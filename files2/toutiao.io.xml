<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>1e22e4414b07b7f0d29b33c0799106a1</guid>
<title>2022 年别再焦虑啦！加入我们！</title>
<link>https://toutiao.io/k/obimloc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                              &lt;strong class=&quot;profile_nickname&quot;&gt;开发者头条&lt;/strong&gt;
                              &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;kaifazhetoutiao&lt;/span&gt;
                              &lt;/p&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;程序员分享平台 | 官方应用下载地址：http://toutiao.io/download&lt;/span&gt;
                              &lt;/p&gt;
                              
                          &lt;/div&gt;
                          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2aa0d8d3970d4f13536c35303c1ed0a5</guid>
<title>深度剖析 Seata TCC 模式</title>
<link>https://toutiao.io/k/usoli0i</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;什么是 TCC&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;TCC 是分布式事务中的二阶段提交协议，它的全称为 Try-Confirm-Cancel，即资源预留（Try）、确认操作（Confirm）、取消操作（Cancel），他们的具体含义如下：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Try：对业务资源的检查并预留；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Confirm：对业务处理进行提交，即 commit 操作，只要 Try 成功，那么该步骤一定成功；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Cancel：对业务处理进行取消，即回滚操作，该步骤回对 Try 预留的资源进行释放。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;TCC 是一种侵入式的分布式事务解决方案，以上三个操作都需要业务系统自行实现，对业务系统有着非常大的入侵性，设计相对复杂，但优点是 TCC 完全不依赖数据库，能够实现跨数据库、跨应用资源管理，对这些不同数据访问通过侵入式的编码方式实现一个原子操作，更好地解决了在各种复杂业务场景下的分布式事务问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7768924302788844&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4MfwdbrwE6d4mBXw77t7OtKMBVRlRBbl9iatc1Cuh6qWgTib3aicMGFkfHFULpKNYeRjLJeqWIUiaCUv6MIge8TQXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1004&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;Seata TCC 模式&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Seata TCC 模式跟通用型 TCC 模式原理一致，我们先来使用 Seata TCC 模式实现一个分布式事务：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;假设现有一个业务需要同时使用服务 A 和服务 B 完成一个事务操作，我们在服务 A 定义该服务的一个 TCC 接口：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;同样，在服务 B 定义该服务的一个 TCC 接口：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;TccActionTwo&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@TwoPhaseBusinessAction&lt;/span&gt;(name = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;DubboTccActionTwo&quot;&lt;/span&gt;, commitMethod = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;commit&quot;&lt;/span&gt;, rollbackMethod = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;rollback&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;prepare&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(BusinessActionContext actionContext, @BusinessActionContextParameter(paramName = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;b&quot;&lt;/span&gt;)&lt;/span&gt; String b)&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;commit&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(BusinessActionContext actionContext)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;rollback&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(BusinessActionContext actionContext)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;span/&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在业务所在系统中开启全局事务并执行服务 A 和服务 B 的 TCC 预留资源方法：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@GlobalTransactional&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; doTransactionCommit() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    tccActionOne.prepare(&lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;one&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    tccActionTwo.prepare(&lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;two&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;span/&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以上就是使用 Seata TCC 模式实现一个全局事务的例子，可以看出，TCC 模式同样使用 @GlobalTransactional 注解开启全局事务，而服务 A 和服务 B 的 TCC 接口为事务参与者，Seata 会把一个 TCC 接口当成一个 Resource，也叫 TCC Resource。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;TCC 接口可以是 RPC，也可以是 JVM 内部调用，意味着一个 TCC 接口，会有发起方和调用方两个身份，以上例子，TCC 接口在服务 A 和服务 B 中是发起方，在业务所在系统中是调用方。如果该 TCC 接口为 Dubbo RPC，那么调用方就是一个 dubbo:reference，发起方则是一个 dubbo:service。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8055555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4MfwdbrwE6d4mBXw77t7OtKMBVRlRBblib91IzAYbpYyyUcn2rMdPxmxAkvYicApr9jIiaAicCPTHNw4r2pw8VKcnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1440&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Seata 启动时会对 TCC 接口进行扫描并解析，如果 TCC 接口是一个发布方，则在 Seata 启动时会向 TC 注册 TCC Resource，每个 TCC Resource 都有一个资源 ID；如果 TCC 接口时一个调用方，Seata 代理调用方，与 AT 模式一样，代理会拦截 TCC 接口的调用，即每次调用 Try 方法，会向 TC 注册一个分支事务，接着才执行原来的 RPC 调用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当全局事务决议提交/回滚时，TC 会通过分支注册的的资源 ID 回调到对应参与者服务中执行 TCC Resource 的 Confirm/Cancel 方法。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;Seata 如何实现 TCC 模式&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从上面的 Seata TCC 模型可以看出，TCC 模式在 Seata 中也是遵循 TC、TM、RM 三种角色模型的，如何在这三种角色模型中实现 TCC 模式呢？我将其主要实现归纳为资源解析、资源管理、事务处理。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;资源解析&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;资源解析即是把 TCC 接口进行解析并注册，前面说过，TCC 接口可以是 PRC，也可以是 JVM 内部调用，在 Seata TCC 模块中中一个 remoting 模块，该模块专门用于解析具有 TwoPhaseBusinessAction 注解的 TCC 接口资源：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8501742160278746&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4MfwdbrwE6d4mBXw77t7OtKMBVRlRBblxIvRqlftiaiacrEPl5pEpnqIokjUia87qlp43aZm2TXupVBPXvibdV38Jg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;574&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;RemotingParser 接口主要有 isRemoting、isReference、isService、getServiceDesc 等方法，默认的实现为 DefaultRemotingParser，其余各自的 RPC 协议解析类都在 DefaultRemotingParser 中执行，Seata 目前已经实现了对 Dubbo、HSF、SofaRpc、LocalTCC 的 RPC 协议的解析，同时具备 SPI 可扩展性，未来欢迎大家为 Seata 提供更多的 RPC 协议解析类。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 Seata 启动过程中，有个 GlobalTransactionScanner 注解进行扫描，会执行以下方法：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;io.seata.spring.util.TCCBeanParserUtils#isTccAutoProxy&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;该方法目的是判断 bean 是否已被 TCC 代理，在过程中会先判断 bean 是否是一个 Remoting bean，如果是则调用 getServiceDesc 方法对 remoting bean 进行解析，同时判断如果是一个发起方，则对其进行资源注册：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;io.seata.rm.tcc.remoting.parser.DefaultRemotingParser#parserRemotingServiceInfo&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; RemotingDesc parserRemotingServiceInfo(Object bean, String beanName, RemotingParser remotingParser) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    RemotingDesc remotingBeanDesc = remotingParser.getServiceDesc(bean, beanName);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (remotingBeanDesc == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    remotingServiceMap.put(beanName, remotingBeanDesc);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Class&amp;lt;?&amp;gt; interfaceClass = remotingBeanDesc.getInterfaceClass();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Method[] methods = interfaceClass.getMethods();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (remotingParser.isService(bean, beanName)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            Object targetBean = remotingBeanDesc.getTargetBean();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (Method m : methods) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                TwoPhaseBusinessAction twoPhaseBusinessAction = m.getAnnotation(TwoPhaseBusinessAction.&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (twoPhaseBusinessAction != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    TCCResource tccResource = new TCCResource();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    tccResource.setActionName(twoPhaseBusinessAction.name());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    tccResource.setTargetBean(targetBean);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    tccResource.setPrepareMethod(m);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    tccResource.setCommitMethodName(twoPhaseBusinessAction.commitMethod());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    tccResource.setCommitMethod(interfaceClass.getMethod(twoPhaseBusinessAction.commitMethod(),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                                                         twoPhaseBusinessAction.commitArgsClasses()));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    tccResource.setRollbackMethodName(twoPhaseBusinessAction.rollbackMethod());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    tccResource.setRollbackMethod(interfaceClass.getMethod(twoPhaseBusinessAction.rollbackMethod(),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                                                           twoPhaseBusinessAction.rollbackArgsClasses()));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    tccResource.setCommitArgsClasses(twoPhaseBusinessAction.commitArgsClasses());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    tccResource.setRollbackArgsClasses(twoPhaseBusinessAction.rollbackArgsClasses());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    tccResource.setPhaseTwoCommitKeys(&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;.getTwoPhaseArgs(tccResource.getCommitMethod(),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                                                           twoPhaseBusinessAction.commitArgsClasses()));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    tccResource.setPhaseTwoRollbackKeys(&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;.getTwoPhaseArgs(tccResource.getRollbackMethod(),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                                                             twoPhaseBusinessAction.rollbackArgsClasses()));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    DefaultResourceManager.&lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt;().registerResource(tccResource);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (Throwable t) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;throw&lt;/span&gt; new FrameworkException(t, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;parser remoting service error&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (remotingParser.isReference(bean, beanName)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        remotingBeanDesc.setReference(&lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; remotingBeanDesc;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;span/&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以上方法，先调用解析类 getServiceDesc 方法对 remoting bean 进行解析，并将解析后的 remotingBeanDesc 放入 本地缓存 remotingServiceMap 中，同时调用解析类 isService 方法判断是否为发起方，如果是发起方，则解析 TwoPhaseBusinessAction 注解内容生成一个 TCCResource，并对其进行资源注册。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;资源管理&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;1、资源注册&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Seata TCC 模式的资源叫 TCCResource，其资源管理器叫 TCCResourceManager，前面讲过，当解析完 TCC 接口 RPC 资源后，如果是发起方，则会对其进行资源注册：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;io.seata.rm.tcc.TCCResourceManager#registerResource&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;registerResource&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(Resource resource)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    TCCResource tccResource = (TCCResource)resource;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    tccResourceCache.put(tccResource.getResourceId(), tccResource);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;super&lt;/span&gt;.registerResource(tccResource);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;span/&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;TCCResource 包含了 TCC 接口的相关信息，同时会在本地进行缓存。继续调用父类 registerResource 方法（封装了通信方法）向 TC 注册，TCC 资源的 resourceId 是 actionName，actionName 就是 @TwoParseBusinessAction 注解中的 name。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;2、资源提交/回滚&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;io.seata.rm.tcc.TCCResourceManager#branchCommit&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; BranchStatus branchCommit(BranchType branchType, &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; xid, long branchId, &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; resourceId,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                 &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; applicationData) throws TransactionException {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    TCCResource tccResource = (TCCResource)tccResourceCache.get(resourceId);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (tccResource == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ShouldNeverHappenException(&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt;.format(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;TCC resource is not exist, resourceId: %s&quot;&lt;/span&gt;, resourceId));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt; targetTCCBean = tccResource.getTargetBean();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Method commitMethod = tccResource.getCommitMethod();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (targetTCCBean == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt; || commitMethod == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ShouldNeverHappenException(&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt;.format(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;TCC resource is not available, resourceId: %s&quot;&lt;/span&gt;, resourceId));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        BusinessActionContext businessActionContext = getBusinessActionContext(xid, branchId, resourceId,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                                                               applicationData);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        ret = commitMethod.invoke(targetTCCBean, args);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; result ? BranchStatus.PhaseTwo_Committed : BranchStatus.PhaseTwo_CommitFailed_Retryable;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (Throwable t) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; msg = &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt;.format(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;commit TCC resource error, resourceId: %s, xid: %s.&quot;&lt;/span&gt;, resourceId, xid);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        LOGGER.error(msg, t);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; BranchStatus.PhaseTwo_CommitFailed_Retryable;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当 TM 决议二阶段提交，TC 会通过分支注册的的资源 ID 回调到对应参与者（即 TCC 接口发起方）服务中执行 TCC Resource 的 Confirm/Cancel 方法。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;资源管理器中会根据 resourceId 在本地缓存找到对应的 TCCResource，同时根据 xid、branchId、resourceId、applicationData 找到对应的 BusinessActionContext 上下文，执行的参数就在上下文中。最后，执行 TCCResource 中获取 commit 的方法进行二阶段提交。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;二阶段回滚同理类似。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;事务处理&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前面讲过，如果 TCC 接口时一个调用方，则会使用 Seata TCC 代理对调用方进行拦截处理，并在处理调用真正的 RPC 方法前对分支进行注册。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;执行方法 io.seata.spring.util.TCCBeanParserUtils#isTccAutoProxy 除了对 TCC 接口资源进行解析，还会判断 TCC 接口是否为调用方，如果是调用方则返回 true：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;io.seata.spring.annotation.GlobalTransactionScanner#wrapIfNecessary&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1905940594059406&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4MfwdbrwE6d4mBXw77t7OtKMBVRlRBblNdcVQC7ZQTVyUBvWK2qQYJ2mXib19r6h7hn3ERdbkMibZOVBicMcMZhGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2424&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如图，当 GlobalTransactionalScanner 扫描到 TCC 接口调用方（Reference）时，会使 TccActionInterceptor 对其进行代理拦截处理，TccActionInterceptor 实现 MethodInterceptor。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 TccActionInterceptor 中还会调用 ActionInterceptorHandler 类型执行拦截处理逻辑，事务相关处理就在 ActionInterceptorHandler#proceed 方法中：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt; proceed(Method method, &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;[] &lt;span class=&quot;code-snippet__built_in&quot;&gt;arguments&lt;/span&gt;, &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; xid, TwoPhaseBusinessAction businessAction,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                      Callback&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt; targetCallback) throws Throwable {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    BusinessActionContext actionContext = getOrCreateActionContextAndResetToArguments(method.getParameterTypes(), &lt;span class=&quot;code-snippet__built_in&quot;&gt;arguments&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; branchId = doTccActionLogStore(method, &lt;span class=&quot;code-snippet__built_in&quot;&gt;arguments&lt;/span&gt;, businessAction, actionContext);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; { &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; targetCallback.execute();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;finally&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            BusinessActionContextUtil.reportContext(actionContext);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;finally&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以上，在执行 TCC 接口一阶段之前，会调用 doTccActionLogStore 方法分支注册，同时还会将 TCC 相关信息比如参数放置在上下文，上面讲的资源提交/回滚就会用到这个上下文。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;如何控制异常&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 TCC 模型执行的过程中，还可能会出现各种异常，其中最为常见的有空回滚、幂等、悬挂等。下面我讲下 Seata 是如何处理这三种异常的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;如何处理空回滚&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;什么是空回滚？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;空回滚指的是在一个分布式事务中，在没有调用参与方的 Try 方法的情况下，TM 驱动二阶段回滚调用了参与方的 Cancel 方法。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么空回滚是如何产生的呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7925824175824175&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4MfwdbrwE6d4mBXw77t7OtKMBVRlRBblb5C8gBNTaD94MDQZanBsvUPvicnibaQ7jb9cic8ibYzsnBWeUiciaFib21HzA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1456&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如上图所示，全局事务开启后，参与者 A 分支注册完成之后会执行参与者一阶段 RPC 方法，如果此时参与者 A 所在的机器发生宕机，网络异常，都会造成 RPC 调用失败，即参与者 A 一阶段方法未成功执行，但是此时全局事务已经开启，Seata 必须要推进到终态，在全局事务回滚时会调用参与者 A 的 Cancel 方法，从而造成空回滚。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;要想防止空回滚，那么必须在 Cancel 方法中识别这是一个空回滚，Seata 是如何做的呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Seata 的做法是新增一个 TCC 事务控制表，包含事务的 XID 和 BranchID 信息，在 Try 方法执行时插入一条记录，表示一阶段执行了，执行 Cancel 方法时读取这条记录，如果记录不存在，说明 Try 方法没有执行。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;如何处理幂等&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;幂等问题指的是 TC 重复进行二阶段提交，因此 Confirm/Cancel 接口需要支持幂等处理，即不会产生资源重复提交或者重复释放。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么幂等问题是如何产生的呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7977839335180056&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4MfwdbrwE6d4mBXw77t7OtKMBVRlRBbl7JzkibThAicvzkwwShb0DkaCGBKXY4hvEF7UlwOAhVjAfkrWwvOl4xBQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1444&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如上图所示，参与者 A 执行完二阶段之后，由于网络抖动或者宕机问题，会造成 TC 收不到参与者 A 执行二阶段的返回结果，TC 会重复发起调用，直到二阶段执行结果成功。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Seata 是如何处理幂等问题的呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;同样的也是在 TCC 事务控制表中增加一个记录状态的字段 status，该字段有有 3 个值，分别为：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;tried：1&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;committed：2&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;rollbacked：3&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;二阶段 Confirm/Cancel 方法执行后，将状态改为 committed 或 rollbacked 状态。当重复调用二阶段 Confirm/Cancel 方法时，判断事务状态即可解决幂等问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;如何处理悬挂&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;悬挂指的是二阶段 Cancel 方法比 一阶段 Try 方法优先执行，由于允许空回滚的原因，在执行完二阶段 Cancel 方法之后直接空回滚返回成功，此时全局事务已结束，但是由于 Try 方法随后执行，这就会造成一阶段 Try 方法预留的资源永远无法提交和释放了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么悬挂是如何产生的呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7988980716253443&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4MfwdbrwE6d4mBXw77t7OtKMBVRlRBblFPZGKcAX6icRxb2NNicibataztZkSxDuaKywrgkWFNb8aOL6DdKEGXKQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1452&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如上图所示，在执行参与者 A 的一阶段 Try 方法时，出现网路拥堵，由于 Seata 全局事务有超时限制，执行 Try 方法超时后，TM 决议全局回滚，回滚完成后如果此时 RPC 请求才到达参与者 A，执行 Try 方法进行资源预留，从而造成悬挂。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Seata 是怎么处理悬挂的呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 TCC 事务控制表记录状态的字段 status 中增加一个状态：&lt;/span&gt;&lt;span&gt;suspended：&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当执行二阶段 Cancel 方法时，如果发现 TCC 事务控制表有相关记录，说明二阶段 Cancel 方法优先一阶段 Try 方法执行，因此插入一条 status=4 状态的记录，当一阶段 Try 方法后面执行时，判断 status=4 ，则说明有二阶段 Cancel 已执行，并返回 false 以阻止一阶段 Try 方法执行成功。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>78da6ae5067e8c9dc1298f8faaf612c4</guid>
<title>从数据库评估差异，看全球化长期主义之路</title>
<link>https://toutiao.io/k/r980b51</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;89204&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;&lt;span&gt;2. 从数据库评估方式看发展差异&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;正如前面所讲，近些年来国内外数据库行业发展迅猛，有越来越多企业、资本、人才投入其中。那么在火热的发展浪潮中，如何对行业、企业、产品、技术有个理性的评估，就至关重要。这不仅有利于数据库厂商预判行业趋势、企业发展定位、产品演进路径、技术发力方向，也有利于广大数据库从业者做出符合自己的发展之路。在这方面，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;国内外有很多机构、组织有着自己的评估方式，而且国内外的评估差异也非常明显&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。下面就谈谈对国内外对数据库评估差异的个人理解。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1).海外评估&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;在海外对数据库的评估，已经有较为成熟的实践。有很多公司、组织或科研机构参与到数据库的评估之中。这里可大致分为三类：一是以 Gartner、Forrester、IDC 为代表的 IT 研究与评估机构，它们会定期发布数据库领域的研究报告；二是以 DB-Engines 为代表的第三方组织，会持续更新排名全球数据库发展现状。三是以卡内基梅隆大学为代表的科研机构，会收录全球数据库信息供学术分析；上述三类公司或组织，其评估角度各有不同，但其合集基本覆盖了从数据库技术、产品、生态、商业等多个侧面。下面详细展开说明下：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;p data-brushtype=&quot;text&quot; hm_fix=&quot;261:273&quot;&gt;&lt;strong&gt;&lt;span&gt; IT研究与评估机构代表：Gartner&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.002439024390244&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xZOm0XATx0WZ7nrYHEteSXSogm0F0ibHm5dHXOXhy9Ciafn2b8V8g4XXGkoapciaJrR8I5cSHsdSyqtNJSptqAbYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;820&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Gartner，是全球最具权威的 IT 研究与顾问咨询公司，成立于 1979 年，总部设在美国康涅狄克州斯坦福，其研究范围覆盖全部 IT 产业。其在 2006 年提出魔力象限模型，用以描述特定领域全球最权威和最具影响力的厂商综合能力评估报告，是头部厂商产品能力的对标。一般情况下，企业 IT 决策者可通过这一分析报告甄别厂商能力，为采购、招标等提供一定的依据佐证。其评选标准包括全球市场份额、产品能力、客户反馈等。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Gartner 魔力象限的评估标准，也是在与时俱进、不断调整。早前 Gartner 主要是根据产品营收选取前 20 个厂商进入年度的云数据库市场的魔力象限，2021 年的评估标准中移除了这一限制，而是采用一种 Market Momentum Index（市场动向指数）来评估，旨在让受到用户欢迎的中小数据库企业有机会入选。于是我们在 2021 年的魔力象限中看到，诸如 SingleStore、Couchbase、Exasol、MariaDB、Cockroach Labs 等数据库新势力首次上榜。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2021 年中国数据库厂商阿里云（Alibaba Cloud）再次进入领导者象限，华为云（HUAWEI CLOUD）进入特定领域者象限（NICHE PLAYERS），是国内入选的仅有两家企业。2020 年还在魔力象限的腾讯云数据库此次缺席，席位被北美的新势力独角兽占据。可见中国数据库厂商由于多数局限在中国市场还未能获得 Gartner 的足够重视，根据非正式渠道得知 Gartner，Forrester，IDC 等三大分析机构已经注意到中国数据库市场的快速发展，将在未来 3-5 年单独强化对中国数据库市场和数据库厂商的评估，包括中国新锐数据库厂商在全球市场的表现。在全球市场的表现，始终是数据库厂商证明自己技术领先性的关键战场。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面我们来看 Gartner 具体在市场动向指数上，统计主要来自哪些方向：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了上述在市场动向指数方面进入 Top 20 之外，还有几个必须满足的条件：至少满足 Gartner 定义的 7 个 Use Case 中的 3 个（Traditional transactions，Traditional data warehouse，Logical data warehouse，Augmented transaction processing，Event stream processing，Data science exploration/deep learning，Operational intelligence ）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;p data-brushtype=&quot;text&quot; hm_fix=&quot;261:273&quot;&gt;&lt;strong&gt;&lt;span&gt; 第三方机构代表：DB-Engine 数据流行度评估&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;DB-Engine Overall Ranking （2022 年 1 月）&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3463541666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xZOm0XATx0WZ7nrYHEteSXSogm0F0ibHm08Os28rklwg4kcLk3TYkKPUZ8ESh3EK6UA7CzInA5JiciaeGPccibPiaHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1536&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;前十位的数据库，有六个是开源的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1504424778761062&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xZOm0XATx0WZ7nrYHEteSXSogm0F0ibHmTVaphpPaoNGokzeXQUenRzIKUMDrKeOOGD7XWCXcZiaclvxNQRPzic0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;904&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;DB-Engines 由于主要统计海外市场的信息，可以看到，在前 100 名关系型数据库厂商里面，仅有 TiDB 和阿里云的两个产品入围。这从侧面也反映了纯海外市场中国数据库综合影响力和中国市场有很大差异。DB-Engines 是由三方机构维护的，收录全球数据库信息，并按照活跃度给予排名。其排名的数据主要来自下面五种因素：&lt;/span&gt;&lt;/section&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Google 及 Bing 搜索引擎的关键字搜索数量；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Google Trends 的搜索数量；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Indeed 网站中的职位搜索量；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;LinkedIn 中提到关键字的个人资料数；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Stackoverflow 上相关的问题和关注者数。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;参考: https://db-engines.com/en/ranking&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;p data-brushtype=&quot;text&quot; hm_fix=&quot;261:273&quot;&gt;&lt;strong&gt;&lt;span&gt; 科研机构代表：dbdb.io（卡内基梅隆大学）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4829482948294829&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xZOm0XATx0WZ7nrYHEteSXSogm0F0ibHmbDk3kRKXnNDmrh1DH81eZlbYaMK8qVOtjxq6EU1fBvJibAEH6oOdnfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1818&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;dbdb.io，是卡内基梅隆大学维护的全球数据库信息库，其中收录了全球 700 多种数据库产品，其包含数据库的开发者、国家、起始年份、项目类型、开发语言、衍生来源、兼容性、适配系统、开源协议等多种信息。除上述信息外，还包括最近更新、浏览、修改等方面的统计，可以间接反映出数据库产品的活跃程度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上述三类评估者，可以说覆盖从技术、产品、生态、商业多角度，可以全方位地了解。但上述这些平台，大家经常访问会有个发现，中国数据库厂商及产品非常少。以 Gartner 为例，在 2021 年的报告中，仅收录了阿里、华为两家中国厂商。其背后原因还是Gartner更加注重商业部分，而国内企业出海不多，而对国内市场的情况海外研究机构又了解有限。而从 DB-Engines 来看，前 100 名仅仅有 PingCAP，阿里两家中国公司，DB- Engine 更多信息也是来自海外的搜索、社交媒体，招聘、论坛类信息，缺少对中国境内的搜索，社交媒体，论坛等信息，三个机构都只能以中国数据库厂商的海外影响力为主，也提示中国数据库厂商应该放眼海外，避免内卷。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2).国内评估&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;从国内情况来看，长期以来一直缺乏对数据库的评估体系。之前也曾有过信创目录等政策引导性评估，但其更多是作为政府采购决策参考，公众参与度、认知度不高。不过值得欣喜的是，国内已经有三方机构主动担负其这一职能，希望从更多角度对国内产品做了全面的评估。这一机构就是墨天轮，其维护的墨天轮数据库排行榜，以月为周期多角度评估国内数据库并加以排名。就在不久前，其还发布墨天轮魔力象限，仿照 Gartner 做法来做象限分析。可以说墨天轮社区填补国内这一领域空白，为其点赞。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.46033057851239667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xZOm0XATx0WZ7nrYHEteSXSogm0F0ibHmpnxk0AyBaOCCCoEDHCJy95anua9nvAUIC5TEGhjcqFNKTiaFGXNIesA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1210&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;从 2021 年的最终排名看，PingCAP 作为开源分布式领导者连续 24 个月领先，但其领先优势开始受到华为 openGauss 数据库的挑战，老牌国产数据库达梦稳居第三，新晋开源的 OceanBase 也进入前五。当把这个前十位的名单与前面海外三类机构的名单比较时，会发现墨天轮的排行主要还是以中国数据库厂商在本土市场的表现为主。从评估维度来看，墨天轮社区在不断改进，其评估指标已较为全面。其排名因素包括如下：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n64&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;搜索引擎：引入百度、必应、谷歌以及微信公众号文章（搜狗）当月搜索条目数，每个搜索引擎权重不同，如百度、公众号文章较高，最后按整体占比计算得分。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;趋势指数：引入百度指数、360 趋势数据，通过搜索数据库关键字得到当月指数或趋势，计算得到每个数据库的平均指数，最后按整体占比计算得分。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;三方评测：引入了包括信通院大数据产品能力评测、电信行业能力评测、TPC 组织评测等，旨在体现数据库产品在特定场景下的基准达标，以及性能和稳定性。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;生态：引入生态体系指标，包含社区平台、高校合作、培训认证、开放文档、代码开源、介质下载共六个维度，以体现厂商对数据库产品的可持续发展战略，开放开源、人才培养和共建行业的理念。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;专利数：专利是自主可控的重要体现，这一指标指厂商在国家或国际平台上可以公开查询的专利数，以体现数据库产品的创新能力。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;论文数：论文指厂商在国际数据库顶会、国际论坛、国际期刊发表的论文，以体现厂商在前沿技术、学术领域的成就。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;招聘岗位数：引入 51JOB 相关招聘数据，根据数据库关键字搜索出每个数据库的岗位数量，体现企业对该数据库人才的需求热度，最后按整体占比计算得分。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;书籍：引入当当网相关书籍数据，根据数据库关键字搜索出每个数据库的书籍数量，最后按整体占比计算得分。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;DB-Engines 上榜指数：指数据库产品在 DB-Engines 上榜，按排名先后依次降档得分。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Gartner 市场份额排行及魔力象限：根据 Gartner 发布的最新市场份额排名先后依次降档得分，最新的魔力象限统一得分。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;IDC 市场份额排行：根据 IDC 发布的最新市场份额排名先后依次降档得分。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;89204&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;&lt;span&gt;3. 数据库评估体系的全球化之路&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;从上述分析来看，海外与国内的数据库评估体系存在明显的割裂现象。海外评估体系，虽然较为全面，但对中国数据库厂商及产品涉及很少，了解很浅。究其原因，其一是由于海外对中国市场的重视程度不足，对中国的很多情况也不甚了解；二是由于大多数中国数据库厂商以中国市场为主，与海外评估机构在商业、技术生态上均存在较大距离；三则是语言、文化等因素，也在一定程度上妨碍了双方的了解。从国内的评估体系来看，起步较晚，发展势头不错，但同样存在类似问题。目前国内的评估体系中，均不包含海外产品，（甚至开源也不包含），其次针对国内产品受限于调查者身份，也很难深入到商业部分，甚至直达客户侧，同时也缺少对中国数据库厂商全球影响力的关注和解读。在技术趋势上，国内机构关注 OLTP，OLAP 等传统领域评估更多，而对云数据库、开源、数仓，AI 与自动化等数据库创新趋势相对较少。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;近些年来，国内数据库产业发展迅速，无论从技术、产品到资本层面，越来越多的厂商产品受到海外的关注。一些国际权威的评估机构已考虑为中国数据库独立评测，这也侧面验证了海外对中国数据库厂商的重视。国内数据库行业已逐渐从跟随者、参与者，向局部引领者角色转变。如何参与到全球化进程中，如何共享全球技术生态，如何发挥全球影响力，如何在全球商业布局等，未来都会成为中国数据库厂商需要面对的问题。从全球及国内来看，数据库行业各种势力正在加速洗牌。相较于海外四五十年的数据库发展来说，国内的数据库厂商还稍显稚嫩。但中国数据库厂商正赶上数据库产业变革的重大机遇期，借助开源和云计算，中国数据库有机会在全球市场占据一席之地。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;数据库评估体系同样需要与时俱进，海外评估机构会更多关注到国内的同时，国内评估机构也可以全球化技术视野和创新模式来看待数据库未来的发展。&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;通过更多元的、更为创新的评估体系把握产业发展脉络，把握时代机遇，促进行业健康发展，最终也让中国的广大数据库企业用户受益。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.959375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/UpAsF3LicVxrIicia05puxLBia4Mjcs7icOXB056ZQLQpEFvQic4hBUsOQ5leb4R7qKUgag7YEKf9HpC6GMcjfGxcibNA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>39538a6bb8efdbdaf94656a49ac058f9</guid>
<title>虚数有物理意义：中科大潘建伟、南科大范靖云团队首次实验排除实数形式的标准量子力学</title>
<link>https://toutiao.io/k/d290ffc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-mpa-powered-by=&quot;yiban.io&quot; data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; data-style=&quot;white-space: normal; max-width: 100%; letter-spacing: 0.544px; text-size-adjust: auto; background-color: rgb(255, 255, 255); font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__0&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-id=&quot;85660&quot; data-custom=&quot;rgb(117, 117, 118)&quot; data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-id=&quot;85660&quot; data-custom=&quot;rgb(117, 117, 118)&quot; data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; data-style=&quot;margin-top: 2em; padding-top: 0.5em; padding-bottom: 0.5em; max-width: 100%; border-style: solid none; text-decoration: inherit; border-top-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-top-width: 1px; border-bottom-width: 1px; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__1&quot;&gt;&lt;section&gt;&lt;span&gt;机器之心报道&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;编辑：泽南、小舟&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;blockquote data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;136&quot; data-source-title=&quot;&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;量子力学的理论能否只用实数构造？从理论上和实践上，研究人员都得出了否定的答案。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虽然在高中数学里，大家都接触过虚数这个概念，但它看起来总是那么反直觉：虚数这个名词是 17 世纪数学家笛卡尔提出的，因为当时的观念认为这不是真实存在的数字，其性质被定义为：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicvJxpNs4WW5SJyiafXpnBLrPuBTJQCxF7IF9RB4SsugqPs5m1WAguGGjatic1FUfMBB42ibU755a3Jg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是现如今，为了从根本上描述物质，虚数被证明是必不可少的。它们似乎融入了量子力学的结构，后者是描述分子、原子和亚原子粒子领域的基础理论。最近的两项新实验表明，遵循量子物理学规则的理论需要虚数来描述现实世界。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虚数由负数的平方根产生。它们经常作为数学工具出现在方程式中，以使计算更容易。但是我们可以实际测量的，关于世界的一切都是用实数来描述的，我们也习惯于正常的、非虚的数字。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在量子物理的范畴中其实也是如此。尽管虚数出现在理论的内部运作中，但所有可能的测量都会产生实数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虚数 i 是薛定谔方程必不可少的常数，由此观之，量子力学必须包含虚数。量子理论对复数（虚数和实数之和）的突出使用令其创始人，包括物理学家艾尔温 · 薛定谔（Erwin Schrödinger）感到不安。「从量子理论的早期开始，复数更多地被视为一种数学便利，而不是基本的构建模块，」南方科技大学的物理学家范靖云说道。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;部分物理学家试图仅使用实数来构建量子理论，而使用称为「实数量子力学」的版本来避免使用虚数。但是如果没有对这些理论进行实验测试，我们无法得知虚数在量子物理学中是否真的必要，或者只是一种有用的计算工具。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一种称为贝尔测量（Bell test）的实验解决了一个不同的量子难题，证明量子力学确实需要粒子之间的奇怪量子联系，也就是量子纠缠。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;要了解标准量子理论和类似实数理论之间的区别，你可以思考限制在两个不同位置上的电子。在量子理论中，电子可以处于两个位置的「叠加」中——既不在这个位置，也不是在另一个位置，被观测到在哪只看概率。这种叠加被表示为包含两个维度的抽象空间中的一个点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但这不是普通的空间，也不容易想象。抽象空间中的每个维度都通过一个复数与现实世界中的一个位置相关联，该复数可用于计算在该位置找到电子的概率。随着电子的状态随时间变化，该点在抽象空间中移动。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.563&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/KmXPKA19gWicvJxpNs4WW5SJyiafXpnBLrBfsJ7tWN2BiaVnkRtcATwic1sxxw41lfjhskx7Tn6ATvqh0BSo39ISibQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;具有两个真实维度的类比空间不足以捕捉该电子可以表现出的所有现象，因为它无法编码两个位置的所有可能叠加。然而，具有四个真实维度的空间能够完整指出电子行为的全部范围。这个事实可以概括为：任何单个量子系统的量子物理学都可以在一个真实空间中完全表示，该真实空间的维度数恰好是其抽象空间的两倍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;维也纳量子光学和信息研究所的理论物理学家 Miguel Navascués 表示：「我们已开始思考这种实验是否也能反驳实数量子力学。」他和来自奥地利、西班牙和瑞士等国家的科学家在 12 月 15 日发表于《自然》杂志的论文《Quantum theory based on real numbers can be experimentally falsified》中制定了一项实验计划。该论文的一作是量子信息科学的理论物理学家 Marc-Olivier Renou。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;论文链接：https://www.nature.com/articles/s41586-021-04160-4&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在实验计划中，研究人员将从两个不同的来源发送成对的纠缠粒子给三个不同的人，根据传统的物理术语命名为 Alice、Bob 和 Charlie。Alice 接收到一个粒子，并且可以使用她选择的各种设置对其进行测量，Charlie 也这样做。Bob 接收到两个粒子并执行一种特殊类型的测量来纠缠 Alice 和 Charlie 接收到的粒子。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;没有虚数的实数量子理论将预测与标准量子物理学不同的结果，从而使实验能够区分哪个是正确的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7328699106256207&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicvJxpNs4WW5SJyiafXpnBLrR7AJGpChFT5VVOfkUr9RMNFHwGuwibULwzWU0eicULTCFtUicvsmeXa1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1007&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;分离实数量子理论和复数量子理论的网络场景。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;范靖云及其同事使用光子和光粒子进行了这样的实验，他们在 1 月 24 日发表在物理学顶级期刊《物理评论快报》（Physical Review Letters，PRL）上的论文《Testing Real Quantum Theory in an Optical Quantum Network》中进行了报告。通过将 Alice、Charlie 和 Bob 的结果以多种度量方式进行比较，范靖云、Navascués 及其同事表明这些数据只能用包含复数的量子理论来描述。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.259375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KmXPKA19gWicvJxpNs4WW5SJyiafXpnBLrpIkqt0ctGEHpCuUYzMXYJBM11bb7DwtXicn9kthnRhibyDCFVzNKNj3g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;论文链接：https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.128.040402&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;与此同时，中科大潘建伟团队基于相同的概念，使用由超导体制成的量子计算机进行了一项实验。这项研究也发现量子物理学需要复数，论文《Ruling Out Real-Valued Standard Formalism of Quantum Theory》也在近日的 PRL 上发表。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.26640625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KmXPKA19gWicvJxpNs4WW5SJyiafXpnBLrkcDXtYPOXPhYiasCTSTTlIgByjibia4DuadicNC4EK0JkdE4QCq49V6V0g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;论文链接：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.128.040403&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;潘建伟、陆朝阳、朱晓波等和西班牙塞维利亚大学 Cabello 教授合作，利用超高精度超导量子线路实现确定性纠缠交换，以超过 43 个标准差的实验精度证明了实数无法完整描述标准量子力学，确立了复数的客观实在性。陈明城、王粲和刘丰铭是该论文的共同一作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;中科大在新闻稿中介绍道：随着量子力学理论的发展，复数逐渐表现出某种直觉上的不可排除性。理论上，作为量子力学基石的薛定谔方程和海森堡对易关系其本身就是依赖于复数写出的。而在实验中，人们直接测量到了波函数的实部与虚部。这说明复数可能不是一个主观引入的计算符号，而是可以实验检测的物理实在。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.69453125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicvJxpNs4WW5SJyiafXpnBLrf2CEBuq8uWN9Lfdp5ic1G8Av17N2uRsBThjspuzNo0dDDgb8YGyyIibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;在理论框架下，实数形式的界限为 7.66，而实验测试结果为 8.09，超过判据 43 个标准差。实验结论支持量子物理需要使用复数。&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;中科大表示，该实验证明了实数无法完整描述标准量子力学，确立了复数的客观实在性。该论文的作者之一、中国科学技术大学的量子物理学家陆朝阳说：「我们很好奇为什么复数是必要的，并且在量子力学中发挥着重要作用。」&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 &lt;span&gt;Navascués&lt;/span&gt; 等人的实验方案提出不久后，潘建伟等人使用超导量子电路，范靖云等人使用线性光学，分别验证了理论。但并未参与这项研究的加州劳伦斯伯克利国家实验室的理论物理学家 Jerry Finkelstein 指出：结果并未排除所有避开虚数的理论。该研究只排除了某些基于实数的理论，即那些仍然遵循量子力学惯例的理论。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过使用打破标准量子规则的理论，仍然可以在没有虚数的情况下解释实验结果。然而 Jerry Finkelstein 说：「虽然这些理论遇到一些概念问题时会变得『丑陋』，但如果你愿意忍受『丑陋』，那么你就可以拥有一套实数量子理论。」&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;尽管存在质疑，但许多物理学家一致认为：「复数对于量子理论是必要的」这一新发现令人信服。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;诚如美国国家标准技术研究所的物理学家 Krister Shalm 所说：「当你问量子力学『为什么会这样』时，这就已经很有趣了。而询问『量子理论是否可以更简单』，或者『它是否包含任何不必要的东西』这些都是更加有趣和发人深省的问题。」&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;参考链接：&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://www.sciencenews.org/article/quantum-physics-imaginary-numbers-math-reality&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://www.nature.com/articles/d41586-021-03678-x&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://news.ustc.edu.cn/info/1055/78317.htm&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;1028&quot; data-ratio=&quot;1.77734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicbHHfrYKw4Mswy4xNNmhEwl19xZSzicTNt91J7hZj8O6Tcicj9HIyPydasCuDr7hC6Gq6iaJsDmWEnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;© THE END &lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;转载请联系本公众号获得授权&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;投稿或寻求报道：content@jiqizhixin.com&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>82064c038f5f36a21b78b551db4ba32c</guid>
<title>[推荐] 面试官问：设计高并发系统的时候，数据库层面该如何设计？</title>
<link>https://toutiao.io/k/p935kqr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;h2&gt;题目描述&lt;/h2&gt;

&lt;p&gt;为什么要分库分表（设计高并发系统的时候，数据库层面该如何设计）？&lt;/p&gt;

&lt;p&gt;用过哪些分库分表中间件？不同的分库分表中间件都有什么优点和缺点 ？&lt;/p&gt;

&lt;p&gt;你们具体是如何对数据库如何进行垂直拆分或水平拆分的 ？&lt;/p&gt;

&lt;h2&gt;1.面试题分析&lt;/h2&gt;

&lt;p&gt;其实这块肯定是扯到高并发了，因为分库分表一定是为了支撑高并发、数据量大两个问题的。尤其是互联网类的公司面试，基本上都会来这么一下，分库分表如此普遍的技术问题，不问实在是不行，而如果你不知道那也实在是说不过去！&lt;/p&gt;

&lt;h2&gt;2.面试题剖析&lt;/h2&gt;

&lt;p&gt;为什么要分库分表？（设计高并发系统的时候，数据库层面该如何设计？）
说白了，分库分表是两回事儿，大家可别搞混了，可能是光分库不分表，也可能是光分表不分库，都有可能。我先给大家抛出来一个场景假如我们现在是一个小创业公司（或者是一个 BAT 公司刚兴起的一个新部门），现在注册用户就 20万，每天活跃用户就 1 万，每天单表数据量就 1000 ，然后高峰期每秒钟并发请求最多就 10 个。我的天，就这种系统，随便找一个有几年工作经验的，然后带几个刚培训出来的，随便干干都可以。结果没想到我们运气居然这么好，碰上个 CEO 带着我们走上了康庄大道，业务发展迅猛，过了几个月，注册用户数达到了 2000 万！每天活跃用户数 100 万！每天单表数据量 10 万条！高峰期每秒最大请求达到 1000 ！同时公司还顺带着融资了两轮，进账了几个亿人民币啊！公司估值达到了惊人的几亿美金！这是小独角兽的节奏！
好吧，没事，现在大家感觉压力已经有点大了，为啥呢？因为每天多 10 万条数据，一个月就多 300 万条数据，现在咱们单表已经几百万数据了，马上就破千万了。但是勉强还能撑着。高峰期请求现在是1000 ，咱们线上部署了几台机器，负载均衡搞了一下，数据库撑 1000QPS 也还凑合。但是大家现在开始感觉有点担心了，接下来咋整呢......
   再接下来几个月，我的天，CEO 太牛逼了，公司用户数已经达到 1 亿，公司继续融资几十亿人民币 啊！公司估值达到了惊人的几十亿美金，成为了国内今年最牛逼的明星创业公司！ 但是我们同时也是不幸的，因为此时每天活跃用户数上千万，每天单表新增数据多达 50 万，目前一个表总数据量都已经达到了两三千万了！扛不住啊！数据库磁盘容量不断消耗掉！高峰期并发达到惊人的5000~8000 ！你的系统肯定支撑不到现在，已经挂掉了！好吧，所以你看到这里差不多就理解分库分表是怎么回事儿了，实际上这是跟着你的公司业务发展走 的，你公司业务发展越好，用户就越多，数据量越大，请求量越大，那你单个数据库一定扛不住。&lt;/p&gt;

&lt;h3&gt;分表&lt;/h3&gt;

&lt;p&gt;比如你单表都几千万数据了，你确定你能扛住么？绝对不行，单表数据量太大，会极大影响你的 sql 执
行的性能，到了后面你的 sql 可能就跑的很慢了。一般来说，就以我的经验来看，单表到几百万的时
候，性能就会相对差一些了，你就得分表了。&lt;/p&gt;

&lt;p&gt;分表是啥意思？就是把一个表的数据放到多个表中，然后查询的时候你就查一个表。比如按照用户 id
来分表，将一个用户的数据就放在一个表中。然后操作的时候你对一个用户就操作那个表就好了。这样
可以控制每个表的数据量在可控的范围内，比如每个表就固定在 200 万以内。&lt;/p&gt;

&lt;h3&gt;分库&lt;/h3&gt;

&lt;p&gt;分库是啥意思？就是你一个库一般我们经验而言，最多支撑到并发 2000 ，一定要扩容了，而且一个健 康的单库并发值你最好保持在每秒 1000 左右，不要太大。那么你可以将一个库的数据拆分到多个库中，访问的时候就访问一个库好了。这就是所谓的分库分表，为啥要分库分表？你明白了吧。 分库分表前 分库分表后并发支撑情况 MySQL 单机部署，扛不住高并发 MySQL从单机到多机，能承受的并发增加了多倍 磁盘使用情况 MySQL 单机磁盘容量几乎撑满 拆分为多个库，数据库服务器磁盘使用率大大降低 SQL 执行性能 单表数据量太大，SQL 越跑越慢 单表数据量减少，SQL 执行效率明显提升&lt;/p&gt;

&lt;h3&gt;用过哪些分库分表中间件？不同的分库分表中间件都有什么优点和缺点？&lt;/h3&gt;

&lt;p&gt;这个其实就是看看你了解哪些分库分表的中间件，各个中间件的优缺点是啥？然后你用过哪些分库分表的中间件。&lt;/p&gt;

&lt;h3&gt;比较常见的包括：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Cobar
TDDL
Atlas
Sharding-jdbc
Mycat
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cobar 阿里 b2b 团队开发和开源的，属于 proxy 层方案，就是介于应用服务器和数据库服务器之间。
应用程序通过 JDBC 驱动访问 Cobar 集群，Cobar 根据 SQL 和分库规则对 SQL 做分解，然后分发到
MySQL 集群不同的数据库实例上执行。早些年还可以用，但是最近几年都没更新了，基本没啥人用，
差不多算是被抛弃的状态吧。而且不支持读写分离、存储过程、跨库 join 和分页等操作。&lt;/p&gt;

&lt;p&gt;TDDL 淘宝团队开发的，属于 client 层方案。支持基本的 crud 语法和读写分离，但不支持 join、多表
查询等语法。目前使用的也不多，因为还依赖淘宝的 diamond 配置管理系统。&lt;/p&gt;

&lt;p&gt;Atlas 360 开源的，属于 proxy 层方案，以前是有一些公司在用的，但是确实有一个很大的问题就是社
区最新的维护都在 5 年前了。所以，现在用的公司基本也很少了。&lt;/p&gt;

&lt;p&gt;Sharding-jdbc 当当开源的，属于 client 层方案，是 ShardingSphere 的 client 层方案，
ShardingSphere 还提供 proxy 层的方案 Sharding-Proxy。确实之前用的还比较多一些，因为 SQL 语
法支持也比较多，没有太多限制，而且截至 2019.4，已经推出到了 4.0.0-RC1 版本，支持分库分表、读
写分离、分布式 id 生成、柔性事务（最大努力送达型事务、TCC 事务）。而且确实之前使用的公司会
比较多一些（这个在官网有登记使用的公司，可以看到从 2017 年一直到现在，是有不少公司在用
的），目前社区也还一直在开发和维护，还算是比较活跃，个人认为算是一个现在也可以选择的方案。&lt;/p&gt;

&lt;p&gt;Mycat 基于 Cobar 改造的，属于 proxy 层方案，支持的功能非常完善，而且目前应该是非常火的而且
不断流行的数据库中间件，社区很活跃，也有一些公司开始在用了。但是确实相比于 Sharding jdbc 来
说，年轻一些，经历的锤炼少一些。&lt;/p&gt;

&lt;h2&gt;3.总结&lt;/h2&gt;

&lt;p&gt;综上，现在其实建议考量的，就是 Sharding-jdbc 和 Mycat，这两个都可以去考虑使用。&lt;/p&gt;

&lt;p&gt;Sharding-jdbc 这种 client 层方案的优点在于不用部署，运维成本低，不需要代理层的二次转发请求，
性能很高，但是如果遇到升级啥的需要各个系统都重新升级版本再发布，各个系统都需要耦合
Sharding-jdbc 的依赖；&lt;/p&gt;

&lt;p&gt;Mycat 这种 proxy 层方案的缺点在于需要部署，自己运维一套中间件，运维成本高，但是好处在于对于
各个项目是透明的，如果遇到升级之类的都是自己中间件那里搞就行了。&lt;/p&gt;

&lt;p&gt;通常来说，这两个方案其实都可以选用，但是我个人建议中小型公司选用 Sharding-jdbc，client 层方
案轻便，而且维护成本低，不需要额外增派人手，而且中小型公司系统复杂度会低一些，项目也没那么
多；但是中大型公司最好还是选用 Mycat 这类 proxy 层方案，因为可能大公司系统和项目非常多，团
队很大，人员充足，那么最好是专门弄个人来研究和维护 Mycat，然后大量项目直接透明使用即可。&lt;/p&gt;

&lt;p&gt;你们具体是如何对数据库如何进行垂直拆分或水平拆分的？ 水平拆分的意思，就是把一个表的数据给
弄到多个库的多个表里去，但是每个库的表结构都一样，只不过每个库表放的数据是不同的，所有库表
的数据加起来就是全部数据。水平拆分的意义，就是将数据均匀放更多的库里，然后用多个库来扛更高
的并发，还有就是用多个库的存储容量来进行扩容。&lt;/p&gt;

&lt;p&gt;database-split-horizon&lt;/p&gt;

&lt;p&gt;垂直拆分的意思，就是把一个有很多字段的表给拆分成多个表，或者是多个库上去。每个库表的结构都
不一样，每个库表都包含部分字段。一般来说，会将较少的访问频率很高的字段放到一个表里去，然后
将较多的访问频率很低的字段放到另外一个表里去。因为数据库是有缓存的，你访问频率高的行字段越
少，就可以在缓存里缓存更多的行，性能就越好。这个一般在表层面做的较多一些。&lt;/p&gt;

&lt;p&gt;database-split-vertically&lt;/p&gt;

&lt;p&gt;这个其实挺常见的，不一定我说，大家很多同学可能自己都做过，把一个大表拆开，订单表、订单支付
表、订单商品表。&lt;/p&gt;

&lt;p&gt;还有表层面的拆分，就是分表，将一个表变成 N 个表，就是让每个表的数据量控制在一定范围内，保证
SQL 的性能。否则单表数据量越大，SQL 性能就越差。一般是 200 万行左右，不要太多，但是也得看
具体你怎么操作，也可能是 500 万，或者是 100 万。你的SQL越复杂，就最好让单表行数越少。&lt;/p&gt;

&lt;p&gt;好了，无论分库还是分表，上面说的那些数据库中间件都是可以支持的。就是基本上那些中间件可以做
到你分库分表之后，中间件可以根据你指定的某个字段值，比如说 userid，自动路由到对应的库上去，
然后再自动路由到对应的表里去。你就得考虑一下，你的项目里该如何分库分表？一般来说，垂直拆分，你可以在表层面来做，对一些字段特别多的表做一下拆分；水平拆分，你可以说是并发承载不了，或者是数据量太大，容量承载不了， 你给拆了，按什么字段来拆，你自己想好；分表，你考虑一下，你如果哪怕是拆到每个库里去，并发和容量都 ok 了，但是每个库的表还是太大了，那么你就分表，将这个表分开，保证每个表的数据量并不是很大。&lt;/p&gt;

&lt;p&gt;而且这儿还有两种分库分表的方式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一种是按照 range 来分，就是每个库一段连续的数据，这个一般是按比如时间范围来的，但是这
种一般较少用，因为很容易产生热点问题，大量的流量都打在最新的数据上了。&lt;/li&gt;
&lt;li&gt;或者是按照某个字段 hash 一下均匀分散，这个较为常用。 range 来分，好处在于说，扩容的时
候很简单，因为你只要预备好，给每个月都准备一个库就可以了，到了一个新的月份的时候，自然
而然，就会写新的库了；缺点，但是大部分的请求，都是访问最新的数据。实际生产用 range，要
看场景。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;hash 分发，好处在于说，可以平均分配每个库的数据量和请求压力；坏处在于说扩容起来比较麻烦，
会有一个数据迁移的过程，之前的数据需要重新计算 hash 值重新分配到不同的库或表。&lt;/p&gt;

&lt;h2&gt;温馨提示&lt;/h2&gt;

&lt;p&gt;欢迎大家关注”浅谈架构“ 公众号 获取全套最新大厂面试题及答案(后台私信”面试题“即可)。
截图如下
&lt;img src=&quot;https://img.toutiao.io/attachment/ca268c220adb4437b53985743482f8ae/w600&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>