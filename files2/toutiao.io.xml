<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>11a140c7abc5fd21ec27c9b4d18486e2</guid>
<title>华为天才少年的超迷你机械臂机器人项目开源了！</title>
<link>https://toutiao.io/k/8hzlaun</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;span&gt;我造了一台钢铁侠的机械臂！&lt;/span&gt;&lt;span&gt;https://www.bilibili.com/video/BV12341117rG&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;项目中使用了 OpenHarmony，包括 3D 结构设计文档在内大部分资料会开源，不过因为资料库很庞大需要整理一阵子。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;933&quot; data-ratio=&quot;2.16&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNav8PALbDBZH2T1PhaQoJE7qsNsA5rDia0ibGqs4Q7Bq5nzOK3BQwky5W2txbdRV1wLYlJhXgbNbx6YOQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;以上内容选自「码农周刊 VIP 会员」圈子，每日更新，精彩不断&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;码农周刊是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;码农周刊是一份专为广大程序员、编程爱好者们打造的 IT 技术周刊。每周发送。&lt;br/&gt;2013 年 9 月 12 日创刊至今，已发送 300 多期，订阅用户超 20 万。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;专业、简单、有用&lt;/span&gt;&lt;span&gt;，是我们一直坚持的办刊宗旨。一路走来，我们见证了不少订阅用户从编程新手进阶成了高级程序员、架构师、CTO……&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2020 年 4 月，为了给用户提供更优质的服务，我们推出了「&lt;/span&gt;&lt;span&gt;码农周刊VIP会员&lt;/span&gt;&lt;span&gt;」服务。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你与 BAT 技术大牛，只差一份「码农周刊VIP会员」的距离！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;VIP会员特权&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 52 期码农周刊VIP会员&lt;span&gt;专属邮件周报&lt;/span&gt;，让你及时掌握技术动向；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 只限VIP会员加入的&lt;span&gt;交流圈子&lt;/span&gt;，让你与技术大牛切磋学习；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. VIP会员独享的&lt;span&gt;工作机会&lt;/span&gt;，为你介绍好公司的好机会；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 更多会员特权，持续更新……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如何加入「码农周刊VIP会员」？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1. 微信扫描下方二维码，加入码农周刊VIP会员知识星球。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;促销期间，一年仅需 108 元！平均一天花费不到 3 毛！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;34&quot; data-cropselx2=&quot;356&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;425&quot; data-ratio=&quot;1.0857487922705313&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/t8lpVibticjQ6h6x4EnYInRLic6PibFNWw4zSv28rAxcJu9dumVJF03PwHGOWxOzeJKIsydVa7UJuTo4jOjrct9NZw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;828&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 加入码农周刊VIP会员知识星球后，客服会联系您，请留意知识星球内的私信。&lt;br/&gt;3. 客服向您发送码农周刊VIP会员欢迎邮件，开启您的码农周刊VIP会员之旅。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;心动不如心动，赶快订阅吧！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b7819307fdc2a5679a276940ae18c063</guid>
<title>[推荐] 彻底弄懂 base64 的编码与解码原理</title>
<link>https://toutiao.io/k/21wnwdq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-hnrfcf&quot; options=&quot;[object Object]&quot;&gt;&lt;p/&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0e20bc6a360cb9b403f1efa04a99af31_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;319&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-0e20bc6a360cb9b403f1efa04a99af31_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;319&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-0e20bc6a360cb9b403f1efa04a99af31_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-0e20bc6a360cb9b403f1efa04a99af31_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;&lt;b&gt;背景&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;base64的编码原理网上讲解较多，但解码原理讲解较少，并且没有对其中的内部实现原理进行剖析。想要彻底了解base64的编码与解码原理，请耐心看完此文，你一定会有所收获。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;涉及算法与逻辑运算概念&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在探究base64编码原理和解码原理的过程中，我们首先需要了解下面会用到的算法和逻辑运算的概念，这样才能真正的吃透base64的编码原理和解码原理，体会到其中算法的精妙，甚至是在思考的过程中得到意想不到的收获。不清楚base64编码表和ascII编码表的同学可直接前往文末查看。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;短除法&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;短除法运算方法是先用一个除数除以能被它除尽的一个质数，以此类推，除到商是质数为止。&lt;br/&gt;通过短除法，十进制数可以不断除以2得到多个余数。最后，将余数从下到上进行排列组合，得到二进制数，我们以字符n对应的ascII编码110为例。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;    110 / 2  = 55...0
    55  / 2  = 27...1
    27  / 2  = 13...1
    13  / 2  = 6...1
    6   / 2  = 3...0
    3   / 2  = 1...1
    1   / 2  = 0...1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;将余数从下到上进行排列组合，得到字符n对应的ascII编码110转二进制为1101110，因为一字节对应8位(bit), 所以需要向前补0补足8位，得到01101110。其余字符同理可得。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;按权展开求和&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;按权展开求和, 8位二进制数从右到左，次数是0到7依次递增, 基数*底数次数，从左到右依次累加，相加结果为对应十进制数。我们以二进制数01101110转10进制为例：&lt;/p&gt;&lt;blockquote&gt;(01101110)2 = 0 * 20 + 1 * 21 + 1 * 22 + 1 * 23 + 0 * 24 + 1 * 25 + 1 * 26 + 0 * 27&lt;/blockquote&gt;&lt;h3&gt;&lt;b&gt;位概念&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;二进制数系统中，每个0或1就是一个位(bit，比特)，也叫存储单元，位是数据存储的最小单位。其中8bit就称为一个字节（Byte）。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;移位运算符&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;移位运算符在程序设计中，是位操作运算符的一种。移位运算符可以在二进制的基础上对数字进行平移。按照平移的方向和填充数字的规则分为三种：&amp;lt;&amp;lt;(左移)、&amp;gt;&amp;gt;(带符号右移)和&amp;gt;&amp;gt;&amp;gt;(无符号右移)。我们在base64的编码和解码过程中操作的又是正数，所以仅使用&amp;lt;&amp;lt;(左移)、&amp;gt;&amp;gt;(带符号右移)两种运算符。&lt;/p&gt;&lt;blockquote&gt;1.左移运算：是将一个二进制位的操作数按指定移动的位数向左移动，移出位被丢弃，右边移出的空位一律补0。&lt;br/&gt;2.右移运算：是将一个二进制位的操作数按指定移动的位数向右移动，移出位被丢弃，左边移出的空位一律补0，或者补符号位，这由不同的机器而定。在使用补码作为机器数的机器中，正数的符号位为0，负数的符号位为1。&lt;/blockquote&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;我们用大白话来描述左移位，一共有8个座位，坐了8个人，在8个座位不动的情况下，现在我让这8个人往左挪2个座位，于是最左边的两个人站了起来，没有座位坐，而最右边空出来了两个座位。移位操作就相当于站起来的人出局，留出来的空位补0.&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// 左移
    01101000 &amp;lt;&amp;lt; 2 -&amp;gt; 101000(左侧移出位被丢弃) -&amp;gt; 10100000(右侧空位一律补0)
    // 右移
    01101000 &amp;gt;&amp;gt; 2 -&amp;gt; 011010(右侧移出位被丢弃) -&amp;gt; 00011010(左侧空位一律补0)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;&lt;b&gt;与运算、或运算&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;与运算、或运算都是计算机中一种基本的逻辑运算方式。&lt;/p&gt;&lt;blockquote&gt;1.与运算：符号表示为&amp;amp;。运算规则：两位同时为“1”，结果才为“1”，否则为0&lt;br/&gt;2.或运算：符号表示为｜。运算规则：两位只要有一位为“1”，结果就为“1”，否则为0&lt;/blockquote&gt;&lt;p&gt;&lt;b&gt;什么是base64编码&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Base64编码是将字符串以每3个8比特(bit)的字节子序列拆分成4个6比特(bit)的字节(6比特有效字节，最左边两个永远为0，其实也是8比特的字节)子序列，再将得到的子序列查找Base64的编码索引表，得到对应的字符拼接成新的字符串的一种编码方式。&lt;/p&gt;&lt;p&gt;每3个8比特(bit)的字节子序列拆分成4个6比特(bit)的字节的拆分过程如下图所示：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-eb270dec0d0e62bd02176a571f3f4ae7_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;938&quot; data-rawheight=&quot;72&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-eb270dec0d0e62bd02176a571f3f4ae7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;938&quot; data-rawheight=&quot;72&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-eb270dec0d0e62bd02176a571f3f4ae7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-eb270dec0d0e62bd02176a571f3f4ae7_b.png&quot;/&gt;&lt;/figure&gt;&lt;h3&gt;&lt;b&gt;为什么base64编码后的大小是原来的4/3倍&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;因为6和8的最大公倍数是24，所以3个8比特的字节刚好可以拆分成4个6比特的字节，3&lt;i&gt;8 = 6&lt;/i&gt;4。计算机中，因为一个字节需要8个存储单元存储，所以我们要把6个比特往前面补两位0，补足8个比特。如下图所示：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-32b25ec16c8a06bb3659cbf4a3216624_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;73&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-32b25ec16c8a06bb3659cbf4a3216624_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;73&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-32b25ec16c8a06bb3659cbf4a3216624_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-32b25ec16c8a06bb3659cbf4a3216624_b.png&quot;/&gt;&lt;/figure&gt;&lt;p&gt;很明显，补足后所需的存储单元为32个，是原来所需的24个的4/3倍。现在大家明白为什么base64编码后的大小是原来的4/3倍了吧。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;为什么命名为base64呢？&lt;/b&gt;&lt;/h3&gt;&lt;blockquote&gt;因为6位(bit)的二进制数有2的6次方个,也就是二进制数(00000000-00111111)之间的代表0-63的64个二进制数。&lt;/blockquote&gt;&lt;h3&gt;&lt;b&gt;不是说一个字节是用8位二进制表示的吗，为什么不是2的8次方？&lt;/b&gt;&lt;/h3&gt;&lt;blockquote&gt;因为我们得到的8位二进制数的前两位永远是0，真正的有效位只有6位，所以我们所能够得到的二进制数只有2的6次方个。&lt;/blockquote&gt;&lt;h3&gt;&lt;b&gt;Base64字符是哪64个？&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;Base64的编码索引表，字符选用了&quot;A-Z、a-z、0-9、+、/&quot; 64个可打印字符来代表(00000000-00111111)这64个二进制数。即&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;    let base64EncodeChars = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;编码原理&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们不妨自己先思考一下，要把3个字节拆分成4个字节可以怎么做？你的实现思路和我的实现思路有哪个不同，我们之间又会碰出怎样的火花？&lt;/p&gt;&lt;h3&gt;&lt;b&gt;流程图&lt;/b&gt;&lt;/h3&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-ff904d3eefb58c00ea4c5c440d07ae37_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;430&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-ff904d3eefb58c00ea4c5c440d07ae37_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;430&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-ff904d3eefb58c00ea4c5c440d07ae37_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-ff904d3eefb58c00ea4c5c440d07ae37_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h3&gt;&lt;b&gt;思路&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;分析映射关系：abc -&amp;gt; xyzi。我们从高位到低位添加索引来分析这个过程&lt;/p&gt;&lt;ul&gt;&lt;li&gt;x: (前面补两个0)a的前六位 =&amp;gt; 00a7a6a5a4a3a2&lt;/li&gt;&lt;li&gt;y: (前面补两个0)a的后两位 + b的前四位 =&amp;gt; 00a1a0b7b6b5b4&lt;/li&gt;&lt;li&gt;z: (前面补两个0)b的后四位 + c的前两位 =&amp;gt; 00b3b2b1b0c7c6&lt;/li&gt;&lt;li&gt;i: (前面补两个0)c的后六位 =&amp;gt; 00c5c4c3c2c1c0通过上述的映射关系，我们很容易得到下面的实现思路：&lt;/li&gt;&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;将字符对应的ascII编码转为8位二进制数&lt;/li&gt;&lt;li&gt;将每三个8位二进制数进行以下操作&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;将第一个数右移位2位，得到第一个6位有效位二进制数&lt;/li&gt;&lt;li&gt;将第一个数 &amp;amp; 0x3之后左移位4位，得到第二个6位有效位二进制数的第一个和第二个有效位，将第二个数 &amp;amp; 0xf0之后右移位4位，得到第二个6位有效位二进制数的后四位有效位，两者取且得到第二个6位有效位二进制&lt;/li&gt;&lt;li&gt;将第二个数 &amp;amp; 0xf之后左移位2位，得到第三个6位有效位二进制数的前四位有效位，将第三个数 &amp;amp; 0xC0之后右移位6位，得到第三个6位有效位二进制数的后两位有效位，两者取且得到第三个6位有效位二进制&lt;/li&gt;&lt;li&gt;将第三个数 &amp;amp; 0x3f，得到第四个6位有效位二进制数&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;将获得的6位有效位二进制数转十进制，查找对应base64字符&lt;/li&gt;&lt;p&gt;我们以hao字符串为例，观察base64编码的过程，我们将上面转换通过代码逻辑分析实现吧。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;代码实现&lt;/b&gt;&lt;/h3&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// 输入字符串
let str = &#x27;hao&#x27;
// base64字符串
let base64EncodeChars = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;
// 定义输入、输出字节的二进制数
let char1, char2, char3, out1, out2, out3, out4, out
// 将字符对应的ascII编码转为8位二进制数
char1 = str.charCodeAt(0) &amp;amp; 0xff // 104  01101000
char2 = str.charCodeAt(1) &amp;amp; 0xff // 97  01100001
char3 = str.charCodeAt(2) &amp;amp; 0xff // 111  01101111
// 输出6位有效字节二进制数
6out1 = char1 &amp;gt;&amp;gt; 2 // 26  011010
out2 = (char1 &amp;amp; 0x3) &amp;lt;&amp;lt; 4 | (char2 &amp;amp; 0xf0) &amp;gt;&amp;gt; 4 // 6  000110
out3 = (char2 &amp;amp; 0xf) &amp;lt;&amp;lt; 2 | (char3 &amp;amp; 0xc0) &amp;gt;&amp;gt; 6 // 5  000101
out4 = char3 &amp;amp; 0x3f // 47 101111

out = base64EncodeChars[out1] + base64EncodeChars[out2] + base64EncodeChars[out3] + base64EncodeChars[out4] // aGFv
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;算法剖析&lt;/p&gt;&lt;ol&gt;&lt;li&gt;out1: char1 &amp;gt;&amp;gt; 201101000 -&amp;gt; 00011010&lt;br/&gt;&lt;/li&gt;&lt;li&gt;out2 = (char1 &amp;amp; 0x3) &amp;lt;&amp;lt; 4 | (char2 &amp;amp; 0xf0) &amp;gt;&amp;gt; 4// 且运算&lt;br/&gt;01101000        01100001&lt;br/&gt;00000011        11110000&lt;br/&gt;--------        --------&lt;br/&gt;00000000        01100000&lt;br/&gt;&lt;br/&gt;// 移位运算后得&lt;br/&gt;00000000        00000110&lt;br/&gt;&lt;br/&gt;// 或运算&lt;br/&gt;00000000&lt;br/&gt;00000110&lt;br/&gt;--------&lt;br/&gt;00000110&lt;br/&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;第三个字符第四个字符同理&lt;/p&gt;&lt;p&gt;整理上述代码，扩展至多字符字符串&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// 输入字符串
let str = &#x27;haohaohao&#x27;
// base64字符串
let base64EncodeChars = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;

// 获取字符串长度
let len = str.length
// 当前字符索引
let index = 0
// 输出字符串
let out = &#x27;&#x27;
while(index &amp;lt; len) {
    // 定义输入、输出字节的二进制数
    let char1, char2, char3, out1, out2, out3, out4
    // 将字符对应的ascII编码转为8位二进制数
    char1 = str.charCodeAt(index++) &amp;amp; 0xff // 104  01101000
    char2 = str.charCodeAt(index++) &amp;amp; 0xff // 97  01100001
    char3 = str.charCodeAt(index++) &amp;amp; 0xff // 111  01101111
    // 输出6位有效字节二进制数
    out1 = char1 &amp;gt;&amp;gt; 2 // 26  011010
    out2 = (char1 &amp;amp; 0x3) &amp;lt;&amp;lt; 4 | (char2 &amp;amp; 0xf0) &amp;gt;&amp;gt; 4 // 6  000110
    out3 = (char2 &amp;amp; 0xf) &amp;lt;&amp;lt; 2 | (char3 &amp;amp; 0xc0) &amp;gt;&amp;gt; 6 // 5  000101
    out4 = char3 &amp;amp; 0x3f // 47 101111

    out = out + base64EncodeChars[out1] + base64EncodeChars[out2] + base64EncodeChars[out3] + base64EncodeChars[out4] // aGFv
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;原字符串长度不是3的整倍数的情况，需要特殊处理&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;    ...
    char1 = str.charCodeAt(index++) &amp;amp; 0xff // 104  01101000
    if (index == len) {
        out2 = (char1 &amp;amp; 0x3) &amp;lt;&amp;lt; 4
        out = out + base64EncodeChars[out1] + base64EncodeChars[out2] + &#x27;==&#x27;
        return out
    }
    char2 = str.charCodeAt(index++) &amp;amp; 0xff // 97  01100001
    if (index == len) {
        out1 = char1 &amp;gt;&amp;gt; 2 // 26  011010
        out2 = (char1 &amp;amp; 0x3) &amp;lt;&amp;lt; 4 | (char2 &amp;amp; 0xf0) &amp;gt;&amp;gt; 4 // 6  000110
        out3 = (char2 &amp;amp; 0xf) &amp;lt;&amp;lt; 2
        out = out + base64EncodeChars[out1] + base64EncodeChars[out2] + base64EncodeChars[out3] + &#x27;=&#x27;
        return out
    }
    ...

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;全部代码&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;function base64Encode(str) {
    // base64字符串
    let base64EncodeChars = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;

    // 获取字符串长度
    let len = str.length
    // 当前字符索引
    let index = 0
    // 输出字符串
    let out = &#x27;&#x27;
    while(index &amp;lt; len) {
        // 定义输入、输出字节的二进制数
        let char1, char2, char3, out1, out2, out3, out4
        // 将字符对应的ascII编码转为8位二进制数
        char1 = str.charCodeAt(index++) &amp;amp; 0xff
        out1 = char1 &amp;gt;&amp;gt; 2
        if (index == len) {
            out2 = (char1 &amp;amp; 0x3) &amp;lt;&amp;lt; 4
            out = out + base64EncodeChars[out1] + base64EncodeChars[out2] + &#x27;==&#x27;
            return out
        }
        char2 = str.charCodeAt(index++) &amp;amp; 0xff
        out2 = (char1 &amp;amp; 0x3) &amp;lt;&amp;lt; 4 | (char2 &amp;amp; 0xf0) &amp;gt;&amp;gt; 4 
        if (index == len) {
            out3 = (char2 &amp;amp; 0xf) &amp;lt;&amp;lt; 2
            out = out + base64EncodeChars[out1] + base64EncodeChars[out2] + base64EncodeChars[out3] + &#x27;=&#x27;
            return out
        }
        char3 = str.charCodeAt(index++) &amp;amp; 0xff
        // 输出6位有效字节二进制数
        out3 = (char2 &amp;amp; 0xf) &amp;lt;&amp;lt; 2 | (char3 &amp;amp; 0xc0) &amp;gt;&amp;gt; 6
        out4 = char3 &amp;amp; 0x3f

        out = out + base64EncodeChars[out1] + base64EncodeChars[out2] + base64EncodeChars[out3] + base64EncodeChars[out4]
    }
    return out
}
base64Encode(&#x27;haohao&#x27;) // aGFvaGFv
base64Encode(&#x27;haoha&#x27;) // aGFvaGE=
base64Encode(&#x27;haoh&#x27;) // aGFvaA==
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;解码原理&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;逆向推导，由每4个6位有效位的二进制数合并成3个8位二进制数，根据ascII编码映射到对应字符后拼接字符串&lt;/p&gt;&lt;h3&gt;&lt;b&gt;思路&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;分析映射关系 xyzi -&amp;gt; abc&lt;/p&gt;&lt;ul&gt;&lt;li&gt;a: x后六位 + y第三、四位 =&amp;gt; x5x4x3x2x1x0y5y4&lt;/li&gt;&lt;li&gt;b: y后四位 + z第三、四、五、六位 =&amp;gt; y3y2y1y0z5z4z3z2&lt;/li&gt;&lt;li&gt;c: z后两位 + i后六位 =&amp;gt; z1z0i5i4i3i2i1i0&lt;/li&gt;&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;将字符对应的base64字符集的索引转为6位有效位二进制数&lt;/li&gt;&lt;li&gt;将每四个6位有效位二进制数进行以下操作&lt;/li&gt;&lt;ol&gt;&lt;li&gt;第一个二进制数左移位2位，得到新二进制数的前6位，第二个二进制数 &amp;amp; 0x30之后右移位4位，或运算后得到第一个新二进制数&lt;/li&gt;&lt;li&gt;第二个二进制数 &amp;amp; 0xf之后左移位4位，第三个二进制数 &amp;amp; 0x3c之后右移位2位，或运算后得到第二个新二进制数&lt;/li&gt;&lt;li&gt;第二个二进制数 &amp;amp; 0x3之后左移位6位，与第四个二进制数或运算后得到第二个新二进制数&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;根据ascII编码映射到对应字符后拼接字符串&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;&lt;b&gt;代码实现&lt;/b&gt;&lt;/h3&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// base64字符串
let str = &#x27;aGFv&#x27;
// base64字符集
let base64CharsArr = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;.split(&#x27;&#x27;)
// 获取索引值
let char1 = base64CharsArr.findIndex(char =&amp;gt; char==str[0]) &amp;amp; 0xff // 26  011010
let char2 = base64CharsArr.findIndex(char =&amp;gt; char==str[1]) &amp;amp; 0xff // 6  000110
let char3 = base64CharsArr.findIndex(char =&amp;gt; char==str[2]) &amp;amp; 0xff // 5  000101
let char4 = base64CharsArr.findIndex(char =&amp;gt; char==str[3]) &amp;amp; 0xff // 47  101111
let out1, out2, out3, out
// 位运算
out1 = char1 &amp;lt;&amp;lt; 2 | (char2 &amp;amp; 0x30) &amp;gt;&amp;gt; 4
out2 = (char2 &amp;amp; 0xf) &amp;lt;&amp;lt; 4 | (char3 &amp;amp; 0x3c) &amp;gt;&amp;gt; 2
out3 = (char3 &amp;amp; 0x3) &amp;lt;&amp;lt; 6 | char4
console.log(out1, out2, out3)
out = String.fromCharCode(out1) + String.fromCharCode(out2) + String.fromCharCode(out3)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;遇到有用&#x27;=&#x27;补过位的情况时&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;function base64decode(str) {
    // base64字符集
    let base64CharsArr = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;.split(&#x27;&#x27;)
    let char1 = base64CharsArr.findIndex(char =&amp;gt; char==str[0])
    let char2 = base64CharsArr.findIndex(char =&amp;gt; char==str[1])
    let out1, out2, out3, out
    if (char1 == -1 || char2 == -1) return out
    char1 = char1 &amp;amp; 0xff
    char2 = char2 &amp;amp; 0xff
    let char3 = base64CharsArr.findIndex(char =&amp;gt; char==str[2])
    // 第三位不在base64对照表中时，只拼接第一个字符串
    if (char3 == -1) {
        out1 = char1 &amp;lt;&amp;lt; 2 | (char2 &amp;amp; 0x30) &amp;gt;&amp;gt; 4
        out = String.fromCharCode(out1)
        return out
    }
    let char4 = base64CharsArr.findIndex(char =&amp;gt; char==str[3])
    // 第三位不在base64对照表中时，只拼接第一个和第二个字符串
    if (char4 == -1) {
        out1 = char1 &amp;lt;&amp;lt; 2 | (char2 &amp;amp; 0x30) &amp;gt;&amp;gt; 4
        out2 = (char2 &amp;amp; 0xf) &amp;lt;&amp;lt; 4 | (char3 &amp;amp; 0x3c) &amp;gt;&amp;gt; 2
        out = String.fromCharCode(out1) + String.fromCharCode(out2)
        return out
    }
    // 位运算
    out1 = char1 &amp;lt;&amp;lt; 2 | (char2 &amp;amp; 0x30) &amp;gt;&amp;gt; 4
    out2 = (char2 &amp;amp; 0xf) &amp;lt;&amp;lt; 4 | (char3 &amp;amp; 0x3c) &amp;gt;&amp;gt; 2
    out3 = (char3 &amp;amp; 0x3) &amp;lt;&amp;lt; 6 | char4
    console.log(out1, out2, out3)
    out = String.fromCharCode(out1) + String.fromCharCode(out2) + String.fromCharCode(out3)
    return out
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;解码整个字符串，整理代码后&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;function base64decode(str) {
    // base64字符集
    let base64CharsArr = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;.split(&#x27;&#x27;)
    let i = 0
    let len = str.length
    let out = &#x27;&#x27;
    while(i &amp;lt; len) {
        let char1 = base64CharsArr.findIndex(char =&amp;gt; char==str[i])
        i++
        let char2 = base64CharsArr.findIndex(char =&amp;gt; char==str[i])
        i++
        let out1, out2, out3
        if (char1 == -1 || char2 == -1) return out
        char1 = char1 &amp;amp; 0xff
        char2 = char2 &amp;amp; 0xff
        let char3 = base64CharsArr.findIndex(char =&amp;gt; char==str[i])
        i++
        // 第三位不在base64对照表中时，只拼接第一个字符串
        out1 = char1 &amp;lt;&amp;lt; 2 | (char2 &amp;amp; 0x30) &amp;gt;&amp;gt; 4
        if (char3 == -1) {
            out = out + String.fromCharCode(out1)
            return out
        }
        let char4 = base64CharsArr.findIndex(char =&amp;gt; char==str[i])
        i++
        // 第三位不在base64对照表中时，只拼接第一个和第二个字符串
        out2 = (char2 &amp;amp; 0xf) &amp;lt;&amp;lt; 4 | (char3 &amp;amp; 0x3c) &amp;gt;&amp;gt; 2
        if (char4 == -1) {
            out = out + String.fromCharCode(out1) + String.fromCharCode(out2)
            return out
        }
        // 位运算
        out3 = (char3 &amp;amp; 0x3) &amp;lt;&amp;lt; 6 | char4
        console.log(out1, out2, out3)
        out = out + String.fromCharCode(out1) + String.fromCharCode(out2) + String.fromCharCode(out3)
    }
    return out
}
base64decode(&#x27;aGFvaGFv&#x27;) // haohao
base64decode(&#x27;aGFvaGE=&#x27;) // haoha
base64decode(&#x27;aGFvaA==&#x27;) // haoh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上述解码核心是字符与base64字符集索引的映射，网上看到过使用AccII编码索引映射base64字符索引的方法&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;let base64DecodeChars = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1]
// 
let char1 = &#x27;hao&#x27;.charCodeAt(0) // h -&amp;gt; 104
base64DecodeChars[char1] // 33 -&amp;gt; base64编码表中的h
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;由此可见，base64DecodeChars对照accII编码表的索引存放的是base64编码表的对应字符的索引。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;说起Base64编码可能有些奇怪，因为大多数的编码都是由字符转化成二进制的过程，而从二进制转成字符的过程称为解码。而Base64的概念就恰好反了，由二进制转到字符称为编码，由字符到二进制称为解码。Base64 是一种数据编码方式，可做简单加密使用，我们可以改变base64编码映射顺序来形成自己独特的加密算法进行加密解密。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;编码表&lt;/b&gt;&lt;/h2&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-389e3895fda68d47c1edbc0cb71cfff6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;972&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-389e3895fda68d47c1edbc0cb71cfff6_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;972&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-389e3895fda68d47c1edbc0cb71cfff6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-389e3895fda68d47c1edbc0cb71cfff6_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b15e05ad7509dfc390e445560196c71e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;1227&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-b15e05ad7509dfc390e445560196c71e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;1227&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-b15e05ad7509dfc390e445560196c71e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-b15e05ad7509dfc390e445560196c71e_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>68b457520c256486f270b7674fafa937</guid>
<title>[推荐] 如何通过项目复盘来加速个人成长</title>
<link>https://toutiao.io/k/ys08f63</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样工作年限的人，能力可能差别很大。工作 5 年的前端，有的只会做简单的任务，有的已经可以独当一面了。导致这种情况的原因有很多，本质是成长的速度不同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;复盘可以加速个人成长。本文主要介绍，个人通过项目复盘来加速成长的方法。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;什么是复盘&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;复盘本是围棋术语，意指对弈者在下完一盘棋后，把对弈过程重新摆一遍，寻找改进点。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;复盘就是从经验中学习。做得不好的地方，避免下次再犯。做得好的地方，争取下次能做得更好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;建议在做完项目的一周内做复盘。这时，对项目的感触是最新鲜的~&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;复盘的步骤&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;做好复盘，主要分为 5 步：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;定主题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;做回顾&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;找根因&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;定策略&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;跟踪落地&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;第 1 步: 定主题&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定主题就是确定复盘的主题。复盘前，如果没确定主题，想法有很多，会有无从下手的感觉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;复盘的主题可以从项目特点来考虑。项目的功能比较复杂，主题可以是: 复杂业务的代码组织。项目大量用了某新技术，主题可以是: xx技术分析。项目有很多跨部门沟通的内容，主题可以是：如何做好跨部门沟通。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;复盘的主题可以从项目的结果来考虑。主题可以是：成功原因分析，失败原因分析。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;复盘的主题可以从个人的职位和发展方向来考虑。专注代码质量的同学，主题可以是：降低代码的复杂度。专注性能的同学，主题可以是：渲染性能优化分析。项目 Leader 主题可以是：提升开发体验。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要注意的是，主题不要太大。主题越大，考虑的内容就越多，容易没有重点，也越难写。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果觉得没法用一个主题描述一次复盘。可以有多个主题。当然，如果实在不知道起什么主题，那就随缘吧XD&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;第 2 步: 做回顾&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;做回顾就是仔细回顾做项目的整个过程。在回顾的过程中，结合主题，列出做的好的和不好的内容。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;举个例子&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6244784422809457&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/mEakJnD74m9OaaDmwM9jKHcTw4vwZKtb8mXfoJgyaGicwCZZRiaRDLlibDeRt9jgYjo2hkQuojTnD66VeuX9Czf3Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1438&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图是我最近做了一个多月的任务：项目集的计划页。页面显示了任务和里程碑的甘特图。用户在这个页面上，可以对任务和里程碑进行新建，编辑，排序，删除等操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;技术栈是 React。组件基本都是函数组件。管理多组件间共享的数据用的是 React 自带的 &lt;span&gt;Context API&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;复盘的主题是：&lt;strong&gt;渲染性能优化分析&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;做的好的部分：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;对大部分组件都用了 &lt;code&gt;React.memo&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;函数属性基本都用了 &lt;code&gt;useCallback&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在必要的地方用了 &lt;code&gt;useMemo&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;做的不好的地方：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;有 2 个比较大的 Context。导致用到这两个 Context 的组件有时会产生不必要的渲染。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;甘特图性能不好。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;第 3 步: 找根因&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;找根因就是产生结果的的根本原因。找根因可以用&lt;span&gt;5why分析法&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;:&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;5why分析法，又称“5问法”，也就是对一个问题点连续以5个“为什么”来自问，以追究其根本原因。虽为5个为什么，但使用时不限定只做“5次为什么的探讨”，主要是必须找到根本原因为止，有时可能只要几次，有时也许要十几次，如古话所言：打破砂锅问到底。5why法的关键所在：鼓励解决问题的人要努力避开主观或自负的假设和逻辑陷阱，从结果着手，沿着因果关系链条，顺藤摸瓜，直至找出原有问题的根本原因。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们用 5why分析法 来分析：甘特图性能不好。&lt;br/&gt;&lt;img data-ratio=&quot;3.8434343434343434&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mEakJnD74m9OaaDmwM9jKHcTw4vwZKtbDUdLSiakwTZ9EERJ18RjibghlsHwt4CImCtOHhguKUxUQDPeoJqWZ1xQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;198&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果根因有很多个，可以用&lt;span&gt;鱼骨图&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;来分析。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;鱼骨图是一种发现问题“根本原因”的方法，它也可以称之为“Ishikawa”或者“因果图”。其特点是简洁实用，深入直观。它看上去有些像鱼骨，问题或缺陷（即后果）标在“鱼头”处。在鱼骨上长出鱼刺，上面按出现机会多寡列出产生问题的可能原因，有助于说明各个原因是如何影响后果的。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如:&lt;img data-ratio=&quot;0.4536082474226804&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mEakJnD74m9OaaDmwM9jKHcTw4vwZKtbz4biblrlN234nrK9WeThNjxM9znyzvKB5dVhyxjnp6j95vnxWHKkAfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;970&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;第 4 步: 定策略&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定策略就是定改进的策略。可以用海星复盘图来定策略。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9660326086956522&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/mEakJnD74m9OaaDmwM9jKHcTw4vwZKtbzhhQhDzL0mcIeeoAczXdsodLO0YtywReevUwSRNYDL80fUSdQmqicAA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1472&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;海星复盘图将策略分为5类：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Stop — 指那些非但没有给团队或客户带来价值，反而带来浪费的活动。&lt;br/&gt;Less — 指团队过去做的一些活动，但并没带来更多收益，团队以后需要花费更少的精力做这些事情。&lt;br/&gt;Keep — 指团队想要继续保留的良好实践或活动。&lt;br/&gt;More — 指那些团队应该更聚焦或更经常进行的活动。&lt;br/&gt;Start — 指想引入到团队中的活动或想法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;详细介绍见: &lt;span&gt;如何做好项目复盘 - 海星复盘图&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;第 5 步: 跟踪落地&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;跟踪落地就是具体实施改进的策略，并评估结果。制定实施计划和评估结果可以使用 &lt;span&gt;SMART 原则&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后推荐一本关于复盘的书：&lt;span&gt;《复盘+：把经验转化为能力（第2版）》&lt;/span&gt;&lt;sup&gt;[6]：&lt;/sup&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;随着环境日趋多变、不确定、复杂、模糊，无论是个人还是组织，都需要更快更有效地进行创新应变、提升能力。复盘作为一种从经验中学习的结构化方法，满足了快速学习的需求，也是有效进行知识萃取与共享的机制。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一起来做项目复盘吧~&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;Context API: &lt;em&gt;https://reactjs.org/docs/context.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;5why分析法: &lt;em&gt;https://baike.baidu.com/item/5why%E5%88%86%E6%9E%90%E6%B3%95&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;鱼骨图: &lt;em&gt;https://baike.baidu.com/item/%E9%B1%BC%E9%AA%A8%E5%9B%BE/6514245&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;如何做好项目复盘 - 海星复盘图: &lt;em&gt;https://juejin.cn/post/6844903817260040199&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;SMART 原则: &lt;em&gt;https://baike.baidu.com/item/SMART%E5%8E%9F%E5%88%99/8575850&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;《复盘+：把经验转化为能力（第2版）》: &lt;em&gt;https://book.douban.com/subject/26838511/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0aea4a7e6196b49a3b35d70bb19599a7</guid>
<title>[推荐] 聊聊 JVM 调优</title>
<link>https://toutiao.io/k/tbiemos</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;文章总体结构&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文中，我们将按照如下结构介绍JVM的整体架构和调优参数。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2hHcUic5FEwFulovMVicfE95bSz4Yp5Hv8oSUORILC5ptwicicblOxAn8IaK8R2pgW90ic0OdgtibhZDg9eMepQtDNgQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JVM的分类&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里，我们先来说说什么是VM吧，VM的中文含义为：虚拟机，指的是使用软件的方式模拟具有完整硬件系统功能、运行在一个完全隔离环境中的完整计算机系统，是物理机的软件实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常用的虚拟机有：VMWare、Virtual Box，Java Virtual Machine（JVM，Java虚拟机）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里，我们重点聊的就是JVM，Java虚拟机。看下图。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7980952380952381&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2hHcUic5FEwFulovMVicfE95bSz4Yp5Hv84A11bSphCINM9BIePUGIQFDHootDA9EW0a3bW0L9gHs2ggjO0xWjfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;525&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这张图看起来还是比较简单的，JVM运行于操作系统之上，操作系统是运行在计算机硬件上的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于JVM，其实有很多大厂开发了不同版本的JVM，比较知名的有：Sun HotSpot VM、BEA JRockit VM、IBM J9 VM、 Azul VM、 Apache Harmony、 Google Dalvik VM、 Microsoft JVM等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在使用的比较多的JDK8版本就是Sun HotSpot VM与BEA JRockit VM合并之后开发出的JDK版本。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JVM的构成&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JVM主要由三个子系统构成，分别为：&lt;strong&gt;类加载器子系统、运行时数据区（内存结构）和字节码执行引擎&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4279141104294479&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2hHcUic5FEwFulovMVicfE95bSz4Yp5Hv827UA7giaVibMTIk7Nc5Z5Qzib8T0uJtS7iabAGaGiaktWYy1LDUIPIEd6gg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;652&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了更好的理解JVM，我们来看一下JVM的全貌图。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.9135338345864662&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2hHcUic5FEwFulovMVicfE95bSz4Yp5Hv8XZL9WSB3hFvUPib3Mx3zzg5j0ibBW5p1HVr8Ddf2jzMQrvvxXjcp8QnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;798&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们开发Java程序时，首先会编写.java文件，之后，会将.java文件编译成.class文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JVM中，会通过类装载子系统将.class文件的内容装载到JVM的运行时数据区，而JVM的运行时数据区又会分为：&lt;strong&gt;方法区、堆、栈、本地方法栈和程序计数器&lt;/strong&gt; 几个部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在装载class文件的内容时，会将class文件的内容拆分为几个部分，分别装载到JVM运行时数据区的几个部分。其中，值得注意的是：&lt;strong&gt;程序计数器的作用是：记录程序执行的下一条指令的地址。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法区也叫作元空间，主要包含了：运行时常量池、类型信息、字段信息、方法信息、类加载器的引用、对应的Class实例的引用等信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在JVM中，程序的执行是通过执行引擎进行的，执行引擎会调用本地方法的接口来执行本地方法库，进而完成整个程序逻辑的执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们常说的垃圾收集器是包含在执行引擎中的，在程序的运行过程中，执行引擎会开启垃圾收集器，并在后台运行，垃圾收集器会不断监控程序运行过程中产生的内存垃圾信息，并根据相应的策略对垃圾信息进行清理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这里，大家需要注意的是：栈、本地方法栈和程序计数器是每个线程运行时独占的，而方法区和堆是所有线程共享的。所以，栈、本地方法栈和程序计数器不会涉及线程安全问题，而方法区和堆会涉及线程安全问题。&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方法区（元空间）&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多小伙伴一看到方法区三个字，脑海中的第一印象可能是存储方法的地方吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实则不然，方法区的另一个名字叫作元空间，相信不少小伙伴或多或少的听说过元空间。这个区域是JDK1.8中划分出来的。主要包含：运行时常量池、类型信息、字段信息、方法信息、类加载器的引用、对应的Class实例的引用等信息。方法区中的信息能够被多个线程共享。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，在程序中声明的常量、静态变量和有关于类的信息等的引用，都会存放在方法区，而这些引用所指向的具体对象 &lt;strong&gt;一般都会在堆中开辟单独的空间进行存储，也可能会在直接内存中进行存储&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.47232472324723246&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2hHcUic5FEwFulovMVicfE95bSz4Yp5Hv8j84ia8ZibdCJqqm0ToVPt0VE5JCMAeI1xzFSmrrgfMFjiaYQhF6UlWNwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;542&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;堆&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;堆中主要存储的是实际创建的对象，也就是会存储通过new关键字创建的对象，堆中的对象能够被多个线程共享。堆中的数据不需要事先明确生存期，可以动态的分配内存，不再使用的数据和对象由JVM中的GC机制自动回收。&lt;strong&gt;对JVM的性能调优一般就是对堆内存的调优&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java中基本类型的包装类：Byte、Short、Integer、Long、Float、Double、Boolean、Character类型的数据是存储在堆中的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;堆一般会被分成年轻代和老年代。而年轻代又会被进一步分为1个Eden区和2个Survivor区。在内存分配上，如果保持默认配置的话，年轻代和老年代的内存大小比例为1 : 2，年轻代中的1个Eden区和2个Survivor区的内存大小比例为：8 : 1 : 1。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4405997693194925&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2hHcUic5FEwFulovMVicfE95bSz4Yp5Hv8uorevgneb1R3qrT3Oicx3yn6aWfgrE3G9fSa6wklUibSq4vAgslBSHew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;867&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;栈&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;栈一般又叫作线程栈或虚拟机栈，一般存储的是局部变量。在Java中，每个线程都会有一个单独的栈区，每个栈中的元素都是私有的，不会被其他的栈所访问。栈中的数据大小和生存期都是确定的，存取速度比较快。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Java中，所有的基本数据类型（byte、short、int、long、float、double、boolean、char）和引用变量（对象引用）都是在栈中的。&lt;strong&gt;一般情况下，线程退出或者方法退出时，栈中的数据会被自动清除&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序在执行过程中，会在栈中为不同的方法创建不同的栈帧，在栈帧中又包含了：&lt;strong&gt;局部变量表、操作数栈、动态链接和方法出口。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.0801144492131616&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2hHcUic5FEwFulovMVicfE95bSz4Yp5Hv8FlSf0XB8GIR1kmCdHlMDY4yeTxPo51mB5vDbD2VazOu8I3Fej9ebjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;699&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于局部变量表、操作数栈、动态链接和方法出口的具体作用，会在《&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg4MjU0OTM1OA==&amp;amp;action=getalbum&amp;amp;album_id=2028693320121548800#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;架构师进阶系列&lt;/a&gt;》中的后续文章中详细阐述。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;栈中一般会存储对象的引用，这些引用所指向的具体对象一般都会在堆中开辟单独的地址空间进行存储，也有可能存储在直接内存中。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4828828828828829&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2hHcUic5FEwFulovMVicfE95bSz4Yp5Hv8cpL92lpHUk0f5MKjQo8kUKQoYMrPhogribQKpAuCWOBQ7ebwSXD7Pag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;555&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意：这里说的是这些引用所指向的具体对象一般都会在堆中开辟单独的地址空间进行存储，也有可能存储在直接内存中。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;因为在JVM中，如果开启了逃逸分析和标量替换，则可能不会再在堆上创建对象，可能会将对象直接分配到栈上，也可能不再创建对象，而是进一步分解对象中的成员变量，将其直接在栈上分配空间并赋值。&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;本地方法栈&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本地方法栈相对来说比较简单，就是保存native方法进入区域的地址。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，在Java中创建线程，调用Thread对象的start()方法时，会通过本地方法start0()调用操作系统创建线程的方法。此时，本地方法栈就会保存start0()方法进入区域的内存地址。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;程序计数器&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序计数器也叫作PC计数器，主要存储的是下一条将要执行的命令的地址。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JVM调优参数&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在JVM中，主要是对堆（新生代）、方法区和栈进行性能调优。各个区域的调优参数如下所示。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;堆：-Xms、-Xmx&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;新生代：-Xmn&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;方法区（元空间）：-XX:MetaspaceSize、-XX:MaxMetaspaceSize&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;栈（线程）：-Xss&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了更加直观的表述，我们可以将JVM的内存区域和对应的调优参数总结成下图所示。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.535904255319149&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2hHcUic5FEwFulovMVicfE95bSz4Yp5Hv8L8PlYs6RMFyicXov1iaDHudR6iaJN7iaEgLfpnDibHImaguC4g7SqMNHJEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;752&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;在设置JVM启动参数时，需要特别注意方法区（元空间）的参数设置。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于方法区（元空间）的JVM参数主要有两个：-XX:MetaspaceSize和-XX:MaxMetaspaceSize。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;-XX:MetaspaceSize：&lt;/strong&gt; 指的是方法区（元空间）触发Full GC的初始内存大小（方法区没有固定的初始内存大小），以字节为单位，默认为21M。达到设置的值时，会触发Full GC，同时垃圾收集器会对这个值进行修改。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果在发生Full GC时，回收了大量内存空间，则垃圾收集器会适当降低此值的大小；如果在发生Full GC时，释放的空间比较少，则在不超过设置的-XX:MetaspaceSize值或者在没设置-XX:MetaspaceSize的值时不超过21M，适当提高此值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;-XX:MaxMetaspaceSize：&lt;/strong&gt; 指的是方法区（元空间）的最大值，默认值为-1，不受堆内存大小限制，此时，只会受限于本地内存大小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;最后需要注意的是：&lt;/strong&gt; 调整方法区（元空间）的大小会发生Full GC，这种操作的代价是非常昂贵的。如果发现应用在启动的时候发生了Full GC，则很有可能是方法区（元空间）的大小被动态调整了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;所以，为了尽量不让JVM动态调整方法区（元空间）的大小造成频繁的Full GC，一般将-XX:MetaspaceSize和-XX:MaxMetaspaceSize设置成一样的值。例如，物理内存8G，可以将这两个值设置为256M&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，我们一起看下在物理内存8G的情况下，启动应用程序时，可以设置的JVM参数。当然，我这里给出的是一些经验值，实际部署到生产环境时，需要经过压测找到最佳的参数值。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;java ‐Xms2048M ‐Xmx2048M ‐Xmn1024M ‐Xss512K ‐XX:MetaspaceSize=256M ‐XX:MaxMetaspaceSize=256M ‐jar xxx.jar&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Tomcat bin目录下catalina.sh文件里配置。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;‐Xms2048M ‐Xmx2048M ‐Xmn1024M ‐Xss512K ‐XX:MetaspaceSize=256M ‐XX:MaxMetaspaceSize=256M&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Tomcat bin目录下catalina.bat文件里配置。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;‐Xms2048M ‐Xmx2048M ‐Xmn1024M ‐Xss512K ‐XX:MetaspaceSize=256M ‐XX:MaxMetaspaceSize=256M&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天，我们一起学习了JVM的整体架构和调优参数，主要包括：JVM的总体结构、JVM的分类、JVM的构成和调优参数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你学会了吗？欢迎在文末留言说出你的想法，如果你有更好的见解，也可以在文末留言和大家交流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;好了，今天就到这儿吧，我们下期见~~&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7fc3a2ee07b5e7ff146d54d590175719</guid>
<title>[推荐] 推荐几个开源类库，超好用，远离 996</title>
<link>https://toutiao.io/k/oi7zdzy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天给大家分享几个 Java 的开源类库，亲测非常好用！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了它们之后，你就可以和很多重复劳动说再见了。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;1. MapStruct&lt;/h1&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2806349206349206&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KSnhEmJ0hk51vGmlPGAia7cBuEstA8ecmrWian3mjF0VvoAiaibNWTC5K3QMZ6yK4QwDYYo401lOymRrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3150&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;MapStruct是干什么的？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MapStruct是个代码产生器，它能直接根据注解生成 Java 对象对应的转换器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，直接把一个 A 类型的 Java 对象，给转成 B 类型的 Java 对象，只需要在他们之间配置上字段之间的映射关系即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;为什么在项目里用它？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在随便一个项目都是多层的，尤其是 Web 项目，经常需要在多层之间做对象模型转换，比如 DTO 转换成 BO。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;DTO（Data Transfer Object）：数据传输对象，Service 向外传输的对象。&lt;br/&gt;BO（Business Object）：业务对象，由 Service 层输出的封装业务逻辑的对象。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这种转换工作就像是小时候，老师罚我们抄写名人名言 100 遍一样，十分枯燥，还容易出错。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CarMapper&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;CarDto &lt;span&gt;carDoToCarDto&lt;/span&gt;&lt;span&gt;(Car car)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        CarDto carDto = &lt;span&gt;new&lt;/span&gt; CarDto();&lt;br/&gt;        carDto.setCarId(car.getCarId());&lt;br/&gt;        carDto.setWheel(car.getWheel());&lt;br/&gt;        carDto.setCarType(car.getCarType());&lt;br/&gt;        carDto.setCarColor(car.getCarColor());&lt;br/&gt;        ......&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要是 Car 有几十个字段，像 Car 一样的又有几十个类，你可以想一下，这种繁琐程度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 MapStruct 之前，我们都是通过 Apache 或者 Spring 的 BeanUtils 工具，去自动做这种事情。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这类工具有两个问题：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1.性能比较差&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;性能差主要是 Apache 的 BeanUtils 这套东西，它每次都要针对字段，做是否可读写的检查，还要根据字段生成对应的 PropertyDescriptor。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些严重影响了它的性能，所以，在阿里 Java 手册里，也不推荐用它。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring 的 BeanUtils，虽然精简了很多 Apache 的 BeanUtils 的读写检查以及对应的属性信息记录，但是它依然是通过反射调用，而且是大量反射调用。这种性能也不能令人满意。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2.运行期做转换，出错就代表损失&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;BeanUtils 这类工具，有个统一的名称，叫做 Java 对象映射框架。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它们大部分的实现都是在运行期去执行代码，然后在 Java 对象之间去拷贝对应的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行期间做这种事儿，有个最大的问题——整个项目启动运行后，才能发现错误。比如，转换的时候，类型不一致导致报错。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于此种情况，咱们大家都知道，这事儿就像开业酬宾没搞好，变成了开业仇宾……&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果能写完代码，编译的时候就发现问题，这种损失就可以避免了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MapStruct 的引入就是为了解决以上这两个问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MapStruct 首先是个代码产生器，它是根据注解，去产生一个专门用来转换的工具类，这个工具类，就像我们自己写的 Java 类一样，可以直接被使用，这样就避免了反射。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时，它产生的转换类也特别简单，就是默认会在两个类型的 Java 对象之间，拷贝同名属性的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果有了配置，属性不同名也可以拷贝。所以它的性能很好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Mapper&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;CarMapper&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    CarMapper INSTANCE = Mappers.getMapper( CarMapper&lt;span&gt;.&lt;span&gt;class&lt;/span&gt; )&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Mapping&lt;/span&gt;(target = &lt;span&gt;&quot;seatCount&quot;&lt;/span&gt;, source = &lt;span&gt;&quot;numberOfSeats&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;CarDto &lt;span&gt;carBoToCarDto&lt;/span&gt;&lt;span&gt;(Car car)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MapStruct由于是个代码产生器，就带来了个巨大的好处，就是这家伙是在编译阶段就会生成对应的类，所以，如果有了类似类型转换不过去的问题，直接就编译报错了，根本等不到运行才发现。这样的话，就不会造成什么损失，这真是件十分 Nice 的事情。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;代码库地址&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://github.com/mapstruct/mapstruct&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;2. Retrofit&lt;/h1&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2265193370165746&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KSnhEmJ0hk51vGmlPGAia7cBuMJpksx3ddxxaG2lyQlMjUZesVMWOJ64E1NkRLHOrziaCj9N1af8Qow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1086&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Retrofit 是干什么的？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Retrofit 就是一套 Http 客户端，可以用来访问第三方的 Http 服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，咱们代码里想调用一个 Http 协议的 URL，就可以用它来访问这个 URL，获取响应结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;为什么在项目里用它？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在公司里，我们有些项目有如下的特点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;不是基于 Spring 的项目&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;需要经常访问大量的第三方 Http 服务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;访问 Http 服务的模型通常是异步回调&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以前的时候，我们访问 Http 服务，都是直接用的 HttpClient。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可是吧，HttpClient 用起来实在够麻烦的。主要也存在两个问题：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1.请求参数和 URL 拼接实在繁琐&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请求参数和 URL 拼接实在是太烦人了。你想想，每调用一个接口，就需要自己去拼接参数，有的 URL，甚至十几二十个参数需要拼接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拼接这事儿简单、枯燥、重复，还没有技术含量，但是工作量却不小，时间真的算浪费了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;URIBuilder uriBuilder = &lt;span&gt;new&lt;/span&gt; URIBuilder(uriBase);&lt;br/&gt;uriBuilder.setParameter(&lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;valuea&quot;&lt;/span&gt;);&lt;br/&gt;uriBuilder.setParameter(&lt;span&gt;&quot;b&quot;&lt;/span&gt;, &lt;span&gt;&quot;valueb&quot;&lt;/span&gt;);&lt;br/&gt;uriBuilder.setParameter(&lt;span&gt;&quot;c&quot;&lt;/span&gt;, &lt;span&gt;&quot;valuec&quot;&lt;/span&gt;);&lt;br/&gt;uriBuilder.setParameter(&lt;span&gt;&quot;d&quot;&lt;/span&gt;, &lt;span&gt;&quot;valued&quot;&lt;/span&gt;);&lt;br/&gt;uriBuilder.setParameter(&lt;span&gt;&quot;e&quot;&lt;/span&gt;, &lt;span&gt;&quot;valuee&quot;&lt;/span&gt;);&lt;br/&gt;uriBuilder.setParameter(&lt;span&gt;&quot;f&quot;&lt;/span&gt;, &lt;span&gt;&quot;valuef&quot;&lt;/span&gt;);&lt;br/&gt;uriBuilder.setParameter(&lt;span&gt;&quot;g&quot;&lt;/span&gt;, &lt;span&gt;&quot;valueg&quot;&lt;/span&gt;);&lt;br/&gt;uriBuilder.setParameter(&lt;span&gt;&quot;h&quot;&lt;/span&gt;, &lt;span&gt;&quot;valueh&quot;&lt;/span&gt;);&lt;br/&gt;uriBuilder.setParameter(&lt;span&gt;&quot;i&quot;&lt;/span&gt;, &lt;span&gt;&quot;valuei&quot;&lt;/span&gt;);&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2.异步回调需要自己搞&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;异步回调这种模型不好处理，主要就是需要自己去搞线程池，还要对线程池管理，还要考虑出错的重试之类的容错问题，实在麻烦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，我们就需要一套能用法简单，不用我们一直搞拼接参数，自己搞线程管理就能完成对第三方 Http 服务访问的库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实我们也想过用 Feign 这套框架的。但是，这套东西和 Spring 绑定的太紧了。如果离开 Spring，它的一些功能就没法简单的通过注解直接使用，必须自己写代码调用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且，Feign 要实现异步回调方式使用，尤其在协程方面，还是需要自己开发。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候，Retrofit 就跳进了我们的选型里。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Retrofit 的模型里，异步回调模型它支持的很好，我们只需要实现一个 Callable 就够了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且最清爽的是，它和 Spring 没什么关系。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Retrofit retrofit = &lt;span&gt;new&lt;/span&gt; Retrofit.Builder()&lt;br/&gt;        .baseUrl(&lt;span&gt;&quot;http://xxx.example.com/&quot;&lt;/span&gt;)&lt;br/&gt;        .build();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;BlogService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@GET&lt;/span&gt;(&lt;span&gt;&quot;blog/{id}&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;Call&amp;lt;ResponseBody&amp;gt; &lt;span&gt;getBlog&lt;/span&gt;&lt;span&gt;(@Path(&lt;span&gt;&quot;id&quot;&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; id)&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;BlogService service = retrofit.create(BlogService&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;Call&amp;lt;ResponseBody&amp;gt; call = service.getBlog(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;// 用法和OkHttp的call如出一辙,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 回调&lt;/span&gt;&lt;br/&gt;call.enqueue(&lt;span&gt;new&lt;/span&gt; Callback&amp;lt;ResponseBody&amp;gt;() {&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onResponse&lt;/span&gt;&lt;span&gt;(Call&amp;lt;ResponseBody&amp;gt; call, Response&amp;lt;ResponseBody&amp;gt; response)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            System.out.println(response.body().string());&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onFailure&lt;/span&gt;&lt;span&gt;(Call&amp;lt;ResponseBody&amp;gt; call, Throwable t)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        t.printStackTrace();&lt;br/&gt;    }&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你看，只需要写上这些代码，我们就不需要操心恼人的 Url 拼接和异步回调的管理问题了。全交给了 Retrofit，着实推荐。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;代码库地址&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://github.com/square/retrofit&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;3. Faker&lt;/h1&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.18406593406593408&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KSnhEmJ0hk51vGmlPGAia7cBhx1f8kKSm5BYewyLsib7J37r8wwGLIlVL9PThILUwLgUYaJKGia37NVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;728&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Faker 是干什么的？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Faker 是专门用来产生各种假数据的辅助工具库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，你想产生个和真实数据一样的有姓名、有地址的用户。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;为什么在项目里用它？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们经常需要造数据去测试，但是，如果没有工具辅助，我们自己造数据，存在一些问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1.数据是需要格式的&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多关于项目，都需要一些格式上尽量能模仿真实世界的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，国内用户的姓名，大部分都是两字、三字的姓名，叫王大，就不能叫 王da 这种。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;又比如，国内的地址是 xx市xx区xx街道xx号 这种的，就不能胡写一个几个没意义的汉字来当地址。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用贴近真实格式的数据，一来可以测出我们对用户的数据解析是否存在问题，二来可以测出数据库内的字段长度是否没问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，格式对产生出可靠地测试结果，是很重要的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2.数据的量大&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有的测试数据量都是上十万、百万的，这些量级的数据并不是只会产生一次。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;甚至几乎每个项目，每个项目的每次测试，可能都会需要新的数据，需要能源源不断地产生出来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更甚至的是，有时候还想要根据我们的要求，在恰当的时候，产生某种关系的数据，或者以某些特定频率产生。比如，两秒后产生一次数据；比如，产生一批姓王的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上这三种要求综合起来，要是我们自己造数据，那真是要了命了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与其自己开发，不如用现成的——Faker 库被我们找到了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Faker库可以创造三百多种数据，而且还很容易对它进行扩展改造，去产生更多的贴合我们需求的数据。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Faker faker = &lt;span&gt;new&lt;/span&gt; Faker();&lt;br/&gt;&lt;br/&gt;String name = faker.name().fullName(); &lt;span&gt;// Miss Samanta Schmidt&lt;/span&gt;&lt;br/&gt;String firstName = faker.name().firstName(); &lt;span&gt;// Emory&lt;/span&gt;&lt;br/&gt;String lastName = faker.name().lastName(); &lt;span&gt;// Barton&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;String streetAddress = faker.address().streetAddress(); &lt;span&gt;// 60018 Sawayn Brooks Suite 449&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;几行代码，我们需要的一个用户就有了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用上 Faker 后，小伙伴们纷纷表示“有更多的时间摸鱼了”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;代码库地址&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://github.com/DiUS/java-faker&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;4. Wiremock&lt;/h1&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5228758169934641&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KSnhEmJ0hk51vGmlPGAia7cBxTkowASXfAumC5G20fMry7hyiciaI6F3jaRfkO7AicibBtwopQibIz4HlVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;306&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Wiremock 是干什么的？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Wiremock 是一个可以模拟服务的测试框架。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，你想测试访问阿里的支付相关接口的代码逻辑，就可以用它来做测试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;为什么在项目里用它？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，我们需要调用银行接口去做资金业务，调用微信接口去做微信登录……这些调用第三方服务的测试存在一个问题：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即太过依赖对方的平台。假如对方平台限制了一些 IP，或者限制了访问频率，又或者就是服务出现了维护，都会影响我们自身的功能测试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决上述问题，在之前，我们需要自己写代码模仿第三方的接口，等我们自己全部测试没问题了，再去和第三方联调。对于这种模拟出来的接口，我们称作挡板。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可是，这种方式是个苦活，没人愿意干。因为每接入一个第三方，可能都需要做挡板。辛苦做个挡板，就是单纯为了测试。如果第三方的接口做了改造，你这边还得跟着改。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家可以想想，换成你自己，你愿意做这么件事儿吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候，Wiremock 的价值就体现出来了。有了 Wiremock，挡板这种东西就再也不存在了，直接在单元测试里模拟测试即可，像这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;WireMock.stubFor(get(urlPathMatching(&lt;span&gt;&quot;/aliyun/.*&quot;&lt;/span&gt;))&lt;br/&gt;                .willReturn(aResponse()&lt;br/&gt;                        .withStatus(&lt;span&gt;200&lt;/span&gt;)&lt;br/&gt;                        .withHeader(&lt;span&gt;&quot;Content-Type&quot;&lt;/span&gt;, APPLICATION_JSON)&lt;br/&gt;                        .withBody(&lt;span&gt;&quot;\&quot;testing-library\&quot;: \&quot;WireMock\&quot;&quot;&lt;/span&gt;)));&lt;br/&gt;&lt;br/&gt;CloseableHttpClient httpClient = HttpClients.createDefault();&lt;br/&gt;HttpGet request = &lt;span&gt;new&lt;/span&gt; HttpGet(String.format(&lt;span&gt;&quot;http://localhost:%s/aliyun/wiremock&quot;&lt;/span&gt;, port));&lt;br/&gt;HttpResponse httpResponse = httpClient.execute(request);&lt;br/&gt;String stringResponse = convertHttpResponseToString(httpResponse);&lt;br/&gt;&lt;br/&gt;verify(getRequestedFor(urlEqualTo(ALIYUN_WIREMOCK_PATH)));&lt;br/&gt;assertEquals(&lt;span&gt;200&lt;/span&gt;, httpResponse.getStatusLine().getStatusCode());&lt;br/&gt;assertEquals(APPLICATION_JSON, httpResponse.getFirstHeader(&lt;span&gt;&quot;Content-Type&quot;&lt;/span&gt;).getValue());&lt;br/&gt;assertEquals(&lt;span&gt;&quot;\&quot;testing-library\&quot;: \&quot;WireMock\&quot;&quot;&lt;/span&gt;, stringResponse);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;代码库地址&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://github.com/wiremock/wiremock&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;结语&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然 Java 有很多遭人诟病的地方，但是 Java 最重要的优点之一，就是它的生态，有其琳琅满目的各种工具类库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;希望大家都“懒”一点，不要埋头去做无效的苦干，不要自己造轮子，你要相信：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;你遇到的问题，基本已经有很多人遇到过了，而且已经被牛人给解决了，把轮子都给你造好了。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看完有收获，可以随手点个&lt;span&gt;&lt;strong&gt;在看&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;&lt;hr/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;你好，我是四猿外。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一家上市公司的技术总监，管理的技术团队一百余人。想了解我如何管理团队——&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3MTg3NDYwNg==&amp;amp;mid=2247485282&amp;amp;idx=1&amp;amp;sn=f368ffae1845809ccf06859f988a88a8&amp;amp;chksm=fcd8cb23cbaf4235db644759c3d8099045d10fc952b950d429e4a5e07ed9a806fddf85c451d3&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;我，管理100多人团队的二三事&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我从一名非计算机专业的毕业生，转行到程序员，一路打拼，一路成长。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我会通过公众号，&lt;br/&gt;把自己的成长故事写成文章，&lt;br/&gt;把枯燥的技术文章写成故事。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我建了一个读者交流群，里面大部分是程序员，一起聊技术、工作、八卦。欢迎加我微信，拉你入群。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9852216748768473&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6nbNnibOq5KQibCDibpTo0kqofPehQvDDibibcb3bQUELdY3Knsl4r0RcgsV9l4icr3icmZQfaBXtSFNTxmdQlAZT1OQg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;609&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>