<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>c6ea36f4e3b41e63796740a84b050e55</guid>
<title>Go 可用性（七）：总结</title>
<link>https://toutiao.io/k/hfpeg25</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;markdown-body&quot;&gt;&lt;div class=&quot;note note-info&quot;&gt;&lt;p&gt;本系列为 Go 进阶训练营 笔记，预计 2021Q2 完成更新，访问 &lt;a href=&quot;https://lailin.xyz/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/&quot;&gt;博客: Go进阶训练营&lt;/a&gt;, 即可查看当前更新进度，部分文章篇幅较长，使用 PC 大屏浏览体验更佳。&lt;/p&gt;&lt;/div&gt;&lt;p&gt;在前面的几篇文章当中我们聊到了 隔离设计、令牌桶算法、漏桶算法、自适应限流和熔断，可用性的建设远不止这些，这一部分的内容在进阶训练营中也讲了 7 个小时，其他部分如果感兴趣的话推荐购买源课程观看。&lt;/p&gt;&lt;p&gt;由于前面的文章大部分都在讲限流相关的内容，所以我们先看一下不同的限流方式的对比&lt;/p&gt;&lt;h2 id=&quot;限流对比&quot;&gt;&lt;a href=&quot;#限流对比&quot; class=&quot;headerlink&quot; title=&quot;限流对比&quot;/&gt;限流对比&lt;/h2&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;类型&lt;/th&gt;&lt;th&gt;实现&lt;/th&gt;&lt;th&gt;优点&lt;/th&gt;&lt;th&gt;缺点&lt;/th&gt;&lt;th&gt;文章&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;单机限流&lt;/td&gt;&lt;td&gt;令牌桶&lt;/td&gt;&lt;td&gt;1. 稳定可靠，实现简单，性能高&lt;br/&gt;2. 支持突发流量应对&lt;/td&gt;&lt;td&gt;1. 流量不均匀会导致误限制&lt;br/&gt;2. 阈值设置较为困难，需要提前压测&lt;/td&gt;&lt;td&gt;&lt;a href=&quot;https://lailin.xyz/post/go-training-week6-2-token-bucket-1.html&quot;&gt;Go可用性(二) 令牌桶原理及使用&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://lailin.xyz/post/go-training-week6-3-token-bucket-2.html&quot;&gt;Go可用性(三) 令牌桶的实现 rate/limit&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td/&gt;&lt;td&gt;漏桶&lt;/td&gt;&lt;td&gt;1. 稳定可靠，实现简单，性能高&lt;/td&gt;&lt;td&gt;1. 流量不均匀会导致误限制&lt;br/&gt;2. 阈值设置较为困难，需要提前压测&lt;br/&gt;3. 不支持突发流量&lt;/td&gt;&lt;td&gt;&lt;a href=&quot;https://lailin.xyz/post/go-training-week6-4-leaky-bucket.html&quot;&gt;Go可用性(四) 漏桶算法&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td/&gt;&lt;td&gt;自适应限流: BBR&lt;/td&gt;&lt;td&gt;1. 根据服务状态进行动态限流&lt;br/&gt;2. 阈值设置简单，无需提前进行压测&lt;br/&gt;3. 服务扩容无需手动调整阈值&lt;/td&gt;&lt;td&gt;1. 需要主动采集相关指标数据（cpu等）&lt;br/&gt;2. 客户端善意限流&lt;br/&gt;3. 应用场景较小&lt;/td&gt;&lt;td&gt;&lt;a href=&quot;https://lailin.xyz/post/go-training-week6-4-auto-limiter.html&quot;&gt;Go可用性(五) 自适应限流&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;全局限流&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;td&gt;1. 应用场景丰富&lt;br/&gt;2. 流量不均不会误触限流，有全局数据，可以合理进行分配&lt;br/&gt;3. 服务扩容无需手动调整阈值&lt;/td&gt;&lt;td&gt;1. 实现较为复杂&lt;br/&gt;2. 配置也较为复杂&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;微服务可用性设计总结&quot;&gt;&lt;a href=&quot;#微服务可用性设计总结&quot; class=&quot;headerlink&quot; title=&quot;微服务可用性设计总结&quot;/&gt;微服务可用性设计总结&lt;/h2&gt;&lt;p&gt;接下来我们就一起来串联我们之前讲到的和课程上讲到的一些内容总结一下可用性应该怎么做。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/20210506135719.jpg&quot; srcset=&quot;/img/loading.gif&quot; alt=&quot;微服务可用性设计总结&quot;/&gt;&lt;/p&gt;&lt;p&gt;如上图所示，我们从一个简单的用户访问出发，用户访问到我们的服务一般是先通过我们的移动客户端或者是浏览器，然后请求再依次通过 CDN、防火墙、API网关、BFF以及各个后端服务，整条链路还是比较长的。&lt;/p&gt;&lt;p&gt;我们上图其实已经一部分体现了隔离设计，所以后面我就不再提了。&lt;/p&gt;&lt;h3 id=&quot;1-移动客户端-浏览器&quot;&gt;&lt;a href=&quot;#1-移动客户端-浏览器&quot; class=&quot;headerlink&quot; title=&quot;1. 移动客户端/浏览器&quot;/&gt;1. 移动客户端/浏览器&lt;/h3&gt;&lt;p&gt;客户端是触及用户的第一线，所以这一层做的可用性优化尤为的重要&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;降级:&lt;/strong&gt; 降级的本质是提供给用户有损服务，所以在触及用户的第一线如何安抚好或者说如何骗过用户的眼睛尤为重要&lt;ul&gt;&lt;li&gt;本地缓存，客户端需要有一些本地缓存数据，不仅可以加速用户首屏的加载时间，还可以在后端服务出现故障的时候起到一定的缓冲作用&lt;/li&gt;&lt;li&gt;降级数据兼容，服务端有时为了降级会返回一些 mock 数据或者是空数据，这些数据一定要和客户端的对接好，如果没有对接好很容易就会出现异常或者是白屏&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;流控:&lt;/strong&gt; 在服务出现问题的时候，用户总是会不断的主动尝试重试，如果不加以限制会让我们本就不堪重负的后端服务雪上加霜&lt;ul&gt;&lt;li&gt;所以在客户端需要做类似熔断的流控措施，常见的思路有指数级退让，或者是通过服务端的返回获取冷却的时间&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;2-BFF-Client&quot;&gt;&lt;a href=&quot;#2-BFF-Client&quot; class=&quot;headerlink&quot; title=&quot;2. BFF/Client&quot;/&gt;2. BFF/Client&lt;/h3&gt;&lt;p&gt;BFF 是我们后端服务的桥头堡，当请求来到 BFF 层的时候，BFF 既是服务端，又是客户端，因为它一般需要请求很多其他的后端服务来完成数据的编排，提供客户端想要的数据&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;超时控制：&lt;/strong&gt;超时控制需要注意的两点是默认值和超时传递&lt;ul&gt;&lt;li&gt;默认值，基础库需要有一些默认值，避免客户端用户漏填，错填，举个例子，如果开发填写一个明显过大的值 100s 才超时，这时候我们基础库可以直接抛出错误，或者是警告只有手动忽略才可以正常启动。我之前有一个应用就是因为忘记配置超时时间，依赖的服务 hang 住导致我的服务也无法正常服务了，即使我之前做了缓存也没有用，因为之前的逻辑是只有请求报错才会降级使用缓存数据。&lt;/li&gt;&lt;li&gt;超时传递，例如我们上图，假设我们整个请求的超时时间配置的 500ms，BFF 里面首先经过一些逻辑判断消耗了 100ms，然后去请求 redis，我们给 redis 配置的超时时间 &lt;code&gt;max_con&lt;/code&gt; 是 500ms，这时候就不能用 500ms 作为超时时间，得用 &lt;code&gt;min(请求剩余的超时时间，max_con)&lt;/code&gt;也就是 400ms 作为我们的超时时间，同样我们请求下游的服务也需要将超时时间携带到 header 信息里面，这样下游服务就可以继承上游的超时时间来进行超时判断。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;负载均衡：&lt;/strong&gt;一般我们比较常用的负载均衡策略就是轮训，或者说加个权重，这个比较大的问题就是，我们的服务性能并不是每个实例都一样，受到宿主机的型号，当前机器上服务的数量等等因素的影响，并且由于我们的服务是在随时漂移和变化的，所以我们没有办法为每个实例配上合适的权重。&lt;ul&gt;&lt;li&gt;所以我们可以根据一些统计数据，例如 cpu、load 等信息获取当前服务的负载情况，然后根据不同的负载情况进行打分，然后来进行流量的分配，这样就可以将我们的流量比较合理的分配到各个实例上了。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;重试：&lt;/strong&gt; &lt;strong&gt;重试一定要注意避免雪崩&lt;/strong&gt;&lt;ul&gt;&lt;li&gt;当我们的服务出现一些错误的时候，我们可以通过重试来解决，例如如果部分实例过载导致请求很慢，我们通过重试，加上面的负载均衡可以将请求发送到正常的实例，这样可以提高我们的 SLA&lt;/li&gt;&lt;li&gt;但是需要的注意的是，重试只能在错误发生的地方进行重试，不能级联重试，级联重试很容易造成雪崩，一般的做法就是约定一个 code 只要出现这个 code 我们就知道下游已经尝试过重试了，我们就不要再重试了&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;熔断：&lt;/strong&gt;一般来说如果只是部分实例出现了问题，我们通过负载均衡阶段+重试一般就可以解决，但如果服务整体出现了问题，作为客户端就需要使用熔断的措施了。&lt;ul&gt;&lt;li&gt;熔断常见的有开启，关闭，半开启的状态，例如 hystrix-go 的实现，但是这种方式比较死板，只要触发了熔断就一个请求都无法放过，所以就又学习了 Google SRE 的做法，同构计算概率来进行判断，没有了半开启的状态，开启的时候也不会说是一刀切。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;降级：&lt;/strong&gt;当我们请求一些不那么重要的服务出现错误时，我们可以通过降级的方式来返回请求，降级一般在 BFF 层做，可以有效的防止污染其他服务的缓存。常见的讨论有返回 mock 数据，缓存数据，空数据等&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;3-Server&quot;&gt;&lt;a href=&quot;#3-Server&quot; class=&quot;headerlink&quot; title=&quot;3. Server&quot;/&gt;3. Server&lt;/h3&gt;&lt;p&gt;BFF 其实也是服务端，但是为了流畅的讲解，主要将其作为了客户端的角色。服务端主要的是限流的措施，当流量从 BFF 来到我们的服务之后，我们会使用令牌桶算法尝试获取 token，如果 token 不够就丢弃，如果 token 足够就完成请求逻辑。&lt;/p&gt;&lt;p&gt;我们的 token 是从哪里来的呢？&lt;/p&gt;&lt;p&gt;拦截器会定时的向 Token Server 上报心跳数据，包含了一些统计信息，同时从 Token Server 获取一定数量的 Token，当 Token Server 接受到请求之后会通过最大最小公平分享的算法，根据每个服务实例上报的统计信息进行 Token 的分配。&lt;/p&gt;&lt;p&gt;这个其实就是之前没有讲到的分布式限流的思路，在单个服务实例上又使用了单机限流的算法&lt;/p&gt;&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;/&gt;总结&lt;/h2&gt;&lt;p&gt;到这里我们的可用性相关的知识点就算是告一段落了，前面的文章主要讲解了限流的相关知识点，虽然其他的没有细说，但是这一篇总结也算是都涉及到了，包括隔离设计、限流（单机限流、自适应限流、分布式限流）、超时控制、降级、熔断、负载均衡、重试，如果想要了解细节内容，可以区报名毛大的课程。OK，话不多说，我们下篇文章见。&lt;/p&gt;&lt;div class=&quot;note note-info&quot;&gt;&lt;p&gt;第 0 期已经结束，想要报名后面课程的同学，我联系极客时间为大家争取到了读者专属优惠&lt;br/&gt;&lt;strong&gt;扫描下方微信公众号二维码，发送【福利】获取专属优惠，比官方优惠更给力哦&lt;/strong&gt;&lt;/p&gt;&lt;/div&gt;&lt;h2 id=&quot;关注我获取更新&quot;&gt;&lt;a href=&quot;#关注我获取更新&quot; class=&quot;headerlink&quot; title=&quot;关注我获取更新&quot;/&gt;关注我获取更新&lt;a class=&quot;anchorjs-link&quot; aria-label=&quot;Anchor&quot; data-anchorjs-icon=&quot;&quot; href=&quot;#关注我获取更新&quot;/&gt;&lt;/h2&gt;&lt;h2 id=&quot;猜你喜欢&quot;&gt;猜你喜欢&lt;/h2&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d446e2316c294a76663d9468f6e22f02</guid>
<title>[推荐] 企业微信万亿级日志检索系统</title>
<link>https://toutiao.io/k/t1o49fm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：datonli，腾讯 WXG 后台开发工程师&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开发在定位问题时需要查找日志，但企业微信业务模块日志存储在本机磁盘，这会造成以下问题：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;日志查找效率低下&lt;/strong&gt;：一次用户请求涉及近十个模块，几十台机器，查找日志需要登录机器 grep 日志文件。这一过程通常需要耗费 10 分钟以上，非常低效；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;日志保存时间短&lt;/strong&gt;：单机磁盘存储容量有限，为保存最新日志，清理脚本周期清理旧日志文件腾出磁盘空间，比如：现网一核心存储 7 天日志占用了 90%的磁盘空间，7 天前日志都会被清理，用户投诉因日志被清理而得不到解决；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;日志缺失&lt;/strong&gt;：虽然现网保留 7 天最新日志，但是由于某些模块请求量大或日志打印不合理，我们也会限制一个小时日志打印量，超过阈值后不再保存，比如：现网一核心存储前 10 分钟打了 10G 日志达到阈值，后 50 分钟日志不再保存了，用户投诉因日志缺失无法得到解决。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们希望有这样一个日志系统：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;存储全量日志&lt;/strong&gt;：由于 To B 业务的特殊性，至少需要保存 30 天的全量日志（&lt;strong&gt;数 PB 日志量，日志达数万亿条&lt;/strong&gt;），方便回查日志定位问题；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;日志快速定位&lt;/strong&gt;：根据模块+时间段+关键字或用户请求信息快速定位日志；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;实时性&lt;/strong&gt;：日志峰值达数亿条每秒，需要做到秒级入库、秒级可查；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;支持日志模糊匹配和统计&lt;/strong&gt;：单机日志查询常用到模糊匹配以及 awk/uniq/sort 等复杂统计，在新日志系统同样希望能够支持；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;支持模块级全量日志查询&lt;/strong&gt;：日常运营中有些用户投诉的问题并不确定具体发生时间，需要对模块进行全量日志（日志量达 TB 级别）查询。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;业界方案对比&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;公司内外有很多日志系统方案，根据是否对日志做全文检索可以分为两类：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;全文检索的日志系统&lt;/strong&gt;：对日志内容切分词和建倒排，通过查询关键词的倒排取交集支持模糊匹配，这类系统一般入库资源消耗较多，也不支持日志统计，典型实现有：ELK、Hermes 以及腾讯云日志服务(Cloud Log Service, CLS)等系统；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;部分字段检索的日志系统&lt;/strong&gt;：只对部分字段建索引，支持特定字段的快速检索，入库资源消耗较低，但是这类系统对模糊匹配未能很好支持，也不支持日志统计，不支持模块级全量日志查询，如 wxlog、LogTrace 等系统。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们新设计的检索系统在资源消耗较小的前提下，很好满足背景所提的所有检索需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;方案设计的考虑&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;保存时间短和日志缺失的问题&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单机存储空间的限制导致日志丢失，日志也没法长时间保存，如何突破单机存储空间限制呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;嗯，是的，使用分布式文件系统替换单机文件系统就可以了！在可水平扩展的分布式文件系统支撑下，存储空间无限大，日志不再因存储空间而丢失了。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;日志查找效率低下问题&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;日志查找效率低下，其根源是日志散落到多台机器，需要登录到机器做日志 grep。引入了分布式文件系统存储全网日志后，我们看到的仍然是一个一个不相关的日志文件，快速定位日志仍然困难。如何提高日志定位的效率呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;索引！就像是利用索引提升数据库表查询效率一样，我们对日志数据建立索引，快速定位到所需日志。那么，需要构建怎样的索引呢？先看看面临的两种问题定位场景：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;开发收到模块告警，通过告警信息结合代码找到关键字，使用关键字查找模块告警时间段内的日志；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;根据用户投诉找到用户请求信息，使用用户请求信息查找所有关联模块的日志。从以上场景看出，我们通常根据模块+时间段+关键字或者用户请求信息查找日志。所以，对模块、时间、用户请求信息建索引提升日志查找效率。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;入库资源消耗问题&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了支持模糊查询，业界方案一般都会对日志内容分词建索引，这会消耗大量资源。日志查询系统有两个特点：每天只有数百次查询请求，日志存储模块（分布式文件系统）IO 密集、CPU 利用率低。为了支持用户模糊查询请求，入库时不对日志内容分词建索引。用户查询时，日志存储模块使用关键字对日志内容正则匹配过滤（利用本机空闲 CPU）。这样既解决了入库资源消耗高的问题，又解决了存储机 CPU 低利用率的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;面临的挑战&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们通过分布式文件系统和索引解决了目前的问题，同时也带来了新的挑战：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;高性能&lt;/strong&gt;：目前企业微信日志量月级数 PB，日志数万亿条，天级数百 TB，面对如此海量日志，如何做到入库和查询的高性能？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;可靠性&lt;/strong&gt;：引入了分布式文件系统以及索引带来更大的复杂性，如何保证整个日志系统可靠性？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;支持灵活多变的用户查询需求&lt;/strong&gt;：通过调研发现，用户主要有以下 4 种日志查询使用场景：a) 一次用户请求关联的所有模块日志查询；b) 模块一段时间内日志模糊查询；c) 模块全量日志模糊查询；d) 查询日志统计（如：awk/uniq/sort 指令等）。如何支持如此灵活多变的用户查询需求？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;名词解释&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在介绍系统前，先对使用的名词进行解释：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;callid：唯一标识一次用户请求，每条日志中都会携带 callid 信息；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;模糊查询：根据用户输入模块、时间段和关键字查询日志；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;全链路查询：根据 callid 查询一次用户请求所有关联的模块日志。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;系统架构&lt;/span&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.717607973421927&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasBoHV69oNfvHptKWUoULAib1BibN5Jvwf4vGHpOvtDxDRNUiamFl2XUaCquToibq6qjXNuBhuoVIcWxQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1505&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;企业微信日志检索系统主要分为 6 个模块：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;LogAgent：和业务模块同机部署，对模块内日志进行聚集，数据批量写分布式文件系统，callid 索引批量发送到 LogMergeSvr 聚集；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LogMergeSvr：对一段时间内的 callid 索引进行模块间聚集，批量写分布式文件系统；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;存储模块(分布式文件系统)：存储原始日志数据、时间索引和 callid 索引数据；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LogIdxSvr：对 callid 索引进行全网聚合，底层存储用的是 Rocksdb；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;WebSvr：接收用户网页请求，并发查询 QuerySvr。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;QuerySvr：查询执行模块，支持全链路查询、模糊查询、awk 统计等。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来分别阐述系统设计和实现中面临的挑战点以及解决办法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如何实现系统高性能&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;日志入库高性能&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前，企业微信全网日志入库峰值 qps 数亿条每秒，而分布式文件系统数据节点仅仅 20 台（单台 12 块 SATA 盘，单盘 IOPS 约 100 左右），我们如何使用少量数据节点支撑如此高峰值的日志秒级入库呢？&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数据入库高性能&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在模糊查询场景下，用户使用模块/机器+时间段+关键字进行查询。为提升数据入库性能，我们以每台机器的 IP 作为分布式文件系统的目录，机器上模块打印的日志写入小时粒度的日志文件，这样不同机器写入自己独占的日志数据文件，相互间数据写入无竞争，入库性能最佳。与此同时，目录结构就相当于一个快速区分不同模块/机器的索引，这也能提升日志查询效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了进一步提升数据入库性能，LogAgent 使用缓冲队列缓存日志数据，累积 8MB 数据后批量顺序写入日志文件中，写 qps 降低为原本的 4 万分之一。同时为了快速查找日志数据，对 8MB 日志数据的时间戳采样，批量写入同目录下的时间索引文件中。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;callid 索引入库高性能&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同一 callid 索引散落在不同模块不同机器，为了全链路查询，需要对数亿条/秒的 callid 索引做秒级聚合，以支持秒级入库、秒级可查，这无疑是一个技术难题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决这一难题，我们通过三重聚合减少 callid 索引写入压力，最终达到 qps 减少到千万分之一、一次 IO 读取 callid 所有日志位置的效果：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;模块内聚合：LogAgent 聚合模块内 callid 索引，批量写入 LogMergeSvr，qps 约减少到万分之一；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;模块间聚合：LogMergeSvr 聚合模块间一段时间内的 callid 索引，批量写分布式文件系统，qps 约减少到千分之一；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;全网聚合：callid 索引文件不利于高效读取，LogIdxSvr 利用 Rocksdb 的 Merge 聚合全网的 callid 索引，一次 IO 可读取 callid 所有日志位置。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.46911764705882353&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasBoHV69oNfvHptKWUoULAibUKITIptJiayn2NUuT4eQo5PoiahZdhhCEfvpOHIibB0ZGC5pNaQAzgBDQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1360&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;日志查询高性能&lt;/span&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;增加索引提升查询性能&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开发通常依据模块、时间段、callid 这 3 个维度查询日志，为了加快查询性能也对这 3 个维度分别增加索引：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;模块：一个模块包含若干机器，每台机器在分布式文件系统中拥有独占的日志目录（用 IP 区分），用于保存机器小时粒度日志文件。通过模块找到所有机器 IP 后，可快速找到该模块的日志在分布式文件系统中的日志目录。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;时间段：日志数据保存在机器目录的小时粒度文件中，通过对日志时间采样保存为相应时间索引文件。当按照时间段查找日志时，可根据时间索引文件快速找到该时间段的日志位置范围。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;callid：解析日志建立 callid 到日志位置的索引，散落在多个模块的 callid 索引通过 LogAgent、LogMergeSvr 以及 LogIdxSvr 三重聚合后，最终存储在 LogIdxSvr 的 Rocksdb 中。全链路日志查询可通过读取一次 Rocksdb 获取所有相关日志位置，快速读取到所需日志。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;模糊查询高性能&lt;/span&gt;&lt;/h5&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;原始版本：并发检索
WebSvr 接收用户模糊查询请求（模块+时间段+关键字），依据模块获取机器列表后，按机器列表并发请求到多台 QuerySvr 执行机器粒度日志查询：通过机器 IP 找到机器日志目录，根据时间段拉取时间索引文件，确定日志数据范围，并发拉取日志到本机用关键字做模糊匹配。最终将匹配后的日志返回给 WebSvr 聚合展示给用户。&lt;/p&gt;&lt;p&gt;通过并发检索的优化手段，模糊查询一个模块一小时日志（12 台机器，7.95GB 日志量）耗时从 1 分钟降到 5.6 秒。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6813880126182965&quot; data-type=&quot;jpeg&quot; data-w=&quot;1585&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasBoHV69oNfvHptKWUoULAibm1icuIDoNPLpy40Mwq8FMXlX06rgfvtJlcgUhZzeyxBAvP90qVxUmibg/640?wx_fmt=jpeg&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;优化版本：模糊匹配下沉分布式文件系统
在系统压测时我们发现 QuerySvr 带宽和 cpu 存在性能瓶颈，原因是 QuerySvr 读取大量未模糊匹配的日志数据，打满了网络带宽，并且在 QuerySvr 做模糊匹配也会消耗大量 cpu 资源。我们需要进行性能优化。考虑到分布式文件系统是重 IO 操作，cpu 利用率很低，将模糊匹配逻辑下沉到分布式文件系统，这样既解决了 QuerySvr 带宽和 cpu 性能瓶颈问题，又充分利用了文件系统的 cpu，避免资源浪费。通过模糊匹配下沉的优化手段，模糊查询一个模块一小时日志（12 台机器，7.95GB 日志量）耗时从 5.6 秒降到 2.5 秒。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5546995377503852&quot; data-type=&quot;jpeg&quot; data-w=&quot;1947&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasBoHV69oNfvHptKWUoULAibBfdUeU7klsFjq2yY51fm3CIumX0blBOKzx4MTEG6bUIUpWZEzxfjWQ/640?wx_fmt=jpeg&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;全链路查询高性能&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;全链路查询和模糊查询类似，同样利用了并发提升查询性能，稍有不同的是全链路查询根据 callid 读取 LogIdxSvr 确定日志位置列表，按照位置列表并发读取日志数据，聚合后将日志返回给用户。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如何保证系统可靠性&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们通过引入了分布式文件系统和索引服务解决了日志丢失、保存时间短和快速定位问题，但系统复杂性导致的可靠性问题，是我们面临的第二大挑战。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数据可靠性保证&lt;/span&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;日志数据缓冲队列（共享内存+本机磁盘文件）&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;LogAgent 负责将日志数据和时间索引写入分布式文件系统，当分布式文件系统抖动时，为了不丢弃待写日志数据，LogAgent 使用缓冲队列（共享内存+本机磁盘文件）缓存日志数据，待抖动恢复后读出缓存数据写入文件系统。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;索引可靠性保证&lt;/span&gt;&lt;/h5&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;服务抖动
LogIdxSvr 使用 Rocksdb 作为底层存储聚合全网 callid 索引，但是 Rocksdb 在高并发写入时容易出现写入抖动进而导致索引丢失，为了保证 callid 索引可靠性，LogMergeSvr 先将 callid 索引写入分布式文件系统保存，LogIdxSvr 从分布式文件系统拉，分布式文件系统当做 queue 使用起到削峰填谷作用，保证 callid 索引可靠性。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;机器坏盘
LogIdxSvr 出现坏盘会导致已聚合到本机的 callid 索引数据丢失，新起的 LogIdxSvr 重新拉取分布式文件系统的 callid 索引文件，可以重建 Rocksdb 的 callid 索引，保证系统可靠性。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如何支持灵活多变的用户查询请求&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过前面的设计，目前可以根据模块+时间段+关键字或者 callid 查找到日志了，但是还不够，用户往往还需要对日志做任意维度模糊匹配、日志统计（如：uniq/sort/awk 等）以及模块级全量日志查询。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;支持任意维度模糊匹配&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如前所述，通过在分布式文件系统实现模糊匹配逻辑，系统支持对日志做任意维度模糊匹配的需求。通过对比，选择性能最优的 RE2 正则匹配库实现模糊匹配逻辑。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5393700787401575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasBoHV69oNfvHptKWUoULAibjeDCYVekpqmZscSgFdpdk9I3Q1N4YQ4He1zEyRUHNUSyw4Glmktz9w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;508&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;支持 awk/uniq/sort 等统计指令&lt;/span&gt;&lt;/h4&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;支持统计指令
用户不仅需要对日志做模糊匹配，还需要对匹配后的日志执行 awk/uniq/sort 等统计指令，其中涉及到指令相互嵌套执行，非常复杂，难以调用相关库实现。我们通过子进程调用系统 shell 支持这一需求。QuerySvr 从分布式文件系统拉取日志数据到本机后，子进程 shell 调用用户传入统计指令处理日志数据，最终结果返回给 WebSvr。子进程处理超时父进程将 kill 掉子进程，防止用户统计任务耗光 QuerySvr 资源。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9254185692541856&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasBoHV69oNfvHptKWUoULAibib8xqlOgibTSibJibKrXvO98qQPZ3GraoTPHgblM1St0KO2F8JysaDvPEA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;657&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;安全考虑
由于用户指令可由用户自定义输入，指令执行的安全问题需要重点考虑。通过两个方法确保执行指令的安全：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;changeroot：使用 Linux 的 changeroot 避免用户指令操作系统重要目录；&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5696594427244582&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasBoHV69oNfvHptKWUoULAibw6MwzktJiaSvousUBALyAs58QScQibmUtozL7vd3tNqlUUlGLgjgtJRA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;646&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;沙盒限制：使用 Linux 支持的沙盒隔离技术，只允许执行特定指令。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6555555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasBoHV69oNfvHptKWUoULAibpOrVbj0Sib3kGkcJGibwibCuUJDMBYLOicwBIzRP44VcJsJP8dsyRmgQHw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;450&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;支持模块级全量日志查询——异步任务&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;模块级全量日志查询通常涉及 TB 级别日志量，因为涉及的数据量过大，查询耗时一般较长，无法给用户提供实时返回，我们通过提供异步任务功能支持这一需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户异步任务请求通过 WebSvr 转发到 QuerySvr，为避免 QuerySvr 宕机导致异步任务丢失，QuerySvr 会将异步任务写入一致性锁服务中存储，空闲的 QuerySvr 会从一致性锁服务抢锁，抢锁成功后执行该异步任务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;QuerySvr 根据异步任务的模块信息读取机器列表，按照机器列表并发读取匹配的日志数据，按顺序写入本机磁盘中，在查询结束后更新一致性锁服务状态（存储机 ip 和路径），用户页面刷新会拉取到异步任务最新状态。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5333333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasBoHV69oNfvHptKWUoULAibVh88zfMa5xOBUXR8Myb0cOI6r2IYYBehtFuQHoF5BWTdsNRTwg4iayg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1980&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fd2508dbd06110abd730f8820c6363f4</guid>
<title>[推荐] Golang 内存管理分析</title>
<link>https://toutiao.io/k/5za3e5u</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;大纲&lt;/h1&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;1. 目录&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;2. 由一个问题展开&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;3. 名字说明&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;4. 内存怎么采样？&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;4.1 编译期间逃逸分析&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;4.2 采样的简单实现&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;4.3 内存采样的时机&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;4.4 内存采样的入口&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;4.5 内存采样的信息&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;4.6 golang的类型反射&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;5. 内存分配&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;5.1 C语言你分配和释放内存怎么做？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;5.2 内存分配设计考虑的几个问题&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;5.3 golang的内存分配&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;6. 内存回收&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;6.1 golang协程抢占执行&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;6.2 STW是怎么回事？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;6.3 垃圾回收要求&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;6.4 golang版本迭代历史&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;6.5 GC触发条件&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;6.6 三色定义&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;6.7 GC流程&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;6.8 写屏障&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;6.9 内存可见性&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;6.10 注意问题&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 目录&lt;strong/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 由一个问题展开&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;golang从语言级别，就提供了完整的采样和分析的机制。大家经常使用 pprof 分析内存占用。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5359477124183006&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DIlBNOZ88iaCnvgTgGLTF9HbeHX7WCJS22BYiajN5aXVWj6qzGLuf2EXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1530&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是不清楚怎么实现？不清楚怎么看指标？不清楚 flat，cum的区别？我们就从这个问题展开。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 名字说明&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;内存分析的时候，有四个输入选项：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;alloc_objects : 历史总分配的累计&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;alloc_space ：历史总分配累计&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;inuse_objects：当前正在使用的对象数&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;堆上分配出来，业务正在使用的，也包括业务没有使用但是还没有垃圾回收掉的对象。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;inuse_space：当前正在使用的内存&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;两个输出选项：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;flat：平坦分配，非累加&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;cum：累加&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;思考几个问题：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;上面说的对象是什么概念？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;经常使用内存分析，这个内存分析是否是精确的？性能消耗大不大&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为啥显示的是堆栈？不是说分配的对象吗？为啥不直接显示分配的对象结构名？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. 内存怎么采样？&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.1 编译期间逃逸分析&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说明下，golang pprof是分析从堆上分配的内存。golang的内存在堆上，还是在栈上？这个不是我们决定的，就算你调用new这个关键字，也不一定是在堆上分配。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.29850746268656714&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DwtPSLRiaQhRoe92zpicanF5zAKlECXHeME4ZKqAwfOHSZicz1zJu5cfvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;402&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.21794871794871795&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DwB356SekRQGzKxIMD16Kropp3P1q4TH9picsL6VPF3UwSM1NY3yn7eQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1014&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;逃逸分析是golang的一个非常重要的一个点。&lt;/span&gt;&lt;span&gt;对于内存分配，垃圾回收的设计都有非常重要的影响。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2 采样的简单实现&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;采样的实现非常简单。简单描述流程：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;用一个公共变量用来记录&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分配内存的时候，加alloc size，加alloc对象数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;释放内存的时候，加free size，加free对象数&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;累计分配：就是alloc
当前在用 inuse：就是 &lt;code&gt;alloc-free&lt;/code&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.8091603053435115&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DjOF71fW6Fln0WUH6ulvHYPkYGomUPHPOUicXY7dutDSQn8opHbVfTdw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;655&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.3 内存采样的时机&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;采样的时机说3个点：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;分配堆上内存的时候，累计分配&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;回收器释放堆上内存的时候，累计释放&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每512KB打点采样&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是注意一点：并不是每一次分配内存都会被采样。也就是说这里其实是有个权衡的。现在是每满512KB才会采样一次。这里的考虑是性能和采样效果的权衡。因为采样是要耗费性能的，是要取堆栈的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;怎么理解？举个例子&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理想情况下（不考虑其他任何影响）：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4197247706422018&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4Dv7xia7VVEaaxR0V7ZASiagO7tuibSQTI8TwD3JeXqdFUQOXITx6qbr9ibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1744&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么有人会想，这样岂不是会漏掉了很多内存？统计还能用来排查问题吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个是性能和效果的一个考虑，一般来讲，我们是用pprof分析内存占用的时候，在整个golang程序跑起来后，时时刻刻都在分配释放内存，每累计分配512KB，打点一次。虽然会漏掉一些内存分配释放，但是对每个结构都是公平的。如果有一个内存泄露分配行为，那么累计下来一定会被抓住的，并且是非常容易被抓住。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.4 内存采样的入口&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存采样的入口，这个非常简单理解。肯定是一个在分配内存的函数位置，一个是释放内存的位置。这里要特意提下上下文环境。因为golang是垃圾回收类型的语言，内存分配是完全交由golang自己管理，自己不能管理内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;两个入口函数：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;mProf_Malloc&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;mProf_Free&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两个是配套使用的采样打点函数。而且一定是配套的。简单说：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;mProf_Malloc 是由业务程序行为（赋值器）触发的，分配内存嘛。比如你new了一个对象，这个对象在堆上，那么会调用 &lt;code&gt;mallocgc&lt;/code&gt; 分配内存，如果到了采样点，那么会调用 &lt;code&gt;mProf_Malloc&lt;/code&gt; 采样。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;mProf_Free 是回收器在确定并且将要回收内存的时候调用的。是垃圾回收过程的一环。并且还要注意一点，只有打过点的（mProf_Malloc计数过的对象，会有一个特殊处理），才会配套使用mProf_Free。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;不是说，任意给一个内存地址给你。你都知道这个是业务类型。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.5 内存采样的信息&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里问你的是，golang采样是采样啥？类型信息？这里也说过一点，内存这里和类型系统是没啥关系的。这里采样的是分配栈，也就是分配路径。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.5.1 flat，cum 分别是怎么来的？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看个例子：&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.9725490196078431&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DfG9con5dbDHuPsyiaUFqnA9qEMNoNfPWuus2C0e6DEtq2KcibB9nKUmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;510&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家可以先猜下，我们看alloc_space。这个内存会是怎么累计到的。实际统计如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3450087565674256&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DiapKxudCtticZGcDvZy4vFrYO4RB8yeQSak92CgqdiaSOf9gvacMcicqbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;571&quot;/&gt;&lt;/p&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和大家猜的一样吗？这些是怎么看。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;首先说几个结论：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;flat统计到的，就是这个函数实际分配的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;cum是累计的，包含自己分配的，也包含路过的。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;cum和flat不相同的时候，代表这个函数除了自己分配内存，自己内部调用的别的函数也在分配内存。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;重点提示：这个要理解这个，首先要知道，内存采样的是什么，内存采样的是分配栈。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;解释说明&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（图中140M我们当150M看哈，这里采样少了第一次，细节原因可以看代码，这里提一下，不做阐述。）：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;main函数里，A函数调用了5次，B函数 5次，C函数5次。其中B会调用A，C会调用B。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用一次A会分配10M内存，调用一次B会分配20M，调用一次C会分配30M。总累计分配内存是300M&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;A函数实际调用次数是 15次；这个和flat的值是一致的：150M&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;(A) * 5&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;(B -&amp;gt; A) * 5&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;(C -&amp;gt; B -&amp;gt; A) * 5&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;B函数函数实际调用10次；这个和flat的值也是一致的：100M&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;B * 5&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;(C -&amp;gt; B) * 5&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;C函数5次：这个和flat的值是一致的：50M&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;C * 5&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;main函数300M，也是一致的。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;图示&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.8029925187032418&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DfIOOpsV7U94sIWrGM8vhXBQMq9SgljYRHPwx5PKZicaqMDEahawGeqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;802&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;记住一句话：采样是记录分配堆栈，而不是类型信息。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.6 golang的类型反射&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;思考几个问题：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;任意给一个内存地址给你，能知道这个对象类型吗？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;golang的反射到底是怎么回事？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先说结论：golang里面，内存块是没有携带对象类型信息的，这个跟C是一样的。但是golang又有反射，golang的反射一定要基于interface使用。这个要仔细理解下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为，golang里面interface的结构变量，是会记录type类型的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;反射定律一：&lt;/strong&gt;反射一定是基于接口的。是从接口到反射类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;反射定律二：&lt;/strong&gt;反射一定是基于接口的。是从反射类型到接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是那句话，golang的反射一定是依赖接口类型的，一定是经过接口倒腾过的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.44385026737967914&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DR1Tyicnbtesda7qV9SViavDJ0siaWEe1AtzTb5a3tRWnJqdlvzwQTAmAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;374&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为当前接口这个类型对应了两个内部结构：&lt;code&gt;struct iface&lt;/code&gt;，&lt;code&gt;struct eface&lt;/code&gt;，这两个结构都是会存储type类型。以后的一切都是基于这个类型的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5. 内存分配&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.1 C语言你分配和释放内存怎么做？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;思考一个问题，在C语言里，我们分配内存：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分配内存的时候，传入大小，拿到一个指针。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;c&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;ptr = malloc(1024);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;释放内存的时候，直接传入ptr，没有任何其他参数：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;c&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;free (ptr);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;释放的时候，怎么确定释放哪些位置？如果要你自己实现，有很多简单的思路，说一个最简单的：分配的时候，不止分配1024字节，还分配了其他的信息，带head了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.3878048780487804&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DpWk8icmdLTf4ddR3pOjLzymKAEC6icv2V9NtG32IAicz0ic9qUH9K8Z1BA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;410&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种分配方式有什么问题：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;开销大，在通用的内存分配器中，很多场景下，有可能meta信息比自身还要大。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2 内存分配设计考虑的几个问题&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;性能&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;局部性&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;碎片率&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;内部碎片率&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;外部碎片率&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3 golang的内存分配&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;golang大方向的考虑就是基于局部性和碎片率来考虑的。使用的是和tcmalloc一致的设计。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.1 整体设计&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，内存块是不带类型信息的。像我们在C语言里面，有时候实现的简单的内存池，在不考虑一些开销的时候，会把业务类型放到meta信息里，为的是排查问题方便。golang内存管理作为一个通用模块，不会这么搞。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.1.1 地址空间设计&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多时候，你查golang的资料，会看到这张图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.16575449569976544&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4Deia6DHht4QwS4kE9VUW6yHlvY6Iwl2bnYf4iaK6p35KdicwL6ejnnmQmQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1279&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这张图有几个信息比较重要&lt;/strong&gt;：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;为什么spans区域是512M，bitmap区是16G，arena是512G？先不要纠结值，我们先说这个比例关系：&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;spans区域，一个指针大小（8Byte）对应arena的一个page（8KB），倍数是1024&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;bitmap区域，一个字节（8bit）对应arena的32Bytes，倍数是32倍&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;我们给用户分配的内存就是arena区域的内存，spans区，bitmap区均为其他用途的元数据信息。&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;bitmap这个实现我们这次不谈，不同通过这个你得知道一点：并不是所有的内存空间都会扫描一把，是有挑选判断的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;spans区域是一般用来根据一个内存地址查询mspan结构的。调用函数：spanOf。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;bitmap是用来辅助垃圾回收用的区域。有这个bitmap信息可以提高回收效率和精度。注意一点，这个不是标识object是否分配的位图，标识是否分配object的问题是&lt;code&gt;mspan.allocBits&lt;/code&gt;结构。这个可以理解为提高垃圾回收效率的实现。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意几个点：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;很多文章都提到golang内存512GB这个事情。512GB说的是内存虚拟地址空间的限制，是最大能力，是最大的规划利用。golang之前最大可以使用的内存地址空间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;golang1.11 之后已经没有512GB的限制了。基本上和系统的虚拟地址空间一致&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这个比例还是一样的，1：1024，1：32&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;就算golang1.11之前，也不是说golang的程序上来就向系统申请这么大块虚拟地址。也是每64M的申请，管理对象单元是heapArea结构。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;三个区域看着连续结在一起，但是其实不是连续的地址。&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;实际的实现中都是以64M（heapArena）的小单位进行的。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.2 抽象对象概念&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4629981024667932&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4D6IqsF5vpIumCKMxwOhDB4A4dQeakqdwOZRt95gicXbqVY09K56bYiaJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1054&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;物理偏向概念&lt;/strong&gt;：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;heapArena：堆上物理空间管理的一个小单元，64M一个。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;page：物理内存最小单位，8KB一个。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;逻辑偏向概念&lt;/strong&gt;：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;span：span为内存分配的一个管理单元。span内按照固定大小size划分，相同的size划分为同一类。一个span管理一个连续的page。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;object：内存分配的最小单元。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;管理结构层次概念&lt;/strong&gt;：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;mcache：每个M上的，管理内存用的。我们都知道GMP架构，每个M都有自己的内存cache管理，这样是为了局部性。只是一个cache管理。mcentral：mheap结构所有，也只是一个cache管理，但是是为所有人服务的。mheap：是真正负责分配和释放物理内存的。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.3 局部性的设计&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个思路很简单，就是设计成局部性的一个层次设计。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.3.1 mcache&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;mcache由于只归属自己的M，span一旦在这个结构管理下，其他人是不可见，不会去操作的。只有这个m会操作。所以自然就不需要加锁。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.3.2 mcentral&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;mcentral是所有人可见的。所以操作自然要互斥，这个的作用也是一个cache的统一管理。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.3.3 mheap&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个是负责真实内存分配和释放的的一个结构。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.4 针对碎片率的设计&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;golang的内存设计目标：碎片率平均12.5%左右。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7231726283048211&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DRE53brYCleJl6622uSwAsh9QFwu9GBhezQMxT19GDEibhB4OibnrKQNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;643&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;tail wast实际是浪费的外部碎片&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;比如说，第一种size，8字节。一个page 8KB，8字节刚好对齐。外部碎片为0.&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;max waste说的是最大的内部碎片率&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;怎么算的？每一个放进该span的对象大小都是最小值的情况&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;比如说，第一种size，8字节。最小的对象是1字节，浪费7字节，最大碎片率为 1-1/8 = 87.5%&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;怎么的出来的这些值？经验值吧，可能。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6. 内存回收&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.1 golang协程抢占执行&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，golang没有真正的抢占。golang调度单位为协程，所谓抢占，也就是强行剥夺执行权。但是有一点，golang本质上是非抢占的，不像操作系统那样，有时钟中断和时间片的概念。golang虽然里面是有一个抢占的概念，但是注意了，这个抢占是建议性质的抢占，也就是说，如果有协程不听话，那是没有办法的，实现抢占的效果是要对方协程自己配合的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一句话：系统想让某个goroutine自己放弃执行权，会给这个协程设置一个魔数，协程在切调度，或者其他时机检查到了的时候，会感知到这一个行为。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;当前的抢占实现是：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;给这个协程设置一个的魔数(stackguard)。每个函数的入口会比较当前栈寄存器值和stackguard值来决定是否触发morestack函数。（这是一个抢占调度点）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;协程调用函数的时候，会检查是否需要栈扩容。如果被设置了抢占标示，那么就会首先调用到&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用newstack，在newstack里面判断是否是特殊值，这种特殊值，目的不在于扩容，而在于让出调度。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，在golang里面，只要有函数调用，就会有感知抢占的时机。stw就是基于这个实现的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;思考一个问题：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果有一个猥琐的函数：非常耗时，一直在做cpu操作，并且完全没有函数调用。这种情况下，golang是没有一点办法的。那么这种情况会影响到整个程序的能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，我们平时写函数，一定要短小精悍，功能拆分合理。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.2 STW是怎么回事？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;STW：stop the world，也就是说暂停说由协程的调度和执行。stw是怎么实现？stw的基础就是上面提到的抢占实现。stw调用的目的是为了让整个程序（赋值器停止），那么就需要剥夺每一个协程的执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;stw在垃圾回收的几个关键操作里是需要的，比如开启垃圾回收，需要stw，做好准备工作。如果stw的时候，出现了猥琐的函数，那么会导致整个系统的能力降低。因为大家都在等你一个人。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.3 垃圾回收要求&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;正确性：绝对不能回收正在使用的的内存对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;存活性：一轮回收过程一定是有边界，可结束的。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.4 golang版本迭代历史&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;go 1.3 以前，使用是标记-清扫的方式，整个过程需要stw&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;go 1.3 版本分离了标记和清扫操作，标记过程stw，清扫过程并发执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;go 1.5 版本在标记过程中，使用三色标记法。回收过程分为四个阶段，其中，标记和清扫都并发执行的，但标记阶段的前后需要stw一定时间来做gc的准备工作和栈的re-scan。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;go 1.8 版本引入了混合写屏障机制，避免了对栈的re-scan，极大的减少了stw的时间。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.5 GC触发条件&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;gcTriggerHeap 当分配的内存达到一定值就触发GC&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;gcTriggerTime 当一定时间没有执行过GC就触发&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;gcTriggerCycle 要求启动新一轮的GC，一启动则跳过，手动触发GC的runtime.GC( )会使用这个条件&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.6 三色定义&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.6.1 强三色&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;黑色对象不允许指向白色对象。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.6.2 弱三色&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;黑色对象可以指向白色对象，但是前提是，该白色对象一定是处于灰色保护链中。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.7 GC流程&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里不详细阐述了。贴一张go1.8之前的图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4515625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DzW1eHrJBFC877UblYFvicerpibx33hDrxmbKq41EQEwSmaYlmGAJOiaZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当下GC大概分为四个阶段：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;GC准备阶段&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;标记阶段&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;标记结束阶段&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;清理阶段&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.8 写屏障&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果标记和回收不用和应用程序并发，在标记和回收整个过程直接stw，那么就简单了。golang为了提供低时延，就必须让赋值器和回收器并发起来。但是在并发的过程中，赋值器和回收器对于引用树的理解就会出现不一致，这里就一定要配合写屏障技术。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写屏障技术，是动态捕捉写操作，维持回收正确性的技术。写屏障就是一段 hook 代码，编译期间生成，运行期间跟进情况会调用到 hook 的代码段，也就是写屏障的代码；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面系统整体的讨论下写屏障的技术。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.8.1 插入写屏障&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（Dijkstra &#x27;78）&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;c&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;writePointer ( slot, ptr ):&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 无脑保护插入的新值&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    shade ( ptr )&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    *slot = ptr&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个是另外一个通用的屏障技术。这个维护的是强三色不变式来保证正确性，保证黑色对象一定不能指向白色对象。golang使用的是这个屏障，插入屏障。按照道理，是几乎完全不需要stw的。但是golang有一个处理，由于栈上面使用屏障会导致处理非常复杂，并且开销会非常大。所以当前golang只针对堆上的写操作做了屏障。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么就会带来一个问题：所以当一轮扫描完了之后，在标记结束的阶段，还需要重新扫描一遍goroutine栈，并且栈引用到的所有对象也要扫描。因为goroutine有可能直接指向了白色对象。在扫描goroutine栈过程中，需要stw。这个也是go1.8以前的一个非常大的延迟来源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（开始的时候，stw扫描栈，得到灰色对象）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;图表演示&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;堆上路径赋值：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;step1：堆上对象赋值的时候，插入写屏障，保护强三色不变式&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.36728395061728397&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DF11J33eLfia9xy4ayicqjFhKiaUlolbJiaeSBEggF7OkOHa0HvHUyHehGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;972&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;step2：删除的时候，没啥问题&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.36699239956568946&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DHmRyWF8d4hV8kyIj0nc9lwcNiawRWBOVuBhPwYvXKTbr1hhwQFHyueg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;921&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;栈上对象赋值：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;step3：栈上对象赋值的时候，没有写屏障。白色对象直接被黑色对象引用。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3575240128068303&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DUfO37E2nVSWzicziaqGdTkrxencx5GPpEDUjBwg5UGGLZO1Mc1q4s7Dg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;937&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;step4：删除灰色保护路径。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.393018018018018&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DpgtnqHS2v5Hq1qG9RAI8CicMpJicZz4EluZJJA6EiaibOfGj3LnauQQO4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;888&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以才需要在mark terminato阶段，重新扫描栈。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.8.2 删除写屏障&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（Yuasa &#x27;90）&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;c&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;writePointer ( slot, ptr ):&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     // 删除之前，保护原先白色或者灰色指向的数据块&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if ( isGery ( slot )  || isWhite ( slot ) )&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        shade ( *slot )&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    *slot = ptr&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个是通用的一种写屏障技术。golang并没有实现，而是实现了插入写屏障。原因就在于：这个在垃圾回收之前，必须做一个快照扫描，这个就会对用户时延有比较严重的影响。下面详述。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;主要流程：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在标记之前，需要打一个引用关系的快照。所以，这个对于栈内存很大的时候，影响越大。&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;不需要完整的快照，只需要在扫描堆对象之前，确保所有的栈对象是黑色的。引用都是灰色的，这样就保证了一个前提：所有可达的对象都处于灰色保护状态中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对栈快照扫描需要stw，去扫描栈对象。这个时候，是需要暂停所有的用户程序。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;扫描堆对象的时候，可以和应用程序并发的。此后根一直保持黑色（黑色赋值器），不用再扫描栈。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对象被删除的时候，删除写屏障会捕捉到。置灰。&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;上面的伪代码显示有条件，其实第一版的时候是没有条件的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这里加上条件是为了回收精度：当上游之前是白色或者灰色才需要把这个置灰色。如果是黑？那么一定是处于灰色保护状态，因为这个是前提（理解这个非常重要）。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（开始的时候，stw扫描栈，得到灰色对象）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;图表演示&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初始扫描快照后：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.37760702524698136&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DLicOrYWuDIic3rNQPtJNmbCx5iaevmMaKcic3DUeuW0iapotAibnGhUx2kWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;911&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;step1: 赋值。这里赋值是允许的，虽然是破坏了强三色不变式。但是还是符合弱三色不变式。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.324&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DAVAO12ru4MZXSHGTcNgNxFOJuSf4EbrS36FKict4EUW6fKDoqicd6ZcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;step2：删除。这里就拦截了，必须置灰色。保证弱三色不变式。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3452502553626149&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DGHKQZBgNYAQtHye4aA4F385MLcBPqrylWt0SQr03fEzF38hatbAgJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;979&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;回收精度：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;删除写屏障的精度比插入写屏障的精度更低。删除的即使是最后一个指针，也会保留到下一轮，属于一个浮动垃圾。这个比插入屏障精度还低。因为，对于插入屏障所保留的对象，回收器至少可以确定曾在其中执行了某些回收相关的操作（获取或写入对象的引用），但删除屏障所保留的对象却不一定被赋值器操作过。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;为什么需要打快照？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;删除写屏障，又叫快照屏障增量技术（或者说，一定要配合这个来做）。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先，是需要stw，针对扫描整个栈根打做一遍扫描。相当于一个快照。这个过程扫描之后，就能保证当前（时刻）所有可达的对象都处于灰色保护状态，满足弱三色不变式。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;然后，赋值器和回收器就可以并发。但是并发有可能会破坏导致弱三色不变式。这个时候，就需要删除写屏障来时刻保护白色对象。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;golang为啥没有用这个？&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一个是精度问题，这个精度要比插入写屏障低；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;考虑goroutine可能非常多，不适合上来就stw，扫描所有的内存栈。这个适合小内存的场景。&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;思考一个问题：这个和混合写屏障有没有区别？还是有区别的，这里是要锁整个栈，混合写屏障是并发的，每次只需要锁单个栈。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.8.3 混合写屏障&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;混合屏障是结合插入屏障和删除屏障。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;伪代码：&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;c&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;writePointer (slot, ptr) :&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 保护原来的（被删除的）&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    shade ( *slot )&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if current stack is grey:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 如果对象为灰色，则还需要保护新指向的对象&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        shade ( ptr )&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    *slot = ptr&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（开始的时候，stw扫描栈，得到黑色对象）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;golang实际情况：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;伪代码如上。但是这里提出来一点，golang根本不是和伪代码说的这样。没有做条件判断，所以现在的回收精度很低。这个算是一个TodoList。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.0122591943957968&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DVkeCnpYkTS4rfhJmYmicZyYMbNKtGj55dWLSzwWU2LcNiaLO0clJRsJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;571&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：使用了混合屏障，还是针对堆上的，栈上对象写入还是没有barrier。golang之前只使用插入屏障，关键在于栈对象没有，导致栈上黑对象可能指向白对象。所以要rescan。因为如果不rescan，而且又破坏了弱三色不变式（没有处于灰色保护链中），那么就丢数据了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;混合屏障，就是结合删除屏障，保护这一个前提，代价就是进一步降低回收精度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;图表示例：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;混合屏障就是要解决：&lt;strong&gt;栈指向白色对象，stw重新扫描栈的问题。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;step1：赋值白对象到黑对象引用，这个不会阻止这个，也不会有写屏障。就是一个正常的赋值。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这个时候黑色指向了白色对象。破坏了强三色不变式。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;但是这个白色对象还处于灰色状态保护下。符合弱三色不变式。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.35441527446300713&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DiaujllHfur23qsTtVYRv3WHS75iaic25pzYkVf6Y3RC0dCdz7eqIcyANg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1676&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;step2：删除指针的时候，意图破坏弱三色不变式的时候，写屏障就会把这个对象置灰色。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.36830102622576966&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DjkltfZP8Er69jfV4hLtmMUwCtPusQvgfqCvyZzar1xzvezSxm3icfXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1754&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;问题一：如果有个还会想？由于栈上没有写屏障，这个删除的对象式根指向的呢？如果存在以下场景?&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;step1：堆上的白色对象引用赋值给黑色栈对象。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3645955451348183&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DMmViaDZLmjTrlLcRAv9W2daNtHXMX8ic6rXMH0PGGe5ysALjgD4Kib28g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1706&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;step2：如果删除指针，岂不是连弱三色不变式也破坏了？&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.36874236874236876&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DhOuzeeiacib7etGBg8pQib4xSmycRjsA8UEhHAFWUTF6xiazYyOZbz3yFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1638&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这个怎么办呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是：其实根本就不可能出现这个场景的引用图。第一个图就不会出现。因为虽然没有stw，但是扫描某个g的时候，这个g是暂停的。相当于这个g栈是一个快照状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;混合写屏障的栈，要么全黑，要么全白（单个栈）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么这个暂停g这个是怎么做到的？&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;扫描的时候，会设置一个 _Gscan 状态。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;casgstatus的时候，保证循环等待这个状态完成。之前是直接吃cpu的，后面做了一个优化，加了一个yield，5us的间隔。&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;关于这段代码的改动&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.39296875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DOvKRyxEOkc0JLVLU9v2sp4bJyXcia4nkxbJmB8H1taXYdSZ0ibYhmFwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;问题二：如果是多个栈呢，那么就不是原子的快照了。比如下图？那么就可能导致这种情况。&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.8549528301886793&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DLQ3JtedhgaOYWEnicYmxlvFQ4k79eXIJVl1z4icMicGN5icx2YcN28aGPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;848&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果说A和前面的黑色对象不属于同一个g栈。那么是否可能会导致这种场景出现？分析下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这个场景是有这么一个白色对象，先只被G2栈根引用到。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当前G1已经被扫描完，G2还没有扫描。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;把这个白色对象赋值给G1栈的黑色对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这个时候把G2对白色对象的引用删掉，这样岂不是会出现黑色白色对象，且为唯一指针？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是：这里的关键在于第三步。G1的栈对象接受赋值，这个并不是凭空来的。那么一定是G1自己找来的，可达的对象。这个是一个前提。所以，如果能接受这样的赋值，那么这个白色对象一定是处于G1栈的灰色保护下，因为G1一定是可访问这个对象的。否则，根本就不能完成这个赋值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;混合写屏障的场景，白色对象处于灰色保护下，但是只由堆上的灰色对象保护。注意理解这点；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;屏障生成示例：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4738562091503268&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4Dcziamq5dlDp6dHsPIkOjDJ0Dh0kSGsQl5QCOmSdu1D4tB2icgZfqUicIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;918&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;写堆上内容，才会在编译期间生成写屏障&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;栈上的写，不会有写屏障。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;runtime.gcWriteBarrier :&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5614457831325301&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DqC3Km4voNU8PgnVaDYvicLfrKgGzpiavSBrp9HNZSPMw7icAic9DRsq5ag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;830&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;计算出wbBuf的next位置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;record ptr&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ptr指针放到wbBuf队列中。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;把 &lt;code&gt;*(slot)&lt;/code&gt; 存到wbBuf队列中 ( 置灰色，flush了就是灰色 )&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;shade( *slot )&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;如果队列没有满&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;那么就赋值写（&lt;code&gt;*(slot) = ptr&lt;/code&gt;）; 则返回&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;如果队列满了，那么跳到flush&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;wbBufFlush就是把wbBufFlush里的元属flush到灰色队列中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用完了 runtime.wbBufFlush 处理之后，返回赋值ret（&lt;code&gt;*(slot) = ptr&lt;/code&gt;）&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这么看起来，就不存在 判断stack是否为灰色的条件？&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.8.4 其他屏障&lt;span/&gt;&lt;/h4&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;c&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;writePointer(slot, ptr):&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    shade(*slot)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    shade(ptr)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    *slot = ptr&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这种无条件的屏障更加容易理解，直接把目标和源都置灰色保护&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;heap上没有黑色到白色的指针&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;唯一有可能出现黑色到白色的引用 只可能出现在 被扫描了的stack&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一旦 stack 被扫描过了，只有一种办法能得到白色对象指针（white pointer）：通过transfer一个可达（reachable）对象&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;删除屏障和混合写屏障，保护了&lt;code&gt;shade(*slot)&lt;/code&gt;这个指针，就保护了一条路径：这个来路一定是灰色的，下游的白色都会收到保护。并且，我们知道，栈上得到的白色指针一定是可达的，那么一定是有堆上灰色对象保护的。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;任何一个白色对象（被黑色栈对象指向的）一定是被堆上灰色对象保护可达的。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺点：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种屏障会导致比较多的屏障，两倍。所以针对这个考虑权衡，会加一个stack条件判断，就是我们看到的混合屏障的样子。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.9 内存可见性&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提一下golang的内存可见性。在c里面，如果是在多线程环境，并发操作一些变量，需要考虑一些可见性的问题。比如赋值一个变量，这个线程还有可能在寄存器里没有刷下去，或者编译器帮你优化到寄存器中，不去内存读。所以有一个volatile关键字，强制去内存读。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;golang是否有这个内存可见性的问题？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一句话，golang里面，只要你保证顺序性，那么内存一致性就没有问题。具体可以搜索happen-before的机制。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.10 注意问题&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.10.1 千万不要尝试绕过golang的类型系统&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;千万不要尝试绕过golang的类型系统。golang官方在提到uintptr类型的时候，都说不要产生uintptr的临时变量，因为很有可能会导致gc的错误回收（这个做过一个简单的验证，1.13本的uintptr类型是不作为指针标记的）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举一个极端的例子，如果你new了一个对象，然后把这个对象的地址保存在8个不连续的byte类型里，那就等着coredump吧。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.10.2 在golang里按照c的思路实现一个内存池很容易踩到巨坑。&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如现在你分配一个大内存出来（1G的[ ]byte类型空间）。这是一个大内存块。并且golang没有任何标识这个地方标识指针。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;golang&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;// 分配一个大内存数组（1GB），数组元素是byte。那么自然每个元素都是不含指针的。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;begin := make([]byte, 1024*1024*1024)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.14094650205761317&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DTv0cf8PLNFgtWxhvpiaEY2voibYpX6iaA4r9ibwNibL5A0qtygnhjqO5oGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;972&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么扫描是不会扫描这个内部的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存池分配器接口：&lt;code&gt;func (ac *Allocator) Alloc (size int) unsafe.Pointer&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用来分配对象，使用可能会导致莫名其妙的内存错误。假设用来分配对象T：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;golang&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;type T struct {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    s *S&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;t := (*T) (ac.Alloc(sizeT))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;t.s = &amp;amp;S{}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;T对象是从一个大数组里划出来的，垃圾回收其实并不知道T这个对象。不过只要1G内存池本身不被回收，T对象还是安全的。但是T里面的S，是golang走类型系统分配出来的，就会有问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设发生垃圾回收了，GC会认为这个内存空间是一个Byte数组，而不会扫描，那么t.s指向的对象认为未被任何对象引用到，它会被清理掉。最后t.s就成了一个悬挂指针。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;golang里面实现内存分配器，适用处理两种情况：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一种是用于分配对象里面不包含其他引用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;另一种，包含的引用对象也在这个分配器里&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，没必要自己搞通用内存池。一旦绕过了golang的类型系统，就会出现坑。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fb71b315f274ba5d552f267f411d7bf8</guid>
<title>[推荐] 我把这个软件，推荐给了总监</title>
<link>https://toutiao.io/k/9yex08q</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你好，我是 yes。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天要来安利一款神器！「&lt;span&gt;uTools&lt;/span&gt;」。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于我个人而言，它的用处在于：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;快速翻译&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;备忘录快贴&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;快速查找和打开文件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Json 解析&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;时间戳转换&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;todo记录&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;等等等等，还有太多太多了，它有 100 多个插件！&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，这些功能别的软件或者网站也能提供，但是它一个就全有了！而且它简单、高效、跨平台！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.26713947990543735&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF6UIhGEVSf14dXaoibPG4iaUoicIRQYBUQib245Ocmv2PX6VVbup3TAibNFmwnSnguYJK7CTibFa0LOScA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;846&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安装了之后，通过 「&lt;span&gt;alt+空格&lt;/span&gt;」就可以唤出它，然后可以往输入框内粘贴文本、图片、截图、文件、文件夹等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我想打开 Chrome，直接alt+空格唤出，再输入 chrome 即可。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.13216957605985039&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF6UIhGEVSf14dXaoibPG4iaUFBZriavxPJwxJOYOq8TdXuRbc0mdhO4icLnUf6UiaCiciaZqx54RoqBug7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;802&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想听歌，那就网易云~&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.13216957605985039&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF6UIhGEVSf14dXaoibPG4iaUZEKmfEfOpicPlu0qHKu4bHpupH4iaGorIqk9nuUhGMDVQe9FFoSnzO2g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;802&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我现在截了个图，可以直接复制输入，然后可以查看 base64编码、另存为图片、也可以把这个图记录下来！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2518703241895262&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF6UIhGEVSf14dXaoibPG4iaUfsRiaMSAYT0c13RiaOJNSzf84AqxBwcQfMGP1OTo4FaPFQiboc7ruhLew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;802&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设今天看了 yes 的技术文章，里面有一段话说的很好，我就截图，然后点击添加到「备忘快贴」，图片还能备注（图中的yes6666就是备注），这样就临时记录下来了！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7506234413965087&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF6UIhGEVSf14dXaoibPG4iaUCzGUoCibM97IibzUOMIQhPxgWXjShMLzr7HseQRWYWlGYb1aA66O2ZibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;802&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后等晚上回去再整理成笔记就 OK 了！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再比如我现在看英文 pdf，我想翻译一下，那非常简单，我&lt;span&gt;划词长按鼠标右键&lt;/span&gt;(默认是鼠标中键)就好了：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7343234323432343&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF6UIhGEVSf14dXaoibPG4iaUDiamEwOFZPPxLtBzZMLN7HnoHViaMh1C6Fl60aZxeswoYLhJduBemYyg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;606&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还可以点出上图的&lt;span&gt;翻译&lt;/span&gt;，这样可以看多个网站的翻译结果！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5859375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF6UIhGEVSf14dXaoibPG4iaUkpoSuxgAtJm6GXTorVJShic0633DJTrgNfqsgSf3y3CkfDJq0PFz7XA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;太方便了！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果要记录 todo 的事情，也很简单！直接 &lt;code&gt;alt+空格&lt;/code&gt; 唤出再输入 &lt;code&gt;todo&lt;/code&gt; 敲个回车即可！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7506234413965087&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF6UIhGEVSf14dXaoibPG4iaURPvXKBabibPUq0mOukOMgO9Y6WILU42vPnTvkW4ZrDa7nnRDVib7GpXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;802&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再比如现在要对接一个接口，接口返回了一个 Json 字符串，那直接复制然后 &lt;code&gt;alt+空格&lt;/code&gt; 唤出，此时的界面就是这样的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3117206982543641&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF6UIhGEVSf14dXaoibPG4iaUxUUQmHCLk9oxCxMcsAecgShJ6gFyDQQHWPUz8MkBqdOiaH8tKUaNNibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;802&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后敲个回车，就搞定啦！就是这么 easy！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7506234413965087&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF6UIhGEVSf14dXaoibPG4iaUT3zqMbjj3gPasHc9p8gCnLx8iaGYYTt4ic31HhNibypnYCbSCickyFeFjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;802&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再比如现在从数据库拿到了个时间戳，想看看到底是什么时候，那么直接复制然后 &lt;code&gt;alt+空格&lt;/code&gt; 唤出。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.371571072319202&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF6UIhGEVSf14dXaoibPG4iaUviaKGydrEVgfKa7WyeXmWIfdUqCJzSNMibGy4M0FoKNIDXAeL7oh7bFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;802&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再敲个回车！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7506234413965087&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF6UIhGEVSf14dXaoibPG4iaUVyfmCa5IGajqXguJp3LwBuWBPlFnCn1hRSCia758pg4efN7DmBeh6KA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;802&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想从现在一个时间倒推一下时间戳，那也简单，&lt;span&gt;直接输入时间&lt;/span&gt;就行：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7506234413965087&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF6UIhGEVSf14dXaoibPG4iaU7lZrsBzIwdBgibNBkN4SeXe1dBXvdIMNPgpF1jUL8q0zxYPM6zskrvw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;802&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后它有很多插件，可以直接输入插件(拼音也ok)来搜：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.19201995012468828&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF6UIhGEVSf14dXaoibPG4iaUR5xpztrYCbB8UFw6HNQdiaTKtRkI5850gjMLPycPENCOkUZkZBibxbHQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;802&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7506234413965087&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF6UIhGEVSf14dXaoibPG4iaUVTzRjtGObtMfJPibwnztz8iaTvWqsXMWNghibWEWRydddHLuISKUpWJ8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;802&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一些文档插件：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3929712460063898&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF6UIhGEVSf14dXaoibPG4iaUhFtkRUcJBhWibmAWu7M3O4IcWCuQ6IVoCdDrA0OtqOrZakLh0zVTTXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;626&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我要查 Linux 的 ps 命令：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7905236907730673&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF6UIhGEVSf14dXaoibPG4iaUVA21wtUIG8U4ibfrJ3zyqzicJayxJUWe5ZesdjNqq3xubEb275OmUgxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;802&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;怎么说，这波是不是很完美！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有&lt;span&gt;渣男语录&lt;/span&gt;，啧啧好骚啊！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6708229426433915&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF6UIhGEVSf14dXaoibPG4iaUAPChPEtVzicnjyibEfCLlzcF3r4sHQr5QmgJIKtsiaejSziakHlc9yApPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;802&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我还看到了啥&lt;/span&gt;？？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7506234413965087&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF6UIhGEVSf14dXaoibPG4iaUd8X20ODD700icIULUIUW50UeDf01TNT2BAabsOL9OlPJrCacFO6ib3Xw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;802&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像我这么正直的人，我是不会下载的！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9816849816849816&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF6UIhGEVSf14dXaoibPG4iaUwtibObnscf80AJYXibDN8zrSgnOzDazMObDP6dkz9vewBWvDE1x2mYNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;273&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是我总监......&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;插件太多了，你们就自己看吧！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官网：https://u.tools/&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我也打包好了，windows、mac都有，后台直接回复「&lt;span&gt;uTools&lt;/span&gt;」即可下载！&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我是yes，我们下篇见~&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>19758aa747b98c97da5c815e213158ab</guid>
<title>[推荐] Spring Boot 开发秘籍：集成参数校验及高阶技巧</title>
<link>https://toutiao.io/k/bzx7ri7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAwMTk4NjM1MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4gcBzLSUNh2cgXUsuLIsvQYJE1lzZd74qpC3iciaM6gcYIfOVV0KjDDkeN4CTLTn4ETPtaHOAuTWSWA/0?wx_fmt=png&quot; data-nickname=&quot;JAVA日知录&quot; data-alias=&quot;javadaily&quot; data-signature=&quot;写代码的架构师，做架构的程序员！  实战、源码、数据库、架构...只要你来，你想了解的这里都有！&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 &lt;code&gt;web&lt;/code&gt;服务来说，为防止非法参数对业务造成影响，在 &lt;code&gt;Controller&lt;/code&gt;层一定要对参数进行校验！本章我们以SpringBoot项目为例，介绍参数校验的基本用法以及一些高级技巧，希望能对你有所帮助。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;简单使用&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;要在Springboot项目中加入参数校验功能首先得加入&lt;code&gt;spring-boot-starter-validation&lt;/code&gt;依赖&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-validation&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;然后给需要校验的字段添加上约束性注解，如我们对实体类参数进行校验&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Data&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ValidEntity&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; id;&lt;br/&gt;    &lt;span&gt;@NotBlank&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String appId;&lt;br/&gt;  &lt;br/&gt;    &lt;span&gt;@NotBlank&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String name;&lt;br/&gt;  &lt;br/&gt;    &lt;span&gt;@Email&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String email;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见约束注解如下：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;注解&lt;/th&gt;&lt;th&gt;功能&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;@AssertFalse&lt;/td&gt;&lt;td&gt;可以为null,如果不为null的话必须为false&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@AssertTrue&lt;/td&gt;&lt;td&gt;可以为null,如果不为null的话必须为true&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@DecimalMax&lt;/td&gt;&lt;td&gt;设置不能超过最大值&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@DecimalMin&lt;/td&gt;&lt;td&gt;设置不能超过最小值&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@Digits&lt;/td&gt;&lt;td&gt;设置必须是数字且数字整数的位数和小数的位数必须在指定范围内&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@Future&lt;/td&gt;&lt;td&gt;日期必须在当前日期的未来&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@Past&lt;/td&gt;&lt;td&gt;日期必须在当前日期的过去&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@Max&lt;/td&gt;&lt;td&gt;最大不得超过此最大值&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@Min&lt;/td&gt;&lt;td&gt;最大不得小于此最小值&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@NotNull&lt;/td&gt;&lt;td&gt;不能为null，可以是空&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@Null&lt;/td&gt;&lt;td&gt;必须为null&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@Pattern&lt;/td&gt;&lt;td&gt;必须满足指定的正则表达式&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@Size&lt;/td&gt;&lt;td&gt;集合、数组、map等的size()值必须在指定范围内&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@Email&lt;/td&gt;&lt;td&gt;必须是email格式&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@Length&lt;/td&gt;&lt;td&gt;长度必须在指定范围内&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@NotBlank&lt;/td&gt;&lt;td&gt;字符串不能为null,字符串trim()后也不能等于“”&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@NotEmpty&lt;/td&gt;&lt;td&gt;不能为null，集合、数组、map等size()不能为0；字符串trim()后可以等于“”&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@Range&lt;/td&gt;&lt;td&gt;值必须在指定范围内&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@URL&lt;/td&gt;&lt;td&gt;必须是一个URL&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注：此表格只是简单的对注解功能的说明，并没有对每一个注解的属性进行说明；可详见源码。&lt;/p&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在Controller层对需要参数校验的方法加上@Validated注解&lt;/p&gt;&lt;p&gt;参数校验一般分为两类：在Controller使用模型接收数据时， @Validated注解直接放在该模型参数前即可。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@PostMapping&lt;/span&gt;(value = &lt;span&gt;&quot;test1&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;(@Validated @RequestBody ValidEntity validEntity)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;test1 valid success&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@PostMapping&lt;/span&gt;(value = &lt;span&gt;&quot;test3&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;test3&lt;/span&gt;&lt;span&gt;(@Validated ValidEntity validEntity)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;test3 valid success&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;  当我们是直接在Controller层中的参数前，使用约束注解时，@Validated要直接放在类上&lt;br/&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@PostMapping&lt;/span&gt;(value = &lt;span&gt;&quot;test2&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;test2&lt;/span&gt;&lt;span&gt;(@Email String email)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;test2 valid success&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;  此时需要在主类上增加@Validated注解&lt;br/&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Validated&lt;br/&gt;@RestController&lt;br/&gt;@RequestMapping(&lt;span&gt;&quot;/demo/valid&quot;&lt;/span&gt;)&lt;br/&gt;public class ValidController {&lt;br/&gt; ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在参数校验时我们既可以使用@Validated也可以使用@Valid注解，两者功能大部分类似；&lt;/span&gt;&lt;p&gt;主要区别在于：&lt;/p&gt;&lt;p&gt;@Valid属于javax下的，而@Validated属于spring下；&lt;/p&gt;&lt;p&gt;@Valid支持嵌套校验、而@Validated不支持，@Validated支持分组，而@Valid不支持。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;统一异常处理&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果参数校验未通过Spring会抛出三种类型的异常&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当对@RequestBody需要的参数进行校验时会出现&lt;code&gt;org.springframework.web.bind.MethodArgumentNotValidException&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.17070063694267515&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4j5Mwbh7ibj84r5ia9LgUAqEJP3tquhVkpb3czUu0PGuViamtdZHP16AkO8w8522CRxzrnkNrFmib8wUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;785&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当直接校验具体参数时会出现&lt;code&gt;javax.validation.ConstraintViolationException&lt;/code&gt;，也属于&lt;code&gt;ValidationException&lt;/code&gt;异常&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.1836441893830703&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4j5Mwbh7ibj84r5ia9LgUAqEJ94ia9cAeibac545p1iaG6rxzreSAQE6ZQw5RiaPj6wBI1KAzvq6EvibBbdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;697&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当直接校验对象时会出现&lt;code&gt;org.springframework.validation.BindException&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.15384615384615385&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4j5Mwbh7ibj84r5ia9LgUAqEJ6cSMyhZSCicHoVdpJwsu6ibPNlWiajQicVjL2tDE3e6k49HPlDESlOAFGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;832&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在SpringBoot中统一拦截处理只需要在配置类上添加 &lt;code&gt;@RestControllerAdvice&lt;/code&gt;注解，然后在具体方法中通过 &lt;code&gt;@ExceptionHandler&lt;/code&gt;指定需要处理的异常，具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@RestControllerAdvice&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;GlobalExceptionHandler&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String ERROR_MSG = &lt;span&gt;&quot;系统异常，请联系管理员。&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@ExceptionHandler&lt;/span&gt;(value = {BindException&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;ValidationException&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;MethodArgumentNotValidException&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;})&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;ResponseEntity&lt;/span&gt;&amp;lt;&lt;span&gt;Result&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;&amp;gt;&amp;gt; &lt;span&gt;handleValidatedException&lt;/span&gt;(&lt;span&gt;Exception&lt;/span&gt; &lt;span&gt;e&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;        Result&amp;lt;String&amp;gt; resp = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (e &lt;span&gt;instanceof&lt;/span&gt; MethodArgumentNotValidException) {&lt;br/&gt;            &lt;span&gt;// BeanValidation exception&lt;/span&gt;&lt;br/&gt;            MethodArgumentNotValidException ex = (MethodArgumentNotValidException) e;&lt;br/&gt;            resp = &lt;span&gt;new&lt;/span&gt; Result&amp;lt;&amp;gt;(Integer.toString(HttpStatus.BAD_REQUEST.value()),&lt;br/&gt;                    ex.getBindingResult().getAllErrors().stream().map(ObjectError::getDefaultMessage).collect(Collectors.joining(&lt;span&gt;&quot;, &quot;&lt;/span&gt;))&lt;br/&gt;                    , getStackTrace(ex));&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (e &lt;span&gt;instanceof&lt;/span&gt; ConstraintViolationException) {&lt;br/&gt;            &lt;span&gt;// BeanValidation GET simple param&lt;/span&gt;&lt;br/&gt;            ConstraintViolationException ex = (ConstraintViolationException) e;&lt;br/&gt;            resp = &lt;span&gt;new&lt;/span&gt; Result&amp;lt;&amp;gt;(Integer.toString(HttpStatus.BAD_REQUEST.value()),&lt;br/&gt;                    ex.getConstraintViolations().stream().map(ConstraintViolation::getMessage).collect(Collectors.joining(&lt;span&gt;&quot;, &quot;&lt;/span&gt;))&lt;br/&gt;                    , getStackTrace(ex));&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (e &lt;span&gt;instanceof&lt;/span&gt; BindException) {&lt;br/&gt;            &lt;span&gt;// BeanValidation GET object param&lt;/span&gt;&lt;br/&gt;            BindException ex = (BindException) e;&lt;br/&gt;            resp = &lt;span&gt;new&lt;/span&gt; Result&amp;lt;&amp;gt;(Integer.toString(HttpStatus.BAD_REQUEST.value()),&lt;br/&gt;                    ex.getAllErrors().stream().map(ObjectError::getDefaultMessage).collect(Collectors.joining(&lt;span&gt;&quot;, &quot;&lt;/span&gt;))&lt;br/&gt;                    , getStackTrace(ex));&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ResponseEntity&amp;lt;&amp;gt;(resp,HttpStatus.BAD_REQUEST);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; String &lt;span&gt;getStackTrace&lt;/span&gt;&lt;span&gt;(Exception e)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//打印日志开关，可通过配置读取&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;boolean&lt;/span&gt; printStrackTrace = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(printStrackTrace){&lt;br/&gt;            StringWriter sw = &lt;span&gt;new&lt;/span&gt; StringWriter();&lt;br/&gt;            e.printStackTrace(&lt;span&gt;new&lt;/span&gt; PrintWriter(sw));&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; sw.toString();&lt;br/&gt;        }&lt;span&gt;else&lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; ERROR_MSG;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终实现效果如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2850765306122449&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4j5Mwbh7ibj84r5ia9LgUAqEJTlia1OPPUhfSlTic2RKuOC5s6VTrXqDekAZXvJT9uM8icgXVUe0nLPXIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1568&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;参数分组&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有下面一个实体类，我们需要对其进行参数校验。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Data&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ValidEntity&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; id;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@NotBlank&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String appId;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@NotBlank&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String name;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Email&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String email;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是实际业务是在编辑的时候 &lt;code&gt;appId&lt;/code&gt;才是必填，在新增的时候 &lt;code&gt;name&lt;/code&gt;必填，这时候可以用groups分组功能来实现：同一个模型在不同场景下，动态区分校验模型中的不同字段。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;使用方式&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先我们定义一个分组接口ValidGroup，再在分组接口总定义出多个不同的操作类型，Create，Update，Query，Delete&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;ValidGroup&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Default&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;  &lt;br/&gt;    &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Crud&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;ValidGroup&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;      &lt;br/&gt;        &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Create&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Crud&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        }&lt;br/&gt;    &lt;br/&gt;        &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Update&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Crud&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        }&lt;br/&gt;      &lt;br/&gt;        &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Query&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Crud&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        }&lt;br/&gt;  &lt;br/&gt;        &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Delete&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Crud&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的 &lt;code&gt;ValidGroup&lt;/code&gt;继承了Default，当然也可以不继承，具体区别我们后面再说。&lt;/p&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在模型中给校验参数分配分组&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Data&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@ApiModel&lt;/span&gt;(value=&lt;span&gt;&quot;ValidEntity&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ValidEntity&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; id;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@NotBlank&lt;/span&gt;(groups = ValidGroup.Crud.Update&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; &lt;span&gt;appId&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@NotBlank&lt;/span&gt;(groups = ValidGroup.Crud.Create&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Email&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String email;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;tips：这里@Email注解未指定分组，默认会属于Default分组，appId和name指定了分组就不会再属于Default分组了。&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在参数校验时通过value属性指定分组&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2874524714828897&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4j5Mwbh7ibj84r5ia9LgUAqEJJjXfGL1NdebZNLDEPF6iaaapLkD8TneC8bEUxKPiajKkiaickWMiaOCrib8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1315&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里通过 &lt;code&gt;@Validated(value = ValidGroup.Crud.Update.class)&lt;/code&gt;指定了具体的分组，上面提到的是否继承Default的区别在于：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果继承了Default，@Validated标注的注解也会校验未指定分组或者Default分组的参数，比如email&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果不继承Default则不会校验未指定分组的参数，需要加上&lt;code&gt;@Validated(value = {ValidGroup.Crud.Update.class, Default.class}&lt;/code&gt;才会校验&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;快速失败（Fali Fast）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认情况下在对参数进行校验时Spring Validation会校验完所有字段然后才抛出异常，可以通过配置开启 &lt;code&gt;Fali Fast&lt;/code&gt;模式，一旦校验失败就立即返回。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ValidatedConfig&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Validator &lt;span&gt;validator&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ValidatorFactory validatorFactory = Validation.byProvider(HibernateValidator&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;                .&lt;span&gt;configure&lt;/span&gt;()&lt;br/&gt;                // 快速失败模式&lt;br/&gt;                .&lt;span&gt;failFast&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;)&lt;br/&gt;                .&lt;span&gt;buildValidatorFactory&lt;/span&gt;()&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; validatorFactory.getValidator();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>