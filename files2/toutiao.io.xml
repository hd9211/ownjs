<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>32e1debb9db748550ac2bc7edd1935b1</guid>
<title>OpenResty 实现限流</title>
<link>https://toutiao.io/k/syxnrph</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前限流的解决方案有很多，从分布式角度来看，限流可分为分布式限流（比如基于Sentinel或者 Redis的集群限流）和单机限流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从算法实现角度来看，限流算法可分为计数器算法、滑动时间窗口算法、漏桶算法、令牌桶算法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;本文主要介绍如何在Nginx中增加流控功能，原因是考虑到nginx的广泛使用且基于流量的入口位置，越早拦截对后面系统的压力越小。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;首先，我们先来了解下nginx&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Nginx是一款轻量级的Web服务器、反向代理服务器，由于它的内存占用少，启动极快，高并发能力强，在互联网项目中广泛应用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Nginx可以做的事情很多，归纳起来主要有四块：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、反向代理&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;接收Internet上的请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给Internet上请求连接的客户端&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、负载均衡&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;将大量的用户请求按照一定的负载策略分摊转发给内部的服务器。负载均衡策略有：轮询（默认）、weight、ip_hash、fair（第三方）、url_hash（第三方）&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、HTTP服务器&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Nginx本身是一个静态资源的服务器，对静态资源缓存，提升性能。也可以实行动静分离，将动态请求转发给后台服务器。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、正向代理&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;为了安全限制，有些内部服务器不允许直接访问外网，需要将请求转发到代理机，再由代理机访问internet。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;那么，Nginx 如何做到高并发下的高效处理？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;现在的软件系统一般采用微服务架构，跨服务器请求产生了大量的网络IO，而IO等待严重影响系统吞吐量&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Nginx采用异步事件驱动的方法来处理请求，Linux的epoll模型基于事件驱动机制，它可以监控多个事件是否准备就绪，如果OK，那么放入epoll队列中，这个过程是异步的。worker只需要从epoll队列循环处理即可。官方测试结果，单台能够支持五万个并行连接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Nginx采用模块化设计，扩展性好，但由于采用C语言，涉及大量的通信协议，开发环境复杂，门槛较高。有没有一种方式，通过简单的脚本语言就可以实现各种定制化功能，并能方便的集成到 Nginx中，OpenResty 是个不错选择，接下来，我们来了解下这个框架&lt;/code&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;🌴 首先，了解下OpenResty&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;OpenResty 是一个基于 Nginx 与 Lua 的高性能 Web 服务器，其内部集成了大量 Lua 库、第三方模块以及大多数的依赖项。方便搭建支持高并发、高扩展性的动态 Web 服务和网关。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;包含 Nginx、ngx_lua、LuaJIT 2.0/2.1 (或者可选的标准 Lua 5.1解释器)，还包含很多强劲、好用的 Nginx 模块。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;OpenResty 使用 Lua 编程语言对 Nginx 核心以及各种 Nginx C 模块进行脚本编程，可以处理一万以上并发请求。选择OpenResty，既拥有脚本语言的开发效率，以及 Nginx 高并发优势。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;OpenResty 现在是全球排名第三的 Web 服务器，由于将Nginx扩展成动态服务器，发展势头很猛。我们经常用到的 12306 的余票查询功能，或者是京东的商品详情页，这些高流量的背后，其实都是 OpenResty 在默默地提供服务。OpenResty 最擅长的是部署在流量入口处，处理各种高并发流量。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.60234375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/3Ohm6WHibeXIQj9bpiaJmoOdJOVKx4alHffoG9icmVkwMXic4IH6StKNvibgcKYA80eNC2JficDORDLU8Qpmrict6tZtw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;🌴 应用场景&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在请求真正到达下游服务之前，Lua 可以随心所欲的做复杂访问控制和安全检测&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从外部存储服务（比如 redis, memcached, mysql, postgresql）中获取后端信息，并用这些信息来实时选择哪一个后端来完成业务访问&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在内容 handler 中随意编写复杂的 web 应用，使用同步非阻塞的方式，访问后端数据库和其他存储&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在 rewrite 阶段，通过 Lua 完成非常复杂的 URL dispatch&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用 Lua 可以为 Nginx 子请求和任意 location，实现高级缓存机制&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Nginx采用原生C语言开发的，通过&lt;code&gt;nginx-lua-module&lt;/code&gt; 借助nginx开放的api，实现 Nginx 的各种功能自由拼接、业务定制化。Lua语言，大大降低了开发门槛。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;🌴 如何二次开发&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们编写的Lua脚本代码均包含在指令函数中，指令函数有严格的执行顺序。当接收请求时，通过指令函数对 &lt;code&gt;request&lt;/code&gt; 、 &lt;code&gt;response&lt;/code&gt;做二次干预处理，从而实现个性化业务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;指令函数的执行顺序：&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.9054726368159204&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3Ohm6WHibeXKuoBtErGT6Eic02xndts9Dxg3brotmFg00CpI3lMp9x5QDSuRISUI6gfqVrACXIHcJ5Yt6Oykxkng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1005&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;函数功能说明：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;set_by_lua，用于设置变量&lt;br/&gt;rewrite_by_lua，用于转发、重定向等&lt;br/&gt;access_by_lua，用于准入、权限等&lt;br/&gt;content_by_lua，用于生成返回内容&lt;br/&gt;header_filter_by_lua，用于响应头过滤处理&lt;br/&gt;body_filter_by_lua，用于响应体过滤处理&lt;br/&gt;log_by_lua，用于日志记录&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意：OpenResty 的 API 有范围限制，每一个 API 都有一个与之对应的使用阶段列表，如果你超范围使用就会报错。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;🌴 限流实战&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;OpenResty 官方提供了封装好的 lua函数，方便我们开箱即用。支持一下几个场景：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;根据ip限制并发连接数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;限制时间窗口的请求数，如：限制 ip 每分钟只能调用 100 次 /order 接口，（允许在时间段开始的时候一次性放过100个请求）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;平滑限制接口请求数，如：限制 ip 每分钟只能调用 120 次 /order 接口（平滑处理请求，即每秒放过2个请求）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;漏桶算法限流，如：限制 ip 每分钟只能调用 120 次 /order 接口（平滑处理请求，即每秒放过2个请求），超过的部分进入桶中等待，（桶容量为60），如果桶也满了，则进行限流&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Lua脚本&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; server {&lt;br/&gt;        listen       80;&lt;br/&gt;        server_name  localhost;&lt;br/&gt;        charset utf-8;&lt;br/&gt;        &lt;span&gt;#access_log  logs/host.access.log  main;&lt;/span&gt;&lt;br/&gt; &lt;br/&gt;        &lt;span&gt;# 限流示例&lt;/span&gt;&lt;br/&gt;        location /order/&lt;span&gt;limit&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;            default_type &lt;span&gt;&#x27;text/html&#x27;&lt;/span&gt;;&lt;br/&gt;            access_by_lua_block {&lt;br/&gt;&lt;br/&gt;                -- 导入模块&lt;br/&gt;                &lt;span&gt;local&lt;/span&gt; limit_count = require &lt;span&gt;&quot;resty.limit.count&quot;&lt;/span&gt;&lt;br/&gt;         &lt;br/&gt;                -- 限流规则: 每分钟3次&lt;br/&gt;                &lt;span&gt;local&lt;/span&gt; lim, err = limit_count.new(&lt;span&gt;&quot;my_limit_count_store&quot;&lt;/span&gt;, 3, 60)&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; not lim &lt;span&gt;then&lt;/span&gt;&lt;br/&gt;                    ngx.log(ngx.ERR, &lt;span&gt;&quot;failed to instantiate a resty.limit.count object: &quot;&lt;/span&gt;, err)&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt; ngx.exit(500)&lt;br/&gt;                end&lt;br/&gt;         &lt;br/&gt;                &lt;span&gt;local&lt;/span&gt; key = ngx.var.binary_remote_addr&lt;br/&gt;                &lt;span&gt;local&lt;/span&gt; delay, err = lim:incoming(key, &lt;span&gt;true&lt;/span&gt;)&lt;br/&gt;                -- 如果请求数在限制范围内，则当前请求被处理的延迟（这种场景下始终为0，因为要么被处理要么被拒绝）和将被处理的请求的剩余数&lt;br/&gt;                 ngx.log(ngx.ERR,&lt;span&gt;&quot;delay: &quot;&lt;/span&gt;,delay,&lt;span&gt;&quot; err: &quot;&lt;/span&gt;,err)&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; not delay &lt;span&gt;then&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; err == &lt;span&gt;&quot;rejected&quot;&lt;/span&gt; &lt;span&gt;then&lt;/span&gt;&lt;br/&gt;                        ngx.say(&lt;span&gt;&quot;访问太频繁了..&quot;&lt;/span&gt;,&lt;span&gt;&quot;delay: &quot;&lt;/span&gt;,delay,&lt;span&gt;&quot; , err: &quot;&lt;/span&gt;,err)&lt;br/&gt;                        -- &lt;span&gt;return&lt;/span&gt; ngx.exit(503)&lt;br/&gt;                    end&lt;br/&gt;         &lt;br/&gt;                    ngx.log(ngx.ERR, &lt;span&gt;&quot;被限流啦...... &quot;&lt;/span&gt;, err)&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt; ngx.exit(500)&lt;br/&gt;                end&lt;br/&gt;&lt;br/&gt;                ngx.say(&lt;span&gt;&quot;success&quot;&lt;/span&gt;)&lt;br/&gt;            }&lt;br/&gt;         &lt;br/&gt;           &lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;场景测试：&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;流控设置规则，每分钟限制访问3次&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;正常请求：&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.2956989247311828&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/3Ohm6WHibeXKuoBtErGT6Eic02xndts9Dx67uMgr6tFbmXlKGo8mNicpZzd89CzDzBqJ7C5Fv4agHicOEIY2iaYvU0w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;372&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;请求过多，触发流控：&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.31453362255965295&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/3Ohm6WHibeXKuoBtErGT6Eic02xndts9Dx9FlKTBOtP3xuxVgIdRicbtSPOMP3OpKxEqMuLHCY4dKfv8OBiaQcKvag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;461&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;你好，我是微观技术&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;计算机专业出身，研究僧，校招进入阿里，架构师&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;写过专利，竞赛拿过奖，CSDN博客专家&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;负责过电商交易、社区、营销、金融等业务&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;多年团队管理经验，爱思考&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;热衷把工作沉淀写成文章&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;感兴趣的同学请关注，也欢迎加微信好友交流&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/3Ohm6WHibeXJxE2KOULCAe2BQfUfcd9Lf2kqibBfdJrGWFPBdoialWJAiaG8FPicR15jW3s75tfS1hKNK9TdqdYjicAg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5NDAwMzM0MA==&amp;amp;mid=2247485101&amp;amp;idx=1&amp;amp;sn=40ecbfba914173c99bba7acedba6478a&amp;amp;chksm=ec68314edb1fb8581b3389a8e47407cccf44b958f9411d1d2e7ca9610e6e2bba2ac0aebfe4b0&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;淘宝双11千亿交易额的系统架构演变&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5NDAwMzM0MA==&amp;amp;mid=2247484438&amp;amp;idx=1&amp;amp;sn=686afd68b34579d0c38b7de67ce2b64b&amp;amp;chksm=ec6833f5db1fbae3897f2261e270e745182996f95b2fe7c3d4d57e2000607e6bf2c6ead2b446&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;淘宝订单自动确认收货的N种实现，秒杀面试官&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5NDAwMzM0MA==&amp;amp;mid=2247484307&amp;amp;idx=1&amp;amp;sn=37351d4934ee92c05f6f1beb76462cf4&amp;amp;chksm=ec683470db1fbd6625e46acc6d1e6813b072c8358dc1d7a98cc6bedd7636a182c2b09d0e8ef8&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;如何设计一个高性能的秒杀系统&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;码字不易，如果对您有帮助，请转发分享，点个 “在看”&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>15ae60d6663242cb7b0ca10b3746da29</guid>
<title>CAP：分布式事务的解决方案</title>
<link>https://toutiao.io/k/mbgrz85</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;CAP 是一个基于 .NET Standard 的 C# 库，它是一种处理分布式事务的解决方案，同样具有 EventBus 的功能，它具有轻量级、易使用、高性能等特点。&lt;/p&gt;&lt;p&gt;https://github.com/dotnetcore/CAP&lt;/p&gt;&lt;p&gt;在我们构建 SOA 或者 微服务系统的过程中，我们通常需要使用事件来对各个服务进行集成，在这过程中简单的使用消息队列并不能保证数据的最终一致性， CAP 采用的是和当前数据库集成的本地消息表的方案来解决在分布式系统互相调用的各个环节可能出现的异常，它能够保证任何情况下事件消息都是不会丢失的。&lt;/p&gt;&lt;p&gt;你同样可以把 CAP 当做 EventBus 来使用，CAP提供了一种更加简单的方式来实现事件消息的发布和订阅，在订阅以及发布的过程中，你不需要继承或实现任何接口。&lt;/p&gt;&lt;p&gt;这是CAP集在ASP.NET Core 微服务架构中的一个示意图：&lt;/p&gt;&lt;h2&gt;&lt;svg viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;架构预览&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.375717017208413&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia9mEhlib6icjTSF4K98gpBlCz2b9C7M5suUliaZWZtwv8mJ9wmW7PyC5JtnoW9UlYGx7vvDZ0108OsohlwAt6fxcw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1046&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;CAP 实现了 eShop 电子书 中描述的发件箱模式&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;&lt;svg viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;Getting Started&lt;/h2&gt;&lt;h3&gt;&lt;svg viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;NuGet&lt;/h3&gt;&lt;p&gt;你可以运行以下下命令在你的项目中安装 CAP。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;PM&amp;gt; Install-Package DotNetCore.CAP&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;CAP 支持 Kafka、RabbitMQ、AzureServiceBus 等消息队列，你可以按需选择下面的包进行安装：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;PM&amp;gt; Install-Package DotNetCore.CAP.Kafka&lt;br/&gt;PM&amp;gt; Install-Package DotNetCore.CAP.RabbitMQ&lt;br/&gt;PM&amp;gt; Install-Package DotNetCore.CAP.AzureServiceBus&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;CAP 提供了 Sql Server, MySql, PostgreSQL，MongoDB 的扩展作为数据库存储：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 按需选择安装你正在使用的数据库&lt;br/&gt;PM&amp;gt; Install-Package DotNetCore.CAP.SqlServer&lt;br/&gt;PM&amp;gt; Install-Package DotNetCore.CAP.MySql&lt;br/&gt;PM&amp;gt; Install-Package DotNetCore.CAP.PostgreSql&lt;br/&gt;PM&amp;gt; Install-Package DotNetCore.CAP.MongoDB&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;svg viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;Configuration&lt;/h3&gt;&lt;p&gt;首先配置CAP到 Startup.cs 文件中，如下：&lt;/p&gt;&lt;pre&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;ConfigureServices&lt;/span&gt;(&lt;span&gt;IServiceCollection&lt;/span&gt; &lt;span&gt;services&lt;/span&gt;)&lt;br/&gt;{&lt;br/&gt;    ......&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;services&lt;/span&gt;.&lt;span&gt;AddDbContext&lt;/span&gt;&amp;lt;&lt;span&gt;AppDbContext&lt;/span&gt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;services&lt;/span&gt;.&lt;span&gt;AddCap&lt;/span&gt;(&lt;span&gt;x&lt;/span&gt; &lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;&lt;span&gt;//&lt;/span&gt;如果你使用的 EF 进行数据操作，你需要添加如下配置：&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;x&lt;/span&gt;.&lt;span&gt;UseEntityFramework&lt;/span&gt;&amp;lt;&lt;span&gt;AppDbContext&lt;/span&gt;&amp;gt;();  &lt;span&gt;&lt;span&gt;//&lt;/span&gt;可选项，你不需要再次配置 x.UseSqlServer 了&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;//&lt;/span&gt;如果你使用的ADO.NET，根据数据库选择进行配置：&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;x&lt;/span&gt;.&lt;span&gt;UseSqlServer&lt;/span&gt;(&lt;span&gt;&lt;span&gt;&quot;&lt;/span&gt;数据库连接字符串&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;x&lt;/span&gt;.&lt;span&gt;UseMySql&lt;/span&gt;(&lt;span&gt;&lt;span&gt;&quot;&lt;/span&gt;数据库连接字符串&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;x&lt;/span&gt;.&lt;span&gt;UsePostgreSql&lt;/span&gt;(&lt;span&gt;&lt;span&gt;&quot;&lt;/span&gt;数据库连接字符串&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;//&lt;/span&gt;如果你使用的 MongoDB，你可以添加如下配置：&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;x&lt;/span&gt;.&lt;span&gt;UseMongoDB&lt;/span&gt;(&lt;span&gt;&lt;span&gt;&quot;&lt;/span&gt;ConnectionStrings&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;);  &lt;span&gt;&lt;span&gt;//&lt;/span&gt;注意，仅支持MongoDB 4.0+集群&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;//&lt;/span&gt;CAP支持 RabbitMQ、Kafka、AzureServiceBus 等作为MQ，根据使用选择配置：&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;x&lt;/span&gt;.&lt;span&gt;UseRabbitMQ&lt;/span&gt;(&lt;span&gt;&lt;span&gt;&quot;&lt;/span&gt;ConnectionStrings&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;x&lt;/span&gt;.&lt;span&gt;UseKafka&lt;/span&gt;(&lt;span&gt;&lt;span&gt;&quot;&lt;/span&gt;ConnectionStrings&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;x&lt;/span&gt;.&lt;span&gt;UseAzureServiceBus&lt;/span&gt;(&lt;span&gt;&lt;span&gt;&quot;&lt;/span&gt;ConnectionStrings&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;);&lt;br/&gt;    });&lt;br/&gt;}&lt;br/&gt;&lt;/pre&gt;&lt;h3&gt;&lt;svg viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;发布&lt;/h3&gt;&lt;p&gt;在 Controller 中注入 &lt;code&gt;ICapPublisher&lt;/code&gt; 然后使用 &lt;code&gt;ICapPublisher&lt;/code&gt; 进行消息发送&lt;/p&gt;&lt;pre&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;PublishController&lt;/span&gt; : &lt;span&gt;Controller&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;ICapPublisher&lt;/span&gt; &lt;span&gt;_capBus&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;PublishController&lt;/span&gt;(&lt;span&gt;ICapPublisher&lt;/span&gt; &lt;span&gt;capPublisher&lt;/span&gt;)&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;_capBus&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;capPublisher&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;//&lt;/span&gt;不使用事务&lt;/span&gt;&lt;br/&gt;    [&lt;span&gt;Route&lt;/span&gt;(&lt;span&gt;&lt;span&gt;&quot;&lt;/span&gt;~/without/transaction&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;)]&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;IActionResult&lt;/span&gt; &lt;span&gt;WithoutTransaction&lt;/span&gt;()&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;_capBus&lt;/span&gt;.&lt;span&gt;Publish&lt;/span&gt;(&lt;span&gt;&lt;span&gt;&quot;&lt;/span&gt;xxx.services.show.time&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span&gt;DateTime&lt;/span&gt;.&lt;span&gt;Now&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;Ok&lt;/span&gt;();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;//&lt;/span&gt;Ado.Net 中使用事务，自动提交&lt;/span&gt;&lt;br/&gt;    [&lt;span&gt;Route&lt;/span&gt;(&lt;span&gt;&lt;span&gt;&quot;&lt;/span&gt;~/adonet/transaction&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;)]&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;IActionResult&lt;/span&gt; &lt;span&gt;AdonetWithTransaction&lt;/span&gt;()&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; &lt;span&gt;connection&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;MySqlConnection&lt;/span&gt;(&lt;span&gt;ConnectionString&lt;/span&gt;))&lt;br/&gt;        {&lt;br/&gt;            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; &lt;span&gt;transaction&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;connection&lt;/span&gt;.&lt;span&gt;BeginTransaction&lt;/span&gt;(&lt;span&gt;_capBus&lt;/span&gt;, &lt;span&gt;autoCommit&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;))&lt;br/&gt;            {&lt;br/&gt;                &lt;span&gt;&lt;span&gt;//&lt;/span&gt;业务代码&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;_capBus&lt;/span&gt;.&lt;span&gt;Publish&lt;/span&gt;(&lt;span&gt;&lt;span&gt;&quot;&lt;/span&gt;xxx.services.show.time&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span&gt;DateTime&lt;/span&gt;.&lt;span&gt;Now&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;Ok&lt;/span&gt;();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;//&lt;/span&gt;EntityFramework 中使用事务，自动提交&lt;/span&gt;&lt;br/&gt;    [&lt;span&gt;Route&lt;/span&gt;(&lt;span&gt;&lt;span&gt;&quot;&lt;/span&gt;~/ef/transaction&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;)]&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;IActionResult&lt;/span&gt; &lt;span&gt;EntityFrameworkWithTransaction&lt;/span&gt;([&lt;span&gt;FromServices&lt;/span&gt;]&lt;span&gt;AppDbContext&lt;/span&gt; &lt;span&gt;dbContext&lt;/span&gt;)&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; &lt;span&gt;trans&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;dbContext&lt;/span&gt;.&lt;span&gt;Database&lt;/span&gt;.&lt;span&gt;BeginTransaction&lt;/span&gt;(&lt;span&gt;_capBus&lt;/span&gt;, &lt;span&gt;autoCommit&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;))&lt;br/&gt;        {&lt;br/&gt;            &lt;span&gt;&lt;span&gt;//&lt;/span&gt;业务代码&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;_capBus&lt;/span&gt;.&lt;span&gt;Publish&lt;/span&gt;(&lt;span&gt;&lt;span&gt;&quot;&lt;/span&gt;xxx.services.show.time&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span&gt;DateTime&lt;/span&gt;.&lt;span&gt;Now&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;Ok&lt;/span&gt;();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/pre&gt;&lt;h3&gt;&lt;svg viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;订阅&lt;/h3&gt;&lt;p&gt;&lt;span&gt;Action Method&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在 Action 上添加 CapSubscribeAttribute 来订阅相关消息。&lt;/p&gt;&lt;pre&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;PublishController&lt;/span&gt; : &lt;span&gt;Controller&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;    [&lt;span&gt;CapSubscribe&lt;/span&gt;(&lt;span&gt;&lt;span&gt;&quot;&lt;/span&gt;xxx.services.show.time&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;)]&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;CheckReceivedMessage&lt;/span&gt;(&lt;span&gt;DateTime&lt;/span&gt; &lt;span&gt;datetime&lt;/span&gt;)&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;Console&lt;/span&gt;.&lt;span&gt;WriteLine&lt;/span&gt;(&lt;span&gt;datetime&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;Service Method&lt;/span&gt;&lt;/p&gt;&lt;p&gt;如果你的订阅方法没有位于 Controller 中，则你订阅的类需要继承 &lt;code&gt;ICapSubscribe&lt;/code&gt;：&lt;/p&gt;&lt;pre&gt;&lt;span&gt;namespace&lt;/span&gt; &lt;span&gt;xxx&lt;/span&gt;.&lt;span&gt;Service&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; &lt;span&gt;ISubscriberService&lt;/span&gt;&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;void&lt;/span&gt; &lt;span&gt;CheckReceivedMessage&lt;/span&gt;(&lt;span&gt;DateTime&lt;/span&gt; &lt;span&gt;datetime&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;SubscriberService&lt;/span&gt;: &lt;span&gt;ISubscriberService&lt;/span&gt;, &lt;span&gt;ICapSubscribe&lt;/span&gt;&lt;br/&gt;    {&lt;br/&gt;        [&lt;span&gt;CapSubscribe&lt;/span&gt;(&lt;span&gt;&lt;span&gt;&quot;&lt;/span&gt;xxx.services.show.time&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;)]&lt;br/&gt;        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;CheckReceivedMessage&lt;/span&gt;(&lt;span&gt;DateTime&lt;/span&gt; &lt;span&gt;datetime&lt;/span&gt;)&lt;br/&gt;        {&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;然后在 Startup.cs 中的 &lt;code&gt;ConfigureServices()&lt;/code&gt; 中注入你的 &lt;code&gt;ISubscriberService&lt;/code&gt; 类&lt;/p&gt;&lt;pre&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;ConfigureServices&lt;/span&gt;(&lt;span&gt;IServiceCollection&lt;/span&gt; &lt;span&gt;services&lt;/span&gt;)&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;//&lt;/span&gt;注意: 注入的服务需要在 `services.AddCap()` 之前&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;services&lt;/span&gt;.&lt;span&gt;AddTransient&lt;/span&gt;&amp;lt;&lt;span&gt;ISubscriberService&lt;/span&gt;,&lt;span&gt;SubscriberService&lt;/span&gt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;services&lt;/span&gt;.&lt;span&gt;AddCap&lt;/span&gt;(&lt;span&gt;x&lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;{});&lt;br/&gt;}&lt;/pre&gt;&lt;h4&gt;&lt;svg viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;订阅者组&lt;/h4&gt;&lt;p&gt;订阅者组的概念类似于 Kafka 中的消费者组，它和消息队列中的广播模式相同，用来处理不同微服务实例之间同时消费相同的消息。&lt;/p&gt;&lt;p&gt;当CAP启动的时候，她将创建一个默认的消费者组，如果多个相同消费者组的消费者消费同一个Topic消息的时候，只会有一个消费者被执行。相反，如果消费者都位于不同的消费者组，则所有的消费者都会被执行。&lt;/p&gt;&lt;p&gt;相同的实例中，你可以通过下面的方式来指定他们位于不同的消费者组。&lt;/p&gt;&lt;pre&gt;[&lt;span&gt;CapSubscribe&lt;/span&gt;(&lt;span&gt;&lt;span&gt;&quot;&lt;/span&gt;xxx.services.show.time&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span&gt;Group&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&lt;span&gt;&quot;&lt;/span&gt;group1&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt; )]&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;ShowTime1&lt;/span&gt;(&lt;span&gt;DateTime&lt;/span&gt; &lt;span&gt;datetime&lt;/span&gt;)&lt;br/&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;[&lt;span&gt;CapSubscribe&lt;/span&gt;(&lt;span&gt;&lt;span&gt;&quot;&lt;/span&gt;xxx.services.show.time&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span&gt;Group&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&lt;span&gt;&quot;&lt;/span&gt;group2&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;)]&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;ShowTime2&lt;/span&gt;(&lt;span&gt;DateTime&lt;/span&gt; &lt;span&gt;datetime&lt;/span&gt;)&lt;br/&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;ShowTime1&lt;/code&gt; 和 &lt;code&gt;ShowTime2&lt;/code&gt; 处于不同的组，他们将会被同时调用。&lt;/p&gt;&lt;p&gt;PS，你可以通过下面的方式来指定默认的消费者组名称：&lt;/p&gt;&lt;pre&gt;&lt;span&gt;services&lt;/span&gt;.&lt;span&gt;AddCap&lt;/span&gt;(&lt;span&gt;x&lt;/span&gt; &lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;x&lt;/span&gt;.&lt;span&gt;DefaultGroup&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&lt;span&gt;&quot;&lt;/span&gt;default-group-name&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;;  &lt;br/&gt;});&lt;br/&gt;&lt;/pre&gt;&lt;h3&gt;&lt;svg viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;Dashboard&lt;/h3&gt;&lt;p&gt;CAP 2.1+ 以上版本中提供了仪表盘（Dashboard）功能，你可以很方便的查看发出和接收到的消息。除此之外，你还可以在仪表盘中实时查看发送或者接收到的消息。&lt;/p&gt;&lt;p&gt;使用一下命令安装 Dashboard：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;PM&amp;gt; Install-Package DotNetCore.CAP.Dashboard&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在分布式环境中，仪表盘内置集成了 Consul 作为节点的注册发现，同时实现了网关代理功能，你同样可以方便的查看本节点或者其他节点的数据，它就像你访问本地资源一样。&lt;/p&gt;&lt;pre&gt;&lt;span&gt;services&lt;/span&gt;.&lt;span&gt;AddCap&lt;/span&gt;(&lt;span&gt;x&lt;/span&gt; &lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;//&lt;/span&gt;...&lt;/span&gt;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;//&lt;/span&gt; 注册 Dashboard&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;x&lt;/span&gt;.&lt;span&gt;UseDashboard&lt;/span&gt;();&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;//&lt;/span&gt; 注册节点到 Consul&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;x&lt;/span&gt;.&lt;span&gt;UseDiscovery&lt;/span&gt;(&lt;span&gt;d&lt;/span&gt; &lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;d&lt;/span&gt;.&lt;span&gt;DiscoveryServerHostName&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&lt;span&gt;&quot;&lt;/span&gt;localhost&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;d&lt;/span&gt;.&lt;span&gt;DiscoveryServerPort&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;8500&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;d&lt;/span&gt;.&lt;span&gt;CurrentNodeHostName&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&lt;span&gt;&quot;&lt;/span&gt;localhost&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;d&lt;/span&gt;.&lt;span&gt;CurrentNodePort&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;5800&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;d&lt;/span&gt;.&lt;span&gt;NodeId&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;d&lt;/span&gt;.&lt;span&gt;NodeName&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&lt;span&gt;&quot;&lt;/span&gt;CAP No.1 Node&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    });&lt;br/&gt;});&lt;/pre&gt;&lt;p&gt;仪表盘默认的访问地址是：http://localhost:xxx/cap，你可以在&lt;code&gt;d.MatchPath&lt;/code&gt;配置项中修改&lt;code&gt;cap&lt;/code&gt;路径后缀为其他的名字。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5749235474006116&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia9mEhlib6icjTSF4K98gpBlCz2b9C7M5suBEU38ZoAZkpX7VknlLrwZQpnW9L7Ue71Nf2rTBfL2EFCpFKXOaZsAw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;981&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>88579463d37b40ff87c4b55cf72cf8c7</guid>
<title>Nginx Buffer 机制引发的下载故障</title>
<link>https://toutiao.io/k/6ld5fxn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;&amp;#10;                col-lg-8 col-lg-offset-2&amp;#10;                col-md-10 col-md-offset-1&amp;#10;                post-container&quot;&gt;

                
                

&lt;p&gt;前几天，接到研发同事反馈，内网通过 Nginx 代理下载 OSS 的大文件时，老是会断，而在服务器上下载时却很正常，非常奇怪。原本以为可能和 VPN 有关，经确认排除嫌疑。彷徨了许久，最后发现是 Nginx Buffer 的锅。下面就来聊聊这个问题是怎么发生的。&lt;/p&gt;

&lt;h2 id=&quot;nginx-buffer-机制&quot;&gt;Nginx Buffer 机制&lt;/h2&gt;

&lt;p&gt;在 Nginx 代理过程中，有两种连接：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;客户端到 Nginx 的连接&lt;/li&gt;
  &lt;li&gt;Nginx 到后端服务器的连接&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这两个连接的速度不一致，会对客户端的体验带来不良的影响。Nginx 正是通过 Buffer 机制来缓解这个问题。&lt;/p&gt;

&lt;p&gt;当启用 buffer 时，Nginx 将会临时存储后端响应内容在内存或者磁盘上，然后慢慢把数据推送给客户端；若关闭，则会按照响应内容的多少立刻同步到客户端。&lt;/p&gt;

&lt;p&gt;假设客户端的速度足够快，那么完全可以把 buffer 关掉，让数据尽可能快速到达；如果客户端很慢，就应该保持 buffer 开启，这样有利于 Nginx 和后端的连接复用（本质上是 HTTP 队头阻塞问题）。&lt;/p&gt;

&lt;h2 id=&quot;大文件下载问题&quot;&gt;大文件下载问题&lt;/h2&gt;

&lt;p&gt;Nginx Buffer 机制默认处于开启状态，其会根据 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;proxy_buffer_size&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;proxy_buffers&lt;/code&gt; 这两个参数控制写入内存的大小。如果响应大于这个 buffer 大小，Nginx 会继续通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;proxy_max_temp_file_size&lt;/code&gt; 参数将响应其余部分写入到磁盘临时文件。&lt;/p&gt;

&lt;p&gt;那么问题来了，如果响应还是很大，超过了临时文件的限额怎么办？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;等！&lt;/strong&gt; &lt;u&gt;此时，Nginx 的 socket 缓冲区也是出于满载状态。由于客户端很慢，Nginx 并没有触发 `read` 后端操作。这里大概率会触发后端服务器的 `write` 超时，进而由后端发起 `close` 操作。&lt;/u&gt;&lt;/p&gt;

&lt;p&gt;这就是我遇到的问题：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;proxy_max_temp_file_size&lt;/code&gt; 默认为 1G，当客户端的网络比较慢时，临时文件很快就被写满。这时候后端的响应还会继续被接收到 socket 缓冲区，直到缓冲区被打满。此时，Nginx 所在服务器通过滑动窗口 zero 0 告知后端服务器停止发送数据，直至触发了后端的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write&lt;/code&gt; 超时。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/wget-partially-downloaded.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;而当客户端的网络比较快时，临时文件并不会被写满，或者即使写满了也很快就会消费掉，不至于让后端“阻塞”过长时间触发超时。&lt;/p&gt;

&lt;h2 id=&quot;如何解决&quot;&gt;如何解决？&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;调整 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;proxy_max_temp_file_size&lt;/code&gt; 大小&lt;/p&gt;

    
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关闭 Buffer&lt;/p&gt;

    &lt;p&gt;不推荐，会影响 Nginx 到后端的连接复用&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;参考文章&quot;&gt;参考文章&lt;/h2&gt;




                &lt;hr/&gt;

                


                
                
                
                
                

                
            &lt;/div&gt;

    
        
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e06cdc962f88a91bcbed48079184b650</guid>
<title>用 Go struct 不能犯的一个低级错误</title>
<link>https://toutiao.io/k/5gpirgo</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是煎鱼。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前段时间我分享了 《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxMDI4MDc1NA==&amp;amp;mid=2247487631&amp;amp;idx=1&amp;amp;sn=0c6d3e548573197e8281f622d8d5b0d7&amp;amp;chksm=f90405d2ce738cc401029885459b1ef29095a429ac7d71667e94750966b3dae1044e09fbdc77&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;手撕 Go 面试官：Go 结构体是否可以比较，为什么？&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;手撕 Go 面试官：Go 结构体是否可以比较，为什么？&lt;/a&gt;》的文章，把基本 Go struct 的比较依据研究了一番。这不，最近有一位读者，遇到了一个关于 struct 的新问题，踩到了雷区。不得解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家一起来看看，建议大家在看到代码例子后先思考一下答案，再往下看。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;独立思考很重要。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;疑惑的例子&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其给出的例子一如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; People &lt;span&gt;struct&lt;/span&gt; {}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; a := &amp;amp;People{}&lt;br/&gt; b := &amp;amp;People{}&lt;br/&gt; fmt.Println(a == b)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你认为输出结果是什么呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果是：false。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再稍加改造一下，例子二如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; People &lt;span&gt;struct&lt;/span&gt; {}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; a := &amp;amp;People{}&lt;br/&gt; b := &amp;amp;People{}&lt;br/&gt; fmt.Printf(&lt;span&gt;&quot;%p\n&quot;&lt;/span&gt;, a)&lt;br/&gt; fmt.Printf(&lt;span&gt;&quot;%p\n&quot;&lt;/span&gt;, b)&lt;br/&gt; fmt.Println(a == b)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果是：true。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;他的问题是 &quot;&lt;strong&gt;为什么第一个返回 false 第二个返回 true，是什么原因导致的&lt;/strong&gt;？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;煎鱼进一步的精简这个例子，得到最小示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; a := &lt;span&gt;new&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;{})&lt;br/&gt; b := &lt;span&gt;new&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;{})&lt;br/&gt; &lt;span&gt;println&lt;/span&gt;(a, b, a == b)&lt;br/&gt;&lt;br/&gt; c := &lt;span&gt;new&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;{})&lt;br/&gt; d := &lt;span&gt;new&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;{})&lt;br/&gt; fmt.Println(c, d)&lt;br/&gt; &lt;span&gt;println&lt;/span&gt;(c, d, c == d)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// a, b; a == b&lt;br/&gt;0xc00005cf57 0xc00005cf57 &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;// c, d&lt;br/&gt;&amp;amp;{} &amp;amp;{}&lt;br/&gt;// c, d, c == d&lt;br/&gt;0x118c370 0x118c370 &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一段代码的结果是 false，第二段的结果是 true，且可以看到内存地址指向的完全一样，也就是排除了输出后变量内存指向改变导致的原因。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进一步来看，似乎是 &lt;code&gt;fmt.Print&lt;/code&gt; 方法导致的，但一个标准库里的输出方法，会导致这种奇怪的问题？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;问题剖析&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果之前有被这个 “坑” 过，或有看过源码的同学。可能能够快速的意识到，导致这个输出是&lt;strong&gt;逃逸分析&lt;/strong&gt;所致的结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们对例子进行逃逸分析：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 源代码结构&lt;br/&gt;$ cat -n main.go&lt;br/&gt;     5 func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;     6  a := new(struct{})&lt;br/&gt;     7  b := new(struct{})&lt;br/&gt;     8  println(a, b, a == b)&lt;br/&gt;     9 &lt;br/&gt;    10  c := new(struct{})&lt;br/&gt;    11  d := new(struct{})&lt;br/&gt;    12  fmt.Println(c, d)&lt;br/&gt;    13  println(c, d, c == d)&lt;br/&gt;    14 }&lt;br/&gt;&lt;br/&gt;// 进行逃逸分析&lt;br/&gt;$ go run -gcflags=&lt;span&gt;&quot;-m -l&quot;&lt;/span&gt; main.go&lt;br/&gt;&lt;span&gt;# command-line-arguments&lt;/span&gt;&lt;br/&gt;./main.go:6:10: a does not escape&lt;br/&gt;./main.go:7:10: b does not escape&lt;br/&gt;./main.go:10:10: c escapes to heap&lt;br/&gt;./main.go:11:10: d escapes to heap&lt;br/&gt;./main.go:12:13: ... argument does not escape&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过分析可得知变量 a, b 均是分配在栈中，而变量 c, d 分配在堆中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其关键原因是因为调用了 &lt;code&gt;fmt.Println&lt;/code&gt; 方法，该方法内部是涉及到大量的反射相关方法的调用，会造成逃逸行为，也就是分配到堆上。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;为什么逃逸后相等&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关注第一个细节，就是 “为什么逃逸后，两个空 struct 会是相等的？”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里主要与 Go runtime 的一个优化细节有关，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// runtime/malloc.go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; zerobase &lt;span&gt;uintptr&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;变量 &lt;code&gt;zerobase&lt;/code&gt; 是所有 0 字节分配的基础地址。更进一步来讲，就是空（0字节）的在进行了逃逸分析后，往堆分配的都会指向 &lt;code&gt;zerobase&lt;/code&gt; 这一个地址。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以空 struct 在逃逸后本质上指向了 &lt;code&gt;zerobase&lt;/code&gt;，其两者比较就是相等的，返回了 true。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;为什么没逃逸不相等&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关注第二个细节，就是 “为什么没逃逸前，两个空 struct 比较不相等？”。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.15115207373271888&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4jWGSpibCpWMJiaqrfkKrkyAprxm6Z3Bzia8Z5ByhoIia2AgaWpocAdq8ZGic6OsmSfkXEyhW5NYY0wPMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2170&quot;/&gt;&lt;figcaption&gt;Go spec&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从 Go spec 来看，这是 Go 团队刻意而为之的设计，不希望大家依赖这一个来做判断依据。如下：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;blockquote&gt;&lt;p&gt;This is an intentional language choice to give implementations flexibility in how they handle pointers to zero-sized objects. If every pointer to a zero-sized object were required to be different, then each allocation of a zero-sized object would have to allocate at least one byte. If every pointer to a zero-sized object were required to be the same, it would be different to handle taking the address of a zero-sized field within a larger struct.&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还说了一句很经典的，细品：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;blockquote&gt;&lt;p&gt;Pointers to distinct zero-size variables may or may not be equal.&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外空 struct 在实际使用中的场景是比较少的，常见的是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;设置 context，传递时作为 key 时用到。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设置空 struct 业务场景中临时用到。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但业务场景的情况下，也大多数会随着业务发展而不断改变，假设有个远古时代的 Go 代码，依赖了空 struct 的直接判断，岂不是事故上身？&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;不可直接依赖&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此 Go 团队这番操作，与 Go map 的随机性如出一辙，避免大家对这类逻辑的直接依赖，是值得思考的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在没逃逸的场景下，两个空 struct 的比较动作，你以为是真的在比较。实际上已经在代码优化阶段被直接优化掉，转为了 false。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，虽然在代码上看上去是 == 在做比较，实际上结果是 a == b 时就直接转为了 false，比都不需要比了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你说妙不？&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;没逃逸让他相等&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然我们知道了他是在代码优化阶段被优化的，那么相对的，知道了原理的我们也可以借助在 go 编译运行时的 gcflags 指令，让他不优化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在运行前面的例子时，执行 &lt;code&gt;-gcflags=&quot;-N -l&quot;&lt;/code&gt; 指令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ go run -gcflags=&lt;span&gt;&quot;-N -l&quot;&lt;/span&gt; main.go &lt;br/&gt;0xc000092f06 0xc000092f06 &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&amp;amp;{} &amp;amp;{}&lt;br/&gt;0x118c370 0x118c370 &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你看，两个比较的结果都是 true 了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在今天这篇文章中，我们针对 Go 语言中的空结构体（struct）的比较场景进行了进一步的补全。&lt;span&gt;经过这两篇文章的洗礼，你会更好的理解 Go 结构体为什么叫既可比较又不可比较了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而空结构比较的奇妙，主要原因如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;若逃逸到堆上，空结构体则默认分配的是 &lt;code&gt;runtime.zerobase&lt;/code&gt; 变量，是专门用于分配到堆上的 0 字节基础地址。因此两个空结构体，都是 &lt;code&gt;runtime.zerobase&lt;/code&gt;，一比较当然就是 true 了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;若没有发生逃逸，也就分配到栈上。在 Go 编译器的代码优化阶段，会对其进行优化，直接返回 false。并不是传统意义上的，真的去比较了。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不会有人拿来出面试题，不会吧，为什么 Go 结构体说可比较又不可比较？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，感谢欧神的指导和曹大的文章。我是煎鱼，咱们下篇文章见 ：）&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;参考&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;欧神的微信交流&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;曹大的一个空 struct 的“坑”&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUxMDI4MDc1NA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4iac2xQZIq5icSiaTepuae8zLIUMiaxibbUM8ic735ewo6e89GRtjGbUBlgNYibwCjAicglQcvz6dCQ6yTKOw/0?wx_fmt=png&quot; data-nickname=&quot;脑子进煎鱼了&quot; data-alias=&quot;eddycjy&quot; data-signature=&quot;分享计算机基础、Go 语言、微服务架构和系统设计；著有图书《Go 语言编程之旅》。&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;关注煎鱼，吸取他的知识 👆&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e80db142d7801d37e2a2d2b92e4100e5</guid>
<title>资料 | Go 语言实用教程</title>
<link>https://toutiao.io/k/9squgg8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;大家好，我是周刊菌。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzA4Njk2NDAzMA==&amp;amp;mid=2660215266&amp;amp;idx=2&amp;amp;sn=54400f6300be9d601500e59d737997e2&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;牛年行牛运！加入「码农周刊VIP会员」，一起牛起来！&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;牛年行牛运！加入「码农周刊VIP会员」，一起牛起来！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以下内容选自「码农周刊 VIP 会员」圈子，每日更新，精彩不断&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;1270&quot; data-ratio=&quot;2.408&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavibc322ykQ89YfEOSt9Z0b4Lbiau4AxXrzLo513GUXMfcB0EeWTydygvmKtqSa1U2SexhgTpmNsdJuw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;码农周刊是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;码农周刊是一份专为广大程序员、编程爱好者们打造的 IT 技术周刊。每周发送。&lt;br/&gt;2013 年 9 月 12 日创刊至今，已发送 300 多期，订阅用户超 20 万。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;专业、简单、有用&lt;/span&gt;&lt;span&gt;，是我们一直坚持的办刊宗旨。一路走来，我们见证了不少订阅用户从编程新手进阶成了高级程序员、架构师、CTO……&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2020 年 4 月，为了给用户提供更优质的服务，我们推出了「&lt;/span&gt;&lt;span&gt;码农周刊VIP会员&lt;/span&gt;&lt;span&gt;」服务。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你与 BAT 技术大牛，只差一份「码农周刊VIP会员」的距离！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;VIP会员特权&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 52 期码农周刊VIP会员&lt;span&gt;专属邮件周报&lt;/span&gt;，让你及时掌握技术动向；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 只限VIP会员加入的&lt;span&gt;交流圈子&lt;/span&gt;，让你与技术大牛切磋学习；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. VIP会员独享的&lt;span&gt;工作机会&lt;/span&gt;，为你介绍好公司的好机会；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 更多会员特权，持续更新……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如何加入「码农周刊VIP会员」？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1. 微信扫描下方二维码，加入码农周刊VIP会员知识星球。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;促销期间，一年仅需 108 元！平均一天花费不到 3 毛！&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;322&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;350&quot; data-ratio=&quot;1.318840579710145&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;690&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNav8pVYfXHFZnJw6GmED4PucZvQd6m3AP8fUG1IKJyBgicmJ3P5ygQjO5r6Bib2x190MFOlb6PwExNQuA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 加入码农周刊VIP会员知识星球后，客服会联系您，请留意知识星球内的私信。&lt;br/&gt;3. 客服向您发送码农周刊VIP会员欢迎邮件，开启您的码农周刊VIP会员之旅。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;心动不如心动，赶快订阅吧！&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>