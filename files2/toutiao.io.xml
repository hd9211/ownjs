<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f24db38f0123670608e70ccdb7ca9786</guid>
<title>IntelliJ 超级实用的 8 个插件</title>
<link>https://toutiao.io/k/vx0h11u</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6664285714285715&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl90Sbe6BYgU4nS8iaicCOtp1SYPTuNydaTNgW9LUzBTf4ZcVo5qSia79JRMKeSUb8bSjiakiboNwkciaYHhw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. IDE Features Trainer&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是 IntelliJ 官方推出的一个插件，可以帮助我们快速学习 IntelliJ 的功能特性，更好的使用它。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5034802784222738&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl90Sbe6BYgU4nS8iaicCOtp1SYopup81Kz2J9ZEcynExzCrldlgZR39sR74mKoxocxPQcm1qmLaEbP0g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1293&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. Codota&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Codota 是一款非常智能的代码提示插件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Codota 扫描了 GitHub 中数百万的代码仓库，分析并学习这些源码，由此可以为我们提供非常优秀的代码建议。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.615&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl90Sbe6BYgU4nS8iaicCOtp1SYTd0emZiaRL1XthkD5y8icc5V4CAZ5cickvK1AyklNwAMUMLbGdmBjqBsg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3082706766917293&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl90Sbe6BYgU4nS8iaicCOtp1SYfxteeNAJ616XlR2JXM5d0wBJOoibqo2MGXZKDaUAelBUOvUeBmbp6KQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1330&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. Comments Highlighter&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个插件可以为注释上色，让我们的注释不再那么沉闷。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尤其是我们想在注释中给出非常重要的信息时，这个插件就更有用了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.3722627737226278&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl90Sbe6BYgU4nS8iaicCOtp1SYX9hXKqlpmXUBoJIgQXQhfxO7tn0ne22DymhaWJTaXNOw33B24M7xpw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;411&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. Return Highlighter&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个插件会在返回语句那行进行标记，这在我们阅读外部源码时比较有用。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.24049429657794677&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl90Sbe6BYgU4nS8iaicCOtp1SYL9WmSJyicJqcRlDGSYNRrt2iaFlT8UrDWXvOIkbnicvxsY2gW9TfP4new/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1052&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5. Key Promoter X&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每次你点击 IntelliJ 的按钮时，这个插件就会弹出快捷键的提示，可以帮助我们更快的掌握快捷键。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5161290322580645&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl90Sbe6BYgU4nS8iaicCOtp1SYEiaCwpkCM4FIKRibvicsx8IKeekCGMqAf67h9BLk5s9iccgOCYR36iapOnA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1364&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6. Atom Material Icons&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个插件没有什么特殊的功能，但丰富了 IntelliJ 图标。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;2.446327683615819&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl90Sbe6BYgU4nS8iaicCOtp1SYLdgxy4rL3qibtPE4BddCOcNtFRyibAHsoiaRcy8vXSHsaUgGtJliayxRmw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;354&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7. Code With Me&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也是 IntelliJ 的官方插件，允许他人操作自己的项目，适用于协同工作场景。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/wv3K6j4ibl90Sbe6BYgU4nS8iaicCOtp1SY03UjQpbflIjZ2dItctS7TcbOxaRqeKeXu9GldVSIp0nDSLnzkTnGIA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8. Yet Another Emoji Support&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个插件可以直接在编辑器中写表情符号，例如在写 README、提交信息或者注释的时候非常实用。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6414285714285715&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl90Sbe6BYgU4nS8iaicCOtp1SYldfdBFWnXCktq4X8WAWs4pLicnvyc2EAhuSN26efYvA0D0Xrv0GL45g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5781990521327014&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/wv3K6j4ibl90Sbe6BYgU4nS8iaicCOtp1SYlmLH7kWrucqdyHycYFodtmVR0Zk1T8H16herQWnx6dYUSl5vYTYh0Q/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;422&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考资料&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://medium.com/better-programming/the-top-12-intellij-plugins-for-2021-55b1815e0eb&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>892baf71bda31f71ef64824af29a0c55</guid>
<title>工具 | 腾讯开源的分布式高性能 KV 存储数据库</title>
<link>https://toutiao.io/k/diu62t3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                              &lt;strong class=&quot;profile_nickname&quot;&gt;开发者头条&lt;/strong&gt;
                              &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;kaifazhetoutiao&lt;/span&gt;
                              &lt;/p&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;程序员分享平台 | 官方应用下载地址：http://toutiao.io/download&lt;/span&gt;
                              &lt;/p&gt;
                              
                          &lt;/div&gt;
                          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5a1f5506976c0014cf726dbd193b337a</guid>
<title>携程 Redis 治理演进之路（二）</title>
<link>https://toutiao.io/k/zzmvet2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>aae62e3e7f4364554da3021dd4dcdc47</guid>
<title>Class.forName 造成的线程阻塞</title>
<link>https://toutiao.io/k/q7ikhfm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;今天在查看服务器时，发现机器上稳定的会有 3 ~ 4 个线程处于阻塞状态，感觉应该是有问题的，仔细排查了一下，最终发现和 Class.forName 有关。&lt;/p&gt;&lt;h2&gt;现象&lt;/h2&gt;&lt;p&gt;某一天突然收到了公司的系统提醒，说是我们的服务中，长时间都有好几个处于&lt;code&gt;BLOCKED&lt;/code&gt;状态的线程。&lt;/p&gt;&lt;p&gt;因为我们的访问量还是不小的，因此写了一段代码模拟了一下，大致类似于：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import java.beans.BeanInfo;&lt;br/&gt;import java.beans.Introspector;&lt;br/&gt;import java.util.concurrent.CountDownLatch;&lt;br/&gt;import java.util.concurrent.LinkedBlockingQueue;&lt;br/&gt;import java.util.concurrent.ThreadFactory;&lt;br/&gt;import java.util.concurrent.ThreadPoolExecutor;&lt;br/&gt;import java.util.concurrent.TimeUnit;&lt;br/&gt;import java.util.concurrent.atomic.AtomicInteger;&lt;br/&gt;&lt;br/&gt;public class Test {&lt;br/&gt;&lt;br/&gt;  public static void main(String[] args) throws InterruptedException {&lt;br/&gt;    ThreadPoolExecutor executor = new ThreadPoolExecutor(10, 10, 0, TimeUnit.SECONDS,&lt;br/&gt;        new LinkedBlockingQueue&amp;lt;&amp;gt;(), new ThreadFactory() {&lt;br/&gt;      private final AtomicInteger count = new AtomicInteger(0);&lt;br/&gt;&lt;br/&gt;      @Override&lt;br/&gt;      public Thread newThread(Runnable r) {&lt;br/&gt;        return new Thread(r, &quot;testThread-&quot; + count.incrementAndGet());&lt;br/&gt;      }&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;    int totalCount = 1000;&lt;br/&gt;    CountDownLatch latch = new CountDownLatch(totalCount);&lt;br/&gt;    for (int i = 0; i &amp;lt; totalCount; i++) {&lt;br/&gt;      int current = i;&lt;br/&gt;      executor.execute(() -&amp;gt; {&lt;br/&gt;        try {&lt;br/&gt;          for (int j = 0; j &amp;lt; totalCount; j++) {&lt;br/&gt;            BeanInfo destBean = Introspector.getBeanInfo(Test.class, java.lang.Object.class);&lt;br/&gt;          }&lt;br/&gt;        } catch (Exception e) {&lt;br/&gt;          System.out.println(current + &quot;\tfail&quot;);&lt;br/&gt;        } finally {&lt;br/&gt;          latch.countDown();&lt;br/&gt;        }&lt;br/&gt;      });&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    latch.await();&lt;br/&gt;    System.out.println(&quot;finish&quot;);&lt;br/&gt;    executor.shutdown();&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  private String name;&lt;br/&gt;&lt;br/&gt;  private Integer age;&lt;br/&gt;&lt;br/&gt;  public String getName() {&lt;br/&gt;    return name;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  public void setName(String name) {&lt;br/&gt;    this.name = name;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  public Integer getAge() {&lt;br/&gt;    return age;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  public void setAge(Integer age) {&lt;br/&gt;    this.age = age;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当时登上了服务器，首先查询出我们的 java 进程号：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;ps -ef | grep java&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;假设结果是&lt;code&gt;26385&lt;/code&gt;，这时再借助&lt;code&gt;jstack&lt;/code&gt;命令打印出各个线程的状态：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;jstack 26385 &amp;gt; 26385.txt&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后分析了&lt;code&gt;26385.txt&lt;/code&gt;，发现了原因：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&quot;testThread-7&quot; #14 prio=5 os_prio=0 tid=0x00007f72a810e800 nid=0x6706 waiting for monitor entry [0x00007f729837c000]&lt;br/&gt;   java.lang.Thread.State: BLOCKED (on object monitor)&lt;br/&gt;    at java.lang.ClassLoader.loadClass(ClassLoader.java:404)&lt;br/&gt;    - waiting to lock &amp;lt;0x00000000f7c773b8&amp;gt; (a java.lang.Object)&lt;br/&gt;    at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:349)&lt;br/&gt;    at java.lang.ClassLoader.loadClass(ClassLoader.java:357)&lt;br/&gt;    at java.lang.Class.forName0(Native Method)&lt;br/&gt;    at java.lang.Class.forName(Class.java:348)&lt;br/&gt;    at com.sun.beans.finder.ClassFinder.findClass(ClassFinder.java:103)&lt;br/&gt;    at java.beans.Introspector.findCustomizerClass(Introspector.java:1301)&lt;br/&gt;    at java.beans.Introspector.getTargetBeanDescriptor(Introspector.java:1295)&lt;br/&gt;    at java.beans.Introspector.getBeanInfo(Introspector.java:425)&lt;br/&gt;    at java.beans.Introspector.getBeanInfo(Introspector.java:262)&lt;br/&gt;    at java.beans.Introspector.getBeanInfo(Introspector.java:224)&lt;br/&gt;    at Test.lambda$main$0(Test.java:35)&lt;br/&gt;    at Test$$Lambda$1/303563356.run(Unknown Source)&lt;br/&gt;    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)&lt;br/&gt;    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)&lt;br/&gt;    at java.lang.Thread.run(Thread.java:748)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面很清晰地显示了，我们写的&lt;code&gt;Introspector.getBeanInfo&lt;/code&gt;代码，最终会调用&lt;code&gt;Class&lt;/code&gt;类中的&lt;code&gt;forName0&lt;/code&gt;方法：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;    /** Called after security check for system loader access checks have been made. */&lt;br/&gt;    private static native Class&amp;lt;?&amp;gt; forName0(String name, boolean initialize,&lt;br/&gt;                                            ClassLoader loader,&lt;br/&gt;                                            Class&amp;lt;?&amp;gt; caller)&lt;br/&gt;        throws ClassNotFoundException;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从上面的&lt;code&gt;stack&lt;/code&gt;中分析可以得知，这个方法内部应该是有锁的，因此会阻塞其他线程。&lt;/p&gt;&lt;h2&gt;解决方法&lt;/h2&gt;&lt;p&gt;既然它是有锁的，为了不让它在运行时每次都执行，最简单的方法就是在初始化时，就将需要处理的类全部处理好，这样在应用运行期间，完全不会再去反射。&lt;/p&gt;&lt;h2&gt;源码&lt;/h2&gt;&lt;p&gt;有些人可能会好奇，&lt;code&gt;forName0&lt;/code&gt;中究竟是如何使用到了锁，这里就把源码展示给大家。&lt;/p&gt;&lt;p&gt;下文的调用链路是：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;forName0 -&amp;gt; JVM_FindClassFromCaller -&amp;gt; find_class_from_class_loader -&amp;gt; resolve_or_fail -&amp;gt; resolve_or_null -&amp;gt; resolve_instance_class_or_null -&amp;gt; load_instance_class&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;forName0&lt;/code&gt;源码实现位于&lt;code&gt;src/java.base/share/native/libjava/Class.c&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 动态装载类型入口&lt;br/&gt;JNIEXPORT jclass JNICALL&lt;br/&gt;Java_java_lang_Class_forName0(JNIEnv *env, jclass this, jstring classname,&lt;br/&gt;                              jboolean initialize, jobject loader, jclass caller)&lt;br/&gt;{&lt;br/&gt;    char *clname;&lt;br/&gt;    jclass cls = 0;&lt;br/&gt;    char buf[128];&lt;br/&gt;    jsize len;&lt;br/&gt;    jsize unicode_len;&lt;br/&gt;&lt;br/&gt;    if (classname == NULL) {&lt;br/&gt;        JNU_ThrowNullPointerException(env, 0);&lt;br/&gt;        return 0;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    // 把类全限定名里的&#x27;.&#x27;翻译成&#x27;/&#x27;&lt;br/&gt;    if (VerifyFixClassname(clname) == JNI_TRUE) {&lt;br/&gt;        /* slashes present in clname, use name b4 translation for exception */&lt;br/&gt;        (*env)-&amp;gt;GetStringUTFRegion(env, classname, 0, unicode_len, clname);&lt;br/&gt;        JNU_ThrowClassNotFoundException(env, clname);&lt;br/&gt;        goto done;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    // 验证类全限定名名合法性（是否以&#x27;/&#x27;分隔）&lt;br/&gt;    if (!VerifyClassname(clname, JNI_TRUE)) {  /* expects slashed name */&lt;br/&gt;        JNU_ThrowClassNotFoundException(env, clname);&lt;br/&gt;        goto done;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    // 从指定的加载器查找该类&lt;br/&gt;    cls = JVM_FindClassFromCaller(env, clname, initialize, loader, caller);&lt;br/&gt;&lt;br/&gt; done:&lt;br/&gt;    if (clname != buf) {&lt;br/&gt;        free(clname);&lt;br/&gt;    }&lt;br/&gt;    return cls;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;FindClassFromCaller&lt;/code&gt;位于&lt;code&gt;src/hotspot/share/prims/jvm.cpp&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 从指定的加载器查找该类&lt;br/&gt;// Find a class with this name in this loader, using the caller&#x27;s protection domain.&lt;br/&gt;JVM_ENTRY(jclass, JVM_FindClassFromCaller(JNIEnv* env, const char* name,&lt;br/&gt;                                          jboolean init, jobject loader,&lt;br/&gt;                                          jclass caller))&lt;br/&gt;&lt;br/&gt;  // 把当前类加入符号表（一个哈希表实现）&lt;br/&gt;  TempNewSymbol h_name = SymbolTable::new_symbol(name, CHECK_NULL);&lt;br/&gt;&lt;br/&gt;  // 获取加载器和调用类&lt;br/&gt;  oop loader_oop = JNIHandles::resolve(loader);&lt;br/&gt;  oop from_class = JNIHandles::resolve(caller);&lt;br/&gt;  oop protection_domain = NULL;&lt;br/&gt;&lt;br/&gt;  if (from_class != NULL &amp;amp;&amp;amp; loader_oop != NULL) {&lt;br/&gt;    protection_domain = java_lang_Class::as_Klass(from_class)-&amp;gt;protection_domain();&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  // 查找该类&lt;br/&gt;  jclass result = find_class_from_class_loader(env, h_name, init, h_loader,&lt;br/&gt;                                               h_prot, false, THREAD);&lt;br/&gt;&lt;br/&gt;  // 返回结果&lt;br/&gt;  return result;&lt;br/&gt;JVM_END&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;find_class_from_class_loader&lt;/code&gt;位于&lt;code&gt;/src/hotspot/share/prims/jvm.cpp&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// Shared JNI/JVM entry points //////////////////////////////////////////////////////////////&lt;br/&gt;// 从指定的classloader中查找类&lt;br/&gt;jclass find_class_from_class_loader(JNIEnv* env, Symbol* name, jboolean init,&lt;br/&gt;                                    Handle loader, Handle protection_domain,&lt;br/&gt;                                    jboolean throwError, TRAPS) {&lt;br/&gt;&lt;br/&gt;  //==========================================&lt;br/&gt;  //&lt;br/&gt;  // 根据指定的类名和加载器返回一个Klass对象，必要情况下需要加载该类。&lt;br/&gt;  // 如果未找到该类则抛出NoClassDefFoundError或ClassNotFoundException&lt;br/&gt;  //&lt;br/&gt;  //=========================================&lt;br/&gt;  Klass* klass = SystemDictionary::resolve_or_fail(name, loader, protection_domain, throwError != 0, CHECK_NULL);&lt;br/&gt;&lt;br/&gt;  // Check if we should initialize the class&lt;br/&gt;  if (init &amp;amp;&amp;amp; klass-&amp;gt;is_instance_klass()) {&lt;br/&gt;    klass-&amp;gt;initialize(CHECK_NULL);&lt;br/&gt;  }&lt;br/&gt;  return (jclass) JNIHandles::make_local(env, klass-&amp;gt;java_mirror());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;resolve_or_fail&lt;/code&gt;位于&lt;code&gt;src/hotspot/share/classfile/systemDictionary.cpp&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// Forwards to resolve_or_null&lt;br/&gt;&lt;br/&gt;Klass* SystemDictionary::resolve_or_fail(Symbol* class_name, Handle class_loader, Handle protection_domain, bool throw_error, TRAPS) {&lt;br/&gt;  Klass* klass = resolve_or_null(class_name, class_loader, protection_domain, THREAD);&lt;br/&gt;  if (HAS_PENDING_EXCEPTION || klass == NULL) {&lt;br/&gt;    // can return a null klass&lt;br/&gt;    klass = handle_resolution_exception(class_name, throw_error, klass, THREAD);&lt;br/&gt;  }&lt;br/&gt;  return klass;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;resolve_or_null&lt;/code&gt;也位于&lt;code&gt;src/hotspot/share/classfile/systemDictionary.cpp&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// Forwards to resolve_instance_class_or_null&lt;br/&gt;&lt;br/&gt;Klass* SystemDictionary::resolve_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS) {&lt;br/&gt;&lt;br/&gt;  if (FieldType::is_array(class_name)) {&lt;br/&gt;    return resolve_array_class_or_null(class_name, class_loader, protection_domain, THREAD);&lt;br/&gt;  } else if (FieldType::is_obj(class_name)) {&lt;br/&gt;    ResourceMark rm(THREAD);&lt;br/&gt;    // Ignore wrapping L and ;.&lt;br/&gt;    TempNewSymbol name = SymbolTable::new_symbol(class_name-&amp;gt;as_C_string() + 1,&lt;br/&gt;                                   class_name-&amp;gt;utf8_length() - 2, CHECK_NULL);&lt;br/&gt;    return resolve_instance_class_or_null(name, class_loader, protection_domain, THREAD);&lt;br/&gt;  } else {&lt;br/&gt;    // 解析实例类&lt;br/&gt;    return resolve_instance_class_or_null(class_name, class_loader, protection_domain, THREAD);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;resolve_instance_class_or_null&lt;/code&gt;也位于&lt;code&gt;src/hotspot/share/classfile/systemDictionary.cpp&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Klass* SystemDictionary::resolve_instance_class_or_null(Symbol* name,&lt;br/&gt;                                                        Handle class_loader,&lt;br/&gt;                                                        Handle protection_domain,&lt;br/&gt;                                                        TRAPS) {&lt;br/&gt;  Handle lockObject = compute_loader_lock_object(class_loader, THREAD);&lt;br/&gt;  check_loader_lock_contention(lockObject, THREAD);&lt;br/&gt;  // 获取对象锁&lt;br/&gt;  ObjectLocker ol(lockObject, THREAD, DoObjectLock);&lt;br/&gt;&lt;br/&gt;  {&lt;br/&gt;    MutexLocker mu(SystemDictionary_lock, THREAD);&lt;br/&gt;    // 查找类&lt;br/&gt;    InstanceKlass* check = find_class(d_index, d_hash, name, dictionary);&lt;br/&gt;    if (check != NULL) {&lt;br/&gt;      // Klass is already loaded, so just return it&lt;br/&gt;      class_has_been_loaded = true;&lt;br/&gt;      k = check;&lt;br/&gt;    } else {&lt;br/&gt;      // 查找该类是否在placeholder table中&lt;br/&gt;      placeholder = placeholders()-&amp;gt;get_entry(p_index, p_hash, name, loader_data);&lt;br/&gt;      if (placeholder &amp;amp;&amp;amp; placeholder-&amp;gt;super_load_in_progress()) {&lt;br/&gt;         super_load_in_progress = true;&lt;br/&gt;         if (placeholder-&amp;gt;havesupername() == true) {&lt;br/&gt;           superclassname = placeholder-&amp;gt;supername();&lt;br/&gt;           havesupername = true;&lt;br/&gt;         }&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  // 如果该类在placeholder table中，则说明类加载进行中&lt;br/&gt;  if (super_load_in_progress &amp;amp;&amp;amp; havesupername==true) {&lt;br/&gt;    k = handle_parallel_super_load(name,&lt;br/&gt;                                   superclassname,&lt;br/&gt;                                   class_loader,&lt;br/&gt;                                   protection_domain,&lt;br/&gt;                                   lockObject, THREAD);&lt;br/&gt;    if (HAS_PENDING_EXCEPTION) {&lt;br/&gt;      return NULL;&lt;br/&gt;    }&lt;br/&gt;    if (k != NULL) {&lt;br/&gt;      class_has_been_loaded = true;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  bool throw_circularity_error = false;&lt;br/&gt;  if (!class_has_been_loaded) {&lt;br/&gt;    bool load_instance_added = false;&lt;br/&gt;&lt;br/&gt;    if (!class_has_been_loaded) {&lt;br/&gt;&lt;br/&gt;      // =====================================&lt;br/&gt;      //&lt;br/&gt;      //      执行实例加载动作&lt;br/&gt;      //&lt;br/&gt;      // =====================================&lt;br/&gt;      k = load_instance_class(name, class_loader, THREAD);&lt;br/&gt;&lt;br/&gt;      if (!HAS_PENDING_EXCEPTION &amp;amp;&amp;amp; k != NULL &amp;amp;&amp;amp;&lt;br/&gt;        k-&amp;gt;class_loader() != class_loader()) {&lt;br/&gt;&lt;br/&gt;        check_constraints(d_index, d_hash, k, class_loader, false, THREAD);&lt;br/&gt;&lt;br/&gt;        // Need to check for a PENDING_EXCEPTION again; check_constraints&lt;br/&gt;        // can throw and doesn&#x27;t use the CHECK macro.&lt;br/&gt;        if (!HAS_PENDING_EXCEPTION) {&lt;br/&gt;          { // Grabbing the Compile_lock prevents systemDictionary updates&lt;br/&gt;            // during compilations.&lt;br/&gt;            MutexLocker mu(Compile_lock, THREAD);&lt;br/&gt;            update_dictionary(d_index, d_hash, p_index, p_hash,&lt;br/&gt;              k, class_loader, THREAD);&lt;br/&gt;          }&lt;br/&gt;&lt;br/&gt;          // 通知JVMTI类加载事件&lt;br/&gt;          if (JvmtiExport::should_post_class_load()) {&lt;br/&gt;            Thread *thread = THREAD;&lt;br/&gt;            assert(thread-&amp;gt;is_Java_thread(), &quot;thread-&amp;gt;is_Java_thread()&quot;);&lt;br/&gt;            JvmtiExport::post_class_load((JavaThread *) thread, k);&lt;br/&gt;          }&lt;br/&gt;        }&lt;br/&gt;      }&lt;br/&gt;    } // load_instance_class&lt;br/&gt;  }&lt;br/&gt;  ...&lt;br/&gt;&lt;br/&gt;  return k;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;load_instance_class&lt;/code&gt;也位于&lt;code&gt;src/hotspot/share/classfile/systemDictionary.cpp&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// ===================================================================================&lt;br/&gt;//&lt;br/&gt;//              加载实例class，这里有两种方式：&lt;br/&gt;// ===================================================================================&lt;br/&gt;//&lt;br/&gt;// 1、如果classloader为null则说明是加载系统类，使用bootstrap loader&lt;br/&gt;//    调用方式：直接调用ClassLoader::load_class()加载该类&lt;br/&gt;//&lt;br/&gt;// 2、如果classloader不为null则说明是非系统类，使用ext/app/自定义 classloader&lt;br/&gt;//    调用方式：通过JavaCalls::call_virtual()调用Java方法ClassLoader.loadClass()加载该类&lt;br/&gt;//&lt;br/&gt;// ===================================================================================&lt;br/&gt;InstanceKlass* SystemDictionary::load_instance_class(Symbol* class_name, Handle class_loader, TRAPS) {&lt;br/&gt;&lt;br/&gt;  // 使用bootstrap加载器加载&lt;br/&gt;  if (class_loader.is_null()) {&lt;br/&gt;&lt;br/&gt;    // 根据全限定名获取包名&lt;br/&gt;    // Find the package in the boot loader&#x27;s package entry table.&lt;br/&gt;    TempNewSymbol pkg_name = InstanceKlass::package_from_name(class_name, CHECK_NULL);&lt;br/&gt;    if (pkg_name != NULL) {&lt;br/&gt;      pkg_entry = loader_data-&amp;gt;packages()-&amp;gt;lookup_only(pkg_name);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    InstanceKlass* k = NULL;&lt;br/&gt;&lt;br/&gt;    if (k == NULL) {&lt;br/&gt;      // Use VM class loader&lt;br/&gt;      PerfTraceTime vmtimer(ClassLoader::perf_sys_classload_time());&lt;br/&gt;      // =================================================================&lt;br/&gt;      //&lt;br/&gt;      //        使用bootstrap loader加载该类&lt;br/&gt;      //&lt;br/&gt;      // =================================================================&lt;br/&gt;      k = ClassLoader::load_class(class_name, search_only_bootloader_append, CHECK_NULL);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    return k;&lt;br/&gt;  } else {&lt;br/&gt;    // =======================================================================================&lt;br/&gt;    //&lt;br/&gt;    // 使用用户指定的加载器加载该类，调用class_loader的loadClass操作方法，&lt;br/&gt;    // 最终返回一个标准的InstanceKlass，流程如下&lt;br/&gt;    //&lt;br/&gt;    // +-----------+  loadClass()   +---------------+  get_jobject()   +-------------+&lt;br/&gt;    // | className | -------------&amp;gt; |   JavaValue   | ---------------&amp;gt; |     oop     |&lt;br/&gt;    // +-----------+                +---------------+                  +-------------+&lt;br/&gt;    //                                                                       |&lt;br/&gt;    //                                                                       | as_Klass()&lt;br/&gt;    //                                                                       v&lt;br/&gt;    //                               +---------------+  cast()          +-------------+&lt;br/&gt;    //                               | InstanceKlass | &amp;lt;--------------- |    Klass    |&lt;br/&gt;    //                               +---------------+                  +-------------+&lt;br/&gt;    //&lt;br/&gt;    // =======================================================================================  &lt;br/&gt;    ResourceMark rm(THREAD);&lt;br/&gt;&lt;br/&gt;    assert(THREAD-&amp;gt;is_Java_thread(), &quot;must be a JavaThread&quot;);&lt;br/&gt;    JavaThread* jt = (JavaThread*) THREAD;&lt;br/&gt;&lt;br/&gt;    PerfClassTraceTime vmtimer(ClassLoader::perf_app_classload_time(),&lt;br/&gt;                               ClassLoader::perf_app_classload_selftime(),&lt;br/&gt;                               ClassLoader::perf_app_classload_count(),&lt;br/&gt;                               jt-&amp;gt;get_thread_stat()-&amp;gt;perf_recursion_counts_addr(),&lt;br/&gt;                               jt-&amp;gt;get_thread_stat()-&amp;gt;perf_timers_addr(),&lt;br/&gt;                               PerfClassTraceTime::CLASS_LOAD);&lt;br/&gt;&lt;br/&gt;    Handle s = java_lang_String::create_from_symbol(class_name, CHECK_NULL);&lt;br/&gt;    // Translate to external class name format, i.e., convert &#x27;/&#x27; chars to &#x27;.&#x27;&lt;br/&gt;    Handle string = java_lang_String::externalize_classname(s, CHECK_NULL);&lt;br/&gt;&lt;br/&gt;    JavaValue result(T_OBJECT);&lt;br/&gt;&lt;br/&gt;    InstanceKlass* spec_klass = SystemDictionary::ClassLoader_klass();&lt;br/&gt;&lt;br/&gt;    // Added MustCallLoadClassInternal in case we discover in the field&lt;br/&gt;    // a customer that counts on this call&lt;br/&gt;    if (MustCallLoadClassInternal &amp;amp;&amp;amp; has_loadClassInternal()) {&lt;br/&gt;      JavaCalls::call_special(&amp;amp;result,&lt;br/&gt;                              class_loader,&lt;br/&gt;                              spec_klass,&lt;br/&gt;                              vmSymbols::loadClassInternal_name(),&lt;br/&gt;                              vmSymbols::string_class_signature(),&lt;br/&gt;                              string,&lt;br/&gt;                              CHECK_NULL);&lt;br/&gt;    } else {&lt;br/&gt;      // ===============================================================&lt;br/&gt;      //&lt;br/&gt;      // 调用ClassLoader.loadClass()方法加载该类，而最终会调用ClassLoader的native方法defineClass1()&lt;br/&gt;      // 其实现位于ClassLoader.c # Java_java_lang_ClassLoader_defineClass1()&lt;br/&gt;      //&lt;br/&gt;      // ===============================================================&lt;br/&gt;      JavaCalls::call_virtual(&amp;amp;result,&lt;br/&gt;                              class_loader,&lt;br/&gt;                              spec_klass,&lt;br/&gt;                              vmSymbols::loadClass_name(),&lt;br/&gt;                              vmSymbols::string_class_signature(),&lt;br/&gt;                              string,&lt;br/&gt;                              CHECK_NULL);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    assert(result.get_type() == T_OBJECT, &quot;just checking&quot;);&lt;br/&gt;    // 获取oop对象&lt;br/&gt;    oop obj = (oop) result.get_jobject();&lt;br/&gt;&lt;br/&gt;    // 如果不是基本类，则转换成对应的InstanceKlass&lt;br/&gt;    if ((obj != NULL) &amp;amp;&amp;amp; !(java_lang_Class::is_primitive(obj))) {&lt;br/&gt;      InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(obj));&lt;br/&gt;&lt;br/&gt;      if (class_name == k-&amp;gt;name()) {&lt;br/&gt;        // 返回最终InstanceKlass&lt;br/&gt;        return k;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;    // Class is not found or has the wrong name, return NULL&lt;br/&gt;    return NULL;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上便是相关的所有底层源码。&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;一个小小的&lt;code&gt;Class.forName&lt;/code&gt;方法，也会引出不少问题，如果仔细研究，在排查的过程，相信你一定会有所收获。&lt;/p&gt;&lt;p&gt;有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。https://death00.github.io/公众号：健程之道&lt;img data-ratio=&quot;0.5555555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BzwEAR61IMeZNWYI6OtqTxEeetJ8ibVVhibZkzVHp8ns2qThE8J2rOmRtWxxd7NvSnLL1z0japxibFu1IF1aUyiaMQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;img data-ratio=&quot;0.5555555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BzwEAR61IMeZNWYI6OtqTxEeetJ8ibVVhPUGhQOtmG3ZZIuia5Ys9tBUCM8ZDy2sbQXTwXWNsqtiadnylkNpQGrBA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>783f5b2e9f66fdac3cfc39eed145ec5e</guid>
<title>写给开发人员的实用密码学：Hash 算法</title>
<link>https://toutiao.io/k/bh8iej1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说到Hash（哈希），开发人员应该不陌生，比如Hash表是一种非常常用的数据结构，通过Hash表能够根据键值快速找到数据。哈希函数将文本（或其他数据）映射为整数，从而能够提高检索效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;密码学中的Hash算法和普通的Hash算法不是同一个概念，从安全的角度考虑，密码学中的Hash算法除了有普通Hash算法的特性之外，还有其他的一些特性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;密码学Hash算法也通常称作摘要算法，是密码学中的基础算法，是现代密码学中的核心组成部分。2004年山东大学王小云教授发表论文，指出了MD5和SHA-1两种Hash算法的漏洞，引起了业界的恐慌，足以说明Hash算法的重要性。密码学中有很多密码学Hash算法，比如MD5、SHA-1、SHA128、SHA256、SHA512等，国家商用密码中也有一个Hash算法SM3。我们不用理解Hash算法的内部实现原理，更应该关注其特性、用途以及使用中需要注意的点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在密码学中，Hash函数将任意大小（例如文本消息）的输入数据转换为固定大小（例如256位）的结果，这称为哈希值（或哈希码、消息摘要）。比如SHA-256和SHA3-256，可将任意输入转换为256位输出。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.425&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibQ4mtgHYXv5kyd7rsQspbfouGG0rqNoqticia9NHQwicWSgKnyicu63oicwibqibK8OM8swcSuSx7LhcMBW7WKVHe9qIA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;哈希算法&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;密码学Hash算法示例&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以借助 OpenSSL 附带的命令行工具计算字符串&quot;hello&quot;的SHA256算法哈希值：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ echo -n &quot;hello&quot; | openssl sha256&lt;br/&gt;(stdin)= 2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也可以借助开源国密算法库 GmSSL 的命令行工具，计算 SM3 算法的哈希值：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ echo -n &quot;hello&quot; | gmssl dgst -sm3&lt;br/&gt;(stdin)= becbbfaae6548b8bf0cfcad5a27183cd1be6093b1cceccc303d9c61d0a645268&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;密码学Hash算法的特点&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设计一个Hash算法并不难，但要设计一个能用于密码学上的Hash算法非常难，需要有非常深厚的数学和密码学功底。一个设计良好的密码学Hash算法需要具有如下特点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;确定性：相同的消息总是能得到同样的摘要值，特定的Hash算法，不管消息长度是多少，最终的摘要值长度是相同的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;快速：计算任何给定消息的哈希值应该很快。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;难以分析：对输入消息的微小修改将完全改变输出哈希值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不可逆：通过摘要值很难逆向计算出原始消息，Hash算法具备单向性，摘要值是不可逆的，这也是非常重要的特性。为了逆向计算出原始消息，唯一的方法就是采用暴力攻击、字典攻击、彩虹表&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;没有碰撞：找到两个具有相同哈希值的不同消息非常困难（或几乎不可能）。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意第5点，没有冲突是一种理想情况，考虑到最后生成的摘要值只有固定的有限位，必然存在不同消息具有相同哈希值的情况，但这里强调的是找到它们非常困难。后面谈到 MD5 的破解将会谈到。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;密码学Hash算法的用途&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;密码学哈希算法用途很广，下面看看最常见的几个用途：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;验证文件/文档/消息的完整性。比如我们在网站下载文件时，网站通常会给出文件的 MD5 值或 SHA256 值。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3099352051835853&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibQ4mtgHYXv5kyd7rsQspbfouGG0rqNoq5hgbEB1lFwHib80eNFfzYQauWjS17jNsbtdb7BKlw2YHBVecN2OsbTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;926&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;OpenSSL源码Hash值&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过对比哈希值，我们可以确保自己下载的文件和服务器上是一致的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个开发人员应该很熟悉，当然也有菜鸟程序员直接往数据库中存储明文密码（从曝光的拖库攻击事件中，发现这么做的公司还不少）。开发人员通常不将纯文本密码保存在数据库中，而保存密码散列值或从密码派生的更复杂的值（例如，Scrypt派生的值）。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4290322580645161&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibQ4mtgHYXv5kyd7rsQspbfouGG0rqNoq1uL2M00HHx8qndCpOSr66YDTsibW62BLyicpRuueoCgRCXibGb92yjErQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;620&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;/etc/shadow文件&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的示例来自现代 Linux 系统中的 /etc/shadow 文件，里面的密码存储为带盐的多轮SHA-512哈希值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;采用这种解决方案，即使数据库或数据文件泄露，攻击者也无法通过口令的摘要值计算出原始口令，攻击者很难伪造用户进行攻击。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;系统具体如何校验用户密码呢？大概的步骤如下：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;用户输入用户名和口令登录。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;系统使用Hash算法计算出口令的摘要值。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;系统使用用户名和摘要值在数据库表中进行检索，一旦匹配到就说明该用户输入的口令是正确的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生成特定文档/消息的（几乎）唯一ID。密码散列函数几乎根据文档的内容唯一地标识文档。当然从理论上讲，任何哈希函数都可能发生碰撞，但是这种碰撞不太可能发生，因此大多数系统（如Git）都假定它们使用的哈希函数不存在碰撞。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样的示例有 git 版本管理系统，其每一个提交通过一个哈希值标记。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5897435897435898&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibQ4mtgHYXv5kyd7rsQspbfouGG0rqNoqBK019fI9hcHrdzJRk94tMW4AkePTAHg7ZCWicKCPkJQ1pZfVB7zEMsQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;975&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;git通过哈希值标记一个提交&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个特性还可以用来比较大文件，通过计算两个文件的Hash值，比较Hash值就可以判断两个文件是否相同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;伪随机数生成和密钥派生。生成随机序列的一种简单方法是这样的：从随机种子开始（例如键盘单击或鼠标移动）。附加“1”并计算散列以获得第一个随机数，然后附加“2”并计算散列获得第二个随机数，以此类推。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要用在比特币，也就是俗称的挖矿。大多数工作量证明算法计算的哈希值大于特定值（称为挖掘难度）。为了找到此哈希值，矿工计算了数十亿个不同的哈希，并采用其中的最大哈希值，因为哈希数是不可预测的。例如，工作证明问题的定义如下：找到一个数字p，以使hash（x + p）的开头保留10个零位。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Hash算法一览&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在过去，软件开发人员设计了许多密码哈希算法。其中有些已证明不安全（例如 MD5 和 SHA1 ），有些仍被认为是安全的（例如 SHA-2 、SHA-3 和 BLAKE2 ）。下面让我们了解一下目前广泛使用的加密哈希算法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MD5是一种比较常用的Hash算法，摘要值长度固定是 128 比特， MD5 算法目前被证明已经不安全了，不建议使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SHA-1算法类似于MD5算法，输出的长度固定是160比特。SHA-1算法在严谨的加密学中已经被证明是不安全的，但在实际中仍然有使用，因为在现实世界中要构造出碰撞还是非常困难的，需要经过大量的运算。当然在新的应用中要避免使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SHA-2是一系列强大的密码哈希函数：SHA-256（256位哈希）、SHA-384（384位哈希）、SHA-512（512位哈希）等。SHA-2算法是目前建议使用的Hash算法，在美国作为官方加密标准发布。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从设计上讲，哈希输出的位数越多，一般而言具有更高的安全性和更高的抗冲突性。通常，128位哈希函数要比256位哈希函数要弱，而256位哈希函数要比512位哈希函数弱。因此，SHA-512比SHA-256更强大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SHA-3算法并不是为了取代SHA-2算法，而是一种在设计上和SHA-2完全不同的算法，主要有四种算法，分别是SHA3-256、SHA3-512、SHA3-224、SHA3-384，输出的长度分别是256比特、512比特、224比特、384比特。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在相同的哈希长度下，SHA-3比SHA-2更安全。例如，SHA3-256比SHA-256提供更多的加密强度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SHA-3被认为是高度安全的，在美国作为官方推荐的加密标准发布。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SM3是国密密码杂凑算法标准，由国家密码管理局于2010年12月公布。SM3的输出杂凑值长度为256比特(32字节)，与国际标准SHA-256等长。SM3设计安全性为128比特，安全性与256比特椭圆曲线/SM2、SM4/SMS4、AES-128等同。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;小知识：王小云院士真的破解了 MD5 吗？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2004年8月，在美国加州圣巴巴拉召开的国际密码大会上，王小云宣读了自己和研究团队对于MD4、MD5、HAVAL-128和RIPEMD四个国际著名密码算法的破译结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这被认为是2004年密码学界最具突破性的结果，堪称学术界的一场强烈地震。当年国际密码大会总结报告上写道：我们该怎么办？MD5被重创了，它即将从应用中淘汰。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2005年，美国《新科学家》杂志在一篇文章中，用了颇具震撼力的标题——《崩溃！密码学的危机》，报道了王小云团队花10年时间取得的学术成果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所谓的“破解”其实误导了很多人，并不是说扔给王小云一个 MD5 散列值，然后她马上就能算出一个原文来。从密文推算出明文理论上是不可能的，所以王小云的研究成果并不能通过 MD5 的散列值逆向推算出明文。即给定 Hash 值，王小云不能逆向计算出 M。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;MD5(M)=Hash&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中 M 指密码的明文，Hash 表示密码散列后的密文。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上，王小云的研究成果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;MD5(M1)=MD5(M2)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即给定消息 M1，能够计算获取 M2，使得 M2 产生的散列值与 M1 产生的散列值相同。如此，MD5 的抗碰撞性就已经不满足了，使得 MD5 不再是安全的散列算法。这样一来，MD5 用于数字签名将存在严重问题，因为可以篡改原始消息，而生成相同的 Hash 值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里，简单地用王教授的碰撞法给大家举个简单的例子。假如用户 A 给 B 写了个 Email 内容为 Hello，然后通过王教授的碰撞法，可能得到 Fuck 这个字符串的摘要信息和 Hello 这个字符串产生的摘要信息是一样的。如果 B 收到的 Email 内容为 Fuck，经过 MD5 计算后的，B 也将认为 Email 并没有被修改！但事实并非如此。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;王小云院士的研究报告表明，MD4，MD5，HAVAL-128，RIPEMD 和 SHA-1 均已被证实存在上面的漏洞，即给定消息 M1，能够找到不同消息 M2 产生相同的散列值，即产生 Hash 碰撞。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibQ4mtgHYXv50C2zJtfH5icNbOicm63Mwia4EaZdIJtQDz9rJLxS6LBsVgWJXtbJIFBaAH2nzu7tBEic76fFUEphPjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>