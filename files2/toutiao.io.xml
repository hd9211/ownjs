<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>1d4d4b44df832196f22d59defa74c8f3</guid>
<title>求抱抱，小王被这 10 道 Java 面试题虐哭了</title>
<link>https://toutiao.io/k/jnjaul9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一天，小王告诉我，他去一家公司面试 Java 岗，结果被面试官虐哭了。整整 10 道 Java 面试题，小王一道也没答正确。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;他沮丧地给我说，“哥，说点我的情况，你愿意听吗？我和一个女孩相处，女孩大我两岁，我非科班。本来打算国庆换一家薪水高点的，好确认关系。我经验不多，技术一般般，之前在一家外包公司，有一个甲方内推，我就鲁莽地把外包的工作辞了，结果没想到面试被虐了，我担心女朋友会不会因为我没有工作和我分手。”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;听他这么一说，确实挺虐心的。后来我就安慰他，要他端正心态，先把这些面试题整明白，然后继续找工作，不要想太多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;借这个机会，我就把小王遇到的这 10 道面试题分享出来，希望能对其他小伙伴一些帮助。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第一题，下面这串代码打印的结果是什么&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(Math.min(Double.MIN_VALUE, &lt;span&gt;0.0&lt;/span&gt;d));&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小王之所以没答对这道题，是因为他觉得 Double.MIN_VALUE 和 Integer.MIN_VALUE 一样，是个负数，应该小于 0.0d。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但事实上，Double. MIN_VALUE 和 Double. MAX_VALUE 一样，都是正数，Double. MIN_VALUE 的值是 &lt;code&gt;2^(-1074)&lt;/code&gt;，直接打印 Double. MIN_VALUE 的话，输出结果为 &lt;code&gt;4.9E-324&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此这道题的正确答案是输出 &lt;code&gt;0.0&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第二题，在 try 块或者 catch 语句中执行 return 语句或者 &lt;code&gt;System.exit()&lt;/code&gt; 会发生什么，finally 语句还会执行吗？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小王之所以没答对这道题，是因为在他的刻板印象中，finally 语句是无论如何都会执行的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但事实上，在 try 块或者 catch 语句中执行 return 语句时，finally 语句会执行；在 try 块或者 catch 语句中执行 &lt;code&gt;System.exit()&lt;/code&gt; 时，finally 语句不会执行。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test1&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        returnTryExec();&lt;br/&gt;        returnCatchExec();&lt;br/&gt;        exitTryExec();&lt;br/&gt;        exitCatchExec();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;returnTryExec&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;finally returnTryExec&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;returnCatchExec&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; { } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;finally returnCatchExec&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;exitTryExec&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            System.exit(&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;finally exitTryExec&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;exitCatchExec&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; { } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;            System.exit(&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;finally exitCatchExec&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序执行结果如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;finally returnTryExec&lt;br/&gt;finally returnCatchExec&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第三题，私有方法或者静态方法能被重写（override）吗？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小王之所以没答对这道题，是因为他不确定私有方法或者静态方法与重写之间的关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重写的两个方法名相同，方法参数的个数也相同；不过一个方法在父类中，另外一个在子类中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LaoWang&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;老王写了一本《基督山伯爵》&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;XiaoWang&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;LaoWang&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;小王写了一本《茶花女》&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;OverridingTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        LaoWang wang = &lt;span&gt;new&lt;/span&gt; XiaoWang();&lt;br/&gt;        wang.write();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;父类 LaoWang 有一个 &lt;code&gt;write()&lt;/code&gt; 方法（无参），方法体是写一本《基督山伯爵》；子类 XiaoWang 重写了父类的 &lt;code&gt;write()&lt;/code&gt; 方法（无参），但方法体是写一本《茶花女》。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 main 方法中，我们声明了一个类型为 LaoWang 的变量 wang。在编译期间，编译器会检查 LaoWang 类是否包含了 &lt;code&gt;write()&lt;/code&gt; 方法，发现 LaoWang 类有，于是编译通过。在运行期间，new 了一个 XiaoWang 对象，并将其赋值给 wang，此时 Java 虚拟机知道 wang 引用的是 XiaoWang 对象，所以调用的是子类 XiaoWang 中的 &lt;code&gt;write()&lt;/code&gt; 方法而不是父类 LaoWang  中的 &lt;code&gt;write()&lt;/code&gt; 方法，因此输出结果为“小王写了一本《茶花女》”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而私有方法对子类是不可见的，它仅在当前声明的类中可见，private 关键字满足了封装的最高级别要求。另外，Java 中的私有方法是通过编译期的静态绑定的方式绑定的，不依赖于特定引用变量所持有的对象类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法重写适用于动态绑定，因此私有方法无法被重写。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LaoWang&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;LaoWang&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        write();&lt;br/&gt;        read();&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;老王写了一本《基督山伯爵》&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;read&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;老王在读《哈姆雷特》&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;XiaoWang&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;LaoWang&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;小王写了一本《茶花女》&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;read&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;小王在读《威尼斯商人》&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PrivateOrrideTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        LaoWang wang = &lt;span&gt;new&lt;/span&gt; XiaoWang();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序输出结果如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;小王写了一本《茶花女》&lt;br/&gt;老王在读《哈姆雷特》&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在父类的构造方法中，分别调用了 &lt;code&gt;write()&lt;/code&gt; 和 &lt;code&gt;read()&lt;/code&gt; 方法，&lt;code&gt;write()&lt;/code&gt;方法是 public 的，可以被重写，因此执行了子类的 &lt;code&gt;write()&lt;/code&gt; 方法，&lt;code&gt;read()&lt;/code&gt; 方法是私有的，无法被重写，因此执行的仍然是父类的 &lt;code&gt;read()&lt;/code&gt; 方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和私有方法类似，静态方法在编译期也是通过静态绑定的方式绑定的，不依赖于特定引用变量所持有的对象类型。方法重写适用于动态绑定，因此静态方法无法被重写。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;StaticOrrideTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Laozi zi = &lt;span&gt;new&lt;/span&gt; Xiaozi();&lt;br/&gt;        zi.write();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Laozi&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;老子写了一本《基督山伯爵》&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Xiaozi&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Laozi&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;小子写了一本《茶花女》&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序输出结果如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;老子写了一本《基督山伯爵》&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引用变量 zi 的类型为 Laozi，所以 &lt;code&gt;zi.write()&lt;/code&gt; 执行的是父类中的 &lt;code&gt;write()&lt;/code&gt; 方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;静态方法也叫类方法，直接通过类名就可以调用，通过对象调用的时候，IDE 会发出警告。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.21129032258064517&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHplr7ZibLgLzL5cP90VDbAx0vjaQrDk8rK6mIlHibUKfIo2ahrauLT88w9ncxN74MfVEq6QWYmOdLyQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第四题，&lt;code&gt;1.0/0.0&lt;/code&gt; 得到的结果是什么？会抛出异常吗，还是会出现编译错误？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小王之所以没答对这道题，是因为他没有深入研究过 double 类型和 int 类型的除法运算。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数字在 Java 中可以分为两种，一种是整形，一种是浮点型。不太清楚的小伙伴先去研究一下&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIxNzQwNjM3NA==&amp;amp;mid=2247489521&amp;amp;idx=2&amp;amp;sn=869f20ba8b26b523b5b0d7d10f3ef87a&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;数据类型&lt;/a&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当浮点数除以 0 的时候，结果为 Infinity 或者 NaN。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;System.out.println(1.0 / 0.0); // Infinity&lt;br/&gt;System.out.println(0.0 / 0.0); // NaN&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Infinity 的中文意思是无穷大，NaN 的中文意思是这不是一个数字（Not a Number）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当整数除以 0 的时候（&lt;code&gt;10 / 0&lt;/code&gt;），会抛出异常：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Exception &lt;span&gt;in&lt;/span&gt; thread &lt;span&gt;&quot;main&quot;&lt;/span&gt; java.lang.ArithmeticException: / by zero&lt;br/&gt; at com.itwanger.eleven.ArithmeticOperator.main(ArithmeticOperator.java:32)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常，我们在进行整数的除法运算时，需要先判断除数是否为 0，以免程序抛出异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第五题，Java 支持多重继承吗？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小王之所以没答对这道题，是因为他知道，通过接口可以达到多重继承的目的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来定义两个接口，Fly 会飞，Run 会跑。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public interface Fly {&lt;br/&gt;    void fly();&lt;br/&gt;}&lt;br/&gt;public interface Run {&lt;br/&gt;    void run();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后让一个类同时实现这两个接口。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Pig&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Fly&lt;/span&gt;,&lt;span&gt;Run&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;fly&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;会飞的猪&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;会跑的猪&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但说到多重继承，讨论的关键字是 extends，而非 implements。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 只支持单一继承，是因为涉及到菱形问题。如果有两个类共同继承一个有特定方法的父类，那么该方法可能会被两个子类重写。然后，如果你决定同时继承这两个子类，那么在你调用该重写方法时，编译器不能识别你要调用哪个子类的方法。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7518939393939394&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHplr7ZibLgLzL5cP90VDbAx0vpLyyBPgeyaDBb4ic38y0Nt62WnH5lCqgojdcbfyUlg2wgToialPRnCibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1056&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类 C 同时继承了类 A 和类 B，类 C 的对象在调用类 A 和类 B 中重写的方法时，就不知道该调用类 A 的方法，还是类 B 的方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第六题，当在 HashMap 中放入一个已经存在的 key 时，会发生什么？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小王之所以没答对这道题，是因为他没有深入研究过 HashMap 的工作原理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Hash，一般译作“散列”，也有直接音译为“哈希”的，这玩意什么意思呢？就是把任意长度的数据通过一种算法映射到固定长度的域上（散列值）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再直观一点，就是对一串数据 wang 进行杂糅，输出另外一段固定长度的数据 er——作为数据 wang 的特征。我们通常用一串指纹来映射某一个人，别小瞧手指头那么大点的指纹，在你所处的范围内很难找出第二个和你相同的（人的散列算法也好厉害，有没有）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于任意两个不同的数据块，其散列值相同的可能性极小，也就是说，对于一个给定的数据块，找到和它散列值相同的数据块极为困难。再者，对于一个数据块，哪怕只改动它的一个比特位，其散列值的改动也会非常的大——这正是 Hash 存在的价值！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家应该知道，HashMap 的底层数据结构是一个数组，通过 &lt;code&gt;hash()&lt;/code&gt; 方法来确定下标。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;hash&lt;/span&gt;&lt;span&gt;(Object key)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; h;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt;) ? &lt;span&gt;0&lt;/span&gt; : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; &lt;span&gt;16&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们放入一个键值对的时候，会先调用 &lt;code&gt;hash()&lt;/code&gt; 方法对 key 进行哈希算法，如果 key 是相同的，那么哈希后的结果也是相同的，意味着数组中的下标是相同的，新放入的值就会覆盖原来的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第七题，下面这段代码将会打印出什么？&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;char&lt;/span&gt;[] chars = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;[]{&lt;span&gt;&#x27;\u0097&#x27;&lt;/span&gt;};&lt;br/&gt;        String str = &lt;span&gt;new&lt;/span&gt; String(chars);&lt;br/&gt;        &lt;span&gt;byte&lt;/span&gt;[] bytes = str.getBytes();&lt;br/&gt;        System.out.println(Arrays.toString(bytes));&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小王之所以没答对这道题，是因为他没有深入研究过字符编码方面的一些知识。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这段程序中，我们通过一个字符数组创建了一个字符串对象，然后调用 String 类的 &lt;code&gt;getByte()&lt;/code&gt; 方法得到字节数组并将其打印到控制台。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这道面试题考察的核心并不是最终的打印结果（结果是不确定的），而是字符编码。通常情况下，我们在调用 &lt;code&gt;getBytes()&lt;/code&gt; 方法时，要指定编码，比如说 &lt;code&gt;str.getBytes(StandardCharsets.UTF_8)&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们没有指定编码的时候，JDK 会调用平台默认的字符编码，而不同的操作系统，编码不尽相同的，bytes 的结果也就会不同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当使用 UTF_8 时，结果为 &lt;code&gt;-62, -105&lt;/code&gt;，当使用 GB2312 时，结果为 &lt;code&gt;63&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第八题，当方法在父类中抛出 &lt;code&gt;NullPointerException&lt;/code&gt; 时，是否可以使用抛出 &lt;code&gt;RuntimeException&lt;/code&gt; 的方法来重写它？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小王之所以没答对这道题，是因为他被重写（overriding）和重载（overloading）的概念搞混了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法重写和方法重载时，方法名可以完全相同，但根本的不同在于方法重写时发生在运行时，方法重载时发生在编译时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，方法重写和方法重载时的规则也不尽相同。在 Java 中，不能重写 private、static 和 final 方法，但可以重载它们。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来重点看一下方法重写时的规则：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）方法签名必须相同，包括返回类型、参数的数量、参数的类型和参数的顺序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2）重写后的方法不能抛出比父类中更高级别的异常。举例来说，如果父类中的方法抛出的是 IOException，那么子类中重写的方法不能抛出 Exception，可以是 IOException 的子类或者不抛出任何异常。这条规则只适用于可检查的异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可检查（checked）异常必须在源代码中显式地进行捕获处理，不检查（unchecked）异常就是所谓的运行时异常，比如说 NullPointerException、ArrayIndexOutOfBoundsException 之类的，不会在编译器强制要求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3）重写后的方法访问权限不能比父类中的方法低，比如说父类中的方法是 public，重写后的方法就不能是 protected。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ExceptionDemo&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Super s = &lt;span&gt;new&lt;/span&gt; Child();&lt;br/&gt;        s.write();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Super&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; NullPointerException &lt;/span&gt;{ }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Child&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Super&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; RuntimeException &lt;/span&gt;{ }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RuntimeException 和 NullPointerException 属于不检查异常，所以本题的答案是可以的。如果是可检查异常的话，IDE 就会发出警告。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2725806451612903&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHplr7ZibLgLzL5cP90VDbAx0vqiaNGoCuwE2WOibPSf0f5aicWWzt3tgIFGWcRnEticCSPlGCEZlB9Vr9QQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第九题，下面这段代码使用了 &lt;code&gt;compareTo()&lt;/code&gt; 方法，有问题吗？&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Employee&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Comparable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; id;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;compareTo&lt;/span&gt;&lt;span&gt;(Object o)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Employee emp = (Employee) o;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.id - emp.id;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小王之所以没答对这道题，是因为他想当然地认为 id 的都是正整数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们需要按照一定的规则进行排序的时候，通常要实现 Comparable 接口，并实现 compareTo 方法，规则如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）如果当前对象小于另外一个对象，则 compareTo 方法必须返回负数；如果当前对象大于另外一个对象，则必须返回正数；如果两个对象相等，则返回零。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2）通常来说，compareTo 方法必须和 equals 方法一致，如果两个对象通过 equals 方法判断的结果为 true，那么 compareTo 必须返回零。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过，JDK 中有一个反例，就是 BigDecimal。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;BigDecimal bd1 = &lt;span&gt;new&lt;/span&gt; BigDecimal(&lt;span&gt;&quot;2.0&quot;&lt;/span&gt;);&lt;br/&gt;BigDecimal bd2 = &lt;span&gt;new&lt;/span&gt; BigDecimal(&lt;span&gt;&quot;2.00&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;System.out.println(&lt;span&gt;&quot;equals: &quot;&lt;/span&gt; + bd1.equals(bd2));&lt;br/&gt;System.out.println(&lt;span&gt;&quot;compareTo: &quot;&lt;/span&gt; + bd1.compareTo(bd2));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;equals: &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;compareTo: 0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是因为 JDK 认为 2.0 和 2.00 的精度不一样，所以不能 equals，但值确实是相等的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3）不能使用减法来比较整数值，因为减法的结果可能溢出。应该使用 &lt;code&gt;Integer.compareTo()&lt;/code&gt; 来进行比较。如果你想通过减法操作来提高性能，必须得确保两个操作数是正整数，或者确保两者相差的值小于 Integer.MAX_VALUE。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CompareDemo&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        List&amp;lt;Employee&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;        list.add(&lt;span&gt;new&lt;/span&gt; Employee(&lt;span&gt;1&lt;/span&gt;));&lt;br/&gt;        list.add(&lt;span&gt;new&lt;/span&gt; Employee(Integer.MIN_VALUE));&lt;br/&gt;        list.add(&lt;span&gt;new&lt;/span&gt; Employee(Integer.MAX_VALUE));&lt;br/&gt;        Collections.sort(list);&lt;br/&gt;        System.out.println(list);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Employee&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Comparable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; id;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Employee&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; id)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.id = id;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;compareTo&lt;/span&gt;&lt;span&gt;(Object o)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Employee emp = (Employee) o;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.id - emp.id;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;toString&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Employee{&quot;&lt;/span&gt; +&lt;br/&gt;                &lt;span&gt;&quot;id=&quot;&lt;/span&gt; + id +&lt;br/&gt;                &lt;span&gt;&#x27;}&#x27;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序的输出结果如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[Employee{id=1}, Employee{id=2147483647}, Employee{id=-2147483648}]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;排序就乱了。因为 &lt;code&gt;Integer.MIN_VALUE - 1&lt;/code&gt; 变成了正数 &lt;code&gt;2147483647&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第十题，StringBuffer 和 StringBuilder 之间有什么区别？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小王之所以没答对这道题，是因为他觉得这道题太简单了，结果说反了，大意了啊。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;StringBuilder 是 JDK 1.5 之后引入的，它和 StringBuffer 最大的区别就在于它的一系列方法都是非同步的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5018867924528302&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHplr7ZibLgLzL5cP90VDbAx0vZ4VQSwpWC08xoJfx4ibOH2Ap3e7Fbgicu7DtxX7jGWY2Aq7yGASwUBrg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1060&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，以上就是小王这次面试遇到的 10 道虐心的面试题，本来最后一道是送分题，结果大意说反了，让小王更加懊恼。年后是跳槽的高峰期，有打算的小伙伴要提前准备了，希望大家都能够顺利面上心仪的岗位。&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>04bc38bbea86d71b2d6e25bbcd995ba3</guid>
<title>白话科普系列：网站靠什么提升加载速度？</title>
<link>https://toutiao.io/k/h61rg9r</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot;&gt;&lt;p&gt;随着生活节奏的不断加快，时间变得极其宝贵，等待页面加载的时间也随之缩短。这样一来如何留住客户变成了一项重要的考验。而减少页面加载等待时间，加快加载速度，就成了提高用户参与度S，提升业务可靠性的有效策略。&lt;/p&gt;&lt;p&gt;根据 Google 的一项研究，有 40％ 的人放弃了某网站，是因为该网站的加载时间超过 3 秒，而页面加载时间增加1 秒，转化就相应减少了 7％。可见，互联网中的每一秒都至关重要。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-dc195edacbcb9f33d918ca2fe35f3d97_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;519&quot; data-rawheight=&quot;300&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-dc195edacbcb9f33d918ca2fe35f3d97_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;519&quot; data-rawheight=&quot;300&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-dc195edacbcb9f33d918ca2fe35f3d97_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-dc195edacbcb9f33d918ca2fe35f3d97_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;那么如何提升网站速度呢？可以通过网页“压缩”也就减少网页体积来实现。至于要如何才能压缩网站，我们需要先了解两个算法，&lt;b&gt;Gzip 和 Brotli 压缩算法。&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;                                         Gzip 压缩算法&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;Gzip 基于 DEFLATE 算法，它是 LZ77 和霍夫曼编码的组合，最早用于 UNIX 系统的文件压缩。HTTP 协议上的 Gzip 编码是一种用来改进 Web 应用程序性能的技术，它要求 Web 服务器和客户端（浏览器）必须共同支持 Gzip。而当下主流的浏览器，包括 IE6、IE7、IE8、IE9、FireFox、Google Chrome、Opera 等都已经开始支持 Gzip 压缩。可见 Gzip 的使用已经成为了互联网发展的必然趋势。&lt;/p&gt;&lt;p&gt;作为 Internet 上使用非常普遍的一种数据压缩格式，Gzip 对一般纯文本内容可压缩到原大小的 40％，这大大减少了网站文件中重复代码和空白的数量。它还可以提供 9 个压缩级别，可以方便使用者微调压缩量和压缩时间。&lt;/p&gt;&lt;p&gt;在用于提高 Web 应用程序的性能这一点上，Gzip 压缩一直是最受欢迎的。直到另一种压缩算法 Brotli 的出现，它成为了 Gzip 最大的竞争对手。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;                                         Brotli 压缩算法&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;Brotli 是 Google 在 2015 年 9 月推出的一种压缩算法，Google 认为互联网用户的时间是宝贵的，他们的时间不应该消耗在漫长的网页加载中，因此与其他压缩算法相比，Brotli 有着更高的压缩效率。它通过变种的 LZ77 算法、Huffman 编码以及二阶文本建模等方式进行数据压缩。&lt;/p&gt;&lt;p&gt;根据 Google 发布的研究报告，Brotli 压缩算法具有多个特点，最典型的是以下 3 个：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;针对常见的 Web 资源内容，Brotli 的性能相比 Gzip 提高了 17-25%；&lt;/li&gt;&lt;li&gt;当 Brotli 压缩级别为 1 时，压缩率比 Gzip 压缩等级为 9（最高）时还要高；&lt;/li&gt;&lt;li&gt;在处理不同 HTML 文档时，Brotli 依然能够提供非常高的压缩率&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;依靠着自身卓越的压缩性能，Brotli 自推出后就迅速开始占领压缩市场，从下图可以看到，除了 IE 和 Opera Mini 之外，几乎所有的主流浏览器都已支持 Brotli 算法。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e9ab7e95798faba589cc1f55e35034df_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1229&quot; data-rawheight=&quot;280&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-e9ab7e95798faba589cc1f55e35034df_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1229&quot; data-rawheight=&quot;280&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-e9ab7e95798faba589cc1f55e35034df_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-e9ab7e95798faba589cc1f55e35034df_b.jpg&quot;/&gt;&lt;figcaption&gt;△ Brotli 浏览器支持情况&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;在压缩效率上 Brotli 毫无疑问的遥遥领先。那么我们是否可以无脑盲选 Brotli 呢，Gzip 是不是应该就此退出市场？&lt;/p&gt;&lt;h2&gt;&lt;b&gt;                                    Brotli 比 Gzip 更好吗？&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;显然与 Gzip 相比，Brotli 压缩在研究中显示出了不俗的成果。，例如 Gzip 有 9 个压缩级别，而 Brotli 有 11 个。此外，Brotli 还使用一个预定义的 120 千字节字典，该字典包含超过 13000 个常用单词、短语和其他子字符串。这些因素都有效提高了 Brotli 的压缩率。根据 Certsimple 的研究，用 Brotli 压缩的 Javascript 文件比 Gzip 小 14％，HTML 文件比 Gzip 小 21％，CSS 文件比 Gzip 小 17％。&lt;/p&gt;&lt;p&gt;无论从哪方面看 Gzip 都已经被 Brotli 碾压，两者之间毫无对比的可能性，我们似乎也完全不需要考虑选择左边或者右边。&lt;/p&gt;&lt;table data-draft-node=&quot;block&quot; data-draft-type=&quot;table&quot; data-size=&quot;normal&quot; data-row-style=&quot;normal&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;注意：图像不应该被 Gzip 或 Brotli 压缩，因为它们已经被压缩，再次压缩将使其尺寸变大。&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;诚然 Brotli 在压缩程度上有着绝对的优势，但是这些优势是用其他代价换来的。Brotli 压缩操作所花费的时间会随着压缩级别的增加而增加。简而言之，就是 Brotli 需要更多的计算能力，而大家都知道计算能力需求的增加代表着设备和软件设施的成本上涨。另外 Brotli 要求浏览器必须支持与 HTTPS 一起使用，这也是他相比在浏览器支持量上比 Gzip 少的原因。毕竟 Gzip 同时支持 HTTP 和 HTTPS。&lt;/p&gt;&lt;p&gt;一边是压缩效果奇佳但是可能会因为浏览器的不支持而导致用户无法访问网站，另一边则是浏览器支持但是压缩效果降低用户加载网页时间依然略长，一个两难的抉择出现在了网站运营者面前。有机灵的小伙伴可能会说：“也不是所有用户都能使用 HTTPS，但是不是有功能判断么？难道压缩算法就不能整一个这种自动判断？让能使用 Brotli 的使用 Brotli，不能的使用 Gzip。”&lt;/p&gt;&lt;p&gt;bingo！华生，你发现了盲点。让我们愉快地掏出又拍云一站式减流量秘籍之智能压缩！&lt;/p&gt;&lt;h2&gt;&lt;b&gt;                                 又拍云秘籍——智能压缩&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;又拍云智能压缩功能旨在为网站减少了流量开支，减少资源加载时间，让终端用户的体验更上一层楼。它同时支持 Gzip 和 Brotli 压缩算法，可同时开启，也可开启其中一种。开启该功能，可对静态文件类型进行压缩，有效减少用户传输内容大小，加速分发效果。为了配置的灵活性，“智能压缩”功能支持压缩等级（1 到 5）的设置。两种压缩算法的压缩等级默认为 1，等级越高，压缩率越大。考虑到压缩等级越高，压缩速度会降低，实际生产环境，建议压缩等级控制在 3 以内，具体请以线上环境实测为准进行自主设置。&lt;/p&gt;&lt;p&gt;当用户在后台同时开启 Gzip 和 Brotli 压缩时，后台会自行判断浏览器是否支持 Brotli 来选择进行哪种压缩。&lt;/p&gt;&lt;p&gt;那么这个浏览器自行判断是怎么操作的呢？&lt;/p&gt;&lt;p&gt;其实支持 Brotli 的浏览器会在接受编码请求标头中发送“ br”和“ gzip”（例如：Accept-Encoding: gzip, deflate, br）。如果 Web 服务器上启用了 Brotli，则用户将获取到 Brotli 压缩格式的响应。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-f0620bb612b5c9deb73925d825277c45_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;667&quot; data-rawheight=&quot;381&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-f0620bb612b5c9deb73925d825277c45_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;667&quot; data-rawheight=&quot;381&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-f0620bb612b5c9deb73925d825277c45_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-f0620bb612b5c9deb73925d825277c45_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这样就能有效避免选择 A 还是选择 B 的烦恼，你可以两者都拥有，在提升用户浏览体验的同时降低你的 CDN 流量。&lt;/p&gt;&lt;p&gt;当然对于“如果浏览器同时支持 Gzip 和 Brotli 会不会出现两次压缩，或者选择错误”的问题，又拍云也考虑到了哦。当客户端同时支持 Gzip 和 Brotli 算法的情况下，Brotli 的优先级高于 Gzip。&lt;/p&gt;&lt;p&gt;这么方便的功能，只需要登陆 CDN 控制台，进入 「性能优化」配置页面，找到「智能压缩」配置项，点击【管理】按钮，进入如下配置界面：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b54a719a3ac378367c37ad71df0d3038_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1077&quot; data-rawheight=&quot;473&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-b54a719a3ac378367c37ad71df0d3038_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1077&quot; data-rawheight=&quot;473&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-b54a719a3ac378367c37ad71df0d3038_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-b54a719a3ac378367c37ad71df0d3038_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;配置好压缩等级就可以愉快使用了。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-202d053a7bcd5118c9ce91d3e3a7fa69_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;892&quot; data-rawheight=&quot;486&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-202d053a7bcd5118c9ce91d3e3a7fa69_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;892&quot; data-rawheight=&quot;486&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-202d053a7bcd5118c9ce91d3e3a7fa69_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-202d053a7bcd5118c9ce91d3e3a7fa69_b.jpg&quot;/&gt;&lt;figcaption&gt;△ 开启智能压缩前&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-305f9d635be7e11e48b8caea6a2c9688_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;888&quot; data-rawheight=&quot;485&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-305f9d635be7e11e48b8caea6a2c9688_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;888&quot; data-rawheight=&quot;485&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-305f9d635be7e11e48b8caea6a2c9688_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-305f9d635be7e11e48b8caea6a2c9688_b.jpg&quot;/&gt;&lt;figcaption&gt;△ 开启智能压缩后&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;除了智能压缩，又拍云还提供了一系列“省带宽，压成本”的绝招，包括 Webp 自适应、H.265 自适应、码率适配限速、窄带高清 等等，从编码技术、网络架构等角度出发，结合又拍云的产品成果，为大家节省流量，降低成本。有兴趣可以随时联系我们了解哦！&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h2&gt;推荐阅读：&lt;/h2&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.upyun.com/tech/article/590/%25E7%2599%25BD%25E8%25AF%259D%25E7%25A7%2591%25E6%2599%25AE%25E7%25B3%25BB%25E5%2588%2597%25E2%2580%2594%25E2%2580%2594Chrome%2520%25E6%25B5%258F%25E8%25A7%2588%25E5%2599%25A8%25EF%25BC%258C%25E4%25BD%25A0%25E7%2594%25A8%25E4%25BA%2586%25E4%25B9%2588%25EF%25BC%259F.html&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic4.zhimg.com/v2-0ce93b77d899e27bf9e9fece8a7086db_180x120.jpg&quot; data-image-width=&quot;1272&quot; data-image-height=&quot;718&quot; class=&quot;LinkCard LinkCard--hasImage&quot;&gt;&lt;span class=&quot;LinkCard-backdrop&quot;/&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;白话科普系列--Chrome 浏览器，你用了么？&lt;/span&gt;&lt;span class=&quot;LinkCard-meta&quot;&gt;&lt;span&gt;​&lt;svg class=&quot;Zi Zi--InsertLink&quot; fill=&quot;currentColor&quot; viewbox=&quot;0 0 24 24&quot;&gt;&lt;path d=&quot;M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;www.upyun.com&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-imageCell&quot;&gt;&lt;img class=&quot;LinkCard-image LinkCard-image--horizontal&quot; alt=&quot;图标&quot; src=&quot;https://pic4.zhimg.com/v2-0ce93b77d899e27bf9e9fece8a7086db_180x120.jpg&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.upyun.com/tech/article/588/%25E7%2599%25BD%25E8%25AF%259D%25E7%25A7%2591%25E6%2599%25AE%25EF%25BC%258C10s%2520%25E4%25BA%2586%25E8%25A7%25A3%2520API.html&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic3.zhimg.com/v2-e2a633e9f561dfa40182f0e6923268a6_180x120.jpg&quot; data-image-width=&quot;546&quot; data-image-height=&quot;346&quot; class=&quot;LinkCard LinkCard--hasImage&quot;&gt;&lt;span class=&quot;LinkCard-backdrop&quot;/&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;白话科普，10s 了解 API - 又拍云&lt;/span&gt;&lt;span class=&quot;LinkCard-meta&quot;&gt;&lt;span&gt;​&lt;svg class=&quot;Zi Zi--InsertLink&quot; fill=&quot;currentColor&quot; viewbox=&quot;0 0 24 24&quot;&gt;&lt;path d=&quot;M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;www.upyun.com&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-imageCell&quot;&gt;&lt;img class=&quot;LinkCard-image LinkCard-image--horizontal&quot; alt=&quot;图标&quot; src=&quot;https://pic3.zhimg.com/v2-e2a633e9f561dfa40182f0e6923268a6_180x120.jpg&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fb1bea933d337473ad3af416de6a2cee</guid>
<title>云游戏在革谁的命？</title>
<link>https://toutiao.io/k/160lo6y</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.628125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpHgfBRWw69LibJob3BMOPo2gfqJHVH4LzohaX3rr6l6zxpMMMq9ouzPaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;我上大学时的第一台电脑是微星的一款游戏本，当时买它的原因很简单，性能足够强大，无论是编程等日常任务还是游戏它都可以胜任。现在回想起来，依稀记得它炫酷的灯光、强悍的性能以及用它驰骋虚拟世界的快感。后来年纪渐长，打游戏的热情逐渐减少，虽然那台电脑仍在家中，但已经落后的性能让我鲜有机会“宠幸”它。再后来，读研之后换了 Mac 后更是没怎么碰过游戏了。&lt;/p&gt;&lt;p&gt;大家都说正经人谁用 Mac 打游戏，一开始我也是这么认为的，毕竟买来就是用来写代码的，可是最近发现的一个有趣玩意让我对这个问题有了新的想法，那就是——云游戏。&lt;/p&gt;&lt;h2&gt;云计算？云？&lt;/h2&gt;&lt;p&gt;以下内容摘自百度百科&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;云游戏是以&lt;strong&gt;云计算&lt;/strong&gt;为基础的游戏方式，在云游戏的运行模式下，所有游戏都在&lt;strong&gt;服务器端&lt;/strong&gt;运行，并将渲染完毕后的游戏画面&lt;strong&gt;压缩&lt;/strong&gt;后通过网络传送给用户。在客户端，用户的游戏设备&lt;strong&gt;不需要&lt;/strong&gt;任何高端处理器和显卡，只需要基本的&lt;strong&gt;视频解压能力&lt;/strong&gt;就可以了。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;我将上述内容中一些比较重要的点做了标注，百科在对于云游戏的描述时，第一句就直接阐明了云游戏的基础是云计算，那么「云计算」以及「云」指的是什么？&lt;/p&gt;&lt;p&gt;云计算（cloud computing），是一种基于互联网的计算方式，通过这种方式，&lt;strong&gt;共享的&lt;/strong&gt;软硬件资源和信息可以按需提供给计算机和其他设备。提供资源的网络被称为“云”。&lt;/p&gt;&lt;p&gt;看完上面一句话有些小伙伴还会不太清楚，我们先来回顾下之前的知识。我在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2ODAyNTgyMQ==&amp;amp;mid=2247484553&amp;amp;idx=1&amp;amp;sn=132a24db34dc55a11be68cbb738a5631&amp;amp;scene=21#wechat_redirect&quot; title=&quot;《互联网是如何工作的》&quot; data-linktype=&quot;2&quot;&gt;《互联网是如何工作的》&lt;/a&gt;这一篇文章中提到：一台又一台的服务器通过“网线”连接在了一起，形成了类似下面这样的结构 👇&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;161&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.5113941018766756&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpHQLthVgvia7dUianrTqqI0uQl6qxdtPibM7TKP189Qc2bExjoCxiakWFkNA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1492&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;众多服务器组成的这种结构被称为“互联网”，而其中每台服务器都被称作“节点”。&lt;/p&gt;&lt;p&gt;事实上这些节点都和你的本机无关但又和你的本机有关。&lt;/p&gt;&lt;p&gt;为什么这么说呢？&lt;/p&gt;&lt;p&gt;无关的原因是，这些节点所包含的计算能力（CPU、GPU）和存储文件都不是你的。有关的原因是，你可以通过某些方式运用这些能力和文件。&lt;/p&gt;&lt;p&gt;而上述所说的一个个节点便是云计算的核心，即「云」。&lt;/p&gt;&lt;p&gt;大量的水滴漂浮在空中，聚合成云。和我们所说的云很相似，只是这里的云是由&lt;strong&gt;大量的数据存储、计算资源和应用程序组成&lt;/strong&gt;，这便是云计算服务。&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;210&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpHSp9rauZrMSxicuDCuVNSic16w3TRRL7wc9oUc6xSONYQlibPhU7IQF5iaQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1620&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;「云」其实是一个抽象的概念，并不像服务器有一个具体的实物可以展示，我们可以把「云」理解为一个&lt;strong&gt;资源共享池&lt;/strong&gt;。举个例子就是，我有很多东西，家里放不下了，放到一个特定的地方存着，随时提取。大家都可以访问的就是「公有云」，只有特定的人可以访问的就是「私有云」。&lt;/p&gt;&lt;p&gt;这个“东西”一般是指&lt;strong&gt;数据、软件、服务&lt;/strong&gt;等，而“特定的地方”就是云。所以对于云计算我们也可以简单的理解为：将本地需要进行的计算任务迁移到云端进行。&lt;/p&gt;&lt;p&gt;如今云计算及其产物已经深入我们的生活，我们熟悉的百度网盘、iCloud 还有最近的阿里网盘就是「云存储」，以及本文要介绍的主角「云游戏」也是云计算的产物。&lt;/p&gt;&lt;h2&gt;云游戏&lt;/h2&gt;&lt;h3&gt;云游戏的原理&lt;/h3&gt;&lt;p&gt;在现在这个游戏变得越来越流行的时代，人们却仍然被低配设备所限制，比如我，虽然不差 298 买赛博朋克的钱，却苦于手头没有一台合适的机器用于玩耍。以往玩游戏我需要配一台游戏主机或者高性能游戏本，少说也要五六千，因为游戏对于计算机性能的要求是非常高的，这些都必须依赖玩家自己的电脑。&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;167&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.531496062992126&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpHz1nREHHT8oufyOhGx6uYWHJbKEKSonyQGKQicbo4iaIvIq0r1ltHZ7cg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2032&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;但是在云游戏模型中，所有的游戏逻辑和渲染都在&lt;strong&gt;服务器端&lt;/strong&gt;运行，然后再从服务器把压缩的画面传给用户，这样玩家就不需要一台高性能的计算机了，对于设备的要求便也就是&lt;strong&gt;基本的视频渲染能力&lt;/strong&gt;和&lt;strong&gt;可靠稳定的网络环境&lt;/strong&gt;了。&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;123&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.39105504587155965&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpH70wfGgT8DalLuugwaclC5UJib7iacUzF7cWYRWOOpe6icFcCc3QNt2apA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1744&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;云游戏摆脱了对硬件的依赖。对服务器来说，仅仅需要提高服务器性能而不需要研发新主机；对用户来说，可以得到更高的画质而不用购买高性能的计算机。也就是说，用户可以花一小笔钱租一个更好的计算机来玩各种游戏，就像用机顶盒看电视一样，这意味着玩家可以在计算机硬件，特别是 GPU 上省下一大笔钱。&lt;/p&gt;&lt;h3&gt;云游戏需要什么？&lt;/h3&gt;&lt;h3&gt;低延时&lt;/h3&gt;&lt;p&gt;在解释云游戏的原理时，我们提到了云游戏的游戏逻辑和渲染都是在服务器端进行，然后将画面传送给用户，所以说一台可以高速上网的设备极其重要。如果网速不够快，不够稳定就无法及时接收到高质量的画面。&lt;/p&gt;&lt;p&gt;说到这我们需要介绍一下网络延时，所谓网络延时指一个数据包从用户的计算机发送到网站服务器，然后再立即从网站服务器返回用户计算机的来回时间。通俗的讲，就是数据从电脑这边传到那边往返所用的时间。&lt;/p&gt;&lt;p&gt;以我们现在还在普遍使用的 4G 网络而言，它的延时基本在 30ms ～ 70ms 波动，部分信号不好的地方延时还会更大。这还只是数据传输时的网络延时，如果算上画面编解码的时间，延时达到 100ms 是很容易的事情。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.0033444816053512&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpHyfFnEl5tdhYI1bGkiaXh2nv1rXJdzvuFd5UGZuKKxbsGAuYtvnZctWg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;299&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;我们知道视频的原理就是每秒播放多张静态画面，画面越多，对于人的观感来说就是视频越流畅。这是因为对于人眼来说，我们的视觉神经是有一个反应速度的，并且对于不同频率的光有不同的暂留时间。其时值约是 1/16 秒，也就是 62.5ms。也就是说，如果网络传输所消耗的延时大于 62.5ms，我们就会觉得画面很不流畅（62.5 是一个理论值，实际情况下这个数值会小于 62.5ms，对延时的要求更苛刻）。&lt;/p&gt;&lt;h3&gt;高带宽&lt;/h3&gt;&lt;p&gt;现在我们来做一个简单的数学题。&lt;/p&gt;&lt;p&gt;刚才我们说到视频的原理是每秒播放多张静态图像。我们知道图像都是由一个个像素点构成的，对于一张非黑即白的二值图像，不压缩的情况下一个像素只需要 1 个 bit。如果是 256 种状态的灰度图像，不压缩的情况下一个像素需要 8bit（1 字节，256 种状态）。如果用 256 种状态标识屏幕上某种颜色的灰度，而屏幕采用三基色红绿蓝（RGB），不压缩的情况下一个像素需要占用 24bit（3 字节），这个就是常说的 24 位真彩色。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.83984375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpHo6zCIEFFdHRic1zntGibWtvamoaT01oac4Srl6g0JUTiah5L2OKjBwJlA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;512&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;那么对于一张 1920×1080 的图像，在不压缩的情况下，所需要的大小为 1920×1080×24 = 49766400bit，约等于 48Mb（注意这里是小写的 b，表示位），那么假设对于一个 1080P 30FPS 的视频，每秒就会播放 30 张 1920×1080 的图像，所以在不压缩的情况下如果为了传输这么多画面，网络的带宽必须要达到 48×30=1440Mb/s，当然在视频传输的过程中，肯定会有压缩的过程，假设可以压缩 50%的数据，那网络的带宽也需要 720Mb/s，看到这你想一下，你家的网络带宽又有多少呢？&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;这里之所以用 Mb 作为单位是因为方便大家和自己家的宽带进行比较，因为通常我们所说的百兆带宽指的是 100Mb 而不是 100MB。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;如何实现低延时+高带宽&lt;/h3&gt;&lt;p&gt;从开源节流的角度去考虑问题，如果网络传输的速度有上限，那么想要在单位时间内传输更多的视频数据，最好的方式便是对视频进行编解码。&lt;/p&gt;&lt;h3&gt;视频编解码&lt;/h3&gt;&lt;p&gt;编码这一概念在通信与信息处理领域中广泛使用，其基本原理是将信息按照一定规则使用某种形式的码流表示与传输。常用的需要编码的信息主要有：文字、语音、视频和控制信息等。&lt;/p&gt;&lt;p&gt;刚才说了动态图像的像素形式表示数据量极为巨大，存储空间和传输带宽完全无法满足保存和传输的需求。所以要对视频进行编码，其最主要的目的就是为了对视频数据进行压缩。&lt;/p&gt;&lt;p&gt;而视频信息之所以存在大量可以被压缩的空间，是因为其中本身就存在大量的数据冗余。&lt;/p&gt;&lt;p&gt;举个简单的例子，下面这两张图片是一段视频的其中两个画面（寒食君友情出镜）&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;176&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.5582761998041136&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpHbdFxG6jUuWfqGuW2rCicqI6pGZEGYfeicOrDAAwfrRxAaDHO9zxMWj5Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1021&quot; title=&quot;null&quot;/&gt;从这两张图片可以看出，其实变化的部分就是人物的动作，而不变的是后面的背景，所以后面的这块背景像素在对于视频来说就是一段冗余数据，可以被压缩。同样的，人物的脸部虽然有动作变化，但是人物的脸并没有变化，寒食君还是寒食君，因此不变的地方同样是冗余数据。&lt;/p&gt;&lt;p&gt;视频中的冗余数据的主要类型有：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;时间冗余：视频相邻的两帧之间内容相似，存在运动关系&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;空间冗余：视频的某一帧内部的相邻像素存在相似性&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;编码冗余：视频中不同数据出现的概率不同&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;视觉冗余：观众的视觉系统对视频中不同的部分敏感度不同&lt;/span&gt;&lt;/p&gt;&lt;p&gt;针对这些不同类型的冗余信息，在各种视频编码的标准算法中都有不同的技术专门应对，以通过不同的角度提高压缩的比率。这里我们简单说一下目前较为流行的两种编码 &lt;strong&gt;H.264 与 H.265&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;217&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.6902173913043478&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpH8aJVqgsNvUMkgVKB7unlu0QiaEI2Mppukg0fMQCvJo5DEyo5UeRGoEA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;736&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;这两个是 ITU-T VCEG 制定的视频编码标准。H.265 标准围绕着现有的视频编码标准 H.264，保留原来的某些技术，同时对一些相关的技术加以改进。新技术使用先进的技术用以改善码流、编码质量、延时和算法复杂度之间的关系，达到最优化设置。&lt;/p&gt;&lt;p&gt;具体的编码算法太过复杂，这里就不再多说，我们只要知道 H264 由于算法优化，可以低于 1Mbps 的速度实现标清数字图像传送；H265 则可以实现利用 1~2Mbps 的传输速度传送 720P（分辨率 1280*720）普通高清音视频传送。H.265 旨在在有限带宽下传输更高质量的网络视频，仅需 H.264 的一半带宽即可播放相同质量的视频。&lt;/p&gt;&lt;p&gt;经过测试，在相同的图像质量下，相比于 H.264，通过 H.265 编码的视频大小将减少大约 39-44%。在码率减少 51-74%的情况下，H.265 编码视频的质量还能与 H.264 编码视频近似甚至更好。&lt;/p&gt;&lt;h3&gt;5G 和 Wi-Fi6&lt;/h3&gt;&lt;p&gt;&lt;img data-backh=&quot;173&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.547699214365881&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpHXfxdXfeReh9S3ricZRFmQHFM6UErVjKdtRSQLeoI5LXC7owibwpWjwrA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1782&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;有了视频解码可以在单位时间内传输更多的数据后，剩下要做的便是提高传输速率。这便引出了今年非常火的两个名词——5G 和 Wi-Fi6。&lt;/p&gt;&lt;p&gt;就目前公开的数据来看，5G 协议中的峰值速度已经达到 20Gbit/s，Wi-Fi 6 最高也可以达到 9.6Gbit/s，这也就意味着在网络传输中可以携带的数据包更大。而且由于技术的提升，这两者在网络延时上也做了非常多的优化，在同等条件下 5G 的延迟低于 1 毫秒，相较于 4G 的 30-70 毫秒可谓是质的飞升。而 WI-FI6 的网络延时虽然不及 5G 这么优秀，但也从 Wi-Fi5 的平均 30ms 降低至 20ms。&lt;/p&gt;&lt;h3&gt;小结&lt;/h3&gt;&lt;p&gt;云游戏的概念其实早在 2013 年就已提出，但一直不温不火，目前来看，得益于越来越先进的压缩算法和低延时高带宽的网络环境，云游戏真的有可能异军突起，那么目前已有的云游戏做到什么样了呢？恰好笔者最近收到消息，腾讯的 START 云游戏平台已经公测，接下来谈谈我的云游戏初体验。&lt;/p&gt;&lt;h2&gt;我的云游戏初体验&lt;/h2&gt;&lt;p&gt;我的第一次云游戏初体验是在腾讯的 START 平台上进行的，点击官网https://start.qq.com即可看到如下的页面。&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;155&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.4913557779799818&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpHxjUQHMhIAtVEotSw2kRCdxu3MXPs46oFe8s2giaFCiaW5XOtCuPUg5Gw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2198&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;如果不是因为他的域名里有 qq.com，这简洁的页面真的让我怀疑这是腾讯做的吗？而且这句「从此 Mac 也有庞大的游戏库」这句话真的让我很难不怀疑腾讯会那么好心提供那么多游戏吗？&lt;/p&gt;&lt;p&gt;抱着怀疑的态度我下载安装了这款云游戏平台，Mac 安装软件的方法一如既往的简单，下载完后直接将 app 文件拖入 Application 文件夹中即可。&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;191&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.6060606060606061&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpHiazltm77RZUR3ceHibj8ZMpRDvvX7pnaKIxHx2yRzXpSZ4MnGg5dQoPg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1320&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;打开之后我们可以看到腾讯提供的一些游戏，种类虽然不是很多，但是对于不能玩游戏的 Mac 来说已经很不错了。&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;207&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.6564356435643565&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpHKDvhlUYKyzvIvkibUmql9Q50KDpnMYNiccibLg7JTgNWFbpEfI8iagMe0Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1010&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;我试玩了一下很久没玩的 QQ 飞车，体验一番后，我只能说：NB！！&lt;/p&gt;&lt;p&gt;我录了一段小视频，大家可以播放看一下（玩的比较菜，不要嫌弃）&lt;/p&gt;&lt;p/&gt;&lt;p&gt;之后我又玩了几把堡垒之夜和穿越火线，目前来看：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;腾讯 START 的整个流程已基本完备，使用门槛很低，下载一个客户端即可体验云游戏。&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;虽然游戏种类不是很多，但有总比没有好&lt;/span&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;赛车类键盘操作游戏体验很好，能还原 PC 体验的 90%以上。画面流畅，帧率稳定，分辨率高。(网速要求并不是很苛刻，只要连接了 5G Wi-Fi 即可)&lt;/span&gt;&lt;span&gt;&lt;span&gt;4.&lt;/span&gt;目前来看 START 是免费的，不知道公开运行时候是不是会收费。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;总的来说，这次的体验真的让我惊到了，因为按照之前的计算，现在的 5G Wi-Fi 的速率和延时其实是不足以带动云游戏，但体验下来，效果真的非常棒，我的 Macbook pro 终于也可以愉快的打游戏了，手里有 Mac 的小伙伴也可以下载体验下。&lt;/p&gt;&lt;h2&gt;浅谈云游戏&lt;/h2&gt;&lt;h3&gt;云游戏的影响&lt;/h3&gt;&lt;p&gt;对于玩家来说，云游戏并不需要高性能的显卡，连使用 MacBook Air 的小伙伴也可以畅玩，扩充了游戏品类，减少了高昂的硬件开支。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpHNaNsLOXYNj99DnUDBcwadyFxf6cybP9A52icpG253keQb31fRHAxeuA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;而且由于游戏都在云端，可以有效的杜绝外挂（你总不能把外挂装到厂商的服务器里吧），同样的也可以防止盗版游戏的盛行（虽然并不知道这是好事还是坏事）。&lt;/p&gt;&lt;p&gt;同样的，对于游戏开发者来说，云游戏的出现可以是他们在开发游戏时可以减少对老设备、低性能设备的适配，提升了游戏呈现质量的同时降低了开发成本，提高了游戏开发的效率。&lt;/p&gt;&lt;h3&gt;云游戏会取代 PC 吗？&lt;/h3&gt;&lt;p&gt;说了那么多，一旦一项新技术兴起，就会面临一个老生常谈的问题：云游戏的出现会取代传统的游戏主机吗？肯定的说，不会。&lt;/p&gt;&lt;p&gt;就算未来网速再快、延时再低，也不可能达到 0 延迟。没办法，这是物理法则。当你在玩电竞游戏的时候，你需要的一定是几毫秒的延时而不是几百毫秒。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6416666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpHV1wr7a5HXpYtUaNibZY7xHeZh0plLiccOrCia2pzQbzbv0zR59Vwf0Fag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;但同样的，云游戏给游戏玩家提供了新的选择，对于一些非重度游戏玩家，玩一些对延时要求不高的游戏来说，云游戏确实是一个新的选择。&lt;/p&gt;&lt;p&gt;所以，回到一开始的问题，云游戏在革谁的命？是英伟达、AMD 这样的显卡厂商吗？还是 Steam、Uplay 这样的游戏平台？我看都不是，它革的是「游戏本」、是「盗版游戏」的命。&lt;/p&gt;&lt;h2&gt;最后&lt;/h2&gt;&lt;p&gt;以上就是本篇文章的全部内容了，如果你觉得还不错的，欢迎点赞支持一波，你们的支持是我更新的最大动力！&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpH47ZQb0Qia7ibfUdueIsZVJMzPW9DXBor2xORyYzlpF6GtIRTkibRTUEQQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>79cada81c373391ababba2acca379cbc</guid>
<title>带你扒一扒 MySQL 的数据在磁盘上到底长什么样子</title>
<link>https://toutiao.io/k/s6jntn5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在之前&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1MDk0MjY0MQ==&amp;amp;mid=2247484095&amp;amp;idx=1&amp;amp;sn=66b3365b22be5165de31f2a221245b16&amp;amp;chksm=e9fbc761de8c4e776e116387af02ca2614f34a85460efd8c6f6f4d7192c80acde97a65e80d19&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《大师，我悟了：为什么 MySQL 索引要用 B+tree ，而且还这么快？》&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;《大师，我悟了：为什么 MySQL 索引要用 B+tree ，而且还这么快？》&lt;/strong&gt;&lt;/a&gt;一文中我从索引的各种数据结构和大家聊到了 &lt;code&gt;MySQL&lt;/code&gt; 底层索引的数据结构 &lt;code&gt;B+tree&lt;/code&gt; 和工作原理。里面多处提到了找数据要从我们电脑的磁盘上找，今天就来说一说 &lt;code&gt;MySQL&lt;/code&gt; 中的数据在磁盘上，&lt;span&gt;它到底是如何进行存储的&lt;/span&gt;？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;存储引擎&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;百度百科是这样定义存储引擎的：&lt;code&gt;MySQL&lt;/code&gt; 中的数据用各种不同的技术存储在文件（或者内存）中，这些不同的技术以及配套的相关功能在 &lt;code&gt;MySQL&lt;/code&gt; 中被称作存储引擎。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单来说就是&lt;span&gt;不同的存储引擎，我们的数据存储的格式也会不一样。&lt;/span&gt;就好比图片有不同的格式，比如：&lt;code&gt;.jpg&lt;/code&gt;, &lt;code&gt;.png&lt;/code&gt;, &lt;code&gt;.gif&lt;/code&gt; 等等……&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;扫盲：存储引擎是作用在&lt;span&gt;表&lt;/span&gt;上的。&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在 &lt;code&gt;MySQL&lt;/code&gt; 中&lt;span&gt;常用的&lt;/span&gt;存储引擎有两种：&lt;code&gt;MyISAM&lt;/code&gt; 和 &lt;code&gt;InnoDB&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;MySQL&lt;/code&gt; &lt;span&gt;5.5之前&lt;/span&gt;，&lt;code&gt;MyISAM&lt;/code&gt; 是默认的存储引擎。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;MySQL&lt;/code&gt; &lt;span&gt;5.5开始&lt;/span&gt;，&lt;code&gt;InnoDB&lt;/code&gt; 是默认的存储引擎。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;主要区别&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;br/&gt;&lt;/th&gt;&lt;th&gt;MyISAM&lt;/th&gt;&lt;th&gt;InnoDB&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;事务&lt;/td&gt;&lt;td&gt;不支持❌&lt;/td&gt;&lt;td&gt;支持&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;表/行锁&lt;/td&gt;&lt;td&gt;只有表锁&lt;/td&gt;&lt;td&gt;还引入了行锁&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;外键&lt;/td&gt;&lt;td&gt;不支持❌&lt;/td&gt;&lt;td&gt;支持✔&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;全文索引&lt;/td&gt;&lt;td&gt;支持✔&lt;/td&gt;&lt;td&gt;版本5.6 开始支持&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;读写速度&lt;/td&gt;&lt;td&gt;更快&lt;/td&gt;&lt;td&gt;更慢&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;MyISAM&lt;/code&gt; 最致命的一点就是不支持事务，而 &lt;code&gt;InnoDB&lt;/code&gt; 支持。所以现在 &lt;code&gt;InnoDB&lt;/code&gt; 已经成为我们使用的标配、最主流的存储引擎了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;相关命令&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查询当前数据库支持的存储引擎&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;show&lt;/span&gt; &lt;span&gt;engines&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查询当前默认的存储引擎&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;show&lt;/span&gt; &lt;span&gt;variables&lt;/span&gt; &lt;span&gt;like&lt;/span&gt; &lt;span&gt;&#x27;%storage_engine%&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查询表的相关信息&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;show&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;status&lt;/span&gt; &lt;span&gt;like&lt;/span&gt; &lt;span&gt;&#x27;表名&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;MyISAM&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个 &lt;code&gt;MyISAM&lt;/code&gt; 表都以3个文件存储在磁盘上。这些文件的名称以表名开头，以扩展名指示文件类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;.frm&lt;/code&gt; 文件（frame）存储表&lt;span&gt;结构&lt;/span&gt;；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;.MYD&lt;/code&gt; 文件（MY Data）存储表&lt;span&gt;数据&lt;/span&gt;；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;.MYI&lt;/code&gt; 文件（MY Index）存储表&lt;span&gt;索引&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;MySQL&lt;/code&gt; 里的数据默认是存放在安装目录下的 data 文件夹中，也可以自己修改。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.56&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wRTybk8SK4aLAQ3BhPBxHbSvoOia6GmibSlXbKOysXfaO5Skkia0zzJ1UUvSufa6E9QNgwAicqxb8WH3PrQIdrOEbQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1100&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我创建了以 &lt;code&gt;MyISAM&lt;/code&gt; 作为存储引擎的一张表 t_user_myisam。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.1692150866462793&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wRTybk8SK4aLAQ3BhPBxHbSvoOia6GmibSVTVKxKGfwZtI9PW8R9fpdQJwAIBVMofy7rIE7mZlrA0Hy6kzcYYCkw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;981&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;.MYI&lt;/code&gt; 文件组织索引的方式就是 &lt;code&gt;B+tree&lt;/code&gt;。叶子节点的 value 处存放的就是&lt;span&gt;索引所在行的磁盘文件地址&lt;/span&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wRTybk8SK4aLAQ3BhPBxHbSvoOia6GmibS6UC3YmIhKw5tAsTCCEmcqlPj6ibJLVITtOw0464c1jaao2ia5GRAzJicg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;底层查找过程&lt;/span&gt;：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先会判断查找条件 &lt;code&gt;where&lt;/code&gt; 中的字段是否是索引字段，如果是就会先拿着这字段去 &lt;code&gt;.MYI&lt;/code&gt; 文件里通过 &lt;code&gt;B+tree&lt;/code&gt; 快速定位，从根节点开始定位查找；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;找到后再把这个索引关键字（就是我们的条件）存放的磁盘文件地址拿到 &lt;code&gt;.MYD&lt;/code&gt; 文件里面找，从而定位到索引所在行的记录。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;表逻辑上相邻的记录行数据在磁盘上并不一定是物理相邻的。&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/wRTybk8SK4aLAQ3BhPBxHbSvoOia6GmibS8my7FzKQ92JekTYZW2oVyib6iaALbb62ecepzTMEaCEv3Cuta3iaRFkbg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1920&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;InnoDB&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一张 &lt;code&gt;InnoDB&lt;/code&gt; 表底层会对应&lt;span&gt;2个&lt;/span&gt;文件在文件夹中进行数据存储。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;.frm&lt;/code&gt; 文件（frame）存储表&lt;span&gt;结构&lt;/span&gt;；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;.ibd&lt;/code&gt; 文件（InnoDB Data）存储表&lt;span&gt;索引+数据&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我创建了以 &lt;code&gt;InnoDB&lt;/code&gt; 作为存储引擎的一张表 t_user_innodb。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2127659574468085&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wRTybk8SK4aLAQ3BhPBxHbSvoOia6GmibSgSq6JC0ezfhiabw6fH1y3BzNSOqPzk4wibib35NV6dbVXkOBr8sFrgqJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;987&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很显然，&lt;code&gt;InnoDB&lt;/code&gt; 把索引和数据都放在一个文件里存着了。毫无疑问，&lt;code&gt;InnoDB&lt;/code&gt; 表里面的数据也是用 &lt;code&gt;B+tree&lt;/code&gt; 数据结构组织起来的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看看它具体是怎么存储的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3401898734177215&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wRTybk8SK4aLAQ3BhPBxHbSvoOia6GmibSgocfYO5Heh2wLHovE943qticGdtZkqQHfwY7btjUzZxJMP45zVNZgXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1896&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;.ibd&lt;/code&gt; 存储数据的特点就是 &lt;code&gt;B+tree&lt;/code&gt; 的叶子节点上&lt;span&gt;包括了我们要的索引和该索引所在行的其它列数据&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;底层查找过程&lt;/span&gt;：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先会判断查找条件 &lt;code&gt;where&lt;/code&gt; 中的字段是否是索引字段，如果是就会先拿着这字段去 &lt;code&gt;.ibd&lt;/code&gt; 文件里通过 &lt;code&gt;B+tree&lt;/code&gt; 快速定位，从根节点开始定位查找；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;找到后直接把这个索引关键字及其记录所在行的其它列数据返回。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3426124197002141&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/wRTybk8SK4aLAQ3BhPBxHbSvoOia6GmibSh9SIUEsCCicsibA53fHMdpzwhU1iclzAfuYK8tDepZNQ5ffz4HmqDv1UA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1868&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;聚集（聚簇）索引&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;聚集索引&lt;/span&gt;：叶子节点包含了完整的数据记录。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单来说就是索引和它所在行的其它列数据全部都在一起了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很显然，&lt;code&gt;MyISAM&lt;/code&gt; 没有聚集索引，&lt;code&gt;InnoDB&lt;/code&gt; 有，而且 &lt;code&gt;InnoDB&lt;/code&gt; 的主键索引就是天然的聚集索引。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有聚集索引当然就有&lt;span&gt;非聚集索引（稀疏索引）&lt;/span&gt;。对于 &lt;code&gt;MyISAM&lt;/code&gt; 来说，它的索引就是非聚集索引。因为它的&lt;span&gt;索引&lt;/span&gt;和&lt;span&gt;数据&lt;/span&gt;是&lt;span&gt;分开&lt;/span&gt;两个文件存的：一个 &lt;code&gt;.MYI&lt;/code&gt; 存索引，一个 &lt;code&gt;.MYD&lt;/code&gt; 存数据。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;为什么 DBA 都建议表中一定要有主键，而且推荐使用整型自增？&lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;杠精请撤离：这里是推荐，没说一定。非要用 UUID 不拦着你😁&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;为什么要有主键？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为 &lt;code&gt;InnoDB&lt;/code&gt; 表里面的数据必须要有一个 &lt;code&gt;B+tree&lt;/code&gt; 的索引结构来组织、维护我们的整张表的所有数据，从而形成 &lt;code&gt;.idb&lt;/code&gt; 文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那和主键有什么关系？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果 &lt;code&gt;InnoDB&lt;/code&gt; 创建了一张没有主键的表，那这张表就有可能没有任何索引，则 &lt;code&gt;MySQL&lt;/code&gt; 会选择所有具有唯一性并且不为 null 中的第一个字段的创建聚集索引。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果没有唯一性索引的字段就会有一个隐式字段成为表的聚集索引：而这个隐式字段，就是 &lt;code&gt;InnoDB&lt;/code&gt; 帮我们创建的一个长度为 6字节 的整数列 &lt;code&gt;ROW_ID&lt;/code&gt;，它随着新行的插入单调增加，&lt;code&gt;InnoDB&lt;/code&gt; 就以该列对数据进行聚集。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用这个 &lt;code&gt;ROW_ID&lt;/code&gt; 列的表都共享一个相同的&lt;span&gt;全局&lt;/span&gt;序列计数器（这是数据字典的一部分）。为了避免这个 &lt;code&gt;ROW_ID&lt;/code&gt; 用完，所以建议表中一定要单独建立一个主键字段。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;为什么推荐使用整型自增？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先整型的&lt;span&gt;占用空间&lt;/span&gt;会比字符串&lt;span&gt;小&lt;/span&gt;，而且在&lt;span&gt;查找&lt;/span&gt;上&lt;span&gt;比大小&lt;/span&gt;也会比字符串更&lt;span&gt;快&lt;/span&gt;。字符串比大小的时候还要先转换成 ASCII 码再去比较。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果&lt;span&gt;使用自增&lt;/span&gt;的话，在&lt;span&gt;插入&lt;/span&gt;方面的效率也会提高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不使用自增，可能时不时会往 &lt;code&gt;B+tree&lt;/code&gt; 的中间某一位置插入元素，当这个节点位置放满了的时候，节点就要进行分裂操作（效率低）再去维护，有可能树还要进行平衡，又是一个耗性能的操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;都用自增就会永远都往后面插入元素，这样索引节点分裂的概率就会小很多。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二级索引&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除聚集索引之外的所有索引都叫做二级索引，也称辅助索引。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的叶子节点则不会存储其它所有列的数据，就&lt;span&gt;只存储主键值&lt;/span&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.16096256684491977&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wRTybk8SK4aLAQ3BhPBxHbSvoOia6GmibSfw0sIic3Rv61ibSS7O0iaiavbyeS4upl0lM2IIvdUf95ytwWsh1VibmfAzQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1870&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;底层查找过程&lt;/span&gt;：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每次要找数据的时候，会根据它找到对应叶子节点的主键值，再把它拿到聚集索引的 &lt;code&gt;B+tree&lt;/code&gt; 中查找，从而拿到整条记录。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/wRTybk8SK4aLAQ3BhPBxHbSvoOia6GmibShE5fCt4vVGK1AAAVf5TZNQpUDe07OlhOqUtUMXKbol0wqk4Pp0WKww/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1920&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;优点：保持一致性和节省空间。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;https://blog.jcole.us/innodb/&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最后&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天和大家聊了 &lt;code&gt;MySQL&lt;/code&gt; 数据在我们电脑中到底是如何进行存储的，从不同存储引擎展开说明，直到聚集索引和二级索引以及它们查找数据的过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后续将和大家谈谈工作中用到最多的&lt;span&gt;联合索引&lt;/span&gt;，和它的&lt;span&gt;最左前缀优化&lt;/span&gt;又是怎么一回事。敬请期待！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果本文对你有帮助的话不妨点个赞👍或者在看呦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分享技术，稳住，我们能赢💪！&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>16d4cc0a03424ffd42116d4593082651</guid>
<title>每个程序员都应该知道的 CPU 知识：NUMA</title>
<link>https://toutiao.io/k/b13e8n2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;什么是 NUMA？&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;早期的计算机，内存控制器还没有整合进 CPU，所有的内存访问都需要经过北桥芯片来完成。如下图所示，CPU 通过前端总线（FSB，Front Side Bus）连接到北桥芯片，然后北桥芯片连接到内存——内存控制器集成在北桥芯片里面。&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;368&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;252&quot; data-ratio=&quot;0.7245508982035929&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9637P74IBOE3mOYRvZ13aE8ZFytOzExOK255TDstq8PiaqpZcGGUicjEgZykQOlEjRsjYWE0307wtoWg4ncmVKhg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;668&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种架构被称为 UMA&lt;sup&gt;1&lt;/sup&gt;（Uniform Memory Access, 一致性内存访问 ）：总线模型保证了 CPU 的所有内存访问都是一致的，不必考虑不同内存地址之间的差异。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 UMA 架构下，CPU 和内存之间的通信全部都要通过前端总线。而提高性能的方式，就是不断地提高 CPU、前端总线和内存的工作频率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后面的故事，大部分人都很清楚：因为物理条件的限制，不断提高工作频率的路子走不下去了。CPU 性能的提升开始从提高主频转向增加 CPU 数量（多核、多 CPU）。越来越多的 CPU 对前端总线的争用，使前端总线成为了瓶颈。为了消除 UMA 架构的瓶颈，NUMA&lt;sup&gt;2&lt;/sup&gt;（Non-Uniform Memory Access, 非一致性内存访问）架构诞生了：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;1&quot; data-cropselx2=&quot;374&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;226&quot; data-ratio=&quot;0.6021180030257186&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9637P74IBOE3mOYRvZ13aE8ZFytOzExOA0POIUeuUnZpzmcWVU71CCRBu6tKPt0GftYx1Qu3lZvPWmny5StPaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;661&quot;/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;CPU 厂商把内存控制器集成到 CPU 内部，一般一个 CPU socket 会有一个独立的内存控制器。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个 CPU scoket 独立连接到一部分内存，这部分 CPU 直连的内存称为“本地内存”。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CPU 之间通过 QPI（Quick Path Interconnect） 总线进行连接。CPU 可以通过 QPI 总线访问不和自己直连的“远程内存”。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和 UMA 架构不同，在 NUMA 架构下，内存的访问出现了本地和远程的区别：访问远程内存的延时会明显高于访问本地内存。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;NUMA 的设置&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Linux 有一个命令 numactl&lt;sup&gt;3&lt;/sup&gt; 可以查看或设置 NUMA 信息。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;执行 &lt;code&gt;numactl --hardware&lt;/code&gt; 可以查看硬件对 NUMA 的支持信息：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;# numactl --hardware&lt;/span&gt;&lt;br/&gt;available: 2 nodes (0-1)&lt;br/&gt;node 0 cpus: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71&lt;br/&gt;node 0 size: 96920 MB&lt;br/&gt;node 0 free: 2951 MB&lt;br/&gt;node 1 cpus: 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95&lt;br/&gt;node 1 size: 98304 MB&lt;br/&gt;node 1 free: 33 MB&lt;br/&gt;node distances:&lt;br/&gt;node   0   1 &lt;br/&gt;  0:  10  21 &lt;br/&gt;  1:  21  10&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;CPU 被分成 node 0 和 node 1 两组（这台机器有两个 CPU Socket）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一组 CPU 分配到 96 GB 的内存（这台机器总共有 192GB 内存）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;node distances 是一个二维矩阵，node[i][j] 表示 node i 访问 node j 的内存的相对距离。比如 node 0 访问 node 0 的内存的距离是 10，而 node 0 访问 node 1 的内存的距离是 21。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;执行 &lt;code&gt;numactl --show&lt;/code&gt; 显示当前的 NUMA 设置：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;# numactl --show&lt;/span&gt;&lt;br/&gt;policy: default&lt;br/&gt;preferred node: current&lt;br/&gt;physcpubind: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 &lt;br/&gt;cpubind: 0 1 &lt;br/&gt;nodebind: 0 1 &lt;br/&gt;membind: 0 1 &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;--cpubind=0&lt;/code&gt;：绑定到 node 0 的 CPU 上执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;--membind=1&lt;/code&gt;：只在 node 1 上分配内存。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;--interleave=nodes&lt;/code&gt;：nodes 可以是 all、N,N,N 或 N-N，表示在 nodes 上轮循（round robin）分配内存。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;--physcpubind=cpus&lt;/code&gt;：cpus 是 /proc/cpuinfo 中的 processor（超线程） 字段，cpus 的格式与 --interleave=nodes 一样，表示绑定到 cpus 上运行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;--preferred=1&lt;/code&gt;：优先考虑从 node 1 上分配内存。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;# 运行 test_program 程序，参数是 argument，绑定到 node 0 的 CPU 和 node 1 的内存&lt;/span&gt;&lt;br/&gt;numactl --cpubind=0 --membind=1 test_program arguments&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 在 processor 0-4，8-12 上运行 test_program&lt;/span&gt;&lt;br/&gt;numactl --physcpubind=0-4,8-12 test_program arguments&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 轮询分配内存&lt;/span&gt;&lt;br/&gt;numactl --interleave=all test_program arguments&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 优先考虑从 node 1 上分配内存&lt;/span&gt;&lt;br/&gt;numactl --preferred=1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;测试 NUMA&lt;/h1&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;sys/time.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;** argv)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; size = &lt;span&gt;std&lt;/span&gt;::stoi(argv[&lt;span&gt;1&lt;/span&gt;]);&lt;br/&gt;  &lt;span&gt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;vector&lt;/span&gt;&amp;lt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;vector&lt;/span&gt;&amp;lt;&lt;span&gt;uint64_t&lt;/span&gt;&amp;gt;&amp;gt; &lt;span&gt;data&lt;/span&gt;&lt;span&gt;(size, &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;vector&lt;/span&gt;&amp;lt;&lt;span&gt;uint64_t&lt;/span&gt;&amp;gt;(size))&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;timeval&lt;/span&gt; &lt;span&gt;b&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;  gettimeofday(&amp;amp;b, &lt;span&gt;nullptr&lt;/span&gt;);&lt;br/&gt;  # 按列遍历，避免 CPU cache 的影响&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; col = &lt;span&gt;0&lt;/span&gt;; col &amp;lt; size; ++col) {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; row = &lt;span&gt;0&lt;/span&gt;; row &amp;lt; size; ++row) {&lt;br/&gt;      data[row][col] = rand();&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;timeval&lt;/span&gt; &lt;span&gt;e&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;  gettimeofday(&amp;amp;e, &lt;span&gt;nullptr&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;Use time &quot;&lt;/span&gt;&lt;br/&gt;            &amp;lt;&amp;lt; e.tv_sec * &lt;span&gt;1000000&lt;/span&gt; + e.tv_usec - b.tv_sec * &lt;span&gt;1000000&lt;/span&gt; - b.tv_usec&lt;br/&gt;            &amp;lt;&amp;lt; &lt;span&gt;&quot;us&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;endl&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;# numactl --cpubind=0 --membind=0 ./numa_test 20000&lt;/span&gt;&lt;br/&gt;Use time 16465637us&lt;br/&gt;&lt;span&gt;# numactl --cpubind=0 --membind=1 ./numa_test 20000 &lt;/span&gt;&lt;br/&gt;Use time 21402436us&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看出，测试程序使用远程内存比使用本地内存慢了接近 30%&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Linux 的 NUMA 策略&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Linux 识别到 NUMA 架构后，默认的内存分配方案是：优先从本地分配内存。如果本地内存不足，优先淘汰本地内存中无用的内存。使内存页尽可能地和调用线程处在同一个 node。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种默认策略在不需要分配大量内存的应用上一般没什么问题。但是对于数据库这种可能分配超过一个 NUMA node 的内存量的应用来说，可能会引起一些奇怪的性能问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是在网上看到的的例子：由于 Linux 默认的 NUMA 内存分配策略，导致 MySQL 在内存比较充足的情况下，出现大量内存页被换出，造成性能抖动的问题。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;The MySQL “swap insanity” problem and the effects of the NUMA architecture&lt;sup&gt;4&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;A brief update on NUMA and MySQL&lt;sup&gt;5&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;参考资料&lt;/h1&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;UMA（Uniform Memory Access, 一致性内存访问）：https://en.wikipedia.org/wiki/Uniform_memory_access&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;NUMA（Non-Uniform Memory Access, 非一致性内存访问）：https://en.wikipedia.org/wiki/Non-uniform_memory_access&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;numactl：https://linux.die.net/man/8/numactl&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;The MySQL “swap insanity” problem and the effects of the NUMA architecture：http://blog.jcole.us/2010/09/28/mysql-swap-insanity-and-the-numa-architecture/&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;A brief update on NUMA and MySQL：http://blog.jcole.us/2012/04/16/a-brief-update-on-numa-and-mysql/&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;NUMA架构的CPU -- 你真的用好了么？：http://cenalulu.github.io/linux/numa/&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Thread and Memory Placement on NUMA Systems: Asymmetry Matters：https://www.usenix.org/conference/atc15/technical-session/presentation/lepers&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;NUMA (Non-Uniform Memory Access): An Overview：https://queue.acm.org/detail.cfm?id=2513149&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;NUMA Memory Policy：https://www.kernel.org/doc/html/latest/admin-guide/mm/numa_memory_policy.html&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;What is NUMA?：https://www.kernel.org/doc/html/latest/vm/numa.html&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;/&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>