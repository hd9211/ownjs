<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>36a862b0d843b47d0373f292e8fcaeaf</guid>
<title>实时数仓方案五花八门，实际落地如何选型和构建！</title>
<link>https://toutiao.io/k/qdvw0pi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;section class=&quot;mp_profile_iframe_wrp&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUyMDA4OTY3MQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/TwK74MzofXdtvHKjv7OHYYSTQ2QOVuyAia3LaU56kibxKLlX5Lo9bgeUfz1R4JDmdW7ZGYSLqsiaBl3nTOwOmFOFQ/0?wx_fmt=png&quot; data-nickname=&quot;浪尖聊大数据&quot; data-alias=&quot;bigdatatip&quot; data-signature=&quot;主要分享大数据框架，如spark，flink，kafka，hbase原理源码，同时会分享数据仓库，图计算等浪尖擅长领域。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-type=&quot;jpeg&quot; data-w=&quot;537&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VLWD2LYLzffW03hVmxUbJv5qjdm8cRbiaX8zKOX00icJqMs0dEQVwmwe6BL5VzFRs6DNlyWKHMNLpnliarRBkMhEw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;【作者介绍】王磊，阿里云 MVP，华院计算技术总监。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;著有：《图解 Spark 大数据快速分析实战》；《offer 来了：Java 面试核心知识点精讲（原理篇）》；《offer 来了：Java 面试核心知识点精讲（架构篇）》。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;    &lt;/span&gt; &lt;/section&gt;&lt;section&gt;&lt;span&gt;编辑 | 韩楠&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;约 &lt;span&gt;4,989&lt;/span&gt; 字 | 10 分钟阅读&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;01&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;文章概览（一至五）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;✦&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;一、为何需要实时数仓架构&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;二、数仓如何分层&amp;amp;各层用途&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;三、数仓分层的必要性&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;四、从Lambda架构说起&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;五、Kappa架构解决哪些问题&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;02&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;文章概览（六至九）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;✦&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;六、深入实时数仓架构［五种方案讲解］   &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;七、具体选型建议&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;八、大厂方案分享&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;九、结语&amp;amp;延伸思考&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;103&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;这里我补充说几句：这篇分享，内容分成了一个个小块知识呈现的，大家可结合文章概览看看对哪部分/哪几部分更为感兴趣，或者哪部分知识点掌握程度有待加深。然后直接找到对应的小模块浏览学习。期待你在留言区里讨论交流。&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;随着数字化进程的推进，企业产生的数据越来越多，与此同时企业对数据的需求也变得越来越复杂多样。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;如何解决大规模复杂数据的存储和计算，已经成为很多企业必须面对的问题？这值得我们深思。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;一、为何需要实时数仓架构&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;最初企业存储数据都在数仓中存储，但是随着数据量的增大，传统数据的方案在时效性上和数据维护上变得越来越困难。实时数仓架构应运而生。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;然而问题并不是这么简单，&lt;strong&gt;在具体方案落地上实时数仓有很多方案可以选择，那么面对不同的业务和应用场景我们到底应该选择哪种技术方案呢？这是困扰好多大数据架构师的问题。&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.604&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VLWD2LYLzffW03hVmxUbJv5qjdm8cRbiaN619iaEQeQtgk6yLOu06HbMD9oYt3T0YibGEFuu6H38gm9ibialqn2jAzg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1000&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;图1&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;本文就针对该问题梳理了市场上常见的实时数仓方案和对应的应用场景。以便大家在选择或者使用实时数仓架构时能够有的放矢。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当然，在职业规划中，对应于想要成为大架构师的你而言，通过本文阅读你将会让你了解大数据架构必须掌握的数仓知识。尤其在实时数仓各种方案对比上会让你对数仓的理解更上一层楼。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另外，&lt;strong&gt;即便你不是大数据方面的研发人员，这一篇中处理数据的流程和思路，也一样会对你日常的工作有所帮助。&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;二、数仓如何分层 &amp;amp; 各层用途&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在介绍实时数仓前，我们先回顾下离线数仓的分层架构，这将对我们后面理解实时数仓架构设计具有很大帮助。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;数仓一般分为：ODS层、DWD层、DWS层和ADS层。&lt;/strong&gt;这里我会分别展开说一下。这部分内容大家了解数仓中每层数据的特点即可，具体研发中同学们可以根据项目再做深入体会。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9546296&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VLWD2LYLzffW03hVmxUbJv5qjdm8cRbiaM97gVJLHBibApYBT26jMoicTexakyhPw6eEwNoklGiau1oOjSiaHGicTJgg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;图2&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1）&lt;strong&gt;ODS层：ODS是数据接入层，所有进入数据的数据首先会接入ODS层。&lt;/strong&gt;一般来说ODS层的数据是多复杂多样的。从数据粒度上看ODS层是粒度最细的数据层。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2）&lt;strong&gt;DWD层：为数据仓库层，数据明细层的数据应是经过ODS清洗，转后的一致的、准确的、干净的数据。&lt;/strong&gt;DWD层数据粒度通常和ODS的粒度相同，不同的是该层的数据质量更高，字段更全面等。在数据明细层会保存BI系统中所有的历史数据，例如保存近10年来的数据。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3）&lt;strong&gt;DWS层：数据集市层，该层数据是面向主题来组织数据的，通常是星形或雪花结构的数据。从数据粒度来说，这层的数据是轻度汇总级的数据，已经不存在明细数据了。&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4）&lt;strong&gt;ADS层：数据应用层，它是完全为了满足具体的分析需求而构建的数据，也是星形或雪花结构的数据。&lt;/strong&gt;从数据粒度来说是高度汇总的数据。其汇总的目标主要是按照应用需求进行的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;三、数仓分层的必要性&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;那么数仓为什么要分层，数仓分层后有哪些好处呢？数仓分层是一个比较麻烦且耗费工作成本的一个事情，只有理解了数仓分层到底有哪些好处，我们才能理解数仓分层的必要性。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;数仓分层的总体思路是用空间换时间，其目的是通过数仓分层，使得数仓能够更好地应对需求的变更，和提高数据的稳定性。&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1）&lt;strong&gt;用空间换时间：&lt;/strong&gt;通过大量的预处理来提升应用系统的用户体验（效率），因此数据仓库会存在大量冗余的数据。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2）&lt;strong&gt;能更好地应对需求的变更：&lt;/strong&gt;如果不分层的话，如果源业务系统的业务规则发生变化，将会影响整个数据清洗过程，工作量巨大。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3）&lt;strong&gt;提高数据处理过程的稳定性：&lt;/strong&gt;通过数据分层管理可以简化数据清洗的过程，因为把原来一步的工作分到了多个步骤去完成，相当于把一个复杂的工作拆成了多个简单的工作，每一层的处理逻辑都相对简单和容易理解。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这样我们比较容易保证每一个步骤的正确性，当数据发生错误的时候，往往我们只需要局部调整某个步骤即可。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3027778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VLWD2LYLzffW03hVmxUbJv5qjdm8cRbiawYAicMibuRervM0WR2crVB4BYazwwGjj9W6vf80wzztC6c2QoDvwiafRA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;图3&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;前面介绍了数仓分层的一些基本理论，这将对我们后面理解实时数仓的各种架构打下一些理论知识基础。下面为大家梳理下市场上常见的实时数仓方案和对应的应用场景。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;四、从Lambda架构说起&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;大部分实时数仓，其实是从Lambda架构演化而来的，因此在介绍实时数仓方案前我们先回顾下Lambda架构。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Lambda架构将数据分为实时数据和离线数据。&lt;/span&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;针对实时数据使用流式计算引擎进行计算（例如Flink），针对离线数据使用批量计算引擎（例如Spark）计算。&lt;/strong&gt;然后分别将计算结果存储在不同的存储引擎上对外提供数据服务。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5101852&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VLWD2LYLzffW03hVmxUbJv5qjdm8cRbiaynQ0C6SoHlAU9e5TcJsSSuuOjv3svqwHAFAmzO39n9gS0z1auTBEww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;图4&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这种架构的优点是离线数据和实时数据各自计算，既能保障实时为业务提供服务，又能保障历史数据的快速分析。它分别结合了离线计算引擎与流式计算引擎二者的优势。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是有一个缺点是离线数据和实时数据的一致性比较难保障，一般在离线数据产生后会使用离线数据清洗实时数据来保障数据的强一致性。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;五、Kappa架构解决哪些问题&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;接下来要讲的这种架构，它是基于Lambda架构上的优化版本，&lt;strong&gt;Kappa架构。这种架构将数据源的数据全部转换为流式数据，并将计算统一到流式计算引擎上。&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;这种方式的特点使架构变得更加简单，但是不足之处是需要保障数据都是实时的数据，&lt;/strong&gt;如果数据是离线的话也需要转化为流式数据的架构进行数据处理，具体架构可结合这张图来看。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3435185&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VLWD2LYLzffW03hVmxUbJv5qjdm8cRbiaf6ZcJic1Y2wMhwrptrFO7ttWICI5AQesM0co8FmKg23Y7Pdjld5Cokg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;图5&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;六、深入实时数仓架构&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;实时数仓的查询需求&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在正式讨论实时数仓前，我们先看下行业对实时数仓的主要需求，这有助于我们理解实时数仓各种方案设计的初衷，了解它是基于哪些需求应运而生的。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这也将帮助我们从更多维度上思考需求、条件、落地难点等等一些关键要素之间如何评估和权衡，最终实现是基于现有条件下的功能如何将其价值最大化。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;传统意义上我们通常将数据处理分为离线的和实时的。对于实时处理场景，我们一般又可以分为两类：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一类诸如监控报警类、大屏展示类场景要求秒级甚至毫秒级；另一类诸如大部分实时报表的需求通常没有非常高的时效性要求，一般分钟级别，比如10分钟甚至30分钟以内都可接受。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2851852&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VLWD2LYLzffW03hVmxUbJv5qjdm8cRbiaxlYQK3iaGtzShfgEwZstZ4OwSviaG21Ma7vMic4A3HGzx6EFEkUgk3qpQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;图6&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;基于以上查询需求，业界常见的实时数仓方案有这几种。 &lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMDA4OTY3MQ==&amp;amp;mid=2247507357&amp;amp;idx=1&amp;amp;sn=5715370c21c0da94dc5d2d0d8a122e9b&amp;amp;chksm=f9ed24b5ce9aada3939ab2e29a4dbd1049d112984d6eadb210acc9e89c39c7c449b06a65d6ec&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6703704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VLWD2LYLzffW03hVmxUbJv5qjdm8cRbiaJV6RkpJ0eBKzBKvk6htUtlebGRVq0owtTHtWAVgSlvOmv2AqKBibAMg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;图7&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;目前老的项目大部分还在使用的标准分层体现+流计算+批量计算的方案。未来大家可能都会迁移到标准分层体系+流计算+数据湖，和基于全场景MPP数据库实现的方案上，我也会重点介绍这两个方案，也希望大家能够多花点时间加以理解。&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;方&lt;/strong&gt;&lt;strong&gt;案 1：&lt;/strong&gt;&lt;strong&gt;Kappa&lt;/strong&gt;&lt;strong&gt; 架构&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先咱们看下Kappa架构，Kappa架构将多源数据（用户日志，系统日志，BinLog日志）实时地发送到Kafka。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;然后通过Flink集群，按照不同的业务构建不同的流式计算任务，对数据进行数据分析和处理，并将计算结果输出到MySQL/ElasticSearch/HBase/Druid/KUDU等对应的数据源中，最终提供应用进行数据查询或者多维分析。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3314815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VLWD2LYLzffW03hVmxUbJv5qjdm8cRbiamRDot7TFzJd6OFOB27FKuBwHe0IlMu1FgF5toibib1nXqlpusicwJXbXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;图8&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这种方案的好处有二，方案简单；数据实时。不过有两个缺点：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一个是用户每产生一个新的报表需求，都需要开发一个Flink流式计算任务，数据开发的人力成本和时间成本都较高。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;第二个是对于每天需要接入近百亿的数据平台，如果要分析近一个月的数据，则需要的Flink集群规模要求很大，且需要将很多计算的中间数据存储在内存中以便多流Join。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3768519&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VLWD2LYLzffW03hVmxUbJv5qjdm8cRbiaUOXr8FtgyVMfqw4e4gyCmMJAib5kkxQ2svCGhibibrPbtaEe3XyrnsibVQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;图9&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;方&lt;/strong&gt;&lt;strong&gt;案 ２：基于标准分层 + 流&lt;/strong&gt;&lt;strong&gt;计算&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;为了解决方案1中将所有数据放在一个层出现的开发维护成本高等问题，于是出现了基于标准分层+流计算的方案。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;接下来咱们看下这种方案，&lt;strong&gt;在传统数仓的分层标准上构建实时数仓，将数据分为ODS、DWD、DWS、ADS层。&lt;/strong&gt;首先将各种来源的数据接入ODS贴源数据层，再对ODS层的数据使用Flink的实时计算进行过滤、清洗、转化、关联等操作，形成针对不同业务主题的DWD数据明细层，并将数据发送到Kafka集群。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;之后在DWD基础上，再使用Flink实时计算进行轻度的汇总操作，形成一定程度上方便查询的DWS轻度汇总层。最后再面向业务需求，在DWS层基础上进一步对数据进行组织进入ADS数据应用层，业务在数据应用层的基础上支持用户画像、用户报表等业务场景。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2268519&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VLWD2LYLzffW03hVmxUbJv5qjdm8cRbiaX1lCvl4ic7UNmA7I97GTYwaSrKvDq5854fMibDhnSctmQ2dsic5Wiab55Q/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;图10&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这种方案的优点是：各层数据职责清晰。缺点是多个Flink集群维护起来复杂，并且过多的数据驻留在Flink集群内也会增大集群的负载，不支持upset操作，同时Schema维护麻烦。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3685185&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VLWD2LYLzffW03hVmxUbJv5qjdm8cRbiaYZ1zxYicJO2RGxGEZU8ZyDlicIJz9Gtcut03Ws31kuMl47I4wp0uxUNw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;图11&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;方&lt;/strong&gt;&lt;strong&gt;案 3：标准分层体现+流计算+批量计算&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;     &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;为了解决方案2不支持upset和schema维护复杂等问题。我们在方案2的基础上加入基于HDFS&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;加&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Spark离线的方案。也就是离线数仓和实时数仓并行流转的方案。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3472222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VLWD2LYLzffW03hVmxUbJv5qjdm8cRbiaBZLG6rm5Dn320PQ7YfQIjeP6DohCUemXCJy1tecuHI1e0bcf0YE9MA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;图12&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这种方案带来的优点是：既支持实时的OLAP查询，也支持离线的大规模数据分析。但是带来了问题这样的几个问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;数据质量管理复杂：需要构建一套兼容离线数据和实时数据血缘关系的数据管理体系，本身就是一个复杂的工程问题。离线数据和实时数据Schema统一困难。架构不支持upset。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2944444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VLWD2LYLzffW03hVmxUbJv5qjdm8cRbiarUcyZaibpFW2RXjzpaLDiajAIDGGAPiaBjU8EmuFf82uqU7gNb9eG7Dxg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;图13&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;方&lt;/strong&gt;&lt;strong&gt;案 4：标准分层体系+流计算+数据湖&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;随着技术的发展，为了解决数据质量管理和upset 问题。出现了流批一体架构，这种架构基于数据湖三剑客 Delta Lake  / Hudi / Iceberg 实现 + Spark 实现。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4657407&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VLWD2LYLzffW03hVmxUbJv5qjdm8cRbiaxsQmPKYJHgcKAEKQD2YEmibW9tm75DVh0OicWZdliaP7syXaEAwXE5ung/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;图14&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们以Iceberg为例介绍下这种方案的架构，从下图可以看到这方案和前面的方案2很相似，只是在数据存储层将Kafka换为了Iceberg。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3490741&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VLWD2LYLzffW03hVmxUbJv5qjdm8cRbiaygrNOC1oDXpV9uyicSEpetUicfZafvpibg1ibpCia3tjXic5W56L7QrpJXOA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;图15&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;它有这样的几个特点，其中第2、3点，尤为重要，需要特别关注下，这也是这个方案和其他方案的重要差别。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;在编程上将流计算和批计算统一到同一个SQL引擎上，基于同一个Flink SQL既可以进行流计算，也可以进行批计算。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;将流计算和批计算的存储进行了统一，也就是统一到Iceberg/HDFS上，这样数据的血缘关系的和数据质量体系的建立也变得简单了。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;由于存储层统一，数据的Schema也自然统一起来了，这样相对流批单独两条计算逻辑来说，处理逻辑和元数据管理的逻辑都得到了统一。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;数据中间的各层（ODS、DWD、DWS、ADS）数据，都支持OLAP的实时查询。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4527778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VLWD2LYLzffW03hVmxUbJv5qjdm8cRbiaVCDXVpUt0f3NudEsIRK5a8w29wL97yVBwzv248ibVyPbOQy2Ooc8ZHA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;图16&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;那么为什么 Iceberg 能承担起实时数仓的方案呢，主要原因是它解决了长久以来流批统一时的这些难题：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;同时支持流式写入和增量拉取。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;解决小文件多的问题。数据湖实现了相关合并小文件的接口，Spark / Flink上层引擎可以周期性地调用接口进行小文件合并。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持批量以及流式的 Upsert(Delete) 功能。批量Upsert / Delete功能主要用于离线数据修正。流式upsert场景前面介绍了，主要是流处理场景下经过窗口时间聚合之后有延迟数据到来的话会有更新的需求。这类需求是需要一个可以支持更新的存储系统的，而离线数仓做更新的话需要全量数据覆盖，这也是离线数仓做不到实时的关键原因之一，数据湖是需要解决掉这个问题的。 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;同时 Iceberg 还支持比较完整的OLAP生态。比如支持Hive / Spark / Presto / Impala 等 OLAP 查询引擎，提供高效的多维聚合查询性能。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4935185&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VLWD2LYLzffW03hVmxUbJv5qjdm8cRbia1G2Dyyjgzt71UWK2dPGiaR4o4CCLAS50ib3QCVuJUiauib8HiaibR10c8XhQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;图17&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;  &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;Iceberg 实战&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上面介绍了基于Iceberg的标准分层体系+流计算+数据湖的架构，下面咱们从实战角度看下Iceberg如何使用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;iceberg写入流式数据代码实现如下：&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;lua&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;data.writeStream.&lt;span class=&quot;code-snippet__built_in&quot;&gt;format&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;iceberg&quot;&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; .outputMode(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;append&quot;&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;.trigger(Trigger.ProcessingTime(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;, TimeUnit.MINUTES)).option(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;data_path&quot;&lt;/span&gt;, tableIdentifier) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;.option(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;checkpointLocation&quot;&lt;/span&gt;, checkpointPath) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;.start()&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;code1&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上述代码会将data_path下的数据以流的形式，实时加入到系统中进行计算。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;iceberg数据过滤代码实现如下：&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;Table&lt;/span&gt; table = ... Actions.forTable(table).rewriteDataFiles() .filter(Expressions.equal(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;date&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;2022-03-18&quot;&lt;/span&gt;)) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;.targetSizeInBytes(&lt;span class=&quot;code-snippet__number&quot;&gt;500&lt;/span&gt; * &lt;span class=&quot;code-snippet__number&quot;&gt;1024&lt;/span&gt; * &lt;span class=&quot;code-snippet__number&quot;&gt;1024&lt;/span&gt;) // &lt;span class=&quot;code-snippet__number&quot;&gt;500&lt;/span&gt; MB &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;.execute();&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;code2&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上述代码过滤出date为2022-03-18的数据。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;方&lt;/strong&gt;&lt;strong&gt;案 5：基于全场景MPP数据库&lt;/strong&gt;&lt;strong&gt;实&lt;/strong&gt;&lt;strong&gt;现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;前面的四种方案，是基于数仓方案的优化。方案仍然属于比较复杂的，如果我能提供一个数据库既能满足海量数据的存储，也能实现快速分析，那岂不是很方便。这时候便出现了以StartRocks和ClickHouse为代表的全场景MPP数据库。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;基于Darios或者ClickHouse构建实时数仓。来看下具体的实现方式：将数据源上的实时数据直接写入消费服务。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对于数据源为离线文件的情况有两种处理方式，一种是将文件转为流式数据写入Kafka，另外一种情况是直接将文件通过SQL导入ClickHouse集群。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;ClickHouse接入Kafka消息并将数据写入对应的原始表，基于原始表可以构建物化视图、Project等实现数据聚合和统计分析。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;应用服务基于ClickHouse数据对外提供BI、统计报表、告警规则等服务。 &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMDA4OTY3MQ==&amp;amp;mid=2247507105&amp;amp;idx=1&amp;amp;sn=6bfd052b7c8a3b572401009af65c9282&amp;amp;chksm=f9ed2589ce9aac9f16a645960b2a02cb5e44b622b0c470afb0f33ea5889392c0c28601921611&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5074074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VLWD2LYLzffW03hVmxUbJv5qjdm8cRbia15IIlNOHmt32k0VVxyy6jib52DLQz43icE7fDwichpaUyYXgsCg6Osmhw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;图18&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;七、具体选型建议&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;对于这5种方案，在具体选型中，我们要根据具体业务需求、团队规模等进行技术方案选型。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;说到这儿，我有这样的几点具体建议，希望或多或少可以给你提供一些可供参考、借鉴的新视角或者新思路。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;（1）对于业务简单，且以流式数据为主数据流的大数据架构可以采用Kappa架构。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;（2）如果业务以流计算为主，对数据分层，数据权限，多主题数据要求比较高，建议使用方案2的基于标准分层+流计算。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;（3）如果业务的流数据是批数据都比较多，且流数据和批数据直接的关联性不大，建议使用方案3的标准分层体现+流计算+批量计算。这种情况下分别能发挥流式计算和批量计算各自的优势。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5898148&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VLWD2LYLzffW03hVmxUbJv5qjdm8cRbiabrLEthr77N05Wn612jN5Z7KMlqXLRz7S5sB0pS5buwPwG0ibBEM9iauA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;图19&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;（4）方案4是一个比较完善的数仓方案，要支持更大规模的和复杂的应用场景，建议大数据研发人员在20以上的团队，可以重点考虑。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;（5）对于大数据研发组团队为10人左右，要维护像方案2、3、4那样以ODS、DWD、DWS、ADS数据分层的方式进行实时数仓建设的话，就需要投入更多的资源。建议使用方案5一站式实现简单的实时数仓。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong/&gt;八、大厂方案分享&lt;/span&gt;&lt;span&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;介绍了这么多实时数仓方案，那么很多小伙伴会问了，大厂到底用的那种方案呢？其实每个大厂根据自己业务特点的不同，也会选择不同的解决方案。下面为大家简要分享下OPPO、滴滴和比特大陆的方案，以便大家能够更好地理解这篇分享中五种架构的具体落地。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;不过具体架构细节我不会进行过多的介绍，有了前面的内容基础，相信大家再通过架构图就能很快了解每个架构的特点。这里只是希望大家能够通过大厂的经验，明白他们架构设计的初衷和要解决的具体问题，同时也给我们的架构设计提供一些思路。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;举例来说，OPPO的实时计算平台架构，其方案其实类似于方案2的基于标准分层+流计算。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.512037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VLWD2LYLzffW03hVmxUbJv5qjdm8cRbiazFS1RV6ZoTPicRw1toTO7HWLHTb8qbZG0TO9siatRrm764U10AWdBARQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;图20&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;滴滴的大数据平台架构是这样的，它的方案其实类似于方案2的基于标准分层+流计算。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3527778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VLWD2LYLzffW03hVmxUbJv5qjdm8cRbiaTQewicVLMiax7KpRcqC0ibZWm5Xh0UemiaK0N9s1q3gKFUT765qJiaIAKkw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;图21&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;再结合比特大陆的方案看下，其方案类型方案3的标准分层体现+流计算+批量计算，同时也引入了ClickHouse，可以看到比特大陆的数据方案是很复杂的。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6407407&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VLWD2LYLzffW03hVmxUbJv5qjdm8cRbiaZ4nqpp5IGb8NkmaJa5nibqwHXVoe2Cjice83W4dPWp4YEVvs2YuLvtHw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;图22&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;九、结语 ＆ 延申思考&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;本文介绍了市面上常见实时数仓方案，并对不同方案的优缺点进行了介绍。在使用过程中我们需要根据自己的业务场景选择合适的架构。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另外想说明的是实时数仓方案并不是“搬过来”，而是根据业务“演化来”的，具体设计的时候需要根据自身业务情况，找到最适合自己当下的实时数仓架构。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;延申思考&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们在实时数仓的构建过程中比较大的争议是采用标准分层体系+流计算+数据湖的方案，还是试用基于全场景MPP数据库实现。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在讨论过程中大家比较大的分歧是基于全场景MPP数据库实现到底算是一个数仓方案不，毕竟该方案没有标准的数仓分层的思想，而是围绕大规模数据统计的需求来实现的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是我的观点是：一切方案都需要以实际需求为出发点，我们的80%的需求就是在一个180多个字段的大宽表（每天80亿条，3TB数据量）上可以灵活的统计分析，快速为业务决策提供依据。因此我们选择了基于全场景MPP数据库方案。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;新的技术层出不穷，对我们技术人来说尝鲜是很爽的一件事情，但是实际落地还是建议大家把需求收敛好后再做决策，保持冷静的思维，有时候适当地“让子弹飞一会”也是有好处的。&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;今天的分享到这里就结束了，期待留言区里的进一步交流，也可以把它分享给你的朋友。我们后续再会。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;--END--&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6764091858037579&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TwK74MzofXd78W49nBaME6TkGc8gv8DBzMJvytIYy9Dibfsl7qq5ibATfYh9BN1xQO5qU1OejK3Gic6dfl8iafXwGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;958&quot;/&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d963ebbb486104fbbae6fdfc665ad856</guid>
<title>JSON神器之jq使用指南指北</title>
<link>https://toutiao.io/k/pzyy5co</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p&gt;1. 美化输出Json：&lt;/p&gt;
&lt;p&gt; 2. 只输出部分字段&lt;/p&gt;
&lt;section id=&quot;Invokingjq&quot;&gt;&lt;hr/&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;命令行参数&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;这里大部分从官网翻译过来的，有问题请帮指点~&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;jq 过滤器在 JSON 数据流上运行。jq 的输入被解析为一系列以空格分隔的 JSON 值，一次一个地通过提供的过滤器。过滤器的输出被写入标准输出，同样是一系列以空格分隔的 JSON 数据。&lt;/p&gt;
&lt;p&gt;注意：注意 shell 的引用规则很重要。作为一般规则，最好总是引用（使用单引号字符） jq 程序，因为太多对 jq 具有特殊含义的字符也是 shell 元字符。例如，&lt;code&gt;jq &quot;foo&quot;&lt;/code&gt;在大多数 Unix shell 上会失败，因为这与 相同&lt;code&gt;jq foo&lt;/code&gt;，通常会失败，因为&lt;code&gt;foo is not defined&lt;/code&gt;. 使用 Windows 命令 shell (cmd.exe) 时，最好在命令行中给出 jq 程序时使用双引号（而不是&lt;code&gt;-f program-file&lt;/code&gt;选项），但是 jq 程序中的双引号需要反斜杠转义。&lt;/p&gt;
&lt;p&gt;您可以使用一些命令行选项影响 jq 如何读取和写入其输入和输出：&lt;/p&gt;

&lt;p&gt;输出 jq 版本并以零退出。&lt;/p&gt;

&lt;p&gt;使用&lt;code&gt;application/json-seq&lt;/code&gt;MIME 类型方案在 jq 的输入和输出中分隔 JSON 文本。这意味着在输出的每个值之前打印一个 ASCII RS（记录分隔符）字符，并且在每个输出之后打印一个 ASCII LF（换行符）。无法解析的输入 JSON 文本将被忽略（但警告），丢弃所有后续输入，直到下一个 RS。此模式还解析 jq 的输出而不使用该&lt;code&gt;--seq&lt;/code&gt; 选项。&lt;/p&gt;

&lt;p&gt;以流方式解析输入，输出路径和叶值数组（标量和空数组或空对象）。例如，&lt;code&gt;&quot;a&quot;&lt;/code&gt;变成&lt;code&gt;[[],&quot;a&quot;]&lt;/code&gt;，&lt;code&gt;[[],&quot;a&quot;,[&quot;b&quot;]]&lt;/code&gt; 变成&lt;code&gt;[[0],[]]&lt;/code&gt;，&lt;code&gt;[[1],&quot;a&quot;]&lt;/code&gt;，和&lt;code&gt;[[1,0],&quot;b&quot;]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这对于处理非常大的输入很有用。将此与过滤和&lt;code&gt;reduce&lt;/code&gt;and&lt;code&gt;foreach&lt;/code&gt;语法结合使用，以逐步减少大输入。&lt;/p&gt;

&lt;p&gt;不要为输入中的每个 JSON 对象运行过滤器，而是将整个输入流读入一个大数组并只运行一次过滤器。&lt;/p&gt;

&lt;p&gt;不要将输入解析为 JSON。相反，每一行文本都作为字符串传递给过滤器。如果与 结合使用&lt;code&gt;--slurp&lt;/code&gt;，则整个输入将作为单个长字符串传递给过滤器。&lt;/p&gt;

&lt;p&gt;根本不读取任何输入！相反，过滤器&lt;code&gt;null&lt;/code&gt;作为输入运行一次。这在将 jq 用作简单的计算器或从头构建 JSON 数据时很有用。&lt;/p&gt;

&lt;p&gt;默认情况下，jq 漂亮地打印 JSON 输出。使用此选项将通过将每个 JSON 对象放在一行中来生成更紧凑的输出。&lt;/p&gt;

&lt;p&gt;每个缩进级别使用一个制表符，而不是两个空格。&lt;/p&gt;

&lt;p&gt;使用给定数量的空格（不超过 7 个）进行缩进。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--color-output&lt;/code&gt;/&lt;code&gt;-C&lt;/code&gt;和&lt;code&gt;--monochrome-output&lt;/code&gt;/ &lt;code&gt;-M&lt;/code&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;默认情况下，如果写入终端，jq 会输出彩色 JSON。即使使用 写入管道或文件，您也可以强制它产生颜色&lt;code&gt;-C&lt;/code&gt;，并使用 禁用颜色&lt;code&gt;-M&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;可以使用&lt;code&gt;JQ_COLORS&lt;/code&gt;环境变量配置颜色（见下文）。&lt;/p&gt;

&lt;p&gt;使用 WSL、MSYS2 或 Cygwin 的 Windows 用户在使用本机 jq.exe 时应使用此选项，否则 jq 会将换行符 (LF) 转换为回车换行符 (CRLF)。&lt;/p&gt;

&lt;p&gt;jq 通常将非 ASCII Unicode 代码点输出为 UTF-8，即使输入将它们指定为转义序列（如“\u03bc”）。使用此选项，您可以强制 jq 生成纯 ASCII 输出，并将每个非 ASCII 字符替换为等效的转义序列。&lt;/p&gt;

&lt;p&gt;在打印每个 JSON 对象后刷新输出（如果您将慢速数据源传送到 jq 并将 jq 的输出传送到其他地方，这很有用）。&lt;/p&gt;

&lt;p&gt;按排序顺序输出每个对象的字段和键。&lt;/p&gt;

&lt;p&gt;使用此选项，如果过滤器的结果是字符串，那么它将直接写入标准输出，而不是格式化为带引号的 JSON 字符串。这对于使 jq 过滤器与非基于 JSON 的系统对话很有用。&lt;/p&gt;

&lt;p&gt;Like&lt;code&gt;-r&lt;/code&gt;但 jq 不会在每次输出后打印换行符。&lt;/p&gt;

&lt;p&gt;像&lt;code&gt;-r&lt;/code&gt;，但 jq 将在每次输出后打印 NUL 而不是换行符。当输出的值可以包含换行符时，这可能很有用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-f filename&lt;/code&gt;/ &lt;code&gt;--from-file filename&lt;/code&gt;:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从文件而不是从命令行读取过滤器，如 awk 的 -f 选项。您也可以使用“#”来发表评论。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-Ldirectory&lt;/code&gt;/ &lt;code&gt;-L directory&lt;/code&gt;:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;预先&lt;code&gt;directory&lt;/code&gt;添加到模块的搜索列表中。如果使用此选项，则不使用内置搜索列表。请参阅下面的模块部分。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;false&lt;/code&gt;如果最后一个输出值不是nor &lt;code&gt;null&lt;/code&gt;，则将jq 的退出状态设置为 0，如果最后一个输出值是&lt;code&gt;false&lt;/code&gt;or &lt;code&gt;null&lt;/code&gt;，则设置为 1，如果没有产生有效结果，则设置为 4。如果有任何使用问题或系统错误，jq 通常退出 2，如果有 jq 程序编译错误，则退出 3，或者如果 jq 程序运行，则退出 0。&lt;/p&gt;
&lt;p&gt;另一种设置退出状态的方法是使用&lt;code&gt;halt_error&lt;/code&gt; 内置函数。&lt;/p&gt;

&lt;p&gt;此选项将值作为预定义变量传递给 jq 程序。如果您使用 运行 jq &lt;code&gt;--arg foo bar&lt;/code&gt;，则&lt;code&gt;$foo&lt;/code&gt;在程序中可用并具有值&lt;code&gt;&quot;bar&quot;&lt;/code&gt;。请注意， &lt;code&gt;value&lt;/code&gt;将被视为字符串，因此&lt;code&gt;--arg foo 123&lt;/code&gt;将绑定&lt;code&gt;$foo&lt;/code&gt;到&lt;code&gt;&quot;123&quot;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;jq 程序也可以使用命名参数作为 &lt;code&gt;$ARGS.named&lt;/code&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--argjson name JSON-text&lt;/code&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此选项将 JSON 编码的值作为预定义变量传递给 jq 程序。如果您使用 运行 jq &lt;code&gt;--argjson foo 123&lt;/code&gt;，则 &lt;code&gt;$foo&lt;/code&gt;在程序中可用并具有值&lt;code&gt;123&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--slurpfile variable-name filename&lt;/code&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此选项读取命名文件中的所有 JSON 文本，并将解析的 JSON 值的数组绑定到给定的全局变量。如果您使用 运行 jq &lt;code&gt;--slurpfile foo bar&lt;/code&gt;，则&lt;code&gt;$foo&lt;/code&gt;在程序中可用，并且有一个数组，其元素对应于名为 的文件中的文本&lt;code&gt;bar&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--rawfile variable-name filename&lt;/code&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此选项读入命名文件并将其内容绑定到给定的全局变量。如果你运行 jq with &lt;code&gt;--rawfile foo bar&lt;/code&gt;, then&lt;code&gt;$foo&lt;/code&gt;在程序中是可用的，并且有一个字符串，其内容是文件中的 texs 名为&lt;code&gt;bar&lt;/code&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--argfile variable-name filename&lt;/code&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不使用。改为使用&lt;code&gt;--slurpfile&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;（此选项类似于&lt;code&gt;--slurpfile&lt;/code&gt;，但当文件只有一个文本时，则使用该文本，否则使用文本数组，如&lt;code&gt;--slurpfile&lt;/code&gt;。）&lt;/p&gt;

&lt;p&gt;其余参数是位置字符串参数。这些可用于 jq 程序作为&lt;code&gt;$ARGS.positional[]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;其余参数是位置 JSON 文本参数。这些可用于 jq 程序作为&lt;code&gt;$ARGS.positional[]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;在给定文件或标准输入中运行测试。这必须是给出的最后一个选项，并且不支持所有前面的选项。输入由注释行、空行和程序行组成，后跟一个输入行，与预期一样多的输出行（每个输出一个），以及一个终止空行。编译失败测试从仅包含“%%FAIL”的行开始，然后是包含要编译的程序的行，然后是包含要与实际进行比较的错误消息的行。&lt;/p&gt;
&lt;p&gt;请注意，此选项可能会向后不兼容地更改。&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;TypesandValues&quot;&gt;
&lt;h2&gt;类型和值&lt;/h2&gt;
&lt;p&gt;jq 支持与 JSON 相同的数据类型集 - 数字、字符串、布尔值、数组、对象（在 JSON 中是只有字符串键的散列）和“null”。&lt;/p&gt;
&lt;p&gt;布尔值、空值、字符串和数字的编写方式与 javascript 相同。就像 jq 中的其他所有内容一样，这些简单的值接受一个输入并产生一个输出 -&lt;code&gt;42&lt;/code&gt;是一个有效的 jq 表达式，它接受一个输入，忽略它，并返回 42。&lt;/p&gt;
&lt;section id=&quot;Arrayconstruction:[]&quot;&gt;
&lt;h3&gt;数组构造：&lt;code&gt;[]&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;在 JSON 中，&lt;code&gt;[]&lt;/code&gt;用于构造数组，如在 &lt;code&gt;[1,2,3]&lt;/code&gt;. 数组的元素可以是任何 jq 表达式，包括管道。所有表达式产生的所有结果都收集到一个大数组中。您可以使用它从已知数量的值中构造一个数组（如&lt;code&gt;[.foo, .bar, .baz]&lt;/code&gt;）或将过滤器的所有结果“收集”到一个数组中（如&lt;code&gt;[.items[].name]&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;一旦你理解了 &quot;,&quot; 操作符，你就可以从不同的角度来看待 jq 的数组语法：表达式&lt;code&gt;[1,2,3]&lt;/code&gt;没有使用逗号分隔数组的内置语法，而是将&lt;code&gt;[]&lt;/code&gt;操作符（收集结果）应用于表达式1,2,3（产生三种不同的结果）。&lt;/p&gt;
&lt;p&gt;如果您有一个&lt;code&gt;X&lt;/code&gt;产生四个结果的过滤器，那么表达式&lt;code&gt;[X]&lt;/code&gt;将产生一个结果，即一个由四个元素组成的数组。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;ObjectConstruction:{}&quot;&gt;
&lt;h3&gt;对象构造：&lt;code&gt;{}&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;像 JSON 一样，&lt;code&gt;{}&lt;/code&gt;用于构造对象（又名字典或哈希），如：&lt;code&gt;{&quot;a&quot;: 42, &quot;b&quot;: 17}&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;如果键是“类似标识符”，则可以省略引号，如&lt;code&gt;{a:42, b:17}&lt;/code&gt;. 作为键表达式的变量引用使用变量的值作为键。常量文字、标识符或变量引用以外的关键表达式需要用括号括起来，例如 &lt;code&gt;{(&quot;a&quot;+&quot;b&quot;):59}&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;该值可以是任何表达式（尽管您可能需要将其括在括号中，例如，如果它包含冒号），它将应用于 {} 表达式的输入（请记住，所有过滤器都有一个输入和一个输出）。&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;{foo: .bar}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;{&quot;foo&quot;: 42}&lt;/code&gt;如果将 JSON 对象&lt;code&gt;{&quot;bar&quot;:42, &quot;baz&quot;:43}&lt;/code&gt;作为其输入，将生成 JSON 对象。您可以使用它来选择对象的特定字段：如果输入是具有“user”、“title”、“id”和“content”字段的对象，而您只需要“user”和“title”，则可以写&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;{user: .user, title: .title}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为这很常见，所以有一个快捷语法： &lt;code&gt;{user, title}&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;如果其中一个表达式产生多个结果，则将产生多个字典。如果输入的&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;{&quot;user&quot;:&quot;stedolan&quot;,&quot;titles&quot;:[&quot;JQ Primer&quot;, &quot;More JQ&quot;]}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后表达式&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;{user, title: .titles[]}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将产生两个输出：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;{&quot;user&quot;:&quot;stedolan&quot;, &quot;title&quot;: &quot;JQ Primer&quot;}
{&quot;user&quot;:&quot;stedolan&quot;, &quot;title&quot;: &quot;More JQ&quot;}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在键周围加上括号意味着它将被评估为表达式。使用与上述相同的输入，&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;{(.user): .titles}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;{&quot;stedolan&quot;: [&quot;JQ Primer&quot;, &quot;More JQ&quot;]}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;作为键的变量引用使用变量的值作为键。如果没有值，则变量的名称将成为键，其值将成为值，&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;&quot;f o o&quot; as $foo | &quot;b a r&quot; as $bar | {$foo, $bar:$foo}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;{&quot;f o o&quot;:&quot;f o o&quot;,&quot;b a r&quot;:&quot;f o o&quot;}&lt;/code&gt;&lt;/pre&gt;

&lt;/section&gt;
&lt;section id=&quot;RecursiveDescent:..&quot;&gt;
&lt;h3&gt;递归下降：&lt;code&gt;..&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;递归下降&lt;code&gt;.&lt;/code&gt;，产生每个值。这与内置的零参数相同&lt;code&gt;recurse&lt;/code&gt;（见下文）。这旨在类似于 XPath&lt;code&gt;//&lt;/code&gt;运算符。注意 &lt;code&gt;..a&lt;/code&gt;不起作用；改为使用&lt;code&gt;..|.a&lt;/code&gt;。在下面的示例中，我们使用&lt;code&gt;..|.a?&lt;/code&gt;在 &quot;below&quot; 找到的任何对象中查找对象键 &quot;a&quot; 的所有值&lt;code&gt;.&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这在与&lt;code&gt;path(EXP)&lt;/code&gt; （另见下文）和&lt;code&gt;?&lt;/code&gt;运算符结合使用时特别有用。&lt;/p&gt;
&lt;div&gt;
&lt;pre class=&quot;language-bash highlighter-hljs&quot;&gt;&lt;code&gt;echo &#x27;{&quot;a&quot;:{&quot;A&quot;:1,&quot;B&quot;:2}}&#x27;|jq &#x27;..&#x27;
{
  &quot;a&quot;: {
    &quot;A&quot;: 1,
    &quot;B&quot;: 2
  }
}
{
  &quot;A&quot;: 1,
  &quot;B&quot;: 2
}
1
2&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id=&quot;Builtinoperatorsandfunctions&quot;&gt;
&lt;h2&gt;内置运算符和函数&lt;/h2&gt;
&lt;p&gt;一些 jq 运算符（例如&lt;code&gt;+&lt;/code&gt;）根据其参数的类型（数组、数字等）执行不同的操作。但是， jq 从不进行隐式类型转换。如果您尝试将字符串添加到对象，您将收到一条错误消息并且没有结果。&lt;/p&gt;
&lt;section id=&quot;Addition:+&quot;&gt;
&lt;h3&gt;添加：&lt;code&gt;+&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;运算符&lt;code&gt;+&lt;/code&gt;采用两个过滤器，将它们都应用于相同的输入，然后将结果相加。“添加”的含义取决于所涉及的类型：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;null&lt;/code&gt;可以添加到任何值，并返回其他值不变。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;Subtraction:-&quot;&gt;
&lt;h3&gt;减法：&lt;code&gt;-&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;除了对数字进行普通算术减法外，该&lt;code&gt;-&lt;/code&gt; 运算符还可用于数组以从第一个数组中删除第二个数组元素的所有出现。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;Multiplication,division,modulo:*,/,and%&quot;&gt;
&lt;h3&gt;乘法、除法、取模：&lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, 和&lt;code&gt;%&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;当给定两个数字时，这些中缀运算符的行为符合预期。除以零会引发错误。&lt;code&gt;x % y&lt;/code&gt;计算 x 模 y。&lt;/p&gt;
&lt;p&gt;将一个字符串乘以一个数字会产生多次串联该字符串。&lt;code&gt;&quot;x&quot; * 0&lt;/code&gt;产生&lt;strong&gt;null&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;将一个字符串除以另一个字符串会使用第二个字符串作为分隔符来拆分第一个字符串。&lt;/p&gt;
&lt;p&gt;将两个对象相乘将递归合并它们：这类似于加法，但如果两个对象都包含相同键的值，并且值是对象，则两者将使用相同的策略合并。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;length&quot;&gt;
&lt;h3&gt;&lt;code&gt;length&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;内置函数&lt;code&gt;length&lt;/code&gt;获取各种不同类型值的长度：&lt;/p&gt;


&lt;/section&gt;
&lt;section id=&quot;utf8bytelength&quot;&gt;
&lt;h3&gt;&lt;code&gt;utf8bytelength&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;内置函数&lt;code&gt;utf8bytelength&lt;/code&gt;输出用于以 UTF-8 编码字符串的字节数。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;keys,keys_unsorted&quot;&gt;
&lt;h3&gt;&lt;code&gt;keys&lt;/code&gt;,&lt;code&gt;keys_unsorted&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;内置函数&lt;code&gt;keys&lt;/code&gt;，当给定一个对象时，会在一个数组中返回它的键。&lt;/p&gt;
&lt;p&gt;键按 unicode 代码点顺序“按字母顺序”排序。这不是在任何特定语言中都特别有意义的顺序，但您可以指望它对于具有相同键集的任何两个对象都是相同的，而不管区域设置如何。&lt;/p&gt;
&lt;p&gt;当&lt;code&gt;keys&lt;/code&gt;给定一个数组时，它返回该数组的有效索引：从 0 到 length-1 的整数。&lt;/p&gt;
&lt;p&gt;该&lt;code&gt;keys_unsorted&lt;/code&gt;函数就像&lt;code&gt;keys&lt;/code&gt;，但如果输入是一个对象，那么键将不会被排序，而是键将大致按插入顺序排列。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;has(key)&quot;&gt;
&lt;h3&gt;&lt;code&gt;has(key)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;内置函数&lt;code&gt;has&lt;/code&gt;返回输入对象是否具有给定键，或者输入数组在给定索引处是否具有元素。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;has($key)&lt;/code&gt;&lt;code&gt;$key&lt;/code&gt; 与检查是否是由 返回的数组的成员具有相同的效果&lt;code&gt;keys&lt;/code&gt;，但&lt;code&gt;has&lt;/code&gt; 会更快。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;in&quot;&gt;
&lt;h3&gt;&lt;code&gt;in&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;内置函数&lt;code&gt;in&lt;/code&gt;返回输入键是否在给定对象中，或者输入索引是否对应于给定数组中的元素。它本质上是&lt;code&gt;has&lt;/code&gt;.&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;map(x),map_values(x)&quot;&gt;
&lt;h3&gt;&lt;code&gt;map(x)&lt;/code&gt;,&lt;code&gt;map_values(x)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;对于任何 filter &lt;code&gt;x&lt;/code&gt;，&lt;code&gt;map(x)&lt;/code&gt;将为输入数组的每个元素运行该过滤器，并在新数组中返回输出。&lt;code&gt;map(.+1)&lt;/code&gt;将递增数字数组的每个元素。&lt;/p&gt;
&lt;p&gt;同样，&lt;code&gt;map_values(x)&lt;/code&gt;将为每个元素运行该过滤器，但是当传递一个对象时它将返回一个对象。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;map(x)&lt;/code&gt;相当于&lt;code&gt;[.[] | x]&lt;/code&gt;。事实上，这就是它的定义方式。同样，&lt;code&gt;map_values(x)&lt;/code&gt;定义为&lt;code&gt;.[] |= x&lt;/code&gt;。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;path(path_expression)&quot;&gt;
&lt;h3&gt;&lt;code&gt;path(path_expression)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;输出给定路径表达式的数组表示形式&lt;code&gt;.&lt;/code&gt;。输出是字符串数组（对象键）和/或数字（数组索引）。&lt;/p&gt;
&lt;p&gt;路径表达式是 jq 表达式，例如&lt;code&gt;.a&lt;/code&gt;, 也是&lt;code&gt;.[]&lt;/code&gt;. 有两种类型的路径表达式：一种可以完全匹配，另一种不能。例如，&lt;code&gt;.a.b.c&lt;/code&gt;is 是一个完全匹配的路径表达式，while&lt;code&gt;.a[].b&lt;/code&gt;不是。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;path(exact_path_expression)&lt;/code&gt;将产生路径表达式的数组表示，即使它不存在于&lt;code&gt;.&lt;/code&gt;, if &lt;code&gt;.&lt;/code&gt;is&lt;code&gt;null&lt;/code&gt;或数组或对象中。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;path(pattern)&lt;/code&gt;如果路径&lt;code&gt;pattern&lt;/code&gt;存在于&lt;code&gt;.&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;请注意，路径表达式与普通表达式没有区别。该表达式 &lt;code&gt;path(..|select(type==&quot;boolean&quot;))&lt;/code&gt;输出 中布尔值的所有路径&lt;code&gt;.&lt;/code&gt;，并且仅输出那些路径。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;del(path_expression)&quot;&gt;
&lt;h3&gt;&lt;code&gt;del(path_expression)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;内置函数&lt;code&gt;del&lt;/code&gt;从对象中删除键及其对应的值。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;getpath(PATHS)&quot;&gt;
&lt;h3&gt;&lt;code&gt;getpath(PATHS)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;内置函数&lt;code&gt;getpath&lt;/code&gt;输出在 中&lt;code&gt;.&lt;/code&gt;的每个路径中找到的值&lt;code&gt;PATHS&lt;/code&gt;。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;setpath(PATHS;VALUE)&quot;&gt;
&lt;h3&gt;&lt;code&gt;setpath(PATHS; VALUE)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;内置函数&lt;code&gt;setpath&lt;/code&gt;将&lt;code&gt;PATHS&lt;/code&gt;in设置&lt;code&gt;.&lt;/code&gt;为&lt;code&gt;VALUE&lt;/code&gt;.&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;delpaths(PATHS)&quot;&gt;
&lt;h3&gt;&lt;code&gt;delpaths(PATHS)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;内置函数&lt;code&gt;delpaths&lt;/code&gt;设置&lt;code&gt;PATHS&lt;/code&gt;in &lt;code&gt;.&lt;/code&gt;。 &lt;code&gt;PATHS&lt;/code&gt;必须是路径数组，其中每个路径都是字符串和数字的数组。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;to_entries,from_entries,with_entries&quot;&gt;
&lt;h3&gt;&lt;code&gt;to_entries&lt;/code&gt;, &lt;code&gt;from_entries&lt;/code&gt;,&lt;code&gt;with_entries&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;这些函数在对象和键值对数组之间进行转换。如果&lt;code&gt;to_entries&lt;/code&gt;传递了一个对象，那么对于&lt;code&gt;k: v&lt;/code&gt;输入中的每个条目，输出数组包括&lt;code&gt;{&quot;key&quot;: k, &quot;value&quot;: v}&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;from_entries&lt;/code&gt;进行相反的转换，并且 &lt;code&gt;with_entries(foo)&lt;/code&gt;是 的简写&lt;code&gt;to_entries | map(foo) | from_entries&lt;/code&gt;，用于对对象的所有键和值进行某些操作。&lt;code&gt;from_entries&lt;/code&gt;接受键、键、名称、名称、值和值作为键。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;select(boolean_expression)&quot;&gt;
&lt;h3&gt;&lt;code&gt;select(boolean_expression)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;如果对该输入返回 true，则该函数&lt;code&gt;select(foo)&lt;/code&gt;将产生其输入不变 &lt;code&gt;foo&lt;/code&gt;，否则不产生任何输出。&lt;/p&gt;
&lt;p&gt;它对过滤列表很有用：&lt;code&gt;[1,2,3] | map(select(. &amp;gt;= 2))&lt;/code&gt; 会给你&lt;code&gt;[2,3]&lt;/code&gt;.&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;arrays,objects,iterables,booleans,numbers,normals,finites,strings,nulls,values,scalars&quot;&gt;
&lt;h3&gt;&lt;code&gt;arrays&lt;/code&gt;, &lt;code&gt;objects&lt;/code&gt;, &lt;code&gt;iterables&lt;/code&gt;, &lt;code&gt;booleans&lt;/code&gt;, &lt;code&gt;numbers&lt;/code&gt;, &lt;code&gt;normals&lt;/code&gt;, &lt;code&gt;finites&lt;/code&gt;, &lt;code&gt;strings&lt;/code&gt;, &lt;code&gt;nulls&lt;/code&gt;, &lt;code&gt;values&lt;/code&gt;,&lt;code&gt;scalars&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;这些内置函数分别只选择数组、对象、可迭代对象（数组或对象）、布尔值、数字、普通数、有限数、字符串、空值、非空值和非可迭代值的输入。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;empty&quot;&gt;
&lt;h3&gt;&lt;code&gt;empty&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;empty&lt;/code&gt;不返回任何结果。一个都没有。甚至没有&lt;code&gt;null&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;有时它很有用。你会知道你是否需要它:)&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;error(message)&quot;&gt;
&lt;h3&gt;&lt;code&gt;error(message)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;产生错误，就像&lt;code&gt;.a&lt;/code&gt;应用于 null 和对象以外的值一样，但将给定的消息作为错误的值。可以使用 try/catch 捕获错误；见下文。&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;halt&quot;&gt;
&lt;h3&gt;&lt;code&gt;halt&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;停止 jq 程序，不再输出。jq 将以退出状态退出&lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;halt_error,halt_error(exit_code)&quot;&gt;
&lt;h3&gt;&lt;code&gt;halt_error&lt;/code&gt;,&lt;code&gt;halt_error(exit_code)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;停止 jq 程序，不再输出。输入将&lt;code&gt;stderr&lt;/code&gt;作为原始输出（即字符串没有双引号）打印，没有任何装饰，甚至没有换行符。&lt;/p&gt;
&lt;p&gt;给定的&lt;code&gt;exit_code&lt;/code&gt;（默认为&lt;code&gt;5&lt;/code&gt;）将是 jq 的退出状态。&lt;/p&gt;
&lt;p&gt;例如，&lt;code&gt;&quot;Error: somthing went wrong\n&quot;|halt_error(1)&lt;/code&gt;。&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;$__loc__&quot;&gt;
&lt;h3&gt;&lt;code&gt;$__loc__&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;生成一个带有“file”键和“line”键的对象，其中&lt;code&gt;$__loc__&lt;/code&gt;出现的文件名和行号作为值。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;paths,paths(node_filter),leaf_paths&quot;&gt;
&lt;h3&gt;&lt;code&gt;paths&lt;/code&gt;, &lt;code&gt;paths(node_filter)&lt;/code&gt;,&lt;code&gt;leaf_paths&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;paths&lt;/code&gt;输出其输入中所有元素的路径（除了它不输出空列表，表示 . 本身）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;paths(f)&lt;/code&gt;输出任何&lt;code&gt;f&lt;/code&gt;为真值的路径。也就是说，&lt;code&gt;paths(numbers)&lt;/code&gt;输出所有数值的路径。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;leaf_paths&lt;/code&gt;是&lt;code&gt;paths(scalars)&lt;/code&gt;;的别名 &lt;code&gt;leaf_paths&lt;/code&gt;已 &lt;em&gt;弃用&lt;/em&gt;，将在下一个主要版本中删除。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;add&quot;&gt;
&lt;h3&gt;&lt;code&gt;add&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;过滤器&lt;code&gt;add&lt;/code&gt;将一个数组作为输入，并将数组的元素加在一起作为输出。这可能意味着求和、连接或合并，具体取决于输入数组元素的类型 - 规则与运算符的规则相同&lt;code&gt;+&lt;/code&gt;（如上所述）。&lt;/p&gt;
&lt;p&gt;如果输入是空数组，则&lt;code&gt;add&lt;/code&gt;返回&lt;code&gt;null&lt;/code&gt;。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;any,any(condition),any(generator;condition)&quot;&gt;
&lt;h3&gt;&lt;code&gt;any&lt;/code&gt;, &lt;code&gt;any(condition)&lt;/code&gt;,&lt;code&gt;any(generator; condition)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;过滤器&lt;code&gt;any&lt;/code&gt;将布尔值数组作为输入，&lt;code&gt;true&lt;/code&gt;如果数组的任何元素为 ，则将其作为输出&lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果输入是空数组，则&lt;code&gt;any&lt;/code&gt;返回&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;该&lt;code&gt;any(condition)&lt;/code&gt;表单将给定条件应用于输入数组的元素。&lt;/p&gt;
&lt;p&gt;该&lt;code&gt;any(generator; condition)&lt;/code&gt;表格将给定条件应用于给定生成器的所有输出。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;all,all(condition),all(generator;condition)&quot;&gt;
&lt;h3&gt;&lt;code&gt;all&lt;/code&gt;, &lt;code&gt;all(condition)&lt;/code&gt;,&lt;code&gt;all(generator; condition)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;过滤器&lt;code&gt;all&lt;/code&gt;将一个布尔值数组作为输入，&lt;code&gt;true&lt;/code&gt;如果数组的所有元素都是 ，则将其作为输出&lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;该&lt;code&gt;all(condition)&lt;/code&gt;表单将给定条件应用于输入数组的元素。&lt;/p&gt;
&lt;p&gt;该&lt;code&gt;all(generator; condition)&lt;/code&gt;表格将给定条件应用于给定生成器的所有输出。&lt;/p&gt;
&lt;p&gt;如果输入是空数组，则&lt;code&gt;all&lt;/code&gt;返回&lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;flatten,flatten(depth)&quot;&gt;
&lt;h3&gt;&lt;code&gt;flatten&lt;/code&gt;,&lt;code&gt;flatten(depth)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;过滤器&lt;code&gt;flatten&lt;/code&gt;将嵌套数组的数组作为输入，并生成一个平面数组，其中原始数组中的所有数组都已被其值递归替换。您可以将参数传递给它以指定要展平的嵌套级别。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;flatten(2)&lt;/code&gt;就像&lt;code&gt;flatten&lt;/code&gt;，但只有两个级别的深度。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;range(upto),range(from;upto)range(from;upto;by)&quot;&gt;
&lt;h3&gt;&lt;code&gt;range(upto)&lt;/code&gt;,&lt;code&gt;range(from;upto)&lt;/code&gt; &lt;code&gt;range(from;upto;by)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;该&lt;code&gt;range&lt;/code&gt;函数产生一系列数字。&lt;code&gt;range(4;10)&lt;/code&gt; 产生 6 个数字，从 4（包括）到 10（不包括）。这些数字作为单独的输出产生。用于&lt;code&gt;[range(4;10)]&lt;/code&gt;将范围作为数组获取。&lt;/p&gt;
&lt;p&gt;one 参数形式生成从 0 到给定数字的数字，增量为 1。&lt;/p&gt;
&lt;p&gt;两个参数形式生成从&lt;code&gt;from&lt;/code&gt;到&lt;code&gt;upto&lt;/code&gt; 以 1 为增量的数字。&lt;/p&gt;
&lt;p&gt;三自变量形式生成&lt;code&gt;from&lt;/code&gt;以&lt;code&gt;upto&lt;/code&gt; 为增量的数字&lt;code&gt;by&lt;/code&gt;。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;floor&quot;&gt;
&lt;h3&gt;&lt;code&gt;floor&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;该&lt;code&gt;floor&lt;/code&gt;函数返回其数字输入的下限。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;sqrt&quot;&gt;
&lt;h3&gt;&lt;code&gt;sqrt&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;该&lt;code&gt;sqrt&lt;/code&gt;函数返回其数字输入的平方根。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;tonumber&quot;&gt;
&lt;h3&gt;&lt;code&gt;tonumber&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;该&lt;code&gt;tonumber&lt;/code&gt;函数将其输入解析为数字。它会将格式正确的字符串转换为等效的数字，不理会数字，并在所有其他输入上出错。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;tostring&quot;&gt;
&lt;h3&gt;&lt;code&gt;tostring&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;该&lt;code&gt;tostring&lt;/code&gt;函数将其输入打印为字符串。字符串保持不变，所有其他值都是 JSON 编码的。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;type&quot;&gt;
&lt;h3&gt;&lt;code&gt;type&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;该&lt;code&gt;type&lt;/code&gt;函数将其参数的类型作为字符串返回，它是 null、布尔值、数字、字符串、数组或对象之一。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;infinite,nan,isinfinite,isnan,isfinite,isnormal&quot;&gt;
&lt;h3&gt;&lt;code&gt;infinite&lt;/code&gt;, &lt;code&gt;nan&lt;/code&gt;, &lt;code&gt;isinfinite&lt;/code&gt;, &lt;code&gt;isnan&lt;/code&gt;, &lt;code&gt;isfinite&lt;/code&gt;,&lt;code&gt;isnormal&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;一些算术运算可以产生无穷大和“非数字”（NaN）值。 如果其输入是无限的，则&lt;code&gt;isinfinite&lt;/code&gt;内置函数返回。&lt;code&gt;true&lt;/code&gt;如果其 输入是 NaN ，则&lt;code&gt;isnan&lt;/code&gt;内置函数返回。内置函数返回一个正无穷大值&lt;code&gt;true&lt;/code&gt;。内置函数返回一个 NaN &lt;code&gt;infinite&lt;/code&gt;。&lt;code&gt;nan&lt;/code&gt;如果其&lt;code&gt;isnormal&lt;/code&gt;输入是正常数字，则内置函数返回 true。&lt;/p&gt;
&lt;p&gt;请注意，除以零会引发错误。&lt;/p&gt;
&lt;p&gt;目前，大多数在无穷大、NaN 和次正规数上进行的算术运算都不会引发错误。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;sort,sort_by(path_expression)&quot;&gt;
&lt;h3&gt;&lt;code&gt;sort, sort_by(path_expression)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;这些&lt;code&gt;sort&lt;/code&gt;函数对其输入进行排序，该输入必须是一个数组。值按以下顺序排序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;null&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;false&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;true&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;数字&lt;/li&gt;
&lt;li&gt;字符串，按字母顺序（按 unicode 代码点值）&lt;/li&gt;
&lt;li&gt;数组，按词法顺序&lt;/li&gt;
&lt;li&gt;对象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对象的排序有点复杂：首先通过比较它们的键集（作为排序顺序的数组）来比较它们，如果它们的键相等，则逐个键比较值。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sort&lt;/code&gt;可用于按对象的特定字段或应用任何 jq 过滤器进行排序。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sort_by(foo)&lt;/code&gt;通过比较每个元素的结果来比较两个元素 &lt;code&gt;foo&lt;/code&gt;。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;group_by(path_expression)&quot;&gt;
&lt;h3&gt;&lt;code&gt;group_by(path_expression)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;group_by(.foo)&lt;/code&gt;将数组作为输入，将具有相同&lt;code&gt;.foo&lt;/code&gt;字段的元素分组到单独的数组中，并将所有这些数组生成为更大数组的元素，并按&lt;code&gt;.foo&lt;/code&gt;字段的值排序。&lt;/p&gt;
&lt;p&gt;任何 jq 表达式，不仅仅是一个字段访问，都可以用来代替&lt;code&gt;.foo&lt;/code&gt;. &lt;code&gt;sort&lt;/code&gt;排序顺序与上面函数中描述的相同。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;min,max,min_by(path_exp),max_by(path_exp)&quot;&gt;
&lt;h3&gt;&lt;code&gt;min&lt;/code&gt;, &lt;code&gt;max&lt;/code&gt;, &lt;code&gt;min_by(path_exp)&lt;/code&gt;,&lt;code&gt;max_by(path_exp)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;查找输入数组的最小或最大元素。&lt;/p&gt;
&lt;p&gt;和函数允许您指定要检查的特定字段或属性，例如 &lt;code&gt;min_by(path_exp)&lt;/code&gt;查找具有最小字段的对象。&lt;code&gt;max_by(path_exp)&lt;/code&gt;&lt;code&gt;min_by(.foo)&lt;/code&gt;&lt;code&gt;foo&lt;/code&gt;&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;unique,unique_by(path_exp)&quot;&gt;
&lt;h3&gt;&lt;code&gt;unique&lt;/code&gt;,&lt;code&gt;unique_by(path_exp)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;该&lt;code&gt;unique&lt;/code&gt;函数将一个数组作为输入，并按排序顺序生成一个包含相同元素的数组，并删除重复项。&lt;/p&gt;
&lt;p&gt;对于通过应用参数获得的每个值，该&lt;code&gt;unique_by(path_exp)&lt;/code&gt;函数将只保留一个元素。可以将其视为通过从&lt;code&gt;group&lt;/code&gt;.&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;reverse&quot;&gt;
&lt;h3&gt;&lt;code&gt;reverse&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;此函数反转数组。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;contains(element)&quot;&gt;
&lt;h3&gt;&lt;code&gt;contains(element)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;contains(b)&lt;/code&gt;如果 b 完全包含在输入中，则过滤器将产生 true。如果 B 是 A 的子字符串，则字符串 B 包含在字符串 A 中。如果 B 中的所有元素都包含在 A 中的任何元素中，则数组 B 包含在数组 A 中。如果所有元素都包含在对象 B 中，则对象 B 包含在对象 A 中B 中的值包含在具有相同键的 A 中的值中。如果所有其他类型相等，则假定它们相互包含。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;indices(s)&quot;&gt;
&lt;h3&gt;&lt;code&gt;indices(s)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;输出一个数组，其中包含&lt;code&gt;.&lt;/code&gt;where的索引&lt;code&gt;s&lt;/code&gt; 。输入可能是一个数组，在这种情况下，如果&lt;code&gt;s&lt;/code&gt;是一个数组，那么索引输出将是所有元素&lt;code&gt;.&lt;/code&gt;匹配的那些&lt;code&gt;s&lt;/code&gt;。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;index(s),rindex(s)&quot;&gt;
&lt;h3&gt;&lt;code&gt;index(s)&lt;/code&gt;,&lt;code&gt;rindex(s)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;index&lt;/code&gt;输出输入中第一个 ( ) 或最后一个 ( &lt;code&gt;rindex&lt;/code&gt;) 出现的索引&lt;code&gt;s&lt;/code&gt;。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;inside&quot;&gt;
&lt;h3&gt;&lt;code&gt;inside&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;inside(b)&lt;/code&gt;如果输入完全包含在 b 中，则过滤器将产生 true。它本质上是&lt;code&gt;contains&lt;/code&gt;.&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;startswith(str)&quot;&gt;
&lt;h3&gt;&lt;code&gt;startswith(str)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;输出&lt;code&gt;true&lt;/code&gt;如果。从给定的字符串参数开始。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;endswith(str)&quot;&gt;
&lt;h3&gt;&lt;code&gt;endswith(str)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;输出&lt;code&gt;true&lt;/code&gt;如果。以给定的字符串参数结束。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;combinations,combinations(n)&quot;&gt;
&lt;h3&gt;&lt;code&gt;combinations&lt;/code&gt;,&lt;code&gt;combinations(n)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;输出输入数组中数组元素的所有组合。如果给定一个参数&lt;code&gt;n&lt;/code&gt;，它会输出&lt;code&gt;n&lt;/code&gt;输入数组的所有重复组合。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;ltrimstr(str)&quot;&gt;
&lt;h3&gt;&lt;code&gt;ltrimstr(str)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;如果它以它开头，则输出它的输入并删除给定的前缀字符串。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;rtrimstr(str)&quot;&gt;
&lt;h3&gt;&lt;code&gt;rtrimstr(str)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;如果它以它结尾，则输出它的输入并删除给定的后缀字符串。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;explode&quot;&gt;
&lt;h3&gt;&lt;code&gt;explode&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;将输入字符串转换为字符串代码点编号的数组。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;implode&quot;&gt;
&lt;h3&gt;&lt;code&gt;implode&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;爆炸的反面。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;split(str)&quot;&gt;
&lt;h3&gt;&lt;code&gt;split(str)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;在分隔符参数上拆分输入字符串。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;join(str)&quot;&gt;
&lt;h3&gt;&lt;code&gt;join(str)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;使用参数作为分隔符连接作为输入给定的元素数组。它是&lt;code&gt;split&lt;/code&gt;: 的倒数，也就是说，&lt;code&gt;split(&quot;foo&quot;) | join(&quot;foo&quot;)&lt;/code&gt;在任何输入字符串上运行都会返回所述输入字符串。&lt;/p&gt;
&lt;p&gt;输入中的数字和布尔值被转换为字符串。Null 值被视为空字符串。不支持输入中的数组和对象。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;ascii_downcase,ascii_upcase&quot;&gt;
&lt;h3&gt;&lt;code&gt;ascii_downcase&lt;/code&gt;,&lt;code&gt;ascii_upcase&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;发出输入字符串的副本，并将其字母字符（az 和 AZ）转换为指定的大小写。&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;while(cond;update)&quot;&gt;
&lt;h3&gt;&lt;code&gt;while(cond; update)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;该&lt;code&gt;while(cond; update)&lt;/code&gt;功能允许您重复应用更新，&lt;code&gt;.&lt;/code&gt;直到&lt;code&gt;cond&lt;/code&gt;为假。&lt;/p&gt;
&lt;p&gt;请注意，它&lt;code&gt;while(cond; update)&lt;/code&gt;在内部定义为递归 jq 函数。如果每个输入最多产生一个输出，则内部的递归调用&lt;code&gt;while&lt;/code&gt;不会消耗额外的内存。&lt;code&gt;update&lt;/code&gt;请参阅下面的高级主题。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;until(cond;next)&quot;&gt;
&lt;h3&gt;&lt;code&gt;until(cond; next)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;该&lt;code&gt;until(cond; next)&lt;/code&gt;函数允许您重复应用表达式&lt;code&gt;next&lt;/code&gt;，从最初到&lt;code&gt;.&lt;/code&gt;然后到它自己的输出，直到&lt;code&gt;cond&lt;/code&gt;为真。例如，这可用于实现阶乘函数（见下文）。&lt;/p&gt;
&lt;p&gt;请注意，它&lt;code&gt;until(cond; next)&lt;/code&gt;在内部定义为递归 jq 函数。如果每个输入最多产生一个输出，则内部的递归调用&lt;code&gt;until()&lt;/code&gt;不会消耗额外的内存。&lt;code&gt;next&lt;/code&gt;请参阅下面的高级主题。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;recurse(f),recurse,recurse(f;condition),recurse_down&quot;&gt;
&lt;h3&gt;&lt;code&gt;recurse(f)&lt;/code&gt;, &lt;code&gt;recurse&lt;/code&gt;, &lt;code&gt;recurse(f; condition)&lt;/code&gt;,&lt;code&gt;recurse_down&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;该&lt;code&gt;recurse(f)&lt;/code&gt;功能允许您搜索递归结构，并从各个级别提取有趣的数据。假设您的输入代表一个文件系统：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;{&quot;name&quot;: &quot;/&quot;, &quot;children&quot;: [
  {&quot;name&quot;: &quot;/bin&quot;, &quot;children&quot;: [
    {&quot;name&quot;: &quot;/bin/ls&quot;, &quot;children&quot;: []},
    {&quot;name&quot;: &quot;/bin/sh&quot;, &quot;children&quot;: []}]},
  {&quot;name&quot;: &quot;/home&quot;, &quot;children&quot;: [
    {&quot;name&quot;: &quot;/home/stephen&quot;, &quot;children&quot;: [
      {&quot;name&quot;: &quot;/home/stephen/jq&quot;, &quot;children&quot;: []}]}]}]}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在假设您要提取所有存在的文件名。您需要检索&lt;code&gt;.name&lt;/code&gt;、&lt;code&gt;.children[].name&lt;/code&gt;、 &lt;code&gt;.children[].children[].name&lt;/code&gt;等。你可以这样做：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;recurse(.children[]) | .name&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不带参数调用时，&lt;code&gt;recurse&lt;/code&gt;等效于 &lt;code&gt;recurse(.[]?)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;recurse(f)&lt;/code&gt;与递归深度相同&lt;code&gt;recurse(f; . != null)&lt;/code&gt;，可以在不考虑递归深度的情况下使用。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;recurse(f; condition)&lt;/code&gt;是一个以发射 开始的生成器。然后依次发出 .|f, .|f|f, .|f|f|f, ... 只要计算值满足条件。例如，要生成所有整数，至少原则上可以写成&lt;code&gt;recurse(.+1; true)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;由于遗留原因，作为不带参数&lt;code&gt;recurse_down&lt;/code&gt;调用的别名存在。&lt;code&gt;recurse&lt;/code&gt;此别名已被 &lt;em&gt;弃用&lt;/em&gt;，将在下一个主要版本中删除。&lt;/p&gt;
&lt;p&gt;只要每个输入最多产生一个输出，递归调用&lt;code&gt;recurse&lt;/code&gt;就不会消耗额外的内存。&lt;code&gt;f&lt;/code&gt;&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;walk(f)&quot;&gt;
&lt;h3&gt;&lt;code&gt;walk(f)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;该&lt;code&gt;walk(f)&lt;/code&gt;函数递归地应用于输入实体的每个组件。当遇到一个数组时，f首先应用于其元素，然后应用于数组本身；当遇到一个对象时，首先将 f 应用于所有值，然后再应用于该对象。在实践中，f 通常会测试其输入的类型，如下面的示例所示。第一个示例强调了在处理数组本身之前处理数组元素的有用性。第二个示例显示了如何考虑更改输入中所有对象的所有键。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;$ENV,env&quot;&gt;
&lt;h3&gt;&lt;code&gt;$ENV&lt;/code&gt;,&lt;code&gt;env&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;$ENV&lt;/code&gt;是一个对象，表示 jq 程序启动时设置的环境变量。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;env&lt;/code&gt;输出一个代表 jq 当前环境的对象。&lt;/p&gt;
&lt;p&gt;目前没有用于设置环境变量的内置函数。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;transpose&quot;&gt;
&lt;h3&gt;&lt;code&gt;transpose&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;转置一个可能锯齿状的矩阵（数组的数组）。行用空值填充，因此结果始终为矩形。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;bsearch(x)&quot;&gt;
&lt;h3&gt;&lt;code&gt;bsearch(x)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;bsearch(x) 在输入数组中对 x 进行二分搜索。如果输入已排序并包含 x，则 bsearch(x) 将返回其在数组中的索引；否则，如果数组已排序，它将返回 (-1 - ix)，其中 ix 是一个插入点，因此在将 x 插入到 ix 后，该数组仍将被排序。如果数组未排序，bsearch(x) 将返回一个可能不感兴趣的整数。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;Stringinterpolation-\(foo)&quot;&gt;
&lt;h3&gt;字符串插值 -&lt;code&gt;\(foo)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;在字符串中，您可以在反斜杠后的括号内放置表达式。无论表达式返回什么，都将被插入到字符串中。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;Convertto/fromJSON&quot;&gt;
&lt;h3&gt;转换为/从 JSON&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;tojson&lt;/code&gt;和builtins 分别将值转储为 JSON 文本或将&lt;code&gt;fromjson&lt;/code&gt;JSON 文本解析为值。内置 tojson 与 tostring 的不同之处在于 tostring 返回未修改的字符串，而 tojson 将字符串编码为 JSON 字符串。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;Formatstringsandescaping&quot;&gt;
&lt;h3&gt;格式化字符串和转义&lt;/h3&gt;
&lt;p&gt;该&lt;code&gt;@foo&lt;/code&gt;语法用于格式化和转义字符串，这对于构建 URL、HTML 或 XML 等语言的文档等很有用。&lt;code&gt;@foo&lt;/code&gt;可以单独用作过滤器，可能的转义是：&lt;/p&gt;

&lt;p&gt;调用&lt;code&gt;tostring&lt;/code&gt;，请参阅该函数以获取详细信息。&lt;/p&gt;

&lt;p&gt;将输入序列化为 JSON。&lt;/p&gt;

&lt;p&gt;通过将字符映射 &lt;code&gt;&amp;lt;&amp;gt;&amp;amp;&#x27;&quot;&lt;/code&gt;到它们的实体等价物&lt;code&gt;&amp;amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;amp;amp;&lt;/code&gt;, &lt;code&gt;&amp;amp;apos;&lt;/code&gt;,来应用 HTML/XML 转义&lt;code&gt;&amp;amp;quot;&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;通过将所有保留的 URI 字符映射到一个&lt;code&gt;%XX&lt;/code&gt;序列来应用百分比编码。&lt;/p&gt;

&lt;p&gt;输入必须是一个数组，并将其呈现为 CSV，字符串带有双引号，引号通过重复转义。&lt;/p&gt;

&lt;p&gt;输入必须是一个数组，并且呈现为 TSV（制表符分隔值）。每个输入数组将打印为一行。字段由单个选项卡 (ascii &lt;code&gt;0x09&lt;/code&gt;) 分隔。输入字符换行 (ascii &lt;code&gt;0x0a&lt;/code&gt;)、回车 (ascii &lt;code&gt;0x0d&lt;/code&gt;)、制表符 (ascii &lt;code&gt;0x09&lt;/code&gt;) 和反斜杠 (ascii &lt;code&gt;0x5c&lt;/code&gt;) 将分别输出为转义 序列&lt;code&gt;\n&lt;/code&gt;, &lt;code&gt;\r&lt;/code&gt;, 。&lt;code&gt;\t&lt;/code&gt;&lt;code&gt;\\&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;输入经过转义，适合在 POSIX shell 的命令行中使用。如果输入是数组，则输出将是一系列以空格分隔的字符串。&lt;/p&gt;

&lt;p&gt;输入将转换为 RFC 4648 指定的 base64。&lt;/p&gt;

&lt;p&gt;, 的逆&lt;code&gt;@base64&lt;/code&gt;输入按照 RFC 4648 的规定进行解码。 注意\：如果解码的字符串不是 UTF-8，则结果未定义。&lt;/p&gt;
&lt;p&gt;这种语法可以以一种有用的方式与字符串插值相结合。您可以在&lt;code&gt;@foo&lt;/code&gt;标记后面加上字符串文字。字符串文字的内容&lt;em&gt;不会&lt;/em&gt;被转义。但是，在该字符串文字内进行的所有插值都将被转义。例如，&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;@uri &quot;https://www.google.com/search?q=\(.search)&quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将为输入产生以下输出 &lt;code&gt;{&quot;search&quot;:&quot;what is jq?&quot;}&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;&quot;https://www.google.com/search?q=what%20is%20jq%3F&quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;请注意，URL 中的斜杠、问号等不会被转义，因为它们是字符串文字的一部分。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;Dates&quot;&gt;
&lt;h3&gt;日期&lt;/h3&gt;
&lt;p&gt;jq 提供了一些基本的日期处理功能，以及一些高级和低级的内置函数。在所有情况下，这些内置函数都专门处理 UTC 时间。&lt;/p&gt;
&lt;p&gt;内置函数将 ISO 8601 格式的&lt;code&gt;fromdateiso8601&lt;/code&gt;日期时间解析为自 Unix 纪元 (1970-01-01T00:00:00Z) 以来的秒数。&lt;code&gt;todateiso8601&lt;/code&gt;内置执行相反的操作。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fromdate&lt;/code&gt;内置解析日期时间字符串。目前 &lt;code&gt;fromdate&lt;/code&gt;仅支持 ISO 8601 日期时间字符串，但未来它将尝试解析更多格式的日期时间字符串。&lt;/p&gt;
&lt;p&gt;内置函数&lt;code&gt;todate&lt;/code&gt;是.&lt;code&gt;todateiso8601&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;now&lt;/code&gt;内置输出当前时间，以 Unix 纪元以来的秒数为单位。&lt;/p&gt;
&lt;p&gt;还提供了 C 库时间函数的低级 jq 接口：&lt;code&gt;strptime&lt;/code&gt;、&lt;code&gt;strftime&lt;/code&gt;、&lt;code&gt;strflocaltime&lt;/code&gt;、 &lt;code&gt;mktime&lt;/code&gt;、&lt;code&gt;gmtime&lt;/code&gt;和&lt;code&gt;localtime&lt;/code&gt;. &lt;code&gt;strptime&lt;/code&gt;有关和使用的格式字符串，请参阅主机操作系统的文档&lt;code&gt;strftime&lt;/code&gt;。注意：这些不一定是 jq 中的稳定接口，尤其是它们的本地化功能。&lt;/p&gt;
&lt;p&gt;内置函数消耗自 Unix 纪元以来的&lt;code&gt;gmtime&lt;/code&gt;秒数，并输出 Greenwhich Meridian 时间的“分解时间”表示，作为表示（按此顺序）的数字数组：年、月（从零开始）、日期月份（从 1 开始）、一天中的小时、小时中的分钟、分钟中的秒、一周中的一天和一年中的一天——除非另有说明，否则都是从 1 开始的。对于 1900 年 3 月 1 日之前或 2099 年 12 月 31 日之后的日期，某些系统上的星期数可能是错误的。&lt;/p&gt;
&lt;p&gt;内置函数的&lt;code&gt;localtime&lt;/code&gt;工作方式与&lt;code&gt;gmtime&lt;/code&gt;内置函数类似，但使用本地时区设置。&lt;/p&gt;
&lt;p&gt;内置使用和输出的时间的&lt;code&gt;mktime&lt;/code&gt;“分解时间”表示。&lt;code&gt;gmtime&lt;/code&gt;&lt;code&gt;strptime&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;内置解析与参数匹配的&lt;code&gt;strptime(fmt)&lt;/code&gt;输入字符串 &lt;code&gt;fmt&lt;/code&gt;。&lt;code&gt;gmtime&lt;/code&gt;输出是由 消耗和输出的“分解时间”表示&lt;code&gt;mktime&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;内置使用&lt;code&gt;strftime(fmt)&lt;/code&gt;给定格式格式化时间（GMT）。执行&lt;code&gt;strflocaltime&lt;/code&gt;相同的操作，但使用本地时区设置。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;strptime&lt;/code&gt;和的格式字符串&lt;code&gt;strftime&lt;/code&gt;在典型的 C 库文档中进行了描述。ISO 8601 日期时间的格式字符串是&lt;code&gt;&quot;%Y-%m-%dT%H:%M:%SZ&quot;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;jq 在某些系统上可能不支持部分或全部此日期功能。特别是，macOS 不支持&lt;code&gt;%u&lt;/code&gt;and&lt;code&gt;%j&lt;/code&gt;说明符 。&lt;code&gt;strptime(fmt)&lt;/code&gt;&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;SQL-StyleOperators&quot;&gt;
&lt;h3&gt;SQL 风格的运算符&lt;/h3&gt;
&lt;p&gt;jq 提供了一些 SQL 风格的运算符。&lt;/p&gt;

&lt;p&gt;此内置函数生成一个对象，其键由应用于给定流中每个值的给定索引表达式计算。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加入（$idx；流；idx_expr；join_expr）：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此内置函数将给定流中的值连接到给定索引。通过将给定的索引表达式应用于给定流中的每个值来计算索引的键。流中的值和索引中的相应值的数组被馈送到给定的连接表达式以产生每个结果。&lt;/p&gt;

&lt;p&gt;与 相同&lt;code&gt;JOIN($idx; stream; idx_expr; .)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;这个内置函数将输入连接&lt;code&gt;.&lt;/code&gt;到给定的索引，应用给定的索引表达式&lt;code&gt;.&lt;/code&gt;来计算索引键。加入操作如上所述。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;true&lt;/code&gt;如果出现在给定的流中，则此内置输出&lt;code&gt;.&lt;/code&gt;，否则输出&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;如果源流中的任何值出现在第二个流中，则此内置输出&lt;code&gt;true&lt;/code&gt;，否则输出&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;builtins&quot;&gt;
&lt;h3&gt;&lt;code&gt;builtins&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;返回格式为 的所有内置函数的列表&lt;code&gt;name/arity&lt;/code&gt;。由于具有相同名称但不同数量的函数被认为是单独的函数，因此&lt;code&gt;all/0&lt;/code&gt;,&lt;code&gt;all/1&lt;/code&gt;和&lt;code&gt;all/2&lt;/code&gt;都将出现在列表中。&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id=&quot;Advancedfeatures&quot;&gt;
&lt;h2&gt;高级功能&lt;/h2&gt;
&lt;p&gt;变量在大多数编程语言中是绝对必要的，但它们在 jq 中被归为“高级特性”。&lt;/p&gt;
&lt;p&gt;在大多数语言中，变量是传递数据的唯一方式。如果你计算一个值，并且你想多次使用它，你需要将它存储在一个变量中。要将值传递给程序的另一部分，您需要程序的该部分定义一个变量（作为函数参数、对象成员或其他）来放置数据。&lt;/p&gt;
&lt;p&gt;也可以在 jq 中定义函数，尽管这是一个最大用途是定义 jq 的标准库的功能（许多 jq 函数，例如&lt;code&gt;map&lt;/code&gt;和&lt;code&gt;find&lt;/code&gt;实际上是用 jq 编写的）。&lt;/p&gt;
&lt;p&gt;jq 有归约运算符，它们非常强大但有点棘手。同样，这些主要在内部使用，以定义 jq 标准库的一些有用位。&lt;/p&gt;
&lt;p&gt;一开始可能并不明显，但 jq 是关于生成器的（是的，这在其他语言中很常见）。提供了一些实用程序来帮助处理生成器。&lt;/p&gt;
&lt;p&gt;一些最小的 I/O 支持（除了从标准输入读取 JSON 并将 JSON 写入标准输出）是可用的。&lt;/p&gt;
&lt;p&gt;最后，还有一个模块/库系统。&lt;/p&gt;
&lt;section id=&quot;Variable/SymbolicBindingOperator:...as$identifier|...&quot;&gt;
&lt;h3&gt;变量/符号绑定运算符：&lt;code&gt;... as $identifier | ...&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;在 jq 中，所有过滤器都有一个输入和一个输出，因此不需要手动管道将值从程序的一个部分传递到下一个部分。许多表达式，例如&lt;code&gt;a + b&lt;/code&gt;，将它们的输入传递给两个不同的子表达式（这里&lt;code&gt;a&lt;/code&gt;和&lt;code&gt;b&lt;/code&gt;都传递相同的输入），因此通常不需要使用变量来两次使用一个值。&lt;/p&gt;
&lt;p&gt;例如，在大多数语言中，计算一个数字数组的平均值需要一些变量——至少有一个变量来保存数组，可能每个元素或循环计数器都有一个变量。在 jq 中，它很简单&lt;code&gt;add / length&lt;/code&gt;-&lt;code&gt;add&lt;/code&gt;表达式被赋予数组并产生其总和，&lt;code&gt;length&lt;/code&gt;表达式被赋予数组并产生其长度。&lt;/p&gt;
&lt;p&gt;因此，通常有一种比定义变量更简洁的方法来解决 jq 中的大多数问题。尽管如此，有时它们确实使事情变得更容易，因此 jq 允许您使用&lt;code&gt;expression as $variable&lt;/code&gt;. 所有变量名都以&lt;code&gt;$&lt;/code&gt;. 这是数组平均示例的一个稍微丑陋的版本：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;length as $array_length | add / $array_length&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们需要一个更复杂的问题来找到使用变量实际上使我们的生活更轻松的情况。&lt;/p&gt;
&lt;p&gt;假设我们有一个博客文章数组，其中包含“作者”和“标题”字段，以及另一个用于将作者用户名映射到真实姓名的对象。我们的输入看起来像：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;{&quot;posts&quot;: [{&quot;title&quot;: &quot;Frist psot&quot;, &quot;author&quot;: &quot;anon&quot;},
           {&quot;title&quot;: &quot;A well-written article&quot;, &quot;author&quot;: &quot;person1&quot;}],
 &quot;realnames&quot;: {&quot;anon&quot;: &quot;Anonymous Coward&quot;,
               &quot;person1&quot;: &quot;Person McPherson&quot;}}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们希望生成包含真实姓名的作者字段的帖子，如下所示：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;{&quot;title&quot;: &quot;Frist psot&quot;, &quot;author&quot;: &quot;Anonymous Coward&quot;}
{&quot;title&quot;: &quot;A well-written article&quot;, &quot;author&quot;: &quot;Person McPherson&quot;}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们使用变量 $names 来存储 realnames 对象，以便稍后在查找作者用户名时引用它：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;.realnames as $names | .posts[] | {title, author: $names[.author]}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;表达式&lt;code&gt;exp as $x | ...&lt;/code&gt;意味着：对于表达式的每个值， &lt;code&gt;exp&lt;/code&gt;使用整个原始输入运行管道的其余部分，并&lt;code&gt;$x&lt;/code&gt;设置为该值。因此&lt;code&gt;as&lt;/code&gt;起到某种 foreach 循环的作用。&lt;/p&gt;
&lt;p&gt;就像&lt;code&gt;{foo}&lt;/code&gt;方便的写作方式一样，方便的写作方式也是&lt;code&gt;{foo: .foo}&lt;/code&gt;如此 。&lt;code&gt;{$foo}&lt;/code&gt;&lt;code&gt;{foo:$foo}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;as&lt;/code&gt;通过提供与输入结构匹配的模式（这称为“解构”），可以使用单个表达式声明多个变量：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;. as {realnames: $names, posts: [$first, $second]} | ...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数组模式中的变量声明（例如，&lt;code&gt;. as [$first, $second]&lt;/code&gt;）按顺序绑定到数组的元素，从索引零的元素开始。当数组模式元素的索引处没有值时，&lt;code&gt;null&lt;/code&gt;将绑定到该变量。&lt;/p&gt;
&lt;p&gt;变量的范围在定义它们的表达式的其余部分，所以&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;.realnames as $names | (.posts[] | {title, author: $names[.author]})&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;会工作，但是&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;(.realnames as $names | .posts[]) | {title, author: $names[.author]}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;惯于。&lt;/p&gt;
&lt;p&gt;对于编程语言理论家来说，更准确的说法是 jq 变量是词法范围的绑定。特别是没有办法改变绑定的值；只能设置一个具有相同名称的新绑定，但在旧绑定的位置不可见。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;DestructuringAlternativeOperator:?//&quot;&gt;
&lt;h3&gt;解构替代运算符：&lt;code&gt;?//&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;解构替代运算符提供了一种简洁的机制来解构可以采用多种形式之一的输入。&lt;/p&gt;
&lt;p&gt;假设我们有一个 API，它返回一个资源列表和与之关联的事件，我们想要获取每个资源的第一个事件的 user_id 和时间戳。如果资源有多个事件，API（已经笨拙地从 XML 转换）只会将事件包装在数组中：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;{&quot;resources&quot;: [{&quot;id&quot;: 1, &quot;kind&quot;: &quot;widget&quot;, &quot;events&quot;: {&quot;action&quot;: &quot;create&quot;, &quot;user_id&quot;: 1, &quot;ts&quot;: 13}},
               {&quot;id&quot;: 2, &quot;kind&quot;: &quot;widget&quot;, &quot;events&quot;: [{&quot;action&quot;: &quot;create&quot;, &quot;user_id&quot;: 1, &quot;ts&quot;: 14}, {&quot;action&quot;: &quot;destroy&quot;, &quot;user_id&quot;: 1, &quot;ts&quot;: 15}]}]}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以使用解构替代运算符来简单地处理这种结构变化：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;.resources[] as {$id, $kind, events: {$user_id, $ts}} ?// {$id, $kind, events: [{$user_id, $ts}]} | {$user_id, $kind, $id, $ts}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者，如果我们不确定输入是值数组还是对象：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;.[] as [$id, $kind, $user_id, $ts] ?// {$id, $kind, $user_id, $ts} | ...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;每个备选方案不需要定义所有相同的变量，但所有命名变量都可用于后续表达式。在成功的替代方案中不匹配的变量将是&lt;code&gt;null&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;.resources[] as {$id, $kind, events: {$user_id, $ts}} ?// {$id, $kind, events: [{$first_user_id, $first_ts}]} | {$user_id, $first_user_id, $kind, $id, $ts, $first_ts}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此外，如果后续表达式返回错误，则替代运算符将尝试尝试下一个绑定。在最终替代过程中发生的错误将被传递。&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;[[3]] | .[] as [$a] ?// [$b] | if $a != null then error(&quot;err: \($a)&quot;) else {$a,$b} end&lt;/code&gt;&lt;/pre&gt;

&lt;/section&gt;
&lt;section id=&quot;DefiningFunctions&quot;&gt;
&lt;h3&gt;定义函数&lt;/h3&gt;
&lt;p&gt;您可以使用“def”语法为过滤器命名：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;def increment: . + 1;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从那时起，&lt;code&gt;increment&lt;/code&gt;就可以像内置函数一样用作过滤器（实际上，这就是定义了多少个内置函数）。函数可以接受参数：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;def map(f): [.[] | f];&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参数作为&lt;em&gt;过滤器&lt;/em&gt;（没有参数的函数）传递，&lt;em&gt;而不是&lt;/em&gt;作为值传递。可以使用不同的输入多次引用相同的参数（这里&lt;code&gt;f&lt;/code&gt;针对输入数组的每个元素运行）。函数的参数更像回调而不是值参数。理解这一点很重要。考虑：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;def foo(f): f|f;
5|foo(.*2)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果将是 20，因为&lt;code&gt;f&lt;/code&gt;is &lt;code&gt;.*2&lt;/code&gt;，并且在第一次调用&lt;code&gt;f&lt;/code&gt; &lt;code&gt;.&lt;/code&gt;将是 5，第二次将是 10 (5 * 2)，所以结果将是 20。函数参数是过滤器，过滤器期望输入调用。&lt;/p&gt;
&lt;p&gt;如果你想要定义简单函数的值参数行为，你可以只使用一个变量：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;def addvalue(f): f as $f | map(. + $f);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者使用简写：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;def addvalue($f): ...;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;无论使用哪种定义，&lt;code&gt;addvalue(.foo)&lt;/code&gt;都会将当前输入的&lt;code&gt;.foo&lt;/code&gt;字段添加到数组的每个元素中。请注意，调用&lt;code&gt;addvalue(.[])&lt;/code&gt;将导致在调用站点&lt;code&gt;map(. + $f)&lt;/code&gt;的值中的每个值对部件进行一次评估。&lt;code&gt;.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;允许使用相同函数名的多个定义。对于相同数量的函数参数，每个重新定义都会替换先前的重新定义，但仅适用于重新定义之后的函数（或主程序）的引用。另请参阅下面有关范围界定的部分。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;Scoping&quot;&gt;
&lt;h3&gt;范围界定&lt;/h3&gt;
&lt;p&gt;jq 中有两种类型的符号：值绑定（又名“变量”）和函数。两者都是词法范围的，表达式只能引用已在它们“左侧”定义的符号。该规则的唯一例外是函数可以引用自身以便能够创建递归函数。&lt;/p&gt;
&lt;p&gt;例如，在下面的表达式中，有一个绑定在它的“右侧”可见&lt;code&gt;... | .*3 as $times_three | [. + $times_three] | ...&lt;/code&gt;，但在“左侧”不可见。现在考虑这个表达式&lt;code&gt;... | (.*3 as $times_three | [. + $times_three]) | ...&lt;/code&gt;：这里的绑定 在右括号之后&lt;code&gt;$times_three&lt;/code&gt;是&lt;em&gt;不&lt;/em&gt;可见的。&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;Reduce&quot;&gt;
&lt;h3&gt;减少&lt;/h3&gt;
&lt;p&gt;jq 中的&lt;code&gt;reduce&lt;/code&gt;语法允许您通过将表达式的所有结果累积成一个答案来组合它们。例如，我们将传递&lt;code&gt;[3,2,1]&lt;/code&gt;给这个表达式：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;reduce .[] as $item (0; . + $item)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于&lt;code&gt;.[]&lt;/code&gt;产生的每个结果，&lt;code&gt;. + $item&lt;/code&gt;运行以累积从 0 开始的运行总计。在此示例中，&lt;code&gt;.[]&lt;/code&gt;产生结果 3、2 和 1，因此效果类似于运行以下内容：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;0 | (3 as $item | . + $item) |
    (2 as $item | . + $item) |
    (1 as $item | . + $item)&lt;/code&gt;&lt;/pre&gt;

&lt;/section&gt;
&lt;section id=&quot;isempty(exp)&quot;&gt;
&lt;h3&gt;&lt;code&gt;isempty(exp)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;exp&lt;/code&gt;如果不产生输出，则返回 true ，否则返回 false。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;limit(n;exp)&quot;&gt;
&lt;h3&gt;&lt;code&gt;limit(n; exp)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;该&lt;code&gt;limit&lt;/code&gt;函数最多从 中提取&lt;code&gt;n&lt;/code&gt;输出&lt;code&gt;exp&lt;/code&gt;。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;first(expr),last(expr),nth(n;expr)&quot;&gt;
&lt;h3&gt;&lt;code&gt;first(expr)&lt;/code&gt;, &lt;code&gt;last(expr)&lt;/code&gt;,&lt;code&gt;nth(n; expr)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;first(expr)&lt;/code&gt;和函数分别从中&lt;code&gt;last(expr)&lt;/code&gt;提取第一个和最后一个值&lt;code&gt;expr&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;该&lt;code&gt;nth(n; expr)&lt;/code&gt;函数提取由 输出的第 n 个值 &lt;code&gt;expr&lt;/code&gt;。这可以定义为&lt;code&gt;def nth(n; expr): last(limit(n + 1; expr));&lt;/code&gt;。请注意，&lt;code&gt;nth(n; expr)&lt;/code&gt;不支持&lt;code&gt;n&lt;/code&gt;.&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;first,last,nth(n)&quot;&gt;
&lt;h3&gt;&lt;code&gt;first&lt;/code&gt;, &lt;code&gt;last&lt;/code&gt;,&lt;code&gt;nth(n)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;first&lt;/code&gt;and函数从位于的&lt;code&gt;last&lt;/code&gt;任何数组中提取第一个和最后一个值&lt;code&gt;.&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;该&lt;code&gt;nth(n)&lt;/code&gt;函数在 处提取任何数组的第 n 个值&lt;code&gt;.&lt;/code&gt;。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;foreach&quot;&gt;
&lt;h3&gt;&lt;code&gt;foreach&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;foreach&lt;/code&gt;语法类似于&lt;code&gt;reduce&lt;/code&gt;，但旨在允许构造&lt;code&gt;limit&lt;/code&gt;和生成中间结果的化简器（参见示例）。&lt;/p&gt;
&lt;p&gt;形式是&lt;code&gt;foreach EXP as $var (INIT; UPDATE; EXTRACT)&lt;/code&gt;。像&lt;code&gt;reduce&lt;/code&gt;,&lt;code&gt;INIT&lt;/code&gt;被评估一次以产生一个状态值，然后每个输出&lt;code&gt;EXP&lt;/code&gt;绑定到&lt;code&gt;$var&lt;/code&gt;,&lt;code&gt;UPDATE&lt;/code&gt; 被评估为&lt;code&gt;EXP&lt;/code&gt;具有当前状态和&lt;code&gt;$var&lt;/code&gt;可见的每个输出。输出的每个值都会&lt;code&gt;UPDATE&lt;/code&gt; 替换先前的状态。最后，&lt;code&gt;EXTRACT&lt;/code&gt;对每个新状态进行评估以提取 的输出&lt;code&gt;foreach&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这仅对构造&lt;code&gt;reduce&lt;/code&gt;- 和 - &lt;code&gt;limit&lt;/code&gt;类似的函数非常有用。但它更通用，因为它允许部分减少（参见下面的示例）。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;Recursion&quot;&gt;
&lt;h3&gt;递归&lt;/h3&gt;
&lt;p&gt;如上所述，&lt;code&gt;recurse&lt;/code&gt;使用递归，任何jq函数都可以递归。&lt;code&gt;while&lt;/code&gt;内置函数也以递归的方式实现。&lt;/p&gt;
&lt;p&gt;只要递归调用左侧的表达式输出其最后一个值，就会优化尾调用。实际上，这意味着递归调用左侧的表达式不应为每个输入生成多个输出。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;def recurse(f): def r: ., (f | select(. != null) | r); r;

def while(cond; update):
  def _while:
    if cond then ., (update | _while) else empty end;
  _while;

def repeat(exp):
  def _repeat:
    exp, _repeat;
  _repeat;&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;section id=&quot;Generatorsanditerators&quot;&gt;
&lt;h3&gt;生成器和迭代器&lt;/h3&gt;
&lt;p&gt;一些 jq 运算符和函数实际上是生成器，因为它们可以为每个输入生成零、一个或多个值，正如人们在其他具有生成器的编程语言中所期望的那样。例如，&lt;code&gt;.[]&lt;/code&gt; 生成其输入中的所有值（必须是数组或对象），&lt;code&gt;range(0; 10)&lt;/code&gt;生成 0 到 10 之间的整数，等等。&lt;/p&gt;
&lt;p&gt;甚至逗号运算符也是一个生成器，它首先生成由逗号左侧的表达式生成的值，然后对于其中的每一个，生成由逗号右侧的表达式生成的值。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;empty&lt;/code&gt;内置是产生零输出的生成器。&lt;code&gt;empty&lt;/code&gt;内置回溯到前面的生成器表达式。&lt;/p&gt;
&lt;p&gt;All jq functions can be generators just by using builtin generators. It is also possible to define new generators using only recursion and the comma operator. If the recursive call(s) is(are) &quot;in tail position&quot; then the generator will be efficient. In the example below the recursive call by &lt;code&gt;_range&lt;/code&gt; to itself is in tail position. The example shows off three advanced topics: tail recursion, generator construction, and sub-functions.&lt;/p&gt;

&lt;/section&gt;
&lt;/section&gt;
&lt;section id=&quot;Assignment&quot;&gt;
&lt;h2&gt;任务&lt;/h2&gt;
&lt;p&gt;jq 中的赋值工作与大多数编程语言中的工作方式略有不同。jq 不区分对某事物的引用和副本——两个对象或数组相等或不相等，没有任何进一步的“相同对象”或“不同对象”的概念。&lt;/p&gt;
&lt;p&gt;如果一个对象有两个字段，它们是数组&lt;code&gt;.foo&lt;/code&gt;和&lt;code&gt;.bar&lt;/code&gt;，并且你在 上附加了一些东西&lt;code&gt;.foo&lt;/code&gt;，那么&lt;code&gt;.bar&lt;/code&gt;即使你之前设置了 ，也不会变大&lt;code&gt;.bar = .foo&lt;/code&gt;。如果您习惯于使用 Python、Java、Ruby、Javascript 等语言进行编程，那么您可以将其想象为 jq 在执行分配之前对每个对象进行了完整的深度复制（出于性能考虑，它实际上并没有这样做，但这是一般的想法）。&lt;/p&gt;
&lt;p&gt;这意味着不可能在 jq 中构建循环值（例如第一个元素是自身的数组）。这是非常有意的，并确保 jq 程序可以生成的任何内容都可以用 JSON 表示。&lt;/p&gt;
&lt;p&gt;jq 中的所有赋值运算符在左侧（LHS）都有路径表达式。右侧 (RHS) 提供设置为由 LHS 路径表达式命名的路径的值。&lt;/p&gt;
&lt;p&gt;jq 中的值始终是不可变的。在内部，赋值通过使用归约来计算新的替换值，&lt;code&gt;.&lt;/code&gt;所有期望的赋值都应用于&lt;code&gt;.&lt;/code&gt;，然后输出修改后的值。这个可以说明这一点：&lt;code&gt;{a:{b:{c:1}}} | (.a.b|=3), .&lt;/code&gt;. 这将输出 &lt;code&gt;{&quot;a&quot;:{&quot;b&quot;:3}}&lt;/code&gt;，&lt;code&gt;{&quot;a&quot;:{&quot;b&quot;:{&quot;c&quot;:1}}}&lt;/code&gt;因为最后一个子表达式&lt;code&gt;.&lt;/code&gt;, 看到的是原始值，而不是修改后的值。&lt;/p&gt;
&lt;p&gt;大多数用户都希望使用修改赋值运算符，例如&lt;code&gt;|=&lt;/code&gt;or &lt;code&gt;+=&lt;/code&gt;，而不是&lt;code&gt;=&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;请注意，赋值运算符的 LHS 是指 &lt;code&gt;.&lt;/code&gt;. 因此&lt;code&gt;$var.foo = 1&lt;/code&gt;不会按预期工作（&lt;code&gt;$var.foo&lt;/code&gt;在 中不是有效或有用的路径表达式&lt;code&gt;.&lt;/code&gt;）；改为使用&lt;code&gt;$var | .foo = 1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;还要注意，&lt;code&gt;.a,.b=0&lt;/code&gt;不设置&lt;code&gt;.a&lt;/code&gt;and &lt;code&gt;.b&lt;/code&gt;，而是 &lt;code&gt;(.a,.b)=0&lt;/code&gt;设置两者。&lt;/p&gt;
&lt;section id=&quot;Update-assignment:|=&quot;&gt;
&lt;h3&gt;更新分配：&lt;code&gt;|=&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;这是“更新”运算符&#x27;|=&#x27;。它在右侧采用一个过滤器，并&lt;code&gt;.&lt;/code&gt;通过该表达式运行旧值来计算分配给的属性的新值。例如， (.foo, .bar) |= .+1 将构建一个对象，其中“foo”字段设置为输入的“foo”加 1，“bar”字段设置为输入的“bar”加 1 .&lt;/p&gt;
&lt;p&gt;左侧可以是任何通用路径表达式；见&lt;code&gt;path()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;请注意，&#x27;|=&#x27; 的左侧指的是&lt;code&gt;.&lt;/code&gt;. 因此&lt;code&gt;$var.foo |= . + 1&lt;/code&gt;不会按预期工作（&lt;code&gt;$var.foo&lt;/code&gt;在 中不是有效或有用的路径表达式&lt;code&gt;.&lt;/code&gt;）；改为使用&lt;code&gt;$var | .foo |= . + 1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果右侧不输出任何值（即&lt;code&gt;empty&lt;/code&gt;），则左侧路径将被删除，与 一样&lt;code&gt;del(path)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果右侧输出多个值，则仅使用第一个值（兼容性说明：在 jq 1.5 及更早版本中，过去是仅使用最后一个）。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;Arithmeticupdate-assignment:+=,-=,*=,/=,%=,//=&quot;&gt;
&lt;h3&gt;算术更新赋值：&lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;%=&lt;/code&gt;,&lt;code&gt;//=&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;jq 有几个形式的运算符&lt;code&gt;a op= b&lt;/code&gt;，它们都等价于&lt;code&gt;a |= . op b&lt;/code&gt;. 因此，&lt;code&gt;+= 1&lt;/code&gt;可用于增加值，与&lt;code&gt;|= . + 1&lt;/code&gt;.&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;Plainassignment:=&quot;&gt;
&lt;h3&gt;简单的分配：&lt;code&gt;=&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;这是普通的赋值运算符。与其他不同的是，右侧 (RHS) 的输入与左侧 (LHS) 的输入相同，而不是 LHS 路径上的值，并且 RHS 输出的所有值都将是使用（如下图）。&lt;/p&gt;
&lt;p&gt;如果 &#x27;=&#x27; 的 RHS 产生多个值，那么对于每个这样的值 jq 将左侧的路径设置为该值，然后它将输出修改后的&lt;code&gt;.&lt;/code&gt;. 例如， &lt;code&gt;(.a,.b)=range(2)&lt;/code&gt;输出&lt;code&gt;{&quot;a&quot;:0,&quot;b&quot;:0}&lt;/code&gt;，然后 &lt;code&gt;{&quot;a&quot;:1,&quot;b&quot;:1}&lt;/code&gt;。“更新”分配表格（见上文）不这样做。&lt;/p&gt;
&lt;p&gt;这个应该显示 &#x27;=&#x27; 和 &#x27;|=&#x27; 之间的区别：&lt;/p&gt;
&lt;p&gt;向程序提供输入 &#x27;{&quot;a&quot;: {&quot;b&quot;: 10}, &quot;b&quot;: 20}&#x27;：&lt;/p&gt;
&lt;p&gt;.a = .b&lt;/p&gt;
&lt;p&gt;.a |= .b&lt;/p&gt;
&lt;p&gt;前者将输入的“a”字段设置为输入的“b”字段，并产生输出{“a”：20，“b”：20}。后者会将输入的“a”字段设置为“a”字段的“b”字段，产生{“a”：10，“b”：20}。&lt;/p&gt;
&lt;p&gt;&#x27;=&#x27; 和 &#x27;|=&#x27; 之间区别的另一个：&lt;/p&gt;
&lt;p&gt;空|(.a,.b)=范围(3)&lt;/p&gt;
&lt;p&gt;输出 &#x27;{&quot;a&quot;:0,&quot;b&quot;:0}&#x27;、&#x27;{&quot;a&quot;:1,&quot;b&quot;:1}&#x27; 和 &#x27;{&quot;a&quot;:2,&quot;b&quot;:2}&#x27;，尽管&lt;/p&gt;
&lt;p&gt;空|(.a,.b)|=范围(3)&lt;/p&gt;
&lt;p&gt;只输出&#x27;{&quot;a&quot;:0,&quot;b&quot;:0}&#x27;。&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;Complexassignments&quot;&gt;
&lt;h3&gt;复杂的任务&lt;/h3&gt;
&lt;p&gt;与大多数语言相比，jq 赋值左侧允许的内容更多。我们已经在左侧看到了简单的字段访问，数组访问也同样有效也就不足为奇了：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;.posts[0].title = &quot;JQ Manual&quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;令人惊讶的是，左边的表达式可能会产生多个结果，指的是输入文档中的不同点：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;.posts[].comments |= . + [&quot;this is great&quot;]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该示例将字符串“this is great”附加到输入中每个帖子的“comments”数组（其中输入是具有字段“posts”的对象，该字段是帖子数组）。&lt;/p&gt;
&lt;p&gt;当 jq 遇到像 &#x27;a = b&#x27; 这样的赋值时，它会记录在执行 a 时选择输入文档的一部分所采用的“路径”。然后，此路径用于查找在执行分配时要更改输入的哪一部分。任何过滤器都可以用在等号的左侧——它从输入中选择的任何路径都将是执行分配的地方。&lt;/p&gt;
&lt;p&gt;这是一个非常强大的操作。假设我们想为博客文章添加评论，使用上面相同的“博客”输入。这一次，我们只想评论“stedolan”写的帖子。我们可以使用前面描述的“选择”功能找到这些帖子：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;.posts[] | select(.author == &quot;stedolan&quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该操作提供的路径指向“stedolan”写的每一个帖子，我们可以像之前一样对每一个帖子进行评论：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;(.posts[] | select(.author == &quot;stedolan&quot;) | .comments) |=
    . + [&quot;terrible.&quot;]&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id=&quot;Modules&quot;&gt;
&lt;h2&gt;模块&lt;/h2&gt;
&lt;p&gt;jq 有一个库/模块系统。模块是名称以 . 结尾的文件&lt;code&gt;.jq&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;程序导入的模块在默认搜索路径中搜索（见下文）。和指令允许导入&lt;code&gt;import&lt;/code&gt;器&lt;code&gt;include&lt;/code&gt;更改此路径。&lt;/p&gt;
&lt;p&gt;搜索路径中的路径会受到各种替换。&lt;/p&gt;
&lt;p&gt;对于以“~/”开头的路径，用户的主目录将替换为“~”。&lt;/p&gt;
&lt;p&gt;对于以“$ORIGIN/”开头的路径，jq 可执行文件的路径将替换为“$ORIGIN”。&lt;/p&gt;
&lt;p&gt;对于以“./”开头的路径或以“.”开头的路径，包含文件的路径将替换为“.”。对于命令行上给出的顶级程序，使用当前目录。&lt;/p&gt;
&lt;p&gt;导入指令可以选择指定附加默认值的搜索路径。&lt;/p&gt;
&lt;p&gt;默认搜索路径是赋予&lt;code&gt;-L&lt;/code&gt; 命令行选项 else的搜索路径&lt;code&gt;[&quot;~/.jq&quot;, &quot;$ORIGIN/../lib/jq&quot;, &quot;$ORIGIN/../lib&quot;]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;Null 和空字符串路径元素终止搜索路径处理。&lt;/p&gt;
&lt;p&gt;将在给定搜索路径的“foo/bar.jq”和“foo/bar/bar.jq”中搜索具有相对路径“foo/bar”的依赖项。这旨在允许将模块与例如版本控制文件、自述文件等一起放置在目录中，但也允许单文件模块。&lt;/p&gt;
&lt;p&gt;不允许具有相同名称的连续组件以避免歧义（例如，“foo/foo”）。&lt;/p&gt;
&lt;p&gt;例如，可以在 和中找到&lt;code&gt;-L$HOME/.jq&lt;/code&gt;一个模块。&lt;code&gt;foo&lt;/code&gt;&lt;code&gt;$HOME/.jq/foo.jq&lt;/code&gt;&lt;code&gt;$HOME/.jq/foo/foo.jq&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果“$HOME/.jq”是一个文件，它会被引入主程序。&lt;/p&gt;
&lt;section id=&quot;importRelativePathStringasNAME[&amp;lt;metadata&amp;gt;];&quot;&gt;
&lt;h3&gt;&lt;code&gt;import RelativePathString as NAME [&amp;lt;metadata&amp;gt;];&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;导入在相对于搜索路径中的目录的给定路径中找到的模块。“.jq”后缀将添加到相对路径字符串中。模块的符号以“NAME::”为前缀。&lt;/p&gt;
&lt;p&gt;可选元数据必须是常量 jq 表达式。它应该是一个带有“主页”等键的对象。此时 jq 只使用元数据的“搜索”键/值。元数据也通过 &lt;code&gt;modulemeta&lt;/code&gt;内置提供给用户。&lt;/p&gt;
&lt;p&gt;元数据中的“搜索”键（如果存在）应具有字符串或数组值（字符串数组）；这是作为顶级搜索路径前缀的搜索路径。&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;includeRelativePathString[&amp;lt;metadata&amp;gt;];&quot;&gt;
&lt;h3&gt;&lt;code&gt;include RelativePathString [&amp;lt;metadata&amp;gt;];&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;导入在给定路径中找到的模块，该模块相对于搜索路径中的目录，就好像它被包含在适当位置一样。“.jq”后缀将添加到相对路径字符串中。模块的符号被导入调用者的命名空间，就好像模块的内容被直接包含在内一样。&lt;/p&gt;
&lt;p&gt;可选元数据必须是常量 jq 表达式。它应该是一个带有“主页”等键的对象。此时 jq 只使用元数据的“搜索”键/值。元数据也通过 &lt;code&gt;modulemeta&lt;/code&gt;内置提供给用户。&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;importRelativePathStringas$NAME[&amp;lt;metadata&amp;gt;];&quot;&gt;
&lt;h3&gt;&lt;code&gt;import RelativePathString as $NAME [&amp;lt;metadata&amp;gt;];&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;导入在相对于搜索路径中的目录的给定路径中找到的 JSON 文件。“.json”后缀将添加到相对路径字符串中。该文件的数据将以&lt;code&gt;$NAME::NAME&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;可选元数据必须是常量 jq 表达式。它应该是一个带有“主页”等键的对象。此时 jq 只使用元数据的“搜索”键/值。元数据也通过 &lt;code&gt;modulemeta&lt;/code&gt;内置提供给用户。&lt;/p&gt;
&lt;p&gt;元数据中的“搜索”键（如果存在）应具有字符串或数组值（字符串数组）；这是作为顶级搜索路径前缀的搜索路径。&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;module&amp;lt;metadata&amp;gt;;&quot;&gt;
&lt;h3&gt;&lt;code&gt;module &amp;lt;metadata&amp;gt;;&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;该指令完全是可选的。它不是正确操作所必需的。它仅用于提供可以使用&lt;code&gt;modulemeta&lt;/code&gt;内置函数读取的元数据。&lt;/p&gt;
&lt;p&gt;元数据必须是常量 jq 表达式。它应该是一个带有“主页”之类的键的对象。此时 jq 不使用此元数据，但它通过 &lt;code&gt;modulemeta&lt;/code&gt;内置提供给用户。&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;modulemeta&quot;&gt;
&lt;h3&gt;&lt;code&gt;modulemeta&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;将模块名称作为输入并将模块的元数据作为对象输出，模块的导入（包括元数据）作为“deps”键的数组值。&lt;/p&gt;
&lt;p&gt;程序可以使用它来查询模块的元数据，然后他们可以使用它来搜索、下载和安装缺少的依赖项。&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>06418b973b87a8e5a6e26758381b11d3</guid>
<title>图文并茂！带你深度解析Kubernetes</title>
<link>https://toutiao.io/k/zqu0b0q</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;来源公众号：腾讯云开发者 / &lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247540019&amp;amp;idx=1&amp;amp;sn=47e622f813ff882d03b3e7d552ab2919&amp;amp;chksm=eaa84763dddfce75a010c1d90bf150666106ef1bc16f9cb651977ec6d8a7bd602306629e0cac&amp;amp;token=2065805670&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;原文链接&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;原文链接&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;导语 | &lt;/span&gt;&lt;span&gt;在云原生技术发展的浪潮之中，Kubernetes作为容器编排领域的事实标准和云原生领域的关键项目，其诞生与完善有着对应的技术历史背景，了解这个过程，对于系统的理解Kubernetes的核心思想、架构设计、实现原理等会很有帮助。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;8c2011fe7977c79c57258f08c7c970ac1&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;81fe9c767d8d736711aa5ce1f9982ddf1&quot;&gt;&lt;span&gt;在云原生技术发展的浪潮之中，Kubernetes伴随着容器技术的发展，成为了目前云时代的操作系统。Kubernetes作为容器编排领域的事实标准和云原生领域的关键项目，已经是云原生时代工程师最需要理解与实践的核心技术。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;0704a60e7ef4f72910d7dce48e47d7672&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;0704a60e7ef4f72910d7dce48e47d7672&quot;&gt;&lt;span&gt;但技术的发展从来都不是一蹴而就，Kubernetes的诞生与完善也有其对应的技术历史背景，了解其诞生与发展的过程，对于更加系统的理解其核心思想、架构设计、实现原理等内容会大有帮助。因此，本文从Kubernetes的诞生背景与Why Kubernetes两个方面，来完成对Kubernetes的概述。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;一、Kubernetes诞生背景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;8c2011fe7977c79c57258f08c7c970ac1&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;5960457f748908fa56dee998cf6c82111&quot;&gt;&lt;span&gt;如果要了解Kubernetes的诞生，就绕不开整个云计算的发展历程。了解了云计算的发展的过程，就会明白，Kubernetes是云计算发展到一定程度的必然产物。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-lines=&quot;1&quot; data-sign=&quot;3e62e6c429b4fb09d30498ee440293ac&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3 data-lines=&quot;1&quot; data-sign=&quot;3e62e6c429b4fb09d30498ee440293ac&quot;&gt;&lt;span&gt;（一）云计算发展历程&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;云计算发展历程的时间轴如下图所示，从物理机过渡到传统的IaaS阶段，进而发展为早期的PaaS，直至发展到如今的基于Kubernetes架构的新兴PaaS平台。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.28046875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96jEyaJCib0qpPqfNTh5WTw45QOn6aO2MYSvtLJEiatskbZoBaGY7QHk2NqAZG8MawqChVnTJ7njiaOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用户使用资源的形态也由早期的物理机过渡到虚拟机，再进化到目前更轻量的Docker容器。本质上云计算实现的关键突破就在于&lt;/span&gt;&lt;span&gt;资源使用方式的改变&lt;/span&gt;&lt;span&gt;，其最初解决的核心的问题就是&lt;/span&gt;&lt;span&gt;应用的托管即应用部署与管理问题&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-lines=&quot;2&quot; data-sign=&quot;71f0aa0e1b7ef1e5fd54159f07be736b&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-lines=&quot;2&quot; data-sign=&quot;71f0aa0e1b7ef1e5fd54159f07be736b&quot;&gt;&lt;span&gt;（二）早期物理机时代&lt;/span&gt;&lt;/h3&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;6978c88870bd69f6101366aa7261ce862&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;6978c88870bd69f6101366aa7261ce862&quot;&gt;&lt;span&gt;云计算之前，开发者如需部署管理服务，需要根据需求，进行配置、管理与运维物理机。整体上维护困难，成本高昂，重复劳动，风险随机。以至于当年流传着运维的传统艺能：上线拜祖，如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;6978c88870bd69f6101366aa7261ce862&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5396341463414634&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96jEyaJCib0qpPqfNTh5WTw4AxQHnvVSlyFXZqCkicmmZ2LzLibcMlDolvCpJY5SIQmb34eY7lflG5Ug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;984&quot;/&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;6978c88870bd69f6101366aa7261ce862&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在那个时代，&lt;/span&gt;&lt;span&gt;应用部署与管理&lt;/span&gt;&lt;span&gt;面临着以下诸多问题：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-lines=&quot;2&quot; data-sign=&quot;3c009f6a60f4162b2b5c9036f302a454&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-lines=&quot;2&quot; data-sign=&quot;3c009f6a60f4162b2b5c9036f302a454&quot;&gt;&lt;span&gt;（三）IaaS平台&lt;/span&gt;&lt;/h3&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;32846b18fa01ab3dbbdd40c5bfedf8ac2&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;32846b18fa01ab3dbbdd40c5bfedf8ac2&quot;&gt;&lt;span&gt;Infrastructure as a service (IaaS) 基础设施即服务，用户可以按需去申请基础设施资源（包括：计算、存储、网络）。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;62e1276149e6a1d9bd35a4b2461dd3cc2&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;62e1276149e6a1d9bd35a4b2461dd3cc2&quot;&gt;&lt;span&gt;IaaS商业化道路上的一个标志性事件：2006年AWS推出了EC2（亚马逊弹性云端运算），其基于Xen虚拟化技术，用户可以在web界面上配置、获取虚拟机资源，部署应用。通过规模化来降低边际成本。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-lines=&quot;1&quot; data-sign=&quot;635c4611cf761a66ee0e83e7000562cf&quot;&gt;&lt;br/&gt;&lt;/h4&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;46f8a131a4d6c53cb9044ad47cfb95fe2&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;46f8a131a4d6c53cb9044ad47cfb95fe2&quot;&gt;&lt;span&gt;IaaS的底层核心技术是虚拟化技术&lt;/span&gt;&lt;span&gt;。虚拟化技术是一种资源关联技术，是将计算机的各种实体资源，如服务器、网络、存储等，进行抽象、整合、管理与再分配的一种技术。最常用的一种方案是基于虚拟机（Hypervisor-based）的虚拟化实现。其通过一个软件层的封装，提供和物理硬件相同的输入输出表现，实现了操作系统和计算机硬件的解耦，将OS和计算机从一对一转变为多对多（实际上是一对多）的关系。该软件层称为虚拟机管理器（VMM/Hypervisor），它分为两大类：裸金属架构、宿主机架构。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;96f6f1f2436bb46987ff2a57e7de39002&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;96f6f1f2436bb46987ff2a57e7de39002&quot;&gt;&lt;span&gt;裸金属架构：VMM直接安装和运行在物理机上；VMM自带虚拟内核的管理和使用底层的硬件资源。业界的Xen、VMWare ESX都是裸金属架构。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;27248b2b9bb1debd3c85415ccfc216a12&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;27248b2b9bb1debd3c85415ccfc216a12&quot;&gt;&lt;span&gt;&lt;span&gt;宿主机架构：&lt;/span&gt;&lt;span&gt;物理机上首先会装一个操作系统，VMM安装和运行在操作系统上；&lt;/span&gt;&lt;span&gt;在VMM再去装其他虚拟机操作系统，依赖&lt;/span&gt;与&lt;span&gt;操作系统对硬件设备的支持与资源的管理。&lt;/span&gt;&lt;span&gt;这种架构的好处是，VMM会变&lt;/span&gt;得&lt;span&gt;非常简单，因为可以基于操作系统去管理系统资源，VMM只需要做额外的虚拟化工作。&lt;/span&gt;&lt;span&gt;Oracle VirtualBox，VMWare Workstation、KVM都是这种架构，宿主机架构是目前虚拟化技术的主流架构。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下图中，对比了物理机架构与宿主机虚拟化架构的区别。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7029608404966571&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96jEyaJCib0qpPqfNTh5WTw4Agfrvib6KempW1TibD1qWwHiaFia5ImCfedqFhTYuhkRibqcKhXS41eAaGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1047&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虚拟化架构有如下的优势：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4 data-lines=&quot;2&quot; data-sign=&quot;451edeb55dda8623a53f228de01183dd&quot;&gt;&lt;br/&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;7e773b8b4da08b66da684a9fae3ffe1b2&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;7e773b8b4da08b66da684a9fae3ffe1b2&quot;&gt;&lt;span&gt;当物理机转变为虚拟机之后，如何对多台虚拟机的资源进行管理与调度，成为了一个新的问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;ecbb8f0944577c23aab4bdac5a38b6d92&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;ecbb8f0944577c23aab4bdac5a38b6d92&quot;&gt;&lt;span&gt;OpenStack给出了解决方案，它是一个开源的分布式的平台，能够统一管理多个服务器，按用户需求进行分配与调度虚拟机。其本质上是&lt;/span&gt;&lt;span&gt;一组分配、管理虚拟机&lt;/span&gt;&lt;span&gt;的自动化工具脚本&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前，OpenStack已经发展成了IaaS的主流解决方案，即：OpenStack as IaaS。目前主流IaaS云服务厂商底层都是利用OpenStack技术。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4617391304347826&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96jEyaJCib0qpPqfNTh5WTw4iaUzQicWFDARuCgyYw6ycrpNCLZBFfD7r39BwibDdvlI23GAtWoq1lH0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1150&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;4734547ff21b5dec530fd7fecbb9e8431&quot;&gt;&lt;span&gt;IaaS平台一定程度上提升了物理机的资源利用率，由物理机时代的低于10%，提升到了15%。但虚拟机对资源利用率的提升仍存在一定的局限性，其相对笨重，启动慢，自身消耗大（其完整运行了一套操作系统），自身加载就要消耗几百兆的内存资源。此外，虚拟机可以预装一些软件，一定程度简化了应用程序的依赖安装。但应用程序的部署与打包，仍然需要开发人员各自解决，仍未高效的完成应用部署与分发。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-lines=&quot;2&quot; data-sign=&quot;c9b0be24a7283a57ba9a49983982acc3&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-lines=&quot;2&quot; data-sign=&quot;c9b0be24a7283a57ba9a49983982acc3&quot;&gt;&lt;span&gt;（四）PaaS平台&lt;/span&gt;&lt;/h3&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;2c0103f05034088e9469148a084169ad2&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;2c0103f05034088e9469148a084169ad2&quot;&gt;&lt;span&gt;Platform-as-a-Service (PaaS)平台即服务。PaaS提供了包括服务器、存储空间和网络等基础结构，但它并未包括中间件、开发工具、数据库管理系统等。&lt;/span&gt;&lt;span&gt;PaaS旨在支持应用程序的完整生命周期：生成、部署、管理和更新，提供应用的托管能力&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在IaaS阶段，服务厂商只提供虚拟机，虚拟机之上的软件栈都由用户管理，包括操作系统、持久化层、中间层、用户程序。在IaaS层面用户只是减少了关心底层硬件，而PaaS层面希望能够进一步解放用户，让用户真正只需&lt;/span&gt;&lt;span&gt;关注应用本身&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4390625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96jEyaJCib0qpPqfNTh5WTw4VUZ01gUSynzOXCaNP6lGI8uQFFe6QsybOuMu7Agcib4nDTrQsQuHLqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前一个成熟的PaaS平台应具备的主要功能，如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.42734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96jEyaJCib0qpPqfNTh5WTw4zuGWEp4NHxIGliaiaib9tT3Y4CTRr93C7ibia1MribhNdn4KBjcOI0WM7fFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;6ab24f4c0b73cb63884a3409083f830e1&quot;&gt;&lt;span&gt;早期PaaS平台，更多关注运行时环境与依赖服务，而目前的PaaS平台新增大量的支持服务，包括：认证授权、系统日志、应用监控等，以上都是应用开发的常见需求。原则上：共用内容就应该抽象出统一通用的组件，由框架和平台来实现。让用户只关心逻辑或应用本身，避免重复造轮子。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-lines=&quot;2&quot; data-sign=&quot;a3b8034589bc4ced5cbc2cd82889c4e2&quot;&gt;&lt;br/&gt;&lt;/h4&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;82dc6a8f7f25481e321f3dff54d07f372&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;82dc6a8f7f25481e321f3dff54d07f372&quot;&gt;&lt;span&gt;PaaS在成熟之前也经历了几个阶段，而PaaS早期的代表就不得不提Cloud Foundry。Cloud Foundry由VMWare开发，是第一款开源PaaS平台（2011年）。支持多种框架、语言、运行时环境、云平台及应用服务，使开发人员能够快速进行应用的部署，无需担心任何基础架构的问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;8818f282597bcf43cf2a571be15f1d4a2&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;8818f282597bcf43cf2a571be15f1d4a2&quot;&gt;&lt;span&gt;它主要功能包括以下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;46e747eda606141e0f276641a09bd08a2&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;46e747eda606141e0f276641a09bd08a2&quot;&gt;&lt;span&gt;Cloud Foundry的出现，其描绘了PaaS平台的初步形态，推动了PaaS的发展，具有划时代的意义。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;f6a28e831b520024f62152e9f9bc925b2&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;f6a28e831b520024f62152e9f9bc925b2&quot;&gt;&lt;span&gt;但其最终并未成为PaaS主流，是因为其存在一个核心不足：它只对应用和配置进行了打包，而没有打包整体依赖（所谓的整体依赖包括：中间环境、操作系统文件）。所以它的包在跨平台运行时，会出现运行失败的现象。这个问题非常致命。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;93ab483c00de1c8c86d74166eb80cad82&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;93ab483c00de1c8c86d74166eb80cad82&quot;&gt;&lt;span&gt;而且，早期Cloud Foundry主要是针对单一Web应用的管理，对分布式应用所需的各项能力均未涉及，例如：服务发现、弹性扩缩等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-lines=&quot;1&quot; data-sign=&quot;8ab13efb2bb16bb2ba542bdc0e3edd34&quot;&gt;&lt;span&gt;（五）Docker&lt;/span&gt;&lt;/h3&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;1e98d8d4af4bdc5bdfa61bc825b2f2f01&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;1e98d8d4af4bdc5bdfa61bc825b2f2f01&quot;&gt;&lt;span&gt;Docker公司的前身是dotCloud，它是2010年成立，提供Paas服务的平台。但当时Cloud Foundry做的相对完善和开放，2012年底dotClound濒临倒闭，创始人决定把内部的打包平台开源出去。因此，2013年3月dotCloud公司在github平台上开源了其内部的容器项目Docker。Github开源之后，受到了业界的热烈追捧，从而Docker大火。公司后来也改名为Docker。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;4b0b7cd58981f7ac048217ab4754eafd2&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;4b0b7cd58981f7ac048217ab4754eafd2&quot;&gt;&lt;span&gt;Docker的成功，主要是通过镜像完美解决了开发、测试、生产环境不一致的问题。它的口号是：Build、Shipand Run any App、Anywhere，即一处构建，到处运行。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;fcc099e074165266a2827042cf958dab2&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;fcc099e074165266a2827042cf958dab2&quot;&gt;&lt;span&gt;Docker的核心技术有三个：NameSpaces做视图隔离、Cgroups做资源限制，UnionFS联合文件系统，统一mount。&lt;/span&gt;&lt;span&gt;通俗理解：NameSpaces、Cgroups通给进程设置属性，实现进程的隔离与限制，UnionFS给进程构造文件系统&lt;/span&gt;&lt;span&gt;。这三项技术均有linux内核提供，Docker本身并没有创造新的技术。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;64011729117bd0e02675dc3a084280562&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;64011729117bd0e02675dc3a084280562&quot;&gt;&lt;span&gt;但是Docker创造性的通过&lt;/span&gt;&lt;span&gt;镜像整体打包了应用的依赖环境&lt;/span&gt;&lt;span&gt;，包括：操作系统文件、中间依赖层、APP。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;b3a59be872d12016a6e2ca04280b73f82&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;f912ebc1c450bce0ce6768f40d217bc02&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;f912ebc1c450bce0ce6768f40d217bc02&quot;&gt;&lt;span&gt;Docker通过镜像分层复用的方式进行了优化。共用只读层，节省存储空间，提高镜像推送、拉取效率，镜像的操作是增量式。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;062ace6d136fadf2658d908b964c2d882&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;a12931589ca862f08d4647745f6f7f4c2&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;a12931589ca862f08d4647745f6f7f4c2&quot;&gt;&lt;span&gt;利用UnionFS实现合并，多个只读层加一个可写层mount成一个目录。并且上面的层会覆盖下面的层，当对底层的只读层修改时会采用写时复制策略（copy-on-write）。写时复制的含义：当另一个层第一次需要写入该文件时（在构建镜像或运行容器时），该文件会被复制到该读写层并被修改。该机制大大减少了容器的启动时间（启动时新建的可写层只有很少的文件写入），但容器运行后每次第一次修改的文件都需要先将整个文件复制到container layer中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.44140625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96jEyaJCib0qpPqfNTh5WTw44cj00RvLWbHwbp4evr4ojkwI1WnHkBxKoLuMYjpsmlWRWkWBicJficrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;4c5529b1c6d4dd1bd2d0877581a392492&quot;&gt;&lt;span&gt;如下图所示，Docker相比于虚拟机操作系统级的资源隔离，实现了进程级资源隔离，极大提升了资源利用率。具备以下特点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6943127962085308&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96jEyaJCib0qpPqfNTh5WTw4stG2iaHquoUO068icLObZ4iarluPYia4cSu902msKiajO8zX4OjutoXMqcA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1266&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-lines=&quot;1&quot; data-sign=&quot;733391ed70076436d98aae6b0ccfbdc3&quot;&gt;&lt;span&gt;（六）容器编排&lt;/span&gt;&lt;/h3&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;6e21b40089f73fd2fc8b4f24229e8b982&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;6e21b40089f73fd2fc8b4f24229e8b982&quot;&gt;&lt;span&gt;当Docker解决了应用打包的问题后，PaaS上应用大规模部署与管理的问题愈发突出。此时，业内明白：&lt;/span&gt;&lt;span&gt;容器本身没有“价值”，有价值的是容器编排&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;efd24ce61803a7f618f19b8a94452cdc2&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;efd24ce61803a7f618f19b8a94452cdc2&quot;&gt;&lt;span&gt;容器编排(Orchestration)：对Docker及容器进行更高级更灵活的管理，按照用户的意愿和整个系统的规则，&lt;/span&gt;&lt;span&gt;完全自动化的处理好容器之间的各种关系&lt;/span&gt;&lt;span&gt;（对象之间的关系远重要于对象本身）。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;f818ef307ea65d22046c4211b346a1912&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;f818ef307ea65d22046c4211b346a1912&quot;&gt;&lt;span&gt;容器技术做为底层基础技术，只能用来创建和启动容器的小工具，最终只能充当平台项目的“幕后英雄”。用户最终部署的还是他们的网站、服务、数据库，甚至是云计算业务。这就需要一个真正的PaaS平台，让用户把自己的容器应用部署在此之上。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;271354f5235e96b64f08a47fcdfeab7b2&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;271354f5235e96b64f08a47fcdfeab7b2&quot;&gt;&lt;span&gt;在以上的历史背景之下，2014年左右，Docker、Mesos、Google相继发布自己的PaaS平台，容器编排之争正式开始。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;35595901c51adc4006112c07517165944&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;35595901c51adc4006112c07517165944&quot;&gt;&lt;span&gt;Docker发布了Swarm平台，Swarm擅长跟Docker生态无缝集成，docker用户可以低成本过渡。其最大亮点是使用Docker项目原有的容器管理API来完成集群管理。例如：单机Docker项目: docker run “我的容器”。集群Docker项目：docker run-H“我的Swarm集群API地址” “我的容器”。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;84d8eb06f8b486b1702a80988a1e6fba2&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;84d8eb06f8b486b1702a80988a1e6fba2&quot;&gt;&lt;span&gt;Mesos平台，擅长大规模集群的调度与管理。它是Apache基金会下的一个开源集群管理器，最初是由Berkeley分校开发的。它为应用程序提供了跨集群的资源管理和调度API。之后转向支持PaaS业务，推出了Marathon项目。它是一个高度成熟的PaaS项目，旨在让用户便捷管理一个数万级别的物理机集群，可使用容器在这个集群里自由部署应用。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;71cc10b8733b3aeaadd3c141bdba02982&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;71cc10b8733b3aeaadd3c141bdba02982&quot;&gt;&lt;span&gt;Google推出的是Kubernetes平台，整个系统的前身是Borg系统，Kubernetes平台是Google在容器化基础设施领域十多年来实践经验的沉淀与升华。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.525&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96jEyaJCib0qpPqfNTh5WTw4IKjGVIyQTd6pEp7ocPl0slI4R0BelhI5lqwbkdZ350bHibtvswQdicQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;8ebf88b53bc64bca94ce0315ee7611202&quot;&gt;&lt;span&gt;经过近3年的角逐，容器编排之争的胜利者是Kubernetes。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;54b88d2a349f3fd252e8b12dfc3467ce2&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;54b88d2a349f3fd252e8b12dfc3467ce2&quot;&gt;&lt;span&gt;Kubernetes，读者一定会有一个疑&lt;/span&gt;&lt;span&gt;问：&lt;/span&gt;&lt;span&gt;为什么最后是Kubernetes&lt;/span&gt;&lt;span&gt;？&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;37e07f4472a078d724e83dba91b9d02d2&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;37e07f4472a078d724e83dba91b9d02d2&quot;&gt;&lt;span&gt;每个人对这个问题，都有一些自己的理解，本文从技术方面对该问题进行了阐述。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-lines=&quot;1&quot; data-sign=&quot;3575649181a9238468042e872bbaaaa9&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;二、Why Kubernetes&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;8c2011fe7977c79c57258f08c7c970ac1&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;d792e1577e9252a4dea5d9f713f4c8e22&quot;&gt;&lt;span&gt;Kubernetes源于希腊语，意为“舵手”。k8s缩写是因为k和s之间有八个字符的原因。它是google在2015开源的容器调度编排的平台。它是建立在Google大规模运行生产工作负载（Borg系统）十几年经验的基础上， 结合了社区中最优秀的想法和实践，已经成为了目前容器编排的事实标准。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;ebd121ef17d73eb9ca4ae7922a21d4ae2&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;ebd121ef17d73eb9ca4ae7922a21d4ae2&quot;&gt;&lt;span&gt;其实看到Docker和Kubernetes的Logo，就可以很快明白Kubernetes的作用。Docker的Logo是一条鲸鱼船，运载着许多封装好的集装箱(container)，代表着一次打包到处运行的意图。&lt;/span&gt;&lt;span&gt;而Kubernetes的Logo就是这条船的方向舵&lt;/span&gt;&lt;span&gt;！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4045881126173097&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96jEyaJCib0qpPqfNTh5WTw4Qw143dqqib8ibWYuEiaUQg9Rx2A3y1tiaYmo6gJVTD3MAKZeQIjQHq6O8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;959&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;e16e9f7db04bf438adb79be38e6cc8242&quot;&gt;&lt;span&gt;对于Why Kubernetes？很多人都有自己的理解，接下来笔者从技术的角度，阐述一下自己的观点。Kubernetes技术上的成功，个人认为核心在于三个关键点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-lines=&quot;1&quot; data-sign=&quot;4cd0fd3f486eeda4f8c72f47ff915230&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3 data-lines=&quot;1&quot; data-sign=&quot;4cd0fd3f486eeda4f8c72f47ff915230&quot;&gt;&lt;span&gt;（一）Kubernetes前身&lt;/span&gt;&lt;/h3&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;05f788dc01db1192da4d14aa5976c8af1&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;05f788dc01db1192da4d14aa5976c8af1&quot;&gt;&lt;span&gt;Kubernetes的基础特性，并不是几个工程师突然“拍脑袋”想出来的东西，而是 Google 公司在容器化基础设施领域多年来实践经验的沉淀与升华。这个实践与升华的过程，就是Kubernetes的前身是Borg系统。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;a0b7b8cec801720608ca73775eaaf2f32&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;a0b7b8cec801720608ca73775eaaf2f32&quot;&gt;&lt;span&gt;Borg系统一直以来都被誉为Google内部最强大的“秘密武器”，是Google整个基础设施的核心依赖。很多应用框架已经运行在Borg上多年，其中包括了内部的MapReduce、GFS、BigTable、Megastore等，上层应用程序更是有这些耳熟能详的产品：Gmail、Google Docs、Google Search等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.43046875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96jEyaJCib0qpPqfNTh5WTw4icl0NqU21hUMNAKlJ9IFxRbkqsszib3OTnPcKAdI93FVOrRjribRGkljw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其架构图如下所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8883048620236531&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96jEyaJCib0qpPqfNTh5WTw4iakvpvWrjMKtbefWzULRkU9JJEOHB10xEwDsFEIgic7RMhjNCAj0iahEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;761&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;6e4ab35e0304e7b57ec63e36c0cfae192&quot;&gt;&lt;span&gt;架构分析：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;ffdf68866cc64f28c2346156b701a4d12&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;ffdf68866cc64f28c2346156b701a4d12&quot;&gt;&lt;span&gt;根据2015年4月google发布的&lt;/span&gt;&lt;span&gt;Large-scale clustermanagement at Google with Borg&lt;/span&gt;&lt;span&gt;，与其2020年7月发布的&lt;/span&gt;&lt;span&gt;Borg: the nextgeneration&lt;/span&gt;&lt;span&gt;，两篇论文中的数据表明：Borg系统通过对在线任务与离线任务进行混合部署，可以节约20%-30%的资源，极大提高了资源利用率。下表是2011年与2019年的Borg集群，与2015年AWS、Facebool、Twitter数据中心资源利用率的对比图。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;ffdf68866cc64f28c2346156b701a4d12&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3336229365768897&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96jEyaJCib0qpPqfNTh5WTw4SicTNFzIvh4007kJwL41DIjbjkGqicuHfV1Lk04HeSTQMTSGkrK0mdWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1151&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;8cb236f6de1b503a02019b6ad53fdca22&quot;&gt;&lt;span&gt;对于成熟高效的Borg系统，继承者Kubernetes从中获得了宝贵的经验：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-lines=&quot;1&quot; data-sign=&quot;937bbe5a7d24aa0703abfd46cb36abbd&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-lines=&quot;1&quot; data-sign=&quot;937bbe5a7d24aa0703abfd46cb36abbd&quot;&gt;&lt;span&gt;（二）Kubernetes架构&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-lines=&quot;2&quot; data-sign=&quot;79e87e30102c96bc3fbc204abd5dcad9&quot;&gt;&lt;br/&gt;&lt;/h4&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;451ff6896767a5ca9735ebd2e9f9e71a2&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;451ff6896767a5ca9735ebd2e9f9e71a2&quot;&gt;&lt;span&gt;Kubernets整体架构，如下所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7267932489451476&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96jEyaJCib0qpPqfNTh5WTw4xYaB8cWicDiaoUZyibrtTqqjNBtOT4WJSMjy1GK0yIX4oy6jHHKN1cxicg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;948&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;f6d8a6fbda9b12c35e9632c38e9a515e3&quot;&gt;&lt;span&gt;整个系统由控制面(Master)与数据面(Worker Node)组成。Master核心组件：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;c00b760c9f5cc9380b990a7fc1e1164d3&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;c00b760c9f5cc9380b990a7fc1e1164d3&quot;&gt;&lt;span&gt;Kubernetes架构具备高可用：一方面Master节点高可用；另一方面所部署的业务也是高可用的。系统高可用的核心在于冗余部署，当某一个节点或程序出现异常时，其他节点或程序能分担或替换工作。Master节点高可用，主要由以下几个方面的设计实现：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;83bd2664e9b6756dd4164eb564ce8bbd2&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;83bd2664e9b6756dd4164eb564ce8bbd2&quot;&gt;&lt;span&gt;Work Node节点由以下组件组成：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4 data-lines=&quot;1&quot; data-sign=&quot;1cf2a7a04daf9cfef4721c0e385911dd&quot;&gt;&lt;br/&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;8b9960d7c260979fc0e33d1ebdda1e7d2&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;8b9960d7c260979fc0e33d1ebdda1e7d2&quot;&gt;&lt;span&gt;Kubernetes中API Server的核心功能是提供Kubernetes各类资源对象（如Pod、RC、Service等）的增、删、改、查及Watch等HTTP REST接口，成为集群内各个功能模块之间数据交互和通信的中心枢纽，是整个系统的数据总线和数据中心。除此之外，它还是集群管理的API入口，提供了完备的集群安全机制。API Server是由多实例同时工作，各个组件通过负载均衡连到具体的API Server实例上。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;af18095807b4c66c1511818862dc708b2&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;af18095807b4c66c1511818862dc708b2&quot;&gt;&lt;span&gt;如下所示，各组件与API Server通信时，采用List-Watch机制，通过API server获取etcd配置与状态信息，进而触发行为。以下图为例是kubectl创建一个deployment时，各个组件与API Server的流程交互。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.521875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96jEyaJCib0qpPqfNTh5WTw4YA678tBun7CCXJot0xFOfO3jwrGhgWpxtvKYsO8r7yr1H54h4rG8Og/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;97b954994c52fed08724a4deb3ae27f32&quot;&gt;&lt;span&gt;Api Server的作用：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-lines=&quot;1&quot; data-sign=&quot;56e7da754adad05262e380ca0b0bd492&quot;&gt;&lt;span&gt;（三）Kubernetes核心设计&lt;/span&gt;&lt;/h3&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;bed9999ba953d16625c3b7999e62711f2&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;bed9999ba953d16625c3b7999e62711f2&quot;&gt;&lt;span&gt;Kubernetes取的巨大的成功，与它良好的核心设计紧密相关。笔者认为Kubernetes有三大核心设计：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;a4c31d6f5c44f89140f5ea51924892d71&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;a4c31d6f5c44f89140f5ea51924892d71&quot;&gt;&lt;span&gt;Kubernetes在对象抽象方面，核心创新在于Pod对象的设计。容器设计本身是一种“单进程”模型。该表述不是指容器里只能启动一个进程，而是指容器无法管理多个进程。只有容器内PID=1的进程生命周期才受到容器管理（该进程退出后，容器也会退出），其他进程都是PID=1的进程的子进程。根据容器设计模式，传统架构中多个紧密配合的业务进程（例如业务进程与日志收集进程，业务进程与业务网络代理进程）应该部署成多个容器。但这些容器之间存在亲密的关系，需要一起调度和直接共享某些资源（网络和存储）。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;e632203266bdf706cca03ba7850ec54d2&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;e632203266bdf706cca03ba7850ec54d2&quot;&gt;&lt;span&gt;Kubernetes抽象出一个Pod对象，是一组（一个或多个）容器， 这些容器共享存储、网络等， 这些容器是相对紧密的耦合在一起的。Pod是Kubernetes内创建和管理的最小可调度单元，调度过程是按Pod整体所需资源一起进行调度的。Pod本身只是逻辑上的概念，在容器管理这层并不认识Pod对象。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Pod的实现需要使用一个中间容器（Infra容器），在这个Pod中，Infra容器永远是第一个被创建的容器，用户定义的其他容器通过Join Network Namespace的方式与Infra容器关联在一起。抽象一个中间容器的原因在于各个业务容器是对等的，其启动没有严格的先后顺序，需借助中间容器实现共享网络和存储的目的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8192&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96jEyaJCib0qpPqfNTh5WTw4HhJKmUfCMCcs9JTiajYNAFvjGbm9NbW5Fk29LovG2DRBSzmArTPSMibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;625&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其中，Node、Pod与容器三者关系，如下图所示。Node表示一台机器，可调度多个Pod，而一个Pod内又能包含多个容器。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5910931174089069&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96jEyaJCib0qpPqfNTh5WTw4j4n2gkvagCh83vENI5Fm1VBFPw92wFpkjutBA86xNMpPnnrLf2Jmfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;988&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;至此，再来通过Kubernetes中各个对象的关联关系来更为深刻的理解Pod的意义。下图可以看出，Pod其实是整个编排过程中操作的核心，很多对象直接或间接的同Pod相关联。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.51484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96jEyaJCib0qpPqfNTh5WTw4at4Sict5HZSPkXl1NhGLxTyLuAiaZ1ztx07YX5wQlibLaRnFFotTCIxVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;ca40e51d07202db8edca91e90afffc812&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;ca40e51d07202db8edca91e90afffc812&quot;&gt;&lt;span&gt;Kubernetes编排抽象的另一个核心对象是Service对象，它统一的解决了集群内服务发现与负载均衡。Service是对一组提供相同功能的Pod的抽象，为其提供了一个统一的入口。Service通过标签选择服务后端，匹配标签的Pod IP和端口列表组成endpoints，由kube-proxy负责将请求负载到相关的endpoints。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下图是kube-proxy通过iptables模式来实现Service的过程，Service对象有一个虚拟clusterIP，集群内请求访问clusterIP时，会由iptables规则负载均衡到后端endpoints。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7393800229621125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96jEyaJCib0qpPqfNTh5WTw4EfP35CvmWPgJM3XCJ2ickgFxmFfjj0HianMuqFx7bQwvicrgNn2t7GPicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;871&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;f7160164cd86dc0f4dd54a27f27a38c32&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;f7160164cd86dc0f4dd54a27f27a38c32&quot;&gt;&lt;span&gt;Declarative（声明式设计）指的是一种软件设计理念和编程方式，描述了目标状态，由工具自行判断当前状态并执行相关操作至目标状态。声明式强调What，目标是什么。而Imperative(命令式)需要用户描述一系列详细指令来达到期望的目标状态。命令式强调How，具体如何做。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;c5f9a3bbd99692a339e8ccd30aad1dcc2&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;c5f9a3bbd99692a339e8ccd30aad1dcc2&quot;&gt;&lt;span&gt;下图描绘了一个场景：目标副本数为3。对于声明式而言，用户设定目标为3，系统获取当前副本数为2，系统判定当前值与目标值的差为1，便自行加1，最终实现副本数为3的目标状态。而对于命令式，需用户判断当前副本数为2，用户给出指令副本+1，系统接收用户指令，执行副本数+1操作，最终系统副本数为3。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.2875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96jEyaJCib0qpPqfNTh5WTw4C1Rbic0sAnOCOatOLiallAOEYfk9MG64zAyc6zCmyT60JssH4KcUBLIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;fe9ddba3e44e8bc2de048aa0faec13262&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;fe9ddba3e44e8bc2de048aa0faec13262&quot;&gt;&lt;span&gt;kubernetes的一大核心设计就是采用了声明式API，利用该设计思想有效的实现了系统的自动化运行。Kubernetes声明式API指定了集群期望的运行状态，集群控制器会通过List&amp;amp;Watch机制来获取当前状态，并根据当前状态自动执行相应的操作至目标状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6199740596627756&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96jEyaJCib0qpPqfNTh5WTw4JlgreOUk9TUJJqgxJx1B5VOeib5ur9C5Rf0vDJljjV6ODLaVZrAwDgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;771&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Kubernetes中，用户通过提交定义好的API对象来声明期望状态，系统允许有多个API写端，以PATCH方式对API对象进行修改。Kubectl工具支持三种对象管理方式：命令式命令行、命令式对象配置(yaml)、声明式对象配置(yaml)。举例如下：命令式命令行：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;kubectl&lt;/span&gt; run nginx –image nginx&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;命令式对象配置：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;kubectl&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;create&lt;/span&gt; –&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;nginx&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.yaml&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;kubectl&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;replace&lt;/span&gt; –&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;nginx&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.yaml&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上先kubectl create再kubectl replace的操作，与命令式命令行不存在本质区别。只是把具体命令写入yaml配置文件中而已。声明式对象配置：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;kubectl&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;apply&lt;/span&gt; –&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;nginx&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.yaml&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;96b5743412c20d0718e62af2ee100d552&quot;&gt;&lt;span&gt;Kubernetes推荐使用：声明式对象配置(YAML)。kubectl replace执行过程是通过新的YAML文件中的API对象来替换原有的API对象，而Kubectl apply执行了一个对原有API对象的PATCH操作。除此之外，YAML配置文件用于Kubernetes对象的定义，还会有以下收益：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;8ce1b473a0775d222efaac72fd12a6572&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;8ce1b473a0775d222efaac72fd12a6572&quot;&gt;&lt;span&gt;Kubernetes的设计初衷就是支持可插拔的架构，解决PaaS平台使用不方便、不易扩展等问题。为了便于系统的扩展，Kubernetes中开放了以下接口可对系统资源（计算、网络、存储）插件进行扩展，可分别对接不同的后端来实现自己的业务逻辑。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CRI（Container Runtime Interface）：容器运行时接口，提供计算资源。CRI接口设计的一个重要原则是只关注接口本身，而不关心具体实现，kubelet就只需要跟这个接口打交道。而作为具体的容器项目，比如Docker、rkt、containerd、kata container它们就只需要自己提供一个该接口的实现，然后对kubelet暴露出gRPC服务即可。简单来说，CRI主要作用就是实现了kubelet和容器运行时之间的解耦。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CNI（Container Network Interface）：容器网络接口，提供网络资源。跨主机容器间的网络互通已经成为基本要求，K8S网络模型要求所有容器都可以直接使用IP地址与其他容器通信，而无需使用NAT；所有宿主机都可以直接使用IP地址与所有容器通信，而无需使用NAT。反之亦然。容器自己的IP地址，和别人（宿主机或者容器）看到的地址是完全一样的。K8S提供了一个插件规范，称为容器网络接口(CNI)，只要满足K8S的基本需求，第三方厂商可以随意使用自己的网络栈，通过使用overlay网络来支持多子网或者一些个性化使用场景，所以出现很多优秀的CNI插件被添加到Kubernetes集群中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CSI（Container Storage Interface）：容器存储接口，提供存储资源。K8S将存储体系抽象出了外部存储组件接口，第三方存储厂商可以发布和部署公开的存储插件，而无需接触Kubernetes核心代码，同时为Kubernetes用户提供了更多的存储选项。例如：AWS、NFS、Ceph。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.48869752421959095&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96jEyaJCib0qpPqfNTh5WTw4ctffBUIQ0yWcibNQVv6gqX3iag9yPFWTMnKFrds0WufNv23amEibPGIHg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;929&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;fb9ad09f765b2e6b7a221dc5dae265162&quot;&gt;&lt;span&gt;Kubernetes除了对系统资源可插件扩展外，也可以自定义CRD（Custom Resource Definition）来扩展API对象，同时也支持编写Operator对CRD进行控制。例如：对于一些有状态应用（etcd），可以定义新的CRD对象，并编写特定的Operator（本质上是新的controller）去实现控制逻辑。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;5e5041554e2b19f1c10b9e4fb2fc71742&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;5e5041554e2b19f1c10b9e4fb2fc71742&quot;&gt;&lt;span&gt;Kubernetes的调度器Scheduler也是可以扩展的，可以部署自定义的调度器，在整个集群中还可以同时运行多个调度器实例，通过 pod.Spec.schedulerName 来选择具体指定调度器（默认使用内置的调度器）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4831168831168831&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96jEyaJCib0qpPqfNTh5WTw40Q3ay0jC3PoHYzC6vcWA0PKkrapfQyKhJks5shR295gBY91fmRxQNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1155&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;三、小结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;8c2011fe7977c79c57258f08c7c970ac1&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;e715bee3943d0b2d181560f41ae89d1d2&quot;&gt;&lt;span&gt;根据以上两个章节的阐述，对于文章开头的经典问题：如何才能有效的部署与管理应用？到Kubernets大放异彩的今天，已经给出了答案：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;dbb68441517cc50e97c7cf71731a81b42&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;dbb68441517cc50e97c7cf71731a81b42&quot;&gt;&lt;span&gt;感谢Kubernetes，将开发、运维人员从繁重的应用部署与管理工作中解放出来。到目前为止，Kubernetes已经成为了容器编排的事实标准，是新一代的基于容器技术的PaaS平台的重要底层框架。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;9e7bcd4229f55657d8bf38d595c8a16f2&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;9e7bcd4229f55657d8bf38d595c8a16f2&quot;&gt;&lt;span&gt;Kubernetes的成熟，拉开了轰轰烈烈的云原生技术发展的大幕！&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;9e7bcd4229f55657d8bf38d595c8a16f2&quot;&gt;&lt;/p&gt;&lt;h2 data-lines=&quot;2&quot; data-sign=&quot;6a8ec4347e92a1cf05a2fcf1e62e0082&quot;&gt;&lt;strong&gt;参考资料：&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;1.&lt;/span&gt;&lt;span&gt;Kuberne&lt;/span&gt;&lt;span&gt;tes 文档&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.Kubern&lt;/span&gt;&lt;span&gt;etes权威指南 第五版&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.深入剖&lt;/span&gt;&lt;span&gt;析 Kubernetes-张磊&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4.&lt;/span&gt;&lt;span&gt;Docker与k8s&lt;/span&gt;&lt;span&gt;的前世今生&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5.https://dra&lt;/span&gt;&lt;span&gt;vene&lt;/span&gt;&lt;span&gt;ss.me/understanding-kubernetes/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt; 作者简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe96jEyaJCib0qpPqfNTh5WTw4XwJmHnmvBwj9Hb34A9kGsXvFdkp3YLMIvWd6jqgviaO8huHePHBRU1Q/0?wx_fmt=jpeg&quot; data-cropx1=&quot;179.02097902097904&quot; data-cropx2=&quot;1118.881118881119&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;957.7622377622379&quot; data-fileid=&quot;100044396&quot; data-ratio=&quot;1.021437578814628&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe96jEyaJCib0qpPqfNTh5WTw462DzOXJzx4UeeLT6HMEqpd1A9ibOIU8EvzOtibJ3m2tEM2px3YSRFC2Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;793&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;尹飞&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;腾讯后台开发工程师&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;腾讯后台开发工程师，专注于后台游戏开发，擅长分布式开发，有丰富的C++、Lua、Go语言使用经验。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span data-raw-text=&quot;快&quot; data-textnode-index-1641449854815=&quot;120&quot; data-index-1641449854815=&quot;5909&quot;&gt;&lt;span data-raw-text=&quot;快&quot; data-textnode-index-1654158604739=&quot;159&quot; data-index-1654158604739=&quot;8582&quot; class=&quot;character hover&quot;&gt;快速&lt;/span&gt;&lt;span data-raw-text=&quot;加&quot; data-textnode-index-1656251905988=&quot;48&quot; data-index-1656251905988=&quot;2029&quot; class=&quot;character hover&quot;&gt;加&lt;/span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index-1656251905988=&quot;48&quot; data-index-1656251905988=&quot;2030&quot; class=&quot;character hover&quot;&gt; &lt;/span&gt;K&lt;span data-raw-text=&quot;8&quot; data-textnode-index-1656251905988=&quot;48&quot; data-index-1656251905988=&quot;2032&quot; class=&quot;character hover&quot;&gt;8&lt;/span&gt;s&lt;span data-raw-text=&quot;学&quot; data-textnode-index-1656251905988=&quot;48&quot; data-index-1656251905988=&quot;2034&quot; class=&quot;character hover&quot;&gt;学&lt;/span&gt;&lt;/span&gt;习&lt;span data-raw-text=&quot;交&quot; data-textnode-index-1641449854815=&quot;120&quot; data-index-1641449854815=&quot;5918&quot;&gt;&lt;span data-raw-text=&quot;交&quot; data-textnode-index-1654158604739=&quot;166&quot; data-index-1654158604739=&quot;8591&quot; class=&quot;character hover&quot;&gt;&lt;span data-raw-text=&quot;交&quot; data-textnode-index-1656251905988=&quot;50&quot; data-index-1656251905988=&quot;2036&quot; class=&quot;character hover&quot;&gt;&lt;span data-raw-text=&quot;交&quot; data-textnode-index-1656411491475=&quot;108&quot; data-index-1656411491475=&quot;4527&quot; class=&quot;character hover&quot;&gt;交&lt;/span&gt;&lt;span data-raw-text=&quot;流&quot; data-textnode-index-1656411491475=&quot;109&quot; data-index-1656411491475=&quot;4528&quot; class=&quot;character hover&quot;&gt;流&lt;/span&gt;&lt;/span&gt;群&lt;span data-raw-text=&quot;，&quot; data-textnode-index-1656251905988=&quot;50&quot; data-index-1656251905988=&quot;2039&quot; class=&quot;character hover&quot;&gt;，&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;与&quot; data-textnode-index-1654158604739=&quot;166&quot; data-index-1654158604739=&quot;8595&quot; class=&quot;character hover&quot;&gt;与&lt;/span&gt;&lt;span data-raw-text=&quot;大&quot; data-textnode-index-1654158604739=&quot;166&quot; data-index-1654158604739=&quot;8596&quot; class=&quot;character hover&quot;&gt;大&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;佬&lt;/span&gt;&lt;span&gt;&lt;span data-raw-text=&quot;共&quot; data-textnode-index-1651239087355=&quot;169&quot; data-index-1651239087355=&quot;7441&quot;&gt;共&lt;span data-raw-text=&quot;卷&quot; data-textnode-index-1654158604739=&quot;169&quot; data-index-1654158604739=&quot;8599&quot; class=&quot;character hover&quot;&gt;卷&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;！&quot; data-textnode-index-1645889042954=&quot;122&quot; data-index-1645889042954=&quot;5595&quot;&gt;！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/D727NicjCjMOWU4gIlOiaIsXL9NH89b7YtkQHp33M5csqJr6lkP5pDKjn8eNEUkW2yOUptjFhAcFsBtia8yYkibPXw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;430&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span data-raw-text=&quot;扫&quot; data-textnode-index-1645522878318=&quot;50&quot; data-index-1645522878318=&quot;2205&quot;&gt;&lt;span&gt;&lt;span data-raw-text=&quot;扫&quot; data-textnode-index-1657291526958=&quot;286&quot; data-index-1657291526958=&quot;4769&quot; class=&quot;character&quot;&gt;扫&lt;/span&gt;&lt;span data-raw-text=&quot;码&quot; data-textnode-index-1657291526958=&quot;286&quot; data-index-1657291526958=&quot;4770&quot; class=&quot;character&quot;&gt;码&lt;/span&gt;&lt;span data-raw-text=&quot;加&quot; data-textnode-index-1657291526958=&quot;286&quot; data-index-1657291526958=&quot;4771&quot; class=&quot;character&quot;&gt;加&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;我&quot; data-textnode-index-1645160961499=&quot;445&quot; data-index-1645160961499=&quot;14028&quot;&gt;&lt;span&gt;&lt;span data-raw-text=&quot;我&quot; data-textnode-index-1657291526958=&quot;287&quot; data-index-1657291526958=&quot;4772&quot; class=&quot;character&quot;&gt;我&lt;/span&gt;&lt;span data-raw-text=&quot;微&quot; data-textnode-index-1657291526958=&quot;287&quot; data-index-1657291526958=&quot;4773&quot; class=&quot;character&quot;&gt;微&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;信&quot; data-textnode-index-1651239087355=&quot;173&quot; data-index-1651239087355=&quot;7449&quot;&gt;&lt;span&gt;&lt;span data-raw-text=&quot;信&quot; data-textnode-index-1657291526958=&quot;288&quot; data-index-1657291526958=&quot;4774&quot; class=&quot;character&quot;&gt;信&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;，&quot; data-textnode-index-1641449854815=&quot;121&quot; data-index-1641449854815=&quot;5934&quot;&gt;&lt;span&gt;&lt;span data-raw-text=&quot;，&quot; data-textnode-index-1657291526958=&quot;289&quot; data-index-1657291526958=&quot;4775&quot; class=&quot;character&quot;&gt;，&lt;/span&gt;&lt;span data-raw-text=&quot;进&quot; data-textnode-index-1657291526958=&quot;289&quot; data-index-1657291526958=&quot;4776&quot; class=&quot;character&quot;&gt;进&lt;/span&gt;&lt;span data-raw-text=&quot;群&quot; data-textnode-index-1657291526958=&quot;289&quot; data-index-1657291526958=&quot;4777&quot; class=&quot;character&quot;&gt;群&lt;/span&gt;&lt;span data-raw-text=&quot;和&quot; data-textnode-index-1657291526958=&quot;289&quot; data-index-1657291526958=&quot;4778&quot; class=&quot;character&quot;&gt;和&lt;/span&gt;&lt;span data-raw-text=&quot;大&quot; data-textnode-index-1657291526958=&quot;289&quot; data-index-1657291526958=&quot;4779&quot; class=&quot;character&quot;&gt;大&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;佬&quot; data-textnode-index-1651239087355=&quot;175&quot; data-index-1651239087355=&quot;7455&quot;&gt;&lt;span&gt;&lt;span data-raw-text=&quot;佬&quot; data-textnode-index-1657291526958=&quot;290&quot; data-index-1657291526958=&quot;4780&quot; class=&quot;character&quot;&gt;佬&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;们&quot; data-textnode-index-1647847983250=&quot;111&quot; data-index-1647847983250=&quot;3701&quot;&gt;&lt;span&gt;&lt;span data-raw-text=&quot;们&quot; data-textnode-index-1657291526958=&quot;291&quot; data-index-1657291526958=&quot;4781&quot; class=&quot;character&quot;&gt;们&lt;/span&gt;&lt;span data-raw-text=&quot;零&quot; data-textnode-index-1657291526958=&quot;291&quot; data-index-1657291526958=&quot;4782&quot; class=&quot;character&quot;&gt;零&lt;/span&gt;&lt;span data-raw-text=&quot;距&quot; data-textnode-index-1657291526958=&quot;291&quot; data-index-1657291526958=&quot;4783&quot; class=&quot;character&quot;&gt;距&lt;/span&gt;&lt;span data-raw-text=&quot;离&quot; data-textnode-index-1657291526958=&quot;291&quot; data-index-1657291526958=&quot;4784&quot; class=&quot;character&quot;&gt;离&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>31894b68c930c08e262e6e7706c851f9</guid>
<title>声网开发者创业讲堂丨第 4 期：创业团队如何保障产品业务的安全合规？</title>
<link>https://toutiao.io/k/lgn6aun</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;event-intro tab-content&quot; id=&quot;eventContentAreaMain&quot;&gt;&amp;#13;
                    &amp;#13;
&amp;#13;
                    &lt;div class=&quot;  &quot; id=&quot;event_desc_page&quot;&gt;&amp;#13;
                        &lt;p ql-global-para=&quot;true&quot; line=&quot;Sl5P&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;安全与合规是两个非常大的话题，即涉及到技术层面，也涉及到政策和业务管理。很多创业团队会在创业初期因为公司规模、项目体量的原因，忽略或刻意规避安全合规，从而引发不可挽回的风险或隐患。在创业初期存在诸多不确定性的情况下，作为创业者应该如何正确且合理的保障产品业务的安全与合规？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;7 月 16 日下午&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，声网开发者创业讲堂 • 第 4 期将以「&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;创业团队如何保障产品业务的安全合规？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;」为题，邀请&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;环信、游族、白山云&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;三家优秀企业的技术专家为大家带来精彩的分享。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;Sl5P&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;h4 data-foldable-wrapper=&quot;&quot; class=&quot;ql-long-10306337&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;时间地点&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;活动时间：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;7 &lt;/span&gt;&lt;span&gt;月 16 日（星期六）&lt;/span&gt;&lt;span&gt; 14:00——16:30&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;活动地点：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;线上直播&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;h4 data-foldable-wrapper=&quot;&quot; class=&quot;ql-long-10306337&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;活动流程&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h4&gt;&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;span&gt;14:00-14:10 开场&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; 14:10-14:50 《即时通信场景下安全合规的实践和经验》&lt;/span&gt;&lt;span&gt;赵亮 环信IM SDK 研发负责人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; 14:50-15:30 &lt;/span&gt;&lt;span&gt;《常见信息安全攻击风险及应对方案》马寅龙 游族网络信息化中心总监&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;15:30-16:10 《&lt;/span&gt;&lt;span&gt;攻防视角下业务安全的实战经验分享&lt;/span&gt;&lt;span&gt;》&lt;/span&gt;&lt;span&gt;胡金涌&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;白山云安全研发总监&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; 16:10-16:30 抽奖&lt;/span&gt;&lt;/p&gt;&lt;p helvetica=&quot;&quot; hiragino=&quot;&quot; sans=&quot;&quot; noto=&quot;&quot; cjk=&quot;&quot; microsoft=&quot;&quot; apple=&quot;&quot; color=&quot;&quot; segoe=&quot;&quot; ui=&quot;&quot; text-align:=&quot;&quot; text-size-adjust:=&quot;&quot; letter-spacing:=&quot;&quot; line-height:=&quot;&quot; span=&quot;&quot; strong=&quot;&quot; p=&quot;&quot;&gt;​&lt;/p&gt;&lt;h4 data-foldable-wrapper=&quot;&quot; class=&quot;ql-long-10306337&quot;&gt;&lt;span ql-global=&quot;true&quot; class=&quot;ql-author-10306337&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section microsoft=&quot;&quot; line-height:=&quot;&quot; border:=&quot;&quot; text-align:=&quot;&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;嘉宾一&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;5mYi&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;img src=&quot;http://cdn.huodongxing.com/file/ue/20150907/11EC6A5AE18CC6F72FD13133F73B484844/30214561467379533.jpg&quot; title=&quot;赵亮.jpeg&quot; alt=&quot;赵亮.jpeg&quot;/&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;5mYi&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;span class=&quot;ql-author-7400209 ql-font-microsoftyahei&quot; ql-global=&quot;true&quot; microsoft=&quot;&quot;/&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;M81Y&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;strong class=&quot;ql-author-7400209 ql-font-microsoftyahei&quot; ql-global=&quot;true&quot; microsoft=&quot;&quot;&gt;赵亮，环信IM SDK 研发负责人&lt;/strong&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;M81Y&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分享主题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;M81Y&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;strong class=&quot;ql-author-7400209 ql-font-microsoftyahei&quot; ql-global=&quot;true&quot; microsoft=&quot;&quot;&gt;即时通信场景下安全合规的实践和经验&lt;/strong&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;5mYi&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span ql-global=&quot;true&quot; class=&quot;ql-author-10306337&quot;&gt;&lt;span/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;个人简介：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;5mYi&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;span&gt;环信IM SDK 研发负责人，十余年电信和互联网从业经验，曾主持研发多个明星项目，目前在环信主持即时通讯云 SDK 研发工作。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;Ji92&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;分享简介：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;LCNh&quot; linespacing=&quot;200&quot; class=&quot;ql-long-10306337&quot;&gt;&lt;span&gt;在监管趋紧的形式下，即时通讯场景会遇到很多安全合规领域的挑战，如何满足这些安全合规的要求，如何保护用户的隐私安全，是一件非常有挑战的事情。本次分享将介绍环信在这个领域所做的一些实践和经验。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;h4 data-foldable-wrapper=&quot;&quot; class=&quot;ql-long-10306337&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span microsoft=&quot;&quot; font-size:=&quot;&quot; font-weight:=&quot;&quot; letter-spacing:=&quot;&quot; text-align:=&quot;&quot; text-size-adjust:=&quot;&quot; background-color:=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;section helvetica=&quot;&quot; pingfang=&quot;&quot; hiragino=&quot;&quot; sans=&quot;&quot; microsoft=&quot;&quot; yahei=&quot;&quot; font-size:=&quot;&quot; letter-spacing:=&quot;&quot; text-align:=&quot;&quot; white-space:=&quot;&quot; text-size-adjust:=&quot;&quot; section=&quot;&quot; line-height:=&quot;&quot; border:=&quot;&quot; span=&quot;&quot; p=&quot;&quot; img=&quot;&quot; src=&quot;http://cdn.huodongxing.com/file/ue/20150907/11EC6A5AE18CC6F72FD13133F73B484844/30294520688364826.jpg&quot; title=&quot;讲师-3.jpg&quot; alt=&quot;讲师-3.jpg&quot; ql-global-para=&quot;true&quot; line=&quot;92I0&quot; class=&quot;ql-author-10306337&quot; linespacing=&quot;200&quot; strong=&quot;&quot; ql-global=&quot;true&quot; h4=&quot;&quot; data-foldable-wrapper=&quot;&quot;&gt;&lt;section microsoft=&quot;&quot; line-height:=&quot;&quot; border:=&quot;&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;嘉宾二&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;5mYi&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;img src=&quot;http://cdn.huodongxing.com/file/ue/20150907/11EC6A5AE18CC6F72FD13133F73B484844/30624561468989583.jpg&quot; title=&quot;马寅龙.jpeg&quot; alt=&quot;马寅龙.jpeg&quot;/&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;5mYi&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;strong class=&quot;ql-author-7400209 ql-font-microsoftyahei&quot; ql-global=&quot;true&quot; microsoft=&quot;&quot;&gt;马寅龙，游族网络信息化中心总监&lt;/strong&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;5mYi&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分享主题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;5mYi&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;strong ql-global=&quot;true&quot; class=&quot;ql-author-10306337&quot;&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;ezi5&quot; linespacing=&quot;200&quot; class=&quot;ql-long-10306337&quot;&gt;&lt;strong class=&quot;ql-author-7400209 ql-font-microsoftyahei&quot; ql-global=&quot;true&quot; microsoft=&quot;&quot;&gt;常见信息安全攻击风险及应对方案&lt;/strong&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;5mYi&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;strong ql-global=&quot;true&quot; class=&quot;ql-author-10306337&quot;&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;个人简介：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;5mYi&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;span&gt;&lt;span&gt;​游族网络信息化中心与信息安全部负责人，拥有 12 年信息安全管理建设经验，主导构建了游族网络信息安全纵深防护体系，曾作为嘉宾在 CIS / EISS / FIT / SSC等国内顶级安全峰会演讲。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;Ji92&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分享简介：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;LCNh&quot; linespacing=&quot;200&quot; class=&quot;ql-long-10306337&quot;&gt;&lt;span&gt;从企业常见的安全事件出发，分析企业信息安全管理的演进路径，包括安全团队建设、安全工具选型、安全服务选型，以及如何以高性价比方式建设企业安全防护能力。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;LCNh&quot; linespacing=&quot;200&quot; class=&quot;ql-long-10306337&quot;&gt;&lt;span microsoft=&quot;&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-foldable-wrapper=&quot;&quot; class=&quot;ql-long-10306337&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span microsoft=&quot;&quot; font-size:=&quot;&quot; font-weight:=&quot;&quot; letter-spacing:=&quot;&quot; text-align:=&quot;&quot; text-size-adjust:=&quot;&quot; background-color:=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;section helvetica=&quot;&quot; pingfang=&quot;&quot; hiragino=&quot;&quot; sans=&quot;&quot; microsoft=&quot;&quot; yahei=&quot;&quot; font-size:=&quot;&quot; letter-spacing:=&quot;&quot; text-align:=&quot;&quot; white-space:=&quot;&quot; text-size-adjust:=&quot;&quot; section=&quot;&quot; line-height:=&quot;&quot; border:=&quot;&quot; span=&quot;&quot; p=&quot;&quot; img=&quot;&quot; src=&quot;http://cdn.huodongxing.com/file/ue/20150907/11EC6A5AE18CC6F72FD13133F73B484844/30294520688364826.jpg&quot; title=&quot;讲师-3.jpg&quot; alt=&quot;讲师-3.jpg&quot; ql-global-para=&quot;true&quot; line=&quot;92I0&quot; class=&quot;ql-author-10306337&quot; linespacing=&quot;200&quot; strong=&quot;&quot; ql-global=&quot;true&quot; h4=&quot;&quot; data-foldable-wrapper=&quot;&quot;&gt;&lt;section microsoft=&quot;&quot; line-height:=&quot;&quot; border:=&quot;&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;嘉宾三&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;LCNh&quot; linespacing=&quot;200&quot; class=&quot;ql-long-10306337&quot;&gt;&lt;span microsoft=&quot;&quot;/&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;xXLn&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;span class=&quot;ql-author-7400209&quot; ql-global=&quot;true&quot;&gt;&lt;img src=&quot;http://cdn.huodongxing.com/file/ue/20150907/11EC6A5AE18CC6F72FD13133F73B484844/30874561474629783.jpg&quot; title=&quot;胡金涌.jpeg&quot; alt=&quot;胡金涌.jpeg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;xXLn&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;span class=&quot;ql-author-7400209&quot; ql-global=&quot;true&quot;&gt;胡金涌，白山云安全研发总监&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;xXLn&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;分享主题&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;xXLn&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;span&gt;攻防视角下业务安全的实战经验分享&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;Sl5P&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;个人简介：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;Sl5P&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;span&gt;&lt;span&gt;白山云安全研发总监，&lt;/span&gt;十年云安全产品研发经验，主持研发了SCDN、抗DDoS、云WAF、SoC、零信任等安全产品，在攻防领域有丰富的经验。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;Los9&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;分享简介：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;Los9&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从攻防的视角分享业务上线后可能遇到的常见攻击，并分享安全研发规范、上线前的安全巡检、上线后的安全防护等实战经验并给出一些安全建议。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;Los9&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;LCNh&quot; linespacing=&quot;200&quot; class=&quot;ql-long-10306337&quot;&gt;&lt;/p&gt;&lt;h4 data-foldable-wrapper=&quot;&quot; class=&quot;ql-long-10306337&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;活动社群&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;当下是一个人人可创业的时代，对技术人来说，更是一个创业友好的时代。如果你懂技术，会比其他人更容易将自己的创业想法和梦想付诸实践。但创业意味着要从 0 到 1，意味着要持续的创造和创新，意味着创业者和团队需要不断的成长和突破。只有这样才能打造出满足市场需求的、有价值的产品，逐渐形成企业的优势和壁垒，成长为一家成熟的企业。声网关注有创新能力、开发能力和创业意向的开发者，并希望为开发者提供相应的支持和服务。为此，我们推出了“声网开发者创业讲堂”系列创业分享，以便为大家在成长和创业路上提供更多的帮助。欢迎扫码申请加入我们的创业开发者社群！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://cdn.huodongxing.com/file/ue/20150907/11EC6A5AE18CC6F72FD13133F73B484844/30884567754245388.jpg&quot; title=&quot;WechatIMG263.jpeg&quot; alt=&quot;WechatIMG263.jpeg&quot;/&gt;&lt;/p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;LCNh&quot; linespacing=&quot;200&quot; class=&quot;ql-long-10306337&quot;&gt;&lt;/p&gt;&lt;h4 data-foldable-wrapper=&quot;&quot; class=&quot;ql-long-10306337&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;活动福利&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;报名直播参与活动，即有机会领取&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;精美声网周边&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;，心动不如行动，赶快报名本次活动吧！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;http://cdn.huodongxing.com/file/ue/20150907/11EC6A5AE18CC6F72FD13133F73B484844/30714561552961563.jpeg&quot; title=&quot;副本_未命名_自定义px_2022-06-28+12_00_12.png&quot; alt=&quot;副本_未命名_自定义px_2022-06-28+12_00_12.png&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;联合主办&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p helvetica=&quot;&quot; pingfang=&quot;&quot; hiragino=&quot;&quot; sans=&quot;&quot; microsoft=&quot;&quot; yahei=&quot;&quot; font-size:=&quot;&quot; text-size-adjust:=&quot;&quot; letter-spacing:=&quot;&quot; line-height:=&quot;&quot; text-align:=&quot;&quot; img=&quot;&quot; src=&quot;http://cdn.huodongxing.com/file/ue/20150907/11EC6A5AE18CC6F72FD13133F73B484844/30264520732955891.jpg&quot; title=&quot;联合主办.jpeg&quot; alt=&quot;联合主办.jpeg&quot; section=&quot;&quot; powered-by=&quot;xiumi.us&quot; white-space:=&quot;&quot;&gt;&lt;img src=&quot;http://cdn.huodongxing.com/file/ue/20150907/11EC6A5AE18CC6F72FD13133F73B484844/30954561508360622.jpg&quot; title=&quot;联合主办.jpeg&quot; alt=&quot;联合主办.jpeg&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;合作伙伴&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img src=&quot;http://cdn.huodongxing.com/file/ue/20150907/11EC6A5AE18CC6F72FD13133F73B484844/30494561569642118.jpg&quot; title=&quot;安全课联合主办.jpeg&quot; alt=&quot;安全课联合主办.jpeg&quot;/&gt;​&lt;/p&gt;&lt;/section&gt;&amp;#13;
                    &lt;/div&gt;&amp;#13;
                    &lt;p class=&quot;clear&quot;&gt;&amp;#13;
                    &lt;/p&gt;&amp;#13;
                    &amp;#13;
                    &amp;#13;
                &lt;/div&gt;&amp;#13;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>402a534469f6d6822709257d5afb5bfc</guid>
<title>聊聊消息中心的设计与实现逻辑</title>
<link>https://toutiao.io/k/skcgh32</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;blockquote&gt;&lt;p&gt;厌烦被消息打扰，又怕突然间的安静；&lt;/p&gt;&lt;/blockquote&gt;&lt;h1&gt;&lt;span&gt;一、业务背景&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;微服务的架构体系中，会存在很多基础服务，提供一些大部分服务都可能需要的能力，比如文件管理、MQ队列、缓存机制、消息中心等等，这些服务需要提供各种可以复用的方法或者接口，以便其他业务服务可以快速调用；下面来看看消息通知的原理：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.23203125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvDW2BSnaNBn2PVQH5VgGSwwUkSAVFvpHtB4HK2T5kz8jw4ic2IcuuQgfQVFlVzvz13ZNGTzibB40DYg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;这里的消息不同于MQ队列，是指业务侧的通知机制，例如短信、邮件、系统消息等，在业务层面的需求很多，通常会封装单独的消息中心提供通知机制；&lt;/p&gt;&lt;p&gt;从流程上面看，消息通知是典型的生产-消费模式，业务侧不断的生产消息，消息中心在接收之后进行消费，把通知推送到相应的渠道中，很显然这种逻辑具备很高的复用性。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;二、消息通知&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、流程管理&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;消息通知的流程设计，在各个业务线中通过消息中心提供的接口方法，将不同场景下的消息内容提交到消息中心，消息中心进行统一维护管理，并根据消息的来源和去向，适配相应的推送逻辑：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.2734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvDW2BSnaNBn2PVQH5VgGSww6a00ibJc613hU3OfIibycAphndBcSY7RhZXn6qpw9wce4n8qphhfvqmQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;消息生产：涉及到的场景很多，比如活动、营销机制、系统通知、业务流转、过期提醒等；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息管理：对预发送消息的结构和参数进行校验，并创建消息推送的任务，维护任务级别的推送管理，跟踪消息的状态周期；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息消费：基于消息任务的结构，构建消息推送的主体内容，并对接多个发送渠道，实现通知的高效触达；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;定时任务：消息可以直接即时推送，但如果是夜间定时任务触发，则要考虑推送延迟问题，将消息放在指定时段投递；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;渠道对接：通常不同的渠道意味着不同的场景，例如监控推送钉钉，活动一般推送微信，账户变动发邮件，营销走短信，业务则应用内通知；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在整个流程中涉及到的模块比较多，状态的流转也很复杂，但是通过消息中心进行统一标准管理和流入流出的跟踪，也可以提供清晰的生命周期监控和维护；&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2、流程时序&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;在整个消息通知链路中，在不同的流转节点中，无不涉及状态的变化（即from.to状态），这样可以构成整个生命周期的视图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.36953125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvDW2BSnaNBn2PVQH5VgGSwwls9cslkdNnMrfPT7uBE5eBM5ibctFNWCEqgliaEJPjrGY5tbRPm08bTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;初始化：业务方构建简单的消息结构，请求发送到消息中心后，初始化一个消息任务；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;任务化：对消息发送请求进行校验，并将消息转换成一个标准的推送任务结构；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;推送中：根据任务推送的时间周期类型，将任务构建成不同渠道的通知主体，从而进行渠道消息推送；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;已完成：根据消息在渠道推送的状态回调，更新消息中心的任务完成状态，或者失败重试；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;大部分的消息通知机制都可以容忍一定的延迟性，所以消息中心完全可以解耦各个流程，引入MQ队列或者异步机制，业务方只需要将请求发送到消息中心，之后由消息中心统一调度和管理即可；&lt;/p&gt;&lt;h2&gt;&lt;span&gt;3、结构设计&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;这里根据系统的实现过程和经验，给出一个数据结构的设计参考，用来对业务场景做简单的维度描述：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5109375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvDW2BSnaNBn2PVQH5VgGSww6tty9EFgCPOo1cHXRvznDqgq7ia5SnFphjyXJg2cyMuYNESEjSibaA3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;消息模板：定义通知的主体结构，基于消息的参数模型，构建推送的消息内容；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息任务：消息中心管理和维护的主体结构，以任务的模式维护消息从生产到推送完成的整个状态周期；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;场景记录：消息最终推送出去的内容和场景分类，也可以简单的理解为不同渠道的投递记录；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;交互消息：强调消息在接收方是否触达并且对消息产生了交互行为，例如会话，邮件回复，状态关联等；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1&gt;&lt;span&gt;三、实践总结&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;最后还是站在技术实现的角度，总结一下消息通知机制中的一些关键问题：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;生产消费：消息生产之后写入消息中心的存储容器，之后进行消费流程的管理，是业务解耦的常用手段；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;任务管理：以任务的模式进行消息推送的调度，通过任务状态的变化和控制，实现生命周期的管理；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;状态机：描述消息的流转节点和状态，在不同的事件中触发不同的状态切换和转移，并在状态变化后衔接各种业务动作；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;渠道对接：通常消息推送的渠道多是第三方平台，所以在消息中心会接入诸多的渠道，例如微信、钉钉、短信等；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;基础封装：作为分布式系统中的基础功能，在封装消息管理功能时，要考虑一定的复用性和流程的可视化呈现；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;消息的本质是信息的触达和传递，但是过多的消息通知也容易让用户产生厌倦心态，所以消息内容的简洁明确，推送的间隔时段以及阅读提醒，在产品具体的实现上需要极为用心，从而让消息在业务体系中发挥更大的价值。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;四、参考源码&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;编程文档：&lt;br/&gt;https://gitee.com/cicadasmile/butte-java-note&lt;br/&gt;&lt;br/&gt;应用仓库：&lt;br/&gt;https://gitee.com/cicadasmile/butte-flyer-parent&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU4Njg0MzYwNw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBj3abVSgCmvm7FIYw55ficInd2se9ia6KSic0ma25AUvrmUtXUwXibjhHmCc7DUawfXBI30QuHBjDnzw/0?wx_fmt=png&quot; data-nickname=&quot;知了一笑&quot; data-alias=&quot;cicada_smile&quot; data-signature=&quot;积累是一个孤独且枯燥的过程&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                          
              &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                  &lt;p class=&quot;tips_global&quot; aria-hidden=&quot;true&quot; id=&quot;js_a11y_reward_qr_title&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                    &lt;p role=&quot;option&quot; aria-labelledby=&quot;js_a11y_reward_qr_word js_a11y_comma js_a11y_reward_qr_title js_a11y_reward_qr_money&quot; aria-describedby=&quot;js_a11y_reward_qr_tips &quot; class=&quot;reward_tips&quot; id=&quot;js_a11y_reward_qr_word&quot;/&gt;
                  &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img alt=&quot;赞赏二维码&quot; class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                  &lt;p aria-hidden=&quot;true&quot; id=&quot;js_a11y_reward_qr_tips&quot; class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                &lt;/div&gt;
                                              
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>