<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f0575c1733aae1367b6266292c2f78a7</guid>
<title>Golang 编程思维和工程实战</title>
<link>https://toutiao.io/k/usjzg6m</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Golang 的一些编程思维和思想，以及总结一些常见的优雅编程实战技巧。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：allendbwu，腾讯 PCG 后台开发工程师&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一 Golang 编程思维&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，我们先来看下最基本的，就是 Golang 的学习技巧，比如通读 Golang 的一些好的文章：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要通读 golang 官方的编码规范，主要是要参考官方的 &lt;a href=&quot;https://github.com/golang/go/wiki/CodeReviewComments&quot; data-linktype=&quot;2&quot;&gt;CodeReviewComments&lt;/a&gt; 和 &lt;a href=&quot;https://golang.org/doc/effective_go.html&quot; data-linktype=&quot;2&quot;&gt;Effective Go&lt;/a&gt; 这两篇官方文章，真的非常推荐必须要好好的看完、看懂这两篇文章（英文不好的同学可以看中文翻译文档），然后按照官方编码规范来具体 coding，主要是能够在具体的编码中有迹可循。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考业界大牛们的代码，主要是看一些开源的优质的项目，比如 Google 他们这帮人自己搞的 Kubernetes、Istio，还有一些好的项目如 Docker、CoreDNS、etcd 等等。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;项目基本架构的组织&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;代码基本的编码封装&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;代码的基本原则规范&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;并发的设计思想&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;面向对象编程的设计思想&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可扩展性的设计思想&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后就是实践，实实在在的跑一些代码示例，可以自己建立一个 base-code 的项目，里面就是你的各种示例，然后进行一些修改、执行。具体的代码示例可以从官方文档上来，推荐&lt;a href=&quot;https://gobyexample.com/&quot; data-linktype=&quot;2&quot;&gt;Go by Example&lt;/a&gt;，里面有大量非常好的例子。也可以自己网上随便搜下，重要的自己要修改并执行，查看和分析结果：&lt;a href=&quot;https://go101.org/article/101.html&quot; data-linktype=&quot;2&quot;&gt;Go 101&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其次，要理解 Golang 编程思维，首先要理解 Golang 这门语言的创始初衷，初衷就是为了解决好 Google 内部大规模高并发服务的问题，主要核心就是围绕高并发来开展；并且同时又不想引入面向对象那种很复杂的继承关系。首先，就是可以方便的解决好并发问题（包括高并发），那么就需要有并发思维，能够并发处理就通过并发来进行任务分配&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这个就是涉及到了 context、 goroutine、channel（select）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;创建大量 goroutine， 但是需要能通过 context、 channel 建立 &quot;父子&quot;关系，保证子任务可以能够被回收、被主动控制（如 杀死）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再者，面向对象编程思想，利用好 interface、 struct 来实现继承、多态的用法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;struct 匿名组合来实现继承；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;terface 和 struct 来实现多态；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;interface 定义接口，尽可能的保持里面的方法定义简单，然后多个 interface 进行组合。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后，理解 Golang 语言本身的一些特性: - 强类型，语法上要注意处理；- GC，实际中要观察 GC 日志并分析；- 注意语法语义尽可能的简单、保持各种类型定义尽可能精简。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，从 Golang 社区的一些最佳实践来看，Golang 的各种组件需要尽可能的精简。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Golang 中用好的一些开源组件库，都是比较轻量级的，然后可以各自随意组合来达到最佳实践。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我们自己进行组件封装、模块封装的时候，也是保持这个原则，尽可能的精简，然后使用方进行组合。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二、Golang 高级编码技巧&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1 优雅的实现构造函数编程思想&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/*&lt;br/&gt;一个更为优雅的构造函数的实现方式&lt;br/&gt;参考：&lt;br/&gt;https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html&lt;br/&gt;通过这个方式可以方便构造不同对象，同时避免了大量重复代码&lt;br/&gt;*/&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&quot;golang.org/x/net/context&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Cluster &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; opts options&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; options &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; connectionTimeout time.Duration&lt;br/&gt; readTimeout       time.Duration&lt;br/&gt; writeTimeout      time.Duration&lt;br/&gt; logError          &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(ctx context.Context, err error)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 通过一个选项实现为一个函数指针来达到一个目的：设置选项中的数据的状态&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Golang函数指针的用法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Option &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(c *options)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 设置某个参数的一个具体实现，用到了闭包的用法。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 不仅仅只是设置而采用闭包的目的是为了更为优化，更好用，对用户更友好&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;LogError&lt;/span&gt;&lt;span&gt;(f &lt;span&gt;func&lt;/span&gt;(ctx context.Context, err error)&lt;/span&gt;) &lt;span&gt;Option&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(opts *options)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  opts.logError = f&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 对关键数据变量的赋值采用一个方法来实现而不是直接设置&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ConnectionTimeout&lt;/span&gt;&lt;span&gt;(d time.Duration)&lt;/span&gt; &lt;span&gt;Option&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(opts *options)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  opts.connectionTimeout = d&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;WriteTimeout&lt;/span&gt;&lt;span&gt;(d time.Duration)&lt;/span&gt; &lt;span&gt;Option&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(opts *options)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  opts.writeTimeout = d&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ReadTimeout&lt;/span&gt;&lt;span&gt;(d time.Duration)&lt;/span&gt; &lt;span&gt;Option&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(opts *options)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  opts.readTimeout = d&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 构造函数具体实现，传入相关Option，new一个对象并赋值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 如果参数很多，也不需要传入很多参数，只需要传入opts ...Option即可&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NewCluster&lt;/span&gt;&lt;span&gt;(opts ...Option)&lt;/span&gt; *&lt;span&gt;Cluster&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; clusterOpts := options{}&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; _, opt := &lt;span&gt;range&lt;/span&gt; opts {&lt;br/&gt;  &lt;span&gt;// 函数指针的赋值调用&lt;/span&gt;&lt;br/&gt;  opt(&amp;amp;clusterOpts)&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; cluster := &lt;span&gt;new&lt;/span&gt;(Cluster)&lt;br/&gt; cluster.opts = clusterOpts&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; cluster&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 前期储备，设定相关参数&lt;/span&gt;&lt;br/&gt; commonsOpts := []Option{&lt;br/&gt;  ConnectionTimeout(&lt;span&gt;1&lt;/span&gt; * time.Second),&lt;br/&gt;  ReadTimeout(&lt;span&gt;2&lt;/span&gt; * time.Second),&lt;br/&gt;  WriteTimeout(&lt;span&gt;3&lt;/span&gt; * time.Second),&lt;br/&gt;  LogError(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(ctx context.Context, err error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  }),&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 终极操作，构造函数&lt;/span&gt;&lt;br/&gt; cluster := NewCluster(commonsOpts...)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 测试验证&lt;/span&gt;&lt;br/&gt; fmt.Println(cluster.opts.connectionTimeout)&lt;br/&gt; fmt.Println(cluster.opts.writeTimeout)&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了构造函数这个思想之外，还有一个思想，就是我们要善于利用 struct 封装对象方法，然后再 new 一个对象出来，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Cluster &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; opts options&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NewCluster&lt;/span&gt;&lt;span&gt;(opts ...Option)&lt;/span&gt; *&lt;span&gt;Cluster&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   ....&lt;br/&gt;&lt;br/&gt; cluster := &lt;span&gt;new&lt;/span&gt;(Cluster)&lt;br/&gt; cluster.opts = clusterOpts&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; cluster&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2 优雅的实现继承编程思想&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Golang 里面没有 C++ 、Java 那种继承的实现方式，但是，我们可以通过 Golang 的匿名组合来实现继承，这里要注意，这个是实际编程中经常用到的一种姿势。具体实现就是一个 struct 里面包含一个匿名的 struct，也就是通过匿名组合，这最基础的基类就是一个 struct 结构，然后定义相关成员变量，然后再定义一个子类，也是一个 struct，里面包含前面的 struct，即可实现继承。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例代码如下，代码里面有详细的解释：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 【基类】&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//定义一个最基础的struct类MsgModel，里面包含一个成员变量msgId&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; MsgModel &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; msgId   &lt;span&gt;int&lt;/span&gt;&lt;br/&gt; msgType &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// MsgModel的一个成员方法，用来设置msgId&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(msg *MsgModel)&lt;/span&gt; &lt;span&gt;SetId&lt;/span&gt;&lt;span&gt;(msgId &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; msg.msgId = msgId&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(msg *MsgModel)&lt;/span&gt; &lt;span&gt;SetType&lt;/span&gt;&lt;span&gt;(msgType &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; msg.msgType = msgType&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//【子类】&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 再定义一个struct为GroupMsgModel，包含了MsgModel，即组合，但是并没有给定MsgModel任何名字，因此是匿名组合&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; GroupMsgModel &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; MsgModel&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 如果子类也包含一个基类的一样的成员变量，那么通过子类设置和获取得到的变量都是基类的&lt;/span&gt;&lt;br/&gt; msgId &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(group *GroupMsgModel)&lt;/span&gt; &lt;span&gt;GetId&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; group.msgId&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/*&lt;br/&gt;func (group *GroupMsgModel) SetId(msgId int) {&lt;br/&gt; group.msgId = msgId&lt;br/&gt;}&lt;br/&gt;*/&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; group := &amp;amp;GroupMsgModel{}&lt;br/&gt;&lt;br/&gt; group.SetId(&lt;span&gt;123&lt;/span&gt;)&lt;br/&gt; group.SetType(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;group.msgId =&quot;&lt;/span&gt;, group.msgId, &lt;span&gt;&quot;\tgroup.MsgModel.msgId =&quot;&lt;/span&gt;, group.MsgModel.msgId)&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;group.msgType =&quot;&lt;/span&gt;, group.msgType, &lt;span&gt;&quot;\tgroup.MsgModel.msgType =&quot;&lt;/span&gt;, group.MsgModel.msgType)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3 优雅的实现虚多态编程思想&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面向对象编程中，我们很多情况下，都会定义一个虚基类，然后利用多态去实现各种相似的场景或者说任务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Golang 里面可以通过 interface + struct 来实现虚基类的用法。interface 用来定义一个 &quot;虚基类&quot;，然后一个 struct 结构定义，用来实现这个 interface 中定义的方法，并且可以有多个类似的 struct 来实现这个 interface，只要实现了这个 interface 中定义的方法即可。这也是典型的多态的一种编程思想，也就是说 Golang 通过接口去实现了多态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体流程如下，这个是我实际项目（大型 IM 架构）中的实现方式：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;定义一个 interface 接口 MsgModel，包含了一些方法，这个就相当于 &quot;虚基类&quot;&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; MsgModel &lt;span&gt;interface&lt;/span&gt; {&lt;br/&gt;    Persist(context context.Context, msg &lt;span&gt;interface&lt;/span&gt;{}) &lt;span&gt;bool&lt;/span&gt;&lt;br/&gt;    PersistOnSensitive(context context.Context, session_type, level, SensitiveStatus &lt;span&gt;int32&lt;/span&gt;, msg &lt;span&gt;interface&lt;/span&gt;{}) &lt;span&gt;bool&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;定义一个类型 msgModelImpl struct{}，用来实现上面的 interface 接口&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;定义一个&lt;span&gt;struct&lt;/span&gt;用来实现接口类型&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; msgModelImpl &lt;span&gt;struct&lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;定义一个变量MsgModelImpl等于msgModelImpl，相当于可以通过MsgModelImpl来调用msgModelImpl的成员&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; MsgModelImpl = msgModelImpl{}&lt;br/&gt;&lt;br/&gt;实现接口的两个方法&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(m msgModelImpl)&lt;/span&gt; &lt;span&gt;Persist&lt;/span&gt;&lt;span&gt;(context context.Context, msgIface &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;// 具体实现省略&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(m msgModelImpl)&lt;/span&gt; &lt;span&gt;UpdateDbContent&lt;/span&gt;&lt;span&gt;(context context.Context, msgIface &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;// 具体实现省略&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;再定义一个 struct 类型的 msgService，包含上述接口类型 MsgModel，相当于组合了。这样的话，这个类型就需要要实现接口方法。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; msgService &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;   msgModel MsgModel&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;再定义一个变量 MsgService，首字母大写，并且赋值为 msgService 对象，同时给成员 msgModel 赋值为上述已经实现了接口的 struct 对象 MsgModelImpl。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;将上述已经实现接口类型的类型(MsgModelImpl) 赋值给此变量(此变量并且要是包含了接口类型的类型), 然后这个变量就可以供外部调用&lt;br/&gt;&lt;span&gt;var&lt;/span&gt;  MsgService = msgService{&lt;br/&gt;        msgModel:  MsgModelImpl,&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;这样就全部实现了，后面只要通过 MsgService 中的接口方法就可以调用 interface 中定义的方法&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;注意，定义个 MsgService，里面的成员变量 msgModel 赋值为 MsgModelImpl 的目的是为了做封装，对外暴露接口的都是 MsgService，隐藏了内部具体的 MsgModelImpl 实现。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol start=&quot;6&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;小结：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;MsgModel 是一个 interface&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;interface 是一组抽象方法的集合，interface 未具体实现的方法，仅包含方法名参数返回值的方法&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;msgModelImpl 是一个 struct，它实现了 MsgModel 这个 interface 的所有方法&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果实现了 interface 中的所有方法，即该类/对象就实现了该接口&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;MsgModelImpl 是 msgModelImpl 这个 struct 的对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;msgService 是一个 struct，它包含了 MsgModel，相当于组合&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;MsgService 是 msgService 这个 struct 的对象，并对成员变量赋值&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;后面就通过 MsgService 对外提供服务，隐藏内部具体的 MsgModelImpl 实现。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4 Golang 的 model service 模型【类 MVC 模型】&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在一个项目工程中，为了使得代码更优雅，需要抽象出一些模型出来，同时基于 C++面向对象编程的思想，需要考虑到一些类、继承相关。在 Golang 中，没有类、继承的概念，但是我们完全可以通过 struct 和 interface 来建立我们想要的任何模型。在我们的工程中，抽象出一种我自认为是类似 MVC 的模型，但是不完全一样，个人觉得这个模型抽象的比较好，容易扩展，模块清晰。对于使用 java 和 PHP 编程的同学对这个模型应该是再熟悉不过了，我这边通过代码来说明下这个模型&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;首先一个 model 包，通过 interface 来实现，包含一些基础方法，需要被外部引用者来具体实现&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; model&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 定义一个基础model&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; MsgModel &lt;span&gt;interface&lt;/span&gt; {&lt;br/&gt; Persist(context context.Context, msg &lt;span&gt;interface&lt;/span&gt;{}) &lt;span&gt;bool&lt;/span&gt;&lt;br/&gt; UpdateDbContent(context context.Context, msgIface &lt;span&gt;interface&lt;/span&gt;{}) &lt;span&gt;bool&lt;/span&gt;&lt;br/&gt; GetList(context context.Context, uid, peerId, sinceMsgId, maxMsgId &lt;span&gt;int64&lt;/span&gt;, count &lt;span&gt;int&lt;/span&gt;) (&lt;span&gt;interface&lt;/span&gt;{}, &lt;span&gt;bool&lt;/span&gt;)]&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;再定义一个 msg 包，用来具体实现 model 包中 MsgModel 模型的所有方法&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; msg&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; msgModelImpl &lt;span&gt;struct&lt;/span&gt;{}&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; MsgModelImpl = msgModelImpl{}&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(m msgModelImpl)&lt;/span&gt; &lt;span&gt;Persist&lt;/span&gt;&lt;span&gt;(context context.Context, msgIface &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// 具体实现&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(m msgModelImpl)&lt;/span&gt; &lt;span&gt;UpdateDbContent&lt;/span&gt;&lt;span&gt;(context context.Context, msgIface &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 具体实现&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;GetList&lt;/span&gt;&lt;span&gt;(context context.Context, uid, peerId, sinceMsgId, maxMsgId &lt;span&gt;int64&lt;/span&gt;, count &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;span&gt;interface&lt;/span&gt;{}, &lt;span&gt;bool&lt;/span&gt;)&lt;/span&gt;]&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 具体实现&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;model 和 具体实现方定义并实现 ok 后，那么就还需要一个 service 来统筹管理&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; service&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 定义一个msgService struct包含了model里面的UserModel和MsgModel两个model&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; msgService &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; userModel  model.UserModel&lt;br/&gt; msgModel   model.MsgModel&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 定义一个MsgService的变量，并初始化，这样通过MsgService，就能引用并访问model的所有方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; (&lt;br/&gt;    MsgService = msgService{&lt;br/&gt;  userModel:      user.UserModelImpl,&lt;br/&gt;  msgModel:       msg.MsgModelImpl,&lt;br/&gt; }&lt;br/&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;调用访问&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; service&lt;br/&gt;service.MsgService.Persist(ctx, xxx)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结一下，model 对应 MVC 的 M，service 对应 MVC 的 C， 调用访问的地方对应 MVC 的 V&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5 Golang 单例模式&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单例模式是一种常用的软件设计模式，在它的核心结构中只包含一个被称为单例的特殊类，通过单例模式可以保证系统中一个类有且仅有一个实例且该实例可以被外界访问。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Golang 中有一种非常优雅的姿势可以实现，就是通过 sync.Once 来实现，这个也是我在实际项目中所应用的，示例如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt;  &lt;span&gt;&quot;github.com/dropbox/godropbox/singleton&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; SingleService = singleton.NewSingleton(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;(&lt;span&gt;interface&lt;/span&gt;{}, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &amp;amp;singleMsgProxy{&lt;br/&gt;  MsgModel: msg.MsgModelImpl,&lt;br/&gt; }, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;singleton.NewSingleton 就是具体单例模式的实现，然后赋值给 SingleService，这样，在程序中任何需要获取这个对象的时候，就直接通过 SingleService 来调用，这个调用，系统会保证，里面的 singleMsgProxy 只会被初始化对象一次，这个 singleMsgProxy 就是 new 了一个对象，并且这个对象是只需要被初始化一次的。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6 Golang layout&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Golang 工程 Layout 规范，网上有较多探讨，每个人的理解也会不一致，但是有些基础的理解是可以保持统一的：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;cmd&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;main 函数文件目录，这个目录下面，每个文件在编译之后都会生成一个可执行的文件。如果只有一个 app 文件，那就是 main.go。这里面的代码尽可能简单。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;conf&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;config&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;docs&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;pkg&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;底层各种实现，每一种实现封装一个文件夹&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;业界知名开源项目如 Kubernetes、Istio 都是这样的姿势&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;build&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;vendor&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个简单示例如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ tree  -d  -L 2&lt;br/&gt;├── build&lt;br/&gt;├── cmd&lt;br/&gt;│   ├── apply&lt;br/&gt;│   └── check&lt;br/&gt;├── conf&lt;br/&gt;├── config&lt;br/&gt;├── docs&lt;br/&gt;├── pkg&lt;br/&gt;│   ├── apply&lt;br/&gt;│   ├── check&lt;br/&gt;│   ├── files&lt;br/&gt;│   ├── k8s&lt;br/&gt;│   └── options&lt;br/&gt;└── vendor&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7 cmd &amp;amp; command &amp;amp; flag&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家看 Kubernetes 的源码就可以发现，会有这么一个现象，Kubernetes 中会有很多二进制程序，然后每个程序，可能会有不同的指令，然后每个指令都会有很多命令行参数。如果大家对 Kubernetes 有一定了解，那么就知道 kubectl 会有如下命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;kubectl apply  -f  进行部署&lt;br/&gt;kubectl delete -f  删除部署&lt;br/&gt;kubectl get pod    获取 Pod&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么 kubectl 这个二进制程序，如何能够优雅的支持不同的参数呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面，还是以我实际项目工程中的应用为例，来进行演示。效果如下，程序 example 包含两个命令 apply 和 check，还有一个 help 命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ ./example&lt;br/&gt;Usage:&lt;br/&gt;  example[&lt;span&gt;command&lt;/span&gt;]&lt;br/&gt;&lt;br/&gt;Available Commands:&lt;br/&gt;  apply       apply request by json file&lt;br/&gt;  check       check request validity by json file&lt;br/&gt;  &lt;span&gt;help&lt;/span&gt;        Help about any &lt;span&gt;command&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;Flags:&lt;br/&gt;      --config string   config file[/.xx.yaml] (default &lt;span&gt;&quot;none&quot;&lt;/span&gt;)&lt;br/&gt;  -h, --&lt;span&gt;help&lt;/span&gt;            &lt;span&gt;help&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; example&lt;br/&gt;      --mode string     mode[cpu  or all] (default &lt;span&gt;&quot;cpu&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;Use &lt;span&gt;&quot;example[command] --help&quot;&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; more information about a &lt;span&gt;command&lt;/span&gt;.&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码示例如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;main 入口&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; log &lt;span&gt;&quot;github.com/sirupsen/logrus&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;github.com/spf13/cobra&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;github.com/spf13/pflag&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&quot;example/cmd/apply&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;example/cmd/check&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;example/config&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; cmdCheck = check.NewVPARequestCheck()&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; cmdApply = apply.NewVPARequestApply()&lt;br/&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; rootCmd = &amp;amp;cobra.Command{Use: &lt;span&gt;&quot;example&quot;&lt;/span&gt;}&lt;br/&gt;&lt;br/&gt; flags := rootCmd.PersistentFlags()&lt;br/&gt; addFlags(flags)&lt;br/&gt;&lt;br/&gt; rootCmd.AddCommand(cmdApply, cmdCheck)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err := rootCmd.Execute(); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;panic&lt;/span&gt;(err)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;addFlags&lt;/span&gt;&lt;span&gt;(flags *pflag.FlagSet)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; flags.StringVar(&amp;amp;config.Cfg.KubeConfig, &lt;span&gt;&quot;config&quot;&lt;/span&gt;, &lt;span&gt;&quot;none&quot;&lt;/span&gt;, &lt;span&gt;&quot;config file[/.xx.yaml]&quot;&lt;/span&gt;)&lt;br/&gt; flags.StringVar(&amp;amp;config.Cfg.Mode, &lt;span&gt;&quot;mode&quot;&lt;/span&gt;, &lt;span&gt;&quot;cpu&quot;&lt;/span&gt;, &lt;span&gt;&quot;mode[cpu  or all]&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;check 命令实现如下，具体 check 相关的 Run 方法忽略：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; check&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt; log &lt;span&gt;&quot;github.com/sirupsen/logrus&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;github.com/spf13/cobra&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;example/config&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;example/pkg/check&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;example/pkg/files&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; RequestCheckOptions &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; configPath &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NewRequestCheckOptions&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; *&lt;span&gt;RequestCheckOptions&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; o := &amp;amp;RequestCheckOptions{}&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; o&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NewVPARequestCheck&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; *&lt;span&gt;cobra&lt;/span&gt;.&lt;span&gt;Command&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; o := NewRequestCheckOptions()&lt;br/&gt; cmd := &amp;amp;cobra.Command{&lt;br/&gt;  Use:   &lt;span&gt;&quot;check [json file]&quot;&lt;/span&gt;,&lt;br/&gt;  Short: &lt;span&gt;&quot;check request validity by json file&quot;&lt;/span&gt;,&lt;br/&gt;  Long:  &lt;span&gt;&quot;check request by new request json file&quot;&lt;/span&gt;,&lt;br/&gt;  Args:  cobra.MinimumNArgs(&lt;span&gt;1&lt;/span&gt;),&lt;br/&gt;  RunE: &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(c *cobra.Command, args []&lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; err := o.Run(args); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; cmd&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;apply 命令如下，具体 apply 相关的 Run 方法忽略：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; apply&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;github.com/spf13/cobra&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;example/pkg/apply&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;example/pkg/files&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; RequestApplyOptions &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; configPath &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NewRequestApplyOptions&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; *&lt;span&gt;RequestApplyOptions&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; o := &amp;amp;RequestApplyOptions{}&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; o&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NewVPARequestApply&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; *&lt;span&gt;cobra&lt;/span&gt;.&lt;span&gt;Command&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; o := NewRequestApplyOptions()&lt;br/&gt;&lt;br/&gt; cmd := &amp;amp;cobra.Command{&lt;br/&gt;  Use:   &lt;span&gt;&quot;apply [json file]&quot;&lt;/span&gt;,&lt;br/&gt;  Short: &lt;span&gt;&quot;apply request by json file&quot;&lt;/span&gt;,&lt;br/&gt;  Long:  &lt;span&gt;&quot;apply request by new request json file&quot;&lt;/span&gt;,&lt;br/&gt;  Args:  cobra.MinimumNArgs(&lt;span&gt;1&lt;/span&gt;),&lt;br/&gt;  RunE: &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(c *cobra.Command, args []&lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; err := o.Run(args); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; cmd&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后只需要在各自的 Run 方法中实现对应的逻辑即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;腾讯程序员视频号最新视频&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAAtlEijNHxUgAAAAstQy6ubaLX4KHWvLEZgBPEzqEwNDVBF6n9zNPgMIv6K8U41VM0i7Hn65qzss8T&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=rjD5jyTuFrIpZ2ibE8T7Ym3K77SEULgkiau3B3zBUa5D6g5AI9rukJNDe9l7ASbTuq8Yeicgibv7Nw5tegFnhRhYicprlWFgtncGZzm2iaCrId3p0&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SZ&amp;amp;idx=1&amp;amp;m=&amp;amp;scene=0&amp;amp;token=x5Y29zUxcibDYtzsnaaic8ibnLljZOptaw2a7BpE6Kicrz70Qv1FCicYqBgddYicesNwVP4wxgDvibibtbs&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/I7awtksbibjQe7RZAy84xESOBAfIZ8xQ9ApXt4uTe8po/0&quot; data-username=&quot;v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder&quot; data-nickname=&quot;腾讯程序员&quot; data-desc=&quot;腾讯水墨画，带你感受中国山水画的魅力&amp;#10;#水墨画 #小程序&quot; data-nonceid=&quot;15312916135145489939&quot; data-type=&quot;video&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ee2f5019b581680daa37a6b766b5a15c</guid>
<title>[译] 为 K8s workload 引入的一些 BPF datapath 扩展 (LPC, 2021)</title>
<link>https://toutiao.io/k/xsrnnj7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post&quot;&gt;
  
  &lt;h1 class=&quot;postTitle&quot;&gt;[译] 为 K8s workload 引入的一些 BPF datapath 扩展（LPC, 2021）&lt;/h1&gt;
  &lt;p class=&quot;meta&quot;&gt;Published at 2021-11-24 | Last Update 2021-11-24&lt;/p&gt;

  
  
  &lt;h3 id=&quot;译者序&quot;&gt;译者序&lt;/h3&gt;

&lt;p&gt;本文翻译自 LPC 2021 的一篇分享：
&lt;a href=&quot;https://linuxplumbersconf.org/event/11/contributions/953/&quot;&gt;BPF datapath extensions for K8s workloads&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;作者 Daniel Borkmann 和 Martynas Pumputis 都是 Cilium 的核心开发。
翻译时补充了一些背景知识、代码片段和链接，以方便理解。&lt;/p&gt;

&lt;p&gt;翻译已获得作者授权。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;由于译者水平有限，本文不免存在遗漏或错误之处。如有疑问，请查阅原文。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;以下是译文。&lt;/p&gt;

&lt;hr/&gt;



&lt;hr/&gt;

&lt;p&gt;今天分享一些我们在开发 Cilium datapath 过程中遇到的有趣问题。&lt;/p&gt;

&lt;h1 id=&quot;0-引言&quot;&gt;0 引言&lt;/h1&gt;

&lt;h2 id=&quot;01-cilium-datapath-基础&quot;&gt;0.1 Cilium datapath 基础&lt;/h2&gt;

&lt;p&gt;Cilium BPF datapath 的设计与实现我们在过去几年已分享过多次，这里不再赘述。
有需要请参考：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/cilium-scale-k8s-service-with-bpf-zh/&quot;&gt;利用 eBPF 支撑大规模 K8s Service (LPC, 2019)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/cilium-k8s-service-lb-zh/&quot;&gt;基于 BPF/XDP 实现 K8s Service 负载均衡 (LPC, 2020)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/advanced-bpf-kernel-features-for-container-age-zh/&quot;&gt;为容器时代设计的高级 eBPF 内核特性（FOSDEM, 2021）&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;接下来重点看下过去一年的几个新变化。&lt;/p&gt;

&lt;h2 id=&quot;02-cilium-datapath-几个新变化&quot;&gt;0.2 Cilium datapath 几个新变化&lt;/h2&gt;

&lt;p&gt;如下图所示，最近一年 Cilium 有一些新的变化：&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/bpf-datapath-ext-for-k8s/cilium-service-lb.png&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;Cilium Service LB&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Cilium 不再只能作为普通 k8s 节点上的网络 agent，而可以作为&lt;strong&gt;&lt;mark&gt;独立的四层负载均（L4LB）&lt;/mark&gt;&lt;/strong&gt; 节点运行了；&lt;/li&gt;
  &lt;li&gt;Service 负载均衡支持了&lt;strong&gt;&lt;mark&gt;一致性哈希（Maglev 算法）&lt;/mark&gt;&lt;/strong&gt;；&lt;/li&gt;
  &lt;li&gt;新引入了一个 &lt;strong&gt;&lt;mark&gt;pcap recorder&lt;/mark&gt;&lt;/strong&gt;，增强 LB 流量的可观测性；&lt;/li&gt;
  &lt;li&gt;为 health probe 引入了一个新的 datapath extension；&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;支持通过 &lt;strong&gt;&lt;mark&gt;IPIP 封装&lt;/mark&gt;&lt;/strong&gt;转发 DSR 流量。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;这是 1.10 的新特性，但这个“新特性”反而是回归到了传统 DSR（为了兼容客户的
基础设施）。&lt;strong&gt;&lt;mark&gt;在此之前，例如 1.9，Cilium 的 DSR 设计是非常巧妙的&lt;/mark&gt;&lt;/strong&gt;，
无需隧道封装，也不要求 LB 节点和 backend 节点在同一个二层网络。有兴趣可参考：
&lt;a href=&quot;/blog/k8s-l4lb/&quot;&gt;L4LB for Kubernetes: Theory and Practice with Cilium+BGP+ECMP&lt;/a&gt;。
译注。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;总体来说，Cilium BPF datapath 的&lt;strong&gt;&lt;mark&gt;核心设计理念&lt;/mark&gt;&lt;/strong&gt;是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对于东西向流量，尽量靠近 socket 层处理；&lt;/li&gt;
  &lt;li&gt;对于南北向流量，尽量靠近网卡驱动处理。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;03-本文提纲&quot;&gt;0.3 本文提纲&lt;/h2&gt;

&lt;p&gt;本文接下来将介绍以下内容：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;cgroup v1/v2 干扰问题&lt;/li&gt;
  &lt;li&gt;TCP pacing for Pods from initns&lt;/li&gt;
  &lt;li&gt;自维护的邻居表项（neighbor entries）和 FIB 扩展&lt;/li&gt;
  &lt;li&gt;BPF map 通配符查找&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;1-cgroup-v1v2-干扰问题&quot;&gt;1 cgroup v1/v2 干扰问题&lt;/h1&gt;

&lt;p&gt;很多 Linux 发行版上&lt;strong&gt;&lt;mark&gt;默认同时启用了 cgroup v1/v2&lt;/mark&gt;&lt;/strong&gt;，导致一些干扰问题。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;例如，&lt;strong&gt;&lt;mark&gt;在 Ubuntu 20.04 上查看&lt;/mark&gt;&lt;/strong&gt;：&lt;/p&gt;

  &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;mount | &lt;span class=&quot;nb&quot;&gt;grep &lt;/span&gt;cgroup
cgroup2 on /sys/fs/cgroup/unified &lt;span class=&quot;nb&quot;&gt;type &lt;/span&gt;cgroup2 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;rw,nosuid,nodev,noexec,relatime,nsdelegate&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
cgroup on /sys/fs/cgroup/systemd &lt;span class=&quot;nb&quot;&gt;type &lt;/span&gt;cgroup &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;rw,nosuid,nodev,noexec,relatime,xattr,name&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;systemd&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
cgroup on /sys/fs/cgroup/blkio &lt;span class=&quot;nb&quot;&gt;type &lt;/span&gt;cgroup &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;rw,nosuid,nodev,noexec,relatime,blkio&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;

  &lt;p&gt;第一行表示挂载了 cgroupv2，后面几行表示挂载了（某些）cgroupv1。
译注。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;11-普通节点v1v2-同时挂载没问题&quot;&gt;1.1 普通节点：v1/v2 同时挂载没问题&lt;/h2&gt;

&lt;p&gt;对于一台普通节点，同时挂载 cgroup v1/v2 后，它们在系统中的&lt;strong&gt;&lt;mark&gt;典型布局&lt;/mark&gt;&lt;/strong&gt;（layout）将如下：&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/bpf-datapath-ext-for-k8s/cgroupv2-layout.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;图中标出了哪些是 v1 挂载点，哪些是 v2 挂载点。简单来说：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;v1 是以 controller 维度挂载的，因此看到大部分文件（目录）都属于 cgroup v1；&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;v2 是以进程维度挂载的单一层级树（unified hierarchy），因此顶层&lt;strong&gt;&lt;mark&gt;只有一个挂载点&lt;/mark&gt;&lt;/strong&gt;（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/sys/fs/cgroup/unified&lt;/code&gt;）。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;&lt;mark&gt;只有 v2 支持 attach bpf 程序&lt;/mark&gt;&lt;/strong&gt;，例如 hook &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;connect&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bind&lt;/code&gt; 等系统调用；因此
 socket-level service LB 之类的代码，只能 attach 到 cgroup v2。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;/blog/bpf-advanced-notes-1-zh/&quot;&gt;BPF 进阶笔记（一）：BPF 程序（BPF Prog）类型详解：使用场景、函数签名、执行位置及程序示例&lt;/a&gt;
在&lt;mark&gt;内核代码层面介绍了为什么 cgroup v2 支持 socket-level BPF&lt;/mark&gt;。&lt;/p&gt;

  &lt;p&gt;另外，想深入了解 cgroup v1/v2 的区别，可参考
&lt;a href=&quot;/blog/cgroupv2-zh/&quot;&gt;&lt;mark&gt;(译) Control Group v2（cgroupv2 权威指南）（KernelDoc, 2021）&lt;/mark&gt;&lt;/a&gt;。
译注。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这种&lt;strong&gt;&lt;mark&gt;普通节点&lt;/mark&gt;&lt;/strong&gt;上，v1/v2 同时挂载是没问题的。下面再看一种&lt;strong&gt;&lt;mark&gt;特殊节点&lt;/mark&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;12-嵌套虚拟化节点&quot;&gt;1.2 嵌套虚拟化节点&lt;/h2&gt;

&lt;h3 id=&quot;121-kind-k8s-in-docker&quot;&gt;1.2.1 KIND (K8s-In-Docker)&lt;/h3&gt;

&lt;p&gt;KIND 是一个将 k8s 完全跑在容器里的项目 —— 包括 worker node —— 也就是说：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;先起一个或多个容器作为 k8s node，里面装上 kubelet、cilium-agent 等组件，然后&lt;/li&gt;
  &lt;li&gt;kubelet 在这些 worker node&lt;strong&gt;&lt;mark&gt;（容器）里再创创建容器&lt;/mark&gt;&lt;/strong&gt;（pod）。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;显然，这个项目的好处是&lt;strong&gt;&lt;mark&gt;只需要一台真实 node&lt;/mark&gt;&lt;/strong&gt;（物理机或虚拟机），
就能&lt;strong&gt;&lt;mark&gt;搭建一个多 node k8s 集群&lt;/mark&gt;&lt;/strong&gt;，方便测试和开发。&lt;/p&gt;

&lt;h3 id=&quot;122-kind-worker-node-cgroup-layout&quot;&gt;1.2.2 KIND-worker-node cgroup layout&lt;/h3&gt;

&lt;p&gt;为方便讨论，先对两种 node 做一下名字上的区分，简单起见：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;将部署 KIND 的这台机器称为 &lt;strong&gt;&lt;mark&gt;bm-node&lt;/mark&gt;&lt;/strong&gt;，虽然它可能是一台物理服务器，也可能是一台虚拟机；&lt;/li&gt;
  &lt;li&gt;将 bm-node 内虚拟化出来的 worker node 称为 &lt;strong&gt;&lt;mark&gt;k8s-node&lt;/mark&gt;&lt;/strong&gt;，这种 node 都是容器。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有了以上区分，我们再来看 cgroup 的挂载情况：&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/bpf-datapath-ext-for-k8s/cgroupv2-layout-k8s-in-docker.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以看到，&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;每个 k8s-node 内，看到的都是自己独立的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/sys/fs/cgroup/&lt;/code&gt; 挂载点；而同时，&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;由于 &lt;strong&gt;&lt;mark&gt;k8s-node 都是容器&lt;/mark&gt;&lt;/strong&gt;，因此它们的&lt;strong&gt;&lt;mark&gt;文件路径又都会映射到 bm-node 上&lt;/mark&gt;&lt;/strong&gt;；&lt;/p&gt;

    &lt;p&gt;具体来说，图中两个 k8s-node 的挂载点 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/sys/fs/cgroup/&lt;/code&gt;，将分别&lt;strong&gt;&lt;mark&gt;映射到 bm-node 的以下路径&lt;/mark&gt;&lt;/strong&gt;：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/sys/fs/cgroup/docker-node-a/&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/sys/fs/cgroup/docker-node-b/&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这种会导致什么问题呢？&lt;/p&gt;

&lt;h3 id=&quot;123-带来的问题&quot;&gt;1.2.3 带来的问题&lt;/h3&gt;

&lt;p&gt;考虑到：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;cilium-agent 运行在 k8s-node 内&lt;/li&gt;
  &lt;li&gt;cilium-agent 会将 BPF 程序加载到&lt;strong&gt;&lt;mark&gt;它的视角看到的 cgroup root 挂载点&lt;/mark&gt;&lt;/strong&gt;（即 k8s-node 中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/sys/fs/cgroup/&lt;/code&gt;）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;那么，&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;cilium-agent 在 &lt;strong&gt;&lt;mark&gt;k8s-node 中 attach 的 BPF 程序&lt;/mark&gt;&lt;/strong&gt;，其实最终是 &lt;strong&gt;&lt;mark&gt;attach 到了 bm-node&lt;/mark&gt;&lt;/strong&gt;
  的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/sys/fs/cgroup/docker-node-a/&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/sys/fs/cgroup/docker-node-b/&lt;/code&gt; 路径下；&lt;/li&gt;
  &lt;li&gt;而 &lt;strong&gt;&lt;mark&gt;BPF 程序要能工作，必须 attach 到 bm-node 的 cgroup root 挂载点&lt;/mark&gt;&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;因此，在这种嵌套虚拟化的场景下，我们的 BPF datapath 就失效了，如下图所示：&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/bpf-datapath-ext-for-k8s/cgroupv2-layout-k8s-in-docker-problem.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;13-问题分析历史代码假设-v1v2-不会同时启用&quot;&gt;1.3 问题分析：历史代码假设 v1/v2 不会同时启用&lt;/h2&gt;

&lt;p&gt;先给一下背景介绍。&lt;/p&gt;

&lt;p&gt;cgroup &lt;strong&gt;&lt;mark&gt;v1 中某些控制器有 tagging 功能&lt;/mark&gt;&lt;/strong&gt;。例如，&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;net_prio 控制器会直接在 sock 上设置 一些属性，这样后面在
&lt;strong&gt;&lt;mark&gt;tc qdisc 上就能根据这些 tags 过滤&lt;/mark&gt;&lt;/strong&gt; socket 和对流量进行分类。&lt;/li&gt;
  &lt;li&gt;net_prio 控制器也是类似的，它的功能是给包设置优先级（priority），后面也是被 tc 使用。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而在 v2 中，每个 &lt;strong&gt;&lt;mark&gt;sock 是关联到&lt;/mark&gt;&lt;/strong&gt;创建这个 sock 时&lt;strong&gt;&lt;mark&gt;所在的 cgroup&lt;/mark&gt;&lt;/strong&gt;，
在&lt;strong&gt;&lt;mark&gt;网络层直接 match cgroup&lt;/mark&gt;&lt;/strong&gt;（而不是 socket 本身）。&lt;/p&gt;

&lt;p&gt;引入 v2 之后，&lt;strong&gt;&lt;mark&gt;socket cgroup 结构体&lt;/mark&gt;&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;struct sock_cgroup_data&lt;/code&gt;
增加了另一个指针，指向 v2 object 对象。
为避免结构体膨胀以及出于性能考虑，当时将这个结构体&lt;strong&gt;&lt;mark&gt;改造成了 union，节省了 8 个字节&lt;/mark&gt;&lt;/strong&gt;，
代码 diff 如下：&lt;/p&gt;

&lt;div class=&quot;language-diff highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gi&quot;&gt;+/*
+ * sock_cgroup_data is embedded at sock-&amp;gt;sk_cgrp_data and contains
+ * per-socket cgroup information except for memcg association.
+ ...
+
&lt;/span&gt; struct sock_cgroup_data {
&lt;span class=&quot;gd&quot;&gt;-u16prioidx;
-u32classid;
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+union {
+#ifdef __LITTLE_ENDIAN
+struct {
+u8is_data;
+u8padding;
+u16prioidx;
+u32classid;
+} __packed;
+#else
+struct {
+u32classid;
+u16prioidx;
+u8padding;
+u8is_data;
+} __packed;
+#endif
+u64val;
+};
&lt;/span&gt; };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;改动之后的逻辑（来自源码注释）：&lt;/p&gt;

  &lt;p&gt;启动时，sock_cgroup_data 会记录这个 sock 创建时它所在的 cgroup，因此后面可以直接匹配 v2；
但如果 net_prio or net_cls 开始使用之后，这个字段就会被 v1 的 prioidx and/or
classid 所覆盖。区分这里存储的是 v1 还是 v2 数据的方式：根据 lowest bit&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;如果为 1：存储的就是 v1 的 prioidx 和 classid&lt;/li&gt;
    &lt;li&gt;如果为 0：存储的就是 v2 cgroup 对象的指针&lt;/li&gt;
  &lt;/ol&gt;

  &lt;p&gt;译注。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;&lt;mark&gt;以上改动的假设是&lt;/mark&gt;&lt;/strong&gt;：&lt;a href=&quot;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=bd1060a1d67128bb8fbe2e1384c518912cbe54e7&quot;&gt;v1 和 v2 不会同时使用&lt;/a&gt;。
一台机器要么使用 v1，要么使用 v2。但今天的实际情况是：v1 和 v2 同时挂载了。
那么，在 fast path 上看起来是什么样的逻辑呢？&lt;/p&gt;

&lt;p&gt;当执行 bpf 程序时，例如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;connect&lt;/code&gt; 系统调用，socket bpf helper 会获取相应的 cgroup v2 对象，&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;例如，下面这两个系统调用：&lt;/p&gt;

  &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;BPF_CALL_1(bpf_skb_cgroup_id, skb)
           |-__bpf_sk_cgroup_id(skb-&amp;gt;sk)
              |-cgrp = sock_cgroup_ptr(&amp;amp;sk-&amp;gt;sk_cgrp_data)
              |-return cgroup_id(cgrp)

BPF_CALL_2(bpf_skb_ancestor_cgroup_id, skb, ancestor_level)
           |-__bpf_sk_ancestor_cgroup_id(skb-&amp;gt;sk, ancestor_level)
              |-cgrp = sock_cgroup_ptr(&amp;amp;sk-&amp;gt;sk_cgrp_data)
              |-ancestor = cgroup_ancestor(cgrp, ancestor_level)
              |-return cgroup_id(ancestor)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;

  &lt;p&gt;译注。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;helper 最终会调用到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sock_cgroup_ptr()&lt;/code&gt;，注意这个函数只会被 cgroup v2 调用：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// https://github.com/torvalds/linux/blob/v5.10/include/linux/cgroup.h#L828&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cgroup&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;sock_cgroup_ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sock_cgroup_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;skcd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#if defined(CONFIG_CGROUP_NET_PRIO) || defined(CONFIG_CGROUP_NET_CLASSID) // 说明使用了 v1
&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                                                      &lt;span class=&quot;c1&quot;&gt;// 而这个函数只会被 v2 使用&lt;/span&gt;
                                                                          &lt;span class=&quot;c1&quot;&gt;// 因此接下来要获取 v2 的 root 地址&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/*
     * @skcd-&amp;gt;val is 64bit but the following is safe on 32bit too as we
     * just need the lower ulong to be written and read atomically.
     */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;READ_ONCE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;skcd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;                      &lt;span class=&quot;c1&quot;&gt;// 如果这个 socket 上使用了 cgroup v1 tagging，则&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cgrp_dfl_root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cgrp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// fallback 到 cgroup v2 default root&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cgroup&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cgrp_dfl_root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cgrp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#else
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cgroup&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;skcd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#endif
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果有 cgroup v1 tag，就会 fallback 到 cgroup v2 default root。
如果 v1/v2 不同时使用，那没问题，但同时使用了之后，会怎么样了呢？&lt;/p&gt;

&lt;p&gt;因为必须 fallback 到 v2。在 bm-node 上，对应的就是&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/sys/fs/cgroup/docker-node-a/&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/sys/fs/cgroup/docker-node-b/&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;等目录。而 bm-node 上的 cgroup v2 hook 是监听在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/sys/fs/cgroup/&lt;/code&gt; 下面的。这意味着
k8s-node 内的路径会被 bypass。或者说，像 cilium agent 这样 attach 到 root 的行
为，在 k8s-node 内做不了任何事情的。&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/bpf-datapath-ext-for-k8s/cgroupv2-layout-k8s-in-docker-problem.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以看到，管理 v2 是非常复杂和脆弱的，例如，&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;对 cgroup namespaces 或 non-root cgroup paths 的不兼容&lt;/p&gt;

    &lt;p&gt;attach 到 root 就会遇到这个问题。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;在 socket 层做 v2-&amp;gt;v1 的转换，会泄露 v2 对象的引用&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;mark&gt;v2 不可靠的唤醒机制&lt;/mark&gt;&lt;/strong&gt;（unreliable v2 invocation）使 bpf 程序的普及遇到问题&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;第三方 agents 都在加载 bpf 程序，&lt;/li&gt;
      &lt;li&gt;发行版为了最大兼容性，会把能打开的功能全打开。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;14-解决方案v1v2-字段拆开&quot;&gt;1.4 解决方案：v1/v2 字段拆开&lt;/h2&gt;

&lt;div class=&quot;language-diff highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; struct sock_cgroup_data {
&lt;span class=&quot;gd&quot;&gt;-union {
-#ifdef __LITTLE_ENDIAN
-struct {
-u8is_data : 1;
-u8no_refcnt : 1;
-u8unused : 6;
-u8padding;
-u16prioidx;
-u32classid;
-} __packed;
-#else
-struct {
-u32classid;
-u16prioidx;
-u8padding;
-u8unused : 6;
-u8no_refcnt : 1;
-u8is_data : 1;
-} __packed;
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+struct cgroup*cgroup; /* v2 */
+#ifdef CONFIG_CGROUP_NET_CLASSID
+u32classid; /* v1 */
+#endif
+#ifdef CONFIG_CGROUP_NET_PRIO
+u16prioidx; /* v1 */
&lt;/span&gt; #endif
&lt;span class=&quot;gd&quot;&gt;-u64val;
-};
&lt;/span&gt; };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-diff highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; static inline struct cgroup *sock_cgroup_ptr(struct sock_cgroup_data *skcd)
 {
&lt;span class=&quot;gd&quot;&gt;-#if defined(CONFIG_CGROUP_NET_PRIO) || defined(CONFIG_CGROUP_NET_CLASSID)
-unsigned long v;
-
-/*
- * @skcd-&amp;gt;val is 64bit but the following is safe on 32bit too as we
- * just need the lower ulong to be written and read atomically.
- */
-v = READ_ONCE(skcd-&amp;gt;val);
-
-if (v &amp;amp; 3)
-return &amp;amp;cgrp_dfl_root.cgrp;
-
-return (struct cgroup *)(unsigned long)v ?: &amp;amp;cgrp_dfl_root.cgrp;
-#else
-return (struct cgroup *)(unsigned long)skcd-&amp;gt;val;
-#endif
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+return skcd-&amp;gt;cgroup;
&lt;/span&gt; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;永远返回可靠的 cgroup 指针： &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;struct sock_cgroup_data&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;还顺便解决了 v2 引用的泄露问题&lt;/li&gt;
  &lt;li&gt;已经&lt;a href=&quot;https://lore.kernel.org/bpf/20210913230759.2313-1-daniel@iogearbox.net/&quot;&gt;提交&lt;/a&gt;到社区&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;2-tcp-pacing&quot;&gt;2 TCP Pacing&lt;/h1&gt;

&lt;h2 id=&quot;20-基础&quot;&gt;2.0 基础&lt;/h2&gt;

&lt;p&gt;本小节为译注，方便大家理解后面的内容。有基础的可以跳过。&lt;/p&gt;

&lt;h3 id=&quot;201-tcp-pacing&quot;&gt;2.0.1 TCP Pacing&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://homes.cs.washington.edu/~tom/pubs/pacing.pdf&quot;&gt;Understanding the Performance of TCP Pacing&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;TCP’s congestion control  mechanisms  can lead  to  bursty  traffic  flows
on  modern  high-speednetworks,  with  a negative  impact  on  overall
network  efficiency.   A  pro-posed solution to this problem is to
&lt;strong&gt;&lt;mark&gt;evenly space, or “pace”, data sent intothe network  over  an entire round-trip  time&lt;/mark&gt;&lt;/strong&gt;,
so that  data is  not  sent  in  aburst.  In this paper, we quantitatively evaluate this approach.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;202-tcp-bbr-算法&quot;&gt;2.0.2 TCP BBR 算法&lt;/h3&gt;

&lt;p&gt;Google 提出的一种 TCP 流控算法。Linux 内核已经支持。&lt;/p&gt;

&lt;h3 id=&quot;203-tc-fq-fair-queue&quot;&gt;2.0.3 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tc&lt;/code&gt; FQ (Fair Queue)&lt;/h3&gt;

&lt;p&gt;内容来自 &lt;a href=&quot;https://man7.org/linux/man-pages/man8/tc-fq.8.html&quot;&gt;tc-fq(8)&lt;/a&gt; manpage。&lt;/p&gt;

&lt;p&gt;FQ (Fair Queue) 是一个 &lt;strong&gt;&lt;mark&gt;classless packet scheduler&lt;/mark&gt;&lt;/strong&gt;，设计主要用于&lt;strong&gt;&lt;mark&gt;本地生成的流量&lt;/mark&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;设计中，能获得 per-flow pacing。&lt;/li&gt;
  &lt;li&gt;FQ 会对 flow 进行 separation，支持 TCP 协议栈设置的 pacing 要求。&lt;/li&gt;
  &lt;li&gt;所有属于某个 socket 的包，认为是一条 flow。&lt;/li&gt;
  &lt;li&gt;对于非本地流量（router workload），会使用 packet hash 作为 fallback 方式。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;使用方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;应用可以通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setsockopt(SO_MAX_PACING_RATE)&lt;/code&gt; 来指定最大 pacing 速率。&lt;/li&gt;
  &lt;li&gt;FQ 会&lt;strong&gt;&lt;mark&gt;在包之间加入延迟&lt;/mark&gt;&lt;/strong&gt;来达到这个 socket 设置的 rate limitation。&lt;/li&gt;
  &lt;li&gt;在 Linux 4.20 之后，内核&lt;strong&gt;&lt;mark&gt;采用了 EDT&lt;/mark&gt;&lt;/strong&gt; (Earliest Departure Time) 算法，
  TCP 也能直接为每个 skb 设置合适的 Departure Time。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;内部设计：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;从队列 dequeue 是以 round-robin 方式进行的。&lt;/li&gt;
  &lt;li&gt;对于高优先级（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TC_PRIO_CONTROL&lt;/code&gt; priority）包，预留了一个特殊的 FIFO queue，确保包永远会先被 dequeue。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;FQ is non-work-conserving.&lt;/p&gt;

&lt;p&gt;TCP pacing 对于有 idle time 的 flow 来说比较有用，因为拥塞窗口允许
TCP stack 将可能非常多的包一次性插入队列。
This removes the ‘slow start after idle’ choice, badly
hitting large BDP (Bandwidth-delay product) flows and applications delivering chunks of
data such as video streams.&lt;/p&gt;

&lt;p&gt;例子：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;tc qdisc add dev eth0 root fq ce_threshold 4ms

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;tc &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; qdisc show dev eth0
qdisc fq 8001: dev eth0 root refcnt 2 limit 10000p flow_limit 100p buckets 1024 orphan_mask 1023 quantum 3028b initial_quantum 15140b low_rate_threshold 550Kbit refill_delay 40.0ms ce_threshold 4.0ms
Sent 72149092 bytes 48062 pkt &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;dropped 2176, overlimits 0 requeues 0&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
backlog 1937920b 1280p requeues 0
  flows 34 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;inactive 17 throttled 0&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  gc 0 highprio 0 throttled 0 ce_mark 47622 flows_plimit 2176
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;下面回到原作者分享内容。&lt;/p&gt;

&lt;h2 id=&quot;21-k8s-pod-限速&quot;&gt;2.1 K8s pod 限速&lt;/h2&gt;

&lt;p&gt;K8s 模型中可以通过给 pod 打上 ingress/egress bandwidth annotation 对容器进行限速，&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;具体实现交给 k8s CNI plugin（例如，&lt;a href=&quot;https://cilium.io/blog/2020/11/10/cilium-19#bwmanager&quot;&gt;Cilium&lt;/a&gt;
或 &lt;a href=&quot;https://www.cni.dev/plugins/current/meta/bandwidth/&quot;&gt;bandwidth plugin&lt;/a&gt;）&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;怎么实现由插件自己决定，例如：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;K8s bandwidth plugin 组合了 ifb &amp;amp; tbf qdisc&lt;/li&gt;
      &lt;li&gt;Cilium 通过 &lt;strong&gt;&lt;mark&gt;BPF &amp;amp; FQ qdisc&lt;/mark&gt;&lt;/strong&gt;，原生实现了 egress 限速&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;22-cilium-中-pod-egress-限速的实现&quot;&gt;2.2 Cilium 中 pod egress 限速的实现&lt;/h2&gt;

&lt;p&gt;cilium attach 到宿主机的物理设备，然后用 bpf 设置 timestamp，
通过 earliest departure time 在 fq 中实现限速，下图：&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/bpf-datapath-ext-for-k8s/pod-egress-rate-limit.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;复习下 Cilium datapath，细节见去年的分享：&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/bpf-datapath-ext-for-k8s/datapath-forwarding.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;mark&gt;工作流程&lt;/mark&gt;&lt;/strong&gt;：&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/bpf-datapath-ext-for-k8s/datapath-works-today.png&quot;/&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Pod egress 流量从容器进入宿主机，此时会发生 &lt;strong&gt;&lt;mark&gt;netns 切换&lt;/mark&gt;&lt;/strong&gt;，但 socket 信息 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;skb-&amp;gt;sk&lt;/code&gt; 不会丢失；&lt;/li&gt;
  &lt;li&gt;Host veth 上的 BPF 标记（marking）包的 aggregate（queue_mapping），见 &lt;a href=&quot;https://github.com/cilium/cilium/blob/v1.10/bpf/lib/edt.h&quot;&gt;Cilium 代码&lt;/a&gt;；&lt;/li&gt;
  &lt;li&gt;物理网卡上的 BPF 程序根据 aggregate 设置的限速参数，设置每个包的时间戳 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;skb-&amp;gt;tstamp&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;FQ+MQ 根据 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;skb-&amp;gt;tstamp&lt;/code&gt; 调度发包。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;过程中用&lt;strong&gt;&lt;mark&gt;到了 bpf map 存储 aggregate 信息&lt;/mark&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;23-下一步计划支持-tcp-pacing--bbr&quot;&gt;2.3 下一步计划：支持 TCP Pacing &amp;amp; BBR&lt;/h2&gt;

&lt;p&gt;以上流程是没问题的。接下来我们想做的是，&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;&lt;mark&gt;允许 pod 内的 socket 定义自己的 max pacing rate&lt;/mark&gt;&lt;/strong&gt;，或&lt;/li&gt;
  &lt;li&gt;允许&lt;strong&gt;&lt;mark&gt;使用 BBR TCP 流控算法&lt;/mark&gt;&lt;/strong&gt; —— 该算法内部也会用到 pacing。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;想在物理网卡上默认 netns 实现这个功能。
但这个功能目前还是做不到的。&lt;/p&gt;

&lt;h3 id=&quot;231-目前无法支持的原因跨-netns-导致-skb-时间戳被重置&quot;&gt;2.3.1 目前无法支持的原因：跨 netns 导致 skb 时间戳被重置&lt;/h3&gt;

&lt;p&gt;如下图所示：&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/bpf-datapath-ext-for-k8s/datapath-next-steps.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在&lt;strong&gt;&lt;mark&gt;切换 netns 时，skb-&amp;gt;tstamp 会被重置&lt;/mark&gt;&lt;/strong&gt;，因此物理网卡上的
&lt;strong&gt;&lt;mark&gt;FQ 看不到时间戳，无法做限速&lt;/mark&gt;&lt;/strong&gt;（无法计算状态）。
下面是设置 4Gbps 限速所做的测试，会发现完全不稳定：&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/bpf-datapath-ext-for-k8s/datapath-next-steps-2.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们做了个 POC 来保持 the egress timestamp ，在切 netns 时不要重置它，
然后就非常稳定了：&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/bpf-datapath-ext-for-k8s/datapath-next-steps-3.png&quot;/&gt;&lt;/p&gt;

&lt;h3 id=&quot;232-为什么跨-netns-时skb-tstamp-要被重置&quot;&gt;2.3.2 为什么跨 netns 时，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;skb-&amp;gt;tstamp&lt;/code&gt; 要被重置&lt;/h3&gt;

&lt;p&gt;下面介绍一些背景，为什么这个 ts 会被重置。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;几种时间规范：https://www.cl.cam.ac.uk/~mgk25/posix-clocks.html&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对于包的时间戳 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;skb-&amp;gt;tstamp&lt;/code&gt;，内核&lt;strong&gt;&lt;mark&gt;根据包的方向（RX/TX）不同而使用的两种时钟源&lt;/mark&gt;&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;mark&gt;Ingress 使用 CLOCK_TAI&lt;/mark&gt;&lt;/strong&gt; (TAI: international atomic time)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;mark&gt;Egress 使用 CLOCK_MONOTONIC&lt;/mark&gt;&lt;/strong&gt;（也是 &lt;strong&gt;&lt;mark&gt;FQ 使用的时钟类型&lt;/mark&gt;&lt;/strong&gt;）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果不重置，将包&lt;strong&gt;&lt;mark&gt;从 RX 转发到 TX 会导致包在 FQ 中被丢弃&lt;/mark&gt;&lt;/strong&gt;，因为
&lt;a href=&quot;https://github.com/torvalds/linux/blob/v5.10/net/sched/sch_fq.c#L463&quot;&gt;超过 FQ 的 drop horizon&lt;/a&gt;。
FQ &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;horizon&lt;/code&gt; &lt;a href=&quot;https://github.com/torvalds/linux/blob/v5.10/net/sched/sch_fq.c#L950&quot;&gt;默认是 10s&lt;/a&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;horizon&lt;/code&gt; 是 FQ 的一个配置项，表示一个时间长度，
在 &lt;a href=&quot;https://github.com/torvalds/linux/commit/39d010504e6b&quot;&gt;net_sched: sch_fq: add horizon attribute&lt;/a&gt; 引入，&lt;/p&gt;

  &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;QUIC servers would like to use SO_TXTIME, without having CAP_NET_ADMIN,
to efficiently pace UDP packets.

As far as sch_fq is concerned, we need to add safety checks, so
that a buggy application does not fill the qdisc with packets
having delivery time far in the future.

This patch adds a configurable horizon (default: 10 seconds),
and a configurable policy when a packet is beyond the horizon
at enqueue() time:
- either drop the packet (default policy)
- or cap its delivery time to the horizon.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;

  &lt;p&gt;简单来说，如果一个&lt;strong&gt;&lt;mark&gt;包的时间戳离现在太远，就直接将这个包
丢弃，或者将其改为一个上限值&lt;/mark&gt;&lt;/strong&gt;（cap），以便节省队列空间；否则，这种
包太多的话，队列可能会被塞满，导致时间戳比较近的包都无法正常处理。
&lt;a href=&quot;https://github.com/torvalds/linux/blob/v5.10/net/sched/sch_fq.c#L436&quot;&gt;内核代码&lt;/a&gt;如下：&lt;/p&gt;

  &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fq_packet_beyond_horizon&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sk_buff&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;skb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fq_sched_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unlikely&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;skb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tstamp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ktime_cache&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;horizon&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;

  &lt;p&gt;译注。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;另外，现在给定一个包，我们&lt;strong&gt;&lt;mark&gt;无法判断它用的是哪种 timestamp&lt;/mark&gt;&lt;/strong&gt;，因此只能用这种 reset 方式。&lt;/p&gt;

&lt;h3 id=&quot;233-能将-skb-tstamp-统一到同一种时钟吗&quot;&gt;2.3.3 能将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;skb-&amp;gt;tstamp&lt;/code&gt; 统一到同一种时钟吗？&lt;/h3&gt;

&lt;p&gt;其实最开始，TCP &lt;strong&gt;&lt;mark&gt;EDT 用的也是 CLOCK_TAI 时钟&lt;/mark&gt;&lt;/strong&gt;。
但有人在&lt;a href=&quot;https://lore.kernel.org/netdev/2185d09d-90e1-81ef-7c7f-346eeb951bf4@gmail.com/&quot;&gt;邮件列表&lt;/a&gt;
里反馈说，某些特殊的嵌入式设备上重启会导致时钟漂移 50 多年。所以后来
&lt;strong&gt;&lt;mark&gt;EDT 又回到了 monotonic 时钟&lt;/mark&gt;&lt;/strong&gt;，而我们必须跨 netns 时 reset。&lt;/p&gt;

&lt;p&gt;我们做了个原型验证，新加一个 bit &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;skb-&amp;gt;tstamp_base&lt;/code&gt; 来解决这个问题，&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;0 表示使用的 TAI，&lt;/li&gt;
  &lt;li&gt;1 表示使用的 MONO，&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;然后，&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;TX/RX 通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;skb_set_tstamp_{mono,tai}(skb, ktime)&lt;/code&gt; helper 来获取这个值，&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fq_enqueue()&lt;/code&gt; 先检查 timestamp 类型，如果不是 MONO，就 reset &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;skb-&amp;gt;tstamp&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;此外，&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;转发逻辑中所有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;skb-&amp;gt;tstamp = 0&lt;/code&gt; 都可以删掉了&lt;/li&gt;
  &lt;li&gt;skb_mstamp_ns union 也可能删掉了&lt;/li&gt;
  &lt;li&gt;在 RX 方向，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;net_timestamp_check()&lt;/code&gt; 必须推迟到 tc ingress 之后执行&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;24-中场-qa-环节&quot;&gt;2.4 中场 Q&amp;amp;A 环节&lt;/h2&gt;

&lt;h3 id=&quot;问题-1net_timestamp_check-功能是什么检查硬件是否设置了时间戳如果没有就加上&quot;&gt;问题 1：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;net_timestamp_check()&lt;/code&gt; 功能是什么？检查硬件是否设置了时间戳，如果没有就加上？&lt;/h3&gt;

&lt;p&gt;是的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;那为什么它必须要推迟到 tc ingress 之后执行？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;流量跨 netns 从 pod 出去后，就&lt;strong&gt;&lt;mark&gt;重新进入了 RX 路径&lt;/mark&gt;&lt;/strong&gt;，其中会执行主
receive 方法，后者也会调用这个函数，就会将时间戳覆盖掉。&lt;/p&gt;

&lt;p&gt;为了保留 skb 上的 monotonic clock，以便将它&lt;strong&gt;&lt;mark&gt;从 tc ingress 一路带给给物理网卡&lt;/mark&gt;&lt;/strong&gt;（FQ 依据这个做限速），
我们就必须在 tc ingress 之后的位置调用这个函数。&lt;/p&gt;

&lt;h3 id=&quot;问题-2这个时间戳相比于包从容器发出的时刻是有偏差的&quot;&gt;问题 2：这个时间戳相比于包从容器发出的时刻是有偏差的？&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;这么说来，这个时间戳相比于包从容器发出的时刻，其实是有一点偏差的？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;理论上是的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;不知道这个延迟是否很明显？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;（Denial 好像走神了，没回答。）&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;不过我觉得你们实现这套新机制已经很不错了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;问题-3用一个-bit-表示时间戳类型是否够&quot;&gt;问题 3：用一个 bit 表示时间戳类型是否够？&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;我在考虑只用一个 bit 是否够，例如，现在已经有新的 time namespace。
不确定当前容器能否有自己独立的 time namespace，如果有的话，即使是
monotonic time 这个 namespace 内也将是独立的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;理解。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;但我不确定现在的是否有合适的 helpers 来，例如，在包从一个 namespace 进入另一
个 namespace 时，我们是否有方式来对这个时间戳做转换，变成当前 namespace 内的视角。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这一点很好，我之前没想到过，后面我会关注一下，也许会放到 issues 列表。
但据我所知目前没有这样的转换方式，也没有办法将一个 monotonic clock 转换 TAI。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我记得是 intel 还是哪个公司将 timstamp 加到 skb 时，他们曾提议在 skb 包含这样的
能区分出时钟源的 bits；而我们现在再次为了这一目的而努力。我相信只要我们有充分的使
用场景，就能将这个改动合并到社区。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;是的。&lt;/p&gt;

&lt;h3 id=&quot;问题-4能否让-bpf-程序处理推迟-reset-timestamp-的操作&quot;&gt;问题 4：能否让 BPF 程序处理推迟 reset timestamp 的操作？&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;前面的 POC 改动了内核代码来推迟 reset timestamp。我的问题是，
能否将这个逻辑放到 BPF 程序里去做？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个问题也很好，我最开始也是这么做（hack）的。不过我觉得这个改动无法合并到内核，因为太丑陋了，
你仍然需要一些方式来避免在 scrub skb 时清掉 timestamp，例如在切换 netns 时就会遇到这种情况。
因此彻底解决这个问题就需要一种不是那么 hacky 但又有效的方式。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;能否在容器内 attach 一段 BPF 程序，在里面实现 disable scrubing，或者将信息
copy 到 cb (control buffer) 之类的地方（然后在宿主机端再取出来）？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;从我个人来说，我避免在 pod namespace 内管理任何事情，因此我不希望在容器内 attach bpf 程序。
我希望无需两个 netns 的任何协作这件事情就能完成，或者说宿主机侧自己就能完成这件事情。&lt;/p&gt;

&lt;h3 id=&quot;问题-5能否在-veth-加一个比特让我们能知道自己在处理-ingress-还是-egress-路径&quot;&gt;问题 5：能否在 veth 加一个比特，让我们能知道自己在处理 ingress 还是 egress 路径？&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;流量永远会经过 veth 设备对吗？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;那能否在 veth 设备设置一个 bit，在包出来时，使我们能分辨出自己在 ingress 路径上处理这个包？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这也是一种方式。&lt;/p&gt;

&lt;p&gt;但我认为这种方式太丑陋了，因为你要如何配置这个东西呢？而且这里设计了太多实现
细节，我们真的要将如此细节的东西（要不清除一个 bit）暴露出来吗？
我认为这种方式不够简洁。&lt;/p&gt;

&lt;p&gt;时间有限，我们先继续下面的内容，其他问题可以会后再继续讨论。&lt;/p&gt;

&lt;h1 id=&quot;3-自维护邻居managed-neighbor与-fib-扩展&quot;&gt;3 自维护邻居（managed neighbor）与 FIB 扩展&lt;/h1&gt;

&lt;h2 id=&quot;31-cilium-l4lb-处理逻辑&quot;&gt;3.1 Cilium L4LB 处理逻辑&lt;/h2&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/bpf-datapath-ext-for-k8s/cilium-xdp-lb.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Cilium L4LB 或其他基于 XDP 的负载均衡器，&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;都位于流量中间路径上，交换机通过 ECMP 算法将流量转发给 LB 节点，LB 节点再转发给后端；&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;LB 收到的流量通常目的地址都是 ServiceIP，&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;BPF 处理逻辑：通过 &lt;strong&gt;&lt;mark&gt;DNAT+SNAT&lt;/mark&gt;&lt;/strong&gt; 或 &lt;strong&gt;&lt;mark&gt;DSR+IPIP/IP6IP6&lt;/mark&gt;&lt;/strong&gt; 将流量转发到后端 pod&lt;/li&gt;
      &lt;li&gt;两种处理方式中，外层 IP 头的 dst_ip 都是 backendIP（pod ip）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;两种情况下，都是&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;利用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bpf_fib_lookup()&lt;/code&gt; helper 函数顺便解析 neighbor 地址&lt;/li&gt;
  &lt;li&gt;Pushed back out via XDP_TX (对 phys/bond 设备来说是透明的)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上转发，需要用到&lt;strong&gt;&lt;mark&gt;后端的 IP 和 MAC 地址信息&lt;/mark&gt;&lt;/strong&gt;，因此涉及到 neighbor/fib 管理。&lt;/p&gt;

&lt;h2 id=&quot;32-邻居表的管理&quot;&gt;3.2 邻居表的管理&lt;/h2&gt;

&lt;h3 id=&quot;321-xdp-场景下的邻居解析&quot;&gt;3.2.1 XDP 场景下的邻居解析&lt;/h3&gt;

&lt;p&gt;首先需要知道，&lt;strong&gt;&lt;mark&gt;XDP 中是无法做邻居解析的&lt;/mark&gt;&lt;/strong&gt;，因此&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;mark&gt;neighbor entry 必须由更上层来解析，然后插入到邻居表&lt;/mark&gt;&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;具体实现就是发送 ARP 请求，获取 MAC 地址。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;322-当前的解析和管理方式&quot;&gt;3.2.2 当前的解析和管理方式&lt;/h3&gt;

&lt;p&gt;当前的邻居解析是由 cilium-agent 来做的。但这里是我们的一个痛点，如下图所示：&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/bpf-datapath-ext-for-k8s/neighbor-mgnt-1.png&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;所有 agent 监听 kube-apiserver node create 事件，&lt;/li&gt;
  &lt;li&gt;对于新 node，agent 发送 ARP 请求解析 MAC 地址，&lt;/li&gt;
  &lt;li&gt;把解析到的地址作为一条永久记录（&lt;strong&gt;&lt;mark&gt;&lt;code&gt;NUD_PERMANENT&lt;/code&gt;&lt;/mark&gt;&lt;/strong&gt;）插入到邻居表。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;需要定期解析，以便即使删除不可用的表项：&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/bpf-datapath-ext-for-k8s/neighbor-mgnt-2.png&quot;/&gt;&lt;/p&gt;

&lt;h3 id=&quot;323-当前管理方式存在的问题&quot;&gt;3.2.3 当前管理方式存在的问题&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;需要定期解析，目前我们是 5 分钟一次。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;逻辑上存在 bug：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;考虑 kube-apiserver node，它们也各自对应一条 NUD_PERMANENT 记录；如果在
&lt;strong&gt;&lt;mark&gt;agent 重启时，kube-apiserver 地址变了&lt;/mark&gt;&lt;/strong&gt;（小概率但可能发生），那所有 node
就都访问不到这台 kube-apiserver 了。&lt;/li&gt;
      &lt;li&gt;本机&lt;strong&gt;&lt;mark&gt;协议栈不会根据收发的流量自动更新这些 entry&lt;/mark&gt;&lt;/strong&gt;，因为这条 entry 是永久的，由外部管理的。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;agent 是在重复内核 net/ipv4/arp.c 的逻辑；&lt;/li&gt;
  &lt;li&gt;需要为 IPv6 ND 实现一套类似机制。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;早期一些的版本，例如 1.9.5 之前，邻居的定期解析比较激进，可能导致意想不到的问题。
从 1.8.4 (customized) 升级到 1.9.5 (customized) 之后，我们曾收到一些偶发到网关超时的报障。&lt;/p&gt;

  &lt;p&gt;基本背景：&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;某个老数据中心，基于接入-汇聚-核心网络架构&lt;/li&gt;
    &lt;li&gt;同时支撑两种虚拟网络：Cilium+BGP 三层网络和 VLAN 二层网络；对于后者，实例（VM/Container）的网关全在核心交换机&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;故障现象：&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;报障的全是二层网络的实例，现象是到网关偶发不通，严重时持续时长在一分钟以上&lt;/li&gt;
    &lt;li&gt;情况有越来越严重的趋势&lt;/li&gt;
    &lt;li&gt;与 Cilium 升级时间吻合&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;排查后发现确实是升级 Cilium 导致的：一台 cilium node 给核心交换机大致增加了 15pps 的入向 ARP 流量。
随着升级的 node 不断增加，当入向 ARP 从 1kpps 上升到 6kpps 时，&lt;strong&gt;&lt;mark&gt;交换机 ARP 响应时间从 10ms 急
剧上升到 500ms&lt;/mark&gt;&lt;/strong&gt; —— 这种情况下，基于 Cilium+BGP 的网络没有问题，但
二层网络的那些应用（例如 OpenStack 实例）就可能遇到网关超时。&lt;/p&gt;

  &lt;p&gt;译注。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;324-解决方案设想&quot;&gt;3.2.4 解决方案：设想&lt;/h3&gt;

&lt;p&gt;设想还是让&lt;strong&gt;&lt;mark&gt;控制平面&lt;/mark&gt;&lt;/strong&gt;（这里就是 cilium agent）做这个事情，要求：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;&lt;mark&gt;基于 netlink 查找路由&lt;/mark&gt;&lt;/strong&gt;：这个 backendIP 是在同一个 L2 网络，还是要通过 GW IP？&lt;/li&gt;
  &lt;li&gt;将 &lt;strong&gt;&lt;mark&gt;L3 地址（不带 L2 地址）写到邻居表&lt;/mark&gt;&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;然后，&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;&lt;mark&gt;内核邻居子系统将自动解析邻居地址&lt;/mark&gt;&lt;/strong&gt;，&lt;/li&gt;
  &lt;li&gt;邻居子系统也会将这个地址一直保持在 reachable 状态，&lt;/li&gt;
  &lt;li&gt;我们也有方式&lt;strong&gt;&lt;mark&gt;配置不要对这种地址进行 GC&lt;/mark&gt;&lt;/strong&gt;，&lt;/li&gt;
  &lt;li&gt;Agent 重启后，会自动 resync/clean 过期的 L3 记录。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;325-解决方案调研&quot;&gt;3.2.5 解决方案：调研&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;mark&gt;&lt;code&gt;NTF_USE | NTF_EXT_LEARNED&lt;/code&gt;&lt;/mark&gt;&lt;/strong&gt; 这两个 neigh flag
大体上能帮我们实现以上设想。我之前其实并不知道这些 flag，也是看代码才发现。&lt;/p&gt;

&lt;h4 id=&quot;ntf_use&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NTF_USE&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;先来看第一个 flag &lt;strong&gt;&lt;mark&gt;&lt;code&gt;NTF_USE&lt;/code&gt;&lt;/mark&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// https://github.com/torvalds/linux/blob/v5.10/net/core/neighbour.c#L1973&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;neigh_add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sk_buff&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;skb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nlmsghdr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nlh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;netlink_ext_ack&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;extack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ndm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ndm_flags&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NTF_USE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;neigh_event_send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;neigh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;__neigh_update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;neigh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lladdr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ndm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ndm_state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NETLINK_CB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;skb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;portid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;extack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看到，指定这个 flag 之后，将一条邻居表项加到内核时，将触发
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;neigh_event_send()&lt;/code&gt; 执行，后者会&lt;strong&gt;&lt;mark&gt;做一次邻居解析&lt;/mark&gt;&lt;/strong&gt;。
如果你一条 entry 加入到内核，它会在内核做 neighbor 解析，&lt;/p&gt;

&lt;p&gt;后面这条表项过期时，&lt;strong&gt;&lt;mark&gt;如果有 inbount 流量进来，或者有 outbound 流量需要这个表项&lt;/mark&gt;&lt;/strong&gt;
（从而再触发一次解析），它会重新更新到 reachable 状态。&lt;/p&gt;

&lt;h4 id=&quot;ntf_ext_learned&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NTF_EXT_LEARNED&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;带这个 flag 表示这是一条&lt;strong&gt;&lt;mark&gt;外部学习（externally learned）到并插入内核&lt;/mark&gt;&lt;/strong&gt;
（而非内核自己维护）的表项，从而
&lt;strong&gt;&lt;mark&gt;确保了这个 entry 不会进入 GC 列表&lt;/mark&gt;&lt;/strong&gt;；这已经使我们非常接近最终想实现的效果了。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;&lt;mark&gt;&lt;code&gt;NTF_EXT_LEARNED&lt;/code&gt;&lt;/mark&gt;&lt;/strong&gt; 与 Ethernet VPN (EVPN)&lt;/p&gt;

  &lt;p&gt;CumulusNetworks 的工程师在 2018 年将
&lt;a href=&quot;https://patchwork.ozlabs.org/project/netdev/patch/1524602974-11476-1-git-send-email-roopa@cumulusnetworks.com/&quot;&gt;这个 flag&lt;/a&gt;
加到了内核，使 Linux 能支持 &lt;strong&gt;&lt;mark&gt;BGP-EVPN&lt;/mark&gt;&lt;/strong&gt;：允许用户将某种
&lt;strong&gt;&lt;mark&gt;控制平面&lt;/mark&gt;&lt;/strong&gt;（例如基于 FRR 的 SDN 控制器）学习到的邻居信息直接添加到内核邻居表。
这种外部 neigh entry 的管理方式，在之前的 bridge 和 vxlan fdb 中已经在用了。&lt;/p&gt;

  &lt;p&gt;BGP-EVPN 用于&lt;strong&gt;&lt;mark&gt;多租户大二层&lt;/mark&gt;&lt;/strong&gt;组网，典型的如 OpenStack SDN 网络，使用案例可参考
&lt;a href=&quot;/blog/ctrip-network-arch-evolution-zh/&quot;&gt;&lt;mark&gt;云计算时代携程的网络架构变迁（2019）&lt;/mark&gt;&lt;/a&gt;。&lt;/p&gt;

  &lt;p&gt;译注。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;但 NTF_EXT_LEARNED 的不足是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;没有 auto-refresh 机制来从 STALE 重新回到 REACHABLE 状态，&lt;/li&gt;
  &lt;li&gt;flags 并没有回传给用户空间，导致 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ip neighbor xxx&lt;/code&gt; 命令之后看不到相应字段的状态（denial 的 &lt;a href=&quot;https://lore.kernel.org/all/20211115165320.907759698@linuxfoundation.org/&quot;&gt;patch&lt;/a&gt;），&lt;/li&gt;
  &lt;li&gt;在发生 &lt;strong&gt;&lt;mark&gt;carrier-down&lt;/mark&gt;&lt;/strong&gt; 事件（例如网线接触不良）时会丢失，而 permanent flag 就不会&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;326-解决方案引入一个新-flag-nud_managed&quot;&gt;3.2.6 解决方案：引入一个新 flag &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NUD_MANAGED&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;因此，我们决定添加一个创建 neighbor entry 时用的&lt;strong&gt;&lt;mark&gt;新 flag NUD_MANAGED&lt;/mark&gt;&lt;/strong&gt;：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用这个 flag 创建的邻居表项，&lt;strong&gt;&lt;mark&gt;状态是可变的&lt;/mark&gt;&lt;/strong&gt;（volatile states，例如会进入 reachable state），而不像 NUD_PERMANENT 表项那样是一个永久状态；
    &lt;ul&gt;
      &lt;li&gt;意味着内部使用了 NTF_USE&lt;/li&gt;
      &lt;li&gt;表项是加到一个 per-neigh table list&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;使用 delayed system-wq 队列来&lt;strong&gt;&lt;mark&gt;定期&lt;/mark&gt;&lt;/strong&gt;为这些表项触发 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;neigh_event_send()&lt;/code&gt;，即&lt;strong&gt;&lt;mark&gt;触发邻居解析&lt;/mark&gt;&lt;/strong&gt;；触发频率 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BASE_REACHABLE_TIME/2&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;这个 flag 还可以&lt;strong&gt;&lt;mark&gt;与 NTF_EXT_LEARNED 一起用&lt;/mark&gt;&lt;/strong&gt;（表示这是外部控制平面学习到的），&lt;strong&gt;&lt;mark&gt;从而避免被 GC&lt;/mark&gt;&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;在发生 carrier-down 事件状态不会丢失，carrier-up 之后会自动刷新状态。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;基于 iproute2 的例子：指定 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nud managed&lt;/code&gt; 创建一条邻居表项：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ip neigh replace 192.168.1.99 dev enp5s0 extern_learn nud managed
192.168.1.99 dev enp5s0 lladdr 98:9b:cb:05:2e:ae use extern_learn REACHABLE
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;33-fib-extensions-snat-时的-src_ip-选择&quot;&gt;3.3 FIB extensions: SNAT 时的 SRC_IP 选择&lt;/h2&gt;

&lt;p&gt;关于邻居表项的管理告一段落，接下来往上走一层，来看某些情况下 cilium datapath 中的 fib 查找问题。&lt;/p&gt;

&lt;h3 id=&quot;331-node-有多个-ipsnatmasquerade-时的源地址选择问题&quot;&gt;3.3.1 Node 有多个 IP：SNAT/Masquerade 时的源地址选择问题&lt;/h3&gt;

&lt;p&gt;来看下面这个例子。&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/bpf-datapath-ext-for-k8s/snat-1.png&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Pod 所在的网络是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;172.16.0.1/24&lt;/code&gt;，无法被外部网络主动访问&lt;/li&gt;
  &lt;li&gt;Node 网卡上有两个 IP 地址，分别属于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;192.168.0.1/24&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;10.0.0.0/24&lt;/code&gt; 网段&lt;/li&gt;
  &lt;li&gt;Pod 想访问宿主机外面的某个 IP &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;10.0.0.100/32&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于 Pod IP 对外不可直接访问，因此 Pod &lt;strong&gt;&lt;mark&gt;出向流量&lt;/mark&gt;&lt;/strong&gt;需要做&lt;strong&gt;&lt;mark&gt;源地址转换&lt;/mark&gt;&lt;/strong&gt;（入向做相反转换）。
我们在 tc ingress 上 attach 了一段 bpf 程序来做这件事情（masquerade，动态版 SNAT）。&lt;/p&gt;

&lt;p&gt;Node IP 有多个，那执行地址转换时&lt;strong&gt;&lt;mark&gt;选哪个呢&lt;/mark&gt;&lt;/strong&gt;？
目前的做法是在 BPF 中根据某些逻辑来选一个地址，然后将其 &lt;strong&gt;&lt;mark&gt;hardcode 到代码中&lt;/mark&gt;&lt;/strong&gt;，如上图所示。&lt;/p&gt;

&lt;p&gt;但这里有个问题：还是以上图为例，虽然宿主机有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;192.168.0.1/24&lt;/code&gt;
和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;10.0.0.0/24&lt;/code&gt; 两个网段的 IP 地址，但实际上连接到的只有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;10.0.0.0/24&lt;/code&gt; 网络。这种情况下，
如果我们用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;192.168.0.1/24&lt;/code&gt; 做 SNAT，应答流量就回不来了。&lt;/p&gt;

&lt;p&gt;也就是说，这里涉及到如何选择真实可用的 Node IP 做 masquerade。&lt;/p&gt;

&lt;h3 id=&quot;332-解决方式&quot;&gt;3.3.2 解决方式&lt;/h3&gt;

&lt;p&gt;这个&lt;strong&gt;&lt;mark&gt;信息其实已经在 FIB 表中了&lt;/mark&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;因此，我们首先要做的是使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bpf_{xdp,skb}_fib_lookup()&lt;/code&gt; 来动态选择源 IP。
这需要对 BPF helper 函数做一些&lt;a href=&quot;https://github.com/brb/linux/commit/044d54d95456163a8fc5f776000e08e13d34039e&quot;&gt;修改&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;其次，给内核 &lt;a href=&quot;https://github.com/brb/linux/commit/d3b42b8fe46b252a8dad27623926f52086105399&quot;&gt;引入&lt;/a&gt; 
一个新 flag &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BPF_FIB_LOOKUP_SET_SRC&lt;/code&gt;，在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bpf_ipv{4,6}_fib_lookup()&lt;/code&gt;
&lt;strong&gt;&lt;mark&gt;查询邻居表项时，自动将正确的源 IP 一起带出来&lt;/mark&gt;&lt;/strong&gt;，这个 patch 很快将合并到上游。&lt;/p&gt;

&lt;p&gt;此外，有了这种方式，我们也不需要在 BPF 程序中 hardcode IP 了。&lt;/p&gt;

&lt;p&gt;效果如下图所示：&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/bpf-datapath-ext-for-k8s/snat-2.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;34-l4lb-节点多网卡service-转发时-egress-网卡的选择问题&quot;&gt;3.4 L4LB 节点多网卡：Service 转发时 egress 网卡的选择问题&lt;/h2&gt;

&lt;h3 id=&quot;341-问题描述&quot;&gt;3.4.1 问题描述&lt;/h3&gt;

&lt;p&gt;FIB lookup 相关的另一个问题是 multi-home 网络。
如下图所示，一个有三张网卡的 Cilium L4LB 节点在处理 Service 转换，将请求 DNAT 到特定的 backend。&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/bpf-datapath-ext-for-k8s/multi-home.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;那么，这里就会涉及到&lt;strong&gt;&lt;mark&gt;选择哪张网卡将流量转发出去&lt;/mark&gt;&lt;/strong&gt;的问题。
目前的做法是，在多个网卡的 datapath 中都重复了一些 fib lookup 逻辑。&lt;/p&gt;

&lt;h3 id=&quot;342-解决方案&quot;&gt;3.4.2 解决方案&lt;/h3&gt;

&lt;p&gt;这个信息（转发表项对应的是哪个 ifindex，即网卡）其实&lt;strong&gt;&lt;mark&gt;也已经在 FIB 表中了&lt;/mark&gt;&lt;/strong&gt;。
因此我们希望再次通过动态 fib lookup 解决这个问题，即（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bpf_{xdp,skb}_fib_lookup()&lt;/code&gt;）把这个信息顺便带出来。&lt;/p&gt;

&lt;p&gt;深入查看了相关代码之后，我们发现这个逻辑已经在了，只是 BPF helper 实现上有点问题，
因此这里我们做了一点 &lt;a href=&quot;https://github.com/brb/linux/commit/3387287212490d30bc1a4266ae472eab9a988962&quot;&gt;改动&lt;/a&gt;，也会合并到上游内核。&lt;/p&gt;

&lt;p&gt;最终效果如下：&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/bpf-datapath-ext-for-k8s/snat-3.png&quot;/&gt;&lt;/p&gt;

&lt;h1 id=&quot;4-查询-bpf-map-时的通配符匹配问题&quot;&gt;4 查询 BPF map 时的通配符匹配问题&lt;/h1&gt;

&lt;h2 id=&quot;41-pcap-recorder-当前使用场景cilium-xdp-l4lb&quot;&gt;4.1 PCAP recorder 当前使用场景：Cilium XDP L4LB&lt;/h2&gt;

&lt;p&gt;Cilium LB 节点上提供了一个灵活的 traffic recorder，&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;它会关联入向和出向 flow（后面会看到原理），因此用它可以查看 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fabric -&amp;gt; L4LB -&amp;gt; L7 proxy/backend&lt;/code&gt; 的整条流量路径。&lt;/li&gt;
  &lt;li&gt;提供了更高层的 API ，能在带外（out-of-band）对 L4LB agent 进行编程。agent 将把指定的 filter 加载到内核 bpf datapath，创建一个 wildcard mask。&lt;/li&gt;
  &lt;li&gt;还有一个叫 &lt;a href=&quot;https://github.com/cilium/hubble&quot;&gt;Hubble&lt;/a&gt; 的组件，能抓包并保存成 pcap 供 offline 排障。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;遗憾的是今天这里不能播放 gif，只能提供两条命令供大家参考：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;hubble record &lt;span class=&quot;s2&quot;&gt;&quot;0.0.0.0/0 192.168.33.11/32 80 TCP&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;



&lt;p&gt;下面介绍一下它的内部实现。&lt;/p&gt;

&lt;h2 id=&quot;42-pcap-recorder-原理&quot;&gt;4.2 PCAP recorder 原理&lt;/h2&gt;

&lt;p&gt;下图从 flow 的角度展示它是如何工作的：&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/bpf-datapath-ext-for-k8s/pcap-recorder.png&quot;/&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;判断入向流量。如果是需要抓取的流量，就提取基本信息存储到一个 per-cpu cache。
将原始包放到 perf ring buffer。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;判断出向流量：如果 ring buffer 中记录了对应的 ingress flow，就抓取该 egress flow。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;以上二者都会调用到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cilium_capture()&lt;/code&gt;，它会&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;记录一些 metadata，例如 recorder id&lt;/li&gt;
      &lt;li&gt;pcap header with MONO。&lt;/li&gt;
      &lt;li&gt;full or partial payload capture。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这些抓取到流量经过隧道封装之后发往 backend。&lt;/p&gt;

&lt;h2 id=&quot;43-pcap-recorder-匹配规则&quot;&gt;4.3 PCAP recorder 匹配规则&lt;/h2&gt;

&lt;h3 id=&quot;431-recorder-组成&quot;&gt;4.3.1 Recorder 组成&lt;/h3&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/bpf-datapath-ext-for-k8s/pcap-recorder-classifier-rules-1.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;一个 Recorder 由下面几部分组成：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Source CIDR, destination CIDR&lt;/li&gt;
  &lt;li&gt;Source Port, destination Port，其中
    &lt;ul&gt;
      &lt;li&gt;0 表示 any&lt;/li&gt;
      &lt;li&gt;n：表示精确匹配 port == n，其中 n != 0&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Currently unsupported: n-m range&lt;/li&gt;
  &lt;li&gt;Protocol
    &lt;ul&gt;
      &lt;li&gt;0 表示 any&lt;/li&gt;
      &lt;li&gt;n：表示精确匹配 proto == n，其中 n != 0&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;432-agent-职责&quot;&gt;4.3.2 Agent 职责&lt;/h3&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/bpf-datapath-ext-for-k8s/pcap-recorder-classifier-rules-2.png&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用 API 来对 recorder 进行编程&lt;/li&gt;
  &lt;li&gt;Tracking different masks from rules&lt;/li&gt;
  &lt;li&gt;在 mask set 发生变化时，Regens datapath&lt;/li&gt;
  &lt;li&gt;v4/v6 hashtable each for rule lookup&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;44-匹配规则当前的代码实现&quot;&gt;4.4 匹配规则：当前的代码实现&lt;/h2&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// https://github.com/cilium/cilium/blob/v1.10/bpf/lib/pcap.h#L216&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__always_inline&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;capture_rule&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;cilium_capture4_classify_wcard&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__ctx_buff&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 有序 mask 集合（列表），PREFIX_MASKS4 是一个编译时常量，由 agent 动态生成&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;capture4_wcard&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prefix_masks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PREFIX_MASKS4&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;_Pragma&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;unroll&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 根据元组信息 okey 和当前 mask 生成 masked key (lkey)，这个函数的实现下面也给出了&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cilium_capture4_masked_key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;okey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prefix_masks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lkey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 用掩码之后的 key（即 lkey）去哈希表查找 &lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;map_lookup_elem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cilium_capture4_rules&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lkey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;match&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;match&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// match 中包含了 Recorder ID 和 capture length 信息&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;根据 tuple 信息和 mask 信息计算掩码之后的 key：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// https://github.com/cilium/cilium/blob/v1.10/bpf/lib/pcap.h#L156&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__always_inline&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;cilium_capture4_masked_key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;capture4_wcard&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;orig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
               &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;capture4_wcard&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;capture4_wcard&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;daddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;orig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;daddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;daddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;saddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;orig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;saddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;saddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dport&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;orig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dport&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dport&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sport&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;orig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sport&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sport&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nexthdr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;orig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nexthdr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nexthdr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dmask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dmask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;smask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;smask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;45-当前实现的问题mask-集合不能太大否则开销太大&quot;&gt;4.5 当前实现的问题：Mask 集合不能太大，否则开销太大&lt;/h2&gt;

&lt;p&gt;总体上来说，这是一种穷人的 wildcard match 方式。&lt;/p&gt;

&lt;p&gt;这里的一个基本前提是 &lt;strong&gt;&lt;mark&gt;mask 集合不会很大&lt;/mark&gt;&lt;/strong&gt;，这个假设对我们当前来说是可接受的。
但有一些缺点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;mask 集合发生变化时，需要动态重新编译，开销非常大；&lt;/li&gt;
  &lt;li&gt;对 mask 的处理是一个线性过程，复杂的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;O(n)&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;虽然在老版本内核上也能工作，但 loop unrolling 可能导致生成的代码太复杂，verifier 通过不了。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;46-原生支持通配符匹配的-bpf-map&quot;&gt;4.6 原生支持通配符匹配的 BPF map&lt;/h2&gt;

&lt;p&gt;理想情况下，有内核原生的 BPF map 来避免开销非常高的 code regeneration：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;非常快速的查询：Millions/Sec&lt;/li&gt;
  &lt;li&gt;合理速度的更新：Thousands/Sec&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这种设想最早在 2018 年
&lt;a href=&quot;https://lore.kernel.org/netdev/CALDO+SYzDDpTmJttghfjUYKbo3AHDaT4L154Acwn5BGqkytkHQ@mail.gmail.com/&quot;&gt;BPF + OVS&lt;/a&gt;
中出现过，他们想基于这种方式在 BPF 中实现 Megaflow 的匹配，但后来没进展了。&lt;/p&gt;

&lt;p&gt;另外，我们最近也在看当前主流的包分类算法有哪些，例如 &lt;a href=&quot;https://nonsns.github.io/paper/rossi19ton.pdf&quot;&gt;TupleMerge&lt;/a&gt;，
下面是论文中的截图：&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/bpf-datapath-ext-for-k8s/classification-time.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;即便是有大量 rules，至少论文中的仿真结果看起来非常不错：&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/bpf-datapath-ext-for-k8s/classification-ruleset-size.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;但目前我们还没有 POC，在我们的 to-do-list 上。
这样就可以免去动态重新编译的问题，如果在座的有这方面经验，我们非常感兴趣。&lt;/p&gt;

&lt;h1 id=&quot;5-完场-qa-环节&quot;&gt;5 完场 Q&amp;amp;A 环节&lt;/h1&gt;

&lt;h3 id=&quot;问题-6关于-wildcard-匹配算法&quot;&gt;问题 6：关于 wildcard 匹配算法&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Alexei：这次分享的能力太密集了，要全程跟上非常困难。我有几个问题。&lt;/p&gt;

  &lt;p&gt;内核有很多限制，所以不是所有&lt;strong&gt;&lt;mark&gt;用户空间算法&lt;/mark&gt;&lt;/strong&gt;都适合在内核实现。
但从论文提供的数据看，如果算法能在内核实现，性能收益的确很可观。&lt;/p&gt;

  &lt;p&gt;另外，有没有试过 map_for_each helper？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;还没。其实我们现在只在 5.4 上需要这个特性，用户在生产环境运行 LB，但对于其他版本，我们需要再深入研究。&lt;/p&gt;

&lt;p&gt;总体来说，我非常同意你的观点，例如必须兼容 rcu 以及其他一些东西，不是所有东西都适合在内核。
论文中提到的一些结果都很不错，但这些终归都是仿真结果，还是需要实现一个真实的版
本来验证性能到底怎么样。&lt;/p&gt;

&lt;h3 id=&quot;问题-7其中一些算法是不是有专利&quot;&gt;问题 7：其中一些算法是不是有专利？&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;上面论文中的算法是不是有专利？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个问题我确实还没考虑到，需要回去确认一下。&lt;/p&gt;

&lt;h3 id=&quot;问题-8cilium-是否已经不需要-direct-interface-概念&quot;&gt;问题 8：Cilium 是否已经不需要 direct interface 概念？&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;你们在设计中似乎倾向于有所谓的 direct interfaces 概念，但听了前面的分享之后，我认为
你们并再需要这个东西。我的意思是，有了 BPF 中的 fib lookup 功能之后，
出向和入向该用哪个接口，交给内核决定就行了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;是的，这种自维护的状态能通过定时刷新或其他方式，保证 neighbor entry 在内核中存在且持续处于 reachable。
这样我们就能用 fib lookup 来查找邻居，后者也为 XDP datapath 提供了便利。&lt;/p&gt;

&lt;p&gt;今天的基础设施，例如 NTF_USE flag，我认为是非常古老的代码，
它没有主动 refresh 进入 reachable 状态，除非有外部流量或内部流量事件，比如 ping node。
如果这些完全由内核的邻居子系统来管理（completely self-managed by the kernel）那自然是很好的。
这样我们就无需外部流量触发更新。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Martynas：明确一下，在选择源地址时我们无需任何邻居表项。&lt;/p&gt;

  &lt;p&gt;Denial：哦是的是的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;问题-9用-libpcap-将-cbpf-编译成-ebpf-是否可以解决你们不支持-port-range-的问题&quot;&gt;问题 9：用 libpcap 将 cbpf 编译成 ebpf 是否可以解决你们不支持 port-range 的问题？&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;我们用 libpcap 将 cbpf 编译成 ebpf，它支持 subnet/port ranges。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这种方式是可行的，但我认为这种方式生成的程序将迅速膨胀。
如果你只有很少的 mask，loop unroll 不会产生问题；但如果要匹配几千个地方，
那生成的代码就会非常长。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;是的，其实就是用真实 BPF 代码来换 hash map entries 了。
我们的场景都是只有几百条 entries，太多确实会有问题；另外就是指令数也是有限制的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们想做的一件事情就是将这段代码从 LB 节点移到 CNI datapath 部分，
而后者中已经有非常复杂的 bpf 代码了，因此再加一段这样的代码将会使其进一步膨胀。
我最大的顾虑是校验器，太大或太复杂会无法通过。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;理解，这里的确有挑战。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;6-本文翻译时原作者特别更新&quot;&gt;6 本文翻译时，原作者特别更新&lt;/h1&gt;

&lt;p&gt;Denial 和 Martynas 在本文翻译时非常热心地提供了以下更新：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;cgroup v1/v2 patch 已经完全合并到内核；&lt;/li&gt;
  &lt;li&gt;自维护 neighbor entries 也已经合并到内核；对于不支持这个新特性的老内核，Cilium 1.11 中做了兼容；&lt;/li&gt;
  &lt;li&gt;TCP 时间戳问题，已经从 Facebook 收到积极反馈，他们也需要这个东西，有望在 12 月份解决。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以下是详细 patch 列表。&lt;/p&gt;

&lt;h2 id=&quot;61-merged-cgroup-v1v2-patches&quot;&gt;6.1 Merged cgroup v1/v2 patches&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=8520e224f547cd070c7c8f97b1fc6d58cff7ccaa&quot;&gt;bpf, cgroups: Fix cgroup v2 fallback on v1/v2 mixed mode&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=d8079d8026f82e4435445297d1b77bba1c4c7960&quot;&gt;bpf, selftests: Add cgroup v1 net_cls classid helpers&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=43d2b88c29f2d120b4dc22f27b3483eb14bd9815&quot;&gt;bpf, selftests: Add test case for mixed cgroup v1/v2&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=78cc316e9583067884eb8bd154301dc1e9ee945c&quot;&gt;bpf, cgroup: Assign cgroup in cgroup_sk_alloc when called from interrupt&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=435b08ec0094ac1e128afe6cfd0d9311a8c617a7&quot;&gt;bpf, test, cgroup: Use sk_{alloc,free} for test cases&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;62-merged-managed-neighbor-entries--fixes&quot;&gt;6.2 Merged managed neighbor entries &amp;amp; fixes&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=e4400bbf5b15750e1b59bf4722d18d99be60c69f&quot;&gt;net, neigh: Fix NTF_EXT_LEARNED in combination with NTF_USE&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=3dc20f4762c62d3b3f0940644881ed818aa7b2f5&quot;&gt;net, neigh: Enable state migration between NUD_PERMANENT and NTF_USE&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=7482e3841d520a368426ac196720601687e2dc47&quot;&gt;net, neigh: Add NTF_MANAGED flag for managed neighbor entries&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=507c2f1d2936e07aef83734983a36df01b458ef9&quot;&gt;net, neigh: Add build-time assertion to avoid neigh-&amp;gt;flags overflow&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=c8e80c1169b2b3b91453f9ff3c34687c42233ef7&quot;&gt;net, neigh: Use NLA_POLICY_MASK helper for NDA_FLAGS_EXT attribute&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=30fc7efa38f21afa48b0be6bf2053e4c10ae2c78&quot;&gt;net, neigh: Reject creating NUD_PERMANENT with NTF_MANAGED entries&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net.git/commit/?id=4177d5b017a71433d4760889b88f7a29e11fad10&quot;&gt;net, neigh: Fix crash in v6 module initialization error path&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;63-iproute2&quot;&gt;6.3 iproute2&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://git.kernel.org/pub/scm/network/iproute2/iproute2.git/commit/?id=c76a3849ec307ae216eb7ae674dcc7aea2f7dde1&quot;&gt;ip, neigh: Fix up spacing in netlink dump&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://git.kernel.org/pub/scm/network/iproute2/iproute2.git/commit/?id=040e52526c22163a218b9cb2224f51a2de0e6576&quot;&gt;ip, neigh: Add missing NTF_USE support&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://git.kernel.org/pub/scm/network/iproute2/iproute2.git/commit/?id=9e009e78e7f14ec98efdaca38998d0f472e45ea5&quot;&gt;ip, neigh: Add NTF_EXT_MANAGED support&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;64-go-netlink-lib&quot;&gt;6.4 go netlink lib&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/vishvananda/netlink/pull/707&quot;&gt;Add support for NDA_FLAGS_EXT neighboring attribute&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;65-cilium-111-neighbor-rework-using-managed-neighbors-on-newer-kernels&quot;&gt;6.5 Cilium 1.11 neighbor rework (using managed neighbors on newer kernels)&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/cilium/cilium/pull/17713&quot;&gt;cilium: Rework neighbor handling&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/cilium/cilium/pull/17842&quot;&gt;cilium: fix ipv6 neighbor discovery&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/cilium/cilium/pull/17862&quot;&gt;neigh: add runtime test for changing next hop address&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/cilium/cilium/pull/17918&quot;&gt;neigh: Clean up stale/untracked non-GC’ed neighbors&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/cilium/cilium/pull/17932&quot;&gt;neigh: Init new neighbor for older kernel with NUD_STALE&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;


  
  
&lt;/div&gt;


          

      &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>30cfd0b4278835e737ded467bcc6dcec</guid>
<title>如何通过抓包来查看 Kubernetes API 流量</title>
<link>https://toutiao.io/k/vwuzlp6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;content&quot;&gt;&lt;p&gt;当我们通过kubectl来查看、修改Kubernetes资源时，有没有想过后面的接口到底是怎样的？有没有办法探查这些交互数据呢？&lt;/p&gt;
&lt;p&gt;Kuberenetes客户端和服务端交互的接口，是基于http协议的。所以只需要能够捕捉并解析https流量，我们就能看到kubernetes的API流量。&lt;/p&gt;
&lt;p&gt;但是由于kubenetes使用了客户端私钥来实现对客户端的认证，所以抓包配置要复杂一点。具体是如下的结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/./how-to-inspect-kubernetes-api/capture-architecture.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;如果想了解更多Kubernetes证书的知识，可以看下&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://qingwave.github.io/k8s-tls/&quot;&gt;这篇Kubernetes证书解析的文章&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h1&gt;&lt;span id=&quot;从kubeconfig中提取出客户端证书和私钥&quot;&gt;从kubeconfig中提取出客户端证书和私钥&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;kubeconfig中包含了客户端的证书和私钥，我们首先要把它们提取出来：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 提取出客户端证书&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;grep client-certificate-data ~/.kube/config | \&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  awk &lt;span class=&quot;string&quot;&gt;&#x27;{ print $2 }&#x27;&lt;/span&gt; | \&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  base64 --decode &amp;gt; client-cert.pem&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 提取出客户端私钥&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;grep client-key-data ~/.kube/config | \&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  awk &lt;span class=&quot;string&quot;&gt;&#x27;{ print $2 }&#x27;&lt;/span&gt; | \&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  base64 --decode &amp;gt; client-key.pem&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 提取出服务端CA证书&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;grep certificate-authority-data ~/.kube/config | \&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  awk &lt;span class=&quot;string&quot;&gt;&#x27;{ print $2 }&#x27;&lt;/span&gt; | \&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  base64 --decode &amp;gt; cluster-ca-cert.pem&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;参考自&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://www.reddit.com/r/kubernetes/comments/h7wfnc/how_do_i_derive_certificate_pem_data_from/&quot;&gt;Reddit&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h1&gt;&lt;span id=&quot;配置charles代理软件&quot;&gt;配置Charles代理软件&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;从第一张图可以看出，代理软件的作用有两个：一是接收https流量并转发，二是转发到kubernetes apiserver的时候，使用指定的客户端私钥。&lt;/p&gt;
&lt;p&gt;首先配置Charles，让他拦截所有的https流量：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/./how-to-inspect-kubernetes-api/ssl-proxy-settings.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后配置客户端私钥，即对于发送到apiserver的请求，统一使用指定的客户端私钥进行认证：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/./how-to-inspect-kubernetes-api/client-cert-config.png&quot;/&gt;&lt;/p&gt;
&lt;h1&gt;&lt;span id=&quot;配置kubectl&quot;&gt;配置kubectl&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;需要抓包kubectl的流量，需要两个条件：1. kubectl使用Charles作为代理，2. kubectl需要信任Charles的证书。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Charles的代理端口是8888，设置https_proxy环境变量，让kubectl使用Charles代理&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;$ &lt;span class=&quot;built_in&quot;&gt;export&lt;/span&gt; https_proxy=http://127.0.0.1:8888/&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# insecure-skip-tls-verify表示不校验服务端证书&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;$ kubectl --insecure-skip-tls-verify get pod&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;NAME                    READY   STATUS    RESTARTS   AGE&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;sc-b-7f5dfb694b-xtfrz   2/2     Running   0          2d20h&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们就可以看到&lt;code&gt;get pod&lt;/code&gt;的网络请求了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/./how-to-inspect-kubernetes-api/kubectl-get-pod.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，get pod的endpoint是&lt;code&gt;GET /api/v1/namespaces/&amp;lt;namespace&amp;gt;/pods&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;让我们再尝试下创建pod的请求：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ cat &amp;lt;&amp;lt;&lt;span class=&quot;string&quot;&gt;EOF &amp;gt;pod.yaml&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;apiVersion: v1&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;kind: Pod&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;metadata:&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;  name: nginx-robberphex&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;spec:&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;  containers:&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;  - name: nginx&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    image: nginx:1.14.2&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;EOF&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;$ kubectl --insecure-skip-tls-verify apply -f pod.yaml&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;pod/nginx-robberphex created&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;也同样可以抓到包：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/./how-to-inspect-kubernetes-api/kubectl-apply-pod.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建pod的endpoint是&lt;code&gt;POST /api/v1/namespaces/&amp;lt;namespace&amp;gt;/pods&lt;/code&gt;&lt;/p&gt;
&lt;h1&gt;&lt;span id=&quot;配置kubenetes-client&quot;&gt;配置kubenetes client&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;我们先从写一个用kubernetes go client来获取pod的例子（注意，代码中已经信任所有的证书，所以可以抓到包）：&lt;/p&gt;
&lt;figure class=&quot;highlight golang&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; main&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;require (&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;k8s.io/api v0.18.19&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;k8s.io/apimachinery v0.18.19&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;k8s.io/client-go v0.18.19&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; (&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;context&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;flag&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;fmt&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;path/filepath&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;apiv1 &lt;span class=&quot;string&quot;&gt;&quot;k8s.io/api/core/v1&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;metav1 &lt;span class=&quot;string&quot;&gt;&quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;k8s.io/client-go/kubernetes&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;k8s.io/client-go/tools/clientcmd&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;k8s.io/client-go/util/homedir&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;ctx := context.Background()&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; kubeconfig *&lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; home := homedir.HomeDir(); home != &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;kubeconfig = flag.String(&lt;span class=&quot;string&quot;&gt;&quot;kubeconfig&quot;&lt;/span&gt;, filepath.Join(home, &lt;span class=&quot;string&quot;&gt;&quot;.kube&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;config&quot;&lt;/span&gt;), &lt;span class=&quot;string&quot;&gt;&quot;(optional) absolute path to the kubeconfig file&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;} &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;kubeconfig = flag.String(&lt;span class=&quot;string&quot;&gt;&quot;kubeconfig&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;absolute path to the kubeconfig file&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;flag.Parse()&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;config, err := clientcmd.BuildConfigFromFlags(&lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;, *kubeconfig)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;panic&lt;/span&gt;(err)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 让clientset信任所有证书&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;config.TLSClientConfig.CAData = &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;config.TLSClientConfig.Insecure = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;clientset, err := kubernetes.NewForConfig(config)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;panic&lt;/span&gt;(err)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;podClient := clientset.CoreV1().Pods(apiv1.NamespaceDefault)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;podList, err := podClient.List(ctx, metav1.ListOptions{})&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;panic&lt;/span&gt;(err)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; _, pod := &lt;span class=&quot;keyword&quot;&gt;range&lt;/span&gt; podList.Items {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;fmt.Printf(&lt;span class=&quot;string&quot;&gt;&quot;podName: %s\n&quot;&lt;/span&gt;, pod.Name)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;fmt.Println(&lt;span class=&quot;string&quot;&gt;&quot;done!&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后编译执行：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ go build -o kube-client&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;$ &lt;span class=&quot;built_in&quot;&gt;export&lt;/span&gt; https_proxy=http://127.0.0.1:8888/&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;$ ./kube-client&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;podName: nginx-robberphex&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;podName: sc-b-7f5dfb694b-xtfrz&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;done&lt;/span&gt;!&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这时也可以抓到同样的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/./how-to-inspect-kubernetes-api/go-client-get-pod.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;基于此，我们就可以分析一个Kubernetes到底干了什么，也是我们分析Kubernetes​实现的入口。&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>faebc0dcec913a4878dba7ad876c0259</guid>
<title>设计模式：七大软件设计原则</title>
<link>https://toutiao.io/k/7p9q0y2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h1&gt;&lt;span&gt;简介&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;学习设计原则，是学习设计模式的基础。在实际开发过程中，并不是一定要求所有代码都遵循设计原则，我们要考虑人力、时间、成本、质量，不是刻意追求完美，要在适当场景遵循设计原则，体现的是一种平衡取舍，帮助我们设计出更加优雅的代码结构&lt;/p&gt;&lt;h1&gt;&lt;span&gt;开闭原则（Open-Closed Principle，OCP）&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;开闭原则是指一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。&lt;/p&gt;&lt;p&gt;所谓的关闭，也正是对扩展和修改两个行为的一个原则。强调的是用抽象构建框架，用实现扩展细节。可以提高软件系统的可复用性及可维护性。&lt;/p&gt;&lt;p&gt;开闭原则，是面向对象设计中最基础的设计原则。它指导我们如何建立稳定灵活的系统，例如：我们版本更新，我们尽可能不修改源代码，但是可以增加新功能。&lt;/p&gt;&lt;p&gt;如下：有一个课程接口和Java课程类&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;ICourse&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;Integer &lt;span&gt;getId&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;String &lt;span&gt;getName&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;Double &lt;span&gt;getPrice&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;JavaCourse&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ICourse&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Integer id;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String name;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Double price;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;JavaCourse&lt;/span&gt;&lt;span&gt;(Integer id, String name, Double price)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.id = id;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.name = name;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.price = price;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Integer &lt;span&gt;getId&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.id;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getName&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.name;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Double &lt;span&gt;getPrice&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.price;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在想要给java课程做活动，有折扣价，如果直接修改JavaCourse中的getPrice()方法，则会存在一定的风险，可能影响其他地方原有的调用。&lt;/p&gt;&lt;p&gt;在不修改原有代码的前提下，可以新增一个有折扣的课程接口，并且新增一个有折扣的Java课程类&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;IDiscountCourse&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;ICourse&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;Double &lt;span&gt;getDiscountPrice&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;JavaDiscountCourse&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;JavaCourse&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IDiscountCourse&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;JavaDiscountCourse&lt;/span&gt;&lt;span&gt;(Integer id, String name, Double price)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(id, name, price);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Double &lt;span&gt;getDiscountPrice&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; getPrice() * &lt;span&gt;0.6&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样，使用的时候可以选择有折扣或者没有折扣&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;OcpTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        ICourse course = &lt;span&gt;new&lt;/span&gt; JavaCourse(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;Java编程思想&quot;&lt;/span&gt;, &lt;span&gt;110&lt;/span&gt;d);&lt;br/&gt;        log.info(&lt;span&gt;&quot;课程ID：{}，名称：{}，原价：{}&quot;&lt;/span&gt;,&lt;br/&gt;                course.getId(),&lt;br/&gt;                course.getName(),&lt;br/&gt;                course.getPrice());&lt;br/&gt;&lt;br/&gt;        IDiscountCourse course2 = &lt;span&gt;new&lt;/span&gt; JavaDiscountCourse(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;Java编程思想&quot;&lt;/span&gt;, &lt;span&gt;110&lt;/span&gt;d);&lt;br/&gt;        log.info(&lt;span&gt;&quot;课程ID：{}，名称：{}，原价：{}，折扣价：{}&quot;&lt;/span&gt;,&lt;br/&gt;                course2.getId(),&lt;br/&gt;                course2.getName(),&lt;br/&gt;                course2.getPrice(),&lt;br/&gt;                course2.getDiscountPrice());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;类图如下&lt;/p&gt;&lt;h1&gt;&lt;span&gt;依赖倒置原则（Dependence Inversion Principle，DIP）&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;依赖倒置原则是指设计代码结构时，高层模块不应该依赖底层模块细节，二者都应该依赖其抽象。抽象不应该依赖细节，细节应该依赖抽象。&lt;/p&gt;&lt;p&gt;通过依赖倒置，可以减少类与类之间的耦合性，提高系统的稳定性，提高代码的可读性和可维护性，并能够降低修改程序所造成的的风险。&lt;/p&gt;&lt;p&gt;如下，汽车系统类直接依赖具体的汽车实现类，如果需要再兼容一个品牌的汽车，则汽车系统类的所有方法都需要同步修改&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;HondaCar&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;本田汽车启动了&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;turn&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;本田汽车转弯了&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;stop&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;本田汽车停车了&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FordCar&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;福特汽车启动了&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;turn&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;福特汽车转弯了&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;stop&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;福特汽车停车了&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CarSystem&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt; CarType {&lt;br/&gt;        Honda, Ford&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; HondaCar hondaCar = &lt;span&gt;new&lt;/span&gt; HondaCar();&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; FordCar fordCar = &lt;span&gt;new&lt;/span&gt; FordCar();&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; CarType carType;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;CarSystem&lt;/span&gt;&lt;span&gt;(CarType carType)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.carType = carType;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;runCar&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;switch&lt;/span&gt; (carType) {&lt;br/&gt;            &lt;span&gt;case&lt;/span&gt; Honda:&lt;br/&gt;                hondaCar.run();&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;case&lt;/span&gt; Ford:&lt;br/&gt;                fordCar.run();&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;turnCar&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;switch&lt;/span&gt; (carType) {&lt;br/&gt;            &lt;span&gt;case&lt;/span&gt; Honda:&lt;br/&gt;                hondaCar.turn();&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;case&lt;/span&gt; Ford:&lt;br/&gt;                fordCar.turn();&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;stopCar&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;switch&lt;/span&gt; (carType) {&lt;br/&gt;            &lt;span&gt;case&lt;/span&gt; Honda:&lt;br/&gt;                hondaCar.stop();&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;case&lt;/span&gt; Ford:&lt;br/&gt;                fordCar.stop();&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DipTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        CarSystem carSystem = &lt;span&gt;new&lt;/span&gt; CarSystem(CarSystem.CarType.Ford);&lt;br/&gt;        carSystem.runCar();&lt;br/&gt;        carSystem.turnCar();&lt;br/&gt;        carSystem.stopCar();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为此，我们抽象一个汽车接口出来，然后每个品牌的汽车都实现它，汽车系统直接依赖汽车接口，不再关注每个品牌的实现。&lt;/p&gt;&lt;p&gt;这样，即使需要再新增一个品牌的汽车，只需要新增一个类实现汽车接口，并且修改客户端代码即可，不需要对汽车系统类做任何改动。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;ICar&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;turn&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;stop&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;HondaCar&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ICar&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;本田汽车启动了&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;turn&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;本田汽车转弯了&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;stop&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;本田汽车停车了&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FordCar&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ICar&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;福特汽车启动了&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;turn&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;福特汽车转弯了&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;stop&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;福特汽车停车了&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CarSystem&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; ICar car;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;CarSystem&lt;/span&gt;&lt;span&gt;(ICar car)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.car = car;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;runCar&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        car.run();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;turnCar&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        car.turn();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;stopCar&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        car.stop();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DipTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        CarSystem carSystem = &lt;span&gt;new&lt;/span&gt; CarSystem(&lt;span&gt;new&lt;/span&gt; FordCar());&lt;br/&gt;        carSystem.runCar();&lt;br/&gt;        carSystem.turnCar();&lt;br/&gt;        carSystem.stopCar();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;类图如下&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6463414634146342&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wTYzmuFUFkVDYEiclwvEvLrtwnn2EAhjliad4I238j0v4ia1DsWzhPsQnplbrOpVXdvcH4tlWlNbnyhia8aJ95IwIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;492&quot;/&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;单一职责原则（Simple Responsibility Principle）&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;单一职责是指不要存在多于一个导致类变更的原因。假设一个类负责两个职责，一旦需求变更，修改其中一个职责的逻辑代码，有可能会导致另一个职责的功能发生故障。这样这个类就存在两个导致类变更的原因了，我们就要给两个职责分别用两个类来实现。&lt;/p&gt;&lt;p&gt;如下，有一个课程类，可以播放直播课程和录播课程，不管哪一个课程的需求变更，都需要修改这个类，即存在多个原因导致类的变化&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Course&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;study&lt;/span&gt;&lt;span&gt;(String courseName)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;直播课&quot;&lt;/span&gt;.equals(courseName)) {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;直播课程不能快进&quot;&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;录播课&quot;&lt;/span&gt;.equals(courseName)) {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;录播课程可以任意切换进度&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们可以将课程类进行拆分，让每一个类只负责一种课程，这样一种课程的修改不会影响到另外一个课程&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LiveCourse&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;study&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;直播课程不能快进&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ReplayCourse&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;study&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;录播课程可以任意切换进度&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SrpTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Course course = &lt;span&gt;new&lt;/span&gt; Course();&lt;br/&gt;        course.study(&lt;span&gt;&quot;直播课&quot;&lt;/span&gt;);&lt;br/&gt;        course.study(&lt;span&gt;&quot;录播课&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        LiveCourse liveCourse = &lt;span&gt;new&lt;/span&gt; LiveCourse();&lt;br/&gt;        liveCourse.study();&lt;br/&gt;&lt;br/&gt;        ReplayCourse replayCourse = &lt;span&gt;new&lt;/span&gt; ReplayCourse();&lt;br/&gt;        replayCourse.study();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1&gt;&lt;span&gt;接口隔离原则（Interface Segregation Principle，ISP）&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;接口隔离原则是指用多个专门的接口，而不使用单一的总接口，客户端不应该依赖它不需要的接口。&lt;/p&gt;&lt;p&gt;这个原则指导我们在设计接口时应当注意一下几点：&lt;/p&gt;&lt;p&gt;一个类对一个类的依赖应该建立在最小的接口之上&lt;br/&gt;建立单一接口，不要建立庞大臃肿的接口&lt;br/&gt;尽量细化接口，接口中的方法尽量少（不是越少越好，一定要适度）&lt;br/&gt;接口隔离原则符合我们常说的高内聚低耦合的设计思想，从而使得类具有很好的可读性、可扩展性和可维护性。我们在设计接口的时候，要多花时间去思考，要考虑业务模型，包括以后有可能发生变更的地方还要做一些预判。&lt;/p&gt;&lt;p&gt;如下，定义了一个动物的接口，有吃东西、飞翔、游泳方法，但是鸟不会游泳，狗不会飞翔，导致它们有一些空实现的方法&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;IAnimal&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;eat&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;fly&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;swim&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Bird&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IAnimal&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;eat&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;鸟吃虫&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;fly&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;鸟会飞&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;swim&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Dog&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IAnimal&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;eat&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;狗吃饭&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;fly&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;swim&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;狗会游泳&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以，我们应该进行接口隔离，不同动物实现各自的接口&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;IEatAnimal&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;eat&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;IFlyAnimal&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;fly&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;ISwimAnimal&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;swim&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Bird&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IEatAnimal&lt;/span&gt;, &lt;span&gt;IFlyAnimal&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;eat&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;鸟会吃东西&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;fly&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;鸟会飞&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Dog&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IEatAnimal&lt;/span&gt;, &lt;span&gt;ISwimAnimal&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;eat&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;狗会吃东西&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;swim&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;狗会游泳&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对比两个类图&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8333333333333334&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wTYzmuFUFkVDYEiclwvEvLrtwnn2EAhjlhqicagaWiaibUN0OmqzGEoFJ6CiafxibLpo75acDNzGnGib3uwJmv8octibrg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;360&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.474&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wTYzmuFUFkVDYEiclwvEvLrtwnn2EAhjlecw20hSaGL3r5RIdAE3PgOjRo7kD9bJTbqkicibg0Cryp3mWO29x89rQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;500&quot;/&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;迪米特法则（Law of Demeter，LOD）&lt;/span&gt;&lt;br/&gt;&lt;/h1&gt;&lt;p&gt;迪米特法则是指一个对象应该对其他对象保持最少的了解，又叫最少知道原则（Least Knowledge Principle，LKP），尽量降低类与类之间的耦合。&lt;/p&gt;&lt;p&gt;迪特米法则主要强调只和朋友交流，不和陌生人说话。出现在成员变量、方法的输入、输出参数中的类都可以称为成员朋友类，而出现在方法内部的类不属于朋友类。&lt;/p&gt;&lt;p&gt;如下，老板让员工统计已发布的课程数量，功能是没有问题的&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Course&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Employee&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;countCourse&lt;/span&gt;&lt;span&gt;(List&amp;lt;course&amp;gt; courses)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;目前已发布的课程数量为&quot;&lt;/span&gt; + courses.size());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Boss&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;countCourse&lt;/span&gt;&lt;span&gt;(Employee employee)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        List&amp;lt;course&amp;gt; courseList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;course&amp;gt;();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;20&lt;/span&gt;; i ++){&lt;br/&gt;            courseList.add(&lt;span&gt;new&lt;/span&gt; Course());&lt;br/&gt;        }&lt;br/&gt;        employee.countCourse(courseList);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LodTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Employee employee = &lt;span&gt;new&lt;/span&gt; Employee();&lt;br/&gt;        Boss boss = &lt;span&gt;new&lt;/span&gt; Boss();&lt;br/&gt;        boss.countCourse(employee);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是老板其实只想要结果，不需要直接知道课程的细节，根据迪特米法则进行调整如下&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Course&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Employee&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; List&amp;lt;course&amp;gt; courses;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Employee&lt;/span&gt;&lt;span&gt;(List&amp;lt;course&amp;gt; courses)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.courses = courses;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;countCourse&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;目前已发布的课程数量为&quot;&lt;/span&gt; + courses.size());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Boss&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;countCourse&lt;/span&gt;&lt;span&gt;(Employee employee)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        employee.countCourse();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LodTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        List&amp;lt;course&amp;gt; courseList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;course&amp;gt;();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;20&lt;/span&gt;; i ++){&lt;br/&gt;            courseList.add(&lt;span&gt;new&lt;/span&gt; Course());&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        Employee employee = &lt;span&gt;new&lt;/span&gt; Employee(courseList);&lt;br/&gt;        Boss boss = &lt;span&gt;new&lt;/span&gt; Boss();&lt;br/&gt;        boss.countCourse(employee);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;类图对比如下&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1497005988023952&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wTYzmuFUFkVDYEiclwvEvLrtwnn2EAhjljPjRicnGH6rbMVcLok2s0MlaNMPzialaAZwXXic8MSd1bTGqnKAibvajWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;334&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9664082687338501&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wTYzmuFUFkVDYEiclwvEvLrtwnn2EAhjljEVgjfqOaKxbrKtPoxbSX3Mb1H2Fgib76PZc2XicwibibWwlicogCnZm2uQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;387&quot;/&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;里氏替换原则（Liskov Substitution Principle，LSP）&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;里氏替换原则是指如果对每一个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序p在所有的对象o1都替换成o2时，程序p的行为没有发生变化，那么类型T2是类型T1的子类型。&lt;/p&gt;&lt;p&gt;定义比较抽象，可以理解为一个软件实体如果适用一个父类的话，那一定适用于其子类，所以引用父类的地方必须能透明地使用其子类的对象，子类的对象能够替换父类的对象，而程序逻辑不变。&lt;/p&gt;&lt;p&gt;引申含义：子类可以扩展父类的功能，但不能改变父类原有的功能。&lt;/p&gt;&lt;p&gt;子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法&lt;br/&gt;子类中可以增加自己特有的方法&lt;br/&gt;当子类的方法重载父类的方法时，方法的前置条件（即方法的入参）要比父类方法的入参更宽松&lt;br/&gt;当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的返回值）要比父类更严格或相等&lt;br/&gt;优点：&lt;/p&gt;&lt;p&gt;约束继承泛滥，开闭原则的一种体现&lt;br/&gt;加强程序的健壮性，同时变更时也可以做到非常好的兼容性，提高程序的维护性、扩展性。降低需求变更时引入的风险。&lt;br/&gt;如下：&lt;br/&gt;同样的方法入参，当调用method1时，都是执行父类的逻辑，属于遵循里氏替换原则，方法的入参要比父类方法的入参更宽松；&lt;br/&gt;当调用method2时，使用子类对象时执行了子类的逻辑，属于违反里氏替换原则；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Parent&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;method1&lt;/span&gt;&lt;span&gt;(HashMap&amp;lt;string, string=&lt;span&gt;&quot;&quot;&lt;/span&gt;&amp;gt; map)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;父类method1&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;method2&lt;/span&gt;&lt;span&gt;(Map map)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;父类method2&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Child&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Parent&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;method1&lt;/span&gt;&lt;span&gt;(Map map)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;子类method1&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;method2&lt;/span&gt;&lt;span&gt;(HashMap&amp;lt;string, string=&lt;span&gt;&quot;&quot;&lt;/span&gt;&amp;gt; map)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;子类method2&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MethodParamTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Parent parent = &lt;span&gt;new&lt;/span&gt; Parent();&lt;br/&gt;        parent.method1(&lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;());&lt;br/&gt;        parent.method2(&lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;());&lt;br/&gt;&lt;br/&gt;        Child child = &lt;span&gt;new&lt;/span&gt; Child();&lt;br/&gt;        child.method1(&lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;());&lt;br/&gt;        child.method2(&lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;父类method1&lt;br/&gt;父类method2&lt;br/&gt;父类method1&lt;br/&gt;子类method2&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如下：当子类复写父类的方法时，而返回值比父类的更宽松，编译不通过，jdk本身提供了这个支持&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Parent&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; HashMap&amp;lt;string, string=&lt;span&gt;&quot;&quot;&lt;/span&gt;&amp;gt; method1() {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;父类method1&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Child&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Parent&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; Map&amp;lt;string, string=&lt;span&gt;&quot;&quot;&lt;/span&gt;&amp;gt; method1() {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;子类method1&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;合成复用原则是指尽量使用对象组合（has-a）/ 聚合（contains-a），而不是继承关系达到软件复用的目的。可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少。&lt;/p&gt;&lt;p&gt;继承我们叫做白箱复用，相当于把所有实现细节暴露给子类。组合/聚合也称之为黑箱复用，对类以外的对象是无法获取到实现细节的。&lt;/p&gt;&lt;p&gt;如下，是一个非常典型的合成复用原则应用场景。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DBConnection&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; String &lt;span&gt;getConnection&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MySQLConnection&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;DBConnection&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getConnection&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;MySQL数据库连接&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;OracleConnection&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;DBConnection&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getConnection&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Oracle数据库连接&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ProductDao&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; DBConnection dbConnection;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;ProductDao&lt;/span&gt;&lt;span&gt;(DBConnection dbConnection)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.dbConnection = dbConnection;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;addProduct&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        String connection = dbConnection.getConnection();&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;获得：&quot;&lt;/span&gt; + connection);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CarpTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ProductDao productDao = &lt;span&gt;new&lt;/span&gt; ProductDao(&lt;span&gt;new&lt;/span&gt; MySQLConnection());&lt;br/&gt;        productDao.addProduct();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;类图如下&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8208661417322834&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wTYzmuFUFkVDYEiclwvEvLrtwnn2EAhjlBIFkj5J5N80RLVCb9RTuPo0PXtcwNia2iccSXEP4elHicRB2GHicOapdZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;508&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>323a9a4969408d362ad9df0614283d63</guid>
<title>我的绘图工具箱</title>
<link>https://toutiao.io/k/cpcd1i2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entry-content&quot; itemprop=&quot;articleBody&quot;&gt;&amp;#13;
&lt;p&gt;由于在写作中经常需要配图，本文分享下我常用的绘图工具以及如何存储并展示配图。&lt;/p&gt;
&lt;h3&gt;白板绘图&lt;/h3&gt;
&lt;hr/&gt;
&lt;h4&gt;Excalidraw&lt;/h4&gt;
&lt;p&gt;白板绘图的好处在于灵活度非常高。好的白板工具可以很方便的绘制自由的图片和预定义的结构化图形，这方面我在用的工具是 &lt;a href=&quot;https://excalidraw.com/&quot;&gt;Excalidraw&lt;/a&gt;，由于是本工具是开源的，我也部署了自己的 Excalidraw &lt;a href=&quot;https://wb.bmpi.dev/&quot;&gt;白板工具&lt;/a&gt;。在 &lt;a href=&quot;https://www.bmpi.dev/self/life-in-plain-text/&quot;&gt;基于纯文本的人生管理&lt;/a&gt; 这篇文章里所有的配图都是用 Excalidraw 绘制，比如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/11/1-practical-drawing-toolbox.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个好的白板工具应该需要有什么特性呢？Excalidraw 的创始人写了一篇很好的文章 &lt;a href=&quot;https://blog.excalidraw.com/rethinking-virtual-whiteboard/&quot;&gt;Rethinking Virtual Whiteboard&lt;/a&gt; 来回答这个问题。&lt;/p&gt;
&lt;p&gt;Excalidraw 的优点有以下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无需注册，直接使用，用完即走；&lt;/li&gt;
&lt;li&gt;代码开源，免费使用，不用担心商业问题；&lt;/li&gt;
&lt;li&gt;多人实时协作，共同绘制；&lt;/li&gt;
&lt;li&gt;数据可导出，可通过链接直接分享给任何人；&lt;/li&gt;
&lt;li&gt;数据存储在浏览器本地，文件可离线编辑；&lt;/li&gt;
&lt;li&gt;扩展性强，可以导入其他人绘制的资源库；&lt;/li&gt;
&lt;li&gt;数据采用&lt;a href=&quot;https://blog.excalidraw.com/end-to-end-encryption/&quot;&gt;端到端加密&lt;/a&gt;，服务器端数据加密存储，隐私保护很可靠；&lt;/li&gt;
&lt;li&gt;保存的文件可直接在 VSCode 编辑（通过插件），同时可被其他网站嵌入使用，比如不只是笔记工具的 &lt;a href=&quot;https://logseq.com/&quot;&gt;Logseq &lt;/a&gt;里的绘图功能就是嵌入 Excalidraw 完成的；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;拥有这么多特性，用 Excalidraw 能画啥图得取决于你的想象力了：在 &lt;a href=&quot;https://blog.excalidraw.com/one-year-of-excalidraw/&quot;&gt;One Year of Excalidraw&lt;/a&gt; 与 &lt;a href=&quot;https://pakstech.com/blog/draw-diagrams/&quot;&gt;Create Diagrams That Look Like Hand-drawn&lt;/a&gt; 这两篇文章里可以看到使用 Excalidraw 画常见的结构图如架构图、结构图、流程图与交互图等，也可以自由绘制如品牌Logo、事件风暴图、原型图、对比图、手绘图、四格漫画与平面图等。&lt;/p&gt;
&lt;p&gt;除了 Excalidraw 外，其创始人早期用了另一个白板工具近 10 年，这个工具是 &lt;a href=&quot;https://zwibbler.com/&quot;&gt;zwibbler&lt;/a&gt;，我看了下感觉用 Excalidraw 完全可以替代它。&lt;/p&gt;

&lt;p&gt;这几个在线白板很适合团队协作（比如敏捷工作流如 Retro、站会、头脑风暴、工作坊等），和 Excalidraw 不同之处在于，它们支持的模版更为丰富，还能集成不同的 App，比如在白板里插入表格和图片之类。其中 Figma 虽然是个类似 Sketch 的设计工具，但是也支持白板的用法。&lt;/p&gt;
&lt;p&gt;不好的地方在于它们都不是开源的，但是也提供了免费版。当然也可以用 Google 出品的 &lt;a href=&quot;https://jamboard.google.com/&quot;&gt;jamboard&lt;/a&gt; 替代，虽然没有提供模版，但是基本功能都类似。&lt;/p&gt;
&lt;h4&gt;Perfect FreeHand&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://hw.bmpi.dev/&quot;&gt;带有压感的在线手写板工具&lt;/a&gt;，以下是用手写板手写的效果：&lt;br/&gt;
&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/11/2-practical-drawing-toolbox-.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;文本绘图&lt;/h3&gt;
&lt;hr/&gt;
&lt;p&gt;文本绘图的好处在于修改、存储方便，很简单即可绘制出固定模式的图，如时序图、架构图、部署图、线框图、甘特图、WBS与思维导图。 &lt;a href=&quot;https://plantuml.com/zh/&quot;&gt;PlantUML&lt;/a&gt; 是一个支持文本绘制类UML图的工具，可以在 &lt;a href=&quot;https://real-world-plantuml.com/&quot;&gt;Real World Plantuml&lt;/a&gt; 找到很多用它实现的图。我一般用它来绘制以下一些图。&lt;/p&gt;
&lt;h4&gt;思维导图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/11/1-practical-drawing-toolbox.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;文本如下：&lt;/p&gt;
&lt;p&gt;@startmindmap&lt;/p&gt;
&lt;p&gt;skinparam monochrome true&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Markdown排版&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;博客&lt;/li&gt;
&lt;li&gt;知乎专栏&lt;/li&gt;
&lt;li&gt;微信公众号&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;@endmindmap&lt;/p&gt;
&lt;p&gt;可以使用在线编辑器 &lt;a href=&quot;http://www.plantuml.com/plantuml/uml/&quot;&gt;PlantUML Editor&lt;/a&gt; 在线编辑预览。&lt;/p&gt;
&lt;h4&gt;架构图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/11/2-practical-drawing-toolbox.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;源文本见 &lt;a href=&quot;https://raw.githubusercontent.com/bmpi-dev/bmpi.dev/master/content/dev/guide-to-serverless/arch_aws.plantuml&quot;&gt;arch_aws.plantuml&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;关于文本绘图的进一步思考，推荐看 &lt;a href=&quot;https://c4model.com/&quot;&gt;C4 Model&lt;/a&gt; 的作者这篇 &lt;a href=&quot;https://dev.to/simonbrown/visio-draw-io-lucidchart-gliffy-etc-not-recommended-for-software-architecture-diagrams-4bmm&quot;&gt;Software architecture diagrams as text&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;专业绘图&lt;/h3&gt;
&lt;hr/&gt;
&lt;h4&gt;Sketch/OmniGraffle&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/11/3-practical-drawing-toolbox.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;源文件见 &lt;a href=&quot;https://github.com/bmpi-dev/bmpi.dev/blob/master/content/dev/guide-to-serverless/Serverless.sketch?raw=true&quot;&gt;Serverless.sketch&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;要想用 Sketch 画好配图，配色很重要，这方面可以看 draveness 写的这篇&lt;a href=&quot;https://draveness.me/sketch-and-sketch/&quot;&gt;《技术文章配图指南》&lt;/a&gt;。当然 Sketch 可以做的远不止这些，不过这不在本文讨论范围。&lt;/p&gt;

&lt;p&gt;这类工具都可以绘制各类你想要的配图，唯一限制的就是你的想象力了。&lt;/p&gt;
&lt;p&gt;在线绘图工具如 &lt;a href=&quot;https://docs.google.com/drawings&quot;&gt;Google Drawings&lt;/a&gt; 的多人实时协作功能更是团队协作绘图利器。这篇&lt;a href=&quot;https://ericfu.me/timestamp-in-distributed-trans/#more&quot;&gt;《分布式事务中的时间戳》&lt;/a&gt;中的配图就是用 Google Drawings 绘制的。&lt;/p&gt;
&lt;h3&gt;代码绘图&lt;/h3&gt;
&lt;hr/&gt;
&lt;h4&gt;Python Jupyter Notebook&lt;/h4&gt;
&lt;p&gt;我用这个绘制一些数据分析的图，比如这种：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/11/4-practical-drawing-toolbox.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;源代码见 &lt;a href=&quot;https://github.com/bmpi-dev/invest-alchemy/raw/master/strategy/index_month_quote_change.ipynb&quot;&gt;index_month_quote_change.ipynb&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;其他工具&lt;/h3&gt;
&lt;hr/&gt;
&lt;h4&gt;Excel&lt;/h4&gt;
&lt;p&gt;用 Excel 画图不是不可以，你可以用数据绘制图，也可以用单元格来绘制马赛克的图，不过我一般用它来绘制投资组合的一些走势图和状态图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/11/5-practical-drawing-toolbox.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;配图存储与展示&lt;/h3&gt;
&lt;hr/&gt;
&lt;p&gt;图片我一般用 VSCode 插件 &lt;a href=&quot;https://github.com/bmpi-dev/vscode-extension-mardown-image-paste&quot;&gt;markdown image paste &lt;/a&gt;配置 AWS S3 后，可将复制到剪贴板的图片一键上传至 S3 桶，之后可通过桶绑定的域名访问图片，具体详见&lt;a href=&quot;https://www.bmpi.dev/self/note-system/&quot;&gt;《我的笔记系统》&lt;/a&gt;&lt;strong&gt;VSCode插件一键存储图片至S3&lt;/strong&gt;节。&lt;/p&gt;
&lt;h3&gt;关于绘图工具的思考&lt;/h3&gt;
&lt;p&gt;没有一种工具是万能的，万能如 Excalidraw 也无法替代 Lucidchart/Draw.io/Google Drawings/Visio 这些复杂的工具（他们更适合复杂的对精确性有高度要求的图）。更没有一种软件工具能替代纸和笔。工具更重要的是背后使用它的人，能用图片讲好一个故事才是我们需要不断提升的能力，一个工具能做到不限制你的发挥就算适合的好的工具。&lt;/p&gt;
&amp;#13;
&lt;/div&gt;&amp;#13;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>