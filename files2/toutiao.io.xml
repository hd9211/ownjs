<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>5a004cf613fa340a91b28ddc0b3c9d68</guid>
<title>史上最全教程：idea 将 Java 项目打包 Jar 包，并生成 exe 可执行文件</title>
<link>https://toutiao.io/k/iyge3cy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;container app-preview post-body&quot;&gt;
  &lt;div class=&quot;preview&quot;&gt;&lt;h2&gt;第一步：idea将Java项目打包Jar包&lt;/h2&gt;

&lt;h3&gt;使用idea创建springboot项目或者java项目&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;这个这里就不多讲解了。（相信大部分都会了，如果不会的话，我后面在出一篇文章专门讲解创建springboot项目和普通java项目。）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;打包springboot或java项目到jar包&lt;/h3&gt;



&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS1lMDYxZGI2ZmM5MGNiYzIz?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;



&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS1iM2IzMTdjNmM2NDg0MzI0?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS1iOGQ0MzViODFlYmZmNjFi?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS0xOWJhNjJjZjc0ZjU0YTA5?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;



&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS0yZjRhZWYxYzU2M2VmYzI2?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS1lOTg1OGMwOTk5MTIxMzk0?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Bulid后会生成jar包，这个jar包会用于后面我们生成&quot;.exe&quot;可执行文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS01MDQ5ZGUyODNkYzc1OWQy?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;



&lt;h2&gt;第二步：Springboot项目jar包生成exe可执行文件&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;jar包生成exe可执行文件需要一个软件-exe4j（微信公众号：Madison龙少 回复：jar2exe 获取资源）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;让我们一起开始使用exe4j打包项目&lt;/h2&gt;

&lt;h3&gt;下载安装exe4j&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS03Y2UzN2ZlNzNhNmIzNjdl?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; 
安装成功之后直接运行。&lt;/p&gt;

&lt;h3&gt;创建打包目录&lt;/h3&gt;

&lt;p&gt;比如在桌面创建一个文件夹gui，将jar包放到gui文件夹里面，如果你怕别的机器没有jre，将你本地的jre目录拷贝的里面，我的目录可以参考一下。（但是我添加了jre，其他机器（没有java环境）没有生效。有知道的可以告知一下。）
&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS05OWNkOGY4ZDkxNzE4MDQ5?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;

&lt;h3&gt;开始打包&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;在打包前先注册，在welcome界面的右下角
用户名和公司随便填写即可。注册码下面的都可以用。
注册码：微信公众号：Madison龙少 回复：jar2exe 获取资源&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS0wYzNlZDhiMGZiYzA0ZGU3?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;



&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS03OGFkMjlkNWEyOWE0OWMx?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;这个地方会出现一个报错&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/LongGroup/tinygray_picturebed/raw/master/wechat/jarToExeFile/01.jpg&quot; alt=&quot;&amp;quot;Madison龙少&amp;quot;&quot;/&gt;
设置方法：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS03MTI3ZDZmMzhjZmMyODA0?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS1lMWI1MWE4ZTdmYTk3N2M3?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS0yMmU1NjZiNGYzMTgwZGM3?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;点击next，到如下界面，点击绿色“＋”，设置程序运行的Class Path&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS1iNmY1ZDA2YmQ0MWM2NDkw?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;选择打包好的jar包&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS01YmI4MTU1ODhlNTkyZWE0?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;选择主程序&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS05YmI4MDk1MGYyNTU4M2Jk?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;点击next，然后出现下面界面。输入Java最小Jre版本号，即低于这个版本的Jre无法运行该程序，接着点击“Advanced Options”-“Search sequence”，设置一下我们的JRE，之前说过，如果客户机上没装Jre咋办？，没关系我们捆绑一个进去&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS1iNjA2Zjg1MDcyZDk4MDdk?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;绑定jre&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS1kYjdhYWRlYjYxMmU0MTY1?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS00YTkzODA4ZDgzZjc4NWYw?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;



&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS1jMjhkYjk3ZGMwNDY1MWE1?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS05MTE5ZmNjOWMyMWQyOTFk?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS1hZjMzYTZmNWY2MGJiZmQy?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS1kNThlNTVlMjgxNjFiYjQw?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;

&lt;p&gt;出现这个就说明我们大功告成了。鼓掌呱唧呱唧&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;看一下我们打包的结果，这就是我们生成的exe文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS04M2U5NTE2ZWQ5Njg1NTI2?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;

&lt;h2&gt;结束语&lt;/h2&gt;

&lt;p&gt;感谢阅读小生文章。祝大家早日富可敌国，实现财富自由。&lt;br/&gt;
&lt;code&gt;写文不易&lt;/code&gt;,一定要&lt;code&gt;点赞、评论、收藏哦&lt;/code&gt;,&lt;code&gt;感谢感谢感谢!!!&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;有任何问题可以在微信搜索&lt;code&gt;公众号&lt;/code&gt;：&lt;code&gt;Madison龙少&lt;/code&gt;进行咨询&lt;br/&gt;
或者微信扫描下面二维码进行咨询&lt;br/&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9af8ae383ef40249747bb2278c064d9%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&amp;quot;Madison龙少&amp;quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>950be1088b2d3d0af479f6f55c0a99d9</guid>
<title>Java 中的集合 List（入门篇）</title>
<link>https://toutiao.io/k/de00pgg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;h2&gt;前言&lt;/h2&gt;

&lt;p&gt;大家好啊，我是汤圆，今天给大家带来的是《Java中的集合List - 入门篇》，希望对大家有帮助，谢谢&lt;/p&gt;

&lt;h2&gt;简介&lt;/h2&gt;

&lt;p&gt;说实话，Java中的集合有很多种，但是这里作为入门级别，先简单介绍第一种集合&lt;code&gt;List&lt;/code&gt;，如下图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/03/30/kTAnEyP9cv1DXai.png&quot; alt=&quot;集合&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;正文&lt;/h2&gt;

&lt;p&gt;List是一种有序集合，和数组的行为非常相似，但是比数组灵活；&lt;/p&gt;

&lt;p&gt;因为数组是长度固定的，而List的长度是动态分配的。&lt;/p&gt;

&lt;h4&gt;数组的概览&lt;/h4&gt;

&lt;p&gt;既然LIst是基于数组实现的，那么在介绍List之前，我们先来熟悉一下Java的数组吧（简单过一下，毕竟用的不多了）&lt;/p&gt;

&lt;p&gt;数组对象有一个length属性来获取数组的长度，和一个&quot;[]&quot;方法来访问元素&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;数组也是一个对象，通过直接打印数组可以看出来，比如&lt;code&gt;[Ljava.lang.String;@1b6d3586&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如下所示，我们先初始化一个数组，并通过length访问了数组的长度，[]语法访问数组内的元素&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;// 初始化数组
String[] arr = {&quot;1&quot;, &quot;2&quot;, &quot;3&quot;};
// 数组长度
int length = arr.length;
// 数组第一个元素
String a1 = arr[0];
// 数组转为字符串，需借助Arrays工具类
String res = Arrays.toString(arr);

System.out.println(length);
System.out.println(a1);
System.out.println(res);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中我们用到了Arrays这个工具类，因为数组的toString方法不能直接拼接内部的元素，而是打印数组对象的地址&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;List可以，直接调用List.toString()即可输出所有元素拼接后的字符串&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;数组的优点：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;随机访问快，也是仅存的一个优点（其他地方都没ArrayList好）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;数组的缺点&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;长度固定，插入慢&lt;/p&gt;

&lt;p&gt;好了，数组先说到这里，下面开始说List&lt;/p&gt;

&lt;h4&gt;List的接口方法&lt;/h4&gt;

&lt;p&gt;下面是几个常用的List接口方法：&lt;/p&gt;



&lt;h4&gt;ArrayList和LinkedList的区别&lt;/h4&gt;

&lt;p&gt;用表格对比结果如下：&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th/&gt;
&lt;th&gt;ArrayList&lt;/th&gt;
&lt;th&gt;LinkedList&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;内部结构&lt;/td&gt;
&lt;td&gt;数组，有序&lt;/td&gt;
&lt;td&gt;双向链表，无序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;随机访问&lt;/td&gt;
&lt;td&gt;快&lt;/td&gt;
&lt;td&gt;慢&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;插入、修改&lt;/td&gt;
&lt;td&gt;慢（如果是末尾插入，则很快）&lt;/td&gt;
&lt;td&gt;快&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;可以看到，ArrayList适合随机访问，LinkedList适合插入和修改（如果是尾插，则区别不大）&lt;/p&gt;

&lt;h4&gt;为什么ArrayList随机访问很快呢？&lt;/h4&gt;

&lt;p&gt;ArrayList是基于数组实现的，而数组又是基于整数索引（下标）来查询数据的，所以ArrayList的查询效率很高&lt;/p&gt;

&lt;h4&gt;为什么ArrayList插入又很慢？&lt;/h4&gt;

&lt;p&gt;插入很慢，是因为ArrayList内部基于数组实现，内存都是连续的，因此插入时要移动后面的数据；&lt;/p&gt;

&lt;p&gt;如果是直接在末尾插入，则不需要移动任何数据，也就快了（默认添加元素时，就是在尾部插入）&lt;/p&gt;

&lt;p&gt;但是如果我要在中间位置插入，那么后面的数据都需要移动&lt;/p&gt;

&lt;p&gt;比如下图，我想把 &quot;Cat 005&quot; 插入到 &quot;Cat 001&quot; 后面，那么后面的 &quot;Cat 002&quot;、&quot;Cat 003&quot;、 &quot;Cat 004&quot;都要移动，这就导致效率很低&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/03/30/OlEzYRg4sdJb6nq.png&quot; alt=&quot;ArrayList中间插入图&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;为什么LinkedList随机访问慢？&lt;/h4&gt;

&lt;p&gt;因为LinkedList内部是双向链表结构，即每个元素都包含一个前引用和后引用，如下图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/03/30/zVmIGbyPHoKQwse.png&quot; alt=&quot;LinkedList内部结构&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这就导致了一个问题，每次不管我访问哪个元素，都需要从头开始一个个索引；&lt;/p&gt;

&lt;p&gt;结果就是访问速度很慢。&lt;/p&gt;

&lt;h4&gt;那么为什么LinkedList随机插入很快呢？&lt;/h4&gt;

&lt;p&gt;正所谓&quot;成也萧何败萧何&quot;，虽然随机访问慢，但是正因为有了这些链表结构，使得插入的时候很方便了&lt;/p&gt;

&lt;p&gt;因为现在不需要移动任何元素，只需要修改前后元素的引用就可以了&lt;/p&gt;

&lt;p&gt;比如下图，我想把 &quot;Dog 005&quot; 插入到 &quot;Dog 001&quot; 后面，那么只需要修改 &quot;Dog 001&quot;的后引用和&quot;Dog 002&quot;的前引用，其他元素都不用动的&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/03/30/fxXyuFWgaoV3pi2.png&quot; alt=&quot;LinkedList中间插入图&quot;/&gt;&lt;/p&gt;

&lt;p&gt;细心的你们可能发现了，ArrayList图中的元素都是&lt;strong&gt;顺序排列&lt;/strong&gt;的，而LinkedList图中的元素都是&lt;strong&gt;随机排列&lt;/strong&gt;的；&lt;/p&gt;

&lt;p&gt;这个其实就是为了说明他们俩的内部结构特征，&lt;strong&gt;ArrayList内存空间有序，LinkedList内存空间无序&lt;/strong&gt;&lt;/p&gt;

&lt;h4&gt;那么LinkedList这样设计，除了插入快，还有其他好处吗？&lt;/h4&gt;

&lt;p&gt;当然有啊，因为LinkedList内部的数据都是通过引用来连接到一起的，所以就可以很好的利用零散的内存空间，从而&lt;strong&gt;提高内存利用率&lt;/strong&gt;&lt;/p&gt;

&lt;h4&gt;代码&lt;/h4&gt;

&lt;p&gt;下面我们用代码来实践下&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;// 初始化
List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
// 插入数据
list.add(&quot;hello world 1&quot;);
// 在指定位置插入数据
list.add(0, &quot;hello world 2&quot;);
// 查询数据
String s1 = list.get(0);
// 查询List是否包含指定对象
boolean isContain = list.contains(s1);
// 查询列表的元素个数
int size = list.size();
// 打印list内部元素：
String res = list.toString();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果如下所示，可以看到，List.toString()会自动拼接内部元素&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/03/30/k8fiZYMSvlbdBCa.png&quot; alt=&quot;List代码输出&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;总结&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;List&lt;/code&gt;是一种有序集合，和数组的行为非常相似，但是比数组灵活；&lt;/p&gt;

&lt;p&gt;最常用的是&lt;code&gt;ArrayList&lt;/code&gt;，它适用于大部分场景；&lt;/p&gt;

&lt;p&gt;但是在&lt;strong&gt;插多查少&lt;/strong&gt;的情况下，建议用&lt;code&gt;LinkedList&lt;/code&gt;，可以提高插入的效率；&lt;/p&gt;

&lt;h2&gt;后记&lt;/h2&gt;

&lt;p&gt;最后，感谢大家的观看，谢谢&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>29fb31b2791771170f26120ef3520d72</guid>
<title>[译] Uber：面向领域的微服务架构</title>
<link>https://toutiao.io/k/0yy2iga</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0eda94d145708a54c90a6a4a7143ec13</guid>
<title>JVM 进阶之路（七）：垃圾收集器盘点</title>
<link>https://toutiao.io/k/55l066q</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkwODE5ODM0Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeFt08hV3N1706WTzfhoTNoXm5LXRV0XibppmeNR4zSNMa3QOJJ7ib4O21P5yohibwuD26Tp9ETWZAqA/0?wx_fmt=png&quot; data-nickname=&quot;三分恶&quot; data-alias=&quot;Fighter3FullStack&quot; data-signature=&quot;一个全栈开发。分享Java后端、Web前端、计算机基础知识。&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前面，我们已经了解了JVM的分代收集，知道JVM垃圾收集在新生代主要采用&lt;code&gt;标记-复制&lt;/code&gt;算法，在老年代主要采用&lt;code&gt;标记-清除&lt;/code&gt;和&lt;code&gt;标记-整理&lt;/code&gt;算法。接下来，我们看一看JDK默认虚拟机HotSpot的一些垃圾收集器的实现。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1、常见垃圾回收器&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先来看一下JDK 11之前全部可用的垃圾收集器。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5464362850971922&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdO3fvU2GrmVgwyep1OOsKArMUIzCibukh3ibCaxX7Jt40kiaUWibq66d4oKibIZZkKibL4uw1Gctiar4cLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;926&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;HotSpot虚拟机&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图中列出了七种垃圾收集器，连线表示可以配合使用，所在区域表示它是属于新生代收集器或是老年代收集器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里还标出了垃圾收集器采用的收集算法，G1收集器比较特殊，整体采用&lt;code&gt;标记-整理&lt;/code&gt;算法，局部采用&lt;code&gt;标记-复制&lt;/code&gt;算法，后面再细讲。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.1、Serial收集器&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Serial收集器是最基础、历史最悠久的收集器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如同它的名字（串行），它是一个单线程工作的收集器，使用一个处理器或一条收集线程去完成垃圾收集工作。并且进行垃圾收集时，必须暂停其他所有工作线程，直到垃圾收集结束——这就是所谓的“Stop The World”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Serial/Serial Old收集器的运行过程如图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.32432432432432434&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdO3fvU2GrmVgwyep1OOsKAzcwuk8kAj4cFGlLbB1xdK9jOnsx0utfgRz8x0nELB2D5fJNVhzoSOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;888&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;Serial/Serial Old收集器运行示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2、ParNew收集器&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ParNew收集器实质上是Serial收集器的多线程并行版本，使用多条线程进行垃圾收集。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ParNew收集器的工作过程如图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.32432432432432434&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdO3fvU2GrmVgwyep1OOsKAJdquP0DZzBAJqHibPNNaTKJxiczTG1Ux2QhWNkbxReEAjyYj0tgdfagw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;888&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;ParNew/Serial Old收集器运行示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里值得一提的是Par是&lt;code&gt;Parallel（并行）&lt;/code&gt;的缩写，但需要注意的是，这个&lt;code&gt;并行（Parallel）&lt;/code&gt;仅仅是描述同一时间多条GC线程协同工作，而不是GC线程和用户线程同时运行。ParNew垃圾收集也是需要Stop The World的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.3、Parallel Scavenge收集器&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Parallel Scavenge收集器是一款新生代收集器，基于标记-复制算法实现，也能够并行收集。和ParNew有些类似，但Parallel Scavenge主要关注的是垃圾收集的吞吐量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所谓吞吐量指的是运行用户代码的时间与处理器总消耗时间的比值。这个比例越高，证明垃圾收集占整个程序运行的比例越小。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3401709401709402&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdO3fvU2GrmVgwyep1OOsKA44OI9VbouNicHvvOP0bO52ZfiaXaAZMGycPnfEFcPKrsibtKib8MM6EkRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;585&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;吞吐量&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;「-XX：MaxGCPauseMillis」&lt;/strong&gt;，最大垃圾回收停顿时间。这个参数的原理是空间换时间，收集器会控制新生代的区域大小，从而尽可能保证回收少于这个最大停顿时间。简单的说就是回收的区域越小，那么耗费的时间也越小。所以这个参数并不是设置得越小越好。设太小的话，新生代空间会太小，从而更频繁的触发GC。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;「-XX：GCTimeRatio」&lt;/strong&gt;，垃圾收集时间与总时间占比。这个是吞吐量的倒数，原理和MaxGCPauseMillis相同。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于与吞吐量关系密切，Parallel Scavenge收集器也经常被称作“吞吐量优先收集器”。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.4、Serial Old收集器&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Serial Old收集器的工作过程如图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.32432432432432434&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdO3fvU2GrmVgwyep1OOsKAzcwuk8kAj4cFGlLbB1xdK9jOnsx0utfgRz8x0nELB2D5fJNVhzoSOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;888&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;Serial/Serial Old收集器运行示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.5、Parallel Old收集器&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.32432432432432434&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdO3fvU2GrmVgwyep1OOsKACaLCLia8khiancXqBwWOWDXg4R77GzBHOJ8dpG7h4aeS9RdiaiaFH9hkpg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;888&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;Parallel Scavenge/Parallel Old收集器运行示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.6、CMS收集器&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，同样是老年代的收集齐，采用&lt;code&gt;标记-清除&lt;/code&gt;算法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CMS收集齐的垃圾收集分为四步：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;初始标记（CMS initial mark）&lt;/code&gt;：单线程运行，需要Stop The World，标记GC  Roots能直达的对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;并发标记（（CMS concurrent mark）&lt;/code&gt;：无停顿，和用户线程同时运行，从GC Roots直达对象开始遍历整个对象图。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;重新标记（CMS remark）&lt;/code&gt;：多线程运行，需要Stop The World，标记并发标记阶段产生对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;并发清除（CMS concurrent sweep）&lt;/code&gt;：无停顿，和用户线程同时运行，清理掉标记阶段标记的死亡的对象。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;涉及到了多次标记的过程，这里插入一点&lt;code&gt;三色抽象&lt;/code&gt;的知识。三色抽象用来描述对象在垃圾收集过程中的状态。&lt;/p&gt;&lt;p&gt;通常白色代表对象未被扫描到，灰色表示对象被扫描到但未被处理，黑色表示对象及其后代已被处理。在CMS的标记和清除过程中就用到了这种抽象，详细的可以查看参考【5】。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Concurrent Mark Sweep收集器运行示意图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2696629213483146&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdO3fvU2GrmVgwyep1OOsKACKsZsJicxfSZQJMzXOmJGObMr4FYBMrYaZL0AG3OKzMphn5iaXkLUzKw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1068&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;Concurrent Mark Sweep收集器运行示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;优点&lt;/code&gt;：CMS最主要的优点在名字上已经体现出来——并发收集、低停顿。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;缺点&lt;/code&gt;：CMS同样有三个明显的缺点。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Mark Sweep算法会导致内存碎片比较多&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;CMS的并发能力比较依赖于CPU资源，并发回收时垃圾收集线程可能会抢占用户线程的资源，导致用户程序性能下降。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;并发清除阶段，用户线程依然在运行，会产生所谓的理“浮动垃圾”（Floating Garbage），本次垃圾收集无法处理浮动垃圾，必须到下一次垃圾收集才能处理。如果浮动垃圾太多，会触发新的垃圾回收，导致性能降低。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.7、Garbage First收集器&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Garbage First（简称G1）收集器是垃圾收集器的一个颠覆性的产物，它开创了局部收集的设计思路和基于Region的内存布局形式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然G1也仍是遵循分代收集理论设计的，但其堆内存的布局与其他收集器有非常明显的差异。以前的收集器分代是划分新生代、老年代、持久代等。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.31724137931034485&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdO3fvU2GrmVgwyep1OOsKAtPhdkSfldyE3zxn1tZ26TK4y6FgSz0tTSBbgZEqFfaVY08HUYRU8EA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;580&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;垃圾分代区域&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;G1把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.31724137931034485&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdO3fvU2GrmVgwyep1OOsKAlSEkL3iadOQkYNicE1dUHVBDk3H0HQn2nPISqw6ymuDxfIxTqDXPsYrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1160&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;G1 Heap Regions&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就避免了收集整个堆，而是按照若干个Region集进行收集，同时维护一个优先级列表，跟踪各个Region回收的“价值，优先收集价值高的Region。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;G1收集器的运行过程大致可划分为以下四个步骤：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;初始标记（initial mark），标记了从GC Root开始直接关联可达的对象。STW（Stop the World）执行。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;并发标记（concurrent marking），和用户线程并发执行，从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象、&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;最终标记（Remark），STW，标记再并发标记过程中产生的垃圾。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;筛选回收（Live Data Counting And Evacuation），制定回收计划，选择多个Region 构成回收集，把回收集中Region的存活对象复制到空的Region中，再清理掉整个旧 Region的全部空间。需要STW。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2696629213483146&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdO3fvU2GrmVgwyep1OOsKAnR8TvkcribWViabjKab9gql6gLsBQqbZhfex31bfFm24kDYIQBq9m4Zw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1068&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;G1收集器运行示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相比CMS，G1的优点有很多，可以指定最大停顿时间、分Region的内存布局、按收益动态确定回收集。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只从内存的角度来看，与CMS的“标记-清除”算法不同，G1从整体来看是基于“标记-整理”算法实现的收集器，但从局部（两个Region 之间）上看又是基于“标记-复制”算法实现，无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，垃圾收集完成之后能提供规整的可用内存。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2、前沿垃圾回收器&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1、ZGC收集器&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在JDK 11当中，加入了实验性质的ZGC。它的回收耗时平均不到2毫秒。它是一款低停顿高并发的收集器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与CMS中的ParNew和G1类似，ZGC也采用标记-复制算法，不过ZGC对该算法做了重大改进：ZGC在标记、转移和重定位阶段几乎都是并发的，这是ZGC实现停顿时间小于10ms目标的最关键原因。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5187637969094923&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdO3fvU2GrmVgwyep1OOsKAREeyQPGSJLOiaBVtW4iabCKGjXjFJvyf1F85OYE8ke7jS5h5p4nbico3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1812&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;ZGC垃圾回收周期&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ZGC虽然在JDK 11还处于实验阶段，但由于算法与思想是一个非常大的提升，未来前景相信还是很广阔的。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3、垃圾收集器选择&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1、收集器选择权衡&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;垃圾收集器的选择需要权衡的点还是比较多的——例如运行应用的基础设施如何？使用JDK的发行商是什么？等等……&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里简单地列一下上面提到的一些收集器的适用场景：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「Serial」&lt;/strong&gt; ：如果应用程序有一个很小的内存空间（大约100 MB）亦或它在没有停顿时间要求的单线程处理器上运行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「Parallel」&lt;/strong&gt;：如果优先考虑应用程序的峰值性能，并且没有时间要求要求，或者可以接受1秒或更长的停顿时间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「CMS/G1」&lt;/strong&gt;：如果响应时间比吞吐量优先级高，亦或垃圾收集暂停必须保持在大约1秒以内。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「ZGC」&lt;/strong&gt;：如果响应时间是高优先级的，亦或堆空间比较大。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1、设置垃圾收集器&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置垃圾收集器（组合）的参数如下：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;strong&gt;「新生代」&lt;/strong&gt;&lt;/th&gt;&lt;th&gt;&lt;strong&gt;「老年代」&lt;/strong&gt;&lt;/th&gt;&lt;th&gt;&lt;strong&gt;「JVM 参数」&lt;/strong&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Incremental&lt;/td&gt;&lt;td&gt;Incremental&lt;/td&gt;&lt;td&gt;-Xincgc&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;「Serial」&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;&lt;strong&gt;「Serial」&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;&lt;strong&gt;「-XX:+UseSerialGC」&lt;/strong&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Parallel Scavenge&lt;/td&gt;&lt;td&gt;Serial&lt;/td&gt;&lt;td&gt;-XX:+UseParallelGC -XX:-UseParallelOldGC&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Parallel New&lt;/td&gt;&lt;td&gt;Serial&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Serial&lt;/td&gt;&lt;td&gt;Parallel Old&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;「Parallel Scavenge」&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;&lt;strong&gt;「Parallel Old」&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;&lt;strong&gt;「-XX:+UseParallelGC -XX:+UseParallelOldGC」&lt;/strong&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Parallel New&lt;/td&gt;&lt;td&gt;Parallel Old&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Serial&lt;/td&gt;&lt;td&gt;CMS&lt;/td&gt;&lt;td&gt;-XX:-UseParNewGC -XX:+UseConcMarkSweepGC&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Parallel Scavenge&lt;/td&gt;&lt;td&gt;CMS&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;「Parallel New」&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;&lt;strong&gt;「CMS」&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;&lt;strong&gt;「-XX:+UseParNewGC -XX:+UseConcMarkSweepGC」&lt;/strong&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;「G1」&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;strong&gt;「-XX:+UseG1GC」&lt;/strong&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;big&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/big&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;【1】：周志朋编著《深入理解Java虚拟机：JVM高级特性与最佳实践》&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;【2】：《垃圾回收算法手册 自动内存管理的艺术》&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;【3】：Garbage Collection in Java – What is GC and How it Works in the JVM&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;【4】：Java Hotspot G1 GC的一些关键技术&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;【5】：GC Algorithms: Implementations&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;【6】：新一代垃圾回收器ZGC的探索与实践&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>da8089e883535318c60273af016b3778</guid>
<title>你该如何为 Kubernetes 定制特性</title>
<link>https://toutiao.io/k/ea28kfh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;article-content&quot;&gt;&lt;p&gt;Kubernetes 是非常复杂的集群编排系统，然而哪怕包含丰富的功能和特性，因为容器的调度和管理本身就有较高的复杂性，所以它无法满足所有场景下的需求。虽然 Kubernetes 能够解决大多数场景中的常见问题，但是为了实现更加灵活的策略，我们需要使用 Kubernetes 提供的扩展能力实现特定目的。&lt;/p&gt;&lt;p&gt;每个项目在不同的周期会着眼于不同的特性，我们可以将项目的演进过程简单分成三个不同的阶段：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;最小可用&lt;/strong&gt;：项目在早期更倾向于解决通用的、常见的问题，给出开箱即用的解决方案以吸引用户，这时代码库的规模还相对比较小，提供的功能较为有限，能够覆盖领域内 90% 的场景；&lt;/li&gt;&lt;li&gt;&lt;strong&gt;功能完善&lt;/strong&gt;：随着项目得到更多的使用者和支持者，社区会不断实现相对重要的功能，社区治理和自动化工具也逐渐变得完善，能够解决覆盖内 95% 的场景；&lt;/li&gt;&lt;li&gt;&lt;strong&gt;扩展能力&lt;/strong&gt;：因为项目的社区变得完善，代码库变得逐渐庞大，项目的每个变动都会影响下游的开发者，任何新功能的加入都需要社区成员的讨论和审批，这时社区会选择增强项目的扩展性，让使用者能够为自己的场景定制需求，能够解决覆盖内 99% 的场景；&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/evolving-of-open-source-project-2021-03-24-16165170057421.png&quot; alt=&quot;evolving-of-open-source-project&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 1 - 开源项目的演进&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;从 90%、95% 到 99%，每个步骤都需要社区成员花费很多精力，但是哪怕提供了较好的扩展性也无法解决领域内的全部问题，在一些极端场景下仍然需要维护自己的分支或者另起炉灶满足业务上的需求。&lt;/p&gt;&lt;p&gt;然而无论是维护自己的分支，还是另起炉灶都会带来较高的开发和维护成本，这需要结合实际需求进行抉择。但是能够利用项目提供的配置能力和扩展能力就可以明显地降低定制化的开发成本，而我们今天要梳理的就是 Kubernetes 的可扩展性。&lt;/p&gt;&lt;h2 id=&quot;扩展接口&quot;&gt;扩展接口&lt;/h2&gt;&lt;p&gt;API 服务器是 Kubernetes 中的核心组件，它承担着集群中资源读写的重任，虽然社区提供的资源和接口可以满足大多数的日常需求，但是我们仍然会有一些场景需要扩展 API 服务器的能力，这一节简单介绍几个扩展该服务的方法。&lt;/p&gt;&lt;h3 id=&quot;自定义资源&quot;&gt;自定义资源&lt;/h3&gt;&lt;p&gt;自定义资源（Custom Resource Definition、CRD）应该是 Kubernetes 最常见的扩展方式&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;，它是扩展 Kubernetes API 的方式之一。Kubernetes 的 API 就是我们向集群提交的 YAML，系统中的各个组件会根据提交的 YAML 启动应用、创建网络路由规则以及运行工作负载。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span&gt;apiVersion&lt;/span&gt;: &lt;span&gt;v1&lt;/span&gt;
&lt;span&gt;kind&lt;/span&gt;: &lt;span&gt;Pod&lt;/span&gt;
&lt;span&gt;metadata&lt;/span&gt;:
  &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;static-web&lt;/span&gt;
  &lt;span&gt;labels&lt;/span&gt;:
    &lt;span&gt;role&lt;/span&gt;: &lt;span&gt;myrole&lt;/span&gt;
&lt;span&gt;spec&lt;/span&gt;:
  &lt;span&gt;containers&lt;/span&gt;:
    - &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;web&lt;/span&gt;
      &lt;span&gt;image&lt;/span&gt;: &lt;span&gt;nginx&lt;/span&gt;
      &lt;span&gt;ports&lt;/span&gt;:
        - &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;web&lt;/span&gt;
          &lt;span&gt;containerPort&lt;/span&gt;: &lt;span&gt;80&lt;/span&gt;
          &lt;span&gt;protocol&lt;/span&gt;: &lt;span&gt;TCP&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;Pod&lt;/code&gt;、&lt;code&gt;Service&lt;/code&gt; 以及 &lt;code&gt;Ingress&lt;/code&gt; 都是 Kubernetes 对外暴露的接口，当我们在集群中提交上述 YAML 时，Kubernetes 中的控制器会根据配置创建满足条件的容器。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span&gt;apiVersion&lt;/span&gt;: &lt;span&gt;apiextensions.k8s.io/v1&lt;/span&gt;
&lt;span&gt;kind&lt;/span&gt;: &lt;span&gt;CustomResourceDefinition&lt;/span&gt;
&lt;span&gt;metadata&lt;/span&gt;:
  &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;crontabs.stable.example.com&lt;/span&gt;
&lt;span&gt;spec&lt;/span&gt;:
  &lt;span&gt;group&lt;/span&gt;: &lt;span&gt;stable.example.com&lt;/span&gt;
  &lt;span&gt;versions&lt;/span&gt;:
    - &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;v1&lt;/span&gt;
      &lt;span&gt;served&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;
      &lt;span&gt;storage&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;
      &lt;span&gt;schema&lt;/span&gt;:
        &lt;span&gt;openAPIV3Schema&lt;/span&gt;:
          &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;object&lt;/span&gt;
          &lt;span&gt;properties&lt;/span&gt;:
            &lt;span&gt;spec&lt;/span&gt;:
              &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;object&lt;/span&gt;
              &lt;span&gt;properties&lt;/span&gt;:
                &lt;span&gt;cronSpec&lt;/span&gt;:
                  &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;string&lt;/span&gt;
                &lt;span&gt;image&lt;/span&gt;:
                  &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;string&lt;/span&gt;
                &lt;span&gt;replicas&lt;/span&gt;:
                  &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;integer&lt;/span&gt;
  &lt;span&gt;scope&lt;/span&gt;: &lt;span&gt;Namespaced&lt;/span&gt;
  &lt;span&gt;names&lt;/span&gt;:
    &lt;span&gt;plural&lt;/span&gt;: &lt;span&gt;crontabs&lt;/span&gt;
    &lt;span&gt;singular&lt;/span&gt;: &lt;span&gt;crontab&lt;/span&gt;
    &lt;span&gt;kind&lt;/span&gt;: &lt;span&gt;CronTab&lt;/span&gt;
    &lt;span&gt;shortNames&lt;/span&gt;:
    - &lt;span&gt;ct&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;除了这些系统内置的 API 之外，想要实现定制的接口就需要使用 CRD，然而 CRD 仅仅是实现自定义资源的冰山一角，因为它只定义了资源中的字段，我们还需要遵循 Kubernetes 的控制器模式，实现消费 CRD 的 Operator，通过组合 Kubernetes 提供的资源实现更复杂、更高级的功能。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/modular-kubernetes-api-2021-03-24-16165170057450.png&quot; alt=&quot;modular-kubernetes-api&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 2 - Kubernetes API 模块化设计&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;如上图所示，Kubernetes 中的控制器等组件会消费 &lt;code&gt;Deployment&lt;/code&gt;、&lt;code&gt;StatefulSet&lt;/code&gt; 等资源，而用户自定义的 CRD 会由自己实现的控制器消费，这种设计极大地降低了系统之间各个模块的耦合，让不同模块可以无缝协作。&lt;/p&gt;&lt;p&gt;当我们想要让 Kubernetes 集群提供更加复杂的功能时，选择 CRD 和控制器是首先需要考虑的方法，这种方式与现有的功能耦合性非常低，同时也具有较强的灵活性，但是在定义接口时应该遵循社区 API 的最佳实践设计出优雅的接口&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;&lt;h3 id=&quot;聚合层&quot;&gt;聚合层&lt;/h3&gt;&lt;p&gt;Kubernetes API 聚合层是 v1.7 版本实现的功能，它的目的是将单体的 API 服务器拆分成多个聚合服务，每个开发者都能够实现聚合 API 服务暴露它们需要的接口，这个过程不需要重新编译 Kubernetes 的任何代码&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/kubernetes-api-aggregation-2021-03-24-16165170057457.png&quot; alt=&quot;kubernetes-api-aggregation&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 3 - Kubernetes API 聚合&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;当我们需要在集群中加入新的 API 聚合服务时，需要提交一个 &lt;code&gt;APIService&lt;/code&gt; 资源，这个资源描述了接口所属的组、版本号以及处理该接口的服务，下面是 Kubernetes 社区中 metrics-server 服务对应的 &lt;code&gt;APIService&lt;/code&gt;：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span&gt;apiVersion&lt;/span&gt;: &lt;span&gt;apiregistration.k8s.io/v1&lt;/span&gt;
&lt;span&gt;kind&lt;/span&gt;: &lt;span&gt;APIService&lt;/span&gt;
&lt;span&gt;metadata&lt;/span&gt;:
  &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;v1beta1.metrics.k8s.io&lt;/span&gt;
&lt;span&gt;spec&lt;/span&gt;:
  &lt;span&gt;service&lt;/span&gt;:
    &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;metrics-server&lt;/span&gt;
    &lt;span&gt;namespace&lt;/span&gt;: &lt;span&gt;kube-system&lt;/span&gt;
  &lt;span&gt;group&lt;/span&gt;: &lt;span&gt;metrics.k8s.io&lt;/span&gt;
  &lt;span&gt;version&lt;/span&gt;: &lt;span&gt;v1beta1&lt;/span&gt;
  &lt;span&gt;insecureSkipTLSVerify&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;
  &lt;span&gt;groupPriorityMinimum&lt;/span&gt;: &lt;span&gt;100&lt;/span&gt;
  &lt;span&gt;versionPriority&lt;/span&gt;: &lt;span&gt;100&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果我们将上述资源提交到 Kubernetes 集群中后，用户在访问 API 服务器的 &lt;code&gt;/apis/metrics.k8s.io/v1beta1&lt;/code&gt; 路径时，会被转发到集群中的 &lt;code&gt;metrics-server.kube-system.svc&lt;/code&gt; 服务上。&lt;/p&gt;&lt;p&gt;与应用范围很广的 CRD 相比，API 聚合机制在项目中比较少见，它的主要目的还是扩展 API 服务器，而大多数的集群都不会有类似的需求，在这里也就不过多介绍了。&lt;/p&gt;&lt;h3 id=&quot;准入控制&quot;&gt;准入控制&lt;/h3&gt;&lt;p&gt;Kubernetes 的准入控制机制可以修改和验证即将被 API 服务器持久化的资源，API 服务器收到的全部写请求都会经过如下所示的阶段持久化到 etcd 中&lt;sup id=&quot;fnref:4&quot;&gt;&lt;a href=&quot;#fn:4&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/kubernetes-admission-control-2021-03-24-16165170057463.png&quot; alt=&quot;kubernetes-admission-control&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 4 - Kubernetes 准入控制&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Kubernetes 的代码仓库中包含 20 多个准入控制插件&lt;sup id=&quot;fnref:5&quot;&gt;&lt;a href=&quot;#fn:5&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;，我们以 &lt;code&gt;TaintNodesByCondition&lt;/code&gt; 插件&lt;sup id=&quot;fnref:6&quot;&gt;&lt;a href=&quot;#fn:6&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;6&lt;/a&gt;&lt;/sup&gt;为例简单介绍一下它们的实现原理：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;p&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;Plugin&lt;/span&gt;) &lt;span&gt;Admit&lt;/span&gt;(&lt;span&gt;ctx&lt;/span&gt; &lt;span&gt;context&lt;/span&gt;.&lt;span&gt;Context&lt;/span&gt;, &lt;span&gt;a&lt;/span&gt; &lt;span&gt;admission&lt;/span&gt;.&lt;span&gt;Attributes&lt;/span&gt;, &lt;span&gt;o&lt;/span&gt; &lt;span&gt;admission&lt;/span&gt;.&lt;span&gt;ObjectInterfaces&lt;/span&gt;) &lt;span&gt;error&lt;/span&gt; {
&lt;span&gt;if&lt;/span&gt; &lt;span&gt;a&lt;/span&gt;.&lt;span&gt;GetResource&lt;/span&gt;().&lt;span&gt;GroupResource&lt;/span&gt;() &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nodeResource&lt;/span&gt; &lt;span&gt;||&lt;/span&gt; &lt;span&gt;a&lt;/span&gt;.&lt;span&gt;GetSubresource&lt;/span&gt;() &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt; {
&lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;
}

&lt;span&gt;node&lt;/span&gt;, &lt;span&gt;ok&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;a&lt;/span&gt;.&lt;span&gt;GetObject&lt;/span&gt;().(&lt;span&gt;*&lt;/span&gt;&lt;span&gt;api&lt;/span&gt;.&lt;span&gt;Node&lt;/span&gt;)
&lt;span&gt;if&lt;/span&gt; !&lt;span&gt;ok&lt;/span&gt; {
&lt;span&gt;return&lt;/span&gt; &lt;span&gt;admission&lt;/span&gt;.&lt;span&gt;NewForbidden&lt;/span&gt;(&lt;span&gt;a&lt;/span&gt;, &lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Errorf&lt;/span&gt;(&lt;span&gt;&quot;unexpected type %T&quot;&lt;/span&gt;, &lt;span&gt;a&lt;/span&gt;.&lt;span&gt;GetObject&lt;/span&gt;()))
}

&lt;span&gt;addNotReadyTaint&lt;/span&gt;(&lt;span&gt;node&lt;/span&gt;)
&lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;所有的准入控制插件都可以实现上述的 &lt;code&gt;Admit&lt;/code&gt; 方法修改即将提交到存储中的资源，也就是上面提到的 Mutating 修改阶段，这段代码会为所有传入节点加上 &lt;code&gt;NotReady&lt;/code&gt; 污点保证节点在更新期间不会有任务调度到该节点上；除了 &lt;code&gt;Admit&lt;/code&gt; 方法之外，插件还可以实现 &lt;code&gt;Validate&lt;/code&gt; 方法验证传入资源的合法性。&lt;/p&gt;&lt;p&gt;在 Kubernetes 实现自定义的准入控制器相对比较复杂，我们需要构建一个实现准入控制接口的 API 服务并将该 API 服务通过 &lt;code&gt;MutatingWebhookConfiguration&lt;/code&gt; 和 &lt;code&gt;ValidatingWebhookConfiguration&lt;/code&gt; 两种资源将服务的地址和接口注册到集群中，而 Kubernetes 的 API 服务器会在修改资源时调用 &lt;code&gt;WebhookConfiguration&lt;/code&gt; 中定义的服务修改和验证资源。Kubernetes 社区中的比较热门的服务网格 Istio 就利用该特性实现了一些功能&lt;sup id=&quot;fnref:7&quot;&gt;&lt;a href=&quot;#fn:7&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;7&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;&lt;h2 id=&quot;容器接口&quot;&gt;容器接口&lt;/h2&gt;&lt;p&gt;Kubernetes 作为容器编排系统，它的主要逻辑还是调度和管理集群中运行的容器，虽然它不需要从零开始实现新的容器运行时，但是因为网络和存储等模块是容器运行的必需品，所以它要与这些模块打交道。Kubernetes 选择的方式是设计网络、存储和运行时接口隔离实现细节，自己把精力放在容器编排上，让第三方社区实现这些复杂而且极具专业性的模块。&lt;/p&gt;&lt;h3 id=&quot;网络插件&quot;&gt;网络插件&lt;/h3&gt;&lt;p&gt;容器网络接口（Container Network Interface、CNI）包含一组用于开发插件去配置 Linux 容器中网卡的接口和框架。CNI 仅会关注容器的网络连通性并在容器删除时回收所有分配的网络资源&lt;sup id=&quot;fnref:8&quot;&gt;&lt;a href=&quot;#fn:8&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;8&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/cni-banner-2021-03-24-16165170057469.png&quot; alt=&quot;cni-banner&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 5 - 容器网络接口&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;CNI 插件虽然与 Kubernetes 有密切的关系，但是不同的容器管理系统都可以使用 CNI 插件来创建和管理网络，例如：mesos、Cloud Foundry 等。&lt;/p&gt;&lt;p&gt;所有的 CNI 插件都应该实现包含 &lt;code&gt;ADD&lt;/code&gt;、&lt;code&gt;DEL&lt;/code&gt; 和 &lt;code&gt;CHECK&lt;/code&gt; 操作的二进制可执行文件，容器管理系统会执行二进制文件来创建网络&lt;sup id=&quot;fnref:9&quot;&gt;&lt;a href=&quot;#fn:9&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;9&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;&lt;p&gt;在 Kubernetes 中，无论使用哪种网络插件都需要遵循它的网络模型，除了每个 Pod 都需要有独立的 IP 地址之外，Kubernetes 还对网络模型做出了以下的需求：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;任意节点上的 Pod 在不使用 NAT 的情况下都访问到所有节点上的所有 Pod；&lt;/li&gt;&lt;li&gt;节点上的 Kubelet 和守护进程等服务可以访问节点上的其他 Pod；&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;CNI&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; {
&lt;span&gt;AddNetworkList&lt;/span&gt;(&lt;span&gt;ctx&lt;/span&gt; &lt;span&gt;context&lt;/span&gt;.&lt;span&gt;Context&lt;/span&gt;, &lt;span&gt;net&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;NetworkConfigList&lt;/span&gt;, &lt;span&gt;rt&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;RuntimeConf&lt;/span&gt;) (&lt;span&gt;types&lt;/span&gt;.&lt;span&gt;Result&lt;/span&gt;, &lt;span&gt;error&lt;/span&gt;)
&lt;span&gt;CheckNetworkList&lt;/span&gt;(&lt;span&gt;ctx&lt;/span&gt; &lt;span&gt;context&lt;/span&gt;.&lt;span&gt;Context&lt;/span&gt;, &lt;span&gt;net&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;NetworkConfigList&lt;/span&gt;, &lt;span&gt;rt&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;RuntimeConf&lt;/span&gt;) &lt;span&gt;error&lt;/span&gt;
&lt;span&gt;DelNetworkList&lt;/span&gt;(&lt;span&gt;ctx&lt;/span&gt; &lt;span&gt;context&lt;/span&gt;.&lt;span&gt;Context&lt;/span&gt;, &lt;span&gt;net&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;NetworkConfigList&lt;/span&gt;, &lt;span&gt;rt&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;RuntimeConf&lt;/span&gt;) &lt;span&gt;error&lt;/span&gt;
&lt;span&gt;GetNetworkListCachedResult&lt;/span&gt;(&lt;span&gt;net&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;NetworkConfigList&lt;/span&gt;, &lt;span&gt;rt&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;RuntimeConf&lt;/span&gt;) (&lt;span&gt;types&lt;/span&gt;.&lt;span&gt;Result&lt;/span&gt;, &lt;span&gt;error&lt;/span&gt;)
&lt;span&gt;GetNetworkListCachedConfig&lt;/span&gt;(&lt;span&gt;net&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;NetworkConfigList&lt;/span&gt;, &lt;span&gt;rt&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;RuntimeConf&lt;/span&gt;) ([]&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;*&lt;/span&gt;&lt;span&gt;RuntimeConf&lt;/span&gt;, &lt;span&gt;error&lt;/span&gt;)

&lt;span&gt;AddNetwork&lt;/span&gt;(&lt;span&gt;ctx&lt;/span&gt; &lt;span&gt;context&lt;/span&gt;.&lt;span&gt;Context&lt;/span&gt;, &lt;span&gt;net&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;NetworkConfig&lt;/span&gt;, &lt;span&gt;rt&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;RuntimeConf&lt;/span&gt;) (&lt;span&gt;types&lt;/span&gt;.&lt;span&gt;Result&lt;/span&gt;, &lt;span&gt;error&lt;/span&gt;)
&lt;span&gt;CheckNetwork&lt;/span&gt;(&lt;span&gt;ctx&lt;/span&gt; &lt;span&gt;context&lt;/span&gt;.&lt;span&gt;Context&lt;/span&gt;, &lt;span&gt;net&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;NetworkConfig&lt;/span&gt;, &lt;span&gt;rt&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;RuntimeConf&lt;/span&gt;) &lt;span&gt;error&lt;/span&gt;
&lt;span&gt;DelNetwork&lt;/span&gt;(&lt;span&gt;ctx&lt;/span&gt; &lt;span&gt;context&lt;/span&gt;.&lt;span&gt;Context&lt;/span&gt;, &lt;span&gt;net&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;NetworkConfig&lt;/span&gt;, &lt;span&gt;rt&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;RuntimeConf&lt;/span&gt;) &lt;span&gt;error&lt;/span&gt;
&lt;span&gt;GetNetworkCachedResult&lt;/span&gt;(&lt;span&gt;net&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;NetworkConfig&lt;/span&gt;, &lt;span&gt;rt&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;RuntimeConf&lt;/span&gt;) (&lt;span&gt;types&lt;/span&gt;.&lt;span&gt;Result&lt;/span&gt;, &lt;span&gt;error&lt;/span&gt;)
&lt;span&gt;GetNetworkCachedConfig&lt;/span&gt;(&lt;span&gt;net&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;NetworkConfig&lt;/span&gt;, &lt;span&gt;rt&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;RuntimeConf&lt;/span&gt;) ([]&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;*&lt;/span&gt;&lt;span&gt;RuntimeConf&lt;/span&gt;, &lt;span&gt;error&lt;/span&gt;)

&lt;span&gt;ValidateNetworkList&lt;/span&gt;(&lt;span&gt;ctx&lt;/span&gt; &lt;span&gt;context&lt;/span&gt;.&lt;span&gt;Context&lt;/span&gt;, &lt;span&gt;net&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;NetworkConfigList&lt;/span&gt;) ([]&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;error&lt;/span&gt;)
&lt;span&gt;ValidateNetwork&lt;/span&gt;(&lt;span&gt;ctx&lt;/span&gt; &lt;span&gt;context&lt;/span&gt;.&lt;span&gt;Context&lt;/span&gt;, &lt;span&gt;net&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;NetworkConfig&lt;/span&gt;) ([]&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;error&lt;/span&gt;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;开发 CNI 插件对于多数工程师来说都非常遥远，在正常情况下，我们只需要在一些常见的开源框架中根据需求做出选择，例如：Flannel、Calico 和 Cilium 等，当集群的规模变得非常庞大时，也自然会有网络工程师与 Kubernetes 开发者配合开发相应的插件。&lt;/p&gt;&lt;h3 id=&quot;存储插件&quot;&gt;存储插件&lt;/h3&gt;&lt;p&gt;容器存储接口（Container Storage Interface、CSI）是 Kubernetes 在 v1.9 引入的新特性，该特性在 v1.13 中达到稳定，目前常见的容器编排系统 Kubernetes、Cloud Foundry、Mesos 和 Nomad 都选择使用该接口扩展集群中容器的存储能力。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/csi-banner-2021-03-24-16165170057477.png&quot; alt=&quot;csi-banner&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 6 - 容器存储接口&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;CSI 是在容器编排系统向容器化的工作负载暴露块存储和文件存储的标准，第三方的存储提供商可以通过实现 CSI 插件在 Kubernetes 集群中提供新的存储&lt;sup id=&quot;fnref:10&quot;&gt;&lt;a href=&quot;#fn:10&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;10&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;&lt;p&gt;Kubernetes 的开发团队在 CSI 的文档中给出了开发和部署 CSI 插件的最佳实践&lt;sup id=&quot;fnref:11&quot;&gt;&lt;a href=&quot;#fn:11&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;11&lt;/a&gt;&lt;/sup&gt;，其中最主要的工作是创建实现 &lt;code&gt;Identity&lt;/code&gt;、&lt;code&gt;Node&lt;/code&gt; 和可选的 &lt;code&gt;Controller&lt;/code&gt; 接口的容器化应用，并通过官方的 &lt;a href=&quot;https://github.com/kubernetes-csi/csi-test/tree/master/pkg/sanity&quot;&gt;&lt;code&gt;sanity&lt;/code&gt;&lt;/a&gt; 包测试 CSI 插件的合法性，需要实现的接口都定义在 CSI 的规格文档中&lt;sup id=&quot;fnref:12&quot;&gt;&lt;a href=&quot;#fn:12&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;12&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-protobuf&quot; data-lang=&quot;protobuf&quot;&gt;&lt;span&gt;service&lt;/span&gt; Identity {&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;rpc&lt;/span&gt; GetPluginInfo(GetPluginInfoRequest)&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;returns&lt;/span&gt; (GetPluginInfoResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;rpc&lt;/span&gt; GetPluginCapabilities(GetPluginCapabilitiesRequest)&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;returns&lt;/span&gt; (GetPluginCapabilitiesResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;rpc&lt;/span&gt; Probe (ProbeRequest)&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;returns&lt;/span&gt; (ProbeResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;}&lt;span&gt;
&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;service&lt;/span&gt; Controller {&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;...&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;}&lt;span&gt;
&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;service&lt;/span&gt; Node {&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;...&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;}&lt;span&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;CSI 的规格文档非常复杂，除了详细地定义了不同接口的请求和响应参数。它还定义不同接口在出现相应错误时应该返回的 gRPC 错误码，开发者想要实现一个完全遵循 CSI 接口的插件还是很麻烦的。&lt;/p&gt;&lt;p&gt;Kubernetes 在较早的版本中分别接入了不同的云厂商的接口，其中包括 Google PD、AWS、Azure 以及 OpenStack，但是随着 CSI 接口的成熟，社区未来会在上游移除云厂商特定的实现，减少上游的维护成本，也能加快各个厂商自身存储的迭代和支持&lt;sup id=&quot;fnref:13&quot;&gt;&lt;a href=&quot;#fn:13&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;13&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;&lt;h3 id=&quot;运行时接口&quot;&gt;运行时接口&lt;/h3&gt;&lt;p&gt;容器运行时接口（Container Runtime Interface、CRI）是一系列用于管理容器运行时和镜像的 gRPC 接口，它是 Kubernetes 在 v1.5 中引入的新接口，Kubelet 可以通过它使用不同的容器运行时。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/cri-and-container-runtimes-2021-03-24-16165170057484.png&quot; alt=&quot;cri-and-container-runtimes&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 7 - CRI 和容器运行时&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;CRI 主要定义的是一组 gRPC 方法，我们能在规格文档中找到 &lt;code&gt;RuntimeService&lt;/code&gt; 和 &lt;code&gt;ImageService&lt;/code&gt; 两个服务&lt;sup id=&quot;fnref:14&quot;&gt;&lt;a href=&quot;#fn:14&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;14&lt;/a&gt;&lt;/sup&gt;，它们的名字很好地解释了各自的作用：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-protobuf&quot; data-lang=&quot;protobuf&quot;&gt;&lt;span&gt;service&lt;/span&gt; RuntimeService {&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;rpc&lt;/span&gt; Version(VersionRequest) &lt;span&gt;returns&lt;/span&gt; (VersionResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;rpc&lt;/span&gt; RunPodSandbox(RunPodSandboxRequest) &lt;span&gt;returns&lt;/span&gt; (RunPodSandboxResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;rpc&lt;/span&gt; StopPodSandbox(StopPodSandboxRequest) &lt;span&gt;returns&lt;/span&gt; (StopPodSandboxResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;rpc&lt;/span&gt; RemovePodSandbox(RemovePodSandboxRequest) &lt;span&gt;returns&lt;/span&gt; (RemovePodSandboxResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;rpc&lt;/span&gt; PodSandboxStatus(PodSandboxStatusRequest) &lt;span&gt;returns&lt;/span&gt; (PodSandboxStatusResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;rpc&lt;/span&gt; ListPodSandbox(ListPodSandboxRequest) &lt;span&gt;returns&lt;/span&gt; (ListPodSandboxResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;rpc&lt;/span&gt; CreateContainer(CreateContainerRequest) &lt;span&gt;returns&lt;/span&gt; (CreateContainerResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;rpc&lt;/span&gt; StartContainer(StartContainerRequest) &lt;span&gt;returns&lt;/span&gt; (StartContainerResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;rpc&lt;/span&gt; StopContainer(StopContainerRequest) &lt;span&gt;returns&lt;/span&gt; (StopContainerResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;rpc&lt;/span&gt; RemoveContainer(RemoveContainerRequest) &lt;span&gt;returns&lt;/span&gt; (RemoveContainerResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;rpc&lt;/span&gt; ListContainers(ListContainersRequest) &lt;span&gt;returns&lt;/span&gt; (ListContainersResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;rpc&lt;/span&gt; ContainerStatus(ContainerStatusRequest) &lt;span&gt;returns&lt;/span&gt; (ContainerStatusResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;rpc&lt;/span&gt; UpdateContainerResources(UpdateContainerResourcesRequest) &lt;span&gt;returns&lt;/span&gt; (UpdateContainerResourcesResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;rpc&lt;/span&gt; ReopenContainerLog(ReopenContainerLogRequest) &lt;span&gt;returns&lt;/span&gt; (ReopenContainerLogResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;rpc&lt;/span&gt; ExecSync(ExecSyncRequest) &lt;span&gt;returns&lt;/span&gt; (ExecSyncResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;rpc&lt;/span&gt; Exec(ExecRequest) &lt;span&gt;returns&lt;/span&gt; (ExecResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;rpc&lt;/span&gt; Attach(AttachRequest) &lt;span&gt;returns&lt;/span&gt; (AttachResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;rpc&lt;/span&gt; PortForward(PortForwardRequest) &lt;span&gt;returns&lt;/span&gt; (PortForwardResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;...&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;}&lt;span&gt;
&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;service&lt;/span&gt; ImageService {&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;rpc&lt;/span&gt; ListImages(ListImagesRequest) &lt;span&gt;returns&lt;/span&gt; (ListImagesResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;rpc&lt;/span&gt; ImageStatus(ImageStatusRequest) &lt;span&gt;returns&lt;/span&gt; (ImageStatusResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;rpc&lt;/span&gt; PullImage(PullImageRequest) &lt;span&gt;returns&lt;/span&gt; (PullImageResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;rpc&lt;/span&gt; RemoveImage(RemoveImageRequest) &lt;span&gt;returns&lt;/span&gt; (RemoveImageResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;rpc&lt;/span&gt; ImageFsInfo(ImageFsInfoRequest) &lt;span&gt;returns&lt;/span&gt; (ImageFsInfoResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;}&lt;span&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;容器运行时的接口相对比较简单，上面的这些接口不仅暴露了 Pod 沙箱管理、容器管理以及命令执行和端口转发等功能，还包含用于管理镜像的多个接口，容器运行时只要实现上面的二三十个方法可以为 Kubelet 提供服务。&lt;/p&gt;&lt;h2 id=&quot;设备插件&quot;&gt;设备插件&lt;/h2&gt;&lt;p&gt;CPU、内存、磁盘是主机上常见的资源，然而随着大数据、机器学习和硬件的发展，部分场景可能需要异构的计算资源，例如：GPU、FPGA 等设备。异构资源的出现不仅需要节点代理 Kubelet 的支持，还需要调度器的配合，为了良好的兼容后出现的不同计算设备，Kubernetes 社区在上游引入了设备插件（Device Plugin）用于支持多种类型资源的调度和分配&lt;sup id=&quot;fnref:15&quot;&gt;&lt;a href=&quot;#fn:15&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;15&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/device-plugin-overview-2021-03-24-16165170057491.png&quot; alt=&quot;device-plugin-overview&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 8 - 设备插件概述&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;设备插件是独立在 Kubelet 之外单独运行的服务，它通过 Kubelet 暴露的 &lt;code&gt;Registration&lt;/code&gt; 服务注册自己的相关信息并实现 &lt;code&gt;DevicePlugin&lt;/code&gt; 服务用于订阅和分配自定义的设备&lt;sup id=&quot;fnref:16&quot;&gt;&lt;a href=&quot;#fn:16&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;16&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-protobuf&quot; data-lang=&quot;protobuf&quot;&gt;&lt;span&gt;service&lt;/span&gt; Registration {&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;rpc&lt;/span&gt; Register(RegisterRequest) &lt;span&gt;returns&lt;/span&gt; (Empty) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;}&lt;span&gt;
&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;service&lt;/span&gt; DevicePlugin {&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;      &lt;span&gt;rpc&lt;/span&gt; GetDevicePluginOptions(Empty) &lt;span&gt;returns&lt;/span&gt; (DevicePluginOptions) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;      &lt;span&gt;rpc&lt;/span&gt; ListAndWatch(Empty) &lt;span&gt;returns&lt;/span&gt; (stream ListAndWatchResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;      &lt;span&gt;rpc&lt;/span&gt; Allocate(AllocateRequest) &lt;span&gt;returns&lt;/span&gt; (AllocateResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;      &lt;span&gt;rpc&lt;/span&gt; GetPreferredAllocation(PreferredAllocationRequest) &lt;span&gt;returns&lt;/span&gt; (PreferredAllocationResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;      &lt;span&gt;rpc&lt;/span&gt; PreStartContainer(PreStartContainerRequest) &lt;span&gt;returns&lt;/span&gt; (PreStartContainerResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;}&lt;span&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当设备插件刚刚启动时，它会调用 Kubelet 的注册接口传入自己的版本号、Unix 套接字和资源名，例如：&lt;code&gt;nvidia.com/gpu&lt;/code&gt;；Kubelet 会通过 Unix 套接字与设备插件通信，它会通过 &lt;code&gt;ListAndWatch&lt;/code&gt; 接口持续获得设备中资源的最新状态，并在 Pod 申请资源时通过 &lt;code&gt;Allocate&lt;/code&gt; 接口分配资源。设备插件的实现逻辑相对比较简单，感兴趣的读者可以研究 Nvidia GPU 插件的实现原理&lt;sup id=&quot;fnref:17&quot;&gt;&lt;a href=&quot;#fn:17&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;17&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;&lt;h2 id=&quot;调度框架&quot;&gt;调度框架&lt;/h2&gt;&lt;p&gt;调度器是 Kubernetes 中的核心组件之一，它的主要作用是在 Kubernetes 集群中的一组节点中为工作负载做出最优的调度决策，不同场景下的调度需求往往都是很复杂的，然而调度器在 Kubernetes 项目早期并不支持易用的扩展能力，仅支持调度器扩展（Extender）这种比较难用的方法。&lt;/p&gt;&lt;p&gt;Kubernetes 从 v1.15 引入的调度框架才是今天比较主流的调度器扩展技术，通过在 Kubernetes 调度器的内部抽象出关键的扩展点（Extension Point）并通过插件的方式在扩展点上改变调度器做出的调度决策&lt;sup id=&quot;fnref:18&quot;&gt;&lt;a href=&quot;#fn:18&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;18&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/scheduling-framework-extensions-2021-03-24-16165170057498.png&quot; alt=&quot;scheduling-framework-extensions&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 9 - 调度框架扩展点&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;目前的调度框架总共支持 11 个不同的扩展点，每个扩展点都对应 Kubernetes 调度器中定义的接口，这里仅展示 &lt;code&gt;FilterPlugin&lt;/code&gt; 和 &lt;code&gt;ScorePlugin&lt;/code&gt; 两个常见接口中的方法&lt;sup id=&quot;fnref:19&quot;&gt;&lt;a href=&quot;#fn:19&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;19&lt;/a&gt;&lt;/sup&gt;：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;FilterPlugin&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; {
&lt;span&gt;Plugin&lt;/span&gt;
&lt;span&gt;Filter&lt;/span&gt;(&lt;span&gt;ctx&lt;/span&gt; &lt;span&gt;context&lt;/span&gt;.&lt;span&gt;Context&lt;/span&gt;, &lt;span&gt;state&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;CycleState&lt;/span&gt;, &lt;span&gt;pod&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;.&lt;span&gt;Pod&lt;/span&gt;, &lt;span&gt;nodeInfo&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;NodeInfo&lt;/span&gt;) &lt;span&gt;*&lt;/span&gt;&lt;span&gt;Status&lt;/span&gt;
}

&lt;span&gt;type&lt;/span&gt; &lt;span&gt;ScoreExtensions&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; {
&lt;span&gt;NormalizeScore&lt;/span&gt;(&lt;span&gt;ctx&lt;/span&gt; &lt;span&gt;context&lt;/span&gt;.&lt;span&gt;Context&lt;/span&gt;, &lt;span&gt;state&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;CycleState&lt;/span&gt;, &lt;span&gt;p&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;.&lt;span&gt;Pod&lt;/span&gt;, &lt;span&gt;scores&lt;/span&gt; &lt;span&gt;NodeScoreList&lt;/span&gt;) &lt;span&gt;*&lt;/span&gt;&lt;span&gt;Status&lt;/span&gt;
}

&lt;span&gt;type&lt;/span&gt; &lt;span&gt;ScorePlugin&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; {
&lt;span&gt;Plugin&lt;/span&gt;
&lt;span&gt;Score&lt;/span&gt;(&lt;span&gt;ctx&lt;/span&gt; &lt;span&gt;context&lt;/span&gt;.&lt;span&gt;Context&lt;/span&gt;, &lt;span&gt;state&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;CycleState&lt;/span&gt;, &lt;span&gt;p&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;.&lt;span&gt;Pod&lt;/span&gt;, &lt;span&gt;nodeName&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;) (&lt;span&gt;int64&lt;/span&gt;, &lt;span&gt;*&lt;/span&gt;&lt;span&gt;Status&lt;/span&gt;)
&lt;span&gt;ScoreExtensions&lt;/span&gt;() &lt;span&gt;ScoreExtensions&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;调度框架的出现让实现复杂的调度策略和调度算法变得更加容易，社区通过调度框架替代更早的谓词和优先级并实现了协作式调度、基于容量调度等功能更强大的插件&lt;sup id=&quot;fnref:20&quot;&gt;&lt;a href=&quot;#fn:20&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;20&lt;/a&gt;&lt;/sup&gt;。虽然今天的调度框架已经变得非常灵活，但是串行的调度器可能无法满足大集群的调度需求，而 Kubernetes 目前也很难实现多调度器，不知道未来是否会提供更灵活的接口。&lt;/p&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;&lt;p&gt;Kubernetes 从 2014 年发布至今已经过去将近 7 年了，从一个最小可用的编排系统到今天的庞然大物，社区的每个代码贡献者和成员都有&lt;del&gt;责任&lt;/del&gt;。从这篇文章中，我们可以看到随着 Kubernetes 项目的演进方向，社区越来越关注系统的可扩展性，通过设计接口、移除第三方代码降低社区成员的负担，让 Kubernetes 能够更专注于容器的编排和调度。&lt;/p&gt;&lt;section class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;&lt;hr/&gt;&lt;ol&gt;&lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;Custom Resources · Kubernetes &lt;a href=&quot;https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/&quot;&gt;https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/&lt;/a&gt; &lt;a href=&quot;#fnref:1&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:2&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;API Conventions · Kubernetes Community &lt;a href=&quot;https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md&quot;&gt;https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md&lt;/a&gt; &lt;a href=&quot;#fnref:2&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:3&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;Aggregated API Servers · Kubernetes Community &lt;a href=&quot;https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/aggregated-api-servers.md&quot;&gt;https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/aggregated-api-servers.md&lt;/a&gt; &lt;a href=&quot;#fnref:3&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:4&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;Using Admission Controllers &lt;a href=&quot;https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/&quot;&gt;https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/&lt;/a&gt; &lt;a href=&quot;#fnref:4&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:5&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;kubernetes/plugin/pkg/admission/ · Kubernetes &lt;a href=&quot;https://github.com/kubernetes/kubernetes/tree/master/plugin/pkg/admission&quot;&gt;https://github.com/kubernetes/kubernetes/tree/master/plugin/pkg/admission&lt;/a&gt; &lt;a href=&quot;#fnref:5&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:6&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;kubernetes/plugin/pkg/admission/nodetaint/admission.go · Kubernetes &lt;a href=&quot;https://github.com/kubernetes/kubernetes/blob/master/plugin/pkg/admission/nodetaint/admission.go&quot;&gt;https://github.com/kubernetes/kubernetes/blob/master/plugin/pkg/admission/nodetaint/admission.go&lt;/a&gt; &lt;a href=&quot;#fnref:6&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:7&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;Dynamic Admission Webhooks Overview &lt;a href=&quot;https://istio.io/latest/docs/ops/configuration/mesh/webhook/&quot;&gt;https://istio.io/latest/docs/ops/configuration/mesh/webhook/&lt;/a&gt; &lt;a href=&quot;#fnref:7&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:8&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;CNI - the Container Network Interface cni &lt;a href=&quot;https://github.com/containernetworking/cni&quot;&gt;https://github.com/containernetworking/cni&lt;/a&gt; &lt;a href=&quot;#fnref:8&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:9&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;Container Network Interface Specification &lt;a href=&quot;https://github.com/containernetworking/cni/blob/master/SPEC.md&quot;&gt;https://github.com/containernetworking/cni/blob/master/SPEC.md&lt;/a&gt; &lt;a href=&quot;#fnref:9&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:10&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;Kubernetes Container Storage Interface (CSI) Documentation &lt;a href=&quot;https://kubernetes-csi.github.io/docs/#kubernetes-container-storage-interface-csi-documentation&quot;&gt;https://kubernetes-csi.github.io/docs/#kubernetes-container-storage-interface-csi-documentation&lt;/a&gt; &lt;a href=&quot;#fnref:10&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:11&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;Recommended Mechanism (for Developing and Deploying a CSI driver for Kubernetes) &lt;a href=&quot;https://kubernetes-csi.github.io/docs/#recommended-mechanism-for-developing-and-deploying-a-csi-driver-for-kubernetes&quot;&gt;https://kubernetes-csi.github.io/docs/#recommended-mechanism-for-developing-and-deploying-a-csi-driver-for-kubernetes&lt;/a&gt; &lt;a href=&quot;#fnref:11&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:12&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;RPC Interface · Container Storage Interface (CSI) &lt;a href=&quot;https://github.com/container-storage-interface/spec/blob/master/spec.md#rpc-interface&quot;&gt;https://github.com/container-storage-interface/spec/blob/master/spec.md#rpc-interface&lt;/a&gt; &lt;a href=&quot;#fnref:12&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:13&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;In-tree Storage Plugin to CSI Migration Design Doc &lt;a href=&quot;https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/csi-migration.md&quot;&gt;https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/csi-migration.md&lt;/a&gt; &lt;a href=&quot;#fnref:13&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:14&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;Container Runtime Interface (CRI) – a plugin interface which enables kubelet to use a wide variety of container runtimes. &lt;a href=&quot;https://github.com/kubernetes/cri-api/blob/master/pkg/apis/runtime/v1/api.proto&quot;&gt;https://github.com/kubernetes/cri-api/blob/master/pkg/apis/runtime/v1/api.proto&lt;/a&gt; &lt;a href=&quot;#fnref:14&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:15&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;Device Plugins &lt;a href=&quot;https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/&quot;&gt;https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/&lt;/a&gt; &lt;a href=&quot;#fnref:15&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:16&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;API Specification · Device Manager Proposal &lt;a href=&quot;https://github.com/kubernetes/community/blob/master/contributors/design-proposals/resource-management/device-plugin.md#api-specification&quot;&gt;https://github.com/kubernetes/community/blob/master/contributors/design-proposals/resource-management/device-plugin.md#api-specification&lt;/a&gt; &lt;a href=&quot;#fnref:16&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:17&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;k8s-device-plugin &lt;a href=&quot;https://github.com/NVIDIA/k8s-device-plugin&quot;&gt;https://github.com/NVIDIA/k8s-device-plugin&lt;/a&gt; &lt;a href=&quot;#fnref:17&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:18&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;Scheduling Framework &lt;a href=&quot;https://github.com/kubernetes/enhancements/tree/master/keps/sig-scheduling/624-scheduling-framework&quot;&gt;https://github.com/kubernetes/enhancements/tree/master/keps/sig-scheduling/624-scheduling-framework&lt;/a&gt; &lt;a href=&quot;#fnref:18&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:19&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;kubernetes/pkg/scheduler/framework/interface.go &lt;a href=&quot;https://github.com/kubernetes/kubernetes/blob/master/pkg/scheduler/framework/interface.go&quot;&gt;https://github.com/kubernetes/kubernetes/blob/master/pkg/scheduler/framework/interface.go&lt;/a&gt; &lt;a href=&quot;#fnref:19&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:20&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;Repository for out-of-tree scheduler plugins based on scheduler framework. &lt;a href=&quot;https://github.com/kubernetes-sigs/scheduler-plugins&quot;&gt;https://github.com/kubernetes-sigs/scheduler-plugins&lt;/a&gt; &lt;a href=&quot;#fnref:20&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;img src=&quot;https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png&quot; alt=&quot;wechat-account-qrcode&quot;/&gt;&lt;h3&gt;转载申请&lt;/h3&gt;&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by/4.0/&quot;&gt;&lt;img alt=&quot;知识共享许可协议&quot; src=&quot;https://img.draveness.me/creative-commons.png&quot;/&gt;&lt;/a&gt;&lt;p&gt;本作品采用&lt;/p&gt;&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by/4.0/&quot;&gt;知识共享署名 4.0 国际许可协议&lt;/a&gt;&lt;p&gt;进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。&lt;/p&gt;&lt;h3&gt;文章图片&lt;/h3&gt;&lt;p&gt;你可以在 &lt;/p&gt;&lt;a href=&quot;/sketch-and-sketch&quot;&gt;技术文章配图指南&lt;/a&gt;&lt;p&gt; 中找到画图的方法和素材。&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>