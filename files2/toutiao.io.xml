<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>d9cdbd1757227d485b5314f963f0b9de</guid>
<title>时间轮在 Kafka 的实践</title>
<link>https://toutiao.io/k/441cqn5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;562&quot; data-backw=&quot;562&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;562&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBG8fiaH5DpcXl4gX9dSJhFzF6ARFqaicYjickTxiaPM701eKEspL7tj7A4xonqVVkpDfA12KVmDDPE8icg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-darkmode-bgcolor-15906711670635=&quot;rgb(52, 52, 52)&quot; data-darkmode-original-bgcolor-15906711670635=&quot;rgb(239, 239, 239)&quot; data-style=&quot;padding: 10px; display: inline-block; width: 558px; border-width: 1px; border-style: solid; border-color: transparent; background-color: rgb(239, 239, 239); border-radius: 0px;&quot; class=&quot;js_darkmode__0&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; data-darkmode-bgcolor-15906711670635=&quot;rgb(52, 52, 52)&quot; data-darkmode-original-bgcolor-15906711670635=&quot;rgb(239, 239, 239)&quot;&gt;&lt;section data-darkmode-bgcolor-15906711670635=&quot;rgb(52, 52, 52)&quot; data-darkmode-original-bgcolor-15906711670635=&quot;rgb(239, 239, 239)&quot;&gt;&lt;p data-darkmode-bgcolor-15906711670635=&quot;rgb(52, 52, 52)&quot; data-darkmode-original-bgcolor-15906711670635=&quot;rgb(239, 239, 239)&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;桔妹导读：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;时间轮是一个应用场景很广的组件，在很多高性能中间件中都有它的身影，如Netty、Quartz、Akka，当然也包括Kafka，本文主要介绍时间轮在kafka的应用和实战，从核心源码和设计的角度对时间轮进行深入的讲解 。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;1. &lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;引子&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.0734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jE5bOw22iaBtFvdK9icOj3ibAXa8W3tqZ2lQDEaA5XcCDJ5cVIic2221PzXcw0oo69kvia8ojgPZnEV4jPxZURBln4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;562&quot; data-backh=&quot;41&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;从2个面试题说起，第一个问题：&lt;strong&gt;如果一台机器上有10w个定时任务，如何做到高效触发？&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;具体场景是：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;有一个APP实时消息通道系统，对每个用户会维护一个APP到服务器的TCP连接，用来实时收发消息，对这个TCP连接，有这样一个需求：“如果连续30s没有请求包（例如登录，消息，keepalive包），服务端就要将这个用户的状态置为离线”。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; 其中，单机TCP同时在线量约在10w级别，keepalive请求包较分散大概30s一次，吞吐量约在3000qps。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;怎么做？&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;常用方案使用time定时任务，每秒扫描一次所有连接的集合Map&amp;lt;uid, last_packet_time&amp;gt;，把连接时间（每次有新的请求更新对应连接的连接时间）比当前时间的差值大30s的连接找出来处理。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另一种方案，使用环形队列法：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;382&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.6606498194945848&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBG8fiaH5DpcXl4gX9dSJhFzFyHiaiaWIPMkRLgqmsN5VzQsHuYdCHiadPl2dunDHicSlewT7ma4pWBNJBQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1108&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;三个重要的数据结构：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;30s超时，就创建一个index从0到30的环形队列（本质是个数组）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;环上每一个slot是一个Set&amp;lt;uid&amp;gt;，任务集合&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;同时还有一个Map&amp;lt;uid, index&amp;gt;，记录uid落在环上的哪个slot里&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这样当有某用户uid有请求包到达时：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;从Map结构中，查找出这个uid存储在哪一个slot里&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;从这个slot的Set结构中，删除这个uid&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将uid重新加入到新的slot中，具体是哪一个slot呢 =&amp;gt; Current Index指针所指向的&lt;/span&gt;&lt;span&gt;上一个&lt;/span&gt;&lt;span&gt;slot，因为这个slot，会被timer在30s之后扫描到&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;更新Map，这个uid对应slot的index值&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;哪些元素会被超时掉呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Current Index每秒种移动一个slot，这个slot对应的Set&amp;lt;uid&amp;gt;中所有uid都应该被集体超时！如果最近30s有请求包来到，一定被放到Current Index的前一个slot了，Current Index所在的slot对应Set中所有元素，都是最近30s没有请求包来到的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，当没有超时时，Current Index扫到的每一个slot的Set中应该都没有元素。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;两种方案对比：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;方案一每次都要轮询所有数据，而方案二使用环形队列只需要轮询这一刻需要过期的数据，如果没有数据过期则没有数据要处理，并且是批量超时，并且由于是环形结构更加节约空间，这很适合高性能场景。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;第二个问题：&lt;strong&gt;在开发过程中有延迟一定时间的任务要执行，怎么做？&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果不重复造轮子的话，我们的选择当然是延迟队列或者Timer。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;延迟队列和在Timer中增 加延时任务采用数组表示的最小堆的数据结构实现，每次放入新元素和移除队首元素时间复杂度为O(nlog(n))。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;2. &lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;时间轮&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.0734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jE5bOw22iaBtFvdK9icOj3ibAXa8W3tqZ2lQDEaA5XcCDJ5cVIic2221PzXcw0oo69kvia8ojgPZnEV4jPxZURBln4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;562&quot; data-backh=&quot;41&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;方案二所采用的环形队列，就是时间轮的底层数据结构，它能够让需要处理的数据（任务的抽象）集中，在Kafka中存在大量的延迟操作，比如延迟生产、延迟拉取以及延迟删除等。Kafka并没有使用JDK自带的Timer或者DelayQueue来实现延迟的功能，而是基于时间轮自定义了一个用于实现延迟功能的定时器（SystemTimer）。JDK的Timer和DelayQueue插入和删除操作的平均时间复杂度为O(nlog(n))，并不能满足Kafka的高性能要求，而基于时间轮可以将插入和删除操作的时间复杂度都降为O(1)。时间轮的应用并非Kafka独有，其应用场景还有很多，在Netty、Akka、Quartz、Zookeeper等组件中都存在时间轮的踪影。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;▍&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;2.1 时间轮的数据结构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;参考下图，Kafka中的时间轮（TimingWheel）是一个存储定时任务的环形队列，底层采用数组实现，数组中的每个元素可以存放一个定时任务列表（TimerTaskList）。TimerTaskList是一个环形的双向链表，链表中的每一项表示的都是定时任务项（TimerTaskEntry），其中封装了真正的定时任务TimerTask。在Kafka源码中对这个TimeTaskList是用一个名称为buckets的数组表示的，所以后面介绍中可能TimerTaskList也会被称为bucket。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;312&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.54&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBG8fiaH5DpcXl4gX9dSJhFzFpdDDKO9Iib8RQIRQ3JMaZoqNfC7VDYJZTtUy2UOaXVFtDicNGsC0Btqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;span&gt;图二&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;针对上图的几个名词简单解释下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;tickMs：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;时间轮由多个时间格组成，每个时间格就是tickMs，它代表当前时间轮的基本时间跨度。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;wheelSize：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;代表每一层时间轮的格数&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;interval：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;当前时间轮的总体时间跨度，interval=tickMs × wheelSize&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;startMs：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;构造当层时间轮时候的当前时间，第一层的时间轮的startMs是TimeUnit.NANOSECONDS.toMillis(nanoseconds()),上层时间轮的startMs为下层时间轮的currentTime。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;currentTime：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;表示时间轮当前所处的时间，currentTime是tickMs的整数倍（通过currentTime=startMs - (startMs % tickMs来保正currentTime一定是tickMs的整数倍），这个运算类比钟表中分钟里65秒分钟指针指向的还是1分钟）。currentTime可以将整个时间轮划分为到期部分和未到期部分，currentTime当前指向的时间格也属于到期部分，表示刚好到期，需要处理此时间格所对应的TimerTaskList的所有任务。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;▍&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;2.2 时间轮中的任务存放&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;若时间轮的tickMs=1ms，wheelSize=20，那么可以计算得出interval为20ms。初始情况下表盘指针currentTime指向时间格0，此时有一个定时为2ms的任务插入进来会存放到时间格为2的TimerTaskList中。随着时间的不断推移，指针currentTime不断向前推进，过了2ms之后，当到达时间格2时，就需要将时间格2所对应的TimeTaskList中的任务做相应的到期操作。此时若又有一个定时为8ms的任务插入进来，则会存放到时间格10中，currentTime再过8ms后会指向时间格10。如果同时有一个定时为19ms的任务插入进来怎么办？新来的TimerTaskEntry会复用原来的TimerTaskList，所以它会插入到原本已经到期的时间格1中。总之，整个时间轮的总体跨度是不变的，随着指针currentTime的不断推进，当前时间轮所能处理的时间段也在不断后移，总体时间范围在currentTime和currentTime+interval之间。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;▍&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;2.3 时间轮的升降级&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果此时有个定时为350ms的任务该如何处理？直接扩充wheelSize的大小么？Kafka中不乏几万甚至几十万毫秒的定时任务，这个wheelSize的扩充没有底线，就算将所有的定时任务的到期时间都设定一个上限，比如100万毫秒，那么这个wheelSize为100万毫秒的时间轮不仅占用很大的内存空间，而且效率也会拉低。Kafka为此引入了层级时间轮的概念，当任务的到期时间超过了当前时间轮所表示的时间范围时，就会尝试添加到上层时间轮中。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;513&quot; data-backw=&quot;562&quot; data-ratio=&quot;0.9129332206255283&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBG8fiaH5DpcXl4gX9dSJhFzFXzdeg3QUgdoJ26RtYQpibFsFK0IXhico9xicPsZDvRnYcicqul57P0tP0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1183&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;图三&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;参考上图，复用之前的案例，第一层的时间轮tickMs=1ms, wheelSize=20, interval=20ms。第二层的时间轮的tickMs为第一层时间轮的interval，即为20ms。每一层时间轮的wheelSize是固定的，都是20，那么第二层的时间轮的总体时间跨度interval为400ms。以此类推，这个400ms也是第三层的tickMs的大小，第三层的时间轮的总体时间跨度为8000ms。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;刚才提到的350ms的任务，不会插入到第一层时间轮，会插入到interval=20*20的第二层时间轮中，具体插入到时间轮的哪个bucket呢？先用350/tickMs(20)=virtualId(17)，然后virtualId(17) %wheelSize (20) = 17，所以350会放在第17个bucket。如果此时有一个450ms后执行的任务，那么会放在第三层时间轮中，按照刚才的计算公式，会放在第0个bucket。第0个bucket里会包含&lt;/span&gt;&lt;span&gt;[400,800)ms&lt;/span&gt;&lt;span&gt;的任务。&lt;/span&gt;&lt;span&gt;随着时间流逝，当时间过去了400ms，那么450ms后就要执行的任务还剩下50ms的时间才能执行，此时有一个时间轮降级的操作，将50ms任务重新提交到层级时间轮中，那么此时50ms的任务根据公式会放入第二个时间轮的第2个bucket中，此bucket的时间范围为[40,60)ms，然后再经过40ms，这个50ms的任务又会被监控到，此时距离任务执行还有10ms，同样将10ms的任务提交到层级时间轮，此时会加入到第一层时间轮的第10个bucket，所以再经过10ms后，此任务到期，最终执行。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;整个时间轮的升级降级操作是不是很类似于我们的时钟？ 第一层时间轮tickMs=1s, wheelSize=60，interval=1min，此为秒钟；第二层tickMs=1min，wheelSize=60，interval=1hour，此为分钟；第三层tickMs=1hour，wheelSize为12，interval为12hours，此为时钟。而钟表的指针就对应程序中的currentTime，这个后面分析代码时候会讲到（对这个的理解也是时间轮理解的重点和难点）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;▍&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;2.4 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;任务添加和驱动时间轮滚动核心流程图&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;322&quot; data-backw=&quot;562&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;409&quot; data-ratio=&quot;0.5736994219653179&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBG8fiaH5DpcXl4gX9dSJhFzFeEWic4vjFkWp5Sng55EQSXoSZIIA9yIlKezQgWkiaT7bRuAHrNWq1J6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1384&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;图四&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;▍&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;2.5 重点代码介绍&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这是往SystenTimer中添加一个任务。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; def &lt;span class=&quot;code-snippet__title&quot;&gt;addTimerTaskEntry&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;timerTaskEntry: TimerTaskEntry&lt;/span&gt;): Unit&lt;/span&gt; = {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (!timingWheel.&lt;span class=&quot;code-snippet__keyword&quot;&gt;add&lt;/span&gt;(timerTaskEntry)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (!timerTaskEntry.cancelled)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      taskExecutor.submit(timerTaskEntry.timerTask)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;timingWheel添加任务，递归添加直到添加该任务进合适的时间轮的bucket中&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;def &lt;span class=&quot;code-snippet__title&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;timerTaskEntry: TimerTaskEntry&lt;/span&gt;): Boolean&lt;/span&gt; = {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  val expiration = timerTaskEntry.expirationMs&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (timerTaskEntry.cancelled) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (expiration &amp;lt; currentTime + tickMs) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (expiration &amp;lt; currentTime + interval) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    val virtualId = expiration / tickMs&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    val bucket = buckets((virtualId % wheelSize.toLong).toInt)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    bucket.&lt;span class=&quot;code-snippet__keyword&quot;&gt;add&lt;/span&gt;(timerTaskEntry)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (bucket.setExpiration(virtualId * tickMs)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      queue.offer(bucket)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (overflowWheel == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) addOverflowWheel()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    overflowWheel.&lt;span class=&quot;code-snippet__keyword&quot;&gt;add&lt;/span&gt;(timerTaskEntry)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在本层级时间轮里添加上一层时间轮里的过程，注意的是在下一层时间轮的interval为上一层时间轮的tickMs。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt;[&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;] &lt;span class=&quot;code-snippet__function&quot;&gt;def &lt;span class=&quot;code-snippet__title&quot;&gt;addOverflowWheel&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;: Unit &lt;/span&gt;= {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;synchronized&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (overflowWheel == &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      overflowWheel = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; TimingWheel(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        tickMs = interval,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        wheelSize = wheelSize,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        startMs = currentTime,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        taskCounter = taskCounter,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        queue&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      )&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;驱动时间轮滚动过程：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;注意这里会存在一个递归，一直驱动时间轮的指针滚动直到时间不足于驱动上层的时间轮滚动。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;def advanceClock(timeMs: &lt;span class=&quot;code-snippet__built_in&quot;&gt;Long&lt;/span&gt;): &lt;span class=&quot;code-snippet__built_in&quot;&gt;Unit&lt;/span&gt; = {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (timeMs &amp;gt;= currentTime + tickMs) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    currentTime = timeMs - (timeMs % tickMs)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (overflowWheel != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) overflowWheel.advanceClock(currentTime)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;驱动源：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt;[&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;] &lt;span class=&quot;code-snippet__keyword&quot;&gt;val&lt;/span&gt; reinsert = (timerTaskEntry: TimerTaskEntry) =&amp;gt; addTimerTaskEntry(timerTaskEntry)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;def advanceClock(timeoutMs: &lt;span class=&quot;code-snippet__built_in&quot;&gt;Long&lt;/span&gt;): &lt;span class=&quot;code-snippet__built_in&quot;&gt;Boolean&lt;/span&gt; = {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; bucket = delayQueue.poll(timeoutMs, TimeUnit.MILLISECONDS)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (bucket != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    writeLock.lock()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt; (bucket != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        timingWheel.advanceClock(bucket.getExpiration())&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        bucket.flush(reinsert)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        bucket = delayQueue.poll()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;finally&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      writeLock.unlock()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;3. &lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.0734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jE5bOw22iaBtFvdK9icOj3ibAXa8W3tqZ2lQDEaA5XcCDJ5cVIic2221PzXcw0oo69kvia8ojgPZnEV4jPxZURBln4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;562&quot; data-backh=&quot;41&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span data-shimo-docs=&quot;[[20,&amp;quot;通过以上工作，滴滴Presto逐渐接入公司各大数据平台，并成为了公司首选Ad-Hoc查询引擎及Hive SQL加速引擎，下图可以看到某产品接入后的性能提升：\n&amp;quot;]]&quot;&gt;&lt;span data-shimo-docs=&quot;[[20,&amp;quot;但是如果看最近一个月的CPU使用率会发现，平均CPU使用率比较低，且波峰在白天10~18点，晚上基本上没有查询，CPU使用率不到5%。如下图所示：&amp;quot;,&amp;quot;0:\&amp;quot;%23333333\&amp;quot;&amp;quot;]]&quot;&gt;kafka的延迟队列使用时间轮实现，能够支持大量任务的高效触发，但是在kafka延迟队列实现方案里还是看到了delayQueue的影子，使用delayQueue是对时间轮里面的bucket放入延迟队列，以此来推动时间轮滚动，但是基于将插入和删除操作则放入时间轮中，将这些操作的时间复杂度都降为O(1)，提升效率。Kafka对性能的极致追求让它把最合适的组件放在最适合的位置。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;本文作者&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;h3&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;▬&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/h3&gt;&lt;h3&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;106&quot; data-backw=&quot;562&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;106&quot; data-ratio=&quot;0.18946188340807174&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBG8fiaH5DpcXl4gX9dSJhFzFSfRy6bcPNkSCjLkT4a5KRa0Rh1n8icXoTBmxqDdEibibXiaK5vI6zfCliag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;892&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span data-shimo-docs=&quot;[[20,&amp;quot;通过以上工作，滴滴Presto逐渐接入公司各大数据平台，并成为了公司首选Ad-Hoc查询引擎及Hive SQL加速引擎，下图可以看到某产品接入后的性能提升：\n&amp;quot;]]&quot;&gt;&lt;span data-shimo-docs=&quot;[[20,&amp;quot;但是如果看最近一个月的CPU使用率会发现，平均CPU使用率比较低，且波峰在白天10~18点，晚上基本上没有查询，CPU使用率不到5%。如下图所示：&amp;quot;,&amp;quot;0:\&amp;quot;%23333333\&amp;quot;&amp;quot;]]&quot;&gt;&lt;span data-shimo-docs=&quot;[[20,&amp;quot;所以，解决晚上资源浪费问题是我们今后需要解决的难题。&amp;quot;,&amp;quot;0:\&amp;quot;%23333333\&amp;quot;&amp;quot;],[20,&amp;quot;\n同时，为了不与开源社区脱节，我们打算升级PrestoDB 0.215到PrestoSQL 340版本，届时会把我们的Presto on Druid代码开源出来，回馈社区。&amp;quot;]]&quot;&gt;滴滴车险团队架构师，负责车险核心系统的架构和设计，十年互联网研发架构经验，其中五年中间件与基础架构经验，对高并发，高可用以及分布式应用的架构设计有丰富的实战经验，尤其对分布式消息队列，分布式流程编排引擎、分布式数据库中间件有较深入的研究，热爱技术，崇尚开源，是Kafka、RocketMQ、Conductor等多个知名开源项目的源码贡献者。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/h3&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;团队招聘&lt;/strong&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;▬&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span data-shimo-docs=&quot;[[20,&amp;quot;对于低重要度的特征，最终做了删除，从而降低模型大小。例如我们发现方位角的重要度在实际模型训练中不如角变量。推测方位角本身的不连续性（0 = 2pi）可能对模型训练是一种干扰。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;对于异常值，做了基本的数据清洗，如无效的速度值，无效的方位角；对于不足的GPS序列长度，用0进行填充（但需要额外注意起点属性）等。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;3. 模型选择、训练与效果&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;DNN&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;：只需要相对简单的算法实现，引入较小的模型库。然而GPS轨迹数据具有典型的时间序列特征，在4万样本下，应用利用DNN模型调参优化后，训练结果准确率最高达到91%。Bad case中存在大量时间不敏感的情形，最典型的情形就是——轨迹由差转优时，判定结果未能及时转变为高质量。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;CNN&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;：这里可以尝试两种实现方式，一种是通过生成bitmap进行识别，然而GPS跨度不确定性较高，方向性不易表达，在实现上具有一定困难。第二种将序列化数据转化为二维数组，C模型能够识别出前后时间戳之间的变化特征，但并不能保留更长的时间的变化特征。最终训练出的准确率在93%左右。另外，CNN模型应用在移动端有一个明显的缺点，即模型尺寸一般较大。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;LSTM（&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;长短期记忆网络&amp;quot;],[20,&amp;quot;）&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;：一种特殊的RNN模型，相比前述模型对轨迹质量序列判定有明显优势。在轨迹质量由好转差，或由差转好的识别上具有非常高的灵敏度，使用128个unit能够达到97%的准确率。缺点是LSTM模型训练速度相对较慢，算法库实现相对复杂。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;最终我们选择了使用LSTM模型。使用LSTM的训练结果，准确率大幅提升。在剩余3%的错误样例中，很多轨迹在形态上表现出较高的真实性，但却无法同路网进行匹配。理论上通过引入路网属性能够上带来准确率的进一步提升，然而这种数据的耦合脱离了轨迹质量判定的初衷——服务于偏航引擎专家系统，而非直接用于偏航判定。对此我们将会在最后进行更详细的介绍。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3&amp;quot;],[20,&amp;quot;4. 移动端性能优化&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;模型推算性能对于移动端尤为重要。偏航场景下，GPS更新频繁，选择在必要的时候进行模型推算能够避免不必要的计算开销。通常我们会计算当前GPS点与规划路线的偏离度，只有偏离度大于阈值时才会进行轨迹质量判定。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;基于深度学习的专家系统探索&amp;quot;,&amp;quot;27:\&amp;quot;14\&amp;quot;|8:1&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:2&amp;quot;],[20,&amp;quot;轨迹质量模型作为偏航判定的重要依据，能够以较小的代价移植到移动端。如果不考虑前端性能及数据限制，我们完全可以定义整个偏航判定问题，训练相应的偏航模型。然而偏航场景种类繁多，过于复杂，训练出一套通用的偏航模型需要大量的数据，充足的路网信息，和较大的模型存储，这对于移动端而言不太现实。  &amp;quot;]]&quot;&gt;&lt;span&gt;滴滴车险团队基于滴滴近百万辆车和海量数据，通过线上化、科技化、数据化的手段，达到车险的降赔付、降发生，降保费，为乘客、司机、以及车队、合作伙伴提供方便快捷高效的车险金融服务。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span data-shimo-docs=&quot;[[20,&amp;quot;对于低重要度的特征，最终做了删除，从而降低模型大小。例如我们发现方位角的重要度在实际模型训练中不如角变量。推测方位角本身的不连续性（0 = 2pi）可能对模型训练是一种干扰。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;对于异常值，做了基本的数据清洗，如无效的速度值，无效的方位角；对于不足的GPS序列长度，用0进行填充（但需要额外注意起点属性）等。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;3. 模型选择、训练与效果&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;DNN&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;：只需要相对简单的算法实现，引入较小的模型库。然而GPS轨迹数据具有典型的时间序列特征，在4万样本下，应用利用DNN模型调参优化后，训练结果准确率最高达到91%。Bad case中存在大量时间不敏感的情形，最典型的情形就是——轨迹由差转优时，判定结果未能及时转变为高质量。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;CNN&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;：这里可以尝试两种实现方式，一种是通过生成bitmap进行识别，然而GPS跨度不确定性较高，方向性不易表达，在实现上具有一定困难。第二种将序列化数据转化为二维数组，C模型能够识别出前后时间戳之间的变化特征，但并不能保留更长的时间的变化特征。最终训练出的准确率在93%左右。另外，CNN模型应用在移动端有一个明显的缺点，即模型尺寸一般较大。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;LSTM（&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;长短期记忆网络&amp;quot;],[20,&amp;quot;）&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;：一种特殊的RNN模型，相比前述模型对轨迹质量序列判定有明显优势。在轨迹质量由好转差，或由差转好的识别上具有非常高的灵敏度，使用128个unit能够达到97%的准确率。缺点是LSTM模型训练速度相对较慢，算法库实现相对复杂。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;最终我们选择了使用LSTM模型。使用LSTM的训练结果，准确率大幅提升。在剩余3%的错误样例中，很多轨迹在形态上表现出较高的真实性，但却无法同路网进行匹配。理论上通过引入路网属性能够上带来准确率的进一步提升，然而这种数据的耦合脱离了轨迹质量判定的初衷——服务于偏航引擎专家系统，而非直接用于偏航判定。对此我们将会在最后进行更详细的介绍。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3&amp;quot;],[20,&amp;quot;4. 移动端性能优化&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;模型推算性能对于移动端尤为重要。偏航场景下，GPS更新频繁，选择在必要的时候进行模型推算能够避免不必要的计算开销。通常我们会计算当前GPS点与规划路线的偏离度，只有偏离度大于阈值时才会进行轨迹质量判定。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;基于深度学习的专家系统探索&amp;quot;,&amp;quot;27:\&amp;quot;14\&amp;quot;|8:1&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:2&amp;quot;],[20,&amp;quot;轨迹质量模型作为偏航判定的重要依据，能够以较小的代价移植到移动端。如果不考虑前端性能及数据限制，我们完全可以定义整个偏航判定问题，训练相应的偏航模型。然而偏航场景种类繁多，过于复杂，训练出一套通用的偏航模型需要大量的数据，充足的路网信息，和较大的模型存储，这对于移动端而言不太现实。  &amp;quot;]]&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;团队长期招聘&lt;span&gt;java高级工程师和技术专家，&lt;/span&gt;欢迎有兴趣的小伙伴加入，可投递简历至 diditech@didiglobal.com，邮件请邮件主题请命名为「姓名-应聘部门-应聘方向」。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;135&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;135&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBFBFcH3cDkw5qRpibVy97GUiaCUicPhRyTg6LpWp2CFHhKZSYuQnmhyZzBnnRxJ4EuWwvI3HTgqibQ7Mw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;256&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;扫码了解更多岗位&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;延伸阅读&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;▬&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1ODEzNjI2NA==&amp;amp;mid=2247512436&amp;amp;idx=1&amp;amp;sn=1fea750185b0ec4a5c5e000db7e773e1&amp;amp;chksm=fc29dfd3cb5e56c5e8d07d13a755a3434cfd61af38a161bfde4be7eaf28b56fda65644da6971&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;112&quot; data-backw=&quot;562&quot; data-ratio=&quot;0.2&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBG8fiaH5DpcXl4gX9dSJhFzFUvNyoeeVzZpUV1iao6ZywZNm1lvQfoWJiaYJF1rICaHKIACfRhLLoIeA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1ODEzNjI2NA==&amp;amp;mid=2247507588&amp;amp;idx=1&amp;amp;sn=a4cc88ed4a14007f5d39da9e7c0e6d02&amp;amp;chksm=fc29b023cb5e393522bc096473e6ff4a5b2045bb591dd62609a6cbae7a2727991c6d82d628e3&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;112&quot; data-backw=&quot;562&quot; data-ratio=&quot;0.2&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBHraEAV6GKpIj4dQOQNs9ggIppJ4Jhjb2ic2K75ZnPYjTCBicrmiaEgQtH17Ks8E8uk0QeojUDD9whibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/a&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1ODEzNjI2NA==&amp;amp;mid=2247493821&amp;amp;idx=1&amp;amp;sn=c3fa1e6733cf9f2b173793adeb0139b3&amp;amp;chksm=fc29861acb5e0f0c5bb5bf02d4e0cafc68cd19232643be1cb798a05bd4a60e65d8705281a0ac&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot; hasload=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.2&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBFPvfKQEIHKT8V3yZSGBZQtHgjI7CoApEqXV3uRhYFH383kdxwNSsfOUib2NViciaJeYHtJk1CvZdVGA/640?wx_fmt=png&quot; data-backw=&quot;562&quot; data-backh=&quot;112&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;内容编辑&lt;span&gt; | Charlotte&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;联系我们 | DiDiTech@didiglobal.com&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;pre ng-bind-html=&quot;message.MMActualContent&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;162&quot; data-backw=&quot;562&quot; data-ratio=&quot;0.28888888888888886&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBHCquJeOibVaFwqqC4iadSqFxSJRyP1G2V6ZB0tXzfDbHQmq5LXdiawGrVAfTs5INmjsvxOnH4dU8how/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/pre&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e7583dd9be89f5f5fba1fc84d1163778</guid>
<title>虚拟机系列：JVM 执行引擎和垃圾回收</title>
<link>https://toutiao.io/k/hvkhrg3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;h1&gt;&lt;span&gt;一、执行引擎&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;应用程序经过编译，转换为字节码文件，字节码加载到内存空间并不能直接在操作系统上执行，执行引擎作为Java虚拟机核心的组成部分，作用就是将字节码指令解释/编译为对应系统平台上的本地机器指令。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5483091787439613&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvArrrqwmibM8HOXIoQDsTfkF0HEywSdsRSgvDxV4diavy7YbsJQia0icz5zdKVn5gk8ABZz50g1DK9BWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;828&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;解释器&lt;/strong&gt;：虚拟机启动时会根据预定义对字节码采用逐行解释的方式执行，将每条字节码文件中的内容解释为对应系统平台的本地机器指令执行；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;JIT编译器&lt;/strong&gt;：虚拟机将源代码编译成本地机器平台相关的机器语言，并且寻找热点高频执行的代码将其放入元空间中，即元空间中存放的JIT缓存代码；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;垃圾回收&lt;/strong&gt;：对于没有任何引用的对象标记为垃圾，会被回收释放内存空间。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;二、垃圾对象标记&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、引用计数法&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;每个对象保存一个整型引用计数器，用来记录对象被引用的次数，当该对象被一个对象引用时，计数器加1，当失去一个引用时，计数器减1；引用计数算法就是通过判断对象的引用数量来决定对象是否可以被当做垃圾对象回收掉。&lt;/p&gt;&lt;p&gt;虽然引用计数法效率高，但是当两个对象互相引用时会导致这两个对象一直不会被回收，这是一个致命的缺陷。所以JVM并没有采用该标记算法。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2、可达性分析算法&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;可达性分析算法是基于对象到根对象的引用链是否可达来判断对象是否可以被回收；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5601503759398496&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvArrrqwmibM8HOXIoQDsTfkFoM8fjGPeOZlPOxKjaYVcGOr2Uey3NUmWfAicD5aWRn8B0rvjsib7vOSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1064&quot;/&gt;&lt;/p&gt;&lt;p&gt;运行程序把所有的引用关系链看作一张图，通过GC-Roots根对象对象集合作为起始点，从每个根节点向下不断搜索被根对象集合所连接的对象是否可达，搜索路径称为引用链（Reference-Chain），如果对象到GC-Roots没有任何引用链存在，则说明此对象是不可用的，&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;虚拟机栈中引用的对象；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;元空间中类静态属性引用的对象；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;元空间中常量引用的对象；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;本地方法栈中Native方法引用的对象；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;相对于引用计数法算法，可达性分析算法则避免了循环引用导致的问题，同样具备执行高效的特点，也是JVM采用的标记算法。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;三、垃圾回收机制&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、标记清除算法&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;标记-清除算法分为标记和清除两个阶段：&lt;/p&gt;&lt;p&gt;标记阶段：从根对象集合进行扫描，对存活的对象对象标记；清除阶段：再次扫描发现未被标记的对象并进行回收；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6045548654244306&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvArrrqwmibM8HOXIoQDsTfkFFpW6FtSSehTaneZfhZpzGw06aibXRkLft1D81v9yibDYf9sic5oZZNDQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;966&quot;/&gt;&lt;/p&gt;&lt;p&gt;该算法效率不高，进行垃圾回收需要暂停应用程序，同时会产生大量内存碎片，后续程序运行过程中分配内存占用较大的对象时，会有连续内存不够情况，容易触发再一次垃圾收集动作。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2、标记整理算法&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;标记整理算法的标记过程类似标记清除算法，第一阶段：标记出垃圾对象；第二阶段：让所有存活的对象都向内存区一端移动；第三阶段：直接清理掉边界端以外的内存，类似于磁盘整理的过程；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6024844720496895&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvArrrqwmibM8HOXIoQDsTfkFNDibrfWCXKSibSXq25VRUhGeOG3KJeynygI8AiaRn7vJZn7qfZnh8bZVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;966&quot;/&gt;&lt;/p&gt;&lt;p&gt;该垃圾回收算法效率不高，对象移动过程需要暂停应用程序，适用于对象存活率高的场景（老年代）。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;3、复制算法&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;复制算法将内存按容量划分为大小相等的两块，每次只使用其中的一块，当使用的这块的内存用完，就将还存活着的对象复制到另外一块空闲内存上，然后使用过的内存空间一次清理。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5762195121951219&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvArrrqwmibM8HOXIoQDsTfkFOSUplgql9BJicPM6eER4DpdcPB0UV5ZcAYSf7H3gdhHbhxEDlw0XkgA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;656&quot;/&gt;&lt;/p&gt;&lt;p&gt;该算法实现简单，运行效率高，但是内存空间严重浪费，适用于对象存活率低的场景，比如新生代。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;4、分代收集算法&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;当前市场上几乎所有的虚拟机都采用该回收算法，分代收集算法根据年轻代和老年代的各自特点采用不同的算法机制，不同内存区域中对象生命周期也不同，因此对堆内存不同区域采用不同的回收策略可以提高垃圾回收执行效率。通常情况新生代对象存活率低，回收频繁，就采用复制算法；老年代存对象生命周期长，活率高，就用标记清除算法或者标记整理算法。&lt;/p&gt;&lt;p&gt;Java堆内存一般可以分为新生代、老年代和永久代三个模块，如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5061728395061729&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvArrrqwmibM8HOXIoQDsTfkFDEOIGxVhjiccicDhYKEomRazWMb0KKkjynpPCW3ImzB3pBNx53dTUoeg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;972&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;新生代&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;通常情况下，新创建的对象实例首先都是放在新生代空间中，所以追求快速的回收掉垃圾对象，一般情况下，新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0，survivor1)区，对象实例大部分在Eden区中生成；&lt;/p&gt;&lt;p&gt;垃圾回收时先把eden区存活对象复制到S0区，然后清空eden区，当S0区也满时，再将eden区和S0区存活对象复制到S1区，然后清空eden和S0区，之后交换S0区和S1区的角色，当S1区无法存放eden区和S0区的存活对象时，就将存活对象直接存移到老年代区，当老年代区也满了，触发一次FullGC，即新生代、老年代都进行回收。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;老年代&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;老年代区存放一些生命周期较长的对象，对象实例在新生代中经历了多次垃圾回收仍然存活的对象，会被移动到老年代区中。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;四、源代码地址&lt;/span&gt;&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;GitHub·地址&lt;br/&gt;https:&lt;span&gt;//github.com/cicadasmile/java-base-parent&lt;/span&gt;&lt;br/&gt;GitEE·地址&lt;br/&gt;https:&lt;span&gt;//gitee.com/cicadasmile/java-base-parent&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3783359497645212&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvCjMheLZtcM2iaVMBOpIUKR4CDRCG9FLT5K6NmGXvG7exrW0TSuDjnTKJQ5PDq8j8Y7PHDd17Z3gicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1274&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f5b6343016d4488fbb09cb98c1146989</guid>
<title>图文结合，白话 Go 的垃圾回收原理</title>
<link>https://toutiao.io/k/51hfsz6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面两篇文章介绍了Go语言的&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&amp;amp;mid=2247485736&amp;amp;idx=1&amp;amp;sn=921a9dfe3d638074b68a4fd072ea3cb9&amp;amp;chksm=fa80d8bfcdf751a948ea49ee620ca9d88ff0a62b4ad4e3a53321fee6813b8f90098fd72f7b11&amp;amp;token=940952510&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;内存分配策略&lt;/a&gt;以及&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&amp;amp;mid=2247485886&amp;amp;idx=1&amp;amp;sn=f29fe2ce95a485e2c2ef1c4cd33b5085&amp;amp;chksm=fa80d829cdf7513fdf45b16be023809d9725b150803b6482643c3dd84aa3c0090c2cb9efd3aa&amp;amp;token=940952510&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Go协程动态扩充和收缩栈内存的原理&lt;/a&gt;，今天这篇文章我们主要来聊一下内存管理的另外一大块内容：垃圾回收。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面首先我们会聊一下什么是GC (垃圾回收)，GC的作用是什么，然后再结合图示用每个人都能听懂的大白话解释Go的GC原理。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是GC？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现代高级编程语言管理内存的方式分为两种：自动和手动，像C、C++ 等编程语言使用手动管理内存的方式，工程师编写代码过程中需要主动申请或者释放内存；而 PHP、Java 和 Go 等语言使用自动的内存管理系统，有内存分配器和垃圾收集器来代为分配和回收内存，其中垃圾收集器就是我们常说的GC。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;GC回收的是什么？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在应用程序中会使用到两种内存，分别为堆（Heap）和栈（Stack），GC负责回收堆内存，而不负责回收栈中的内存。那么这是为什么呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要原因是栈是一块专用内存，专门为了函数执行而准备的，存储着函数中的局部变量以及调用栈。除此以外，栈中的数据都有一个特点——简单。比如局部变量不能被函数外访问，所以这块内存用完就可以直接释放。正是因为这个特点，栈中的数据可以通过简单的编译器指令自动清理，并不需要通过 GC 来回收。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;GC算法的种类&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主流的垃圾回收算法有两大类，分别是追踪式垃圾回收算法和引用计数法（ Reference counting ）。而Go语言现在用的三色标记法就属于追踪式垃圾回收算法的一种。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;追踪式算法的核心思想是判断一个对象是否可达，一旦这个对象不可达就可以在垃圾回收的控制循环里被 GC 回收了。那么我们怎么判断一个对象是否可达呢？很简单，第一步找出所有的全局变量和当前函数栈里的变量，标记为可达。第二步，从已经标记的数据开始，进一步标记它们可访问的变量，以此类推。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Go的垃圾回收算法&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go的垃圾收集器从一开始到现在一直在演进，在v1.5版本开始三色标记法作为垃圾回收算法前使用&lt;strong&gt;Mark-And-Sweep&lt;/strong&gt;（标记清除）算法。从v1.5版本Go实现了基于&lt;strong&gt;三色标记清除的并发&lt;/strong&gt;垃圾收集器，大幅度降低垃圾收集的延迟从几百 ms 降低至 10ms 以下。在v1.8又使用&lt;strong&gt;混合写屏障&lt;/strong&gt;将垃圾收集的时间缩短至 0.5ms 以内。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;标记清除算法的缺点&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Mark-And-Sweep&lt;/strong&gt;，这个算法就是严格按照追踪式算法的思路来实现的。这个垃圾回收算法的执行流程可以用下面这张图来表示。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;2.031613976705491&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/z4pQ0O5h0f4Wt7WE18DVyFiaPG2C5Uyib3vZ40yEAiaviasqGLxEW1MwP6HwnZTSqeCibDZXL0pH527xtnEh9xOhujA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;601&quot;/&gt;&lt;figcaption&gt;垃圾回收--标记清除&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此算法主要有两个步骤：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;暂停应用程序的执行, 从根对象出发标记出可达对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;清除未标记的对象，恢复应用程序的执行。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个算法最大的问题是 GC 执行期间需要把整个程序完全暂停，不能异步地进行垃圾回收，对实时性要求高的系统来说，这种需要长时间挂起的标记清扫法是不可接受的。所以就需要一个算法来解决 GC 运行时程序长时间挂起的问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;三色标记清除法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从v1.5版本Go实现了基于&lt;strong&gt;三色标记清除的并发&lt;/strong&gt;垃圾收集器，注意&lt;strong&gt;三色标记&lt;/strong&gt;这个算法不是Go的垃圾收集器独有的。这个算法背后的核心思想是由Edsger W. Dijkstra，Leslie Lamport，A.J.Martin，C.S.Scholten和E.F.M.Steffens提出的，算法首先于1978年发表在论文&lt;span&gt;*On-the-fly Garbage Collection：An Exercise in Cooperation*&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;上面。三色标记清除算法背后的首要原则就是它把堆中的对象根据它们的颜色分到不同集合里面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;三色标记算法将程序中的对象分成白色、黑色和灰色三类：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;白色对象 — 潜在的垃圾，其内存可能会被垃圾收集器回收；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;黑色对象 — 活跃的对象，包括不存在任何引用外部指针的对象以及从根对象可达的对象，垃圾回收器不会扫描这些对象的子对象；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;灰色对象 — 活跃的对象，因为存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文字解释起来不太好理解，我用下面几张图演示一下三色标记清除的整个过程：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第一步：在进入GC的三色标记阶段的一开始，所有对象都是白色的。&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5910878112712975&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f4Wt7WE18DVyFiaPG2C5Uyib3Nzw2JVKp2Yb0ic2TiaqGBzicxhEYIGndsIYlvlCiakQFibTIMwckKy7FibVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1526&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第二步, 遍历根节点集合里的所有根对象，把根对象引用的对象标记为灰色，从白色集合放入灰色集合。&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5947712418300654&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f4Wt7WE18DVyFiaPG2C5Uyib3dA0l02vibL9iau9ibUzibN2LxKfL75PF4neicrGvzzfE3CXR4xHxxqVbiakQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1530&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第三步, 遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合&lt;/strong&gt;&lt;img data-ratio=&quot;0.5973856209150327&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f4Wt7WE18DVyFiaPG2C5Uyib3V0Nh0p9q4rTqic66muZfnVb0bVbYaiasU5qgovyK4x59F5aFjJOcKd2g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1530&quot;/&gt;&lt;strong&gt;第四步：重复第三步, 直到灰色集合中无任何对象。&lt;/strong&gt;&lt;img data-ratio=&quot;0.609375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f4Wt7WE18DVyFiaPG2C5Uyib3icre2fEw3yVtOiaX1fo1foqeOg1e7QRXMia5tcAY7GJWu9fnu4Fq1Jhww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1536&quot;/&gt;&lt;strong&gt;第五步：回收白色集合里的所有对象，本次垃圾回收结束。&lt;/strong&gt;&lt;img data-ratio=&quot;0.594488188976378&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f4Wt7WE18DVyFiaPG2C5Uyib3CeBkJth5gYBK4YWWG3wrickbVQpHV1nwXqiadZqBL5uibk3bY8YqaubVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1524&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里所说的根节点集合里的根对象就是栈上的对象或者堆上的全局变量。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;写屏障&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Go&lt;/code&gt; 在GC阶段执行三色标记前，还需要先做一个准备工作——打开写屏障(Write Barrier)。那么写屏障是什么呢？我们知道三色标记法是一种可以并发执行的算法。所以在GC运行过程中程序的函数栈内可能会有新分配的对象，那么这些对象该怎么通知到 GC，怎么给他们着色呢？如果还是按照之前新建的对象标记为白色就有可能出现下图中的问题：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5846774193548387&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f4Wt7WE18DVyFiaPG2C5Uyib3DvWGYAkN0xonqzEpthFIo0HkqLCDpR1zb7XEOjwttcUogAu4icoia9xw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1488&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在GC进行的过程中，应用程序新建了对象&lt;code&gt;I&lt;/code&gt;，此时如果已经标记成黑的对象&lt;code&gt;F&lt;/code&gt;引用了对象&lt;code&gt;I&lt;/code&gt;，那么在本次GC执行过程中因为黑色对象不会再次扫描，所以如果&lt;code&gt;I&lt;/code&gt;着色成白色的话，会被回收掉，这显然是不允许的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个时候就需要我们的&lt;strong&gt;写屏障&lt;/strong&gt;出马了。&lt;strong&gt;写屏障&lt;/strong&gt;主要做一件事情，修改原先的写逻辑，然后在对象新增的同时给它着色，并且着色为灰色。因此打开了写屏障可以保证了三色标记法在并发下安全正确地运行。&lt;span&gt;那么有人就会问这些写屏障标记成灰色的对象什么时候回收呢？&lt;/span&gt;&lt;span&gt;答案是后&lt;/span&gt;&lt;span&gt;续的GC过程中回收，在新的GC过程中所有已存对象就又从白色开始逐步被标记啦。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;三色不变性&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想要在并发或者增量的标记算法中保证正确性，我们需要达成以下两种三色不变性（Tri-color invariant）中的任意一种：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;强三色不变性 — 黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;弱三色不变性 — 黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;屏障技术&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;垃圾收集中的屏障技术更像是一个钩子方法，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，根据操作类型的不同，我们可以将它们分成读屏障（Read barrier）和写屏障（Write barrier）两种，因为读屏障需要在读操作中加入代码片段，对用户程序的性能影响很大，所以编程语言往往都会采用写屏障保证三色不变性。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Go的混合写屏障&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;Go&lt;/code&gt; 语言 v1.7 版本之前，使用的是&lt;code&gt;Dijkstra&lt;/code&gt;插入写屏障保证强三色不变性，但是运行时并没有在所有的垃圾收集根对象上开启插入写屏障。因为 Go 语言的应用程序可能包含成百上千的 goroutine，而垃圾收集的根对象一般包括全局变量和栈对象，如果运行时需要在几百个 goroutine 的栈上都开启写屏障，会带来巨大的额外开销，所以 Go 团队在实现上选择了在标记阶段完成时&lt;strong&gt;暂停程序、将所有栈对象标记为灰色并重新扫描&lt;/strong&gt;，在活跃 goroutine 非常多的程序中，重新扫描的过程需要占用 10 ~ 100ms 的时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 语言在 v1.8 组合 Dijkstra 插入写屏障和 Yuasa 删除写屏障构成了如下所示的混合写屏障，该写屏障会&lt;strong&gt;将被覆盖的对象标记成灰色并在当前栈没有扫描时将新对象也标记成灰色&lt;/strong&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;writePointer(slot, ptr):&lt;br/&gt;    shade(*slot)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; current stack is grey:&lt;br/&gt;        shade(ptr)&lt;br/&gt;    *slot = ptr&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了移除栈的重扫描过程，除了引入混合写屏障之外，在垃圾收集的标记阶段，我们还需要&lt;strong&gt;将创建的所有新对象都标记成黑色&lt;/strong&gt;，防止新分配的栈内存和堆内存中的对象被错误地回收，因为栈内存在标记阶段最终都会变为黑色，所以不再需要重新扫描栈空间。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一次完整的GC过程&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go的垃圾回收器在使用了三色标记清除算法和混合写屏障后大大减少了暂停程序（STW）的时间，主要是在开启写屏障前和移除写屏障前暂停应用程序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go的垃圾收集的整个过程可以分成标记准备、标记、标记终止和清除四个不同阶段，每个阶段完成的工作如下：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;标记准备阶段&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;暂停程序&lt;/strong&gt;，所有的处理器在这时会进入安全点（Safe point）；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;标记阶段&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;将状态切换至 &lt;code&gt;_GCmark&lt;/code&gt;、开启写屏障、用户程序协助（Mutator Assiste）并将根对象入队；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;恢复执行程序，&lt;strong&gt;标记进程和用于协助的用户程序会开始并发标记内存中的对象&lt;/strong&gt;，标记用的算法就是上面介绍的三色标记清除法。&lt;strong&gt;写屏障会将被覆盖的指针和新指针都标记成灰色，而所有新创建的对象都会被直接标记成黑色&lt;/strong&gt;；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;开始扫描根对象，包括所有 goroutine 的栈、全局对象以及不在堆中的运行时数据结构，扫描 goroutine 栈期间会暂停当前处理器；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;依次处理灰色队列中的对象，将对象标记成黑色并将它们指向的对象标记成灰色；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;使用分布式的终止算法检查剩余的工作，发现标记阶段完成后进入标记终止阶段；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在标记开始的时候，收集器会默认抢占 25% 的 CPU 性能，剩下的75%会分配给程序执行。但是一旦收集器认为来不及进行标记任务了，就会改变这个 25% 的性能分配。这个时候收集器会抢占程序额外的 CPU，这部分被抢占 goroutine 有个名字叫 Mark Assist。而且因为抢占 CPU的目的主要是 GC 来不及标记新增的内存，那么抢占正在分配内存的 goroutine 效果会更加好，所以分配内存速度越快的 goroutine 就会被抢占越多的资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此以外 GC 还有一个额外的优化，一旦某次 GC 中用到了 Mark Assist，下次 GC 就会提前开始，目的是尽量减少 Mark Assist 的使用，从而避免影响正常的程序执行。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;标记终止阶段&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;暂停程序&lt;/strong&gt;、将状态切换至 &lt;code&gt;_GCmarktermination&lt;/code&gt; 并关闭辅助标记的用户程序；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;清理处理器上的线程缓存；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;清理阶段&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;将状态切换至 &lt;code&gt;_GCoff&lt;/code&gt; 开始清理阶段，初始化清理状态并关闭写屏障；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;恢复用户程序，所有新创建的对象会标记成白色；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;后台并发清理所有的内存管理单元，当 goroutine 申请新的内存管理单元时就会触发清理；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;清理这个过程是并发进行的。清扫的开销会增加到分配堆内存的过程中，所以这个时间也是无感知的，不会与垃圾回收的延迟相关联。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go语言的垃圾收集的实现非常复杂，难懂的技术概念和原理也比较多，这篇文章意在用每个人都能看懂的白话文字结合图示把Go的垃圾回收原理解释清楚，让读者能对垃圾回收的大体流程有个概念。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面用一句话总结概况Go的垃圾回收原理：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Go的GC最早期使用的回收算法是&lt;strong&gt;标记-清除&lt;/strong&gt;算法，该算法需要在执行期间需要暂停应用程序(STW)，无法满足并发程序的实时性。后面Go的GC转为使用三色标记清除算法，并通过混合写屏障技术保证了Go并发执行GC时内存中对象的三色一致性（&lt;strong&gt;这里的并发指的是GC和应用程序的goroutine能同时执行&lt;/strong&gt;）。&lt;/p&gt;&lt;p&gt;一次完整的垃圾回收会分为四个阶段，分别是标记准备、标记、结束标记以及清理。在标记准备和标记结束阶段会需要 STW，标记阶段会减少程序的性能，而清理阶段是不会对程序有影响的。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这句话有点长，哈哈哈。看了今天的文章你对Go的垃圾回收有大体的理解了吗？能用自己的话总结一下吗？欢迎把自己的总结发在留言里，也欢迎把文章分享给朋友阅读。关注公众号「网管叨bi叨」，获取我整理的所有关于Go语言的技术文章。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;垃圾收集器&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Go 垃圾回收——三色标记法&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;&lt;span&gt;On-the-fly Garbage Collection：An Exercise in Cooperation&lt;/span&gt;: &lt;span&gt;https://www.microsoft.com/en-us/research/publication/fly-garbage-collection-exercise-cooperation/&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;垃圾收集器: &lt;span&gt;https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;Go 垃圾回收——三色标记法: &lt;span&gt;https://zhuanlan.zhihu.com/p/105495961&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1c1b46c537261473cd39d096100a2f0d</guid>
<title>浅谈 MySQL 并发控制：隔离级别、锁与 MVCC</title>
<link>https://toutiao.io/k/y63nj77</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;如果数据库中的事务都是串行执行的，这种方式可以保障事务的执行不会出现异常和错误，但带来的问题是串行执行会带来性能瓶颈；而事务并发执行，如果不加以控制则会引发诸多问题，包括死锁、更新丢失等等。这就需要我们在性能和安全之间做出合理的权衡，使用适当的并发控制机制保障并发事务的执行。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;并发事务带来的问题&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;首先我们先来了解一下并发事务会带来哪些问题。并发事务访问相同记录大致可归纳为以下3种情况：&lt;/p&gt;&lt;h5&gt;&lt;span&gt;读-读&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;因为读取记录并不会对记录造成任何影响，所以同个事务并发读取同一记录也就不存在任何安全问题，所以允许这种操作。&lt;/p&gt;&lt;h5&gt;&lt;span&gt;写-写&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;如果允许并发事务都读取同一记录，并相继基于旧值对这一记录做出修改，那么就会出现前一个事务所做的修改被后面事务的修改覆盖，即出现&lt;strong&gt;提交覆盖&lt;/strong&gt;的问题。&lt;/p&gt;&lt;p&gt;另外一种情况，并发事务相继对同一记录做出修改，其中一个事务提交之后之后另一个事务发生回滚，这样就会出现已提交的修改因为回滚而丢失的问题，即&lt;strong&gt;回滚覆盖&lt;/strong&gt;问题。&lt;/p&gt;&lt;p&gt;这两种问题都造成丢失更新，其中回滚覆盖称为&lt;strong&gt;第一类丢失更新&lt;/strong&gt;问题，提交覆盖称为&lt;strong&gt;第二类丢失更新&lt;/strong&gt;问题。&lt;/p&gt;&lt;h5&gt;&lt;span&gt;&lt;strong&gt;写-读&lt;/strong&gt;或&lt;strong&gt;读-写&lt;/strong&gt;&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;这种情况较为复杂，也最容易出现问题。&lt;/p&gt;&lt;p&gt;如果一个事务读取了另一个事务尚未提交的修改记录，那么就出现了&lt;strong&gt;脏读&lt;/strong&gt;的问题；&lt;/p&gt;&lt;p&gt;如果我们加以控制使得一个事务只能读取其他已提交事务的修改的数据，那么这个事务在另一事务提交修改前后读取到的数据是不一样的，这就意味着发生了&lt;strong&gt;不可重复读&lt;/strong&gt;；&lt;/p&gt;&lt;p&gt;如果一个事务根据一些条件查询到一些记录，之后另一事务向表中插入了一些记录，原先的事务以相同条件再次查询时发现得到的结果跟第一次查询得到的结果不一致，这就意味着发生了&lt;strong&gt;幻读&lt;/strong&gt;。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;事务的隔离级别&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;对于以上提到的并发事务执行过程中可能出现的问题，其严重性也是不一样的，我们可以按照问题的严重程度排个序：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;丢失更新 &amp;gt; 脏读 &amp;gt; 不可重复读 &amp;gt; 幻读&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因此如果我们可以容忍一些严重程度较轻的问题，我们就能获取一些性能上的提升。于是便有了事务的四种隔离级别：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;读未提交（&lt;code&gt;Read Uncommitted&lt;/code&gt;）：允许读取未提交的记录，会发生脏读、不可重复读、幻读；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;读已提交（&lt;code&gt;Read Committed&lt;/code&gt;）：只允许读物已提交的记录，不会发生脏读，但会出现重复读、幻读；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;可重复读（&lt;code&gt;Repeatable Read&lt;/code&gt;）：不会发生脏读和不可重复读的问题，但会发生幻读问题；但&lt;code&gt;MySQL&lt;/code&gt;在此隔离级别下利用&lt;strong&gt;MVCC&lt;/strong&gt;或者&lt;strong&gt;间隙锁&lt;/strong&gt;可以禁止幻读问题的发生；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;可串行化（&lt;code&gt;Serializable&lt;/code&gt;）：即事务串行执行，以上各种问题自然也就都不会发生。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;值得注意的是以上四种隔离级别都不会出现回滚覆盖的问题，但是提交覆盖的问题对于&lt;code&gt;MySQL&lt;/code&gt;来说，在&lt;code&gt;Read Uncommitted&lt;/code&gt;、&lt;code&gt;Read Committed&lt;/code&gt;以及&lt;code&gt;Repeatable Read&lt;/code&gt;这三种隔离级别下都会发生（标准的&lt;code&gt;Repeatable Read&lt;/code&gt;隔离级别不允许出现提交覆盖的问题），需要额外加锁来避免此问题。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;隔离级别的实现&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;SQL&lt;/code&gt;规范定义了以上四种隔离级别，但是并没有给出如何实现四种隔离级别，因此不同数据库的实现方式和使用方式也并不相同。而&lt;code&gt;SQL&lt;/code&gt;隔离级别的标准是依据基于锁的实现方式来制定的，因为有必要先了解一下传统的基于锁的隔离级别是如何实现的。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;传统隔离级别的实现&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;既然说到传统的隔离级别是基于锁实现的，我们先来了解一下锁。&lt;/p&gt;&lt;h5&gt;&lt;span&gt;锁&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;传统的锁有两种：&lt;/p&gt;&lt;p&gt;需要注意的是，加了共享锁的记录，其他事务也可以获得该记录的共享锁，但是无法获取该记录的排他锁，即&lt;code&gt;S锁&lt;/code&gt;和&lt;code&gt;S锁&lt;/code&gt;是兼容的，&lt;code&gt;S锁&lt;/code&gt;和&lt;code&gt;X锁&lt;/code&gt;是不兼容的；而加了排他锁的记录，其他事务既无法获取该记录的共享锁也无法获取排他锁，即&lt;code&gt;X锁&lt;/code&gt;和&lt;code&gt;X锁&lt;/code&gt;也是不兼容的。&lt;/p&gt;&lt;p&gt;另外，刚刚说到事务对一条记录进行读操作时，需要先获取该记录的&lt;code&gt;S锁&lt;/code&gt;，但有时事务在读取记录时需要阻止其他事务访问该记录，这时就需要获取该记录的&lt;code&gt;X锁&lt;/code&gt;。以&lt;code&gt;MySQL&lt;/code&gt;为例，有以下两种锁定读的方式：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;SELECT&lt;/span&gt; ... &lt;span&gt;LOCK&lt;/span&gt; &lt;span&gt;IN&lt;/span&gt; &lt;span&gt;SHARE&lt;/span&gt; &lt;span&gt;MODE&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果事务执行了该语句，则会在读取的记录上加&lt;code&gt;S锁&lt;/code&gt;，这样就允许其他事务也能获取到该记录的&lt;code&gt;S锁&lt;/code&gt;；而如果其他事务需要获取该记录的&lt;code&gt;X锁&lt;/code&gt;，那么就需要等待当前事务提交后释放掉&lt;code&gt;S锁&lt;/code&gt;。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;SELECT&lt;/span&gt; ... &lt;span&gt;FOR&lt;/span&gt; &lt;span&gt;UPDATE&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果事务执行了该语句，则会在读取的记录上加&lt;code&gt;X锁&lt;/code&gt;，这样其他事务想要获取该记录的&lt;code&gt;S锁&lt;/code&gt;或&lt;code&gt;X锁&lt;/code&gt;，那么需要等待当前事务提交后释放掉&lt;code&gt;X锁&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;对于锁的粒度而言，锁又可以分为两种：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;行锁：只锁住某一行记录，其他行的记录不受影响。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;表锁：锁住整个表，所有对于该表的操作都会受影响。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5&gt;&lt;span&gt;基于锁实现隔离级别&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;在基于锁的实现方式下，四种隔离级别的区别就在于加锁方式的区别：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;读未提交&lt;/strong&gt;：读操作不加锁，读读，读写，写读并行；写操作加&lt;code&gt;X锁&lt;/code&gt;且直到事务提交后才释放。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;读已提交&lt;/strong&gt;：读操作加&lt;code&gt;S锁&lt;/code&gt;，写操作加&lt;code&gt;X锁&lt;/code&gt;且直到事务提交后才释放；读操作不会阻塞其他事务读或写，写操作会阻塞其他事务写和读，因此可以防止脏读问题。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;可重复读&lt;/strong&gt;：读操作加&lt;code&gt;S锁&lt;/code&gt;且直到事务提交后才释放，写操作加&lt;code&gt;X锁&lt;/code&gt;且直到事务提交后才释放；读操作不会阻塞其他事务读但会阻塞其他事务写，写操作会阻塞其他事务读和写，因此可以防止脏读、不可重复读。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;串行化&lt;/strong&gt;：读操作和写操作都加&lt;code&gt;X锁&lt;/code&gt;且直到事务提交后才释放，粒度为表锁，也就是严格串行。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这里面有一些细节值得注意：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;如果锁获取之后直到事务提交后才释放，这种锁称为&lt;strong&gt;长锁&lt;/strong&gt;；如果锁在操作完成之后就被释放，这种锁称为&lt;strong&gt;短锁&lt;/strong&gt;。例如，在读已提交隔离级别下，读操作所加&lt;code&gt;S锁&lt;/code&gt;为短锁，写操作所加&lt;code&gt;X锁&lt;/code&gt;为长锁。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;对于可重复读和串行化隔离级别，读操作所加&lt;code&gt;S锁&lt;/code&gt;和写操作所加&lt;code&gt;X锁&lt;/code&gt;均为长锁，即事务获取锁之后直到事务提交后才能释放，这种把获取锁和释放锁分为两个不同的阶段的协议称为&lt;strong&gt;两阶段锁&lt;/strong&gt;协议（&lt;code&gt;2-phase locking&lt;/code&gt;）。两阶段锁协议规定在加锁阶段，一个事务可以获得锁但是不能释放锁；而在解锁阶段事务只可以释放锁，并不能获得新的锁。两阶段锁协议能够保证事务串行化执行，解决事务并发问题，但也会导致死锁发生的概率大大提升。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;&lt;span&gt;MySQL隔离级别的实现&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;不同数据库对于&lt;code&gt;SQL&lt;/code&gt;标准中规定的隔离级别支持是不一样的，数据库引擎实现隔离级别的方式虽然都在尽可能地贴近标准的隔离级别规范，但和标准的预期还是有些不一样的地方。&lt;/p&gt;&lt;p&gt;&lt;code&gt;MySQL&lt;/code&gt;（&lt;code&gt;InnoDB&lt;/code&gt;）支持的4种隔离级别，与标准的各级隔离级别允许出现的问题有些出入，比如&lt;code&gt;MySQL&lt;/code&gt;在可重复读隔离级别下可以防止幻读的问题出现，但也会出现提交覆盖的问题。&lt;/p&gt;&lt;p&gt;相对于传统隔离级别基于锁的实现方式，&lt;code&gt;MySQL&lt;/code&gt; 是通过&lt;code&gt;MVCC&lt;/code&gt;（多版本并发控制）来实现读-写并发控制，又是通过两阶段锁来实现写-写并发控制的。&lt;code&gt;MVCC&lt;/code&gt;是一种无锁方案，用以解决事务&lt;strong&gt;读-写&lt;/strong&gt;并发的问题，能够极大提升&lt;strong&gt;读-写&lt;/strong&gt;并发操作的性能。&lt;/p&gt;&lt;h5&gt;&lt;span&gt;MVCC的实现原理&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;为了方便描述，首先我们创建一个表&lt;code&gt;book&lt;/code&gt;，就三个字段，分别是主键&lt;code&gt;book_id&lt;/code&gt;, 名称&lt;code&gt;book_name&lt;/code&gt;, 库存&lt;code&gt;stock&lt;/code&gt;。然后向表中插入一些数据：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; book &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&#x27;数据结构&#x27;&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; book &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;&#x27;C++指南&#x27;&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; book &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;&#x27;精通Java&#x27;&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h6&gt;&lt;span&gt;版本链&lt;/span&gt;&lt;/h6&gt;&lt;p&gt;对于使用&lt;code&gt;InnoDB&lt;/code&gt;存储引擎的表，其聚簇索引记录中包含了两个重要的隐藏列：&lt;/p&gt;&lt;p&gt;如果在一个事务中多次对记录进行修改，则每次修改都会生成&lt;code&gt;undo&lt;/code&gt;日志，并且这些&lt;code&gt;undo&lt;/code&gt;日志通过&lt;code&gt;DB_ROLL_PTR&lt;/code&gt;指针串联成一个版本链，版本链的头结点是该记录最新的值，尾结点是事务开始时的初始值。&lt;/p&gt;&lt;p&gt;例如，我们在表&lt;code&gt;book&lt;/code&gt;中做以下修改：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;BEGIN&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;UPDATE&lt;/span&gt; book &lt;span&gt;SET&lt;/span&gt; stock = &lt;span&gt;200&lt;/span&gt; &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;UPDATE&lt;/span&gt; book &lt;span&gt;SET&lt;/span&gt; stock = &lt;span&gt;300&lt;/span&gt; &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那么&lt;code&gt;id=1&lt;/code&gt;的记录此时的版本链就如下图所示：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4383561643835616&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/r8E7jgUqWLABp0Re143hguzibQBM57GuYtAlzCDFxLnoZ812xQ2xUpibS68ez6St6ZR7vpibIlKCIwJIOU5ur4gtQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2044&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;h6&gt;&lt;span&gt;ReadView&lt;/span&gt;&lt;/h6&gt;&lt;p&gt;对于使用&lt;code&gt;Read Uncommitted&lt;/code&gt;隔离级别的事务来说，只需要读取版本链上最新版本的记录即可；对于使用&lt;code&gt;Serializable&lt;/code&gt;隔离级别的事务来说，&lt;code&gt;InnoDB&lt;/code&gt;使用加锁的方式来访问记录。而&lt;code&gt;Read Committed&lt;/code&gt;和&lt;code&gt;Repeatable Read&lt;/code&gt;隔离级别来说，都需要读取已经提交的事务所修改的记录，也就是说如果版本链中某个版本的修改没有提交，那么该版本的记录时不能被读取的。所以需要确定在&lt;code&gt;Read Committed&lt;/code&gt;和&lt;code&gt;Repeatable Read&lt;/code&gt;隔离级别下，版本链中哪个版本是能被当前事务读取的。于是&lt;code&gt;ReadView&lt;/code&gt;的概念被提出以解决这个问题。&lt;/p&gt;&lt;p&gt;&lt;code&gt;ReadView&lt;/code&gt;相当于某个时刻表记录的一个快照，在这个快照中我们能获取到与当前记录相关的事务中，哪些事务是已提交的&lt;strong&gt;稳定事务&lt;/strong&gt;，哪些是&lt;strong&gt;正在活跃的事务&lt;/strong&gt;，哪些是&lt;strong&gt;生成快照之后才开启的事务&lt;/strong&gt;。由此我们就能根据&lt;strong&gt;可见性比较算法&lt;/strong&gt;判断出版本链中能被读取的最新版本记录。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;可见性比较算法&lt;/strong&gt;是基于事务ID的比较算法。首先我们需要知道的一个事实是：事务&lt;code&gt;id&lt;/code&gt;是递增分配的。从&lt;code&gt;ReadView&lt;/code&gt;中我们能获取到生成快照时刻系统中活跃的事务中最小和最大的事务&lt;code&gt;id&lt;/code&gt;（最大的事务&lt;code&gt;id&lt;/code&gt;实际上是系统中将要分配给下一个事务的&lt;code&gt;id&lt;/code&gt;值），这样我们就得到了一个活跃事务&lt;code&gt;id&lt;/code&gt;的范围，我们可称之为&lt;code&gt;ACTIVE_TRX_ID_RANGE&lt;/code&gt;。那么小于这个范围的事务id对应的事务都是已提交的稳定事务，大于这个范围的事务都是在快照生成之后才开启的事务，而在&lt;code&gt;ACTIVE_TRX_ID_RANGE&lt;/code&gt;范围内的事务中除了正在活跃的事务，也都是已提交的稳定事务。&lt;/p&gt;&lt;p&gt;有了以上信息之后，我们顺着版本链从头结点开始查找最新的可被读取的版本记录：&lt;/p&gt;&lt;p&gt;1、首先判断版本记录的&lt;code&gt;DB_TRX_ID&lt;/code&gt;字段与生成&lt;code&gt;ReadView&lt;/code&gt;的事务对应的事务ID是否相等。如果相等，那就说明该版本的记录是在当前事务中生成的，自然也就能够被当前事务读取；否则进行第2步。&lt;/p&gt;&lt;p&gt;2、如果版本记录的&lt;code&gt;DB_TRX_ID&lt;/code&gt;字段小于范围&lt;code&gt;ACTIVE_TRX_ID_RANGE&lt;/code&gt;，表明该版本记录是已提交事务修改的记录，即对当前事务可见；否则进行下一步。&lt;/p&gt;&lt;p&gt;3、如果版本记录的&lt;code&gt;DB_TRX_ID&lt;/code&gt;字段位于范围&lt;code&gt;ACTIVE_TRX_ID_RANGE&lt;/code&gt;内，如果该事务ID对应的不是活跃事务，表明该版本记录是已提交事务修改的记录，即对当前事务可见；如果该事务ID对应的是活跃事务，那么对当前事务不可见，则读取版本链中下一个版本记录，重复以上步骤，直到找到对当前事务可见的版本。&lt;/p&gt;&lt;p&gt;如果某个版本记录经过以上步骤判断确定其对当前事务可见，则查询结果返回此版本记录；否则读取下一个版本记录继续按照上述步骤进行判断，直到版本链的尾结点。如果遍历完版本链没有找到对当前事务可见的版本，则查询结果为空。&lt;/p&gt;&lt;p&gt;在&lt;code&gt;MySQL&lt;/code&gt;中，&lt;code&gt;Read Committed&lt;/code&gt;和&lt;code&gt;Repeatable Read&lt;/code&gt;隔离级别下的区别就是它们生成&lt;code&gt;ReadView&lt;/code&gt;的时机不同。&lt;/p&gt;&lt;h5&gt;&lt;span&gt;MVCC实现不同隔离级别&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;之前说到&lt;code&gt;ReadView&lt;/code&gt;的机制只在&lt;code&gt;Read Committed&lt;/code&gt;和&lt;code&gt;Repeatable Read&lt;/code&gt;隔离级别下生效，所以只有这两种隔离级别才有&lt;code&gt;MVCC&lt;/code&gt;。&lt;br/&gt;在&lt;code&gt;Read Committed&lt;/code&gt;隔离级别下，每次读取数据时都会生成&lt;code&gt;ReadView&lt;/code&gt;；而在&lt;code&gt;Repeatable Read&lt;/code&gt;隔离级别下只会在事务首次读取数据时生成&lt;code&gt;ReadView&lt;/code&gt;，之后的读操作都会沿用此&lt;code&gt;ReadView&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;下面我们通过例子来看看&lt;code&gt;Read Committed&lt;/code&gt;和&lt;code&gt;Repeatable Read&lt;/code&gt;隔离级别下&lt;code&gt;MVCC&lt;/code&gt;的不同表现。我们继续以表&lt;code&gt;book&lt;/code&gt;为例进行演示。&lt;/p&gt;&lt;h6&gt;&lt;span&gt;Read Committed隔离级别分析&lt;/span&gt;&lt;/h6&gt;&lt;p&gt;假设在&lt;code&gt;Read Committed&lt;/code&gt;隔离级别下，有如下事务在执行，事务&lt;code&gt;id&lt;/code&gt;为10：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;BEGIN&lt;/span&gt;; // 开启Transaction 10&lt;br/&gt;&lt;br/&gt;&lt;span&gt;UPDATE&lt;/span&gt; book &lt;span&gt;SET&lt;/span&gt; stock = &lt;span&gt;200&lt;/span&gt; &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;UPDATE&lt;/span&gt; book &lt;span&gt;SET&lt;/span&gt; stock = &lt;span&gt;300&lt;/span&gt; &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时该事务尚未提交，&lt;code&gt;id&lt;/code&gt;为2的记录版本链如下图所示：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.46105919003115264&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/r8E7jgUqWLABp0Re143hguzibQBM57GuYmGAoJjSufxTH6LV6d6ca6pnreEw10aiaUBDHapUDH54BEaYS6koNKvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1926&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;然后我们开启一个事务对&lt;code&gt;id&lt;/code&gt;为2的记录进行查询：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;BEGIN&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; book &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当执行&lt;code&gt;SELECT&lt;/code&gt;语句时会生成一个&lt;code&gt;ReadView&lt;/code&gt;，该&lt;code&gt;ReadView&lt;/code&gt;中的&lt;code&gt;ACTIVE_TRX_ID_RANGE&lt;/code&gt;为&lt;code&gt;[10, 11)&lt;/code&gt;，当前事务ID&lt;code&gt;creator_trx_id&lt;/code&gt;为&lt;code&gt;0&lt;/code&gt;（因为事务中当执行写操作时才会分配一个单独的事务&lt;code&gt;id&lt;/code&gt;，否则事务&lt;code&gt;id&lt;/code&gt;为&lt;code&gt;0&lt;/code&gt;）。按照我们之前所述&lt;code&gt;ReadView&lt;/code&gt;的工作原理，我们查询到的版本记录为&lt;/p&gt;&lt;pre&gt;&lt;code&gt;+----------+-----------+-------+&lt;br/&gt;&lt;span&gt;| book_id  |&lt;/span&gt; book_name &lt;span&gt;| stock |&lt;/span&gt;&lt;br/&gt;+----------+-----------+-------+&lt;br/&gt;&lt;span&gt;| 2        |&lt;/span&gt; C++指南    &lt;span&gt;|  100  |&lt;/span&gt;&lt;br/&gt;+----------+-----------+-------+&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后我们将事务&lt;code&gt;id&lt;/code&gt;为10的事务提交：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;BEGIN&lt;/span&gt;; // 开启Transaction 10&lt;br/&gt;&lt;br/&gt;&lt;span&gt;UPDATE&lt;/span&gt; book &lt;span&gt;SET&lt;/span&gt; stock = &lt;span&gt;200&lt;/span&gt; &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;UPDATE&lt;/span&gt; book &lt;span&gt;SET&lt;/span&gt; stock = &lt;span&gt;300&lt;/span&gt; &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;COMMIT&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;同时开启执行另一事务&lt;code&gt;id&lt;/code&gt;为&lt;code&gt;11&lt;/code&gt;的事务，但不提交：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;BEGIN&lt;/span&gt;; // 开启Transaction 11&lt;br/&gt;&lt;br/&gt;&lt;span&gt;UPDATE&lt;/span&gt; book &lt;span&gt;SET&lt;/span&gt; stock = &lt;span&gt;400&lt;/span&gt; &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时&lt;code&gt;id&lt;/code&gt;为2的记录版本链如下图所示：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5665280665280665&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/r8E7jgUqWLABp0Re143hguzibQBM57GuYOhXhvSGf0Swr9TI6EibvRqxGBvJBwxnGNBXfjqMv1LaSUCYd6KxKmmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1924&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;然后我们回到刚才的查询事务中再次查询&lt;code&gt;id&lt;/code&gt;为2的记录：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;BEGIN&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; book &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; = &lt;span&gt;2&lt;/span&gt;; // 此时Transaction 10 未提交&lt;br/&gt;&lt;br/&gt;&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; book &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; = &lt;span&gt;2&lt;/span&gt;; // 此时Transaction 10 已提交&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当第二次执行&lt;code&gt;SELECT&lt;/code&gt;语句时会再次生成一个&lt;code&gt;ReadView&lt;/code&gt;，该&lt;code&gt;ReadView&lt;/code&gt;中的&lt;code&gt;ACTIVE_TRX_ID_RANGE&lt;/code&gt;为&lt;code&gt;[11, 12)&lt;/code&gt;，当前事务ID&lt;code&gt;creator_trx_id&lt;/code&gt;依然为&lt;code&gt;0&lt;/code&gt;。按照&lt;code&gt;ReadView&lt;/code&gt;的工作原理进行分析，我们查询到的版本记录为&lt;/p&gt;&lt;pre&gt;&lt;code&gt;+----------+-----------+-------+&lt;br/&gt;&lt;span&gt;| book_id  |&lt;/span&gt; book_name &lt;span&gt;| stock |&lt;/span&gt;&lt;br/&gt;+----------+-----------+-------+&lt;br/&gt;&lt;span&gt;| 2        |&lt;/span&gt; C++指南    &lt;span&gt;| 300   |&lt;/span&gt;&lt;br/&gt;+----------+-----------+-------+&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从上述分析可以发现，因为每次执行查询语句都会生成新的&lt;code&gt;ReadView&lt;/code&gt;，所以在&lt;code&gt;Read Committed&lt;/code&gt;隔离级别下的事务读取到的是查询时刻表中已提交事务修改之后的数据。&lt;/p&gt;&lt;h6&gt;&lt;span&gt;Repeatable Read隔离级别分析&lt;/span&gt;&lt;/h6&gt;&lt;p&gt;我们在&lt;code&gt;Repeatable Read&lt;/code&gt;隔离级别下重复上面的事务操作：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;BEGIN&lt;/span&gt;; // 开启Transaction 20&lt;br/&gt;&lt;br/&gt;&lt;span&gt;UPDATE&lt;/span&gt; book &lt;span&gt;SET&lt;/span&gt; stock = &lt;span&gt;200&lt;/span&gt; &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;UPDATE&lt;/span&gt; book &lt;span&gt;SET&lt;/span&gt; stock = &lt;span&gt;300&lt;/span&gt; &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时该事务尚未提交，然后我们开启一个事务对&lt;code&gt;id&lt;/code&gt;为2的记录进行查询：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;BEGIN&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; book &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当事务第一次执行&lt;code&gt;SELECT&lt;/code&gt;语句时会生成一个&lt;code&gt;ReadView&lt;/code&gt;，该&lt;code&gt;ReadView&lt;/code&gt;中的&lt;code&gt;ACTIVE_TRX_ID_RANGE&lt;/code&gt;为&lt;code&gt;[10, 11)&lt;/code&gt;，当前事务ID&lt;code&gt;creator_trx_id&lt;/code&gt;为&lt;code&gt;0&lt;/code&gt;。根据&lt;code&gt;ReadView&lt;/code&gt;的工作原理，我们查询到的版本记录为&lt;/p&gt;&lt;pre&gt;&lt;code&gt;+----------+-----------+-------+&lt;br/&gt;&lt;span&gt;| book_id  |&lt;/span&gt; book_name &lt;span&gt;| stock |&lt;/span&gt;&lt;br/&gt;+----------+-----------+-------+&lt;br/&gt;&lt;span&gt;| 2        |&lt;/span&gt; C++指南    &lt;span&gt;|  100  |&lt;/span&gt;&lt;br/&gt;+----------+-----------+-------+&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后我们将事务&lt;code&gt;id&lt;/code&gt;为20的事务提交：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;BEGIN&lt;/span&gt;; // 开启Transaction 20&lt;br/&gt;&lt;br/&gt;&lt;span&gt;UPDATE&lt;/span&gt; book &lt;span&gt;SET&lt;/span&gt; stock = &lt;span&gt;200&lt;/span&gt; &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;UPDATE&lt;/span&gt; book &lt;span&gt;SET&lt;/span&gt; stock = &lt;span&gt;300&lt;/span&gt; &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;COMMIT&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;同时开启执行另一事务&lt;code&gt;id&lt;/code&gt;为21的事务，但不提交：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;BEGIN&lt;/span&gt;; // 开启Transaction 21&lt;br/&gt;&lt;br/&gt;&lt;span&gt;UPDATE&lt;/span&gt; book &lt;span&gt;SET&lt;/span&gt; stock = &lt;span&gt;400&lt;/span&gt; &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后我们回到刚才的查询事务中再次查询&lt;code&gt;id&lt;/code&gt;为2的记录：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;BEGIN&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; book &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; = &lt;span&gt;2&lt;/span&gt;; // 此时Transaction 10 未提交&lt;br/&gt;&lt;br/&gt;&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; book &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; = &lt;span&gt;2&lt;/span&gt;; // 此时Transaction 10 已提交&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当第二次执行&lt;code&gt;SELECT&lt;/code&gt;语句时不会生成新的&lt;code&gt;ReadView&lt;/code&gt;，依然会使用第一次查询时生成&lt;code&gt;ReadView&lt;/code&gt;。因此我们查询到的版本记录跟第一次查询到的结果是一样的：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;+----------+-----------+-------+&lt;br/&gt;&lt;span&gt;| book_id  |&lt;/span&gt; book_name &lt;span&gt;| stock |&lt;/span&gt;&lt;br/&gt;+----------+-----------+-------+&lt;br/&gt;&lt;span&gt;| 2        |&lt;/span&gt; C++指南    &lt;span&gt;|  100  |&lt;/span&gt;&lt;br/&gt;+----------+-----------+-------+&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从上述分析可以发现，因为在&lt;code&gt;Repeatable Read&lt;/code&gt;隔离级别下的事务只会在第一次执行查询时生成&lt;code&gt;ReadView&lt;/code&gt;，该事务中后续的查询操作都会沿用这个&lt;code&gt;ReadView&lt;/code&gt;，因此此隔离级别下一个事务中多次执行同样的查询，其结果都是一样的，这样就实现了可重复读。&lt;/p&gt;&lt;h5&gt;&lt;span&gt;快照读和当前读&lt;/span&gt;&lt;/h5&gt;&lt;h6&gt;&lt;span&gt;快照读&lt;/span&gt;&lt;/h6&gt;&lt;p&gt;在&lt;code&gt;Read Committed&lt;/code&gt;和&lt;code&gt;Repeatable Read&lt;/code&gt;隔离级别下，普通的&lt;code&gt;SELECT&lt;/code&gt;查询都是读取&lt;code&gt;MVCC&lt;/code&gt;版本链中的一个版本，相当于读取一个快照，因此称为&lt;strong&gt;快照读&lt;/strong&gt;。这种读取方式不会加锁，因此读操作时非阻塞的，因此也叫&lt;strong&gt;非阻塞读&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;在标准的&lt;code&gt;Repeatable Read&lt;/code&gt;隔离级别下读操作会加&lt;code&gt;S锁&lt;/code&gt;，直到事务结束，因此可以阻止其他事务的写操作；但在&lt;code&gt;MySQL&lt;/code&gt;的&lt;code&gt;Repeatable Read&lt;/code&gt;隔离级别下读操作没有加锁，不会阻止其他事务对相同记录的写操作，因此在后续进行写操作时就有可能写入基于版本链中的旧数据计算得到的结果，这就导致了提交覆盖的问题。想要避免此问题，就需要另外加锁来实现。&lt;/p&gt;&lt;h6&gt;&lt;span&gt;当前读&lt;/span&gt;&lt;/h6&gt;&lt;p&gt;之前提到&lt;code&gt;MySQL&lt;/code&gt;有两种锁定读的方式：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;SELECT&lt;/span&gt; ... &lt;span&gt;LOCK&lt;/span&gt; &lt;span&gt;IN&lt;/span&gt; &lt;span&gt;SHARE&lt;/span&gt; &lt;span&gt;MODE&lt;/span&gt;; // 读取时对记录加S锁，直到事务结束&lt;br/&gt;&lt;br/&gt;&lt;span&gt;SELECT&lt;/span&gt; ... &lt;span&gt;FOR&lt;/span&gt; &lt;span&gt;UPDATE&lt;/span&gt;; // 读取时对记录加X锁，直到事务结束&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种读取方式读取的是记录的当前最新版本，称为&lt;strong&gt;当前读&lt;/strong&gt;。另外对于&lt;code&gt;INSERT&lt;/code&gt;、&lt;code&gt;DELETE&lt;/code&gt;、&lt;code&gt;UPDATE&lt;/code&gt;操作，也是需要先读取记录，获取记录的&lt;code&gt;X锁&lt;/code&gt;，这个过程也是一个当前读。由于需要对记录进行加锁，会阻塞其他事务的写操作，因此也叫&lt;strong&gt;加锁读&lt;/strong&gt;或&lt;strong&gt;阻塞读&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;当前读不仅会对当前记录加&lt;strong&gt;行记录锁&lt;/strong&gt;，还会对查询范围空间的数据加&lt;strong&gt;间隙锁&lt;/strong&gt;（&lt;code&gt;GAP LOCK&lt;/code&gt;），因此可以阻止幻读问题的出现。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;本文介绍了事务的多种并发问题，以及用以避免不同程度问题的隔离级别，并较为详细描述了传统隔离级别的实现方式以及&lt;code&gt;MySQL&lt;/code&gt;隔离级别的实现方式。但数据库的并发机制较为复杂，本文也只是做了大致的描述和介绍，很多细节还需要读者自己查询相关资料进行更细致的了解。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;1、MySQL-InnoDB-MVCC多版本并发控制&lt;/p&gt;&lt;p&gt;2、MySQL 是怎样运行的：从根儿上理解 MySQL&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span data-raw-text=&quot;长&quot; data-textnode-index=&quot;126&quot; data-index=&quot;4905&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;211&quot; data-ratio=&quot;0.470314318975553&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/r8E7jgUqWLABp0Re143hguzibQBM57GuY6GFz2LJcTdP49elictV9qiaQGwjeas67Y3NibWSRJV49ouulgcyu3uA2g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1718&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span data-raw-text=&quot;长&quot; data-textnode-index=&quot;126&quot; data-index=&quot;4905&quot;&gt;长&lt;/span&gt;&lt;span data-raw-text=&quot;按&quot; data-textnode-index=&quot;126&quot; data-index=&quot;4906&quot;&gt;按&lt;/span&gt;&lt;span data-raw-text=&quot;二&quot; data-textnode-index=&quot;126&quot; data-index=&quot;4907&quot;&gt;二&lt;/span&gt;&lt;span data-raw-text=&quot;维&quot; data-textnode-index=&quot;126&quot; data-index=&quot;4908&quot;&gt;维&lt;/span&gt;&lt;span data-raw-text=&quot;码&quot; data-textnode-index=&quot;126&quot; data-index=&quot;4909&quot;&gt;码&lt;/span&gt;&lt;span data-raw-text=&quot;↑&quot; data-textnode-index=&quot;126&quot; data-index=&quot;4910&quot;&gt;↑&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span data-raw-text=&quot;关&quot; data-textnode-index=&quot;127&quot; data-index=&quot;4911&quot;&gt;关&lt;/span&gt;&lt;span data-raw-text=&quot;注&quot; data-textnode-index=&quot;127&quot; data-index=&quot;4912&quot;&gt;注&lt;/span&gt;&lt;span data-raw-text=&quot;『&quot; data-textnode-index=&quot;127&quot; data-index=&quot;4913&quot;&gt;『比特瓦尔登&lt;/span&gt;&lt;span data-raw-text=&quot;』&quot; data-textnode-index=&quot;127&quot; data-index=&quot;4920&quot;&gt;』&lt;/span&gt;&lt;span data-raw-text=&quot;公&quot; data-textnode-index=&quot;127&quot; data-index=&quot;4921&quot;&gt;公&lt;/span&gt;&lt;span data-raw-text=&quot;众&quot; data-textnode-index=&quot;127&quot; data-index=&quot;4922&quot;&gt;众&lt;/span&gt;&lt;span data-raw-text=&quot;号&quot; data-textnode-index=&quot;127&quot; data-index=&quot;4923&quot;&gt;号&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8a46795e87cdf47634c946257b5b245b</guid>
<title>如何提升微服务的幸福感？</title>
<link>https://toutiao.io/k/p8owj4t</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                                    


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section data-tools=&quot;新媒体管家&quot; data-label=&quot;powered by xmt.cn&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/yvBJb5IiafvlarThVF9TtSAibE87HzU6uOicI9uSy1ZI6icuFNuODgXBAwaBUAyw7JzxQWCadtbt3W4lujlMwcuXlg/0?wx_fmt=jpeg&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1280&quot; data-cropy1=&quot;137.30103806228374&quot; data-cropy2=&quot;803.8754325259516&quot; data-ratio=&quot;0.52109375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/yvBJb5IiafvlarThVF9TtSAibE87HzU6uOWNyYGMNRcHAKjGKLia7NybDkZc9VPVAyUFMx25gjSQ8njKDPicfsuOBw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; 作者 | 亦盏&lt;/span&gt;&lt;/p&gt;&lt;h2 data-lake-id=&quot;c46495e57a2c6c5846a0b2901aef5063_h2_0&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;2858960&quot; data-style-type=&quot;undefined&quot;&gt;&lt;section data-style-type=&quot;5&quot; data-id=&quot;2763309&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;img class=&quot;__bg_gif&quot; data-ratio=&quot;0.45454545454545453&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/US10Gcd0tQGY9ddd5GpbmVRuaRfuaESAUBGE7uHX5G0nxxLSub2QTKZdu538V7GaHXS5jsTCebYCUibaHsjg0ow/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;22&quot; title=&quot;动态黑色音符&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;前言&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着微服务的流行，越来越多公司使用了微服务框架，微服务以其高内聚、低耦合等特性，提供了更好的容错性，也更适应业务的快速迭代，为开发人员带来了很多的便利性。但是随着业务的发展，微服务拆分越来越复杂，微服务的治理也成了一个比较令人头疼的问题，我相信下面这些场景大家或多或少都遇到过。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;场景一&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;发布是天大的事情，每一次的发布，都会出现执行到一半的请求中断掉，上游继续调用已经下线的节点导致报错的现象。发布时收到各种报错，同时还影响用户的体验，发布后又需要修复执行到一半的脏数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;上述场景还是在新版本没有任何问题的情况下，如果新版本有问题，则会导致大量业务直接请求到有问题的新版本，轻则修复数据，重则严重影响用户体验，甚至产生资损。最后不得不每次发版都安排在凌晨两三点发布，心惊胆颤，睡眠不足，苦不可言。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;场景二&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：大半夜某个服务节点出现异常，上游仍旧不断地调用，出现很多异常和各种报警短信。被报警吵醒后，想直接在线上修复，有点难，想保留现场又害怕拖垮整个应用，只好先重启为上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;但是这只是治标不治本的方式，因为很难复现从而无法有效定位，可能明天又被吵醒，继续重启。上述场景还是建立在报警系统比较完善的情况下，如果没有完善的报警系统，严重情况可能整个业务系统都被单机异常拖垮。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;场景三&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：公司业务壮大了，部门组织变复杂后，微服务模块越来越多。我不清楚发布的服务到底被谁调用了，所以我不知道能否安全地下线一个服务。我这个应用的这个接口是个敏感接口，我只希望得到我授权的应用才能调用，而不是直接从服务注册中心得到我的地址就能直接调用，但是目前好像还做不到。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上三个场景确实是使用微服务之后带来的痛点，这时候有个人告诉你，这些问题，我都知道怎么搞定，我有着丰富的经验，知道怎么解决，你肯定很开心。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后高薪请进来了，确实不错，各种架构图、框架原理，框架修改点都非常清晰而且功能确实完美。最后评估对当前系统的修改成本，需要搭建三套中间件服务端，增加 4 个中间件依赖，修改几万行代码和配置。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;“打扰了，还是业务重要，产品经理给的需求还没完成呢，刚刚说的场景也没那么痛苦，不就几个小问题嘛，真的没事。”&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这时候 EDAS 告诉你，EDAS 的微服务解决方案，不需要做任何的代码和配置的修改，就能完美地解决上面说的三个场景中的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;你，不心动吗？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;是的，你没看错，只要你的应用是&lt;strong&gt;基于 Spring Cloud 或 Dubbo 最近五年内的版本开发，就能直接使用完整的 EDAS 微服务治理能力，不需要修改任何代码和配置&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-lake-id=&quot;c3219578fefe53e47ef824ce6f79f057_h2_1&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;article tabindex=&quot;0&quot;&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;2858960&quot; data-style-type=&quot;undefined&quot;&gt;&lt;section data-style-type=&quot;5&quot; data-id=&quot;2763309&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;img class=&quot;__bg_gif&quot; data-ratio=&quot;0.45454545454545453&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/US10Gcd0tQGY9ddd5GpbmVRuaRfuaESAUBGE7uHX5G0nxxLSub2QTKZdu538V7GaHXS5jsTCebYCUibaHsjg0ow/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;22&quot; title=&quot;动态黑色音符&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;为什么 EDAS 用户可以轻松发布？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/article&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3198855&quot; data-style-type=&quot;undefined&quot;&gt;&lt;section data-style-type=&quot;5&quot; data-id=&quot;2763310&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h3&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;1. 传统的发布流程真的很容易出错&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;传统的发布流程中，服务提供者停止再启动，服务消费者感知到服务提供者节点停止的流程如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5412221144519883&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWuOOWQHh8E04Ag94LcEGEZD2lhWudxb6lt1qlX6cM6HaOQ9U8JEektn8BY86bKIvBhEJdTYN1tBUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1031&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1. &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;服务发布前，消费者根据负载均衡规则调用服务提供者，业务正常。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2. &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;服务提供者 B 需要发布新版本，先对其中的一个节点进行操作，首先是停止 Java 进程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3. &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;服务停止过程，又分为主动注销和被动注销，主动注销是准实时的，被动注销的时间由不同的注册中心决定，最差的情况会需要 1 分钟。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果应用是正常停止，Spring Cloud 和 Dubbo 框架的 Shutdown Hook 能正常被执行，这一步的耗时可以忽略不计。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果应用是非正常停止，比如直接使用 kill -9 停止，或者 Docker 镜像构建的时候 Java 应用不是 1 号进程且没有把 kill 信号传递给应用。那么服务提供者不会主动去注销服务节点，而是在超过一段时间后由于心跳超时而被动地被注册中心摘除。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4. &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;服务注册中心通知消费者，其中的一个服务提供者节点已下线。包含推送和轮询两种方式，推送可以认为是准实时的，轮询的耗时由服务消费者轮询间隔决定，最差的情况下需要 1 分钟。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;5. &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;服务消费者刷新服务列表，感知到服务提供者已经下线了一个节点，这一步对于 Dubbo 框架来说不存在，但是 Spring Cloud 的负载均衡组件 Ribbon 默认的刷新时间是 30 秒 ，最差情况下需要耗时 30 秒。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;6. &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;服务消费者不再调用已经下线的节点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从第 2 步到第 6 步的过程中，Eureka 在最差的情况下需要耗时 2 分钟，Nacos 在最差的情况下需要耗时 50 秒。在这段时间内，请求都有可能出现问题，所以发布时会出现各种报错，同时还影响用户的体验，发布后又需要修复执行到一半的脏数据。最后不得不每次发版都安排在凌晨两三点发布，心惊胆颤，睡眠不足，苦不可言。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3198855&quot; data-style-type=&quot;undefined&quot;&gt;&lt;section data-style-type=&quot;5&quot; data-id=&quot;2763310&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h3&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;2. 为什么 EDAS 用户不需要修复数据&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当您的应用部署到 EDAS 之后，EDAS 的无损下线功能会自动在发布新版本的时候做如下的增强，我们主要关注绿色部分的信息：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5842931937172775&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWuOOWQHh8E04Ag94LcEGEZDUCDdg9cZiazwicFwTCujyYN9MjIiarzkzYds6IrxgcJ20UiaDvaQKKj03A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;955&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1. &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;应用在发布前主动向注册中心注销应用，并将应用标记为已下线的状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2. &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;在接收到服务消费者请求时，首先会正常处理本次调用，并通知服务消费者此节点已下线，服务消费者会立即从调用列表删除此节点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3. &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;在这之后，服务消费者不再调用已经下线的节点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;EDAS 的无损下线功能，将原来的从原来的 停止进程阶段 注销服务变成了 prestop 阶段注销服务，将原来的依赖于 注册中心推送，做到了服务提供者直接通知消费者从调用列表中摘除自己。使得下线感知的时间大大减短，从原来的分钟级别做到准实时，确保您的应用在下线时能做到业务无损。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3198855&quot; data-style-type=&quot;undefined&quot;&gt;&lt;section data-style-type=&quot;5&quot; data-id=&quot;2763310&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h3&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;3. 金丝雀发布为 EDAS 用户再加一重保障&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在普通的新版本发布场景中，默认情况下请求到各个节点的流量是均匀分布的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;假设服务提供者有 4 台，只要某个节点一发布新版本，就会有 25% 的流量打到新版本。如果新版本存在问题，就会影响线上 25% 的流量，轻则修复数据，重则严重影响用户体验，甚至产生资损。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.8555078683834049&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWuOOWQHh8E04Ag94LcEGEZDIvb3Notljy9bhBbCVfwycGcNEvtrlibBCs9ZoJxFC7qiaqyZVwpsJBfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;699&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;EDAS 提供的金丝雀发布功能，支持 EDAS 用户在发布新版本之前就提前配置好金丝雀规则，使得只有符合流量特征的流量会调用到新版本，从而可以精准地控制调用到新版本的流量，进行新版本验证。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.8555078683834049&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWuOOWQHh8E04Ag94LcEGEZDTRriapgW2ia6U148NOmCVX7HGtvbM337SwSqibBibE6AWAib3Fk0TRjwfrg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;699&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如图所示，EDAS 的用户可以在发布之前配置好金丝雀规则。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里以 Dubbo 为例，下图中配置表明：调用 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;com.alibaba.edas.demo.EchoService.echo(String string) 的流量中，只有参数为 &quot;helloworld&quot; 的流量才会被路由到新版本。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.46221570066030815&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWuOOWQHh8E04Ag94LcEGEZDuTfcibI93wnYIXpibfSpjQAM73QQU6vm2MGcAVpicfpV0sTIMnd9VNuEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2726&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在服务提供者的将服务注册到注册中心前，EDAS 已经将新版本对应的金丝雀规则推送到服务消费者端。服务消费者在调用的时候，会根据金丝雀规则对流量进行分析，并与服务提供者列表中的元数据进行比对，选择正确的调用地址。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了上图中演示的简单参数比对之外，EDAS 也支持解析更复杂的结构体进行规则配置。当然，如果某个场景只需要控制流量百分比就能满足需求，EDAS 用户也可以直接按比例进行灰度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;EDAS 金丝雀发布 将路由到新版本的流量，从所占总节点数的百分比转变成了根据流量特征进行控制。您可以自由地控制路由到新版本的流量，比如只将内部测试账号的流量路由到新版本，从而做到小心发布、大胆验证。所以，赶紧来 EDAS 进行轻松发布吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;article tabindex=&quot;0&quot;&gt;&lt;article tabindex=&quot;0&quot;/&gt;&lt;/article&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;2858960&quot; data-style-type=&quot;undefined&quot;&gt;&lt;section data-style-type=&quot;5&quot; data-id=&quot;2763309&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;img class=&quot;__bg_gif&quot; data-ratio=&quot;0.45454545454545453&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/US10Gcd0tQGY9ddd5GpbmVRuaRfuaESAUBGE7uHX5G0nxxLSub2QTKZdu538V7GaHXS5jsTCebYCUibaHsjg0ow/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;22&quot; title=&quot;动态黑色音符&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;为什么 EDAS 用户不需要半夜醒来重启机器？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3198855&quot; data-style-type=&quot;undefined&quot;&gt;&lt;section data-style-type=&quot;5&quot; data-id=&quot;2763310&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h3&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;1. 开源框架有可能被单点异常拖垮整个应用系统&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在微服务架构中，当服务提供者的应用实例出现异常时，服务消费者无法及时感知，会影响服务的正常调用，进而影响消费者的服务性能甚至可用性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.577570093457944&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWuOOWQHh8E04Ag94LcEGEZDNkJCBK2cFjmxFO3eqfXSHtgCl3e0AZzgaAyoFTe2Sw3t2BX1ICypicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;535&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在上图的示例场景中，系统包含 4 个应用，A、B、C 和 D，其中应用 A 会分别调用应用 B、C 和 D。当应用 B、C 或 D 的某些实例异常时（如图中应用 B、C 和 D 标识的各有 1个和 2 个异常实例），如果应用 A 无法感知，会导致部分调用失败；如果业务代码写的不够优雅，有可能影响应用 A 的性能甚至整个系统的可用性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3198855&quot; data-style-type=&quot;undefined&quot;&gt;&lt;section data-style-type=&quot;5&quot; data-id=&quot;2763310&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h3&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;2. 离群实例摘除给业务系统的稳定性加把锁&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了保护应用的服务性能和可用性，EDAS 支持检测应用实例的可用性并进行动态调整，以保证服务成功调用，从而提升业务的稳定性和服务质量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下图所示，EDAS 用户可以在控制台上对应用 A 进行如下配置，从而保证 A 应用的稳定性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5117004680187207&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWuOOWQHh8E04Ag94LcEGEZDZwJEPQrvgX6Nt2oJSlibFjNjRtKxaiaKz55CH1OlXUuoBYDMzwCq9icMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2564&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于离群实例摘除功能，EDAS 用户不会因为单机异常在半夜醒来重启机器，先安心地睡一觉吧，反正业务也不会受影响。醒来之后机器现场也还在，是拿着保留的现场进行分析，还是直接重启，任君选择。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;article tabindex=&quot;0&quot;&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;2858960&quot; data-style-type=&quot;undefined&quot;&gt;&lt;section data-style-type=&quot;5&quot; data-id=&quot;2763309&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;img class=&quot;__bg_gif&quot; data-ratio=&quot;0.45454545454545453&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/US10Gcd0tQGY9ddd5GpbmVRuaRfuaESAUBGE7uHX5G0nxxLSub2QTKZdu538V7GaHXS5jsTCebYCUibaHsjg0ow/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;22&quot; title=&quot;动态黑色音符&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;为什么 EDAS 用户对自己的服务胸有成竹？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/article&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3198855&quot; data-style-type=&quot;undefined&quot;&gt;&lt;section data-style-type=&quot;5&quot; data-id=&quot;2763310&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h3&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;1. 服务查询一目了然&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们熟知的 zookeeper 组件并没有服务查询界面，Eureka 和 Nacos 这两个注册中心，虽然提供了网页版的控制台，但是在控制台上只能查询到服务的 IP 和 port 等基本的信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;EDAS 用户在使用服务查询时，不仅能够查询到应用注册了哪些服务，对应的 IP 和 port 是什么，还能查询到服务包含的具体方法和参数类型，以及直观地看到服务被其他应用和节点的订阅情况。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6122866894197952&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWuOOWQHh8E04Ag94LcEGEZDX9PszibfT6NM2PvCb3T2LGSNvSt7zcGasMZtogJXNoNxzr6UXQCCFnw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2930&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;即使部门组织再复杂、微服务模块再多，EDAS 的用户也可以清晰地查询出服务的被调用情况，做到心中有数，在梳理服务依赖以及评估影响面的时候可以做到胸有成竹。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4 data-lake-id=&quot;5c7a487cc5f9c86272a10514609f57aa_h4_6&quot;&gt;&lt;span/&gt;&lt;/h4&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3198855&quot; data-style-type=&quot;undefined&quot;&gt;&lt;section data-style-type=&quot;5&quot; data-id=&quot;2763310&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h3&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;2. 精准地控制服务调用的权限&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;业务发展后，服务还会遇到权限控制的需求。比如优惠券部门的某个应用，同时包含了优惠券查询接口 和优惠券发放接口。对于优惠券查询接口来说，默认公司内部的所有应用都有权限调用的；但优惠券发放接口只有客服和运营部门的某些应用才有权限调用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下图所示，EDAS 用户可以对自己的服务进行权限管理，这里以 Dubbo 为例，下图中配置表明，应用 cartservice 发布的 com.alibaba.edas.demo.EchoService 服务的 addItemToCart 的方法，只允许 frontend 这个应用调用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6650485436893204&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWuOOWQHh8E04Ag94LcEGEZDJhicB9iahzjHCD0od4aRIJ9TBGRibaHvdHHR1CZ1B3qop1QtA0L074L2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2472&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了支持对指定的接口添加鉴权规则之外，服务鉴权也支持对整个应用添加鉴权规则，还支持根据调用方 IP 进行鉴权。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;精准的权限管理，可以让你更好地管理微服务调用的权限，保证业务的合规性，保障数据的安全。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;article tabindex=&quot;0&quot;&gt;&lt;article tabindex=&quot;0&quot;/&gt;&lt;/article&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;2858960&quot; data-style-type=&quot;undefined&quot;&gt;&lt;section data-style-type=&quot;5&quot; data-id=&quot;2763309&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;img class=&quot;__bg_gif&quot; data-ratio=&quot;0.45454545454545453&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/US10Gcd0tQGY9ddd5GpbmVRuaRfuaESAUBGE7uHX5G0nxxLSub2QTKZdu538V7GaHXS5jsTCebYCUibaHsjg0ow/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;22&quot; title=&quot;动态黑色音符&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;EDAS 微服务治理使用成本真的很低&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用 EDAS 微服务治理的成本真的已经低得不能再低，不需要修改任何代码和配置，直接将应用部署上来就可以享受完整的 EDAS 微服务治理能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;只要你的应用是基于 Spring Cloud 或 Dubbo 最近五年内的版本开发，就能直接使用完整的  EDAS 微服务治理能力，赶快来体验吧！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-lake-id=&quot;9d80a048b0f16b137389ca00a353d0ed_h2_5&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;article tabindex=&quot;0&quot;&gt;&lt;article tabindex=&quot;0&quot;/&gt;&lt;/article&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3198855&quot; data-style-type=&quot;undefined&quot;&gt;&lt;section data-style-type=&quot;5&quot; data-id=&quot;2763310&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h3&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;团队招人啦&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;阿里云云原生微服务产品研发团队正在招人，我们需要志同道合的你，一起将微服务的产品建设得更好，让应用的开发更加简单，让应用的运行更加稳定，实现业务永远在线。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了 EDAS 和 MSE（微服务引擎）这些微服务相关的产品之外，我们还有 ARMS (应用实时监控服务)、ACM（应用配置管理）、SAE（Serverless 应用引擎）等云产品，也迫切地等待你的到来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;联系方式：yizhan.xj@alibaba-inc.com&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3198855&quot; data-style-type=&quot;undefined&quot;&gt;&lt;section data-style-type=&quot;5&quot; data-id=&quot;2763310&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h3&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;作者信息&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;肖京&lt;/span&gt;&lt;span&gt;（花名：亦盏）&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，阿里云智能技术专家，Spring Cloud Alibaba PMC。主要负责阿里云微服务产品的研发工作，关注微服务、云原生等技术方向。&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>