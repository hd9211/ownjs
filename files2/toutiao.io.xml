<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>a66a404513aced0b40d2a229af55229c</guid>
<title>轻松搞懂5种IO模型</title>
<link>https://toutiao.io/k/o77uhyt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;同步阻塞IO、同步非阻塞IO、IO多路复用、异步阻塞IO、异步非阻塞IO，这五种IO模型有没有朋友记过多次了，但是总是记不住？那是因为没有理解本质。5年前我记住了，到现在发现记忆和区分仍然很清晰，今天把理解方法介绍给大家。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;首先，大家先思考一个问题：&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;vote_area&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;IO操作其实主要为了读和写。本文以读数据做说明。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当程序调用read方法时，会切换到系统内核来完成真正的读取。而读取又分为等待数据和复制数据两个阶段。如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.591002044989775&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlibwAicyibKwptvaTrLpel9o7xWE8NHicicu68aYkU1HRQSDEu0XOZcKZJDGJA5Jr5ddHf2vN6roGX0zBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;489&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;同步阻塞IO&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5967413441955194&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlibwAicyibKwptvaTrLpel9o7xdZlbgqv5kQRQCKQVxD7RKyFjKIE80nDaWJGKJ7OkKwEd6R9xU5AYng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;491&quot;/&gt;&lt;/p&gt;&lt;p&gt;如上图所示，用户线程发起一个read请求，会切换到内核空间。这时候如果没有数据过来，则用户线程和对应的内核线程什么都做不了，一直等到有数据进来，并且完成了内核态的数据复制才继续返回用户空间继续执行。这整个过程是阻塞的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;同步非阻塞IO&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5925925925925926&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlibwAicyibKwptvaTrLpel9o7xcicUu1licMQMqp5hCbA590GcR4TicHLbPZU9GcRqKFDJoeD85RB2w9K6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;486&quot;/&gt;&lt;/p&gt;&lt;p&gt;如上图所示，用户线程发起一个read请求，会切换到内核空间。这时候如果没有数据过来，则直接返回。它可以再次轮循发起read，如果某一次发现有数据过来，则等待完成了内核态的数据复制才继续返回用户空间继续执行。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个过程中，没有数据时是非阻塞的。有数据时是阻塞的，被称为非阻塞IO。这种方式涉及多次内核切换，某些情况下反而会影响性能。之前业界发生过一个由阻塞切换成非阻塞，流量高峰时性能不足引起的重大故障。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;IO多路复用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5876288659793815&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlibwAicyibKwptvaTrLpel9o7x3R6o8o1QLpLXicnnBktC7rCnwib7AknBhK3XicTdoMdBSx1mlKbgtCoPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;485&quot;/&gt;&lt;/p&gt;&lt;p&gt;如上图所示，用户线程发起一个select请求，会切换到内核空间。这时候如果没有数据过来，则阻塞直到有数据时返回给用户线程。用户线程收到有数据的消息，发起read操作同步等待直到完成内核态的数据复制才继续返回用户空间继续执行。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这时候，是不是有朋友冒出来一个问题：似乎看不到多路复用的优势啊。似乎阻塞才是最佳选择啊。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;上面都是以最简单的例子来介绍的，下面来看一个复杂一些的阻塞IO。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0589430894308942&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlibwAicyibKwptvaTrLpel9o7xplOGIzPYnKtkRa7cibope8SBxPp6sR9mqdBNoqg0S1uJvjBeKPu4NwA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;492&quot;/&gt;&lt;/p&gt;&lt;p&gt;如上图所示，用户线程发起一个read请求，会切换到内核空间。这时候又有另外一个连接请求过来。这个线程不会立即影响这个连接请求，而是一直等到有数据进来，并且完成了内核态的数据复制才继续返回用户空间继续执行。处理完第一个连接的所有read操作之后，才会响应新的连接。新连接从accept（netty中建立连接的函数）到read都是同步阻塞的，每次只能处理一个连接的事件。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7582644628099173&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlibwAicyibKwptvaTrLpel9o7x60ehaqKgCXiciadN6g65vhRgJRnwyv1BU2cLzMiaDbricyZbwxnnuDjBcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;484&quot;/&gt;&lt;/p&gt;&lt;p&gt;如上图所示，多路复用时，用户程序发起一个select操作，会返回一批事件，有read、write、accept（netty中建立连接的事件）。这时候，该等的时间select操作都已经做了。这时候，用户线程可以用新的线程(worker线程)直接去建立连接、复制数据。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;异步非阻塞IO&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这里就要明确IO模型中，同步和异步的概念了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;同步：线程自己去获取结果。(一个线程)&lt;/p&gt;&lt;p&gt;异步：线程自己不去获取结果，而由其他线程送结果。(至少两个线程)&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6081632653061224&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlibwAicyibKwptvaTrLpel9o7xt7uXTkFdFoPwoZdMWodV4Mic1JwZFDZo26aS8tKQUYaeJSN2eHcY9Pw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;490&quot;/&gt;&lt;/p&gt;&lt;p&gt;如上图所示，异步是通过回调来完成的。用户程序发起read操作只是去通知操作系统我在等待数据。另外一个线程等待数据复制完成回调read方法返回结果。异步IO从实现上是基于操作系统信号驱动的，也叫信号驱动IO。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;异步阻塞IO和异步非阻塞IO又有什么区别呢？看上面的过程，异步read操作去通知完操作系统肯定是直接返回的，也就是肯定是非阻塞的。其实根本没有异步阻塞这种说法，纯属误传。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;最近发现，为了把一件事情讲清楚，要写的字越来越多。因为写的过程中会引出一些额外层面的问题需要解释。两者没有分离好反而不好理解。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我就想出来现在的办法，先在一篇文章中阐述一件事，同时抛出来一个问题让大家思考。然后另起一篇把问题讲透。就像本周的&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486533&amp;amp;idx=1&amp;amp;sn=a7a6bb50bb1ce4fb88510ab5b1fb9288&amp;amp;chksm=fafde6ebcd8a6ffd53ade8cd730c7436b93199b8bfcfa160d29056312432e4db5bfba3568eb0&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《HTTP状态码1XX深入理解》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《&lt;span&gt;HTTP状态码1XX深入理解&lt;/span&gt;》&lt;/a&gt;和&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486543&amp;amp;idx=1&amp;amp;sn=e61c5e6e427fca705414108e3cc4fd64&amp;amp;chksm=fafde6e1cd8a6ff773e553fd317b64a8f78dc15e8c340fa9762cacef25a7b811c7322839dbfc&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《【答案公布】客户端与服务端通信时，所有的http状态码是否都是服务端返回的？》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《&lt;span&gt;【&lt;/span&gt;&lt;span&gt;答案公布】客户端与服务端通信时，所有的http状态码是否都是服务端返回的？&lt;/span&gt;》&lt;/a&gt;。自己觉得这种方式更加清晰，大家觉得如何呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>16223002993e63e0fd319b68c9bd74e1</guid>
<title>你分库分表的姿势对么？——详谈水平分库分表</title>
<link>https://toutiao.io/k/eteqw6s</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;22&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;作者：vivo平台产品开发团队-Han Lei&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;一、背景&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;提起分库分表，对于大部分服务器开发来说，其实并不是一个新鲜的名词。随着业务的发展，我们表中的数据量会变的越来越大，字段也可能随着业务复杂度的升高而逐渐增多，我们为了解决单表的查询性能问题，一般会进行分表操作。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;同时我们业务的用户活跃度也会越来越高，并发量级不断加大，那么可能会达到单个数据库的处理能力上限。此时我们为了解决数据库的处理性能瓶颈，一般会进行分库操作。不管是分库操作还是分表操作，我们一般都有两种方式应对，一种是垂直拆分，一种是水平拆分。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;关于两种拆分方式的区别和特点，互联网上参考资料众多，很多人都写过相关内容，这里就不再进行详细赘述，有兴趣的读者可以自行检索。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;此文主要详细聊一聊，我们最实用最常见的水平分库分表方式中的一些特殊细节，希望能帮助大家避免走弯路，找到最合适自身业务的分库分表设计。&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;87&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p&gt;【注1】本文中的案例均基于Mysql数据库，下文中的分库分表统指水平分库分表。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;【注2】后文中提到到M库N表，均指共M个数据库，每个数据库共N个分表，即总表个数其实为M*N。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;二、什么是一个好的分库分表方案？&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.1 方案可持续性&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;前期业务数据量级不大，流量较低的时候，我们无需分库分表，也不建议分库分表。但是一旦我们要对业务进行分库分表设计时，就一定要考虑到分库分表方案的可持续性。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;那何为可持续性？&lt;/strong&gt;其实就是：业务数据量级和业务流量未来进一步升高达到新的量级的时候，我们的分库分表方案可以持续使用。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;一个通俗的案例，假定当前我们分库分表的方案为10库100表，那么未来某个时间点，若10个库仍然无法应对用户的流量压力，或者10个库的磁盘使用即将达到物理上限时，我们的方案能够进行平滑扩容。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在后文中我们将介绍下目前业界常用的翻倍扩容法和一致性Hash扩容法。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.2 数据偏斜问题&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;一个良好的分库分表方案，它的数据应该是需要比较均匀的分散在各个库表中的。如果我们进行一个拍脑袋式的分库分表设计，很容易会遇到以下类似问题：&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;135&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p&gt;a、某个数据库实例中，部分表的数据很多，而其他表中的数据却寥寥无几，业务上的表现经常是延迟忽高忽低，飘忽不定。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;b、数据库集群中，部分集群的磁盘使用增长特别块，而部分集群的磁盘增长却很缓慢。每个库的增长步调不一致，这种情况会给后续的扩容带来步调不一致，无法统一操作的问题。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这边我们定义分库分表最大数据偏斜率为 ：（数据量最大样本 - 数据量最小样本）/ 数据量最小样本。一般来说，如果我们的最大数据偏斜率在5%以内是可以接受的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100008465&quot; data-ratio=&quot;0.5117773019271948&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7ibSqqgkw7u8SC7X6Jv4YzZgAnfMNvQibZvq4LtEbZeoBN27oY1KicgZHAXDu0Fs8ax3HeUjQYh2pKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;467&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;三、常见的分库分表方案&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.1 Range分库分表&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;顾名思义，该方案根据数据范围划分数据的存放位置。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;举个最简单例子，我们可以把订单表按照年份为单位，每年的数据存放在单独的库（或者表）中。如下图所示：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt; * &lt;span class=&quot;code-snippet__doctag&quot;&gt;@return&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; String &lt;span class=&quot;code-snippet__title&quot;&gt;rangeShardByYear&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(String orderId)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; year = Integer.parseInt(orderId.substring(&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;4&lt;/span&gt;));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;t_order_&quot;&lt;/span&gt; + year;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通过数据的范围进行分库分表，该方案是最朴实的一种分库方案，它也可以和其他分库分表方案灵活结合使用。时下非常流行的分布式数据库：TiDB数据库，针对TiKV中数据的打散，也是基于Range的方式进行，将不同范围内的[StartKey,EndKey)分配到不同的Region上。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下面我们看看该方案的缺点：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;39&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;这点非常容易被遗忘，尤其是稳定跑了几年没有迭代任务，或者人员又交替频繁的模块。&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这里就需要注意了，因为是通过年份进行分库分表，那么元旦的那一天，你的定时任务很有可能会漏掉上一年的最后一天的数据扫描。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.2 Hash分库分表&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;虽然分库分表的方案众多，但是Hash分库分表是最大众最普遍的方案，也是本文花最大篇幅描述的部分。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;针对Hash分库分表的细节部分，相关的资料并不多。大部分都是阐述一下概念举几个示例，而细节部分并没有特别多的深入，如果未结合自身业务贸然参考引用，后期非常容易出现各种问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在正式介绍这种分库分表方式之前，我们先看几个常见的错误案例。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;常见错误案例一：非互质关系导致的数据偏斜问题&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; ShardCfg &lt;span class=&quot;code-snippet__title&quot;&gt;shard&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(String userId)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; hash = userId.hashCode();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__comment&quot;&gt;// 对库数量取余结果为库序号&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; dbIdx = Math.&lt;span class=&quot;code-snippet__built_in&quot;&gt;abs&lt;/span&gt;(hash % DB_CNT);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__comment&quot;&gt;// 对表数量取余结果为表序号&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; tblIdx = Math.&lt;span class=&quot;code-snippet__built_in&quot;&gt;abs&lt;/span&gt;(hash % TBL_CNT);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ShardCfg(dbIdx, tblIdx);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;上述方案是初次使用者特别容易进入的误区，用&lt;span&gt;Hash&lt;/span&gt;值分别对分库数和分表数取余，得到库序号和表序号。其实稍微思索一下，我们就会发现，以10库100表为例，如果一个&lt;span&gt;Hash&lt;/span&gt;值对100取余为0，那么它对10取余也必然为0。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这就意味着只有0库里面的0表才可能有数据，而其他库中的0表永远为空！&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;类似的我们还能推导到，0库里面的共100张表，只有10张表中(个位数为0的表序号)才可能有数据。这就带来了非常严重的数据偏斜问题，因为某些表中永远不可能有数据，最大数据偏斜率达到了无穷大。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;那么很明显，该方案是一个未达到预期效果的错误方案。数据的散落情况大致示意图如下：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;303&quot; data-backw=&quot;578&quot; data-fileid=&quot;100008466&quot; data-ratio=&quot;0.5237449118046132&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7ibSqqgkw7u8SC7X6Jv4YzZpIKzw3xB1jE6WvhrjwNfpRA2W6cPuvco1Lqm6bxgsmWChU7IegDqaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;737&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;事实上，只要库数量和表数量非互质关系，都会出现某些表中无数据的问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;证明如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100008467&quot; data-ratio=&quot;0.4548440065681445&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7ibSqqgkw7u8SC7X6Jv4YzZJz6wCq1zwxLI062iahVEGn80PS0RcDfAdQ5hQWrB5kXPpwBcYyCrrKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;609&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;那么是不是只要库数量和表数量互质就可用用这种分库分表方案呢？比如我用11库100表的方案，是不是就合理了呢？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;答案是否定的，我们除了要考虑数据偏斜的问题，还需要考虑可持续性扩容的问题，一般这种&lt;span&gt;Hash&lt;/span&gt;分库分表的方案后期的扩容方式都是通过翻倍扩容法，那11库翻倍后，和100又不再互质。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当然，如果分库数和分表数不仅互质，而且分表数为奇数(例如10库101表)，则理论上可以使用该方案，但是我想大部分人可能都会觉得使用奇数的分表数比较奇怪吧。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;常见错误案例二：扩容难以持续&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;如果避开了上述案例一的陷阱，那么我们又很容易一头扎进另一个陷阱，大概思路如下；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们把10库100表看成总共1000个逻辑表，将求得的Hash值对1000取余，得到一个介于[0，999)中的数，然后再将这个数二次均分到每个库和每个表中，大概逻辑代码如下：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; ShardCfg &lt;span class=&quot;code-snippet__title&quot;&gt;shard&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(String userId)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// ① 算Hash&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; hash = userId.hashCode();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// ② 总分片数&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; sumSlot = DB_CNT * TBL_CNT;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// ③ 分片序号&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; slot = Math.&lt;span class=&quot;code-snippet__built_in&quot;&gt;abs&lt;/span&gt;(hash % sumSlot);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// ④ 计算库序号和表序号的错误案例&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; dbIdx = slot % DB_CNT ;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; tblIdx = slot / DB_CNT ;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ShardCfg(dbIdx, tblIdx);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;该方案确实很巧妙的解决了数据偏斜的问题，只要&lt;span&gt;Hash&lt;/span&gt;值足够均匀，那么理论上分配序号也会足够平均，于是每个库和表中的数据量也能保持较均衡的状态。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100008468&quot; data-ratio=&quot;0.7772357723577236&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7ibSqqgkw7u8SC7X6Jv4YzZiaBvZ7pLrTdsmfFPRC4FlJvHbqGNRXYHQ6JyA7WJhC4lJC08466l5ow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;615&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但是该方案有个比较大的问题，那就是在计算表序号的时候，依赖了总库的数量，那么后续翻倍扩容法进行扩容时，会出现扩容前后数据不在同一个表中，从而无法实施。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如上图中，例如扩容前&lt;span&gt;Hash&lt;/span&gt;为1986的数据应该存放在6库98表，但是翻倍扩容成20库100表后，它分配到了6库99表，表序号发生了偏移。这样的话，我们在后续在扩容的时候，不仅要基于库迁移数据，还要基于表迁移数据，非常麻烦且易错。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;看完了上面的几种典型的错误案例，那么我们有哪些比较正确的方案呢？下面将结合一些实际场景案例介绍几种Hash分库分表的方案。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;常用姿势一：标准的二次分片法&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;上述错误案例二中，整体思路完全正确，只是最后计算库序号和表序号的时候，使用了库数量作为影响表序号的因子，导致扩容时表序号偏移而无法进行。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;事实上，我们只需要换种写法，就能得出一个比较大众化的分库分表方案。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; ShardCfg &lt;span class=&quot;code-snippet__title&quot;&gt;shard2&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(String userId)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// ① 算Hash&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; hash = userId.hashCode();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// ② 总分片数&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; sumSlot = DB_CNT * TBL_CNT;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// ③ 分片序号&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; slot = Math.&lt;span class=&quot;code-snippet__built_in&quot;&gt;abs&lt;/span&gt;(hash % sumSlot);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// ④ 重新修改二次求值方案&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; dbIdx = slot / TBL_CNT ;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; tblIdx = slot % TBL_CNT ;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ShardCfg(dbIdx, tblIdx);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;大家可以注意到，和错误案例二中的区别就是通过分配序号重新计算库序号和表序号的逻辑发生了变化。它的分配情况如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;426&quot; data-backw=&quot;568&quot; data-fileid=&quot;100008469&quot; data-ratio=&quot;0.75&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7ibSqqgkw7u8SC7X6Jv4YzZSdnFhxmkHZicZX7P3W6iceeraNwiaNibp2cexGiacNAmHNy1aMMEOVib60fQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;568&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;那为何使用这种方案就能够有很好的扩展持久性呢？我们进行一个简短的证明：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100008470&quot; data-ratio=&quot;0.5790251107828656&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7ibSqqgkw7u8SC7X6Jv4YzZG1Wg0sVFvdcAhJfwjfTgLpw0gtwLYbiaBiarNibLsAPLThFMHLIMj3r9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;677&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通过上面结论我们知道，通过翻倍扩容后，我们的表序号一定维持不变，库序号可能还是在原来库，也可能平移到了新库中(原库序号加上原分库数)，完全符合我们需要的扩容持久性方案。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100008471&quot; data-ratio=&quot;0.8562992125984252&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7ibSqqgkw7u8SC7X6Jv4YzZII2eI7xAY7V3wxpXEO6LoU41HA0pQo1WpicEbq0UibFpqshjdp83B1RQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;508&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;【方案缺点】&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;1、翻倍扩容法前期操作性高，但是后续如果分库数已经是大几十的时候，每次扩容都非常耗费资源。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2、连续的分片键&lt;span&gt;Hash&lt;/span&gt;值大概率会散落在相同的库中，某些业务可能容易存在库热点（例如新生成的用户&lt;span&gt;Hash&lt;/span&gt;相邻且递增，且新增用户又是高概率的活跃用户，那么一段时间内生成的新用户都会集中在相邻的几个库中）。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;常用姿势二：关系表冗余&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;我们可以将分片键对应库的关系通过关系表记录下来，我们把这张关系表称为&quot;路由关系表&quot;。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; ShardCfg &lt;span class=&quot;code-snippet__title&quot;&gt;shard&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;String userId&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; tblIdx = Math.abs(userId.hashCode() % TBL_CNT);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// 从缓存获取&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Integer dbIdx = loadFromCache(userId);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt; == dbIdx) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__comment&quot;&gt;// 从路由表获取&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            dbIdx = loadFromRouteTable(userId);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt; != dbIdx) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__comment&quot;&gt;// 保存到缓存&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                saveRouteCache(userId, dbIdx);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt; == dbIdx) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__comment&quot;&gt;// 此处可以自由实现计算库的逻辑&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            dbIdx = selectRandomDbIdx();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            saveToRouteTable(userId, dbIdx);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            saveRouteCache(userId, dbIdx);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ShardCfg(dbIdx, tblIdx);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;该方案还是通过常规的&lt;span&gt;Hash&lt;/span&gt;算法计算表序号，而计算库序号时，则从路由表读取数据。因为在每次数据查询时，都需要读取路由表，故我们需要将分片键和库序号的对应关系记录同时维护在缓存中以提升性能。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;上述实例中&lt;strong&gt;selectRandomDbIdx方法&lt;/strong&gt;作用为生成该分片键对应的存储库序号，这边可以非常灵活的动态配置。例如可以为每个库指定一个权重，权重大的被选中的概率更高，权重配置成0则可以将关闭某些库的分配。当发现数据存在偏斜时，也可以调整权重使得各个库的使用量调整趋向接近。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;该方案还有个优点，就是理论上后续进行扩容的时候，仅需要挂载上新的数据库节点，将权重配置成较大值即可，无需进行任何的数据迁移即可完成。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如下图所示：最开始我们为4个数据库分配了相同的权重，理论上落在每个库的数据概率均等。但是由于用户也有高频低频之分，可能某些库的数据增长会比较快。当挂载新的数据库节点后，我们灵活的调整了每个库的新权重。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100008472&quot; data-ratio=&quot;0.44283121597096187&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/4g5IMGibSxt7ibSqqgkw7u8SC7X6Jv4YzZ9icic99AgSdJ8CpmiboWqb2Js9gMZw5qqfKn6icBRakKVlr3T0FbChF5Tw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;551&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;该方案似乎解决了很多问题，那么它有没有什么不适合的场景呢？当然有，该方案在很多场景下其实并不太适合，以下举例说明。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;a、每次读取数据需要访问路由表，虽然使用了缓存，但是还是有一定的性能损耗。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;b、路由关系表的存储方面，有些场景并不合适。例如上述案例中用户id的规模大概是在10亿以内，我们用单库百表存储该关系表即可。但如果例如要用文件MD5摘要值作为分片键，因为样本集过大，无法为每个md5值都去指定关系（当然我们也可以使用md5前N位来存储关系）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;c、&lt;strong&gt;饥饿占位问题，如下详叙&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们知道，该方案的特点是后续无需扩容，可以随时修改权重调整每个库的存储增长速度。但是这个愿景是比较缥缈，并且很难实施的，我们选取一个简单的业务场景考虑以下几个问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;【&lt;strong&gt;业务场景&lt;/strong&gt;】：以用户存放文件到云端的云盘业务为例，需要对用户的文件信息进行分库分表设计，有以下假定场景：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;我们使用路由表记录每个用户所在的库序号信息。那么该方案会有以下问题：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第一：&lt;/strong&gt;我们总共有2亿个用户，只有3000W个产生过事务的用户。若程序不加处理，用户发起任何请求则创建路由表数据，会导致为大量实际没有事务数据的用户提前创建路由表。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;笔者最初存储云盘用户数据的时候便遇到了这个问题，客户端app会在首页查询用户空间使用情况，这样导致几乎一开始就为每个使用者分配好了路由。随着时间的推移，这部分没有数据的&quot;静默&quot;的用户，随时可能开始他的云盘使用之旅而“复苏”，从而导致它所在的库迅速增长并超过单个库的空间容量极限，从而被迫拆分扩容。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解决这个问题的方案，其实就是只针对事务操作(例如购买空间，上传数据，创建文件夹等等)才进行路由的分配，这样对代码层面便有了一些倾入。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第二、&lt;/strong&gt;按照前面描述的业务场景，一个用户最终平均有2000条数据，假定每行大小为1K，为了保证B+数的层级在3层，我们限制每张表的数据量在2000W，分表数为100的话，可以得到理论上每个库的用户数不能超过100W个用户。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;也就是如果是3000W个产生过事务的用户，我们需要为其分配30个库，这样会在业务前期，用户平均数据量相对较少的时候，存在非常大的数据库资源的浪费。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解决第二个问题，我们一般可以将很多数据库放在一个实例上，后续随着增长情况进行拆分。也可以后续针对将满的库，使用常规手段进行拆分和迁移。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;常用姿势三：基因法&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;还是由错误案例一启发，我们发现案例一不合理的主要原因，就是因为库序号和表序号的计算逻辑中，有公约数这个因子在影响库表的独立性。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;那么我们是否可以换一种思路呢？我们使用相对独立的&lt;span&gt;Hash&lt;/span&gt;值来计算库序号和表序号。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; ShardCfg &lt;span class=&quot;code-snippet__title&quot;&gt;shard&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(String userId)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; dbIdx = Math.&lt;span class=&quot;code-snippet__built_in&quot;&gt;abs&lt;/span&gt;(userId.substring(&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;4&lt;/span&gt;).hashCode() % DB_CNT );&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; tblIdx = Math.&lt;span class=&quot;code-snippet__built_in&quot;&gt;abs&lt;/span&gt;(userId.hashCode() % TBL_CNT);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ShardCfg(dbIdx, tblIdx);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;如上所示，我们计算库序号的时候做了部分改动，我们使用分片键的前四位作为&lt;span&gt;Hash&lt;/span&gt;值来计算库序号。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这也是一种常用的方案，我们称为基因法，即使用原分片键中的某些基因（例如前四位）作为库的计算因子，而使用另外一些基因作为表的计算因子。该方案也是网上不少的实践方案或者是其变种，看起来非常巧妙的解决了问题，然而在实际生成过程中还是需要慎重。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;笔者曾在云盘的空间模块的分库分表实践中采用了该方案，使用16库100表拆分数据，上线初期数据正常。然而当数据量级增长起来后，发现每个库的用户数量严重不均等，故猜测该方案存在一定的数据偏斜。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为了验证观点，进行如下测试，随机2亿个用户id（16位的随机字符串），针对不同的M库N表方案，重复若干次后求平均值得到结论如下：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;8库100表&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;min=248305(dbIdx=2, tblIdx=64), max=251419(dbIdx=7, tblIdx=8), rate= 1.25%            √&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;16库100表&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;min=95560(dbIdx=8, tblIdx=42), max=154476(dbIdx=0, tblIdx=87), rate= 61.65%           ×&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;20库100表&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;min=98351(dbIdx=14, tblIdx=78), max=101228(dbIdx=6, tblIdx=71), rate= 2.93%&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们发现该方案中，分库数为16，分表数为100，数量最小行数仅为10W不到，但是最多的已经达到了15W+，最大数据偏斜率高达61%。按这个趋势发展下去，后期很可能出现一台数据库容量已经使用满，而另一台还剩下30%+的容量。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;该方案并不是一定不行，而是我们在采用的时候，要综合分片键的样本规则，选取的分片键前缀位数，库数量，表数量，四个变量对最终的偏斜率都有影响。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;例如上述例子中，如果不是16库100表，而是8库100表，或者20库100表，数据偏斜率都能降低到了5%以下的可接受范围。所以该方案的隐藏的&quot;坑&quot;较多，我们不仅要估算上线初期的偏斜率，还需要测算若干次翻倍扩容后的数据偏斜率。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;例如你用着初期比较完美的8库100表的方案，后期扩容成16库100表的时候，麻烦就接踵而至。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;常用姿势四：剔除公因数法&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;还是基于错误案例一启发，在很多场景下我们还是希望相邻的&lt;span&gt;Hash&lt;/span&gt;能分到不同的库中。就像N库单表的时候，我们计算库序号一般直接用&lt;span&gt;Hash&lt;/span&gt;值对库数量取余。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;那么我们是不是可以有办法去除掉公因数的影响呢？下面为一个可以考虑的实现案例：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; ShardCfg &lt;span class=&quot;code-snippet__title&quot;&gt;shard&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(String userId)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; dbIdx = Math.&lt;span class=&quot;code-snippet__built_in&quot;&gt;abs&lt;/span&gt;(userId.hashCode() % DB_CNT);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// 计算表序号时先剔除掉公约数的影响&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; tblIdx = Math.&lt;span class=&quot;code-snippet__built_in&quot;&gt;abs&lt;/span&gt;((userId.hashCode() / TBL_CNT) % TBL_CNT);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ShardCfg(dbIdx, tblIdx);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;经过测算，该方案的最大数据偏斜度也比较小，针对不少业务从N库1表升级到N库M表下，需要维护库序号不变的场景下可以考虑。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;常用姿势五：一致性Hash法&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;一致性Hash算法也是一种比较流行的集群数据分区算法，比如RedisCluster即是通过一致性Hash算法，使用16384个虚拟槽节点进行每个分片数据的管理。关于一致性Hash的具体原理这边不再重复描述，读者可以自行翻阅资料。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这边详细介绍如何使用一致性Hash进行分库分表的设计。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们通常会将每个实际节点的配置持久化在一个配置项或者是数据库中，应用启动时或者是进行切换操作的时候会去加载配置。配置一般包括一个[StartKey,Endkey)的左闭右开区间和一个数据库节点信息，例如：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;503&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;195&quot; data-fileid=&quot;100008473&quot; data-ratio=&quot;0.38911290322580644&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7AWBMjESn4VYZibMW4Z0ScG0EwOmwf17qWyia5Y2OsNDia6qk0D8HZbY9vDVCsQwKD2Zvh88luLJJeg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;496&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;示例代码：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; TreeMap&amp;lt;Long, Integer&amp;gt; nodeTreeMap = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; TreeMap&amp;lt;&amp;gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;@&lt;span class=&quot;code-snippet__function&quot;&gt;Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;afterPropertiesSet&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__comment&quot;&gt;// 启动时加载分区配置&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    List&amp;lt;HashCfg&amp;gt; cfgList = fetchCfgFromDb();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (HashCfg cfg : cfgList) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        nodeTreeMap.put(cfg.endKey, cfg.nodeIdx);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; ShardCfg &lt;span class=&quot;code-snippet__title&quot;&gt;shard&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(String userId)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; hash = userId.hashCode();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; dbIdx = nodeTreeMap.tailMap((&lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt;) hash, &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;).firstEntry().getValue();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; tblIdx = Math.&lt;span class=&quot;code-snippet__built_in&quot;&gt;abs&lt;/span&gt;(hash % &lt;span class=&quot;code-snippet__number&quot;&gt;100&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ShardCfg(dbIdx, tblIdx);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;我们可以看到，这种形式和上文描述的Range分表非常相似，Range分库分表方式针对分片键本身划分范围，而一致性Hash是针对分片键的&lt;span&gt;Hash&lt;/span&gt;值进行范围配置。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;正规的一致性Hash算法会引入虚拟节点，每个虚拟节点会指向一个真实的物理节点。这样设计方案主要是能够在加入新节点后的时候，可以有方案保证每个节点迁移的数据量级和迁移后每个节点的压力保持几乎均等。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但是用在分库分表上，一般大部分都只用实际节点，引入虚拟节点的案例不多，主要有以下原因：&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;188&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p&gt;a、应用程序需要花费额外的耗时和内存来加载虚拟节点的配置信息。如果虚拟节点较多，内存的占用也会有些不太乐观。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;b、由于mysql有非常完善的主从复制方案，与其通过从各个虚拟节点中筛选需要迁移的范围数据进行迁移，不如通过从库升级方式处理后再删除冗余数据简单可控。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;c、虚拟节点主要解决的痛点是节点数据搬迁过程中各个节点的负载不均衡问题，通过虚拟节点打散到各个节点中均摊压力进行处理。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;而作为OLTP数据库，我们很少需要突然将某个数据库下线，新增节点后一般也不会从0开始从其他节点搬迁数据，而是前置准备好大部分数据的方式，故一般来说没有必要引入虚拟节点来增加复杂度。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;四、常见扩容方案&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;4.1 翻倍扩容法&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;翻倍扩容法的主要思维是每次扩容，库的数量均翻倍处理，而翻倍的数据源通常是由原数据源通过主从复制方式得到的从库升级成主库提供服务的方式。故有些文档将其称作&quot;&lt;strong&gt;从库升级法&lt;/strong&gt;&quot;。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;理论上，经过翻倍扩容法后，我们会多一倍的数据库用来存储数据和应对流量，原先数据库的磁盘使用量也将得到一半空间的释放。如下图所示:&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100008475&quot; data-ratio=&quot;0.5273775216138329&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7ibSqqgkw7u8SC7X6Jv4YzZwJlqfTzSZEDuiaibgRibNrqFj5CcibPicbBHlkvg3KO9tW4YDH1PnibrCPRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;694&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;具体的流程大致如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;①、时间点t1：为每个节点都新增从库，开启主从同步进行数据同步。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;②、时间点t2：主从同步完成后，对主库进行禁写。&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;153&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p&gt;此处禁写主要是为了保证数据的正确性。若不进行禁写操作，在以下两个时间窗口期内将出现数据不一致的问题：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;a、断开主从后，若主库不禁写，主库若还有数据写入，这部分数据将无法同步到从库中。&lt;/p&gt;&lt;p&gt; b、应用集群识别到分库数翻倍的时间点无法严格一致，在某个时间点可能两台应用使用不同的分库数，运算到不同的库序号，导致错误写入。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;③、时间点t3：同步完全完成后，断开主从关系，理论上此时从库和主库有着完全一样的数据集。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;④、时间点t4：从库升级为集群节点，业务应用识别到新的分库数后，将应用新的路由算法。&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;161&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;一般情况下，我们将分库数的配置放到配置中心中，当上述三个步骤完成后，我们修改分库数进行翻倍，应用生效后，应用服务将使用新的配置。这里需要注意的是，业务应用接收到新的配置的时间点不一定一致，所以必定存在一个时间窗口期，该期间部分机器使用原分库数，部分节点使用新分库数。这也正是我们的禁写操作一定要在此步完成后才能放开的原因。&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;⑤、时间点t5：确定所有的应用均接受到库总数的配置后，放开原主库的禁写操作，此时应用完全恢复服务。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;⑥、启动离线的定时任务，清除各库中的约一半冗余数据。&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;65&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;为了节省磁盘的使用率，我们可以选择离线定时任务清除冗余的数据。也可以在业务初期表结构设计的时候，将索引键的Hash值存为一个字段。&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;257&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;那么以上述常用姿势四为例，我们离线的清除任务可以简单的通过sql即可实现（需要防止锁住全表，可以拆分成若干个id范围的子sql执行）：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;delete from db0.tbl0 where hash_val mod 4 &amp;lt;&amp;gt; 0; &lt;/p&gt;&lt;p&gt;delete from db1.tbl0 where hash_val mod 4 &amp;lt;&amp;gt; 1;&lt;/p&gt;&lt;p&gt;delete from db2.tbl0 where hash_val mod 4 &amp;lt;&amp;gt; 2;&lt;/p&gt;&lt;p&gt;delete from db3.tbl0 where hash_val mod 4 &amp;lt;&amp;gt; 3;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;具体的扩容步骤可参考下图：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100008476&quot; data-ratio=&quot;1.0336&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/4g5IMGibSxt7ibSqqgkw7u8SC7X6Jv4YzZfaZ1SZUkySuiccD7xiayc6kOPvIcWnVB3MnuvTQocGOCTmhvfbpl2hTw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;625&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：通过上述迁移方案可以看出，从时间点t2到t5时间窗口呢内，需要对数据库禁写，相当于是该时间范围内服务器是部分有损的，该阶段整体耗时差不多是在分钟级范围内。若业务可以接受，可以在业务低峰期进行该操作。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当然也会有不少应用无法容忍分钟级写入不可用，例如写操作远远大于读操作的应用，此时可以结合canel开源框架进行窗口期内数据双写操作以保证数据的一致性。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;该方案主要借助于mysql强大完善的主从同步机制，能在事前提前准备好新的节点中大部分需要的数据，节省大量的人为数据迁移操作。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但是缺点也很明显，一是过程中整个服务可能需要以有损为代价，二是每次扩容均需要对库数量进行翻倍，会提前浪费不少的数据库资源。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;4.2 一致性Hash扩容&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;我们主要还是看下不带虚拟槽的一致性Hash扩容方法，假如当前数据库节点DB0负载或磁盘使用过大需要扩容，我们通过扩容可以达到例如下图的效果。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下图中，扩容前配置了三个&lt;span&gt;Hash&lt;/span&gt;分段，发现[-Inf，-10000）范围内的的数据量过大或者压力过高时，需要对其进行扩容。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100008477&quot; data-ratio=&quot;0.548460661345496&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7ibSqqgkw7u8SC7X6Jv4YzZVUcTNVh9jBUiaplWhveGiapBAxdNFVpicm6vyX77ylMziaqtryJv0Pia1vA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;877&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;主要步骤如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;①、&lt;strong&gt;时间点t1&lt;/strong&gt;：针对需要扩容的数据库节点增加从节点，开启主从同步进行数据同步。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;②、&lt;strong&gt;时间点t2&lt;/strong&gt;：完成主从同步后，对原主库进行禁写。&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;35&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt; 此处原因和翻倍扩容法类似，需要保证新的从库和原来主库中数据的一致性。&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;③、&lt;strong&gt;时间点t3&lt;/strong&gt;：同步完全完成后，断开主从关系，理论上此时从库和主库有着完全一样的数据集。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;④、&lt;strong&gt;时间点t4&lt;/strong&gt;：修改一致性Hash范围的配置，并使应用服务重新读取并生效。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;⑤、&lt;strong&gt;时间点t5&lt;/strong&gt;：确定所有的应用均接受到新的一致性Hash范围配置后，放开原主库的禁写操作，此时应用完全恢复服务。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;⑥、&lt;strong&gt;启动离线的定时任务&lt;/strong&gt;，清除冗余数据。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;可以看到，该方案和翻倍扩容法的方案比较类似，但是它更加灵活，可以根据当前集群每个节点的压力情况选择性扩容，而无需整个集群同时翻倍进行扩容。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;五、小结&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;本文主要描述了我们进行水平分库分表设计时的一些常见方案。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们在进行分库分表设计时，可以选择例如范围分表，&lt;span&gt;Hash&lt;/span&gt;分表，路由表，或者一致性Hash分表等各种方案。进行选择时需要充分考虑到后续的扩容可持续性，最大数据偏斜率等因素。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;文中也列举了一些常见的错误示例，例如库表计算逻辑中公约数的影响，使用前若干位计算库序号常见的数据倾斜因素等等。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们在实际进行选择时，一定要考虑自身的业务特点，充分验证分片键在各个参数因子下的数据偏斜程度，并提前规划考虑好后续扩容的方案。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;END&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span title=&quot;&quot; opera-tn-ra-cell=&quot;_$.pages:0.layers:0.comps:94.title1&quot;&gt;&lt;p&gt;猜你喜欢&lt;/p&gt;&lt;/span&gt; &lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c6a73aaa425dc10d4b723e20dac76821</guid>
<title>一种开发 Chrome 扩展程序的新姿势</title>
<link>https://toutiao.io/k/zq92ag2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6669921875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/QRibyjewM1IDFSXtDKxJq496uG4ZQvgzPSRzTcJ5vskkdHyOWYTU0mAHYG1ibXNlcB39hIvtKEnMcTNyAgX6rU9g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1024&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在日常工作和生活中经常会使用到各种各样的 Chrome 扩展程序，比如 1Password 能自动帮你填充密码，Adblock 能帮你拦截广告，又或者是开发时经常会使用的 React Developer Tools，Redux DevTools 等等。这些扩展程序对效率的提升是巨大的。在日常开发过程中，我们也可以尝试开发自己的扩展程序，来辅助提升团队的开发体验和效率。本文首先会展示一个实际开发扩展程序的例子，从而让读者体会到当前开发时存在的问题，并基于此提出解决方案。如果你已经对如何开发一个扩展程序很熟悉了，那么直接看下文中【新的开发方式】部分，或者直接浏览对应的框架—— browser-extension-kit（https://github.com/alibaba/browser-extension-kit）即可。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-id=&quot;2988&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;一个例子&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设我们要做一个可以重定向请求的扩展程序（类似 XSwitch），可以将当前页面的某个请求重定向到用户输入的地址，比如将某个环境下当前页面的 js 重定向到本地 webpack-dev-server 提供的 js，这样就可以实现线上调试功能了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了实现这个功能，我们首先需要一个页面能够让用户输入重定向前后对应的 url，这个页面会在用户点击该扩展程序的 icon 时展开，在 Chrome 官方文档中称为 popup。同时，实现具体重定向逻辑是在一个叫 background 的地方。根据官方指南，任何一个扩展程序都必须有一个 background，这个 background 存在于扩展程序的整个生命周期。通常情况下，你应该把所有核心业务逻辑和状态定义在 background 中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在扩展程序的世界中，background 和 popup 都是完全独立的执行环境，这意味着彼此之间无法直接获取对方定义的变量、函数等。而用户输入的参数，需要从 popup 传递到 background 中，在扩展程序的场景下，官方提供了基于消息的机制来完成数据的流转。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，我们在 popup 中处理用户输入：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// popup.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; React &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;react&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 在这里向 background 发起连接，之后会通过这个 port 来监听或者发送消息&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; port = chrome.runtime.connect();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; App = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;    &amp;lt;&amp;gt;&lt;br/&gt;      &amp;lt;div&amp;gt;&lt;br/&gt;        原始 URL：&amp;lt;input onChange={&lt;span&gt;&lt;span&gt;e&lt;/span&gt; =&amp;gt;&lt;/span&gt; port.postMessage({ originalUrl: e.target.value })} /&amp;gt;&lt;br/&gt;      &amp;lt;&lt;span&gt;/div&amp;gt;&lt;br/&gt;     &amp;lt;div&amp;gt;&lt;br/&gt;        新 URL：&amp;lt;input onChange={e =&amp;gt; port.postMessage({ newUrl: e.target.value })} /&lt;/span&gt;&amp;gt;&lt;br/&gt;      &amp;lt;&lt;span&gt;/div&amp;gt;&lt;br/&gt;    &amp;lt;/&lt;/span&gt;&amp;gt;&lt;br/&gt;  );&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在 background 中，我们需要等待连接建立，之后即可监听消息，拿到对应的数据，并且处理重定向逻辑：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// background.js&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; originalUrl = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; newUrl = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;chrome.runtime.onConnect.addListener(&lt;span&gt;&lt;span&gt;port&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt; port.onMessage.addListener(&lt;span&gt;&lt;span&gt;message&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (message.originalUrl) {&lt;br/&gt;     originalUrl = message.originalUrl;&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (message.newUrl) {&lt;br/&gt;     newUrl = message.newUrl;&lt;br/&gt;    }&lt;br/&gt;  });&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;chrome.webRequest.onBeforeRequest.addListener(&lt;span&gt;&lt;span&gt;request&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (!originalUrl || !newUrl || request.url !== originalUrl) {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; { redirectUrl: newUrl };&lt;br/&gt;}, {}, [&lt;span&gt;&#x27;blocking&#x27;&lt;/span&gt;])&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个最简单的例子就写好了。当然，要让这个例子实际能跑起来，还需要提供一个 manifest.json 给浏览器，在这个文件中声明该扩展程序的元信息，在此略过。如果你有兴趣，还可以看看官方指南（https://developer.chrome.com/docs/extensions/mv3/getstarted/），浏览器提供了丰富的 API，能够帮助你实现任何你想做的事。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然这个例子很简单，但是可以看到，如果要开发一个扩展程序，少不了要和消息机制打交道。对一个有实际业务逻辑的扩展程序来说，发送消息、接受消息是一个极高频的场景。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-id=&quot;2988&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;实际的场景&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于一个功能完整的扩展程序来说，显然不会像刚才的例子那样简单。通常来说，一个扩展程序会涉及到多个执行环境（如 content-script、 popup 等，这些都是 Chrome 提供的彼此互相独立的执行环境），同时可能提供多个功能，而 background 负责全局的状态管理和逻辑串联。在这个假设下，我们很自然的构造出如下的目录结构：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先，我们应该会在 &lt;/span&gt;&lt;code&gt;background/index.ts&lt;/code&gt;&lt;span&gt;里初始化我们的 background 功能，在这里开始监听全局所有的消息，再根据消息的某个标识符（这里是 &lt;/span&gt;&lt;code&gt;port.name&lt;/code&gt;&lt;span&gt; ）分发到对应的模块中，由这些模块处理具体的业务逻辑，整个流程和 Redux 很像：&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里使用了 rxjs，很适合处理类似消息这样的场景，当然不用也行，这不是本文的重点&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; { fromEventPattern, merge } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;rxjs&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { module1Processer, observable1 } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;./module1&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { module2Processer, observable2 } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;./module2&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 为了保存不同执行环境发来的消息，考虑到每个 port 生成时机、消息流向等不同，不得不保存外部变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; devtoolPort: chrome.runtime.Port | &lt;span&gt;undefined&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; contentScript: chrome.runtime.Port | &lt;span&gt;undefined&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; pageScriptPort: chrome.runtime.Port | &lt;span&gt;undefined&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 以下 2 个 fromEventPattern，分别处理内部、外部消息&lt;/span&gt;&lt;br/&gt;fromEventPattern&amp;lt;chrome.runtime.Port&amp;gt;(&lt;br/&gt;  &lt;span&gt;&lt;span&gt;handler&lt;/span&gt; =&amp;gt;&lt;/span&gt; chrome.runtime.onConnect.addListener(handler),&lt;br/&gt;  &lt;span&gt;&lt;span&gt;handler&lt;/span&gt; =&amp;gt;&lt;/span&gt; chrome.runtime.onConnect.removeListener(handler)&lt;br/&gt;).subscribe(&lt;span&gt;&lt;span&gt;port&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (port.name === &lt;span&gt;&#x27;devtool&#x27;&lt;/span&gt;) {&lt;br/&gt;   devtoolPort = port;&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  port.onMessage.addListener(&lt;span&gt;&lt;span&gt;message&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;switch&lt;/span&gt; (message.type) {&lt;br/&gt;      &lt;span&gt;// 分发消息到具体的 module&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; module1: { module1Processer() }&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; module2: { module2Processer() }&lt;br/&gt;    }&lt;br/&gt;  });&lt;br/&gt;})&lt;br/&gt;fromEventPattern&amp;lt;chrome.runtime.Port&amp;gt;(&lt;br/&gt;  &lt;span&gt;&lt;span&gt;handler&lt;/span&gt; =&amp;gt;&lt;/span&gt; chrome.runtime.onConnectExternal.addListener(handler),&lt;br/&gt;  &lt;span&gt;&lt;span&gt;handler&lt;/span&gt; =&amp;gt;&lt;/span&gt; chrome.runtime.onConnectExternal.removeListener(handler)&lt;br/&gt;).subscribe(&lt;span&gt;&lt;span&gt;port&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (port.name === &lt;span&gt;&#x27;devtool&#x27;&lt;/span&gt;) {&lt;br/&gt;   devtoolPort = port;&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt; &lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;})&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 有些功能需要整合多个 module 内的数据，放在这里处理&lt;/span&gt;&lt;br/&gt;merge(observable1, observable1).pipe(...).subscribe(...)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在 UI 部分（如 popup ）中，不出意外肯定需要调用 background 的能力，并且监听来自 background 的消息。如果使用 React 来写 UI 的话，我们可能会将这部分功能包装到顶层 Context 里，向下传递：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; { createContext, useState, useRef } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;react&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 手动建立连接&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; port = chrome.runtime.connect({ name: BACKGROUND_MESSAGE_NAME });&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; defaultStore: Store = {&lt;br/&gt;  &lt;span&gt;// 功能 1 的 state&lt;/span&gt;&lt;br/&gt;  module1: {...},&lt;br/&gt;  &lt;span&gt;// 功能 2 的 state&lt;/span&gt;&lt;br/&gt;  module2: {...},&lt;br/&gt;  &lt;span&gt;// 类似 Redux 中的 dispatch，用来传递消息，发送事件&lt;/span&gt;&lt;br/&gt;  dispatch: {&lt;br/&gt;    &lt;span&gt;// 功能 1 的 action&lt;/span&gt;&lt;br/&gt;    module1: &lt;span&gt;(&lt;span&gt;payload&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      port.postMessage({ &lt;span&gt;type&lt;/span&gt;: MessageType.emit, payload: { ...payload, domain: &lt;span&gt;&#x27;module1&#x27;&lt;/span&gt; } });&lt;br/&gt;    },&lt;br/&gt;  &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;};&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; Context = createContext&amp;lt;Store&amp;gt;(defaultStore);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; ContextProvider = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; [store, setStore] = useState(defaultStore);&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; storeRef = useRef(defaultStore);&lt;br/&gt;&lt;br/&gt;  useEffect(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    port.onMessage.addListener(&lt;span&gt;&lt;span&gt;msg&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;// 手动监听事件，根据不同的事件更新不同的 state&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;switch&lt;/span&gt; (msg.type) {&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; MessageType.storeChanged: {&lt;br/&gt;          storeRef.current = {&lt;br/&gt;            ...storeRef.current,&lt;br/&gt;            [msg.payload.domain]: msg.payload.store,&lt;br/&gt;          };&lt;br/&gt;          setStore(storeRef.current);&lt;br/&gt;          &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;          &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;      }&lt;br/&gt;    });&lt;br/&gt;    &lt;span&gt;// eslint-disable-next-line react-hooks/exhaustive-deps&lt;/span&gt;&lt;br/&gt;  }, []);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;    &amp;lt;Context.Provider value={store}&amp;gt;&lt;br/&gt;      &amp;lt;App /&amp;gt;&lt;br/&gt;    &amp;lt;&lt;span&gt;/Context.Provider&amp;gt;&lt;br/&gt;  );&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;export default ContextProvider;&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，在这种代码组织方式下，一旦功能变的复杂起来，会变的很难维护。而每当新增一个功能模块时，都少不了一大堆模板代码（监听消息并派发、UI 中初始化对应 store 等）。类比一下的话，我们在写原生 Redux 时不爽的地方，就是这里会感到不爽的地方。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-id=&quot;2988&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;存在的问题&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过刚才的例子，我们可以看出，在开发 Chrome 扩展程序时，处理不同执行环境下的消息流转是一件很麻烦的事。事实上，执行环境还有很多：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;background&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;popup&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;content-script&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;page-script&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;devtools&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些环境之间互相隔离，通信只能依靠 message。在实际开发过程中，我们遇到了 2 类问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;框架能力缺失：社区中没有针对开发扩展程序的最佳实践，自然也就没有对应的框架能力，导致每个项目、模块之间重复建设或者逻辑混乱，例如如下这些常用模块或功能：&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实际经验缺失：由于不是经常会开发到的场景，在初次上手时踩坑是在所难免的，例如：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;content-script 插入带 iframe 的页面时执行环境错乱（this 指向问题，意外创建多实例等）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Chrome API 在不同执行环境下可用性差异大&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里需要特别强调一下消息机制的问题，这是目前开发扩展程序面临的最大的问题。Chrome 扩展程序本身提供了基于&lt;code&gt;postMessage&lt;/code&gt;的消息传递机制，在实际开发中遇到如下问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;不同执行环境之间，需要区分内部消息和外部消息（如 page-script 和 background 通信），他们的 API 存在差异&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;建立连接的顺序：主动建立连接的一方应该是生命周期较短的一方，但是生命周期在不同的场景下可能完全相反，例如 devtool 和 page-script 之间，完全取决于 devtool 的打开关闭时机&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;并不是任意 2 个执行环境之间都可以直接建立连接，例如 page-script -&amp;gt; content-script -&amp;gt; background -&amp;gt; devtool，当扩展程序慢慢变的复杂起来之后，消息传递路径不明确，排查困难&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;message 传递方式有多种，需要根据实际情况区分使用，例如 page-script -&amp;gt; content-script，即可以使用 chrome 的 API（需要 background 中转），也可以直接使用 &lt;code&gt;window.postMessage&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;单条 message 最大支持的数据大小是有限的，这在大部分开发场景下不是问题，但是如果扩展程序承载的功能对此有要求，那就比较麻烦了&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;message 序列化：同样是一些特殊场景下凸显的问题，消息只能传递可被序列化的数据，导致该场景下需要认真考虑序列化方案，否则带来严重的性能问题，例如：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;循环引用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内存占用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;嵌套&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;类型（object/Map/Set/Regexp/Funtion）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-id=&quot;2988&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;新的开发方式&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;扩展程序中不同执行环境相互隔离这一点无法改变，但是，在每个执行环境中，开发中应该专注于自己的逻辑，不用关心事件注册、逻辑派发、公共方法调用等这些通用能力，这些东西都应该交给框架去做。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总体上来说，新的方式下，业务逻辑通过继承特定的类，获取到父类上的公共方法，这些公共方法中包装好了关于消息、日志等的逻辑，可供直接使用。基于这个想法，我们可以设计出新的编写形式：&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;module1/background.ts&lt;/code&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; rxjs &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;rxjs&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { Background } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;browser-extension-kit/background&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { subject, observable } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;browser-extension-kit&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyBackground &lt;span&gt;extends&lt;/span&gt; Background {&lt;br/&gt; &lt;span&gt;constructor&lt;/span&gt;(&lt;span/&gt;) {&lt;br/&gt;    &lt;span&gt;super&lt;/span&gt;();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 对 myObservable1$ 额外的处理逻辑&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.myObservable1$.subscribe(&lt;span&gt;&lt;span&gt;data&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;// do something with data&lt;/span&gt;&lt;br/&gt;    });&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;// 订阅消息&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.on(&lt;span&gt;&#x27;messageID&#x27;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;message&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;     &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;    });&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 接受外界传来的 id 为 &#x27;uniqueID&#x27; 的消息，并且自动转化为 mySubject 的下一个值&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;@subject&lt;/span&gt;(&lt;span&gt;&#x27;uniqueID&#x27;&lt;/span&gt;) &lt;span&gt;private&lt;/span&gt; mySubject = &lt;span&gt;new&lt;/span&gt; rxjs.Subject&amp;lt;&lt;span&gt;number&lt;/span&gt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 通过 @observable.popup 来声明当 myObservable1$ 发出一个值时，自动通过消息传递给 popup&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 这个消息的默认 id 为 &#x27;MyBackground::myObservable1$&#x27;，可自定义&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;@observable&lt;/span&gt;.popup &lt;span&gt;private&lt;/span&gt; myObservable1$ = rxjs.from(...).pipe(&lt;br/&gt;    rxjs.shareReplay(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;  );&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 当多个环境都需要订阅这个消息时，可以使用 @observable([&#x27;background&#x27;, &#x27;popup&#x27;])&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;@observable&lt;/span&gt;([&lt;span&gt;&#x27;background&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;popup&#x27;&lt;/span&gt;]) &lt;span&gt;private&lt;/span&gt; myObservable2$ = rxjs.concat(&lt;br/&gt;    rxjs.from(...),&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.mySubject&lt;br/&gt;  ).pipe(&lt;br/&gt;    rxjs.shareReplay(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;  );&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;module1/popup.tsx&lt;/code&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 popup、devtools 等环境中，通常都是一个 React 组件，这种情况下，框架提供了相应的 hooks 来帮助实现逻辑：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; React  &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;react&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { useMessage, usePostMessage } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;browser-extension-kit/popup&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; App = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; active = useMessage(&lt;span&gt;&#x27;MyBackground::active$&#x27;&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; port = usePostMessage();&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; toggleActive = useCallback(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    port.background(&lt;span&gt;&#x27;MyBackground::active&#x27;&lt;/span&gt;, !active);&lt;br/&gt;  }, [port]);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;    &amp;lt;div&amp;gt;&lt;br/&gt;      active: {active}&lt;br/&gt;   &amp;lt;button onClick={toggleActive}&amp;gt;click me&amp;lt;&lt;span&gt;/button&amp;gt;&lt;br/&gt;    &amp;lt;/&lt;/span&gt;div&amp;gt;&lt;br/&gt;  );&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; App;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-id=&quot;2988&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;实现方式&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5594974131559497&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QRibyjewM1IDFSXtDKxJq496uG4ZQvgzPj2qsXHnJrTyQ0sfFwMGdFjfrKiaQ1twRm7UnVjr289CaSic4GPwKB6dg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2706&quot;/&gt;&lt;br/&gt;可以猜到，如果要使用上述新的开发方式，核心是要在各个基类中内置处理消息的逻辑，background 负责所有消息的接受和转发，这一点依然不变，对外只暴露处理好的消息即可：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先，每当 content-script/page-script/devtools/popup 加载时，框架会自动向 background  建立连接，每一个 context 下，只会建立一次连接，连接建立后的 port 会存储在中心化的 port hub 内&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;针对每个 port，系统会自动对其订阅消息，这里的 port 和 port 内的 message，全部由框架接管，不对外暴露&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有的时候，开发者希望向某个 context 发送消息，但是对应的 context 还没有加载，考虑到这种情况，框架内部使用 rxjs 的 ReplaySubject  来中转 port 产生的 message，这样保证当一个 context 加载后，可以立即获取到加载前向这个 context 发送的消息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;background 还会生成一个 dispatcher，用来分发消息。由于所有的消息都汇集到 background 中，dispatcher 会检查每个消息的接受方，如果是 background ，则直接派发给对应的处理者，如果是其他 context，则调用 port 将该消息传递给对应的 context&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后，每个 context 初始化时，也会生成一个 controller，这个 controller 订阅 ReplaySubject， 用来真正处理属于自己的 message&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-id=&quot;2988&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事实上，在这种方案下，所有的消息都会由 background 中转一下，在一定程度上造成了性能损失，这也算是在简洁和性能之间的一种取舍。而对于 devtools 和 popup 这 2 个 UI 的部分，目前只考虑了在 React 下的场景。此外，虽然监控、埋点、鉴权等也是较为通用的功能，但是不同的业务也存在着不同的诉求，所以这一部分无法集成到框架中，需要业务自行实现。如果符合你的口味，可以直接安装体验一下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npm i browser-extension-kit -S&lt;br/&gt;&lt;span&gt;// or&lt;/span&gt;&lt;br/&gt;yarn add browser-extension-kit&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更多使用方式和 API 可在 https://github.com/alibaba/browser-extension-kit 查看，如果感兴趣，欢迎一起交流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg4MjE5OTI4Mw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/QRibyjewM1IBw49BrMXhuGAyhmAKA0jiabJkQx7dXYbRWRSffHNGyahxmAdToib28VaTjzFqyMKgcnvA4iaiczGy3ug/0?wx_fmt=png&quot; data-nickname=&quot;Alibaba F2E&quot; data-alias=&quot;alibabaf2e&quot; data-signature=&quot;阿里巴巴前端官方公众号&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;关注&lt;/span&gt;&lt;span&gt;「Alibaba F2E」&lt;/span&gt;&lt;span&gt;微信公众号&lt;/span&gt;&lt;span&gt;把握阿里巴巴前端新动向&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>492648e91b5b0f73105be2abc7dbcc42</guid>
<title>2022 年升职加薪就靠它了！抓紧时间！</title>
<link>https://toutiao.io/k/fitvcz1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                              &lt;strong class=&quot;profile_nickname&quot;&gt;开发者头条&lt;/strong&gt;
                              &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;kaifazhetoutiao&lt;/span&gt;
                              &lt;/p&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;程序员分享平台 | 官方应用下载地址：http://toutiao.io/download&lt;/span&gt;
                              &lt;/p&gt;
                              
                          &lt;/div&gt;
                          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>649838f5d1510ea5ad680394a009e6c7</guid>
<title>2022年之WEB开发新基准</title>
<link>https://toutiao.io/k/82apco8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;本文译者是360奇舞团前端开发工程师&lt;/p&gt;&lt;p&gt;原文标题：The baseline for web development in 2022&lt;/p&gt;&lt;p&gt;原文作者：Alan Dávalos&lt;/p&gt;&lt;p&gt;原文地址：https://engineering.linecorp.com/en/blog/the-baseline-for-web-development-in-2022/&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;概要:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2022年网页开发的基准将会是:性能方面的低版本Android设备，标准方面的Safari(从两年前迄今为止的版本)，以及网络方面的4G。一般来说，网络并没有很好地满足这些需求，特别是在性能方面，&lt;strong&gt;过度依赖JavaScript等因素阻碍了我们网站的性能&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你好!我是Alan Dávalos, LINE的前端工程师。你可能认为这篇文章的只是标题党，但请耐心听我讲一下，我保证这是值得的。主要原因是，在2021年至2022年之间，网络发生了一些重大变化，这些变化影响了我们应对网络发展的整体方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，今天我想通过分析许多不同维度的数据来剖析这些变化，以及我们作为web开发者如何适应它们。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2021年最大的变化是ie浏览器的&quot;淘汰&quot;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然2021年发生了很多变化，但没有一个比&lt;span&gt;IE正式&quot;退役&quot;&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;更大的变化。微软在2021年5月宣布了这一消息，到8月，包括微软365在内的许多微软产品都正式放弃了对IE的支持。IE的正式退役日期定于2022年6月，但还有其他几个原因可以让我们认为IE现在已经完全&quot;淘汰&quot;了。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;一些大型网站放弃了对IE的支持&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在微软宣布这一消息后，许多其他项目开始放弃对IE的支持。这其中包括很多包含海量用户的大型网站:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，谷歌搜索在2021年10月放弃了对IE的支持。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，WordPress还宣布，他们会在2021年7月发布的WordPress 5.8版本中放弃对IE的支持。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;IE目前的市场份额&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;IE的市场份额在2021年大幅下降&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2021年全球浏览器市场份额分布:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6183333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cAd6ObKOzECH0vcpB21uS9hPFrJYIMiclotlqEbr3ZsEJ4hianyKvBx4aQauibTzhT9VmgBDk0IL6ia8vrzBrqQMAg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在全球范围内，IE目前的市场份额不到0.5%。即使是在IE市场份额高于其他国家的日本，IE的市场份额也接近2%，并且有下降的趋势。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;web开发的新基准&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到目前为止，由于IE的市场份额，我们一直支持它。但是现在，基本上没有什么好的理由继续支持IE。然而，这带来了一个新问题，IE是许多工具的支持基线。IE的开发已经停止了很长一段时间，所以它所支持的web标准与现代浏览器所支持的web标准非常不同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在IE消失了，基线变得模糊了。因此，我将通过分析我们用户设备的当前状态来定义一个新的基线。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;用户的设备和浏览器&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;浏览器和操作系统的市场份额&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让我们以不同的格式来看看浏览器市场份额图表:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6183333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cAd6ObKOzECH0vcpB21uS9hPFrJYIMiclhTlkCU2n5Usqg0dCedJUK69rTp9kr6HG0qCqWicAibrnib4jM2b3HibOXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我想强调几种趋势,换言之，我们至少需要支持以下3个浏览器引擎:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Chrome, Edge -- 三星网络浏览器和Opera的基础。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Gecko -- Firefox的基础。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;WebKit -- Safari的基础。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;浏览器与网络标准的一致性&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在不同的浏览器中，最影响web开发的部分是它们实现了不同的web标准。如上所述，我们应该关注3种浏览器引擎。那么，让我们来看看这些不同的浏览器是如何实现网络标准的。检查这些差异的最简单的方法是使用下面的Web平台测试数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Web平台仅一个浏览器不通过测试(其余浏览器测试通过):&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6183333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cAd6ObKOzECH0vcpB21uS9hPFrJYIMiclCFyaboXJx3UB4yv0gQfJAI9g5MPqM5vfls2EbIuMM8dtGRV7Egbg6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;**注:**上图来源为:&lt;span&gt;&quot;Browser Specific Failures&quot;&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;-摘自2021年12月4日&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此图表显示了仅在一个浏览器中失败的Web平台测试的数量。换句话说，其他两个浏览器已经实现了多少特性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很明显我们可以看到，只有Safari还没有实现的网络标准的数量比Firefox和Chrome多很多倍。准确地说，是火狐的&lt;strong&gt;2.4&lt;/strong&gt;倍，Chrome的&lt;strong&gt;4.7&lt;/strong&gt;倍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，我们还应该考虑到Safari和iOS之间的密切关系。具体来说，有两点:&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;其他移动浏览器的更新独立于操作系统，而Safari只有在iOS更新时才会更新。新版本的iOS不再支持的iOS设备不能更新到最新版本的Safari。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;iOS中的所有浏览器都是基于Webkit的:iOS中有Chrome和Firefox版本，但它们使用的引擎与iOS中的Safari相同。这是因为苹果有一条规定，即所有iOS浏览器都必须使用Webkit。iOS和Safari之间的这种关系也意味着我们必须检查iOS版本的市场份额随着每一个新的主要iOS版本的发布而发生的变化。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;iOS主要版本的季度市场份额如下:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6100217864923747&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cAd6ObKOzECH0vcpB21uS9hPFrJYIMiclic40GJdrb6sxX1V8feExBjEnTYc5b1HIY1tes15UGsrYyam4sriaDO3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;918&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了更深入地了解每个iOS版本的市场份额是如何变化的，让我们来看看iOS 12在过去2年的市场份额变化:&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从2019年第一季度到第三季度，iOS 12的份额逐渐增长，但随着iPhone 11和iOS 13在第三季度的发布，这一数字直线下降。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从那以后，iOS 12的市场份额在接下来的一年里下降到了20%以下。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后，在2020年第三季度iPhone 12和iOS 14发布后，iOS 12的份额急剧下降，到2021年第二季度，它的份额微不足道。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在iOS 12上发生的同样的情况也出现在后来的版本13和14上。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;综上所述，我们可以肯定的是，在过去2年里，iOS市场份额将持续占据90%以上。换句话说，我们只需要支持过去两年发布的Safari版本。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;移动端网络状况分析&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到目前为止，我们主要谈论的是设备和浏览器，但现在让我们看看一个对用户体验有很大影响的因素，而web开发者却没有影响:网络连接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当连接到Wi-Fi网络时，连接基本上是稳定的，但移动网络就不是这样了。让我们来看看移动网络的现状。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3G 和 4G&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当使用诸如Lighthouse之类的测试工具时，网络可以被用来模拟3G，但是最近全球的移动网络都发生了变化。根据&lt;span&gt;Opensignal 2020年5月的一份报告&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;，全球4G的平均可用性为86.8%。因此，我们可以放心地假设，全球大多数用户都可以接入4G网络。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5G&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然而，5G网络仍远未成为现实。根据&lt;span&gt;Opensignal 2021年11月的一份报告&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;，全球5G可用性最高的国家只有韩国的29.1%。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新的基准线是什么?&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;考虑到上述所有数据，web开发的新基线将是:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Safari是网络标准的基准:我们开发的站点必须在至少2年前的Safari版本中运行。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;低端Android设备是性能的基准:低端Android设备在过去几年中几乎没有进步，所以我们必须确保我们的站点具有不错的性能。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;4G是网络的基准:近年来，全球范围内的移动网络已经变得更快、更稳定。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;我们在多大程度上满足了用户需求?&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们已经成功地定义了构成基线的3个部分，但这还不够。我们需要看看我们在多大程度上满足了用户的需求。然而，深入的分析会为不同的项目带来不同的结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;考虑到这一点，我将进一步分析整个网络。幸运的是，我们有一个很好的数据来源，&lt;span&gt;2021年网络年鉴&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;。这是由HTTP Archive创建的年度报告。在这份报告中，他们分析了超过820万个网站，创建了24个章节。在本文中，我们将从这些章节中选取一些数据，看看当前的网络与上述定义的基线匹配得如何。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2021年网站的中位数&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2021年的网站体积的中位数为1923 KB。如果我们按文件类型划分大小，我们可以看到图像和JavaScript占据了大部分的比例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按文件类型划分的网站size中位数:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6183333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cAd6ObKOzECH0vcpB21uS9hPFrJYIMicldsnUrJ65Dmw6ibZE65x6k42f4Hc31KPYUgWhFeMTIesxqHTGomBIaNg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面这些数据，我们很清晰地看到在图像处理(image资源)占据了最大的比例，但我们更应该特别注意JS的大小。因为处理图像不像处理JS那么复杂。图像基本上可以被渲染，只要他们被下载，但JS需要被解析和执行。所以，一般来说，JS的处理会占用更多的资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，根据&lt;span&gt;Alex Russell上面提到的文章&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt;，当在4G网络上测试一个低级Android设备时，一个网站要保持良好的性能，需要100kb的HTML和CSS以及350kb的JS。换句话说，当前的中位数站点在HTML和CSS方面满足了性能预算，但&lt;strong&gt;在JS方面却远远超过了预算&lt;/strong&gt;。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;HTML和CSS的使用情况分析&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网页年鉴中有一章同时介绍了&lt;span&gt;HTML&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;和&lt;span&gt;CSS&lt;/span&gt;&lt;sup&gt;[8]&lt;/sup&gt;，其中包含了大量的信息。我想强调几个关键的数据点，我认为它们可以用来举例说明我们目前是如何使用HTML和CSS的。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;HTML&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让我们先来谈谈HTML，目前有&lt;span&gt;112个未弃用的HTML元素&lt;/span&gt;&lt;sup&gt;[9]&lt;/sup&gt;。但是页面中使用的HTML元素的中位数是31。显然，没有必要在所有页面中使用每个元素，但是这31个元素包括诸如html标签、body标签和script标签。这意味着我们用来显示内容的元素数量实际上更少了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在最常用的HTML元素列表中,div标签第一名，span 标签第三名,p标签第七名。此外，页面有98.9%的概率是div标签,div肯定是最常用来显示内容的元素。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相比之下，main元素被使用的概率只有27.9%。这之所以重要，是因为，相比于aside以及header等其他元素，main元素是没有应用特殊样式但具有语义化的元素之一。换句话说，main标签的使用可以作为一个指示器，指示有多少页面主动使用语义化元素。这就是27.9%这个数字如此重要的原因。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;CSS&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于CSS的使用，我认为有一个数据点可以很好地总结CSS的使用，这就是现代布局特性的使用:Flex和Grid的使用率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Flex和Grid的使用率:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6183333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cAd6ObKOzECH0vcpB21uS9hPFrJYIMicl043iajOqj41j2o2fcl8PfzmVmXA1Ar8ib9FEfK8YCntVMwxk3NrXickWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正如你所看到的，虽然71%的页面使用了Flex，但只有8%的页面使用了Grid。造成这种差异的最大原因在于对IE的支持。&lt;span&gt;IE只支持旧的Grid规范&lt;/span&gt;&lt;sup&gt;[10]&lt;/sup&gt;，所以想要支持IE的页面必须考虑到这一点。CSS特性不能像JS特性那样容易填充。这可能是许多开发人员放弃使用Grid的主要原因。然而，现在我们可以减少对IE的支持，许多例如Grid之类的现代CSS特性就可以考虑使用。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;性能&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前最常用的性能测量方法是通过&lt;span&gt;测量核心指标Web Vitals (CWV)&lt;/span&gt;&lt;sup&gt;[11]&lt;/sup&gt;。采用这个测量方法的原因是&lt;span&gt;CWV被用作谷歌搜索的排名因素可能是最大的一个&lt;/span&gt;&lt;sup&gt;[12]&lt;/sup&gt;。让我们看看网络在CWV方面的表现如何。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CMV分数良好的页面百分比:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6183333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cAd6ObKOzECH0vcpB21uS9hPFrJYIMiclhDUiayhVds1RguBUVPVTaRMZup9j8EYicicznEzs3RBbaxUBaTiaiauzgxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总的来说，性能不是很好，超过一半的页面CWV分数很差。考虑到不同设备之间的CPU性能差异，移动端页面在12%的时间里比桌面页面得分低似乎是合理的。这个结果也与大多数站点的JS体积大小高于性能预算的事实相一致。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还可以在下一张图表中看到，性能直接影响用户的数量:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6183333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cAd6ObKOzECH0vcpB21uS9hPFrJYIMiclGUueLaVAcY3Ztuyxw1iaiangnt1e0wfRku53icYEVp7CObyQ3Wdic2D2Rw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以看到，良好的CWV分数与浏览量之间存在相关性。也许部分是受CWV是谷歌搜索排名因素的影响。在浏览量排名前1000位的网站中，有37%的CWV得分良好，而总体得分为32%。当查看排名前1万或10万的网站时，我们可以看到，在浏览量方面排名更高的网站往往有更好的性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以毫不夸张地说，提升网站性能是我们可以直接增加项目收入的方法之一。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;JS库和框架&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到目前为止，我们已经看到我们服务的JS数量对我们网站的性能产生了不良影响。大多数使用大量JS的项目都会以某种方式使用库或框架。那么，让我们来看看这种过度依赖框架库的选择可能带来的后果。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;JS库和框架的使用情况&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据&lt;span&gt;网络年鉴的JS章节&lt;/span&gt;&lt;sup&gt;[13]&lt;/sup&gt;，使用最多的库是jQuery，使用率为84%。我们上面提到的大约33%的网站都使用WordPress，这是其中一个重要原因。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在众多框架中，React最受欢迎，占8%。但是如果你认为其他框架甚至没有达到4%的标志，那么你可以说其他框架的使用仍然是占据极少数。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;比较框架性能&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然框架仍然是少数，但我们有足够的数据来比较最流行的框架的性能。本节的数据来自&lt;span&gt;Tim Kadlec的这篇2020年的文章&lt;/span&gt;&lt;sup&gt;[14]&lt;/sup&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5084745762711864&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cAd6ObKOzECH0vcpB21uS9hPFrJYIMiclUHuXWNiajPhuIUYg0rvfKHadmt036qibIxwUkVr37Ania4941t9onl7sw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;885&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，我们将使用React、Angular、Vue和jQuery的站点的JS大小与常规数据进行比较：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;总体数据和jQuery的中位数分别为414KB和430KB。这个数字接近2021年的中位数。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;然而，Vue和React的中位数都在690 KB左右。超过总中位数250 KB。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Angular更高，达到1066KB，它是第一个&lt;span&gt;超过1MB&lt;/span&gt;的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;即使看第10个百分位，情况也是相似的：第10个百分位的总大小是93KB，jQuery是110KB，Vue是245KB，React是348KB，Angular是445KB。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;换句话说，即使是使用JS最少的框架的站点，也几乎无法达到上面设定的性能预算。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，虽然JS大小是性能的一个重要指标，但它肯定不是全部。现在，让我们深入了解一下这些站点在实际设备中的表现。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5084745762711864&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cAd6ObKOzECH0vcpB21uS9hPFrJYIMicliauahkX16OUr1NvQRMGB7UjxDZ7OdiamUZTFGXynU4rWXGcp4kY2eALg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;885&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;为了公平起见，不包括使用多个库或框架的站点。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;看看jQuery和Vue的中值时间，它们分别是2.3秒和3.2秒。通过简单的数学计算，尺寸差的比率与时间差的比率非常接近。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;然而，React和Angular并没有遵循同样的趋势。Angular的中值时间是3.7秒，而React的中值时间要慢一些，为10.1秒。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;很明显，在比较JS库时，大小并不是唯一重要的指标。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;比较静态站点(SSG)中的框架性能&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;框架经常用于创建单页应用程序（SPA），但也用于创建静态站点。让我们比较一下使用框架的静态站点生成器（SSG）和不使用JS框架的SSG的性能。我们将比较实际可检测到使用情况的&lt;span&gt;排名前五的SSG框架&lt;/span&gt;&lt;sup&gt;[15]&lt;/sup&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按SSG划分的js资源体积中位数:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6183333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cAd6ObKOzECH0vcpB21uS9hPFrJYIMicl0uOjXZujd5sfXK25yCIHfL2kHnRUcyWk5mVqhcbA1m4WDbfbTl87cA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;基于React的Gatsby和Next.JS体积中位数和基于Vue的Nuxt.js的大小都在700 KB左右，这个数字与React和Vue的中位数大致相似。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;相比之下，基于Go的Hugo和基于Ruby的Jekyll分别为177KB和129KB。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;基于JS框架的SSG比不基于JS的SSG提供的JS平均超过500KB。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然我们提到了JS大小并不是性能的全部，那么让我们看看移动端网站CWV分数之间的差异:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6183333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cAd6ObKOzECH0vcpB21uS9hPFrJYIMiclFeJjo6qtyk0q1iaibkWfJ6vA1K76dm0CdRIkFfBLRnHTUm2Gug4UJS9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Next.js和Nuxt。js的CWV得分低于15%。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Gatsby占比高，为21.9%。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;非基于框架的Hugo和Jekyll在CWV方面的得分分别为31.8%和34.3%。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;不使用JS框架的SSG的CWV分数百分比高于总体平均水平。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;通过实验测试比较框架性能&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到目前为止，我们已经查看了三种最流行的框架的使用数据，并比较了它们的性能。然而，除了这三个框架之外，还有许多其他框架。考虑到这一点，让我们将这三个框架与其他一些框架进行比较，这些框架可能没有被充分使用，无法出现在网络年鉴中，但它们是最受欢迎的框架之一。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;这些比较的数据来自实验室测试，在实际项目中使用时，性能可能会有所不同。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;添加到比较中的框架是作者认为最具动力的框架之一。通过查看每次比较的数据源，可以看到与其他框架的比较。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4831130690161527&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cAd6ObKOzECH0vcpB21uS9hPFrJYIMiclyp6SvDGPISJoL0OAVYrkmeADLQgZcRLwrCoL8UoyHtnicvvytd3RrTQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;681&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上表将框架与手动优化的Vanilla JS实现进行了三个主要方面的比较:DOM操作、启动和内存分配。从中我们可以观察到以下几点:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;React和Angular的平均性能是Vanilla JS的两倍。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;相比之下，Vue实际上更接近Preact和Stencil，平均为1.5倍。这个结果和我们在Web年鉴中看到的报告之间的差异的主要原因可能是由于Vue在3.0版本发布时的性能改进。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;最后，Solid、Lit以及Svelte都是1.2倍左右。它们的性能都非常接近Vanilla JS版本。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;IE显然影响了这些结果。你可能会问:“为什么要提IE?”为此，我们必须回顾一下框架和JS标准的历史。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以说，Edge在2015年发布后，IE的新开发基本上停止了。那一年也是ES 2015(或ES6)标准出台的一年;这可以说是JS历史上最大的革命。ES 2015包含了Promise和箭头函数等功能。后来的版本开始向JS添加更多的特性，可以用更少的代码实现更多的事情。换句话说，因为ES 2015之前的世界开发的东西与为ES 2015以后的世界开发的东西有很大的不同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上表中，性能最差的是Angular和React。这两个框架和Vue是唯一在2015年之前发布第一个版本的框架。换句话说，他们的表现差异可以归因于他们发展的时代。这条规则似乎不适用于Vue的原因是，如上所述，Vue 3.0为了提高性能改变了很多内部代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一种方法可以完全理解上面提到的区别:比较Solid、Preact和React。Solid和Preact深受React的影响。在Preact的例子中，他们甚至有一个兼容模块来使用React代码作为Preact代码。但从上面的表中可以看出，Solid和Preact在每一个参数上都优于React。这意味着React的性能问题并不在于它的理念或你为React编写代码的方式。它们存在于React的内部。确切地说，在React的虚拟DOM和合成事件系统实现中，这两者都需要对IE进行很多考虑。Preact和Solid更喜欢使用默认api，而不是使用现代浏览器中可用的api。这可能是性能差的最大原因。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，让我们再看一张图表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用相同库的30个组件的包大小:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6183333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cAd6ObKOzECH0vcpB21uS9hPFrJYIMiclreTc1iaPfozAFOHQMonobsDOMx4oyoAQ4SBibmm0uFibpVBskh3ia6REbw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个图表比较了前面提到的大多数框架的不同指标:用同一个框架创建30个组件时的包大小。通过这种比较，我们可以模拟这些框架在创建完整应用程序时是如何工作的。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;React最终以45.45 KB的大小再次成为最大的，但就实际开发代码而言，它是最小的，只有9.26 KB。只是因为React框架自身的体积比其他框架体积大而已。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Vue在3.0版本中做了很多改进，但它的大小仍然是其他库的两倍，为32.65 KB。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;其他框架最终的大小都差不多，都在14-18 KB范围内。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;可访问性(Accessibility,简称a11y)&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们已经讨论了很多关于用户设备的内容，现在让我们来谈谈用户本身。据世界卫生组织统计，有超过&lt;span&gt;全世界约有10亿人患有不同程度的残疾&lt;/span&gt;&lt;sup&gt;[16]&lt;/sup&gt;。世界上有许多不同类型的残疾和缺陷人士，但其中许多都会影响用户与设备的交互方式。我们通常使用术语无障碍(a11y)来指确保残疾用户能够完全与我们的网站交互所需要的操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然而，a11y并不仅仅适用于残疾人。促进a11y的行动对每个用户的用户体验都有积极的影响。造成这种情况的主要原因是情境障碍。一些情景障碍的例子包括试图用一只手在吃东西或喝东西时使用手机，或者设备设置在一小时后在屏幕上设置一个黑白滤镜来改善睡眠质量。面对这些情境障碍的用户将能够像往常一样使用在设计时考虑到a11y的页面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，网站若是存在糟糕可访问性也可能招致法律问题。根据法律的规定，用户甚至可以起诉那些&quot;糟糕可访问性&quot;的网站。一些著名的案例包括国际巨星&lt;span&gt;碧昂丝和达美乐披萨(Domino’s Pizza)因视觉障碍用户无法访问而被起诉&lt;/span&gt;&lt;sup&gt;[17]&lt;/sup&gt;。因此，没有合适的a11y也可能会让你付出惨痛代价。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;网络的可访问性如何?&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在让我们来看看网络的可访问性。为此，我们将从&lt;span&gt;《网络年鉴》的a11y章节&lt;/span&gt;&lt;sup&gt;[18]&lt;/sup&gt;中取出一些具有代表性的数据。如果你想要更深入地了解，这里还有更多的数据点。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;77.8%的网站背景和字体颜色对比度不佳。这意味着，一些视力受损的用户和使用上面提到的过滤器的用户可能不能完全使用80%的网络。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;29.4%的网站阻止缩放。现在有些浏览器忽略了这个设置，但这仍然是一个很大的数字。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;42%的网站标题排列不当。例如使用h2元素而不使用h1元素。这种无序可能会导致问题，特别是对于使用辅助技术的用户。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;29%的网站使用role=&quot;button&quot;。有些人可能认为拥有这个role=&quot;button&quot;和一个事件监听器就足够了，但是按钮还必须响应键盘事件并具有适当的焦点处理。虽然您可以使用JS实现这一点，但如果您只使用button标签的话，则根本不需要JS。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;32.7%的站点有没有可访问标签的输入元素。换句话说，它们没有关联的标签元素、aria-label属性或其他任何东西。这是令人担忧的，因为你可能会因此而承担损失。例如，如果信用卡输入没有标记，可能会有想买东西但不知道在哪里编写所需信息的用户。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;结论&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后让我们看一下结论:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;WEB开发并没有百分百满足用户的需求:特别是在性能和其他方面。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;WEB开发过度使用JS:无论是在依赖关系中还是在我们自己的代码中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;WEB开发没有充分使用HTML和CSS:这部分是由于IE的支持，但现在我们不需要支持IE，有许多特性变得可用。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有一些建议，可以帮助那些想要改善WEB体验和性能的前端工程师们:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果你可以用CSS做一些事情，那就用CSS:有很多以前只能用JS完成的事情，现在只能用CSS完成。这样做可以在一定程度上减少JS代码。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;解放思想，不要为旧的思维定式所禁锢&lt;/strong&gt;: 在做技术选型，需要拓宽视角。与旧的工具相比，许多新的工具具有更好的性能，&lt;strong&gt;并且不是每个项目都需要SPA&lt;/strong&gt;。一些非基于框架的SSG技术，如Hugo、Jekyll或11ty，也许会更适合这些场景。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;为现代浏览器构建: &lt;strong&gt;放弃IE支持&lt;/strong&gt;，将构建目标设置为ES 2017甚至2018。这样做可能会让你的Bundle大小减少20%以上。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;全面思考问题: 在规划和设计阶段就将所有因素考虑在内是最理想的方案。从提高对比度、字体大小、语义化HTML的使用和键盘导航等方面入手，可以带来很明显的改善效果。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;IE正式&#x27;退役&#x27;: &lt;em&gt;https://blogs.windows.com/windowsexperience/2021/05/19/the-future-of-internet-explorer-on-windows-10-is-in-microsoft-edge/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;Browser Specific Failures: &lt;em&gt;https://ecosystem-infra.github.io/wpt-results-analysis/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;Opensignal 2020年5月的一份报告: &lt;em&gt;https://www.opensignal.com/sites/opensignal-com/files/data/reports/pdf-only/data-2020-05/state_of_mobile_experience_may_2020_opensignal_3_0.pdf&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;Opensignal 2021年11月的一份报告: &lt;em&gt;https://www.opensignal.com/2021/11/30/benchmarking-the-global-5g-experience-november-2021&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;Opensignal 2021年11月的一份报告: &lt;em&gt;https://almanac.httparchive.org/en/2021/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;Alex Russell上面提到的文章: &lt;em&gt;https://infrequently.org/2021/03/the-performance-inequality-gap/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[7]&lt;/span&gt;&lt;p&gt;HTML: &lt;em&gt;https://almanac.httparchive.org/en/2021/markup&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[8]&lt;/span&gt;&lt;p&gt;CSS: &lt;em&gt;https://almanac.httparchive.org/en/2021/css&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[9]&lt;/span&gt;&lt;p&gt;112个未弃用的HTML元素: &lt;em&gt;https://html.spec.whatwg.org/multipage/indices.html#elements-3&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[10]&lt;/span&gt;&lt;p&gt;IE只支持旧的Grid规范: &lt;em&gt;https://caniuse.com/css-grid&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[11]&lt;/span&gt;&lt;p&gt;测量核心指标Web Vitals (CWV): &lt;em&gt;https://web.dev/vitals/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[12]&lt;/span&gt;&lt;p&gt;CWV被用作谷歌搜索的排名因素可能是最大的一个: &lt;em&gt;https://developers.google.com/search/blog/2020/11/timing-for-page-experience&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[13]&lt;/span&gt;&lt;p&gt;网络年鉴的JS章节: &lt;em&gt;https://almanac.httparchive.org/en/2021/javascript#libraries-usage&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[14]&lt;/span&gt;&lt;p&gt;Tim Kadlec的这篇2020年的文章: &lt;em&gt;https://timkadlec.com/remembers/2020-04-21-the-cost-of-javascript-frameworks/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[15]&lt;/span&gt;&lt;p&gt;排名前五的SSG框架: &lt;em&gt;https://almanac.httparchive.org/en/2021/jamstack#which-ssgs-are-the-most-popular&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[16]&lt;/span&gt;&lt;p&gt;全世界约有10亿人患有不同程度的残疾: &lt;em&gt;https://www.who.int/news-room/fact-sheets/detail/disability-and-health&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[17]&lt;/span&gt;&lt;p&gt;碧昂丝和达美乐披萨(Domino’s Pizza)因视觉障碍用户无法访问而被起诉: &lt;em&gt;https://www.forbes.com/sites/jackgarson/2020/02/25&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[18]&lt;/span&gt;&lt;p&gt;《网络年鉴》的a11y章节: &lt;em&gt;https://almanac.httparchive.org/en/2021/accessibility&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>