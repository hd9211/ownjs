<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>3fbb6d11de8c4031ee549c0bf35c3cff</guid>
<title>2022过虎年新年春节大门立体对联大礼包，点击链接立即领取红包！</title>
<link>https://toutiao.io/k/mfp3pig</link>
<content:encoded>&lt;div&gt;&lt;body data-spm=&quot;10720394/n&quot; id=&quot;readabilityBody&quot;&gt;
    
    
    
    
    
    
      
      
    
    
    
    
    
  &lt;/body&gt;
&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c818ac75b54a17047499a165f5c3f8ea</guid>
<title>[推荐] 据说看完这篇 JVM 要一小时</title>
<link>https://toutiao.io/k/1dauixx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;JVM 的主要作用是什么？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;J&lt;/span&gt;&lt;span&gt;VM 就是 Java Virtual Machine（Java虚拟机）的缩写，JVM 屏蔽了与具体操作系统平台相关的信息，使 Java 程序只需生成在 Java 虚拟机上运行的目标代码 （字节码），就可以在不同的平台上运行。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;请你描述一下 Java 的内存区域？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JVM 在执行 Java 程序的过程中会把它管理的内存分为若干个不同的区域，这些组成部分有些是线程私有的，有些则是线程共享的，Java 内存区域也叫做运行时数据区，它的具体划分如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7437092264678472&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmH9aGibGUjlxTy3le1caYkicpKl6nB2tvY37G39bUyIGSu4mzoScJZPbQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1073&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;虚拟机栈&lt;/code&gt; : Java 虚拟机栈是线程私有的数据区，Java 虚拟机栈的生命周期与线程相同，虚拟机栈也是局部变量的存储位置。方法在执行过程中，会在虚拟机栈中创建一个 &lt;code&gt;栈帧(stack frame)&lt;/code&gt;。每个方法执行的过程就对应了一个入栈和出栈的过程。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.7777777777777777&quot; data-type=&quot;jpeg&quot; data-w=&quot;315&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYm3dmdg7jW9BViaBNL5Z449GBOuMDwXfPPjiaSfQDnnTVSFiaO7Yvk0k8vQ/640?wx_fmt=jpeg&quot; class=&quot;rich_pages wxw-img&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;本地方法栈&lt;/code&gt;: 本地方法栈也是线程私有的数据区，本地方法栈存储的区域主要是 Java 中使用 &lt;code&gt;native&lt;/code&gt; 关键字修饰的方法所存储的区域。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;程序计数器&lt;/code&gt;：程序计数器也是线程私有的数据区，这部分区域用于存储线程的指令地址，用于判断线程的分支、循环、跳转、异常、线程切换和恢复等功能，这些都通过程序计数器来完成。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;方法区&lt;/code&gt;：方法区是各个线程共享的内存区域，它用于存储虚拟机加载的 类信息、常量、静态变量、即时编译器编译后的代码等数据。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;堆&lt;/code&gt;：堆是线程共享的数据区，堆是 JVM 中最大的一块存储区域，所有的对象实例都会分配在堆上。JDK 1.7后，字符串常量池从永久代中剥离出来，存放在堆中。&lt;/p&gt;&lt;p&gt;堆空间的内存分配（默认情况下）：&lt;/p&gt;&lt;p&gt;命令行上执行如下命令，会查看默认的 JVM 参数。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;java -XX:+PrintFlagsFinal -version&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出的内容非常多，但是只有两行能够反映出上面的内存分配结果&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.026957637997432605&quot; data-type=&quot;jpeg&quot; data-w=&quot;1558&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmTE6mPvUkFS94GmjBPr6O6bibMdpkFjGVUZsNxDUoYwW0mxQMpfIQ8uQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.025348542458808618&quot; data-type=&quot;jpeg&quot; data-w=&quot;1578&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmMbrkQujCzJ36ZRFUIAKxx4zUgksBDFdM0VPxGkG2BnCbY79TLRm1mQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.16066838046272494&quot; data-type=&quot;jpeg&quot; data-w=&quot;1556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmqSu2icmh4TXibVQP9VPw7gxtDoiblbmOBQJWuicnL1RYW0nw848aomFMzw/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;eden 区：8/10 的年轻代空间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;survivor 0 : 1/10 的年轻代空间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;survivor 1 : 1/10 的年轻代空间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;老年代 ：三分之二的堆空间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;年轻代 ：三分之一的堆空间&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;运行时常量池&lt;/code&gt;：运行时常量池又被称为 &lt;code&gt;Runtime Constant Pool&lt;/code&gt;，这块区域是方法区的一部分，它的名字非常有意思，通常被称为 &lt;code&gt;非堆&lt;/code&gt;。它并不要求常量一定只有在编译期才能产生，也就是并非编译期间将常量放在常量池中，运行期间也可以将新的常量放入常量池中，String 的 intern 方法就是一个典型的例子。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;请你描述一下 Java 中的类加载机制？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 虚拟机负责把描述类的数据从 Class 文件加载到系统内存中，并对类的数据进行&lt;strong&gt;校验、转换解析和初始化&lt;/strong&gt;，最终形成可以被虚拟机直接使用的 Java 类型，这个过程被称之为 Java 的&lt;code&gt;类加载机制&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个类从被加载到虚拟机内存开始，到卸载出内存为止，一共会经历下面这些过程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.35430038510911427&quot; data-type=&quot;jpeg&quot; data-w=&quot;779&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmhtUXSic00Bagu6DFhheVwHP2rV3V5FVOJezDXME6sy6ePBVxibFeicuzA/640?wx_fmt=jpeg&quot; class=&quot;rich_pages wxw-img&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类加载机制一共有五个步骤，分别是&lt;strong&gt;加载、链接、初始化、使用和卸载&lt;/strong&gt;阶段，这五个阶段的顺序是确定的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中链接阶段会细分成三个阶段，分别是验证、准备、解析阶段，这三个阶段的顺序是不确定的，这三个阶段通常交互进行。解析阶段通常会在初始化之后再开始，这是为了支持 Java 语言的运行时绑定特性（也被称为&lt;code&gt;动态绑定&lt;/code&gt;）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们就来聊一下这几个过程。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;加载&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于什么时候开始加载这个过程，《Java 虚拟机规范》并没有强制约束，所以这一点我们可以自由实现。加载是整个类加载过程的第一个阶段，在这个阶段，Java 虚拟机需要完成三件事情：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;通过一个类的全限定名来获取定义此类的二进制字节流。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将这个字节流表示的一种存储结构转换为运行时数据区中方法区的数据结构。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在内存中生成一个 Class 对象，这个对象就代表了这个数据结构的访问入口。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;《Java 虚拟机规范》并未规定全限定名是如何获取的，所以现在业界有很多获取全限定名的方式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;从 ZIP 包中读取，最终会改变为 JAR、EAR、WAR 格式。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从网络中获取，最常见的应用就是 Web Applet。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;运行时动态生成，使用最多的就是动态代理技术。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;由其他文件生成，比如 JSP 应用场景，由 JSP 文件生成对应的 Class 文件。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从数据库中读取，这种场景就比较小了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以从加密文件中获取，这是典型的防止 Class 文件被反编译的保护措施。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加载阶段既可以使用虚拟机内置的引导类加载器来完成，也可以使用用户自定义的类加载器来完成。程序员可以通过自己定义类加载器来控制字节流的访问方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数组的加载不需要通过类加载器来创建，它是直接在内存中分配，但是数组的元素类型（数组去掉所有维度的类型）最终还是要靠类加载器来完成加载。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;验证&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加载过后的下一个阶段就是验证，因为我们上一步讲到在内存中生成了一个 Class 对象，这个对象是访问其代表数据结构的入口，所以这一步验证的工作就是确保 Class 文件的字节流中的内容符合《Java 虚拟机规范》中的要求，保证这些信息被当作代码运行后，它不会威胁到虚拟机的安全。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;验证阶段主要分为四个阶段的检验：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;文件格式验证。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;元数据验证。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;字节码验证。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;符号引用验证。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;文件格式验证&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一阶段可能会包含下面这些验证点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;魔数是否以 &lt;code&gt;0xCAFEBABE&lt;/code&gt; 开头。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主、次版本号是否在当前 Java 虚拟机接受范围之内。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;常量池的常量中是否有不支持的常量类型。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CONSTANT_Utf8_info 型的常量中是否有不符合 UTF8 编码的数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Class 文件中各个部分及文件本身是否有被删除的或附加的其他信息。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上验证点远远不止有这些，上面这些只是从 HotSpot 源码中摘抄的一小段内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;元数据验证&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一阶段主要是对字节码描述的信息进行语义分析，以确保描述的信息符合《Java 语言规范》，验证点包括&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;验证的类是否有父类（除了 Object 类之外，所有的类都应该有父类）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;要验证类的父类是否继承了不允许继承的类。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果这个类不是抽象类，那么这个类是否实现了父类或者接口中要求的所有方法。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;是否覆盖了 final 字段，是否出现了不符合规定的重载等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要记住这一阶段只是对《Java 语言规范》的验证。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;字节码验证&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;字节码验证阶段是最复杂的一个阶段，这个阶段主要是确定程序语意是否合法、是否是符合逻辑的。这个阶段主要是对类的方法体（Class 文件中的 Code 属性）进行校验分析。这部分验证包括&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;确保操作数栈的数据类型和实际执行时的数据类型是否一致。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;保证任何跳转指令不会跳出到方法体外的字节码指令上。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;保证方法体中的类型转换是有效的，例如可以把一个子类对象赋值给父类数据类型，但是不能把父类数据类型赋值给子类等诸如此不安全的类型转换。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;其他验证。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果没有通过字节码验证，就说明验证出问题。但是不一定通过了字节码验证，就能保证程序是安全的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;符号引用验证&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后一个阶段的校验行为发生在虚拟机将符号引用转换为直接引用的时候，这个转化将在连接的第三个阶段，即解析阶段中发生。符号引用验证可以看作是对类自身以外的各类信息进行匹配性校验，这个验证主要包括&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;符号引用中的字符串全限定名是否能找到对应的类。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;符号引用的类、字段方法的可访问性是否可被当前类所访问。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;其他验证。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一阶段主要是确保解析行为能否正常执行，如果无法通过符号引用验证，就会出现类似 &lt;code&gt;IllegalAccessError&lt;/code&gt;、&lt;code&gt;NoSuchFieldError&lt;/code&gt;、&lt;code&gt;NoSuchMethodError&lt;/code&gt; 等错误。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;验证阶段对于虚拟机来说非常重要，如果能通过验证，就说明你的程序在运行时不会产生任何影响。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;准备&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;准备阶段是为类中的变量分配内存并设置其初始值的阶段，这些变量所使用的内存都应当在方法区中进行分配，在 JDK 7 之前，HotSpot 使用永久代来实现方法区，是符合这种逻辑概念的。而在 JDK 8 之后，变量则会随着 Class 对象一起存放在 Java 堆中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面通常情况下的基本类型和引用类型的初始值&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4858548585485855&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYm1Ch67QbW54ydQnWYMxRXKPScMyEPg9vgJe5dnyDHS9LUd7E6xLjickA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;813&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了&quot;通常情况&quot;下，还有一些&quot;例外情况&quot;，如果类字段属性中存在 &lt;code&gt;ConstantValue&lt;/code&gt; 属性，那就这个变量值在初始阶段就会初始化为 ConstantValue 属性所指定的初始值，比如&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; value = &lt;span&gt;&quot;666&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译时就会把 value 的值设置为 666。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;解析&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解析阶段是 Java 虚拟机将常量池内的符号引用替换为直接引用的过程。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;符号引用&lt;/code&gt;：符号引用以一组符号来描述所引用的目标。符号引用可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可，符号引用和虚拟机的布局无关。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;直接引用&lt;/code&gt;：直接引用可以直接指向目标的指针、相对便宜量或者一个能间接定位到目标的句柄。直接引用和虚拟机的布局是相关的，不同的虚拟机对于相同的符号引用所翻译出来的直接引用一般是不同的。如果有了直接引用，那么直接引用的目标一定被加载到了内存中。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样说你可能还有点不明白，我再换一种说法：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在编译的时候一个每个 Java 类都会被编译成一个 class 文件，但在编译的时候虚拟机并不知道所引用类的地址，所以就用符号引用来代替，而在这个解析阶段就是为了把这个符号引用转化成为真正的地址的阶段。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;《Java 虚拟机规范》并未规定解析阶段发生的时间，只要求了在 anewarray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invokespecial、invokestatic、invokevirtual、ldc、ldc_w、ldc2_w、multianewarray、new、putfield 和 putstatic 这 17 个用于操作符号引用的字节码指令之前，先对所使用的符号引用进行解析。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解析也分为四个步骤&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;初始化&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初始化是类加载过程的最后一个步骤，在之前的阶段中，都是由 Java 虚拟机占主导作用，但是到了这一步，却把主动权移交给应用程序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于初始化阶段，《Java 虚拟机规范》严格规定了只有下面这六种情况下才会触发类的初始化。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在遇到 new、getstatic、putstatic 或者 invokestatic 这四条字节码指令时，如果没有进行过初始化，那么首先触发初始化。通过这四个字节码的名称可以判断，这四条字节码其实就两个场景，调用 new 关键字的时候进行初始化、读取或者设置一个静态字段的时候、调用静态方法的时候。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在初始化类的时候，如果父类还没有初始化，那么就需要先对父类进行初始化。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在使用 java.lang.reflect 包的方法进行反射调用的时候。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当虚拟机启动时，用户需要指定执行主类的时候，说白了就是虚拟机会先初始化 main 方法这个类。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在使用 JDK 7 新加入的动态语言支持时，如果一个 jafva.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getstatic、REF_putstatic、REF_invokeStatic、REF_newInvokeSpecial 四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，需要先对其进行初始化。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当一个接口中定义了 JDK 8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实上面只有前四个大家需要知道就好了，后面两个比较冷门。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;如果说要回答&lt;/span&gt;&lt;span&gt;类加载的话，其实聊到这里已经可以了，但是为了完整性，我们索性把后面两个过程也来聊一聊。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;使用&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个阶段没什么可说的，就是初始化之后的代码由 JVM 来动态调用执行。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;卸载&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当代表一个类的 Class 对象不再被引用，那么 Class 对象的生命周期就结束了，对应的在方法区中的数据也会被卸载。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;⚠️但是需要注意一点：JVM 自带的类加载器装载的类，是不会卸载的，由用户自定义的类加载器加载的类是可以卸载的。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;在 JVM 中，对象是如何创建的？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果要回答对象是怎么创建的，我们一般想到的回答是直接 &lt;code&gt;new&lt;/code&gt; 出来就行了，这个回答不仅局限于编程中，也融入在我们生活中的方方面面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是遇到面试的时候你只回答一个&quot;new 出来就行了&quot;显然是不行的，因为面试更趋向于让你解释当程序执行到 new 这条指令时，它的背后发生了什么。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以你需要从 JVM 的角度来解释这件事情。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当虚拟机遇到一个 new 指令时（其实就是字节码），首先会去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用所代表的类是否已经被加载、解析和初始化。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;因为此时很可能不知道具体的类是什么，所以这里使用的是符号引用。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果发现这个类没有经过上面类加载的过程，那么就执行相应的类加载过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类检查完成后，接下来虚拟机将会为新生对象&lt;strong&gt;分配内存&lt;/strong&gt;，对象所需的大小在类加载完成后便可确定（我会在下面的面试题中介绍）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分配内存相当于是把一块固定的内存块从堆中划分出来。划分出来之后，虚拟机会将分配到的内存空间都初始化为零值，如果使用了 &lt;code&gt;TLAB&lt;/code&gt;（本地线程分配缓冲），这一项初始化工作可以提前在 TLAB 分配时进行。这一步操作保证了对象实例字段在 Java 代码中可以不赋值就能直接使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，Java 虚拟机还会对对象进行必要的设置，比如确定对象是哪个类的实例、对象的 hashcode、对象的 gc 分代年龄信息。这些信息存放在对象的对象头（Object Header）中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果上面的工作都做完后，从虚拟机的角度来说，一个新的对象就创建完毕了；但是对于程序员来说，对象创建才刚刚开始，因为构造函数，即 Class 文件中的 &lt;code&gt;&amp;lt;init&amp;gt;()&lt;/code&gt; 方法还没有执行，所有字段都为默认的零值。new 指令之后才会执行 &lt;code&gt;&amp;lt;init&amp;gt;()&lt;/code&gt; 方法，然后按照程序员的意愿对对象进行初始化，这样一个对象才可能被完整的构造出来。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;内存分配方式有哪些呢？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在类加载完成后，虚拟机需要为新生对象分配内存，为对象分配内存相当于是把一块确定的区域从堆中划分出来，这就涉及到一个问题，&lt;strong&gt;要划分的堆区是否规整&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设 Java 堆中内存是规整的，所有使用过的内存放在一边，未使用的内存放在一边，中间放着一个指针，这个指针为分界指示器。那么为新对象分配内存空间就相当于是把指针向空闲的空间挪动对象大小相等的距离，这种内存分配方式叫做&lt;code&gt;指针碰撞(Bump The Pointer)&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果 Java 堆中的内存并不是规整的，已经被使用的内存和未被使用的内存相互交错在一起，这种情况下就没有办法使用指针碰撞，这里就要使用另外一种记录内存使用的方式：&lt;code&gt;空闲列表(Free List)&lt;/code&gt;，空闲列表维护了一个列表，这个列表记录了哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，上述两种分配方式选择哪个，取决于 Java 堆是否规整来决定。在一些垃圾收集器的实现中，Serial、ParNew 等带压缩整理过程的收集器，使用的是指针碰撞；而使用 CMS 这种基于清除算法的收集器时，使用的是空闲列表，具体的垃圾收集器我们后面会聊到。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;请你说一下对象的内存布局？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;code&gt;hotspot&lt;/code&gt; 虚拟机中，对象在内存中的布局分为三块区域：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;对象头(Header)&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;实例数据(Instance Data)&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;对齐填充(Padding)&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这三块区域的内存分布如下图所示&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5553892215568862&quot; data-type=&quot;jpeg&quot; data-w=&quot;668&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmwt0GFv70dlvtZVDNGSlN1va4spbg2Jib3RsZibIY59DMSdsRAsIGBFJg/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来详细介绍一下上面对象中的内容。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;对象头 Header&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对象头 Header 主要包含 MarkWord 和对象指针 Klass Pointer，如果是数组的话，还要包含数组的长度。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.16253101736972705&quot; data-type=&quot;jpeg&quot; data-w=&quot;806&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmdSiazv22SSjqa9qTicdtOaqEU6ysPu1aPm0ia5E9DJk5JUY1ibSGaKGwww/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 32 位的虚拟机中 MarkWord ，Klass Pointer 和数组长度分别占用 32 位，也就是 4 字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是 64 位虚拟机的话，MarkWord ，Klass Pointer 和数组长度分别占用 64 位，也就是 8 字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 32 位虚拟机和 64 位虚拟机的 Mark Word 所占用的字节大小不一样，32 位虚拟机的 Mark Word 和 Klass Pointer 分别占用 32 bits 的字节，而 64 位虚拟机的 Mark Word 和 Klass Pointer 占用了64 bits 的字节，下面我们以 32 位虚拟机为例，来看一下其 Mark Word 的字节具体是如何分配的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7952261306532663&quot; data-type=&quot;jpeg&quot; data-w=&quot;796&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmF7oQ1WDXyWnQ2vctT5zLDibH4A11ZOVQb9H7aSbaKVu9WHOLyicRR4YA/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用中文翻译过来就是&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5868102288021534&quot; data-type=&quot;jpeg&quot; data-w=&quot;743&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmFkK8j9Zq4XVUHHKwFaqiarAJmvDobibvjDTjojGFve00zwh3zjso09bQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;无状态也就是&lt;code&gt;无锁&lt;/code&gt;的时候，对象头开辟 25 bit 的空间用来存储对象的 hashcode ，4 bit 用于存放分代年龄，1 bit 用来存放是否偏向锁的标识位，2 bit 用来存放锁标识位为 01。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;偏向锁&lt;/code&gt; 中划分更细，还是开辟 25 bit 的空间，其中 23 bit 用来存放线程ID，2bit 用来存放 epoch，4bit 存放分代年龄，1 bit 存放是否偏向锁标识， 0 表示无锁，1 表示偏向锁，锁的标识位还是 01。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;轻量级锁&lt;/code&gt;中直接开辟 30 bit 的空间存放指向栈中锁记录的指针，2bit 存放锁的标志位，其标志位为 00。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;重量级锁&lt;/code&gt;中和轻量级锁一样，30 bit 的空间用来存放指向重量级锁的指针，2 bit 存放锁的标识位，为 11&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;GC标记&lt;/code&gt;开辟 30 bit 的内存空间却没有占用，2 bit 空间存放锁标志位为 11。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中无锁和偏向锁的锁标志位都是 01，只是在前面的 1 bit 区分了这是无锁状态还是偏向锁状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于为什么这么分配的内存，我们可以从 &lt;code&gt;OpenJDK&lt;/code&gt; 中的markOop.hpp类中的枚举窥出端倪&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.27560050568900124&quot; data-type=&quot;jpeg&quot; data-w=&quot;791&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYm96eGhUyYOWB0aUCSkb4KQZPHEI2gDibq9Pia7nOsNP3jvusH9G9uNDQg/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来解释一下&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;age_bits 就是我们说的分代回收的标识，占用4字节&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;lock_bits 是锁的标志位，占用2个字节&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;biased_lock_bits 是是否偏向锁的标识，占用1个字节。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;max_hash_bits 是针对无锁计算的 hashcode 占用字节数量，如果是 32 位虚拟机，就是 32 - 4 - 2 -1 = 25 byte，如果是 64 位虚拟机，64 - 4 - 2 - 1 = 57 byte，但是会有 25 字节未使用，所以 64 位的 hashcode 占用 31 byte。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;hash_bits 是针对 64 位虚拟机来说，如果最大字节数大于 31，则取 31，否则取真实的字节数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;cms_bits 我觉得应该是不是 64 位虚拟机就占用 0 byte，是 64 位就占用 1byte&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;epoch_bits 就是 epoch 所占用的字节大小，2 字节。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面的虚拟机对象头分配表中，我们可以看到有几种锁的状态：无锁（无状态），偏向锁，轻量级锁，重量级锁，其中轻量级锁和偏向锁是 JDK1.6 中对 synchronized 锁进行优化后新增加的，其目的就是为了大大优化锁的性能，所以在 JDK 1.6 中，使用 synchronized 的开销也没那么大了。其实从锁有无锁定来讲，还是只有无锁和重量级锁，偏向锁和轻量级锁的出现就是增加了锁的获取性能而已，并没有出现新的锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们的重点放在对 synchronized 重量级锁的研究上，当 monitor 被某个线程持有后，它就会处于锁定状态。在 HotSpot 虚拟机中，monitor 的底层代码是由 &lt;code&gt;ObjectMonitor&lt;/code&gt; 实现的，其主要数据结构如下（位于 HotSpot 虚拟机源码 ObjectMonitor.hpp 文件，C++ 实现的）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6672413793103448&quot; data-type=&quot;jpeg&quot; data-w=&quot;580&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmibCm80Ch6SkLdCI5t5WWf9dyyA6ONK72jhw1KVa0M2ZF0ibo76dC29TQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段 C++ 中需要注意几个属性：_WaitSet 、 _EntryList 和 _Owner，每个等待获取锁的线程都会被封装称为 &lt;code&gt;ObjectWaiter&lt;/code&gt; 对象。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.15234375&quot; data-type=&quot;jpeg&quot; data-w=&quot;768&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmk3YshTalB5Hwd6Fiar6GlZcynMNp8jPFTMXAQYL5vOY7EBsuEUcAAQw/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;_Owner 是指向了 ObjectMonitor 对象的线程，而 _WaitSet 和 _EntryList 就是用来保存每个线程的列表。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;那么这两个列表有什么区别呢？这个问题我和你聊一下锁的获取流程你就清楚了。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;锁的两个列表&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当多个线程同时访问某段同步代码时，首先会进入 _EntryList 集合，当线程获取到对象的 monitor 之后，就会进入 _Owner 区域，并把 ObjectMonitor 对象的 _Owner 指向为当前线程，并使 _count + 1，如果调用了释放锁（比如 wait）的操作，就会释放当前持有的 monitor ，owner = null， _count - 1，同时这个线程会进入到 _WaitSet 列表中等待被唤醒。如果当前线程执行完毕后也会释放 monitor 锁，只不过此时不会进入 _WaitSet 列表了，而是直接复位 _count 的值。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5186721991701245&quot; data-type=&quot;jpeg&quot; data-w=&quot;723&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmBkaHmIEibGZQNYvZxKVI44KjHm6f8h97E8lQ5QReUfjGyicIdKDvfqaQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Klass Pointer 表示的是类型指针，也就是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;你可能不是很理解指针是个什么概念，你可以简单理解为指针就是指向某个数据的地址。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24173553719008264&quot; data-type=&quot;jpeg&quot; data-w=&quot;484&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmg07SkwDltzz9neeE2KaZendKZ6fXemgDZkicSJDj0c550jUZsbkmribA/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;实例数据 Instance Data&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实例数据部分是对象真正存储的有效信息，也是代码中定义的各个字段的字节大小，比如一个 byte 占 1 个字节，一个 int 占用 4 个字节。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;对齐 Padding&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对齐不是必须存在的，它只起到了占位符(%d, %c 等)的作用。这就是 JVM 的要求了，因为 HotSpot JVM 要求对象的起始地址必须是 8 字节的整数倍，也就是说对象的字节大小是 8 的整数倍，不够的需要使用 Padding 补全。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;对象访问定位的方式有哪些？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们创建一个对象的目的当然就是为了使用它，但是，一个对象被创建出来之后，在 JVM 中是如何访问这个对象的呢？一般有两种方式：&lt;strong&gt;通过句柄访问&lt;/strong&gt;和 &lt;strong&gt;通过直接指针访问&lt;/strong&gt;。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果使用句柄访问方式的话，Java 堆中可能会划分出一块内存作为句柄池，引用（reference）中存储的是对象的句柄地址，而句柄中包含了对象的实例数据与类型数据各自具体的地址信息。如下图所示。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5897079276773296&quot; data-type=&quot;jpeg&quot; data-w=&quot;719&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmHgibj2NpibuUa5q2waiaW1IBIibGSVCLo0PK24xS5o9JIhvHTJ2av06Vvw/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果使用直接指针访问的话，Java 堆中对象的内存布局就会有所区别，栈区引用指示的是堆中的实例数据的地址，如果只是访问对象本身的话，就不会多一次直接访问的开销，而对象类型数据的指针是存在于方法区中，如果定位的话，需要多一次直接定位开销。如下图所示&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5730180806675939&quot; data-type=&quot;jpeg&quot; data-w=&quot;719&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmBv2RUQEwedibWN6J1au1sNtv7CwytYs7jsgv6McosWQ6ZKkyZzpRohA/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两种对象访问方式各有各的优势，使用句柄最大的好处就是引用中存储的是句柄地址，对象移动时只需改变句柄的地址就可以，而无需改变对象本身。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用直接指针来访问速度更快，它节省了一次指针定位的时间开销，由于对象访问在 Java 中非常频繁，因为这类的开销也是值得优化的地方。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面聊到了对象的两种数据，一种是对象的实例数据，这没什么好说的，就是对象实例字段的数据，一种是对象的类型数据，这个数据说的是对象的类型、父类、实现的接口和方法等。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;如何判断对象已经死亡？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们大家知道，基本上所有的对象都在堆中分布，当我们不再使用对象的时候，垃圾收集器会对无用对象进行回收♻️，那么 JVM 是如何判断哪些对象已经是&quot;无用对象&quot;的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有两种判断方式，首先我们先来说第一种：&lt;strong&gt;引用计数法&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引用计数法的判断标准是这样的：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器的值就会加一；当引用失效时，计数器的值就会减一；只要任何时刻计数器为零的对象就是不会再被使用的对象。虽然这种判断方式非常简单粗暴，但是往往很有用，不过，在 Java 领域，主流的 Hotspot 虚拟机实现并没有采用这种方式，因为引用计数法不能解决对象之间的循环引用问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;循环引用问题简单来讲就是两个对象之间互相依赖着对方，除此之外，再无其他引用，这样虚拟机无法判断引用是否为零从而进行垃圾回收操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一种判断对象无用的方法就是&lt;strong&gt;可达性分析算法&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当前主流的 JVM 都采用了可达性分析算法来进行判断，这个算法的基本思路就是通过一系列被称为&lt;code&gt;GC Roots&lt;/code&gt;的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程走过的路径被称为&lt;code&gt;引用链&lt;/code&gt;（Reference Chain），如果某个对象到 GC Roots 之间没有任何引用链相连接，或者说从 GC Roots 到这个对象不可达时，则证明此这个对象是无用对象，需要被垃圾回收。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种引用方式如下&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6780626780626781&quot; data-type=&quot;jpeg&quot; data-w=&quot;702&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmibo27syf4OQQJTcBLlJd8qGxwuGFhVdBNvfpxiaPZg1Cz6aozFz22hdw/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图所示，从枚举根节点 GC Roots 开始进行遍历，object 1 、2、3、4 是存在引用关系的对象，而 object 5、6、7 之间虽然有关联，但是它们到 GC Roots 之间是不可达的，所以被认为是可以回收的对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Java 技术体系中，可以作为 GC Roots 进行检索的对象主要有&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在虚拟机栈（栈帧中的本地变量表）中引用的对象。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;方法区中类静态属性引用的对象，比如 Java 类的引用类型静态变量。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;方法区中常量引用的对象，比如字符串常量池中的引用。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在本地方法栈中 JNI 引用的对象。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;JVM 内部的引用，比如基本数据类型对应的 Class 对象，一些异常对象比如 NullPointerException、OutOfMemoryError 等，还有系统类加载器。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;所有被 synchronized 持有的对象。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;还有一些 JVM 内部的比如 JMXBean、JVMTI 中注册的回调，本地代码缓存等。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;根据用户所选的垃圾收集器以及当前回收的内存区域的不同，还可能会有一些对象临时加入，共同构成 GC Roots 集合。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然我们上面提到了两种判断对象回收的方法，但无论是引用计数法还是判断 GC Roots 都离不开&lt;code&gt;引用&lt;/code&gt;这一层关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里涉及到到强引用、软引用、弱引用、虚引用的引用关系，你可以阅读作者的这一篇文章&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwMDE1MzkwNQ==&amp;amp;mid=2247495968&amp;amp;idx=1&amp;amp;sn=48de091f4fabdf682a9f8b5ddd8db936&amp;amp;chksm=c04ae67ef73d6f68935382dcaa0bd4d538a9e0b45ee49500ee7e2356cc24dba750b197960477&amp;amp;token=1191632986&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;小心点，别被当成垃圾回收了。&lt;/a&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;如何判断一个不再使用的类？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;判断一个类型属于&quot;不再使用的类&quot;需要满足下面这三个条件&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这个类所有的实例已经被回收，也就是 Java 堆中不存在该类及其任何这个类字类的实例&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;加载这个类的类加载器已经被回收，但是类加载器一般很难会被回收，除非这个类加载器是为了这个目的设计的，比如 OSGI、JSP 的重加载等，否则通常很难达成。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这个类对应的 Class 对象没有任何地方被引用，无法在任何时刻通过反射访问这个类的属性和方法。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虚拟机允许对满足上面这三个条件的无用类进行回收操作。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JVM 分代收集理论有哪些？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般商业的虚拟机，大多数都遵循了&lt;strong&gt;分代收集&lt;/strong&gt;的设计思想，分代收集理论主要有两条假说。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一个是&lt;strong&gt;强分代假说&lt;/strong&gt;，强分代假说指的是 JVM 认为绝大多数对象的生存周期都是朝生夕灭的；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二个是&lt;strong&gt;弱分代假说&lt;/strong&gt;，弱分代假说指的是只要熬过越多次垃圾收集过程的对象就越难以回收（看来对象也会长心眼）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就是基于这两个假说理论，JVM 将&lt;code&gt;堆&lt;/code&gt;区划分为不同的区域，再将需要回收的对象根据其熬过垃圾回收的次数分配到不同的区域中存储。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;JVM 根据这两条分代收集理论，把堆区划分为新生代(Young Generation)和&lt;/span&gt;&lt;span&gt;老年代(Old Generation)这两个区域。&lt;/span&gt;&lt;span&gt;在新生代中，每次垃圾收集时都发现有大批对象死去，剩下没有死去的对象会直接晋升到老年代中。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这两个假说没有考虑对象的引用关系，而事实情况是，对象之间会存在引用关系，基于此又诞生了第三个假说，即&lt;strong&gt;跨代引用假说(Intergeneration Reference Hypothesis)&lt;/strong&gt;，跨代引用相比较同代引用来说仅占少数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正常来说存在相互引用的两个对象应该是同生共死的，不过也会存在特例，如果一个新生代对象跨代引用了一个老年代的对象，那么垃圾回收的时候就不会回收这个新生代对象，更不会回收老年代对象，然后这个新生代对象熬过一次垃圾回收进入到老年代中，这时候跨代引用才会消除。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据跨代引用假说，我们不需要因为老年代中存在少量跨代引用就去直接扫描整个老年代，也不用在老年代中维护一个列表记录有哪些跨代引用，实际上，可以直接在新生代中维护一个&lt;strong&gt;记忆集(Remembered Set)&lt;/strong&gt;，由这个记忆集把老年代划分称为若干小块，标识出老年代的哪一块会存在跨代引用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;记忆集的图示如下&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3736842105263158&quot; data-type=&quot;jpeg&quot; data-w=&quot;760&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmjJ9x4892ccaD2Cks5hjiaHRXH9TrbWR5DibfOPPrcgs1CTjKKX67PWrA/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图中我们可以看到，记忆集中的每个元素分别对应内存中的一块连续区域是否有跨代引用对象，如果有，该区域会被标记为“脏的”（dirty），否则就是“干净的”（clean）。这样在垃圾回收时，只需要扫描记忆集就可以简单地确定跨代引用的位置，是个典型的空间换时间的思路。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;聊一聊 JVM 中的垃圾回收算法？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在聊具体的垃圾回收算法之前，需要明确一点，哪些对象需要被垃圾收集器进行回收？也就是说需要先判断哪些对象是&quot;垃圾&quot;？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;判断的标准我在上面&lt;strong&gt;如何判断对象已经死亡&lt;/strong&gt;的问题中描述了，有两种方式，一种是引用计数法，这种判断标准就是给对象添加一个引用计数器，引用这个对象会使计数器的值 + 1，引用失效后，计数器的值就会 -1。但是这种技术无法解决对象之间的循环引用问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一种方式是 GC Roots，GC Roots 这种方式是以 Root 根节点为核心，逐步向下搜索每个对象的引用，搜索走过的路径被称为引用链，如果搜索过后这个对象不存在引用链，那么这个对象就是无用对象，可以被回收。GC Roots 可以解决循环引用问题，所以一般 JVM 都采用的是这种方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解决循环引用代码描述：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[]args)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        A a = &lt;span&gt;new&lt;/span&gt; A();&lt;br/&gt;        B b = &lt;span&gt;new&lt;/span&gt; B();&lt;br/&gt;        a=&lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        b=&lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;A&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; B b;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;B&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; A a;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于 GC Roots 的这种思想，发展出了很多垃圾回收算法，下面我们就来聊一聊这些算法。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;标记-清除算法&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标记-清除(Mark-Sweep)这个算法可以说是最早最基础的算法了，标记-清除顾名思义分为两个阶段，即标记和清除阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象。当然也可以标记存活的对象，回收未被标记的对象。这个标记的过程就是垃圾判定的过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后续大部分垃圾回收算法都是基于标记-算法思想衍生的，只不过后续的算法弥补了标记-清除算法的缺点，那么它有什么缺点呢？主要有两个&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;执行效率不稳定&lt;/strong&gt;，因为假如说堆中存在大量无用对象，而且大部分需要回收的情况下，这时必须进行大量的标记和清除，导致标记和清除这两个过程的执行效率随对象的数量增长而降低。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;内存碎片化&lt;/strong&gt;，标记-清除算法会在堆区产生大量不连续的内存碎片。碎片太多会导致在分配大对象时没有足够的空间，不得不进行一次垃圾回收操作。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标记算法的示意图如下&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6547277936962751&quot; data-type=&quot;jpeg&quot; data-w=&quot;698&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYm8AemwmWaUPnRysSxqyplddlib4UjMRJiadSqMxK049A1snJyxaBj3GoA/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;标记-复制算法&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于标记-清除算法极易产生内存碎片，研究人员提出了标记-复制算法，标记-复制算法也可以简称为复制算法，复制算法是一种&lt;strong&gt;半区复制&lt;/strong&gt;，它会将内存大小划分为相等的两块，每次只使用其中的一块，用完一块再用另外一块，然后再把用过的一块进行清除。虽然解决了部分内存碎片的问题，但是复制算法也带来了新的问题，即&lt;strong&gt;复制开销&lt;/strong&gt;，不过这种开销是可以降低的，如果内存中大多数对象是无用对象，那么就可以把少数的存活对象进行复制，再回收无用的对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过复制算法的缺陷也是显而易见的，那就是内存空间缩小为原来的一半，空间浪费太明显。标记-复制算法示意图如下&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.598937583001328&quot; data-type=&quot;jpeg&quot; data-w=&quot;753&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYm82CwrSX0SzxshZPJ7XpofasKBOBgicWOkg328AeIKLXn1qOqK8FDIZw/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在 Java 虚拟机大多数都是用了这种算法来回收新生代，因为经过研究表明，新生代对象 98% 都熬不过第一轮收集，因此不需要按照 1 ：1 的比例来划分新生代的内存空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于此，研究人员提出了一种 Appel 式回收，Appel 式回收的具体做法是把新生代分为一块较大的 &lt;em&gt;Eden&lt;/em&gt; 空间和两块 &lt;em&gt;Survivor&lt;/em&gt; 空间，每次分配内存都只使用 Eden 和其中的一块 Survivor 空间，发生垃圾收集时，将 Eden 和 Survivor 中仍然存活的对象一次性复制到另外一块 Survivor 空间上，然后直接清理掉 Eden 和已使用过的 Survivor 空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在主流的 HotSpot 虚拟机中，默认的 Eden 和 Survivor 大小比例是 8：1，也就是每次新生代中可用内存空间为整个新生代容量的 90%，只有一个 Survivor 空间，所以会浪费掉 10% 的空间。这个 8：1 只是一个理论值，也就是说，不能保证每次都有不超过 10% 的对象存活，所以，当进行垃圾回收后如果 Survivor 容纳不了可存活的对象后，就需要其他内存空间来进行&lt;strong&gt;帮助&lt;/strong&gt;，这种方式就叫做&lt;strong&gt;内存担保(Handle Promotion)&lt;/strong&gt; ，通常情况下，作为担保的是老年代。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;标记-整理算法&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标记-复制算法虽然解决了内存碎片问题，但是没有解决复制对象存在大量开销的问题。为了解决复制算法的缺陷，充分利用内存空间，提出了标记-整理算法。该算法标记阶段和标记-清除一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。具体过程如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6557142857142857&quot; data-type=&quot;jpeg&quot; data-w=&quot;700&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmFBJDpzuH8wmQMDM4kVXrSdTQ6fcYVjJpx56uCj7o0mU1WAWsD6H7Aw/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是记忆集，什么是卡表？记忆集和卡表有什么关系？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决跨代引用问题，提出了记忆集这个概念，记忆集是一个在新生代中使用的数据结构，它相当于是记录了一些指针的集合，指向了老年代中哪些对象存在跨代引用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;记忆集的实现有不同的粒度&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;字长精度&lt;/strong&gt;：每个记录精确到一个字长，机器字长就是处理器的寻址位数，比如常见的 32 位或者 64 位处理器，这个精度决定了机器访问物理内存地址的指针长度，字中包含跨代指针。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;对象精度&lt;/strong&gt;：每个记录精确到一个对象，该对象里含有跨代指针。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;卡精度&lt;/strong&gt;：每个记录精确到一块内存区域，区域内含有跨代指针。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中卡精度是使用了卡表作为记忆集的实现，关于记忆集和卡表的关系，大家可以想象成是 HashMap 和 Map 的关系。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是卡页？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;卡表其实就是一个字节数组&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;CARD_TABLE[&lt;span&gt;this&lt;/span&gt; address &amp;gt;&amp;gt; &lt;span&gt;9&lt;/span&gt;] = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;字节数组 CARD_TABLE 的每一个元素都对应着内存区域中一块特定大小的内存块，这个内存块就是&lt;strong&gt;卡页&lt;/strong&gt;，一般来说，卡页都是 2 的 N 次幂字节数，通过上面的代码我们可以知道，卡页一般是 2 的 9 次幂，这也是 HotSpot 中使用的卡页，即 512 字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个卡页的内存通常包含不止一个对象，只要卡页中有一个对象的字段存在跨代指针，那就将对应卡表的数组元素的值设置为 1，称之为这个元素变&lt;code&gt;脏&lt;/code&gt;了，没有标示则为 0 。在垃圾收集时，只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页内存块中包含跨代指针，然后把他们加入 GC Roots 进行扫描。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，卡页和卡表主要用来解决跨代引用问题的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是写屏障？写屏障带来的问题？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果有其他分代区域中对象引用了本区域的对象，那么其对应的卡表元素就会变脏，这个引用说的就是对象赋值，也就是说卡表元素会变脏发生在对象赋值的时候，那么如何在对象赋值的时候更新维护卡表呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 HotSpot 虚拟机中使用的是&lt;strong&gt;写屏障(Write Barrier)&lt;/strong&gt; 来维护卡表状态的，这个写屏障和我们内存屏障完全不同，希望读者不要搞混了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个写屏障其实就是一个 Aop 切面，在引用对象进行赋值时会产生一个&lt;strong&gt;环形通知(Around)&lt;/strong&gt;，环形通知就是切面前后分别产生一个通知，因为这个又是写屏障，所以在赋值前的部分写屏障叫做写前屏障，在赋值后的则叫做写后屏障。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写屏障会带来两个问题&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;无条件写屏障带来的性能开销&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每次对引用的更新，无论是否更新了老年代对新生代对象的引用，都会进行一次写屏障操作。显然，这会增加一些额外的开销。但是，扫描整个老年代相比较，这个开销就低得多了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过，在高并发环境下，写屏障又带来了伪共享（false sharing）问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;高并发下伪共享带来的性能开销&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在高并发情况下，频繁的写屏障很容易发生伪共享（false sharing），从而带来性能开销。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设 CPU 缓存行大小为 64 字节，由于一个卡表项占 1 个字节，这意味着，64 个卡表项将共享同一个缓存行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HotSpot 每个卡页为 512 字节，那么一个缓存行将对应 64 个卡页一共 64*512 = 32K B。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不同线程对对象引用的更新操作，恰好位于同一个 32 KB 区域内，这将导致同时更新卡表的同一个缓存行，从而造成缓存行的写回、无效化或者同步操作，间接影响程序性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个简单的解决方案，就是不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表项未被标记过才将其标记为脏的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是 JDK  7 中引入的解决方法，引入了一个新的 JVM 参数 &lt;em&gt;-XX:+UseCondCardMark&lt;/em&gt;，在执行写屏障之前，先简单的做一下判断。如果卡页已被标识过，则不再进行标识。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单理解如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (CARD_TABLE [this address &amp;gt;&amp;gt; 9] != 0)&lt;br/&gt;  CARD_TABLE [this address &amp;gt;&amp;gt; 9] = 0;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与原来的实现相比，只是简单的增加了一个判断操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然开启 &lt;em&gt;-XX:+UseCondCardMark&lt;/em&gt; 之后多了一些判断开销，但是却可以避免在高并发情况下可能发生的并发写卡表问题。通过减少并发写操作，进而避免出现伪共享问题（false sharing）。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是三色标记法？三色标记法会造成哪些问题？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据可达性算法的分析可知，如果要找出存活对象，需要从 GC Roots 开始遍历，然后搜索每个对象是否可达，如果对象可达则为存活对象，在 GC Roots 的搜索过程中，按照&lt;strong&gt;对象和其引用是否被访问过&lt;/strong&gt;这个条件会分成下面三种颜色：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;白色：白色表示 GC Roots 的遍历过程中没有被访问过的对象，出现白色显然在可达性分析刚刚开始的阶段，这个时候所有对象都是白色的，如果在分析结束的阶段，仍然是白色的对象，那么代表不可达，可以进行回收。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;灰色：灰色表示对象已经被访问过，但是这个对象的引用还没有访问完毕。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;黑色：黑色表示此对象已经被访问过了，而且这个对象的引用也已经被访问了。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注：如果标记结束后对象仍为白色，意味着已经“找不到”该对象在哪了，不可能会再被重新引用。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现代的垃圾回收器几乎都借鉴了三色标记的算法思想，尽管实现的方式不尽相同：比如白色/黑色集合一般都不会出现（但是有其他体现颜色的地方）、灰色集合可以通过栈/队列/缓存日志等方式进行实现、遍历方式可以是广度/深度遍历等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;三色标记法会造成两种问题，这两种问题所出现的环境都是由于&lt;strong&gt;用户环境和收集器并行工作造成的&lt;/strong&gt; 。当用户线程正在修改引用关系，此时收集器在回收引用关系，此时就会造成把原本已经消亡的对象标记为存活，如果出现这种状况的话，问题不大，下次再让收集器重新收集一波就完了，但是还有一种情况是把存活的对象标记为死亡，这种状况就会造成不可预知的后果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对上面这两种对象消失问题，业界有两种处理方式，一种是&lt;strong&gt;增量更新(Incremental Update)&lt;/strong&gt; ，一种是&lt;strong&gt;原是快照(Snapshot At The Beginning, SATB)&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;请你介绍一波垃圾收集器&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;垃圾收集器是面试的常考，也是必考点，只要涉及到 JVM 的相关问题，都会围绕着垃圾收集器来做一波展开，所以，有必要了解一下这些垃圾收集器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;垃圾收集器有很多，不同商家、不同版本的 JVM 所提供的垃圾收集器可能会有很大差别，我们主要介绍 HotSpot 虚拟机中的垃圾收集器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;垃圾收集器是垃圾回收算法的具体实现，我们上面提到过，垃圾回收算法有标记-清除算法、标记-整理、标记-复制，所以对应的垃圾收集器也有不同的实现方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道，HotSpot 虚拟机中的垃圾收集都是分代回收的，所以根据不同的分代，可以把垃圾收集器分为&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新生代收集器：Serial、ParNew、Parallel Scavenge；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;老年代收集器：Serial Old、Parallel Old、CMS；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整堆收集器：G1；&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Serial 收集器&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Serial 收集器是一种新生代的垃圾收集器，它是一个单线程工作的收集器，使用复制算法来进行回收，单线程工作不是说这个垃圾收集器只有一个，而是说这个收集器在工作时，必须暂停其他所有工作线程，这种暴力的暂停方式就是 &lt;strong&gt;Stop The World&lt;/strong&gt;，Serial 就好像是寡头垄断一样，只要它一发话，其他所有的小弟（线程）都得给它让路。Serial 收集器的示意图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5209059233449478&quot; data-type=&quot;jpeg&quot; data-w=&quot;574&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmZ3BbmNV9XmU92S53CoX5j4bSEticcJt77oYXQAqpicLRFmA7cBZVsXMg/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;SefePoint 全局安全点：它就是代码中的一段特殊的位置，在所有用户线程到达 SafePoint 之后，用户线程挂起，GC 线程会进行清理工作。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然 Serial 有 STW 这种显而易见的缺点，不过，从其他角度来看，Serial 还是很讨喜的，它还有着优于其他收集器的地方，那就是简单而高效，对于内存资源首先的环境，它是所有收集器中额外内存消耗最小的，对于单核处理器或者处理器核心较少的环境来说，Serial 收集器由于没有线程交互开销，所以 Serial 专心做垃圾回收效率比较高。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ParNew 收集器&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ParNew 是 Serial 的多线程版本，除了同时使用多条线程外，其他参数和机制（STW、回收策略、对象分配规则）都和 Serial 完全一致，ParNew 收集器的示意图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5993150684931506&quot; data-type=&quot;jpeg&quot; data-w=&quot;584&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmPxHcC0semKUibicnjjuSjSkbo8VXdpcs3yZPBw3IQc71u25f8u54iabIw/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然 ParNew 使用了多条线程进行垃圾回收，但是在单线程环境下它绝对不会比 Serial 收集效率更高，因为多线程存在线程交互的开销，但是随着可用 CPU 核数的增加，ParNew 的处理效率会比 Serial 更高效。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Parallel Scavenge 收集器&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Parallel Scavenge 收集器也是一款新生代收集器，它同样是基于标记-复制算法实现的，而且它也能够并行收集，这么看来，表面上 Parallel Scavenge 与 ParNew 非常相似，那么它们之间有什么区别呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Parallel Scavenge 的关注点主要在&lt;strong&gt;达到一个可控制的吞吐量上面&lt;/strong&gt;。吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比。也就是&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.17894736842105263&quot; data-type=&quot;jpeg&quot; data-w=&quot;665&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmscYdWaDzFkxkO3WPSDB9v2OQSHecPmiauKjCEDZyBhmOCLE40bMVETQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里给大家举一个吞吐量的例子，如果执行用户代码的时间 + 运行垃圾收集的时间总共耗费了 100 分钟，其中垃圾收集耗费掉了 1 分钟，那么吞吐量就是 99%。停顿时间越短就越适合需要与用户交互或需要保证服务响应质量，良好的响应速度可以提升用户体验，而高吞吐量可以最高效率利用处理器资源。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Serial Old 收集器&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面介绍了一下 Serial，我们知道它是一个新生代的垃圾收集，使用了标记-复制算法。而这个 Serial Old 收集器却是 Serial 的老年版本，它同样也是一个单线程收集器，使用的是&lt;strong&gt;标记-整理&lt;/strong&gt;算法，Serial Old 收集器有两种用途：一种是在 JDK 5 和之前的版本与 Parallel Scavenge 收集器搭配使用，另外一种用法就是作为 &lt;code&gt;CMS&lt;/code&gt; 收集器的备选，CMS 垃圾收集器我们下面说，Serial Old 的收集流程如下&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4251207729468599&quot; data-type=&quot;jpeg&quot; data-w=&quot;828&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmsr5qnsJKzjvNXjXNCrib8u5HbWlEUWwNPadXLAib7wYHnDL1QP9Gq7jg/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Parallel Old 收集器&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面我们介绍了 Parallel Scavenge 收集器，现在来介绍一下 Parallel Old 收集器，它是 Parallel Scavenge 的老年版本，支持多线程并发收集，基于标记 - 整理算法实现，JDK 6 之后出现，吞吐量优先可以考虑 Parallel Scavenge + Parallel Old 的搭配&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.43103448275862066&quot; data-type=&quot;jpeg&quot; data-w=&quot;812&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmmumuGg3XajNzH8jGictWpG83p0CcRbfoic3OI0dlEsMqZiawe6Ww2jS4Q/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;CMS 收集器&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;CMS&lt;/code&gt;收集器的主要目标是获取最短的回收停顿时间，它的全称是 &lt;em&gt;Concurrent Mark Sweep&lt;/em&gt;，从这个名字就可以知道，这个收集器是基于标记 - 清除算法实现的，而且支持并发收集，它的运行过程要比上面我们提到的收集器复杂一些，它的工作流程如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;初始标记（CMS initial mark）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;并发标记（CMS concurrent mark）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;重新标记（CMS remark）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;并发清除（CMS concurrent sweep）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于上面这四个步骤，初始标记和并发标记都需要 &lt;em&gt;Stop The World&lt;/em&gt;，初始标记只是标记一下和 GC Roots 直接关联到的对象，速度较快；并发标记阶段就是从 GC Roots 的直接关联对象开始遍历整个对象图的过程。这个过程时间比较长但是不需要停顿用户线程，也就是说与垃圾收集线程一起并发运行。并发标记的过程中，可能会有错标或者漏标的情况，此时就需要在重新标记一下，最后是并发清除阶段，清理掉标记阶段中判断已经死亡的对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CMS 的收集过程如下&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3606936416184971&quot; data-type=&quot;jpeg&quot; data-w=&quot;865&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmfffkneclx5D1bAnFbSukKgEWYScjqsrxYZwmMBkvOy4Nkib9tPEOaGQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CMS 是一款非常优秀的垃圾收集器，但是没有任何收集器能够做到完美的程度，CMS 也是一样，CMS 至少有三个缺点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;CMS 对处理器资源非常敏感，在并发阶段，虽然不会造成用户线程停顿，但是却会因为占用一部分线程而导致应用程序变慢，降低总吞吐量。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;CMS 无法处理&lt;strong&gt;浮动垃圾&lt;/strong&gt;，有可能出现&lt;em&gt;Concurrent Mode Failure&lt;/em&gt;失败进而导致另一次完全 &lt;em&gt;Stop The World&lt;/em&gt;的 &lt;em&gt;Full GC&lt;/em&gt; 产生。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;什么是浮动垃圾呢？由于并发标记和并发清理阶段，用户线程仍在继续运行，所以程序自然而然就会伴随着新的垃圾不断出现，而且这一部分垃圾出现在标记结束之后，CMS 无法处理这些垃圾，所以只能等到下一次垃圾回收时在进行清理。这一部分垃圾就被称为浮动垃圾。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;CMS 最后一个缺点是并发-清除的通病，也就是会有大量的空间碎片出现，这将会给分配大对象带来困难。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Garbage First 收集器&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Garbage First 又被称为 &lt;em&gt;G1 收集器&lt;/em&gt;，它的出现意味着垃圾收集器走过了一个里程碑，为什么说它是里程碑呢？因为 G1 这个收集器是一种面向局部的垃圾收集器，HotSpot 团队开发这个垃圾收集器为了让它替换掉 CMS 收集器，所以到后来，JDK 9 发布后，G1 取代了 Parallel Scavenge + Parallel Old 组合，成为服务端默认的垃圾收集器，而 CMS 则不再推荐使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前的垃圾收集器存在回收区域的局限性，因为之前这些垃圾收集器的目标范围要么是整个新生代、要么是整个老年代，要么是整个 Java 堆（Full GC），而 G1 跳出了这个框架，它可以面向堆内存的任何部分来组成&lt;strong&gt;回收集(Collection Set，CSet)&lt;/strong&gt;，衡量垃圾收集的不再是哪个分代，这就是 G1 的 &lt;em&gt;Mixed GC&lt;/em&gt; 模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;G1 是基于 Region 来进行回收的，Region 就是堆内存中任意的布局，每一块 Region 都可以根据需要扮演 Eden 空间、Survivor 空间或者老年代空间，收集器能够对不同的 Region 角色采用不同的策略来进行处理。Region 中还有一块特殊的区域，这块区域就是 &lt;em&gt;Humongous&lt;/em&gt; 区域，它是专门用来存储大对象的，G1 认为只要大小超过了 Region 容量一半的对象即可判定为大对象。如果超过了 Region 容量的大对象，将会存储在连续的 Humongous Region 中，G1 大多数行为都会把 Humongous Region 作为老年代来看待。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;G1 保留了新生代（Eden Suvivor）和老年代的概念，但是新生代和老年代不再是固定的了。它们都是一系列区域的动态集合。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;G1 收集器的运作过程可以分为以下四步：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;初始标记：这个步骤也仅仅是标记一下 GC Roots 能够直接关联到的对象；并修改 TAMS 指针的值（每一个 Region 都有两个 RAMS 指针），使得下一阶段用户并发运行时，能够在可用的 Region 中分配对象，这个阶段需要暂停用户线程，但是时间很短。这个停顿是借用 Minor GC 的时候完成的，所以可以忽略不计。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;并发标记：从 GC Root 开始对堆中对象进行可达性分析，递归扫描整个堆中的对象图，找出要回收的对象。当对象图扫描完成后，重新处理 SATB 记录下的在并发时有引用的对象；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最终标记：对用户线程做一个短暂的暂停，用于处理并发阶段结束后遗留下来的少量 &lt;em&gt;SATB&lt;/em&gt; 记录（一种原始快照，用来记录并发标记中某些对象）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;筛选回收：负责更新 Region 的统计数据，对各个 Region 的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择多个 Region 构成回收集，然后把决定要回收的那一部分 Region 存活对象复制到空的 Region 中，再清理掉整个旧 Region 的全部空间。这里的操作设计对象的移动，所以必须要暂停用户线程，由多条收集器线程并行收集&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面这几个步骤可以看出，除了并发标记外，其余三个阶段都需要暂停用户线程，所以，这个 G1 收集器并非追求&lt;strong&gt;低延迟&lt;/strong&gt;，官方给出的设计目标是&lt;strong&gt;在延迟可控的情况下尽可能的提高吞吐量&lt;/strong&gt;，担任全功能收集器的重任。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是 G1 回收的示意图&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.375&quot; data-type=&quot;jpeg&quot; data-w=&quot;864&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmOticPic3nnyPXRDCMfc6JIOjbSW9QE1y2KVLicsazGK9CDrlps3MOHAAg/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;G1 收集器同样也有缺点和问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一个问题就是 Region 中存在跨代引用的问题，我们之前知道可以用记忆集来解决跨代引用问题，不过 Region 中的跨代引用要复杂很多；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二个问题就是如何保证收集线程与用户线程互不干扰的运行？CMS 使用的是增量更新算法，G1 使用的是原始快照（SATB），G1 为 Region 分配了两块 TAMS 指针，把 Region 中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须在这两个指针位置以上。如果内存回收速度赶不上内存分配速度，G1 收集器也要冻结用户线程执行，导致 Full GC 而产生长时间的 STW。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第三个问题是无法建立可预测的停顿模型。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JVM 常用命令介绍&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面介绍一下 JVM 中常用的调优、故障处理等工具。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;em&gt;jps&lt;/em&gt; ：虚拟机进程工具，全称是 &lt;em&gt;JVM Process Status Tool&lt;/em&gt;，它的功能和 Linux 中的 &lt;em&gt;ps&lt;/em&gt; 类似，可以列出正在运行的虚拟机进程，并显示虚拟机执行主类 &lt;em&gt;Main Class&lt;/em&gt; 所在的本地虚拟机唯一 ID，虽然功能比较单一，但是这个命令绝对是使用最高频的一个命令。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;em&gt;jstat&lt;/em&gt;：虚拟机统计信息工具，用于监视虚拟机各种运行状态的信息的命令行工具，它可以显示本地或者远程虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;em&gt;jinfo&lt;/em&gt;：Java 配置信息工具，全称是 &lt;em&gt;Configuration Info for Java&lt;/em&gt;，它的作用是可以实时调整虚拟机各项参数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;em&gt;jmap&lt;/em&gt;：Java 内存映像工具，全称是 &lt;em&gt;Memory Map For Java&lt;/em&gt;，它用于生成转储快照，用来排查内存占用情况&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;em&gt;jhat&lt;/em&gt;：虚拟机堆转储快照分析工具，全称是 &lt;em&gt;JVM Heap Analysis Tool&lt;/em&gt;，这个指令通常和 jmap 一起搭配使用，jhat 内置了一个 HTTP/Web 服务器，生成转储快照后可以在浏览器中查看。不过，一般还是 jmap 命令使用的频率比较高。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;em&gt;jstack&lt;/em&gt;：Java 堆栈跟踪工具，全称是 &lt;em&gt;Stack Trace for Java&lt;/em&gt; ，顾名思义，这个命令用来追踪堆栈的使用情况，用于虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条正在执行的方法堆栈的集合。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是双亲委派模型？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JVM 类加载默认使用的是&lt;strong&gt;双亲委派模型&lt;/strong&gt;，那么什么是双亲委派模型呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们需要先介绍一下三种类加载器：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;启动类加载器，&lt;em&gt;Bootstrap Class Loader&lt;/em&gt;，这个类加载器是 C++ 实现的，它是 JVM 的一部分，这个类加载器负责加载存放在 &lt;em&gt;&amp;lt;JAVA_HOME&amp;gt;\lib&lt;/em&gt; 目录，启动类加载器无法被 Java 程序直接引用。这也就是说，JDK 中的常用类的加载都是由启动类加载器来完成的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;扩展类加载器，&lt;em&gt;Extension Class Loader&lt;/em&gt;，这个类加载器是 Java 实现的，它负责加载 &lt;em&gt;&amp;lt;JAVA_HOME&amp;gt;\lib\ext&lt;/em&gt; 目录。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;应用程序类加载器，&lt;em&gt;Application Class Loader&lt;/em&gt;，这个类加载器是由 &lt;em&gt;sum.misc.Launcher$AppClassLoader&lt;/em&gt; 来实现，它负责加载 &lt;em&gt;ClassPath&lt;/em&gt; 上所有的类库，如果应用程序中没有定义自己的类加载器，默认使用就是这个类加载器。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，我们的 Java 应用程序都是由这三种类加载器来相互配合完成的，当然，用户也可以自己定义类加载器，即 &lt;em&gt;User Class Loader&lt;/em&gt;，这几个类加载器的模型如下&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7843137254901961&quot; data-type=&quot;jpeg&quot; data-w=&quot;1377&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmtI4ta2xo6xGOr0kbMvQOcJcibLLYZVxwS0ZOtNtHCJSwaKDhC1eRmgg/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这几类类加载器构成了不同的层次结构，当我们需要加载一个类时，子类加载器并不会马上去加载，而是依次去请求父类加载器加载，一直往上请求到最高类加载器：启动类加载器。当启动类加载器加载不了的时候，依次往下让子类加载器进行加载。这就是双亲委派模型。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;双亲委派模型的缺陷？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在双亲委派模型中，子类加载器可以使用父类加载器已经加载的类，而父类加载器无法使用子类加载器已经加载的。这就导致了双亲委派模型并不能解决所有的类加载器问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 提供了很多外部接口，这些接口统称为 &lt;em&gt;Service Provider Interface, SPI&lt;/em&gt;，允许第三方实现这些接口，而这些接口却是 Java 核心类提供的，由 Bootstrap Class Loader 加载，而一般的扩展接口是由 Application Class Loader 加载的，Bootstrap Class Loader 是无法找到 SPI 的实现类的，因为它只加载 Java 的核心库。它也不能代理给 Application Class Loader，因为它是最顶层的类加载器。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;双亲委派机制的三次破坏&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然双亲委派机制是 Java 强烈推荐给开发者们的类加载器的实现方式，但是并没有强制规定你必须就要这么实现，所以，它一样也存在被破坏的情况，实际上，历史上一共出现三次双亲委派机制被破坏的情况：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;双亲委派机制第一次被破坏发生在双亲委派机制出现之前，由于双亲委派机制 JDK 1.2 之后才引用的，但类加载的概念在 Java 刚出现的时候就有了，所以引用双亲委派机制之前，设计者们必须兼顾开发者们自定义的一些类加载器的代码，所以在 JDK 1.2 之后的 java.lang.ClassLoader 中添加了一个新的 &lt;em&gt;findClass&lt;/em&gt; 方法，引导用户编写类加载器逻辑的时候重写这个 findClass 方法，而不是基于 &lt;em&gt;loadClass&lt;/em&gt;编写。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;双亲委派机制第二次被破坏是由于它自己模型导致的，由于它只能向上（基础）加载，越基础的类越由上层加载器加载，所以如果基础类型又想要调用用户的代码，该怎么办？这也就是我们上面那个问题所说的 SPI 机制。那么 JDK 团队是如何做的呢？它们引用了一个 &lt;strong&gt;线程上下文类加载器(Thread Context ClassLoader)&lt;/strong&gt;，这个类加载器可以通过 java.lang.Thread 类的 &lt;em&gt;setContextClassLoader&lt;/em&gt; 进行设置，如果创建时线程还未设置，它将会从父线程中继承，如果全局没有设置类加载器的话，这个 ClassLoader 就是默认的类加载器。这种行为虽然是一种犯规行为，但是 Java 代码中的 &lt;strong&gt;JNDI、JDBC&lt;/strong&gt; 等都是使用这种方式来完成的。直到 JDK 6 ，引用了 &lt;em&gt;java.util.ServiceLoader&lt;/em&gt;，使用 &lt;strong&gt;META-INF/services&lt;/strong&gt; + 责任链的设计模式，才解决了 SPI 的这种加载机制。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;双亲委派机制第三次被破坏是由于用户对程序的动态需求使热加载、热部署的引入所致。由于时代的变化，我们希望 Java 能像鼠标键盘一样实现热部署，即时加载（load class），引入了 OSGI，OSGI 实现热部署的关键在于它自定义类加载器机制的实现，OSGI 中的每一个 &lt;em&gt;Bundle&lt;/em&gt; 也就是模块都有一个自己的类加载器。当需要更换 Bundle 时，就直接把 Bundle 连同类加载器一起替换掉就能够实现热加载。在 OSGI 环境下，类加载器不再遵从双亲委派机制，而是使用了一种更复杂的加载机制。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;常见的 JVM 调优参数有哪些？&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;-Xms256m：初始化堆大小为 256m；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-Xmx2g：最大内存为 2g；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-Xmn50m：新生代的大小50m；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:+PrintGCDetails 打印 gc 详细信息；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:+HeapDumpOnOutOfMemoryError  在发生OutOfMemoryError错误时，来 dump 出堆快照；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:NewRatio=4    设置年轻的和老年代的内存比例为 1:4；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:SurvivorRatio=8 设置新生代 Eden 和 Survivor 比例为 8:2；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:+UseSerialGC   新生代和老年代都用串行收集器 Serial + Serial Old&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:+UseParNewGC 指定使用 ParNew + Serial Old 垃圾回收器组合；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:+UseParallelGC  新生代使用 Parallel Scavenge，老年代使用 Serial Old&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:+UseParallelOldGC：新生代 ParallelScavenge + 老年代 ParallelOld 组合；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:+UseConcMarkSweepGC：新生代使用 ParNew，老年代使用 CMS；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:NewSize：新生代最小值；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:MaxNewSize：新生代最大值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:MetaspaceSize 元空间初始化大小&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:MaxMetaspaceSize 元空间最大值&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;后记&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章是 JVM 面试题的第二版，新增了很多内容，写的时间也比较长了，如果你觉得文章还不错的话，大家&lt;span&gt;三连&lt;/span&gt;走起！&lt;span&gt;另外，分享到朋友圈是对我莫大的支持，感谢&lt;/span&gt;！不骗你，看完真的需要一小时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651508525&amp;amp;idx=1&amp;amp;sn=7fc6ce143c3a600ea7defa896707d4b2&amp;amp;chksm=bd25a3528a522a448304c6baf7877af993464eb39c839ef30392457677f74fd58b5cdf562b04&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;空降的大厂 CTO，半年内成功把团队带垮了！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;空降的大厂 CTO，半年内成功把团队带垮了！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651508525&amp;amp;idx=2&amp;amp;sn=c11a048bd986b2ac897b74fd9b492c6c&amp;amp;chksm=bd25a3528a522a44118d1065aee8c5cdb2a8299d6b3cf1174ac9a8b1eeaa828dd13c36d3b508&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;如何设计API返回码（错误码）？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;如何设计API返回码（错误码）？&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651508521&amp;amp;idx=2&amp;amp;sn=fd61ee0009a89aff50ab87d60be4b4d8&amp;amp;chksm=bd25a3568a522a40484bf60ef51c01ca8641f91750ebc58f34744677f81199f426471ade4bf6&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;看一遍就理解：零拷贝详解&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;看一遍就理解：零拷贝详解&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关注「ImportNew」，提升Java技能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9166666666666666&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;点赞和在看就是最大的支持&lt;/span&gt;&lt;span&gt;❤️&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6bcc65d24a18cea70ca9591dab3f8651</guid>
<title>[推荐] 从MVC到DDD的架构演进</title>
<link>https://toutiao.io/k/c7mn7hz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article class=&quot;markdown-body mt-4&quot;&gt;
        &lt;p&gt;DDD这几年越来越火，资料也很多，大部分的资料都偏向于理论介绍，有给出的代码与传统MVC的三层架构差异较大，再加上大量的新概念很容易让初学者望而却步。本文从MVC架构角度来讲解如何演进到DDD架构。&lt;/p&gt;
&lt;h3 id=&quot;从ddd的角度看mvc架构的问题&quot;&gt;从DDD的角度看MVC架构的问题&lt;/h3&gt;
&lt;p&gt;代码角度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;瘦实体模型：只起到数据类的作用，业务逻辑散落到service，可维护性越来越差；&lt;/li&gt;
&lt;li&gt;面向数据库表编程，而非模型编程；&lt;/li&gt;
&lt;li&gt;实体类之间的关系是复杂的网状结构，成为大泥球，牵一发而动全身，导致不敢轻易改代码；&lt;/li&gt;
&lt;li&gt;service类承接的所有的业务逻辑，越来越臃肿，很容易出现几千行的service类；&lt;/li&gt;
&lt;li&gt;对外接口直接暴露实体模型，导致不必要开放内部逻辑对外暴露，就算有DTO类一般也是实体类的直接copy；&lt;/li&gt;
&lt;li&gt;外部依赖层直接从service层调用，字段转换、异常处理大量充斥在service方法中；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;项目管理角度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;交付效率：越来越低；&lt;/li&gt;
&lt;li&gt;稳定性差：不好测试，代码改动的影响范围不好预估；&lt;/li&gt;
&lt;li&gt;理解成本高：新成员介入成本高，长期会导致模块只有一个人最熟悉，离职成本很大；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;第一层初出茅庐&quot;&gt;第一层：初出茅庐&lt;/h3&gt;
&lt;p&gt;以上的问题越来越严重，很多人开始把眼光转向DDD，于是埋头啃了几本大部头的书，对以下概念有了基本的了解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;统一语言&lt;/li&gt;
&lt;li&gt;限界上下文&lt;/li&gt;
&lt;li&gt;领域、子域、支撑域&lt;/li&gt;
&lt;li&gt;聚合、实体、值对象&lt;/li&gt;
&lt;li&gt;分层：用户接口层、应用层、领域层、基础层&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;于是把MVC架构进行了改造，演进成DDD的分层架构。&lt;/p&gt;
&lt;p&gt;DDD分层架构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blogpic.chekuspace.com/5fKsjeq0ZqpGk7XvauObZBXrtzjMiXOpLhzJhKLUBiI.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;MVC架构到DDD分层架构的映射：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blogpic.chekuspace.com/nm2JYF5eU_NhBTjnuQzNg9SJL5ViYyHKfL_myGe5ojY.jpeg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，算了基本入门了DDD架构，扩展性也得到了一定的提升。不过随着业务的发展，不断冒出新的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一段业务逻辑代码，到底应该放到应用层还是领域层？&lt;/li&gt;
&lt;li&gt;领域服务当成原来的MVC中的service层，随着业务不断发展，类也在不断膨胀，好像还是老样子啊？&lt;/li&gt;
&lt;li&gt;聚合包含多个实体类，这个接口用不到这么多实体，为了性能还是直接写个SQL返回必要的操作吧，不过这样貌似又回到了MVC模式&lt;/li&gt;
&lt;li&gt;既然实体类可以包含业务逻辑、领域服务也可以放业务逻辑，那到底放哪里？&lt;/li&gt;
&lt;li&gt;资料上说领域层不能有外部依赖，要做到100%单测覆盖，可是我的领域服务中需要用到外部接口、中央缓存等等，那这不就有了外部依赖了吗？&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;第二层草船借箭战术设计&quot;&gt;第二层：草船借箭（战术设计）&lt;/h3&gt;
&lt;p&gt;带着问题不断学习他人经验，并不断的尝试，逐渐get到以下技能：&lt;/p&gt;
&lt;h4 id=&quot;1领域层&quot;&gt;1、领域层&lt;/h4&gt;
&lt;p&gt;领域（domain）是个模块，包含以下组成部分，传统的service按功能可能拆分到任何一个地方，各司其职。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1个聚合&lt;/li&gt;
&lt;li&gt;1到多个实体&lt;/li&gt;
&lt;li&gt;若干值对象&lt;/li&gt;
&lt;li&gt;多个DomainService&lt;/li&gt;
&lt;li&gt;1个Factory：新建聚合&lt;/li&gt;
&lt;li&gt;1个Repository：聚合仓储服务&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;聚合根aggregateroot&quot;&gt;聚合根（AggregateRoot）&lt;/h5&gt;
&lt;p&gt;聚合本身也是一个实体，聚合可以包含其他实体，其他实体不能脱离聚合而单独提供服务，比如一篇文章下的评论，评论必须从属于文章，没有文章也就没有评论。仓库层（repository）也必须是以聚合为核心提供服务的；&lt;/p&gt;
&lt;p&gt;实体：可以理解为一张数据库表，必须有主键；&lt;/p&gt;
&lt;p&gt;值对象：没有主键，依附于实体而存在，比如用户实体下住址对象，一般在数据库中已json字符串的形式存在；最常见的值对象是枚举；&lt;/p&gt;
&lt;h5 id=&quot;仓库服务repository&quot;&gt;仓库服务（repository）&lt;/h5&gt;
&lt;p&gt;资源库是聚合的仓储机制，外部世界通过资源库，而且只能通过资源库来完成对聚合的访问。资源库以聚合的整体管理对象。因此，一个聚合只能有一个资源库对象，那就是以聚合根命名的资源库。除此之外的其他对象，都不应该提供资源库对象。仓储服务的实现一般有Spring Data JPA、Mybatis两种方式。&lt;/p&gt;
&lt;p&gt;如果是用Spring Data JPA实现，直接使用JPA注解@OneToOne、@OneToMany，配合fetch配置，即可一个方法查询出所有的关联实体。&lt;/p&gt;
&lt;p&gt;如果是用Mybatis实现，那么repository需要加入多个mapper的引用，再手动做拼装。&lt;/p&gt;
&lt;p&gt;这里有一个经典的Hibernate笛卡尔积问题，答案是在聚合根中，一般不会加在大量的关联实体对象。如果确实需要查询关联对象而关联对象又比较多怎么办呢？在DDD中有一个CQRS(Command-Query Responsibility Segregation)模式，是一种读写分离模式，在此场景中需要将查询操作放到查询命令中分页查询。&lt;/p&gt;
&lt;p&gt;当然CQRS也是一个很复杂模式，不应照搬他人方案，而是根据自己的业务场景选择适合自己的方案，以下列举了CQRS的几种应用模式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blogpic.chekuspace.com/RBQqPimBOS1s4cpPxkHAlxZFpyhdQ4bcSfkzJu_1pGQ.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;工厂服务factory&quot;&gt;工厂服务（factory）&lt;/h5&gt;
&lt;p&gt;作用是创建聚合，只传入必要的参数，工厂服务内部隐藏复杂的创建逻辑。简单的聚合可以直接通过new、静态方法等创建，不是必须由factory创建。&lt;/p&gt;
&lt;h5 id=&quot;领域服务&quot;&gt;领域服务&lt;/h5&gt;
&lt;p&gt;单个实体对象能处理的逻辑放到实体里，多个实体或有交互的场景放到领域服务里。&lt;/p&gt;
&lt;p&gt;领域服务可不可以调用仓储层或外部接口？ 可以，但不能直接和领域服务代码放一起，领域服务模块存放API，实现放基础层（infrastructure）。&lt;/p&gt;
&lt;p&gt;领域服务对象不建议直接以聚合名+DomainService命名，而要以操作命令关联，比如用户保存服务命名为：UserSaveService, 审核服务：UserAuditSerivce。&lt;/p&gt;
&lt;h4 id=&quot;2应用层&quot;&gt;2、应用层&lt;/h4&gt;
&lt;p&gt;应用层通过应用服务接口来暴露系统的全部功能。在应用服务的实现中，它负责&lt;strong&gt;编排和转发&lt;/strong&gt;，它将要实现的功能委托给一个或多个领域对象来实现，它本身只负责处理业务用例的执行顺序以及结果的拼装。通过这样一种方式，它隐藏了领域层的复杂性及其内部实现机制。&lt;/p&gt;
&lt;p&gt;比如下订单服务的方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Plain&quot;&gt;public void submitOrder(Long orderId) {
    Order order = OrderFetchService.fetchById(orderId);   //获取订单对象
    OrderCheckSerivce.check(order);    //验证订单是否有效
    OrderSubmitSerivce.submit(order);  //提交订单
    ShoppingCartClearService.clear(order);  //移除购物车中已购商品
    NotifySerivce.emailNotify(order.getUser());  //发送邮件通知买家
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于复杂的业务来说，应用层也有几种模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编排服务：最典型比如Drools；&lt;/li&gt;
&lt;li&gt;Command、Query命令模式；&lt;/li&gt;
&lt;li&gt;业务按Rhase、Step逐层拆分模式；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://blogpic.chekuspace.com/hVk44fi54NRfIpszQndvINbvAW_wpEX2MM1u10Jz488.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;3maven模块划分&quot;&gt;3、Maven模块划分&lt;/h4&gt;
&lt;p&gt;基础层是比较简单一层，不过这里还有个比较疑惑的问题：按照DDD的四层架构图去划分Maven模块，基础层是最上的一层，但是基础层也要包含基础组件供其他层使用，这时基础层应该是放到最下层，直接按照这样构建Maven模块会造成循环依赖。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blogpic.chekuspace.com/-yfk48fv1-8tdlIQi9NXhhT85G1229lmVCYgmqhCJCw.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;相比来说，另一个架构图更准确一些，不过依然没有直观体现Maven模块如何划分。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blogpic.chekuspace.com/SBZB_QjiM_JcIm4Bwbv8EoUhnhjaKPp50A_000GaiwU.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我的最佳实践是将基础层拆分两部分，一部分是基础的组件+仓储API，一部分是实现，maven模块划分图如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blogpic.chekuspace.com/0tlMJCqf85yTrqKHDYkdgArjLtIzShP12CUQoX8_zhU.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;第三层运筹帷幄战略设计&quot;&gt;第三层：运筹帷幄（战略设计）&lt;/h3&gt;
&lt;p&gt;经过以上的两层的磨炼，恭喜你把DDD战术都学习完了，应付日常的代码开发也够了，不过作为架构师来说，探索的道路还不能止步于此，接下来会DDD战略部分。战略部分关注点有3个：&lt;/p&gt;

&lt;h5 id=&quot;1统一语言&quot;&gt;1、统一语言&lt;/h5&gt;
&lt;p&gt;统一语言的重要性可以根据Jeff Patton 在《用户故事地图》中给出的一副漫画来直观的描述：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blogpic.chekuspace.com/Qltdl7WxKJoQgq9hzp94skZxw_SLjRXyCmm9KVz3WlY.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;统一语言是提炼领域知识的输出结果，也是进行后续需求迭代及重构的基础，统一语言的建立有以下几个要点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;统一语言必须以文档的形式提供出来，并且在整个项目组的各团队达成共识；&lt;/li&gt;
&lt;li&gt;统一语言必须每个中文名有对应的英文名，并且在整个技术栈保持一致；&lt;/li&gt;
&lt;li&gt;统一语言必须是完整的，包含以下要素：
&lt;ol&gt;
&lt;li&gt;领域模型的概念与逻辑；&lt;/li&gt;
&lt;li&gt;界限上下文（Bounded Context）；&lt;/li&gt;
&lt;li&gt;系统隐喻；&lt;/li&gt;
&lt;li&gt;职责的分层；&lt;/li&gt;
&lt;li&gt;模式（patterns）与惯用法。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;2领域划分&quot;&gt;2、领域划分&lt;/h5&gt;
&lt;p&gt;以事件风暴的形式（Event Storming），列出所有的用户故事（Use Story），用户故事可通过&lt;strong&gt;6W模型&lt;/strong&gt;来构建，即描写场景的 &lt;strong&gt;W&lt;/strong&gt;ho、&lt;strong&gt;W&lt;/strong&gt;hat、&lt;strong&gt;W&lt;/strong&gt;hy、&lt;strong&gt;W&lt;/strong&gt;here、&lt;strong&gt;W&lt;/strong&gt;hen 与 ho&lt;strong&gt;W&lt;/strong&gt; 六个要素。然后圈选功能相近的部分，就形成了领域，领域又根据职能不同划分为：核心域、支撑域、通用域，&lt;/p&gt;
&lt;p&gt;具体的过程有很多参考资料，这里不再细讲，最终的输出是领域划分图，以下是一个保险业务示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blogpic.chekuspace.com/GQaI_aQ2C9MeqT7kQ5_VXbv-4WAp-K-Hn3bJUf9cIxQ.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;3限界上下文&quot;&gt;3、限界上下文&lt;/h5&gt;
&lt;p&gt;限界上下文包含两部分：上下文（Context）是业务目标，限界（Bounded）则是保护和隔离上下文的边界。&lt;/p&gt;
&lt;p&gt;比如上图中的实现部分即是限界上下文的边界，虚线部分代表了领域的边界。限界上下文没有统一的划分标准，需要的读者根据自己的业务场景来甄别如何划分。&lt;/p&gt;
&lt;p&gt;一个上下文中包含了相同的领域知识，角色在上下文中完成动作目标；&lt;/p&gt;
&lt;p&gt;边界体现在以下几方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;领域逻辑层&lt;/strong&gt;：确定了领域模型的业务边界，维护了模型的完整性与一致性，从而降低系统的业务复杂度；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;团队合作层&lt;/strong&gt;：限界上下文一般也是用户换分团队的依据；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;技术实现层&lt;/strong&gt;：限界上下文可当成是微服务的划分边界；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;ddd的不足&quot;&gt;DDD的不足&lt;/h3&gt;
&lt;p&gt;DDD架构作为一套先进的方法论，在很多场景能发挥很大价值，但是DDD也不是银弹。高级的架构师把DDD架构当成一种工具，结合其他架构经验一起为业务服务。&lt;/p&gt;
&lt;p&gt;DDD的不足有几个方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;性能：DDD是基于聚合来组织代码，对于高性能场景下，加载聚合中大量的无用字段会严重影响性能，比如报表场景中，直接写SQL会更简单直接；&lt;/li&gt;
&lt;li&gt;事务：DDD中的事务被限定在限界上下文中，跨多个限界上下文的场景需要开发者额外考虑分布式事务问题；&lt;/li&gt;
&lt;li&gt;难度系数高，推广成本大：DDD项目需要领域专家专家，且需要特别熟悉业务、建模、OOP，对于管理者来说评估一个人是否真的能胜任也是一件困难的事情；&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;本文从MVC架构开始讲述了如何从演进到DDD架构，限于篇幅很多DDD的知识点没有讲到，希望大家在实践过程中能灵活运用，尽享DDD给业务带来的价值。本文如有不足之处敬请反馈。&lt;/p&gt;
&lt;p&gt;本文链接：&lt;a href=&quot;https://lesofn.com/archives/mvn-to-ddd-architecture&quot;&gt;从MVC到DDD的架构演进&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者简介：木小丰，美团Java技术专家，专注分享软件研发实践、架构思考。欢迎关注公共号：&lt;strong&gt;Java研发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blogpic.chekuspace.com/二维码小_1607785087313.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

    &lt;/article&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3a676082c2425e9d5ae55a5f471e09b6</guid>
<title>[推荐] 缓存一致性最佳实践</title>
<link>https://toutiao.io/k/ymscqc1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.4382826&quot; data-w=&quot;559&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74ACnsfKcnFDT8Uf8XcCHKTbbFu7n3GktsBgczeVd0RHngWc5I6Wvf01FzUtDwQibTQEpYeZSM64W8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;背景 &lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;概述&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;最近团队里我们在密集的讨论Redis缓存一致性相关的问题，电商核心的域如商品、营销、库存、订单等实际上在缓存的选择上各有特色，那么在这些差异的业务背后，我们有没有一些最佳实践可供参考呢？&lt;/p&gt;&lt;p&gt;本文尝试着来讨论这个问题，并给出一些建议。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在讨论之前，有两个重点我们需要达成一致：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;分布式场景下无法做到强一致&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不同于CPU硬件缓存体系采用的MESI协议以及硬件的强时钟控制，分布式场景下我们无法做到缓存与底层数据库的强一致，即把缓存和数据库的数据变更做成一个原子操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;硬件工程师设计了内存屏障（Memory Barrier）的概念，提供给软件开发者不同的一致性选项在性能与一致性上进行权衡。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;就算是达到最终一致性也很难&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;分布式场景下，要做到最终一致性，就要求缓存中存储的是最新版本的数据（或者缓存为空），而且是在数据库更新后很迅速的就要达到这个一致性的状态，要做到是极其困难的。&lt;/p&gt;&lt;p&gt;我们会面临硬件、软件、通信等等组件非常多的异常情况。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5409836&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74ACnsfKcnFDT8Uf8XcCHKTbvSxeCUz3xV2YIUErVqjzgbHHKuhWXsU0JyWT3jfkpKJPI1Z14xiatxA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;976&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;CPU的缓存结构&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;缓存的一致性问题&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;一般化来说，我们面临的是这样的一个问题，如下图所示，数据库的数据会有5次更新，产生6个版本，V1~V6，图中每个方框的长度代表这个版本持续的时间。&lt;/p&gt;&lt;p&gt;我们期望，在数据库中的数据变化后，缓存层需要尽快的感知到并作出反应，如下图所示，缓存层方框中的间隔代表这个时间段缓存数据不存在，V2、V3以及V5版本在缓存中不存在并不会破坏我们的最终一致性要求，只要数据库的最终版本和缓存的最终版本是相同的就可以了。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2796296&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74ACnsfKcnFDT8Uf8XcCHKTbpcFMVGBvhuLoH4m6rYIj8yhttcP7lbiaonk7s2MgEjNyQmj9zOCXE1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;缓存是如何写入的&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;缓存写入的代码通常情况下都是和缓存使用的代码放在一起的，包含4个步骤，如下图所示：W1读取缓存，W2判断缓存是否存在，W3组装缓存数据（这通常需要向数据库进行查询），W4写入缓存。&lt;/p&gt;&lt;p&gt;每一个步骤间可能会停顿多久是没有办法控制的，尤其是W3、W4之间的停顿最为要命，它很可能让我们将旧版本的数据写入到缓存中。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;我们可能会想，W4步的写入，带上W2的假设，即使用WriteIfNotExists语义，会不会有所改善？&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3916667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74ACnsfKcnFDT8Uf8XcCHKTb20FjhyT48qhUfho2h4bwblJcIsFVibcSh0dgWLCqB0hicJ8EDgk8VUyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;考虑如下的情形，假设有3个缓存写入的并发执行，由于短时间数据库大量的更新，它们分别组装的是V1、V2、V3版本的数据。&lt;/p&gt;&lt;p&gt;使用WriteIfNotExists语义，其中必然有2个执行会失败，哪一个会成功根本无法保证。&lt;/p&gt;&lt;p&gt;我们无法简单的做决策，需要再次将缓存读取出来，然后判断是否我们即将写入的一样，如果一样那就很简单；如果不一样的话，我们有两种选择：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;将缓存删除，让后续别的请求来处理写入。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;使用缓存提供的原子操作，仅在我们的数据是较新版本时写入。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.27833&quot; data-w=&quot;1006&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74ACnsfKcnFDT8Uf8XcCHKTbxFk3v9PuJ3VBXYmdBKGOcvrMXAyRjrqiaXlId1X7Q849lA9Gbon5dpg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;如何感知数据库的变化&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;数据库的数据发生变化后，我们如何感知到并进行有效的缓存管理呢？&lt;/p&gt;&lt;p&gt;通常情况下有如下的3种做法：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;使用代码执行流&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;通常我们会在数据库操作完成后，执行一些缓存操作的代码。&lt;/p&gt;&lt;p&gt;这种方式最大的问题是可靠性不高，应用重启、机器意外当机等情况都会导致后续的代码无法执行。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;使用事务消息&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;作为使用代码执行流的改进，在数据库操作完成后发出事务消息，然后在消息的消费逻辑里执行缓存的管理操作。&lt;/p&gt;&lt;p&gt;可靠性的问题就解决了，只是业务侧要为此增加事务消息的逻辑，以及运行成本。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;使用数据变更日志&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;数据库产品通常都支持在数据变更后产生变更日志，比如MySQL的binlog。&lt;/p&gt;&lt;p&gt;可以让中间件团队写一款产品，在接收到变更后执行缓存的管理操作，比如阿里的精卫。&lt;/p&gt;&lt;p&gt;可靠性有保证，同时还可以进行某个时间段变更日志的回放，功能就比较强大了。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;最佳实践一：数据库变更后失效缓存&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;这是最常用和简单的方式，应该被作为首选的方案，整体的执行逻辑如下图所示：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5731481&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74ACnsfKcnFDT8Uf8XcCHKTbuFnDYpEbhQKFJQVPGlOAZaJibTSPEQ0ag8mIn1J78yhhBfdYOlLhBibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;W4步使用最基本的put语义，这里的假设是写入较晚的请求往往也是携带的最新的数据，这在大多的情形下都是成立的。&lt;/p&gt;&lt;p&gt;D1步使用监听DB binlog的方式来删除缓存，即前述使用数据变更日志中介绍的方法。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;这个方案的缺点是&lt;/strong&gt;：在数据库数据存在高并发更新且缓存读取流量较大的情况下，会有小概率存在缓存中存储的是旧版本数据的情况。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通常的解法有四种：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;限制缓存有效时间&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;设定缓存的过期时间，比如15分钟。即表示我们最多接受缓存在15分钟的时间范围内是旧的。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;小概率缓存重加载&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;根据流量比设定一定比例的缓存重加载，以保证大流量情况下的缓存数据的一致性。&lt;/p&gt;&lt;p&gt;比如1%的比例，这同时还可以帮助数据库得到充分的预热。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;结合业务特点&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;根据业务的特点做一些设计，比如：&lt;/p&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;针对营销的场景&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;在商品详情页/确认订单页的优惠计算时使用缓存，而在下单时不使用缓存。&lt;/p&gt;&lt;p&gt;这可以让极端情况发生时，不产生过大的业务损失。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;针对库存的场景&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;读取到旧版本的数据只是会在商品已售罄的情况下让多余的流量进入到下单而已，下单时的库存扣减是操作数据库的，所以不会有业务上的损失。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;两次删除&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;D1步删除缓存的操作执行两次，且中间有一定的间隔，比如30秒。&lt;/p&gt;&lt;p&gt;这两次动作的触发都是由“缓存管理组件”发起的，所以可以由它支持。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;最佳实践二：带版本写入&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;针对象商品信息缓存这种更新频率低、数据一致性要求较高且缓存读取流量很高的场景，通常会采用带版本更新的方式，整体的执行逻辑如下图如示：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6055556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74ACnsfKcnFDT8Uf8XcCHKTblN4aNHDMTub6GiboN4tIj5MlIj1sSpEiamGf0A9Pu2VBmPRF9fjxcayA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;和“数据库变更后失效缓存”方案最大的差异在W4步和D1步，需要缓存层提供带版本写入的API，即仅当写入数据版本较新时可以写入成功，否则写入失败。&lt;/p&gt;&lt;p&gt;这同时也要求我们在数据库增加数据版本的信息。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个方案的最终一致性效果比较好，仅在极端情况下（新版本写入后数据丢失了，后续旧版本的写入就会成功）存在缓存中存储的是旧版本数据的可能。&lt;/p&gt;&lt;p&gt;在D1步使用写入而不是使用删除可以极大程度的避免这个极端情况的出现，同时由于该方案适用于缓存读取流量很高的场景，还可以避免缓存被删除后W3步短时间大量请求穿透到DB。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;总结与展望&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;对于缓存与数据库分离的场景，在结合了业界多家公司的实践经验以及ROI权衡之后，前述的两个最佳实践是被应用的最为广泛的，尤其是最佳实践一，应该作为我们日常应用的首选。&lt;/p&gt;&lt;p&gt;同时，为了最大限度的避免每个最佳实践背后可能发生的不一致性问题，我们还需要切合业务的特点，在关键的场景上做一些保障一致性的设计（比如前述的营销在下单时使用数据库读而不是缓存读），这也显得尤为重要（毕竟如“背景”中所述，并不存在完美的技术方案）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;除了缓存与数据库分离的方案，还有两个业界已经应用的方案也值得我们借鉴：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;阿里XKV&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;简单来讲就是在数据库上部署一个Memcache的Server，它直接绕过数据库层直接访问存储引擎层（如：InnoDB），同时使用KV client来进行数据的访问。&lt;/p&gt;&lt;p&gt;它的特点是数据实际上与数据库是强一致的，性能可以比使用SQL访问数据库提升5～10倍。&lt;/p&gt;&lt;p&gt;缺点也很明显，只能通过主键或者唯一键来访问数据（这只是相对SQL来说的，大多数缓存本来也就是KV访问协议）。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;腾讯DCache&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;不用自行维护缓存与数据库两套存储，给开发人员统一的一套数据视图，由DCache在缓存更新后自行持久化数据。&lt;/p&gt;&lt;p&gt;缺点是支持的数据结构有限（ key-value，k-k-row，list，set，zset ），未来也很难支持形如数据库表一样复杂的数据结构。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.004&quot; data-w=&quot;1000&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/n4p7ssmqwmGHOiaBs4TLdiacnZ6Ub3E6Oqia4cJNlwjuvAI6fuDuXvUGb9FX2wTNgvRtdpqlSf4V780atTia0eorag/640?wx_fmt=gif&quot; data-type=&quot;gif&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;*文/苏木&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkxNTE3ODU0NA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74Diclic7XyegA4UmC0SqoT4jDEpdzibjkibmAvz8svbJwfsufiaBqOWx9sskIrickxzGfCwkjuMBiaNLDxNA/0?wx_fmt=png&quot; data-nickname=&quot;得物技术&quot; data-signature=&quot;技术知识分享交流平台，与你一同走向技术的云端。&quot;/&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>223efe9fc75695a1ed7b0c2441de2cef</guid>
<title>[推荐] 面渣逆袭：Java并发六十问，图文详解，快来看看你会多少道！</title>
<link>https://toutiao.io/k/4ndh1gd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是老三，&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzkwODE5ODM0Ng==&amp;amp;action=getalbum&amp;amp;album_id=2041709347461709827&amp;amp;scene=173&amp;amp;from_msgid=2247489004&amp;amp;from_itemidx=1&amp;amp;count=3&amp;amp;nolastread=1#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;面渣逆袭&lt;/a&gt; 继续，这节我们来盘一盘另一个面试必问知识点——Java并发。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章有点长，四万字，图文详解六十道Java并发面试题。人已经肝麻了，大家可以&lt;strong&gt;点赞&lt;/strong&gt;、&lt;strong&gt;收藏&lt;/strong&gt;慢慢看！扶我起来，我还能肝！&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkwODE5ODM0Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdFLJg0sAOqwHB1mb24icMADUgxm1qZQft5aN3H37NAmQnOvpGB7J9JVHxC6NSiacxbBP1DYdhIAeyA/0?wx_fmt=png&quot; data-nickname=&quot;三分恶&quot; data-alias=&quot;Fighter3FullStack&quot; data-signature=&quot;CSDN博客专家、优质创作者，华为云云享专家；肝过外包、混过国企，目前在一家跨境电商搬砖；写过诗，打过拳，佛系小码农。认真讲技术，随性侃人生，关注我，我们一起走的更远。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;基础&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.并行跟并发有什么区别？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从操作系统的角度来看，线程是CPU分配的最小单位。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;并行就是同一时刻，两个线程都在执行。这就要求有两个CPU去分别执行两个线程。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;并发就是同一时刻，只有一个执行，但是一个时间段内，两个线程都执行了。并发的实现依赖于CPU切换线程，因为切换的时间特别短，所以基本对于用户是无感知的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTS2ibNTT0qBy2tDgPX9pG1xvI8EG1JXpZ4t60qd5cTeLfaX2ph3gdT38g/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;并行和并发&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就好像我们去食堂打饭，并行就是我们在多个窗口排队，几个阿姨同时打菜；并发就是我们挤在一个窗口，阿姨给这个打一勺，又手忙脚乱地给那个打一勺。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSQXibcUjkj72rFyjaHicpxaO7O7QibQGTvC5ZLnuSXwlxBxkuWjQ3cJiaRg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;并行并发和食堂打饭&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.说说什么是进程和线程？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要说线程，必须得先说说进程。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;进程：进程是代码在数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程：线程是进程的一个执行路径，一个进程中至少有一个线程，进程中的多个线程共享进程的资源。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;操作系统在分配资源时是把资源分配给进程的， 但是 CPU 资源比较特殊，它是被分配到线程的，因为真正要占用CPU运行的是线程，所以也说线程是 CPU分配的基本单位。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如在Java中，当我们启动 main 函数其实就启动了一个JVM进程，而 main 函数在的线程就是这个进程中的一个线程，也称主线程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTS74wN2kmXIicVic1QlXH54kkRECFvyjNtTwyvRzHBA35cqcysVibTA2fYw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;程序进程线程关系&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个进程中有多个线程，多个线程共用进程的堆和方法区资源，但是每个线程有自己的程序计数器和栈。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.说说线程有几种创建方式？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java中创建线程主要有三种方式，分别为继承Thread类、实现Runnable接口、实现Callable接口。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTS6LVYDqPoWWNxm2p8ibPTjwxiaSDaaLxcHvMg0ib7oWQaxUE5g95CRdjwA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;线程创建三种方式&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;继承Thread类，重写run()方法，调用start()方法启动线程&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 继承Thread类&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyThread&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Thread&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;This is child thread&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        MyThread thread = &lt;span&gt;new&lt;/span&gt; MyThread();&lt;br/&gt;        thread.start();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RunnableTask&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;Runnable!&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        RunnableTask task = &lt;span&gt;new&lt;/span&gt; RunnableTask();&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; Thread(task).start();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面两种都是没有返回值的，但是如果我们需要获取线程的执行结果，该怎么办呢？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;实现Callable接口，重写call()方法，这种方式可以通过FutureTask获取任务执行的返回值&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CallerTask&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Callable&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;call&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Hello,i am running!&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//创建异步任务&lt;/span&gt;&lt;br/&gt;        FutureTask&amp;lt;String&amp;gt; task=&lt;span&gt;new&lt;/span&gt; FutureTask&amp;lt;String&amp;gt;(&lt;span&gt;new&lt;/span&gt; CallerTask());&lt;br/&gt;        &lt;span&gt;//启动线程&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; Thread(task).start();&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;//等待执行完成，并获取返回结果&lt;/span&gt;&lt;br/&gt;            String result=task.get();&lt;br/&gt;            System.out.println(result);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (ExecutionException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.为什么调用start()方法时会执行run()方法，那怎么不直接调用run()方法？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JVM执行start方法，会先创建一条线程，由创建出来的新线程去执行thread的run方法，这才起到多线程的效果。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSdTd8PGSRoibhE9aky2sXmFyX8CTfkMoXvhBF74VbAlWmkL6cfaGxnnA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;start方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;**为什么我们不能直接调用run()方法？**也很清楚， 如果直接调用Thread的run()方法，那么run方法还是运行在主线程中，相当于顺序执行，就起不到多线程的效果。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.线程有哪些常用的调度方法？&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSsK0UianSHEombkRSia1P63NxI4kicIwfTEZDFiciaOZiaWvckeAdIrl0v2Lw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;线程常用调度方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;线程等待与通知&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Object类中有一些函数可以用于线程的等待与通知。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;wait()：当一个线程A调用一个共享变量的 wait()方法时， 线程A会被阻塞挂起， 发生下面几种情况才会返回 ：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;（1） 线程A调用了共享对象 notify()或者 notifyAll()方法；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;（2）其他线程调用了线程A的 interrupt() 方法，线程A抛出InterruptedException异常返回。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;wait(long timeout) ：这个方法相比 wait() 方法多了一个超时参数，它的不同之处在于，如果线程A调用共享对象的wait(long timeout)方法后，没有在指定的 timeout ms时间内被其它线程唤醒，那么这个方法还是会因为超时而返回。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;wait(long timeout, int nanos)，其内部调用的是 wait(long timout）函数。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面是线程等待的方法，而唤醒线程主要是下面两个方法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;notify() : 一个线程A调用共享对象的 notify() 方法后，会唤醒一个在这个共享变量上调用 wait 系列方法后被挂起的线程。一个共享变量上可能会有多个线程在等待，具体唤醒哪个等待的线程是随机的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;notifyAll() ：不同于在共享变量上调用 notify() 函数会唤醒被阻塞到该共享变量上的一个线程，notifyAll()方法则会唤醒所有在该共享变量上由于调用 wait 系列方法而被挂起的线程。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Thread类也提供了一个方法用于等待的方法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;join()：如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才&lt;/p&gt;&lt;p&gt;从thread.join()返回。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;线程休眠&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;sleep(long millis)  :Thread类中的静态方法，当一个执行中的线程A调用了Thread 的sleep方法后，线程A会暂时让出指定时间的执行权，但是线程A所拥有的监视器资源，比如锁还是持有不让出的。指定的睡眠时间到了后该函数会正常返回，接着参与 CPU 的调度，获取到 CPU 资源后就可以继续运行。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;让出优先权&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;yield() ：Thread类中的静态方法，当一个线程调用 yield 方法时，实际就是在暗示线程调度器当前线程请求让出自己的CPU ，但是线程调度器可以无条件忽略这个暗示。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;线程中断&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 中的线程中断是一种线程间的协作模式，通过设置线程的中断标志并不能直接终止该线程的执行，而是被中断的线程根据中断状态自行处理。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;void interrupt() ：中断线程，例如，当线程A运行时，线程B可以调用钱程interrupt() 方法来设置线程的中断标志为true 并立即返回。设置标志仅仅是设置标志, 线程A实际并没有被中断， 会继续往下执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;boolean isInterrupted() 方法：检测当前线程是否被中断。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;boolean interrupted() 方法：检测当前线程是否被中断，与 isInterrupted 不同的是，该方法如果发现当前线程被中断，则会清除中断标志。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6.线程有几种状态？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Java中，线程共有六种状态：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;状态&lt;/th&gt;&lt;th&gt;说明&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;NEW&lt;/td&gt;&lt;td&gt;初始状态：线程被创建，但还没有调用start()方法&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;RUNNABLE&lt;/td&gt;&lt;td&gt;运行状态：Java线程将操作系统中的就绪和运行两种状态笼统的称作“运行”&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;BLOCKED&lt;/td&gt;&lt;td&gt;阻塞状态：表示线程阻塞于锁&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;WAITING&lt;/td&gt;&lt;td&gt;等待状态：表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或中断）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;TIME_WAITING&lt;/td&gt;&lt;td&gt;超时等待状态：该状态不同于 WAITIND，它是可以在指定的时间自行返回的&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;TERMINATED&lt;/td&gt;&lt;td&gt;终止状态：表示当前线程已经执行完毕&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程在自身的生命周期中， 并不是固定地处于某个状态，而是随着代码的执行在不同的状态之间进行切换，Java线程状态变化如图示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTShQkou2XzC8FIN6UXecNN3FTb0MvGugyl0oJ1rUn9WOONtU8iaPt3XJw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;Java线程状态变化&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;7.什么是线程上下文切换？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用多线程的目的是为了充分利用CPU，但是我们知道，并发其实是一个CPU来应付多个线程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSZzAS4QOe2F12nI4saOBr2lZibrR6zHlhxnEWHIY08LyZhQGibU6ckO9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;线程切换-2020-12-16-2107&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了让用户感觉多个线程是在同时执行的， CPU 资源的分配采用了时间片轮转也就是给每个线程分配一个时间片，线程在时间片内占用 CPU 执行任务。当线程使用完时间片后，就会处于就绪状态并让出 CPU 让其他线程占用，这就是上下文切换。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSbEVPLNk4QgvXZick5kIvibH5uf2L1gbDQZhbG7ibzgHefDQ0UyqlGGAgA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;上下文切换时机&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;8.守护线程了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java中的线程分为两类，分别为 daemon 线程（守护线程）和 user 线程（用户线程）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在JVM 启动时会调用 main 函数，main函数所在的钱程就是一个用户线程。其实在 JVM 内部同时还启动了很多守护线程， 比如垃圾回收线程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么守护线程和用户线程有什么区别呢？区别之一是当最后一个非守护线程束时， JVM会正常退出，而不管当前是否存在守护线程，也就是说守护线程是否结束并不影响 JVM退出。换而言之，只要有一个用户线程还没结束，正常情况下JVM就不会退出。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;9.线程间有哪些通信方式？&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSdnNJ9qArkNSUFrBzego4UowztBD355hQYrOjML8icFREsxT0jkLZ2UQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;线程间通信方式&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关键字volatile可以用来修饰字段（成员变量），就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过Java内置的等待/通知机制（wait()/notify()）实现一个线程修改一个对象的值，而另一个线程感知到了变化，然后进行相应的操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;管道输入/输出流和普通的文件输入/输出流或者网络输入/输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;管道输入/输出流主要包括了如下4种具体实现：PipedOutputStream、PipedInputStream、 PipedReader和PipedWriter，前两种面向字节，而后两种面向字符。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才从thread.join()返回。。线程Thread除了提供join()方法之外，还提供了join(long millis)和join(long millis,int nanos)两个具备超时特性的方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocal，即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过set(T)方法来设置一个值，在当前线程下再通过get()方法获取到原先设置的值。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;关于多线程，其实很大概率还会出一些笔试题，比如交替打印、银行转账、生产消费模型等等，后面老三会单独出一期来盘点一下常见的多线程笔试题。&lt;/p&gt;&lt;/blockquote&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;ThreadLocal&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocal其实应用场景不是很多，但却是被炸了千百遍的面试老油条，涉及到多线程、数据结构、JVM，可问的点比较多，一定要拿下。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;10.ThreadLocal是什么？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocal，也就是线程本地变量。如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量的时候，实际是操作自己本地内存里面的变量，从而起到线程隔离的作用，避免了线程安全问题。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTS7OzNCVicicddtUicSdxR1sqVnbUbK2cggB1Tib0nhhGqWSxbcUKibQ52sxw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;ThreadLocal线程副本&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建了一个ThreadLoca变量localVariable，任何一个线程都能并发访问localVariable。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//创建一个ThreadLocal变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ThreadLocal&amp;lt;String&amp;gt; localVariable = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程可以在任何地方使用localVariable，写入变量。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;localVariable.set(&lt;span&gt;&quot;鄙人三某”);&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程在任何地方读取的都是它写入的变量。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;localVariable.get();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;11.你在工作中用到过ThreadLocal吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有用到过的，用来做用户信息上下文的存储。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的系统应用是一个典型的MVC架构，登录后的用户每次访问接口，都会在请求头中携带一个token，在控制层可以根据这个token，解析出用户的基本信息。那么问题来了，假如在服务层和持久层都要用到用户信息，比如rpc调用、更新用户获取等等，那应该怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一种办法是显式定义用户相关的参数，比如账号、用户名……这样一来，我们可能需要大面积地修改代码，多少有点瓜皮，那该怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候我们就可以用到ThreadLocal，在控制层拦截请求把用户信息存入ThreadLocal，这样我们在任何一个地方，都可以取出ThreadLocal中存的用户数据。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSLxvRaYIsxKVfiaiaARYGuicb8atXdAtVhLt8sSbmLMa4PGuMSsVdCxxbw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;ThreadLoca存放用户上下文&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多其它场景的cookie、session等等数据隔离也都可以通过ThreadLocal去实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们常用的数据库连接池也用到了ThreadLocal：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;数据库连接池的连接交给ThreadLoca进行管理，保证当前线程的操作都是同一个Connnection。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;12.ThreadLocal怎么实现的呢？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看一下ThreadLocal的set(T)方法，发现先获取到当前线程，再获取&lt;code&gt;ThreadLocalMap&lt;/code&gt;，然后把元素存到这个map中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;(T value)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//获取当前线程&lt;/span&gt;&lt;br/&gt;        Thread t = Thread.currentThread();&lt;br/&gt;        &lt;span&gt;//获取ThreadLocalMap&lt;/span&gt;&lt;br/&gt;        ThreadLocalMap map = getMap(t);&lt;br/&gt;        &lt;span&gt;//讲当前元素存入map&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (map != &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;            map.set(&lt;span&gt;this&lt;/span&gt;, value);&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;            createMap(t, value);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocal实现的秘密都在这个&lt;code&gt;ThreadLocalMap&lt;/code&gt;了，可以Thread类中定义了一个类型为&lt;code&gt;ThreadLocal.ThreadLocalMap&lt;/code&gt;的成员变量&lt;code&gt;threadLocals&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Thread&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;//ThreadLocal.ThreadLocalMap是Thread的属性&lt;/span&gt;&lt;br/&gt;   ThreadLocal.ThreadLocalMap threadLocals = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocalMap既然被称为Map，那么毫无疑问它是&amp;lt;key,value&amp;gt;型的数据结构。我们都知道map的本质是一个个&amp;lt;key,value&amp;gt;形式的节点组成的数组，那ThreadLocalMap的节点是什么样的呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Entry&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;WeakReference&lt;/span&gt;&amp;lt;&lt;span&gt;ThreadLocal&lt;/span&gt;&amp;lt;?&amp;gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;/** The value associated with this ThreadLocal. */&lt;/span&gt;&lt;br/&gt;            Object value;&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;//节点类&lt;/span&gt;&lt;br/&gt;            Entry(ThreadLocal&amp;lt;?&amp;gt; k, Object v) {&lt;br/&gt;                &lt;span&gt;//key赋值&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;super&lt;/span&gt;(k);&lt;br/&gt;                &lt;span&gt;//value赋值&lt;/span&gt;&lt;br/&gt;                value = v;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的节点，key可以简单低视作ThreadLocal，value为代码中放入的值，当然实际上key并不是ThreadLocal本身，而是它的一个&lt;strong&gt;弱引用&lt;/strong&gt;，可以看到Entry的key继承了 WeakReference（弱引用），再来看一下key怎么赋值的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;WeakReference&lt;/span&gt;&lt;span&gt;(T referent)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(referent);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;key的赋值，使用的是WeakReference的赋值。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSxFgEObg5arqOtcKsnCpibAyuEINwG41poYJtQxiaMowJFv4dhicg6X9tA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;ThreadLoca结构图&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;所以，怎么回答ThreadLocal原理？要答出这几个点：&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Thread类有一个类型为ThreadLocal.ThreadLocalMap的实例变量threadLocals，每个线程都有一个属于自己的ThreadLocalMap。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ThreadLocalMap内部维护着Entry数组，每个Entry代表一个完整的对象，key是ThreadLocal的弱引用，value是ThreadLocal的泛型值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个线程在往ThreadLocal里设置值的时候，都是往自己的ThreadLocalMap里存，读也是以某个ThreadLocal作为引用，在自己的map里找对应的key，从而实现了线程隔离。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ThreadLocal本身不存储值，它只是作为一个key来让线程往ThreadLocalMap里存取值。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;13.ThreadLocal 内存泄露是怎么回事？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来分析一下使用ThreadLocal时的内存，我们都知道，在JVM中，栈内存线程私有，存储了对象的引用，堆内存线程共享，存储了对象实例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以呢，栈中存储了ThreadLocal、Thread的引用，堆中存储了它们的具体实例。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSJOAVnpoBkPjgRy503rPYLiaSGDIqol7Pohf6WQgibNKekuD9Sp4TWJnw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;ThreadLocal内存分配&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocalMap中使用的 key 为 ThreadLocal 的弱引用。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;“弱引用：只要垃圾回收机制一运行，不管JVM的内存空间是否充足，都会回收该对象占用的内存。”&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么现在问题就来了，弱引用很容易被回收，如果ThreadLocal（ThreadLocalMap的Key）被垃圾回收器回收了，但是ThreadLocalMap生命周期和Thread是一样的，它这时候如果不被回收，就会出现这种情况：ThreadLocalMap的key没了，value还在，这就会&lt;strong&gt;造成了内存泄漏问题&lt;/strong&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;那怎么解决内存泄漏问题呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很简单，使用完ThreadLocal后，及时调用remove()方法释放内存空间。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ThreadLocal&amp;lt;String&amp;gt; localVariable = &lt;span&gt;new&lt;/span&gt; ThreadLocal();&lt;br/&gt;&lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    localVariable.set(&lt;span&gt;&quot;鄙人三某”);&lt;br/&gt;    ……&lt;br/&gt;} finally {&lt;br/&gt;    localVariable.remove();&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;那为什么key还要设计成弱引用？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;key设计成弱引用同样是为了防止内存泄漏。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如key被设计成强引用，如果ThreadLocal Reference被销毁，此时它指向ThreadLoca的强引用就没有了，但是此时key还强引用指向ThreadLoca，就会导致ThreadLocal不能被回收，这时候就发生了内存泄漏的问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;14.ThreadLocalMap的结构了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocalMap虽然被叫做Map，其实它是没有实现Map接口的，但是结构还是和HashMap比较类似的，主要关注的是两个要素：&lt;code&gt;元素数组&lt;/code&gt;和&lt;code&gt;散列方法&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSgI4lgEHeM9mwORic2rkq4KJ4vsibqs7eezWc6kiarB3LvnxhibaZzUSIDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;ThreadLocalMap结构示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;元素数组&lt;/p&gt;&lt;p&gt;一个table数组，存储Entry类型的元素，Entry是ThreaLocal弱引用作为key，Object作为value的结构。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt; &lt;span&gt;private&lt;/span&gt; Entry[] table;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;散列方法&lt;/p&gt;&lt;p&gt;散列方法就是怎么把对应的key映射到table数组的相应下标，ThreadLocalMap用的是哈希取余法，取出key的threadLocalHashCode，然后和table数组长度减一&amp;amp;运算（相当于取余）。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; i = key.threadLocalHashCode &amp;amp; (table.length - &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的threadLocalHashCode计算有点东西，每创建一个ThreadLocal对象，它就会新增&lt;code&gt;0x61c88647&lt;/code&gt;，这个值很特殊，它是&lt;strong&gt;斐波那契数&lt;/strong&gt;  也叫 &lt;strong&gt;黄金分割数&lt;/strong&gt;。&lt;code&gt;hash&lt;/code&gt;增量为 这个数字，带来的好处就是 &lt;code&gt;hash&lt;/code&gt; &lt;strong&gt;分布非常均匀&lt;/strong&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; HASH_INCREMENT = &lt;span&gt;0x61c88647&lt;/span&gt;;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;nextHashCode&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; nextHashCode.getAndAdd(HASH_INCREMENT);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;15.ThreadLocalMap怎么解决Hash冲突的？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可能都知道HashMap使用了链表来解决冲突，也就是所谓的链地址法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocalMap没有使用链表，自然也不是用链地址法来解决冲突了，它用的是另外一种方式——&lt;strong&gt;开放定址法&lt;/strong&gt;。开放定址法是什么意思呢？简单来说，就是这个坑被人占了，那就接着去找空着的坑。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSXqlXgzl4viatlpaKZ2NcpQaKOwODCJicogsE6ico6TOFGicv6GGEJmAbTg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;ThreadLocalMap解决冲突&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图所示，如果我们插入一个value=27的数据，通过 hash计算后应该落入第 4 个槽位中，而槽位 4 已经有了 Entry数据，而且Entry数据的key和当前不相等。此时就会线性向后查找，一直找到 Entry为 null的槽位才会停止查找，把元素放到空的槽中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在get的时候，也会根据ThreadLocal对象的hash值，定位到table中的位置，然后判断该槽位Entry对象中的key是否和get的key一致，如果不一致，就判断下一个位置。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;16.ThreadLocalMap扩容机制了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在ThreadLocalMap.set()方法的最后，如果执行完启发式清理工作后，未清理到任何数据，且当前散列数组中&lt;code&gt;Entry&lt;/code&gt;的数量已经达到了列表的扩容阈值&lt;code&gt;(len*2/3)&lt;/code&gt;，就开始执行&lt;code&gt;rehash()&lt;/code&gt;逻辑：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (!cleanSomeSlots(i, sz) &amp;amp;&amp;amp; sz &amp;gt;= threshold)&lt;br/&gt;    rehash();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再着看rehash()具体实现：这里会先去清理过期的Entry，然后还要根据条件判断&lt;code&gt;size &amp;gt;= threshold - threshold / 4&lt;/code&gt; 也就是&lt;code&gt;size &amp;gt;= threshold* 3/4&lt;/code&gt;来决定是否需要扩容。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;rehash&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//清理过期Entry&lt;/span&gt;&lt;br/&gt;    expungeStaleEntries();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//扩容&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (size &amp;gt;= threshold - threshold / &lt;span&gt;4&lt;/span&gt;)&lt;br/&gt;        resize();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//清理过期Entry&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;expungeStaleEntries&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Entry[] tab = table;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; len = tab.length;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; len; j++) {&lt;br/&gt;        Entry e = tab[j];&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; e.get() == &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;            expungeStaleEntry(j);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着看看具体的&lt;code&gt;resize()&lt;/code&gt;方法，扩容后的&lt;code&gt;newTab&lt;/code&gt;的大小为老数组的两倍，然后遍历老的table数组，散列方法重新计算位置，开放地址解决冲突，然后放到新的&lt;code&gt;newTab&lt;/code&gt;，遍历完成之后，&lt;code&gt;oldTab&lt;/code&gt;中所有的&lt;code&gt;entry&lt;/code&gt;数据都已经放入到&lt;code&gt;newTab&lt;/code&gt;中了，然后table引用指向&lt;code&gt;newTab&lt;/code&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSV7Bjxb1CgQ5AIGI4IianWrjsGI6FeU8WkZP88b0HJye0ibdY3lIrcXUw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;ThreadLocalMap扩容&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体代码：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9412568306010929&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSGjqQa74l4ibU9LUxAyiccib1M1ygC69DhiaAY9pLcTsVXh8kB5mG5hAUFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1464&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;ThreadLocalMap resize&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;17.父子线程怎么共享数据？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;父线程能用ThreadLocal来给子线程传值吗？毫无疑问，不能。那该怎么办？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候可以用到另外一个类——&lt;code&gt;InheritableThreadLocal&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用起来很简单，在主线程的InheritableThreadLocal实例设置值，在子线程中就可以拿到了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;InheritableThreadLocalTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; ThreadLocal threadLocal = &lt;span&gt;new&lt;/span&gt; InheritableThreadLocal();&lt;br/&gt;        &lt;span&gt;// 主线程&lt;/span&gt;&lt;br/&gt;        threadLocal.set(&lt;span&gt;&quot;不擅技术&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;//子线程&lt;/span&gt;&lt;br/&gt;        Thread t = &lt;span&gt;new&lt;/span&gt; Thread() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;super&lt;/span&gt;.run();&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;鄙人三某 ，&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;            }&lt;br/&gt;        };&lt;br/&gt;        t.start();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;那原理是什么呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原理很简单，在Thread类里还有另外一个变量：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ThreadLocal.ThreadLocalMap inheritableThreadLocals = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Thread.init的时候，如果父线程的&lt;code&gt;inheritableThreadLocals&lt;/code&gt;不为空，就把它赋给当前线程（子线程）的&lt;code&gt;inheritableThreadLocals&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;        &lt;span&gt;if&lt;/span&gt; (inheritThreadLocals &amp;amp;&amp;amp; parent.inheritableThreadLocals != &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.inheritableThreadLocals =&lt;br/&gt;                ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Java内存模型&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;18.说一下你对Java内存模型（JMM）的理解？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java内存模型（Java Memory Model，JMM），是一种抽象的模型，被定义出来屏蔽各种硬件和操作系统的内存访问差异。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在&lt;code&gt;主内存&lt;/code&gt;（Main Memory）中，每个线程都有一个私有的&lt;code&gt;本地内存&lt;/code&gt;（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java内存模型的抽象图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSnonAhOvsLyIq9oVniaHbQoBBiabb3icDmUj9QPpwr6JTicxLvUXjkyA5iag/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;Java内存模型&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本地内存是JMM的 一个抽象概念，并不真实存在。它其实涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSAc5mhRToS0npoiaVx3X8JlsodFZK6fhurcicHpgRp14WfL8JvicvcOr6A/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;实际线程工作模型&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图里面的是一个双核 CPU 系统架构 ，每个核有自己的控制器和运算器，其中控制器包含一组寄存器和操作控制器，运算器执行算术逻辅运算。每个核都有自己的一级缓存，在有些架构里面还有一个所有 CPU 共享的二级缓存。那么 Java 内存模型里面的工作内存，就对应这里的 Ll 缓存或者 L2 缓存或者 CPU 寄存器。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;19.说说你对原子性、可见性、有序性的理解？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原子性、有序性、可见性是并发编程中非常重要的基础概念，JMM的很多技术都是围绕着这三大特性展开。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;原子性&lt;/strong&gt;：原子性指的是一个操作是不可分割、不可中断的，要么全部执行并且执行的过程不会被任何因素打断，要么就全不执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;可见性&lt;/strong&gt;：可见性指的是一个线程修改了某一个共享变量的值时，其它线程能够立即知道这个修改。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;有序性&lt;/strong&gt;：有序性指的是对于一个线程的执行代码，从前往后依次执行，单线程下可以认为程序是有序的，但是并发时有可能会发生指令重排。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;分析下面几行代码的原子性？&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; j = i;&lt;br/&gt;i++;&lt;br/&gt;i = i + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第1句是基本类型赋值，是原子性操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第2句先读i的值，再赋值到j，两步操作，不能保证原子性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第3和第4句其实是等效的，先读取i的值，再+1，最后赋值到i，三步操作了，不能保证原子性。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原子性、可见性、有序性都应该怎么保证呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;原子性：JMM只能保证基本的原子性，如果要保证一个代码块的原子性，需要使用&lt;code&gt;synchronized&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可见性：Java是利用&lt;code&gt;volatile&lt;/code&gt;关键字来保证可见性的，除此之外，&lt;code&gt;final&lt;/code&gt;和&lt;code&gt;synchronized&lt;/code&gt;也能保证可见性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有序性：&lt;code&gt;synchronized&lt;/code&gt;或者&lt;code&gt;volatile&lt;/code&gt;都可以保证多线程之间操作的有序性。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;20.那说说什么是指令重排？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分3种类型。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应 机器指令的执行顺序。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从Java源代码到最终实际执行的指令序列，会分别经历下面3种重排序，如图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSic5DZznpibPK6xYic2ia1qfAvCm2rgjicibgxl13iaib4EIFbCkTuTQibianGebw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;多级指令重排&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们比较熟悉的双重校验单例模式就是一个经典的指令重排的例子，&lt;code&gt;Singleton instance=new Singleton()；&lt;/code&gt;对应的JVM指令分为三步：分配内存空间--&amp;gt;初始化对象---&amp;gt;对象指向分配的内存空间，但是经过了编译器的指令重排序，第二步和第三步就可能会重排序。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSoocg32Q3ch7OlT42qibFohN60RgRYZ7sMAx6iciaHRDictnV8mJjib0Cy7w/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;双重校验单例模式异常情形&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;21.指令重排有限制吗？happens-before了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;指令重排也是有一些限制的，有两个规则&lt;code&gt;happens-before&lt;/code&gt;和&lt;code&gt;as-if-serial&lt;/code&gt;来约束。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;happens-before的定义：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照 happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;happens-before和我们息息相关的有六大规则：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSG26AK357jeffoicWUO9hou5heVHIz0ib2Dzk3tz5mcWSWmFUXhGja5Lg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;happens-before六大规则&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;程序顺序规则&lt;/strong&gt;：一个线程中的每个操作，happens-before于该线程中的任意后续操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;监视器锁规则&lt;/strong&gt;：对一个锁的解锁，happens-before于随后对这个锁的加锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;volatile变量规则&lt;/strong&gt;：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;传递性&lt;/strong&gt;：如果A happens-before B，且B happens-before C，那么A happens-before C。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;start()规则&lt;/strong&gt;：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的 ThreadB.start()操作happens-before于线程B中的任意操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;join()规则&lt;/strong&gt;：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作 happens-before于线程A从ThreadB.join()操作成功返回。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;22.as-if-serial又是什么？单线程的程序一定是顺序的吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;as-if-serial语义的意思是：不管怎么重排序（编译器和处理器为了提高并行度），&lt;strong&gt;单线程程序的执行结果不能被改变&lt;/strong&gt;。编译器、runtime和处理器都必须遵守as-if-serial语义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。为了具体说明，请看下面计算圆面积的代码示例。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;double&lt;/span&gt; pi = &lt;span&gt;3.14&lt;/span&gt;;   &lt;span&gt;// A&lt;/span&gt;&lt;br/&gt;&lt;span&gt;double&lt;/span&gt; r = &lt;span&gt;1.0&lt;/span&gt;;   &lt;span&gt;// B &lt;/span&gt;&lt;br/&gt;&lt;span&gt;double&lt;/span&gt; area = pi * r * r;   &lt;span&gt;// C&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面3个操作的数据依赖关系：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSoicqQts0bjMgrE0ydNavibWlNQ2PoXiadcZBFQoZw1osxvKymibuIqYYSw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;image-20210812200646364&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;A和C之间存在数据依赖关系，同时B和C之间也存在数据依赖关系。因此在最终执行的指令序列中，C不能被重排序到A和B的前面（C排到A和B的前面，程序的结果将会被改变）。但A和B之间没有数据依赖关系，编译器和处理器可以重排序A和B之间的执行顺序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以最终，程序可能会有两种执行顺序：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSicLH66iaiaxc40M9Trt5Oibibeh38rTWArPs9lzibbbiar9cZydb3CUjT6zhQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;两种执行结果&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;as-if-serial语义把单线程程序保护了起来，遵守as-if-serial语义的编译器、runtime和处理器共同编织了这么一个“楚门的世界”：单线程程序是按程序的“顺序”来执行的。as- if-serial语义使单线程情况下，我们不需要担心重排序的问题，可见性的问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;23.volatile实现原理了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;volatile有两个作用，保证&lt;strong&gt;可见性&lt;/strong&gt;和&lt;strong&gt;有序性&lt;/strong&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;volatile怎么保证可见性的呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相比synchronized的加锁方式来解决共享变量的内存可见性问题，volatile就是更轻量的选择，它没有上下文切换的额外开销成本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;volatile可以确保对某个变量的更新对其他线程马上可见，一个变量被声明为volatile 时，线程在写入变量时不会把值缓存在寄存器或者其他地方，而是会把值刷新回主内存 当其它线程读取该共享变量 ，会从主内存重新获取最新值，而不是使用当前线程的本地内存中的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，我们声明一个 volatile 变量 volatile int x = 0，线程A修改x=1，修改完之后就会把新的值刷新回主内存，线程B读取x的时候，就会清空本地内存变量，然后再从主内存获取最新值。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSGcrh3iaF31I0HPWFgCvJwYz9LzdocCsvDwwpTLFcWCib9WDUOXJBSYRw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;volatile内存可见性&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;volatile怎么保证有序性的呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重排序可以分为编译器重排序和处理器重排序，valatile保证有序性，就是通过分别限制这两种类型的重排序。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTS2ZQ1DzwFGiao8t8BK6RrXAfZxXKiagoDmcWY2vqxuLKTr7SvlJNyQsRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;volatile重排序规则表&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在每个volatile写操作的前面插入一个&lt;code&gt;StoreStore&lt;/code&gt;屏障&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在每个volatile写操作的后面插入一个&lt;code&gt;StoreLoad&lt;/code&gt;屏障&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在每个volatile读操作的后面插入一个&lt;code&gt;LoadLoad&lt;/code&gt;屏障&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在每个volatile读操作的后面插入一个&lt;code&gt;LoadStore&lt;/code&gt;屏障&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTS3M20yZxcKh01sIRcmlfictrIiaFiamFAz6F6heFib3rUNekdic6aBcxQd8A/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;volatile写插入内存屏障后生成的指令序列示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSckMwF6bKicicIo4KB8WWUBtxiazY0RYjkaHTPSficTicqFN8T1AJZ1ZHhoQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;volatile写插入内存屏障后生成的指令序列示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;锁&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;24.synchronized用过吗？怎么使用？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;synchronized经常用的，用来保证代码的原子性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;synchronized主要有三种用法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;修饰实例方法:&lt;/strong&gt; 作用于当前对象实例加锁，进入同步代码前要获得 &lt;strong&gt;当前对象实例的锁&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;method&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;//业务代码&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;修饰静态方法&lt;/strong&gt;：也就是给当前类加锁，会作⽤于类的所有对象实例 ，进⼊同步代码前要获得当前 class 的锁。因为静态成员不属于任何⼀个实例对象，是类成员（ static 表明这是该类的⼀个静态资源，不管 new 了多少个对象，只有⼀份）。&lt;/p&gt;&lt;p&gt;如果⼀个线程 A 调⽤⼀个实例对象的⾮静态 synchronized ⽅法，⽽线程 B 需要调⽤这个实例对象所属类的静态 synchronized ⽅法，是允许的，不会发⽣互斥现象，因为访问静态 synchronized ⽅法占⽤的锁是当前类的锁，⽽访问⾮静态 synchronized ⽅法占⽤的锁是当前实例对象锁。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; staic &lt;span&gt;method&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;//业务代码&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;修饰代码块&lt;/strong&gt; ：指定加锁对象，对给定对象/类加锁。synchronized(this|object) 表示进⼊同步代码库前要获得给定对象的锁。synchronized(类.class) 表示进⼊同步代码前要获得 当前 &lt;strong&gt;class&lt;/strong&gt; 的锁&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;synchronized&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;) {&lt;br/&gt; &lt;span&gt;//业务代码&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;25.synchronized的实现原理？&lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;synchronized是怎么加锁的呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们使用synchronized的时候，发现不用自己去lock和unlock，是因为JVM帮我们把这个事情做了。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;synchronized修饰代码块时，JVM采用&lt;code&gt;monitorenter&lt;/code&gt;、&lt;code&gt;monitorexit&lt;/code&gt;两个指令来实现同步，&lt;code&gt;monitorenter&lt;/code&gt; 指令指向同步代码块的开始位置， &lt;code&gt;monitorexit&lt;/code&gt; 指令则指向同步代码块的结束位置。&lt;/p&gt;&lt;p&gt;反编译一段synchronized修饰代码块代码，&lt;code&gt;javap -c -s -v -l SynchronizedDemo.class&lt;/code&gt;，可以看到相应的字节码指令。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSRr65FWYHibtxk43IlzxZEuO4ibSzXiakqolF1FWDibuWGWRqqF5xG89zTQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;monitorenter和monitorexit&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;synchronized修饰同步方法时，JVM采用&lt;code&gt;ACC_SYNCHRONIZED&lt;/code&gt;标记符来实现同步，这个标识指明了该方法是一个同步方法。&lt;/p&gt;&lt;p&gt;同样可以写段代码反编译看一下。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSvZkByFiaSR186ic6tG7tMUaz2gWloo5WpChlWgg0zOkmbzicLQibzBhX2g/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;synchronized修饰同步方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;synchronized锁住的是什么呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;monitorenter、monitorexit或者ACC_SYNCHRONIZED都是&lt;strong&gt;基于Monitor实现&lt;/strong&gt;的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实例对象结构里有对象头，对象头里面有一块结构叫Mark Word，Mark Word指针指向了&lt;strong&gt;monitor&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所谓的Monitor其实是一种&lt;strong&gt;同步工具&lt;/strong&gt;，也可以说是一种&lt;strong&gt;同步机制&lt;/strong&gt;。在Java虚拟机（HotSpot）中，Monitor是由&lt;strong&gt;ObjectMonitor实现&lt;/strong&gt;的，可以叫做内部锁，或者Monitor锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ObjectMonitor的工作原理：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ObjectMonitor有两个队列：_WaitSet、_EntryList，用来保存ObjectWaiter 对象列表。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;_owner，获取 Monitor 对象的线程进入 _owner 区时， _count + 1。如果线程调用了 wait() 方法，此时会释放 Monitor 对象， _owner 恢复为空， _count - 1。同时该等待线程进入 _WaitSet 中，等待被唤醒。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ObjectMonitor() {&lt;br/&gt;    _header       = NULL;&lt;br/&gt;    _count        = &lt;span&gt;0&lt;/span&gt;; &lt;span&gt;// 记录线程获取锁的次数&lt;/span&gt;&lt;br/&gt;    _waiters      = &lt;span&gt;0&lt;/span&gt;,&lt;br/&gt;    _recursions   = &lt;span&gt;0&lt;/span&gt;;  &lt;span&gt;//锁的重入次数&lt;/span&gt;&lt;br/&gt;    _object       = NULL;&lt;br/&gt;    _owner        = NULL;  &lt;span&gt;// 指向持有ObjectMonitor对象的线程&lt;/span&gt;&lt;br/&gt;    _WaitSet      = NULL;  &lt;span&gt;// 处于wait状态的线程，会被加入到_WaitSet&lt;/span&gt;&lt;br/&gt;    _WaitSetLock  = &lt;span&gt;0&lt;/span&gt; ;&lt;br/&gt;    _Responsible  = NULL ;&lt;br/&gt;    _succ         = NULL ;&lt;br/&gt;    _cxq          = NULL ;&lt;br/&gt;    FreeNext      = NULL ;&lt;br/&gt;    _EntryList    = NULL ;  &lt;span&gt;// 处于等待锁block状态的线程，会被加入到该列表&lt;/span&gt;&lt;br/&gt;    _SpinFreq     = &lt;span&gt;0&lt;/span&gt; ;&lt;br/&gt;    _SpinClock    = &lt;span&gt;0&lt;/span&gt; ;&lt;br/&gt;    OwnerIsThread = &lt;span&gt;0&lt;/span&gt; ;&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以类比一个去医院就诊的例子[18]：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;首先，患者在&lt;strong&gt;门诊大厅&lt;/strong&gt;前台或自助挂号机&lt;strong&gt;进行挂号&lt;/strong&gt;；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;随后，挂号结束后患者找到对应的&lt;strong&gt;诊室就诊&lt;/strong&gt;：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;诊室每次只能有一个患者就诊；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果此时诊室空闲，直接进入就诊；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果此时诊室内有其它患者就诊，那么当前患者进入&lt;strong&gt;候诊室&lt;/strong&gt;，等待叫号；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;就诊结束后，&lt;strong&gt;走出就诊室&lt;/strong&gt;，候诊室的&lt;strong&gt;下一位候诊患者&lt;/strong&gt;进入就诊室。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSiagkLrT13ODJIGtCoqmkaqHAr8ajLSn9yrssSYc4tCuFyFzmtFRW5BA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;就诊-图片来源参考[18]&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个过程就和Monitor机制比较相似：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;门诊大厅&lt;/strong&gt;：所有待进入的线程都必须先在&lt;strong&gt;入口Entry Set&lt;/strong&gt;挂号才有资格；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;就诊室&lt;/strong&gt;：就诊室**_Owner**里里只能有一个线程就诊，就诊完线程就自行离开&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;候诊室&lt;/strong&gt;：就诊室繁忙时，进入&lt;strong&gt;等待区（Wait Set）&lt;/strong&gt;，就诊室空闲的时候就从**等待区（Wait Set）**叫新的线程&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSos3QdH4PxYjvib985CQRpnWcRVfjEPUUpNlOS9qdqVcMeiaP45JeH4xg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;Java Montior机制&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们就知道了，同步是锁住的什么东西：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;monitorenter，在判断拥有同步标识 ACC_SYNCHRONIZED 抢先进入此方法的线程会优先拥有 Monitor 的 owner ，此时计数器 +1。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;monitorexit，当执行完退出后，计数器 -1，归 0 后被其他进入的线程获得。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;26.除了原子性，synchronized可见性，有序性，可重入性怎么实现？&lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;synchronized怎么保证可见性？&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;线程加锁前，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程加锁后，其它线程无法获取主内存中的共享变量。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程解锁前，必须把共享变量的最新值刷新到主内存中。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;synchronized怎么保证有序性？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;synchronized同步的代码块，具有排他性，一次只能被一个线程拥有，所以synchronized保证同一时刻，代码是单线程执行的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为as-if-serial语义的存在，单线程的程序能保证最终结果是有序的，但是不保证不会指令重排。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以synchronized保证的有序是执行结果的有序性，而不是防止指令重排的有序性。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;synchronized怎么实现可重入的呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;synchronized 是可重入锁，也就是说，允许一个线程二次请求自己持有对象锁的临界资源，这种情况称为可重入锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;synchronized 锁对象的时候有个计数器，他会记录下线程获取锁的次数，在执行完对应的代码块之后，计数器就会-1，直到计数器清零，就释放锁了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之所以，是可重入的。是因为 synchronized 锁对象有个计数器，会随着线程获取锁后 +1 计数，当线程执行完毕后 -1，直到清零释放锁。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;27.锁升级？synchronized优化了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;了解锁升级，得先知道，不同锁的状态是什么样的。这个状态指的是什么呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java对象头里，有一块结构，叫&lt;code&gt;Mark Word&lt;/code&gt;标记字段，这块结构会随着锁的状态变化而变化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;64 位虚拟机 Mark Word 是 64bit，我们来看看它的状态变化：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSIibOhyPThvSk8jq1BpXuUcrcNfa2M7VEXg5yQn8NCFLLic4zMr8pG8EQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;Mark Word变化&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Mark Word存储对象自身的运行数据，如&lt;strong&gt;哈希码、GC分代年龄、锁状态标志、偏向时间戳（Epoch）&lt;/strong&gt; 等。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;synchronized做了哪些优化？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在JDK1.6之前，synchronized的实现直接调用ObjectMonitor的enter和exit，这种锁被称之为&lt;strong&gt;重量级锁&lt;/strong&gt;。从JDK6开始，HotSpot虚拟机开发团队对Java中的锁进行优化，如增加了适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁等优化策略，提升了synchronized的性能。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;偏向锁：在无竞争的情况下，只是在Mark Word里存储当前线程指针，CAS操作都不做。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;轻量级锁：在没有多线程竞争时，相对重量级锁，减少操作系统互斥量带来的性能消耗。但是，如果存在锁竞争，除了互斥量本身开销，还额外有CAS操作的开销。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;自旋锁：减少不必要的CPU上下文切换。在轻量级锁升级为重量级锁时，就使用了自旋加锁的方式&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;锁粗化：将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;锁消除：虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;锁升级的过程是什么样的？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;锁升级方向：无锁--&amp;gt;偏向锁---&amp;gt; 轻量级锁----&amp;gt;重量级锁，这个方向基本上是不可逆的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSFBicqibx89V9xFTHnSrdwBvrxTmdichAPglf9UQtxhNNJYtiamtDxGJRug/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;锁升级方向&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看一下升级的过程：&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;偏向锁：&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;偏向锁的获取：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;判断是否为可偏向状态--MarkWord中锁标志是否为‘01’，是否偏向锁是否为‘1’&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果是可偏向状态，则查看线程ID是否为当前线程，如果是，则进入步骤&#x27;5&#x27;，否则进入步骤‘3’&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过CAS操作竞争锁，如果竞争成功，则将MarkWord中线程ID设置为当前线程ID，然后执行‘5’；竞争失败，则执行‘4’&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CAS获取偏向锁失败表示有竞争。当达到safepoint时获得偏向锁的线程被挂起，&lt;strong&gt;偏向锁升级为轻量级锁&lt;/strong&gt;，然后被阻塞在安全点的线程继续往下执行同步代码块&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;执行同步代码&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;偏向锁的撤销：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;偏向锁不会主动释放(撤销)，只有遇到其他线程竞争时才会执行撤销，由于撤销需要知道当前持有该偏向锁的线程栈状态，因此要等到safepoint时执行，此时持有该偏向锁的线程（T）有‘2’，‘3’两种情况；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;撤销----T线程已经退出同步代码块，或者已经不再存活，则直接撤销偏向锁，变成无锁状态----该状态达到阈值20则执行批量重偏向&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;升级----T线程还在同步代码块中，则将T线程的偏向锁&lt;strong&gt;升级为轻量级锁&lt;/strong&gt;，当前线程执行轻量级锁状态下的锁获取步骤----该状态达到阈值40则执行批量撤销&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;轻量级锁：&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;轻量级锁的获取：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;进行加锁操作时，jvm会判断是否已经时重量级锁，如果不是，则会在当前线程栈帧中划出一块空间，作为该锁的锁记录，并且将锁对象MarkWord复制到该锁记录中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;复制成功之后，jvm使用CAS操作将对象头MarkWord更新为指向锁记录的指针，并将锁记录里的owner指针指向对象头的MarkWord。如果成功，则执行‘3’，否则执行‘4’&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;更新成功，则当前线程持有该对象锁，并且对象MarkWord锁标志设置为‘00’，即表示此对象处于轻量级锁状态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;更新失败，jvm先检查对象MarkWord是否指向当前线程栈帧中的锁记录，如果是则执行‘5’，否则执行‘4’&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;表示锁重入；然后当前线程栈帧中增加一个锁记录第一部分（Displaced Mark Word）为null，并指向Mark Word的锁对象，起到一个重入计数器的作用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;表示该锁对象已经被其他线程抢占，则进行&lt;strong&gt;自旋等待&lt;/strong&gt;（默认10次），等待次数达到阈值仍未获取到锁，则&lt;strong&gt;升级为重量级锁&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大体上省简的升级过程：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSUdHGNFiaN1E2Zr5MxUCOLXzsmdazwmo4icmdbDt1Trq3jnKPMuJ7jia9g/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;锁升级简略过程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完整的升级过程：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSkjvnRAc4TnSIA1U2icO3p0LuvwqOjhxmPUuNkUXf1joULVyycxHeu8A/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;synchronized 锁升级过程-来源参考[14]&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;28.说说synchronized和ReentrantLock的区别？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以从锁的实现、功能特点、性能等几个维度去回答这个问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;锁的实现：&lt;/strong&gt; synchronized是Java语言的关键字，基于JVM实现。而ReentrantLock是基于JDK的API层面实现的（一般是lock()和unlock()方法配合try/finally 语句块来完成。）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;性能：&lt;/strong&gt; 在JDK1.6锁优化以前，synchronized的性能比ReenTrantLock差很多。但是JDK6开始，增加了适应性自旋、锁消除等，两者性能就差不多了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;功能特点：&lt;/strong&gt; ReentrantLock 比 synchronized 增加了一些高级功能，如等待可中断、可实现公平锁、可实现选择性通知。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ReentrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;synchronized与wait()和notify()/notifyAll()方法结合实现等待/通知机制，ReentrantLock类借助Condition接口与newCondition()方法实现。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ReentrantLock需要手工声明来加锁和释放锁，一般跟finally配合释放锁。而synchronized不用手动释放锁。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面的表格列出出了两种锁之间的区别：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSYVosAF4icCeqKaSzMCOibQBHniaPwlicAVUiapic0M78KCQsoH8NkkGDibTicA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;synchronized和ReentrantLock的区别&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;29.AQS了解多少？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AbstractQueuedSynchronizer 抽象同步队列，简称 AQS ，它是Java并发包的根基，并发包中的锁就是基于AQS实现的。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;AQS是基于一个FIFO的双向队列，其内部定义了一个节点类Node，Node 节点内部的 SHARED 用来标记该线程是获取共享资源时被阻挂起后放入AQS 队列的， EXCLUSIVE 用来标记线程是 取独占资源时被挂起后放入AQS 队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;AQS 使用一个 volatile 修饰的 int 类型的成员变量 state 来表示同步状态，修改同步状态成功即为获得锁，volatile 保证了变量在多线程之间的可见性，修改 State 值时通过 CAS 机制来保证修改的原子性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;获取state的方式分为两种，独占方式和共享方式，一个线程使用独占方式获取了资源，其它线程就会在获取失败后被阻塞。一个线程使用共享方式获取了资源，另外一个线程还可以通过CAS的方式进行获取。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果共享资源被占用，需要一定的阻塞等待唤醒机制来保证锁的分配，AQS 中会将竞争共享资源失败的线程添加到一个变体的 CLH 队列中。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSHibmXuU9fNatvbDvmliawbRgKe1N7ThtQPKaJicIVTnY6jfgp0KzwktWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;先简单了解一下CLH：Craig、Landin and Hagersten 队列，是 &lt;strong&gt;单向链表实现的队列&lt;/strong&gt;。申请线程只在本地变量上自旋，&lt;strong&gt;它不断轮询前驱的状态&lt;/strong&gt;，如果发现 &lt;strong&gt;前驱节点释放了锁就结束自旋&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSb1rsYZx0s7UfGico3DU3xL4vVWuopBj5fE9jJPyMutQkFgOom8phllA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;CLH队列&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AQS 中的队列是 CLH 变体的虚拟双向队列，通过将每条请求共享资源的线程封装成一个节点来实现锁的分配：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTShod0nzG9dWkP9pgooxqstkWOSmtiahqPMdIp9FGicaujPkWFyuEHb7Fw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;AQS变种CLH队列&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AQS 中的 CLH 变体等待队列拥有以下特性：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;AQS 中队列是个双向链表，也是 FIFO 先进先出的特性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过 Head、Tail 头尾两个节点来组成队列结构，通过 volatile 修饰保证可见性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Head 指向节点为已获得锁的节点，是一个虚拟节点，节点本身不持有具体线程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;获取不到同步状态，会将节点进行自旋获取锁，自旋一定次数失败后会将线程阻塞，相对于 CLH 队列性能较好&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ps:AQS源码里面有很多细节可问，建议有时间好好看看AQS源码。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;30.&lt;strong&gt;ReentrantLock&lt;/strong&gt;实现原理？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ReentrantLock 是可重入的独占锁，只能有一个线程可以获取该锁，其它获取该锁的线程会被阻塞而被放入该锁的阻塞队列里面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看看ReentrantLock的加锁操作：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;// 创建非公平锁&lt;/span&gt;&lt;br/&gt;    ReentrantLock lock = &lt;span&gt;new&lt;/span&gt; ReentrantLock();&lt;br/&gt;    &lt;span&gt;// 获取锁操作&lt;/span&gt;&lt;br/&gt;    lock.lock();&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// 执行代码逻辑&lt;/span&gt;&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (Exception ex) {&lt;br/&gt;        &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// 解锁操作&lt;/span&gt;&lt;br/&gt;        lock.unlock();&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;new ReentrantLock()&lt;/code&gt;构造函数默认创建的是非公平锁 NonfairSync。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;公平锁 FairSync&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU 唤醒阻塞线程的开销比非公平锁大&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;非公平锁 NonfairSync&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU 不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认创建的对象lock()的时候：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果锁当前没有被其它线程占用，并且当前线程之前没有获取过该锁，则当前线程会获取到该锁，然后设置当前锁的拥有者为当前线程，并设置 AQS 的状态值为1 ，然后直接返回。如果当前线程之前己经获取过该锁，则这次只是简单地把 AQS 的状态值加1后返回。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果该锁己经被其他线程持有，非公平锁会尝试去获取锁，获取失败的话，则调用该方法线程会被放入 AQS 队列阻塞挂起。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSxW4UK7CjYTOdRgwfib67w89iay9r7m4vhSzZQ24LXNFaKqtFyq8ibHu9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;ReentrantLock 非公平锁加锁流程简图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;31.ReentrantLock怎么实现公平锁的？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;new ReentrantLock()&lt;/code&gt;构造函数默认创建的是非公平锁 NonfairSync&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;ReentrantLock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    sync = &lt;span&gt;new&lt;/span&gt; NonfairSync();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时也可以在创建锁构造函数中传入具体参数创建公平锁 FairSync&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ReentrantLock lock = &lt;span&gt;new&lt;/span&gt; ReentrantLock(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;--- ReentrantLock&lt;br/&gt;&lt;span&gt;// true 代表公平锁，false 代表非公平锁&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;ReentrantLock&lt;/span&gt;&lt;span&gt;(&lt;span&gt;boolean&lt;/span&gt; fair)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    sync = fair ? &lt;span&gt;new&lt;/span&gt; FairSync() : &lt;span&gt;new&lt;/span&gt; NonfairSync();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;FairSync、NonfairSync 代表公平锁和非公平锁，两者都是 ReentrantLock 静态内部类，只不过实现不同锁语义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;非公平锁和公平锁的两处不同：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSCS1z5onhYJcWagbrTJI5rcWrKribFQ5S3j7lMibJfwJY9z2vL2BDx6zg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;公平锁tryAcquire&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;32.CAS呢？CAS了解多少？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CAS叫做CompareAndSwap，⽐较并交换，主要是通过处理器的指令来保证操作的原⼦性的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CAS 指令包含 3 个参数：共享变量的内存地址 A、预期的值 B 和共享变量的新值 C。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只有当内存中地址 A 处的值等于 B 时，才能将内存中地址 A 处的值更新为新值 C。作为一条 CPU 指令，CAS 指令本身是能够保证原子性的 。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;33.CAS 有什么问题？如何解决？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CAS的经典三大问题：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSCmW9YFZQxA82BH87mhNickMyP1GtHDUTQoTO5ajoPfvKeNgBfI9U0iaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;CAS三大问题&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;ABA 问题&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并发环境下，假设初始条件是A，去修改数据时，发现是A就会执行修改。但是看到的虽然是A，中间可能发生了A变B，B又变回A的情况。此时A已经非彼A，数据即使成功修改，也可能有问题。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;怎么解决ABA问题？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每次修改变量，都在这个变量的版本号上加1，这样，刚刚A-&amp;gt;B-&amp;gt;A，虽然A的值没变，但是它的版本号已经变了，再判断版本号就会发现此时的A已经被改过了。参考乐观锁的版本号，这种做法可以给数据带上了一种实效性的检验。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java提供了AtomicStampReference类，它的compareAndSet方法首先检查当前的对象引用值是否等于预期引用，并且当前印戳（Stamp）标志是否等于预期标志，如果全部相等，则以原子方式将引用值和印戳标志的值更新为给定的更新值。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;循环性能开销&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自旋CAS，如果一直循环执行，一直不成功，会给CPU带来非常大的执行开销。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;怎么解决循环性能开销问题？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Java中，很多使用自旋CAS的地方，会有一个自旋次数的限制，超过一定次数，就停止自旋。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;只能保证一个变量的原子操作&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CAS 保证的是对一个变量执行操作的原子性，如果对多个变量操作时，CAS 目前无法直接保证操作的原子性的。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;怎么解决只能保证一个变量的原子操作问题？&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;可以考虑改用锁来保证操作的原子性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以考虑合并多个变量，将多个变量封装成一个对象，通过AtomicReference来保证原子性。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;34.Java有哪些保证原子性的方法？如何保证多线程下i++ 结果正确？&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSzoU0PfIVzIW6XOxevaHvDKTibuysDUZaDOibBElaM77pMYIM7kAKd43A/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;Java保证原子性方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;使用循环原子类，例如AtomicInteger，实现i++原子操作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用juc包下的锁，如ReentrantLock ，对i++操作加锁lock.lock()来实现原子性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用synchronized，对i++操作加锁&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;35.原子操作类了解多少？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当程序更新一个变量时，如果多线程同时更新这个变量，可能得到期望之外的值，比如变量i=1，A线程更新i+1，B线程也更新i+1，经过两个线程操作之后可能i不等于3，而是等于2。因为A和B线程在更新变量i的时候拿到的i都是1，这就是线程不安全的更新操作，一般我们会使用synchronized来解决这个问题，synchronized会保证多线程不会同时更新变量i。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实除此之外，还有更轻量级的选择，Java从JDK 1.5开始提供了java.util.concurrent.atomic包，这个包中的原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为变量的类型有很多种，所以在Atomic包里一共提供了13个类，属于4种类型的原子更新方式，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性（字段）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSQDecO0hWicHCSFaxnibCBlyH2bxBGvEeZr4cmYIiavD4D7o9YSlSfk67w/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;原子操作类&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Atomic包里的类基本都是使用Unsafe实现的包装类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用原子的方式更新基本类型，Atomic包提供了以下3个类：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;AtomicBoolean：原子更新布尔类型。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;AtomicInteger：原子更新整型。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;AtomicLong：原子更新长整型。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过原子的方式更新数组里的某个元素，Atomic包提供了以下4个类：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;AtomicIntegerArray：原子更新整型数组里的元素。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;AtomicLongArray：原子更新长整型数组里的元素。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;AtomicReferenceArray：原子更新引用类型数组里的元素。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;AtomicIntegerArray类主要是提供原子的方式更新数组里的整型&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原子更新基本类型的AtomicInteger，只能更新一个变量，如果要原子更新多个变量，就需要使用这个原子更新引用类型提供的类。Atomic包提供了以下3个类：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;AtomicReference：原子更新引用类型。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;AtomicReferenceFieldUpdater：原子更新引用类型里的字段。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;AtomicMarkableReference：原子更新带有标记位的引用类型。可以原子更新一个布尔类型的标记位和引用类型。构造方法是AtomicMarkableReference（V initialRef，boolean initialMark）。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果需原子地更新某个类里的某个字段时，就需要使用原子更新字段类，Atomic包提供了以下3个类进行原子字段更新：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;AtomicLongFieldUpdater：原子更新长整型字段的更新器。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于原子的更新数据和数据的版本号，可以解决使用CAS进行原子更新时可能出现的 ABA问题。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;36.AtomicInteger 的原理？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一句话概括：&lt;strong&gt;使用CAS实现&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以AtomicInteger的添加方法为例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;getAndIncrement&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; unsafe.getAndAddInt(&lt;span&gt;this&lt;/span&gt;, valueOffset, &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过&lt;code&gt;Unsafe&lt;/code&gt;类的实例来进行添加操作，来看看具体的CAS操作：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;getAndAddInt&lt;/span&gt;&lt;span&gt;(Object var1, &lt;span&gt;long&lt;/span&gt; var2, &lt;span&gt;int&lt;/span&gt; var4)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; var5;&lt;br/&gt;        &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;            var5 = &lt;span&gt;this&lt;/span&gt;.getIntVolatile(var1, var2);&lt;br/&gt;        } &lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;this&lt;/span&gt;.compareAndSwapInt(var1, var2, var5, var5 + var4));&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; var5;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;compareAndSwapInt 是一个native方法，基于CAS来操作int类型变量。其它的原子操作类基本都是大同小异。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;37.线程死锁了解吗？该如何避免？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象，在无外力作用的情况下，这些线程会一直相互等待而无法继续运行下去。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSJZBWAeMMS4QmWpfWhuUf9hmricZSX2fE9hRjatRjNVCoMXxbwDN9GxA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;死锁示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么为什么会产生死锁呢？死锁的产生必须具备以下四个条件：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSLvMeyd8aibH7WpmtvvqgVnricnFQEEA0waM0CytWbM53yGcr4jOlHxFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;死锁产生必备四条件&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;互斥条件：指线程对己经获取到的资源进行它性使用，即该资源同时只由一个线程占用。如果此时还有其它线程请求获取获取该资源，则请求者只能等待，直至占有资源的线程释放该资源。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;请求并持有条件：指一个 线程己经持有了至少一个资源，但又提出了新的资源请求，而新资源己被其它线程占有，所以当前线程会被阻塞，但阻塞 的同时并不释放自己已经获取的资源。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不可剥夺条件：指线程获取到的资源在自己使用完之前不能被其它线程抢占，只有在自己使用完毕后才由自己释放该资源。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;环路等待条件：指在发生死锁时，必然存在一个线程——资源的环形链，即线程集合 {T0，T1，T2,…… ，Tn} 中 T0 正在等待一 T1 占用的资源，Tl1正在等待 T2用的资源，…… Tn 在等待己被 T0占用的资源。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该如何避免死锁呢？答案是&lt;strong&gt;至少破坏死锁发生的一个条件&lt;/strong&gt;。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;其中，互斥这个条件我们没有办法破坏，因为用锁为的就是互斥。不过其他三个条件都是有办法破坏掉的，到底如何做呢？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;对于“请求并持有”这个条件，可以一次性请求所有的资源。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;对于“不可剥夺”这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;对于“环路等待”这个条件，可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后就不存在环路了。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;38.那死锁问题怎么排查呢？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以使用jdk自带的命令行工具排查：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;使用jps查找运行的Java进程：jps -l&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用jstack查看线程堆栈信息：jstack -l  进程id&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基本就可以看到死锁的信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还可以利用图形化工具，比如JConsole。出现线程死锁以后，点击JConsole线程面板的&lt;code&gt;检测到死锁&lt;/code&gt;按钮，将会看到线程的死锁信息。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSZaDcxh51tkQdYyOk2Mj56hV8d1c3L1HAdzZ0MREJXicxXicrWj0rlGdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;线程死锁检测&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;并发工具类&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;39.CountDownLatch（倒计数器）了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CountDownLatch，倒计数器，有两个常见的应用场景[18]：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;场景1：协调子线程结束动作：等待所有子线程运行结束&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CountDownLatch允许一个或多个线程等待其他线程完成操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，我们很多人喜欢玩的王者荣耀，开黑的时候，得等所有人都上线之后，才能开打。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSDeuziaia9bUbDlgkVXZuy3Tn8mhsbfV0cHY6Y44VGXblHuzxDpibwibLng/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;figcaption&gt;王者荣耀等待玩家确认-来源参考[18]&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CountDownLatch模仿这个场景(参考[18])：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建大乔、兰陵王、安其拉、哪吒和铠等五个玩家，主线程必须在他们都完成确认后，才可以继续运行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这段代码中，&lt;code&gt;new CountDownLatch(5)&lt;/code&gt;用户创建初始的latch数量，各玩家通过&lt;code&gt;countDownLatch.countDown()&lt;/code&gt;完成状态确认，主线程通过&lt;code&gt;countDownLatch.await()&lt;/code&gt;等待。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;        CountDownLatch countDownLatch = &lt;span&gt;new&lt;/span&gt; CountDownLatch(&lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        Thread 大乔 = &lt;span&gt;new&lt;/span&gt; Thread(countDownLatch::countDown);&lt;br/&gt;        Thread 兰陵王 = &lt;span&gt;new&lt;/span&gt; Thread(countDownLatch::countDown);&lt;br/&gt;        Thread 安其拉 = &lt;span&gt;new&lt;/span&gt; Thread(countDownLatch::countDown);&lt;br/&gt;        Thread 哪吒 = &lt;span&gt;new&lt;/span&gt; Thread(countDownLatch::countDown);&lt;br/&gt;        Thread 铠 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;// 稍等，上个卫生间，马上到...&lt;/span&gt;&lt;br/&gt;                Thread.sleep(&lt;span&gt;1500&lt;/span&gt;);&lt;br/&gt;                countDownLatch.countDown();&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (InterruptedException ignored) {}&lt;br/&gt;        });&lt;br/&gt;&lt;br/&gt;        大乔.start();&lt;br/&gt;        兰陵王.start();&lt;br/&gt;        安其拉.start();&lt;br/&gt;        哪吒.start();&lt;br/&gt;        铠.start();&lt;br/&gt;        countDownLatch.await();&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;所有玩家已经就位！&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;场景2. 协调子线程开始动作：统一各线程动作开始的时机&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;王者游戏中也有类似的场景，游戏开始时，各玩家的初始状态必须一致。不能有的玩家都出完装了，有的才降生。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以大家得一块出生，在&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTS5ibDQ2dibUe6icuZLpE6FxA33gtJ4f86g1BgCSOiaDHl5hwEO29gXOJhBA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;figcaption&gt;王者荣耀-来源参考[18]&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个场景中，仍然用五个线程代表大乔、兰陵王、安其拉、哪吒和铠等五个玩家。需要注意的是，各玩家虽然都调用了&lt;code&gt;start()&lt;/code&gt;线程，但是它们在运行时都在等待&lt;code&gt;countDownLatch&lt;/code&gt;的信号，在信号未收到前，它们不会往下执行。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;        CountDownLatch countDownLatch = &lt;span&gt;new&lt;/span&gt; CountDownLatch(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        Thread 大乔 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; waitToFight(countDownLatch));&lt;br/&gt;        Thread 兰陵王 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; waitToFight(countDownLatch));&lt;br/&gt;        Thread 安其拉 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; waitToFight(countDownLatch));&lt;br/&gt;        Thread 哪吒 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; waitToFight(countDownLatch));&lt;br/&gt;        Thread 铠 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; waitToFight(countDownLatch));&lt;br/&gt;&lt;br/&gt;        大乔.start();&lt;br/&gt;        兰陵王.start();&lt;br/&gt;        安其拉.start();&lt;br/&gt;        哪吒.start();&lt;br/&gt;        铠.start();&lt;br/&gt;        Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;        countDownLatch.countDown();&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;敌方还有5秒达到战场，全军出击！&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;waitToFight&lt;/span&gt;&lt;span&gt;(CountDownLatch countDownLatch)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            countDownLatch.await(); &lt;span&gt;// 在此等待信号再继续&lt;/span&gt;&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;收到，发起进攻！&quot;&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CountDownLatch的&lt;strong&gt;核心方法&lt;/strong&gt;也不多：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;await()&lt;/code&gt;：等待latch降为0；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;boolean await(long timeout, TimeUnit unit)&lt;/code&gt;：等待latch降为0，但是可以设置超时时间。比如有玩家超时未确认，那就重新匹配，总不能为了某个玩家等到天荒地老。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;countDown()&lt;/code&gt;：latch数量减1；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;getCount()&lt;/code&gt;：获取当前的latch数量。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;40.CyclicBarrier（同步屏障）了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一 组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它和CountDownLatch类似，都可以协调多线程的结束动作，在它们结束后都可以执行特定动作，但是为什么要有CyclicBarrier，自然是它有和CountDownLatch不同的地方。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道你听没听过一个新人UP主小约翰可汗，小约翰生平有两大恨——“想结衣结衣不依,迷爱理爱理不理。”我们来还原一下事情的经过：小约翰在亲政后认识了新垣结衣，于是决定第一次选妃，向结衣表白，等待回应。然而新垣结衣回应嫁给了星野源，小约翰伤心欲绝，发誓生平不娶，突然发现了铃木爱理，于是小约翰决定第二次选妃，求爱理搭理，等待回应。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSwJOkr0nM9chATLIqHc3Kx2uzViaulDeWk3mibsmm18gOx4SXSLJzsu0Q/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;想结衣结衣不依,迷爱理爱理不理。&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们拿代码模拟这一场景，发现CountDownLatch无能为力了，因为CountDownLatch的使用是一次性的，无法重复利用，而这里等待了两次。此时，我们用CyclicBarrier就可以实现，因为它可以重复利用。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSHRdvLYeibZpliby0H0hu1h1PCRRlCyS7oECAVv2YDPDH77RGiaRWMESJw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;小约翰可汗选妃模拟代码&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行结果：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSvgPTibpiaM3TBarbGDCRo20hXlQEulasJQj6CHHWP8yP6I1BibVylAqQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;运行结果&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CyclicBarrier最最核心的方法，仍然是await()：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果当前线程不是第一个到达屏障的话，它将会进入等待，直到其他线程都到达，除非发生&lt;strong&gt;被中断&lt;/strong&gt;、&lt;strong&gt;屏障被拆除&lt;/strong&gt;、&lt;strong&gt;屏障被重设&lt;/strong&gt;等情况；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的例子抽象一下，本质上它的流程就是这样就是这样：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSTv4BWvMFc29kVvm9L8UcuZ2AL8EiauGxSV4TJbht7b3lhkLqibC8S6WA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;CyclicBarrier工作流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;41.CyclicBarrier和CountDownLatch有什么区别？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两者最核心的区别[18]：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;CountDownLatch是一次性的，而CyclicBarrier则可以多次设置屏障，实现重复利用；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CountDownLatch中的各个子线程不可以等待其他线程，只能完成自己的任务；而CyclicBarrier中的各个线程可以等待其他线程&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它们区别用一个表格整理：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;CyclicBarrier&lt;/th&gt;&lt;th&gt;CountDownLatch&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;CyclicBarrier是可重用的，其中的线程会等待所有的线程完成任务。届时，屏障将被拆除，并可以选择性地做一些特定的动作。&lt;/td&gt;&lt;td&gt;CountDownLatch是一次性的，不同的线程在同一个计数器上工作，直到计数器为0.&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;CyclicBarrier面向的是线程数&lt;/td&gt;&lt;td&gt;CountDownLatch面向的是任务数&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;在使用CyclicBarrier时，你必须在构造中指定参与协作的线程数，这些线程必须调用await()方法&lt;/td&gt;&lt;td&gt;使用CountDownLatch时，则必须要指定任务数，至于这些任务由哪些线程完成无关紧要&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;CyclicBarrier可以在所有的线程释放后重新使用&lt;/td&gt;&lt;td&gt;CountDownLatch在计数器为0时不能再使用&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;在CyclicBarrier中，如果某个线程遇到了中断、超时等问题时，则处于await的线程都会出现问题&lt;/td&gt;&lt;td&gt;在CountDownLatch中，如果某个线程出现问题，其他线程不受影响&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;42.Semaphore（信号量）了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;听起来似乎很抽象，现在汽车多了，开车出门在外的一个老大难问题就是停车 。停车场的车位是有限的，只能允许若干车辆停泊，如果停车场还有空位，那么显示牌显示的就是绿灯和剩余的车位，车辆就可以驶入；如果停车场没位了，那么显示牌显示的就是绿灯和数字0，车辆就得等待。如果满了的停车场有车离开，那么显示牌就又变绿，显示空车位数量，等待的车辆就能进停车场。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSwY9aohegYwwHF0CEfDEPSLu1W083XZxJ3SibjK9FMLmXicEib480apbYw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;figcaption&gt;停车场空闲车位提示-图片来源网络&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们把这个例子类比一下，车辆就是线程，进入停车场就是线程在执行，离开停车场就是线程执行完毕，看见红灯就表示线程被阻塞，不能执行，Semaphore的本质就是&lt;strong&gt;协调多个线程对共享资源的获取&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSdbG4FgP1SvkcndmuCC0qznN86KtYm62Gia2JLBI0ncbadspaAFfBCOw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;figcaption&gt;Semaphore许可获取-来源参考[18]&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再来看一个Semaphore的用途：它可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，就可以使用Semaphore来做流量控制，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SemaphoreTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; THREAD_COUNT = &lt;span&gt;30&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Semaphore s = &lt;span&gt;new&lt;/span&gt; Semaphore(&lt;span&gt;10&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; THREAD_COUNT; i++) {&lt;br/&gt;            threadPool.execute(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;                &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                        s.acquire();&lt;br/&gt;                        System.out.println(&lt;span&gt;&quot;save data&quot;&lt;/span&gt;);&lt;br/&gt;                        s.release();&lt;br/&gt;                    } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            });&lt;br/&gt;        }&lt;br/&gt;        threadPool.shutdown();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在代码中，虽然有30个线程在执行，但是只允许10个并发执行。Semaphore的构造方法&lt;code&gt;Semaphore（int permits&lt;/code&gt;）接受一个整型的数字，表示可用的许可证数量。&lt;code&gt;Semaphore（10）&lt;/code&gt;表示允许10个线程获取许可证，也就是最大并发数是10。Semaphore的用法也很简单，首先线程使用 Semaphore的acquire()方法获取一个许可证，使用完之后调用release()方法归还许可证。还可以用tryAcquire()方法尝试获取许可证。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;43.Exchanger 了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSjKoOWuWQEY5yjvDU7GY5lUTia7rd8xUD90pULvzAS2KarJeBCRs2FRQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;figcaption&gt;英雄交换猎物-来源参考[18]&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两个线程通过 exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Exchanger可以用于遗传算法，遗传算法里需要选出两个人作为交配对象，这时候会交换两人的数据，并使用交叉规则得出2个交配结果。Exchanger也可以用于校对工作，比如我们需要将纸制银行流水通过人工的方式录入成电子银行流水，为了避免错误，采用AB岗两人进行录入，录入到Excel之后，系统需要加载这两个Excel，并对两个Excel数据进行校对，看看是否录入一致。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ExchangerTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Exchanger&amp;lt;String&amp;gt; exgr = &lt;span&gt;new&lt;/span&gt; Exchanger&amp;lt;String&amp;gt;();&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ExecutorService threadPool = Executors.newFixedThreadPool(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        threadPool.execute(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    String A = &lt;span&gt;&quot;银行流水A&quot;&lt;/span&gt;; &lt;span&gt;// A录入银行流水数据 &lt;/span&gt;&lt;br/&gt;                    exgr.exchange(A);&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        threadPool.execute(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    String B = &lt;span&gt;&quot;银行流水B&quot;&lt;/span&gt;; &lt;span&gt;// B录入银行流水数据 &lt;/span&gt;&lt;br/&gt;                    String A = exgr.exchange(&lt;span&gt;&quot;B&quot;&lt;/span&gt;);&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;A和B数据是否一致：&quot;&lt;/span&gt; + A.equals(B) + &lt;span&gt;&quot;，A录入的是：&quot;&lt;/span&gt;&lt;br/&gt;                            + A + &lt;span&gt;&quot;，B录入是：&quot;&lt;/span&gt; + B);&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        threadPool.shutdown();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如两个线程有一个没有执行exchange()方法，则会一直等待，如果担心有特殊情况发生，避免一直等待，可以使用&lt;code&gt;exchange(V x, long timeOut, TimeUnit unit)&lt;/code&gt;设置最大等待时长。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;线程池&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;44.什么是线程池？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;线程池：&lt;/strong&gt; 简单理解，它就是一个管理线程的池子。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSf2k5phoelUUlI70EgtQd1y511gbMT2dHibsoT2AWrxicQvEj4JK4f7hA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;管理线程的池子&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;它帮我们管理线程，避免增加创建线程和销毁线程的资源损耗&lt;/strong&gt;。因为线程其实也是一个对象，创建一个对象，需要经过类加载过程，销毁一个对象，需要走GC垃圾回收流程，都是需要资源开销的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;提高响应速度。&lt;/strong&gt; 如果任务到达了，相对于从线程池拿线程，重新去创建一条线程执行，速度肯定慢很多。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;重复利用。&lt;/strong&gt; 线程用完，再放回池子，可以达到重复利用的效果，节省资源。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;45.能说说工作中线程池的应用吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前我们有一个和第三方对接的需求，需要向第三方推送数据，引入了多线程来提升数据推送的效率，其中用到了线程池来管理线程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSus2LEXwloZbsTicqwu3iaSnkicgOb9GCM00Du50GkZ6IIicG1C8fMppOPA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;业务示例&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要代码如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.9267578125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSfo2EaKMOdxA6kFLib00aJjkXhVow9WibVZlk5rDtFXXb8DPpguXyVKeA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2048&quot;/&gt;&lt;figcaption&gt;主要代码&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完整可运行代码地址：https://gitee.com/fighter3/thread-demo.git&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池的参数如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;corePoolSize：线程核心参数选择了CPU数×2&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;maximumPoolSize：最大线程数选择了和核心线程数相同&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;keepAliveTime：非核心闲置线程存活时间直接置为0&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;unit：非核心线程保持存活的时间选择了 TimeUnit.SECONDS 秒&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;workQueue：线程池等待队列，使用 LinkedBlockingQueue阻塞队列&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时还用了synchronized 来加锁，保证数据不会被重复推送：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;synchronized&lt;/span&gt; (PushProcessServiceImpl&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;) &lt;/span&gt;{}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ps:这个例子只是简单地进行了数据推送，实际上还可以结合其他的业务，像什么数据清洗啊、数据统计啊，都可以套用。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;46.能简单说一下线程池的工作流程吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用一个通俗的比喻：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一个营业厅，总共有六个窗口，现在开放了三个窗口，现在有三个窗口坐着三个营业员小姐姐在营业。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;老三去办业务，可能会遇到什么情况呢？&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;老三发现有空间的在营业的窗口，直接去找小姐姐办理业务。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSjpvyfZib7ew5ZVdU4sdQZkj8rxzXxO5mCMw17VvoCd3bibYzpYq29SCg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;直接办理&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;老三发现没有空闲的窗口，就在排队区排队等。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSic6ichibZ4noB72VhkLQNNaUZbfuTa2fwcDEZVahvk1dcC7pVMibKnI9CA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;排队等待&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;老三发现没有空闲的窗口，等待区也满了，蚌埠住了，经理一看，就让休息的小姐姐赶紧回来上班，等待区号靠前的赶紧去新窗口办，老三去排队区排队。小姐姐比较辛苦，假如一段时间发现他们可以不用接着营业，经理就让她们接着休息。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSPzDkc95d4iaibp28VMlfdEibFLCngcsMmgEWiaXZ1n4lYZ3ngPDnqHjicLg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;排队区满&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;老三一看，六个窗口都满了，等待区也没位置了。老三急了，要闹，经理赶紧出来了，经理该怎么办呢？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTS1ehibUjaq5qHicxgMjd9CZbd7Q4dZuGKNUwl5gnQgC3mbqSVNMQ9z2Rw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;等待区，排队区都满&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;我们银行系统已经瘫痪&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;谁叫你来办的你找谁去&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;看你比较急，去队里加个塞&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;今天没办法，不行你看改一天&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的这个流程几乎就跟 JDK 线程池的大致流程类似，&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;营业中的 3个窗口对应核心线程池数：corePoolSize&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;总的营业窗口数6对应：maximumPoolSize&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;打开的临时窗口在多少时间内无人办理则关闭对应：unit&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;排队区就是等待队列：workQueue&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;无法办理的时候银行给出的解决方法对应：RejectedExecutionHandler&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;threadFactory 该参数在 JDK 中是 线程工厂，用来创建线程对象，一般不会动。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们线程池的工作流程也比较好理解了：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当调用 execute() 方法添加一个任务时，线程池会做如下判断：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会根据拒绝策略来对应处理。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSibgvbJBh08S7ZeC4ULW8dRucYedq5XCGW0dicJMw5m12561icGetUb2xQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;线程池执行流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当一个线程完成任务时，它会从队列中取下一个任务来执行。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;47.线程池主要参数有哪些？&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSpl3zNLric81KibgVWibibDkrjusELR26w8EmFsUm6tSWgAb8KicmXulBMPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;线程池参数&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池有七大参数，需要重点关注&lt;code&gt;corePoolSize&lt;/code&gt;、&lt;code&gt;maximumPoolSize&lt;/code&gt;、&lt;code&gt;workQueue&lt;/code&gt;、&lt;code&gt;handler&lt;/code&gt;这四个。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;corePoolSize&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此值是用来初始化线程池中核心线程数，当线程池中线程池数&amp;lt; &lt;code&gt;corePoolSize&lt;/code&gt;时，系统默认是添加一个任务才创建一个线程池。当线程数 = corePoolSize时，新任务会追加到workQueue中。&lt;/p&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;maximumPoolSize&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;maximumPoolSize&lt;/code&gt;表示允许的最大线程数 = (非核心线程数+核心线程数)，当&lt;code&gt;BlockingQueue&lt;/code&gt;也满了，但线程池中总线程数 &amp;lt; &lt;code&gt;maximumPoolSize&lt;/code&gt;时候就会再次创建新的线程。&lt;/p&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;keepAliveTime&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非核心线程 =(maximumPoolSize - corePoolSize ) ,非核心线程闲置下来不干活最多存活时间。&lt;/p&gt;&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;unit&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池中非核心线程保持存活的时间的单位&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;TimeUnit.DAYS;天&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TimeUnit.HOURS;小时&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TimeUnit.MINUTES;分钟&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TimeUnit.SECONDS;秒&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TimeUnit.MILLISECONDS;  毫秒&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TimeUnit.MICROSECONDS;  微秒&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TimeUnit.NANOSECONDS;  纳秒&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol start=&quot;5&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;workQueue&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池等待队列，维护着等待执行的&lt;code&gt;Runnable&lt;/code&gt;对象。当运行当线程数= corePoolSize时，新的任务会被添加到&lt;code&gt;workQueue&lt;/code&gt;中，如果&lt;code&gt;workQueue&lt;/code&gt;也满了则尝试用非核心线程执行任务，等待队列应该尽量用有界的。&lt;/p&gt;&lt;ol start=&quot;6&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;threadFactory&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等。&lt;/p&gt;&lt;ol start=&quot;7&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;handler&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;corePoolSize&lt;/code&gt;、&lt;code&gt;workQueue&lt;/code&gt;、&lt;code&gt;maximumPoolSize&lt;/code&gt;都不可用的时候执行的饱和策略。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;48.线程池的拒绝策略有哪些？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类比前面的例子，无法办理业务时的处理方式，帮助记忆：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSEialhu9UoRSTBT2grUaJdmGflo3ORHhHEE2pQZptibgqDjAg8nJxrq2g/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;四种策略&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;AbortPolicy ：直接抛出异常，默认使用此策略&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CallerRunsPolicy：用调用者所在的线程来执行任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DiscardOldestPolicy：丢弃阻塞队列里最老的任务，也就是队列里靠前的任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DiscardPolicy ：当前任务直接丢弃&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想实现自己的拒绝策略，实现RejectedExecutionHandler接口即可。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;49.线程池有哪几种工作队列？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常用的阻塞队列主要有以下几种：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSPNoYnf7B8TtrxRXCOfgkLXxmKEuqqfuJZKVPArLOJCIrLgLUxmuIWA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;线程池常用阻塞队列&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ArrayBlockingQueue：ArrayBlockingQueue（有界队列）是一个用数组实现的有界阻塞队列，按FIFO排序量。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingQueue：LinkedBlockingQueue（可设置容量队列）是基于链表结构的阻塞队列，按FIFO排序任务，容量可以选择进行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE，吞吐量通常要高于ArrayBlockingQuene；newFixedThreadPool线程池使用了这个队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DelayQueue：DelayQueue（延迟队列）是一个任务定时周期的延迟执行的队列。根据指定的执行时间从小到大排序，否则根据插入到队列的先后排序。newScheduledThreadPool线程池使用了这个队列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;PriorityBlockingQueue：PriorityBlockingQueue（优先级队列）是具有优先级的无界阻塞队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SynchronousQueue：SynchronousQueue（同步队列）是一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene，newCachedThreadPool线程池使用了这个队列。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;50.线程池提交execute和submit有什么区别？&lt;/span&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;execute 用于提交不需要返回值的任务&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;threadsPool.execute(&lt;span&gt;new&lt;/span&gt; Runnable() { &lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{ &lt;br/&gt;        &lt;span&gt;// TODO Auto-generated method stub } &lt;/span&gt;&lt;br/&gt;    });&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个 future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Future&amp;lt;Object&amp;gt; future = executor.submit(harReturnValuetask); &lt;br/&gt;&lt;span&gt;try&lt;/span&gt; { Object s = future.get(); } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) { &lt;br/&gt;    &lt;span&gt;// 处理中断异常 &lt;/span&gt;&lt;br/&gt;} &lt;span&gt;catch&lt;/span&gt; (ExecutionException e) { &lt;br/&gt;    &lt;span&gt;// 处理无法执行任务异常 &lt;/span&gt;&lt;br/&gt;} &lt;span&gt;finally&lt;/span&gt; { &lt;br/&gt;    &lt;span&gt;// 关闭线程池 executor.shutdown();&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;51.线程池怎么关闭知道吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过调用线程池的&lt;code&gt;shutdown&lt;/code&gt;或&lt;code&gt;shutdownNow&lt;/code&gt;方法来关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;shutdown() 将线程池状态置为shutdown,并不会立即停止&lt;/strong&gt;：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;停止接收外部submit的任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内部正在跑的任务和队列里等待的任务，会执行完&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;等到第二步完成后，才真正停止&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;shutdownNow() 将线程池状态置为stop。一般会立即停止，事实上不一定&lt;/strong&gt;：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;和shutdown()一样，先停止接收外部提交的任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;忽略队列里等待的任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;尝试将正在跑的任务interrupt中断&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;返回未执行的任务列表&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;shutdown 和shutdownnow简单来说区别如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;shutdownNow()能立即停止线程池，正在跑的和正在等待的任务都停下了。这样做立即生效，但是风险也比较大。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;shutdown()只是关闭了提交通道，用submit()是无效的；而内部的任务该怎么跑还是怎么跑，跑完再彻底停止线程池。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;52.线程池的线程数应该怎么配置？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程在Java中属于稀缺资源，线程池不是越大越好也不是越小越好。任务分为计算密集型、IO密集型、混合型。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;计算密集型：大部分都在用CPU跟内存，加密，逻辑操作业务处理等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;IO密集型：数据库链接，网络通讯传输等。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTS911XXzD3vbwfoTaWB8BduS0zvR0ky7JFAFlia3eHgwpTq7dTj2alMcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;常见线程池参数配置方案-来源美团技术博客&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般的经验，不同类型线程池的参数配置：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;计算密集型一般推荐线程池不要过大，一般是CPU数 + 1，+1是因为可能存在&lt;strong&gt;页缺失&lt;/strong&gt;(就是可能存在有些数据在硬盘中需要多来一个线程将数据读入内存)。如果线程池数太大，可能会频繁的 进行线程上下文切换跟任务调度。获得当前CPU核心数代码如下：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Runtime.getRuntime().availableProcessors();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;IO密集型：线程数适当大一点，机器的Cpu核心数*2。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;混合型：可以考虑根绝情况将它拆分成CPU密集型和IO密集型任务，如果执行时间相差不大，拆分可以提升吞吐量，反之没有必要。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，实际应用中没有固定的公式，需要结合测试和监控来进行调整。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;53.有哪几种常见的线程池？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试常问，主要有四种，都是通过工具类Excutors创建出来的，需要注意，阿里巴巴《Java开发手册》里禁止使用这种方式来创建线程池。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSndSYswbkly8nx1qibaD0AtnyjnxUypp15Cyf5ibJssbkYB8TXHPFf8NQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;四大线程池&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;newFixedThreadPool  (固定数目线程的线程池)&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;newCachedThreadPool (可缓存线程的线程池)&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;newSingleThreadExecutor (单线程的线程池)&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;newScheduledThreadPool (定时及周期执行的线程池)&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;54.能说一下四种常见线程池的原理吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前三种线程池的构造直接调用ThreadPoolExecutor的构造方法。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;newSingleThreadExecutor&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ExecutorService &lt;span&gt;newSingleThreadExecutor&lt;/span&gt;&lt;span&gt;(ThreadFactory threadFactory)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; FinalizableDelegatedExecutorService&lt;br/&gt;            (&lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;                                    &lt;span&gt;0L&lt;/span&gt;, TimeUnit.MILLISECONDS,&lt;br/&gt;                                    &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(),&lt;br/&gt;                                    threadFactory));&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;线程池特点&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;核心线程数为1&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最大线程数也为1&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;阻塞队列是无界队列LinkedBlockingQueue，可能会导致OOM&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;keepAliveTime为0&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSoPO2yic7w1Pupakc9GeQzCw0mkURCNHptnmRE3vfiaVQLTyIicnbAUIgA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;SingleThreadExecutor运行流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作流程：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;提交任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程池是否有一条线程在，如果没有，新建线程执行任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果有，将任务加到阻塞队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当前的唯一线程，从队列取任务，执行完一个，再继续取，一个线程执行任务。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;适用场景&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;适用于串行执行任务的场景，一个任务一个任务地执行。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;newFixedThreadPool&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ExecutorService &lt;span&gt;newFixedThreadPool&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; nThreads, ThreadFactory threadFactory)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(nThreads, nThreads,&lt;br/&gt;                                      &lt;span&gt;0L&lt;/span&gt;, TimeUnit.MILLISECONDS,&lt;br/&gt;                                      &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(),&lt;br/&gt;                                      threadFactory);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;线程池特点：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;核心线程数和最大线程数大小一样&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;没有所谓的非空闲时间，即keepAliveTime为0&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;阻塞队列为无界队列LinkedBlockingQueue，可能会导致OOM&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSQQBIZZBy7dwTtTUpmbraicYVEJvbaDsiamZDMuFKY2kTPWcyYOYeBS1g/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;FixedThreadPool&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作流程：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;提交任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果线程数少于核心线程，创建核心线程执行任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果线程数等于核心线程，把任务添加到LinkedBlockingQueue阻塞队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果线程执行完任务，去阻塞队列取任务，继续执行。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;使用场景&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;FixedThreadPool 适用于处理CPU密集型的任务，确保CPU在长期被工作线程使用的情况下，尽可能的少的分配线程，即适用执行长期的任务。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;newCachedThreadPool&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ExecutorService &lt;span&gt;newCachedThreadPool&lt;/span&gt;&lt;span&gt;(ThreadFactory threadFactory)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(&lt;span&gt;0&lt;/span&gt;, Integer.MAX_VALUE,&lt;br/&gt;                                      &lt;span&gt;60L&lt;/span&gt;, TimeUnit.SECONDS,&lt;br/&gt;                                      &lt;span&gt;new&lt;/span&gt; SynchronousQueue&amp;lt;Runnable&amp;gt;(),&lt;br/&gt;                                      threadFactory);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;线程池特点：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;核心线程数为0&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最大线程数为Integer.MAX_VALUE，即无限大，可能会因为无限创建线程，导致OOM&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;阻塞队列是SynchronousQueue&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;非核心线程空闲存活时间为60秒&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当提交任务的速度大于处理任务的速度时，每次提交一个任务，就必然会创建一个线程。极端情况下会创建过多的线程，耗尽 CPU 和内存资源。由于空闲 60 秒的线程会被终止，长时间保持空闲的 CachedThreadPool 不会占用任何资源。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSVC6RoUUiabxbQibKjhtjC6UfvNiawscicuj8MYfmdQlct3enazyicQxzENQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;CachedThreadPool执行流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作流程：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;提交任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;因为没有核心线程，所以任务直接加到SynchronousQueue队列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;判断是否有空闲线程，如果有，就去取出任务执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果没有空闲线程，就新建一个线程执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;执行完任务的线程，还可以存活60秒，如果在这期间，接到任务，可以继续活下去；否则，被销毁。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;适用场景&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用于并发执行大量短期的小任务。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;newScheduledThreadPool&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;ScheduledThreadPoolExecutor&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; corePoolSize)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(corePoolSize, Integer.MAX_VALUE, &lt;span&gt;0&lt;/span&gt;, NANOSECONDS,&lt;br/&gt;              &lt;span&gt;new&lt;/span&gt; DelayedWorkQueue());&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;线程池特点&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;最大线程数为Integer.MAX_VALUE，也有OOM的风险&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;阻塞队列是DelayedWorkQueue&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;keepAliveTime为0&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;scheduleAtFixedRate() ：按某种速率周期执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;scheduleWithFixedDelay()：在某个延迟后执行&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSpLIibSktN1W8Y63icicLw6WNSlVc3yeFyuibJq7Gkkj4MibxCJ1Qznvwe5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;ScheduledThreadPool执行流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;工作机制&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;线程从DelayQueue中获取已到期的ScheduledFutureTask（DelayQueue.take()）。到期任务是指ScheduledFutureTask的time大于等于当前时间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程执行这个ScheduledFutureTask。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程修改ScheduledFutureTask的time变量为下次将要被执行的时间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程把这个修改time之后的ScheduledFutureTask放回DelayQueue中（DelayQueue.add()）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSgGFneaLl3DOo26lX6mr6PBWGmx6XSFLK5ibzzxf3I2ZsBGuia68awLFg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;ScheduledThreadPoolExecutor执行流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;使用场景&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;周期性执行任务的场景，需要限制线程数量的场景&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;使用无界队列的线程池会导致什么问题吗？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如newFixedThreadPool使用了无界的阻塞队列LinkedBlockingQueue，如果线程获取一个任务后，任务的执行时间比较长，会导致队列的任务越积越多，导致机器内存使用不停飙升，最终导致OOM。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;55.线程池异常怎么处理知道吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在使用线程池处理任务的时候，任务代码可能抛出RuntimeException，抛出异常后，线程池可能捕获它，也可能创建一个新的线程来代替异常的线程，我们可能无法感知任务出现了异常，因此我们需要考虑线程池异常情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的异常处理方式：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSITic450VQC8zhvBae0x7bLCQU2BlmnEsMe1Ww18Kh4vf0zIVibP6Jr1g/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;线程池异常处理&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;56.能说一下线程池有几种状态吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池有这几个状态：RUNNING,SHUTDOWN,STOP,TIDYING,TERMINATED。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;   &lt;span&gt;//线程池状态&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; RUNNING    = -&lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; COUNT_BITS;&lt;br/&gt;   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SHUTDOWN   =  &lt;span&gt;0&lt;/span&gt; &amp;lt;&amp;lt; COUNT_BITS;&lt;br/&gt;   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; STOP       =  &lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; COUNT_BITS;&lt;br/&gt;   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; TIDYING    =  &lt;span&gt;2&lt;/span&gt; &amp;lt;&amp;lt; COUNT_BITS;&lt;br/&gt;   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; TERMINATED =  &lt;span&gt;3&lt;/span&gt; &amp;lt;&amp;lt; COUNT_BITS;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池各个状态切换图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSCmytA2eBOib4TUlWRjmQ0WlIHdlH5d0IXHPiae8xHkyVfqF2nImX1zmA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;线程池状态切换图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;RUNNING&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;该状态的线程池会接收新任务，并处理阻塞队列中的任务;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用线程池的shutdown()方法，可以切换到SHUTDOWN状态;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用线程池的shutdownNow()方法，可以切换到STOP状态;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;SHUTDOWN&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;队列为空，并且线程池中执行的任务也为空,进入TIDYING状态;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;STOP&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程池中执行的任务为空,进入TIDYING状态;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;TIDYING&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;该状态表明所有的任务已经运行终止，记录的任务数量为0。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;terminated()执行完毕，进入TERMINATED状态&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;TERMINATED&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;57.线程池如何实现参数的动态修改？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池提供了几个  setter方法来设置线程池的参数。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSavbupJDShuicur1MP6r55ANkIbmzhkoSYn6yRGOrcrPBExbtd9cgGPw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;JDK 线程池参数设置接口来源参考[7]&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里主要有两个思路：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSLrfjLDicA55ZfCzjAaicbk47vicbGUs88z1U3xD478zQAckYQkGCVtUlQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;动态修改线程池参数&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在我们微服务的架构下，可以利用配置中心如Nacos、Apollo等等，也可以自己开发配置中心。业务服务读取线程池配置，获取相应的线程池实例来修改线程池的参数。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果限制了配置中心的使用，也可以自己去扩展&lt;strong&gt;ThreadPoolExecutor&lt;/strong&gt;，重写方法，监听线程池参数变化，来动态修改线程池参数。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;线程池调优了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池配置没有固定的公式，通常事前会对线程池进行一定评估，常见的评估方案如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTS911XXzD3vbwfoTaWB8BduS0zvR0ky7JFAFlia3eHgwpTq7dTj2alMcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;线程池评估方案 来源参考[7]&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上线之前也要进行充分的测试，上线之后要建立完善的线程池监控机制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事中结合监控告警机制，分析线程池的问题，或者可优化点，结合线程池动态参数配置机制来调整配置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事后要注意仔细观察，随时调整。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSjlUdjTG0hA2bQABkZ1KFYK5RUfrumweRprdxzwErgJrTMYNHJnx46g/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;线程池调优&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体的调优案例可以查看参考[7]美团技术博客。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;58.你能设计实现一个线程池吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;⭐这道题在阿里的面试中出现频率比较高&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池实现原理可以查看 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247488521&amp;amp;idx=1&amp;amp;sn=66b0ae23ef24ba47f4487aa8a3646886&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;要是以前有人这么讲线程池，我早就该明白了！&lt;/a&gt;  ，当然，我们自己实现， 只需要抓住线程池的核心流程-参考[6]：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTS6pnG8oPaia0Kicic8DhQ08mkzn8iaGEJk8whPYZ4E3sGYf2gUGoDfUW5Hg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;线程池主要实现流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们自己的实现就是完成这个核心流程：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;线程池中有N个工作线程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;把任务提交给线程池运行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果线程池已满，把任务放入队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后当有空闲时，获取队列中任务来执行&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现代码[6]：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTS9pA3JJZyEsgepVkQ9M2prjsiamJ8cBKb8MCWnX9l6jsn1aNyQuH2vpw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;自定义线程池&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样，一个实现了线程池主要流程的类就完成了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;59.单机线程池执行断电了应该怎么处理？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;我们可以对正在处理和阻塞队列的任务做事务管理或者对阻塞队列中的任务持久化处理，并且当断电或者系统崩溃，操作无法继续下去的时候，可以通过回溯日志的方式来撤销&lt;code&gt;正在处理&lt;/code&gt;的已经执行成功的操作。然后重新执行整个阻塞队列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，对阻塞队列持久化；正在处理任务事务控制；断电之后正在处理任务的回滚，通过日志恢复该次操作；服务器重启后阻塞队列中的数据再加载。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;并发容器和框架&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于一些并发容器，可以去看看 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247488788&amp;amp;idx=1&amp;amp;sn=01875e3e45515c2d57593cb7a01d0b6b&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;面渣逆袭：Java集合连环三十问  &lt;/a&gt;，里面有&lt;code&gt;CopyOnWriteList&lt;/code&gt;和&lt;code&gt;ConcurrentHashMap&lt;/code&gt;这两种线程安全容器类的问答。。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;60.Fork/Join框架了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Fork/Join框架是Java7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要想掌握Fork/Join框架，首先需要理解两个点，&lt;strong&gt;分而治之&lt;/strong&gt;和&lt;strong&gt;工作窃取算法&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;分而治之&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Fork/Join框架的定义，其实就体现了分治思想：将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTS6J3czqIO12fQuCQKZZWHQdd6Egdjia4ertvp8Ap80Zx3BZ4mkeTsvJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;Fork/Join分治算法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;工作窃取算法&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大任务拆成了若干个小任务，把这些小任务放到不同的队列里，各自创建单独线程来执行队列里的任务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么问题来了，有的线程干活块，有的线程干活慢。干完活的线程不能让它空下来，得让它去帮没干完活的线程干活。它去其它线程的队列里窃取一个任务来执行，这就是所谓的&lt;strong&gt;工作窃取&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作窃取发生的时候，它们会访问同一个队列，为了减少窃取任务线程和被窃取任务线程之间的竞争，通常任务会使用双端队列，被窃取任务线程永远从双端队列的头部拿，而窃取任务的线程永远从双端队列的尾部拿任务执行。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSMU4VPDmKLHgz7FU8UKgQOvmpH9oDI7fOiboDYQz7nhwIAjdE1Y2NZicg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;工作窃取&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看一个Fork/Join框架应用的例子，计算1~n之间的和：1+2+3+…+n&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;设置一个分割阈值，任务大于阈值就拆分任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;任务有结果，所以需要继承RecursiveTask&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CountTask&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;RecursiveTask&lt;/span&gt;&amp;lt;&lt;span&gt;Integer&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; THRESHOLD = &lt;span&gt;16&lt;/span&gt;; &lt;span&gt;// 阈值&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; start;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; end;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;CountTask&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; start, &lt;span&gt;int&lt;/span&gt; end)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.start = start;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.end = end;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; Integer &lt;span&gt;compute&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; sum = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;// 如果任务足够小就计算任务&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;boolean&lt;/span&gt; canCompute = (end - start) &amp;lt;= THRESHOLD;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (canCompute) {&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = start; i &amp;lt;= end; i++) {&lt;br/&gt;                sum += i;&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;// 如果任务大于阈值，就分裂成两个子任务计算&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; middle = (start + end) / &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;            CountTask leftTask = &lt;span&gt;new&lt;/span&gt; CountTask(start, middle);&lt;br/&gt;            CountTask rightTask = &lt;span&gt;new&lt;/span&gt; CountTask(middle + &lt;span&gt;1&lt;/span&gt;, end);&lt;br/&gt;            &lt;span&gt;// 执行子任务&lt;/span&gt;&lt;br/&gt;            leftTask.fork();&lt;br/&gt;            rightTask.fork(); &lt;span&gt;// 等待子任务执行完，并得到其结果&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; leftResult = leftTask.join();&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; rightResult = rightTask.join(); &lt;span&gt;// 合并子任务&lt;/span&gt;&lt;br/&gt;            sum = leftResult + rightResult;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; sum;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ForkJoinPool forkJoinPool = &lt;span&gt;new&lt;/span&gt; ForkJoinPool(); &lt;span&gt;// 生成一个计算任务，负责计算1+2+3+4&lt;/span&gt;&lt;br/&gt;        CountTask task = &lt;span&gt;new&lt;/span&gt; CountTask(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;); &lt;span&gt;// 执行一个任务&lt;/span&gt;&lt;br/&gt;        Future&amp;lt;Integer&amp;gt; result = forkJoinPool.submit(task);&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            System.out.println(result.get());&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (ExecutionException e) {&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ForkJoinTask与一般Task的主要区别在于它需要实现compute方法，在这个方法里，首先需要判断任务是否足够小，如果足够小就直接执行任务。如果比较大，就必须分割成两个子任务，每个子任务在调用fork方法时，又会进compute方法，看看当前子任务是否需要继续分割成子任务，如果不需要继续分割，则执行当前子任务并返回结果。使用join方法会等待子任务执行完并得到其结果。&lt;/p&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;big&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/big&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;span&gt;[1]. 《Java并发编程的艺术》&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;[2]. 《Java发编程实战》&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;[3]. 个人珍藏的80道多线程并发面试题（1-10答案解析）:https://juejin.cn/post/6854573221258199048&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;[4]. 艾小仙 《我想进大厂》&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;[5]. Java并发基础知识，我用思维导图整理好了:https://fighter3.blog.csdn.net/article/details/113612422&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;[6] . 极客时间 《Java并发编程实战》&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;[7]. 《Java并发编程之美》&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;[8]. 万字图文 | 聊一聊 ReentrantLock 和 AQS 那点事（看完不会你找我）:https://juejin.cn/post/6896278031317663751&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;[9]. 《深入理解Java虚拟机》&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;[10]. 如何实现阻塞队列 :https://juejin.cn/post/6977948393272246285&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;[11]. 讲真 这次绝对让你轻松学习线程池:https://mp.weixin.qq.com/s/dTMH1TdxiCKy5yotQ7u7cA&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;[12]. 面试必备：Java线程池解析:https://juejin.cn/post/6844903889678893063&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;[13]. 面试官问：“在项目中用过多线程吗？”你就把这个案例讲给他听！:https://juejin.cn/post/6936457087505399821&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;[14]. 小傅哥 《Java面经手册》&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;[15]. Java线程池实现原理及其在美团业务中的实践:https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;[16]. 面试官：小伙子，听说你看过ThreadLocal源码？（万字图文深度解析ThreadLocal）:https://juejin.cn/post/6844904151567040519&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;[17].面试官问我什么是JMM:https://zhuanlan.zhihu.com/p/258393139&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;[18]. 《王者并发课》:https://juejin.cn/column/6963590682602635294&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;[19]. synchronized锁升级详细过程:https://www.cnblogs.com/suixing123/p/13996479.html&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>