<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>8631613f34e07b1ff2bd64cb8a728f6f</guid>
<title>七步制作精简镜像，So easy</title>
<link>https://toutiao.io/k/s48j8ku</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;文章来自黄庆兵老师的网易蜂巢《玩转 Docker 镜像》系列https://github.com/bingohuang/play-docker-images，原本分为上下两篇，这里由生态君整合成一篇便于阅读。希望能对大家有所帮助。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;目录&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;介绍&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;镜像层(Layers)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;制作步骤&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;lab-1：初始化构建 Redis 镜像&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;lab-2：优化基础镜像&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;lab-3：串联 Dockerfile 指令&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;lab-4：压缩你的镜像&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;lab-5：使用最精简的 base image&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;lab-6：提取动态链接的 .so 文件&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;lab-7：为 Go 应用构建精简镜像&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;总结&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;参考&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;作者简介：&lt;/strong&gt; 黄庆兵，毕业于浙大，工作于网易，从事云计算、Docker和Go相关开发及布道工作；喜欢开源，乐于分享，勤于布道，折腾过开源小工具，制作过Docker课程，分享过 Gopher Meetup。我的 Github 账号：https://github.com/bingohuang，欢迎一起来 &lt;code&gt;写 Go 玩 Docker&lt;/code&gt;！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100000304&quot; data-ratio=&quot;0.8055555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/otNtibX96l9ibwMmqp4H0uRMU8ib3Rar6K6Tq2792RY1EBs7ibI50bXpz3KssjHmxsM6daT6ZribO47ibUCpjmUG97Ng/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;792&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;介绍&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前段时间网易蜂巢曾经推出蜂巢 &lt;code&gt;Logo&lt;/code&gt; T恤，用的正是 Docker 镜像制作，最神奇的是，它最终的镜像大小只有 &lt;code&gt;585&lt;/code&gt; 字节。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ docker images | grep hub.c.163.com/public/logo&lt;br/&gt;REPOSITORY                      TAG           IMAGE ID         CREATED       SIZE&lt;br/&gt;hub.c.163.com/public/logo       latest        6fbdd13cd204     11 days ago   585 B&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些镜像都不是我们自己来打包的（比如下载公共镜像），那是否有一些通用的精简 Docker 镜像的手段呢？答案是肯定的，甚至有的镜像可以精简 98%。精简镜像大小的好处不言而喻，既节省了存储空间，又能节省带宽，加快传输等。那好，接下来就请跟随我来学习怎么制作精简 Docker 镜像。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;镜像层(Layers)&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在开始制作镜像之前，首先了解下镜像的原理，而这其中最重要的概念就是&lt;code&gt;镜像层(Layers)&lt;/code&gt;。镜像层依赖于一系列的底层技术，比如文件系统(filesystems)、写时复制(copy-on-write)、联合挂载(union mounts)等，幸运的是你可以在很多地方学习到&lt;span&gt;这些技术&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;，这里就不再赘述技术细节。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100000305&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/otNtibX96l9ibwMmqp4H0uRMU8ib3Rar6K6y1jCKRUD4KmGicxiauzaCuiaEJ2HLakOY1ZmlvoXn6cYFTTgGL0ibXgyHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总的来说，你最需要记住这点：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;在 Dockerfile 中， 每一条指令都会创建一个镜像层，继而会增加整体镜像的大小。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举例来说：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;FROM&lt;/span&gt; busybox&lt;br/&gt;&lt;span&gt;RUN&lt;/span&gt;&lt;span&gt; mkdir /tmp/foo&lt;/span&gt;&lt;br/&gt;&lt;span&gt;RUN&lt;/span&gt;&lt;span&gt; dd &lt;span&gt;if&lt;/span&gt;=/dev/zero of=/tmp/foo/bar bs=1048576 count=100&lt;/span&gt;&lt;br/&gt;&lt;span&gt;RUN&lt;/span&gt;&lt;span&gt; rm /tmp/foo/bar&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上 Dockerfile 干了几件事：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;基于一个官方的基础镜像 busybox(只有1M多)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;创建一个文件夹(/tmp/foo)和一个文件(bar)，该文件分配了100M大小&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;再把这个大文件删除&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上它最终什么也没做，我们把它构建成镜像（构建可以参考&lt;span&gt;一期&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;docker build -t busybox:&lt;span&gt;test&lt;/span&gt; .&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再让我们来对比下原生的 busybox 镜像大小和我们生成的镜像大小：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ docker images | grep busybox&lt;br/&gt;busybox    &lt;span&gt;test&lt;/span&gt;     896c63dbdb96    2 seconds ago    106 MB&lt;br/&gt;busybox    latest   2b8fd9751c4c    9 weeks ago      1.093 MB&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;出乎意料的是，却生成了 106 MB 的镜像。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多出了 100 M，这是为何？这点和 Git 类似（都用到了Copy-On-Write技术），我用 git 做了如下两次提交（添加了又删除），请问 &lt;code&gt;A_VERY_LARGE_FILE&lt;/code&gt; 还在 git 仓库中吗？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ git add  A_VERY_LARGE_FILE&lt;br/&gt;$ git commit&lt;br/&gt;$ git rm  A_VERY_LARGE_FILE&lt;br/&gt;$ git commit&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是:在的，并且会占用仓库的大小。Git 会保存每一次提交的文件版本，而 Dockerfile 中每一条指令都可能增加整体镜像的大小，即使它最终什么事情都没做。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;制作步骤&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;了解了镜像层知识，有助于我们接下来制作精简镜像。这里开始，以最常用的开源缓存软件 &lt;code&gt;Redis&lt;/code&gt; 为例，从一步步试验，来介绍如何制作更精简的 Docker 镜像。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;lab-1：初始化构建 Redis 镜像&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;直接上 &lt;code&gt;Dockerfile&lt;/code&gt; ：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;FROM&lt;/span&gt; ubuntu:trusty&lt;br/&gt;&lt;span&gt;ENV&lt;/span&gt; VER     &lt;span&gt;3.0&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;ENV&lt;/span&gt; TARBALL http://download.redis.io/releases/redis-$VER.tar.gz&lt;br/&gt;&lt;span&gt;# ==&amp;gt; Install curl and helper tools...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;RUN&lt;/span&gt;&lt;span&gt; apt-get update&lt;/span&gt;&lt;br/&gt;&lt;span&gt;RUN&lt;/span&gt;&lt;span&gt; apt-get install -y  curl make gcc&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# ==&amp;gt; Download, compile, and install...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;RUN&lt;/span&gt;&lt;span&gt; curl -L &lt;span&gt;$TARBALL&lt;/span&gt; | tar zxv&lt;/span&gt;&lt;br/&gt;&lt;span&gt;WORKDIR&lt;/span&gt;&lt;span&gt;  redis-&lt;span&gt;$VER&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;RUN&lt;/span&gt;&lt;span&gt; make&lt;/span&gt;&lt;br/&gt;&lt;span&gt;RUN&lt;/span&gt;&lt;span&gt; make install&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# ==&amp;gt; Clean up...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;WORKDIR&lt;/span&gt;&lt;span&gt; /&lt;/span&gt;&lt;br/&gt;&lt;span&gt;RUN&lt;/span&gt;&lt;span&gt; apt-get remove -y --auto-remove curl make gcc&lt;/span&gt;&lt;br/&gt;&lt;span&gt;RUN&lt;/span&gt;&lt;span&gt; apt-get clean&lt;/span&gt;&lt;br/&gt;&lt;span&gt;RUN&lt;/span&gt;&lt;span&gt; rm -rf /var/lib/apt/lists/*  /redis-&lt;span&gt;$VER&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;CMD&lt;/span&gt;&lt;span&gt; [&lt;span&gt;&quot;redis-server&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结合注释，读起来并不困难，用到的都是常规的几个命令，简要介绍如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;FROM：顶头写，指定一个基础镜像，此处基于 &lt;code&gt;ubuntu:trusty&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ENV：设置环境变量，这里设置了 &lt;code&gt;VER&lt;/code&gt; 和 &lt;code&gt;TARBALL&lt;/code&gt; 两个环境变量&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RUN：最常用的 Dockerfile 指令，用于运行各种命令，这里调用了 8 次 RUN 指令&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;WORKDIR：指定工作目录，相当于指令 &lt;code&gt;cd&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CMD：指定镜像默认执行的命令，此处默认执行 redis-server 命令来启动 redis&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;执行构建：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ docker build  -t redis:lab-1  .&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;注：国内网络，更新下载可能会较慢&lt;/em&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;查看大小：&lt;/strong&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Lab&lt;/th&gt;&lt;th&gt;iamge&lt;/th&gt;&lt;th&gt;Base&lt;/th&gt;&lt;th&gt;Lang&lt;/th&gt;&lt;th&gt;.red[*]&lt;/th&gt;&lt;th&gt;Size (MB)&lt;/th&gt;&lt;th&gt;   Memo&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;redis&lt;/td&gt;&lt;td&gt;&lt;code&gt;ubuntu&lt;/code&gt;&lt;/td&gt;&lt;td&gt;C&lt;/td&gt;&lt;td&gt;dyn&lt;/td&gt;&lt;td&gt;347.3&lt;/td&gt;&lt;td&gt;   base ubuntu&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;动辄就有 300多 M 的大小，不能忍，下面我们开始一步步优化。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;lab-2：优化基础镜像&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;精简1：选用更小的基础镜像。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常用的 Linux 系统镜像一般有 &lt;code&gt;ubuntu&lt;/code&gt;、&lt;code&gt;centos&lt;/code&gt;、&lt;code&gt;debian&lt;/code&gt;，其中&lt;code&gt;debian&lt;/code&gt; 更轻量，而且够用，对比如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;REPOSITORY          TAG        IMAGE ID         VIRTUAL SIZE&lt;br/&gt;---------------     ------     ------------     ------------&lt;br/&gt;centos              7          214a4932132a     215.7 MB&lt;br/&gt;centos              6          f6808a3e4d9e     202.6 MB&lt;br/&gt;ubuntu              trusty     d0955f21bf24     188.3 MB&lt;br/&gt;ubuntu              precise    9c5e4be642b7     131.9 MB&lt;br/&gt;debian              jessie     65688f7c61c4     122.8 MB&lt;br/&gt;debian              wheezy     1265e16d0c28     84.96 MB&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;替换 &lt;code&gt;debian:jessie&lt;/code&gt; 作为我们的基础镜像。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优化 Dockerfile：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;FROM&lt;/span&gt; debian:jessie&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#...&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;执行构建：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ docker build  -t redis:lab-2  .&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;查看大小：&lt;/strong&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Lab&lt;/th&gt;&lt;th&gt;image&lt;/th&gt;&lt;th&gt;Base&lt;/th&gt;&lt;th&gt;Lang&lt;/th&gt;&lt;th&gt;.red[*]&lt;/th&gt;&lt;th&gt;Size (MB)&lt;/th&gt;&lt;th&gt;   Memo&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;01&lt;/td&gt;&lt;td&gt;redis&lt;/td&gt;&lt;td&gt;&lt;code&gt;ubuntu&lt;/code&gt;&lt;/td&gt;&lt;td&gt;C&lt;/td&gt;&lt;td&gt;dyn&lt;/td&gt;&lt;td&gt;347.3&lt;/td&gt;&lt;td&gt;   base ubuntu&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;02&lt;/td&gt;&lt;td&gt;redis&lt;/td&gt;&lt;td&gt;&lt;code&gt;debian&lt;/code&gt;&lt;/td&gt;&lt;td&gt;C&lt;/td&gt;&lt;td&gt;dyn&lt;/td&gt;&lt;td&gt;305.7&lt;/td&gt;&lt;td&gt;   base debian&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;减少了42M，稍有成效，但并不明显。细心的同学应该发现，只有 122 MB 的 &lt;code&gt;debian&lt;/code&gt; 基础镜像，构建后增加到了 305 MB，看来这里面肯定有优化的空间，如何优化就要用到我们开头说到的 &lt;code&gt;Image Layer&lt;/code&gt; 知识了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;lab-3：串联 Dockerfile 指令&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;精简2：串联你的 Dockerfile 指令（一般是 &lt;code&gt;RUN&lt;/code&gt; 指令）。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Dockerfile 中的 RUN 指令通过 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 和 &lt;code&gt;/&lt;/code&gt; 支持将命令串联在一起，有时能达到意想不到的精简效果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优化 Dockerfile：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;FROM&lt;/span&gt; debian:jessie&lt;br/&gt;&lt;br/&gt;&lt;span&gt;ENV&lt;/span&gt; VER     &lt;span&gt;3.0&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;ENV&lt;/span&gt; TARBALL http://download.redis.io/releases/redis-$VER.tar.gz&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;RUN&lt;/span&gt;&lt;span&gt; &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;==&amp;gt; Install curl and helper tools...&quot;&lt;/span&gt;  &amp;amp;&amp;amp; \&lt;br/&gt;    apt-get update                      &amp;amp;&amp;amp; \&lt;br/&gt;    apt-get install -y  curl make gcc   &amp;amp;&amp;amp; \&lt;br/&gt;    \&lt;br/&gt;    &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;==&amp;gt; Download, compile, and install...&quot;&lt;/span&gt;  &amp;amp;&amp;amp; \&lt;br/&gt;    curl -L &lt;span&gt;$TARBALL&lt;/span&gt; | tar zxv  &amp;amp;&amp;amp; \&lt;br/&gt;    &lt;span&gt;cd&lt;/span&gt; redis-&lt;span&gt;$VER&lt;/span&gt;               &amp;amp;&amp;amp; \&lt;br/&gt;    make                        &amp;amp;&amp;amp; \&lt;br/&gt;    make install                &amp;amp;&amp;amp; \&lt;br/&gt;    ...&lt;/span&gt;&lt;br/&gt;    echo &lt;span&gt;&quot;==&amp;gt; Clean up...&quot;&lt;/span&gt;  &amp;amp;&amp;amp; \&lt;br/&gt;    apt-get remove -y --auto-remove curl make gcc  &amp;amp;&amp;amp; \&lt;br/&gt;    apt-get clean                                  &amp;amp;&amp;amp; \&lt;br/&gt;    rm -rf /var/lib/apt/lists/*  /redis-$VER&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;CMD&lt;/span&gt;&lt;span&gt; [&lt;span&gt;&quot;redis-server&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;构建：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ docker build  -t redis:lab-3  .&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看大小：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Lab&lt;/th&gt;&lt;th&gt;Image&lt;/th&gt;&lt;th&gt;Base&lt;/th&gt;&lt;th&gt;Lang&lt;/th&gt;&lt;th&gt;.red[*]&lt;/th&gt;&lt;th&gt;Size (MB)&lt;/th&gt;&lt;th&gt;   Memo&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;01&lt;/td&gt;&lt;td&gt;redis&lt;/td&gt;&lt;td&gt;&lt;code&gt;ubuntu&lt;/code&gt;&lt;/td&gt;&lt;td&gt;C&lt;/td&gt;&lt;td&gt;dyn&lt;/td&gt;&lt;td&gt;347.3&lt;/td&gt;&lt;td&gt;   base ubuntu&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;02&lt;/td&gt;&lt;td&gt;redis&lt;/td&gt;&lt;td&gt;&lt;code&gt;debian&lt;/code&gt;&lt;/td&gt;&lt;td&gt;C&lt;/td&gt;&lt;td&gt;dyn&lt;/td&gt;&lt;td&gt;305.7&lt;/td&gt;&lt;td&gt;   base debian&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;03&lt;/td&gt;&lt;td&gt;redis&lt;/td&gt;&lt;td&gt;&lt;code&gt;debian&lt;/code&gt;&lt;/td&gt;&lt;td&gt;C&lt;/td&gt;&lt;td&gt;dyn&lt;/td&gt;&lt;td&gt;151.4&lt;/td&gt;&lt;td&gt;   cmd chaining&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哇！一下子减少了 50%，效果明显啊！这是最常用的一个精简手段了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;lab-4：压缩你的镜像&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优化3：试着用命令或工具压缩你的镜像。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;docker 自带的一些命令还能协助压缩镜像，比如 &lt;code&gt;export&lt;/code&gt; 和 &lt;code&gt;import&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ docker run -d redis:lab-3&lt;br/&gt;$ docker &lt;span&gt;export&lt;/span&gt; 71b1c0ad0a2b | docker import - redis:lab-4&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但麻烦的是需要先将容器运行起来，而且这个过程中你会丢失镜像原有的一些信息，比如：导出端口，环境变量，默认指令。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以一般通过命令行来精简镜像都是实验性的，那么这里再推荐一个小工具：&lt;span&gt;docker-squash&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;。用起来更简单方便，并且不会丢失原有镜像的自带信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;下载安装：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://github.com/jwilder/docker-squash#installation&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;压缩操作：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ docker save redis:lab-3 \&lt;br/&gt;  | sudo docker-squash -verbose -t redis:lab-4  \&lt;br/&gt;  | docker load&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;注：该工具在 Mac 下并不好使，请在 Linux 下使用&lt;/em&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;对比大小：&lt;/strong&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Lab&lt;/th&gt;&lt;th&gt;Image&lt;/th&gt;&lt;th&gt;Base&lt;/th&gt;&lt;th&gt;PL&lt;/th&gt;&lt;th&gt;.red[*]&lt;/th&gt;&lt;th&gt;Size (MB)&lt;/th&gt;&lt;th&gt;   Memo&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;01&lt;/td&gt;&lt;td&gt;redis&lt;/td&gt;&lt;td&gt;&lt;code&gt;ubuntu&lt;/code&gt;&lt;/td&gt;&lt;td&gt;C&lt;/td&gt;&lt;td&gt;dyn&lt;/td&gt;&lt;td&gt;347.3&lt;/td&gt;&lt;td&gt;   base ubuntu&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;02&lt;/td&gt;&lt;td&gt;redis&lt;/td&gt;&lt;td&gt;&lt;code&gt;debian&lt;/code&gt;&lt;/td&gt;&lt;td&gt;C&lt;/td&gt;&lt;td&gt;dyn&lt;/td&gt;&lt;td&gt;305.7&lt;/td&gt;&lt;td&gt;   base debian&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;03&lt;/td&gt;&lt;td&gt;redis&lt;/td&gt;&lt;td&gt;&lt;code&gt;debian&lt;/code&gt;&lt;/td&gt;&lt;td&gt;C&lt;/td&gt;&lt;td&gt;dyn&lt;/td&gt;&lt;td&gt;151.4&lt;/td&gt;&lt;td&gt;   cmd chaining&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;04&lt;/td&gt;&lt;td&gt;redis&lt;/td&gt;&lt;td&gt;&lt;code&gt;debian&lt;/code&gt;&lt;/td&gt;&lt;td&gt;C&lt;/td&gt;&lt;td&gt;dyn&lt;/td&gt;&lt;td&gt;151.4&lt;/td&gt;&lt;td&gt;   docker-squash&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好吧，从这里看起来并没有太大作用，所以我只能说&lt;code&gt;试着&lt;/code&gt;，而不要报太大期望。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;lab-5：使用最精简的 base image&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100000303&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/otNtibX96l9ibwMmqp4H0uRMU8ib3Rar6K6mMHg3xYCb7QCfotOVZNeBmiaZKLI1oVKHbibrQOna5cyMEV0GE3v53JA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 &lt;code&gt;scratch&lt;/code&gt; 或者 &lt;code&gt;busybox&lt;/code&gt; 作为基础镜像。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于 scratch：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一个空镜像，只能用于构建镜像，通过 &lt;code&gt;FROM scratch&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在构建一些基础镜像，比如 &lt;code&gt;debian&lt;/code&gt; 、 &lt;code&gt;busybox&lt;/code&gt;，非常有用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用于构建超少镜像，比如构建一个包含所有库的二进制文件&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于 &lt;code&gt;busybox&lt;/code&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;只有 1~5M 的大小&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;包含了常用的 UNIX 工具&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;非常方便构建小镜像&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些超小的基础镜像，结合能生成静态原生 ELF 文件的编译语言，比如C/C++，比如 Go，特别方便构建超小的镜像。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;cloudcomb-logo（C语言开发） 就是用到了该原理，才能构建出 585 字节的镜像。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;redis&lt;/code&gt; 同样使用 C语言 开发，看来也有很大的优化空间，下面这个实验，让我们介绍具体的操作方法。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;lab-6：提取动态链接的 .so 文件&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实验上下文：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ cat /etc/os-release&lt;br/&gt;&lt;br/&gt;NAME=&lt;span&gt;&quot;Ubuntu&quot;&lt;/span&gt;&lt;br/&gt;VERSION=&lt;span&gt;&quot;14.04.2 LTS, Trusty Tahr&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ uname -a&lt;br/&gt;Linux localhost 3.13.0-46-generic &lt;span&gt;#77-Ubuntu SMP&lt;/span&gt;&lt;br/&gt;Mon Mar 2 18:23:39 UTC 2015&lt;br/&gt;x86_64 x86_64 x86_64 GNU/Linux&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;隆重推出 ldd：打印共享的依赖库&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ ldd  redis-3.0.0/src/redis-server&lt;br/&gt;    linux-vdso.so.1 =&amp;gt;  (0x00007fffde365000)&lt;br/&gt;    libm.so.6 =&amp;gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f307d5aa000)&lt;br/&gt;    libpthread.so.0 =&amp;gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f307d38c000)&lt;br/&gt;    libc.so.6 =&amp;gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f307cfc6000)&lt;br/&gt;    /lib64/ld-linux-x86-64.so.2 (0x00007f307d8b9000)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将所有需要的 .so 文件打包：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ tar ztvf rootfs.tar.gz&lt;br/&gt;4485167  2015-04-21 22:54  usr/&lt;span&gt;local&lt;/span&gt;/bin/redis-server&lt;br/&gt;1071552  2015-02-25 16:56  lib/x86_64-linux-gnu/libm.so.6&lt;br/&gt; 141574  2015-02-25 16:56  lib/x86_64-linux-gnu/libpthread.so.0&lt;br/&gt;1840928  2015-02-25 16:56  lib/x86_64-linux-gnu/libc.so.6&lt;br/&gt; 149120  2015-02-25 16:56  lib64/ld-linux-x86-64.so.2&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再制作成 Dockerfile：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;FROM&lt;/span&gt; scratch&lt;br/&gt;&lt;span&gt;ADD&lt;/span&gt;&lt;span&gt;  rootfs.tar.gz  /&lt;/span&gt;&lt;br/&gt;&lt;span&gt;COPY&lt;/span&gt;&lt;span&gt; redis.conf     /etc/redis/redis.conf&lt;/span&gt;&lt;br/&gt;&lt;span&gt;EXPOSE&lt;/span&gt; &lt;span&gt;6379&lt;/span&gt;&lt;br/&gt;&lt;span&gt;CMD&lt;/span&gt;&lt;span&gt; [&lt;span&gt;&quot;redis-server&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行构建：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ docker build  -t redis-05  .&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看大小：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Lab&lt;/th&gt;&lt;th&gt;&lt;br/&gt;&lt;/th&gt;&lt;th&gt;Base&lt;/th&gt;&lt;th&gt;PL&lt;/th&gt;&lt;th&gt;.red[*]&lt;/th&gt;&lt;th&gt;Size (MB)&lt;/th&gt;&lt;th&gt;   Memo&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;01&lt;/td&gt;&lt;td&gt;redis&lt;/td&gt;&lt;td&gt;&lt;code&gt;ubuntu&lt;/code&gt;&lt;/td&gt;&lt;td&gt;C&lt;/td&gt;&lt;td&gt;dyn&lt;/td&gt;&lt;td&gt;347.3&lt;/td&gt;&lt;td&gt;   base ubuntu&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;02&lt;/td&gt;&lt;td&gt;redis&lt;/td&gt;&lt;td&gt;&lt;code&gt;debian&lt;/code&gt;&lt;/td&gt;&lt;td&gt;C&lt;/td&gt;&lt;td&gt;dyn&lt;/td&gt;&lt;td&gt;305.7&lt;/td&gt;&lt;td&gt;   base debian&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;03&lt;/td&gt;&lt;td&gt;redis&lt;/td&gt;&lt;td&gt;&lt;code&gt;debian&lt;/code&gt;&lt;/td&gt;&lt;td&gt;C&lt;/td&gt;&lt;td&gt;dyn&lt;/td&gt;&lt;td&gt;151.4&lt;/td&gt;&lt;td&gt;   cmd chaining&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;04&lt;/td&gt;&lt;td&gt;redis&lt;/td&gt;&lt;td&gt;&lt;code&gt;debian&lt;/code&gt;&lt;/td&gt;&lt;td&gt;C&lt;/td&gt;&lt;td&gt;dyn&lt;/td&gt;&lt;td&gt;151.4&lt;/td&gt;&lt;td&gt;   docker-squash&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;05&lt;/td&gt;&lt;td&gt;redis&lt;/td&gt;&lt;td&gt;&lt;code&gt;scratch&lt;/code&gt;&lt;/td&gt;&lt;td&gt;C&lt;/td&gt;&lt;td&gt;dyn&lt;/td&gt;&lt;td&gt;7.73&lt;/td&gt;&lt;td&gt;   rootfs: .so&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哇！显著提高啦！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试一下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ docker run -d --name redis-05 redis-05&lt;br/&gt;&lt;br/&gt;$ redis-cli  -h  \&lt;br/&gt;  $(docker inspect -f &lt;span&gt;&#x27;{{.NetworkSettings.IPAddress}}&#x27;&lt;/span&gt; redis-05)&lt;br/&gt;&lt;br/&gt;$ redis-benchmark  -h  \&lt;br/&gt;  $(docker inspect -f &lt;span&gt;&#x27;{{.NetworkSettings.IPAddress}}&#x27;&lt;/span&gt; redis-05)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结一下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;用 &lt;code&gt;ldd&lt;/code&gt; 查出所需的 .so 文件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将所有依赖压缩成 &lt;code&gt;rootfs.tar&lt;/code&gt; 或 &lt;code&gt;rootfs.tar.gz&lt;/code&gt;，之后打进 &lt;code&gt;scratch&lt;/code&gt; 基础镜像&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;lab-7：为 Go 应用构建精简镜像&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 语言天生就方便用来构建精简镜像，得益于它能方便的打包成包含静态链接的二进制文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;打个比方，你有一个 4 MB 大小的包含静态链接的 Go 二进制，并且将其打进 scratch 这样的基础镜像，你得到的镜像大小也只有区区的 4 MB。这可是包含同样功能的 Ruby 程序的百分之一啊。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里再给大家介绍一个非常好用开源的 Go 编译工具：golang-builder，并给大家实际演示一个例子&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main &lt;span&gt;// import &quot;github.com/CenturyLinkLabs/hello&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;Hello World&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Dockerfile：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;FROM&lt;/span&gt; scratch&lt;br/&gt;&lt;span&gt;COPY&lt;/span&gt;&lt;span&gt; hello /&lt;/span&gt;&lt;br/&gt;&lt;span&gt;ENTRYPOINT&lt;/span&gt;&lt;span&gt; [&lt;span&gt;&quot;/hello&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 golang-builder 打包成镜像：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;docker run --rm \&lt;br/&gt;    -v $(&lt;span&gt;pwd&lt;/span&gt;):/src \&lt;br/&gt;    -v /var/run/docker.sock:/var/run/docker.sock \&lt;br/&gt;    centurylink/golang-builder&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看镜像大小(Mac下测试)：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ docker images&lt;br/&gt;REPOSITORY   TAG      IMAGE ID       CREATED          VIRTUAL SIZE&lt;br/&gt;hello        latest   1a42948d3224   24 seconds ago   1.59 MB&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哇！这么省力，就能创建几 M 大小的镜像，Go 简介就是为 Docker 镜像量身定做的！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们介绍了镜像层的知识，并且通过实验，介绍三种如何精简镜像的技巧。这里主要介绍了三种精简方法：选用更精小的镜像，串联 Dockerfile 运行指令，以及试着压缩你的镜像。通过这几个技巧，已经可以将 300M 大小的镜像压缩到 150M，压缩率50%到98%，效果还是不错。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;优化基础镜像&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;串接 Dockerfile 命令：&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;压缩 Docker images&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;优化程序依赖&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;选用更合适的开发语言&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;文章的最后，插播一个福利&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;双十一快到了，&lt;/span&gt;&lt;span&gt;阿里云也开始搞活动了&lt;/span&gt;&lt;span&gt;，刚好我这边可以带大家&lt;/span&gt;&lt;strong&gt;白Piao &lt;/strong&gt;&lt;span&gt;阿里云的服务器。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;说白了就是大家 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;可以一分钱不花，就可以领到服务器&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，规格是 2c2m（2vcpu 2G memory） 的机器。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;昨天在&lt;/span&gt;&lt;span&gt;朋友圈&lt;/span&gt;&lt;span&gt;发了下，&lt;/span&gt;&lt;span&gt;已经有 400 人报名参与了，&lt;/span&gt;&lt;span&gt;今天&lt;/span&gt;&lt;span&gt;借&lt;/span&gt;&lt;span&gt;这篇文章再说一下，&lt;/span&gt;&lt;span&gt;有想&lt;/span&gt;&lt;span&gt;参加的朋友，&lt;/span&gt;&lt;span&gt;可以加我下微信，备注『&lt;strong&gt;服务器&lt;/strong&gt;』&lt;/span&gt;&lt;span&gt;，我&lt;/span&gt;&lt;span&gt;统一&lt;/span&gt;&lt;span&gt;拉群，&lt;/span&gt;&lt;span&gt;带大家一起&lt;/span&gt;&lt;span&gt;薅羊毛。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100002183&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/QB6G4ZoE1844XggiaKk4CnSJBGTia3z9sVPlARYFdQGHibxh6jpthSCmhUhGuM1EIiavAGxg5p7ibRXDvPB6pFt8jEg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;430&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;参考&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;scratch in Docker Hub&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;Make FROM scratch a special cased &#x27;no-base&#x27; spec&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;vDSO (virtual dynamic shared object)&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;Small Docker Images For Go Apps&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt; (with &lt;span&gt;golang-builder&lt;/span&gt;&lt;sup&gt;[8]&lt;/sup&gt;)&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;Building Docker Images for Static Go Binaries&lt;/span&gt;&lt;sup&gt;[9]&lt;/sup&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;Dockerfile Best Practices - take 2&lt;/span&gt;&lt;sup&gt;[10]&lt;/sup&gt; - by Michael Crosby, 2014-03-09.&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;Optimizing Docker Images&lt;/span&gt;&lt;sup&gt;[11]&lt;/sup&gt; - by Brian DeHamer, 2014-07-28.&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;Squashing Docker Images&lt;/span&gt;&lt;sup&gt;[12]&lt;/sup&gt; - by Jason Wilder, 2014-08-19.&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;这些技术: &lt;em&gt;https://docs.docker.com/engine/userguide/storagedriver/imagesandcontainers/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;一期: &lt;em&gt;https://github.com/bingohuang/play-docker-images/tree/master/stage-01&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;docker-squash: &lt;em&gt;https://github.com/jwilder/docker-squash&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;scratch in Docker Hub: &lt;em&gt;https://registry.hub.docker.com/_/scratch/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;Make FROM scratch a special cased &#x27;no-base&#x27; spec: &lt;em&gt;https://github.com/docker/docker/pull/8827&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;vDSO (virtual dynamic shared object): &lt;em&gt;http://en.wikipedia.org/wiki/VDSO&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[7]&lt;/span&gt;&lt;p&gt;Small Docker Images For Go Apps: &lt;em&gt;http://www.centurylinklabs.com/small-docker-images-for-go-apps/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[8]&lt;/span&gt;&lt;p&gt;golang-builder: &lt;em&gt;https://github.com/CenturyLinkLabs/golang-builder&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[9]&lt;/span&gt;&lt;p&gt;Building Docker Images for Static Go Binaries: &lt;em&gt;https://medium.com/@kelseyhightower/optimizing-docker-images-for-static-binaries-b5696e26eb07&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[10]&lt;/span&gt;&lt;p&gt;Dockerfile Best Practices - take 2: &lt;em&gt;http://crosbymichael.com/dockerfile-best-practices-take-2.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[11]&lt;/span&gt;&lt;p&gt;Optimizing Docker Images: &lt;em&gt;http://www.centurylinklabs.com/optimizing-docker-images/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[12]&lt;/span&gt;&lt;p&gt;Squashing Docker Images: &lt;em&gt;http://jasonwilder.com/blog/2014/08/19/squashing-docker-images/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>83aac753bab2b124a21d4a7222ab3ff1</guid>
<title>最近很火火火火的 GitHub 项目</title>
<link>https://toutiao.io/k/3l64knj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;老逛每个月都会盘点当前月份最火的开源项目，本篇文章就是十月份 Star 攀升最多的的开源项目，它们分别是：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;1. 电商大促脚本&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2. 基于 Js 的游戏引擎&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3. Bug 厂库&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4. 高分计算机书单&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;5. 开源物联网平台&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;6. K8S 可视化面板&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;7. 硬核系统管理工具&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;8. 强大的线程池项目&lt;/span&gt;&lt;/section&gt;&lt;h1 data-key=&quot;fd245a0b20464c4d835251e573a6be6f&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;hr/&gt;&lt;/section&gt;&lt;/h1&gt;&lt;section&gt;&lt;span&gt;01&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;任务脚本&lt;/span&gt;&lt;/section&gt;&lt;h1&gt;&lt;span&gt;当你想完成一件重复劳动的事情，就先去 GitHub 去看看有没有黑科技。最近双十一大促，GitHub 上一个任务自动脚本登上了榜单，该项目是基于AutoJs编写的任务自动完成脚本，可以帮助你在 618、双十一、淘宝、京东、赚喵糖、赚汪汪币活动中崭露头角。&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100022368&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.44356578001437813&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwOWLicYpJXHBwMgD2LRUQ4EsoyaMTRlpCT7IER3VpDRfoNfbdGnvU1Z7GHNLYy1NqnqDUicaZNeOUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2782&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;02&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;LittleJS&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;LittleJS 是一个超轻量级的 2D JavaScript 游戏引擎，具有快速的 WebGL 渲染。它被设计为小巧、简单且易于使用，适用于从 game jams 到商业发布的各种应用程序。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该引擎拥有制作高质量游戏所需的一切，包括快速渲染、物理、粒子、音效、音乐、键盘/鼠标/游戏手柄输入处理、更新/渲染循环和调试工具。🚂&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100022369&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ePw3ZeGRruwOWLicYpJXHBwMgD2LRUQ4ET5icic7bCSmqZ1x3SicRSEroroauOib52heqUyrOt238bstnSUicnS16qEw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;03&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;GrowingBugs&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;一个不断增长的 bug 存储库，称为 GrowingBugs。在这个厂库中，&lt;span&gt;每个错误都由一个错误版本、一个修复版本、一个简洁的补丁（仅限错误修复更改）和一个或多个触发测试用例组成。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100022370&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6642685851318945&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwOWLicYpJXHBwMgD2LRUQ4EtJJzI1T14BJN86yK0dr9YskdA6tNe18iapDBqDqbpQDvsibf4kMHWreg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1668&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;04&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;高分计算机书单&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;这个仓库时一个书单索引，综合了豆瓣 goodreads 综合评分的计算机书籍书单。该仓库包含计算机，互联网有关的几乎所有书籍，根据不同版本，两个平台的总评价人数和评分求出平均分，按从高到低排列。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;希望能对寻找经典计算机书籍的朋友提供帮助，排序仅供参考，评分的高低不一定代表书籍的真正质量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100022372&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7123947051744886&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwOWLicYpJXHBwMgD2LRUQ4E3HsB3bJgVvAVEKrNttogclYVE3syrnzFU0xBibcZLeCictuSpVvNzmJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1662&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;05&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;物联网开源平台&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;DGIOT&lt;/em&gt; 是国内首款轻量级开源工业物联网持续集成平台，DG-IoT团队2016年之前，在互联网和移动互联网爬坑多年，2016年开始进入物联网爬坑，希望通过这个开源平台把多年爬坑经验共享出来，让多学科交叉的工业互联网项目变得更简单。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 让丰富工程人员可以通过视窗交互可以完成需求较简单的工业互联网项目&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 让广大的初级前端工程师通过serverless的方式可以承接需求较复杂的工业互联网项目&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. 让Python、Java、Go、C初级后台工程师通过web编程开发通道来承接复杂的工业互联网项目&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100022378&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8862068965517241&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwOWLicYpJXHBwMgD2LRUQ4EEjtaB8pyibGppgI2Ofiaj1aSWMG3WkexiaYDz6GKTQHAYw6q2WksDBXjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1160&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;06&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;K8S可视化管理面板&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;KubePi 是一款简单易用的开源 Kubernetes 可视化管理面板。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;KubePi 允许管理员导入多个 Kubernetes 集群，并且通过权限控制，将不同 cluster、namespace 的权限分配给指定用户。它允许开发人员管理 Kubernetes 集群中运行的应用程序并对其进行故障排查，供开发人员更好地处理 Kubernetes 集群中的复杂性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100022371&quot; data-ratio=&quot;0.5675&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwOWLicYpJXHBwMgD2LRUQ4EGOccaFQ6rpPKN0e1by7Chy456TCMxLEyG3r40zL2139j1VWXWGRpicg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100022376&quot; data-ratio=&quot;0.568407960199005&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwOWLicYpJXHBwMgD2LRUQ4Echia19PzLiaMtu4lwM4vF7cUPiaZ5hzSIfibN07yicBfjkdwVd995T3lIkQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1608&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;07&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;硬核的系统工具&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100022375&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.464808362369338&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwOWLicYpJXHBwMgD2LRUQ4EnFqia230iaXmIQiaaRDA2Lubg8aByDgicTdBk2NdWtMMvK5NrIvPQbX8Eg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2870&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一款免费、功能强大的多用途工具，可帮助您监控系统资源、调试软件和检测恶意软件。&lt;span&gt;当无法编辑或删除文件时，该开源项目能够帮你发现哪些进程正在使用该文件。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100022374&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.30615384615384617&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwOWLicYpJXHBwMgD2LRUQ4EbRb4zbwDQpRibDMajVhbsqIgFlXkrdr2HZicFz0VlsRjYwrEj6mJnxCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;650&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;查看哪些程序具有活动的网络连接，也可以关闭它们。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100022373&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.46177847113884557&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwOWLicYpJXHBwMgD2LRUQ4E4p6HJa8QIicic9bbR8TAAAodibWjBlHTxnnVY5SUCxSdnEKMhyiar9l3Jg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;641&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;08&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;强大的动态线程池&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;强大的动态线程池：Hippo，并附带监控报警功能（没有依赖中间件），完全遵循阿里巴巴编码规范。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;线程池在业务系统应该都有使用到，帮助业务流程提升效率以及管理线程，多数场景应用于大量的异步任务处理虽然线程池提供了我们许多便利，但也并非尽善尽美，也存在很多问题可能需要发布业务系统来解决。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Hippo 很好解决了这个问题，它将业务中所有线程池统一管理，遇到上述问题不需要发布系统就可以替换线程池参数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Hippo 按照租户、项目、线程池的维度划分。再加上系统权限，让不同的开发、管理人员负责自己系统的线程池操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100022377&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8807692307692307&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwOWLicYpJXHBwMgD2LRUQ4ExiaS8WtJibgXRp7TTZM08eH8nFT4TalnjWgBNJXfadAL1gUdYviavA29w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;780&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;欢迎关注公众号 逛逛GitHub 回复「1028」下载本期所有项目。&lt;/span&gt;&lt;span&gt;最后，防止找不到本篇文章，可以收藏点赞，方便翻阅查找。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;hr/&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;1. &lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247498662&amp;amp;idx=1&amp;amp;sn=0087c4f3b79ba3420e917e9b42d45eda&amp;amp;chksm=f9a2286fced5a1794eb9a73d0be7c2e16eaceabf3a0420647c40cb4202bd116d9a15dd57c008&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;GitHub 上有什么好玩的项目？&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;2.&lt;/span&gt;&lt;/em&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247505125&amp;amp;idx=1&amp;amp;sn=d7da4f44bdbd4f439e02c316810e75c2&amp;amp;chksm=f9a2072cced58e3aaeff8543f8f1ea050d4b04f7a1d730482aacd4db8cc9372ae1d103a56a56&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;推荐 7 个热门电商 GitHub 项目&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;3.&lt;/span&gt;&lt;/em&gt; &lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247505087&amp;amp;idx=1&amp;amp;sn=51e6b3db9d95ea2683f3bff5645c83e2&amp;amp;chksm=f9a20776ced58e60658b56869e9496196acf7ffb08fff639a913ecd770745567b4c6e7870db2&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;女朋友让我写 1 万字检讨&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;4.&lt;/span&gt;&lt;/em&gt; &lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247504912&amp;amp;idx=1&amp;amp;sn=5f800a1753d03014052ce50b548d5c0d&amp;amp;chksm=f9a207d9ced58ecf146bac5e034a503d1c17b3f755a8a16b9cca190f4c590d368dee3040f5ef&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;GitHub 上 7 个 yyds 算法项目&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;172&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;172&quot; data-fileid=&quot;100022379&quot; data-ratio=&quot;1.005449591280654&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruxW7LMX2Iz5DfjRIbFTS7UROhxibBmicicT0HpjIh1yniaJJibSnLFuicMHRx5NEdiaOh2OOACfr6MvR38ibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;734&quot;/&gt; &lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7356d038928d1b94b0edfa59b58b1242</guid>
<title>十小时写出一个活动通知的微信小程序</title>
<link>https://toutiao.io/k/x94g7dn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entry-inner&quot;&gt;
                                                    
&lt;p&gt;熟悉我的人都知道，我们每周都会举办一次分布式系统话题的讨论（对活动感兴趣的同学可以参考这个网址：&lt;a href=&quot;https://donggeitnote.com/2021/07/24/topic-introduction/&quot;&gt;https://donggeitnote.com/2021/07/24/topic-introduction/&lt;/a&gt;，当然这个不是我们今天讨论的重点），这个讨论的活动安排会发布到各个微信群，这样感兴趣的同学就可以来参加了。在上周五因为我个人的失误，没有更新活动通知中的时间，于是就导致这个活动的消息需要重新发布，这其实给帮忙发布活动的同学带来了很大的困扰。虽然最后也解决了问题，但是过程并不是很开心。所以我就想应该写个小程序来通知一下，这样一方面可以解决我们遇到的问题，比如哪次的时间再写错了，我们只要更新一下小程序内的内容就可以了。另外一方面也可以让一些主动想了解讨论话题的同学能够有一个统一的地方来发现话题。说做就做，一到周六我就开始来着手搞这件事情了。&lt;/p&gt;



&lt;h1&gt;需求分析&lt;/h1&gt;



&lt;p&gt;需求大概是我们第一步需要了解清楚的东西，在真正着手之前，我把最基本的需求简单列了一下，如下所示：&lt;/p&gt;



&lt;h2&gt;活动管理页面&lt;/h2&gt;



&lt;p&gt;这个页面是让活动发布者管理已经创建的活动以及发布新的活动，主要的功能包括以下几个方面：&lt;/p&gt;



&lt;ol type=&quot;1&quot;&gt;&lt;li&gt;显示已经创建的活动列表&lt;/li&gt;&lt;li&gt;创建新的活动&lt;/li&gt;&lt;li&gt;修改已经创建的活动&lt;/li&gt;&lt;li&gt;删除已经创建的活动&lt;/li&gt;&lt;/ol&gt;



&lt;h2&gt;活动显示页面&lt;/h2&gt;



&lt;p&gt;这个页面主要是让活动的参与者知道有哪些活动，都会在什么时候举行，想参加的话还可以设置相关的提醒，所以主要的功能会包含下面这些&lt;/p&gt;



&lt;ol type=&quot;1&quot;&gt;&lt;li&gt;显示即将举行的活动&lt;/li&gt;&lt;li&gt;设置活动的提醒&lt;/li&gt;&lt;li&gt;取消活动的提醒&lt;/li&gt;&lt;li&gt;显示活动的详情&lt;/li&gt;&lt;/ol&gt;



&lt;h2&gt;活动提醒&lt;/h2&gt;



&lt;p&gt;这是一个后台运行的程序，主要用来在活动即将开始之前通知已经设置提醒了的同学。&lt;/p&gt;



&lt;h1&gt;准备&lt;/h1&gt;



&lt;p&gt;搞懂了需求之后，在正式写代码之前我们还有一些工作需要去做：&lt;/p&gt;



&lt;p&gt;首先我们需要去注册一个小程序，相应的网址是：&lt;a href=&quot;https://mp.weixin.qq.com/cgi-bin/wx&quot;&gt;https://mp.weixin.qq.com/cgi-bin/wx&lt;/a&gt;，点击前往注册就可以了，没有什么特别的，大家按步操作就可以了。这里吐槽一下就是一个邮箱只能注册一个小程序比较麻烦，我还得再申请一个新的邮箱来注册小程序，啥时微信能把这个简单的问题解决就方便多了。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-40.png&quot; alt=&quot;&quot; class=&quot;wp-image-1068&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-40.png 624w, https://donggeitnote.com/wp-content/uploads/2021/10/image-40-294x300.png 294w&quot; sizes=&quot;(max-width: 624px) 100vw, 624px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;在注册了小程序之后，我们需要下载微信开发者工具，可以在这个页面下载&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/devtools/devtools.html&quot;&gt;https://developers.weixin.qq.com/miniprogram/dev/devtools/devtools.html&lt;/a&gt;， 当然假如你是第一次使用，也可以把相关的内容读一下，熟悉一下这个工具如何使用。这个工具打开之后，大概是这个样子：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-41.png&quot; alt=&quot;&quot; class=&quot;wp-image-1069&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-41.png 624w, https://donggeitnote.com/wp-content/uploads/2021/10/image-41-300x213.png 300w&quot; sizes=&quot;(max-width: 624px) 100vw, 624px&quot;/&gt;&lt;/figure&gt;



&lt;h1&gt;微信小程序总体架构&lt;/h1&gt;



&lt;p&gt;在准备好了相关的工具之后，真正动手写代码之前，我们再来简单了解一下微信小程序的总体架构，这样我们就可以大概知道自己需要实现些什么。微信小程序的总体架构如下图所示，我们可以看到其实微信已经帮我们做好了所有的架构相关的内容，比如我们通常说的负载均衡，集群容错，CDN加速，Redis cache，监控系统等等，我们所要做的其实很简单，只要实现小程序的前端页面和后端数据库以及两者之间的交互，也就是常说的API层就可以了。这背后的其它所有的和架构，部署相关的东西都不需要特别在意。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-42.png&quot; alt=&quot;&quot; class=&quot;wp-image-1070&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-42.png 624w, https://donggeitnote.com/wp-content/uploads/2021/10/image-42-300x203.png 300w&quot; sizes=&quot;(max-width: 624px) 100vw, 624px&quot;/&gt;&lt;/figure&gt;



&lt;h1&gt;用户ID&lt;/h1&gt;



&lt;p&gt;在了解了相关的架构之后，我们心理有底，就可以真正着手开始写代码了。这里我们首先来思考一下上文提到的活动管理页面如何实现，我们预想中的这个页面是如下图所示的，它包含了几个部分，首先能够列出已经创建的活动列表，其次能够修改这个活动（点击笔这个图标），当然还必须要能够创建新的活动。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-43.png&quot; alt=&quot;&quot; class=&quot;wp-image-1071&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-43.png 419w, https://donggeitnote.com/wp-content/uploads/2021/10/image-43-300x151.png 300w&quot; sizes=&quot;(max-width: 419px) 100vw, 419px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;我们来想一下这个页面的实现，肯定是需要一个API来得到所有的活动，我们假设这个API名字是GetActivities()，只要我们通过这个API把数据库中所有符合要求的活动返回到前端之后，就只是一个列表显示的问题了。&lt;/p&gt;



&lt;p&gt;这里比较难的一个问题就在于符合要求的活动列表，我们最初的设计是希望活动创建者只能看到/修改创建的活动。 这就需要一个用户ID来标识这个活动的创建者，当我翻开微信小程序的开发文档时，会发现其实这里有两个ID可以使用，一个是openId，一个是UnionId。&lt;/p&gt;



&lt;ul&gt;&lt;li&gt;简单来说openId是对于小程序来说的，也就是说同一个用户在打开微信小程序的时候都会是这一个id，它不需要用户操作和授权。&lt;/li&gt;&lt;li&gt;而UnionId则是同一个用户在你所开发的所有的APP包括微信小程序，微信公众号，app等之间统一的ID标识，这样你就可以在小程序，公众号等之间交互数据了。当然小程序，公众号必须是同一个主体才行。&lt;/li&gt;&lt;/ul&gt;



&lt;p&gt;那么回归到我们的小程序，我们其实并不需要在多个应用之间进行数据交互。所以理所当然选择openId就可以了。我们可以使用一个简单的云函数来实现OpenId的获取，相关的代码如下：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-44.png&quot; alt=&quot;&quot; class=&quot;wp-image-1072&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;我们获取了需要的openId之后，还有一个问题需要考虑，那就是什么时候来获取OpenId，可以预见的是我们大概在整个程序的运行过程中都需要使用这个id，那么把它保存到一个全局的地方显然是一个很好的方法。我们可以在app.js的onLaunch来获取，并它保存到一个全局变量中。&lt;/p&gt;



&lt;h1&gt;获取活动列表&lt;/h1&gt;



&lt;p&gt;在有了OpenId之后，我们就可以来获取已经创建的活动列表了。也就是我们上文提到的GetActivities() API。这里有两种实现:&lt;/p&gt;



&lt;ol type=&quot;1&quot;&gt;&lt;li&gt;GetActivities(OpenId)，这种实现中把OpenId作为参数传给后端，然后返回的结果只包含OpenId创建的活动，也就是我们想要的结果，直接以列表的方法显示出来即可。&lt;/li&gt;&lt;li&gt;GetActivities()，获取所有人创建的活动，然后在前端在根据openId来filter出来管理者自己创建的活动，然后再显示。&lt;/li&gt;&lt;/ol&gt;



&lt;p&gt;这两种方法各有其优缺点，前者的好处就是它只需要返回管理者创建的活动即可，没有额外的返回。但是问题就是在这个request发送之前，它就需要openId，而我们上文的OpenId其实是一个异步调用，它什么时候能够返回并不确定。也就是说从performance的角度来说，这个GetActivites(OpenId)只能在上面的getOpenId返回之后才能执行。&lt;/p&gt;



&lt;p&gt;而第二种方法则可以解决第一种方法的问题，它不需要等待OpenId的返回，只要在得到response做filter之前得到OpenId即可。当然它本身的问题也很明显，就是它需要返回所有人创建的活动，这个response有可能会有很多没有必要内容。&lt;/p&gt;



&lt;p&gt;那么我们这里会选择哪一种方案呢？我们最终选择的是第二种方案，原因是从我们的角度来看，其实创建的活动量不会很多，一周也就不会超过十个，而且很多时候都是一个人创建的，所以即使选择第一种方案，可能也不能得到第一种方案的好处。所以这个最终方案的选择还是需要看你自己的使用场景是怎么样的来最终决定。&lt;/p&gt;



&lt;p&gt;拿到activities之后再做filter，（前提也还是要判断一下openId是否是已经存在了）&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-45.png&quot; alt=&quot;&quot; class=&quot;wp-image-1073&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-45.png 346w, https://donggeitnote.com/wp-content/uploads/2021/10/image-45-300x124.png 300w&quot; sizes=&quot;(max-width: 346px) 100vw, 346px&quot;/&gt;&lt;/figure&gt;



&lt;h1&gt;创建活动&lt;/h1&gt;



&lt;p&gt;创建活动的页面大概如下所示，主要就是包含活动主题，时间，星期，以及描述。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-46.png&quot; alt=&quot;&quot; class=&quot;wp-image-1074&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-46.png 336w, https://donggeitnote.com/wp-content/uploads/2021/10/image-46-173x300.png 173w&quot; sizes=&quot;(max-width: 336px) 100vw, 336px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;从UI的角度来说，这个没有什么特别需要注意的，就是这里可能会有一些bind的操作，比如说我们修改了时间，那么星期也需要跟着修改，我想这个对于写过前端代码的同学来说应该会比较简单。它主要通过这样类似bindchange的操作来实现：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-47.png&quot; alt=&quot;&quot; class=&quot;wp-image-1075&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-47.png 624w, https://donggeitnote.com/wp-content/uploads/2021/10/image-47-300x103.png 300w&quot; sizes=&quot;(max-width: 624px) 100vw, 624px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;在创建活动之后，我们可以看到会在后端数据库中插入一条类似下面这样的数据：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-48.png&quot; alt=&quot;&quot; class=&quot;wp-image-1076&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-48.png 257w, https://donggeitnote.com/wp-content/uploads/2021/10/image-48-234x300.png 234w&quot; sizes=&quot;(max-width: 257px) 100vw, 257px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;应该每一个property都比较清楚，你也许会问这里的applyMembers是什么呢？我们来接着看：&lt;/p&gt;



&lt;h1&gt;提醒的设置&lt;/h1&gt;



&lt;p&gt;在活动创建并能够显示之后，一个很重要的功能就是能够及时提醒相关的用户活动即将开始。这里的页面大概如下所示：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-49.png&quot; alt=&quot;&quot; class=&quot;wp-image-1077&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-49.png 421w, https://donggeitnote.com/wp-content/uploads/2021/10/image-49-300x300.png 300w, https://donggeitnote.com/wp-content/uploads/2021/10/image-49-150x150.png 150w, https://donggeitnote.com/wp-content/uploads/2021/10/image-49-80x80.png 80w, https://donggeitnote.com/wp-content/uploads/2021/10/image-49-320x320.png 320w&quot; sizes=&quot;(max-width: 421px) 100vw, 421px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;上面是活动的显示，这个很好做，一个GetActivities()的API得到所有的活动，然后显示就可以了。这里需要考虑的是如何实现这个设置提醒的功能。这个功能包含两个方面，一个方面就是能够通过一定的机制发送提醒给用户；另一个方面就是如何知道哪些用户设置了提醒，并且在正确的时间发送提醒。&lt;/p&gt;



&lt;p&gt;前者通知的机制肯定就是需要微信小程序来支持了，我们这里使用的“订阅消息”的功能，你可以在微信小程序后台看到这个选项：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-50.png&quot; alt=&quot;&quot; class=&quot;wp-image-1078&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-50.png 258w, https://donggeitnote.com/wp-content/uploads/2021/10/image-50-150x150.png 150w, https://donggeitnote.com/wp-content/uploads/2021/10/image-50-80x80.png 80w&quot; sizes=&quot;(max-width: 258px) 100vw, 258px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;要使用这个功能，你需要先选用一个模板或者自己创建一个模板，目前小程序的公共模板库有50个常见的订阅模板，如下所示，我们的场景也很通用，没有什么特殊的地方，所以可以直接选择其中一个。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-51.png&quot; alt=&quot;&quot; class=&quot;wp-image-1079&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-51.png 624w, https://donggeitnote.com/wp-content/uploads/2021/10/image-51-300x199.png 300w&quot; sizes=&quot;(max-width: 624px) 100vw, 624px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;这里假如你仔细观察，可以发现其实是支持两种订阅模式的：&lt;/p&gt;



&lt;ol type=&quot;1&quot;&gt;&lt;li&gt;一次性订阅：也就是用户授权一次，你可以发送一次通知。&lt;/li&gt;&lt;li&gt;长期订阅：用户授权一次，你可以发送无限次通知。&lt;/li&gt;&lt;/ol&gt;



&lt;p&gt;目前向个人开发者开放的是一次性订阅，长期订阅我们并不能使用，所以可以忽略。当你选择了模板之后，就会有一个模板的ID（templateId），这个id就可以用来进行订阅和发送了。&lt;/p&gt;



&lt;p&gt;相关的订阅代码如下所示：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-52.png&quot; alt=&quot;&quot; class=&quot;wp-image-1080&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;也就是说有用户点击了设置提醒之后，我们就需要调用这个函数来注册到相关的templateId中。同时我们需要把这个用户的id加入到我们上文提到的appplyMembers列表中，从而我们可以知道哪些用户设置了提醒了。&lt;/p&gt;



&lt;p&gt;那么在用户设置了提醒之后，我们怎么才可以给对应的用户发送提醒呢？这里有两个问题，一个是怎么知道何时发送，这就需要我们有一个类似定时器的任务一直在后台运行，看哪个activity已经要开始了，然后决定是否要发送提醒。&lt;/p&gt;



&lt;p&gt;要实现这个功能，我们可以使用小程序中的定时触发器功能。它主要就是会定时执行一个云函数，有了这个功能之后就方便了，如下所示，在相关的云函数中加入这个定时触发器，这里每15分钟执行一次这个函数。相关定时器的使用，大家可以参见微信的官方文档：https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/functions/triggers.html&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-53.png&quot; alt=&quot;&quot; class=&quot;wp-image-1081&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;这样每15分钟会检查一次看是否有活动要开始了，如果有，则会发送通知，发送通知可以使用下面函数来实现：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-54.png&quot; alt=&quot;&quot; class=&quot;wp-image-1082&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-54.png 365w, https://donggeitnote.com/wp-content/uploads/2021/10/image-54-252x300.png 252w&quot; sizes=&quot;(max-width: 365px) 100vw, 365px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;这里的templateId就是我们之前注册的templateId，需要注意的时候它的消息是有一些长度限制的，只能发送20个字符，最终的效果如下所示：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-55.png&quot; alt=&quot;&quot; class=&quot;wp-image-1083&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-55.png 393w, https://donggeitnote.com/wp-content/uploads/2021/10/image-55-300x180.png 300w&quot; sizes=&quot;(max-width: 393px) 100vw, 393px&quot;/&gt;&lt;/figure&gt;



&lt;h1&gt;监控&lt;/h1&gt;



&lt;p&gt;至此，小程序的开发部分就基本完成了，我们最后来聊一聊监控相关的内容。就是你的小程序的使用情况，你可以通过开发工具中的云开发平台来监控：&lt;/p&gt;



&lt;p&gt;这是整体的状况：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-56.png&quot; alt=&quot;&quot; class=&quot;wp-image-1084&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-56.png 624w, https://donggeitnote.com/wp-content/uploads/2021/10/image-56-300x114.png 300w&quot; sizes=&quot;(max-width: 624px) 100vw, 624px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;资源使用的情况，这个比较重要，你可以根据这个来评测你的用户量，然后评估是否需要付费运行。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-57.png&quot; alt=&quot;&quot; class=&quot;wp-image-1085&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-57.png 624w, https://donggeitnote.com/wp-content/uploads/2021/10/image-57-300x48.png 300w&quot; sizes=&quot;(max-width: 624px) 100vw, 624px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;当然从开发者角度来看，你而已可以看各个云函数执行的状况，比如我们上面的每15分钟运行的函数的执行情况如下：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-58.png&quot; alt=&quot;&quot; class=&quot;wp-image-1086&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-58.png 276w, https://donggeitnote.com/wp-content/uploads/2021/10/image-58-221x300.png 221w&quot; sizes=&quot;(max-width: 276px) 100vw, 276px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;这里你基本可以监控你所有你想知道的东西，甚至可以直接修改数据库，哈哈。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-59.png&quot; alt=&quot;&quot; class=&quot;wp-image-1087&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-59.png 485w, https://donggeitnote.com/wp-content/uploads/2021/10/image-59-300x111.png 300w&quot; sizes=&quot;(max-width: 485px) 100vw, 485px&quot;/&gt;&lt;/figure&gt;



&lt;h1&gt;总结&lt;/h1&gt;



&lt;p&gt;至此，我们就把这个花了我10个小时肝出来的小程序写法告诉大家了，具体的小程序名字就不说了，否则被你们去尝试之后，我们的免费额度就不够用了，希望对写小程序感兴趣的同学能有所帮助。&lt;/p&gt;
                                                    &lt;nav class=&quot;pagination group&quot;&gt;
                      &lt;/nav&gt;
        &lt;/div&gt;

        
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e92c589169bdb6d30fc38cba86272862</guid>
<title>性能优化：如何更快地接收数据</title>
<link>https://toutiao.io/k/xcgimf8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-hnrfcf&quot; options=&quot;[object Object]&quot;&gt;&lt;p&gt;从网卡到应用程序，数据包会经过一系列组件，其中驱动做了什么？内核做了什么？为了优化，我们又能做些什么？整个过程中涉及到诸多细微可调的软硬件参数，并且相互影响，不存在一劳永逸的“银弹”。本文中又拍云系统开发高级工程师杨鹏将结合自己的的实践经验，介绍在深入理解底层机制的基础上如何做出“场景化”的最优配置。&lt;/p&gt;&lt;blockquote&gt;文章根据杨鹏在又拍云 Open Talk 技术沙龙北京站主题演讲《性能优化：更快地接收数据》整理而成，现场视频及 PPT 可下拉文末点击阅读原文查看。&lt;/blockquote&gt;&lt;p&gt;大家好，我是又拍云开发工程师杨鹏，在又拍云工作已有四年时间，期间一直从事 CDN 底层系统开发的工作，负责调度、缓存、负载均衡等 CDN的核心组件，很高兴来跟大家分享在网络数据处理方面的经验和感受。今天分享的主题是《如何更快地接收数据》，主要介绍加速网络数据处理的方法和实践。希望能帮助大家更好的了解如何在系统的层面，尽量在应用程序无感的情况下做到极致的优化。言归正传，进入主题。&lt;/p&gt;&lt;p&gt;首先需要清楚在尝试做任何优化的时候，想到的第一件事情应该是什么？个人觉得是衡量指标。做任何改动或优化之前，都要明确地知道，是怎样的指标反映出了当前的问题。那么在做了相应的调整或改动之后，也才能通过指标去验证实际效果与作用。&lt;/p&gt;&lt;p&gt;针对要分享的主题，有一个围绕上面指标核心的基本原则。在网络层面做优化，归根结底只需要看一点，假如可以做到网络栈的每个层次，加入能监控到对应层次的丢包率，这样核心的指标，就可以明确地知道问题出在哪一层。有了明确可监控的指标，之后做相应的调整与实际效果的验证也就很简单了。当然上述两点相对有点虚，接下来就是比较干的部分了。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-31788060ba64420840bc3acc09064678_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1026&quot; data-rawheight=&quot;652&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-31788060ba64420840bc3acc09064678_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1026&quot; data-rawheight=&quot;652&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-31788060ba64420840bc3acc09064678_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-31788060ba64420840bc3acc09064678_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;如上图所示，当收到一个数据包，从进入网卡，一直到达应用层，总的数据流程有很多。在当前阶段，无需关注每个流程，留意其中几个核心的关键路径即可：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;第一个，数据包到达网卡；&lt;/li&gt;&lt;li&gt;第二个，网卡在收到数据包时，它需要产生一个中断，告诉 CPU 数据已经到了；&lt;/li&gt;&lt;li&gt;第三步，内核从这个时候开始进行接管，把数据从网卡中拿出来，交到后面内核的协议栈去处理。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;以上是三个关键的路径。上图中右边的手绘图指的就是这三个步骤，并有意区分了两个颜色。之所以这么区分是因为&lt;b&gt;接下来会按这两部分进行分享，一是上层驱动部分，二是下层涉及到内核的部分。&lt;/b&gt;当然内核比较多，通篇只涉及到内核网络子系统，更具体来说是内核跟驱动交互部分的内容。&lt;/p&gt;&lt;h2&gt;&lt;br/&gt;网卡驱动&lt;/h2&gt;&lt;p&gt;网卡驱动的部分，网卡是硬件，驱动（driver）是软件，包括了网卡驱动部分的大部分。这部分可简单分四个点，依次是初始化、启动、监控与调优驱动它的初始化流程&lt;/p&gt;&lt;p&gt;&lt;b&gt;网卡驱动-初始化 &lt;/b&gt;&lt;/p&gt;&lt;p&gt;驱动初始化的过程和硬件相关，无需过分关注。但需注意一点就是注册 ethool 的一系列操作，这个工具可以对网卡做各种各样的操作，不止可以读取网卡的配置，还可以更改网卡的配置参数，是一个非常强大的工具。&lt;/p&gt;&lt;p&gt;那它是如何控制网卡的呢？每个网卡的驱动在初始化时，通过接口，去注册支持 ethool 工具的一系列操作。ethool 是一套很通用的接口，比如说它支持 100 个功能，但每个型号的网卡，只能支持一个子集。所以具体支持哪些功能，会在这一步进行声明。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-2d0afc79ffc5a1c3d62383e2ba827274_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1057&quot; data-rawheight=&quot;589&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-2d0afc79ffc5a1c3d62383e2ba827274_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1057&quot; data-rawheight=&quot;589&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-2d0afc79ffc5a1c3d62383e2ba827274_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-2d0afc79ffc5a1c3d62383e2ba827274_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;上图截取的部分，是在初始化时结构体的赋值。前面两个可以简单看一下，驱动在初始化的时候会告诉内核，如果想要操作这块网卡对应的回调函数，其中最主要的是启动和关闭，有用 ifconfig 工具操作网卡的应该都很熟悉，当用 ifconfigup/down一张网卡的时候，调用的都是它初始化时指定的这几个函数。&lt;/p&gt;&lt;p&gt;&lt;b&gt;网卡驱动-启动&lt;/b&gt;&lt;/p&gt;&lt;p&gt;驱动初始化过程之后就是启动（open）中的流程了，一共分为四步：分配 rx/tx 队列内存、&lt;/p&gt;&lt;p&gt;开启 NAPI、注册中断处理函数、开启中断。其中注册中断处理函数和开启中断是理所当然的，任何一个硬件接入到机器上都需要做这个操作。当后面收到一些事件时，它需要通过中断去通知系统，然后开启中断。&lt;/p&gt;&lt;p&gt;第二步的 NAPI 后面会详细说明，这里先重点关注启动过程中对内存的分配。网卡在收到数据时，都必须把数据从链路层拷贝到机器的内存里，而这块内存就是网卡在启动时，通过接口向内核、向操作系统申请而来的。内存一旦申请下来，地址确定之后，后续网卡在收到数据的时候，就可以直接通过 DMA 的机制，直接把数据包传送到内存固定的地址中去，甚至不需要 CPU 的参与。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-92836b80b7002489b2cc8e9b2001aabb_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;601&quot; data-rawheight=&quot;423&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-92836b80b7002489b2cc8e9b2001aabb_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;601&quot; data-rawheight=&quot;423&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-92836b80b7002489b2cc8e9b2001aabb_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-92836b80b7002489b2cc8e9b2001aabb_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;到队列内存的分配可以看下上图，很早之前的网卡都是单队列的机制，但现代的网卡大多都是多队列的。好处就是机器网卡的数据接收可以被负载均衡到多个 CPU 上，因此会提供多个队列，这里先有个概念后面会详细说明。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2b6298f60c2e08d3b9e0f3011a8e2911_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;752&quot; data-rawheight=&quot;536&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-2b6298f60c2e08d3b9e0f3011a8e2911_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;752&quot; data-rawheight=&quot;536&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-2b6298f60c2e08d3b9e0f3011a8e2911_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-2b6298f60c2e08d3b9e0f3011a8e2911_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;下面来详细介绍启动过程中的第二步 NAPI，这是现代网络数据包处理框架中非常重要的一个扩展。之所以现在能支持10G、20G、25G等非常高速的网卡，NAPI 机制起到了非常大的作用。当然 NAPI 并不复杂，其核心就两点：中断、轮循。一般来说，网卡在接收数据时肯定是收一个包，产生一个中断，然后在中断处理函数的时候将包处理掉。处在收包、处理中断，下一个收包，再处理中断，这样的循环中。而 NAPI 机制优势在于只需要一次中断，收到之后就可以通过轮循的方式，把队列内存中所有的数据都拿走，达到非常高效的状态。&lt;/p&gt;&lt;p&gt;&lt;b&gt;网卡驱动-监控&lt;/b&gt;&lt;/p&gt;&lt;p&gt;接下来就是在驱动这层可以做的监控了，需要去关注其中一些数据的来源。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;$ sudo ethtool -S eth0
NIC statistics:
     rx_packets: 597028087
     tx_packets: 5924278060
     rx_bytes: 112643393747
     tx_bytes: 990080156714
     rx_broadcast: 96
     tx_broadcast: 116
     rx_multicast:20294528
     .... &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;首先非常重要的是ethool 工具，它可以拿到网卡中统计的数据、接收的包数量、处理的流量等等常规的信息，而我们更多的是需要关注到异常信息。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;$ cat /sys/class/net/eth0/statistics/rx_dropped
2&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过 sysfs 的接口，可以看到网卡的丢包数，这就是系统出现异常的一个标志。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-4b742b0dcda2b39a2e0443c7626e4ee8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1097&quot; data-rawheight=&quot;163&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-4b742b0dcda2b39a2e0443c7626e4ee8_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1097&quot; data-rawheight=&quot;163&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-4b742b0dcda2b39a2e0443c7626e4ee8_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-4b742b0dcda2b39a2e0443c7626e4ee8_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;三个途径拿到的信息与前面差不多，只是格式有些乱，仅做了解即可。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-14f2ef2437cddbb2823e26b8381324e9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1213&quot; data-rawheight=&quot;624&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-14f2ef2437cddbb2823e26b8381324e9_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1213&quot; data-rawheight=&quot;624&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-14f2ef2437cddbb2823e26b8381324e9_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-14f2ef2437cddbb2823e26b8381324e9_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;上图是要分享的一个线上案例。当时业务上出现异常，经过排查最后是怀疑到网卡这层，为此需要做进一步的分析。通过 ifconfig 工具可以很直观的查看到网卡的一些统计数据，图中可以看到网卡的 errors 数据指标非常高，明显出现了问题。但更有意思的一点是， errors 右边最后的 frame 指标数值跟它完全相同。因为 errors 指标是网卡中很多错误累加之后的指标，与它相邻的 dropped、overruns 这俩个指标都是零，也就是说在当时的状态下，网卡的错误大部分来自 frame。&lt;/p&gt;&lt;p&gt;当然这只是瞬时的状态，上图中下面部分是监控数据，可以明显看到波动的变化，确实是某一台机器异常了。frame 错误一般是在网卡收到数据包，进行 RCR 校验时失败导致的。当收到数据包，会对该包中的内容做校验，当发现跟已经存下来的校验不匹配，说明包是损坏的，因此会直接将其丢掉。&lt;/p&gt;&lt;p&gt;这个原因是比较好分析的，两点一线，机器的网卡通过网线接到上联交换机。当这里出现问题，不是网线就是机器本身的网卡问题，或者是对端交换机的端口，也就是上联交换机端口出现问题。当然按第一优先级去分析，协调运维去更换了机器对应的网线，后面的指标情况也反映出了效果，指标直接突降直到完全消失，错误也就不复存在了，对应上层的业务也很快恢复了正常。&lt;/p&gt;&lt;p&gt;&lt;b&gt;网卡驱动-调优&lt;/b&gt;&lt;/p&gt;&lt;p&gt;说完监控之后来看下最后的调优。在这个层面能调整的东西不多，主要是针对网卡多队列的调整，比较直观。调整队列数目、大小，各队列间的权重，甚至是调整哈希的字段，都是可以的。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;$ sudo ethtool -l eth0
Channel parameters for eth0:
Pre-set maximums:
RX:   0
TX:   0
Other:    0
Combined: 8
Current hardware settings:
RX:   0
TX:   0
Other:    0
Combined: 4&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上图是针对多队列的调整。为了说明刚才的概念，举个例子，比如有个 web server 绑定到了 CPU2，而机器有多个 CPU，这个机器的网卡也是多队列的，其中某个队列会被 CPU2 处理。这个时候就会有一个问题，因为网卡有多个队列，所以 80 端口的流量只会被分配到其中一个队列上去。假如这个队列不是由 CPU2 处理的，就会涉及到一些数据的腾挪。底层把数据接收上来后再交给应用层的时候，需要把这个数据移动一下。如果本来在 CPU1 处理的，需要挪到 CPU2 去，这时会涉及到 CPU cache 的失效，这对高速运转的 CPU 来说是代价很高的操作。&lt;/p&gt;&lt;p&gt;那么该怎么做呢？我们可以通过前面提到的工具，特意把 80 端口 tcp 数据流量导向到对应 CPU2 处理的网卡队列。这么做的效果是数据包从到达网卡开始，到内核处理完再到送达应用层，都是同一个 CPU。这样最大的好处就是缓存，CPU 的 cache 始终是热的，如此整体下来，它的延迟、效果也会非常好。当然这个例子并不实际，主要是为了说明能做到的一个效果。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;内核网络子系统&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;说完了整个网卡驱动部分，接下来是讲解内核子系统部分，这块会分为软中断与网络子系统初始化两部分来分享。&lt;/p&gt;&lt;p&gt;&lt;b&gt;软中断&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-5d12edfde7eaff899116de9a1d3df3c3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;912&quot; data-rawheight=&quot;362&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-5d12edfde7eaff899116de9a1d3df3c3_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;912&quot; data-rawheight=&quot;362&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-5d12edfde7eaff899116de9a1d3df3c3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-5d12edfde7eaff899116de9a1d3df3c3_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;上图的 NETDEV 是 linux 网络子系统每年都会开的一个分会，其中比较有意思的点是每年大会举办的届数会以一个特殊字符来表示。图中是办到了 0X15 届，想必也都发现这是 16 进制的数字，0X15 刚好就是 21 年，也是比较极客范。对网络子系统感兴趣的可以去关注一下。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-45b823a5f80ba9a8297ddc490ab1d3ea_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;823&quot; data-rawheight=&quot;638&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-45b823a5f80ba9a8297ddc490ab1d3ea_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;823&quot; data-rawheight=&quot;638&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-45b823a5f80ba9a8297ddc490ab1d3ea_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-45b823a5f80ba9a8297ddc490ab1d3ea_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;言归正传，内核延时任务有多种机制，而软中断只是其中一种。上图是 linux 的基本结构，上层是用户态，中间是内核，下层是硬件，很抽象的一个分层。用户态和内核态之间会有两种交互的方式：通过系统调用，或者通过异常可以陷入到内核态里面。那底层的硬件跟内核又是怎么交互的呢？答案是中断，硬件跟内核交互的时候必须通过中断，处理任何事件都需要产生一个中断信号来告知 CPU 与内核。&lt;/p&gt;&lt;p&gt;不过这样的机制一般情况下也许没有问题，但是对网络数据来说，一个数据报一个中断，这样会有很明显的两个问题。&lt;/p&gt;&lt;p&gt;&lt;b&gt;问题一：中断在处理期间，会屏蔽之前的中断信号。当一个中断处理的时间很长，在处理期间收到的中断信号都会丢掉。&lt;/b&gt;如果处理一个包用了十秒，在这十秒期间又收到了五个数据包，但因为中断信号丢了，即便前面的处理完了，后面的数据包也不会再处理了。对应到 tcp 这边，假如客户端给服务端发了一个数据包，几秒后处理完了，但在处理期间客户端又发了后续的三个包，但是服务端后面并不知道，以为只收到了一个包，这时客户端又在等待服务端的回包，如此会导致两边都卡住了，也说明了信号丢失是一个极其严重的问题。&lt;/p&gt;&lt;p&gt;&lt;b&gt;问题二：一个数据包触发一次中断处理的话，当有大量的数据包到来后，就会产生非常大量的中断。&lt;/b&gt;如果达到了 10 万、50 万、甚至百万的 pps，那 CPU 就需要处理大量的网络中断，也就不用干其他事情了。&lt;/p&gt;&lt;p&gt;&lt;b&gt;而针对以上两点问题的解决方法就是让中断处理尽可能的短。&lt;/b&gt;具体来说，不能在中断处理函数，只能把它揪出来，交到软中断机制里。这样之后的实际结果是硬件的中断处理做的事情就很少了，将接收数据等一些必须的事情交到软中断去完成，这也是软中断存在的意义。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;static struct smp_hotplug_thread softirq_threads = {
  .store              = &amp;amp;ksoftirqd,
  .thread_should_run  = ksoftirqd_should_run,
  .thread_fn          = run_ksoftirqd,
  .thread-comm        = “ksoftirqd/%u”,
};

static _init int spawn_ksoftirqd(void)
{
  regiter_cpu_notifier(&amp;amp;cpu_nfb);
  
  BUG_ON(smpboot_register_percpu_thread(&amp;amp;softirq_threads));

  return 0;
}
early_initcall(spawn_ksoftirqd);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;软中断机制是通过内核的线程来实现的。图中是对应的一个内核线程。服务器 CPU 都会有一个 ksoftirqd 这样的内核线程，多 CPU 的机器会相对应的有多个线程。图中结构体最后一个成员 ksoftirqd/，如果有三个 CPU 对应就会有 /0/1/2 三个内核线程。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e69ad0277289d40e2598ef63d7a79091_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1035&quot; data-rawheight=&quot;490&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-e69ad0277289d40e2598ef63d7a79091_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1035&quot; data-rawheight=&quot;490&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-e69ad0277289d40e2598ef63d7a79091_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-e69ad0277289d40e2598ef63d7a79091_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;软中断机制的信息在 softirqs 下面可以看到。软中断并不多只有几种，其中需要关注的，跟网络相关的就是 NET-TX 和 NET-RX，网络数据收发的两种场景。&lt;/p&gt;&lt;p&gt;&lt;b&gt;内核初始化&lt;/b&gt;&lt;/p&gt;&lt;p&gt;铺垫完软中断之后，下面来看内核初始化的流程。主要为两步：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;针对每个 CPU，创建一个数据结构，这上面挂了非常多的成员，与后面的处理密切相关；&lt;/li&gt;&lt;li&gt;注册一个软中断处理函数，对应上面看到的 NET-TX 和 NET-RX 这两个软中断的处理函数。&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-14f3a0f0efddba26ebf4d0b056dee11d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;885&quot; data-rawheight=&quot;626&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-14f3a0f0efddba26ebf4d0b056dee11d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;885&quot; data-rawheight=&quot;626&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-14f3a0f0efddba26ebf4d0b056dee11d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-14f3a0f0efddba26ebf4d0b056dee11d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;上图是手绘的一个数据包的处理流程：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;第一步网卡收到了数据包；&lt;/li&gt;&lt;li&gt;第二步把数据包通过 DMA 拷到了内存里面；&lt;/li&gt;&lt;li&gt;第三步产生了一个中断告诉 CPU 并开始处理中断。重点的中断处理可分为两步：一是将中断信号屏蔽了，二是唤醒 NAPI 机制。&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;static irqreturn_t igb_msix_ring(int irq, void *data)
{
  struct igb_q_vector *q_vector = data;
  
  /* Write the ITR value calculated from the previous interrupt. */
  igb_write_itr(q_vector);
  
  napi_schedule(&amp;amp;q_vector-&amp;gt;napi);
  
  return IRO_HANDLED;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面的代码是 igb 网卡驱动中断处理函数做的事情。如果省略掉开始的变量声明和后面的返回，这个中断处理函数只有两行代码，非常短。需要关注的是第二个，在硬件中断处理函数中，只用激活外部 NIPA 软中断处理机制，无需做其他任何事情。因此这个中断处理函数会返回的非常快。&lt;/p&gt;&lt;p&gt;&lt;b&gt;NIPI 激活&lt;/b&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;/* Called with irq disabled */
static inline void ____napi_schedule(struct softnet_data *sd, struct napi_struct *napi)
{
  list_add_tail(&amp;amp;napi-&amp;gt;poll_list, &amp;amp;sd-&amp;gt;poll_list);
  _raise_softirq_irqoff(NET_RX_SOFTIRQ);
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;NIPI 的激活也很简单，主要为两步。内核网络系统在初始化的时每个 CPU 都会有一个结构体，它会把队列对应的信息插入到结构体的链表里。换句话说，每个网卡队列在收到数据的时候，需要把自己的队列信息告诉对应的 CPU，将这两个信息绑定起来，保证某个 CPU 处理某个队列。&lt;/p&gt;&lt;p&gt;除此之外，还要与触发硬中断一样，需要触发软中断。下图将很多步骤放到了一块，前面讲过的就不再赘述了。图中要关注的是软中断是怎么触发的。与硬中断差不多，软中断也有中断的向量表。每个中断号，都会对应一个处理函数，当需要处理某个中断，只需要在对应的中断向量表里找就好了，跟硬中断的处理是一模一样的。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2abc67a748c4bc68d58cc530d1580fa2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1200&quot; data-rawheight=&quot;806&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-2abc67a748c4bc68d58cc530d1580fa2_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1200&quot; data-rawheight=&quot;806&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-2abc67a748c4bc68d58cc530d1580fa2_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-2abc67a748c4bc68d58cc530d1580fa2_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;数据接收-监控&lt;/b&gt;&lt;/p&gt;&lt;p&gt;说完了运作机制，再来看看有哪些地方可以做监控。在 proc 下面有很多东西，可以看到中断的处理情况。第一列就是中断号，每个设备都有独立的中断号，这是写死的。对网络来说只需要关注网卡对应的中断号，图中是 65、66、67、68 等。当然看实际的数字并没有意义，而是需要看它的分布情况，中断是不是被不同 CPU 在处理，如果所有的中断都是被一个 CPU 处理，那么就需要做些调整，把它分散开。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1ed00a346e9f9b1cb9256e2e9ccd5326_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1092&quot; data-rawheight=&quot;398&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-1ed00a346e9f9b1cb9256e2e9ccd5326_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1092&quot; data-rawheight=&quot;398&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-1ed00a346e9f9b1cb9256e2e9ccd5326_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-1ed00a346e9f9b1cb9256e2e9ccd5326_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;数据接收-调优&lt;/b&gt;&lt;/p&gt;&lt;p&gt;中断可以做的调整有两个：一是中断合并，二是中断亲和性。&lt;/p&gt;&lt;p&gt;&lt;b&gt;自适应中断合并&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;rx-usecs：&lt;/b&gt;数据帧到达后，延迟多长时间产生中断信号，单位微秒&lt;/li&gt;&lt;li&gt;&lt;b&gt;rx-frames：&lt;/b&gt;触发中断前积累数据帧的最大个数&lt;/li&gt;&lt;li&gt;&lt;b&gt;rx-usecs-irq：&lt;/b&gt;如果有中断处理正在执行，当前中断延迟多久送达 &lt;b&gt;CPU&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;rx-frames-irq：&lt;/b&gt;如果有中断处理正在执行，最多积累多少个数据帧&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;上面列的都是硬件网卡支持的功能。NAPI 本质上也是中断合并的机制，假如有很多包的到来，NAPI 就可以做到只产生一个中断，因此不需要硬件来帮助做中断合并，实际效果是跟 NAPI 是相同的，都是减少了总的中断数量。&lt;/p&gt;&lt;p&gt;&lt;b&gt;中断亲和性&lt;/b&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;$ sudo bash -c ‘echo 1 &amp;gt; /proc/irq/8/smp_affinity’&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个与网卡多队列是密切相关的。如果网卡有多个队列，就能手动来明确指定由哪个 CPU 来处理，均衡的把数据处理的负载分散到机器的可用 CPU 上。配置也比较简单，只需把数字写入到 /proc 对应的这个文件中就可以了。这是个位数组，转成二进制后就会有对应的 CPU 去处理。如果写个 1，可能就是 CPU0 来处理；如果写个 4，转化成二进制是 100，那么就会交给 CPU2 去处理。&lt;/p&gt;&lt;p&gt;另外有个小问题需要注意，很多发行版可能会自带一个 irqbalance 的守护进程（&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//irqbalance.github.io/irqbalance&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;irqbalance.github.io/ir&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;qbalance&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt;），会将手动中断均衡的设置给覆盖掉。这个程序做的核心事情就是把上面手动设置文件的操作放到程序里，有兴趣可以去看下它的代码（&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Irqbalance/irqbalance/blob/master/activate.c&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/Irqbalance/i&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;rqbalance/blob/master/activate.c&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt;），也是把这个文件打开，写对应的数字进去就可以了。 &lt;/p&gt;&lt;p&gt;&lt;b&gt;内核-数据处理&lt;/b&gt;&lt;/p&gt;&lt;p&gt;最后是数据处理部分了。当数据到达网卡，进入队列内存后，就需要内核从队列内存中将数据拉出来。如果机器的 PPS 达到了十万甚至百万，而 CPU 只处理网络数据的话，那其他基本的业务逻辑也就不用干了，因此不能让数据包的处理独占整个 CPU，而核心点是怎么去做限制。&lt;/p&gt;&lt;p&gt;针对上述问题主要有两方面的限制：整体的限制和单次的限制&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;while (!list_empty(&amp;amp;sd-&amp;gt;poll_list)){
  struct napi_struct *n;
  int work,weight;
  
  /* If softirq window is exhausted then punt.
   * Allow this to run for 2 jiffies since which will allow
   * an average latency of 1.5/HZ.
   */
   if (unlikely(budget &amp;lt;= 0 || time_after_eq(jiffies, time_limit)))
   goto softnet_break;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;整体限制很好理解，就是一个 CPU 对应一个队列。如果 CPU 的数量比队列数量少，那么一个 CPU 可能需要处理多个队列。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;weight = n-&amp;gt;weight;

work = 0;
if (test_bit(NAPI_STATE_SCHED, &amp;amp;n-&amp;gt;state)) {
        work = n-&amp;gt;poll(n,weight);
        trace_napi_poll(n);
}

WARN_ON_ONCE(work &amp;gt; weight);

budget -= work;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;单次限制则是限制一个队列在一轮里处理包的数量。达到限制之后就停下来，等待下一轮的处理。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;softnet_break:
  sd-&amp;gt;time_squeeze++;
  _raise_softirq_irqoff(NET_RX_SOFTIRQ);
  goto out;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而停下来就是很关键的节点，幸运的是有对应的指标记录，有 time-squeeze 这样中断的计数，拿到这个信息就可以判断出机器的网络处理是否有瓶颈，被迫中断的频率高低。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-337c4da7806a0ab9d52df871c5864192_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;274&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-337c4da7806a0ab9d52df871c5864192_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;274&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-337c4da7806a0ab9d52df871c5864192_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-337c4da7806a0ab9d52df871c5864192_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;上图是监控 CPU 指标的数据，格式很简单，每行对应一个 CPU，数值之间用空格分割，输出格式为 16 进制。那么每一列数值又代表什么呢？很不幸，这个没有文档，只能通过检查使用的内核版本，然后去看对应的代码。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;seq_printf（seq,
     &quot;%08x %08x %08x %08x %08x %08x %08x %08x %08x %08x %08x\n&quot;,
     sd-&amp;gt;processed, sd-&amp;gt;dropped, sd-&amp;gt;time_squeeze, 0,
     0, 0, 0, 0, /* was fastroute */
     sd-&amp;gt;cpu_collision, sd-&amp;gt;received_rps, flow_limit_count）;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;下面说明了文件中每个字段都是怎么来的，实际情况可能会有所不同，因为随着内核版本的迭代，字段的数量以及字段的顺序都有可能发生变化，其中与网络数据处理被中断次数相关的就是 squeeze 字段：&lt;/p&gt;&lt;ul&gt;&lt;li&gt; * sd-&amp;gt;processed          处理的包数量（多网卡 bond 模式可能多于实际的收包数量）&lt;/li&gt;&lt;li&gt; * sd-&amp;gt;dropped             丢包数量，因为队列满了&lt;/li&gt;&lt;li&gt; * sd-&amp;gt;time_spueeze      软中断处理 net_rx_action 被迫打断的次数&lt;/li&gt;&lt;li&gt; * sd-&amp;gt;cpu_collision       发送数据时获取设备锁冲突，比如多个 CPU 同时发送数据&lt;/li&gt;&lt;li&gt; * sd-&amp;gt;received_rps       当前 CPU 被唤醒的次数（通过处理器间中断）&lt;/li&gt;&lt;li&gt;* sd-&amp;gt;flow_limit_count    触发 flow limit 的次数&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;下图是业务中遇到相关问题的案例，最后排查到 CPU 层面。图一是 TOP 命令的输出，显示了每个 CPU 的使用量，其中红框标出的 CPU4 的使用率存在着异常，尤其是倒数第二列的 SI 占用达到了 89%。SI 是 softirq 的缩写，表示 CPU 花在软中断处理上的时间占比，而图中 CPU4 在时间占比上明显过高。图二则是对应图一的输出结果，CPU4 对应的是第五行，其中第三列数值明显高于其他 CPU，表明它在处理网络数据的时被频繁的打断。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d8ef117a14c9bb6073d240208e509e34_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;668&quot; data-rawheight=&quot;657&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-d8ef117a14c9bb6073d240208e509e34_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;668&quot; data-rawheight=&quot;657&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-d8ef117a14c9bb6073d240208e509e34_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-d8ef117a14c9bb6073d240208e509e34_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-73e2e677a8473fce69ad4a8a36cdce71_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;804&quot; data-rawheight=&quot;638&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-73e2e677a8473fce69ad4a8a36cdce71_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;804&quot; data-rawheight=&quot;638&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-73e2e677a8473fce69ad4a8a36cdce71_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-73e2e677a8473fce69ad4a8a36cdce71_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;针对上面的问题推断 CPU4 存在一定的性能衰退，也许是质量不过关或其他的原因。为了验证是否是性能衰退，写了一个简单的 python 脚本，一个一直去累加的死循环。每次运行时，把这段脚本绑定到某个 CPU 上，然后观察不同 CPU 耗时的对比。最后对比结果也显示 CPU4 的耗时比其他的 CPU 高了几倍，也验证了之前的推断。之后协调运维更换了 CPU，意向指标也就恢复正常了。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;以上所有操作都只是在数据包从网卡到了内核层，还没到常见的协议，只是完成了万里长征第一步，后面还有一系列的步骤，例如数据包的压缩（GRO）、网卡多队列软件（RPS）还有 RFS 在负载均衡的基础上考虑流的特征，就是 IP 端口四元组的特征，最后才是把数据递交到 IP 层，以及到熟悉的 TCP 层。&lt;/p&gt;&lt;p&gt;总的来说，今天的分享都是围绕驱动来做的，我想强调的性能优化的核心点在于指标，不能测量也就很难去改善，要有指标的存在，这样一切的优化才有意义。&lt;/p&gt;&lt;p&gt;&lt;b&gt;现场视频、PPT请戳：&lt;/b&gt;&lt;/p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.upyun.com/opentalk/461.html&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic4.zhimg.com/v2-dbe7f56d0bf38ef5c8e35ae759458897_180x120.jpg&quot; data-image-width=&quot;960&quot; data-image-height=&quot;540&quot; data-text=&quot;性能优化 - 如何更快的收发数据&quot; class=&quot;LinkCard new&quot;&gt;&lt;span class=&quot;LinkCard-contents&quot;&gt;&lt;span class=&quot;LinkCard-title loading&quot; data-text=&quot;true&quot;/&gt;&lt;span class=&quot;LinkCard-desc loading&quot;/&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-image LinkCard-image--default&quot;/&gt;&lt;/a&gt;&lt;p/&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>16c749e7d45c2e73cf64cf775386b9e7</guid>
<title>Redis 核心原理与实践：Redis启动过程源码分析</title>
<link>https://toutiao.io/k/tiiu7yc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;Redis服务器负责接收处理用户请求，为用户提供服务。&lt;br/&gt;Redis服务器的启动命令格式如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;redis-server&lt;/span&gt; &lt;span&gt;[ configfile ]&lt;/span&gt; &lt;span&gt;[ options ]&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;configfile参数指定配置文件。options参数指定启动配置项，它可以覆盖配置文件中的配置项，如&lt;/p&gt;&lt;pre&gt;&lt;code&gt;redis-server /&lt;span&gt;path&lt;/span&gt;/to/redis.conf &lt;span&gt;--port 7777 --protected-mode no&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该命令启动Redis服务，并指定了配置文件/path/to/redis.conf，给出了两个启动配置项：port、protected-mode。&lt;/p&gt;&lt;p&gt;本文通过阅读Redis源码，分析Redis启动过程，内容摘自新书《Redis核心原理与实践》。&lt;br/&gt;本文涉及Redis的很多概念，如事件循环器、ACL、Module、LUA、慢日志等，这些功能在作者新书《Redis核心原理与实践》做了详尽分析，感兴趣的读者可以参考本书。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;服务器定义&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;提示：本章代码如无特殊说明，均在server.h、server.c中。&lt;/p&gt;&lt;p&gt;Redis中定义了server.h/redisServer结构体，存储Redis服务器信息，包括服务器配置项和运行时数据（如网络连接信息、数据库redisDb、命令表、客户端信息、从服务器信息、统计信息等数据）。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;redisServer&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;pid_t&lt;/span&gt; pid;                  &lt;br/&gt;    &lt;span&gt;pthread_t&lt;/span&gt; main_thread_id;         &lt;br/&gt;    &lt;span&gt;char&lt;/span&gt; *configfile;           &lt;br/&gt;    &lt;span&gt;char&lt;/span&gt; *executable;           &lt;br/&gt;    &lt;span&gt;char&lt;/span&gt; **exec_argv;    &lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;redisServer中的属性很多，这里不一一列举，等到分析具体功能时再说明相关的server属性。&lt;br/&gt;server.h中定义了一个redisServer全局变量：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;extern&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;redisServer&lt;/span&gt; &lt;span&gt;server&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;本书说到的server变量，如无特殊说明，都是指该redisServer全局变量。例如，第1部分说过server.list_max_ziplist_size等属性，正是指该变量的属性。&lt;br/&gt;可以使用INFO命令获取服务器的信息，该命令主要返回以下信息：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;server：有关Redis服务器的常规信息。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;clients：客户端连接信息。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;memory：内存消耗相关信息。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;persistence：RDB和AOF持久化信息。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;stats：常规统计信息。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;replication：主/副本复制信息。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;cpu：CPU消耗信息。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;commandstats：Redis 命令统计信息。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;cluster：Redis Cluster集群信息。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;modules：Modules模块信息。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;keyspace：数据库相关的统计信息。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;errorstats：Redis错误统计信息。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;INFO命令响应内容中除了memory和cpu等统计数据，其他数据大部分都保存在redisServer中。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;main函数&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;server.c/main函数负责启动Redis服务：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; **argv)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;    &lt;span&gt;// [1]&lt;/span&gt;&lt;br/&gt;    server.sentinel_mode = checkForSentinelMode(argc,argv);&lt;br/&gt;    &lt;span&gt;// [2]&lt;/span&gt;&lt;br/&gt;    initServerConfig();&lt;br/&gt;    ACLInit(); &lt;br/&gt;&lt;br/&gt;    moduleInitModulesSystem();&lt;br/&gt;    tlsInit();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// [3]&lt;/span&gt;&lt;br/&gt;    server.executable = getAbsolutePath(argv[&lt;span&gt;0&lt;/span&gt;]);&lt;br/&gt;    server.exec_argv = zmalloc(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;char&lt;/span&gt;*)*(argc+&lt;span&gt;1&lt;/span&gt;));&lt;br/&gt;    server.exec_argv[argc] = &lt;span&gt;NULL&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; argc; j++) server.exec_argv[j] = zstrdup(argv[j]);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// [4]&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (server.sentinel_mode) {&lt;br/&gt;        initSentinelConfig();&lt;br/&gt;        initSentinel();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// [5]&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;strstr&lt;/span&gt;(argv[&lt;span&gt;0&lt;/span&gt;],&lt;span&gt;&quot;redis-check-rdb&quot;&lt;/span&gt;) != &lt;span&gt;NULL&lt;/span&gt;)&lt;br/&gt;        redis_check_rdb_main(argc,argv,&lt;span&gt;NULL&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;strstr&lt;/span&gt;(argv[&lt;span&gt;0&lt;/span&gt;],&lt;span&gt;&quot;redis-check-aof&quot;&lt;/span&gt;) != &lt;span&gt;NULL&lt;/span&gt;)&lt;br/&gt;        redis_check_aof_main(argc,argv);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// more&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;【1】检查该Redis服务器是否以sentinel模式启动。&lt;br/&gt;【2】initServerConfig函数将redisServer中记录配置项的属性初始化为默认值。ACLInit函数初始化ACL机制，moduleInitModulesSystem函数初始化Module机制。&lt;br/&gt;【3】记录Redis程序可执行路径及启动参数，以便后续重启服务器。&lt;br/&gt;【4】如果以Sentinel模式启动，则初始化Sentinel机制。&lt;br/&gt;【5】如果启动程序是redis-check-rdb或redis-check-aof，则执行redis_check_rdb_main或redis_check_aof_main函数，它们尝试检验并修复RDB、AOF文件后便退出程序。&lt;br/&gt;Redis编译完成后，会生成5个可执行程序：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;redis-server：Redis执行程序。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;redis-sentinel：Redis Sentinel执行程序。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;redis-cli：Redis客户端程序。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;redis-benchmark：Redis性能压测工具。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;redis-check-aof、redis-check-rdb：用于检验和修复RDB、AOF持久化文件的工具。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;继续分析main函数：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; **argv)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (argc &amp;gt;= &lt;span&gt;2&lt;/span&gt;) {&lt;br/&gt;        j = &lt;span&gt;1&lt;/span&gt;; &lt;br/&gt;        sds options = sdsempty();&lt;br/&gt;        &lt;span&gt;char&lt;/span&gt; *configfile = &lt;span&gt;NULL&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// [6]&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;strcmp&lt;/span&gt;(argv[&lt;span&gt;1&lt;/span&gt;], &lt;span&gt;&quot;-v&quot;&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt; ||&lt;br/&gt;            &lt;span&gt;strcmp&lt;/span&gt;(argv[&lt;span&gt;1&lt;/span&gt;], &lt;span&gt;&quot;--version&quot;&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt;) version();&lt;br/&gt;        ...&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// [7]&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (argv[j][&lt;span&gt;0&lt;/span&gt;] != &lt;span&gt;&#x27;-&#x27;&lt;/span&gt; || argv[j][&lt;span&gt;1&lt;/span&gt;] != &lt;span&gt;&#x27;-&#x27;&lt;/span&gt;) {&lt;br/&gt;            configfile = argv[j];&lt;br/&gt;            server.configfile = getAbsolutePath(configfile);&lt;br/&gt;            zfree(server.exec_argv[j]);&lt;br/&gt;            server.exec_argv[j] = zstrdup(server.configfile);&lt;br/&gt;            j++;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;       &lt;span&gt;// [8]&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt;(j != argc) {&lt;br/&gt;            ...&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;// [9]&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (server.sentinel_mode &amp;amp;&amp;amp; configfile &amp;amp;&amp;amp; *configfile == &lt;span&gt;&#x27;-&#x27;&lt;/span&gt;) {&lt;br/&gt;            ...&lt;br/&gt;            &lt;span&gt;exit&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;// [10]&lt;/span&gt;&lt;br/&gt;        resetServerSaveParams();&lt;br/&gt;        loadServerConfig(configfile,options);&lt;br/&gt;        sdsfree(options);&lt;br/&gt;    }&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;【6】对-v、--version、--help、-h、--test-memory等命令进行优先处理。&lt;br/&gt;strcmp函数比较两个字符串str1、str2，若str1=str2，则返回零；若str1&lt;str2/&gt;&amp;lt;/str2，则返回负数；若str1&amp;gt;&amp;lt;/str2，则返回负数；若str1&amp;gt;str2，则返回正数。&lt;br/&gt;【7】如果启动命令的第二个参数不是以“--”开始的，则是配置文件参数，将配置文件路径转化为绝对路径，存入server.configfile中。&lt;br/&gt;【8】读取启动命令中的启动配置项，并将它们拼接到一个字符串中。&lt;br/&gt;【9】以Sentinel模式启动，必须指定配置文件，否则直接报错退出。&lt;br/&gt;【10】config.c/resetServerSaveParams函数重置server.saveparams属性（该属性存放RDB SAVE配置）。config.c/loadServerConfig函数从配置文件中加载所有配置项，并使用启动命令配置项覆盖配置文件中的配置项。&amp;lt;/str2，则返回负数；若str1&amp;gt;&lt;/p&gt;&lt;p&gt;提示：config.c中的configs数组定义了大多数配置选项与server属性的对应关系：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;standardConfig configs[] = {&lt;br/&gt;    createBoolConfig(&lt;span&gt;&quot;rdbchecksum&quot;&lt;/span&gt;, &lt;span&gt;NULL&lt;/span&gt;, IMMUTABLE_CONFIG, server.rdb_checksum, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;NULL&lt;/span&gt;, &lt;span&gt;NULL&lt;/span&gt;),&lt;br/&gt;    createBoolConfig(&lt;span&gt;&quot;daemonize&quot;&lt;/span&gt;, &lt;span&gt;NULL&lt;/span&gt;, IMMUTABLE_CONFIG, server.daemonize, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;NULL&lt;/span&gt;, &lt;span&gt;NULL&lt;/span&gt;),&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;配置项rdbchecksum对应server.rdb_checksum属性，默认值为1（即bool值yes），其他配置项以此类推。如果读者需要查找配置项对应的server属性和默认值，则可以从中查找。&lt;/p&gt;&lt;p&gt;下面继续分析main函数：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; **argv)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;    &lt;span&gt;// [11]    &lt;/span&gt;&lt;br/&gt;    server.supervised = redisIsSupervised(server.supervised_mode);&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; background = server.daemonize &amp;amp;&amp;amp; !server.supervised;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (background) daemonize();&lt;br/&gt;    &lt;span&gt;// [12]&lt;/span&gt;&lt;br/&gt;    serverLog(LL_WARNING, &lt;span&gt;&quot;oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo&quot;&lt;/span&gt;);&lt;br/&gt;    ...&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// [13]&lt;/span&gt;&lt;br/&gt;    initServer();&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (background || server.pidfile) createPidFile();&lt;br/&gt;    ...&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!server.sentinel_mode) {&lt;br/&gt;        ...&lt;br/&gt;        &lt;span&gt;// [14]&lt;/span&gt;&lt;br/&gt;        moduleLoadFromQueue();&lt;br/&gt;        ACLLoadUsersAtStartup();&lt;br/&gt;        InitServerLast();&lt;br/&gt;        loadDataFromDisk();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (server.cluster_enabled) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (verifyClusterConfigWithData() == C_ERR) {&lt;br/&gt;                ...&lt;br/&gt;                &lt;span&gt;exit&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        ...&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// [15]&lt;/span&gt;&lt;br/&gt;        InitServerLast();&lt;br/&gt;        sentinelIsRunning();&lt;br/&gt;        ...&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    ...&lt;br/&gt;    &lt;span&gt;// [16]&lt;/span&gt;&lt;br/&gt;    redisSetCpuAffinity(server.server_cpulist);&lt;br/&gt;    setOOMScoreAdj(&lt;span&gt;-1&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;// [17]&lt;/span&gt;&lt;br/&gt;    aeMain(server.el);&lt;br/&gt;    &lt;span&gt;// [18]&lt;/span&gt;&lt;br/&gt;    aeDeleteEventLoop(server.el);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;【11】server.supervised属性指定是否以upstart服务或systemd服务启动Redis。如果配置了server.daemonize且没有配置server.supervised，则以守护进程的方式启动Redis。&lt;br/&gt;【12】打印启动日志。&lt;br/&gt;【13】initServer函数初始化Redis运行时数据，createPidFile函数创建pid文件。&lt;br/&gt;【14】如果非Sentinel模式启动，则完成以下操作：&lt;br/&gt;（1）moduleLoadFromQueue函数加载配置文件指定的Module模块；&lt;br/&gt;（2）ACLLoadUsersAtStartup函数加载ACL用户控制列表；&lt;br/&gt;（3）InitServerLast函数负责创建后台线程、I/O线程，该步骤需在Module模块加载后再执行；&lt;br/&gt;（4）loadDataFromDisk函数从磁盘中加载AOF或RDB文件。&lt;br/&gt;（5）如果以Cluster模式启动，那么还需要验证加载的数据是否正确。&lt;br/&gt;【15】如果以Sentinel模式启动，则调用sentinelIsRunning函数启动Sentinel机制。&lt;br/&gt;【16】尽可能将Redis主线程绑定到server.server_cpulist配置的CPU列表上，Redis 4开始使用多线程，该操作可以减少不必要的线程切换，提高性能。&lt;br/&gt;【17】启动事件循环器。事件循环器是Redis中的重要组件。在Redis运行期间，由事件循环器提供服务。&lt;br/&gt;【18】执行到这里，说明Redis服务已停止，aeDeleteEventLoop函数清除事件循环器中的事件，最后退出程序。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;Redis初始化过程&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;下面看一下initServer函数，它负责初始化Redis运行时数据：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;initServer&lt;/span&gt;&lt;span&gt;(&lt;span&gt;void&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; j;&lt;br/&gt;    &lt;span&gt;// [1]&lt;/span&gt;&lt;br/&gt;    signal(SIGHUP, SIG_IGN);&lt;br/&gt;    signal(SIGPIPE, SIG_IGN);&lt;br/&gt;    setupSignalHandlers();&lt;br/&gt;    &lt;span&gt;// [2]&lt;/span&gt;&lt;br/&gt;    makeThreadKillable();&lt;br/&gt;    &lt;span&gt;// [3]&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (server.syslog_enabled) {&lt;br/&gt;        openlog(server.syslog_ident, LOG_PID | LOG_NDELAY | LOG_NOWAIT,&lt;br/&gt;            server.syslog_facility);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// [4]&lt;/span&gt;&lt;br/&gt;    server.aof_state = server.aof_enabled ? AOF_ON : AOF_OFF;&lt;br/&gt;    server.hz = server.config_hz;&lt;br/&gt;    server.pid = getpid();&lt;br/&gt;    ...&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// [5]&lt;/span&gt;&lt;br/&gt;    createSharedObjects();&lt;br/&gt;    adjustOpenFilesLimit();&lt;br/&gt;    &lt;span&gt;// [6]&lt;/span&gt;&lt;br/&gt;    server.el = aeCreateEventLoop(server.maxclients+CONFIG_FDSET_INCR);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (server.el == &lt;span&gt;NULL&lt;/span&gt;) {&lt;br/&gt;        ...&lt;br/&gt;        &lt;span&gt;exit&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// more&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;【1】设置UNIX信号处理函数，使Redis服务器收到SIGINT信号后退出程序。&lt;br/&gt;【2】设置线程随时响应CANCEL信号，终止线程，以便停止程序。&lt;br/&gt;【3】如果开启了Unix系统日志，则调用openlog函数与Unix系统日志建立输出连接，以便输出系统日志。&lt;br/&gt;【4】初始化server中负责存储运行时数据的相关属性。&lt;br/&gt;【5】createSharedObjects函数创建共享数据集，这些数据可在各场景中共享使用，如小数字0～9999、常用字符串+OK\r\n（命令处理成功响应字符串）、+PONG\r\n（ping命令响应字符串）。adjustOpenFilesLimit函数尝试修改环境变量，提高系统允许打开的文件描述符上限，避免由于大量客户端连接（Socket文件描述符）导致错误。&lt;br/&gt;【6】创建事件循环器。&lt;br/&gt;UNIX编程：信号也称为软中断，信号是UNIX提供的一种处理异步事件的方法，程序通过设置回调函数告诉系统内核，在信号产生后要做什么操作。系统中很多场景会产生信号，例如：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;用户按下某些终端键，使终端产生信号。例如，用户在终端按下了中断键（一般为Ctrl+C组合键），会发送SIGINT信号通知程序停止运行。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;系统中发生了某些特定事件，例如，当alarm函数设置的定时器超时，内核发送SIGALRM信号，或者一个进程终止时，内核发送SIGCLD信号给其父进程。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;某些硬件异常，例如，除数为0、无效的内存引用。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;程序中使用函数发送信号，例如，调用kill函数将任意信号发送给另一个进程。&lt;br/&gt;感兴趣的读者可以自行深入了解UNIX编程相关内容。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;接着分析initServer函数：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;initServer&lt;/span&gt;&lt;span&gt;(&lt;span&gt;void&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;{    &lt;br/&gt;    server.db = zmalloc(&lt;span&gt;sizeof&lt;/span&gt;(redisDb)*server.dbnum);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// [7]&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (server.port != &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp;&lt;br/&gt;        listenToPort(server.port,server.ipfd,&amp;amp;server.ipfd_count) == C_ERR)&lt;br/&gt;        &lt;span&gt;exit&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    ...&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// [8]&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; server.dbnum; j++) {&lt;br/&gt;        server.db[j].dict = dictCreate(&amp;amp;dbDictType,&lt;span&gt;NULL&lt;/span&gt;);&lt;br/&gt;        server.db[j].expires = dictCreate(&amp;amp;keyptrDictType,&lt;span&gt;NULL&lt;/span&gt;);&lt;br/&gt;        ...&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// [9]&lt;/span&gt;&lt;br/&gt;    evictionPoolAlloc(); &lt;br/&gt;    server.pubsub_channels = dictCreate(&amp;amp;keylistDictType,&lt;span&gt;NULL&lt;/span&gt;);&lt;br/&gt;    server.pubsub_patterns = listCreate();&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;【7】如果配置了server.port，则开启TCP Socket服务，接收用户请求。如果配置了server.tls_ port，则开启TLS Socket服务，Redis 6.0开始支持TLS连接。如果配置了server.unixsocket，则开启UNIX Socket服务。如果上面3个选项都没有配置，则报错退出。&lt;br/&gt;【8】初始化数据库server.db，用于存储数据。&lt;br/&gt;【9】evictionPoolAlloc函数初始化LRU/LFU样本池，用于实现LRU/LFU近似算法。&lt;/p&gt;&lt;p&gt;initServer函数继续初始化server中存储运行时数据的相关属性：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;initServer&lt;/span&gt;&lt;span&gt;(&lt;span&gt;void&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;    &lt;span&gt;// [10]&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (aeCreateTimeEvent(server.el, &lt;span&gt;1&lt;/span&gt;, serverCron, &lt;span&gt;NULL&lt;/span&gt;, &lt;span&gt;NULL&lt;/span&gt;) == AE_ERR) {&lt;br/&gt;        serverPanic(&lt;span&gt;&quot;Can&#x27;t create event loop timers.&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;exit&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// [11]&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; server.ipfd_count; j++) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE,&lt;br/&gt;            acceptTcpHandler,&lt;span&gt;NULL&lt;/span&gt;) == AE_ERR)&lt;br/&gt;            {&lt;br/&gt;                serverPanic(&lt;br/&gt;                    &lt;span&gt;&quot;Unrecoverable error creating server.ipfd file event.&quot;&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;    }&lt;br/&gt;    ...&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// [12]&lt;/span&gt;&lt;br/&gt;    aeSetBeforeSleepProc(server.el,beforeSleep);&lt;br/&gt;    aeSetAfterSleepProc(server.el,afterSleep);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// [13]&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (server.aof_state == AOF_ON) {&lt;br/&gt;        server.aof_fd = open(server.aof_filename,&lt;br/&gt;                               O_WRONLY|O_APPEND|O_CREAT,&lt;span&gt;0644&lt;/span&gt;);&lt;br/&gt;        ...&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// [14]&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (server.arch_bits == &lt;span&gt;32&lt;/span&gt; &amp;amp;&amp;amp; server.maxmemory == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;        ...&lt;br/&gt;        server.maxmemory = &lt;span&gt;3072L&lt;/span&gt;L*(&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;); &lt;span&gt;/* 3 GB */&lt;/span&gt;&lt;br/&gt;        server.maxmemory_policy = MAXMEMORY_NO_EVICTION;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// [15]&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (server.cluster_enabled) clusterInit();&lt;br/&gt;    replicationScriptCacheInit();&lt;br/&gt;    scriptingInit(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    slowlogInit();&lt;br/&gt;    latencyMonitorInit();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;【10】创建一个时间事件，执行函数为serverCron，负责处理Redis中的定时任务，如清理过期数据、生成RDB文件等。&lt;br/&gt;【11】分别为TCP Socket、TSL Socks、UNIX Socket注册监听AE_READABLE类型的文件事件，事件处理函数分别为acceptTcpHandler、acceptTLSHandler、acceptUnixHandler，这些函数负责接收Socket中的新连接，本书后续会详细分析acceptTcpHandler函数。&lt;br/&gt;【12】注册事件循环器的钩子函数，事件循环器在每次阻塞前后都会调用钩子函数。&lt;br/&gt;【13】如果开启了AOF，则预先打开AOF文件。&lt;br/&gt;【14】如果Redis运行在32位操作系统上，由于32位操作系统内存空间限制为4GB，所以将Redis使用内存限制为3GB，避免Redis服务器因内存不足而崩溃。&lt;br/&gt;【15】如果以Cluster模式启动，则调用clusterInit函数初始化Cluster机制。&lt;/p&gt;&lt;p&gt;总结：&lt;/p&gt;&lt;p&gt;文章最后，介绍一下新书《Redis核心原理与实践》，本书通过深入分析Redis 6.0源码，总结了Redis核心功能的设计与实现。通过阅读本书，读者可以深入理解Redis内部机制及最新特性，并学习到Redis相关的数据结构与算法、Unix编程、存储系统设计，分布式系统架构等一系列知识。&lt;br/&gt;经过该书编辑同意，我会继续在个人技术公众号（binecy）发布书中部分章节内容，作为书的预览内容，欢迎大家查阅，谢谢。&lt;/p&gt;&lt;p&gt;&lt;span&gt;书籍详情：&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MDQzMTU2MA==&amp;amp;mid=2247484112&amp;amp;idx=1&amp;amp;sn=c7d2d153a65a72fb3cd074803c7c2fbc&amp;amp;chksm=ea688977dd1f0061831cae4f5361182603b2e5778cae8aa0fc8f7e92ab75bc08c81afd717e6c&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;新书介绍 -- 《Redis核心原理与实践》&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>