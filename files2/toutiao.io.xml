<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>dc96aefafc706fa7aa3af54dc6cb9278</guid>
<title>ElasticSearch 存储成本省 60%，稿定科技干货分享</title>
<link>https://toutiao.io/k/oy304tv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post_content markdown&quot;&gt;&lt;h1 id=&quot;背景&quot;&gt;背景&lt;/h1&gt;&lt;p&gt;稿定科技旗下稿定设计产品是一个聚焦商业设计的多场景在线设计平台，打破了软硬件间的技术限制，汇集创意内容与设计工具于一体，为不同场景下的设计需求提供优质的解决方案，满足图片、视频等全类型媒介的设计需求，让设计更简单。&lt;/p&gt;&lt;p&gt;我们使用 Elasticsearch（下文中简称为 ES） 作为日志检索组件，随着业务量的增长，每天有 2T 左右的新增数据，需要保存 15~30 天，给磁盘和系统带来了不小的压力。在 ES 中为了保证日志的写入和查询的性能，大多使用单位存储成本更高的高性能云盘。但是，在实际的业务场景中，超过 7 天的数据仅作低频使用，全部存储在高性能云盘必然会导致过高的成本和空间的浪费。&lt;/p&gt;&lt;h1 id=&quot;方案&quot;&gt;方案&lt;/h1&gt;&lt;p&gt;ElasticSearch 7.10 版本推出了索引生命周期概念，开始支持数据分层存储，可以指定不同节点使用不同的磁盘介质来区分冷热数据，比如使用 HDD 磁盘来存储温冷数据，能获得更大的使用空间和更低的成本。这个特性非常适合日志索引场景。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;在温冷数据的存储介质上，使用 JuiceFS 替代 HDD 磁盘，相当于获得了无限容量的存储空间。通过 ES 的索引生命周期管理，可以自动完成索引的创建 - 迁移 - 销毁整个生命周期管理，无需手工干预。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;在实践中，首先将 ES 集群升级到目前最新的 7.13 版本。然后拆分冷热节点，热节点优先考虑性能，冷节点优先考虑存储的容量和成本。同时，调整索引和模板方式，配置数据生命周期、索引模板和数据流，完成索引数据写入。&lt;/p&gt;&lt;p&gt;调整后整个索引的流转如下图所示：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;在索引创建时，配置 &lt;code&gt;index.routing.allocation.require.box_type:hot&lt;/code&gt; 进行节点筛选；&lt;/li&gt;&lt;li&gt;等待索引进入 warm 周期时，调整 &lt;code&gt;index.routing.allocation.require.box_type:warm&lt;/code&gt;，并迁移到 warm 节点后，数据进入冷节点存储，实际存储于 JuiceFS 中；&lt;/li&gt;&lt;li&gt;等待索引进入 delete 周期时，ES 会自动把索引数据删除。&lt;/li&gt;&lt;/ol&gt;&lt;h1 id=&quot;客户收益&quot;&gt;客户收益&lt;/h1&gt;&lt;p&gt;方案中使用的 JuiceFS 是什么呢？&lt;/p&gt;&lt;p&gt;JuiceFS 是一款面向云环境设计的企业级分布式文件系统。提供完备的 POSIX 兼容性，为应用提供一个低成本、空间无限的共享文件系统。使用 JuiceFS 存储数据，数据本身会被持久化在对象存储（例如，Amazon S3、阿里云 OSS 等)，结合 JuiceFS 的元数据服务来提供高性能文件存储。JuiceFS 在全球公有云服务中都提供有全托管服务，只需点点鼠标，十分钟配置好。同时 JuiceFS 在 2021年初在 GitHub 开源，受到全球开发者的关注和参与，目前已经获得 3700+ stars。&lt;/p&gt;&lt;p&gt;在本方案中 ES 集群 warm 节点使用 JuiceFS 做存储之后，我们不用再对这些节点做容量规划和扩容工作，也省去了节点故障时的数据迁移，降成本的同时还为运维带来很大的便利。&lt;/p&gt;&lt;p&gt;JuiceFS 的持久层使用对象存储，弹性计费，TCO 比使用普通云盘还要低。在本方案的 ES 集群中，Hot 节点使用的云盘价格为 1000元/TB/月，使用全托管的 JuiceFS 服务加上对象存储的开销，价格约为 250元/TB/月。ES 集群总容量 60TB+，通过冷热分层处理，&lt;strong&gt;75% 的数据存在 JuiceFS 中，仅存储成本已经节省近 60%。如果再加上运维团队介绍的时间精力，这个方案为客户的数据存储带来的 TCO 下降至少有 70%。&lt;/strong&gt;&lt;/p&gt;&lt;h1 id=&quot;实践&quot;&gt;实践&lt;/h1&gt;&lt;h2 id=&quot;集群配置&quot;&gt;集群配置&lt;/h2&gt;&lt;p&gt;集群共 9 个节点，⼀个独⽴的 master 节点（elastic_001），另外 8 个数据节点，其中有 5 个热数据节点（elastic_002 ~ elastic_006），3 个冷数据节点（elastic_007 ~ elastic_009）。&lt;/p&gt;&lt;h2 id=&quot;目录挂载与配置&quot;&gt;目录挂载与配置&lt;/h2&gt;&lt;p&gt;JuiceFS 挂载在 ES 冷数据节点，提供 ES 的数据⽬录。&lt;/p&gt;&lt;p&gt;节点配置有⼀块 2T 的数据盘，挂载在 /data ⽬录，ES 进程以容器的⽅式启动，数据盘挂载的是系统的 &lt;code&gt;/data/elastic&lt;/code&gt; ⽬录，由于使⽤的容器挂载系统⽬录的⽅式，不能通过 &lt;strong&gt;&lt;em&gt;*软链*&lt;/em&gt;&lt;/strong&gt; 的⽅式将 ES 数据⽬录 ( &lt;code&gt;/data/elastic&lt;/code&gt; ) 指向 JuiceFS 挂载的某个⼦⽬录，使⽤了 Linux 系统的 bind mount 将 JuiceFS 的⼦⽬录挂载到 &lt;code&gt;/data/elastic&lt;/code&gt; 这个路径上。⽐如在 007 节点上：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# ./juicefs mount gd-elasticsearch-jfs --attrcacheto=1 --entrycacheto=1 \ 
--cache-dir=/data/jfsCache --cache-size=307200 \
--upload-limit=800 --writeback /jfs
# mount -o bind /jfs/data-elastic-pro-007 /data/elastic
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样在 &lt;code&gt;/data/elastic&lt;/code&gt; ⽬录看到 &lt;code&gt;/jfs/data-elastic-pro-007&lt;/code&gt; 的内容。&lt;/p&gt;&lt;p&gt;在 008 和 009 节点上也做类似挂载操作。&lt;/p&gt;&lt;p&gt;如果您还不熟悉 JuiceFS 的初始化、挂载等基本操作，请参考 &lt;a href=&quot;https://github.com/juicedata/juicefs/blob/main/docs/zh_cn/README.md&quot;&gt;JuiceFS 官方文档&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;本地磁盘⽬录使⽤的是 &lt;code&gt;/data/jfsCache/gd-elasticsearch-jfs/rawstaging/&lt;/code&gt; ，请注意不要删除这个⽬录中的任何⽂件，否则可能出现数据丢失。
&lt;code&gt;cache-size&lt;/code&gt; 和 &lt;code&gt;upload-limit&lt;/code&gt; 分别⽤来限制本地的读缓存使⽤空间为 300GiB，写对象存储的带宽不超过 800Mbps。&lt;code&gt;attrcacheto&lt;/code&gt; 和 &lt;code&gt;entrycacheto&lt;/code&gt; 分别表示内核的 attr cache 和 entry cache 的缓存超时时间，单位是秒。&lt;/p&gt;&lt;h1 id=&quot;性能优化&quot;&gt;性能优化&lt;/h1&gt;&lt;h2 id=&quot;降低节点负载&quot;&gt;降低节点负载&lt;/h2&gt;&lt;p&gt;在采用 JuiceFS 之前，ES 集群生命周期中配置了 Force Merge，具体配置项为 warm.actions.forcemerge.max_num_segments: 1，它会导致数据在 Rollover 时重新 Merge，给 CPU 带来极大的压力。而这步动作是完全没必要的，关闭 Force Merge 配置即可避免不必要的性能开销，降低节点负载。&lt;/p&gt;&lt;h2 id=&quot;rollover-参数配置优化&quot;&gt;Rollover 参数配置优化&lt;/h2&gt;&lt;p&gt;由于 warm 阶段数据写入 JuiceFS，最终会持久化到对象存储上，应用层不用再存储多副本，可以在索引 Rollover 过程中，设置 replicas 为 0，即 &lt;code&gt;warm.actions.number_of_replicas: 0&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;另外，考虑当索引数据迁移到 warm 阶段后，数据并不再写入，可以设置 warm 阶段索引只读，即 &lt;code&gt;warm.actions.readonly: {}&lt;/code&gt;，关闭索引的数据写入可以减少内存占用量。&lt;/p&gt;&lt;h1 id=&quot;总结&quot;&gt;总结&lt;/h1&gt;&lt;p&gt;随着时间的推移和业务量的增长，企业势必面临更大规模的数据存储和管理上的双重挑战。在本案中，稿定科技充分发挥 ElasticSearch 的生命周期管理能力，根据业务需要将日志数据进行分层存储。将需要频繁使用的热数据保存在 SSD，而超过 7 天的低频使用数据则存储在性价比更高的 JuiceFS，为客户节省存储成本 60%。同时，JuiceFS 还为应用提供近乎无限的弹性空间，省去了容量规划、扩容、数据迁移等一系列的运维工作，提升了企业 IT 架构的效率。&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>585a8299c1af9f643ed1c177e8095c4f</guid>
<title>VS Code-loader 实现之：requirejs 源码解析</title>
<link>https://toutiao.io/k/ukkvgta</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;Post-body&quot;&gt;
                    &lt;p&gt;vscode 源码使用 vscode-loader 加载模块，vscode-loader 是异步模块定义 (AMD) 加载器的一种实现。而 AMD 规范的实现典范是 requirejs，可在浏览器、node 等环境中，异步加载 js 或模块。&lt;/p&gt;

&lt;p&gt;本文先学习梳理 requirejs 的源码，了解 AMD 一般是如何实现的。在后面的文章中，再进一步学习 vscode-loader 的实现。&lt;/p&gt;

&lt;h2&gt;requirejs 的使用示例&lt;/h2&gt;

&lt;p&gt;require.js 在 浏览器中的使用方法如下：&lt;/p&gt;

&lt;p&gt;html：&amp;lt;srcipt&amp;gt; 标签的 src 指定为 require.js，data-main 指定为入口 js。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;!-- 指定入口脚本 a/b.js --&amp;gt;
    &amp;lt;script src=&quot;require.js&quot; data-main=&quot;a/b.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;入口 js：调用 requirejs 方法，加载模块。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// a/b.js

// 配置模块路径
require.config({
  paths: {
    test: &quot;test&quot;,
  },
});

// 加载模块
requirejs([&quot;test&quot;], function (test) {
  test.compare(2, 5);
});&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;定义模块：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// test.js

define(&quot;test&quot;, function () {
  return {
    compare: function (a, b) {
      return a &amp;gt; b;
    },
  };
});&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;define 方法：&lt;code&gt;define(id?, dependencies?, factory);&lt;/code&gt;，第一个参数是模块名，第二个参数是依赖，第三个参数是模块的工厂函数，返回定义的模块。&lt;/p&gt;

&lt;h2&gt;requirejs 的代码解析&lt;/h2&gt;

&lt;p&gt;requirejs 的主体是一个自执行函数。下面代码省略了许多细节，先看一下基本的结构。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var requirejs, require, define;
(function (global, setTimeout) {
    // 定义一系列的变量和函数，最主要是 newContext、req、define
    function newContext(contextName) {}
    req = requirejs = function (deps, callback, errback, optional) {}
    define = function (name, deps, callback) {}

    // 第一步：创建默认上下文
    req({});

    // 第二步：浏览器环境，查找入口 js，放到配置中
    if (isBrowser &amp;amp;&amp;amp; !cfg.skipDataMain) {
        ...

        cfg.deps = cfg.deps ? cfg.deps.concat(mainScript) : [mainScript];

        ...
    }

    // 第三步：根据配置，加载入口 js
    req(cfg);

}(this, (typeof setTimeout === &#x27;undefined&#x27; ? undefined : setTimeout)));&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，requirejs 可以分为三步：创建默认上下文、查找入口 js、加载入口 js。&lt;/p&gt;

&lt;p&gt;第一步和第三步都是调用 req 函数，涉及代码较多。我们先看看相对简单的第二步，查找入口 js 的具体实现。&lt;/p&gt;

&lt;h3&gt;查找入口 js&lt;/h3&gt;

&lt;p&gt;从前面的示例 &lt;code&gt;&amp;lt;script src=&quot;require.js&quot; data-main=&quot;a/b.js&quot; &amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;，我们知道，入口 js 在 script 标签的 data-main 属性中指定。所以查找入口 js，也就是先找到 data-main，再进行解析。具体如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;
    if (isBrowser &amp;amp;&amp;amp; !cfg.skipDataMain) {
        // 第一步：遍历 script 标签
        // 注：eachReverse，对 scripts 数组，遍历执行传入的函数，函数返回值为 true 时中止遍历
        eachReverse(scripts(), function (script) {
            // 第二步：保存 script 标签的父元素
            if (!head) {
                head = script.parentNode;
            }

            // 第三步：获取 data-main 属性
            dataMain = script.getAttribute(&#x27;data-main&#x27;);

            // 第四步：解析 data-main，获取入口 js，放到配置中
            if (dataMain) {
                // 略，在下面展开讨论
                ...
            }
        });
    }

    // 相关函数如下：
    /**
     * 遍历数组，执行函数，函数返回 true 时，break
     */
    function eachReverse(ary, func) {
        if (ary) {
            var i;
            for (i = ary.length - 1; i &amp;gt; -1; i -= 1) {
                if (ary[i] &amp;amp;&amp;amp; func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    function scripts() {
        return document.getElementsByTagName(&#x27;script&#x27;);
    }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解析 data-main 的具体逻辑如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;if (dataMain) {
  mainScript = dataMain;

  // 第一步：如果没有 baseUrl，则解析获取 baseUrl
  // 注：mainScript.indexOf(&#x27;!&#x27;) === -1，该判断是指 data-main 值不是加载器插件模块的 ID。
  if (!cfg.baseUrl &amp;amp;&amp;amp; mainScript.indexOf(&quot;!&quot;) === -1) {
    // 1. data-main 解析为 mainScript 和 subPath
    /**
     * 例子：
     * dataMain = &#x27;a&#x27;, 解析出 mainScirpt = &#x27;a&#x27;, subPath = &#x27;./&#x27;
     * dataMain = &#x27;a/b&#x27;, 解析出 mainScript = &#x27;b&#x27;, subpath = &#x27;a/&#x27;
     */
    src = mainScript.split(&quot;/&quot;);
    mainScript = src.pop();
    subPath = src.length ? src.join(&quot;/&quot;) + &quot;/&quot; : &quot;./&quot;;

    // 2. 设置 cfg 的 baseUrl
    cfg.baseUrl = subPath;
  }

  // 第二步：mainScript 去掉结尾的 .js
  mainScript = mainScript.replace(jsSuffixRegExp, &quot;&quot;);

  // 第三步：如果 mainScript 仍然是路径，则回退到 dataMain
  if (req.jsExtRegExp.test(mainScript)) {
    mainScript = dataMain;
  }

  // 第四步：将 data-main 脚本放入 cfg.deps 中，等待后续加载
  cfg.deps = cfg.deps ? cfg.deps.concat(mainScript) : [mainScript];

  return true;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;经过解析，得到配置对象 cfg。比如对于 &lt;code&gt;data-main=&quot;./a/b.js&quot;&lt;/code&gt;，得到的 cfg 如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;cfg = {
  baseUrl: &quot;./a/&quot;,
  deps: [&quot;b&quot;],
};&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;req 加载入口 js&lt;/h3&gt;

&lt;p&gt;&amp;lt;!-- 接下来，我们继续看第一步、第三步操作：调用 req 函数，创建默认上下文、加载入口 js --&amp;gt;&lt;/p&gt;

&lt;p&gt;配置好入口文件后，下一步就是调用 req 函数，加载入口 js。第一步操作，创建默认上下文也是调用 req 函数，我们放在一起看。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;defContextName = &quot;_&quot;;

req = requirejs = function (deps, callback, errback, optional) {
  // 第一步：contextName 设置为默认值
  var context,
    config,
    contextName = defContextName;

  // 第二步：确定第一个参数，是否为 config 对象。如果是，重新修改其他参数。
  if (!isArray(deps) &amp;amp;&amp;amp; typeof deps !== &quot;string&quot;) {
    // deps is a config object
    config = deps;
    if (isArray(callback)) {
      // Adjust args if there are dependencies
      deps = callback;
      callback = errback;
      errback = optional;
    } else {
      deps = [];
    }
  }

  // 第三步：根据 config 对象，更新 contextName
  if (config &amp;amp;&amp;amp; config.context) {
    contextName = config.context;
  }

  // 第四步：根据 contextName 获取或新建上下文
  context = getOwn(contexts, contextName);
  if (!context) {
    context = contexts[contextName] = req.s.newContext(contextName);
  }

  // 第五步：如果有 config 对象，就更新上下文的配置
  if (config) {
    context.configure(config);
  }

  // 第六步：调用上下文的 require 方法
  return context.require(deps, callback, errback);
};

s = req.s = {
  contexts: contexts,
  newContext: newContext,
};&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到 &lt;code&gt;req&lt;/code&gt; 函数就是 &lt;code&gt;requirejs&lt;/code&gt; 函数。它有两种调用方式，一种是不传入 config 对象，一种是传入。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;不传入 config 对象：
  &lt;ul&gt;&lt;li&gt;直接使用默认上下文（获取或新建默认上下文），调用默认上下文的 &lt;code&gt;require&lt;/code&gt; 方法。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;传入 config 对象：
  &lt;ul&gt;&lt;li&gt;根据 config 更新 contextName，根据 contextName 获取或新建上下文（注意：如果它没有更新，也还是默认上下文）。&lt;/li&gt;
  &lt;li&gt;用 config 更新上下文的配置，再调用上下文的 &lt;code&gt;require&lt;/code&gt; 方法。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;&amp;lt;!-- todo --&amp;gt;&lt;br/&gt;
&amp;lt;!-- 另外，如果只传入 config 对象，不传入 deps, callback, errback 等参数，那么只会设置上下文配置，而第六步的 require 其实是不生效的。 --&amp;gt;&lt;/p&gt;

&lt;h4&gt;req 执行过程&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;req({})&lt;/code&gt;，传了一个没有属性的对象进去，创建了默认上下文。&lt;br/&gt;
&lt;code&gt;req(cfg)&lt;/code&gt;，还是以前面 &lt;code&gt;data-main=&quot;./a/b.js&quot;&lt;/code&gt; 为例，传入参数为 { baseUrl: &#x27;./a/&#x27;, deps: [&#x27;b&#x27;] }，加载了入口文件。&lt;br/&gt;
req 前三步的执行逻辑如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;req = requirejs = function (deps, callback, errback, optional) {

    // 第一步：contextName = &#x27;_&#x27;
    var context, config,
        contextName = defContextName;

    // 第二步：
    // req({})，第一个参数是 {}，结果： config = {}, deps = []。
    // req(cfg)，第一个参数是 { baseUrl: &#x27;./a/&#x27;, deps: [&#x27;b&#x27;] }，结果：config = { baseUrl: &#x27;./a/&#x27;, deps: [&#x27;b&#x27;] }, deps = []
    if (!isArray(deps) &amp;amp;&amp;amp; typeof deps !== &#x27;string&#x27;) {
        // config = 第一个参数
        config = deps;
        // 未传入第二个参数，deps = []
        if (isArray(callback)) {
            deps = callback;
            callback = errback;
            errback = optional;
        } else {
            deps = [];
        }
    }

    // 第三步：
    // req({})，config 为 {}，所以 contextName 依然为默认值 &#x27;_&#x27;
    // req(cfg)，config 为 { baseUrl: &#x27;./a/&#x27;, deps: [&#x27;b&#x27;] }, 所以 contextName 依然为默认值 &#x27;_&#x27;
    if (config &amp;amp;&amp;amp; config.context) {
        contextName = config.context;
    }

    ...
};&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们继续看 req 函数的第四步。&lt;br/&gt;
&lt;code&gt;req({})&lt;/code&gt;，一开始还没有默认上下文，所以会新建默认上下文。&lt;br/&gt;
&lt;code&gt;req(cfg)&lt;/code&gt; 的 contextName 也是默认值 &#x27;_&#x27;，而默认上下文已经新建，所以会直接获取默认上下文。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;    // req 函数的第四步：
    // req({})，contextName 为默认值 &#x27;_&#x27;，一开始没有默认上下文，所以走 req-4.2，新建默认上下文。
    // req(cfg)，contextName 为默认值 &#x27;_&#x27;，已经有默认上下文，所以走 req-4.1，获取默认上下文。
    req = requirejs = function (deps, callback, errback, optional) {
        ...
        // req-4.1. 根据 contextName 获取 context。
        context = getOwn(contexts, contextName);
        // req-4.2. 如果没有 context，根据 contextName 新建一个上下文。
        if (!context) {
            context = contexts[contextName] = req.s.newContext(contextName);
        }
        ...
    }

    /* req-4.1 获取上下文 */
    // getOwn 的第一个参数 contexts，初始化时是 {}
    contexts = {},

    // getOwn：判断对象中，是否有某个属性，如果有就返回属性值
    function getOwn(obj, prop) {
        return hasProp(obj, prop) &amp;amp;&amp;amp; obj[prop];
    }

    // hasProp：判断对象中，是否有某个属性
    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    // hasOwn
    op = Object.prototype,
    hasOwn = op.hasOwnProperty,&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;继续看 req-4.2 新建上下文的逻辑，由于代码量大，这里进行省略简化。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;    /* req-4.2 新建上下文 */
    function newContext(contextName) {
        // 定义一堆变量和函数，这里只看 context
        var context
        ...

        // req-4.2.1：context 赋值
        context = {
            config: config,
            contextName: contextName,
            ...
            // 为上下文设置配置
            configure: function (cfg) {
                // 确保 baseUrl 以 / 结束
                if (cfg.baseUrl) {
                    if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== &#x27;/&#x27;) {
                        cfg.baseUrl += &#x27;/&#x27;;
                    }
                }
                ...
                // configure 的最后一步：如果指定了 deps 或 callback，则使用这些参数调用 require。
                if (cfg.deps || cfg.callback) {
                    context.require(cfg.deps || [], cfg.callback);
                }
            },
            // 加载模块
            makeRequire: function (relMap, options) { ... },
            ...
        }

        // req-4.2.2：设置 context.require，并返回 context
        context.require = context.makeRequire();
        return context;
    }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到新建上下文，主要是对 context 进行赋值，定义一系列的属性和方法，并返回 context。&lt;/p&gt;

&lt;p&gt;回到 req 函数，第五步是设置 config，如果指定了 deps，则调用 require 加载模块。&lt;/p&gt;

&lt;p&gt;第六步是返回 context.require，加载模块。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;req = requirejs = function (deps, callback, errback, optional) {
    ...

    // 第五步：调用 context.configure 更新配置
    /**
     * req({})，config 为 {}，结果：context.config = {config: baseUrl: &quot;./&quot;, bundles: {}, config: {}, paths: {}, pkgs: {}, shim: {}, waitSeconds: 7}
     * req(cfg)，config 为 { baseUrl: &#x27;./a/&#x27;, deps: [&#x27;b&#x27;] }，结果：context.config = {config: baseUrl: &quot;./a/&quot;, deps: [&quot;b&quot;], bundles: {}, config: {}, paths: {}, pkgs: {}, shim: {}, waitSeconds: 7}, 由于 cfg.deps 为 [&#x27;b&#x27;]，在 configure 的最后一步会调用 context.require(cfg.deps)，加载入口 js
     */
    if (config) {
        context.configure(config);
    }

    // 第六步：context.require，从第二步可知，deps 均为 []，所以这里没有依赖模块加载。
    return context.require(deps, callback, errback);
};&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;加载模块&lt;/h4&gt;

&lt;p&gt;梳理完 req 函数的执行过程，可以看到，&lt;code&gt;req(cfg)&lt;/code&gt; 在第五步会通过 &lt;code&gt;context.require(cfg.deps)&lt;/code&gt;，加载入口 js，其中 &lt;code&gt;cfg.deps&lt;/code&gt; 为 [&#x27;b&#x27;]。&lt;/p&gt;

&lt;p&gt;接下来，就继续查看加载模块的实现逻辑。在前面(req-4.2.2)，可以看到 &lt;code&gt;context.require = context.makeRequire()&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;context = {
    ...
    makeRequire: function (relMap, options) {
        options = options || {};

        // 第一步：定义 localRequire（require 的实现）
        function localRequire(deps, callback, errback) {
            var id, map, requireMod;

            if (options.enableBuildCallback &amp;amp;&amp;amp; callback &amp;amp;&amp;amp; isFunction(callback)) {
                callback.__requireJsBuild = true;
            }

            // require-1. 如果 deps 是字符串类型，根据模块名称获取模块id ,再返回 defined[id]
            if (typeof deps === &#x27;string&#x27;) {
                ...
                return defined[id];
            }

            // require-2. 抓取全局队列中等待的 defines
            intakeDefines();

            // require-3. 在 nextTick 中，加载所有依赖
            context.nextTick(function () {
                intakeDefines();

                // 获取模块加载器（重点）
                requireMod = getModule(makeModuleMap(null, relMap));

                requireMod.skipMap = options.skipMap;

                // 初始化模块（重点）
                requireMod.init(deps, callback, errback, {
                    enabled: true
                });

                checkLoaded();
            });

            return localRequire;
        }

        // 第二步：localReuire 增加 isBrowser, toUrl, defined, specified 四个方法
        mixin(localRequire, {
            isBrowser: isBrowser,
            toUrl: function (moduleNamePlusExt) { ... }, // module name + .extension 转为 url 路径
            defined: function (id) { ... },
            specified: function (id) { ... }
        });

        // 第三步：localRequire 增加 undef 方法，注意：只允许在顶级 require 调用 undef
        if (!relMap) {
            localRequire.undef = function (id) {
                ...
            };
        }

        // 第四步：返回 localRequire
        return localRequire;
    }
}

context.require = context.makeRequire()&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;context.makeRequire()&lt;/code&gt; 返回的是 &lt;code&gt;localRequire&lt;/code&gt;，而 &lt;code&gt;localRequire&lt;/code&gt; 使用 &lt;code&gt;context.nextTick&lt;/code&gt;，在未来的事件循环中加载依赖。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;nextTick&lt;/code&gt; 的实现如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;context = {
  nextTick: req.nextTick,
};
/**
 * 在当前任务结束之后执行某些操作，具体来说是通过 setTimeout 将操作放到事件循环的消息队列中，排队等待执行。
 * 其他环境下，如果有比 setTimeout 更好的解决方案，就会改写该方法。
 * 注：延时 4ms，是因为 setTimeout 的最小延时时间为 4ms。
 */
req.nextTick =
  typeof setTimeout !== &quot;undefined&quot;
    ? function (fn) {
        setTimeout(fn, 4);
      }
    : function (fn) {
        fn();
      };&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;继续看，&lt;code&gt;nextTick&lt;/code&gt; 中加载模块的逻辑：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;context.nextTick(function () {
    ...
    // module-1. 获取模块加载器
    requireMod = getModule(makeModuleMap(null, relMap));

    // module-2. 初始化模块（重点）
    requireMod.init(deps, callback, errback, {
        enabled: true
    });
    ...
});

// module-1. 获取或新建模块加载器：new context.Module(depMap)
function getModule(depMap) {
    var id = depMap.id,
        mod = getOwn(registry, id);

    if (!mod) {
        // 新建一个模块加载器
        mod = registry[id] = new context.Module(depMap);
    }

    return mod;
}

// 模块加载器：包含属性和原型方法
Module = function (map) {
    this.map = map;
    ...
};
Module.prototype = {
    ...
};
context = {
    ...
    Module: Module
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里通过 &lt;code&gt;getModule&lt;/code&gt; 返回 &lt;code&gt;Module&lt;/code&gt; 的实例，&lt;code&gt;Module&lt;/code&gt; 包含模块相关的属性和方法。&lt;/p&gt;

&lt;p&gt;接下来，调用 &lt;code&gt;Module&lt;/code&gt; 的 &lt;code&gt;init&lt;/code&gt; 方法初始化模块：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// module-2. 初始化模块
Module.prototype = {
    init: function (depMaps, factory, errback, options) {
        ...

        // 如果未启动，就启动该模块。如果已启动，检查并启动其依赖项。
        if (options.enabled || this.enabled) {
            this.enable();
        } else {
            this.check();
        }
    },
    enable: function () {
        ...
        // module-2.1. 遍历启动依赖
        each(this.depMaps, bind(this, function (depMap, i) {
            ...
            if (!hasProp(handlers, id) &amp;amp;&amp;amp; mod &amp;amp;&amp;amp; !mod.enabled) {
                // 调用 context.enable 启动
                context.enable(depMap, this);
            }
        }));

        // module-2.2. 加载当前模块
        this.check();
    }
}

context = {
    ...
    enable: function (depMap) {
        // 如果模块仍在注册表中等待启动，则启动该模块。
        var mod = getOwn(registry, depMap.id);
        if (mod) {
            // 递归加载依赖项，getModule，并 enable
            getModule(depMap).enable();
        }
    },
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;module-2.1 的执行流程：&lt;code&gt;this.init()&lt;/code&gt; -&amp;gt; &lt;code&gt;this.enale()&lt;/code&gt; -&amp;gt; &lt;code&gt;context.enable(depMap, this)&lt;/code&gt; -&amp;gt; &lt;code&gt;getModule(depMap).enable()&lt;/code&gt; -&amp;gt; ...&lt;br/&gt;
在当前模块执行 &lt;code&gt;enable()&lt;/code&gt; 时，遍历启动依赖模块；依赖模块执行 &lt;code&gt;enable()&lt;/code&gt; 时，又会遍历启动它里面的依赖。就这样，通过递归，启动所有依赖模块。&lt;/p&gt;

&lt;p&gt;继续看 module-2.2 &lt;code&gt;this.check()&lt;/code&gt; 加载当前模块。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;Module.prototype = {
    check: function () {
        ...

        if (!this.inited) {
            // 调用 this.fetch
            if (!hasProp(context.defQueueMap, id)) {
                this.fetch();
            }
        }
        ...
    },
    fetch: function () {
        ...
        // 调用 this.load。this.callPlugin 是加载插件的，最终也会调用 this.load()。
        return map.prefix ? this.callPlugin() : this.load();
    },
    load: function () {
        var url = this.map.url;

        if (!urlFetched[url]) {
            urlFetched[url] = true;
            // 调用 context.load
            context.load(this.map.id, url);
        }
    }
}

context = {
    ...
    // 执行 req.load
    load: function (id, url) {
        req.load(context, id, url);
    }
}

req.load = function (context, moduleName, url) {
    var config = (context &amp;amp;&amp;amp; context.config) || {},
        node;
    if (isBrowser) {
        // 浏览器环境，新建 script 标签
        node = req.createNode(config, moduleName, url);

        // 记录上下文名和模块名
        node.setAttribute(&#x27;data-requirecontext&#x27;, context.contextName);
        node.setAttribute(&#x27;data-requiremodule&#x27;, moduleName);

        // 监听事件
        if (node.attachEvent &amp;amp;&amp;amp;
                !(node.attachEvent.toString &amp;amp;&amp;amp; node.attachEvent.toString().indexOf(&#x27;[native code&#x27;) &amp;lt; 0) &amp;amp;&amp;amp;
                !isOpera) {
            // 兼容 IE
            useInteractive = true;

            node.attachEvent(&#x27;onreadystatechange&#x27;, context.onScriptLoad);
        } else {
            node.addEventListener(&#x27;load&#x27;, context.onScriptLoad, false);
            node.addEventListener(&#x27;error&#x27;, context.onScriptError, false);
        }
        // 设置 src
        node.src = url;

        if (config.onNodeCreated) {
            config.onNodeCreated(node, config, moduleName, url);
        }

        // 插入 scirpt 标签
        currentlyAddingScript = node;
        if (baseElement) {
            head.insertBefore(node, baseElement);
        } else {
            head.appendChild(node);
        }
        currentlyAddingScript = null;

        return node;
    } else if (isWebWorker) {
        ...
    }
};

// 新建 script 节点
req.createNode = function (config, moduleName, url) {
    var node = config.xhtml ?
            document.createElementNS(&#x27;http://www.w3.org/1999/xhtml&#x27;, &#x27;html:script&#x27;) :
            document.createElement(&#x27;script&#x27;);
    node.type = config.scriptType || &#x27;text/javascript&#x27;;
    node.charset = &#x27;utf-8&#x27;;
    node.async = true;
    return node;
};&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;module-2.2 加载模块的执行流程：&lt;code&gt;this.check()&lt;/code&gt; -&amp;gt; &lt;code&gt;this.fetch()&lt;/code&gt; -&amp;gt; &lt;code&gt;this.load()&lt;/code&gt; -&amp;gt; &lt;code&gt;context.load()&lt;/code&gt; -&amp;gt; &lt;code&gt;req.load()&lt;/code&gt; -&amp;gt; &lt;code&gt;req.createNode()&lt;/code&gt;。&lt;br/&gt;
可以看到，在浏览器环境，是通过插入 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标签，设置 &lt;code&gt;node.src = url&lt;/code&gt; 来加载模块的。&lt;/p&gt;

&lt;h3&gt;define 定义模块&lt;/h3&gt;

&lt;p&gt;在 requirejs 的使用示例中，有一个 test 模块。在调用 &lt;code&gt;require&lt;/code&gt; 函数时，会通过 &lt;code&gt;context.require(deps, callback, errback)&lt;/code&gt;，加载 test.js。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// a/b.js

// 加载模块
requirejs([&quot;test&quot;], function (test) {
  test.compare(2, 5);
});&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而 test.js 中，通过 &lt;code&gt;define&lt;/code&gt; 函数定义了 test 模块。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// test.js

define(&quot;test&quot;, function () {
  return {
    compare: function (a, b) {
      return a &amp;gt; b;
    },
  };
});&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面看一下 &lt;code&gt;define&lt;/code&gt; 函数的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;(commentRegExp = /\/\*[\s\S]*?\*\/|([^:&quot;&#x27;=]|^)\/\/.*$/gm),
  (cjsRequireRegExp = /[^.]\s*require\s*\(\s*[&quot;&#x27;]([^&#x27;&quot;\s]+)[&quot;&#x27;]\s*\)/g),
  (define = function (name, deps, callback) {
    var node, context;

    // 第一步：没有传入 name，调整参数
    // 示例中的 test 模块，name 为 &#x27;test&#x27;
    if (typeof name !== &quot;string&quot;) {
      callback = deps;
      deps = name;
      name = null;
    }

    // 第二步：没有传入 deps，调整参数
    // test 模块，没有传入 deps，callback = fn，deps = null
    if (!isArray(deps)) {
      callback = deps;
      deps = null;
    }

    // 第三步：没有传入 deps, callback 为函数，从 callback 中获取依赖
    // test 模块，执行这部分代码，由于 callback 没有形式参数，结果：deps = []
    if (!deps &amp;amp;&amp;amp; isFunction(callback)) {
      deps = [];
      if (callback.length) {
        callback
          .toString()
          .replace(commentRegExp, commentReplace) // 删除注释
          .replace(cjsRequireRegExp, function (match, dep) {
            // 获取依赖模块
            deps.push(dep);
          });

        // Function.length 对应函数形参的个数，只有一个参数时，deps = [&#x27;require&#x27;]；否则 deps = [&#x27;require&#x27;, &#x27;exports&#x27;, &#x27;module&#x27;, ...deps]
        deps = (callback.length === 1
          ? [&quot;require&quot;]
          : [&quot;require&quot;, &quot;exports&quot;, &quot;module&quot;]
        ).concat(deps);
      }
    }

    // 第四步：兼容 IE 6-8
    // test 模块，非 IE，不执行这部分代码
    if (useInteractive) {
      node = currentlyAddingScript || getInteractiveScript();
      if (node) {
        if (!name) {
          name = node.getAttribute(&quot;data-requiremodule&quot;);
        }
        context = contexts[node.getAttribute(&quot;data-requirecontext&quot;)];
      }
    }

    /**
     * 第五步：如果有上下文，则将依赖加入 context.defQueue。如果没有上下文，则将依赖加入全局队列。
     * 脚本 onload 时，再调用 def。这允许一个文件有多个模块，而不会过早地跟踪依赖，并支持匿名模块，其中模块名称在脚本 onload 事件发生之前是未知的。
     */
    // test 模块，由于没有执行第四步，没有获取 context，所以加入 globalDefQueue。
    if (context) {
      context.defQueue.push([name, deps, callback]);
      context.defQueueMap[name] = true;
    } else {
      globalDefQueue.push([name, deps, callback]);
    }
  });&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过 &lt;code&gt;define(&#x27;test&#x27;, function() {...})&lt;/code&gt;，依赖模块加入 &lt;code&gt;context.defQueue&lt;/code&gt; 或 &lt;code&gt;globalDefQueue&lt;/code&gt; 中，在脚本 &lt;code&gt;onload&lt;/code&gt; 之后加载依赖模块。&lt;/p&gt;

&lt;p&gt;回顾前面加载模块的流程，module-2.2 &lt;code&gt;this.check()&lt;/code&gt; -&amp;gt; &lt;code&gt;this.fetch()&lt;/code&gt; -&amp;gt; &lt;code&gt;this.load()&lt;/code&gt; -&amp;gt; &lt;code&gt;context.load()&lt;/code&gt; -&amp;gt; &lt;code&gt;req.load()&lt;/code&gt;。在 &lt;code&gt;req.load&lt;/code&gt; 中，会监听 test 脚本的 &lt;code&gt;load&lt;/code&gt; 事件，并在这里再次初始化 test 模块。具体如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;req.load = function (context, moduleName, url) {
    ...
    // 第一步：监听 script 的 load 事件，调用 context.onScriptLoad
    node.addEventListener(&#x27;load&#x27;, context.onScriptLoad, false);
    ...
};

function newContext(contextName) {
    var defQueue = []

    context = {
        ...
        defQueue: defQueue,
        onScriptLoad: function (evt) {
            if (evt.type === &#x27;load&#x27; ||
                    (readyRegExp.test((evt.currentTarget || evt.srcElement).readyState))) {
                interactiveScript = null;

                // 第二步：获取模块名，调用 completeLoad
                var data = getScriptData(evt);
                context.completeLoad(data.id);
            }
        },
        completeLoad: function (moduleName) {
            var found, args, mod,
                shim = getOwn(config.shim, moduleName) || {},
                shExports = shim.exports;

            // 第三步：获取全局依赖模块
            takeGlobalQueue();

            while (defQueue.length) {
                args = defQueue.shift();
                if (args[0] === null) {
                    args[0] = moduleName;
                    if (found) {
                        break;
                    }
                    found = true;
                } else if (args[0] === moduleName) {
                    found = true;
                }

                // 第四步：获取模块并初始化
                callGetModule(args);
            }
            context.defQueueMap = {};

            ...
        },
    }

    function takeGlobalQueue() {
        // 将 globalDefQueue 中的依赖放入 context 的 defQueue
        if (globalDefQueue.length) {
            each(globalDefQueue, function(queueItem) {
                var id = queueItem[0];
                if (typeof id === &#x27;string&#x27;) {
                    context.defQueueMap[id] = true;
                }
                defQueue.push(queueItem);
            });
            globalDefQueue = [];
        }
    }

    function callGetModule(args) {
        // 跳过已定义的模块
        if (!hasProp(defined, args[0])) {
            // 获取模块，初始化
            getModule(makeModuleMap(args[0], null, true)).init(args[1], args[2]);
        }
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，依然是通过 &lt;code&gt;getModule&lt;/code&gt; 获取模块，再通过 &lt;code&gt;init&lt;/code&gt; 初始化。初始化流程和前面 req 函数一样：&lt;code&gt;this.init()&lt;/code&gt; -&amp;gt; &lt;code&gt;this.enale()&lt;/code&gt; -&amp;gt; 遍历启动依赖模块（test 模块没有依赖，跳过） -&amp;gt; &lt;code&gt;this.check()&lt;/code&gt;，不再赘述。不同的是，&lt;code&gt;this.check()&lt;/code&gt; 中的流程（执行 test 模块的工厂函数，并赋值给 &lt;code&gt;this.exports&lt;/code&gt; 和 &lt;code&gt;defined[&#x27;test&#x27;]&lt;/code&gt;）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;Module.prototype = {
    check: function () {
        ...
        // 已经初始化过，这次不走 this.fetch()
        if (!this.inited) {
            if (!hasProp(context.defQueueMap, id)) {
                this.fetch();
            }
        } else if (this.error) {
            this.emit(&#x27;error&#x27;, this.error);
        } else if (!this.defining) {
            // 走这个流程
            this.defining = true;

            if (this.depCount &amp;lt; 1 &amp;amp;&amp;amp; !this.defined) {
                if (isFunction(factory)) {
                    // 第一步：调用 context.execCb，执行 factory 函数，执行结果赋值给 exports
                    // 对于 test 模块，入参 id = &quot;test&quot;, factory = test 模块的工厂函数, depExports = [], exports = undefined, 结果：exports = { compare: fn }
                    if ((this.events.error &amp;amp;&amp;amp; this.map.isDefine) ||
                        req.onError !== defaultOnError) {
                        try {
                            exports = context.execCb(id, factory, depExports, exports);
                        } catch (e) {
                            err = e;
                        }
                    } else {
                        exports = context.execCb(id, factory, depExports, exports);
                    }
                    ...
                } else {
                    exports = factory;
                }

                this.exports = exports;

                if (this.map.isDefine &amp;amp;&amp;amp; !this.ignore) {
                    // 第二步：设置 defined[id]
                    // 对于 test 模块，id = &#x27;test&#x27;, exports = { compare: fn }，结果: defined[&#x27;test&#x27;] = { compare: fn }
                    defined[id] = exports;

                    if (req.onResourceLoad) {
                        var resLoadMaps = [];
                        each(this.depMaps, function (depMap) {
                            resLoadMaps.push(depMap.normalizedMap || depMap);
                        });
                        req.onResourceLoad(context, this.map, resLoadMaps);
                    }
                }

                cleanRegistry(id);

                this.defined = true;
            }

            this.defining = false;

            if (this.defined &amp;amp;&amp;amp; !this.defineEmitted) {
                this.defineEmitted = true;
                // 第三步：触发 defined 事件
                this.emit(&#x27;defined&#x27;, this.exports);
                this.defineEmitComplete = true;
            }

        }
    },
    // 注意：这里 enable 的模块对应 require([&#x27;test&#x27;], f(test))，在该模块 enable 时遍历其依赖 [&#x27;test&#x27;]，并监听依赖的 defined 事件
    enable: function () {
        ...
        each(this.depMaps, bind(this, function (depMap, i) {
            var id, mod, handler;

            if (typeof depMap === &#x27;string&#x27;) {
                ...
                this.depCount += 1;

                // 第四步：监听 defined 事件
                // test 模块，depExports = { compare: fn }
                on(depMap, &#x27;defined&#x27;, bind(this, function (depExports) {
                    if (this.undefed) {
                        return;
                    }
                    // 第五步：将 exports 存放到 this.depExports 数组中
                    this.defineDep(i, depExports);
                    // 第六步：再次执行 this.check()
                    this.check();
                }));
                ...
            }
            ...
        }
        ...
    },
    defineDep: function (i, depExports) {
        if (!this.depMatched[i]) {
            this.depMatched[i] = true;
            this.depCount -= 1;
            // 将 exports 存放到 this.depExports 数组中
            this.depExports[i] = depExports;
        }
    },
}

function newContext(contextName) {
    context = {
        execCb: function (name, callback, args, exports) {
            return callback.apply(exports, args);
        },
        ...
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里，执行 &lt;code&gt;define(&#x27;test&#x27;, function() {...})&lt;/code&gt; 中工厂函数，得到 test 模块的对象 &lt;code&gt;{ compare: fn }&lt;/code&gt;。再将模块对象赋值给 &lt;code&gt;this.exports&lt;/code&gt;，用于输出模块对象。同时保存到上下文的 &lt;code&gt;defined&lt;/code&gt; 对象中，缓存起来。（第一步 - 第二步）&lt;/p&gt;

&lt;p&gt;接着，触发 &lt;code&gt;defined&lt;/code&gt; 事件，将 &lt;code&gt;exports&lt;/code&gt; 存放到 &lt;code&gt;this.depExports&lt;/code&gt; 数组中，并执行 &lt;code&gt;require([&#x27;test&#x27;], f(test))&lt;/code&gt; 模块的 &lt;code&gt;this.check()&lt;/code&gt;。（第三步 - 第六步）&lt;/p&gt;

&lt;p&gt;继续看这一次的 &lt;code&gt;this.check()&lt;/code&gt; 流程：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;Module.prototype = {
    check: function () {
        ...
        // factory = require 中的函数 f(test), depExports = [compare], exports = undefined
        // 调用 context.execCb，执行 require([&#x27;test&#x27;], function (test) {}) 中的函数，并将 depExports（即 test 模块的返回值，compare 函数） 作为参数传入。
        exports = context.execCb(id, factory, depExports, exports);
        ...
        }
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这次调用 &lt;code&gt;check&lt;/code&gt;，执行的是 &lt;code&gt;require&lt;/code&gt; 中传入的函数，并将 &lt;code&gt;this.depExports&lt;/code&gt; 作为参数传入，也就是前面 test 模块的返回值 &lt;code&gt;{ compare: fn }&lt;/code&gt;。至此，test 模块加载完成。&lt;/p&gt;
                &lt;/div&gt;
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6f3b191bd536eda3e412e232425358f6</guid>
<title>一文学会 Java 事件机制</title>
<link>https://toutiao.io/k/44t0udv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;content&quot;&gt;&lt;div class=&quot;gh&quot;&gt;
  &lt;figure class=&quot;gh_qrcode&quot;&gt;
    &lt;img src=&quot;/assets/img/qrcode_for_gh_lomagicode.jpg&quot; alt=&quot;公众号二维码&quot;/&gt;
    公众号：逻魔代码
  &lt;/figure&gt;
&lt;/div&gt;&lt;p&gt;相信做 Java 开发的朋友，大多都是学习过或至少了解过 Java GUI 编程的，其中有大量的事件和控件的绑定，当我们需要在点击某个按钮实现某些操作的时候，其实就是为这个按钮控件注册了一个合理处理点击事件的监听器。此外，Spring Framework 中也有许多用到事件处理机制的地方，如 ApplicationContextEvent 及其子类，代表着容器的启动、停止、关闭、刷新等事件。本文会为大家介绍 Java 的事件处理机制，也会用示例来说明，如何优雅地触发并处理一个自定义事件。&lt;/p&gt;



&lt;h3 id=&quot;委托事件模型&quot;&gt;委托事件模型&lt;/h3&gt;

&lt;p&gt;Java 自 1.1 之后基于委托事件模型，定义了标准一致的获取和处理事件的方式。它的思路非常简单，由事件源发起特定事件，并将事件发送给一个或多个事件监听器，而监听器在此过程中一直处于等待状态，直到接收到该事件，然后处理事件并返回。实现起来也很简单：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;定义事件&lt;/li&gt;
  &lt;li&gt;实现特定的监听器接口，接收特定类型的事件&lt;/li&gt;
  &lt;li&gt;实现代码，注册（或解除）监听器作为特定事件类型的接收者&lt;/li&gt;
  &lt;li&gt;在恰当的时机触发事件&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;核心组件&quot;&gt;核心组件&lt;/h3&gt;

&lt;p&gt;在 Java 的这个事件处理机制中，包含三个核心组件：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;事件&lt;/strong&gt; 事件对象，描述相位的变化。比如在 GUI 中一个动作的点击，在 Spring Framework 中容器的启停，更多的诸如电脑的开机、关机、休眠，缓存的过期，公众号的关注、取关等等。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;事件源&lt;/strong&gt; 可以是任意对象，它具备触发事件的能力。一般在这个对象中注册（或解除）监听器，此外事件的触发通常也在这里。一个源可能产生多个不同类的事件，要为不同的事件类型分别注册事件监听器，而每个事件类型可以注册一个或多个监听器。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;事件监听器&lt;/strong&gt; 一个实现了特定接口的类，它需要实现对针对特定事件的具体处理方法，且必须被注册到该特定事件上。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;那么问题来了，我们如何优雅地触发并处理一个自定义事件呢？&lt;/p&gt;

&lt;h3 id=&quot;自定义事件&quot;&gt;自定义事件&lt;/h3&gt;

&lt;p&gt;在 Java 中自定义事件非常简单。考虑到现在各个应用中都有绑定社交账号的需求，我们就以此为例，在社交账号绑定或者解绑时简单的打印一条记录。&lt;/p&gt;

&lt;p&gt;首先定义一个事件对象，代码如下：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SocialEvent&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EventObject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serialVersionUID&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5473622737706032666L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;WECHAT_BIND&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;WECHAT_UNBIND&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;WEIBO_BIND&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;WEIBO_UNBIND&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socialType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;SocialEvent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socialType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;socialType&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socialType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getSocialType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socialType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setSocialType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socialType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;socialType&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socialType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;事件类必须是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EventObject&lt;/code&gt; 的子类。值得一提的是，事件对象通常代表一类而非一个事件，即合理的做法是将一类事件而非一个事件概念融合起来。&lt;/p&gt;

&lt;p&gt;接下来，我们实现一套事件处理逻辑，即事件监听器：&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SocialEventListener&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EventListener&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onSocialChanged&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;SocialEvent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getSocialType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SocialEvent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;WECHAT_BIND&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Wechat bind.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SocialEvent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;WECHAT_UNBIND&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Wechat unbind.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SocialEvent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;WEIBO_BIND&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Weibo bind.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SocialEvent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;WEIBO_UNBIND&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Weibo unbind.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Bad social type.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;此外，我们需要一个事件源：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Social&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;SocialEventListener&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listeners&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addListener&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;SocialEventListener&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listener&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;listeners&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;listeners&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;listeners&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;listener&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;removeListener&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;SocialEventListener&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listener&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;listeners&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;listeners&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;listener&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;emitEvent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;SocialEvent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;SocialEventListener&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listener&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listeners&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;listener&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;onSocialChanged&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;SocialEventListener&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getListeners&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listeners&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setListeners&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;SocialEventListener&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listeners&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;listeners&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listeners&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在这里，我们定义了专门的类 Social 作为事件源，事实上，可以在任意其他的类中实现事件的触发与注册逻辑，比如启动类中。&lt;/p&gt;

&lt;p&gt;顺便说一句，我们在 Java GUI 编程中，通常只需要为组件注册事件监听器，而无需考虑事件的触发逻辑，这是因为它们的事件是由系统自动触发的。&lt;/p&gt;

&lt;p&gt;具体的代码实现细节，请参考源码 &lt;a href=&quot;https://github.com/fy-demos/demo-javaevent&quot; title=&quot;Demo Source Code&quot;&gt;Demo Source Code&lt;/a&gt;&lt;/p&gt;


      &lt;/div&gt;
     
    &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6d36a9305cb718070d8bae20d3b15ee3</guid>
<title>前端项目打包版本维护命令 npm version 完全解析</title>
<link>https://toutiao.io/k/tr2itmn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entryContent&quot;&gt;&amp;#13;
        &lt;p&gt;前端项目版本的维护，通常在 &lt;code&gt;package.json&lt;/code&gt; 文件中的 &lt;code&gt;version &lt;/code&gt; 属性进行配置，当我们要在前端页面中显示的时候，可以按如下操作：&lt;/p&gt;
&lt;pre&gt;&amp;lt;script&amp;gt;&amp;#13;
import config from &#x27;../../package.json&#x27;&amp;#13;
export default {&amp;#13;
  name: &#x27;Footer&#x27;,&amp;#13;
  data() {&amp;#13;
    return {&amp;#13;
      appVersion: config.version&amp;#13;
    }&amp;#13;
  }&amp;#13;
}&amp;#13;
&amp;lt;/script&amp;gt;&lt;/pre&gt;
&lt;p&gt;那么项目迭代中，如何来维护我们的版本号？只能手动在 &lt;code&gt;package.json&lt;/code&gt; 中修改么？&lt;/p&gt;
&lt;p&gt;其实可以在打包执行命令的时候，通过命令及参数帮助我们实现自动升级版本号的目的。比如我们在打测试环境包的时候可以使用（&lt;code&gt;cross-env&lt;/code&gt; 用来指定变量 &lt;code&gt;NODE_ENV&lt;/code&gt; 的值）&lt;/p&gt;
&lt;pre&gt;&quot;scripts&quot;: {&amp;#13;
  &quot;test&quot;: &quot;npm version patch &amp;amp;&amp;amp; cross-env NODE_ENV=testing node build/build.js&quot;&amp;#13;
}&lt;/pre&gt;
&lt;p&gt;下面我们来看看 &lt;code&gt;npm version&lt;/code&gt; 命令具体的使用方式：&lt;code&gt;npm&lt;/code&gt; 采用了 &lt;code&gt;semver&lt;/code&gt; 规范作为依赖版本管理方案。&lt;code&gt;semver&lt;/code&gt; 约定一个包的版本号必须包含3个数字&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MAJOR.MINOR.PATCH&lt;/code&gt; 意思是 &lt;code&gt;主版本号.小版本号.修订版本号&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MAJOR 对应大的版本号迭代，做了不兼容旧版的修改时要更新 MAJOR 版本号&lt;/li&gt;
&lt;li&gt;MINOR 对应小版本迭代，发生兼容旧版 API 的修改或功能更新时，更新 MINOR 版本号&lt;/li&gt;
&lt;li&gt;PATCH 对应修订版本号，一般针对修复 BUG 的版本号&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当我们每次发布包的时候都需要升级版本号：&lt;/p&gt;
&lt;pre&gt;npm version major  # 大版本号加 1，其余版本号归 0&amp;#13;
npm version minor  # 小版本号加 1，修订号归 0&amp;#13;
npm version patch  # 修订号加 1&lt;/pre&gt;
&lt;p&gt;另外还有其它一些参数需要注意&lt;/p&gt;
&lt;h4&gt;&lt;code class=&quot;inline-code__InlineCode-sc-6w7ni7-0 cfZKRM&quot;&gt;allow-same-version&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;该配置项用于防止我们的升级后的版本号和升级前一样时抛出错误&lt;/p&gt;
&lt;h4&gt;&lt;code class=&quot;inline-code__InlineCode-sc-6w7ni7-0 cfZKRM&quot;&gt;git-tag-version&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;这个配置项用来是否在升级版本号后自动给该版本号打 Tag&lt;/p&gt;
&lt;pre&gt;npm version patch --allow-same-version=false --git-tag-version=true&lt;/pre&gt;
    &lt;/div&gt;&amp;#13;
&amp;#13;
    &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>53e22ba1f0c03d152beeb71e096b945f</guid>
<title>深度剖析Linux CP 原理（附源码）</title>
<link>https://toutiao.io/k/8pcizk2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span title=&quot;&quot; opera-tn-ra-cell=&quot;_$.pages:0.layers:0.comps:0.txt1&quot;&gt;&lt;section&gt;“&lt;/section&gt;&lt;/span&gt;&lt;span&gt;同学用 Linux cp&lt;/span&gt;&lt;span&gt; 命令复制了200G文件，&lt;/span&gt;&lt;span&gt;竟然一秒不到就拷贝完成了！彻底震惊+迷惑。。。。。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.0208333333333333&quot; data-type=&quot;png&quot; data-w=&quot;96&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/E7PuB8occXpoqnvYsd3GsYicWxmuCvI2p5mSKsxCognzURYY27N4Z1AUlCXytekruoDOia3GM5w8iadrELIRk4OKg/640?wx_fmt=png&quot; data-fileid=&quot;100001524&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;大纲&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.1929824561403508&quot; data-type=&quot;png&quot; data-w=&quot;114&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fMeqxiaIMiaH6OPjyIRmVSYPsDpIcBqcaRCGpZFXHqCVfldMeUMM0r8e5lEmTjvfNrbw7UtCFoXQ18E5XYeADxhw/640?wx_fmt=png&quot; data-fileid=&quot;100001528&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;cp 引发的思考&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;文件系统&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;文件的稀疏语义&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;什么是稀疏文件&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;为什么要支持稀疏语义？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;怎么创建一个稀疏文件？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;稀疏语义接口&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;稀疏文件的应用&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Go 语言实现&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;`cp` 的秘密&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;spare 三大策略&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;深入剖析 `cp  --sparse` 源码&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;cp 快速的原因&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;稀疏文件的应用&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;一起做个实验&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;知识点总结&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;后记&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5268817204301075&quot; data-type=&quot;png&quot; data-w=&quot;186&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsesdolc6YJHWRf1C8UTPs3scrsXWFoCHYsntUfbpKFrDicJ5tFbLPxBw/640?wx_fmt=png&quot; data-fileid=&quot;100001527&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;cp 引发的思考&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5520833333333334&quot; data-type=&quot;png&quot; data-w=&quot;192&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsl8Q8jryjW8fJDBj8r4A48RcHDMj7ibJfRRhRWSJUUWNTqiaibDr9dmstQ/640?wx_fmt=png&quot; data-fileid=&quot;100001525&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;cp&lt;/code&gt; 是啥 ? 是的，就是 Linux 是 Linux 下最常用的命令之一，copy 的简写，小伙伴 100% 都用过。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;cp 命令处于 Coreutils 库里，是 GNU 项目维护的一个核心项目，提供 Linux 上核心的命令。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天用 &lt;code&gt;cp&lt;/code&gt; 命令，把小伙伴惊到了，引发了我对其中细节的思考。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;背景是这样的，奇伢今天用 &lt;code&gt;cp&lt;/code&gt;  拷贝了一个 100 GiB 的文件，竟然一秒不到就拷贝完成了。一个 SATA 机械盘的写能力能到 150 MiB/s （大部分的机械盘都是到不了这个值的）就算非常不错了，所以，正常情况下，copy 一个 100G 的文件至少要 682 秒 ( 100 GiB/ 150 MiB/s )，也就是 11 分钟。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sh-4.4&lt;span&gt;# time cp ./test.txt ./test.txt.cp&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;real 0m0.107s&lt;br/&gt;user 0m0.008s&lt;br/&gt;sys 0m0.085s&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面是我们理论分析，最少要 11 分钟，实际情况却是我们 &lt;code&gt;cp&lt;/code&gt; 一秒没到就完成了工作，惊呆了，为啥呢？并且还有一个更诡异的我文件系统大小才 40 GiB，为啥里面会有一个 100 G的文件呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;分析文件&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先用 &lt;code&gt;ls&lt;/code&gt;  看一把文件，显示文件确实是 100 GiB.&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sh-4.4&lt;span&gt;# ls -lh&lt;/span&gt;&lt;br/&gt;-rw-r--r-- 1 root root 100G Mar  6 12:22 test.txt&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是再用 &lt;code&gt;du&lt;/code&gt; 命令看却只有 2M ，这是怎么回事？（且所在的文件系统总空间都没 100G 这么大）&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sh-4.4&lt;span&gt;# du -sh ./test.txt&lt;/span&gt;&lt;br/&gt;2.0M ./test.txt&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再看 &lt;code&gt;stat&lt;/code&gt; 命令显示的信息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sh-4.4&lt;span&gt;# stat ./test.txt&lt;/span&gt;&lt;br/&gt;  File: ./test.txt&lt;br/&gt;  Size: 107374182400 Blocks: 4096       IO Block: 4096   regular file&lt;br/&gt;Device: 78h/120d Inode: 3148347     Links: 1&lt;br/&gt;Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)&lt;br/&gt;Access: 2021-03-13 12:22:00.888871000 +0000&lt;br/&gt;Modify: 2021-03-13 12:22:46.562243000 +0000&lt;br/&gt;Change: 2021-03-13 12:22:46.562243000 +0000&lt;br/&gt; Birth: -&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;stat&lt;/code&gt; 命令输出解释：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Size 为 107374182400（知识点：单位是字节），也就是 100G ；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Blocks 这个指标显示为 4096（知识点：一个 Block 的单位固定是 512 字节，也就是一个扇区的大小），这里表示为 2M；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;划重点&lt;/strong&gt;：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Size 表示的是&lt;strong&gt;文件大小&lt;/strong&gt;，这个也是大多数人看到的大小；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Blocks 表示的是&lt;strong&gt;物理实际占用空间&lt;/strong&gt;；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，注意到一个新概念，&lt;strong&gt;文件大小&lt;/strong&gt;和&lt;strong&gt;实际物理占用&lt;/strong&gt;，这两个竟然不是相同的概念。为什么会这样？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里先梳理下文件系统的基础知识，文件系统究竟是怎么存储文件的？（以 Linux 上 ext系列的文件系统举例）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5268817204301075&quot; data-type=&quot;png&quot; data-w=&quot;186&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsesdolc6YJHWRf1C8UTPs3scrsXWFoCHYsntUfbpKFrDicJ5tFbLPxBw/640?wx_fmt=png&quot; data-fileid=&quot;100001526&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;文件系统&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5520833333333334&quot; data-type=&quot;png&quot; data-w=&quot;192&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsl8Q8jryjW8fJDBj8r4A48RcHDMj7ibJfRRhRWSJUUWNTqiaibDr9dmstQ/640?wx_fmt=png&quot; data-fileid=&quot;100001529&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文件系统听起来很高大上，通俗话就用来&lt;strong&gt;存数据的一个容器&lt;/strong&gt;而已，本质和你的行李箱、仓库没有啥区别。只不过文件系统存储的是数字产品而已。我有一个视频文件，我把这个视频放到这个文件系统里，下次来拿，要能拿到我完整的视频文件数据，这就是文件系统，&lt;strong&gt;对外提供的就是存取服务&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;现实的存取场景&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就跟你在火车站使用的寄存服务一样，包裹我能存进去，稍后我能取出来，就可以了。问题来了，存进去？怎么取？仔细回忆下存储行李的场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;存行李的时候&lt;/strong&gt;，是不是要登记一些个人信息？对吧，至少自己名字要写上。可能还会给你一个牌子，让你挂手上，这个东西就是为了标示每一个唯一的行李。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages __bg_gif&quot; data-fileid=&quot;100001530&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/4UtmXsuLoNd7TgWQgNicxERn4VwB6EKE0kUjRrKialanVEibboYHfvWlg90avaK05DeBeRBOBJdSQLx9KjAkbKTjA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;720&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;取行李的时候&lt;/strong&gt;，要报自己名字，有牌子的给他牌子，然后工作人员才能去特定的位置找到你的行李（不然机场那么多人，行李都长差不多，他肯定不知道你的行李是哪个）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages __bg_gif&quot; data-fileid=&quot;100001531&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/4UtmXsuLoNd7TgWQgNicxERn4VwB6EKE0ZcBIJOmZOsLHjFSZbBVicszmrGtFBTmHDB7rSpAEiczBSemlIEkiamttg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;720&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;划重点：存的时候必须记录一些关键信息（记录ID、给身份牌），取的时候才能正确定位到。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;文件系统&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回到我们的文件系统，对比上面的行李存取行为，可以做个简单的类比；&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;登记名字就是在文件系统记录文件名；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;生成的牌子就是元数据索引；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你的行李就是文件；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;寄存室就是磁盘（容纳东西的物理空间）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;管理员整套运行机制就是文件系统；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的对应并不是非常严谨，仅仅是帮助大家理解文件系统而已，让大家知道其实文件系统是非常朴实的一个东西，思想都来源于生活。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;划重点：文件系统的存储介质是磁盘，文件系统是软件层面的，是管理员，管理怎么使用磁盘空间的软件系统而已。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;空间管理&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在思考文件系统是怎么管理空间的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果，一个连续的大磁盘空间给你使用，你会怎么使用这段空间呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直观的一个想法，我把进来的数据就完整的放进去。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages __bg_gif&quot; data-fileid=&quot;100001532&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/4UtmXsuLoNd7TgWQgNicxERn4VwB6EKE0jB4yOAY2G3YXtTFJA6S4ibic83y9Nqzw1n3oOZKlzBiaQ13B31so8V9Lg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;720&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式非常容易实现，属于眼前最简单，以后最麻烦的方式。因为会造成很多空洞，明明还有很多空间位置，但是由于整个太大，形状不合适（数据大小），哪里都放不下。因为你要放一个完整的空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种不能利用的空间我们称之为碎片，准确的说是&lt;strong&gt;外部碎片&lt;/strong&gt;，这种碎片在内存池分配内存的时候最常见，产生的原理是一样的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;怎么改进？有人会想，既然整个放不进去，那就剁碎了呗。这里塞一点，那里塞一点，就塞进去了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对，思路完全正确。&lt;strong&gt;改进的方式就是切分，把空间按照一定粒度切分&lt;/strong&gt;。每个小粒度的物理块命名为 Block，每个 Block 一般是 4K 大小，用户数据存到文件系统里来自然也是要切分，存储到每一个 Block 。Block 粒度越小则外部碎片则会越少（注意：元数据量会越大），可以尽可能的利用到空间，并且完整的用户数据文件存储到磁盘上则不再连续，而是切成一个个 Block 大小的数据块存到磁盘的各个角落上。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages __bg_gif&quot; data-fileid=&quot;100001533&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/4UtmXsuLoNd7TgWQgNicxERn4VwB6EKE0iaNKQ38SMSYEW7AQqGRphjvFHDUHwsE9v559pSLUE5ic8bahJsIqCYGw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;720&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图示标号表示这个完整对象的 Block 的序号，用来复原对象用的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随之而来又有一个问题：你光会切成块还不行，取文件数据的时候，要给完整的用户数据出去，用户不管你内部怎么实现，他只想要的是最初的样子。&lt;strong&gt;所以，要有一个表记录该文件对应所有 Block 的位置&lt;/strong&gt;，要把每一个 Block 的位置记录好，取文件的时候，对照这表恢复出一个完整的块给到用户。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，写流程再完善一下就是这样子：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;先写数据：数据先按照 Block 粒度存储到磁盘的各个位置；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;再写元数据：然后把 Block 所在的各个位置保存起来，这也就是元数据，文件系统里叫做 inode（我用一本书来表示）；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages __bg_gif&quot; data-fileid=&quot;100001538&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/4UtmXsuLoNd7TgWQgNicxERn4VwB6EKE08e6IygNt3etyfW6LtxA51Uv00s6fGuaWD3Ppfq8siaBkGgn9947EM3Q/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;720&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文件读流程则是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;先读元数据，找到各个 Block 的位置；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;然后读数据，构造一个完整的文件，给到用户；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages __bg_gif&quot; data-fileid=&quot;100001536&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/4UtmXsuLoNd7TgWQgNicxERn4VwB6EKE0LBHhTcuzA6kiavuiaRrA6Y5cmBdiayNT1icpGdNIR8iaM6oXmTC4eVmibYoQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;720&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;inode/block 概念&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好，现在我们引出了两个概念：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;磁盘空间是按照 Block 粒度来划分空间的，存储数据的区域全都是 Block，我们叫做数据区域；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;文件存储不再连续存储在磁盘上，所以需要记录元数据，这个我们叫做 inode；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文件系统中，一个 inode 唯一对应一个文件，inode 的个数则是在文件系统格式化的时候就确定好了的，换言之，&lt;strong&gt;一个 local 文件系统支持的文件数是天然就有上限的&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;block 固定大小，每个 4k（大部分文件系统都是，这里不做纠结），block 意图存储打散的用户数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论是 inode 区，还是 block 区，本质上都是在线性的磁盘空间上。文件系统的空间层次如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;100001534&quot; data-ratio=&quot;0.18758085381630013&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4UtmXsuLoNd7TgWQgNicxERn4VwB6EKE04muYCXyNE41AlUZwaicNvUWxSgJcAIIIkhUdwJ1u2NGx3Aiatp0XsuLQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;773&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个文件的对应一个 inode，这个文件需要按照 Block 切分存储在磁盘上，存储的位置则由 inode 记录起来，通过 inode 则能找到 block，也就获取到用户数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在有一个新的小问题，inode 区和 block 区都是在初始化就构造好的。存储一个文件的时候，需要取一个空闲的 inode，然后把数据切分成 4k 大小存储到空闲的 block 上，对吧？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;划重点：空闲的inode，空闲的 block。&lt;/strong&gt; 这个很关键，已经存储了数据的地方不能再让写，不然会把别人的数据覆盖掉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，怎么区分空闲和已经在用的 inode ，block 呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;答案是 ：inode 区和 block 区分别需要另一张表，用来表示 inode 是否在用，block 是否在用，这个表的名字我们叫做 bitmap 表&lt;/strong&gt;。bitmap 是一个 bit 数组，用 0 表示空闲，1 表示在用，如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;100001535&quot; data-ratio=&quot;0.23858921161825727&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4UtmXsuLoNd7TgWQgNicxERn4VwB6EKE0GdQQic94CJlDD2yTTawryhBuEIBZ4ddFlmA5uHmqdQNdUfNYzclROgg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;964&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;bitmap 什么时候用呢？自然是写的时候，也就是分配 inode 或者 block 的时候，因为只有分配的时候，你才需要找空闲的空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图我为了突出本质思想，类似于超级块，块描述符都省略了，这个感兴趣可以自己扩展，这里只突出主干哈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;小结一下&lt;/strong&gt;：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;bitmap 本质是个 bit 数组，占用空间极其少，用 0 来表示空闲，1 表示在用。使用时机是在创建文件，或者写数据的时候；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;inode 则对应一个文件，里面存储的是元数据，主要是数据 block 的位置信息；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;block 里面存储的是用户数据，用户数据按照 block 大小（4k）切分，离散的分布在磁盘上。读的时候只有依赖于 inode 里面记录的位置才能恢复出完整的文件；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;inode 和 block 的总个数在文件系统格式化的时候就确定了，所以文件数和文件大小都是有上限的；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;一个文件真实的模样&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面是抽象的样子，现在我们看一个真实的 inode -&amp;gt; block 的样子。一个文件除了数据需要存储之外，一些元信心也需要存储，例如文件类型，权限，文件大小，创建/修改/访问时间等，这些信息存在 inode 中，每个文件唯一对应一个inode 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看一下 inode 的数据结构（就以 linxu ext2 为例，该结构定义在 &lt;code&gt;linux/fs/ext2/ext2.h&lt;/code&gt; 头文件中 ）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;ext2_inode&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    __le16  i_mode;     &lt;span&gt;/* File mode */&lt;/span&gt;&lt;br/&gt;    __le16  i_uid;      &lt;span&gt;/* Low 16 bits of Owner Uid */&lt;/span&gt;&lt;br/&gt;    __le32  i_size;     &lt;span&gt;/* Size in bytes */&lt;/span&gt;&lt;br/&gt;    __le32  i_atime;    &lt;span&gt;/* Access time */&lt;/span&gt;&lt;br/&gt;    __le32  i_ctime;    &lt;span&gt;/* Creation time */&lt;/span&gt;&lt;br/&gt;    __le32  i_mtime;    &lt;span&gt;/* Modification time */&lt;/span&gt;&lt;br/&gt;    __le32  i_dtime;    &lt;span&gt;/* Deletion Time */&lt;/span&gt;&lt;br/&gt;    __le16  i_gid;      &lt;span&gt;/* Low 16 bits of Group Id */&lt;/span&gt;&lt;br/&gt;    __le16  i_links_count;  &lt;span&gt;/* Links count */&lt;/span&gt;&lt;br/&gt;    __le32  i_blocks;   &lt;span&gt;/* Blocks count */&lt;/span&gt;&lt;br/&gt;    __le32  i_flags;    &lt;span&gt;/* File flags */&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    __le32  i_block[EXT2_N_BLOCKS];&lt;span&gt;/* Pointers to blocks */&lt;/span&gt;&lt;br/&gt;    __le32  i_file_acl; &lt;span&gt;/* File ACL */&lt;/span&gt;&lt;br/&gt;    __le32  i_dir_acl;  &lt;span&gt;/* Directory ACL */&lt;/span&gt;&lt;br/&gt;    __le32  i_faddr;    &lt;span&gt;/* Fragment address */&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;重点&lt;/strong&gt;：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;上面的结构 mode，uid，size，time 等信息就是我们常说的文件类型，大小，创建修改等时间元数据；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;注意到 &lt;code&gt;i_block[EXT2_N_BLOCKS]&lt;/code&gt;  这个字段，这个字段将会带你找到数据, 因为里面存储的就是 block 所在的位置，也就是 block 的编号；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再来，理解下什么叫做 block 的位置（编号）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages __bg_gif&quot; data-fileid=&quot;100001537&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/4UtmXsuLoNd7TgWQgNicxERn4VwB6EKE0LKUL4awfmoZibG3q2kPVQ276VYmiaUdgrhquw68xb44Hpic81Sww69icYA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;720&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;位置就是编号，记录位置就是记录编号，编号就是索引。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到有一个数组：&lt;code&gt;i_block[EXT2_N_BLOCKS]&lt;/code&gt;，这个数组是存储 block 位置的数组。其中 &lt;code&gt;EXT2_N_BLOCKS&lt;/code&gt; 是一个宏定义，值为 15 。也就是说，&lt;code&gt;i_block&lt;/code&gt; 是一个 15 个元素的数组，每个元素是 4 字节（32 bit）大小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子，假设我们现在有一个 6k 的文件，那么只需要 2 个 block 就可以存下了，假设现在数据就存储在编号为 3 和 101  这两个 block 上，那么如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;100001539&quot; data-ratio=&quot;0.56796875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4UtmXsuLoNd7TgWQgNicxERn4VwB6EKE0fCE7kciaQCwo1Vv1wPRCUPkcphib8gu3M8Cwg6mF0zHSUgsoIVQ3uwDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;i_block[15]&lt;/code&gt; 第一个元素存的是 3，第二个存储的是 101，其他槽位没用用到，&lt;strong&gt;由于 inode 的内存是置零分配的，所以里面的值为 0，表示没有在使用&lt;/strong&gt; . 我们通过 [3, 101] 这两个 block 就能拼装出完整的用户数据了。用户的 6k 文件组成如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一个 4k 数据在 [3*4K, 4*4K] 范围；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二个 2k 数据在 [ 101*4K, 101*4K+2K] 范围；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好，现在我们知道了&lt;strong&gt;每个定长 block 都有唯一编号&lt;/strong&gt;，我们的 &lt;strong&gt;&lt;code&gt;i_block[15]&lt;/code&gt; 数组 通过有序存储这个编号找到文件数据所在的位置&lt;/strong&gt;，并且拼装出完整文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;思考问题：区分文件的切分成 4k 块的编号和 磁盘上物理 4k 块的编号的区别。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个栗子，一个文件 12K 的大小，那么按照 4K 切分会存储到 3 个 物理 block 上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文件第 0 个 4k 存储到了 101 这个物理 block 上；文件第 1 个 4k 存储到了 30  这个物理 block 上；文件第 2 个 4k 存储到了 11  这个物理 block 上；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文件逻辑空间上的编号是从 0 开始，到 2 结束，对应存储的物理块编号分别是 101，30，11 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;思考问题：这么一个 inode 结构能够表示多大的文件？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到 &lt;code&gt;inode-&amp;gt;i_block[15]&lt;/code&gt; 是一个一维数组，里面能存 15 个元素。也就是能存 15 个 block 的编号，那么如果直接存储文件的 block 编号最大能表示 60K (15*4K) 的文件。换句话说，如果我拿着 15 个槽位全部用来存储文件的编号，这个文件系统支撑的最大文件却就是 60K。惊呆了？（注意：ext2 文件系统是可以创建 4T 以内的文件的！！）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那我们自然会思考，怎么解决呢？怎么才能支撑更大的文件？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最直接思考就是用更大的数组，把 &lt;code&gt;inode-&amp;gt;i_block&lt;/code&gt;  数组变得更大。比如，如果你想要支持 100G 的文件：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，需要 i_block 数组大小为 26214400 （计算公式：&lt;code&gt;100\*1024\*1024/4&lt;/code&gt;），也就是要分配一个 &lt;code&gt;i_block[26214400]&lt;/code&gt;  的数组。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个编号占用 4 字节，这个数组就占用 100M 的空间（计算公式：(&lt;code&gt;26214400\*4)/1024/1024&lt;/code&gt;）。&lt;span&gt;100M ！这里就有点夸张了，注意到 &lt;/span&gt;&lt;code&gt;i_block&lt;/code&gt;&lt;span&gt; 只是一个 inode 内部的字段，是一个静态分配的数组，也就是说，&lt;/span&gt;&lt;strong&gt;这个文件系统为了支持最大 100G 的文件存入，每一个 inode 都要占用 100M 的内存，就算你是一个 1K 的文件，inode 也会占用这么大的内存空间&lt;/strong&gt;&lt;span&gt;。并且，这种方案扩展性差，支持的文件 size 越大，&lt;/span&gt;&lt;code&gt;i_block[N]&lt;/code&gt;&lt;span&gt; 消耗内存情况越严重。&lt;/span&gt;&lt;span&gt;这是无法接受的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;思考问题：&lt;span&gt;怎么才能让你既能表示更大的文件，又能不浪费占用空间？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们仔细分析这个问题，你会发现，这里有 2 个核心问题：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一点，核心在于浪费内存空间（关键点是要保证 inode 内存结构的稳定，无论文件怎么变，inode 结构本身不能变）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二点，仔细思考你会发现，无论是什么神仙方案，如果你要存储一个按照 4k 切分的 100G 文件，都是需要 100M 的空间来存储索引（ block 编号），但是 99.99% 的文件可能都没有这么大；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们前面用一个大数组来一把存储 block 编号的方案固然简单，但是问题在于太过死板。核心问题在于存储 block 编号的数组是预分配的，为了还没有发生并且 99% 场景都不会发生的事情（文件大小达到 100G），却不管三七二十一，提前准备好了完整的 block 索引数组，&lt;strong&gt;预分配就是浪费的根源&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么知道了这两个问题，下一步分析下一个个解决：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;索引存磁盘&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;问题一的解决：索引存磁盘&lt;/strong&gt;：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然问题在于浪费内存，inode 内存分配不灵活，那就可以看把 &lt;code&gt;inode-&amp;gt;i_block&lt;/code&gt; 下放到磁盘。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为磁盘的空间比内存大了不止一个量级。100M 对内存来说&lt;strong&gt;很大&lt;/strong&gt;，对磁盘来说&lt;strong&gt;很小&lt;/strong&gt;。换句话说，用把用户数据所在的 block 编号存到磁盘上去，这个也需要物理空间，使用的也是 block 来存储，只不过这种 block 存储的是 block 编号信息，而不是用户数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么我们怎么通过 inode 找到用户数据呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为这个 block 本身也有编号，我们则需要把这个存储用户 block 编号的 block 所在块的编号存储在 &lt;code&gt;inode-&amp;gt;i_block[15]&lt;/code&gt; 里，当读数据的时候，我们需要先找到这个存储编号的 block，然后再通过里面存储的用户数据所在的 block 编号找到用户所在的 block ，去读数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个&lt;strong&gt;存储用户 block 编号的 block 所在块的编号&lt;/strong&gt;我们叫做&lt;strong&gt;间接索引&lt;/strong&gt;，然后我们根据跳转的次数可以分类成一级索引，二级索引，三级索引。顾名思义，一级索引就是跳转 1 次就能定位到用户数据，二级索引就是跳转 2 次，三级索引就是跳转 3 次才能定位到用户数据。那么 &lt;code&gt;inode-&amp;gt;i_block[15]&lt;/code&gt;  里面存储的可以直接定位到用户数据的 block 就是&lt;strong&gt;直接索引&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;终于可以说回 ext2 的使用了，ext2 的 &lt;code&gt;inode-&amp;gt;i_block[15]&lt;/code&gt; 数组。知识点来了，按照约定，这 15 个槽位分作 4 个不同类别来用：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;前 12 个槽位（也就是 0 - 11 ）我们成为&lt;strong&gt;直接索引&lt;/strong&gt;；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第 13 个位置，我们称为 &lt;strong&gt;1 级索引&lt;/strong&gt;；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第 14 个位置，我们称为 &lt;strong&gt;2 级索引&lt;/strong&gt;；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第 15 个位置，我们称为 &lt;strong&gt;3 级索引&lt;/strong&gt;；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;100001540&quot; data-ratio=&quot;1.3747178329571106&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4UtmXsuLoNd7TgWQgNicxERn4VwB6EKE0Gicqy7iaDaf0M6sgFjAwZY3JvxJuNjiauK63eoqUwzMY8ShUE6O1heNIw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;443&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好，那我们在来看下直接索引，一级，二级，三级索引的表现力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;直接索引&lt;/strong&gt;：能存 12 个 block 编号，每个 block 4K，就是 48K，也就是说，48K 以内的文件，只需要用到 &lt;code&gt;inode-&amp;gt;i_block[15]&lt;/code&gt;  前 12 个槽位存储编号就能完全 hold 住。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;一级索引&lt;/strong&gt;：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;inode-&amp;gt;i_block[12]&lt;/code&gt; 这个位置存储的是一个一级索引，也就是说这里存储的编号指向的 block 里面存储的也是 block 编号，里面的编号指向用户数据。一个 block 4K，每个元素 4 字节，也就是有 1024 个编号位置可以存储。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，一级索引能寻址 4M（1024 * 4K）空间 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;二级索引&lt;/strong&gt;：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;二级索引是在一级索引的基础上多了一级而已，换算下来，有了 4M 的空间用来存储用户数据的编号。所以二级索引能寻址 4G (4M/4 * 4K) 的空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;三级索引&lt;/strong&gt;：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;三级索引是在二级索引的基础上又多了一级，也就是说，有了 4G 的空间来存储用户数据的 block 编号。所以二级索引能寻址 4T （4G/4 * 4K） 的空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;最后，看一眼完整的表示图：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;100001541&quot; data-ratio=&quot;0.61328125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4UtmXsuLoNd7TgWQgNicxERn4VwB6EKE01V9FVibSGa4nesnNIGCSTicp91q26auJDFP6XJETpjLxnQtyiab2vYYKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，在我们 ext2 的文件系统上，通过这种间接块索引的方式，最大能支撑的文件大小 = 48K + 4M + 4G + 4T ，约等于 4 T。文件系统最大支撑 16T 空间，因为 4 Byte 的整形最大数就是 &lt;code&gt;2^32=4294967296&lt;/code&gt; ， 乘以 4K 就等于 16 T。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ext2 文件系统支持的最大单文件大小和文件系统最大容量就是这么算出来的（温馨提示：ext4 文件系统不仅兼容间接块的实现，还使用的是 extent 模式来管理的空间，最大支持单文件 16 TB ，文件系统最大 1 EB）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;思考：这种多级索引寻址性能表现怎么样？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在不超过 12 个数据块的小文件的寻址是最快的，访问文件中的任意数据理论只需要两次读盘，一次读 inode，一次读数据块。访问大文件中的数据则需要最多五次读盘操作：inode、一级间接寻址块、二级间接寻址块、三级间接寻址块、数据块。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;多级索引和后分配&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;问题二解决：多级索引和后分配&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;一级索引不够，表现力太差，预留空间又太浪费，不预留空间又无法扩展，怎么解决？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然问题在于预分配，我们使用后分配（瘦分配，或精简分配）解决。&lt;strong&gt;也就是说用户文件数据有多大，我才分配出多大的数组&lt;/strong&gt;。举个例子，我们存储 100 G 的文件，那么就要用到三级索引块，最多分配 26214400 个槽位的数组（因为要 26214400 个 block）。如果是存储 6K 的文件，那么只需要 2 个槽位的数组。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;索引数组的后分配&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后分配这里说的是 block 索引编号数组的后分配，需要用到的时候才分配，而不是说，现在用户存储一个 1k 的文件，我上来就给他分配一个 100M 的索引数组，只是为了以后这个文件可能增长到 100 G。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;数据的后分配&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然这里说到，关于后分配还有一个层面，就是数据所占的空间也是用到了才分配，这个也就是涉及到今天 cp的秘密的核心问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;实际的栗子&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先看下下正常的文件写入要做的事情（注意这里只描述主干，实际流程可能，有优化）：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;创建一个文件，这个时候分配一个 inode；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在 [ 0，4K ] 的位置写入 4K 数据，这个时候只需要 一个 block 假设编号 102，把这个编号写到 &lt;code&gt;inode-&amp;gt;i_block[0]&lt;/code&gt; 这个位置保存起来；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在 [ 1T，1T+4K ] 的位置写入 4K 数据，这个时候需要分配一个 block 假设编号 7，因为这个位置已经落到三级索引才能表现的空间了，所以需要还需要分配出 3 个索引块；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;写入完成，close 文件；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里解释下文件偏移位置 [1T, 1T+4K] 为什么落到三级索引。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;offset 为 1T，按照 4K 切分，也就是 block 268435456 块（注意这个是虚拟文件块，不是物理位置）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;先算出范围：直接索引的范围是 [0, 11] 个，一级索引 [12, 1035]，二级索引 [1036, 1049611], 三级索引 [1049612, 1074791435]，（有人如果不知道怎么来的话，可以往前看看 inode 的结构，直接索引 12个，一级索引 1024 个，二级 1M 个，三级 1G 个，然后算出来的）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;268435456 落在三级索引 [1049612, 1074791435] 这个范围；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;实际存储如图&lt;/strong&gt;：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;计算索引：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;12 + 1024 + 1024 * 1024 + 1024 * 1024 * 254 + 1024 * 1022 + 1012 =  268435456&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际的物理分配如图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;100001542&quot; data-ratio=&quot;0.6143790849673203&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4UtmXsuLoNd7TgWQgNicxERn4VwB6EKE0aSgCE3ibBEQl7LVHEiaW84kk4rTsItSwCHVgdgGQVg5JXibDg57AKXuvA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1224&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为偏移已经用到了 3 级索引，所以除了用户数据的两个 block ，中间还需要 3 个间接索引 block 分配出来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果要读 [1T, 1T+4K] 这个位置的数据怎么办？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;流程如下&lt;/strong&gt;：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;计算 offset 得出在第 268435456 的位置；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;读出三级索引 &lt;code&gt;inode-&amp;gt;i_block[14]&lt;/code&gt; 里存储的 block 编号，找到对应的物理 block，这个是第一级的 block；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;然后读该 block 的第 254+1 个槽位里的数据，里面存储的是第二级的 block 编号，把这个编号读出来，通过这个编号找到对应的物理 block；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;读该 block 的第 1022 +1 个操作的数据，里面存储的是第三级的 block 编号，通过这个编号可以找到物理 block 的数据，里面存储的是用户数据所在 block 的编号；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;读该 block 第 1012+1 个槽位里存储的编号，找到物理 block，这个 block 里存的就是用户数据了；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个时候，我们的文件看起来是超大文件，size 等于 1T+4K ，但里面实际的数据只有 8 K，位置分别是  [ 0，4K ] ，[ 1T，1T+4K ]。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;重点：文件 size 只是 inode 里面的一个属性，实际物理空间占用则是要看用户数据放了多少个 block 。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;划重点：没写数据的地方不用分配物理 block 块&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;没写数据不分配物理块？那是什么？那就是我们下面要说的稀疏文件。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5268817204301075&quot; data-type=&quot;png&quot; data-w=&quot;186&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsesdolc6YJHWRf1C8UTPs3scrsXWFoCHYsntUfbpKFrDicJ5tFbLPxBw/640?wx_fmt=png&quot; data-fileid=&quot;100001543&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;文件的稀疏语义&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5520833333333334&quot; data-type=&quot;png&quot; data-w=&quot;192&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsl8Q8jryjW8fJDBj8r4A48RcHDMj7ibJfRRhRWSJUUWNTqiaibDr9dmstQ/640?wx_fmt=png&quot; data-fileid=&quot;100001545&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;什么是稀疏文件&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;终于到我们文件的稀疏语义了，稀疏语义什么意思？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;稀疏文件英文名 sparse file 。稀疏文件本质上就是计算机文件，用户不感知，文件系统支持稀疏文件只是为了更有效率的使用磁盘空间而已。稀疏文件就是后分配空间的一种实现形式，做到真正用时才分配，最大效率的利用磁盘空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就以上面举的栗子，文件大小 1T，但是实际数据只有 8K，这种就是稀疏文件，&lt;strong&gt;逻辑大小和实际物理空间是可以不等的&lt;/strong&gt;。文件大小只是一个属性，文件只是数据的容器，没有用户数据的位置可以不分配空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;为什么要支持稀疏语义？&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是以上面 1T 的文件举例，如果这 1T 的文件只有首尾分别写了 4K 的数据，而文件系统却要分配 1T 的物理空间，&lt;strong&gt;这里将带来巨大的浪费&lt;/strong&gt;。何不等存了用户数据的时候再分配了，实际数据有多少，才去分配多大的 block ，何必着急的预分配呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;后分配本着用多少给多少的原则，尽量有效的利用空间。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后分配还有一个优点，这也减少了首次写入的时间，怎么理解？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为，如果文件大小 1T，就要分配 1T 的空间，那么初始分配需要写入全零到空间，否则上面的数据可能是随机数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;对于稀疏文件空洞的地方，不占用物理空间，但要保证读的时候返回全 0 数据的语义，即可。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;又一个知识点：有时候稀疏文件的空洞和用户真正的全 0 数据是无法区分的，因为对外表现是一样的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;稀疏文件也要文件系统支持，并不是所有的文件系统都支持稀疏语义，比如 ext2 就没有，ext4 才有稀疏语义，支持的标志是实现文件系统的 fallocate 接口。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;怎么创建一个稀疏文件？&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以使用 truncate 命令在一个 ext4 的文件系统创建一个文件。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;truncate -s 100G  test.txt&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;你 &lt;code&gt;ls -lh ./test.txt&lt;/code&gt; 命令看会发现是一个 100 G 的文件；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;但是 &lt;code&gt;du -sh ./test.txt&lt;/code&gt;  会发现是一个 0 字节的文件；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;stat ./test.txt&lt;/code&gt; 会发现是 &lt;code&gt;Size: 107374182400 Blocks: 0&lt;/code&gt; 的文件；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是一个典型的稀疏文件。size 只是文件的逻辑大小，实际的物理空间占用还是得看 Blocks 这个数值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面这种 1T 的文件，因为只写了头尾 8K 数据，所以只需要分配 2 个 block 存储用户数据即可。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;100001546&quot; data-ratio=&quot;0.6143790849673203&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4UtmXsuLoNd7TgWQgNicxERn4VwB6EKE0aSgCE3ibBEQl7LVHEiaW84kk4rTsItSwCHVgdgGQVg5JXibDg57AKXuvA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1224&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好，我们再深入思考下，文件系统为什么能做到这个？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也是为什么理解稀疏语义要先了解文件系统的实现的原因。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先，最关键的是把磁盘空间切成离散的、定长的 block 来管理；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;然后，通过 inode 能查找到所有离散的数据（保存了所有的索引）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后，实现索引块和数据块空间的后分配；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这三点是层层递进的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;稀疏语义接口&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了知识的完整性，简要介绍稀疏语义的几个接口：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;preallocate（预分配）：提供接口可以让用户预占用文件内指定范围的物理空间；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;punch hole（打洞）：提供接口可以让用户释放文件内指定范围的物理空间；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两个操作刚好相反。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;预分配的意思是？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就是说，当你创建一个 1T的文件，如果你没写数据，这个时候其实没有分配物理空间的，支持稀疏语义的文件系统会提供一个 fallocate 接口给你，让你实现预分配，也就是说把这 1T 的物理空间现在就分配出来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;思考：这个有什么好处呢？&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一，如果你命中注定要 1T 的空间，预分配是有好处的，把空间分配的工作量集中在初始化的时候一把做了，避免了实时现场分配的开销；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二，如果不提前占坑，很有可能等你想要的时候已经没有空间可占用了。所以你把物理空间先占好，就可以安心使用了；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;linux 提供了一个 fallocate 命令，可以用来预分配空间。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;fallocate -o 0 -l 4096 ./test.txt&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个命令的意思就是给 &lt;code&gt;text.txt&lt;/code&gt; 这个文件 [0, 4K] 的位置分配好物理空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;打洞（punch hole） 是干啥的呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个调用允许你把已经占用的物理空间释放掉，从而达到快速释放的目的。这种操作在虚拟机镜像的场景用得多，通常用于快速释放空间，punch hole 能够让业务更有效的利用空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;linux 提供了一个 fallocate 命令也可以用来 punch hole 空间。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;fallocate -p -o 0 -l 4096 ./test.txt&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个命令的意思是把 &lt;code&gt;test.txt&lt;/code&gt;  [ 0,  4K ] 的物理空间释放掉。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;Go 语言实现&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;稀疏文件本身和编程语言无具体关系，可以用任何语言实现，我下面以 Go 为例，看下稀疏文件的预分配和打洞（punch hole）是怎么实现的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;预分配实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;PreAllocate&lt;/span&gt;&lt;span&gt;(f *os.File, sizeInBytes &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;// use mode = 1 to keep size&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;// see FALLOC_FL_KEEP_SIZE&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; syscall.Fallocate(&lt;span&gt;int&lt;/span&gt;(f.Fd()), &lt;span&gt;0x0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;int64&lt;/span&gt;(sizeInBytes))&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;punch hole 实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//  mode 0 change to size                  0x0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//  FALLOC_FL_KEEP_SIZE                  = 0x1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// FALLOC_FL_PUNCH_HOLE                 = 0x2&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;PunchHole&lt;/span&gt;&lt;span&gt;(file *os.File, offset &lt;span&gt;int64&lt;/span&gt;, size &lt;span&gt;int64&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   err := syscall.Fallocate(&lt;span&gt;int&lt;/span&gt;(file.Fd()), &lt;span&gt;0x1&lt;/span&gt;|&lt;span&gt;0x2&lt;/span&gt;, offset, size)&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; err == syscall.ENOSYS || err == syscall.EOPNOTSUPP {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; syscall.EPERM&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，本质上都是系统调用 &lt;code&gt;fallocate&lt;/code&gt; ，然后带不同的参数而已。指定文件偏移和长度，就能预分配物理空间或者释放物理空间了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有一个知识点：punch hole 的调用要保证 4k 对齐才能释放空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子，比如：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;punch hole [0, 6k] 的数据，你会发现只有 [0, 4k] 的数据物理块被释放了，[4k, 6k] 所占的 4k 物理块还占着空间呢。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个很容易理解，因为磁盘的物理空间是划分成 4k 的 block，这个是最小单位了，不能再分了，你无法切割一个最小的单位。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;值得注意的是，就算你没有 4k 对齐的发送调用，fallocate 也不会报错，这个请注意了。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5268817204301075&quot; data-type=&quot;png&quot; data-w=&quot;186&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsesdolc6YJHWRf1C8UTPs3scrsXWFoCHYsntUfbpKFrDicJ5tFbLPxBw/640?wx_fmt=png&quot; data-fileid=&quot;100001547&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;cp 的秘密&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5520833333333334&quot; data-type=&quot;png&quot; data-w=&quot;192&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsl8Q8jryjW8fJDBj8r4A48RcHDMj7ibJfRRhRWSJUUWNTqiaibDr9dmstQ/640?wx_fmt=png&quot; data-fileid=&quot;100001544&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;铺垫了这么久的基础知识，终于到我们的 cp 命令的解密了。回到最开始的问题，cp 一个 100G 的文件 1 秒都不到，为什么这么快？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说到现在，这个问题就很清晰了，&lt;strong&gt;这个 100G 的文件是个稀疏文件，盲猜一手：cp 的时候只拷贝了有效数据，空洞是直接跳过的。&lt;/strong&gt; 往前看 &lt;code&gt;stat&lt;/code&gt; 命令和 &lt;code&gt;ls&lt;/code&gt; 命令显示的差距就知道了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们具体看一下 cp 的实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;cp 有一个参数 &lt;code&gt;--sparse&lt;/code&gt; 很有意思，&lt;code&gt;sparse&lt;/code&gt; 这个参数控制这 cp 命令对稀疏文件的行为，这个参数有三个值可选：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;--sparse=always&lt;/code&gt; ：空间最省；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;--sparse=auto&lt;/code&gt; ：默认值，速度最快；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;--sparse=never&lt;/code&gt; ：吭呲吭呲 copy，最傻；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;cp 默认的时候，&lt;code&gt;sparse&lt;/code&gt; 是 &lt;code&gt;auto&lt;/code&gt; 策略。auto，always，never 分别是什么策略呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;spare 三大策略&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;auto 策略&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认的情况下，cp 会检查源文件是否具有稀疏语义，对于不占物理空间的位置，目标文件不会写入数据，从而形成空洞。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，对于我们的例子，真实的就只进行了 2M 的 IO ，预期的 100G 文件，只拷贝了 2M 的数据，自然飞快了，自然惊艳所有人。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;auto 是默认策略，使用该模式的时候，cp 内部实现是通过系统调用拿到文件的空洞位置情况，然后对这些位置目标文件会保持空洞。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;注意，不会对非空洞位置的文件内容做判断，如果用户数据占用了物理块，但是是全 0 数据，这种情况下，auto 模式不会识别，会以全零的数据写入到目标文件。&lt;/span&gt;&lt;/strong&gt;这个是跟 always 最大的区别。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;auto 策略下 cp 的文件的文件，size，物理 block 数量都和源文件一致。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;always&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式是最激进的，追求空间的最小化。&lt;strong&gt;在 auto 的基础之上，还多做了一步：对源文件内容做了判断。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在读出源数据之后，就算这块数据位置在源文件不是空洞，也会自己在程序里做一次判断，判断是否是全 0 的数据，如果是，那么也会在目标文件里对应的位置创建空洞（不分配物理空间）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式则会导致源文件的 size 和目标文件一样（三种策略下，文件size 都是不变的），但是 物理 blocks 占用却更小。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;never&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式最保守，实现也最简单。不管源文件是否是稀疏文件，cp 完全不感知，读出来的任何数据都直接写入目标文件。也就是说，如果一个 100G 的文件，就算只占用了 4K 的物理空间，也会创建出一个 100G 的目标文件，物理空间就占用 100G。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，如果你 cp 的时候带了这个参数，那么将会非常非常慢。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;深入剖析 cp --sparse 源码&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的都是结论，现在我们通过源码再深入理解下 cp 的原理，一起围观下 cp 的代码实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;cp 命令源码在 GNU 项目的 coreutils 项目中，为 Linux 提供外围的基础命令工具。看似极简的 cp，其实代码实现还挺有趣的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;cp 的入口代码在 &lt;code&gt;cp.c&lt;/code&gt; 文件中（以下基于 coreutils 8.30 版本）：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以一个 cp 文件的命令举例，我们一起走一下源码视角的旅途：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;cp ./src.txt dest.txt&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，在 main 函数里初始化参数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;      &lt;span&gt;switch&lt;/span&gt; (c)&lt;br/&gt;        {&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; SPARSE_OPTION:&lt;br/&gt;          x.sparse_mode = XARGMATCH (&lt;span&gt;&quot;--sparse&quot;&lt;/span&gt;, optarg,&lt;br/&gt;                                     sparse_type_string, sparse_type);&lt;br/&gt;          &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里会根据用户传入的参数，对应翻译成一个枚举值，该枚举值就是 &lt;code&gt;SPARSE_NEVER&lt;/code&gt;，&lt;code&gt;SPARSE_AUTO&lt;/code&gt;，&lt;code&gt;SPARSE_ALWAYS&lt;/code&gt; 其中之一，默认用户没带这个参数的话，就会是 &lt;code&gt;SPARSE_AUTO&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt; Sparse_type &lt;span&gt;const&lt;/span&gt; sparse_type[] =&lt;br/&gt;{&lt;br/&gt;  SPARSE_NEVER, SPARSE_AUTO, SPARSE_ALWAYS&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，main 函数里赋值了 &lt;code&gt;x.sparse_mode&lt;/code&gt; 这个参数，这个参数也是稀疏文件行为的指导参数，后面怎么处理稀疏文件，就依赖于这个参数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面就是依次调用 &lt;code&gt;do_copy&lt;/code&gt; ，&lt;code&gt;copy&lt;/code&gt;，&lt;code&gt;copy_internal&lt;/code&gt; 函数，&lt;code&gt;do_copy&lt;/code&gt;，&lt;code&gt;copy&lt;/code&gt; 这两个函数就是处理一些封装，校验，包括涉及目录的一些逻辑，跟我们本次稀疏文件解密关系不大，直接略过。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;copy_internal&lt;/code&gt; 则是一个巨长的函数，里面的逻辑多数是一些兼容性，适配场景的考虑，也和本次关系不大。对于一个普通文件( &lt;code&gt;regular&lt;/code&gt; 类型) 最终调用到 &lt;code&gt;copy_reg&lt;/code&gt; 函数，才是普通文件 copy 的实现所在。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (S_ISREG (src_mode)&lt;br/&gt;           || (x-&amp;gt;copy_as_regular &amp;amp;&amp;amp; !S_ISLNK (src_mode)))&lt;br/&gt;    {&lt;br/&gt;      copied_as_regular = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;// 普通文件的拷贝&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (! copy_reg (src_name, dst_name, x, dst_mode_bits &amp;amp; S_IRWXUGO,&lt;br/&gt;                      omitted_permissions, &amp;amp;new_dst, &amp;amp;src_sb))&lt;br/&gt;        &lt;span&gt;goto&lt;/span&gt; un_backup;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;普通文件的 copy 就是从函数 &lt;code&gt;copy_reg&lt;/code&gt; 才真正开始的。在这个函数里，首先 &lt;code&gt;open&lt;/code&gt; 源文件和目标文件的句柄，然后进行数据拷贝。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;br/&gt;&lt;span&gt;copy_reg&lt;/span&gt;&lt;span&gt;( ... )&lt;/span&gt; &lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 确认要拷贝数据&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (data_copy_required)&lt;br/&gt;    {&lt;br/&gt;      &lt;span&gt;// 获取到块大小，buffer 大小等参数&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;size_t&lt;/span&gt; buf_alignment = getpagesize ();&lt;br/&gt;      &lt;span&gt;size_t&lt;/span&gt; buf_size = io_blksize (sb);&lt;br/&gt;      &lt;span&gt;size_t&lt;/span&gt; hole_size = ST_BLKSIZE (sb);&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;bool&lt;/span&gt; make_holes = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;// 关键函数来啦，is_probably_sparse 函数就是用来判断源文件是否是稀疏文件的；&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;bool&lt;/span&gt; sparse_src = is_probably_sparse (&amp;amp;src_open_sb);&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (S_ISREG (sb.st_mode))&lt;br/&gt;        {&lt;br/&gt;          &lt;span&gt;if&lt;/span&gt; (x-&amp;gt;sparse_mode == SPARSE_ALWAYS)&lt;br/&gt;            &lt;span&gt;// sparse_always 模式，也是追求极致空间效率的策略；&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;// 所以这种方式不管源文件是否真的是稀疏文件，都会生成稀疏的目标文件；&lt;/span&gt;&lt;br/&gt;            make_holes = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;          &lt;span&gt;// 如果是 sparse_auto 的策略，并且源文件是稀疏文件，那么目标文件也会是稀疏文件（也就是可以有洞洞的文件）&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;if&lt;/span&gt; (x-&amp;gt;sparse_mode == SPARSE_AUTO &amp;amp;&amp;amp; sparse_src)&lt;br/&gt;            make_holes = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;// 如果到这里判断不是目标不会是稀疏文件，那么就使用更有效率的方式来 copy，比如用更大的 buffer 来装数据，一次 copy 更多；&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (! make_holes)&lt;br/&gt;        {&lt;br/&gt;            &lt;span&gt;// 略&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;// 源文件是稀疏文件的情况下，可以使用 extent_copy 这种更有效率的方式进行拷贝。&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (sparse_src)&lt;br/&gt;        {&lt;br/&gt;          &lt;span&gt;if&lt;/span&gt; (extent_copy (source_desc, dest_desc, buf, buf_size, hole_size,&lt;br/&gt;                           src_open_sb.st_size,&lt;br/&gt;                           make_holes ? x-&amp;gt;sparse_mode : SPARSE_NEVER,&lt;br/&gt;                           src_name, dst_name, &amp;amp;normal_copy_required))&lt;br/&gt;            &lt;span&gt;goto&lt;/span&gt; preserve_metadata;&lt;br/&gt;            &lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;// 如果源文件判断不是稀疏文件，那么就使用标准的 sparse_copy 函数来拷贝。&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (! sparse_copy (source_desc, dest_desc, buf, buf_size,&lt;br/&gt;                         make_holes ? hole_size : &lt;span&gt;0&lt;/span&gt;,&lt;br/&gt;                         x-&amp;gt;sparse_mode == SPARSE_ALWAYS, src_name, dst_name,&lt;br/&gt;                         UINTMAX_MAX, &amp;amp;n_read,&lt;br/&gt;                         &amp;amp;wrote_hole_at_eof))&lt;br/&gt;        {&lt;br/&gt;          return_val = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;          &lt;span&gt;goto&lt;/span&gt; close_src_and_dst_desc;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;// 略&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上对于 copy_reg 的代码我做了极大的简化，把关键流程梳理了出来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;小结&lt;/strong&gt;：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;copy_reg 函数才是真正 cp 一个普通文件的逻辑所在，源文件的打开，目标文件的创建和数据的写入都在这里；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;拷贝之前，会先用 &lt;code&gt;is_probably_sparse&lt;/code&gt; 函数来判断源文件是否属于稀疏文件；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果是 sparse always 模式，那么无论源文件是否是稀疏文件，那么都会尝试生成稀疏的目标文件（这种模式下，源文件如果是非稀疏文件，会判断是否是全 0 数据，如果是的话，还是会在目标文件中打洞）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果是 sparse auto 模式，源文件是稀疏文件，那么生成的目标文件也会是稀疏文件；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;源文件为稀疏文件的时候，会尝试使用效率更高的 &lt;code&gt;extent_copy&lt;/code&gt; 函数来拷贝数据；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果是 never 模式，那么是调用 &lt;code&gt;sparse_copy&lt;/code&gt; 函数来拷贝数据，并且里面不会尝试 punch hole，拷贝过程会非常慢，会生成一个实打实的目标文件，物理空间占用完全和文件size一致；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的小结，提到几个有意思的点，我们一起探秘下几个问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;问题一：&lt;code&gt;is_probably_sparse&lt;/code&gt; 函数是怎么来判断源文件的？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看了源码你会发现，非常简单，其实就是 stat 一下源文件，拿到文件大小 size，还有物理块的占用个数（假设物理块 512 字节），比一下就知道了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;br/&gt;&lt;span&gt;is_probably_sparse&lt;/span&gt; &lt;span&gt;(struct stat &lt;span&gt;const&lt;/span&gt; *sb)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (HAVE_STRUCT_STAT_ST_BLOCKS&lt;br/&gt;          &amp;amp;&amp;amp; S_ISREG (sb-&amp;gt;st_mode)&lt;br/&gt;          &amp;amp;&amp;amp; ST_NBLOCKS (*sb) &amp;lt; sb-&amp;gt;st_size / ST_NBLOCKSIZE);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子，文件大小 size 为 100G，物理占用块 8 个，那么 100G/512字节 &amp;gt; 8，所以就是稀疏文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文件大小 size 为 4K，物理占用块 8 个，那么 4K/512字节 == 8，所以就不是稀疏文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;问题二：&lt;code&gt;extent_copy&lt;/code&gt; 为什么更有效率？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关键在于里面的一个子函数 &lt;code&gt;extent_scan_read&lt;/code&gt; 的实现，&lt;code&gt;extent_scan_read&lt;/code&gt; 位于 extent-scan.c 文件中。&lt;code&gt;extent_scan_read&lt;/code&gt; 位于 &lt;code&gt;extent_copy&lt;/code&gt; 开头，用来获取到源文件的空洞位置信息。这个就是 &lt;code&gt;extent_copy&lt;/code&gt; 高效率的根本原因。&lt;code&gt;extent_scan_read&lt;/code&gt; 通过这个函数能够拿到文件的空洞的详细位置，那么拷贝数据的时候，就能针对性的跳过这些空洞，只拷贝有效的位置即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，不禁又要问， &lt;code&gt;extent_scan_read&lt;/code&gt; 又是怎么实现的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;答案是：ioctl 系统调用，搭配 FS_IOC_FIEMAP 参数，也就是 fiemap 的调用。&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;/* Call ioctl(2) with FS_IOC_FIEMAP (available in linux 2.6.27) to obtain a map of file extents excluding holes.  */&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;fiemap 这个是一个非常关键的特性，ioctl 搭配 FS_IOC_FIEMAP 这个函数能够拿到文件的物理空间分配关系，能够让用户知道长达 100G 的文件中，哪些位置才是真正有物理块存储数据的，哪些位置是空洞。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个特性则由文件系统提供，也就是说，只有文件系统提供了这个对外接口，我们才能拿得到，比如 ext4，就支持这个接口，ext2 就没有。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;问题二：&lt;code&gt;sparse_copy&lt;/code&gt; 为什么慢，里面哟是做了啥？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个函数是标准的 copy 函数，对比 &lt;code&gt;extent_copy&lt;/code&gt; 来说，没有 fiemap 的加持，那么这个函数就自己判断是否是空洞，怎么判断？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sparse_copy&lt;/code&gt; 认为，只要大块连续的全 0 数据，那么就认为是空洞，目标文件就不用写入，直接打洞即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;判断是否全 0 的函数是&lt;code&gt;is_nul&lt;/code&gt;，位于 &lt;code&gt;system.h&lt;/code&gt; 头文件中，实现非常简单，就是看整个内存块是否全部为 0 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子，现在 &lt;code&gt;sparse_copy&lt;/code&gt; 从源文件里读出 4k 的数据，发现全都是 0，那么目标文件对应的位置就不会写入，而是直接 punch hole 打洞，节省空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是注意了，这种行为只有在激进的 &lt;code&gt;sparse always&lt;/code&gt; 策略才是这样的。如果是其他策略，&lt;code&gt;sparse_copy&lt;/code&gt; 不会做这样做，而是老老实实的拷贝数据，哪怕是全 0 的数据，也要如实的写入到目标文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;所以，always 模式下，目标文件所占物理空间比源文件小的根本原因就在于 &lt;code&gt;sparse_copy&lt;/code&gt; 这个函数的实现。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;cp 快速的原因&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;梳理到这里，cp 的秘密已经彻底揭开了，cp 一个 100G 的文件为什么那么快？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为源文件是稀疏文件啊，文件看似 100G，实际只占用了 2M 的物理空间。文件系统将文件大小和物理空间占用这两个概念解耦，使得有更灵活的使用姿势，更有效的使用物理空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;cp 默认的情况下，通过文件系统提供的 fiemap 接口，获取到文件所有的空洞信息，然后跳过这些空洞，只 copy 有效的数据，极大的减少了磁盘 io 的数据量，所以才那么快。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结下 &lt;code&gt;cp --sparse&lt;/code&gt; 三个参数的特点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;auto 模式：默认模式，最一致的模式（如果没有用户全0 块数据，那么可能也是速度最快的），会根据源文件的实际空间占用复制数据，目标文件和源文件一致。无论是文件 size 还是物理 blocks；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;always 模式：追求最小空间占用的模式，就算源文件不是稀疏文件，而仅仅是有些连续大块的全 0 数据，也会尝试在目标文件上 punch hole，从而节省空间，&lt;strong&gt;这种方式会导致目标文件的物理 blocks 可能比源文件要小&lt;/strong&gt;；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;never 模式：最低效，速度最慢的方式。这种方式无论源文件是啥，全都是实打实的复制，不管是空洞还是全 0 数据，都会在目标文件写入；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;动画演示（精髓）&lt;/strong&gt;：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;精髓所在，前面知识点就算全都忘了，只记得这三张图，你也赚了。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;cp src.txt dest.txt&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages __bg_gif&quot; data-fileid=&quot;100001548&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/4UtmXsuLoNd7TgWQgNicxERn4VwB6EKE0AtMEOgOfMNAOrFa5mWaFhDWgEyzguXZsWuB3ibYGhARaF2xH6D1tjvA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;720&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;cp --sparse=always src.txt dest.txt&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages __bg_gif&quot; data-fileid=&quot;100001552&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/4UtmXsuLoNd7TgWQgNicxERn4VwB6EKE0siak6ffTLc0VoaZSaHGvxhKoh1IYia7j9FiatLhJ2JEdJ2PswRjVQRfrQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;720&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;cp --sparse=never src.txt dest.txt&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages __bg_gif&quot; data-fileid=&quot;100001553&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/4UtmXsuLoNd7TgWQgNicxERn4VwB6EKE0NsKibhicUB7B3U1icZAiaiaic13QaEv49icHkNbb18kGZIciaerpt1ZkT7q9rg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;720&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5268817204301075&quot; data-type=&quot;png&quot; data-w=&quot;186&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsesdolc6YJHWRf1C8UTPs3scrsXWFoCHYsntUfbpKFrDicJ5tFbLPxBw/640?wx_fmt=png&quot; data-fileid=&quot;100001551&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;稀疏文件的应用&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5520833333333334&quot; data-type=&quot;png&quot; data-w=&quot;192&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsl8Q8jryjW8fJDBj8r4A48RcHDMj7ibJfRRhRWSJUUWNTqiaibDr9dmstQ/640?wx_fmt=png&quot; data-fileid=&quot;100001549&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;稀疏文件在哪些地方有应用呢？&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;数据库快照：生成一个数据库快照时会生成一个稀疏文件，稀疏文件一开始并不会占用磁盘空间。当源数据库发生写操作时，就把修改前的原数据块复制且只复制一次到稀疏文件中；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;MySQL5.7 有一种数据压缩方式，其原理就是利用内核Punch hole特性，对于一个16kb的数据页，在写文件之前，除了 Page 头之外，其他部分进行压缩，压缩后留白的地方使用 punch hole 进行 “打洞”，在磁盘上表现为不占用空间，从而达到快速释放物理空间的目的；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;qemu 磁盘镜像文件的空间回收场景；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5268817204301075&quot; data-type=&quot;png&quot; data-w=&quot;186&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsesdolc6YJHWRf1C8UTPs3scrsXWFoCHYsntUfbpKFrDicJ5tFbLPxBw/640?wx_fmt=png&quot; data-fileid=&quot;100001550&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;一起做个实验&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5520833333333334&quot; data-type=&quot;png&quot; data-w=&quot;192&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsl8Q8jryjW8fJDBj8r4A48RcHDMj7ibJfRRhRWSJUUWNTqiaibDr9dmstQ/640?wx_fmt=png&quot; data-fileid=&quot;100001554&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后我们演示下实验，检验看下你懂了吗？找一台 linux 机器，跟着运行下面的命令。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;初始条件准备&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;步骤一：创建一个文件（预期占用 1 个 block）。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;echo&lt;/span&gt; =========== &lt;span&gt;test&lt;/span&gt; ======= &amp;gt; test.txt&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;步骤二：truncate 成 1G 的稀疏文件。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;truncate -s 1G ./test.txt&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;步骤三：把 1M 到 1M+4K 的位置预分配出来（并且是写 0 分配，预期到这里要占用 2 个 block，也就是 8K 数据）。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;fallocate -o 1048576 -l 4096 -z ./test.txt&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;步骤四：&lt;code&gt;stat&lt;/code&gt; 命令检查下情况。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sh-4.4&lt;span&gt;# stat test.txt&lt;/span&gt;&lt;br/&gt;  File: test.txt&lt;br/&gt;  Size: 1073741824 Blocks: 16         IO Block: 4096   regular file&lt;br/&gt;Device: 6ah/106d Inode: 3148347     Links: 1&lt;br/&gt;Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)&lt;br/&gt;Access: 2021-03-12 15:37:54.427903000 +0000&lt;br/&gt;Modify: 2021-03-12 15:46:00.456246000 +0000&lt;br/&gt;Change: 2021-03-12 15:46:00.456246000 +0000&lt;br/&gt; Birth: -&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到 &lt;code&gt;Size: 1073741824 Blocks: 16&lt;/code&gt; ，Size  大小等于 1G，&lt;strong&gt;stat 显示的 Blocks 是扇区（512字节）的个数&lt;/strong&gt;，也就是说，物理空间占用 8K，&lt;strong&gt;符合预期&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;文件大小为 1G；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实际数据在 [0, 4K] 和 [1M, 1M+4K] 这两个位置才有写入；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;其中 [0, 4K] 范围为正常数据， [1M, 1M+4K] 这段范围的数据为全 0 数据；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好，初始条件准备好了，下面我们开始对 &lt;code&gt;cp --sparse&lt;/code&gt; 的三个行为做实验。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;cp 的实验验证&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认策略：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;cp ./test.txt ./test.txt.auto&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;always 策略：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;cp --sparse=always ./test.txt ./test.txt.always&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;never 策略（这条命令敲下去可能有点慢哦，并且要预留好足够空间）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;cp --sparse=never ./test.txt ./test.txt.never&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上三个命令敲完，生成了三个文件，给大家 1 秒钟的思考时间，思考下 &lt;code&gt;test.txt.auto&lt;/code&gt;，&lt;code&gt;test.txt.always&lt;/code&gt;，&lt;code&gt;test.txt.never&lt;/code&gt;，这三个文件的属性有何异同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;..... ..... .....&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;结果揭秘：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;test.txt.auto&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sh-4.4&lt;span&gt;# stat ./test.txt.auto&lt;/span&gt;&lt;br/&gt;  File: ./test.txt.auto&lt;br/&gt;  Size: 1073741824 Blocks: 16         IO Block: 4096   regular file&lt;br/&gt;Device: 6ah/106d Inode: 3148348     Links: 1&lt;br/&gt;Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)&lt;br/&gt;Access: 2021-03-13 15:58:57.395725000 +0000&lt;br/&gt;Modify: 2021-03-13 15:58:57.395725000 +0000&lt;br/&gt;Change: 2021-03-13 15:58:57.395725000 +0000&lt;br/&gt; Birth: -&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Size: 1073741824：文件大小 1G&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Blocks: 8：&lt;strong&gt;物理空间占用 8K&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;test.txt.always&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sh-4.4&lt;span&gt;# stat ./test.txt.always&lt;/span&gt;&lt;br/&gt;  File: ./test.txt.always&lt;br/&gt;  Size: 1073741824 Blocks: 8          IO Block: 4096   regular file&lt;br/&gt;Device: 6ah/106d Inode: 3148349     Links: 1&lt;br/&gt;Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)&lt;br/&gt;Access: 2021-03-13 15:59:01.064725000 +0000&lt;br/&gt;Modify: 2021-03-13 15:59:01.064725000 +0000&lt;br/&gt;Change: 2021-03-13 15:59:01.064725000 +0000&lt;br/&gt; Birth: -&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Size: 1073741824：文件大小 1G&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Blocks: 8：&lt;strong&gt;物理空间占用 4K&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;test.txt.never&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sh-4.4&lt;span&gt;# stat ./test.txt.never&lt;/span&gt;&lt;br/&gt;  File: ./test.txt.never&lt;br/&gt;  Size: 1073741824 Blocks: 2097160    IO Block: 4096   regular file&lt;br/&gt;Device: 6ah/106d Inode: 3148350     Links: 1&lt;br/&gt;Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)&lt;br/&gt;Access: 2021-03-13 15:59:04.774725000 +0000&lt;br/&gt;Modify: 2021-03-13 15:59:05.977725000 +0000&lt;br/&gt;Change: 2021-03-13 15:59:05.977725000 +0000&lt;br/&gt; Birth: -&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Size: 1073741824：文件大小 1G&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Blocks: 2097160：&lt;strong&gt;物理空间占用 1G&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;所以，你学会了吗？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5268817204301075&quot; data-type=&quot;png&quot; data-w=&quot;186&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsesdolc6YJHWRf1C8UTPs3scrsXWFoCHYsntUfbpKFrDicJ5tFbLPxBw/640?wx_fmt=png&quot; data-fileid=&quot;100001555&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;知识点总结&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5520833333333334&quot; data-type=&quot;png&quot; data-w=&quot;192&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsl8Q8jryjW8fJDBj8r4A48RcHDMj7ibJfRRhRWSJUUWNTqiaibDr9dmstQ/640?wx_fmt=png&quot; data-fileid=&quot;100001558&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;文件系统对外提供文件语义，本质只是管理磁盘空间的软件而已；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;经典的文件系统主要划分 3 大块 superblock 区，inode 区，block 区（块描述区，bitmap区这里暂不介绍）。一个文件在文件系统的内部形态由一个 inode 记录元数据加上 block 存储用户存储用户数据样子；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;文件系统的 size 是文件大小，是逻辑空间大小，文件大小 size 和真实的物理空间并不是一个概念&lt;/strong&gt;；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;稀疏语义是文件系统提供的一种特性，根本用途是用来更有效的利用磁盘空间；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;后分配空间是空间利用最有效的方式&lt;/strong&gt;，公有云的云盘靠什么赚钱？就是后分配，你买了 2T 的云盘，在没有写入数据的时候，一个字节都没给你分配，你却是付出 2T 的价格；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;stat 命令能够查看物理空间占用，Blocks 表示的是扇区（512字节）个数；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;稀疏文件的空洞和用户真正的全 0 数据是无法区分的，因为对外表现是一样的（这点非常重要）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;cp 命令通过调用 &lt;code&gt;ioctl&lt;/code&gt;（fiemap）系统调用，可以获取到文件空洞的分布情况，cp 过程中跳过这些空洞，极大的提高了效率（100G 的源文件，cp 只做了十几次 io 搞定了，所以 1 秒足以）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;cp 的 sparse 参数从速度最快，空间最省，数据最拷贝最多，各有特点，小小的 cp 命令出来的目标文件，其实和源文件并不相同，只不过你没注意到；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;预分配和 punch hole 其实都是&lt;code&gt;fallocate&lt;/code&gt; 调用，只是参数不同而已，调用的时候，&lt;strong&gt;注意要 4k 对齐才能达到目的&lt;/strong&gt;；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;稀疏文件的 punch hole 应用有很多场景，通常是用来快速释放空间，比如镜像文件；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;&lt;span&gt;~完～&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5268817204301075&quot; data-type=&quot;png&quot; data-w=&quot;186&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsesdolc6YJHWRf1C8UTPs3scrsXWFoCHYsntUfbpKFrDicJ5tFbLPxBw/640?wx_fmt=png&quot; data-fileid=&quot;100001556&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;后记&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-fileid=&quot;100001557&quot; data-ratio=&quot;0.5520833333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsl8Q8jryjW8fJDBj8r4A48RcHDMj7ibJfRRhRWSJUUWNTqiaibDr9dmstQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;192&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文通过一个日常随处可见、所有人都用过，但是都没有细想过的 cp 命令切入，通过一个常常被我们忽略的现象来剖析其中的原理，&lt;span&gt;里面暗含的存储技术非常之丰富&lt;/span&gt;。这次通过分析 cp 的又获得一点秘密的知识点呢。&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;欢迎关注大佬的公众号&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg5NTU0NjMwOA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/xwgH35iaUoxaP0b86ozT32OA22cLIOhUFiaypiceUEnVeWe95vLskSDpd8YoXAiceeA8JrOfy4h7TqhnoibaF2rwgrw/0?wx_fmt=png&quot; data-nickname=&quot;云原生之道&quot; data-alias=&quot;cloudnative_wang&quot; data-signature=&quot;云原生前瞻技术文章，最新动态分享。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI4MzA5ODEyNw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/sM0hH9BhiaDchTIiavJnibsCE5Mrkn8JHYIjWDsibNcfhI1jXYbshOchjM2EEuRGCiciarNV85hmGhzfNKIVialpoeIOw/0?wx_fmt=png&quot; data-nickname=&quot;码农吴先生&quot; data-alias=&quot;CoderMrWu&quot; data-signature=&quot;专注DevOps、SRE技术分享和Python，从小工到专家的路上你我通行~&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;欢迎扫码进群！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100001179&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hBBhGOkMVjjpkPwV1hyE2Gs3cYAibzpPtcNiatQrGVfJI09LP65UD7hibRjsEgCNPElEmOniaAPySvcajhdTibdbcUQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;512&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>