<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f8028b4fcba6fdffdceecadd411cf538</guid>
<title>欢迎加入读者圈子，一起交流！</title>
<link>https://toutiao.io/k/h3qlj72</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;&lt;strong&gt;欢迎加入读者圈子，一起交流！&lt;br/&gt;↓↓↓&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;307&quot; data-ratio=&quot;0.5493333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavich3VaNkKeiaAwUhz7TQbQmic4fFsr58X9PAYleYzxqc1K1vZjeBoZDMUsmia0xH67EQYINGRvNOtLmA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;圈子剧透&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、600+圈子成员，以中高级程序员为主，更有架构师、CTO坐镇交流；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、1000+优质主题，数十G独家资料，每日分享，精挑细选；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、全年52期专属邮件周报，让你轻松掌握业界资讯、技术干货，提升认知水平；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、全年52本好书共读，让你花最少的时间，获取更好的知识；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;心动不如行动，赶快加入吧！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9f63894fa6503a1867f5a0702807f90c</guid>
<title>为什么你需要关注软件架构？</title>
<link>https://toutiao.io/k/g9j0b7r</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;作者&lt;/span&gt;&lt;span&gt; | &lt;span&gt;Pierre Pureur, Kurt Bittner&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;
译者 | 明知山&lt;/section&gt;&lt;section&gt;策划 | 丁晓昀&lt;/section&gt;&lt;section&gt;
软件开发团队一直反对“前期大设计”，而倾向于自组织团队中出现的架构设计，这可能导致低估软件架构重要性的心态。更多地意识到架构当中存在的隐式决策，并迫使这些决策变成显式的，有助于开发团队做出更好、更明智的决策。&lt;/section&gt;&lt;section&gt;
&lt;span&gt;1&lt;/span&gt; 关键要点&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;软件开发人员通常不信任架构实践，倾向于避开有意识的架构活动，并选择在自组织团队中出现的架构设计；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;为解决紧急架构的局限性和满足最初的质量属性需求，进行有意识的架构设计是有必要的；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;软件架构是由质量属性需求 (Quality Attribute Requirements，QAR) 驱动的，如果在最初的迭代中没有考虑到它们，通常会在软件系统被部署到初始试验阶段之后（只有少量的用户）出现问题；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;更多地意识到架构当中存在的隐式决策，并迫使这些决策变成显式的，这有助于开发团队利用他们从 Sprint 和迭代中获得的经验数据做出更好、更明智的决策；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;重构和过度的组件化会导致解决方案的碎片化，以至于没有人能完全理解发生了什么；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;现代架构实践，如持续架构和演进架构，提供了可以帮助做出显式架构决策的工具，让开发人员能够交付更可持续的软件产品。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;许多软件开发人员不信任架构实践，他们将这些实践与严格和专横的过程以及重要的前期规划和设计联系在一起。&lt;/p&gt;&lt;p&gt;因此，他们相信，如果他们遵循这些实践，可能需要很长时间才能交付一些甚至可能不是客户想要的东西。&lt;/p&gt;&lt;p&gt;他们更愿意专注于理解客户的需求，并通过小而快速的敏捷迭代过程来交付产品。&lt;/p&gt;&lt;p&gt;他们当中有一些人相信，只要遵循了这些过程，架构自然会“出现”，而不需要有意识地进行计划或架构设计。因为存在这些信念，他们可能不认为软件架构是重要的，甚至可能不关心它。&lt;/p&gt;&lt;p&gt;这种架构方法通常可以交付满足客户所需的产品，这是一个好的开始。&lt;/p&gt;&lt;p&gt;但是，如果不显式考虑产品的可持续性，它就有可能衰退，导致产品在自然退役前无法维护。&lt;/p&gt;&lt;p&gt;通过关注关键的质量属性，如性能、可伸缩性、安全性和弹性，有意识的软件架构方法有助于延长产品的生命周期，使其在更长的时期内可持续。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.36771300448430494&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FE4VibF0SjfOpzgIGIgOmrscThZCCVwLUe850MECweQXZkvic7vj5xEbzCib4lGpDv4cwx5BPmB6mhYPLK1fkzsPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;892&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;预先架构和紧急架构对比&lt;/section&gt;&lt;p&gt;如果我们正在做的事情是我们非常了解的，并且已经做过很多次了，那么预先设计方法就很有效。例如，建造摩天大楼、挖运河、生产产品或建造桥梁。我们可以应用“最佳实践”，并依赖过去已经在这些事情上验证过的有效方法。&lt;/p&gt;&lt;p&gt;如果我们正在处理一些东西是全新的，并且我们不太了解，或者变化太快以至于还没有“最佳实践”，那么预先设计就不起作用了。在这种情况下，作为科学革命基础的可控性实验可以帮助我们更深入地理解问题和可能的解决方案。最终的解决方案“出现”了，只是它沿着有意识的实验的路径向我们招手。&lt;/p&gt;&lt;p&gt;这两种方法都是有价值的，但适用的场景非常不同，一种可用于处理大部分已知的事情，而另一种可用于在变化的世界中探索新的机会和可能性。&lt;/p&gt;&lt;p&gt;第二种方法的问题在于，可控性实验可能无法在合理的时间内产生可持续的解决方案，并且可能需要进行可接受的返工。软件架构实践可以通过更早地提出更好的问题来指导实验，以减少交付可持续产品的时间和成本，并仍然可以保留敏捷方法的优势。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;2&lt;/span&gt; 架构是如何出现的&lt;/section&gt;&lt;p&gt;正如我们在前一篇文章中所讨论的，架构的本质由一组定义和约束产品技术面的决策组成。无论团队采用哪种方法，无论他们是有意识地还是心照不宣地做出决定，这些决定都是存在的。这些决策专注于产品如何处理质量属性需求（QAR）。&lt;/p&gt;&lt;p&gt;QAR 也可以是显式或隐式的，尽管显式的更容易处理并可以确保产品契合它们。例如，用户通常希望在使用产品时能够得到及时响应，而不管有多少人也在使用该产品。显式地声明“响应性”需求以及产品可以支持多少并发用户而不会变成“无法应式”的，将有助于开发团队对他们的技术方法做出更好的决策，比如“系统的速度必须够快”或“系统必须是可伸缩的”这样的声明并不能帮助团队做出更好的技术决策。&lt;/p&gt;&lt;p&gt;评估质量属性需求和设计一个架构来实现这些需求涉及到一些前期规划，这些也是软件系统取得成功的关键驱动因素，原因如下：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;软件架构是由质量属性需求驱动的，如果在最初的迭代中没有考虑到它们，通常会在软件系统被部署到初始试验阶段之后（只有少量的用户）出现问题。因此，当必须满足关键的质量属性需求 (如性能、安全性或可伸缩性) 时，可能需要进行重要的架构、设计和代码重构，这可能会出现具有高度易变性的软件架构。此外，如果架构设计没有强有力地实现组件的抽象和隔离，重构的成本可能会飙升。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;为解决紧急架构的局限性和满足最初的质量属性需求，进行有意识的架构设计是有必要的。例如，除了提供关于系统实际使用情况的有用信息以及关于架构设计的反馈回路之外，在初始架构设计中加入一个简单的监控框架，这对于确保软件系统的弹性和正确性来说是至关重要的。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;重构和过度的组件化会导致解决方案的碎片化，以至于没有人能完全理解发生了什么。有可能不知道正在使用的组件是什么版本，也可能没有记录每个组件的服务水平协议 (Service Level agreement，SLA)。微服务架构为每个服务使用了单独的数据存储，这可能会导致数据一致性问题。单体系统的可持续性较差，但具有高度的内部一致性。这两种架构各有优缺点。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;
&lt;span&gt;3&lt;/span&gt; 你的软件系统是可持续的吗?&lt;/section&gt;&lt;p&gt;广义地说，实现“可持续性”是软件产品架构工作的重点。如果软件产品能够满足当前需求 (包括 QAR)，而不损害满足未来需求的能力，则可以认为该软件产品是可持续的。正如我们在前一节中所述，质量属性需求驱动了架构，满足关键 QAR 对于创建可持续的架构设计来说是至关重要的。不幸的是，随着功能增强的实现和新设计决策的制定，软件系统会随着时间的推移而“磨损”，这可能会延展甚至破坏最初的架构设计。常见的“磨损”原因包括：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;由于维护系统的开发人员对系统缺乏理解，最初的设计决策也就过时了。与系统设计相关的决策和假设很少会被准确地记录下来。当人们不再针对系统提出问题或回答问题时，软件系统就开始衰退了。提出问题是评估软件系统健康状况的一种重要技术，如果有知识资源可以回答这些问题的话。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;技术债务的累积会导致系统维护不再可行或不再具有成本效益，并且无法实现新的功能。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;开发人员试图重用不同组件的代码块，他们认为可以通过对复用代码进行微小的改动来实现新功能。遗憾的是，他们可能无法完全理解原始代码所依赖的架构上下文，也意识不到在不同的组件中重用代码可能会在以后产生不必要的副作用，例如性能、可伸缩性或可用性问题。这些软件变更增加了技术债务，并降低了系统的整体质量，除非技术债务能够迅速得到解决。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;技术的发展导致一些软件系统运行在不是为它们设计的技术平台上。一些较老的软件系统经历了“灾难性的成功”，因为它们持续存在的时间比最初计划的要长得多，而且它们的技术债务已经变得非常沉重、难以解决且代价巨大，“偿还”起来非常困难。偿还技术债务的成本可能与完全替换该软件系统的成本类似，甚至有过之而无不及。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;失败的假设。逻辑的主体，包括软件系统，最终会因为假设的失败而崩溃，软件开发人员可能没有意识到他们所做的假设。隐藏的假设可以被认为是对系统的约束。关键在于要清楚地阐明所有的假设，并保持信息的更新。质量属性需求本身也是一种需要进行验证的假设，它们的实现需要经过经验的测试和确认，如果可能的话，可以使用自动化。性能、可伸缩性、弹性 (例如，使用类似于 Netflix 猴子军团的框架) 和安全性都是很好的例子。质量属性自动化测试的目标是持续对假设 (例如，实现 QAR 仍然是现实的吗？) 进行测试，并用以指导软件系统的演化。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;如果对最初的架构没有很好的理解，即使增加了新特性 (我们可以称之为“架构熵定律”)，使用紧急架构创建的软件系统最终也会失去架构完整性。因此，它们可能不再是可持续的。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;4&lt;/span&gt; 评估软件架构的适用性&lt;/section&gt;&lt;p&gt;如何知道你的软件系统什么时候磨损了，就像知道你的汽车轮胎什么时候磨损了并需要更换一样？就像医生可能使用许多不同种类的工具来评估个体的健康状况 (心电图、MRI、CT、血液测试、体格检查) 一样，不同的工具可以帮助团队评估软件架构的适用性。旧的系统可能难以理解，因为正如我们前面提到的，它们的设计决策和假设通常没有文档记录，而即使存在文档，也很可能是过时的。理解和评估系统的架构设计通常需要“软件考古”工具和技能。总的来说，有很多工具可以用来评估软件架构的适用性，包括：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;架构评审 (特别是对等评审) 是评估软件系统架构设计适用性的有效工具，特别是如果他们关注的权衡 (例如，来自 CMU/SEI 的架构权衡评估方法 (pdf))。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;自动化的软件质量评估工具 (例如 CAST)，但是人们需要接受它们生成的结果。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;代码评审 (特别是自动化代码评审) 对于确保代码质量来说非常重要。结对编程是实现这一目标的另一种方法。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;适用性功能实现，例如自动化性能测试。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;增强框架实现，包括 Web 服务监控工具，为软件架构提供反馈循环。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;技术债务的识别和评估，包括标明会导致技术债务增加的决定。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;自动化测试工具 (特别是负载 / 伸缩性 / 弹性测试)。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;缺陷趋势分析 (这是技术债务的代理)，需要使用一致的方式捕获数据，目标是识别不稳定性。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;生产事故趋势分析——与缺陷趋势分析具有相同的要求和目标。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;安全测试工具。使用这些工具的目的是找出风险暴露点。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;
&lt;span&gt;5&lt;/span&gt; 结论&lt;/section&gt;&lt;p&gt;在“前期大设计”和敏捷实践之间长达 20 年的争议中，软件开发人员努力在这两种方法之间找到一个有意义的平衡点，并从有意识的架构活动转向自组织团队的架构设计。因此，他们常常认为软件架构并不是那么重要。更多地意识到架构当中存在的隐式决策，并迫使这些决策变成显式的，这有助于开发团队利用他们从 Sprint 和迭代中获得的经验数据做出更好、更明智的决策。现代架构实践，如持续架构和演进架构，提供了可以帮助做出显式架构决策的工具，让开发人员能够交付更可持续的软件产品。&lt;/p&gt;&lt;p&gt;欲了解更多信息，请参考 Murat Erder、Pierre Pureur 和 Eoin Woods 合著的“Continuous Architecture in Practice”，以及 Murat Erder 和 Pierre Pureur 合著的“Continuous Architecture: Sustainable Architecture in an Agile and Cloud-Centric World”。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;作者简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Pierre Pureur 是一位经验丰富的软件架构师，拥有广泛的创新和应用开发背景，丰富的金融服务行业经验，广泛的咨询经验和全面的技术基础设施知识。他曾担任一家大型金融服务公司的首席企业架构师，领导大型架构团队，管理大型并发应用程序开发项目，指导创新活动，以及制定战略和业务计划。他是“Continuous Architecture in Practice: Scalable Software Architecture in the Age of Agility and DevOps”(2021 年出版) 和“Continuous Architecture: Sustainable Architecture in an Agile and Cloud-Centric World”(2015 年出版) 的合著者，并发表了许多文章，还在多个软件架构会议上做演讲。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Kurt Bittner 拥有超过 30 年在短反馈驱动周期内开发软件的经验。他帮助许多组织采用敏捷软件交付实践，包括大型银行、保险、制造和零售组织，以及大型政府机构。他曾为包括 Oracle、HP、IBM 和微软在内的大型软件交付组织工作，曾是 Forrester Research 的技术行业分析师。他的工作重心是帮助企业建立强大的、自组织的、高性能的团队，为客户提供他们喜爱的解决方案。他写了四本关于软件开发的书，包括“The Nexus Framework for Scaling Scrum”。他现居科罗拉多州博尔德市，担任 Scrum.org 的企业解决方案副总裁。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;查看英文原文：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.infoq.com/articles/care-about-architecture/?&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;
活动推荐&lt;/section&gt;&lt;p&gt;今年 7 月，ArchSummit 全球架构师峰会将落地深圳。目前已经邀请到了顺丰集团 CTO 耿艳坤、美的集团 IoT 副总裁兼 CTO 向江旭、度小满金融数据智能部总经理 / 技术委员会执行主席杨青、Shopee 技术委员会主席叶绍志博士等多位专家来大会现场分享，更多大咖正在陆续邀请中...&lt;/p&gt;&lt;p&gt;ArchSummit 深圳站的主题是数字化转型下的架构升级，根据这一主题，以及广东地区金融业、制造业发达的特色，我们设置了金融领域数字化转型、数字化转型时代的数据治理、AICon 全球人工智能与机器学习大会、 可观测性技术落地探索、单云架构到多云架构转型、 IoT 系统架构设计、微服务架构落地实践、云原生前沿技术应用、架构师能力模型、出海业务架构、开源和自研选型思考、架构稳定性保障等专题，点击阅读原文了解详情。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3b86ba366f4f4c3e877516e736dc525e</guid>
<title>是时候为Spring Boot 3.0做准备了</title>
<link>https://toutiao.io/k/v3i8wzb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.41101152368758004&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5KYkqUOzHEMPIFkQzAFEGktt0lwYGbSSL2krVpdKt8ydaHltcVfZfdBohyN6Nh2D8eo9wqrIpDK9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1562&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2018年2月28日Spring Boot进入2.0时代，距今已经超过4年了。2022 年11月Spring Boot 3.0将正式发布，它将基于Spring Framework 6.0，并且需要 Java 17 或更高版本，同时它也将是Jakarta EE 9的第一个Spring Boot版本。还有六个月的时间留给开发者来过渡到Spring Boot 3.0，今天胖哥将告诉你一些方法，以便于将来快速迁移到3.0。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;Java 17&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 17将是继Java 8以来最重要的LTS版本，是Java社区八年努力的成果。包含了很多重要的改进，Java 17也是目前性能最强的LTS版本。目前所有的Spring Boot 2.x 版本都能很好地适配Java 17，你可以无需等待，先着手JDK的升级调试，并尝试一些新的特性和API。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;尽快升级到Spring Boot 2.7&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前几日胖哥已经讲了Spring Boot 2.7基本已经是Spring Boot 2.x最后一个大版本了，Spring Boot 2.5已经停止OSS支持，不再进行维护，Spring Boot 2.6也将在Spring Boot 3.0发布后停止维护，迭代的速度越来越快了。尽早升级到2.7才能更好迁移到3.0，这里胖哥建议不要跳版本升级，比如不要直接从2.4跳到2.7，尽量按照2.4、2.5、2.6、2.7这样的步骤升级，跨度太大反而不利于平滑升级。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;移除过时代码&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个Spring Boot版本都会或多或少有一些被标记为&lt;code&gt;@Deprecated&lt;/code&gt;的代码，Spring Boot 3.0 将完全移除在 2.x 过时的代码，当然2.x早期的过时代码也可能在最新的2.x被移除。尽量不要使用过时代码，一般过时代码上都注释有过时的原因或者替代的API。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;配置文件机制的更改&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Spring Boot 2.4中，配置文件 &lt;code&gt;application.properties&lt;/code&gt; 和 &lt;code&gt;application.yaml&lt;/code&gt; 的加载机制被改变，目的是为了简化外部配置的加载方式，使之更加合理，带来的是不向下兼容。为了平滑升级，Spring 提供了一个配置项来兼容旧机制：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;spring:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;config:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;use-legacy-processing:&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而这个机制将在3.0时移除，我们必须使用符合新机制的配置方式，如果你存在这几种方式就需要注意了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;多文档Yaml&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你在&lt;code&gt;yaml&lt;/code&gt;配置文件中使用了间隔符&lt;code&gt;---&lt;/code&gt;来声明多文档的话，你得知道现在按文档声明的顺序来注册声明的配置属性；而在 Spring Boot 2.3 及更早版本中，基于配置文件激活顺序。举个例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;---&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spring:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;profiles:&lt;/span&gt; &lt;br/&gt;    &lt;span&gt;active:&lt;/span&gt; &lt;span&gt;dev&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;application:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;dev-app&lt;/span&gt;&lt;br/&gt;&lt;span&gt;server:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;port:&lt;/span&gt; &lt;span&gt;8081&lt;/span&gt;      &lt;br/&gt;&lt;span&gt;---&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spring:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;profiles:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;active:&lt;/span&gt; &lt;span&gt;prod&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;application:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;prod-app&lt;/span&gt;&lt;br/&gt;&lt;span&gt;server:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;port:&lt;/span&gt; &lt;span&gt;8080&lt;/span&gt;     &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个配置文件在Spring Boot 2.3以及更早的版本中会根据&lt;code&gt;spring.profiles.active&lt;/code&gt;来决定加载的环境。但是从2.4开始后面的属性会覆盖前面的属性。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;外部配置总是覆盖jar内的配置&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你的配置文件在jar之外，并且该配置文件适用于特定的环境，例如&lt;code&gt;application-dev.yaml&lt;/code&gt;。2.4以下的版本中，在jar外面的&lt;code&gt;application.yaml&lt;/code&gt;不会覆盖jar中的&lt;code&gt;application-&amp;lt;profile名称&amp;gt;.yaml&lt;/code&gt;文件，从2.4开始外部文件将总是覆盖jar内的配置文件。你需要检查你是否存在这种情况。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;激活配置文件&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果您使用&lt;code&gt;spring.profiles&lt;/code&gt;属性来激活环境配置，那么现在就应该迁移到&lt;code&gt;spring.config.activate.on-profile&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;旧玩法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;spring:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;profiles:&lt;/span&gt; &lt;span&gt;&quot;prod&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;secret:&lt;/span&gt; &lt;span&gt;&quot;production-password&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新玩法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;spring:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;config:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;activate:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;on-profile:&lt;/span&gt; &lt;span&gt;&quot;prod&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;secret:&lt;/span&gt; &lt;span&gt;&quot;production-password&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这真是折腾人啊。&lt;code&gt;spring.profiles.active&lt;/code&gt;仍然可以用来激活特定的环境，例如命令行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ java -jar myapp.jar --spring.profiles.active=prod&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你也可以在 &lt;code&gt;application.properties&lt;/code&gt; 或 &lt;code&gt;application.yaml&lt;/code&gt; 中使用&lt;code&gt;spring.profiles.active&lt;/code&gt;，从2.4开始&lt;code&gt;spring.profiles.active&lt;/code&gt;不能在特定环境中使用，也就是说&lt;code&gt;application-&amp;lt;profile&amp;gt;.yaml&lt;/code&gt;中不能使用，&lt;code&gt;---&lt;/code&gt;间隔的多文档中也不能使用它。一句话，你不能再通过&lt;code&gt;spring.profiles.active&lt;/code&gt;来合并一个包含了&lt;code&gt;spring.config.activate.on-profile&lt;/code&gt;属性的配置文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样的机制， &lt;code&gt;spring.profiles.include&lt;/code&gt;属性只能在非特定配置文件中使用，下面的配置是无效的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 无效配置&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spring:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;config:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;activate:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;on-profile:&lt;/span&gt; &lt;span&gt;&quot;prod&quot;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;profiles:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;include:&lt;/span&gt; &lt;span&gt;&quot;metrics&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更多的要点请参考官方配置文件&lt;span&gt;Spring boot配置迁移指南&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;性能更高的路径解析方式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从Spring Boot 2.6 开始，路径解析默认使用&lt;code&gt;PathPatternParser&lt;/code&gt;，取代了之前的Ant风格匹配&lt;code&gt;AntPathMatcher&lt;/code&gt;，升级时很多人的&lt;strong&gt;Swagger&lt;/strong&gt;出问题了，通过&lt;code&gt;spring.mvc.pathmatch.matching-strategy&lt;/code&gt;解决了这个问题。虽然在Spring Boot 3.0中&lt;code&gt;AntPathMatcher&lt;/code&gt;会继续生效，但是&lt;code&gt;PathPatternParser&lt;/code&gt;成为官方推荐，因为它的性能更高，稍后我也将出一篇专题来分析&lt;code&gt;PathPatternParser&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;兼容问题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先是Jakarta EE 9的兼容问题，确保你的第三方依赖库和你的代码都兼容Jakarta EE 9。另外也要检查Spring框架正在使用的第三方依赖jar是否有计划兼容Spring 6。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;尝试去学习Spring 6&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring 6以及Spring Boot 3已经发布了多个里程碑，在闲暇时间可以抽出一些时间去尝试一下，体验新的特性和变化，评估你应用升级的难度。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;p&gt;Spring boot配置迁移指南: https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-Config-Data-Migration-Guide&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651514853&amp;amp;idx=1&amp;amp;sn=cc4c1ab9812868835e414a9ca610d1ab&amp;amp;chksm=bd258b9a8a52028cea6d9ac013784ac4e29085cdcbc5ac2e07beadd7c13a684dca151dfcec04&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Spring Boot 2.7.0 发布，2.5 停止维护，节奏太快了吧&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Spring Boot 2.7.0 发布，2.5 停止维护，节奏太快了吧&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651514488&amp;amp;idx=1&amp;amp;sn=5b9509cdd0903bbfed9669f0451dc6fd&amp;amp;chksm=bd258a078a520311dda464be496b4a53c1031af4ba72da99dafd58da5dd0d787733535435ae7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;SpringCloud 优雅下线+灰度发布&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;SpringCloud 优雅下线+灰度发布&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关注「ImportNew」，提升Java技能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9166666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;点赞和在看就是最大的支持&lt;/span&gt;&lt;span&gt;❤️&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>44ccc4e203bff48085cb5b2078a0f1cc</guid>
<title>C++异步从理论到实践总览篇</title>
<link>https://toutiao.io/k/3zwk82u</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;作者：&lt;/span&gt;&lt;span&gt;fangshen，腾讯 IEG 客户端开发工程师&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;C++20带来了coroutine特性, 同时新的execution也在提案过程中, 这两者都给我们在C++中解决异步问题带来了新的思路. 但对比其他语言的实现, C++的协程和后续的execution都存在一定的理解和封装成本, 本系列的分享我们将围绕基本的原理, 相应的封装, 以及剥析优秀的第三方实现, 最终结合笔者framework落地的情况来展开.&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 纠结的开篇&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前设计我们游戏用的c++框架的时候, 刚好c++20的coroutine已经发布, 又因为是专门 给game server用的c++ framework, 对多线程的诉求相对有限, 或者本着少并发少奇怪的错误的原则, 除网络和IO和日志等少量模块外, 大部分模块主要还是工作在主线程上的, 所以当时设计的重点也就放在了c++20 coroutine的包装和使用上, 更多的使用coroutine来完善异步的支持. 但如果考虑到framework作为前后端公用框架的话, 原来主要针对主线程使用的包装的coroutine调度器就显得有些不够用, 以此作为基础, 我们开始了尝试结合比较新的c++异步思路, 来重新思考应该如何实现一个尽量利用c++新特性, 业务层简单易用的异步框架了.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本系列的主要内容也是围绕这条主线来铺开, 过程中我们 主要以:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;自有的framework异步实现&lt;/strong&gt; - 主要落地尝试利用c++20的coroutine实现一个业务级的调度器.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;asio&lt;/strong&gt; - 这个应该不用多说了, 近年来一直高频迭代, 业界广泛使用的开源第三方库, 中间的异步任务调度, 网络部分的代码实现都非常优质.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;libunifex&lt;/strong&gt; - 最接近当前sender/receiver版 execution提案的可实操版本, c++17/20兼容, 但不推荐使用c++17的版本进行任何尝试, 原因后续文件会展开.&lt;br/&gt;这几个库作为基础, 逐步展开我们对c++异步的探索, 然后再回到落地实践这条主线上, 探讨一个业务侧使用简单, 内部高效的异步库应该如何来实现并落地.  当然, 我们的侧重点主要还是c++异步的调度和处理上, 网络相关的有部分内容可能会简单提到, 但不会进行深入的展开.
  其实整个尝试的过程只能说非常不顺利了, 当然, 随着对相关实现的深入理解和细节的深挖, 收益也是颇多的. 闲话不多说了, 我们直接切入主题, 以对异步的思考来展开这篇总览的内容.&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 前尘往事 - rstudio framework实现&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;rstudio framework的异步框架由两块比较独立的部分组成:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;一部分是源自asio几年前版本的post和strand部分实现, 另外附加了一些业务侧较常用的像Fence等对象;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;另外一部分是主线程的协程调度器实现, 这部分最早是基于c++17实现的一版stackless 协程; 另外一版则是gcc11.1正式发布后, 直接用c++20重构了整个实现, 直接使用c++20的coroutine的一个版本.&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1 asio 部分&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;  这一部分的内容因为后续有asio scheduler实现具体的分析篇章, 这个地方主要以业务侧使用进行展开了.&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1.1 executor概述&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;来源于1.6X boost同期的asio standalone版本&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;去除了各平台网络处理相关的代码&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;仅保留了post和相关的功能(新版本有executor实现)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;早期c++11兼容, 无coroutine支持&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;除网络库外, asio非常有使用价值的一部分代码&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1.2  一个简单的使用示例&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  GJobSystem-&amp;gt;Post([]() {&lt;br/&gt;        &lt;span&gt;//some calculate task here&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;        GJobSystem-&amp;gt;Post(&lt;br/&gt;            []() {&lt;br/&gt;                &lt;span&gt;//task notify code here&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;            },&lt;br/&gt;            rstudio::JobSystemType::kLogicJob);&lt;br/&gt;      }, rstudio::JobSystemType::kWorkJob);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;相关的时序图:&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2801678908709339&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavoY2qYsT93zCZmcM8HTl4l6jiaWwnw868fiaEK3qYELYicEGic4ENDOSjDItwAOgHatRBSkwsutkSJKw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1906&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1.3  当前框架使用的线程结构&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6405693950177936&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavoY2qYsT93zCZmcM8HTl4lnQWicBuPxTCHqCWPOGnWGZlpWGcSZHWsHVO66yKzk2u5OZj9xYhjqdA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1686&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;预定义的枚举值:&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;enum&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;JobSystemType&lt;/span&gt; :&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; {&lt;br/&gt;  kLogicJob = &lt;span&gt;0&lt;/span&gt;,       &lt;span&gt;// logic thread(main thread)&lt;/span&gt;&lt;br/&gt;  kWorkJob,            &lt;span&gt;// work thread&lt;/span&gt;&lt;br/&gt;  kSlowJob,            &lt;span&gt;// slow work thread(run io or other slow job)&lt;/span&gt;&lt;br/&gt;  kNetworkJob,         &lt;span&gt;// add a separate thread for network&lt;/span&gt;&lt;br/&gt;  kNetworkConnectJob,  &lt;span&gt;// extra connect thread for network&lt;/span&gt;&lt;br/&gt;  kLogJob,             &lt;span&gt;// log thread&lt;/span&gt;&lt;br/&gt;  kNotifyExternalJob,  &lt;span&gt;// use external process to report something, 1 thread only~~&lt;/span&gt;&lt;br/&gt;  kTotalJobTypes,&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;不同Job说明:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;kLogicJob&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;kWorkJob&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Work Thread线程池执行任务(多个), 一般是计算量可控的小任务&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;kSlowJob&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;kNetworkJob&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;kNetworkConnectJob&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;kLogJob&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;日志专用线程, 目前日志模块是自己起的线程, 可以归并到此处管理&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;kNotifyExternalJob&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;专用的通知线程, 如lua error的上报, 使用该类型&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1.4  Timer任务相关&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;相关接口:&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//NoIgnore version&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;uint64_t&lt;/span&gt; &lt;span&gt;JobSystemModule::AddAlwaysRunJob&lt;/span&gt;&lt;span&gt;(JobSystemType jobType,&lt;br/&gt;      threads::ThreadJobFunction&amp;amp;&amp;amp; periodJob, &lt;br/&gt;      &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; periodTimeMs)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;uint64_t&lt;/span&gt; &lt;span&gt;JobSystemModule::AddTimesRunJob&lt;/span&gt;&lt;span&gt;(JobSystemType jobType, &lt;br/&gt;      threads::ThreadJobFunction&amp;amp;&amp;amp; periodJob, &lt;br/&gt;      &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; periodTimeMs, &lt;br/&gt;      &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; runCount)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;      &lt;br/&gt;&lt;span&gt;&lt;span&gt;uint64_t&lt;/span&gt; &lt;span&gt;JobSystemModule::AddDelayRunJob&lt;/span&gt;&lt;span&gt;(JobSystemType jobType,  &lt;br/&gt;      threads::ThreadJobFunction&amp;amp;&amp;amp; periodJob,&lt;br/&gt;      &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; delayTimeMs)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;      &lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;JobSystemModule::KillTimerJob&lt;/span&gt;&lt;span&gt;(&lt;span&gt;uint64_t&lt;/span&gt; tid)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;本部分并未直接使用asio原始的basic_waitable_timer实现, 而是自己实现的定时任务.&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1.5 在线程池上关联执行任务 - Strand&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;特定的情况下, 被派发到Work线程池的任务存在依赖关系&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;需要串联执行的时候, 这个时候我们需要额外的设施 JobStrand&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;来保证任务是按先后依赖关系来串行执行的&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如下图中part1, part2, part3, part4串行执行的情况所示&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.425&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavoY2qYsT93zCZmcM8HTl4lCGIGIQqZmiback9qKNkaTib2rPpXrCTNCoWqW8lRM5AMV5h22ZEbaXrg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;示例代码:&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;auto&lt;/span&gt; strand = GJobSystem-&amp;gt;RequestStrand(rstudio::JobSystemType::kWorkJob);&lt;br/&gt;starnd.Post([](){ &lt;br/&gt;    &lt;span&gt;//part1~&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;});&lt;br/&gt;starnd.Post([](){ &lt;br/&gt;    &lt;span&gt;//part2~&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;});&lt;br/&gt;starnd.Post([](){ &lt;br/&gt;    &lt;span&gt;//part3~ &lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;});&lt;br/&gt;starnd.Post([](){ &lt;br/&gt;    &lt;span&gt;//part4~ &lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;});&lt;br/&gt;starnd.Post([](){ &lt;br/&gt;    GJobSystem-&amp;gt;Post([](){&lt;br/&gt;        &lt;span&gt;//return code here&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;    }, rstudio::JobSystemType::kLogicJob); &lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1.6 其他辅助设施&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JobFence&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;jobs::JobFencePtr &lt;span&gt;JobSystemModule::RequestFence&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;字面义, 栅栏, 起到拦截执行的作用.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一般多用于模块的初始化和结束&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如tbuspp在kNetworkJob上的初始化和结束.&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3619246861924686&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavoY2qYsT93zCZmcM8HTl4lqTs7fklVPtWiczxGu3OvFuia3Rs4OjglNM3sCicicIGopJQZwBQQL6Xa8w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1912&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;示例代码(TcpService的初始化)&lt;/strong&gt;:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;job_system_module_-&amp;gt;Post(&lt;br/&gt;    [&lt;span&gt;this&lt;/span&gt;, workTicket]() {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!workTicket || workTicket-&amp;gt;IsExpired()) &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;        InitInNetworkThread();&lt;br/&gt;    },&lt;br/&gt;    JobSystemType::kNetworkJob);&lt;br/&gt;&lt;br/&gt;period_task_ptr = job_system_module_-&amp;gt;AddAlwaysRunJob(&lt;br/&gt;    JobSystemType::kNetworkJob,&lt;br/&gt;    [&lt;span&gt;this&lt;/span&gt;, workTicket]() {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!workTicket || workTicket-&amp;gt;IsExpired()) &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;        LoopInNetworkThread();&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;10&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;fence_-&amp;gt;FenceTo((&lt;span&gt;int&lt;/span&gt;)JobSystemType::kNetworkJob);&lt;br/&gt;fence_-&amp;gt;Wait();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JobNotify &amp;amp;&amp;amp; JobWaiter&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;jobs::JobWaiterPtr &lt;span&gt;JobSystemModule::RequestWaiter&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;jobs::JobNotifyPtr &lt;span&gt;JobSystemModule::RequestNotify&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;批量任务管理使用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;等待的方式的区别&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;JobNotify&lt;/strong&gt;: 执行完成调用额外指定的回调.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;JobWaiter&lt;/strong&gt;: 以Wait的方式在特定线程等待所有Job执行完成.&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JobTicket&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;jobs::JobTicketPtr &lt;span&gt;JobSystemModule::RequestTicket&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;令牌对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一般用来处理跨线程的生命周期控制&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;回调之前先通过IsExpired()来判断对应对象是否已经释放&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例代码:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;GJobSystem-&amp;gt;Post(&lt;br/&gt;  [&lt;span&gt;this&lt;/span&gt;, workTicket]() {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (!workTicket || workTicket-&amp;gt;IsExpired()) &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt; InitInNetworkThread();&lt;br/&gt;  },&lt;br/&gt;  JobSystemType::kNetworkJob);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2 asio 与其他实现的对比&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;  正好今年的GDC上有一个&amp;lt;&amp;lt;One Frame In Halo Infinite&amp;gt;&amp;gt;的分享, 里面主要讲述的是对Halo Infinite的引擎升级, 提供新的JobSystem和新的动态帧的机制来支撑项目的, 我们直接以它为例子来对比一下framework和Halo的实现, 并且也借用Halo Infinite的例子, 来更好的了解这种lambda post模式的缺陷, 以及可以改进的点.
  Halo引入新的JobSystem主要是为了将老的Tetris结构的并发模式:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5618055555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavoY2qYsT93zCZmcM8HTl4lzJm0V4Ww8UxzPVO2j0ib0Te7n2W1oL3NMKjAABpdZSiblLucQ92P8ibcw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1440&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;向新的基于Dependency的图状结构迁移:&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.56875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavoY2qYsT93zCZmcM8HTl4lHC1a2xnia1VHGmpMictbJTMp3sqtyAxCq0kWqOFXapLmnpGfMsK4ibSicA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1440&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;他使用的JobSystem的业务Api其实很简单, 我们直接来看一下相关的代码:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;JobSystem&amp;amp; jobSsytem = JobSystem::Get();&lt;br/&gt;JobGraphHandle graphHandle = jobSystem.CreateJobGraph();&lt;br/&gt;&lt;br/&gt;JobHandle jobA = jobSystem.AddJob( &lt;br/&gt; graphHandle, &lt;br/&gt; &lt;span&gt;&quot;JobA&quot;&lt;/span&gt;,&lt;br/&gt; [](){...} );&lt;br/&gt;&lt;br/&gt;JobHandle jobB = jobSystem.AddJob(&lt;br/&gt; graphHandle,&lt;br/&gt; &lt;span&gt;&quot;JobB&quot;&lt;/span&gt;,&lt;br/&gt; [](){...} );&lt;br/&gt;&lt;br/&gt;jobSystem.AddJobToJobDependency(jobA, jobB);&lt;br/&gt;&lt;br/&gt;jobSystem.SubmitJobGraph(graphHandle);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过这样的机制, 就很容易形成如:&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5454545454545454&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavoY2qYsT93zCZmcM8HTl4lv1iamtUVNDHCWunZBJibDREpNrcIcy5hMrK9AnicTHq9Dibic2TlDg05Bfg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;913&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外还有一个用于同步的SyncPoint:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;JobSystem&amp;amp; jobSystem = JobSystem::Get();&lt;br/&gt;JobGraphHandle graphHandle = jobSystem.CreateJobGraph();&lt;br/&gt;&lt;br/&gt;SyncPointHandle syncPointX = jobSystem.CreateSyncPoint(graphHandle, &lt;span&gt;&quot;SyncPointX&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;JobHandle jobA = jobSystem.AddJob(graphHandle, &lt;span&gt;&quot;JobA&quot;&lt;/span&gt;, [](){...});&lt;br/&gt;JobHandle jobB = jobSystem.AddJob(graphHandle, &lt;span&gt;&quot;JobB&quot;&lt;/span&gt;, [](){...});&lt;br/&gt;&lt;br/&gt;jobSystem.AddJobToSyncPointDependency(jobA, syncPointX);&lt;br/&gt;jobSystem.AddSyncPointToJobDependency(syncPointX, jobB);&lt;br/&gt;&lt;br/&gt;jobSystem.SubmitJobGraph(graphHandle);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大致的作用如下:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5675487465181058&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavoY2qYsT93zCZmcM8HTl4lTo3UDOjLg9SN8kVUAzPsAc44fUTcZe2mYqzF2F6MuMd9d9m5JljYrw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1436&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样在workload主动触发SyncPoint后, 整体执行才会继续往下推进, 这样就能方便的加入一些主动的同步点对整个Graph的执行做相关的控制了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回到asio, 我们前面也介绍了, 使用strand和post(), 我们也能很方便的构造出Graph形的执行情况 , 而SyncPoint其实类型framework中提供的Event, 表达上会略有差异, 但很容易看出两套实现其实是相当类同的. 这样的话, Halo 的JobSystem有的所有优缺点, framework基本也同样存在了, 这里简单搬运一下:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5634588563458857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavoY2qYsT93zCZmcM8HTl4libdSFcjs02k1Oic6LkU4FEdfqMAJFgoZ0BpRPAf87cXhYH5ziamYstfTg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1434&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于复杂并发业务的表达以lambda内嵌为主, 虽然这种方式尽可能保证所有代码上下文是比较集中的, 对比纯粹使用callback的模式有所进步, 但这种自由度过高的方式本身也会存在一些问题, 纯粹靠编码者来维系并发上下文的正确性,  这种情况下状态值在lambda之间的传递也需要特别的小心,  容易出错, 并且难以调试。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.3 coroutine实现部分&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;coroutine部分之前的帖子里已经写得比较详细了, 这里仅给出链接以及简单的代码示例:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/411834453&quot; data-linktype=&quot;2&quot;&gt;如何在C++17中实现stackless coroutine以及相关的任务调度器&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/414506528&quot; data-linktype=&quot;2&quot;&gt;C++20 Coroutine实例教学&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;另外还有一个purecpp大会的演讲视频,  主要内容与上述的两篇文章相关度比较高, 这里也给出相关的链接, 感兴趣的同学可以自行观看:&lt;a href=&quot;https://www.bilibili.com/video/BV1fZ4y197AL?spm_id_from=333.999.0.0&quot; data-linktype=&quot;2&quot;&gt;C++20 coroutine原理与应用&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;代码示例:&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//C++ 20 coroutine&lt;/span&gt;&lt;br/&gt;&lt;span&gt;auto&lt;/span&gt; clientProxy = mRpcClient-&amp;gt;CreateServiceProxy(&lt;span&gt;&quot;mmo.HeartBeat&quot;&lt;/span&gt;);&lt;br/&gt;mScheduler.CreateTask20([clientProxy]() &lt;br/&gt;                        -&amp;gt; rstudio::logic::CoResumingTaskCpp20 {&lt;br/&gt;    &lt;span&gt;auto&lt;/span&gt;* task = rco_self_task();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;step1: task is %llu\n&quot;&lt;/span&gt;, task-&amp;gt;GetId());&lt;br/&gt;    &lt;span&gt;co_await&lt;/span&gt; rstudio::logic::cotasks::NextFrame{};&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;step2 after yield!\n&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; c = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (c &amp;lt; &lt;span&gt;5&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;in while loop c=%d\n&quot;&lt;/span&gt;, c);&lt;br/&gt;        &lt;span&gt;co_await&lt;/span&gt; rstudio::logic::cotasks::Sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;        c++;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (c = &lt;span&gt;0&lt;/span&gt;; c &amp;lt; &lt;span&gt;5&lt;/span&gt;; c++) {&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;in for loop c=%d\n&quot;&lt;/span&gt;, c);&lt;br/&gt;        &lt;span&gt;co_await&lt;/span&gt; rstudio::logic::cotasks::NextFrame{};&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;step3 %d\n&quot;&lt;/span&gt;, c);&lt;br/&gt;    &lt;span&gt;auto&lt;/span&gt; newTaskId = &lt;span&gt;co_await&lt;/span&gt; rstudio::logic::cotasks::CreateTask(&lt;span&gt;false&lt;/span&gt;, &lt;br/&gt;                                    []()-&amp;gt; logic::CoResumingTaskCpp20 {&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;from child coroutine!\n&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;co_await&lt;/span&gt; rstudio::logic::cotasks::Sleep(&lt;span&gt;2000&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;after child coroutine sleep\n&quot;&lt;/span&gt;);&lt;br/&gt;    });&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;new task create in coroutine: %llu\n&quot;&lt;/span&gt;, newTaskId);&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;Begin wait for task!\n&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;co_await&lt;/span&gt; rstudio::logic::cotasks::WaitTaskFinish{ newTaskId, &lt;span&gt;10000&lt;/span&gt; };&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;After wait for task!\n&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    rstudio::logic::cotasks::RpcRequest &lt;br/&gt;        rpcReq{clientProxy, &lt;span&gt;&quot;DoHeartBeat&quot;&lt;/span&gt;, rstudio::reflection::Args{ &lt;span&gt;3&lt;/span&gt; }, &lt;span&gt;5000&lt;/span&gt;};&lt;br/&gt;    &lt;span&gt;auto&lt;/span&gt;* rpcret = &lt;span&gt;co_await&lt;/span&gt; rpcReq;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (rpcret-&amp;gt;rpcResultType == rstudio::network::RpcResponseResultType::RequestSuc) {&lt;br/&gt;        assert(rpcret-&amp;gt;totalRet == &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;auto&lt;/span&gt; retval = rpcret-&amp;gt;retValue.to&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;();&lt;br/&gt;        assert(retval == &lt;span&gt;4&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;rpc coroutine run suc, val = %d!\n&quot;&lt;/span&gt;, retval);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;rpc coroutine run failed! result = %d \n&quot;&lt;/span&gt;, (&lt;span&gt;int&lt;/span&gt;)rpcret-&amp;gt;rpcResultType);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;co_await&lt;/span&gt; rstudio::logic::cotasks::Sleep(&lt;span&gt;5000&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;step4, after 5s sleep\n&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;co_return&lt;/span&gt; rstudio::logic::CoNil;&lt;br/&gt;} );&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;执行结果:&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;step1: task is 1&lt;br/&gt;step2 after yield!&lt;br/&gt;in while loop c=0&lt;br/&gt;in while loop c=1&lt;br/&gt;in while loop c=2&lt;br/&gt;in while loop c=3&lt;br/&gt;in while loop c=4&lt;br/&gt;in for loop c=0&lt;br/&gt;in for loop c=1&lt;br/&gt;in for loop c=2&lt;br/&gt;in for loop c=3&lt;br/&gt;in for loop c=4&lt;br/&gt;step3 5&lt;br/&gt;new task create in coroutine: 2&lt;br/&gt;Begin wait for task!&lt;br/&gt;from child coroutine!&lt;br/&gt;after child coroutine sleep&lt;br/&gt;After wait for task!&lt;br/&gt;service yield call finish!&lt;br/&gt;rpc coroutine run suc, val = 4!&lt;br/&gt;step4, after 5s sleep&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整体来看, 协程的使用还是给异步编程带来了很多便利, 但框架本身的实现其实还是有比较多迭代优化的空间的:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;asio的调度部分与coroutine部分的实现是分离的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;coroutine暂时只支持主线程&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.4 小结&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面也结合halo的实例说到了一些限制, 那么这些问题有没有好的解决办法了, 答案是肯定的, 虽然execution并未完全通过提案, 但整体而言, execution新的sender/reciever模型, 对于解决上面提到的一些缺陷, 应该是提供了非常好的思路, 我们下一章节中继续展开.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. so easy - execution就是解?&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最开始的想法其实比较简单, 结合原来的framework, 适当引入提案中的execution一些比较可取的思路, 让framework的异步编程能更多的吸取c++新特性和execution比较高级的框架抽象能力, 提升整个异步库的实现质量. 所以最开始定的主线思路其实是更多的向execution倾斜, 怎么了解掌握execution, 怎么与现在的framework结合成了主线思路.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们选择的基础参考库是来自冲元宇宙这波改名的Meta公司的libunifex, 客观来说, Meta公司的folly库, 以及libunifex库的实现质量, 肯定都是业界前沿的, 对c++新特性的使用和探索, 也是相当给力的. 这些我们后续在分析libunifex具体实现的篇章中也能实际感受到.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但深入了解libunifex后, 我们会发现, 它的优点有不少:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;尝试为c++提供表达异步的框架性结构.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;泛型用得出神入化, ponder在它前面基本是小弟级别的, 一系列泛用性特别强的template 编程示例, 比如隐含在sender/receiver思路内的lazy evaluate表达, 如何在大量使用泛型的情况下提供业务定制点等等.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;结构化的表达并发和异步, 相关代码的编写从自由发挥自主把控走向框架化, 约束化, 能够更有序更可靠的表达复杂异步逻辑&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;整个执行pipeline的组织, 所有信息是compile time和runtime完备的, dependencies不会丢失.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;节点之间的值类型是强制检查的, 有问题的情况 , 大多时候compiler time就会报错.
有不少优点的同时, 也有很多缺点:&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;整个库的实现严重依赖了c++20 ranges采用的一种定制手段 cpo, 并且也使用了类似ranges的pipe表达方法, 理解相关代码存在一定的门坎.(后续会有具体的篇章展开相关的内容)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;库同时向下兼容了c++17, 但由于c++17本身特性的限制, 引入了大量的宏, 以及X Macros展开的方式, 导致相关的代码阅读难度进一步提升. 但实际上c++17版本并不具备可维护的价值, 依赖SIFINAE的实现, 如果中间任何一环报错, 必然需要在N屏的报错中寻找有效信息.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;libunifex对coroutine的支持存疑, 虽然让coroutine可以作为一种reciever存在, 但本质上来说, coroutine其实更适合拿来做流程控制的胶水, 而不是作为异步中的某个节点存在.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;默认的scheduler实现质量离工业级还存在一定的距离, 这一点后续的代码分析中也会具体提到.
诸多问题的存在, 可能也是execution提案没有短时间内获得通过的原因吧, 但整体来说, execution本身的理念还是很有参考价值的, 但以它的现状来说, 离最终的解肯定还是有比较大的距离的.&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. 尝试重新思考 - 要什么, 用什么&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事情到这个点就有点尴尬了, 原有的asio, 架构层面来说, 跟新的execution是存在落差的. 而项目实践上来说, asio相当稳扎稳打, 而以libunifex当前的状态来说, 离工业化使用其实是有一定距离的. 但asio作者在21年时候的两篇演讲(更像coding show):&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=icgnqFM-aY4&amp;amp;t=868s&quot; data-linktype=&quot;2&quot;&gt;Talking Async Ep1: Why C++20 is the Awesomest Language for Network Programming&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=hHk5OXlKVFg&quot; data-linktype=&quot;2&quot;&gt;Talking Async Ep2: Cancellation in depth&lt;/a&gt;第一篇基本整个演示了asio从最开始的callback, 到融入c++20 coroutine后的优雅异步表达, 我们可以通过下面的代码片断感受一下:&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;asio相关示例代码1&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;awaitable&amp;lt;&lt;span&gt;void&lt;/span&gt;&amp;gt; &lt;span&gt;listen&lt;/span&gt;&lt;span&gt;(tcp::acceptor&amp;amp; acceptor, tcp::endpoint target)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (;;)&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;auto&lt;/span&gt; [e, client] = &lt;span&gt;co_await&lt;/span&gt; acceptor.async_accept(use_nothrow_awaitable);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (e)&lt;br/&gt;      &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;auto&lt;/span&gt; ex = client.get_executor();&lt;br/&gt;    co_spawn(ex, proxy(&lt;span&gt;std&lt;/span&gt;::move(client), target), detached);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;asio相关示例代码2&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &lt;span&gt;auto&lt;/span&gt; [e] = &lt;span&gt;co_await&lt;/span&gt; server.async_connect(target, use_nothrow_awaitable);&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!e)&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;co_await&lt;/span&gt; (&lt;br/&gt;        (&lt;br/&gt;          transfer(client, server, client_to_server_deadline) ||&lt;br/&gt;          watchdog(client_to_server_deadline)&lt;br/&gt;        )&lt;br/&gt;        &amp;amp;&amp;amp;&lt;br/&gt;        (&lt;br/&gt;          transfer(server, client, server_to_client_deadline) ||&lt;br/&gt;          watchdog(server_to_client_deadline)&lt;br/&gt;        )&lt;br/&gt;      );&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对比原来每个async_xxx()函数后接callback的模式, 整个实现可以说是相当的优雅了, 代码的可读性也得到了极大的提高, 这两段代码都来自于上面的演讲中, 想深入了解的可以直接打开相关的链接观看视频, 很推荐大家去看一下.
  能够把复杂的事情用更简洁易懂的方法表达, 这肯定是让人振奋的, 当然, 深入了解相关实现后, 也会发现存在一些问题, 但我们的本意是参考学习, 得出最终想要的可以比较好的支撑并发和异步业务的基础框架, 有这些, 其实已经可以理出一条比较清晰的思路了:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;execution部分主要使用它的sender/receiver概念, 和它提供的一些通用的算法. 移除掉所有因为fallback c++17引入的大量代码噪声. 抛弃它并不完备的各种scheduler实现&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;协程借鉴部分asio的思路, 首先让协程可以基于context上下文, 在跨线程的情况下使用, 另外更多还是使用原有框架有明确的scheduler的方式对所有协程进行管理和定制的模式.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用asio的scheduler部分作为execution的底层scheduler实现, 同时也使用asio的timer表达, 去除原始libunifex依赖不同scheduler提供schedule_at()方法来执行定时器相关逻辑的实现.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;根据业务需要, 定制一些必要的sender adapter等简化业务的使用.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;尝试用execution框架对接ISPC等特殊的并发库, 能够以一个清晰的方式来表达这种混合环境上执行的逻辑.&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本系列涉及的基础知识和相关内容比较多, 先给出一个临时的大纲, 后续可能会有调整. 目前的思路是先介绍大家相对熟悉度不那么高的execution基础知识和libunifex, 后面再介绍asio相关的scheduler以及coroutine实现, 最后再回归笔者正在迭代的framework, 这样一个顺序来展开.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;参考&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=IUiNUky-ibM&quot; data-linktype=&quot;2&quot;&gt;One Frame in Halo Infinite&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;a href=&quot;https://think-async.com/Asio/&quot; data-linktype=&quot;2&quot;&gt;asio官网&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;a href=&quot;https://github.com/facebookexperimental/libunifex&quot; data-linktype=&quot;2&quot;&gt;libunifex源码库&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;近期好文：&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&amp;amp;mid=2649770979&amp;amp;idx=1&amp;amp;sn=040e8980fa1acdde8658d1d64477a531&amp;amp;chksm=beccd89889bb518e24d339637539fee251d9502c2117a6315cbc3efc64be670714439cdf8683&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;月活 12.8 亿的微信是如何防止崩溃的？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;月活 12.8 亿的微信是如何防止崩溃的？&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_live_iframe&quot; data-pluginname=&quot;videosnap&quot; data-headimgurl=&quot;https://wx.qlogo.cn/finderhead/I7awtksbibjQe7RZAy84xESOBAfIZ8xQ9ApXt4uTe8po/0&quot; data-username=&quot;v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder&quot; data-nickname=&quot;腾讯程序员&quot; data-desc=&quot;将在06月08日 19:30 直播&quot; data-intro=&quot;对谈从业22年+技术人：健康码不崩，你就不会想起我&quot; data-noticeid=&quot;finderlivenotice-v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder-1652418032974586-1817145992&quot; data-type=&quot;live&quot;/&gt;&lt;/section&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe videosnap_video_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAAjQk0RgWbuwAAAAstQy6ubaLX4KHWvLEZgBPE1aIUFQxWRKKDzNPgMItVt7MBPyPn10ZZD8cXgtf9&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=rjD5jyTuFrIpZ2ibE8T7Ym3K77SEULgkiaK0DoUicWmFlI1tRiatibpSGJYcVet7ibjjvECRUqK9JZc39otOsZWpHbTicMJFuVgtiamwqVXeqqzWda9XibWtIs1eiagg&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SZ&amp;amp;idx=1&amp;amp;m=&amp;amp;scene=0&amp;amp;token=AxricY7RBHdV9E7ibhl8AQMvrhdGTafob5OnHztc0kEuESsUia6GwebT6o8KIG7wdhcI1YhrhibQRkQ&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/I7awtksbibjQe7RZAy84xESOBAfIZ8xQ9ApXt4uTe8po/0&quot; data-username=&quot;v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder&quot; data-nickname=&quot;腾讯程序员&quot; data-desc=&quot;上班打工，下班打碟，work-life balance.&amp;#10;&amp;#10;#产品经理 @内森の日常 &amp;#10;&quot; data-nonceid=&quot;1762807789237249818&quot; data-type=&quot;video&quot; data-width=&quot;1920&quot; data-height=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7ef080e11de5e3b77247a18055ce9a8f</guid>
<title>前端必学的动画实现思路</title>
<link>https://toutiao.io/k/4l238n9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;前言&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个合理的动画是良好用户体验中必不可少的一部分。我们平常是怎样写动画的？CSS 中的 &lt;code&gt;animation&lt;/code&gt; 和 &lt;code&gt;transition&lt;/code&gt;，还有 &lt;code&gt;requestAnimationFrame&lt;/code&gt;？相信大家写动画的时候心里也是在万马奔腾。今天我们从一个另辟蹊径的角度来探索一个动画实现。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;示例&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请看下面的示例：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/3O9fy5mPFqpDuY1AiacN5ib20iciba9afClWZS6zHfBe1yiatFiaRYWom7z2sILOVKr5HLH99Olr1IwEQwXq9AVAmfhQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;480&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个可添加的数字的随机乱序列表。首先想一想，我们第一直觉可能会这样做：将这些数字的 DOM 节点用绝对定位来布局，数字变化后计算 &lt;code&gt;top&lt;/code&gt;、&lt;code&gt;left&lt;/code&gt; 的值，再配合 &lt;code&gt;transition&lt;/code&gt; 实现该动画。这种方式看似简单，其实内部要维护各种位置信息，所有坐标都需要手动管理，相当繁杂，非常不利于后期扩展。如果这些节点换成高度不固定的图片，那计算量可想而知。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那有没有一种更好的方式实现呢？肯定的，接下来介绍一个金光闪闪的概念：&lt;code&gt;FLIP&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提前预览：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;https://minjieliu.github.io/react-flip-demo&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;FLIP&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;FLIP&lt;/code&gt; 其实是几个单词的缩写：即 &lt;strong&gt;F&lt;/strong&gt;irst、&lt;strong&gt;L&lt;/strong&gt;ast 、&lt;strong&gt;I&lt;/strong&gt;nvert 、&lt;strong&gt;P&lt;/strong&gt;lay。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让我们分解一下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;First&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;涉及动画的元素的初始状态（比如位置、缩放、透明等）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Last&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;涉及动画的元素的最终状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Invert&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一步为核心，即找出这个元素是如何变化的。例如该元素在 &lt;strong&gt;First&lt;/strong&gt; 和 &lt;strong&gt;Last&lt;/strong&gt; 之间向右移动了 50px，你就需要在 X 方向 &lt;code&gt;translateX(-50px)&lt;/code&gt;，使元素看起来在 &lt;strong&gt;First&lt;/strong&gt; 位置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有一个知识点值得注意，DOM 元素属性的改变（比如 &lt;code&gt;left&lt;/code&gt;、&lt;code&gt;right&lt;/code&gt;、&lt;code&gt;transform&lt;/code&gt; 等），会被集中起来延迟到浏览器下一帧统一渲染，所以我们可以得到一个这样的中间时间点：&lt;span&gt;DOM 位置信息改变了，而浏览器还没渲染&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;。也就意味着在一定的时间内，我们能获取 DOM 改变后的位置，但在浏览器中位置还未改变。经测试，这个过程超过 10ms 就显得不稳定了。因此 &lt;code&gt;setTimeout(fn, 0)&lt;/code&gt;、 &lt;code&gt;React useEffect&lt;/code&gt; 和 &lt;code&gt;Vue $nextTick&lt;/code&gt; 都可以实现 &lt;strong&gt;Invert&lt;/strong&gt; 过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Play&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即从 &lt;strong&gt;Invert&lt;/strong&gt; 回到最终状态，有了两个点的位置信息，中间的过渡动画就可以使用 &lt;code&gt;transition&lt;/code&gt; 实现。本文采用 &lt;span&gt;Web Animation API&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt; 实现，动画执行过程中不会添加 CSS 到 DOM 上，相当干净。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/3O9fy5mPFqpDuY1AiacN5ib20iciba9afClWOmLrUdWjNcKvbQy9t8m0WNMLrVekAh4wnKlV7C8pzfichJA47Bw7s3w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;480&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;实现&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里主要使用 React 方式实现该效果，其他框架原理都一样可参考。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个列表，将子元素 5 列为一行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;.list&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;display&lt;/span&gt;: flex;&lt;br/&gt;  &lt;span&gt;flex-wrap&lt;/span&gt;: wrap;&lt;br/&gt;  &lt;span&gt;width&lt;/span&gt;: &lt;span&gt;400px&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;.item&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;display&lt;/span&gt;: flex;&lt;br/&gt;  &lt;span&gt;align-items&lt;/span&gt;: center;&lt;br/&gt;  &lt;span&gt;justify-content&lt;/span&gt;: center;&lt;br/&gt;  &lt;span&gt;width&lt;/span&gt;: &lt;span&gt;80px&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;height&lt;/span&gt;: &lt;span&gt;80px&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;border&lt;/span&gt;: &lt;span&gt;1px&lt;/span&gt; solid &lt;span&gt;#eee&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;ListShuffler&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; [data, setData] = useState([&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;]);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; listRef = useRef&amp;lt;HTMLDivElement&amp;gt;(&lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;    &amp;lt;div className={styles.list} ref={listRef}&amp;gt;&lt;br/&gt;      {data.map(&lt;span&gt;(&lt;span&gt;item&lt;/span&gt;) =&amp;gt;&lt;/span&gt; (&lt;br/&gt;        &amp;lt;div key={item} className={styles.item}&amp;gt;&lt;br/&gt;          {item}&lt;br/&gt;        &amp;lt;&lt;span&gt;/div&amp;gt;&lt;br/&gt;      ))}&lt;br/&gt;    &amp;lt;/&lt;/span&gt;div&amp;gt;&lt;br/&gt;  );&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，我们需要记录 &lt;code&gt;First&lt;/code&gt; 和 &lt;code&gt;Last&lt;/code&gt; 的位置信息，并用来计算 &lt;code&gt;Invert&lt;/code&gt; 偏移差，因此用 &lt;code&gt;Map&lt;/code&gt; 对象来存储最合适不过了，有了这个方法，我们就可以用它来生成前后快照：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;createChildElementRectMap&lt;/span&gt;(&lt;span&gt;nodes: HTMLElement | &lt;span&gt;null&lt;/span&gt; | &lt;span&gt;undefined&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!nodes) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Map();&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; elements = &lt;span&gt;Array&lt;/span&gt;.from(nodes.childNodes) &lt;span&gt;as&lt;/span&gt; HTMLElement[];&lt;br/&gt;  &lt;span&gt;// 使用节点作为 Map 的 key 存储当前快照，下次直接用 node 引用取值，相当方便&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Map(elements.map(&lt;span&gt;(&lt;span&gt;node&lt;/span&gt;) =&amp;gt;&lt;/span&gt; [node, node.getBoundingClientRect()]));&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点击添加的时候记录 &lt;strong&gt;First&lt;/strong&gt; 快照：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 使用 ref 存储 DOM 之前的位置信息&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; lastRectRef = useRef&amp;lt;Map&amp;lt;HTMLElement, DOMRect&amp;gt;&amp;gt;(&lt;span&gt;new&lt;/span&gt; Map());&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;handleAdd&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 添加一条到顶部，让后面节点运动&lt;/span&gt;&lt;br/&gt;  setData(&lt;span&gt;(&lt;span&gt;prev&lt;/span&gt;) =&amp;gt;&lt;/span&gt; [prev.length, ...prev]);&lt;br/&gt;  &lt;span&gt;// 并存储改变前的 DOM 快照&lt;/span&gt;&lt;br/&gt;  lastRectRef.current = createChildElementRectMap(listRef.current);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来 DOM 更新后还需要改变后的快照，在 React 中，无论是 &lt;code&gt;useEffect&lt;/code&gt; 还是 &lt;code&gt;useLayoutEffect&lt;/code&gt; 这里都可以拿到：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;useLayoutEffect(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// 改变后的 DOM 快照，此时 UI 并未更新&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; currentRectMap = createChildElementRectMap(listRef.current);&lt;br/&gt;}, [data]);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在，我们就可以把之前的快照进行遍历，实现 &lt;code&gt;Invert&lt;/code&gt; 并 &lt;code&gt;Play&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 遍历之前的快照&lt;/span&gt;&lt;br/&gt;lastRectRef.current.forEach(&lt;span&gt;(&lt;span&gt;prevRect, node&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// 前后快照的 DOM 引用一样，可以直接获取&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; currentRect = currentRectMap.get(node);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Invert&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; invert = {&lt;br/&gt;    left: prevRect.left - currentRect.left,&lt;br/&gt;    top: prevRect.top - currentRect.top,&lt;br/&gt;  };&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; keyframes = [&lt;br/&gt;    {&lt;br/&gt;      transform: &lt;span&gt;`translate(&lt;span&gt;${invert.left}&lt;/span&gt;px, &lt;span&gt;${invert.top}&lt;/span&gt;px)`&lt;/span&gt;,&lt;br/&gt;    },&lt;br/&gt;    { transform: &lt;span&gt;&#x27;translate(0, 0)&#x27;&lt;/span&gt; },&lt;br/&gt;  ];&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Play 执行动画&lt;/span&gt;&lt;br/&gt;  node.animate(keyframes, {&lt;br/&gt;    duration: &lt;span&gt;800&lt;/span&gt;,&lt;br/&gt;    easing: &lt;span&gt;&#x27;cubic-bezier(0.25, 0.8, 0.25, 1)&#x27;&lt;/span&gt;,&lt;br/&gt;  });&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大功告成！这里每个节点有单独的动画，各个节点之间互不冲突。也就是说无论节点位置多么复杂，处理起来都能从容应对。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如图片乱序只需要从 &lt;code&gt;lodash&lt;/code&gt; 引入 &lt;code&gt;shuffle&lt;/code&gt; 修改数据就可以完美实现展现。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; { shuffle } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;lodash-es&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;shuffleList&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  setData(shuffle);&lt;br/&gt;  &lt;span&gt;// 并存储改变前的 DOM 快照&lt;/span&gt;&lt;br/&gt;  lastRectRef.current = createChildElementRectMap(listRef.current);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上总体思路就是 &lt;strong&gt;First -&amp;gt; Last -&amp;gt; Invert -&amp;gt; Play&lt;/strong&gt; 的一个变换过程。预览下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.165938864628821&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/3O9fy5mPFqpDuY1AiacN5ib20iciba9afClWOXPXYwHvfz1jyLz3gsnibcUVSWyKM2GyibFtewZm8CrSoB9Ut7pBWBQw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;458&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你发现没有，每次做完操作都需要手动更新快照，作为开发者不能忍，我们要懒到极致，好好封装一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直白需求：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;数据变化后自动执行动画&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以不关心任何动画逻辑&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不要限制 DOM 结构&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用法要简单&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;性能要好&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开干！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 React 更新模型中，执行顺序为：&lt;strong&gt;setState -&amp;gt; render -&amp;gt; layoutEffect&lt;/strong&gt;。因此可以把 &lt;code&gt;setState&lt;/code&gt; 生成快照的步骤放到 &lt;code&gt;render&lt;/code&gt; 中，从而与操作解耦。（如果放到 &lt;code&gt;useLayoutEffect&lt;/code&gt; 中动画频繁会出现位置计算不准确的问题）&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;useMemo(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// render 时立即执行&lt;/span&gt;&lt;br/&gt;  lastRectRef.current.forEach(&lt;span&gt;(&lt;span&gt;item&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    item.rect = item.node.getBoundingClientRect();&lt;br/&gt;  });&lt;br/&gt;}, [data]);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加上之前 &lt;code&gt;useLayoutEffect&lt;/code&gt; 那部分逻辑，我们可以抽到一个独立组件中（&lt;code&gt;Flipper&lt;/code&gt;），用 &lt;code&gt;flipKey&lt;/code&gt; 来控制，只要 &lt;code&gt;flipKey&lt;/code&gt; 变化就执行动画，即实现 1、2 两点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Flipper.tsx&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;Flipper&lt;/span&gt;(&lt;span&gt;{ flipKey, children }: FlipperProps&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; lastRectRef = useRef&amp;lt;Map&amp;lt;&lt;span&gt;number&lt;/span&gt;, FlipItemType&amp;gt;&amp;gt;(&lt;span&gt;new&lt;/span&gt; Map());&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; uniqueIdRef = useRef(&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 通过 ref 创建函数，传递 context 避免引起穿透渲染&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; fnRef = useRef&amp;lt;IFlipContext&amp;gt;({&lt;br/&gt;    add(flipItem) {&lt;br/&gt;      lastRectRef.current.set(flipItem.flipId, flipItem);&lt;br/&gt;    },&lt;br/&gt;    remove(flipId) {&lt;br/&gt;      lastRectRef.current.delete(flipId);&lt;br/&gt;    },&lt;br/&gt;    nextId() {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; (uniqueIdRef.current += &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    },&lt;br/&gt;  });&lt;br/&gt;&lt;br/&gt;  useMemo(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    lastRectRef.current.forEach(&lt;span&gt;(&lt;span&gt;item&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      item.rect = item.node.getBoundingClientRect();&lt;br/&gt;    });&lt;br/&gt;  }, [flipKey]);&lt;br/&gt;&lt;br/&gt;  useLayoutEffect(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; currentRectMap = &lt;span&gt;new&lt;/span&gt; Map&amp;lt;&lt;span&gt;number&lt;/span&gt;, DOMRect&amp;gt;();&lt;br/&gt;    lastRectRef.current.forEach(&lt;span&gt;(&lt;span&gt;item&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      currentRectMap.set(item.flipId, item.node.getBoundingClientRect());&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;    lastRectRef.current.forEach(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;// 之前的 FLIP 代码&lt;/span&gt;&lt;br/&gt;    });&lt;br/&gt;  }, [flipKey]);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &amp;lt;FlipContext.Provider value={fnRef}&amp;gt;{children}&amp;lt;&lt;span&gt;/FlipContext.Provider&amp;gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最开始的方式是通过原生方法遍历 DOM，因此我们只能限制子节点一个层级，并且操作方式也脱离的 React 的编写模型，加以改进可以使用 &lt;code&gt;Context&lt;/code&gt; 来通信存储：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;FlipContext.ts&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; React, { createContext } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;react&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;type&lt;/span&gt; FlipItemType = {&lt;br/&gt;  &lt;span&gt;// 子组件的唯一标识&lt;/span&gt;&lt;br/&gt;  flipId: &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;// 子组件通过 ref 获取的节点&lt;/span&gt;&lt;br/&gt;  node: HTMLElement;&lt;br/&gt;  &lt;span&gt;// 子组件的位置快照&lt;/span&gt;&lt;br/&gt;  rect?: DOMRect;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IFlipContext {&lt;br/&gt;  &lt;span&gt;// mount 后执行 add&lt;/span&gt;&lt;br/&gt;  add: &lt;span&gt;(&lt;span&gt;item: FlipItemType&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;// unout 后执行 remove&lt;/span&gt;&lt;br/&gt;  remove: &lt;span&gt;(&lt;span&gt;flipId: &lt;span&gt;number&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;// 自增唯一 id&lt;/span&gt;&lt;br/&gt;  nextId: &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; FlipContext = createContext(&lt;br/&gt;  &lt;span&gt;undefined&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; unknown &lt;span&gt;as&lt;/span&gt; React.MutableRefObject&amp;lt;IFlipContext&amp;gt;,&lt;br/&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后则是要实现采集每个动画元素的节点。将动画的节点使用自定义组件 &lt;code&gt;Flipped&lt;/code&gt; 包裹并 &lt;code&gt;cloneElement(children { ref })&lt;/code&gt; 劫持 ref，&lt;code&gt;mount&lt;/code&gt; 时将子组件 &lt;code&gt;ref&lt;/code&gt; 添加到 &lt;code&gt;Context&lt;/code&gt;，&lt;code&gt;unmount&lt;/code&gt; 时则移除。&lt;span&gt;react-photo-view&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt; 的封装方式也是如此。即实现 3、4 两点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Flipped.tsx&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; React, {&lt;br/&gt;  cloneElement,&lt;br/&gt;  memo,&lt;br/&gt;  useContext,&lt;br/&gt;  useLayoutEffect,&lt;br/&gt;  useRef,&lt;br/&gt;} &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;react&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { FlipContext } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;./FlipContext&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; FlippedProps {&lt;br/&gt;  children: React.ReactElement;&lt;br/&gt;  innerRef?: React.RefObject&amp;lt;HTMLElement&amp;gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;Flipped&lt;/span&gt;(&lt;span&gt;{ children, innerRef }: FlippedProps&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// Flipper.tsx 将 ref 通过 Context 传递，避免穿透渲染&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; ctxRef = useContext(FlipContext);&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; ref = useRef&amp;lt;HTMLElement&amp;gt;(&lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; currentRef = innerRef || ref;&lt;br/&gt;&lt;br/&gt;  useLayoutEffect(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; ctx = ctxRef.current;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; node = currentRef.current;&lt;br/&gt;    &lt;span&gt;// 生成唯一 ID&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; flipId = ctx.nextId();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (node) {&lt;br/&gt;      &lt;span&gt;// mount 后添加节点&lt;/span&gt;&lt;br/&gt;      ctx.add({ flipId, node });&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;// unmout 后删除节点&lt;/span&gt;&lt;br/&gt;      ctx.remove(flipId);&lt;br/&gt;    };&lt;br/&gt;  }, []);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; cloneElement(children, { ref: currentRef });&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; memo(Flipped);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，看一下如何使用，一共就两个 API，从原本的 JSX 只需包裹一下就有动画了：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;Flipper flipKey={data}&amp;gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;{styles.list}&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    {data.map((item) =&amp;gt; (&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;Flipped&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;=&lt;span&gt;{item}&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;{styles.item}&lt;/span&gt;&amp;gt;&lt;/span&gt;{item}&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;/&lt;span&gt;Flipped&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    ))}&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&amp;lt;&lt;span&gt;/Flipper&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是不是超简单！最后，还剩性能问题一个非常重要的指标。因为每个节点都是独立的动画，数据量大了之后渲染肯定卡顿。经过测试，5000 个 DIV 节点的数字数组的随机动画完成更新时间为大约 2 秒，这是很不能接受的。我们可以只允许屏幕内的节点有动画，其他节点就跳过，只需要稍微判断一下两个状态都不在屏幕内就好了，这可以节约 2 / 3 的时间：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; isLastRectOverflow =&lt;br/&gt;  rect.right &amp;lt; &lt;span&gt;0&lt;/span&gt; ||&lt;br/&gt;  rect.left &amp;gt; innerWidth ||&lt;br/&gt;  rect.bottom &amp;lt; &lt;span&gt;0&lt;/span&gt; ||&lt;br/&gt;  rect.top &amp;gt; innerHeight;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; isCurrentRectOverflow =&lt;br/&gt;  currentRect.right &amp;lt; &lt;span&gt;0&lt;/span&gt; ||&lt;br/&gt;  currentRect.left &amp;gt; innerWidth ||&lt;br/&gt;  currentRect.bottom &amp;lt; &lt;span&gt;0&lt;/span&gt; ||&lt;br/&gt;  currentRect.top &amp;gt; innerHeight;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (isLastRectOverflow &amp;amp;&amp;amp; isCurrentRectOverflow) {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// node.animate() ...&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;记得之前 &lt;span&gt;react-beautiful-dnd&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt; 库刚出来的时候拖拽动画迷倒了不少人。但是现在有了 FLIP 再配合 &lt;span&gt;react-dnd&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt; 就可以轻松实现此类动画，功能上就更是属于碾压状态。而 &lt;span&gt;react-motion&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt; 之类的动画库实现该动画就繁杂很多，因为它用的是绝对定位控制的类型。下面的例子仅仅用刚封装的 &lt;code&gt;Flipper&lt;/code&gt; 包裹了一下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/3O9fy5mPFqpDuY1AiacN5ib20iciba9afClWwsn3l7VCP7CTUibJEU0sicWibHck6G0nH6sIvskh48jO6UXOVSqpicV2vg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;480&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下是源码：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;https://github.com/MinJieLiu/react-flip-demo&lt;/span&gt;&lt;sup&gt;[8]&lt;/sup&gt; 其中里面的 &lt;code&gt;Flipper&lt;/code&gt; 组件目录可以直接拷贝到项目中使用，100 来行代码相当轻量 🤭。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：&lt;code&gt;Web Animation&lt;/code&gt; 只兼容 &lt;code&gt;Chrome 75&lt;/code&gt; 以上，兼容古董浏览器可以考虑 &lt;span&gt;Web Animations API polyfill&lt;/span&gt;&lt;sup&gt;[9]&lt;/sup&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;现成的方案&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;什么？你有更复杂的动画需求，自己不想动手，可以看看这个，支持更多特性&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;react-flip-toolkit&lt;/span&gt;&lt;sup&gt;[10]&lt;/sup&gt; 一款有 3.4K Star FLIP 的库。实现了你所能想到的功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;交错效果：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.934375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/3O9fy5mPFqpDuY1AiacN5ib20iciba9afClWAZErYhtY1cgXmw42OtCdAH3rG2iad6jIicdO223Uh1fnbiaMtIWQ2oSBw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;嵌套比例变换：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6737864077669903&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/3O9fy5mPFqpDuY1AiacN5ib20iciba9afClWAaK4rV5mEHGYBKRnKn0zicS0RLgItySdl0xNGic8oPtnMoYBqoCR0eYw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1030&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;路由动画：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.622&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/3O9fy5mPFqpDuY1AiacN5ib20iciba9afClWsS4icnxLlm1yIKPicg2DUmMXia3x07Gd48s9hEHUmzqCericRiaG1SNiaFLA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以及更多&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Guitar 商城&lt;/span&gt;&lt;sup&gt;[11]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;React-flip-toolkit logo&lt;/span&gt;&lt;sup&gt;[12]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;使用 Portals&lt;/span&gt;&lt;sup&gt;[13]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;结语&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信这种动画思路肯定能大幅度简化编写动画的门槛，想起自己以前傻傻的用绝对定位计算位置，真是可笑可笑~ 😂😂&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;顺便给大家加个餐，&lt;strong&gt;&lt;span&gt;如何让display出现动画&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkwODIwMDY2OQ==&amp;amp;mid=2247489373&amp;amp;idx=1&amp;amp;sn=254507cb0f970d91c4c895cf6bac9c43&amp;amp;chksm=c0ccc8eff7bb41f98ebcd1af41205c2a86cd1acb4a6c6595e71631b68b44d822e721d9aeee58&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;三分钟,让display出现动画!&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;三分钟,让display出现动画!&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkwODIwMDY2OQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/sz_mmbiz_png/3GPT1CHiaSVssAs3fYdfweBskcYpVTrKpyGRwvSia0MOULHpGU8497uAkHic3CSPvqbr1BGQY45zoj0rvLexzLVVA/0?wx_fmt=png&quot; data-nickname=&quot;前端巅峰&quot; data-alias=&quot;Java-Script-&quot; data-signature=&quot;不止前端&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>