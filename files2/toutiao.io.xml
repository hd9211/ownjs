<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>0ae9e4b9eaa12632bc6ce7c2d309e392</guid>
<title>静态博客如何高性能插入评论</title>
<link>https://toutiao.io/k/ezkvu3s</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;content&quot;&gt;
            &lt;h2 id=&quot;-前言&quot;&gt;🌏 前言&lt;/h2&gt;
&lt;p&gt;我们知道，静态博客由于不带有动态功能，所以针对评论这种动态需求比较大众的做法就是使用第三方评论系统。第三方评论的本质其实就是使用 JS 去调取第三方服务接口获取评论后动态渲染到页面中。虽然它很好的解决了这个问题，但是由于需要请求接口，在体验上远比动态博客的直出效果要差很多。所以当我把博客从动态博客 Typecho 迁移到静态博客 Hugo 上来时，就一直在思考这个问题。直到我看到了 Hugo 的 &lt;code&gt;getJSON&lt;/code&gt; 方法，发现原来静态博客也是能够像动态博客一样直出评论的。&lt;/p&gt;
&lt;p&gt;大部分的静态博客的原理是解析存储内容的文件夹，使用一些模板语言遍历数据生成一堆 HTML 文件。而 Hugo 除了解析 Markdown 内容之外，还支持额外的数据获取方法 &lt;code&gt;getJSON&lt;/code&gt;。由于有了 &lt;code&gt;getJSON&lt;/code&gt; 方法的出现，我们可以实现在博客编译构建过程中动态的去获取评论接口数据，将其渲染到页面中，实现评论数据的直出效果。关于 &lt;code&gt;getJSON&lt;/code&gt; 的更多介绍，可以查看 Hugo 文档&lt;a href=&quot;https://gohugo.io/templates/data-templates/&quot;&gt;数据模板&lt;/a&gt;一节。&lt;/p&gt;
&lt;h2 id=&quot;-方案&quot;&gt;🎃 方案&lt;/h2&gt;
&lt;p&gt;高性能方案基本思路是在需要评论数据的地方通过 &lt;code&gt;getJSON&lt;/code&gt; 方法调用接口获取评论数据并进行模板渲染。当评论更新的时候，我们需要触发重新构建。实现这个方案依赖三个关键要素：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;构建过程支持调取接口获取数据&lt;/li&gt;
&lt;li&gt;评论服务提供 HTTP 接口返回数据&lt;/li&gt;
&lt;li&gt;博客部署服务支持钩子触发重新构建&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我的博客使用的是 Hugo 静态博客系统，如上文所说通过 &lt;code&gt;getJSON&lt;/code&gt; 即可解决第一个问题。而我的评论服务使用的是自研的 &lt;a href=&quot;https://waline.js.org&quot;&gt;Waline&lt;/a&gt; 评论系统，它提供了评论数、评论列表、最近评论等基础接口满足我们的数据获取需求。并且 Waline 提供了丰富的&lt;a href=&quot;https://waline.js.org/server/basic.html#%E8%AF%84%E8%AE%BA-hooks&quot;&gt;钩子功能&lt;/a&gt;，支持在评论发布的时候触发自第一方法。我的博客部署在 Vercel 上，它提供了 &lt;a href=&quot;https://vercel.com/docs/more/deploy-hooks&quot;&gt;Deploy Hooks&lt;/a&gt; 功能，通过 URL 即可触发重新构建。也就是说我只要在 Waline 评论发布的钩子中调用 Vercel 的钩子 URL 触发重新构建即可解决第三个问题。&lt;/p&gt;
&lt;h2 id=&quot;-实现&quot;&gt;🥪 实现&lt;/h2&gt;
&lt;p&gt;我的博客上有三处地方和评论有关，分别是首页侧边栏的最近评论，文章标题下方的评论数，以及文章详情页底部的评论列表展示。&lt;/p&gt;
&lt;h3 id=&quot;-最近评论&quot;&gt;🍞 最近评论&lt;/h3&gt;
&lt;p&gt;Waline 最近评论接口：&lt;a href=&quot;https://waline.js.org/api.html#%E8%AF%84%E8%AE%BA%E6%8E%A5%E5%8F%A3&quot;&gt;文档&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;chroma&quot;&gt;&lt;code class=&quot;language-fallback&quot; data-lang=&quot;fallback&quot;&gt;{{ $walineURL := .Site.Params.comment.waline.serverURL }}
&amp;lt;h2 class=&quot;widget-title &quot;&amp;gt;最近回复&amp;lt;/h2&amp;gt;
&amp;lt;ul class=&quot;widget-list recentcomments&quot;&amp;gt;
  {{ $resp := getJSON $walineURL &quot;/comment?type=recent&quot; }}
  {{ range $resp }}
  &amp;lt;li class=&quot;recentcomments&quot;&amp;gt;
    &amp;lt;a href=&quot;{{.Site.BaseURL}}{{ .url }}&quot;&amp;gt;{{ .nick }}&amp;lt;/a&amp;gt;：{{ .comment | safeHTML | truncate 22 }}
  &amp;lt;/li&amp;gt;
  {{ end }}
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&quot;-文章评论数&quot;&gt;🧀 文章评论数&lt;/h3&gt;
&lt;p&gt;Waline 获取文章对应的评论数接口：&lt;a href=&quot;https://waline.js.org/api.html#%E8%AF%84%E8%AE%BA%E6%95%B0&quot;&gt;文档&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;chroma&quot;&gt;&lt;code class=&quot;language-fallback&quot; data-lang=&quot;fallback&quot;&gt;{{ $walineURL := .Site.Params.comment.waline.serverURL }}
{{ $count := getJSON $walineURL &quot;/comment?type=count&amp;amp;url=/&quot; .Slug &quot;.html&quot; }}
&amp;lt;a href=&quot;{{ .Permalink }}#comments&quot; title=&quot;{{ .Title }}&quot;&amp;gt;
  &amp;lt;i class=&quot;fas fa-comment mr-1&quot;&amp;gt;&amp;lt;/i&amp;gt;
  &amp;lt;span&amp;gt;{{- if gt $resp 0}}{{$resp}} 条评论{{else}}暂无评论{{end -}}&amp;lt;/span&amp;gt;
&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&quot;-评论列表&quot;&gt;🍯 评论列表&lt;/h3&gt;
&lt;p&gt;评论列表由于有分页的存在，不像最近评论和评论数一样简单的调用接口即可。先获取评论数，发现有评论时先获取第一页的评论，主要是用来获取总共有多少页评论。之后再从第二页开始循环获取评论数据。最终将获取到的数据全部存到 &lt;code&gt;{{$scratch.Get &quot;comments&quot;}}&lt;/code&gt; 数组中，使用模板语法渲染该数组数据即可。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;chroma&quot;&gt;&lt;code class=&quot;language-fallback&quot; data-lang=&quot;fallback&quot;&gt;{{$baseUrl := .Site.Params.comment.waline.serverURL}}
{{$slug := .Slug}}
{{$count := getJSON $baseUrl &quot;/comment?type=count&amp;amp;url=/&quot; $slug &quot;.html&quot; }}
{{$scratch := newScratch}}
{{$scratch.Add &quot;comments&quot; slice}}

{{if gt $count 0}}
  {{$comments := getJSON $baseUrl &quot;/comment?path=/&quot; $slug &quot;.html&amp;amp;page=1&amp;amp;pageSize=100&quot;}}
  {{range $cmt := $comments.data}}
    {{$scratch.Add &quot;comments&quot; $cmt}}
  {{end}}

  {{$totalPages := $comments.totalPages}}
  {{if gt $totalPages 1}}
    {{range $page := seq 2 $totalPages}}
      {{$comments := getJSON $baseUrl &quot;/comment?path=/&quot; $slug &quot;.html&amp;amp;pageSize=100&amp;amp;page=&quot; $page}}
      {{range $cmt := $comments.data}}
        {{$scratch.Add &quot;comments&quot; $cmt}}
      {{end}}
    {{end}}
  {{end}}
{{end}}

&amp;lt;div class=&quot;vcards&quot;&amp;gt;
  {{range $cmt := $scratch.Get &quot;comments&quot;}}
  &amp;lt;div class=&quot;vcard&quot; id={{$cmt.objectId}}&amp;gt;
    &amp;lt;img class=&quot;vimg&quot; src=&quot;https://gravatar.loli.net/avatar/{{$cmt.mail}}?d=mp&quot;&amp;gt;
    &amp;lt;div class=&quot;vh&quot;&amp;gt;
      &amp;lt;div class=&quot;vhead&quot;&amp;gt;
        &amp;lt;a class=&quot;vnick&quot; rel=&quot;nofollow&quot; href=&quot;{{$cmt.link}}&quot; target=&quot;_blank&quot;&amp;gt;{{$cmt.nick}}&amp;lt;/a&amp;gt;
        &amp;lt;span class=&quot;vsys&quot;&amp;gt;{{$cmt.browser}}&amp;lt;/span&amp;gt;
        &amp;lt;span class=&quot;vsys&quot;&amp;gt;{{$cmt.os}}&amp;lt;/span&amp;gt;
      &amp;lt;/div&amp;gt;
      &amp;lt;div class=&quot;vmeta&quot;&amp;gt;
        &amp;lt;span class=&quot;vtime&quot;&amp;gt;{{dateFormat $cmt.insertedAt &quot;2006-01-02 03:04:05&quot;}}&amp;lt;/span&amp;gt;
        &amp;lt;span class=&quot;vat&quot;&amp;gt;回复&amp;lt;/span&amp;gt;
      &amp;lt;/div&amp;gt;
      &amp;lt;div class=&quot;vcontent&quot; data-expand=&quot;查看更多...&quot;&amp;gt;
        {{$cmt.comment | safeHTML}}
      &amp;lt;/div&amp;gt;
      &amp;lt;div class=&quot;vreply-wrapper&quot;&amp;gt;&amp;lt;/div&amp;gt;
      &amp;lt;div class=&quot;vquote&quot;&amp;gt;
        {{range $cmt := $cmt.children}}
        &amp;lt;div class=&quot;vh&quot; id=&quot;{{$cmt.objectId}}&quot;&amp;gt;
          &amp;lt;div class=&quot;vhead&quot;&amp;gt;
            &amp;lt;a class=&quot;vnick&quot; rel=&quot;nofollow&quot; href=&quot;{{$cmt.link}}&quot; target=&quot;_blank&quot;&amp;gt;{{$cmt.nick}}&amp;lt;/a&amp;gt;
            &amp;lt;span class=&quot;vsys&quot;&amp;gt;{{$cmt.browser}}&amp;lt;/span&amp;gt;
            &amp;lt;span class=&quot;vsys&quot;&amp;gt;{{$cmt.os}}&amp;lt;/span&amp;gt;
          &amp;lt;/div&amp;gt;
          &amp;lt;div class=&quot;vmeta&quot;&amp;gt;
            &amp;lt;span class=&quot;vtime&quot;&amp;gt;{{dateFormat $cmt.insertedAt &quot;2006-01-02 03:04:05&quot;}}&amp;lt;/span&amp;gt;
            &amp;lt;span class=&quot;vat&quot;&amp;gt;回复&amp;lt;/span&amp;gt;
          &amp;lt;/div&amp;gt;
          &amp;lt;div class=&quot;vcontent&quot; data-expand=&quot;查看更多...&quot;&amp;gt;
            {{$cmt.comment | safeHTML}}
          &amp;lt;/div&amp;gt;
          &amp;lt;div class=&quot;vreply-wrapper&quot;&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
        {{end}}
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
  {{end}}
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&quot;-构建触发&quot;&gt;🍳 构建触发&lt;/h3&gt;
&lt;p&gt;Waline 在评论发布、更新和删除阶段都支持自定义钩子，在钩子中触发 Vercel 的构建钩子即可完成发布评论重新构建的流程。&lt;/p&gt;
&lt;p&gt;按照如下内容修改服务端部署的 &lt;code&gt;index.js&lt;/code&gt; 文件，&lt;a href=&quot;https://waline.js.org/server/basic.html#%E8%AF%84%E8%AE%BA-hooks&quot;&gt;查看文档&lt;/a&gt;了解全部的 Waline 钩子。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;chroma&quot;&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Waline&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#x27;@waline/vercel&#x27;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;https&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#x27;https&#x27;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;buildTrigger&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;https&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#x27;https://api.vercel.com/v1/integrations/deploy/xxxxx&#x27;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;exports&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Waline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;postSave&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;comment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;comment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#x27;approved&#x27;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;buildTrigger&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;postUpdate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;buildTrigger&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;postDelete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;buildTrigger&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&quot;-后记&quot;&gt;🍾 后记&lt;/h2&gt;
&lt;p&gt;通过以上操作，就能在不损失用户体验的情况下实现评论数据的动态支持了。有些人可能会担心是否会在构建阶段造成超多的接口请求。这里大可不用担心，Hugo 自己会在构建的时候做接口的缓存，同 URL 的接口调用会走缓存数据而不会重新调用。&lt;/p&gt;
&lt;p&gt;除了用户体验之外，由于只会在构建的时候触发数据的获取，针对有调用次数配额的第三方评论服务也能节省额度。当然，理论上构建次数是远小于访问次数的，所以额度节省的结论是能成立的。如果说你的构建次数要比访问次数还要大的话，那这种方法就无法节省额度了。&lt;/p&gt;
&lt;p&gt;当然这种方式也会有带来些问题，主要是评论的更新没那么快。好在 Hugo 的构建速度非常快，一两分钟的时间也能接受。而针对用户评论的发布，则可以通过评论发布后先假插入缓解该问题。&lt;/p&gt;

        &lt;/div&gt;

        
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b561f9bb140d08cce309d8cd9d2c7f38</guid>
<title>深入理解 Flutter 的图形图像绘制原理：图形库 skia 剖析</title>
<link>https://toutiao.io/k/v57wvqz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p cid=&quot;n2&quot; mdtype=&quot;paragraph&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;Flutter是目前流行的高性能跨平台UI框架，图形库skia是其跨平台的基石。本文将深入分析skia的图形、字体、图片的渲染原理，如何挖掘硬件特性，为UI性能优化提供思路。&lt;/span&gt;&lt;/p&gt;&lt;h2 cid=&quot;n4&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;1. 引言&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n5&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Flutter是目前非常流行的跨平台UI开发框架，不仅支持Android、iOS，还支持Windows、Linux等操作系统。Flutter的性能非常高，拥有120fps的刷新率。那么flutter是如何实现在不同平台上高性能绘制图形图像的呢？首先我们分析下Flutter App和原生Android App、原生iOS App的UI绘制原理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7388059701492538&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ECThdibSVDxg8MJWE7VFSOYEDMqHzahjXX7oI8QhzlPCKOgib48S4NOgZqzGvj3tCnibmmD47KrFBL8aicrChwoo2g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;670&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n7&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;移动App的整体UI框架大致分成下面4个层次：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n8&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;1）UI库&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n9&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;跟Android、iOS原生开发类似，Flutter用dart语言实现一整套UI控件。Flutter先将控件树转成渲染树，然后交由skia库绘制界面。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n10&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;2）图形库&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n11&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Skia图形库跟iOS平台的CoreAnimation等库功能类似，不仅提供了图形渲染功能，还提供文字绘制和图片显示功能。高级图形图像库将需要绘制的图形转成点、线、三角形等图元，再调用底层图形接口实现绘制。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n12&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;3）低级图形接口&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n13&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;OpenGL是使用最广的低级图形接口，兼容性最好，基本上支持市面上的所有GPU。Vulkan是最近几年新推出的图形API，除了iPhone的GPU，其他厂家的GPU基本都支持。Metal是苹果新推出的图形API，只支持自家GPU。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n14&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;4）硬件设备层&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n15&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;目前的移动设备出于性能考虑，大部分图形都是通过GPU渲染，少数情况也会使用CPU渲染，后文会介绍skia使用CPU和GPU渲染的具体场景。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n16&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;iPhone 在A11芯片以前使用power vr系列GPU，之后采用自研GPU。安卓手机大部分采用高通Adreno GPU或ARM mail GPU。GPU渲染完一帧图像后送FrameBuffer，最后在合适的时机展示在屏幕上。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n17&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Skia应用广泛并且跨平台，不仅用于Flutter和Android操作系统，还用于Google Chrome浏览器，同时支持windows、Mac、iOS操作系统。Skia由C++编写，代码开源，通过研究skia有助于理解图形图像的绘制原理，为UI性能优化提供思路。&lt;/span&gt;&lt;/p&gt;&lt;h2 cid=&quot;n18&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;2. skia 框架分析&lt;/span&gt;&lt;/h2&gt;&lt;h3 cid=&quot;n19&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;2.1 Skia外部组件依赖&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n20&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Skia依赖的第三方库众多，包括字体解析库freeType,图片编解码库libjpeg-turbo、libpng、libgifocode、libwebp和pdf文档处理库fpdfemb等。Skia支持多种软硬件平台，既支持ARM和x86指令集，也支持OpenGL、Metal和Vulkan低级图形接口。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5723350253807107&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ECThdibSVDxg8MJWE7VFSOYEDMqHzahjXJge0keibrVLM2jfibOuDU7ETcWURnR7GlET4Un4hbOzvCoU4G61dAeDg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;788&quot;/&gt;&lt;/p&gt;&lt;h3 cid=&quot;n22&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;2.2 Skia 层次分析&lt;/span&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p cid=&quot;n23&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Skia在结构上大致分成三层：画布层，渲染设备层和封装适配层。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4991364421416235&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ECThdibSVDxg8MJWE7VFSOYEDMqHzahjX9an0NNZqFUW5YN4D7vHvKHY8vSv1b1yqaFqcQpk5VKlQvnjJriaJHpw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;579&quot;/&gt;&lt;/p&gt;&lt;h4 cid=&quot;n26&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;2.2.1 画布层&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n27&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;画布层可以理解成提供给开发者在一个设备无关的画布，可以在上面绘制各种图形，且不用关心硬件细节，功能如下：&lt;/span&gt;&lt;/p&gt;&lt;figure cid=&quot;n28&quot; mdtype=&quot;table&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr cid=&quot;n29&quot; mdtype=&quot;table_row&quot;&gt;&lt;th&gt;&lt;span&gt;类别&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;函数名&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;含义&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr cid=&quot;n33&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;画图形&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;drawPoints&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;画点&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n37&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;画图形&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;drawRect&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;画矩形&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n41&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;画图形&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;drawVertices&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;画多边形&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n45&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;画图形&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;drawRoundRect&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;画圆角矩形&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n49&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;画图形&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;drawArc&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;画圆弧&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n53&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;画图形&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;drawOval&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;画椭圆&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n57&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;画图形&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;drawPath&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;画矢量图&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n61&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;绘制文字&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;drawText&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;显示文字&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n65&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;显示图片&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;drawBitmap&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;显示位图&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h4 cid=&quot;n69&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;左右滑动查看完整表格&lt;/span&gt;&lt;/h4&gt;&lt;h4 cid=&quot;n69&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;2.2.2 渲染设备层&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n70&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;渲染设备层负责画布层的硬件实现，skia将设备封装成下面三个类：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n71&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;1）SKBitmapDevice&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n72&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;CPU渲染模式绘图，用于没有显卡或者显卡驱动的设备。此模式下，最后会将需要绘制的图形转成位图数据（RGB）写入指定内存，故称为BitmapDevice。写内存操作通过AVX或者NEON指令集实现。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n73&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;2）SKGPUDevice&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n74&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;GPU渲染方式绘图。目前大部分移动设备和个人电脑都有GPU，GPU比CPU的运算单元多，并行计算能力强，通过GPU绘图可降低CPU占用，性能更好。Flutter、最新版本的chrome和android系统默认设置为GPU渲染模式。Chrome中的配置截图如下，可看到默认采用GPU渲染。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.26987951807228916&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ECThdibSVDxg8MJWE7VFSOYEDMqHzahjX4qZ69a4uMNRE3hjGGpibwOL4mJ8EtUHpCoKicZBnMvAyArC1H6ibHsdjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;415&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n76&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;3）SKPDFDevice&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n77&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;选用此设备时，渲染结果不是输出到显示器的画面，而是输出为pdf文件。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n78&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;可以通过skia官网在线体验不同设备的渲染结果：&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://fiddle.skia.org/c/@shapes&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n79&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;2.2.3封装适配层&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n80&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Skia为了屏蔽不同依赖库的接口差异，对依赖库进行了封装和适配。例如基于图片编解码库libjpeg-turbo、libpng、libwebp 封装了类SKJpegCodec、SKPngCodec、SKWebpCodec。基于底层图形库OpenGL、Metal、Vulkan封装了GrGLOpsRenderPass， GrMTOpsRenderPass, GrVKOpsRenderPass三个类。基于苹果平台CoreText字体库和开源字体FreeType封装了类SkScalerContext_Mac和SkScalerContext_FreeType。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n81&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Skia的外部依赖和层级结构讲解完毕，下面重点讲解skia的图形、文字和图片的绘制原理。&lt;/span&gt;&lt;/p&gt;&lt;h2 cid=&quot;n82&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;3. 图形绘制原理&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n83&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Skia支持绘制的图形众多，包括圆形、椭圆、矩形、贝塞尔曲线等。下文重点分析图形的CPU和GPU两种渲染模式的原理。&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n84&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;3.1 图形CPU渲染原理&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n85&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;曲线的绘制涉及的数学知识较多，本文不再展开，下面以绘制实心矩形为例说明原理进行剖析。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.9265734265734266&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ECThdibSVDxg8MJWE7VFSOYEDMqHzahjX4icPT1AO3Wc9ibFfugWhXwtr4gXmKjje0ibUaiaKfNIG7Pib2ZlXicvau8VQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;572&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n87&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;1）调用画布的绘图API&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n88&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;应用层调用画布SKCanvas的drawRect函数，传入左上角和右下角顶点坐标。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n89&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;2）选用对应的设备的绘图API&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n90&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;由于选择的是CPU渲染模式，故调用SKBitmapDevice的矩形绘图函数drawRect实现。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n91&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;3）图形表示&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n92&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;所有的图形可分解成下面几种基本矢量图形的组合，矩形可表示成四条直线的组合。&lt;/span&gt;&lt;/p&gt;&lt;figure cid=&quot;n93&quot; mdtype=&quot;table&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr cid=&quot;n94&quot; mdtype=&quot;table_row&quot;&gt;&lt;th&gt;&lt;span&gt;曲线类型&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;参数&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;用途&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr cid=&quot;n98&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;直线（一次贝塞尔曲线）&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;起点坐标，终点坐标&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;可表示绘制三角形、四边形等多边形&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n102&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;圆锥曲线&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;起点坐标，终点坐标，椭圆参数&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;表示椭圆、圆弧、圆形&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n106&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;二次贝塞尔曲线&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;三个控制点&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;表示TrueType字体、抛物线等曲线&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n110&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;三次贝塞尔曲线&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;四个控制点&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;表示OpenType字体和其他曲线&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h4 cid=&quot;n69&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;左右滑动查看完整表格&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n114&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;4）绘制算法实现&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n115&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;矢量图转成位图的过程称为光栅化。带填充的矩形光栅化过程比较简单，可以分解成绘制多条横线。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n116&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;5）横线线绘制算法&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n117&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;每条横向的画法通过SKBlitter:: blitH实现。接口定义如下：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n255&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;virtual void blitH(int x, int y, int width);&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n257&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;功能：从坐标x,y开始，连续写入宽度为width的RGB颜色值。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n118&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;6）内存中写颜色数据&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n119&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;通过追踪代码，发现上文中的横线绘制函数调用的是memsetT函数（内存赋值）实现。参数如下：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n120&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;static void memsetT(T buffer[], T value, int count)&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n121&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;目前x86和ARM处理器是32或者64位，普通的指令一次最多写入32位 或者64位数据，一个带透明通道的点通常占4个字节，相当于一次只能绘制1到2个点，效率比较低。Skia从性能角度考虑，采用的SIMD指令集来加速内存操作。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n122&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;在X86平台，调用SSE、AVX、AVX2等指令集实现内存赋值，SSE支持一次操作128位操作，AVX/AVX2支持一次操作256位数据，ARM处理器的NEON指令集支持一次操作128位数据。&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n123&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;3.2 图形GPU渲染原理&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n124&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;GPU的并行运算能力强，目前大部分移动设备都采用的是GPU渲染。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n260&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;skia GPU渲染流程如下：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n125&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;1）发起绘图，先调用SKCanvas的绘图函数drawRect，传入左上角和右下角顶点坐标。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n126&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;2）调用GPU设备的绘图函数SKGPUDevice::drawRect。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n127&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;3）采用命令模式，将GPU绘图操作封装成类GrOpsTask的实例。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n128&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;4）根据软硬件平台的不同选用不同的底层API。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n129&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;OpenGL（Open Graphics Library”）是目前使用最广泛的跨平台图形变成接口，跨平台特性好，大部分操作系统和GPU。Skia在大部分平台采用OpenGL实现GPU绘图，少部分平台调用Metal和vulkan。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n130&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Metal是苹果公司2014年推出的和 OpenGL类似的面向底层的图形编程接口，只支持iOS。对软硬件有要求，要求硬件苹果A7及以后，操作系统iOS 10及以上。Metal理论上性能比OpenGL性能强，故新设备中开启Metal可提高性能。例如Flutter中已启用了metal支持，详情参考&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/flutter/flutter/wiki/Metal-on-iOS-FAQ&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n131&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Vulkan是新一代跨平台的2D和3D绘图应用程序接口（API）,旨在取代OpenGL，理论上性能强于OpenGL。自 Android 7.0 开发者预览版开始，Google便在系统平台中添加了对Vulkan的API支持。目前Skia的GPU渲染模式已用vulkan实现了一套，但存在一些bug。具体参考&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://skia.org/user/special/vulkan&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n132&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Skia对上述三种图形接口进行了封装，屏蔽了不同底层图形API接口的差异。OpenGL接口的封为GrGLOpsRenderPass，Metal的封装层为GrMTOpsRenderPass,Vuklan的封装层为 GrVKOpsRenderPass。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7763157894736842&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ECThdibSVDxg8MJWE7VFSOYEDMqHzahjXl8NeQgFa4t0s5qzs27KtV6pqKBI4u3FzqCr05ibmGTabIOALVmGE8gw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;608&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n136&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;5）通过GPU完成剩余绘图操作。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n266&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;下面以OpenGL为例说明。接口封装层调用OpenGL glDrawArray绘制矩形，之后在渲染流水线中完成顶点变换、光栅化和着色，最后送帧缓冲显示。渲染流水线如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6578947368421053&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ECThdibSVDxg8MJWE7VFSOYEDMqHzahjXqNRTVXwkh9xobpLcLOEFVtouN63iciaHoahEa9YUE8A8UicVMhRBoLsoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;304&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n138&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Metal、vulkan的渲染流水线这里不再展开。&lt;/span&gt;&lt;/p&gt;&lt;h2 cid=&quot;n139&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;4. 字体绘制原理&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n140&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;字体无法直接显示在屏幕上，需要解析成位图或者矢量图才能绘制。Skia的字体解析实现跟进平台差异有所不同，mac和iOS平台调用coreText库,安卓平台调用开源库freeType。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n141&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;FreeType是一个用C语言实现的，免费的高质量可移植字体引擎，支持点阵字体PCF、BDF和矢量字体TrueType、freeType等字体。&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n142&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;4.1 skia点阵字体绘制原理&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n143&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Skia支持的点阵字体有PCF、BDF格式。点阵存储的是多张位图，常见的有16&lt;em&gt;16，24&lt;/em&gt;24，32*32等尺寸，解码和显示简单，缺点是放大后有锯齿。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n144&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;1) skia点阵文字显示代码：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;SkFont font;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;font.setEdging(SkFont::Edging::kAlias);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;font.setSize(40);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;const char text[] = &quot;Click this link!&quot;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;size_t byteLength = strlen(static_cast&amp;lt;const char*&amp;gt;(text));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;canvas-&amp;gt;drawSimpleText(text, byteLength, SkTextEncoding::kUTF8, x, y, font, SkPaint());&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p cid=&quot;n144&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;文字绘制流程如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.0201342281879195&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ECThdibSVDxg8MJWE7VFSOYEDMqHzahjX8JMjOdpsicDoruWFbBPiciakc1pmUSwhPY4W8b26Lu13WRMiaWqcmkhKtA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;447&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n283&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;点阵字体最后解析成了位图，然后根据平台不同选用CPU或者GPU渲染出来。Skia为了提高字体显示速度，对字体的解析结果做了内存缓存。&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n154&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;4.2 矢量字体绘制原理&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n155&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;矢量字体主要通过贝塞尔曲线描述字体，存储空间小，但渲染复杂，还需要导入字体库文件。Skia支持的矢量字体有tff(true type font)和otf(open true type)格式。前者采用二次贝塞尔曲线表示，后者采用三次贝塞尔曲线表示。Skia中矢量文字绘制代码如下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;SkPaint p;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    p.setStyle(SkPaint::kStroke_Style);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    p.setStrokeWidth(10);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    p.setARGB(0xff, 0xbb, 0x00, 0x00);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   sk_sp&amp;lt;SkTypeface&amp;gt; ttf = MakeResourceAsTypeface(&quot;fonts/Stroking.ttf&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;SkFont font(ttf, 100);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;if (ttf) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        SkFont font(ttf, 100);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        canvas-&amp;gt;drawString(&quot;○◉  ⁻₋⁺₊&quot;, 10, 100, font, p);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p cid=&quot;n155&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;绘制流程如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.025&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ECThdibSVDxg8MJWE7VFSOYEDMqHzahjXNq83QcoZFdXefCHr36H6KHmC9ibfpIejRWQ8MuxxtkU73iaXic7rHzTHA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;440&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n168&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;矢量字体的绘制流程跟点阵字体大部分一样，不同之处在于解析结果为贝塞尔曲线。贝塞尔曲线的渲染算法稍微复杂，参考文章&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://www3.cs.stonybrook.edu/~qin/courses/geometry/4.pdf&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 cid=&quot;n169&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;5. 图片绘制原理&lt;/span&gt;&lt;/h2&gt;&lt;h3 cid=&quot;n170&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;5.1 Skia位图绘制原理&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n171&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;skia提供了showBitmap函数可直接显示位图。位图渲染模式跟矢量图形类似，分为CPU渲染和GPU渲染。位图的CPU渲染跟实心矩形的渲染原理类似，通过SIMD指令集将位图内存一行一行拷贝到指定内存缓存中。GPU渲染模式通过调用OpenGL、Metal、vulkan的纹理贴图函数实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5407503234152652&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ECThdibSVDxg8MJWE7VFSOYEDMqHzahjXb9OD6vmJ1ksk7G5XFic8UW4Al6aUIeDJIoVkcIQUAJ8o7kibTxyFlHUQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;773&quot;/&gt;&lt;/p&gt;&lt;h3 cid=&quot;n292&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;5.2 Skia压缩格式图片绘制原理&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n174&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;位图由于占用空间大，使用频率低，大部分情况下使用压缩格式图片。Skia支持的压缩格式图片如下：&lt;/span&gt;&lt;/p&gt;&lt;figure cid=&quot;n175&quot; mdtype=&quot;table&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr cid=&quot;n176&quot; mdtype=&quot;table_row&quot;&gt;&lt;th&gt;&lt;span&gt;格式&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;优点&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;缺点&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;场景&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;依赖解码库&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr cid=&quot;n182&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;gif&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;文件小，支持动画、透明，无兼容性问题&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;只支持种颜色，且透明度只有1位，有白边和锯齿&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;简单的动图&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;libgifcodec&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n188&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;jpg&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;支持位真彩色，压缩率高&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;有损压缩，不支持透明通道&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;色彩丰富的图片&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;libjpeg-turbo&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n194&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;png&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;无损压缩，支持透明，简单图片尺寸小&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;不支持动画，压缩率低&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;logo/icon/透明图&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;libpng&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n200&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;webp&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;比jpeg压缩率更高，支持有损和无损压缩，支持动画、透明通道&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;谷歌自研格式，部分平台不支持。&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;支持有损和无损压缩格式，支持动画&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;libwebp&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h4 cid=&quot;n69&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;左右滑动查看完整表格&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n206&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;压缩格式图片使用代码如下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;SkCanvas c(dst);  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    SkBitmap src;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    SkImageDecoder::DecodeFile(“test.jpg”, &amp;amp;src);//  图片解码&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    c.drawBitmap(src, 0, 0, NULL);  //图片显示&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p cid=&quot;n206&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;显示流程如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.8160377358490566&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ECThdibSVDxg8MJWE7VFSOYEDMqHzahjXPvg5u1dxIicsTkWsVFq1y2M6XRQB2lNh4StHJCwRlvibyUlKmgBN5jEQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;424&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n213&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;读取文件后，先通过文件头判断图片类型，然后送相应的图片库解码成位图图像后，再通过CPU或者GPU渲染。&lt;/span&gt;&lt;/p&gt;&lt;h2 cid=&quot;n214&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;6. skia小结&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n215&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Skia是一个功能强大的跨平台图形库，能绘制矩形、圆形、贝塞尔曲线等矢量图，绘制点阵字体和矢量字体，显示jpeg、png、gif、webp等图片，同时性能好，从算法和硬件两个层面进行了优化。skia支持多种软硬件平台，除了Android、chrome、Flutter等产品直接将其作为图形引擎，也支持iOS、windows等操作系统。Skia功能较多，还支持lottie动画，图像特效，还引入了中间语言SKGL，限于篇幅，这里不再展开。&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n216&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;参考文档：&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;1. iOS高性能绘图：&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://medium.com/@almalehdev/high-performance-drawing-on-ios-part-1-f3a24a0dcb31&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. Core Animation 编程指南：&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004514-CH1-SW1&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. skia编译方法：&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://skia.org/user/build&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4&lt;span&gt;. &lt;/span&gt;Skia技术路线：https://docs.google.com/document/d/1C9w8qpPpdgNGThqmgNnTToLZ5UYK4TsUGl5X3B_q6oM/edit&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5&lt;span&gt;. &lt;/span&gt;SKGL说明：&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/google/skia/blob/master/src/sksl/README&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;6&lt;span&gt;. &lt;/span&gt;Skia源码：&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://skia.googlesource.com/skia.git&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;7&lt;span&gt;. &lt;/span&gt;Skia 百科：&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://zh.wikipedia.org/zh-cn/Skia_Graphics_Library&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;8&lt;span&gt;. &lt;/span&gt;字体介绍：http://www.klayge.org/wiki/index.php/%E5%AD%97%E4%BD%93%E7%B3%BB%E7%BB%9F&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;9&lt;span&gt;. &lt;/span&gt;FreeType官网：&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://www.freetype.org/&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;10&lt;span&gt;. &lt;/span&gt;png压缩原理：&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://www.jianshu.com/p/5ad19825a3d0&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;11&lt;span&gt;. &lt;/span&gt;GPU渲染流水线：&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://zhuanlan.zhihu.com/p/61949898&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;12&lt;span&gt;. &lt;/span&gt;Vukan介绍：&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://www.khronos.org/assets/uploads/developers/library/overview/Vk_201602_Overview_Feb16.pdf&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;13&lt;span&gt;. &lt;/span&gt;ARM Mali GPU介绍：&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://developer.arm.com/solutions/graphics-and-gaming/apis/vulkan&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;14&lt;span&gt;. &lt;/span&gt;Vulkan和OpenGL ES比较：&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://community.arm.com/developer/tools-software/graphics/b/blog/posts/initial-comparison-of-vulkan-api-vs-opengl-es-api-on-arm&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;15&lt;span&gt;. &lt;/span&gt;Qualcomm宣布Adreno 530 GPU支持vulkan：&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://www.qualcomm.cn/news/releases-2016-02-18-0&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;16&lt;span&gt;. &lt;/span&gt;https://www.adobe.com/content/dam/acom/en/devnet/font/pdfs/5005.BDF_Spec.pdf&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;☆ &lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;END&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt; ☆&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;招聘信息&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section label=&quot;Copyright Reserved by PLAYHUDONG.&quot; donone=&quot;shifuMouseDownCard(&#x27;shifu_c_008&#x27;)&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section label=&quot;Copyright Reserved by PLAYHUDONG.&quot; donone=&quot;shifuMouseDownCard(&#x27;shifu_c_008&#x27;)&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section label=&quot;Copyright Reserved by PLAYHUDONG.&quot; donone=&quot;shifuMouseDownCard(&#x27;shifu_c_008&#x27;)&quot;&gt;&lt;p&gt;&lt;span&gt;OPPO互联网基础技术团队招聘一大波岗位，涵盖&lt;strong&gt;C++、Go、OpenJDK、Java、DevOps、Android、ElasticSearch&lt;/strong&gt;等多个方向，&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4MzE2MzY1OA==&amp;amp;mid=2247484254&amp;amp;idx=2&amp;amp;sn=bccee04adfd2c2e7d72b427c32f5891c&amp;amp;chksm=cf4ad43bf83d5d2d0d4ced10e8b047565e8fb765ab1ea62a5fb1c4d5b77a1ac8248a9afca96f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;请点击这里查看详细信息及JD&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;strong&gt;请点击这里查看详细信息及JD&lt;/strong&gt;&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你可能还喜欢&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section label=&quot;Copyright Reserved by PLAYHUDONG.&quot; donone=&quot;shifuMouseDownCard(&#x27;shifu_c_008&#x27;)&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section label=&quot;Copyright Reserved by PLAYHUDONG.&quot; donone=&quot;shifuMouseDownCard(&#x27;shifu_c_008&#x27;)&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section label=&quot;Copyright Reserved by PLAYHUDONG.&quot; donone=&quot;shifuMouseDownCard(&#x27;shifu_c_008&#x27;)&quot;&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4MzE2MzY1OA==&amp;amp;mid=2247485081&amp;amp;idx=1&amp;amp;sn=aaf43d2b82145a9c07c94ae6d024654e&amp;amp;chksm=cf4ad1fcf83d58ea7e77b359e2e4c19d52d8f18d80ad3c23c8f7f950f10efc1d326270e0279e&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;前端插件化架构的探索和实践&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4MzE2MzY1OA==&amp;amp;mid=2247484222&amp;amp;idx=1&amp;amp;sn=51f2c71fef5ffe6441a173e02bab9464&amp;amp;chksm=cf4ad45bf83d5d4d77f2b0e098067f2e00d54568f7a7ef7be89927c7d6de9afc1714310a0d71&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;JavaScript 异步之路&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4MzE2MzY1OA==&amp;amp;mid=2247484945&amp;amp;idx=1&amp;amp;sn=f3bbc20122db55510e03576e96da728a&amp;amp;chksm=cf4ad174f83d586279eddd4d30c077b3505467f7c50eb69f530fc7ca6edbff517d94fdb5c0b3&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;微服务全链路异步化实践&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4MzE2MzY1OA==&amp;amp;mid=2247484902&amp;amp;idx=1&amp;amp;sn=34904f4f3af88bed24a7e052f3526044&amp;amp;chksm=cf4ad283f83d5b959ca17d2560c1ba4c360bda3595418708a7898b1ed27c1b0331f3e2a54b1c&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;Dubbo协议解析与ESA RPC实践&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4MzE2MzY1OA==&amp;amp;mid=2247485454&amp;amp;idx=1&amp;amp;sn=ccb0ff7f6230ea8049a5a842f71a6f40&amp;amp;chksm=cf4adf6bf83d567d84f35b0b6058c0b0afb8eded93e32ff5f71de7cfb8c7d08af5b3b2f3a8b8&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;qiankun 微前端原理与实践&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;更多技术干货&lt;/span&gt;&lt;/p&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;扫码关注&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;OPPO互联网技术&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;120&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;120&quot; data-ratio=&quot;1&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ECThdibSVDxjYDM1fnDY1N9LLUp4gJV8ulKxP20jO66gHdE8q9DgFIB5hvxfBxEERyWeSxpc6nor8SPgiadWNVsQ/640?wx_fmt=jpeg&quot;/&gt; &lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;95172&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-brushtype=&quot;text&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;我就知道你“在看”&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;__bg_gif&quot; data-ratio=&quot;1.0377358490566038&quot; data-type=&quot;gif&quot; data-w=&quot;53&quot; data-width=&quot;100%&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/ECThdibSVDxjYDM1fnDY1N9LLUp4gJV8uk9kQ2Hw3Ucae5fnjEfVb2noBlx2NuTgMwzuiceEL19F9prbiaKnZZd3A/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9bff4502c7da68a617d26c9c185fe025</guid>
<title>鸿蒙开发板 HI3516 用命令行连接 wifi</title>
<link>https://toutiao.io/k/phkllhg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-content&quot; id=&quot;post-content&quot; itemprop=&quot;postContent&quot;&gt;
            &lt;blockquote&gt;
&lt;p&gt;鸿蒙的HI3516编译里已经有wpa_supplicant相关工程了，但编译时没有包进去, 所以只要修改配置文件后就能编译出来了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;主要修改文件: &lt;a href=&quot;https://gitee.com/openharmony/applications_sample_camera/blob/master/communication/BUILD.gn#L17-18&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;communication/BUILD.gn#L17-18&lt;/a&gt; 行之间添加， 以下第2行&lt;br/&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;features = [&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;   &quot;wpa_supplicant:wpa_sample&quot;,&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;编译过程&quot;&gt;&lt;a href=&quot;#编译过程&quot; class=&quot;headerlink&quot; title=&quot;编译过程&quot;/&gt;编译过程&lt;/h3&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker run --rm -ti -e HARDWARE=ipcamera_hi3516dv300 -v ${PWD}/out:/OpenHarmony/out ystyle/open-harmony bash&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;sed -i &#x27;17a\ \ \ \ \ \ &quot;wpa_supplicant:wpa_sample&quot;,&#x27; applications/sample/camera/communication/BUILD.gn&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;python build.py ${HARDWARE} -b debug&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;然后wpa_supplicant在编译目录&lt;code&gt;/out/ipcamera_hi3516dv300/bin/&lt;/code&gt;， 把wpa_supplicant复制出来就可以直接使用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;使用方法&quot;&gt;&lt;a href=&quot;#使用方法&quot; class=&quot;headerlink&quot; title=&quot;使用方法&quot;/&gt;使用方法&lt;/h3&gt;&lt;p&gt;先创建配置文件，wpa_supplicant.conf&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;country=GB&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;ctrl_interface=udp&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;network={&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    #要连接的SSID&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    ssid=&quot;example&quot;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    #如果不需要加密就写key_mgmt=NONE&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    #key_mgmt=NONE&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    #如果需要加密就写这行密码&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    psk=&quot;AA123456&quot;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;把wpa_supplicant和配置文件复制到hi3516， 执行以下命令连接wifi&lt;br/&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cd /nfs/wifi&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;./wpa_supplicant -i wlan0 -c ./wpa_supplicant.conf&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;

        &lt;/div&gt;

        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>10cdab1c7ebf093c52f49186571e4cc9</guid>
<title>并发编程：用 SingleFlight 合并重复请求</title>
<link>https://toutiao.io/k/y2btneh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好啊，今天网管想给大家介绍一下&lt;code&gt;Go&lt;/code&gt;的&lt;code&gt;singleflight&lt;/code&gt;包，当然它不是直译过来的单飞的意思~~！&lt;code&gt;SingleFlight&lt;/code&gt;是&lt;code&gt;Go&lt;/code&gt;语言&lt;code&gt;sync&lt;/code&gt;扩展库提供的另一种并发原语，那么&lt;code&gt;SingleFlight&lt;/code&gt;是用于解决什么问题的呢？官方文档里的解释是：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Package singleflight provides a duplicate function call suppression mechanism.&lt;/p&gt;&lt;p&gt;翻译过来就是：singleflight包提供了一种抑制重复函数调用的机制。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体到&lt;code&gt;Go&lt;/code&gt;程序运行的层面来说，&lt;code&gt;SingleFlight&lt;/code&gt;的作用是在处理多个&lt;code&gt;goroutine&lt;/code&gt;同时调用同一个函数的时候，只让一个&lt;code&gt;goroutine&lt;/code&gt;去实际调用这个函数，等到这个&lt;code&gt;goroutine&lt;/code&gt;返回结果的时候，再把结果返回给其他几个同时调用了相同函数的&lt;code&gt;goroutine&lt;/code&gt;，这样可以减少并发调用的数量。在实际应用中也是，它能够在一个服务中减少对下游的并发重复请求。还有一个比较常见的使用场景是用来防止缓存击穿。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Go提供的SingleFlight&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Go&lt;/code&gt;扩展库里用&lt;code&gt;singleflight.Group&lt;/code&gt;结构体类型提供了&lt;code&gt;SingleFlight&lt;/code&gt;并发原语的功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;singleflight.Group&lt;/code&gt;类型提供了三个方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(g *Group)&lt;/span&gt; &lt;span&gt;Do&lt;/span&gt;&lt;span&gt;(key &lt;span&gt;string&lt;/span&gt;, fn &lt;span&gt;func&lt;/span&gt;()&lt;/span&gt; &lt;span&gt;(&lt;span&gt;interface&lt;/span&gt;{}, error)&lt;/span&gt;) &lt;span&gt;(v &lt;span&gt;interface&lt;/span&gt;{}, err error, shared &lt;span&gt;bool&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(g *Group)&lt;/span&gt; &lt;span&gt;DoChan&lt;/span&gt;&lt;span&gt;(key &lt;span&gt;string&lt;/span&gt;, fn &lt;span&gt;func&lt;/span&gt;()&lt;/span&gt; &lt;span&gt;(&lt;span&gt;interface&lt;/span&gt;{}, error)&lt;/span&gt;) &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;Result&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(g *Group)&lt;/span&gt; &lt;span&gt;Forget&lt;/span&gt;&lt;span&gt;(key &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Do&lt;/strong&gt;方法，接受一个字符串Key和一个待调用的函数，会返回调用函数的结果和错误。使用Do方法的时候，它会根据提供的Key判断是否去真正调用&lt;code&gt;fn&lt;/code&gt;函数。同一个 key，在同一时间只有第一次调用Do方法时才会去执行&lt;code&gt;fn&lt;/code&gt;函数，其他并发的请求会等待调用的执行结果。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;DoChan&lt;/strong&gt;方法：类似Do方法，只不过是一个异步调用。它会返回一个通道，等&lt;code&gt;fn&lt;/code&gt;函数执行完，产生了结果以后，就能从这个 chan 中接收这个结果。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Forget&lt;/strong&gt;方法：在SingleFlight中删除一个Key。这样一来，之后这个Key的Do方法调用会执行&lt;code&gt;fn&lt;/code&gt;函数，而不是等待前一个未完成的&lt;code&gt;fn&lt;/code&gt; 函数的结果。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;应用场景&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;了解了Go语言提供的 SingleFlight并发原语都有哪些方法可以调用后 ，下面介绍两个它的应用场景。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;查询DNS记录&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Go&lt;/code&gt;语言的&lt;code&gt;net&lt;/code&gt;标准库里使用的&lt;code&gt;lookupGroup&lt;/code&gt;结构，就是Go扩展库提供的原语&lt;code&gt;singleflight.Group&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Resolver &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;  ......&lt;br/&gt; &lt;span&gt;// 源码地址 https://github.com/golang/go/blob/master/src/net/lookup.go#L151&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// lookupGroup merges LookupIPAddr calls together for lookups for the same&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// host. The lookupGroup key is the LookupIPAddr.host argument.&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// The return values are ([]IPAddr, error).&lt;/span&gt;&lt;br/&gt; lookupGroup singleflight.Group&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的作用是将对相同域名的DNS记录查询合并成一个查询，下面是&lt;code&gt;net&lt;/code&gt;库提供的DNS记录查询方法&lt;code&gt;LookupIp&lt;/code&gt;使用&lt;code&gt;lookupGroup&lt;/code&gt;这个SingleFlight进行合并查询的相关源码，它使用的是异步查询的方法&lt;code&gt;DoChan&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func LookupIP(host string) ([]IP, error) {&lt;br/&gt; addrs, err := DefaultResolver.LookupIPAddr(context.Background(), host)&lt;br/&gt;  ......&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func (r *Resolver) lookupIPAddr(ctx context.Context, network, host string) ([]IPAddr, error) {&lt;br/&gt;  ......&lt;br/&gt;  // 使用SingleFlight的DoChan合并多个查询请求&lt;br/&gt; ch, called := r.getLookupGroup().DoChan(lookupKey, func() (interface{}, error) {&lt;br/&gt;  defer dnsWaitGroup.Done()&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; testHookLookupIP(lookupGroupCtx, resolverFunc, network, host)&lt;br/&gt; })&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; !called {&lt;br/&gt;  dnsWaitGroup.Done()&lt;br/&gt; }&lt;br/&gt; &lt;br/&gt; select {&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; &amp;lt;-ctx.Done():&lt;br/&gt;  ......&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; r := &amp;lt;-ch:&lt;br/&gt;  lookupGroupCancel()&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; trace != nil &amp;amp;&amp;amp; trace.DNSDone != nil {&lt;br/&gt;   addrs, _ := r.Val.([]IPAddr)&lt;br/&gt;   trace.DNSDone(ipAddrsEface(addrs), r.Shared, r.Err)&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; lookupIPReturn(r.Val, r.Err, r.Shared)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的源码做了很多删减，只留了&lt;code&gt;SingleFlight&lt;/code&gt;合并查询的部分，如果有兴趣可以去&lt;code&gt;GitHub&lt;/code&gt;上看一下完整的源码，访问链接https://github.com/golang/go/blob/master/src/net/lookup.go#L261 ，可直接定位到这部分的源码。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;网管是不是很贴心，记得三连啊~！&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;防止缓存击穿&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在项目里使用缓存时，一个常见的用法是查询一个数据先去查询缓存，如果没有就去数据库里查到数据并缓存到&lt;code&gt;Redis&lt;/code&gt;里。那么缓存击穿问题是指，高并发的系统中，大量的请求同时查询一个缓存Key 时，如果这个 Key 正好过期失效，就会导致大量的请求都打到数据库上，这就是缓存击穿。用 &lt;code&gt;SingleFlight&lt;/code&gt; 来解决缓存击穿问题再合适不过，这个时候只要这些对同一个 Key 的并发请求的其中一个到数据库中查询就可以了，这些并发的请求可以共享同一个结果。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.41058941058941056&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/z4pQ0O5h0f5ZOj4KGGfzLLQQ8PibN9fMThIN1E7mZQgxGubUt23yP3BuAYVM9lFzS7UQWdQK9pQwY9UYzIjAmfw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1001&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是一个模拟用&lt;code&gt;SingleFlight&lt;/code&gt;并发原语合并查询&lt;code&gt;Redis&lt;/code&gt;缓存的程序，你可以自己动手测试一下，开10个&lt;code&gt;goroutine&lt;/code&gt;去查询一个固定的Key，观察一下返回结果就会发现最终只执行了一次&lt;code&gt;Redis&lt;/code&gt;查询。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 模拟一个Redis客户端&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; client struct {&lt;br/&gt; // ... 其他的配置省略&lt;br/&gt; requestGroup singleflight.Group&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// 普通查询&lt;br/&gt;func (c *client) Get(key string) (interface{}, error) {&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;Querying Database&quot;&lt;/span&gt;)&lt;br/&gt; time.Sleep(time.Second)&lt;br/&gt; v := &lt;span&gt;&quot;Content of key&quot;&lt;/span&gt; + key&lt;br/&gt; &lt;span&gt;return&lt;/span&gt;  v, nil&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// SingleFlight查询&lt;br/&gt;func (c *client) SingleFlightGet(key string) (interface{}, error) {&lt;br/&gt; v, err, _ := c.requestGroup.Do(key, func() (interface{}, error) {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; c.Get(key)&lt;br/&gt;&lt;br/&gt; })&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; nil, err&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; v, err&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;完整的测试源码可以点击阅读原文，去我的GitHub仓库下载&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;实现原理&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后我们来看一下&lt;code&gt;singleflight.Group&lt;/code&gt;的实现原理，通过它的源码也是能学到不少用&lt;code&gt;Go&lt;/code&gt;语言编程的技巧的。&lt;code&gt;singleflight.Group&lt;/code&gt;由一个互斥锁&lt;code&gt;sync.Mutex&lt;/code&gt;和一个映射表组成，每一个 &lt;code&gt;singleflight.call&lt;/code&gt;结构体都保存了当前调用对应的信息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Group &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; mu sync.Mutex&lt;br/&gt; m  &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]*call&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; call &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; wg sync.WaitGroup&lt;br/&gt;&lt;br/&gt; val &lt;span&gt;interface&lt;/span&gt;{}&lt;br/&gt; err error&lt;br/&gt;&lt;br/&gt; dups  &lt;span&gt;int&lt;/span&gt;&lt;br/&gt; chans []&lt;span&gt;chan&lt;/span&gt;&amp;lt;- Result&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看看 Do 和 DoChan 方法是怎么实现的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Do方法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;SingleFlight&lt;/code&gt; 定义一个&lt;code&gt;call&lt;/code&gt;结构体，每个结构体都保存了&lt;code&gt;fn&lt;/code&gt;调用对应的信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Do方法的执行逻辑是每次调用Do方法都会先去获取互斥锁，随后判断在映射表里是否已经有Key对应的&lt;code&gt;fn&lt;/code&gt;函数调用信息的&lt;code&gt;call&lt;/code&gt;结构体。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当不存在时，证明是这个Key的第一次请求，那么会初始化一个&lt;code&gt;call&lt;/code&gt;结构体指针，增加&lt;code&gt;SingleFlight&lt;/code&gt;内部持有的&lt;code&gt;sync.WaitGroup&lt;/code&gt;计数器到1。释放互斥锁，然后阻塞的等待doCall方法执行&lt;code&gt;fn&lt;/code&gt;函数的返回结果&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当存在时，增加&lt;code&gt;call&lt;/code&gt;结构体内代表&lt;code&gt;fn&lt;/code&gt;重复调用次数的计数器&lt;code&gt;dups&lt;/code&gt;，释放互斥锁，然后使用&lt;code&gt;WaitGroup&lt;/code&gt;等待&lt;code&gt;fn&lt;/code&gt;函数执行完成。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;call&lt;/code&gt;结构体的&lt;code&gt;val&lt;/code&gt; 和 &lt;code&gt;err&lt;/code&gt; 两个字段只会在 &lt;code&gt;doCall&lt;/code&gt;方法中执行&lt;code&gt;fn&lt;/code&gt;有返回结果后才赋值，所以当 &lt;code&gt;doCall&lt;/code&gt;方法 和 &lt;code&gt;WaitGroup.Wait&lt;/code&gt;返回时，函数调用的结果和错误会返回给Do方法的所有调用者。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(g *Group)&lt;/span&gt; &lt;span&gt;Do&lt;/span&gt;&lt;span&gt;(key &lt;span&gt;string&lt;/span&gt;, fn &lt;span&gt;func&lt;/span&gt;()&lt;/span&gt; &lt;span&gt;(&lt;span&gt;interface&lt;/span&gt;{}, error)&lt;/span&gt;) &lt;span&gt;(v &lt;span&gt;interface&lt;/span&gt;{}, err error, shared &lt;span&gt;bool&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    g.mu.Lock()&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; g.m == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;      g.m = &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]*call)&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; c, ok := g.m[key]; ok {&lt;br/&gt;      &lt;span&gt;// 存在相同的key, 增加计数&lt;/span&gt;&lt;br/&gt;      c.dups++&lt;br/&gt;      g.mu.Unlock()&lt;br/&gt;      c.wg.Wait() &lt;span&gt;//等待这个key对应的fn调用完成&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; c.val, c.err, &lt;span&gt;true&lt;/span&gt; &lt;span&gt;// 返回fn调用的结果&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    c := &lt;span&gt;new&lt;/span&gt;(call) &lt;span&gt;// 不存在key, 是第一个请求, 创建一个call结构体&lt;/span&gt;&lt;br/&gt;    c.wg.Add(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;    g.m[key] = c &lt;span&gt;//加入到映射表中&lt;/span&gt;&lt;br/&gt;    g.mu.Unlock()&lt;br/&gt;  &lt;br/&gt;&lt;br/&gt;    g.doCall(c, key, fn) &lt;span&gt;// 调用方法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; c.val, c.err, c.dups &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;doCall&lt;/code&gt;方法会去实际调用&lt;code&gt;fn&lt;/code&gt;函数，因为&lt;code&gt;call&lt;/code&gt;结构体初始化后&lt;code&gt;forgotten&lt;/code&gt;字段的默认值是&lt;code&gt;false&lt;/code&gt;，&lt;code&gt;fn&lt;/code&gt;调用有返回后，会把对应的Key删掉。这样这轮请求都返回后，下一轮使用同一的Key的请求会重新调用执行一次&lt;code&gt;fn&lt;/code&gt;函数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;  func (g *Group) doCall(c *call, key string, fn func() (interface{}, error)) {&lt;br/&gt;    c.val, c.err = fn()&lt;br/&gt;    c.wg.Done()&lt;br/&gt;  &lt;br/&gt;&lt;br/&gt;    g.mu.Lock()&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; !c.forgotten { // 已调用完，删除这个key&lt;br/&gt;      delete(g.m, key)&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; _, ch := range c.chans {&lt;br/&gt;      ch &amp;lt;- Result{c.val, c.err, c.dups &amp;gt; 0}&lt;br/&gt;    }&lt;br/&gt;    g.mu.Unlock()&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;DoChan方法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;SingleFlight&lt;/code&gt;还提供了异步调用&lt;code&gt;DoChan&lt;/code&gt;方法，它的执行逻辑和&lt;code&gt;Do&lt;/code&gt;方法类似，唯一不同的是调用者不用阻塞等待调用的返回， &lt;code&gt;DoChan&lt;/code&gt;方法会创建一个&lt;code&gt;chan Result&lt;/code&gt;通道返回给调用者，调用者通过这个通道就能接受到&lt;code&gt;fn&lt;/code&gt;函数的结果。这个&lt;code&gt;chan Result&lt;/code&gt;通道，在返回给调用者前会先放到&lt;code&gt;call&lt;/code&gt;结构体的维护的通知队列里，待&lt;code&gt;fn&lt;/code&gt;函数返回结果后&lt;code&gt;DoChan&lt;/code&gt;方法会把结果发送给通知队列中的每个通道。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(g *Group)&lt;/span&gt; &lt;span&gt;DoChan&lt;/span&gt;&lt;span&gt;(key &lt;span&gt;string&lt;/span&gt;, fn &lt;span&gt;func&lt;/span&gt;()&lt;/span&gt; &lt;span&gt;(&lt;span&gt;interface&lt;/span&gt;{}, error)&lt;/span&gt;) &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;Result&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; ch := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; Result, &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt; g.mu.Lock()&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; g.m == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  g.m = &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]*call)&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; c, ok := g.m[key]; ok {&lt;br/&gt;  c.dups++&lt;br/&gt;  c.chans = &lt;span&gt;append&lt;/span&gt;(c.chans, ch)&lt;br/&gt;  g.mu.Unlock()&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; ch&lt;br/&gt; }&lt;br/&gt; c := &amp;amp;call{chans: []&lt;span&gt;chan&lt;/span&gt;&amp;lt;- Result{ch}}&lt;br/&gt; c.wg.Add(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt; g.m[key] = c&lt;br/&gt; g.mu.Unlock()&lt;br/&gt;&lt;br/&gt; &lt;span&gt;go&lt;/span&gt; g.doCall(c, key, fn)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; ch&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Result &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Val    &lt;span&gt;interface&lt;/span&gt;{}&lt;br/&gt; Err    error&lt;br/&gt; Shared &lt;span&gt;bool&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;学会&lt;code&gt;SingleFlight&lt;/code&gt;这个并发原语后，下次在遇到类似在高并发情况下查询DNS记录、Redis缓存这样的场景的时候就可以应用上啦。最后我给你留个思考题吧，上面用&lt;code&gt;SingleFlight&lt;/code&gt;查询&lt;code&gt;Redis&lt;/code&gt;缓存的例子使用的是同步阻塞方法&lt;code&gt;Do&lt;/code&gt;，你能不能改成使用异步非阻塞的&lt;code&gt;DoChan&lt;/code&gt;方法呢？另外能不能给&lt;code&gt;SingleFlightGet&lt;/code&gt;增加一个超时返回错误的功能呢？&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;提示一下，使用上下文对象，返回的错误是ctx.Err()&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以把在留言里写下你的解决方案，最好能附上源码链接，欢迎把文章分享给你更多的朋友，一起讨论。还没关注公众号「网管叨bi叨」的抓紧关注呀，每周都会有干货技术分享。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关注公众号，获取更多精选技术原创文章&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.0188679245283019&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;318&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f4icJbGAQ8RjXUUVdUZsGADuMBVWePgn7tfrWjjHyc6b8kXTQ7Sdkp0QQFFK4mel5tniczqooMna1CA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>be16f0765aab6d3537e62aa94b4c6ed2</guid>
<title>打日志还能打出个线上 Bug，太难了</title>
<link>https://toutiao.io/k/9p8zgng</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;某日中午，收到告警，有一笔订单下单失败了。赶紧去 Cat 看了下错误信息，如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.19803063457330417&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WRLYshvT39xviap51u0HOlEibxddgwK2gmPqbTt7zNicicgLdznlOBrIwPiaErl1JZJxS05U3DJOZzh1s6Ee5HdLzTQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1828&quot;/&gt;&lt;figcaption&gt;异常信息&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Web 应用调用订单服务的 RPC 接口报错了，一看错误很自主的认为这是一个序列化的问题。后面排查下来发现压根就不是，这个错误报的有点。。。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想着是不是参数中有什么特别的东西，然后发现也没有什么特别的。这个错误是某个商品下单才会出现，不是所有的商品都会出现这个问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后尝试在本地复现，有这么一行关键的代码，贴了一部分，完整的作用是埋点打日志。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String.format(&quot;UnifiedOrderServiceImpl.makeOrder创建订单, make order, request: MakeOrderRequest= &quot;+ request)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说实话我是没看懂这里用 String.format 的原因在哪里，不就是想拼接个字符串么？还搞个 format，搞就搞嘛，还没用占位符，骚操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;真正 Bug 的原因是 request 对象中有个 String 类型的字段，字段里面的内容有%\，format 内部就报错了，大家可以用下面这段代码复现错误：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public static void main(String[] args) {&lt;br/&gt;   String.format(&quot;dsdsdsd&quot;+&quot;%\\sdsd&quot;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;错误信息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Exception in thread &quot;main&quot; java.util.UnknownFormatConversionException: Conversion = &#x27;\&#x27;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原因是在 format 中会校验参数，然后触发了异常。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2554858934169279&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WRLYshvT39xviap51u0HOlEibxddgwK2gmtuYmmicp2ao1Yj2gyoXzurQ1OZB23ic2iasFkxQ5QMIxsKrDwoWUWckWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1276&quot;/&gt;&lt;figcaption&gt;判断文本内容&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然是很小的改动，就记录个日志而已，但也不要轻视，往往就是不够仔细，然后才会出这种问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结：&lt;/p&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;关于作者&lt;/strong&gt;：尹吉欢，简单的技术爱好者，《Spring Cloud 微服务-全栈技术与案例解析》, 《Spring Cloud 微服务 入门 实战与进阶》作者, 公众号&lt;strong&gt;猿天地&lt;/strong&gt;发起人。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我整理了一份很全的学习资料，感兴趣的可以微信搜索「&lt;strong&gt;猿天地&lt;/strong&gt;」，回复关键字 「&lt;strong&gt;学习资料&lt;/strong&gt;」获取我整理好了的 Spring Cloud，Spring Cloud Alibaba，Sharding-JDBC 分库分表，任务调度框架 XXL-JOB，MongoDB，爬虫等相关资料。&lt;/p&gt;&lt;p&gt;后台回复 &lt;strong&gt;&lt;span&gt;学习资料&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;领取学习视频&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.511002444987775&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WRLYshvT39zWmaics1nAAwT4NCD77uDcf6vcXE1DAHybibTY0V3XDmf4YX1q9qYibIwz9xmRVTkEvTjP87gaKEZrQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;818&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如有收获，点个在看，诚挚感谢&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;&gt;我不差钱啊&lt;/p&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>