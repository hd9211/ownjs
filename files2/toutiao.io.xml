<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>7972a065c5bd60fadcf5e034a3c588cd</guid>
<title>基于时间线的 Feed 流后台系统设计</title>
<link>https://toutiao.io/k/yy8cawz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;&lt;span&gt;| 导语  &lt;/span&gt;&lt;span&gt;本文将总结一下常用的基于时间线Feed流的后台存储设计方案。结合具体的业务场景，讲述一下根据实际需求，在基本设计思路上做一些灵活运用。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h1 data-mid=&quot;&quot;&gt;01&lt;/h1&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;背景介绍&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Feed流产品在我们手机APP中几乎无处不在，常见的Feed流比如微信朋友圈、新浪微博、今日头条等。对Feed流的定义，可以简单理解为只要大拇指不停地往下划手机屏幕，就有一条条的信息不断涌现出来。就像给牲畜喂饲料一样，只要它吃光了就要不断再往里加，故此得名Feed（饲养）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大多数Feed流产品都包含两种Feed流，一种是基于算法推荐，另一种是基于关注（好友关系）。例如下图中的微博和知乎，顶栏的页卡都包含“关注”和“推荐”这两种。两种Feed流背后用到的技术差别会比较大。本文将重点探索一下“关注”页卡的后台实现方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.456&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jiboYA4jZECwia2nukSP19wlR1UA1MexAIicibFam6WcZxfibgMqWtSCHETM6ojOtmJjuWIEXLcYicicWPEsvFCZA9gOw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图片来源:新浪微博&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5106666666666667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jiboYA4jZECwia2nukSP19wlR1UA1MexAIjBgRzGj09712g4icG1kNeOXgvJnfhflF6UJlLfUbk3LFHwD3VBQ5qpQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图片来源:知乎&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不同于“推荐”页卡那种千人前面算法推荐的方式，通常“关注”页卡所展示的内容先后顺序都有固定的规则，最常见的规则是基于时间线来排序，也就是展示“我关注的人所发的帖子，&lt;/span&gt;&lt;span&gt;根据发帖时间从晚到早依次排列&lt;/span&gt;&lt;span&gt;”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h1 data-mid=&quot;&quot;&gt;02&lt;/h1&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;Feed流实现方案介绍&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;方案1——读扩散&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;读扩散也称为拉模式，这应该是最符合我们直觉的一种实现方式。如下图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6164167324388319&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jiboYA4jZECwia2nukSP19wlR1UA1MexAIL5cG4Jib8ga3JFY696FHgX1qqd0icUjdAmqwVyLYbbmNUGvFJehZJicibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1267&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;每一个内容发布者都有一个自己的发件箱（“我发布的内容”），每当我们发出一个新帖子，都存入自己的发件箱中。当我们的粉丝来阅读时，系统首先需要拿到粉丝关注的所有人，然后遍历所有发布者的发件箱，取出他们所发布的帖子，然后依据发布时间排序，展示给阅读者。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种设计，阅读者&lt;/span&gt;&lt;span&gt;读一次&lt;/span&gt;&lt;span&gt;Feed流，后台&lt;/span&gt;&lt;span&gt;会扩散为N次读操作&lt;/span&gt;&lt;span&gt;（N等于关注的人数）以及一次聚合操作，因此称为读扩散。每次读Feed流相当于去关注者的收件箱主动拉取帖子，因此也得名拉模式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种模式的好处是底层存储简单，没有空间浪费。坏处是每次读操作会非常重，操作非常多。设想一下如果我关注的人数非常多，遍历一遍我所关注的所有人，并且再聚合一下，这个系统开销会非常大，时延上可能达到无法忍受的地步。因此读扩散主要适用系统中阅读者关注的人没那么多，并且刷Feed流并不频繁的场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;拉模式还有一个比较大的缺点就是分页不方便，我们刷微博或朋友圈，肯定是随着大拇指在屏幕不断划动，内容一页一页的从后台拉取。如果不做其他优化，只采用实时聚合的方式，下滑到比较靠后的页码时会非常麻烦。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;方案2——写扩散&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;据统计，大多数Feed流产品的读写比大概在100:1，也就是说大部分情况都是刷Feed流看别人发的朋友圈和微博，只有很少情况是自己亲自发一条朋友圈或微博给别人看。因此，读扩散那种很重的读逻辑并不适合大多数场景。我们宁愿让发帖的过程复杂一些，也不愿影响用户读Feed流的体验，因此稍微改造一下前面方案就有了写扩散。写扩散也称为推模式，这种模式会对拉模式的一些缺点做改进。如下图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6187845303867403&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jiboYA4jZECwia2nukSP19wlR1UA1MexAI8h0GN9j2NxibTXRh7QNRWERy44BNJdt33ynsjvaIYTt8u2mcVSCibdrQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1267&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;系统中每个用户除了有发件箱，也会有自己的收件箱。当发布者发表一篇帖子的时候，除了往自己发件箱记录一下之外，还会遍历发布者的所有粉丝，往这些粉丝的收件箱也投放一份相同内容。这样阅读者来读Feed流时，直接从自己的收件箱读取即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种设计，&lt;/span&gt;&lt;span&gt;每次发表帖子，都会扩散为M次写操作&lt;/span&gt;&lt;span&gt;（M等于自己的粉丝数），因此成为写扩散。每篇帖子都会主动推送到所有粉丝的收件箱，因此也得名推模式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种模式可想而知，发一篇帖子，背后会涉及到很多次的写操作。通常为了发帖人的用户体验，当发布的帖子写到自己发件箱时，就可以返回发布成功。后台另外起一个异步任务，不慌不忙地往粉丝收件箱投递帖子即可。写扩散的好处在于通过数据冗余（一篇帖子会被存储M份副本），提升了阅读者的用户体验。通常适当的数据冗余不是什么问题，但是到了微博明星这里，完全行不通。比如目前微博粉丝量Top2的谢娜与何炅，两个人微博粉丝过亿。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.40175219023779724&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jiboYA4jZECwia2nukSP19wlR1UA1MexAIoUYdzOIUVULHVicSdNk4iaXleaaZ9q4qpaicNvicPpBFB08NYnuciaVhwaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1598&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图片来源：&lt;/span&gt;&lt;span&gt;新浪&lt;/span&gt;&lt;span&gt;微博&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;设想一下，如果单纯采用推模式，那每次谢娜何炅发一条微博，微博后台都要地震一次。一篇微博导致后台上亿次写操作，这显然是不可行的。另外由于写扩散是异步操作，写的太慢会导致帖子发出去半天，有些粉丝依然没能看见，这种体验也不太好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通常写扩散适用于好友量不大的情况，据悉微信朋友圈正是写扩散模式。每一名微信用户的好友上限为5000人，也就是说你发一条朋友圈最多也就扩散到5000次写操作，如果异步任务性能好一些，完全没有问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;方案3——读写混合模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;读写混合也可以称作推拉结合。这种方式可以兼具读扩散和写扩散的优点。我们首先来总结一下读扩散和写扩散的优缺点：&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;优点&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;缺点&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;适用场景&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;读扩散&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;节约存储空间&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;发帖操作简单&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;读帖操作复杂&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关注人数多时是灾难&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;用户不活跃，很少读帖&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有大V粉丝量多，但每个粉丝关注的人少&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;写扩散&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;读帖操作简单&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;发帖操作复杂，浪费存储空间&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大V粉丝量多时是灾难&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;用户非常活跃，经常刷帖&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;无大V，用户粉丝量都比较少&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;仔细比较一下读扩散与写扩散的优缺点，不难发现两者的适用场景是互补的。因此在设计后台存储的时候，我们如果能够区分一下场景，在不同场景下选择最适合的方案，并且动态调整策略，就实现了读写混合模式。如下图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5511811023622047&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jiboYA4jZECwia2nukSP19wlR1UA1MexAIRmT9V432l0mAtDhycHicnM3ia1HFo8I00jqt17Xodz292xr7cOXh8FTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1270&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当何炅这种粉丝量超大的人发帖时，将帖子写入何炅的发件箱，另外提取出来何炅粉丝当中比较活跃的那一批（这已经可以筛掉大部分了），将何炅的帖子写入他们的收件箱。当一个粉丝量很小的路人甲发帖时，采用写扩散方式，遍历他的所有粉丝并将帖子写入粉丝收件箱。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于那些活跃用户登录刷Feed流时，他直接从自己的收件箱读取帖子即可，保证了活跃用户的体验。当一个非活跃的用户突然登录刷Feed流时，我们一方面需要读他的收件箱，另一方面需要遍历他所关注的大V用户的发件箱提取帖子，并且做一下聚合展示。在展示完后，系统还需要有个任务来判断是否有必要将该用户升级为活跃用户。因为有读扩散的场景存在，因此即使是混合模式，每个阅读者所能关注的人数也要设置上限，例如新浪微博限制每个账号最多可以关注2000人。如果不设上限，设想一下有一位用户把微博所有账号全部关注了，那他打开关注列表会读取到微博全站所有帖子，一旦出现读扩散，系统必然崩溃；即使是写扩散，他的收件箱也无法容纳这么多的微博。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;读写混合模式下，系统需要做两个判断。一个是哪些用户属于大V，我们可以将粉丝量作为一个判断指标。另一个是哪些用户属于活跃粉丝，这个判断标准可以是最近一次登录时间等。这两处判断标准就需要在系统发展过程中动态地识别和调整，没有固定公式了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看出读写结合模式综合了两种模式的优点，属于最佳方案。然而他的缺点是系统机制非常复杂，给程序员带来无数烦恼。通常在项目初期，只有一两个开发人员，用户规模也很小的时候，一步到位地采用这种混合模式还是要慎重，容易出bug。当项目规模逐渐发展到新浪微博的水平，有一个大团队专门来做Feed流时，读写混合模式才是必须的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Feed流中的分页问题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;前文已经叙述了基于时间线的Feed流常见设计方案，但实操起来会比理论要麻烦许多。接下来专门讨论一个困难点——Feed流的分页。不管是读扩散还是写扩散，Feed流本质上是一个动态列表，列表内容会随着时间不断变化。传统的前端分页参数使用page_size和page_num，分表表示每页几条，以及当前是第几页。对于一个动态列表会有如下问题：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.37381703470031546&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jiboYA4jZECwia2nukSP19wlR1UA1MexAIwX6v94mT3bOJmd8GBM0Lms3pul0ZcmfrcRGNtFkNVeePoicNy9CY6sg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1268&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在T1时刻读取了第一页，T2时刻有人新发表了“内容11”，在T3时刻如果来拉取第二页，会导致错位出现，“内容6”在第一页和第二页都被返回了。事实上，但凡两页之间出现内容的添加或删除，都会导致错位问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了解决这一问题，通常Feed流的分页入参不会使用page_size和page_num，而是使用last_id来记录上一页最后一条内容的id。前端读取下一页的时候，必须将last_id作为入参，后台直接找到last_id对应数据，再往后偏移page_size条数据，返回给前端，这样就避免了错位问题。如下图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.37381703470031546&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jiboYA4jZECwia2nukSP19wlR1UA1MexAIroJl1axDODe9VbQboNEah3iaACDkDEVFrjHtZYWnMQH7xDQicQqBDsiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1268&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;采用last_id的方案有一个重要条件，就是last_id本身这条数据不可以被硬删除。设想一下上图中T1时刻返回5条数据，last_id为内容6；T2时刻内容6被发布者删除；那么T3时刻再来请求第二页，我们根本找不到last_id对应的数据了，也就无法确认分页偏移量。通常碰到删除的场景，我们采用软删除方式，只是在内容上置一个标志位，表示内容已删除。由于已经删除的内容不应该再返回给前端，因此软删除模式下，找到last_id并往后偏移page_size条，如果其中有被删除的数据会导致获得足够的数据条数给前端。这里一个解决方案是找不够继续再往下找，另一种方案是与前端协商，允许返回条数少于page_size条，page_size只是个建议值。甚至大家约定好了以后，可以不要page_size参数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h1 data-mid=&quot;&quot;&gt;03&lt;/h1&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;实际业务应用&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;业务需求&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;文章最后结合我们自身业务，介绍一下实际业务场景中碰到的一个非常特殊的Feed流设计方案。直享直播是一款直播带货工具，主播可以创建一场未来时刻的直播，到时间后开播卖货，直播结束后，主播的粉丝可以查看直播回放。这样，每个直播场次就有三种状态——预告中（创建一场直播但还未开播）、直播中、回放。作为观众，我可以关注多位主播，这样从粉丝视角来看，也会有个直播场次的Feed流页面。这个Feed流最特殊的地方在于它的Feed流排序规则。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.8639652677279306&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jiboYA4jZECwia2nukSP19wlR1UA1MexAIUzQUWrk9GTu9iblPtjCrUicqfSJuoDss4HXPTkjJXWkBZhBXsUiczgiawg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;691&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Feed流排序规则：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.我关注的所有主播，正在直播中的场次排在最前；预告中的场次排中间；回放场次排最后&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.多场次都在直播中的，按开播时间从晚到早排序&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.多场次都在预告中的，按预计开播时间从早到晚排序&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4.多场次都在回放的，按直播结束时间从晚到早排序&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h1 data-mid=&quot;&quot;&gt;04&lt;/h1&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;问题分析&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本需求最复杂的点在于Feed流内容融入的“状态”因素，状态的转变会直接导致Feed流顺序不同。为了更清晰解释一下对排序的影响，我们可以用下图详细说明：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.53836784409257&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jiboYA4jZECwia2nukSP19wlR1UA1MexAIorRoCC7yjzlcKOvSz6ia4NOxOXRCiaGEwLGIjHqHrNcDmvNqKMStncyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1642&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图中展示了4个主播的5个直播场次，作为观众，当我在T1时刻打开页面，看到的顺序是场次3在最上方，其余场次均在预告状态，按照预计开播时间从早到晚展示。当我在T2时刻打开页面，场次5在最上方，其余有三场在预告状态排在中间，场次3已经结束了所以排在最后。以此类推，直到所有直播都结束，所有场次最终的状态都会变为回放。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里需要注意一点，如果我在T1时刻打开第一页，然后盯着页面不动，一直盯到T4时刻再下划到第二页，这时上一页的last_id，即分页偏移量很有可能因为直播状态变化而不知道飞到了什么位置，这会导致严重的&lt;/span&gt;&lt;span&gt;错位问题&lt;/span&gt;&lt;span&gt;，以及直播&lt;/span&gt;&lt;span&gt;状态展示不统一&lt;/span&gt;&lt;span&gt;的问题（第一页展示的是T1时刻的直播状态，第二页展示的是T4时刻的直播状态）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h1 data-mid=&quot;&quot;&gt;05&lt;/h1&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;解决方案&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;直播系统是个单向关系链，和微博有些类似，&lt;/span&gt;&lt;span&gt;每个观众会关注少量主播，每个主播会可能有非常多的关注者&lt;/span&gt;&lt;span&gt;。由于有状态变化的存在，写扩散几乎无法实现。因为如果采用写扩散的方式，每次主播创建直播、直播开播、直播结束这三个事件发生时导致的场次状态变化，会扩散为非常多次的写操作，不仅操作复杂，时延上也无法接受。微博之所以可以写扩散，就是因为一篇帖子发出后，这篇帖子就不会再有任何影响排序的状态转变。在我们场景中，“预告中”与“直播中”是两个中间态，而“回放”状态才是所有直播的最终归宿，一旦进入回放，这场直播也就不会再有状态转变。因此“&lt;/span&gt;&lt;span&gt;直播中&lt;/span&gt;&lt;span&gt;”与“&lt;/span&gt;&lt;span&gt;预告中&lt;/span&gt;&lt;span&gt;”状态可以采用&lt;/span&gt;&lt;span&gt;读扩散&lt;/span&gt;&lt;span&gt;方式，“&lt;/span&gt;&lt;span&gt;回放&lt;/span&gt;&lt;span&gt;”状态采取写扩散方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最终的方案如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.793538219070134&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jiboYA4jZECwia2nukSP19wlR1UA1MexAItHotS8G6SI3I7r4QKksicQyIG3hUJuwib6wk6mha132v0FI1NK1uRAmw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1269&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;会影响直播状态的三种事件（创建直播、开播、结束直播）全部采用监听队列异步处理。我们为每一位主播维护一个直播中+预告中状态的优先级队列。每当监听到有主播创建直播时，将直播场次加入队列中，得分为开播的时间戳的相反数（负数）。每当监听到有主播开播时，把这场直播在队列中的得分修改为开播时间（正数）。每当监听到有主播结束直播，则异步地将播放信息投递到每个观众的回放队列中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里有一个小技巧，前文提到，直播中状态按照开播时间从大到小排序，而预告中状态则按照开播时间从小到大排序，因此如果将预告中状态的得分全部取开播时间相反数，那排序同样就成为了从大到小。这样的转化可以保证直播中与预告中同处于一个队列排序。&lt;/span&gt;&lt;span&gt;预告中得分全都为负数，直播中得分全都为正数&lt;/span&gt;&lt;span&gt;，最后聚合时可以保证所有直播中全都自然排在预告中前面。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外前文还提到的另一个问题是T1时刻拉取第一页，T4时刻拉取第二页，导致第一页和第二页直播间状态不统一。解决这个问题的办法是通过快照方式。当观众来拉取第一页Feed流时，我们依据当前时间，将全部直播中和预告中状态的场次建立一份快照，使用一个session_id标识，每次前端分页拉取时，我们直接从快照中读取即可。如果快照中读取完毕，证明该观众的直播中和预告中场次全部读完，剩下的则使用回放队列进行补充。照此一来，我们的Feed流系统，前端分页拉取的参数一共有4个：&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;含义&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;值来源&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;读第一页时参数值&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;session_id&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;快照队列ID，从该快照中读取直播中和预告中场次&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;上一页返回值&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;空字符串&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;last_id&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;上一页读取到哪一场直播&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;上一页返回值&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;空字符串&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;state&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;枚举值0或1，表示last_id处于快照队列还是回放队列&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;上一页返回值&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;0&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;page_size&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;每页建议读几条&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;前后端约定&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;10&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;每当碰到session_id和last_id为空，则证明用户想要读取第一页，需要重新构建快照。这里还有一个衍生问题，session_id的如何取值？如果不考虑同一个观众在多端登录的情况，其实每一位观众维护一个快照id即可，也就是直接将系统用户id设为session_id；如果考虑多端登录的情况，则session_id中必须包含每个端的信息，以避免多端快照相互影响；如果不心疼内存，也可以每次随机一个字符串作为session_id，并设置一个足够长的过期时间，让快照自然过期。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上设计，其实系统计算量最大的时刻就是拉取第一页，构建快照的开销。目前的线上数据，对于只关注不到10个主播的观众（这也是大多数场景），拉取第一页的QPS可以达到1.5万。如果将第二页以后的请求也算进来，Feed流的综合QPS可以达到更高水平，支撑目前的用户规模已经绰绰有余。如果我们拉取第一页时只获取到前10条即可直接返回，将构建快照操作改为异步，也许QPS可以更高一些，这可能是后续的优化点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h1 data-mid=&quot;&quot;&gt;06&lt;/h1&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;读扩散、写扩散、读写混合，几乎所有基于时间线和关注关系的Feed流都逃不开这三种基本设计模式。具体到实际业务中，可能会有更复杂的场景，比如本文所说的状态流转影响排序，微博朋友圈场景中也会有广告接入、特别关注、热点话题等可能影响到Feed流排序的因素。这些场景就只能根据业务需求，做相对应的变通了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;paragraph&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-id=&quot;92805&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-width=&quot;100%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-brushtype=&quot;text&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong&gt;▼&lt;/strong&gt;&lt;strong&gt;近期热文&lt;/strong&gt;&lt;strong&gt;▼&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot; data-width=&quot;96%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/jiboYA4jZECzSiakZVZkZxlxohbG68ZFCdgNxc2bfc9oVunDD0Cjt7pUTq3KLernrgXM4Tnxiaibx301wyMsAyqicOQ/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;900&quot; data-cropy1=&quot;11.35135135135135&quot; data-cropy2=&quot;347.027027027027&quot; data-ratio=&quot;0.37333333333333335&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jiboYA4jZECwia2nukSP19wlR1UA1MexAImuO8icLYWczZtjAJ5tQQW1eRfobWnRmlic6zMqkoUooFgu30Tnibtadbg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用户访谈（一）：如何做好访谈前的准备工作&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/jiboYA4jZECwFiaxZanicXILIU67ZkN6Pftibibw8RappAvsfEfYvL3jMAnqY7nplPYJ1T7SR6qSBU2APWG4TqLU0rA/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;900&quot; data-cropy1=&quot;29.584775086505182&quot; data-cropy2=&quot;348.78892733564004&quot; data-ratio=&quot;0.35444444444444445&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jiboYA4jZECwia2nukSP19wlR1UA1MexAI54vROEMyGibgt1ibcqIwI3lcmU86WsOaJoicETZxglOIorLGXgbsaLsCg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;section data-autoskip=&quot;1&quot; data-width=&quot;96%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;用户访谈（二）：如何进行一场有效的访谈？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MTEwNTM0ODI0MQ==&amp;amp;mid=2653449418&amp;amp;idx=1&amp;amp;sn=ad1ea98489213b88560d9c382174bcde&amp;amp;chksm=72017d344576f422956ea79c32c6d1486d2a156dcdce625fa5c8f67914aa68ca4dedb42ad3d0&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/jiboYA4jZECwiazRb3mtLO3KVYmGzmGwVsiblicTCHDEyuaZT14iaWmnz8wMA3xliaQTQFBxbf7UeEAf4zT6E067ZDYQ/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;900&quot; data-cropy1=&quot;17.837837837837835&quot; data-cropy2=&quot;353.5135135135135&quot; data-ratio=&quot;0.37333333333333335&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jiboYA4jZECzSiakZVZkZxlxohbG68ZFCdf0Kp77J5tGRmJIoHcYk7qecIOboTQRm8H9C8te6x4U51J3dHjicpJ3Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MTEwNTM0ODI0MQ==&amp;amp;mid=2653449418&amp;amp;idx=1&amp;amp;sn=ad1ea98489213b88560d9c382174bcde&amp;amp;chksm=72017d344576f422956ea79c32c6d1486d2a156dcdce625fa5c8f67914aa68ca4dedb42ad3d0&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;渠道质量评估模型&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;渠道质量评估模型&lt;br/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-id=&quot;94901&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-brushtype=&quot;text&quot; data-width=&quot;100%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;__bg_gif&quot; data-ratio=&quot;0.65625&quot; data-type=&quot;gif&quot; data-w=&quot;640&quot; data-backw=&quot;677&quot; data-backh=&quot;444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/jiboYA4jZECyg5asa7YvWj9MVdwpMRfiaugTX0ZODtYicibgG6lAqia17L773UTuFHTTlz8rsec5Qhp3OzYffibD2YUg/640?wx_fmt=gif&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;喜欢本文？快点“在看”支持一下&lt;/span&gt;&lt;img data-ratio=&quot;0.43902439024390244&quot; data-type=&quot;gif&quot; data-w=&quot;41&quot; class=&quot;__bg_gif&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/jiboYA4jZECzfiag8ibXkV6v69AiaeWjmU9ic1nKbfLjPibRx0CSMt87FJz2ibeFibOuhS7Fe3QKa46qulB8HYbjOtfaBA/640?wx_fmt=gif&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0c161506b19a23154f8284d0efa394c2</guid>
<title>技术人员该如何接手一个复杂的系统？吐血推荐这几招</title>
<link>https://toutiao.io/k/yyjv3sj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;23&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;阅读本文大概需要 5 分钟。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;作为程序员，无论是小菜还是老鸟，都会因为离职交接或者岗位异动等各种原因，而避免不了要如羚羊奔跑版的速度接手一个复杂业务系统。&lt;/span&gt;&lt;span&gt;因为只有尽快熟悉系统，方能够快速支持业务需求的研发。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;那么，问题就来了？面对一个一无所知的复杂的系统，我们该如何入手呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;本文将结合菜菜同学多年来的沉（经）淀（验），再融合&lt;/span&gt;&lt;span&gt;老中医望闻问切的招式，吐血整理成一副图和一剂&lt;span&gt;锦囊妙药，送给大家&lt;/span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;《一剂良药》&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;「&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;菊花&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;」看文档，记疑惑。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;「&lt;span&gt;&lt;span&gt;薄荷&lt;/span&gt;&lt;/span&gt;」串文档，理脉络。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;「&lt;span&gt;&lt;span&gt;莲&lt;span&gt;心&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;」讲系统，要知彼。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;「&lt;span&gt;&lt;span&gt;荷叶&lt;/span&gt;&lt;/span&gt;」捋代码，了梗概。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;「&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;玄参&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;」盘经验，&lt;/span&gt;&lt;span&gt;理大坑。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;「&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;芦根&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;」亲操刀，细解剖&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;《一幅脑图》&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;369&quot; data-backw=&quot;544&quot; data-ratio=&quot;0.6787003610108303&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/waH0DGXhQWOPZShy6w0VLYA9q4QG54aXkVo8OJ9MTP1IQmgia6C8Cia3VD4XlTLgAJc2icPNZADZOcngrGI5Bznsw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1662&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;1&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;第一招：&lt;span&gt;看文档，知脉略。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;老中医：望。望诊，是对病人的神、色、形、态、舌象等进行有目的的观察，以测知内脏病变。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;菜菜同学结合「望诊」而独创快速接手一个复杂系统之&lt;/span&gt;&lt;strong&gt;&lt;span&gt;招式一：&lt;/span&gt;&lt;span&gt;看&lt;/span&gt;&lt;span&gt;文档，知脉略&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当一个复杂的系统要交接到你手上时，理想中各种文档样样全，要啥有啥，而现实啪啪打脸。&lt;/span&gt;&lt;span&gt;多数情况下都没有文档，如果有一些文档可看，无论质量如何，都是一件值得庆幸的事情。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果项目组比较规范，沉淀了一些入门文档、产品介绍文档、业务架构设计文档、数据库设计文档，那就更值得庆幸啦，静下来仔细去看，&lt;span&gt;通过文档多少会了解一些系统的前世今生，对系统有一个初步的认识。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不过，&lt;/span&gt;&lt;span&gt;当接手一个系统时，一定要看看文档在哪里？&lt;/span&gt;&lt;span&gt;是在 Wiki 上，还是在 SVN、Git 上，如若有文档的情况下，尽快找到它，并粗略的看一遍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看了这么多文档，肯定有太多的疑惑，先拿小本本记下来，制造机会请老鸟给你答疑解惑。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;2&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;第二招：听细节&lt;/span&gt;&lt;span&gt;，聊全局。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;老中医：闻。闻诊，主要是听患者语言气息的高低、强弱、清浊、缓急……等变化，以分辨病情的虚实寒热。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;菜菜同学结合「闻诊」而独创快速接手一个复杂系统之&lt;/span&gt;&lt;strong&gt;&lt;span&gt;招式二：&lt;/span&gt;&lt;span&gt;听细节，聊全局。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;拿着你事先记录好满满疑惑的小本本，组个会议，喊上老鸟好好给你指点迷津。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;首先，请老鸟串一串文档。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大概理一理，然后把你之前小本本上的问题，一股脑抛出来当面请教。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;然后，请老鸟讲一讲系统。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大概要了解一下系统的使用方是谁？&lt;/span&gt;&lt;span&gt;系统依赖的系统有哪些？系统&lt;/span&gt;&lt;span&gt;主要干&lt;/span&gt;&lt;span&gt;系&lt;/span&gt;&lt;span&gt;人有哪些？系统研发的需求来自于哪里？&lt;/span&gt;&lt;span&gt;最重要的是要请老鸟演示一下如何把系统跑起来？&lt;/span&gt;&lt;span&gt;跑起来后功能该怎么用？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;最后，请老鸟捋一捋代码。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;大概捋一捋代码的设计，了解一下&lt;span&gt;主要分为几&lt;/span&gt;&lt;span&gt;大&lt;/span&gt;&lt;span&gt;块？&lt;/span&gt;程序入口在哪里？技术栈是啥样子？... ...&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;3&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;第三招：&lt;/span&gt;&lt;span&gt;问疑难，解杂症。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;老中医：问。问诊，通过了解既往病史与家族病史、起病原因、发病经过及治疗过程，主要痛苦所在，自觉症状，饮食喜恶等情况，结合望、切、闻三诊，综合分析，作出判断。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;菜菜同学结合「问诊」而独创快速接手一个复杂系统之&lt;/span&gt;&lt;strong&gt;&lt;span&gt;招式三：问疑难&lt;/span&gt;&lt;span&gt;，解杂症。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;首先，问老鸟：要接手的系统，历史事故都发生过哪些？&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;为了&lt;/span&gt;&lt;span&gt;不贰过，要&lt;/span&gt;了解一下要接手的系统，历史的事故是代码问题，还是人祸导致的？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;最后，问老鸟：要接手的系统，坑在哪里？&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大概了解一下老鸟以往趟过的那些坑，前车之鉴必是后车之师。&lt;/span&gt;&lt;span&gt;重点了解系统有哪块会有潜在的问题，当接手之后一定要细心着重对待，防患于未然。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;4&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;第四招：亲操刀&lt;/span&gt;&lt;span&gt;，细解剖。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;老中医：切。切脉又称诊脉，是医者用手指按其腕后桡动脉搏动处，借以体察脉象变化，辨别脏腑功能盛衰，气血津精虚滞的一种方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;菜菜同学结合「切诊」而独创快速接手一个复杂系统之&lt;/span&gt;&lt;strong&gt;&lt;span&gt;招式四：&lt;/span&gt;&lt;span&gt;亲操刀，细解剖。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过前面三种招式相结合，我们文档也看了，系统功能也了解了，历史事故也知道了，接下来要进入程序员最擅长区域——解剖代码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;首先，加注释，加&lt;/span&gt;&lt;span&gt;关键日志。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;找到程序入口，根据自己的理解，一步一步去加注释，&lt;span&gt;要&lt;/span&gt;&lt;span&gt;敢于&lt;/span&gt;&lt;span&gt;动手去&lt;/span&gt;&lt;span&gt;加，确定不了的，有疑问&lt;/span&gt;的用注释标记好，或者记个大大的问号，把你的想法理解都用注释记录一下，相信对代码的理解，一遍比一遍更透彻。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然，除了加注释的一种方式，还推荐加关键日志，因为加入关键日志，不过日志最好有一些特色，例如都还有「haha：」，这样能够在子模块调用比较复杂的情形下，在项目启动后，根据加入日志文件，直接关注「haha：」就能把相关子系统的调用流程串在一起，屡试不爽。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;然后，跑应用，Debug。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了加注释，加关键日志能够理解代码逻辑外，Debug 也是推荐的一种方式，从程序入口开始逐步进行调试，也会对代码有一个质的理解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;仁者见仁智者见智，依据个人习惯，还是更推荐加日志，或许是因为 Debug 有些时候遇到反射或者库调用，跟着跟着就乱掉了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在这里，建议一定要把应用跑起来，只有跑起来，才能根据之前加入的日志，梳理梳理系统调用关系，模块调用关系，再好好体验体验功能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;最后，画画图，善分享。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;加日志、加注释、Debug 的事儿&lt;span/&gt;&lt;span&gt;多数铁子&lt;/span&gt;都干过，但是能把自己对代码的理解真心画下来的估计会很少，这块真心推荐大家没事的时候静下来画一画，是对代码理解质的一次提升，画出来才能理解的更透彻，更清晰，如果闲暇之余把上手系统的经过写成手册，相信对于后面接手的同事而言是一大笔“财富”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然了，除了画图、写手册还是不够的，重要的是能够拉几个同事进行分享一下，这样才能更快变成自己的知识，在这里忍不住要抛一张图。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;383&quot; data-backw=&quot;544&quot; data-ratio=&quot;0.7043918918918919&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/waH0DGXhQWOPZShy6w0VLYA9q4QG54aXcqRygDUGZ7A2oNeg0VBT6rLfvn7woyU2HqufDeia1Tv3Dp6KGz5JKnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1184&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，接手系统解剖代码这块放到最后一部分去谈，原因这块确实考验个人的技术能力，而且是一个长久的过程，需要慢慢去磨。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;5&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;真心寄语&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本次主要谈谈如何快速接手一个系统？&lt;/span&gt;&lt;span&gt;吐血推荐的一幅图和一剂药，如果有接手系统的困惑，而且没有更好的方法时，那不妨拿去实践，&lt;/span&gt;&lt;span&gt;屡试不爽。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;前路漫长，&lt;/span&gt;&lt;span&gt;人生实苦，每个人方法都不一样，条条大路通罗马，选择适合自己的。奔跑是追梦人的气质，用奋斗定义人生价值，在奔跑中抵达远方，铁子们加油💪。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;好了，分享就到这里，希望对你有帮助。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;一起聊技术、谈业务、喷架构，少走弯路，不踩大坑。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;会持续输出原创精彩分享，敬请期待！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;198&quot; data-backw=&quot;544&quot; data-ratio=&quot;0.3649122807017544&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1710&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/waH0DGXhQWOwkpyEoA1IiakYviaHIX4GnoUHGE4kNCqHqAM54WmxryEd76E7Uf1xibO18pftGiafQqI8ibxqMHG34xA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;推荐阅读：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MDg5NzYzNA==&amp;amp;mid=2247485536&amp;amp;idx=1&amp;amp;sn=4347aea8740973fea3346fb48e7efd97&amp;amp;chksm=fc00436dcb77ca7ba2c0fcc105c8adbf1c31f61fc6ed143b936fea806c973fdf37e169aeba61&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;真实|技术人员该如何站好最后一班岗？&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MDg5NzYzNA==&amp;amp;mid=2247485423&amp;amp;idx=1&amp;amp;sn=e74b30d0c5482e2b6f488901229698b5&amp;amp;chksm=fc004ce2cb77c5f419dabb40e9a237d892a3cf489741f4c5f87fc0d9f61d296c763f58cd4726&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;真实|为什么要做有灵魂的程序员？&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6c3371b910d79429f2655d9830128436</guid>
<title>什么是环境变量？</title>
<link>https://toutiao.io/k/t85bk83</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4255555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybzdKJLNMkP1PZBBYgztJzNaG8OiabN6k1zW14jjJcgYCT21cmcDzCvSy0ibVkptqv5SWOqvxNxddEng/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在初学 Java 时，相信大家下载安装完 JDK 后的第一件事就是 &lt;strong&gt;「配置环境变量」&lt;/strong&gt;，几乎所有的教程都会告诉你当你在命令行工具中输入了 java 命令和 javac 命令后看到类似如下的结果就说明你的 Java 环境配置好了 👇&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybzdKJLNMkP1PZBBYgztJzNac9wicbEibkuAXTXcc7zxdARRVf0KVyJQgJX1e1Eny1exIQ29kkniaMAXQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1728&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybzdKJLNMkP1PZBBYgztJzNacgzTNSrf1pShiaKUecfmvT3YPa9PyzyqNsHf2iaCR0gYDHr1unepia6uw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1728&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道你有没有思考过这个「环境变量」究竟是什么？为什么配置了之后就会显示这样的内容，为什么不配置，就会提示你一个错误：&lt;code&gt;&#x27;javac&#x27; 不是内部命令或外部命令，也不是可运行的程序或批处理文件。&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你也有这样的疑问，不要着急，我们今天就来一探究竟。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;文内相关的演示，均在 Windows10 操作系统下执行&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;从打开软件的两种方式说起&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们平时打开一个应用程序，一般是双击桌面图标或在开始菜单链接，无论是桌面的快捷图标还是菜单链接都包含了应用程序的安装位置信息，打开它们的时候系统会按照这些位置信息找到安装目录然后启动程序，这里以 QQ 这个软件为例：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.4684466019417475&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybzdKJLNMkP1PZBBYgztJzNa5xMMsnoYXibZLx2EUZd6iaVYJDvWStD5JNctlnaiaWkyEvFzen1WV9x7w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;824&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面是我们最常用的打开软件的方式，当然了，既然知道了一个应用程序的安装目录位置，我们也可以通过命令行工具进入启动程序所在的文件，通过命令打开，如笔者 QQ 的位置为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&quot;C:\Program Files (x86)\Tencent\QQ\Bin\QQScLauncher.exe&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;QQ 的启动程序名为 QQScLauncher，那么我们打开终端工具，使用 cd 命令进入该目录，再输入&lt;code&gt;.\QQScLauncher.exe&lt;/code&gt;，即可通过命令启动 QQ。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5106382978723404&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybzdKJLNMkP1PZBBYgztJzNaiaDPbgoibiaRhaogia9bLTtIBOQWueD8r9QbN5Letr2SfGm1L5fZAWjib1g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2115&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;做一点改进&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想要炫技，每次都先进入安装目录再打开文件显然有些麻烦，那有没有什么简单的方式，直接在命令行工具中输入 QQScLauncher 甚至直接输入 QQ 就能打开软件呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然是可以的，我们只需要在&lt;strong&gt;用户变量&lt;/strong&gt;名&lt;code&gt;Path&lt;/code&gt;中添加安装路径的字符，我们在命令行工具无需进入软件的安装路径即可打开软件了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5963556046383214&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybzdKJLNMkP1PZBBYgztJzNaVzoJKnrssJBlsxnFBtjvibIFTsWtHZpglAZrhFw9QoZONt4tCR3lugw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1811&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来试下直接在命令行工具中输入 QQScLauncher，果然可以直接打开软件了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5687203791469194&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybzdKJLNMkP1PZBBYgztJzNaGBH0ILAPuAe7gHmcicCGzGP6gdnoeibldjWzMhP98nKzDFl6PUib5hb4Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1899&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;原因&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么配置环境变量前，直接输入 QQScLauncher 无法打开软件呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是因为操作系统并不知道你的 QQScLauncher.exe 这个文件在哪里，所以无法执行对应的文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你在命令行里输入的那几个符号，其实就是一些可执行程序的名字(标签、别名)，是可以直接被当前系统直接执行的程序。如果是在 Windows 系统中，则这些被输入的符号就是可以直接被 windows 系统执行、后缀为&#x27;.exe&#x27;的程序(文件)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么为了能够让操作系统找到这个可执行文件，我们就需要把 QQScLauncher.exe 这个 可执行文件所在的目录作为 PATH 环境变量的一部分设置起来，这样当你在命令行输入一个命令的时候，操作系统就会&lt;strong&gt;自动搜索 PATH 变量&lt;/strong&gt;中所指定的所有目录 了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Windows 系统中 PATH 变量中的所有路径采用分号分割，如果在 Linux 系统中采用冒号分割。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如果你设置好了环境变量，在命令 行中还是出现同样的错误，那么有两种可能，一种就是你的设置不正确，另一种就是你的设置没有生效，一般你可以关闭命令行窗口再重新打开就可以了。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;环境变量&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面所说的 PATH 变量其实就是环境变量，和他的名字一样，环境变量是&lt;strong&gt;描述环境的变量&lt;/strong&gt;，是指在操作系统中用来指定操作系统运行环境的变量。它包含了一个或者多个应用程序所将使用到的信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如 Windows 和 DOS 操作系统中的 PATH 环境变量，当要求系统运行一个程序而没有告诉它程序所在的完整路径时，系统除了在当前目录下面寻找此程序外，还应到 PATH 中指定的路径去找。用户通过设置环境变量，来更好的运行进程。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;系统变量 OR 用户变量&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信细心的小伙伴已经发现了，在上图的页面中除了&lt;strong&gt;用户变量&lt;/strong&gt;还有一个叫&lt;strong&gt;系统变量&lt;/strong&gt;的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事实上，环境变量是一个总称，代表了系统变量和用户变量，因此我们说环境变量都是指的系统变量和用户变量。系统变量就是系统级别的变量，用户需要使用系统变量。如果系统变量被修改了，而任何系统用户都在用系统变量，因此每个系统用户都将受到影响。用户变量运行在系统变量之上的，每个用户拥有不同的用户变量，不同用户的用户变量之间是并列的，也是互不干扰的。他们之间的关系图如下如所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5221169036334913&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybzdKJLNMkP1PZBBYgztJzNaFWQ8CgO8BJzibEJRJOIHyxawhZfB1IWmFiaTiapUib6rjf6qTicTTania9pg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1266&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这，想必在验证 Java 环境是否安装成功的时候，我们在终端工具中输入 &lt;code&gt;java&lt;/code&gt; 和 &lt;code&gt;javac&lt;/code&gt; 命令显示出相应的字符的原理想必你也就知道了吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一图说明：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.23684210526315788&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybzdKJLNMkP1PZBBYgztJzNaloG4lGjJAbJyXPlQgdgaVLwfL0bN6urPpiaRk6fUsT0wzq37gqkkewA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;3268&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;题外话&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为一个计算机专业的学生，一定要学会使用命令行工具，你可以选择自己喜欢的终端软件，这里我使用的是 &lt;strong&gt;「Windows Terminal」&lt;/strong&gt;，一方面是因为他是微软官方推出的终端工具，更有一点就是他的颜值很高，你可以在微软的应用商店搜索下载安装。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.45366284201235657&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybzdKJLNMkP1PZBBYgztJzNa8xZBwMRp2TXffmFxOY6bELJCwU4iaUPaick8C6yQ0nLXkj13wF3WMvrw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2266&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是本文的全部内容了，如果你觉得对你有所帮助，不妨点赞关注支持一波 👍&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>03f0d6ab93cc21161cc4ee13790013d5</guid>
<title>[译] 深入理解 Kubernetes 网络模型：自己实现 kube-proxy 的功能</title>
<link>https://toutiao.io/k/ui8teps</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;content&quot;&gt;
&lt;p&gt;本文译自 &lt;a href=&quot;https://arthurchiao.art/blog/cracking-k8s-node-proxy/&quot;&gt;Cracking kubernetes node proxy (aka kube-proxy)&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Kubernetes 中有几种类型的代理。其中有 &lt;strong&gt;node proxier&lt;/strong&gt; 或 &lt;a href=&quot;https://kubernetes.io/docs/reference/command-line-tools-reference/kube-proxy/&quot;&gt;kube-proxy&lt;/a&gt;，它在每个节点上反映 Kubernetes API 中定义的服务，可以跨一组后端执行简单的 TCP/UDP/SCTP 流转发 [1]。&lt;/p&gt;
&lt;p&gt;为了更好地理解节点代理模型，在这篇文章中，我们将用不同的方法设计和实现我们自己版本的 &lt;code&gt;kube-proxy&lt;/code&gt;; 尽管这些只是 &lt;code&gt;toy-proxy&lt;/code&gt;，但从&lt;strong&gt;透明流量拦截、转发、负载均衡&lt;/strong&gt;等方面来说，它们的工作方式与 K8S 集群中运行的普通 &lt;code&gt;kube-proxy&lt;/code&gt; 基本相同。&lt;/p&gt;
&lt;p&gt;通过我们的 &lt;code&gt;toy-proxy&lt;/code&gt; 程序，非 K8S 节点（不在 K8S 集群中）上的应用程序（无论是宿主本地应用程序，还是在 VM/容器中运行的应用程序）也可以通过 &lt;strong&gt;ClusterIP&lt;/strong&gt; 访问 K8S 服务 – &lt;strong&gt;注意，在 kubernetes 的设计中，ClusterIP 只能在 K8S 集群节点中访问（在某种意义上，我们的 &lt;code&gt;toy-proxy&lt;/code&gt; 程序将非 K8S 节点变成了 K8S 节点）。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;背景知识&quot;&gt;背景知识&lt;/h2&gt;
&lt;p&gt;了解 Linux 内核中的流量拦截和代理需要具备以下背景知识。&lt;/p&gt;
&lt;h3 id=&quot;netfilter&quot;&gt;Netfilter&lt;/h3&gt;
&lt;p&gt;Netfilter 是 Linux 内核内部的&lt;strong&gt;包过滤和处理框架&lt;/strong&gt;。如果你不熟悉 Iptables 和 Netfilter 体系结构，请参阅 &lt;a href=&quot;https://www.digitalocean.com/community/tutorials/a-deep-dive-into-iptables-and-netfilter-architecture&quot;&gt;A Deep Dive into Iptables and Netfilter Architecture&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一些要点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主机上的&lt;strong&gt;所有数据包&lt;/strong&gt;都将通过 netfilter 框架&lt;/li&gt;
&lt;li&gt;在 netfilter 框架中有 &lt;strong&gt;5 个钩子&lt;/strong&gt;点：&lt;code&gt;PRE_ROUTING&lt;/code&gt;, &lt;code&gt;INPUT&lt;/code&gt;, &lt;code&gt;FORWARD&lt;/code&gt;, &lt;code&gt;OUTPUT&lt;/code&gt;, &lt;code&gt;POST_ROUTING&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;命令行工具 &lt;code&gt;iptables&lt;/code&gt; 可用于&lt;strong&gt;动态地将规则插入到钩子点中&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;可以通过组合各种 &lt;code&gt;iptables&lt;/code&gt; 规则来操作数据包（接受/重定向/删除/修改，等等）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./images/proxy_hooks.png&quot; alt=&quot;The 5 hook points in netfilter framework&quot;/&gt;
此外，这 5 个钩子点还可以与内核的其他网络设施，如内核路由子系统进行协同工作。&lt;/p&gt;
&lt;p&gt;此外，在每个钩子点中，规则被组织到具有预定义优先级的不同链中。为了按目的管理链，链被进一步组织到表中。现在有 5 个表：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;filter&lt;/code&gt;：做正常的过滤，如接受，拒绝/删，跳&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nat&lt;/code&gt;：网络地址转换，包括 SNAT（源 nat) 和 DNAT（目的 nat)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mangle&lt;/code&gt;：修改包属性，例如 TTL&lt;/li&gt;
&lt;li&gt;&lt;code&gt;raw&lt;/code&gt;：最早的处理点，连接跟踪前的特殊处理 (conntrack 或 CT，也包含在上图中，但这不是链）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;security&lt;/code&gt;：本文未涉及&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将表/链添加到上图中，我们可以得到更详细的视图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./images/proxy_hooks-and-tables.png&quot; alt=&quot;iptables table/chains inside hook points&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;vip-与负载均衡-lb&quot;&gt;VIP 与负载均衡 (LB)&lt;/h3&gt;
&lt;p&gt;虚拟 IP (IP) 将所有后端 IP 隐藏给客户端/用户，因此客户端/用户总是与 VIP 的后端服务通信，而不需要关心 VIP 后面有多少实例。&lt;/p&gt;
&lt;p&gt;VIP 总是伴随着负载均衡，因为它需要在不同的后端之间分配流量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./images/proxy_vip-and-lb.png&quot; alt=&quot;VIP and load balancing&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;cross-host-网络模型&quot;&gt;Cross-host 网络模型&lt;/h3&gt;
&lt;p&gt;主机 A 上的实例（容器、VM 等）如何与主机 B 上的另一个实例通信？有很多解决方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接路由：BGP 等&lt;/li&gt;
&lt;li&gt;隧道：VxLAN, IPIP, GRE 等&lt;/li&gt;
&lt;li&gt;NAT：例如 docker 的桥接网络模式&lt;/li&gt;
&lt;li&gt;其它方式&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;节点代理模型&quot;&gt;节点代理模型&lt;/h2&gt;
&lt;p&gt;在 kubernetes 中，你可以将应用程序定义为 &lt;code&gt;Service&lt;/code&gt;。&lt;code&gt;Service&lt;/code&gt; 是一种抽象，它定义了一组 Pods 的逻辑集和访问它们的策略。&lt;/p&gt;
&lt;h3 id=&quot;service-类型&quot;&gt;Service 类型&lt;/h3&gt;
&lt;p&gt;K8S 中定义了 4 种 &lt;code&gt;Service&lt;/code&gt; 类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ClusterIP&lt;/code&gt;：通过 VIP 访问 Service，但该 VIP 只能在此集群内访问&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NodePort&lt;/code&gt;：通过 NodeIP:NodePort 访问 Service，这意味着该端口将保留在集群内的所有节点上&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ExternalIP&lt;/code&gt;：与 &lt;code&gt;ClusterIP&lt;/code&gt; 相同，但是这个 VIP 可以从这个集群之外访问&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LoadBalancer&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这篇文章将关注 &lt;code&gt;ClusterIP&lt;/code&gt;，但是其他三种类型在流量拦截和转发方面的底层实现非常相似。&lt;/p&gt;
&lt;h3 id=&quot;节点代理&quot;&gt;节点代理&lt;/h3&gt;
&lt;p&gt;一个 Service 有一个 VIP（本文中的 &lt;code&gt;ClusterIP&lt;/code&gt;）和多个端点（后端 pods）。每个 pod 或节点都可以通过 VIP 直接访问应用程序。要做到这一点，节点代理程序需要在每个节点上运行，它应该能够透明地拦截到任何 &lt;code&gt;ClusterIP:Port&lt;/code&gt;[注解 1] 的流量，并将它们重定向到一个或多个后端 pods。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./images/proxy_k8s-proxier-model.png&quot; alt=&quot;Kubernetes proxier model&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注解 1：&lt;/p&gt;
&lt;p&gt;对 &lt;code&gt;ClusterIP&lt;/code&gt; 的一个常见误解是，&lt;code&gt;ClusterIP&lt;/code&gt; 是可访问的——它们不是通过定义访问的。如果 ping 一个 &lt;code&gt;ClusterIP&lt;/code&gt;，可能会发现它不可访问。&lt;/p&gt;
&lt;p&gt;根据定义，&lt;strong&gt;&amp;lt;Protocol,ClusterIP,Port&amp;gt;&lt;/strong&gt; 元组独特地定义了一个服务（因此也定义了一个拦截规则）。例如，如果一个服务被定义为 &lt;code&gt;&amp;lt;tcp,10.7.0.100,80&amp;gt;&lt;/code&gt;，那么代理只处理 &lt;code&gt;tcp:10.7.0.100:80&lt;/code&gt; 的流量，其他流量，例如。&lt;code&gt;tcp:10.7.0.100:8080&lt;/code&gt;, &lt;code&gt;udp:10.7.0.100:80&lt;/code&gt; 将不会被代理。因此，也无法访问 ClusterIP（ICMP 流量）。&lt;/p&gt;
&lt;p&gt;但是，如果你使用的是带有 IPVS 模式的 &lt;code&gt;kube-proxy&lt;/code&gt;，那么确实可以通过 ping 访问 &lt;code&gt;ClusterIP&lt;/code&gt;。这是因为 IPVS 模式实现比定义所需要的做得更多。你将在下面几节中看到不同之处。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;节点代理的角色反向代理&quot;&gt;节点代理的角色：反向代理&lt;/h3&gt;
&lt;p&gt;想想节点代理的作用，在 K8S 网络模型中，它实际上是一个反向代理，也就是说，在每个节点上，它将：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将所有后端 Pods 隐藏到客户端&lt;/li&gt;
&lt;li&gt;过滤所有出口流量（对后端的请求）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于 ingress traffic，它什么也不做。&lt;/p&gt;
&lt;h3 id=&quot;性能问题&quot;&gt;性能问题&lt;/h3&gt;
&lt;p&gt;如果我们在主机上有一个应用程序，并且在 K8S 集群中有 1K 个服务，那么我们永远无法猜测该应用程序在下一时刻将访问哪个服务（这里忽略网络策略）。因此，为了让应用程序能够访问所有服务，我们必须为节点上的所有服务应用所有代理规则。将这个想法推广到整个集群，这意味着：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所有服务的代理规则应该应用于整个集群中的所有节点。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在某种意义上，这是一个完全分布式的代理模型，因为任何节点都拥有集群的所有规则。&lt;/p&gt;
&lt;p&gt;当集群变大时，这会导致严重的性能问题，因为每个节点上可能有数十万条规则 [6,7]。&lt;/p&gt;
&lt;h2 id=&quot;测试环境&quot;&gt;测试环境&lt;/h2&gt;
&lt;h3 id=&quot;集群拓扑和测试环境&quot;&gt;集群拓扑和测试环境&lt;/h3&gt;
&lt;p&gt;我们将使用以下环境进行测试：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个 k8s 集群
&lt;ul&gt;
&lt;li&gt;一个 master 节点&lt;/li&gt;
&lt;li&gt;一个 node 节点&lt;/li&gt;
&lt;li&gt;网络解决方案：直接路由（PodIP 可直接路由）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一个非 k8s 节点，但是它可以到达工作节点和 Pod（得益于直接路由网络方案）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./images/proxy_test-env.png&quot; alt=&quot;test env&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们将在工作节点上部署 Pods，并从 test 节点通过 &lt;code&gt;ClusterIP&lt;/code&gt; 访问 Pods 中的应用程序。&lt;/p&gt;
&lt;h3 id=&quot;创建一个-service&quot;&gt;创建一个 Service&lt;/h3&gt;
&lt;p&gt;创建一个简单的 &lt;code&gt;Statefulset&lt;/code&gt;，其中包括一个 &lt;code&gt;Service&lt;/code&gt;，该 &lt;code&gt;Service&lt;/code&gt; 将有一个或多个后端 Pods:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span&gt;# see appendix for webapp.yaml&lt;/span&gt;
$ kubectl create -f webapp.yaml

$ kubectl get svc -o wide webapp
NAME     TYPE        CLUSTER-IP     EXTERNAL-IP   PORT&lt;span&gt;(&lt;/span&gt;S&lt;span&gt;)&lt;/span&gt;   AGE     SELECTOR
webapp   ClusterIP   10.7.111.132   &amp;lt;none&amp;gt;        80/TCP    2m11s   app&lt;span&gt;=&lt;/span&gt;webapp

$ kubectl get pod -o wide | grep webapp
webapp-0    2/2     Running   &lt;span&gt;0&lt;/span&gt;    2m12s 10.5.41.204    node1    &amp;lt;none&amp;gt;  &amp;lt;none&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;应用程序在带有 tcp 协议的 80 端口上运行。&lt;/p&gt;
&lt;h3 id=&quot;可达性测试&quot;&gt;可达性测试&lt;/h3&gt;
&lt;p&gt;首先访问 PodIP+Port:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ curl 10.5.41.204:80
&amp;lt;!DOCTYPE html&amp;gt;
...
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;成功的！然后用 &lt;code&gt;ClusterIP&lt;/code&gt; 替换 PodIP 再试一次：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ curl 10.7.111.132:80
^C
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;正如所料，它是不可访问的！&lt;/p&gt;
&lt;p&gt;在下一节中，我们将研究如何使用不同的方法使 &lt;code&gt;ClusterIP&lt;/code&gt; 可访问。&lt;/p&gt;
&lt;h2 id=&quot;实现通过-userspace-socket-实现-proxy&quot;&gt;实现：通过 userspace socket 实现 proxy&lt;/h2&gt;
&lt;h3 id=&quot;中间人模型&quot;&gt;中间人模型&lt;/h3&gt;
&lt;p&gt;最容易理解的实现是在此主机上的通信路径中插入我们的 &lt;code&gt;toy-proxy&lt;/code&gt; 作为中间人：对于从本地客户端到 ClusterIP:Port 的每个连接，&lt;strong&gt;我们拦截该连接并将其分割为两个单独的连接&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本地客户端和 &lt;code&gt;toy-proxy&lt;/code&gt; 之间的连接&lt;/li&gt;
&lt;li&gt;连接 &lt;code&gt;toy-proxy&lt;/code&gt; 和后端 pods&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实现此目的的最简单方法是在用户空间中实现它：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;监听资源&lt;/code&gt;：启动一个守护进程，监听 K8S apiserver、监视服务 (ClusterIP) 和端点 (Pod) 的变化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;代理通信&lt;/code&gt;：对于从本地客户端到服务 (ClusterIP) 的每个连接请求，通过充当中间人来拦截请求&lt;/li&gt;
&lt;li&gt;&lt;code&gt;动态应用代理规则&lt;/code&gt;：对于任何 Service/Endpoint 更新，相应地更改 &lt;code&gt;toy-proxy&lt;/code&gt; 连接设置&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于我们上面的测试应用 &lt;code&gt;webapp&lt;/code&gt;，数据流程如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./images/proxy_userspace-proxier.png&quot; alt=&quot;userspace-proxier&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;poc-实现&quot;&gt;POC 实现&lt;/h3&gt;
&lt;p&gt;让我们来看看上图的概念验证实现。&lt;/p&gt;
&lt;h4 id=&quot;代码&quot;&gt;代码&lt;/h4&gt;
&lt;p&gt;以下代码省略了一些错误处理代码，便于阅读：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-golang&quot; data-lang=&quot;golang&quot;&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;() {
&lt;span&gt;clusterIP&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;&quot;10.7.111.132&quot;&lt;/span&gt;
&lt;span&gt;podIP&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;&quot;10.5.41.204&quot;&lt;/span&gt;
&lt;span&gt;port&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;80&lt;/span&gt;
&lt;span&gt;proto&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;&quot;tcp&quot;&lt;/span&gt;

&lt;span&gt;addRedirectRules&lt;/span&gt;(&lt;span&gt;clusterIP&lt;/span&gt;, &lt;span&gt;port&lt;/span&gt;, &lt;span&gt;proto&lt;/span&gt;)
&lt;span&gt;createProxy&lt;/span&gt;(&lt;span&gt;podIP&lt;/span&gt;, &lt;span&gt;port&lt;/span&gt;, &lt;span&gt;proto&lt;/span&gt;)
}

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;addRedirectRules&lt;/span&gt;(&lt;span&gt;clusterIP&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;, &lt;span&gt;port&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;, &lt;span&gt;proto&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;) &lt;span&gt;error&lt;/span&gt; {
&lt;span&gt;p&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;strconv&lt;/span&gt;.&lt;span&gt;Itoa&lt;/span&gt;(&lt;span&gt;port&lt;/span&gt;)
&lt;span&gt;cmd&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;exec&lt;/span&gt;.&lt;span&gt;Command&lt;/span&gt;(&lt;span&gt;&quot;iptables&quot;&lt;/span&gt;, &lt;span&gt;&quot;-t&quot;&lt;/span&gt;, &lt;span&gt;&quot;nat&quot;&lt;/span&gt;, &lt;span&gt;&quot;-A&quot;&lt;/span&gt;, &lt;span&gt;&quot;OUTPUT&quot;&lt;/span&gt;, &lt;span&gt;&quot;-p&quot;&lt;/span&gt;, &lt;span&gt;&quot;tcp&quot;&lt;/span&gt;,
&lt;span&gt;&quot;-d&quot;&lt;/span&gt;, &lt;span&gt;clusterIP&lt;/span&gt;, &lt;span&gt;&quot;--dport&quot;&lt;/span&gt;, &lt;span&gt;p&lt;/span&gt;, &lt;span&gt;&quot;-j&quot;&lt;/span&gt;, &lt;span&gt;&quot;REDIRECT&quot;&lt;/span&gt;, &lt;span&gt;&quot;--to-port&quot;&lt;/span&gt;, &lt;span&gt;p&lt;/span&gt;)
&lt;span&gt;return&lt;/span&gt; &lt;span&gt;cmd&lt;/span&gt;.&lt;span&gt;Run&lt;/span&gt;()
}

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;createProxy&lt;/span&gt;(&lt;span&gt;podIP&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;, &lt;span&gt;port&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;, &lt;span&gt;proto&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;) {
&lt;span&gt;host&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;
&lt;span&gt;listener&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;net&lt;/span&gt;.&lt;span&gt;Listen&lt;/span&gt;(&lt;span&gt;proto&lt;/span&gt;, &lt;span&gt;net&lt;/span&gt;.&lt;span&gt;JoinHostPort&lt;/span&gt;(&lt;span&gt;host&lt;/span&gt;, &lt;span&gt;strconv&lt;/span&gt;.&lt;span&gt;Itoa&lt;/span&gt;(&lt;span&gt;port&lt;/span&gt;)))

&lt;span&gt;for&lt;/span&gt; {
&lt;span&gt;inConn&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;listener&lt;/span&gt;.&lt;span&gt;Accept&lt;/span&gt;()
&lt;span&gt;outConn&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;net&lt;/span&gt;.&lt;span&gt;Dial&lt;/span&gt;(&lt;span&gt;proto&lt;/span&gt;, &lt;span&gt;net&lt;/span&gt;.&lt;span&gt;JoinHostPort&lt;/span&gt;(&lt;span&gt;podIP&lt;/span&gt;, &lt;span&gt;strconv&lt;/span&gt;.&lt;span&gt;Itoa&lt;/span&gt;(&lt;span&gt;port&lt;/span&gt;)))

&lt;span&gt;go&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;(&lt;span&gt;in&lt;/span&gt;, &lt;span&gt;out&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;net&lt;/span&gt;.&lt;span&gt;TCPConn&lt;/span&gt;) {
&lt;span&gt;var&lt;/span&gt; &lt;span&gt;wg&lt;/span&gt; &lt;span&gt;sync&lt;/span&gt;.&lt;span&gt;WaitGroup&lt;/span&gt;
&lt;span&gt;wg&lt;/span&gt;.&lt;span&gt;Add&lt;/span&gt;(&lt;span&gt;2&lt;/span&gt;)
&lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Printf&lt;/span&gt;(&lt;span&gt;&quot;Proxying %v &amp;lt;-&amp;gt; %v &amp;lt;-&amp;gt; %v &amp;lt;-&amp;gt; %v\n&quot;&lt;/span&gt;,
&lt;span&gt;in&lt;/span&gt;.&lt;span&gt;RemoteAddr&lt;/span&gt;(), &lt;span&gt;in&lt;/span&gt;.&lt;span&gt;LocalAddr&lt;/span&gt;(), &lt;span&gt;out&lt;/span&gt;.&lt;span&gt;LocalAddr&lt;/span&gt;(), &lt;span&gt;out&lt;/span&gt;.&lt;span&gt;RemoteAddr&lt;/span&gt;())
&lt;span&gt;go&lt;/span&gt; &lt;span&gt;copyBytes&lt;/span&gt;(&lt;span&gt;in&lt;/span&gt;, &lt;span&gt;out&lt;/span&gt;, &lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;wg&lt;/span&gt;)
&lt;span&gt;go&lt;/span&gt; &lt;span&gt;copyBytes&lt;/span&gt;(&lt;span&gt;out&lt;/span&gt;, &lt;span&gt;in&lt;/span&gt;, &lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;wg&lt;/span&gt;)
&lt;span&gt;wg&lt;/span&gt;.&lt;span&gt;Wait&lt;/span&gt;()
}(&lt;span&gt;inConn&lt;/span&gt;.(&lt;span&gt;*&lt;/span&gt;&lt;span&gt;net&lt;/span&gt;.&lt;span&gt;TCPConn&lt;/span&gt;), &lt;span&gt;outConn&lt;/span&gt;.(&lt;span&gt;*&lt;/span&gt;&lt;span&gt;net&lt;/span&gt;.&lt;span&gt;TCPConn&lt;/span&gt;))
}

&lt;span&gt;listener&lt;/span&gt;.&lt;span&gt;Close&lt;/span&gt;()
}

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;copyBytes&lt;/span&gt;(&lt;span&gt;dst&lt;/span&gt;, &lt;span&gt;src&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;net&lt;/span&gt;.&lt;span&gt;TCPConn&lt;/span&gt;, &lt;span&gt;wg&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;sync&lt;/span&gt;.&lt;span&gt;WaitGroup&lt;/span&gt;) {
&lt;span&gt;defer&lt;/span&gt; &lt;span&gt;wg&lt;/span&gt;.&lt;span&gt;Done&lt;/span&gt;()
&lt;span&gt;if&lt;/span&gt; &lt;span&gt;_&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;io&lt;/span&gt;.&lt;span&gt;Copy&lt;/span&gt;(&lt;span&gt;dst&lt;/span&gt;, &lt;span&gt;src&lt;/span&gt;); &lt;span&gt;err&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
&lt;span&gt;if&lt;/span&gt; !&lt;span&gt;strings&lt;/span&gt;.&lt;span&gt;HasSuffix&lt;/span&gt;(&lt;span&gt;err&lt;/span&gt;.&lt;span&gt;Error&lt;/span&gt;(), &lt;span&gt;&quot;use of closed network connection&quot;&lt;/span&gt;) {
&lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Printf&lt;/span&gt;(&lt;span&gt;&quot;io.Copy error: %v&quot;&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt;)
}
}
&lt;span&gt;dst&lt;/span&gt;.&lt;span&gt;Close&lt;/span&gt;()
&lt;span&gt;src&lt;/span&gt;.&lt;span&gt;Close&lt;/span&gt;()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&quot;一些解释&quot;&gt;一些解释&lt;/h4&gt;
&lt;h5 id=&quot;traffic-拦截&quot;&gt;traffic 拦截&lt;/h5&gt;
&lt;p&gt;我们想拦截所有发往 &lt;code&gt;ClusterIP:Port&lt;/code&gt; 的流量，但是在这个节点上任何设备都没有配置&lt;code&gt;ClusterIP&lt;/code&gt;，因此我们无法执行诸如 listen（ClusterIP，Port）之类的操作，那么我们如何才能拦截呢？答案是：使用&lt;code&gt;iptables/netfilter&lt;/code&gt; 提供的 &lt;code&gt;REDIRECT&lt;/code&gt; 能力。&lt;/p&gt;
&lt;p&gt;以下命令会将所有发往 &lt;code&gt;ClusterIP:Port&lt;/code&gt; 的流量定向到 &lt;code&gt;localhost:Port&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ sudo iptables -t nat -A OUTPUT -p tcp -d $CLUSTER_IP --dport $PORT -j REDIRECT --to-port $PORT
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果你现在不能理解这一点，不要害怕。稍后我们将讨论这个问题。&lt;/p&gt;
&lt;p&gt;通过下面命令的输出来验证这一点：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ iptables -t nat -L -n
...
Chain OUTPUT &lt;span&gt;(&lt;/span&gt;policy ACCEPT&lt;span&gt;)&lt;/span&gt;
target     prot opt source      destination
REDIRECT   tcp  --  0.0.0.0/0   10.7.111.132         tcp dpt:80 redir ports &lt;span&gt;80&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在代码中，函数 &lt;code&gt;addRedirectRules()&lt;/code&gt; 包装了上述过程。&lt;/p&gt;
&lt;h5 id=&quot;创建-proxy&quot;&gt;创建 proxy&lt;/h5&gt;
&lt;p&gt;函数 &lt;code&gt;createProxy()&lt;/code&gt; 创建用户空间代理，并执行双向转发。&lt;/p&gt;
&lt;h4 id=&quot;可达性测试-1&quot;&gt;可达性测试&lt;/h4&gt;
&lt;p&gt;编译代码并执行二进制文件：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ go build toy-proxy-userspace.go
$ sudo ./toy-proxy-userspace
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在测试访问：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ curl $CLUSTER_IP:$PORT
&amp;lt;!DOCTYPE html&amp;gt;
...
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;成功！我们的代理传达的信息是：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ sudo ./toy-proxy-userspace
Creating proxy between &amp;lt;host ip&amp;gt;:53912 &amp;lt;-&amp;gt; 127.0.0.1:80 &amp;lt;-&amp;gt; &amp;lt;host ip&amp;gt;:40194 &amp;lt;-&amp;gt; 10.5.41.204:80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;表示，对于原 &lt;code&gt;&amp;lt;host ip&amp;gt;:53912 &amp;lt;-&amp;gt; 10.7.111.132:80&lt;/code&gt; 的连接请求，将其拆分为两个连接：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;host ip&amp;gt;:53912 &amp;lt;-&amp;gt; 127.0.0.1:80&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;host ip&amp;gt;:40194 &amp;lt;-&amp;gt; 10.5.41.204:80&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;删除这条规则：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ iptables -t nat -L -n --line-numbers
...
Chain OUTPUT &lt;span&gt;(&lt;/span&gt;policy ACCEPT&lt;span&gt;)&lt;/span&gt;
num  target     prot opt source               destination
&lt;span&gt;2&lt;/span&gt;    REDIRECT   tcp  --  0.0.0.0/0   10.7.111.132         tcp dpt:80 redir ports &lt;span&gt;80&lt;/span&gt;

&lt;span&gt;# iptables -t nat -D OUTPUT &amp;lt;num&amp;gt;&lt;/span&gt;
$ iptables -t nat -D OUTPUT &lt;span&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;或者删除（刷新）所有规则，如果你把 iptabels 弄的一团糟的情况下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ iptables -t nat -F &lt;span&gt;# delete all rules&lt;/span&gt;
$ iptables -t nat -X &lt;span&gt;# delete all custom chains&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&quot;改进&quot;&gt;改进&lt;/h4&gt;
&lt;p&gt;在这个 &lt;code&gt;toy-proxy&lt;/code&gt; 实现中，我们拦截了 &lt;code&gt;ClusterIP:80&lt;/code&gt; 到 &lt;code&gt;localhost:80&lt;/code&gt;，但是如果该主机上的本机应用程序也想使用 &lt;code&gt;localhost:80&lt;/code&gt; 怎么办？此外，如果多个服务都公开 80 端口会怎样？显然，我们需要区分这些应用程序或服务。解决这个问题的正确方法是：为每个代理分配一个未使用的临时端口 TmpPort，拦截 &lt;code&gt;ClusterIP:Port&lt;/code&gt; 到 &lt;code&gt;local:TmpPort&lt;/code&gt;。例如，app1 使用 10001, app2 使用 10002。&lt;/p&gt;
&lt;p&gt;其次，上面的代码只处理一个后端，如果有多个后端 pods 怎么办？因此，我们需要通过负载均衡算法将请求分发到不同的后端 pods。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./images/proxy_userspace-proxier-2.png&quot; alt=&quot;userspace-proxier-2&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;优缺点&quot;&gt;优缺点&lt;/h4&gt;
&lt;p&gt;这种方法非常容易理解和实现，但是，它的性能会很差，因为它必须在两端以及内核和用户空间内存之间复制字节。&lt;/p&gt;
&lt;p&gt;我们没有在这上面花太多时间，如果你感兴趣，可以在这里查看用户空间 &lt;code&gt;kube-proxy&lt;/code&gt; 的简单实现。&lt;/p&gt;
&lt;p&gt;接下来，让我们看看实现这个任务的另一种方法。&lt;/p&gt;
&lt;h2 id=&quot;实现通过-iptables-实现-proxy&quot;&gt;实现：通过 iptables 实现 proxy&lt;/h2&gt;
&lt;p&gt;用户空间代理程序的主要瓶颈来自内核-用户空间切换和数据复制。&lt;strong&gt;如果我们可以完全在内核空间中实现代理&lt;/strong&gt;，它将在性能上大大提高，从而击败用户空间的代理。&lt;code&gt;iptables&lt;/code&gt; 可用于实现这一目标。&lt;/p&gt;
&lt;p&gt;在开始之前，让我们首先弄清楚在执行 &lt;code&gt;curl ClusterIP:Port&lt;/code&gt; 时的流量路径，然后研究如何使用 &lt;code&gt;iptables&lt;/code&gt; 规则使其可访问。&lt;/p&gt;
&lt;h3 id=&quot;host---clusterip单一后端&quot;&gt;Host -&amp;gt; ClusterIP（单一后端）&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ClusterIP&lt;/code&gt; 不存在于任何网络设备上，所以为了让我们的数据包最终到达后端 Pod，我们需要将 &lt;code&gt;ClusterIP&lt;/code&gt; 转换为 PodIP（可路由），即：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;条件：匹配 &lt;code&gt;dst=ClusterIP,proto=tcp,dport=80&lt;/code&gt; 的数据包&lt;/li&gt;
&lt;li&gt;操作：将数据包的 IP 报头中的 &lt;code&gt;dst=ClusterIP&lt;/code&gt; 替换为 &lt;code&gt;dst=PodIP&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用网络术语来说，这是一个网络地址转换 (NAT) 过程。&lt;/p&gt;
&lt;h4 id=&quot;在哪里做-dnat&quot;&gt;在哪里做 DNAT&lt;/h4&gt;
&lt;p&gt;通过 curl 查看出口数据包路径（下图展示了数据流向过程）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./images/proxy_host-to-clusterip-dnat.png&quot; alt=&quot;host-to-clusterip-dnat&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&amp;lt;curl process&amp;gt; -&amp;gt; raw -&amp;gt; CT -&amp;gt; mangle -&amp;gt; dnat -&amp;gt; filter -&amp;gt; security -&amp;gt; snat -&amp;gt; &amp;lt;ROUTING&amp;gt; -&amp;gt; mangle -&amp;gt; snat -&amp;gt; NIC
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;很明显，在 OUTPUT 钩中只有一个 dnat（链），我们可以在其中进行 DNAT。&lt;/p&gt;
&lt;p&gt;让我们看看我们将如何进行黑客入侵。&lt;/p&gt;
&lt;h4 id=&quot;检查当前的-nat-规则&quot;&gt;检查当前的 NAT 规则&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;NAT&lt;/code&gt; 规则被组织到 &lt;code&gt;nat&lt;/code&gt; 表中。检查 &lt;code&gt;nat&lt;/code&gt; 表中的当前规则：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span&gt;# -t &amp;lt;table&amp;gt;&lt;/span&gt;
&lt;span&gt;# -L list rules&lt;/span&gt;
&lt;span&gt;# -n numeric output&lt;/span&gt;
$ iptables -t nat -L -n
Chain PREROUTING &lt;span&gt;(&lt;/span&gt;policy ACCEPT&lt;span&gt;)&lt;/span&gt;

Chain INPUT &lt;span&gt;(&lt;/span&gt;policy ACCEPT&lt;span&gt;)&lt;/span&gt;

Chain OUTPUT &lt;span&gt;(&lt;/span&gt;policy ACCEPT&lt;span&gt;)&lt;/span&gt;
DOCKER     all  --  0.0.0.0/0    !127.0.0.0/8   ADDRTYPE match dst-type LOCAL

Chain POSTROUTING &lt;span&gt;(&lt;/span&gt;policy ACCEPT&lt;span&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出显示除了与 DOCKER 相关的规则外，没有其他规则。这些 DOCKER 规则是 DOCKER 在安装时插入的，但它们不会影响我们在这篇文章中的实验。所以我们忽略它们。&lt;/p&gt;
&lt;h4 id=&quot;增加-dnat-规则&quot;&gt;增加 DNAT 规则&lt;/h4&gt;
&lt;p&gt;为了便于查看，我们不会用 go 代码包装 &lt;code&gt;iptables&lt;/code&gt; 命令，而是直接显示命令本身。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：在继续之前，请确保删除了在上一节中添加的所有规则。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;确认目前无法访问 ClusterIP：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ curl $CLUSTER_IP:$PORT
^C
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在添加我们的出口 NAT 规则：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ cat ENV
CLUSTER_IP&lt;span&gt;=&lt;/span&gt;10.7.111.132
POD_IP&lt;span&gt;=&lt;/span&gt;10.5.41.204
PORT&lt;span&gt;=&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;
PROTO&lt;span&gt;=&lt;/span&gt;tcp

&lt;span&gt;# -p               &amp;lt;protocol&amp;gt;&lt;/span&gt;
&lt;span&gt;# -A               add rule&lt;/span&gt;
&lt;span&gt;# --dport          &amp;lt;dst port&amp;gt;&lt;/span&gt;
&lt;span&gt;# -d               &amp;lt;dst ip&amp;gt;&lt;/span&gt;
&lt;span&gt;# -j               jump to&lt;/span&gt;
&lt;span&gt;# --to-destination &amp;lt;ip&amp;gt;:&amp;lt;port&amp;gt;&lt;/span&gt;
$ iptables -t nat -A OUTPUT -p $PROTO --dport $PORT -d $CLUSTER_IP -j DNAT --to-destination $POD_IP:$PORT
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;再次检查规则表：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ iptables -t nat -L -n

Chain OUTPUT &lt;span&gt;(&lt;/span&gt;policy ACCEPT&lt;span&gt;)&lt;/span&gt;
target     prot opt source      destination
DNAT       tcp  --  0.0.0.0/0   10.7.111.132   tcp dpt:80 to:10.5.41.204:80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们可以看到规则已经被添加。&lt;/p&gt;
&lt;h4 id=&quot;测试可达性&quot;&gt;测试可达性&lt;/h4&gt;
&lt;p&gt;现在再一次访问：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ curl $CLUSTER_IP:$PORT
&amp;lt;!DOCTYPE html&amp;gt;
...
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;就是这样！访问成功。&lt;/p&gt;
&lt;p&gt;但是等等！我们期望出口的交通应该是正确的，但我们没有添加任何 NAT 规则的入口路径，怎么可能交通是正常的两个方向？事实证明，当你为一个方向添加一个 NAT 规则时，Linux 内核会自动为另一个方向添加保留规则！这与 conntrack (CT，连接跟踪）模块协同工作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./images/proxy_host-to-clusterip-dnat-ct.png&quot; alt=&quot;host-to-clusterip-dnat-ct&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;清理&quot;&gt;清理&lt;/h4&gt;
&lt;p&gt;删除这些规则：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ iptables -t nat -L -n --line-numbers
...
Chain OUTPUT &lt;span&gt;(&lt;/span&gt;policy ACCEPT&lt;span&gt;)&lt;/span&gt;
num  target     prot opt source               destination
&lt;span&gt;2&lt;/span&gt;    DNAT       tcp  --  0.0.0.0/0   10.7.111.132   tcp dpt:80 to:10.5.41.204:80

&lt;span&gt;# iptables -t &amp;lt;table&amp;gt; -D &amp;lt;chain&amp;gt; &amp;lt;num&amp;gt;&lt;/span&gt;
$ iptables -t nat -D OUTPUT &lt;span&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&quot;host---clusterip-多个后端&quot;&gt;Host -&amp;gt; ClusterIP （多个后端）&lt;/h3&gt;
&lt;p&gt;在上一节中，我们展示了如何使用一个后端 Pod 执行 NAT。现在让我们看看多后端情况。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：在继续之前，请确保删除了在上一节中添加的所有规则。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;伸缩-webapp&quot;&gt;伸缩 webapp&lt;/h4&gt;
&lt;p&gt;首先扩大我们的服务到 2 个后端 pods:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ kubectl scale sts webapp --replicas&lt;span&gt;=&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
statefulset.apps/webapp scaled

$ kubectl get pod -o wide | grep webapp
webapp-0   2/2     Running   &lt;span&gt;0&lt;/span&gt;   1h24m   10.5.41.204    node1    &amp;lt;none&amp;gt; &amp;lt;none&amp;gt;
webapp-1   2/2     Running   &lt;span&gt;0&lt;/span&gt;   11s     10.5.41.5      node1    &amp;lt;none&amp;gt; &amp;lt;none&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&quot;通过负载平衡添加-dnat-规则&quot;&gt;通过负载平衡添加 DNAT 规则&lt;/h4&gt;
&lt;p&gt;我们需要 &lt;code&gt;iptables&lt;/code&gt; 中的 &lt;code&gt;statistic&lt;/code&gt; 模块以概率的方式将请求分发到后端 Pods，这样才能达到负载均衡的效果：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span&gt;# -m &amp;lt;module&amp;gt;&lt;/span&gt;
$ iptables -t nat -A OUTPUT -p $PROTO --dport $PORT -d $CLUSTER_IP &lt;span&gt;\
&lt;/span&gt;&lt;span/&gt;    -m statistic --mode random --probability 0.5  &lt;span&gt;\
&lt;/span&gt;&lt;span/&gt;    -j DNAT --to-destination $POD1_IP:$PORT
$ iptables -t nat -A OUTPUT -p $PROTO --dport $PORT -d $CLUSTER_IP &lt;span&gt;\
&lt;/span&gt;&lt;span/&gt;    -m statistic --mode random --probability 1.0  &lt;span&gt;\
&lt;/span&gt;&lt;span/&gt;    -j DNAT --to-destination $POD2_IP:$PORT
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面的命令指定在两个 Pods 之间随机分配请求，每个都有 50% 的概率。&lt;/p&gt;
&lt;p&gt;现在检查这些规则：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ iptables -t nat -L -n
...
Chain OUTPUT &lt;span&gt;(&lt;/span&gt;policy ACCEPT&lt;span&gt;)&lt;/span&gt;
target  prot opt source      destination
DNAT    tcp  --  0.0.0.0/0   10.7.111.132  tcp dpt:80 statistic mode random probability 0.50000000000 to:10.5.41.204:80
DNAT    tcp  --  0.0.0.0/0   10.7.111.132  tcp dpt:80 statistic mode random probability 1.00000000000 to:10.5.41.5:80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&quot;./images/proxy_host-to-clusterip-lb-ct.png&quot; alt=&quot;host-to-clusterip-lb-ct&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;验证&quot;&gt;验证&lt;/h4&gt;
&lt;p&gt;现在，我们来验证下负载均衡是否生效。我们发出 8 个 请求，并捕获到这个主机通信的真实 PodIPs:&lt;/p&gt;
&lt;p&gt;在测试节点上打开一个 shell:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ &lt;span&gt;for&lt;/span&gt; i in &lt;span&gt;{&lt;/span&gt;1..8&lt;span&gt;}&lt;/span&gt;; &lt;span&gt;do&lt;/span&gt; curl $CLUSTER_IP:$PORT 2&amp;gt;&amp;amp;&lt;span&gt;1&lt;/span&gt; &amp;gt;/dev/null; sleep 1; &lt;span&gt;done&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;测试节点上的另一个 shell 窗口：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ tcpdump -nn -i eth0 port $PORT | grep &lt;span&gt;&quot;GET /&quot;&lt;/span&gt;
10.21.0.7.48306 &amp;gt; 10.5.41.5.80:   ... HTTP: GET / HTTP/1.1
10.21.0.7.48308 &amp;gt; 10.5.41.204.80: ... HTTP: GET / HTTP/1.1
10.21.0.7.48310 &amp;gt; 10.5.41.204.80: ... HTTP: GET / HTTP/1.1
10.21.0.7.48312 &amp;gt; 10.5.41.5.80:   ... HTTP: GET / HTTP/1.1
10.21.0.7.48314 &amp;gt; 10.5.41.5.80:   ... HTTP: GET / HTTP/1.1
10.21.0.7.48316 &amp;gt; 10.5.41.204.80: ... HTTP: GET / HTTP/1.1
10.21.0.7.48318 &amp;gt; 10.5.41.5.80:   ... HTTP: GET / HTTP/1.1
10.21.0.7.48320 &amp;gt; 10.5.41.204.80: ... HTTP: GET / HTTP/1.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 Pod1 中有 4 次，在 Pod2 中有 4 次，每个 pod 有 50%，这正是我们所期望的。&lt;/p&gt;
&lt;h4 id=&quot;清理-1&quot;&gt;清理&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ iptables -t nat -L -n --line-numbers
...
Chain OUTPUT &lt;span&gt;(&lt;/span&gt;policy ACCEPT&lt;span&gt;)&lt;/span&gt;
num  target     prot opt source               destination
&lt;span&gt;2&lt;/span&gt;    DNAT    tcp  --  0.0.0.0/0   10.7.111.132  tcp dpt:80 statistic mode random probability 0.50000000000 to:10.5.41.204:80
&lt;span&gt;3&lt;/span&gt;    DNAT    tcp  --  0.0.0.0/0   10.7.111.132  tcp dpt:80 statistic mode random probability 1.00000000000 to:10.5.41.5:80

$ iptables -t nat -D OUTPUT &lt;span&gt;2&lt;/span&gt;
$ iptables -t nat -D OUTPUT &lt;span&gt;3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&quot;pod-app-a---clusterip-app-b&quot;&gt;Pod (app A) -&amp;gt; ClusterIP (app B)&lt;/h3&gt;
&lt;p&gt;如果想通过 hostA 上的 &lt;code&gt;Pod A&lt;/code&gt; 通过 &lt;code&gt;ClusterIP&lt;/code&gt; 访问 &lt;code&gt;Pod B&lt;/code&gt;，B 的 Pod 驻留在 hostB 上，我们应该做什么？&lt;/p&gt;
&lt;p&gt;实际上，这与 &lt;code&gt;Host -&amp;gt; ClusterIP&lt;/code&gt; 情况非常相似，但是有一点需要注意：在执行 NAT 之后，源节点 (hostA) 需要将包发送到目的地 Pod 所在的正确目的地节点 (hostB)。根据不同的跨主机网络解决方案，这有很大不同：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于直接路由的情况下，主机只是发送数据包。对应的有这些解决方案：
&lt;ul&gt;
&lt;li&gt;calico + bird&lt;/li&gt;
&lt;li&gt;cilium + kube-router（Cilium BGP 的默认解决方案）&lt;/li&gt;
&lt;li&gt;cilium + bird（实际上这只是我们的测试环境网络解决方案）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对于隧道的情况，每个主机上必须有一个代理，它在 DNAT 之后执行 encap，在 SNAT 之前执行 decap。这些解决方案包括：
&lt;ul&gt;
&lt;li&gt;calico + VxLAN 模式&lt;/li&gt;
&lt;li&gt;flannel + IPIP 模式&lt;/li&gt;
&lt;li&gt;flannel + VxLAN 模式&lt;/li&gt;
&lt;li&gt;cilium + VxLAN 模式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;像 aws 的 ENI 模式：类似于直接路由，但不需要 BGP 代理

&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下图展示了隧道的情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./images/proxy_tunneling.png&quot; alt=&quot;tunneling&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代理与隧道相关的职责包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;同步所有节点之间的隧道信息&lt;/strong&gt;，例如描述哪个实例在哪个节点上的信息&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在 DNAT 之后对 pod 流量执行封装&lt;/strong&gt;：对于所有的出口流量，例如来自 hostA 的 &lt;code&gt;dst=&amp;lt;PodIP&amp;gt;&lt;/code&gt;，其中 PodIP 在 hostB 上，通过添加另一个头来封装数据包，例如 VxLAN 头，其中封装头有 &lt;code&gt;src=hostA_IP,dst=hostB_IP&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在 SNAT 之前对 Pod 流量执行解封装&lt;/strong&gt;：解封装每个入口封装的数据包：删除外层（例如 VxLAN 标头）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同时，主机需要决定：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;哪些数据包应该交给解码器（pod 流量），哪些不应该（例如主机流量）&lt;/li&gt;
&lt;li&gt;哪些包应该封装（pod 流量），哪些不应该（例如主机流量）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;重新构造-iptables-规则&quot;&gt;重新构造 iptables 规则&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：在继续之前，请确保删除了在上一节中添加的所有规则。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当你有大量的 Service 时，每个节点上的 iptables 规则将相当复杂，因此你需要进行一些结构化工作来组织这些规则。&lt;/p&gt;
&lt;p&gt;在本节中，我们将在 nat 表中创建几个专用的 iptables 链，具体如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;链 &lt;code&gt;KUBE-SERVICES&lt;/code&gt;：拦截 nat 表的输出链中所有到此链的出口流量，如果它们被指定为 ClusterIP，则执行 DNAT&lt;/li&gt;
&lt;li&gt;链 &lt;code&gt;KUBE-SVC-WEBAPP&lt;/code&gt;：如果 &lt;code&gt;dst&lt;/code&gt;、&lt;code&gt;proto&lt;/code&gt; 和 &lt;code&gt;port&lt;/code&gt; 匹配，则拦截该链 &lt;code&gt;KUBE-SERVICES&lt;/code&gt; 中的所有流量&lt;/li&gt;
&lt;li&gt;链 &lt;code&gt;KUBE-SEP-WEBAPP1&lt;/code&gt;：拦截 50% 的流量在 &lt;code&gt;KUBE-SVC-WEBAPP&lt;/code&gt; 到这里&lt;/li&gt;
&lt;li&gt;链 &lt;code&gt;KUBE-SEP-WEBAPP2&lt;/code&gt;：拦截 50% 的流量在 &lt;code&gt;KUBE-SVC-WEBAPP&lt;/code&gt; 到这里&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;DNAT 路径现在为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;OUTPUT -&amp;gt; KUBE-SERVICES -&amp;gt; KUBE-SVC-WEBAPP --&amp;gt; KUBE-SEP-WEBAPP1
                                         &lt;span&gt;\
&lt;/span&gt;&lt;span/&gt;                                          &lt;span&gt;\-&lt;/span&gt;-&amp;gt; KUBE-SEP-WEBAPP2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果你有多个 Service，DNAT 路径如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;OUTPUT -&amp;gt; KUBE-SERVICES -&amp;gt; KUBE-SVC-A --&amp;gt; KUBE-SEP-A1
                      |              &lt;span&gt;\-&lt;/span&gt;-&amp;gt; KUBE-SEP-A2
                      |
                      |--&amp;gt; KUBE-SVC-B --&amp;gt; KUBE-SEP-B1
                      |              &lt;span&gt;\-&lt;/span&gt;-&amp;gt; KUBE-SEP-B2
                      |
                      |--&amp;gt; KUBE-SVC-C --&amp;gt; KUBE-SEP-C1
                                     &lt;span&gt;\-&lt;/span&gt;-&amp;gt; KUBE-SEP-C2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;iptables 命令：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ cat add-dnat-structured.sh
source ../ENV

set -x

KUBE_SVCS&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;KUBE-SERVICES&quot;&lt;/span&gt;        &lt;span&gt;# chain that serves as kubernetes service portal&lt;/span&gt;
SVC_WEBAPP&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;KUBE-SVC-WEBAPP&quot;&lt;/span&gt;     &lt;span&gt;# chain that serves as DNAT entrypoint for webapp&lt;/span&gt;
WEBAPP_EP1&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;KUBE-SEP-WEBAPP1&quot;&lt;/span&gt;    &lt;span&gt;# chain that performs dnat to pod1&lt;/span&gt;
WEBAPP_EP2&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;KUBE-SEP-WEBAPP2&quot;&lt;/span&gt;    &lt;span&gt;# chain that performs dnat to pod2&lt;/span&gt;

&lt;span&gt;# OUTPUT -&amp;gt; KUBE-SERVICES&lt;/span&gt;
sudo iptables -t nat -N $KUBE_SVCS
sudo iptables -t nat -A OUTPUT -p all -s 0.0.0.0/0 -d 0.0.0.0/0 -j $KUBE_SVCS

&lt;span&gt;# KUBE-SERVICES -&amp;gt; KUBE-SVC-WEBAPP&lt;/span&gt;
sudo iptables -t nat -N $SVC_WEBAPP
sudo iptables -t nat -A $KUBE_SVCS -p $PROTO -s 0.0.0.0/0 -d $CLUSTER_IP --dport $PORT -j $SVC_WEBAPP

&lt;span&gt;# KUBE-SVC-WEBAPP -&amp;gt; KUBE-SEP-WEBAPP*&lt;/span&gt;
sudo iptables -t nat -N $WEBAPP_EP1
sudo iptables -t nat -N $WEBAPP_EP2
sudo iptables -t nat -A $WEBAPP_EP1 -p $PROTO -s 0.0.0.0/0 -d 0.0.0.0/0 --dport $PORT -j DNAT --to-destination $POD1_IP:$PORT
sudo iptables -t nat -A $WEBAPP_EP2 -p $PROTO -s 0.0.0.0/0 -d 0.0.0.0/0 --dport $PORT -j DNAT --to-destination $POD2_IP:$PORT
sudo iptables -t nat -A $SVC_WEBAPP -p $PROTO -s 0.0.0.0/0 -d 0.0.0.0/0 -m statistic --mode random --probability 0.5  -j $WEBAPP_EP1
sudo iptables -t nat -A $SVC_WEBAPP -p $PROTO -s 0.0.0.0/0 -d 0.0.0.0/0 -m statistic --mode random --probability 1.0  -j $WEBAPP_EP2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在测试我们设计：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ ./add-dnat-structured.sh
++ KUBE_SVCS&lt;span&gt;=&lt;/span&gt;KUBE-SERVICES
++ SVC_WEBAPP&lt;span&gt;=&lt;/span&gt;KUBE-SVC-WEBAPP
++ WEBAPP_EP1&lt;span&gt;=&lt;/span&gt;KUBE-SEP-WEBAPP1
++ WEBAPP_EP2&lt;span&gt;=&lt;/span&gt;KUBE-SEP-WEBAPP2
++ sudo iptables -t nat -N KUBE-SERVICES
++ sudo iptables -t nat -A OUTPUT -p all -s 0.0.0.0/0 -d 0.0.0.0/0 -j KUBE-SERVICES
++ sudo iptables -t nat -N KUBE-SVC-WEBAPP
++ sudo iptables -t nat -A KUBE-SERVICES -p tcp -s 0.0.0.0/0 -d 10.7.111.132 --dport &lt;span&gt;80&lt;/span&gt; -j KUBE-SVC-WEBAPP
++ sudo iptables -t nat -N KUBE-SEP-WEBAPP1
++ sudo iptables -t nat -N KUBE-SEP-WEBAPP2
++ sudo iptables -t nat -A KUBE-SEP-WEBAPP1 -p tcp -s 0.0.0.0/0 -d 0.0.0.0/0 --dport &lt;span&gt;80&lt;/span&gt; -j DNAT --to-destination 10.5.41.204:80
++ sudo iptables -t nat -A KUBE-SEP-WEBAPP2 -p tcp -s 0.0.0.0/0 -d 0.0.0.0/0 --dport &lt;span&gt;80&lt;/span&gt; -j DNAT --to-destination 10.5.41.5:80
++ sudo iptables -t nat -A KUBE-SVC-WEBAPP -p tcp -s 0.0.0.0/0 -d 0.0.0.0/0 -m statistic --mode random --probability 0.5 -j KUBE-SEP-WEBAPP1
++ sudo iptables -t nat -A KUBE-SVC-WEBAPP -p tcp -s 0.0.0.0/0 -d 0.0.0.0/0 -m statistic --mode random --probability 1.0 -j KUBE-SEP-WEBAPP2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;检查这些规则：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ sudo iptables -t nat -L -n
...
Chain OUTPUT &lt;span&gt;(&lt;/span&gt;policy ACCEPT&lt;span&gt;)&lt;/span&gt;
target     prot opt source               destination
KUBE-SERVICES  all  --  0.0.0.0/0            0.0.0.0/0

Chain KUBE-SEP-WEBAPP1 &lt;span&gt;(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; references&lt;span&gt;)&lt;/span&gt;
target     prot opt source               destination
DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:80 to:10.5.41.204:80

Chain KUBE-SEP-WEBAPP2 &lt;span&gt;(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; references&lt;span&gt;)&lt;/span&gt;
target     prot opt source               destination
DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:80 to:10.5.41.5:80

Chain KUBE-SERVICES &lt;span&gt;(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; references&lt;span&gt;)&lt;/span&gt;
target     prot opt source               destination
KUBE-SVC-WEBAPP  tcp  --  0.0.0.0/0            10.7.111.132         tcp dpt:80

Chain KUBE-SVC-WEBAPP &lt;span&gt;(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; references&lt;span&gt;)&lt;/span&gt;
target     prot opt source               destination
KUBE-SEP-WEBAPP1  tcp  --  0.0.0.0/0            0.0.0.0/0            statistic mode random probability 0.50000000000
KUBE-SEP-WEBAPP2  tcp  --  0.0.0.0/0            0.0.0.0/0            statistic mode random probability 1.00000000000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ curl $CLUSTER_IP:$PORT
&amp;lt;!DOCTYPE html&amp;gt;
...
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;成功！&lt;/p&gt;
&lt;p&gt;如果你将上面的输出与普通的 &lt;code&gt;kube-proxy&lt;/code&gt; 规则进行比较，这两个规则是非常相似的，下面是从启用 &lt;code&gt;kube-proxy&lt;/code&gt; 的节点提取的：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;Chain OUTPUT &lt;span&gt;(&lt;/span&gt;policy ACCEPT&lt;span&gt;)&lt;/span&gt;
target         prot opt source               destination
KUBE-SERVICES  all  --  0.0.0.0/0            0.0.0.0/0            /* kubernetes service portals */

Chain KUBE-SERVICES &lt;span&gt;(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; references&lt;span&gt;)&lt;/span&gt;
target                     prot opt source               destination
KUBE-SVC-YK2SNH4V42VSDWIJ  tcp  --  0.0.0.0/0            10.7.22.18           /* default/nginx:web cluster IP */ tcp dpt:80

Chain KUBE-SVC-YK2SNH4V42VSDWIJ &lt;span&gt;(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; references&lt;span&gt;)&lt;/span&gt;
target                     prot opt source               destination
KUBE-SEP-GL2BLSI2B4ICU6WH  all  --  0.0.0.0/0            0.0.0.0/0            /* default/nginx:web */ statistic mode random probability 0.33332999982
KUBE-SEP-AIRRSG3CIF42U3PX  all  --  0.0.0.0/0            0.0.0.0/0            /* default/nginx:web */

Chain KUBE-SEP-GL2BLSI2B4ICU6WH &lt;span&gt;(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; references&lt;span&gt;)&lt;/span&gt;
target          prot opt source               destination
DNAT            tcp  --  0.0.0.0/0            0.0.0.0/0            /* default/nginx:web */ tcp to:10.244.3.181:80

Chain KUBE-SEP-AIRRSG3CIF42U3PX &lt;span&gt;(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; references&lt;span&gt;)&lt;/span&gt;
target          prot opt source               destination
DNAT            tcp  --  0.0.0.0/0            0.0.0.0/0            /* default/nginx:web */ tcp to:10.244.3.182:80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&quot;进一步重新构造-iptables-规则&quot;&gt;进一步重新构造 iptables 规则&lt;/h3&gt;
&lt;p&gt;TODO：为来自集群外部的流量添加规则。&lt;/p&gt;
&lt;h2 id=&quot;实现通过-ipvs-实现-proxy&quot;&gt;实现：通过 ipvs 实现 proxy&lt;/h2&gt;
&lt;p&gt;虽然基于 iptables 的代理在性能上优于基于用户空间的代理，但在集群服务过多的情况下也会导致性能严重下降 [6,7]。&lt;/p&gt;
&lt;p&gt;本质上，这是因为 iptables 判决是基于链的，它是一个复杂度为 O(n) 的线性算法。iptables 的一个好的替代方案是 IPVS——内核中的 L4 负载均衡器，它在底层使用 ipset（哈希实现），因此复杂度为 O(1)。&lt;/p&gt;
&lt;p&gt;让我们看看如何使用 ipvs 实现相同的目标。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：在继续之前，请确保删除了在上一节中添加的所有规则。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;安装-ipvs&quot;&gt;安装 IPVS&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ yum install -y ipvsadm

&lt;span&gt;# -l  list load balancing status&lt;/span&gt;
&lt;span&gt;# -n  numeric output&lt;/span&gt;
$ ipvsadm -ln
Prot LocalAddress:Port Scheduler Flags
  -&amp;gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;默认无规则&lt;/p&gt;
&lt;h4 id=&quot;增加虚拟真正的-services&quot;&gt;增加虚拟/真正的 services&lt;/h4&gt;
&lt;p&gt;使用 ipvs 实现负载均衡：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span&gt;# -A/--add-service           add service&lt;/span&gt;
&lt;span&gt;# -t/--tcp-service &amp;lt;address&amp;gt; VIP + Port&lt;/span&gt;
&lt;span&gt;# -s &amp;lt;method&amp;gt;                scheduling-method&lt;/span&gt;
&lt;span&gt;# -r/--real-server &amp;lt;address&amp;gt; real backend IP + Port&lt;/span&gt;
&lt;span&gt;# -m                         masquerading (NAT)&lt;/span&gt;
$ ipvsadm -A -t $CLUSTER_IP:$PORT -s rr
$ ipvsadm -a -t $CLUSTER_IP:$PORT -r $POD1_IP -m
$ ipvsadm -a -t $CLUSTER_IP:$PORT -r $POD2_IP -m
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;或者使用我的脚本：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ ./ipvs-add-server.sh
Adding virtual server CLUSTER_IP:PORT&lt;span&gt;=&lt;/span&gt;10.7.111.132:80 ...
Adding real servers ...
10.7.111.132:80 -&amp;gt; 10.5.41.204
10.7.111.132:80 -&amp;gt; 10.5.41.5
Done
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;再次检查状态：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ ipvsadm -ln
Prot LocalAddress:Port Scheduler Flags
  -&amp;gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn
TCP  10.7.111.132:80 rr
  -&amp;gt; 10.5.41.5:80                 Masq    &lt;span&gt;1&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt;          &lt;span&gt;0&lt;/span&gt;
  -&amp;gt; 10.5.41.204:80               Masq    &lt;span&gt;1&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt;          &lt;span&gt;0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;一些解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于所有发往 &lt;code&gt;10.7.111.132:80&lt;/code&gt; 的流量，将负载均衡到 &lt;code&gt;10.5.41.5:80&lt;/code&gt; 和 &lt;code&gt;10.5.41.204:80&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用轮询 (rr) 算法实现负载均衡&lt;/li&gt;
&lt;li&gt;两个后端，每个后端的权重为 1（各 50％）&lt;/li&gt;
&lt;li&gt;使用 MASQ（增强型 SNAT）在 VIP 和 RealIP 之间进行流量转发&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;验证-1&quot;&gt;验证&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ &lt;span&gt;for&lt;/span&gt; i in &lt;span&gt;{&lt;/span&gt;1..8&lt;span&gt;}&lt;/span&gt;; &lt;span&gt;do&lt;/span&gt; curl $CLUSTER_IP:$PORT 2&amp;gt;&amp;amp;&lt;span&gt;1&lt;/span&gt; &amp;gt;/dev/null; sleep 1; &lt;span&gt;done&lt;/span&gt;

$ tcpdump -nn -i eth0 port $PORT | grep &lt;span&gt;&quot;HTTP: GET&quot;&lt;/span&gt;
IP 10.21.0.7.49556 &amp;gt; 10.5.41.204.80: ... HTTP: GET / HTTP/1.1
IP 10.21.0.7.49558 &amp;gt; 10.5.41.5.80  : ... HTTP: GET / HTTP/1.1
IP 10.21.0.7.49560 &amp;gt; 10.5.41.204.80: ... HTTP: GET / HTTP/1.1
IP 10.21.0.7.49562 &amp;gt; 10.5.41.5.80  : ... HTTP: GET / HTTP/1.1
IP 10.21.0.7.49566 &amp;gt; 10.5.41.204.80: ... HTTP: GET / HTTP/1.1
IP 10.21.0.7.49568 &amp;gt; 10.5.41.5.80  : ... HTTP: GET / HTTP/1.1
IP 10.21.0.7.49570 &amp;gt; 10.5.41.204.80: ... HTTP: GET / HTTP/1.1
IP 10.21.0.7.49572 &amp;gt; 10.5.41.5.80  : ... HTTP: GET / HTTP/1.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;完美！&lt;/p&gt;
&lt;h3 id=&quot;清理-2&quot;&gt;清理&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ ./ipvs-del-server.sh
Deleting real servers ...
10.7.111.132:80 -&amp;gt; 10.5.41.204
10.7.111.132:80 -&amp;gt; 10.5.41.5
Deleting virtual server CLUSTER_IP:PORT&lt;span&gt;=&lt;/span&gt;10.7.111.132:80 ...
Done
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&quot;实现通过-bpf-实现-proxy&quot;&gt;实现：通过 bpf 实现 proxy&lt;/h2&gt;
&lt;p&gt;这也是一个 &lt;code&gt;O(1)&lt;/code&gt; 代理，但是与 IPVS 相比具有更高的性能。&lt;/p&gt;
&lt;p&gt;让我们看看如何在不到 100 行 C 代码中使用 eBPF 实现代理功能。&lt;/p&gt;
&lt;h3 id=&quot;先决条件&quot;&gt;先决条件&lt;/h3&gt;
&lt;p&gt;如果你有足够的时间和兴趣来阅读 eBPF/BPF，可以考虑阅读 &lt;a href=&quot;https://docs.cilium.io/en/v1.6/bpf/&quot;&gt;Cilium: BPF and XDP Reference Guide&lt;/a&gt;，它对开发人员来说是一个完美的 BPF 文档。&lt;/p&gt;
&lt;h3 id=&quot;实现&quot;&gt;实现&lt;/h3&gt;
&lt;p&gt;让我们看看出口部分的基本概念：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于所有流量，匹配 &lt;code&gt;dst=CLUSTER_IP &amp;amp;&amp;amp; proto==TCP &amp;amp;&amp;amp; dport==80&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;更改目标 IP：&lt;code&gt;CLUSTER_IP -&amp;gt; POD_IP&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;更新 IP 和 TCP 报头中的校验和文件（否则我们的数据包将被丢弃）&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;__section(&lt;span&gt;&quot;egress&quot;&lt;/span&gt;)
&lt;span&gt;int&lt;/span&gt; tc_egress(&lt;span&gt;struct&lt;/span&gt; __sk_buff &lt;span&gt;*&lt;/span&gt;skb)
{
    &lt;span&gt;const&lt;/span&gt; __be32 cluster_ip &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0x846F070A&lt;/span&gt;; &lt;span&gt;// 10.7.111.132
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;const&lt;/span&gt; __be32 pod_ip &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0x0529050A&lt;/span&gt;;     &lt;span&gt;// 10.5.41.5
&lt;/span&gt;&lt;span/&gt;
    &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; l3_off &lt;span&gt;=&lt;/span&gt; ETH_HLEN;    &lt;span&gt;// IP header offset
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; l4_off &lt;span&gt;=&lt;/span&gt; l3_off &lt;span&gt;+&lt;/span&gt; &lt;span&gt;20&lt;/span&gt;; &lt;span&gt;// TCP header offset: l3_off + sizeof(struct iphdr)
&lt;/span&gt;&lt;span/&gt;    __be32 sum;                     &lt;span&gt;// IP checksum
&lt;/span&gt;&lt;span/&gt;
    &lt;span&gt;void&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;data &lt;span&gt;=&lt;/span&gt; (&lt;span&gt;void&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;)(&lt;span&gt;long&lt;/span&gt;)skb&lt;span&gt;-&amp;gt;&lt;/span&gt;data;
    &lt;span&gt;void&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;data_end &lt;span&gt;=&lt;/span&gt; (&lt;span&gt;void&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;)(&lt;span&gt;long&lt;/span&gt;)skb&lt;span&gt;-&amp;gt;&lt;/span&gt;data_end;
    &lt;span&gt;if&lt;/span&gt; (data_end &lt;span&gt;&amp;lt;&lt;/span&gt; data &lt;span&gt;+&lt;/span&gt; l4_off) { &lt;span&gt;// not our packet
&lt;/span&gt;&lt;span/&gt;        &lt;span&gt;return&lt;/span&gt; TC_ACT_OK;
    }

    &lt;span&gt;struct&lt;/span&gt; iphdr &lt;span&gt;*&lt;/span&gt;ip4 &lt;span&gt;=&lt;/span&gt; (&lt;span&gt;struct&lt;/span&gt; iphdr &lt;span&gt;*&lt;/span&gt;)(data &lt;span&gt;+&lt;/span&gt; l3_off);
    &lt;span&gt;if&lt;/span&gt; (ip4&lt;span&gt;-&amp;gt;&lt;/span&gt;daddr &lt;span&gt;!=&lt;/span&gt; cluster_ip &lt;span&gt;||&lt;/span&gt; ip4&lt;span&gt;-&amp;gt;&lt;/span&gt;protocol &lt;span&gt;!=&lt;/span&gt; IPPROTO_TCP &lt;span&gt;/* || tcp-&amp;gt;dport == 80 */&lt;/span&gt;) {
        &lt;span&gt;return&lt;/span&gt; TC_ACT_OK;
    }

    &lt;span&gt;// DNAT: cluster_ip -&amp;gt; pod_ip, then update L3 and L4 checksum
&lt;/span&gt;&lt;span/&gt;    sum &lt;span&gt;=&lt;/span&gt; csum_diff((&lt;span&gt;void&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;)&lt;span&gt;&amp;amp;&lt;/span&gt;ip4&lt;span&gt;-&amp;gt;&lt;/span&gt;daddr, &lt;span&gt;4&lt;/span&gt;, (&lt;span&gt;void&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;)&lt;span&gt;&amp;amp;&lt;/span&gt;pod_ip, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;);
    skb_store_bytes(skb, l3_off &lt;span&gt;+&lt;/span&gt; offsetof(&lt;span&gt;struct&lt;/span&gt; iphdr, daddr), (&lt;span&gt;void&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;)&lt;span&gt;&amp;amp;&lt;/span&gt;pod_ip, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;);
    l3_csum_replace(skb, l3_off &lt;span&gt;+&lt;/span&gt; offsetof(&lt;span&gt;struct&lt;/span&gt; iphdr, check), &lt;span&gt;0&lt;/span&gt;, sum, &lt;span&gt;0&lt;/span&gt;);
l4_csum_replace(skb, l4_off &lt;span&gt;+&lt;/span&gt; offsetof(&lt;span&gt;struct&lt;/span&gt; tcphdr, check), &lt;span&gt;0&lt;/span&gt;, sum, BPF_F_PSEUDO_HDR);

    &lt;span&gt;return&lt;/span&gt; TC_ACT_OK;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于入口部分，非常类似于出口代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;__section(&lt;span&gt;&quot;ingress&quot;&lt;/span&gt;)
&lt;span&gt;int&lt;/span&gt; tc_ingress(&lt;span&gt;struct&lt;/span&gt; __sk_buff &lt;span&gt;*&lt;/span&gt;skb)
{
    &lt;span&gt;const&lt;/span&gt; __be32 cluster_ip &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0x846F070A&lt;/span&gt;; &lt;span&gt;// 10.7.111.132
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;const&lt;/span&gt; __be32 pod_ip &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0x0529050A&lt;/span&gt;;     &lt;span&gt;// 10.5.41.5
&lt;/span&gt;&lt;span/&gt;
    &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; l3_off &lt;span&gt;=&lt;/span&gt; ETH_HLEN;    &lt;span&gt;// IP header offset
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; l4_off &lt;span&gt;=&lt;/span&gt; l3_off &lt;span&gt;+&lt;/span&gt; &lt;span&gt;20&lt;/span&gt;; &lt;span&gt;// TCP header offset: l3_off + sizeof(struct iphdr)
&lt;/span&gt;&lt;span/&gt;    __be32 sum;                     &lt;span&gt;// IP checksum
&lt;/span&gt;&lt;span/&gt;
    &lt;span&gt;void&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;data &lt;span&gt;=&lt;/span&gt; (&lt;span&gt;void&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;)(&lt;span&gt;long&lt;/span&gt;)skb&lt;span&gt;-&amp;gt;&lt;/span&gt;data;
    &lt;span&gt;void&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;data_end &lt;span&gt;=&lt;/span&gt; (&lt;span&gt;void&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;)(&lt;span&gt;long&lt;/span&gt;)skb&lt;span&gt;-&amp;gt;&lt;/span&gt;data_end;
    &lt;span&gt;if&lt;/span&gt; (data_end &lt;span&gt;&amp;lt;&lt;/span&gt; data &lt;span&gt;+&lt;/span&gt; l4_off) { &lt;span&gt;// not our packet
&lt;/span&gt;&lt;span/&gt;        &lt;span&gt;return&lt;/span&gt; TC_ACT_OK;
    }

    &lt;span&gt;struct&lt;/span&gt; iphdr &lt;span&gt;*&lt;/span&gt;ip4 &lt;span&gt;=&lt;/span&gt; (&lt;span&gt;struct&lt;/span&gt; iphdr &lt;span&gt;*&lt;/span&gt;)(data &lt;span&gt;+&lt;/span&gt; l3_off);
    &lt;span&gt;if&lt;/span&gt; (ip4&lt;span&gt;-&amp;gt;&lt;/span&gt;saddr &lt;span&gt;!=&lt;/span&gt; pod_ip &lt;span&gt;||&lt;/span&gt; ip4&lt;span&gt;-&amp;gt;&lt;/span&gt;protocol &lt;span&gt;!=&lt;/span&gt; IPPROTO_TCP &lt;span&gt;/* || tcp-&amp;gt;dport == 80 */&lt;/span&gt;) {
        &lt;span&gt;return&lt;/span&gt; TC_ACT_OK;
    }

    &lt;span&gt;// SNAT: pod_ip -&amp;gt; cluster_ip, then update L3 and L4 header
&lt;/span&gt;&lt;span/&gt;    sum &lt;span&gt;=&lt;/span&gt; csum_diff((&lt;span&gt;void&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;)&lt;span&gt;&amp;amp;&lt;/span&gt;ip4&lt;span&gt;-&amp;gt;&lt;/span&gt;saddr, &lt;span&gt;4&lt;/span&gt;, (&lt;span&gt;void&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;)&lt;span&gt;&amp;amp;&lt;/span&gt;cluster_ip, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;);
    skb_store_bytes(skb, l3_off &lt;span&gt;+&lt;/span&gt; offsetof(&lt;span&gt;struct&lt;/span&gt; iphdr, saddr), (&lt;span&gt;void&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;)&lt;span&gt;&amp;amp;&lt;/span&gt;cluster_ip, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;);
    l3_csum_replace(skb, l3_off &lt;span&gt;+&lt;/span&gt; offsetof(&lt;span&gt;struct&lt;/span&gt; iphdr, check), &lt;span&gt;0&lt;/span&gt;, sum, &lt;span&gt;0&lt;/span&gt;);
l4_csum_replace(skb, l4_off &lt;span&gt;+&lt;/span&gt; offsetof(&lt;span&gt;struct&lt;/span&gt; tcphdr, check), &lt;span&gt;0&lt;/span&gt;, sum, BPF_F_PSEUDO_HDR);

    &lt;span&gt;return&lt;/span&gt; TC_ACT_OK;
}

&lt;span&gt;char&lt;/span&gt; __license[] __section(&lt;span&gt;&quot;license&quot;&lt;/span&gt;) &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;GPL&quot;&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&quot;编译并加载到内核中&quot;&gt;编译并加载到内核中&lt;/h3&gt;
&lt;p&gt;现在使用我的小脚本编译和加载到内核：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ ./compile-and-load.sh
...
++ sudo tc filter show dev eth0 egress
filter protocol all pref &lt;span&gt;49152&lt;/span&gt; bpf chain &lt;span&gt;0&lt;/span&gt;
filter protocol all pref &lt;span&gt;49152&lt;/span&gt; bpf chain &lt;span&gt;0&lt;/span&gt; handle 0x1 toy-proxy-bpf.o:&lt;span&gt;[&lt;/span&gt;egress&lt;span&gt;]&lt;/span&gt; direct-action not_in_hw id &lt;span&gt;18&lt;/span&gt; tag f5f39a21730006aa jited

++ sudo tc filter show dev eth0 ingress
filter protocol all pref &lt;span&gt;49152&lt;/span&gt; bpf chain &lt;span&gt;0&lt;/span&gt;
filter protocol all pref &lt;span&gt;49152&lt;/span&gt; bpf chain &lt;span&gt;0&lt;/span&gt; handle 0x1 toy-proxy-bpf.o:&lt;span&gt;[&lt;/span&gt;ingress&lt;span&gt;]&lt;/span&gt; direct-action not_in_hw id &lt;span&gt;19&lt;/span&gt; tag b41159c5873bcbc9 jited
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;脚本是这样的：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ cat compile-and-load.sh
set -x

NIC&lt;span&gt;=&lt;/span&gt;eth0

&lt;span&gt;# compile c code into bpf code&lt;/span&gt;
clang -O2 -Wall -c toy-proxy-bpf.c -target bpf -o toy-proxy-bpf.o

&lt;span&gt;# add tc queuing discipline (egress and ingress buffer)&lt;/span&gt;
sudo tc qdisc del dev $NIC clsact 2&amp;gt;&amp;amp;&lt;span&gt;1&lt;/span&gt; &amp;gt;/dev/null
sudo tc qdisc add dev $NIC clsact

&lt;span&gt;# load bpf code into the tc egress and ingress hook respectively&lt;/span&gt;
sudo tc filter add dev $NIC egress bpf da obj toy-proxy-bpf.o sec egress
sudo tc filter add dev $NIC ingress bpf da obj toy-proxy-bpf.o sec ingress

&lt;span&gt;# show info&lt;/span&gt;
sudo tc filter show dev $NIC egress
sudo tc filter show dev $NIC ingress
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&quot;验证-2&quot;&gt;验证&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ curl $CLUSTER_IP:$PORT
&amp;lt;!DOCTYPE html&amp;gt;
...
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;完美！&lt;/p&gt;
&lt;h3 id=&quot;清理-3&quot;&gt;清理&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ sudo tc qdisc del dev $NIC clsact 2&amp;gt;&amp;amp;&lt;span&gt;1&lt;/span&gt; &amp;gt;/dev/null
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;在这篇文章中，我们用不同的方法手工实现了 &lt;code&gt;kube-proxy&lt;/code&gt; 的核心功能。希望你现在对 kubernetes 节点代理有了更好的理解，以及关于网络的其他一些配置。&lt;/p&gt;
&lt;p&gt;在这篇文章中使用的代码和脚本：&lt;a href=&quot;https://github.com/icyxp/icyxp.github.io/tree/master./images/code&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;参考文献&quot;&gt;参考文献&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://kubernetes.io/docs/reference/command-line-tools-reference/kube-proxy/&quot;&gt;Kubernetes Doc: CLI - kube-proxy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/kubernetes/enhancements/blob/master/keps/sig-network/0011-ipvs-proxier.md&quot;&gt;kubernetes/enhancements: enhancements/0011-ipvs-proxier.md&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types&quot;&gt;Kubernetes Doc: Service types&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://kubernetes.io/docs/concepts/cluster-administration/proxies/&quot;&gt;Proxies in Kubernetes - Kubernetes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/@benmeier_/a-quick-minimal-ipvs-load-balancer-demo-d5cc42d0deb4&quot;&gt;A minimal IPVS Load Balancer demo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.google.com/presentation/d/1BaIAywY2qqeHtyGZtlyAp89JIZs59MZLKcFLxKE6LyM/edit#slide=id.p3&quot;&gt;Scaling Kubernetes to Support 50,000 Services&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37230013&quot;&gt;华为云在 K8S 大规模场景下的 Service 性能优化实践&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;附录&quot;&gt;附录&lt;/h2&gt;
&lt;p&gt;webapp.yaml:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span&gt;apiVersion&lt;/span&gt;: v1
&lt;span&gt;kind&lt;/span&gt;: Service
&lt;span&gt;metadata&lt;/span&gt;:
  &lt;span&gt;name&lt;/span&gt;: webapp
  &lt;span&gt;labels&lt;/span&gt;:
    &lt;span&gt;app&lt;/span&gt;: webapp
&lt;span&gt;spec&lt;/span&gt;:
  &lt;span&gt;ports&lt;/span&gt;:
  - &lt;span&gt;port&lt;/span&gt;: &lt;span&gt;80&lt;/span&gt;
    &lt;span&gt;name&lt;/span&gt;: web
  &lt;span&gt;selector&lt;/span&gt;:
    &lt;span&gt;app&lt;/span&gt;: webapp
---
&lt;span&gt;apiVersion&lt;/span&gt;: apps/v1
&lt;span&gt;kind&lt;/span&gt;: StatefulSet
&lt;span&gt;metadata&lt;/span&gt;:
  &lt;span&gt;name&lt;/span&gt;: webapp
&lt;span&gt;spec&lt;/span&gt;:
  &lt;span&gt;serviceName&lt;/span&gt;: &lt;span&gt;&quot;webapp&quot;&lt;/span&gt;
  &lt;span&gt;replicas&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;
  &lt;span&gt;selector&lt;/span&gt;:
    &lt;span&gt;matchLabels&lt;/span&gt;:
      &lt;span&gt;app&lt;/span&gt;: webapp
  &lt;span&gt;template&lt;/span&gt;:
    &lt;span&gt;metadata&lt;/span&gt;:
      &lt;span&gt;labels&lt;/span&gt;:
        &lt;span&gt;app&lt;/span&gt;: webapp
    &lt;span&gt;spec&lt;/span&gt;:
      &lt;span&gt;# affinity:&lt;/span&gt;
      &lt;span&gt;#   nodeAffinity:&lt;/span&gt;
      &lt;span&gt;#     requiredDuringSchedulingIgnoredDuringExecution:&lt;/span&gt;
      &lt;span&gt;#       nodeSelectorTerms:&lt;/span&gt;
      &lt;span&gt;#       - matchExpressions:&lt;/span&gt;
      &lt;span&gt;#         - key: kubernetes.io/hostname&lt;/span&gt;
      &lt;span&gt;#           operator: In&lt;/span&gt;
      &lt;span&gt;#           values:&lt;/span&gt;
      &lt;span&gt;#           - node1&lt;/span&gt;
      &lt;span&gt;tolerations&lt;/span&gt;:
      - &lt;span&gt;effect&lt;/span&gt;: NoSchedule
        &lt;span&gt;key&lt;/span&gt;: smoke
        &lt;span&gt;operator&lt;/span&gt;: Equal
        &lt;span&gt;value&lt;/span&gt;: test
      &lt;span&gt;containers&lt;/span&gt;:
      - &lt;span&gt;name&lt;/span&gt;: webapp
        &lt;span&gt;image&lt;/span&gt;: nginx-slim:&lt;span&gt;0.8&lt;/span&gt;
        &lt;span&gt;ports&lt;/span&gt;:
        - &lt;span&gt;containerPort&lt;/span&gt;: &lt;span&gt;80&lt;/span&gt;
          &lt;span&gt;name&lt;/span&gt;: web
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f42975c38e85d05791840224ec9e7200</guid>
<title>从几亿的坑爹项目说 JSON 格式的比较的实现</title>
<link>https://toutiao.io/k/hq9n8q3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.37613019891500904&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AxaTsYOXGWCK8E6d78xUXpVaNNQYx7LKtaXUSFtZEXFQT632vKvknRY4KCfghHOa5eUKS4cVtZibbmShaZDQCXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;553&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;国内一个据说专业外包户的xxxInfo公司，再做所谓的集中话，听说项目中标N个亿，在这就不细说了。&lt;/span&gt;&lt;span&gt;项目具体实施情况就不说了，说说最近在遇到的一个坑人的事情以及解决办法哈。&lt;/span&gt;&lt;span&gt;所在项目组，不对应该说是小作坊，根据甲方爸爸的要求需要接入该集中的项目，其实就是一个统一的API网关(当然现在本来就是用的统一API网关，只是这次的更集中话了而已)。&lt;/span&gt;&lt;span&gt;因此需要我们配合测试API是否正常，数据是否正确。&lt;/span&gt;&lt;span&gt;本来是个很简单的事情但是在测试的时候发现返回结果的JSON格式有差异，这就比较坑了，测试要求是需要给对方接口人提供差异点，比如说原本JSON的中X_RESULT_CODE但是现在是X_CODE，注入此类的问题很多。&lt;/span&gt;&lt;span&gt;由于线上接口比较多而已返回JSON格式比较复杂，单靠眼里对比那是相当坑人的。&lt;/span&gt;&lt;span&gt;即便先格式化再排序对比还是需要靠人眼去识别。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n5&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;基于此说说JSON格式对于吧，其实但对比格式还是比较容易实现的，就是将所有的键值全体提取处理，然后做差异对比即可。当然再使用的操作需要处理数组类型的值。可以将所有的键值全体提取成js访问格式分为如下俩种&lt;/span&gt;&lt;/p&gt;&lt;pre mdtype=&quot;fences&quot; cid=&quot;n7&quot; lang=&quot;js&quot; spellcheck=&quot;false&quot;&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;data&lt;/span&gt;.&lt;span&gt;id&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;data&lt;/span&gt;.&lt;span&gt;id&lt;/span&gt;.&lt;span&gt;value&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;data&lt;/span&gt;.&lt;span&gt;list&lt;/span&gt;[&lt;span&gt;x&lt;/span&gt;]&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;data&lt;/span&gt;.&lt;span&gt;list&lt;/span&gt;[&lt;span&gt;x&lt;/span&gt;].&lt;span&gt;val&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;//以上俩种的N多中变种格式&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;p cid=&quot;n9&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;另外还有一种比较常见后台API接口中的变种方式JSON的value值是个字符串而非json对象，但是这个字符串能通过解码或者不解码可以直接转换成一个JSON对象。这种情况也需要单独处理。Talk is cheap. Show me the code!!!&lt;/span&gt;&lt;/p&gt;&lt;pre mdtype=&quot;fences&quot; cid=&quot;n11&quot; lang=&quot;java&quot; spellcheck=&quot;false&quot;&gt; &lt;span role=&quot;presentation&quot;&gt;   &lt;span&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;     &lt;span&gt;* 利用fastjson 实现的简单json键值提取&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;     &lt;span&gt;* @param bkey&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;     &lt;span&gt;* @param node&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;     &lt;span&gt;* @param dealStringJson&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;     &lt;span&gt;* @return&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;     &lt;span&gt;*/&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;Set&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;jsonObjectKeySet&lt;/span&gt;(&lt;span&gt;String&lt;/span&gt; &lt;span&gt;bkey&lt;/span&gt;, &lt;span&gt;JSONObject&lt;/span&gt; &lt;span&gt;node&lt;/span&gt;, &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;dealStringJson&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;Set&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;keySet&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;HashSet&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;();&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;Set&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;strings&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;node&lt;/span&gt;.&lt;span&gt;keySet&lt;/span&gt;();&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;String&lt;/span&gt; &lt;span&gt;key&lt;/span&gt; : &lt;span&gt;strings&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;            &lt;span&gt;Object&lt;/span&gt; &lt;span&gt;value&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;node&lt;/span&gt;.&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;key&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;            &lt;span&gt;String&lt;/span&gt; &lt;span&gt;myKey&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;!&lt;/span&gt;&lt;span&gt;StringUtils&lt;/span&gt;.&lt;span&gt;isBlank&lt;/span&gt;(&lt;span&gt;bkey&lt;/span&gt;)) {&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;                &lt;span&gt;myKey&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;bkey&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;.&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;            }&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;            &lt;span&gt;keySet&lt;/span&gt;.&lt;span&gt;add&lt;/span&gt;(&lt;span&gt;myKey&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;value&lt;/span&gt; &lt;span&gt;instanceof&lt;/span&gt; &lt;span&gt;JSONObject&lt;/span&gt; &lt;span&gt;||&lt;/span&gt; &lt;span&gt;value&lt;/span&gt; &lt;span&gt;instanceof&lt;/span&gt; &lt;span&gt;JSONArray&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;                &lt;span&gt;keySet&lt;/span&gt;.&lt;span&gt;addAll&lt;/span&gt;(&lt;span&gt;jsonKeySet&lt;/span&gt;(&lt;span&gt;myKey&lt;/span&gt;, &lt;span&gt;value&lt;/span&gt;, &lt;span&gt;dealStringJson&lt;/span&gt;));&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;            }&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;dealStringJson&lt;/span&gt; &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span&gt;value&lt;/span&gt; &lt;span&gt;instanceof&lt;/span&gt; &lt;span&gt;String&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;                &lt;span&gt;String&lt;/span&gt; &lt;span&gt;strJson&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; (&lt;span&gt;String&lt;/span&gt;) &lt;span&gt;value&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;                &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;strJson&lt;/span&gt;.&lt;span&gt;startsWith&lt;/span&gt;(&lt;span&gt;&quot;{&quot;&lt;/span&gt;) &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span&gt;strJson&lt;/span&gt;.&lt;span&gt;endsWith&lt;/span&gt;(&lt;span&gt;&quot;}&quot;&lt;/span&gt;)) {&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;                    &lt;span&gt;keySet&lt;/span&gt;.&lt;span&gt;addAll&lt;/span&gt;(&lt;span&gt;jsonKeySet&lt;/span&gt;(&lt;span&gt;myKey&lt;/span&gt;, &lt;span&gt;JSONObject&lt;/span&gt;.&lt;span&gt;parseObject&lt;/span&gt;(&lt;span&gt;strJson&lt;/span&gt;), &lt;span&gt;dealStringJson&lt;/span&gt;));&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;                }&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;                &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;strJson&lt;/span&gt;.&lt;span&gt;startsWith&lt;/span&gt;(&lt;span&gt;&quot;[&quot;&lt;/span&gt;) &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span&gt;strJson&lt;/span&gt;.&lt;span&gt;endsWith&lt;/span&gt;(&lt;span&gt;&quot;]&quot;&lt;/span&gt;)) {&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;                    &lt;span&gt;System&lt;/span&gt;.&lt;span&gt;out&lt;/span&gt;.&lt;span&gt;println&lt;/span&gt;(&lt;span&gt;&quot;@@@&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;strJson&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;                    &lt;span&gt;JSONArray&lt;/span&gt; &lt;span&gt;parseObject&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;JSONArray&lt;/span&gt;.&lt;span&gt;parseArray&lt;/span&gt;(&lt;span&gt;strJson&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;                    &lt;span&gt;keySet&lt;/span&gt;.&lt;span&gt;addAll&lt;/span&gt;(&lt;span&gt;jsonKeySet&lt;/span&gt;(&lt;span&gt;myKey&lt;/span&gt;, &lt;span&gt;parseObject&lt;/span&gt;, &lt;span&gt;dealStringJson&lt;/span&gt;));&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;                }&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;            }&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;        }&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;keySet&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;    }&lt;/span&gt;&lt;br/&gt; &lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;Set&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;jsonKeySet&lt;/span&gt;(&lt;span&gt;String&lt;/span&gt; &lt;span&gt;bkey&lt;/span&gt;, &lt;span&gt;Object&lt;/span&gt; &lt;span&gt;node&lt;/span&gt;, &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;dealStringJson&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;Set&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;keySet&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;HashSet&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;();&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;node&lt;/span&gt; &lt;span&gt;instanceof&lt;/span&gt; &lt;span&gt;JSONObject&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;            &lt;span&gt;keySet&lt;/span&gt;.&lt;span&gt;addAll&lt;/span&gt;(&lt;span&gt;jsonObjectKeySet&lt;/span&gt;(&lt;span&gt;bkey&lt;/span&gt;, (&lt;span&gt;JSONObject&lt;/span&gt;) &lt;span&gt;node&lt;/span&gt;, &lt;span&gt;dealStringJson&lt;/span&gt;));&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;        }&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;node&lt;/span&gt; &lt;span&gt;instanceof&lt;/span&gt; &lt;span&gt;JSONArray&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;            &lt;span&gt;Iterator&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Object&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;iterator&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; ((&lt;span&gt;JSONArray&lt;/span&gt;) &lt;span&gt;node&lt;/span&gt;).&lt;span&gt;iterator&lt;/span&gt;();&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;            &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;iterator&lt;/span&gt;.&lt;span&gt;hasNext&lt;/span&gt;()) {&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;                &lt;span&gt;Object&lt;/span&gt; &lt;span&gt;next&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;iterator&lt;/span&gt;.&lt;span&gt;next&lt;/span&gt;();&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;                &lt;span&gt;String&lt;/span&gt; &lt;span&gt;bsKey&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;bkey&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;[x]&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;                &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;next&lt;/span&gt; &lt;span&gt;instanceof&lt;/span&gt; &lt;span&gt;JSONObject&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;                    &lt;span&gt;keySet&lt;/span&gt;.&lt;span&gt;addAll&lt;/span&gt;(&lt;span&gt;jsonObjectKeySet&lt;/span&gt;(&lt;span&gt;bsKey&lt;/span&gt;, (&lt;span&gt;JSONObject&lt;/span&gt;) &lt;span&gt;next&lt;/span&gt;, &lt;span&gt;dealStringJson&lt;/span&gt;));&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;                }&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;            }&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;        }&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;keySet&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;    }&lt;/span&gt;&lt;br/&gt; &lt;br/&gt; &lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;    &lt;span&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;     &lt;span&gt;* 利用Jackson实现简单的json键值提取&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;     &lt;span&gt;* @param bKey&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;     &lt;span&gt;* @param node&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;     &lt;span&gt;* @return&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;     &lt;span&gt;* @throws IOException&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;     &lt;span&gt;*/&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;Set&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;jsonLeaf&lt;/span&gt;(&lt;span&gt;String&lt;/span&gt; &lt;span&gt;bKey&lt;/span&gt;, &lt;span&gt;JsonNode&lt;/span&gt; &lt;span&gt;node&lt;/span&gt;) &lt;span&gt;throws&lt;/span&gt; &lt;span&gt;IOException&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;Set&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;keySet&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;HashSet&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;();&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;node&lt;/span&gt;.&lt;span&gt;isValueNode&lt;/span&gt;()) {&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;            &lt;span&gt;String&lt;/span&gt; &lt;span&gt;strJson&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;node&lt;/span&gt;.&lt;span&gt;toString&lt;/span&gt;();&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;strJson&lt;/span&gt;.&lt;span&gt;startsWith&lt;/span&gt;(&lt;span&gt;&quot;{&quot;&lt;/span&gt;) &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span&gt;strJson&lt;/span&gt;.&lt;span&gt;endsWith&lt;/span&gt;(&lt;span&gt;&quot;}&quot;&lt;/span&gt;)) {&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;                &lt;span&gt;ObjectMapper&lt;/span&gt; &lt;span&gt;jackson&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;ObjectMapper&lt;/span&gt;();&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;                &lt;span&gt;JsonNode&lt;/span&gt; &lt;span&gt;nodeStr&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;jackson&lt;/span&gt;.&lt;span&gt;readTree&lt;/span&gt;(&lt;span&gt;strJson&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;                &lt;span&gt;keySet&lt;/span&gt;.&lt;span&gt;addAll&lt;/span&gt;(&lt;span&gt;jsonLeaf&lt;/span&gt;(&lt;span&gt;bKey&lt;/span&gt;, &lt;span&gt;nodeStr&lt;/span&gt;));&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;            }&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;strJson&lt;/span&gt;.&lt;span&gt;startsWith&lt;/span&gt;(&lt;span&gt;&quot;[&quot;&lt;/span&gt;) &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span&gt;strJson&lt;/span&gt;.&lt;span&gt;endsWith&lt;/span&gt;(&lt;span&gt;&quot;]&quot;&lt;/span&gt;)) {&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;                &lt;span&gt;ObjectMapper&lt;/span&gt; &lt;span&gt;jackson&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;ObjectMapper&lt;/span&gt;();&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;                &lt;span&gt;JsonNode&lt;/span&gt; &lt;span&gt;nodeStr&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;jackson&lt;/span&gt;.&lt;span&gt;readTree&lt;/span&gt;(&lt;span&gt;strJson&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;                &lt;span&gt;keySet&lt;/span&gt;.&lt;span&gt;addAll&lt;/span&gt;(&lt;span&gt;jsonLeaf&lt;/span&gt;(&lt;span&gt;bKey&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;[x]&quot;&lt;/span&gt;, &lt;span&gt;nodeStr&lt;/span&gt;));&lt;/span&gt;&lt;br/&gt; &lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;            }&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;keySet&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;        }&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;node&lt;/span&gt;.&lt;span&gt;isObject&lt;/span&gt;()) {&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;            &lt;span&gt;Iterator&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Map&lt;/span&gt;.&lt;span&gt;Entry&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;, &lt;span&gt;JsonNode&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;it&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;node&lt;/span&gt;.&lt;span&gt;fields&lt;/span&gt;();&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;            &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;it&lt;/span&gt;.&lt;span&gt;hasNext&lt;/span&gt;()) {&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;                &lt;span&gt;Map&lt;/span&gt;.&lt;span&gt;Entry&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;, &lt;span&gt;JsonNode&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;entry&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;it&lt;/span&gt;.&lt;span&gt;next&lt;/span&gt;();&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;                &lt;span&gt;String&lt;/span&gt; &lt;span&gt;key&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;entry&lt;/span&gt;.&lt;span&gt;getKey&lt;/span&gt;();&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;                &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;!&lt;/span&gt;&lt;span&gt;StringUtils&lt;/span&gt;.&lt;span&gt;isBlank&lt;/span&gt;(&lt;span&gt;bKey&lt;/span&gt;)) {&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;                    &lt;span&gt;key&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;bKey&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;.&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;                }&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;                &lt;span&gt;keySet&lt;/span&gt;.&lt;span&gt;add&lt;/span&gt;(&lt;span&gt;key&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;                &lt;span&gt;JsonNode&lt;/span&gt; &lt;span&gt;value&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;entry&lt;/span&gt;.&lt;span&gt;getValue&lt;/span&gt;();&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;                &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;value&lt;/span&gt;.&lt;span&gt;isContainerNode&lt;/span&gt;()) {&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;                    &lt;span&gt;keySet&lt;/span&gt;.&lt;span&gt;addAll&lt;/span&gt;(&lt;span&gt;jsonLeaf&lt;/span&gt;(&lt;span&gt;key&lt;/span&gt;, &lt;span&gt;value&lt;/span&gt;));&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;                }&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;            }&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;        }&lt;/span&gt;&lt;br/&gt; &lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;node&lt;/span&gt;.&lt;span&gt;isArray&lt;/span&gt;()) {&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;            &lt;span&gt;Iterator&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;JsonNode&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;it&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;node&lt;/span&gt;.&lt;span&gt;iterator&lt;/span&gt;();&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;            &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;it&lt;/span&gt;.&lt;span&gt;hasNext&lt;/span&gt;()) {&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;                &lt;span&gt;keySet&lt;/span&gt;.&lt;span&gt;addAll&lt;/span&gt;(&lt;span&gt;jsonLeaf&lt;/span&gt;(&lt;span&gt;bKey&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;[x]&quot;&lt;/span&gt;, &lt;span&gt;it&lt;/span&gt;.&lt;span&gt;next&lt;/span&gt;()));&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;            }&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;        }&lt;/span&gt;&lt;br/&gt; &lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;keySet&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;    }&lt;/span&gt;&lt;/pre&gt;&lt;p cid=&quot;n15&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;调用实例&lt;/span&gt;&lt;/p&gt;&lt;pre mdtype=&quot;fences&quot; cid=&quot;n17&quot; lang=&quot;java&quot; spellcheck=&quot;false&quot;&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;JSONObject&lt;/span&gt; &lt;span&gt;jsonObject&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;JSONObject&lt;/span&gt;.&lt;span&gt;parseObject&lt;/span&gt;(&lt;span&gt;json&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;Set&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;strings&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;jsonKeySet&lt;/span&gt;(&lt;span&gt;&quot;&quot;&lt;/span&gt;, &lt;span&gt;jsonObject&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt; &lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;Set&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;sortSet&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;TreeSet&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Comparator&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;() {&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;compare&lt;/span&gt;(&lt;span&gt;String&lt;/span&gt; &lt;span&gt;o1&lt;/span&gt;, &lt;span&gt;String&lt;/span&gt; &lt;span&gt;o2&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;o1&lt;/span&gt;.&lt;span&gt;compareTo&lt;/span&gt;(&lt;span&gt;o2&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;    }&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;});&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;sortSet&lt;/span&gt;.&lt;span&gt;addAll&lt;/span&gt;(&lt;span&gt;strings&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;String&lt;/span&gt; &lt;span&gt;key&lt;/span&gt; : &lt;span&gt;sortSet&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;    &lt;span&gt;System&lt;/span&gt;.&lt;span&gt;out&lt;/span&gt;.&lt;span&gt;println&lt;/span&gt;(&lt;span&gt;key&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;p cid=&quot;n19&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;剩下的就是利用set很简单的就能获取到差异了。然后配置模板自动回复微信了，然后剩下的就是可以摸鱼了。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n19&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;当然还有一个问题也可以利用该方法进一步完成，获取到JSON键值的差异以后可以反向生成实体对象或者生成字段映射关系，只是这样效率可能有些低，臃肿就是这样产生的。当然为了追求完美可以level并新开一个v，通过level实现新老转换，新v全部统一，外围逐步同步到新v上即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>