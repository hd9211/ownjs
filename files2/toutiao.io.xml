<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>db9786f7e124f4b0fb9feb64534cf4f7</guid>
<title>面试必问的 ThreadLocal 细节，其他文章里写的真的对吗？</title>
<link>https://toutiao.io/k/12dqepa</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;ThreadLocal的作用是什么？使用时有哪些注意事项？为什么ThreadLocalMap中的Entry要使用WeakReference？netty中FastThreadLocal又做了什么优化？答案尽在本文中。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;ThreadLocal介绍&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;用ThreadLocal&lt;/span&gt;&lt;t&gt;&lt;span&gt;修饰的变量，一般我们&lt;/span&gt;称&lt;span&gt;为线程本地变量。&lt;/span&gt;&lt;span&gt;那么一般什么情况下&lt;/span&gt;会&lt;span&gt;使用ThreadLocal呢？&lt;/span&gt;&lt;/t&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;解决线程安全问题。线程安全问题一般是多个线程对共享可变变量变量的修改问题，那么如果线程之间不共享变量，自然就解决了这个问题，通过线程本地变量就可以不共享，每个线程只能获取到自己的线程本地变量，线程间互不打扰。比如&lt;code&gt;java.text.SimpleDateFormat&lt;/code&gt;不是线程安全的，如果多个线程都使用同一个SimpleDateFormat对象进行日期操作，则会出现线程安全问题。一种解决方案就是把SimpleDateFormat对象进行ThreadLocal封装，代码示例如下。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;SimpleDateFormat&amp;gt; simpleDateFormat = ThreadLocal.withInitial(SimpleDateFormat::&lt;span&gt;new&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;say&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    simpleDateFormat.get().format(&lt;span&gt;new&lt;/span&gt; Date());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;同一线程内代码间传递上下文信息 在一些框架中，需要在不同的代码间传递信息，比如分布式追踪(tracing)框架一般都需要在各个开源框架中进行埋点上报，比如上报一个请求处理开始和请求处理结束的埋点，但是如果开始和请求在不同的方法中，该怎么不修改框架方法参数实现埋点串联id的传递呢？通过通过ThreadLocal我们就可以实现id的透传；spring在aop、事务等功能中都使用了ThreadLocal来进行线程内方法间的对象传递 ; 在业务代码中，也经常会用ThreadLocal传递一些公共参数比如请求的用户id，这样可以减少参数的传递。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;&lt;span&gt;ThreadLocal的方法和使用介绍&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;ThreadLocal提供的方法有get(),set(T value), remove()，并且有一个可以override的initialValue()方法。&lt;/p&gt;&lt;section&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法&lt;/th&gt;&lt;th&gt;方法介绍&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;get&lt;/td&gt;&lt;td&gt;获取这个ThreadLocal在当前线程内的值&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;set(T value)&lt;/td&gt;&lt;td&gt;设置这个ThreadLocal在当前线程内的值&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;remove&lt;/td&gt;&lt;td&gt;删除这个ThreadLocal在当前线程内的值&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;initialValue()&lt;/td&gt;&lt;td&gt;如果这个ThreadLocal在当前线程内没有值，会通过initialValue()进行初始化，默认返回null。可以通过匿名内部类或Thread.withInitial(Supplier&amp;lt;? extends S&amp;gt; supplier)实现override initialValue()方法&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p&gt;一般我们定义ThreadLocal变量都定义成static final的变量，然后就可以通过这个ThreadLocal变量进行get set了。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;SimpleDateFormat&amp;gt; simpleDateFormat = ThreadLocal.withInitial(SimpleDateFormat::&lt;span&gt;new&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;say&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    simpleDateFormat.get().format(&lt;span&gt;new&lt;/span&gt; Date());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;ThreadLocal实现&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;了解了ThreadLocal的作用后，我们开始分析一下内部实现。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6752232142857143&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bfAhkMkS9hMY3Oyx53T7SBT1bPD6XNbgPVK4defYY1wKLtnlZdlPGVSia4ugGfBg8HWLWlpALoLHMyXotffED7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;896&quot;/&gt;&lt;/p&gt;&lt;p&gt;首先，每个线程Thread对象内有一个ThreadLocalMap类型的threadLocals字段，里面保存着key为ThreadLocal到value为Object的映射。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Thread&lt;/span&gt;&lt;/span&gt;{ &lt;br/&gt;    &lt;span&gt;/* ThreadLocal values pertaining to this thread. This map is maintained&lt;br/&gt;     * by the ThreadLocal class. */&lt;/span&gt;&lt;br/&gt;    ThreadLocal.ThreadLocalMap threadLocals = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ThreadLocal的get,set,remove方法都是通过操作当前线程内的ThreadLocalMap字段实现的，操作的key为自己(this)&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadLocal&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 每个ThreadLocal的hashCode，用来在ThreadLocalMap中寻找自己的位置。ThreadLocalMap使用的是线性探查的开放寻址法解决hash冲突而不是HashMap中的链表法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; threadLocalHashCode = nextHashCode();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 用来生成分配ThreadLocal的hashCode的AtomicInteger&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; AtomicInteger nextHashCode =&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; AtomicInteger();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// AtomicInteger每次增加的间隔，0x61c88647这个魔数在映射到2的次方的数组中能够保证比较高好的分散性，减少冲突&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// https://stackoverflow.com/questions/38994306/what-is-the-meaning-of-0x61c88647-constant-in-threadlocal-java&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; HASH_INCREMENT = &lt;span&gt;0x61c88647&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 生成hashCode，在ThreadLocal对象构造的时候（构造代码块中）调用&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;nextHashCode&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; nextHashCode.getAndAdd(HASH_INCREMENT);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 覆盖initialValue()可以定制ThreadLocal的默认值&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; T &lt;span&gt;initialValue&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;ThreadLocal&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; T &lt;span&gt;get&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;// 获取当前线程Thread对象&lt;/span&gt;&lt;br/&gt;        Thread t = Thread.currentThread();&lt;br/&gt; &lt;span&gt;// 从Thread对象拿到ThreadLocalMap字段&lt;/span&gt;&lt;br/&gt;        ThreadLocalMap map = getMap(t);&lt;br/&gt; &lt;span&gt;// 如果map不为空，从map中尝试获取当前ThreadLocal对应的value值&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (map != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            ThreadLocalMap.Entry e = map.getEntry(&lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;@SuppressWarnings&lt;/span&gt;(&lt;span&gt;&quot;unchecked&quot;&lt;/span&gt;)&lt;br/&gt;                T result = (T)e.value;&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt; &lt;span&gt;// map为空，或者map中没有找到当前ThreadLocal对应的value的映射，则会进行创建ThreadLocalMap、在map中设置初始默认值&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; setInitialValue();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; T &lt;span&gt;setInitialValue&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        T value = initialValue();&lt;br/&gt;        Thread t = Thread.currentThread();&lt;br/&gt;        ThreadLocalMap map = getMap(t);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (map != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            map.set(&lt;span&gt;this&lt;/span&gt;, value);&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            createMap(t, value);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt; &lt;span&gt;instanceof&lt;/span&gt; TerminatingThreadLocal) {&lt;br/&gt;            TerminatingThreadLocal.register((TerminatingThreadLocal&amp;lt;?&amp;gt;) &lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; value;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;(T value)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;// 获取当前Thread，从中取出ThreadLocalMap&lt;/span&gt;&lt;br/&gt;        Thread t = Thread.currentThread();&lt;br/&gt;        ThreadLocalMap map = getMap(t);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (map != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;     &lt;span&gt;// map不空则调用map的set设置当前ThreadLocal到value的映射&lt;/span&gt;&lt;br/&gt;            map.set(&lt;span&gt;this&lt;/span&gt;, value);&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;     &lt;span&gt;// map为空则创建包含当前ThreadLocal到value映射的map&lt;/span&gt;&lt;br/&gt;     createMap(t, value);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;remove&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;         ThreadLocalMap m = getMap(Thread.currentThread());&lt;br/&gt;         &lt;span&gt;if&lt;/span&gt; (m != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;// 从当前map中删除映射&lt;/span&gt;&lt;br/&gt;             m.remove(&lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;         }&lt;br/&gt;     }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;ThreadLocalMap &lt;span&gt;getMap&lt;/span&gt;&lt;span&gt;(Thread t)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; t.threadLocals;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;createMap&lt;/span&gt;&lt;span&gt;(Thread t, T firstValue)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        t.threadLocals = &lt;span&gt;new&lt;/span&gt; ThreadLocalMap(&lt;span&gt;this&lt;/span&gt;, firstValue);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的ThreadLocal的实现中大部分都是对ThreadLocalMap的操作封装，那么ThreadLocalMap是怎么实现的呢？ThreadLocalMap是ThreadLocal类的静态内部类。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;线性探查法的Map&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;ThreadLocalMap和HashMap有所不同，ThreadLocalMap使用线性探查法而不是拉链法解决hash冲突问题。&lt;/p&gt;&lt;p&gt;线性探查法可以用一个小例子来理解，想象一个停车场的场景，停车场中有一排停车位，停车时，会计算车子的hashCode算出在停车位中的序号，停上去，如果那个车位有车了， 则尝试停到它的下一个车位，如果还有车则继续尝试，到末尾之后从头再来。当取车时，则按照hashCode去找车，找到对应的位置后，要看一下对应的车位上是不是自己的车，如果不是， 尝试找下一个车位，如果找到了自己的车，则说明车存在，如果遇到车位为空，说明车不在。要开走车时，不光是简单开走就可以了，还得把自己车位后面的车重新修改车位，因为那些车可能因为 hash冲突更换了位置，修改车位的范围是当前位置到下一个为空的车位位置。当然还有扩容的情况，后面代码里会具体介绍。&lt;/p&gt;&lt;p&gt;那么为什么使用线性探测法而不是链表法呢？主要是因为数组结构更节省内存空间，并且一般ThreadLocal变量不会很多，通过0x61c88647这个黄金分割的递增hashCode也能比较好的分布在数组上减少冲突。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;使用WeakReference引用ThreadLocal对象&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;Map中的元素用一个Entry类表示，Entry包含了对ThreadLocal的WeakReference，以及对ThreadLocal值的强引用。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// Map中的Entry，也是数组中的元素，会使用WeakReference引用ThreadLocal对象，value的对象是默认的强引用&lt;/span&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Entry&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;WeakReference&lt;/span&gt;&amp;lt;&lt;span&gt;ThreadLocal&lt;/span&gt;&amp;lt;?&amp;gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    Object value;&lt;br/&gt;&lt;br/&gt;    Entry(ThreadLocal&amp;lt;?&amp;gt; k, Object v) {&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(k);&lt;br/&gt;        value = v;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为什么使用WeakReference对象引用呢? 很多文章都提到内存泄漏，但是都没有说明白具体是什么样的内存泄漏，不少文章写道是因为value是强引用，如果线程一直存活会一直让value释放不了，这个其实并不准确，因为如果ThreadLocal字段是static的，这个static变量对象的声明周期和class对象是一致的，而class对象出现卸载的条件非常少，大部分类加载后一直存活，因此即使Entry声明成WeakReference，GC后static的ThreadLocal对象也不会被回收。原因究竟是为什么呢？这个要从要求ThreadLocal变量声明成static final说起。如果不是static final，比如是实例字段，则这个ThreadLocal字段可能会出现非常多个ThreadLocal实例，而不是静态常量一样一个classloader内只有一个。如果有非常多ThreadLocal实例，想想ThreadLocal的实现，是在线程内有一个Map保存ThreadLocal到value的映射。这样即使ThreadLocal实例对象已经不使用了，只要Thread对象存活，被引用的对象就无法释放。这就是使用WeakReference的原因，WeakReference引用不会影响对象被GC。这样gc后会清理掉ThreadLocalMap中已经失效的映射。也就是当我们没有正确使用ThreadLocal时（没有使用static字段），是可能出现内存泄露的，因为ThreadLocalMap中保存了对ThreadLocal的引用，ThreadLocalMap通过WeakReference以及清理机制在一定程度上缓解了这个问题。&lt;/p&gt;&lt;p&gt;下面用一段代码来阐述一下。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt;&lt;span&gt;100&lt;/span&gt;; i++) {&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; People().say();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;People&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; AtomicInteger counter = &lt;span&gt;new&lt;/span&gt; AtomicInteger();&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;String&amp;gt; threadLocal = ThreadLocal.withInitial(() -&amp;gt; &lt;span&gt;&quot;hello&quot;&lt;/span&gt; + counter.getAndIncrement());&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;say&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(threadLocal.get());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们创建了一个People类，并且创建了一个类型为ThreadLocal&lt;string&gt;的实例字段，我们在main方法中连续调用say()方法，会发现打印出来的threadLocal的值是不一样的，虽然我们这些调用都在 同一个线程中，但是因为每次调用的ThreadLocal对象是不同的，也就是ThreadLocalMap的key不相同。如果我们把ThreadLocal字段加上static，就会发现打印出来的都是相同的值了。长时间运行的线程是有可能出现的，比如tomcat的http处理线程，grpc的rpc业务处理线程等都是长时间一直运行的。&lt;/string&gt;&lt;/p&gt;&lt;p&gt;另外因为Entry有对value的强引用，所以在线程业务处理的最后可以主动调用remove方法清理ThreadLocal，加快垃圾对象的回收，可以避免长时间存活而晋升到老年代。例如如果我们在Filter中使用ThreadLocal,一般在处理之前获取设置ThreadLocal，处理完成后，remove()删除ThreadLocal。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;String&amp;gt; userNameThreadLocal = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doFilterInternal&lt;/span&gt;&lt;span&gt;(HttpServletRequest request, HttpServletResponse response,&lt;br/&gt; FilterChain filterChain)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; userNameThreadLocal.set(getName(request));&lt;br/&gt; &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;  filterChain.doFilter(request, response);&lt;br/&gt; } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;  userNameThreadLocal.remove();&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面看一下ThreadLocalMap的实现，也就是线性探测法的具体实现。使用数组存放ThreadLocal到value的映射Entry，也有一个threshold(按照数组长度乘以2/3得到)，元素数量达到threshold时，会触发resize。在ThreadLocalMap中也有清理stale Entry的处理，当ThreadLocal对象没有强引用后，Entry.get()就会返回null，这个Entry就称为stale entry，就可以触发清理工作来回收空间。&lt;/p&gt;&lt;p&gt;ThreadLocalMap中定义了Entry[]数组，可以想象成循环数组，在线性探查中，如果遍历到边界后会从另一头继续遍历。threshold是扩容的阈值，当Map中元素数量达到threshold的时候会进行扩容，threshold通过数组长度乘以2/3得到，2/3就是Map的load factor（也翻译成负载因子）&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadLocalMap&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 初始数组的大小&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; INITIAL_CAPACITY = &lt;span&gt;16&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 存放Entry的数组，和HashMap一样是惰性创建的，并且长度是2的次方，每次扩容乘以2.&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Entry[] table;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 触发resize的阈值，&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; threshold; &lt;span&gt;// Default to 0&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// threshold是数组长度乘以2/3&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setThreshold&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; len)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;     threshold = len * &lt;span&gt;2&lt;/span&gt; / &lt;span&gt;3&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 线性探测法使用的计算后一个数组index的方法，到达数组最后之后会从0开始&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;nextIndex&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt; len)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; ((i + &lt;span&gt;1&lt;/span&gt; &amp;lt; len) ? i + &lt;span&gt;1&lt;/span&gt; : &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 线性探测法使用的计算前一个数组index的方法，到达数组最前面后会总数组的最后开始&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;prevIndex&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt; len)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; ((i - &lt;span&gt;1&lt;/span&gt; &amp;gt;= &lt;span&gt;0&lt;/span&gt;) ? i - &lt;span&gt;1&lt;/span&gt; : len - &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;getEntry方法返回ThreadLocal对应的Entry，通过与操作得到非负数的数组index&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 获取某个ThreadLocal对应的Entry&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; Entry &lt;span&gt;getEntry&lt;/span&gt;&lt;span&gt;(ThreadLocal&amp;lt;?&amp;gt; key)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 通过hashCode和（数组长度-1）做与操作，在数组长度为2的次方时，等价于对数组长度取余并且不会返回负数，因为数组长度-1的高位都是0&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i = key.threadLocalHashCode &amp;amp; (table.length - &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    Entry e = table[i];&lt;br/&gt;    &lt;span&gt;// 数组对应index位置的元素是当前ThreadLocal对象时，直接返回这个Entry&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; e.get() == key)&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; e;&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 其他情况都调用getEntryAfterMiss处理，会到后面的位置继续查找&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; getEntryAfterMiss(key, i, e);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;getEntryAfterMiss方法在ThreadLocal计算的hashCode直接找到的数组中的位置和ThreadLocal不匹配时，继续在后面的Entry查找（直接找到的Entry不为空的情况，为空直接返回null） 如果遇到Entry.get返回null情况，说明这个Entry的ThreadLocal对象没有强引用了，也就是stale entry，会进行清理，也就是调用expungeStaleEntry方法。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; Entry &lt;span&gt;getEntryAfterMiss&lt;/span&gt;&lt;span&gt;(ThreadLocal&amp;lt;?&amp;gt; key, &lt;span&gt;int&lt;/span&gt; i, Entry e)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Entry[] tab = table;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; len = tab.length;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 从i数组位置开始不断遍历，直到数组Entry为null&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;// 调用Entry.get获取ThreadLocal对象&lt;/span&gt;&lt;br/&gt;        ThreadLocal&amp;lt;?&amp;gt; k = e.get();&lt;br/&gt;        &lt;span&gt;// 如果是同一个对象，说明找到了，返回&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (k == key)&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; e;&lt;br/&gt;        &lt;span&gt;// 如果ThreadLocal对象为null，说明被回收了，需要进行清理&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (k == &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;            &lt;span&gt;// expungeStaleEntry方法会负责清理，并且如果后面的元素是因为和当前i所在的ThreadLocal冲突而后移的，则会把后面的元素向左移动归位&lt;/span&gt;&lt;br/&gt;            expungeStaleEntry(i);&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;// 否则，继续遍历下一个元素，到头之后从0重来&lt;/span&gt;&lt;br/&gt;            i = nextIndex(i, len);&lt;br/&gt;        &lt;span&gt;// 获取下一个位置的Entry对象&lt;/span&gt;&lt;br/&gt;        e = tab[i];&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;set方法负责在Map中写入ThreadLocal到value的映射。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;(ThreadLocal&amp;lt;?&amp;gt; key, Object value)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; Entry[] tab = table;&lt;br/&gt; &lt;span&gt;int&lt;/span&gt; len = tab.length;&lt;br/&gt;    &lt;span&gt;// 计算出index&lt;/span&gt;&lt;br/&gt; &lt;span&gt;int&lt;/span&gt; i = key.threadLocalHashCode &amp;amp; (len-&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 从index开始遍历，会不会出现满了没有地方添加的情况呢？是不会的，因为这个方法的最后有判断threshold(load factor 2/3，数组初始大小为16)扩容的逻辑&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; (Entry e = tab[i];&lt;br/&gt;  e != &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;  e = tab[i = nextIndex(i, len)]) {&lt;br/&gt;        ThreadLocal&amp;lt;?&amp;gt; k = e.get();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 找到了相同的ThreadLocal，说明Entry已经存在，进行value覆盖&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (k == key) {&lt;br/&gt;            e.value = value;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 如果ThreadLocal对象是null，调用replaceStaleEntry替换stale entry&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (k == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            replaceStaleEntry(key, value, i);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt; }&lt;br/&gt;    &lt;span&gt;// 说明没有找到ThreadLocal或替换stale entry，则会创建一个新的Entry放在i的位置。&lt;/span&gt;&lt;br/&gt; tab[i] = &lt;span&gt;new&lt;/span&gt; Entry(key, value);&lt;br/&gt;    &lt;span&gt;// 记录元素数量&lt;/span&gt;&lt;br/&gt; &lt;span&gt;int&lt;/span&gt; sz = ++size;&lt;br/&gt;    &lt;span&gt;// 先清理一部分数组中的stale entry，再判断下元素数量是否超过threshold&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (!cleanSomeSlots(i, sz) &amp;amp;&amp;amp; sz &amp;gt;= threshold)&lt;br/&gt;        &lt;span&gt;// 如果元素数量达到了threshold，进行rehash扩容&lt;/span&gt;&lt;br/&gt;     rehash();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;remove方法，会从Map中删除ThreadLocal对象的映射，并且也会触发expungeStaleEntry清理&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;remove&lt;/span&gt;&lt;span&gt;(ThreadLocal&amp;lt;?&amp;gt; key)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Entry[] tab = table;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; len = tab.length;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i = key.threadLocalHashCode &amp;amp; (len-&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (Entry e = tab[i];&lt;br/&gt;        e != &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        e = tab[i = nextIndex(i, len)]) {&lt;br/&gt;        &lt;span&gt;// 找到了TheadLocal对应的Entry后&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (e.get() == key) {&lt;br/&gt;            &lt;span&gt;// 调用clear清理掉队ThreadLocal的引用，clear完之后中调用get就会返回null，相当于是stale entry了&lt;/span&gt;&lt;br/&gt;            e.clear();&lt;br/&gt;            &lt;span&gt;// 触发清理，也会释放对value的引用&lt;/span&gt;&lt;br/&gt;            expungeStaleEntry(i);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;replaceStaleEntry会替换staleSlot上的Entry为ThreadLocal对象到value的映射&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;replaceStaleEntry&lt;/span&gt;&lt;span&gt;(ThreadLocal&amp;lt;?&amp;gt; key, Object value,&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; staleSlot)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Entry[] tab = table;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; len = tab.length;&lt;br/&gt;    Entry e;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 向前找第一个不为null的数组位置，作为这次replace中会清理的起点，避免频繁全量rehash&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; slotToExpunge = staleSlot;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = prevIndex(staleSlot, len);&lt;br/&gt;        (e = tab[i]) != &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        i = prevIndex(i, len)) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (e.get() == &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;            slotToExpunge = i;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = nextIndex(staleSlot, len);&lt;br/&gt;        (e = tab[i]) != &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        i = nextIndex(i, len)) {&lt;br/&gt;        ThreadLocal&amp;lt;?&amp;gt; k = e.get();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 找到了元素，进行替换&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (k == key) {&lt;br/&gt;            e.value = value;&lt;br/&gt;&lt;br/&gt;            tab[i] = tab[staleSlot];&lt;br/&gt;            tab[staleSlot] = e;&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (slotToExpunge == staleSlot)&lt;br/&gt;                slotToExpunge = i;&lt;br/&gt;            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 在上面for循环中没有找到stale entry的情况下，如果这个for循环中找到了，替换slotToExpunge&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (k == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; slotToExpunge == staleSlot)&lt;br/&gt;            slotToExpunge = i;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 如果没有找到原有的key，则直接替换staleSlot&lt;/span&gt;&lt;br/&gt;    tab[staleSlot].value = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    tab[staleSlot] = &lt;span&gt;new&lt;/span&gt; Entry(key, value);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 清理&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (slotToExpunge != staleSlot)&lt;br/&gt;        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;expungeStaleEntry方法从staleSlot开始清理stale entry，直到遇到一个null的entry&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;expungeStaleEntry&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; staleSlot)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Entry[] tab = table;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; len = tab.length;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 先清理staleSlot位置的Entry的引用&lt;/span&gt;&lt;br/&gt;    tab[staleSlot].value = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    tab[staleSlot] = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    size--;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 从staleSlot后面开始重新计算Entry位置，直到遇到null数组元素&lt;/span&gt;&lt;br/&gt;    Entry e;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (i = nextIndex(staleSlot, len);&lt;br/&gt;        (e = tab[i]) != &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        i = nextIndex(i, len)) {&lt;br/&gt;        ThreadLocal&amp;lt;?&amp;gt; k = e.get();&lt;br/&gt;        &lt;span&gt;// k == null说明是stale entry，清理&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (k == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            e.value = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;            tab[i] = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;            size--;&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;// 否则重新计算存放entry位置&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; h = k.threadLocalHashCode &amp;amp; (len - &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (h != i) {&lt;br/&gt;                tab[i] = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;// Unlike Knuth 6.4 Algorithm R, we must scan until&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// null because multiple entries could have been stale.&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;while&lt;/span&gt; (tab[h] != &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;                    h = nextIndex(h, len);&lt;br/&gt;                tab[h] = e;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; i;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;rehash方法会先完整清理一遍，然后再check下size，如果刚才的清理后size还是大于3/4 threshold，也就是大约1/2 数组长度，则发起resize扩容&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;rehash&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    expungeStaleEntries();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Use lower threshold for doubling to avoid hysteresis&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (size &amp;gt;= threshold - threshold / &lt;span&gt;4&lt;/span&gt;)&lt;br/&gt;        resize();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;resize扩容，会把数组长度扩大一倍，并且对Entry元素重新计算存放位置&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;resize&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Entry[] oldTab = table;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; oldLen = oldTab.length;&lt;br/&gt;    &lt;span&gt;// 计算新数组长度为老数组的两倍&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; newLen = oldLen * &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;// 创建新数组&lt;/span&gt;&lt;br/&gt;    Entry[] newTab = &lt;span&gt;new&lt;/span&gt; Entry[newLen];&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 循环遍历老数组的元素，依次放到新数组中，相当于依次调用set方法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (Entry e : oldTab) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            ThreadLocal&amp;lt;?&amp;gt; k = e.get();&lt;br/&gt;            &lt;span&gt;// 如果resize的时候发现stale entry，把value设置成null释放对应的引用&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (k == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                e.value = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;// Help the GC&lt;/span&gt;&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;// 否则在新数组中寻找可以存放的位置，先计算hash index&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;int&lt;/span&gt; h = k.threadLocalHashCode &amp;amp; (newLen - &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;// 如果数组中对应位置有元素，则一直向后遍历&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;while&lt;/span&gt; (newTab[h] != &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;                    h = nextIndex(h, newLen);&lt;br/&gt;                &lt;span&gt;// 直到一个新位置可以存放&lt;/span&gt;&lt;br/&gt;                newTab[h] = e;&lt;br/&gt;                &lt;span&gt;// 计数加一&lt;/span&gt;&lt;br/&gt;                count++;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 数组元素转移完成，修改threshold&lt;/span&gt;&lt;br/&gt;    setThreshold(newLen);&lt;br/&gt;    &lt;span&gt;// 修改size&lt;/span&gt;&lt;br/&gt;    size = count;&lt;br/&gt;    &lt;span&gt;// 替换table数组&lt;/span&gt;&lt;br/&gt;    table = newTab;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;expungeStaleEntries方法清理数组中所有的staleEntry&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;expungeStaleEntries&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Entry[] tab = table;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; len = tab.length;&lt;br/&gt;    &lt;span&gt;// 遍历所有的数组元素&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; len; j++) {&lt;br/&gt;        Entry e = tab[j];&lt;br/&gt;        &lt;span&gt;// 如果entry不为空但是get出来的ThreadLocal为空&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; e.get() == &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;            &lt;span&gt;// 从j位置开始清理&lt;/span&gt;&lt;br/&gt;            expungeStaleEntry(j);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;ThreadLocal的使用注意事项&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ThreadLocal字段应该声明成static final&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ThreadLocal在线程处理完成后建议主动remove&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;注意跨线程使用ThreadLocal的问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ThreadLocal通过避免线程间共享数据，可以解决一些线程安全问题，并且可以跨代码区域传递参数，但是也带来了一些隐式约定，要避免滥用作参数隐式传递&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;&lt;span&gt;延伸: netty中FastThreadLocal的优化&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;jdk中ThreadLocal的实现就是最好的吗？并不见得，高性能的io框架netty中就对ThreadLocal进行了优化，提供了FastThreadLocal。那么FastThreadLocal究竟Fast快在哪里呢？&lt;/p&gt;&lt;p&gt;在上面ThreadLocal的实现分析中我们可以看到ThreadLocal中是有可能出现hash冲突而进行线性探测的问题的，而FastThreadLocal通过简单的方法巧妙的解决了这个问题。&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;FastThreadLocal类中保存了一个数组中的index，这样get操作就变成了先直接拿到index再从数组中按照index读取，而不会像ThreadLoacl还可能需要向后遍历。index是通过0开始递增分配的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;FastTheadLocal中增加了UNSET和initialValue的null做区分，避免ThreadLocal在get遇到initialValue()返回null时每次get()总会调用setInitialValue的问题&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;FastThreadLocal要搭配FastThreadLocalThread使用, FastThreadLocalThread继承Thread并定义了一个InternalThreadLocalMap对象，和ThreadLocalMap类似，InternalThreadLocalMap也是存放当前线程的FastThreadLocal到value的映射。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FastThreadLocalThread&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Thread&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; InternalThreadLocalMap threadLocalMap;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;get方法实现是获取当前线程FastThreadLocalThread的InternalThreadLocalMap，然后从FastThreadLocal拿到index调用indexedVariable获取value。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FastThreadLocal&lt;/span&gt;&amp;lt;&lt;span&gt;V&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 每个FastThreadLocal对象有自己的index，对应数组中的位置&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; index;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;FastThreadLocal&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        index = InternalThreadLocalMap.nextVariableIndex();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; V &lt;span&gt;get&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        InternalThreadLocalMap threadLocalMap = InternalThreadLocalMap.get();&lt;br/&gt;        Object v = threadLocalMap.indexedVariable(index);&lt;br/&gt;        &lt;span&gt;// 如果initialValue返回了null，则不会多次执行initialize方法&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (v != InternalThreadLocalMap.UNSET) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; (V) v;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; initialize(threadLocalMap);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; V &lt;span&gt;initialize&lt;/span&gt;&lt;span&gt;(InternalThreadLocalMap threadLocalMap)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        V v = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            v = initialValue();&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;            PlatformDependent.throwException(e);&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        threadLocalMap.setIndexedVariable(index, v);&lt;br/&gt;        addToVariablesToRemove(threadLocalMap, &lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; v;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;InternalThreadLocalMap的indexedVariable方法直接按照index获取数组元素&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;InternalThreadLocalMap&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; AtomicInteger nextIndex = &lt;span&gt;new&lt;/span&gt; AtomicInteger();&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Object UNSET = &lt;span&gt;new&lt;/span&gt; Object();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; InternalThreadLocalMap &lt;span&gt;get&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Thread thread = Thread.currentThread();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; thread &lt;span&gt;instanceof&lt;/span&gt; FastThreadLocalThread ? fastGet((FastThreadLocalThread)thread) : slowGet();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; InternalThreadLocalMap &lt;span&gt;fastGet&lt;/span&gt;&lt;span&gt;(FastThreadLocalThread thread)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        InternalThreadLocalMap threadLocalMap = thread.threadLocalMap();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (threadLocalMap == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            thread.setThreadLocalMap(threadLocalMap = &lt;span&gt;new&lt;/span&gt; InternalThreadLocalMap());&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; threadLocalMap;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    Object[] indexedVariables;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;indexedVariable&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; index)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Object[] lookup = indexedVariables;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; index &amp;lt; lookup.length? lookup[index] : UNSET;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UnpaddedInternalThreadLocalMap&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不过FastThreadLocal没有做内存泄漏保护，如果我们使用不正确，比如创建了大量ThreadLocal对象，则可能会出现数组内存不断增长，这就需要我们在使用时注意ThreadLocal声明成static，并且尽量在线程处理完成后主动remove&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4e88217d38c736e30050982fd3a26657</guid>
<title>[译] 图解 Go 微服务熔断器</title>
<link>https://toutiao.io/k/ewzp9hr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;原文中 &lt;code&gt;Circuit Breakers&lt;/code&gt; 这里翻译为了熔断器，大家也可以理解叫为断路器&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;fallback&lt;/code&gt;本文翻译为兜底，大家也可以理解为容错补救。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;本文翻译自https://ioshellboy.medium.com/circuit-breakers-in-golang-1779da9b001，由于本人翻译水平有限，翻译不当之处烦请指出。希望大家看了这篇文章能有所帮助。感谢捧场。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;什么是熔断器&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当你看到 “熔断器” 这个术语时，你会想到什么呢?&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4915254237288136&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkYNiaZsfpqa5dSIH3gibmwLbeqnaibsPgBzicBRv73lFAxic69Chc2eIlTgm4KVr7A46tkSjOCzYich396LjVW0P4mA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;944&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图片字面意思理解是使用一个锤子破坏了一个电路。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们一般都会在自己家里安装熔断器，以阻止异常的电流从电网流向家里。在开始“微服务的熔断器”之前，让我们先看看它是如何工作的。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.494140625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkYNiaZsfpqa5dSIH3gibmwLbeqnaibsPgBGXhZWJfTqCzciaicicwO6icQRpBqGhc3NUZ4Eouo0tV1oIQzeXro0veyFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图所示，一个典型的熔断器装置有 2 个主要部件:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;用火线紧紧包裹的软铁芯&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;触体。只要接触点能够形成一个连接点，电流就会从外部电源流向我们的房子。相反，如果连接断开，电流就停止流动。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当电流通过缠绕在软铁芯周围的导线时，软铁芯就像一块电磁铁，当流过它的电流高于预期的安培时，电磁铁就会变得强大到足以吸引邻近的触点，从而导致短路。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你一定在想，这与微服务架构有什么关系呢？在我看来，这是高度相关的，正如我们下面将要看到的！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;微服务架构中的级联故障&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;微服务架构已经很好地取代了单体架构，但是为了使我们的系统具有高度的弹性，我们还需要解决一些关键问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;微服务的一个问题是级联故障。举一个例子来更好地理解它。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5707142857142857&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkYNiaZsfpqa5dSIH3gibmwLbeqnaibsPgB57LL42icEKQqiby96uB4ZKBuEPyvjbyCYeXbLibWbyssAlneookK7ahGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上图中，参与者调用我们的主服务，它依赖于上游服务——A，B，C。现在假定，服务 A 是一个读取量较大的系统，它依赖于数据库。这个数据库有其自身的局限性，并且在过载时，可能导致连接重置。这个问题不仅会影响服务 A 的性能，还会影响主服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是人们所说的“一块臭肉坏了整锅汤”，喝过这锅汤的人肯定会有同感。下面让我们用一个例子来验证这一点。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.29428571428571426&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkYNiaZsfpqa5dSIH3gibmwLbeqnaibsPgBSy2CNq0qAkyuZHibt3d6cCaaNeiamySLR1nahS3zPn5KMia5zN8JibskEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让我们构建一个 Netflixisc 应用程序。其中一个微服务负责提供feed页面的&lt;strong&gt;电影服务&lt;/strong&gt;。此服务还依赖于&lt;strong&gt;推荐服务&lt;/strong&gt;为用户提供适当的推荐。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// Recommendation Service&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt; logGoroutines()&lt;br/&gt; http.HandleFunc(&lt;span&gt;&quot;/recommendations&quot;&lt;/span&gt;, recoHandler)&lt;br/&gt; log.Fatal(http.ListenAndServe(&lt;span&gt;&quot;:9090&quot;&lt;/span&gt;, nil))&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;logGoroutines&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt; ticker := time.NewTicker(500 * time.Millisecond)&lt;br/&gt; &lt;span&gt;done&lt;/span&gt; := make(chan bool)&lt;br/&gt; go &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;   select {&lt;br/&gt;   &lt;span&gt;case&lt;/span&gt; &amp;lt;-&lt;span&gt;done&lt;/span&gt;:&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;case&lt;/span&gt; t := &amp;lt;-ticker.C:&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;\n%v - %v&quot;&lt;/span&gt;, t, runtime.NumGoroutine())&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt; }()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func recoHandler(w http.ResponseWriter, r *http.Request) {&lt;br/&gt; a := `{&lt;span&gt;&quot;movies&quot;&lt;/span&gt;: [&lt;span&gt;&quot;Few Angry Men&quot;&lt;/span&gt;, &lt;span&gt;&quot;Pride &amp;amp; Prejudice&quot;&lt;/span&gt;]}`&lt;br/&gt; w.Write([]byte(a))&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;推荐服务&lt;/strong&gt;暴露一个路由接口 &lt;code&gt;/recommendations&lt;/code&gt;，它返回一个推荐电影列表，同时每 500 毫秒打印一次 goroutine 的数量。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// Movies App&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; MovieResponse struct {&lt;br/&gt; Feed           []string&lt;br/&gt; Recommendation []string&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt; http.HandleFunc(&lt;span&gt;&quot;/movies&quot;&lt;/span&gt;, fetchMoviesFeedHandler)&lt;br/&gt; log.Fatal(http.ListenAndServe(&lt;span&gt;&quot;:8080&quot;&lt;/span&gt;, nil))&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func fetchMoviesFeedHandler(w http.ResponseWriter, r *http.Request) {&lt;br/&gt; mr := MovieResponse{&lt;br/&gt;  Feed: []string{&lt;span&gt;&quot;Transformers&quot;&lt;/span&gt;, &lt;span&gt;&quot;Fault in our stars&quot;&lt;/span&gt;, &lt;span&gt;&quot;The Old Boy&quot;&lt;/span&gt;},&lt;br/&gt; }&lt;br/&gt; rms, err := fetchRecommendations()&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;  w.WriteHeader(500)&lt;br/&gt; }&lt;br/&gt; mr.Recommendation = rms&lt;br/&gt; bytes, err := json.Marshal(mr)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;  w.WriteHeader(500)&lt;br/&gt; }&lt;br/&gt; w.Write(bytes)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func fetchRecommendations() ([]string, error) {&lt;br/&gt; resp, err := http.Get(&lt;span&gt;&quot;http://localhost:9090/recommendations&quot;&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; []string{}, err&lt;br/&gt; }&lt;br/&gt; defer resp.Body.Close()&lt;br/&gt; body, err := ioutil.ReadAll(resp.Body)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; []string{}, err&lt;br/&gt; }&lt;br/&gt; var mvsr map[string]interface{}&lt;br/&gt; err = json.Unmarshal(body, &amp;amp;mvsr)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; []string{}, err&lt;br/&gt; }&lt;br/&gt; mvsb, err := json.Marshal(mvsr[&lt;span&gt;&quot;movies&quot;&lt;/span&gt;])&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; []string{}, err&lt;br/&gt; }&lt;br/&gt; var mvs []string&lt;br/&gt; err = json.Unmarshal(mvsb, &amp;amp;mvs)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; []string{}, err&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; mvs, nil&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;电影服务&lt;/strong&gt;暴露一个路由 &lt;code&gt;/movies&lt;/code&gt;，它返回电影列表和推荐列表。为了获取推荐，它反过来调用上游的&lt;strong&gt;推荐服务&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过此设置，让我们以每秒 100 个请求的速率访问电影服务，持续 3 秒钟。在 99% 的毫秒范围内，我们可以获得 100% 的成功。这是预期的，因为只提供静态数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在，假设推荐服务的响应时间过长，并在 &lt;code&gt;recoHandler&lt;/code&gt; 添加20秒的等待时间，然后重新进行测试。成功率会下降，而响应时间也会开始受到影响。此外，在测试期间阻塞在推荐服务上的&lt;code&gt;goroutine&lt;/code&gt;数量将急剧增加。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推荐服务的停工时间影响了终端用户，因为本来可以提供给他的电影feed列表都没有提供。这正是级联故障对我们的系统造成的影响。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;熔断器救援&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;熔断器是一个非常简单但相当重要的概念，因为它可以让我们保持服务的高可用性。熔断器有三种状态:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关闭状态是指数据通过的时候连接处关闭的状态。这是我们的理想状态，其中上游服务正如预期的那样工作。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7614035087719299&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkYNiaZsfpqa5dSIH3gibmwLbeqnaibsPgB0BhqXxRjFp07HS5dIRhJpvz5Ub8NJIayEicgmvD0XKvWaFkXCDne3FA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1140&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;打开状态指的是由于上游服务未按预期响应而导致电路短路的状态。这种短路可以避免上游服务在已经挣扎的情况下不堪重负。此外，下游服务的业务逻辑可以更快地获得上游可用性状态的反馈，而无需等待上游的响应。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9162303664921466&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkYNiaZsfpqa5dSIH3gibmwLbeqnaibsPgBoicHzjLC5WEBJfKKglhjvFsNmY8DrDMwia8Y5TF9RfPGeGbQ0E65JIiag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;764&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Half Open State&lt;/strong&gt; 半开状态&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9294117647058824&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkYNiaZsfpqa5dSIH3gibmwLbeqnaibsPgBUGNym8GFg8kkhms5CRdOFpxhia49hbaSxeFA4rojfQxib87NjKh4EseQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1190&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果熔断器是打开状态，我们希望它在上游服务再次可用时立即关闭它。虽然你可以通过手动干预来实现，但首选的方法应该是在电路最后一次打开，让一些请求延迟之后通过电路，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果这些请求请求上游服务成功，我们就可以安全地接通整个链路。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9275123558484349&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkYNiaZsfpqa5dSIH3gibmwLbeqnaibsPgB51zWicyecmQDdstqiccUKC1icuqaBMqgegOfAqNgBu3bOE2xkEVbdh5uw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1214&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一方面，如果这些请求失败，熔断器仍然处于打开状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;熔断器的状态图如下:&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9530916844349681&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkYNiaZsfpqa5dSIH3gibmwLbeqnaibsPgB4c5JJ7pJUha3sz398gSQKQfRGfy0c2xiaNYJyGfeNiaNWK7kKSpRETkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;938&quot;/&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;初始状态下熔断器是关闭的，当故障超过配置的阈值，则会打开&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;熔断器是打开状态，在经过一段熔断时间后，部分会打开&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果熔断器是半开的，它可以&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;再次打开，如果允许通过的请求也失败了&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;关闭，如果允许通过的请求成功响应&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;熔断器在 Golang 的应用&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然有多个库可供选择，但最常用的是 &lt;span&gt;hystrix&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;。正如文档建议的那样，hystrix 是 Netflix 设计的一个延迟和容错库，用于隔离远程系统、服务和第三方库的访问，阻止级联故障，并在不可避免的故障发生的复杂分布式系统中实现恢复能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Hystrix 熔断器的实现取决于以下配置:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;超时 ー 上游服务响应的等待时间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最大并发请求 ー 上游服务允许调用的最大并发&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;请求容量阈值 ー 在熔断之前的请求数，断路器在需要更改状态时无法评估的请求数量&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;睡眠窗口 ー 开放状态与半开放状态之间的延迟时间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;误差百分比阈值ー熔断器短路时的误差百分比阈值&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来让我们在电影和推荐示例中使用它，并在获取推荐时实现熔断器模式。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;var downstreamErrCount int&lt;br/&gt;var circuitOpenErrCount int&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt; downstreamErrCount = 0&lt;br/&gt; circuitOpenErrCount = 0&lt;br/&gt; hystrix.ConfigureCommand(&lt;span&gt;&quot;recommendation&quot;&lt;/span&gt;, hystrix.CommandConfig{&lt;br/&gt;  Timeout: 100,&lt;br/&gt;  RequestVolumeThreshold: 25,&lt;br/&gt;  ErrorPercentThreshold:  5,&lt;br/&gt;  SleepWindow:            1000,&lt;br/&gt; })&lt;br/&gt; http.HandleFunc(&lt;span&gt;&quot;/movies&quot;&lt;/span&gt;, fetchMoviesFeedHandlerWithCircuitBreaker)&lt;br/&gt; log.Fatal(http.ListenAndServe(&lt;span&gt;&quot;:8080&quot;&lt;/span&gt;, nil))&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func fetchMoviesFeedHandlerWithCircuitBreaker(w http.ResponseWriter, r *http.Request) {&lt;br/&gt; mr := MovieResponse{&lt;br/&gt;  Feed: []string{&lt;span&gt;&quot;Transformers&quot;&lt;/span&gt;, &lt;span&gt;&quot;Fault in our stars&quot;&lt;/span&gt;, &lt;span&gt;&quot;The Old Boy&quot;&lt;/span&gt;},&lt;br/&gt; }&lt;br/&gt; &lt;br/&gt; output := make(chan bool, 1)&lt;br/&gt; errors := hystrix.Go(&lt;span&gt;&quot;recommendation&quot;&lt;/span&gt;, func() error {&lt;br/&gt;  // talk to other services&lt;br/&gt;  rms, err := fetchRecommendations()&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt;  }&lt;br/&gt;  mr.Recommendation = rms&lt;br/&gt;  output &amp;lt;- &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; nil&lt;br/&gt; }, func(err error) error {&lt;br/&gt;     // 写你的fallback(兜底)逻辑&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; nil&lt;br/&gt; })&lt;br/&gt;&lt;br/&gt; select {&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; err := &amp;lt;-errors:&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err == hystrix.ErrCircuitOpen {&lt;br/&gt;   circuitOpenErrCount = circuitOpenErrCount + 1&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;   downstreamErrCount = downstreamErrCount + 1&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; _ = &amp;lt;-output:&lt;br/&gt;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; bytes, err := json.Marshal(mr)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;  w.WriteHeader(500)&lt;br/&gt; }&lt;br/&gt; fmt.Printf(&lt;span&gt;&quot;\ndownstreamErrCount=%d, circuitOpenErrCount=%d&quot;&lt;/span&gt;, downstreamErrCount, circuitOpenErrCount)&lt;br/&gt; w.Write(bytes)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 Hystrix，您还可以在熔断器打开时实现兜底逻辑。这种逻辑可能因情况而异。如果熔断器打开，则从缓存中获取。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用这个更新的逻辑，让我们尝试以每秒100个请求的速率重新攻击 3 秒钟。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哇! ！100% 的成功率，在打开的情况下，我们只提供 Feed 和返回 0个推荐。此外，由于每当熔断器熔断，我们不再调用上游服务，因此推荐服务不会不堪重负，阻塞的 goroutine 数量不会像以前那么多。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;扩展阅读&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我的建议:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;关于 Netflix Hystrix&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Hystrix 是怎样工作的？&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Hystrix bucketing&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.81328125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkYNiaZsfpqa5dSIH3gibmwLbeqnaibsPgBgxQ2I3OXoIPx2umXAPzBHwRXaic01CaPRDr0vFaqy6Dib9DYXVKs24Iw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;sup/&gt;&lt;br/&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1] &lt;/span&gt;&lt;p&gt;hystrix: &lt;span&gt;https://github.com/afex/hystrix-go/hystrix&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2] &lt;/span&gt;&lt;p&gt;关于 Netflix Hystrix: &lt;span&gt;https://github.com/Netflix/Hystrix/wiki&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3] &lt;/span&gt;&lt;p&gt;Hystrix 是怎样工作的？: &lt;span&gt;https://github.com/Netflix/Hystrix/wiki/How-it-Works&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4] &lt;/span&gt;&lt;p&gt;Hystrix bucketing: &lt;span&gt;https://raw.githubusercontent.com/wiki/Netflix/Hystrix/images/circuit-breaker-1280.png&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0d9c5704047e5b6e071f41017eccd7d1</guid>
<title>Python 打包 exe 之 pyinstaller 用法</title>
<link>https://toutiao.io/k/x82rc4p</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;container app-preview post-body&quot;&gt;
  &lt;div class=&quot;preview&quot;&gt;&lt;p&gt;pyinstaller可以将python写好的脚本打包成exe文件，方便windows用户在没有python环境下运行。这个程序完全跨平台，包括Windows、Linux、Mac OS X等多个操作系统下运行。因为我用的是win7，以下直接使用windows打包讲解，不同平台上使用 PyInstaller方法是一样的，它们支持的选项也是一样的。&lt;/p&gt;

&lt;h2&gt;安装Pyinstaller&lt;/h2&gt;

&lt;p&gt;Python默认不包含Pyinstaller模块，因此需要自行安装&lt;/p&gt;

&lt;p&gt;与安装其它Python模块一样，使用pip命令安装即可，一条搞定：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;pip install pyinstaller&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/bd29e490842b481c12b6321cb08996ea.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;运行上面命令，可以看到如下输出结果，表示成功：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Successfully installed altgraph-0.17 pefile-2021.5.24 pyinstaller-4.5.1 pyinstaller....&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;使用Pyinstaller&lt;/h2&gt;

&lt;p&gt;Pyinstaller 工具使用的命令语法如下：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;pyinstaller 选项 python源文件&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;实际工作中常用的命令也就几条：&lt;/p&gt;

&lt;pre lang=&quot;shell&quot;&gt;&lt;code&gt;## -D(默认选项)，生成build、dist目录，该选项生成一个目录(包含多个文件)来作为程序
pyinstall -D app.py

## 使用-F选项，在dist目录下生成单独的EXE文件(在Mac生成的文件没有exe后缀)
pyinstaller -F app.py

## -w不显示GUI窗口，-i指定图标
pyinstaller -F -w -i app.ico app.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想给软件添加自己喜欢的图标，这里推荐以下方式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;https://www.iconfont.cn/                ####免费的在线icon图标网站
http://www.favicon-icon-generator.com/  ###免费在线生成1
http://www.ico51.cn/                    ####免费在线生成2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;常用参数说明&lt;/h3&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;-h，--help&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;查看该模块的帮助信息&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-F，-onefile&lt;/td&gt;
&lt;td&gt;产生单个的可执行文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-D，--onedir&lt;/td&gt;
&lt;td&gt;产生一个目录（包含多个文件）作为可执行程序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-a，--ascii&lt;/td&gt;
&lt;td&gt;不包含 Unicode 字符集支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-d，--debug&lt;/td&gt;
&lt;td&gt;产生 debug 版本的可执行文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-w，--windowed，--noconsolc&lt;/td&gt;
&lt;td&gt;指定程序运行时不显示命令行窗口（仅对 Windows 有效）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-c，--nowindowed，--console&lt;/td&gt;
&lt;td&gt;指定使用命令行窗口运行程序（仅对 Windows 有效）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-o DIR，--out=DIR&lt;/td&gt;
&lt;td&gt;指定 spec 文件的生成目录。如果没有指定，则默认使用当前目录来生成 spec 文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-p DIR，--path=DIR&lt;/td&gt;
&lt;td&gt;设置 Python 导入模块的路径（和设置 PYTHONPATH 环境变量的作用相似）。也可使用路径分隔符（Windows 使用分号，Linux 使用冒号）来分隔多个路径&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-n NAME，--name=NAME&lt;/td&gt;
&lt;td&gt;指定项目（产生的 spec）名字。如果省略该选项，那么第一个脚本的主文件名将作为 spec 的名字&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;blockquote&gt;
&lt;p&gt;以上只是Pyinstaller模块所支持的常用选项，如需了解更多可通过&lt;code&gt;pyinstaller -h&lt;/code&gt;来查看。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;实践一下&lt;/h3&gt;

&lt;p&gt;这里简单写一个demo，我们来进行打包测试&lt;/p&gt;

&lt;p&gt;为了不让界面执行完立即退出，使用input()让界面暂时停留&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;print(&quot;钢铁侠的知识库&quot;)
input()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用命令进行打包：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;pyinstaller -F test.py&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/9abae3ef21d9cc02624e7f2adb0e86cc.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;打包成功后会在dist下找到test.exe文件，执行即可看到&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/2b764dc175ce09d4f6bba9fd0f856684.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;以上即表示打包成功。&lt;/p&gt;

&lt;p&gt;---- 钢铁 &lt;a href=&quot;mailto:648403020@qq.com&quot;&gt;648403020@qq.com&lt;/a&gt; 2021.08.07&lt;/p&gt;

&lt;h2&gt;参考鸣谢&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://c.biancheng.net/view/2690.html&quot;&gt;http://c.biancheng.net/view/2690.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/xiaomu_347/article/details/108761161&quot;&gt;https://blog.csdn.net/xiaomu_347/article/details/108761161&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://medium.com/pyladies-taiwan/python-%E5%B0%87python%E6%89%93%E5%8C%85%E6%88%90exe%E6%AA%94-32a4bacbe351&quot;&gt;https://medium.com/pyladies-taiwan/python-%E5%B0%87python%E6%89%93%E5%8C%85%E6%88%90exe%E6%AA%94-32a4bacbe351&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f97a2c83c0ff4a2ac1ec6a55bab2f4e0</guid>
<title>从命令行追踪新冠肺炎全球疫情数据</title>
<link>https://toutiao.io/k/etanllv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post&quot;&gt;
&lt;h1 class=&quot;title&quot;&gt;从命令行追踪新冠肺炎全球疫情数据&lt;/h1&gt;
&lt;p&gt;
今天发现一个好牛逼的网站，可以让我们通过命令行查看新冠肺炎全球疫情数据
&lt;/p&gt;

&lt;ol class=&quot;org-ol&quot;&gt;
&lt;li&gt;查看指定国家的今日疫情数据&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
通过访问 `&lt;a href=&quot;https://corona-stats.online/%E5%9B%BD%E5%AE%B6%E5%90%8D%E7%A7%B0&quot;&gt;https://corona-stats.online/国家名称&lt;/a&gt;` 可以获得指定国家的今日疫情数据，例如下面命令查看中国的当前疫情数据：
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;
&lt;pre class=&quot;src src-shell&quot;&gt;curl https://corona-stats.online/china
&lt;/pre&gt;
&lt;/div&gt;




&lt;ol class=&quot;org-ol&quot;&gt;
&lt;li&gt;获取新冠肺炎全球TOP排行榜数据&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
通过访问 `&lt;a href=&quot;https://corona-stats.online?top=N&quot;&gt;https://corona-stats.online?top=N&lt;/a&gt;` 可以获得感染人数前N的国家今日疫情数据，例如下面命令查看感染人数前5的国家及其疫情数据：
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;
&lt;pre class=&quot;src src-shell&quot;&gt;curl https://corona-stats.online?&lt;span class=&quot;org-variable-name&quot;&gt;top&lt;/span&gt;=5
&lt;/pre&gt;
&lt;/div&gt;




&lt;ol class=&quot;org-ol&quot;&gt;
&lt;li&gt;指定返回 JSON 格式的数据&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
通过在访问URL后加上 &lt;code&gt;?format=json&lt;/code&gt; 可以获取 JSON 格式的数据，例如下面命令获取中国今日新冠感染人数的JSON数据集:
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;
&lt;pre class=&quot;src src-shell&quot;&gt;curl &lt;span class=&quot;org-string&quot;&gt;&quot;https://corona-stats.online/china?format=json&quot;&lt;/span&gt; |jq
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
输出结果为
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;
&lt;pre class=&quot;src src-json&quot;&gt;{
  &quot;data&quot;: [
    {
      &quot;updated&quot;: 1628329931927,
      &quot;country&quot;: &quot;China&quot;,
      &quot;countryInfo&quot;: {
        &quot;_id&quot;: 156,
        &quot;iso2&quot;: &quot;CN&quot;,
        &quot;iso3&quot;: &quot;CHN&quot;,
        &quot;lat&quot;: 35,
        &quot;long&quot;: 105,
        &quot;flag&quot;: &quot;https://disease.sh/assets/img/flags/cn.png&quot;
      },
      &quot;cases&quot;: 93605,
      &quot;todayCases&quot;: 107,
      &quot;deaths&quot;: 4636,
      &quot;todayDeaths&quot;: 0,
      &quot;recovered&quot;: 87525,
      &quot;todayRecovered&quot;: 33,
      &quot;active&quot;: 1444,
      &quot;critical&quot;: 39,
      &quot;casesPerOneMillion&quot;: 65,
      &quot;deathsPerOneMillion&quot;: 3,
      &quot;tests&quot;: 160000000,
      &quot;testsPerOneMillion&quot;: 111163,
      &quot;population&quot;: 1439323776,
      &quot;continent&quot;: &quot;Asia&quot;,
      &quot;oneCasePerPeople&quot;: 15377,
      &quot;oneDeathPerPeople&quot;: 310467,
      &quot;oneTestPerPeople&quot;: 9,
      &quot;activePerOneMillion&quot;: 1,
      &quot;recoveredPerOneMillion&quot;: 60.81,
      &quot;criticalPerOneMillion&quot;: 0.03,
      &quot;confirmed&quot;: 93605,
      &quot;countryCode&quot;: &quot;CN&quot;
    }
  ],
  &quot;worldStats&quot;: {
    &quot;country&quot;: &quot;World&quot;,
    &quot;countryCode&quot;: &quot;World&quot;,
    &quot;cases&quot;: 202490517,
    &quot;todayCases&quot;: 130727,
    &quot;deaths&quot;: 4292020,
    &quot;todayDeaths&quot;: 2305,
    &quot;recovered&quot;: 180258478,
    &quot;active&quot;: 17940019,
    &quot;critical&quot;: 95654,
    &quot;casesPerOneMillion&quot;: &quot;25980.31&quot;,
    &quot;confirmed&quot;: 202490517
  }
}
&lt;/pre&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>505a5a454dac486faa00381db716e023</guid>
<title>@Autowired 的这些骚操作，你都知道吗？</title>
<link>https://toutiao.io/k/vfzkbo6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;hi，大家好，我是苏三，又跟大家见面了。&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近review别人代码的时候，看到了一些&lt;code&gt;@Autowired&lt;/code&gt;不一样的用法，觉得有些意思，特定花时间研究了一下，收获了不少东西，现在分享给大家。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也许&lt;code&gt;@Autowired&lt;/code&gt;比你想象中更强大。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.577490774907749&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEbl9QOtuOuiauNH0OEJre3F4vd8UI5cdRH7MGsUyCe7uQp8jy49fOmdpj0zkTiaxNt1KJox9WI600A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1084&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. @Autowired的默认装配&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道在spring中@Autowired注解，是用来自动装配对象的。通常，我们在项目中是这样用的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; com.sue.cache.service;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.springframework.stereotype.Service;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService1&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; com.sue.cache.service;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.springframework.stereotype.Service;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService2&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TestService1 testService1;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，这样是能够装配成功的，因为默认情况下spring是按照类型装配的，也就是我们所说的&lt;code&gt;byType&lt;/code&gt;方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，@Autowired注解的&lt;code&gt;required&lt;/code&gt;参数默认是true，表示开启自动装配，有些时候我们不想使用自动装配功能，可以将该参数设置成false。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 相同类型的对象不只一个时&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面&lt;code&gt;byType&lt;/code&gt;方式主要针对相同类型的对象只有一个的情况，此时对象类型是唯一的，可以找到正确的对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果相同类型的对象不只一个时，会发生什么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在项目的test目录下，建了一个同名的类TestService1：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; com.sue.cache.service.test;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.springframework.stereotype.Service;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService1&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重新启动项目时：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Caused by: org.springframework.context.annotation.ConflictingBeanDefinitionException: Annotation-specified bean name &lt;span&gt;&#x27;testService1&#x27;&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; bean &lt;span&gt;&lt;span&gt;class&lt;/span&gt; [&lt;span&gt;com&lt;/span&gt;.&lt;span&gt;sue&lt;/span&gt;.&lt;span&gt;cache&lt;/span&gt;.&lt;span&gt;service&lt;/span&gt;.&lt;span&gt;test&lt;/span&gt;.&lt;span&gt;TestService1&lt;/span&gt;] &lt;span&gt;conflicts&lt;/span&gt; &lt;span&gt;with&lt;/span&gt; &lt;span&gt;existing&lt;/span&gt;, &lt;span&gt;non&lt;/span&gt;-&lt;span&gt;compatible&lt;/span&gt; &lt;span&gt;bean&lt;/span&gt; &lt;span&gt;definition&lt;/span&gt; &lt;span&gt;of&lt;/span&gt; &lt;span&gt;same&lt;/span&gt; &lt;span&gt;name&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; [&lt;span&gt;com&lt;/span&gt;.&lt;span&gt;sue&lt;/span&gt;.&lt;span&gt;cache&lt;/span&gt;.&lt;span&gt;service&lt;/span&gt;.&lt;span&gt;TestService1&lt;/span&gt;]&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结果报错了，报类类名称有冲突，直接导致项目启动不来。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意，这种情况不是相同类型的对象在Autowired时有两个导致的，非常容易产生混淆。这种情况是因为spring的@Service方法不允许出现相同的类名，因为spring会将类名的第一个字母转换成小写，作为bean的名称，比如：testService1，而默认情况下bean名称必须是唯一的。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面看看如何产生两个相同的类型bean：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService1&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService2&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TestService1 testService1;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestConfig&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;(&lt;span&gt;&quot;test1&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; TestService1 &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; TestService1();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;(&lt;span&gt;&quot;test2&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; TestService1 &lt;span&gt;test2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; TestService1();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在TestConfig类中手动创建TestService1实例，并且去掉TestService1类上原有的@Service注解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重新启动项目：&lt;img data-ratio=&quot;0.17408906882591094&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEbl9QOtuOuiauNH0OEJre3FLMqTqYBSWZOcibUuGwZBFqV22FluMF93s3WRycvztyDetrae16Xn80A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1482&quot;/&gt;果然报错了，提示testService1是单例的，却找到两个对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实还有一个情况会产生两个相同的类型bean：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;IUser&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;say&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;User1&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IUser&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;say&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;User2&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IUser&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;say&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; IUser user;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目重新启动时：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.07684824902723736&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEbl9QOtuOuiauNH0OEJre3FallJOACicOQYTC8stx1eaFicTYKJK7xH7qricp6D0tSsmk6fkl3ica5cQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2056&quot;/&gt;报错了，提示跟上面一样，testService1是单例的，却找到两个对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二种情况在实际的项目中出现得更多一些，后面的例子，我们主要针对第二种情况。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. @Qualifier和@Primary&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然在spring中，按照Autowired默认的装配方式：byType，是无法解决上面的问题的，这时可以改用按名称装配：byName。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只需在代码上加上&lt;code&gt;@Qualifier&lt;/code&gt;注解即可：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Qualifier&lt;/span&gt;(&lt;span&gt;&quot;user1&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; IUser user;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只需这样调整之后，项目就能正常启动了。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Qualifier意思是合格者，一般跟Autowired配合使用，需要指定一个bean的名称，通过bean名称就能找到需要装配的bean。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了上面的&lt;code&gt;@Qualifier&lt;/code&gt;注解之外，还能使用&lt;code&gt;@Primary&lt;/code&gt;注解解决上面的问题。在User1上面加上@Primary注解：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Primary&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;User1&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IUser&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;say&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;去掉UserService上的@Qualifier注解：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; IUser user;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重新启动项目，一样能正常运行。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;当我们使用自动配置的方式装配Bean时，如果这个Bean有多个候选者，假如其中一个候选者具有@Primary注解修饰，该候选者会被选中，作为自动配置的值。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. @Autowired的使用范围&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的实例中@Autowired注解，都是使用在成员变量上，但@Autowired的强大之处，远非如此。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先看看@Autowired注解的定义：&lt;img data-ratio=&quot;0.26450892857142855&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEbl9QOtuOuiauNH0OEJre3FE6WjwdiaSrRibb3qVnxSsvxibdP6RQQoBW7mgw9RKe2ic9N3k8yfXnuYicg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1792&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图中可以看出该注解能够使用在5种目标类型上，下面用一张图总结一下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.577490774907749&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEbl9QOtuOuiauNH0OEJre3F4vd8UI5cdRH7MGsUyCe7uQp8jy49fOmdpj0zkTiaxNt1KJox9WI600A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1084&quot;/&gt;该注解我们平常使用最多的地方可能是在成员变量上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，我们重点看看在其他地方该怎么用？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;4.1 成员变量&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在成员变量上使用Autowired注解：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; IUser user;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式可能是平时用得最多的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;4.2 构造器&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在构造器上使用Autowired注解：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; IUser user;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt;&lt;span&gt;(IUser user)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.user = user;&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;user:&quot;&lt;/span&gt; + user);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意，在构造器上加Autowired注解，实际上还是使用了Autowired装配方式，并非构造器装配。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;4.3 方法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在普通方法上加Autowired注解：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;span&gt;(IUser user)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;       user.say();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;spring会在项目启动的过程中，自动调用一次加了@Autowired注解的方法，我们可以在该方法做一些初始化的工作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也可以在setter方法上Autowired注解：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; IUser user;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setUser&lt;/span&gt;&lt;span&gt;(IUser user)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.user = user;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;4.4 参数&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以在构造器的入参上加Autowired注解：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; IUser user;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt;&lt;span&gt;(@Autowired IUser user)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.user = user;&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;user:&quot;&lt;/span&gt; + user);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也可以在非静态方法的入参上加Autowired注解：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;span&gt;(@Autowired IUser user)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;       user.say();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;4.5 注解&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式其实用得不多，我就不过多介绍了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. @Autowired的高端玩法&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实上面举的例子都是通过@Autowired自动装配单个实例，但这里我会告诉你，它也能自动装配多个实例，怎么回事呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将UserService方法调整一下，用一个List集合接收IUser类型的参数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; List&amp;lt;IUser&amp;gt; userList;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Set&amp;lt;IUser&amp;gt; userSet;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, IUser&amp;gt; userMap;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;userList:&quot;&lt;/span&gt; + userList);&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;userSet:&quot;&lt;/span&gt; + userSet);&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;userMap:&quot;&lt;/span&gt; + userMap);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;增加一个controller：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@RequestMapping&lt;/span&gt;(&lt;span&gt;&quot;/u&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@RestController&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UController&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; UserService userService;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@RequestMapping&lt;/span&gt;(&lt;span&gt;&quot;/test&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;test&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        userService.test();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;success&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用该接口后：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.0810126582278481&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEbl9QOtuOuiauNH0OEJre3FerS8YnIsYQTbEL3KrVXX3yIvS4chxAiabVy9ZUXwXrAJiakLvGBqYoibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1580&quot;/&gt;从上图中看出：userList、userSet和userMap都打印出了两个元素，说明@Autowired会自动把相同类型的IUser对象收集到集合中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;意不意外，惊不惊喜？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. @Autowired一定能装配成功？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面介绍了@Autowired注解这么多牛逼之处，其实有些情况下，即使使用了@Autowired装配的对象还是null，到底是什么原因呢？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;6.1 没有加@Service注解&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在类上面忘了加@Controller、@Service、@Component、@Repository等注解，spring就无法完成自动装配的功能，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; IUser user;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        user.say();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种情况应该是最常见的错误了，不会因为你长得帅，就不会犯这种低级的错误。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;6.2 注入Filter或Listener&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;web应用启动的顺序是：&lt;code&gt;listener&lt;/code&gt;-&amp;gt;&lt;code&gt;filter&lt;/code&gt;-&amp;gt;&lt;code&gt;servlet&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.4131736526946108&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEbl9QOtuOuiauNH0OEJre3FyecpM3sKZ95GgSNBMuDD5weiasDxMp7paNFDtFKDUORQbu9Fiaa9KvFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;334&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来看看这个案例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserFilter&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Filter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; IUser user;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;(FilterConfig filterConfig)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; ServletException &lt;/span&gt;{&lt;br/&gt;        user.say();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doFilter&lt;/span&gt;&lt;span&gt;(ServletRequest request, ServletResponse response, FilterChain chain)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException, ServletException &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;destroy&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FilterConfig&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; FilterRegistrationBean &lt;span&gt;filterRegistrationBean&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        FilterRegistrationBean bean = &lt;span&gt;new&lt;/span&gt; FilterRegistrationBean();&lt;br/&gt;        bean.setFilter(&lt;span&gt;new&lt;/span&gt; UserFilter());&lt;br/&gt;        bean.addUrlPatterns(&lt;span&gt;&quot;/*&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; bean;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序启动会报错：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2995169082125604&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEbl9QOtuOuiauNH0OEJre3FgO2me6nwVS7qkLsTxlhg9SpR7mXpQwEPbkicfkwia1cBYW7j8qrwIHjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1656&quot;/&gt;tomcat无法正常启动。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;什么原因呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;众所周知，springmvc的启动是在DisptachServlet里面做的，而它是在listener和filter之后执行。如果我们想在listener和filter里面@Autowired某个bean，肯定是不行的，因为filter初始化的时候，此时bean还没有初始化，无法自动装配。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果工作当中真的需要这样做，我们该如何解决这个问题呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserFilter&lt;/span&gt;  &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Filter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; IUser user;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;(FilterConfig filterConfig)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; ServletException &lt;/span&gt;{&lt;br/&gt;        ApplicationContext applicationContext = WebApplicationContextUtils.getWebApplicationContext(filterConfig.getServletContext());&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.user = ((IUser)(applicationContext.getBean(&lt;span&gt;&quot;user1&quot;&lt;/span&gt;)));&lt;br/&gt;        user.say();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doFilter&lt;/span&gt;&lt;span&gt;(ServletRequest request, ServletResponse response, FilterChain chain)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException, ServletException &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;destroy&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是使用WebApplicationContextUtils.getWebApplicationContext获取当前的ApplicationContext，再通过它获取到bean实例。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;6.3 注解未被@ComponentScan扫描&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常情况下，@Controller、@Service、@Component、@Repository、@Configuration等注解，是需要通过@ComponentScan注解扫描，收集元数据的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，如果没有加@ComponentScan注解，或者@ComponentScan注解扫描的路径不对，或者路径范围太小，会导致有些注解无法收集，到后面无法使用@Autowired完成自动装配的功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有个好消息是，在springboot项目中，如果使用了&lt;code&gt;@SpringBootApplication&lt;/code&gt;注解，它里面内置了@ComponentScan注解的功能。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;6.4 循环依赖问题&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果A依赖于B，B依赖于C，C又依赖于A，这样就形成了一个死循环。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7452830188679245&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEbl9QOtuOuiauNH0OEJre3F3Pn1gia1axuA2htamntaSlb7UPTgZyMeIZgTP1unTiaehXOquFnQ5FVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;636&quot;/&gt;spring的bean默认是单例的，如果单例bean使用@Autowired自动装配，大多数情况，能解决循环依赖问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是如果bean是多例的，会出现循环依赖问题，导致bean自动装配不了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有有些情况下，如果创建了代理对象，即使bean是单例的，依然会出现循环依赖问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你对循环依赖问题比较感兴趣，也可以看一下我的另一篇专题《》，里面介绍的非常详细。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7. @Autowired和@Resouce的区别&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;@Autowired功能虽说非常强大，但是也有些不足之处。比如：比如它跟spring强耦合了，如果换成了JFinal等其他框架，功能就会失效。而@Resource是JSR-250提供的，它是Java标准，绝大部分框架都支持。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，有些场景使用@Autowired无法满足的要求，改成@Resource却能解决问题。接下来，我们重点看看@Autowired和@Resource的区别。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;@Autowired默认按byType自动装配，而@Resource默认byName自动装配。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@Autowired只包含一个参数：required，表示是否开启自动准入，默认是true。而@Resource包含七个参数，其中最重要的两个参数是：name 和 type。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@Autowired如果要使用byName，需要使用@Qualifier一起配合。而@Resource如果指定了name，则用byName自动装配，如果指定了type，则用byType自动装配。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@Autowired能够用在：构造器、方法、参数、成员变量和注解上，而@Resource能用在：类、成员变量和方法上。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@Autowired是spring定义的注解，而@Resource是JSR-250定义的注解。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，它们的装配顺序不同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;@Autowired的装配顺序如下：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.777059773828756&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEbl9QOtuOuiauNH0OEJre3FLheGfbQcE2ibyBrve31BibbsqS6trxZW5gh8KaU4wpnlKgdibND6MIqKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1238&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;@Resource的装配顺序如下：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果同时指定了name和type：&lt;img data-ratio=&quot;0.8&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEbl9QOtuOuiauNH0OEJre3FgSomjYicbevYNrd1RTpPHX3BkYH888sTKHSjlBUsPv3fGQWkibYOlfww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;760&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果指定了name：&lt;img data-ratio=&quot;0.939873417721519&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEbl9QOtuOuiauNH0OEJre3FhEV71B6Neiab480Sic9H0RDHsmHxyAjDASnYJblggcibyic0icsAVtB9aZg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;632&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果指定了type：&lt;img data-ratio=&quot;0.8559322033898306&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEbl9QOtuOuiauNH0OEJre3FRb7RJE5mHjvpajgGvyPAlYohyA98MWwah1rHEcW6cuKcFKibCbmW2Cw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;708&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果既没有指定name，也没有指定type：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0344827586206897&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEbl9QOtuOuiauNH0OEJre3FXHwenxGvDLNK9vnYEsAXX2k3K6WZiaBvAXspnUImQ0QeWSDfxtNShqQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;696&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;后记&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我原本打算接下来写@Autowired原理分析和源码解读的，但是由于篇幅太长了，不适合放在一起，后面打算开个专题。如果有兴趣的朋友，可以持续关注我后续的文章，相信你读完必定会有些收获。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最后说一句(求关注，别白嫖我)&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果这篇文章对您有所帮助，或者有所启发的话，帮忙关注一下，您的支持是我坚持写作最大的动力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加群交流，可以添加下面微信，群里有很多技术大牛喔。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0048309178743962&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDE9vvfu1eb0KdQmjCiceE3xr7JF0cvK0z4UwCNyKO4UsMg5Urfro5qzoU2NWfgthCjwENmLxK6Nxyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;414&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;求一键三连：点赞、转发、在看。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>