<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f24db38f0123670608e70ccdb7ca9786</guid>
<title>IntelliJ 超级实用的 8 个插件</title>
<link>https://toutiao.io/k/vx0h11u</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6664285714285715&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl90Sbe6BYgU4nS8iaicCOtp1SYPTuNydaTNgW9LUzBTf4ZcVo5qSia79JRMKeSUb8bSjiakiboNwkciaYHhw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. IDE Features Trainer&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是 IntelliJ 官方推出的一个插件，可以帮助我们快速学习 IntelliJ 的功能特性，更好的使用它。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5034802784222738&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl90Sbe6BYgU4nS8iaicCOtp1SYopup81Kz2J9ZEcynExzCrldlgZR39sR74mKoxocxPQcm1qmLaEbP0g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1293&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. Codota&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Codota 是一款非常智能的代码提示插件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Codota 扫描了 GitHub 中数百万的代码仓库，分析并学习这些源码，由此可以为我们提供非常优秀的代码建议。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.615&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl90Sbe6BYgU4nS8iaicCOtp1SYTd0emZiaRL1XthkD5y8icc5V4CAZ5cickvK1AyklNwAMUMLbGdmBjqBsg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3082706766917293&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl90Sbe6BYgU4nS8iaicCOtp1SYfxteeNAJ616XlR2JXM5d0wBJOoibqo2MGXZKDaUAelBUOvUeBmbp6KQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1330&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. Comments Highlighter&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个插件可以为注释上色，让我们的注释不再那么沉闷。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尤其是我们想在注释中给出非常重要的信息时，这个插件就更有用了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.3722627737226278&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl90Sbe6BYgU4nS8iaicCOtp1SYX9hXKqlpmXUBoJIgQXQhfxO7tn0ne22DymhaWJTaXNOw33B24M7xpw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;411&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. Return Highlighter&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个插件会在返回语句那行进行标记，这在我们阅读外部源码时比较有用。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.24049429657794677&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl90Sbe6BYgU4nS8iaicCOtp1SYL9WmSJyicJqcRlDGSYNRrt2iaFlT8UrDWXvOIkbnicvxsY2gW9TfP4new/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1052&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5. Key Promoter X&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每次你点击 IntelliJ 的按钮时，这个插件就会弹出快捷键的提示，可以帮助我们更快的掌握快捷键。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5161290322580645&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl90Sbe6BYgU4nS8iaicCOtp1SYEiaCwpkCM4FIKRibvicsx8IKeekCGMqAf67h9BLk5s9iccgOCYR36iapOnA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1364&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6. Atom Material Icons&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个插件没有什么特殊的功能，但丰富了 IntelliJ 图标。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;2.446327683615819&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl90Sbe6BYgU4nS8iaicCOtp1SYLdgxy4rL3qibtPE4BddCOcNtFRyibAHsoiaRcy8vXSHsaUgGtJliayxRmw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;354&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7. Code With Me&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也是 IntelliJ 的官方插件，允许他人操作自己的项目，适用于协同工作场景。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/wv3K6j4ibl90Sbe6BYgU4nS8iaicCOtp1SY03UjQpbflIjZ2dItctS7TcbOxaRqeKeXu9GldVSIp0nDSLnzkTnGIA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8. Yet Another Emoji Support&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个插件可以直接在编辑器中写表情符号，例如在写 README、提交信息或者注释的时候非常实用。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6414285714285715&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl90Sbe6BYgU4nS8iaicCOtp1SYldfdBFWnXCktq4X8WAWs4pLicnvyc2EAhuSN26efYvA0D0Xrv0GL45g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5781990521327014&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/wv3K6j4ibl90Sbe6BYgU4nS8iaicCOtp1SYlmLH7kWrucqdyHycYFodtmVR0Zk1T8H16herQWnx6dYUSl5vYTYh0Q/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;422&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考资料&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://medium.com/better-programming/the-top-12-intellij-plugins-for-2021-55b1815e0eb&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>892baf71bda31f71ef64824af29a0c55</guid>
<title>工具 | 腾讯开源的分布式高性能 KV 存储数据库</title>
<link>https://toutiao.io/k/diu62t3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                              &lt;strong class=&quot;profile_nickname&quot;&gt;开发者头条&lt;/strong&gt;
                              &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;kaifazhetoutiao&lt;/span&gt;
                              &lt;/p&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;程序员分享平台 | 官方应用下载地址：http://toutiao.io/download&lt;/span&gt;
                              &lt;/p&gt;
                              
                          &lt;/div&gt;
                          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5a1f5506976c0014cf726dbd193b337a</guid>
<title>携程 Redis 治理演进之路（二）</title>
<link>https://toutiao.io/k/zzmvet2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>aae62e3e7f4364554da3021dd4dcdc47</guid>
<title>Class.forName 造成的线程阻塞</title>
<link>https://toutiao.io/k/q7ikhfm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;今天在查看服务器时，发现机器上稳定的会有 3 ~ 4 个线程处于阻塞状态，感觉应该是有问题的，仔细排查了一下，最终发现和 Class.forName 有关。&lt;/p&gt;&lt;h2&gt;现象&lt;/h2&gt;&lt;p&gt;某一天突然收到了公司的系统提醒，说是我们的服务中，长时间都有好几个处于&lt;code&gt;BLOCKED&lt;/code&gt;状态的线程。&lt;/p&gt;&lt;p&gt;因为我们的访问量还是不小的，因此写了一段代码模拟了一下，大致类似于：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import java.beans.BeanInfo;&lt;br/&gt;import java.beans.Introspector;&lt;br/&gt;import java.util.concurrent.CountDownLatch;&lt;br/&gt;import java.util.concurrent.LinkedBlockingQueue;&lt;br/&gt;import java.util.concurrent.ThreadFactory;&lt;br/&gt;import java.util.concurrent.ThreadPoolExecutor;&lt;br/&gt;import java.util.concurrent.TimeUnit;&lt;br/&gt;import java.util.concurrent.atomic.AtomicInteger;&lt;br/&gt;&lt;br/&gt;public class Test {&lt;br/&gt;&lt;br/&gt;  public static void main(String[] args) throws InterruptedException {&lt;br/&gt;    ThreadPoolExecutor executor = new ThreadPoolExecutor(10, 10, 0, TimeUnit.SECONDS,&lt;br/&gt;        new LinkedBlockingQueue&amp;lt;&amp;gt;(), new ThreadFactory() {&lt;br/&gt;      private final AtomicInteger count = new AtomicInteger(0);&lt;br/&gt;&lt;br/&gt;      @Override&lt;br/&gt;      public Thread newThread(Runnable r) {&lt;br/&gt;        return new Thread(r, &quot;testThread-&quot; + count.incrementAndGet());&lt;br/&gt;      }&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;    int totalCount = 1000;&lt;br/&gt;    CountDownLatch latch = new CountDownLatch(totalCount);&lt;br/&gt;    for (int i = 0; i &amp;lt; totalCount; i++) {&lt;br/&gt;      int current = i;&lt;br/&gt;      executor.execute(() -&amp;gt; {&lt;br/&gt;        try {&lt;br/&gt;          for (int j = 0; j &amp;lt; totalCount; j++) {&lt;br/&gt;            BeanInfo destBean = Introspector.getBeanInfo(Test.class, java.lang.Object.class);&lt;br/&gt;          }&lt;br/&gt;        } catch (Exception e) {&lt;br/&gt;          System.out.println(current + &quot;\tfail&quot;);&lt;br/&gt;        } finally {&lt;br/&gt;          latch.countDown();&lt;br/&gt;        }&lt;br/&gt;      });&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    latch.await();&lt;br/&gt;    System.out.println(&quot;finish&quot;);&lt;br/&gt;    executor.shutdown();&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  private String name;&lt;br/&gt;&lt;br/&gt;  private Integer age;&lt;br/&gt;&lt;br/&gt;  public String getName() {&lt;br/&gt;    return name;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  public void setName(String name) {&lt;br/&gt;    this.name = name;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  public Integer getAge() {&lt;br/&gt;    return age;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  public void setAge(Integer age) {&lt;br/&gt;    this.age = age;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当时登上了服务器，首先查询出我们的 java 进程号：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;ps -ef | grep java&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;假设结果是&lt;code&gt;26385&lt;/code&gt;，这时再借助&lt;code&gt;jstack&lt;/code&gt;命令打印出各个线程的状态：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;jstack 26385 &amp;gt; 26385.txt&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后分析了&lt;code&gt;26385.txt&lt;/code&gt;，发现了原因：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&quot;testThread-7&quot; #14 prio=5 os_prio=0 tid=0x00007f72a810e800 nid=0x6706 waiting for monitor entry [0x00007f729837c000]&lt;br/&gt;   java.lang.Thread.State: BLOCKED (on object monitor)&lt;br/&gt;    at java.lang.ClassLoader.loadClass(ClassLoader.java:404)&lt;br/&gt;    - waiting to lock &amp;lt;0x00000000f7c773b8&amp;gt; (a java.lang.Object)&lt;br/&gt;    at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:349)&lt;br/&gt;    at java.lang.ClassLoader.loadClass(ClassLoader.java:357)&lt;br/&gt;    at java.lang.Class.forName0(Native Method)&lt;br/&gt;    at java.lang.Class.forName(Class.java:348)&lt;br/&gt;    at com.sun.beans.finder.ClassFinder.findClass(ClassFinder.java:103)&lt;br/&gt;    at java.beans.Introspector.findCustomizerClass(Introspector.java:1301)&lt;br/&gt;    at java.beans.Introspector.getTargetBeanDescriptor(Introspector.java:1295)&lt;br/&gt;    at java.beans.Introspector.getBeanInfo(Introspector.java:425)&lt;br/&gt;    at java.beans.Introspector.getBeanInfo(Introspector.java:262)&lt;br/&gt;    at java.beans.Introspector.getBeanInfo(Introspector.java:224)&lt;br/&gt;    at Test.lambda$main$0(Test.java:35)&lt;br/&gt;    at Test$$Lambda$1/303563356.run(Unknown Source)&lt;br/&gt;    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)&lt;br/&gt;    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)&lt;br/&gt;    at java.lang.Thread.run(Thread.java:748)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面很清晰地显示了，我们写的&lt;code&gt;Introspector.getBeanInfo&lt;/code&gt;代码，最终会调用&lt;code&gt;Class&lt;/code&gt;类中的&lt;code&gt;forName0&lt;/code&gt;方法：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;    /** Called after security check for system loader access checks have been made. */&lt;br/&gt;    private static native Class&amp;lt;?&amp;gt; forName0(String name, boolean initialize,&lt;br/&gt;                                            ClassLoader loader,&lt;br/&gt;                                            Class&amp;lt;?&amp;gt; caller)&lt;br/&gt;        throws ClassNotFoundException;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从上面的&lt;code&gt;stack&lt;/code&gt;中分析可以得知，这个方法内部应该是有锁的，因此会阻塞其他线程。&lt;/p&gt;&lt;h2&gt;解决方法&lt;/h2&gt;&lt;p&gt;既然它是有锁的，为了不让它在运行时每次都执行，最简单的方法就是在初始化时，就将需要处理的类全部处理好，这样在应用运行期间，完全不会再去反射。&lt;/p&gt;&lt;h2&gt;源码&lt;/h2&gt;&lt;p&gt;有些人可能会好奇，&lt;code&gt;forName0&lt;/code&gt;中究竟是如何使用到了锁，这里就把源码展示给大家。&lt;/p&gt;&lt;p&gt;下文的调用链路是：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;forName0 -&amp;gt; JVM_FindClassFromCaller -&amp;gt; find_class_from_class_loader -&amp;gt; resolve_or_fail -&amp;gt; resolve_or_null -&amp;gt; resolve_instance_class_or_null -&amp;gt; load_instance_class&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;forName0&lt;/code&gt;源码实现位于&lt;code&gt;src/java.base/share/native/libjava/Class.c&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 动态装载类型入口&lt;br/&gt;JNIEXPORT jclass JNICALL&lt;br/&gt;Java_java_lang_Class_forName0(JNIEnv *env, jclass this, jstring classname,&lt;br/&gt;                              jboolean initialize, jobject loader, jclass caller)&lt;br/&gt;{&lt;br/&gt;    char *clname;&lt;br/&gt;    jclass cls = 0;&lt;br/&gt;    char buf[128];&lt;br/&gt;    jsize len;&lt;br/&gt;    jsize unicode_len;&lt;br/&gt;&lt;br/&gt;    if (classname == NULL) {&lt;br/&gt;        JNU_ThrowNullPointerException(env, 0);&lt;br/&gt;        return 0;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    // 把类全限定名里的&#x27;.&#x27;翻译成&#x27;/&#x27;&lt;br/&gt;    if (VerifyFixClassname(clname) == JNI_TRUE) {&lt;br/&gt;        /* slashes present in clname, use name b4 translation for exception */&lt;br/&gt;        (*env)-&amp;gt;GetStringUTFRegion(env, classname, 0, unicode_len, clname);&lt;br/&gt;        JNU_ThrowClassNotFoundException(env, clname);&lt;br/&gt;        goto done;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    // 验证类全限定名名合法性（是否以&#x27;/&#x27;分隔）&lt;br/&gt;    if (!VerifyClassname(clname, JNI_TRUE)) {  /* expects slashed name */&lt;br/&gt;        JNU_ThrowClassNotFoundException(env, clname);&lt;br/&gt;        goto done;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    // 从指定的加载器查找该类&lt;br/&gt;    cls = JVM_FindClassFromCaller(env, clname, initialize, loader, caller);&lt;br/&gt;&lt;br/&gt; done:&lt;br/&gt;    if (clname != buf) {&lt;br/&gt;        free(clname);&lt;br/&gt;    }&lt;br/&gt;    return cls;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;FindClassFromCaller&lt;/code&gt;位于&lt;code&gt;src/hotspot/share/prims/jvm.cpp&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 从指定的加载器查找该类&lt;br/&gt;// Find a class with this name in this loader, using the caller&#x27;s protection domain.&lt;br/&gt;JVM_ENTRY(jclass, JVM_FindClassFromCaller(JNIEnv* env, const char* name,&lt;br/&gt;                                          jboolean init, jobject loader,&lt;br/&gt;                                          jclass caller))&lt;br/&gt;&lt;br/&gt;  // 把当前类加入符号表（一个哈希表实现）&lt;br/&gt;  TempNewSymbol h_name = SymbolTable::new_symbol(name, CHECK_NULL);&lt;br/&gt;&lt;br/&gt;  // 获取加载器和调用类&lt;br/&gt;  oop loader_oop = JNIHandles::resolve(loader);&lt;br/&gt;  oop from_class = JNIHandles::resolve(caller);&lt;br/&gt;  oop protection_domain = NULL;&lt;br/&gt;&lt;br/&gt;  if (from_class != NULL &amp;amp;&amp;amp; loader_oop != NULL) {&lt;br/&gt;    protection_domain = java_lang_Class::as_Klass(from_class)-&amp;gt;protection_domain();&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  // 查找该类&lt;br/&gt;  jclass result = find_class_from_class_loader(env, h_name, init, h_loader,&lt;br/&gt;                                               h_prot, false, THREAD);&lt;br/&gt;&lt;br/&gt;  // 返回结果&lt;br/&gt;  return result;&lt;br/&gt;JVM_END&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;find_class_from_class_loader&lt;/code&gt;位于&lt;code&gt;/src/hotspot/share/prims/jvm.cpp&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// Shared JNI/JVM entry points //////////////////////////////////////////////////////////////&lt;br/&gt;// 从指定的classloader中查找类&lt;br/&gt;jclass find_class_from_class_loader(JNIEnv* env, Symbol* name, jboolean init,&lt;br/&gt;                                    Handle loader, Handle protection_domain,&lt;br/&gt;                                    jboolean throwError, TRAPS) {&lt;br/&gt;&lt;br/&gt;  //==========================================&lt;br/&gt;  //&lt;br/&gt;  // 根据指定的类名和加载器返回一个Klass对象，必要情况下需要加载该类。&lt;br/&gt;  // 如果未找到该类则抛出NoClassDefFoundError或ClassNotFoundException&lt;br/&gt;  //&lt;br/&gt;  //=========================================&lt;br/&gt;  Klass* klass = SystemDictionary::resolve_or_fail(name, loader, protection_domain, throwError != 0, CHECK_NULL);&lt;br/&gt;&lt;br/&gt;  // Check if we should initialize the class&lt;br/&gt;  if (init &amp;amp;&amp;amp; klass-&amp;gt;is_instance_klass()) {&lt;br/&gt;    klass-&amp;gt;initialize(CHECK_NULL);&lt;br/&gt;  }&lt;br/&gt;  return (jclass) JNIHandles::make_local(env, klass-&amp;gt;java_mirror());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;resolve_or_fail&lt;/code&gt;位于&lt;code&gt;src/hotspot/share/classfile/systemDictionary.cpp&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// Forwards to resolve_or_null&lt;br/&gt;&lt;br/&gt;Klass* SystemDictionary::resolve_or_fail(Symbol* class_name, Handle class_loader, Handle protection_domain, bool throw_error, TRAPS) {&lt;br/&gt;  Klass* klass = resolve_or_null(class_name, class_loader, protection_domain, THREAD);&lt;br/&gt;  if (HAS_PENDING_EXCEPTION || klass == NULL) {&lt;br/&gt;    // can return a null klass&lt;br/&gt;    klass = handle_resolution_exception(class_name, throw_error, klass, THREAD);&lt;br/&gt;  }&lt;br/&gt;  return klass;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;resolve_or_null&lt;/code&gt;也位于&lt;code&gt;src/hotspot/share/classfile/systemDictionary.cpp&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// Forwards to resolve_instance_class_or_null&lt;br/&gt;&lt;br/&gt;Klass* SystemDictionary::resolve_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS) {&lt;br/&gt;&lt;br/&gt;  if (FieldType::is_array(class_name)) {&lt;br/&gt;    return resolve_array_class_or_null(class_name, class_loader, protection_domain, THREAD);&lt;br/&gt;  } else if (FieldType::is_obj(class_name)) {&lt;br/&gt;    ResourceMark rm(THREAD);&lt;br/&gt;    // Ignore wrapping L and ;.&lt;br/&gt;    TempNewSymbol name = SymbolTable::new_symbol(class_name-&amp;gt;as_C_string() + 1,&lt;br/&gt;                                   class_name-&amp;gt;utf8_length() - 2, CHECK_NULL);&lt;br/&gt;    return resolve_instance_class_or_null(name, class_loader, protection_domain, THREAD);&lt;br/&gt;  } else {&lt;br/&gt;    // 解析实例类&lt;br/&gt;    return resolve_instance_class_or_null(class_name, class_loader, protection_domain, THREAD);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;resolve_instance_class_or_null&lt;/code&gt;也位于&lt;code&gt;src/hotspot/share/classfile/systemDictionary.cpp&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Klass* SystemDictionary::resolve_instance_class_or_null(Symbol* name,&lt;br/&gt;                                                        Handle class_loader,&lt;br/&gt;                                                        Handle protection_domain,&lt;br/&gt;                                                        TRAPS) {&lt;br/&gt;  Handle lockObject = compute_loader_lock_object(class_loader, THREAD);&lt;br/&gt;  check_loader_lock_contention(lockObject, THREAD);&lt;br/&gt;  // 获取对象锁&lt;br/&gt;  ObjectLocker ol(lockObject, THREAD, DoObjectLock);&lt;br/&gt;&lt;br/&gt;  {&lt;br/&gt;    MutexLocker mu(SystemDictionary_lock, THREAD);&lt;br/&gt;    // 查找类&lt;br/&gt;    InstanceKlass* check = find_class(d_index, d_hash, name, dictionary);&lt;br/&gt;    if (check != NULL) {&lt;br/&gt;      // Klass is already loaded, so just return it&lt;br/&gt;      class_has_been_loaded = true;&lt;br/&gt;      k = check;&lt;br/&gt;    } else {&lt;br/&gt;      // 查找该类是否在placeholder table中&lt;br/&gt;      placeholder = placeholders()-&amp;gt;get_entry(p_index, p_hash, name, loader_data);&lt;br/&gt;      if (placeholder &amp;amp;&amp;amp; placeholder-&amp;gt;super_load_in_progress()) {&lt;br/&gt;         super_load_in_progress = true;&lt;br/&gt;         if (placeholder-&amp;gt;havesupername() == true) {&lt;br/&gt;           superclassname = placeholder-&amp;gt;supername();&lt;br/&gt;           havesupername = true;&lt;br/&gt;         }&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  // 如果该类在placeholder table中，则说明类加载进行中&lt;br/&gt;  if (super_load_in_progress &amp;amp;&amp;amp; havesupername==true) {&lt;br/&gt;    k = handle_parallel_super_load(name,&lt;br/&gt;                                   superclassname,&lt;br/&gt;                                   class_loader,&lt;br/&gt;                                   protection_domain,&lt;br/&gt;                                   lockObject, THREAD);&lt;br/&gt;    if (HAS_PENDING_EXCEPTION) {&lt;br/&gt;      return NULL;&lt;br/&gt;    }&lt;br/&gt;    if (k != NULL) {&lt;br/&gt;      class_has_been_loaded = true;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  bool throw_circularity_error = false;&lt;br/&gt;  if (!class_has_been_loaded) {&lt;br/&gt;    bool load_instance_added = false;&lt;br/&gt;&lt;br/&gt;    if (!class_has_been_loaded) {&lt;br/&gt;&lt;br/&gt;      // =====================================&lt;br/&gt;      //&lt;br/&gt;      //      执行实例加载动作&lt;br/&gt;      //&lt;br/&gt;      // =====================================&lt;br/&gt;      k = load_instance_class(name, class_loader, THREAD);&lt;br/&gt;&lt;br/&gt;      if (!HAS_PENDING_EXCEPTION &amp;amp;&amp;amp; k != NULL &amp;amp;&amp;amp;&lt;br/&gt;        k-&amp;gt;class_loader() != class_loader()) {&lt;br/&gt;&lt;br/&gt;        check_constraints(d_index, d_hash, k, class_loader, false, THREAD);&lt;br/&gt;&lt;br/&gt;        // Need to check for a PENDING_EXCEPTION again; check_constraints&lt;br/&gt;        // can throw and doesn&#x27;t use the CHECK macro.&lt;br/&gt;        if (!HAS_PENDING_EXCEPTION) {&lt;br/&gt;          { // Grabbing the Compile_lock prevents systemDictionary updates&lt;br/&gt;            // during compilations.&lt;br/&gt;            MutexLocker mu(Compile_lock, THREAD);&lt;br/&gt;            update_dictionary(d_index, d_hash, p_index, p_hash,&lt;br/&gt;              k, class_loader, THREAD);&lt;br/&gt;          }&lt;br/&gt;&lt;br/&gt;          // 通知JVMTI类加载事件&lt;br/&gt;          if (JvmtiExport::should_post_class_load()) {&lt;br/&gt;            Thread *thread = THREAD;&lt;br/&gt;            assert(thread-&amp;gt;is_Java_thread(), &quot;thread-&amp;gt;is_Java_thread()&quot;);&lt;br/&gt;            JvmtiExport::post_class_load((JavaThread *) thread, k);&lt;br/&gt;          }&lt;br/&gt;        }&lt;br/&gt;      }&lt;br/&gt;    } // load_instance_class&lt;br/&gt;  }&lt;br/&gt;  ...&lt;br/&gt;&lt;br/&gt;  return k;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;load_instance_class&lt;/code&gt;也位于&lt;code&gt;src/hotspot/share/classfile/systemDictionary.cpp&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// ===================================================================================&lt;br/&gt;//&lt;br/&gt;//              加载实例class，这里有两种方式：&lt;br/&gt;// ===================================================================================&lt;br/&gt;//&lt;br/&gt;// 1、如果classloader为null则说明是加载系统类，使用bootstrap loader&lt;br/&gt;//    调用方式：直接调用ClassLoader::load_class()加载该类&lt;br/&gt;//&lt;br/&gt;// 2、如果classloader不为null则说明是非系统类，使用ext/app/自定义 classloader&lt;br/&gt;//    调用方式：通过JavaCalls::call_virtual()调用Java方法ClassLoader.loadClass()加载该类&lt;br/&gt;//&lt;br/&gt;// ===================================================================================&lt;br/&gt;InstanceKlass* SystemDictionary::load_instance_class(Symbol* class_name, Handle class_loader, TRAPS) {&lt;br/&gt;&lt;br/&gt;  // 使用bootstrap加载器加载&lt;br/&gt;  if (class_loader.is_null()) {&lt;br/&gt;&lt;br/&gt;    // 根据全限定名获取包名&lt;br/&gt;    // Find the package in the boot loader&#x27;s package entry table.&lt;br/&gt;    TempNewSymbol pkg_name = InstanceKlass::package_from_name(class_name, CHECK_NULL);&lt;br/&gt;    if (pkg_name != NULL) {&lt;br/&gt;      pkg_entry = loader_data-&amp;gt;packages()-&amp;gt;lookup_only(pkg_name);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    InstanceKlass* k = NULL;&lt;br/&gt;&lt;br/&gt;    if (k == NULL) {&lt;br/&gt;      // Use VM class loader&lt;br/&gt;      PerfTraceTime vmtimer(ClassLoader::perf_sys_classload_time());&lt;br/&gt;      // =================================================================&lt;br/&gt;      //&lt;br/&gt;      //        使用bootstrap loader加载该类&lt;br/&gt;      //&lt;br/&gt;      // =================================================================&lt;br/&gt;      k = ClassLoader::load_class(class_name, search_only_bootloader_append, CHECK_NULL);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    return k;&lt;br/&gt;  } else {&lt;br/&gt;    // =======================================================================================&lt;br/&gt;    //&lt;br/&gt;    // 使用用户指定的加载器加载该类，调用class_loader的loadClass操作方法，&lt;br/&gt;    // 最终返回一个标准的InstanceKlass，流程如下&lt;br/&gt;    //&lt;br/&gt;    // +-----------+  loadClass()   +---------------+  get_jobject()   +-------------+&lt;br/&gt;    // | className | -------------&amp;gt; |   JavaValue   | ---------------&amp;gt; |     oop     |&lt;br/&gt;    // +-----------+                +---------------+                  +-------------+&lt;br/&gt;    //                                                                       |&lt;br/&gt;    //                                                                       | as_Klass()&lt;br/&gt;    //                                                                       v&lt;br/&gt;    //                               +---------------+  cast()          +-------------+&lt;br/&gt;    //                               | InstanceKlass | &amp;lt;--------------- |    Klass    |&lt;br/&gt;    //                               +---------------+                  +-------------+&lt;br/&gt;    //&lt;br/&gt;    // =======================================================================================  &lt;br/&gt;    ResourceMark rm(THREAD);&lt;br/&gt;&lt;br/&gt;    assert(THREAD-&amp;gt;is_Java_thread(), &quot;must be a JavaThread&quot;);&lt;br/&gt;    JavaThread* jt = (JavaThread*) THREAD;&lt;br/&gt;&lt;br/&gt;    PerfClassTraceTime vmtimer(ClassLoader::perf_app_classload_time(),&lt;br/&gt;                               ClassLoader::perf_app_classload_selftime(),&lt;br/&gt;                               ClassLoader::perf_app_classload_count(),&lt;br/&gt;                               jt-&amp;gt;get_thread_stat()-&amp;gt;perf_recursion_counts_addr(),&lt;br/&gt;                               jt-&amp;gt;get_thread_stat()-&amp;gt;perf_timers_addr(),&lt;br/&gt;                               PerfClassTraceTime::CLASS_LOAD);&lt;br/&gt;&lt;br/&gt;    Handle s = java_lang_String::create_from_symbol(class_name, CHECK_NULL);&lt;br/&gt;    // Translate to external class name format, i.e., convert &#x27;/&#x27; chars to &#x27;.&#x27;&lt;br/&gt;    Handle string = java_lang_String::externalize_classname(s, CHECK_NULL);&lt;br/&gt;&lt;br/&gt;    JavaValue result(T_OBJECT);&lt;br/&gt;&lt;br/&gt;    InstanceKlass* spec_klass = SystemDictionary::ClassLoader_klass();&lt;br/&gt;&lt;br/&gt;    // Added MustCallLoadClassInternal in case we discover in the field&lt;br/&gt;    // a customer that counts on this call&lt;br/&gt;    if (MustCallLoadClassInternal &amp;amp;&amp;amp; has_loadClassInternal()) {&lt;br/&gt;      JavaCalls::call_special(&amp;amp;result,&lt;br/&gt;                              class_loader,&lt;br/&gt;                              spec_klass,&lt;br/&gt;                              vmSymbols::loadClassInternal_name(),&lt;br/&gt;                              vmSymbols::string_class_signature(),&lt;br/&gt;                              string,&lt;br/&gt;                              CHECK_NULL);&lt;br/&gt;    } else {&lt;br/&gt;      // ===============================================================&lt;br/&gt;      //&lt;br/&gt;      // 调用ClassLoader.loadClass()方法加载该类，而最终会调用ClassLoader的native方法defineClass1()&lt;br/&gt;      // 其实现位于ClassLoader.c # Java_java_lang_ClassLoader_defineClass1()&lt;br/&gt;      //&lt;br/&gt;      // ===============================================================&lt;br/&gt;      JavaCalls::call_virtual(&amp;amp;result,&lt;br/&gt;                              class_loader,&lt;br/&gt;                              spec_klass,&lt;br/&gt;                              vmSymbols::loadClass_name(),&lt;br/&gt;                              vmSymbols::string_class_signature(),&lt;br/&gt;                              string,&lt;br/&gt;                              CHECK_NULL);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    assert(result.get_type() == T_OBJECT, &quot;just checking&quot;);&lt;br/&gt;    // 获取oop对象&lt;br/&gt;    oop obj = (oop) result.get_jobject();&lt;br/&gt;&lt;br/&gt;    // 如果不是基本类，则转换成对应的InstanceKlass&lt;br/&gt;    if ((obj != NULL) &amp;amp;&amp;amp; !(java_lang_Class::is_primitive(obj))) {&lt;br/&gt;      InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(obj));&lt;br/&gt;&lt;br/&gt;      if (class_name == k-&amp;gt;name()) {&lt;br/&gt;        // 返回最终InstanceKlass&lt;br/&gt;        return k;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;    // Class is not found or has the wrong name, return NULL&lt;br/&gt;    return NULL;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上便是相关的所有底层源码。&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;一个小小的&lt;code&gt;Class.forName&lt;/code&gt;方法，也会引出不少问题，如果仔细研究，在排查的过程，相信你一定会有所收获。&lt;/p&gt;&lt;p&gt;有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。https://death00.github.io/公众号：健程之道&lt;img data-ratio=&quot;0.5555555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BzwEAR61IMeZNWYI6OtqTxEeetJ8ibVVhibZkzVHp8ns2qThE8J2rOmRtWxxd7NvSnLL1z0japxibFu1IF1aUyiaMQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;img data-ratio=&quot;0.5555555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BzwEAR61IMeZNWYI6OtqTxEeetJ8ibVVhPUGhQOtmG3ZZIuia5Ys9tBUCM8ZDy2sbQXTwXWNsqtiadnylkNpQGrBA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4fc7317ad5241060ade7249db5ec33ef</guid>
<title>ClickHouse 常用的监控指标有哪些？</title>
<link>https://toutiao.io/k/ajp6rre</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;在前一篇文章《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4MDIwNTY4MQ==&amp;amp;mid=2247484065&amp;amp;idx=1&amp;amp;sn=a9fb5081bb8f5b294439bf31c313ae27&amp;amp;chksm=9fa680bfa8d109a992e65003909b757efdbc35638d45c1cc4e75cabe43f6bd13290b3f79bae8&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;ClickHouse的运行指标监控可以怎么玩?》&lt;/a&gt;中，我介绍了怎么利用 ClickHouse 内置的 /metrics 服务，轻松与 &lt;span&gt;Prometheus &lt;/span&gt;和 &lt;span&gt;Grafana&lt;/span&gt; 集成。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;所以今天就接着聊一聊，在 ClickHouse 中有哪些常用的监控指标。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在生产环境中，大部分操作都是围绕 MergeTree 进行的，总的来说不外乎&lt;/p&gt;&lt;p&gt;INSERT、ALTER 、 MERGE 和 &lt;span&gt;SELECT&lt;/span&gt; 这么几类操作。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于 ClickHouse 内部记录的指标非常多， 这里不可能列全，所以今天只能算是抛砖引玉，供大家参考。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;INSERT:&lt;/strong&gt;&lt;/p&gt;&lt;table align=&quot;center&quot; interlaced=&quot;enabled&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;ue-table-interlace-color-single&quot;&gt;&lt;td valign=&quot;top&quot;&gt;指标&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;说明&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-double&quot;&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;events.InsertQuery&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;执行的INSERT语句数量&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-single&quot;&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;events.&lt;/span&gt;InsertedRows&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;已经写入的数据行&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-double&quot;&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;events.&lt;/span&gt;DelayedInserts&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;由于写入负载过高，延迟写入的Block数量&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-single&quot;&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;events.&lt;/span&gt;RejectedInserts&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;由于 Too many parts 异常导致无法写入的Block数&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-double&quot;&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;events.&lt;/span&gt;DuplicatedInsertedBlocks&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;在写入ReplicatedMergeTree时，由于Block ID相同导致忽略的Block数量&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;MERGE:&lt;/strong&gt;&lt;/p&gt;&lt;table interlaced=&quot;enabled&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;ue-table-interlace-color-single&quot;&gt;&lt;td valign=&quot;top&quot;&gt;指标&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;说明&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-double&quot;&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;events.MergedRows&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;Merge的数据行&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-single&quot;&gt;&lt;td valign=&quot;top&quot;&gt;metrics.BackgroundPoolTask&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;后台正在执行任务的线程数&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-double&quot;&gt;&lt;td valign=&quot;top&quot;&gt;metrics.Merge&lt;span&gt;‍‍&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;Merge的次数&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-single&quot;&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;metrics.MemoryTrackingForMerges&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;分配给merge操作的内存总数&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;ALTER TABLE:&lt;/strong&gt;&lt;/p&gt;&lt;table interlaced=&quot;enabled&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;ue-table-interlace-color-single&quot;&gt;&lt;td valign=&quot;top&quot;&gt;指标&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;说明&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-double&quot;&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;metrics.PartMutation&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;执行ALTER UPDATE/DELETE的次数&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;SELECT:&lt;/strong&gt;&lt;/p&gt;&lt;table interlaced=&quot;enabled&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;ue-table-interlace-color-single&quot;&gt;&lt;td valign=&quot;top&quot;&gt;指标&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;说明&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-double&quot;&gt;&lt;td valign=&quot;top&quot;&gt;events.Query&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;总的查询次数，包括INSERT&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-single&quot;&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;events.&lt;/span&gt;SelectQuery&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;SELECT查询的次数&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-double&quot;&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;events.SlowRead&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;慢查询的数量&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-single&quot;&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;metrics.MemoryTracking&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;分配给server的内存总数&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-double&quot;&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;MarkCacheHits/MarkCacheMisses&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;MarkCache缓存的命中率&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;除了上述的几类常规操作之外，对于副本而言也有一些常用的监控指标&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;ReplicaMergeTree&lt;strong&gt;:&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;table interlaced=&quot;enabled&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;ue-table-interlace-color-single&quot;&gt;&lt;td valign=&quot;top&quot;&gt;指标&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;说明&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-double&quot;&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;metrics.ReadonlyReplica&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;当前只读的副本数&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-single&quot;&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;metrics.ReplicatedFetch&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;副本fetch part的数量&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-double&quot;&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;metrics.ReplicatedSend&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;副本发送part的数量&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-single&quot;&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;events.ZooKeeperTransactions&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;ZK的事务数&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-double&quot;&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;metrics.ZooKeeperSession&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;ZK的会话数&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-single&quot;&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;metrics.ZooKeeperWatch&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;ZK的Watch数&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;除了上述的列举的部分以外，相关的指标还有很多，我没有列全，大家可以顺着思路继续添加自己喜欢的指标。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;最后，再结合跟 &lt;span&gt;Prometheus 与&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Grafana 的集成，我们对 ClickHouse 的运行状态就非常容易掌控了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4281705948372615&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OIyE3Zib48wP50sgdRXCGvHqZq1LEm5XHtOasThBbU9mn5ZyRkCMIKwJZibSPOGgH5iakrXOf2eiasqIXkpwkFoecw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3564&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;原创不易，如果这篇文章对你有帮助，欢迎 &lt;/span&gt;&lt;span&gt;点赞、转发、在看 &lt;/span&gt;&lt;span&gt;三连击&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;mpcps frameborder=&quot;0&quot; class=&quot;js_editor_cps&quot; data-datakey=&quot;1608777004766_0.2779841804946046&quot; data-uid=&quot;1608777004764&quot; data-type=&quot;1&quot; data-product=&quot;&quot; data-templateid=&quot;list&quot; data-pid=&quot;12886370&quot; data-categoryid=&quot;3&quot; data-appuin=&quot;3208869061&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;欢迎大家扫码关注我的&lt;/span&gt;&lt;span&gt;公众号和视频号&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;ClickHouse的秘密基地&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OIyE3Zib48wMzw1n32iaibic8DREUYDNEWQ6vib8b3VicraCF7JicHcNAOz1uq6DGibcVMf4bKicWPzI7wuAfgI1ickQzoGQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;nauu的奇思妙想&lt;/strong&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.9806201550387597&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OIyE3Zib48wPtibZMTRqHLl37qicMFy86WMWg6YVic1V0EzEqXdsCtOZmicbrvgCxGdBWQeQze7JLeibn0Q9elxzvltg/640?wx_fmt=jpeg&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;往期精彩推荐:&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;amp;album_id=1336889409916043265&amp;amp;__biz=MzA4MDIwNTY4MQ==#wechat_redirect&quot; textvalue=&quot;【专辑】ClickHouse的资讯手札&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;【专辑】ClickHouse的资讯手札&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;amp;album_id=1339543307420106752&amp;amp;__biz=MzA4MDIwNTY4MQ==#wechat_redirect&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;【专辑】ClickHouse的原理巩固&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;amp;album_id=1342290453848326144&amp;amp;__biz=MzA4MDIwNTY4MQ==#wechat_redirect&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;【专辑】ClickHouse的经验分享&lt;/a&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;/&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>