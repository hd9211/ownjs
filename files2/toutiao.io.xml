<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>61caa43ab3c12c07090f4cc00836cd41</guid>
<title>深入理解 MQ 生产端的底层通信过程：理解 channel</title>
<link>https://toutiao.io/k/h2av1kt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUzNjAxODg4MQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlic1g1jGjiaBS1uNgC9uX4jDFicf7wBxXh5ic9WicdiaDq0qtNYgXjqOWZtpXqnXVibuZlfn7gzrWPObnEDQ/0?wx_fmt=png&quot; data-nickname=&quot;编程一生&quot; data-alias=&quot;cloudrise1986&quot; data-signature=&quot;致力于写大家都能看懂的、有深度的技术文章&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;qqmusic class=&quot;js_editor_qqmusic qqmusic_iframe js_uneditable custom_select_card res_iframe&quot; musicid=&quot;3534500&quot; mid=&quot;&quot; albumurl=&quot;&quot; audiourl=&quot;https://sharefs.ali.kugou.com/202111281720/b4145791813798693f646930d680bdc2/G205/M05/00/14/DQ4DAF5vP5SAToLKAC6luapH_qQ666.mp3&quot; music_name=&quot;任性的爱情&quot; singer=&quot;薛枫;板晋萍 - 默认专辑&quot; play_length=&quot;191&quot; src=&quot;/mp/readtemplate?t=app_editor/music&amp;amp;singer=%E8%96%9B%E6%9E%AB%3B%E6%9D%BF%E6%99%8B%E8%90%8D%20-%20%E9%BB%98%E8%AE%A4%E4%B8%93%E8%BE%91&amp;amp;music_name=%E4%BB%BB%E6%80%A7%E7%9A%84%E7%88%B1%E6%83%85&amp;amp;albumurl=&amp;amp;musictype=2&quot; musictype=&quot;2&quot; otherid=&quot;23r8kfa&quot; albumid=&quot;&quot; jumpurlkey=&quot;23r8ked&quot; data-pluginname=&quot;insertaudio&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;引子&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;在上一篇&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486166&amp;amp;idx=1&amp;amp;sn=08a24c175c02a4b146dc52088d410599&amp;amp;chksm=fafde078cd8a696e616aebcb72aeef444e1e0008bf950a368933195f13c0a268face0d3ee371&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《接下来一段时间会对大家进行网络通信的魔鬼训练-理解socket》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《接下来一段时间会对大家进行网络通信的魔鬼训练-理解socket》&lt;/a&gt;里，标题里用到了“魔鬼训练”。一向注重标题贴合内容本意，为什么我会用这个词，这里跟大家解释一下。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这是我自己的一个学习方法。有些朋友是知道的，我日语学的不错的。1年的时间内从0开始学习通过了最高级(一级)的考试。当时我就是用的这种方法。简单介绍一下当时学习的整个过程：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我加入了当时一个特别大(鼎盛时期有8W人)的对日公司。听小伙伴们说有的人3个月就可以过日语三级(最低级别是四级)了。我就想啊，别人要是可以我也可以。于是我一个0基础，直接跳过了四级班，直接报了三级班。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;可以想象，每次上课，我如听天书，就是奔着老师的颜值去的。但是私下里，我自己在赶进度。自己找其他人学习了假名等基础知识，然后抱着四级课本从头到尾的捋内容。捋完之后开始捋三级课本。怎么可能看的懂！但是我在三级课本里用到的四级内容的地方，我知道去哪里找了。所以当我终于赶上了老师的进度，三级的东西基本不会，但是四级的内容就差不多了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我一边跟着老师学，听不明白的，我就找之前的内容自己补习。三个月后的日语考试，在这个班30多个人中，我考了十几名。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我如法炮制，考二级的时候，我在整个公司一起举行的考试中考了第7名。考一级的时候，我是第1名。第2名的分数被我远远的甩在了后面。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;于是我的名字那时候经常出现在公司的周刊上面。还有人专门从其他办公楼跑过来看一眼，说是想知道这个传说中的人物长成什么样子。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这整件事情魔鬼在哪里呢，外面只看到了结果。那时候刚大学毕业，大家一起住公司宿舍。那个宿舍有7层楼，只有两层有人住。一层住男生，一层住女生。我下班之后就找没人的楼层自己在那里读日语。除了别人来叫我玩，我很少主动找别人玩的，有时间就学啊。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-type=&quot;jpeg&quot; data-w=&quot;400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRlicNVdCPHGOs2zB6FvOHyI5Y0kiaBNXqP4A5KvSv35t7GbVI5k920HVImpvvhHbibfmicyy3hLSa2yROw/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;1年的时间努力一把其实够好几年收益的。我虽然当时努力的方向不对，但是也收益了。头两年我是在沈阳的，来到北京之后找工作去了当时不错的名企，薪资也比同届的其他人高出不少。其实那时候我的技术很菜，但是日语能学的这么好，说明学习能力不错的。年轻可培养嘛，所以人家也很乐意收。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;不过这里说明了，努力的方向不对。如果我用来学习技术，那我这几年的整个人生状态都将被改变。但是我花了2年搞日语；花了1年多搞文学；如果不是要生小鲜肉，我大概已经北大文学系研究生毕业了；后来读的是中科院心理学的研究生。爱好，我是认真的。人各有所求，虽然技术上发力的晚，我也不后悔。各阶段自己想做的事情都做了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;简而言之，以上的学习方法推荐给大家，近期的文章安排也是遵循这一思路。另外一点很重要：这不是一个成功的例子，而是一个失败的教训。虽然一直以来平台都不错，还是有希望的。不可否认的是因为我那时候没有好好学习技术，现在步履艰难。换个词大家应该就能理解了：不务正业。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9269162210338681&quot; data-type=&quot;jpeg&quot; data-w=&quot;561&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRlicNVdCPHGOs2zB6FvOHyI5YPQyAK3FF0X4VM7wy5qlulMcSS1K5nk5jYTWibh0nYbPR6ztrcT8kicwA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;深入理解Channel&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;引入Channel&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485843&amp;amp;idx=1&amp;amp;sn=ae07db807669699bc4bec807aa468a5c&amp;amp;chksm=fafde33dcd8a6a2b8a34483bc61771c3cf99a49a7baf46e47e770c58372808e2053f27a203e1&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《RabbitMQ设计原理解析》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《RabbitMQ设计原理解析》&lt;/a&gt;里提到RabbitMQ的工作原理如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5049833887043189&quot; data-type=&quot;png&quot; data-w=&quot;602&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlibtgWiaX2cCEDMicOlCURnaqJRWyb1JxYqDr6zjdoqNbyprLVpiaRCarhTibFucc3J0xAibCjvNc7QOz4g/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;简单理解一下：在生产端也就是产生消息的客户端。如果咱们使用MQ发送消息，那就是咱们的应用服务器。它会通过Channel和MQ服务器也就是Broker进行通信。在Broker内部有一个路由层也就是Exchange。Exchange是交换机的意思，顾名思义，它的作用是进行一些规则的匹配，根据不同的规则将不同的消息转发到不同的消息队列Queue上。Queue里的消息到达消费端也要进行Channel。在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485991&amp;amp;idx=1&amp;amp;sn=98d17273c84eefb4a4ad23f749bedb4a&amp;amp;chksm=fafde089cd8a699f12ff60689f73e9ef8a189f3dc2dd36031ea27936863038685125ca0467f1&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《架构师三大难-领域划分问题》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《架构师三大难-领域划分问题》&lt;/a&gt;的&lt;strong&gt;示例三(异步处理模式)&lt;/strong&gt;里，我也讲了：消费端和生产端有可能是同一个应用，也可以设计为不同的应用。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;好，那在这整个流程中，Channel到底是个什么东西呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其实Channel通常翻译为信道或者渠道。不是Linux网络编程里的标准概念，而是一种抽象。什么的抽象呢？文件的读取等操作的抽象。看下面Java NIO中最重要的通道的实现：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;FileChannel：从文件中读写数据(不可异步读写)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;DatagramChannel： 能通过UDP读写网络中的数据&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;SocketChannel：能通过TCP读写网络中的数据&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;ServerSocketChannel：可以监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;再联想一下上篇&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486166&amp;amp;idx=1&amp;amp;sn=08a24c175c02a4b146dc52088d410599&amp;amp;chksm=fafde078cd8a696e616aebcb72aeef444e1e0008bf950a368933195f13c0a268face0d3ee371&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《接下来一段时间会对大家进行网络通信的魔鬼训练-理解socket》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《接下来一段时间会对大家进行网络通信的魔鬼训练-理解socket》&lt;/a&gt;里提到的Socket的本质：&lt;/p&gt;&lt;p&gt;socket的本质就是一种类型的文件，所以一个socket在进行读写操作时会对应一个文件描述符fd(file descriptor)。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7784090909090909&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicNVdCPHGOs2zB6FvOHyI5Y86OYjOPPScr5606EGbqbljfKGwsAR7lYgGCfsDtWQDvyBht3IXC4lA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;这一段是让大家回忆一下：socket是一种文件。对应于“文件的读取等操作的抽象”中的文件。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Java中怎么使用Channel&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Channel的概念语言无关，这里只是因为本人更熟悉Java。使用别的语言不影响对概念的理解。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;上篇文章中用到的ServerSocket和Socket类中都有getChannel的实现：&lt;/p&gt;&lt;pre&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt;&lt;/span&gt;&lt;span&gt; * Returns the unique {&lt;/span&gt;&lt;span&gt;@link &lt;/span&gt;&lt;span&gt;java.nio.channels.SocketChannel SocketChannel}&lt;br/&gt;&lt;/span&gt;&lt;span&gt; * object associated with this socket, if any.&lt;br/&gt;&lt;/span&gt;&lt;span&gt; *&lt;br/&gt;&lt;/span&gt;&lt;span&gt; * &lt;/span&gt;&lt;span&gt;&amp;lt;p&amp;gt; &lt;/span&gt;&lt;span&gt;A socket will have a channel if, and only if, the channel itself was&lt;br/&gt;&lt;/span&gt;&lt;span&gt; * created via the {&lt;/span&gt;&lt;span&gt;@link &lt;/span&gt;&lt;span&gt;java.nio.channels.SocketChannel#open&lt;br/&gt;&lt;/span&gt;&lt;span&gt; * SocketChannel.open} or {&lt;/span&gt;&lt;span&gt;@link&lt;br/&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;* java.nio.channels.ServerSocketChannel#accept ServerSocketChannel.accept}&lt;br/&gt;&lt;/span&gt;&lt;span&gt; * methods.&lt;br/&gt;&lt;/span&gt;&lt;span&gt; *&lt;br/&gt;&lt;/span&gt;&lt;span&gt; * &lt;/span&gt;&lt;span&gt;@return  &lt;/span&gt;&lt;span&gt;the socket channel associated with this socket,&lt;br/&gt;&lt;/span&gt;&lt;span&gt; *          or {&lt;/span&gt;&lt;span&gt;@code &lt;/span&gt;&lt;span&gt;null} if this socket was not created&lt;br/&gt;&lt;/span&gt;&lt;span&gt; *          for a channel&lt;br/&gt;&lt;/span&gt;&lt;span&gt; *&lt;br/&gt;&lt;/span&gt;&lt;span&gt; * &lt;/span&gt;&lt;span&gt;@since &lt;/span&gt;&lt;span&gt;1.4&lt;br/&gt;&lt;/span&gt;&lt;span&gt; * &lt;/span&gt;&lt;span&gt;@spec &lt;/span&gt;&lt;span&gt;JSR-51&lt;br/&gt;&lt;/span&gt;&lt;span&gt; */&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public &lt;/span&gt;SocketChannel &lt;span&gt;getChannel&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;return null;&lt;br/&gt;&lt;/span&gt;}&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;注释直接翻译成中文：&lt;/p&gt;&lt;p&gt;返回一个唯一的SocketChannel对象或者返回null。一个Socket只有在Channel本身是由SocketChannel.open或者ServerSocketChannel.accept方法创建之时才会存在(不为null)。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;上面代码已经很清楚了，直接使用Socket时，getChannel就是返回null。没有用的。那正确的获取SocketChannel的方法是什么呢？来看下面的代码：&lt;/p&gt;&lt;pre&gt;&lt;span&gt;@Test&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public void &lt;/span&gt;&lt;span&gt;getChannel&lt;/span&gt;() &lt;span&gt;throws &lt;/span&gt;Exception {&lt;br/&gt;    InetSocketAddress inetSocketAddress = &lt;span&gt;new &lt;/span&gt;InetSocketAddress(&lt;span&gt;&quot;127.0.0.1&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;520&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    for &lt;/span&gt;(&lt;span&gt;int &lt;/span&gt;i=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;; &lt;/span&gt;i &amp;lt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;; &lt;/span&gt;i++) {&lt;br/&gt;        SocketChannel socketChannel = SocketChannel.&lt;span&gt;open&lt;/span&gt;(inetSocketAddress)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;String msg = i == &lt;span&gt;1 &lt;/span&gt;? &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;客户端：我知道我是任性太任性，伤透了你的心。我是追梦的人，追一生的缘分。&lt;/span&gt;&lt;span&gt;&quot; &lt;/span&gt;:&lt;br/&gt;                &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;客户端：我愿意嫁给你，你却不能答应我。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;p&gt;&lt;span&gt;       &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;ByteBuffer writeBuffer = ByteBuffer.&lt;span&gt;allocate&lt;/span&gt;(&lt;span&gt;20000&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;span&gt;        &lt;/span&gt;writeBuffer.put(msg.getBytes())&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;writeBuffer.flip()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;socketChannel.write(writeBuffer)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;writeBuffer.clear()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;span&gt;        &lt;/span&gt;ByteBuffer readBuffer = ByteBuffer.&lt;span&gt;allocate&lt;/span&gt;(&lt;span&gt;20000&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;readBuffer.flip()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;socketChannel.read(readBuffer)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;span&gt;        &lt;/span&gt;socketChannel.close()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;}&lt;br/&gt;}&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;服务端代码还是用&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486166&amp;amp;idx=1&amp;amp;sn=08a24c175c02a4b146dc52088d410599&amp;amp;chksm=fafde078cd8a696e616aebcb72aeef444e1e0008bf950a368933195f13c0a268face0d3ee371&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《接下来一段时间会对大家进行网络通信的魔鬼训练-理解socket》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《接下来一段时间会对大家进行网络通信的魔鬼训练-理解socket》&lt;/a&gt;中服务端的代码。因为客户端没有打印任何东西，直接看服务端运行结果：&lt;/p&gt;&lt;p&gt;客户端：我知道我是任性太任性，伤透了你的心。我是追梦的人，追一生的缘分。    &lt;/p&gt;&lt;p&gt;服务端：我知道你是任性太任性，伤透了我的心。同是追梦的人，难舍难分。&lt;/p&gt;&lt;p&gt;客户端：我愿意嫁给你，你却不能答应我。       &lt;/p&gt;&lt;p&gt;服务端：你愿意嫁给你，我却不能向你承诺。&lt;/p&gt;&lt;p&gt;和上篇文章运行结果一致。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;看到这里大家是不是更疑惑了，SocketChannel和Socket做的同样的事情？&lt;/p&gt;&lt;pre&gt;&lt;span&gt;public static &lt;/span&gt;SocketChannel &lt;span&gt;open&lt;/span&gt;(SocketAddress remote) &lt;span&gt;throws &lt;/span&gt;IOException {&lt;br/&gt;    SocketChannel sc = &lt;strong&gt;&lt;span&gt;&lt;span&gt;open&lt;/span&gt;();&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;    try &lt;/span&gt;{&lt;br/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;       sc.connect(remote);&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;    } &lt;span&gt;catch &lt;/span&gt;(Throwable x) {&lt;/p&gt;&lt;span&gt;         try &lt;/span&gt;{&lt;br/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;          sc.close();&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;        } &lt;span&gt;catch &lt;/span&gt;(Throwable suppressed) {&lt;/p&gt;             x.addSuppressed(suppressed)&lt;span&gt;;&lt;br/&gt;         &lt;/span&gt;}&lt;br/&gt;        &lt;span&gt;throw &lt;/span&gt;x&lt;span&gt;;&lt;br/&gt;    &lt;/span&gt;}&lt;br/&gt;    &lt;span&gt;assert &lt;/span&gt;sc.isConnected()&lt;span&gt;;&lt;br/&gt;    return &lt;/span&gt;sc&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;}&lt;/pre&gt;&lt;pre&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;注意里面标红加粗的三个方法，open方法点进去有实现。这里有只截取open方法中我想说明的地方：&lt;/p&gt;&lt;pre&gt;SocketChannelImpl(SelectorProvider var1) &lt;span&gt;throws &lt;/span&gt;IOException {&lt;br/&gt;    &lt;span&gt;super&lt;/span&gt;(var1)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;p&gt;&lt;span&gt;    this&lt;/span&gt;.fd = &lt;span&gt;&lt;strong&gt;&lt;span&gt;Net.socket(true);&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    this&lt;/span&gt;.fdVal = IOUtil.fdVal(&lt;span&gt;this&lt;/span&gt;.fd)&lt;span&gt;;&lt;br/&gt;    this&lt;/span&gt;&lt;/p&gt;&lt;span&gt;    this&lt;/span&gt;.state = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;}&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;结合客户端例子的代码，发现了什么？&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1065830721003134&quot; data-type=&quot;jpeg&quot; data-w=&quot;638&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRl8W5MBSAVicGgJ8bmicz4wgcviciaPLFGAQGggcw638lYSn0v8wJqv6icWXkaREMVl6LoyaL0leoxKKjMQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;这张图眼熟不？&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486166&amp;amp;idx=1&amp;amp;sn=08a24c175c02a4b146dc52088d410599&amp;amp;chksm=fafde078cd8a696e616aebcb72aeef444e1e0008bf950a368933195f13c0a268face0d3ee371&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《接下来一段时间会对大家进行网络通信的魔鬼训练-理解socket》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《接下来一段时间会对大家进行网络通信的魔鬼训练-理解socket》&lt;/a&gt;的图又来了一遍。看！TCP客户端这里做的事情，Channel全都做了！&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;SocketChannel就是Socket 的替代类, 支持阻塞通信与非阻塞通信。Socket原生只支持最简的阻塞通信。Socket是在java.net下，SocketChannel在java.nio包下。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;MQ中怎么使用Channel&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;下面是RabbitMQ的客户端代码，为什么用RabbitMQ呢？&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485843&amp;amp;idx=1&amp;amp;sn=ae07db807669699bc4bec807aa468a5c&amp;amp;chksm=fafde33dcd8a6a2b8a34483bc61771c3cf99a49a7baf46e47e770c58372808e2053f27a203e1&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《RabbitMQ设计原理解析》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《RabbitMQ设计原理解析》&lt;/a&gt;里有说明：因为它实现了AMQP的标准协议。先上代码：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; final &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; EXCHANGE_NAME = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;RABBITMQ_Fanout&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;void&lt;/span&gt; main(&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt;[] args) throws Exception{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        ConnectionFactory connectionFactory = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ConnectionFactory();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        connectionFactory.setHost(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;localhost&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Connection connection = connectionFactory.newConnection();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Channel channel = connection.createChannel();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        channel.exchangeDeclare(EXCHANGE_NAME, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;fanout&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; message = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;This message is from Fanout mode.特点是Consumer均可获取到消息&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        channel.basicPublish(EXCHANGE_NAME, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;, message.getBytes());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.out.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;---【Producer发送消息】&quot;&lt;/span&gt; + message + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;---&quot;&lt;/span&gt; );&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        channel.close();;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        connection.close();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解析一下这段代码：这是一个生产端的代码。首先新建一个连接工厂的实例。一个连接工厂可以创建多个连接。一个连接可以创建多个Channel信道。Channel可以声明为fanout广播，也可以设置其他路由形式。然后就可以通过Channel进行数据发送了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在AMQP协议中，有channel的概念，在RabbitMq中,channel表示逻辑连接或者叫虚拟连接，是棣属于TCP连接的。一个TCP连接里可以创建多个channel,在Rabbit MQ里，消息的发送和接收都是基于channel的。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4056603773584906&quot; data-type=&quot;png&quot; data-w=&quot;424&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicNVdCPHGOs2zB6FvOHyI5YOLLAcvGIx9MHhr3CLTSiaib8FenjqYUrewjXnziaSo9mD9BACE0ubzA2w/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;有了TCP连接后,还需要channel的原因如下:&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;创建和销毁TCP连接很耗时;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;打开太多TCP连接,耗操作系统资源，并发量大到一定程度,系统的吞吐量会降低；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;使用一个connection多channel的方式,可以提升连接的利用率。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;因此采用多个channel多路复用一个TCP连接的方式才比较合理。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;https://www.rabbitmq.com/api-guide.html#connection-and-channel-lifspan&lt;/p&gt;&lt;p&gt;说话要有证据，官网上这样说：&lt;/p&gt;&lt;p&gt;Client connections are meant to be long-lived. The underlying protocol is designed and optimized for long running connections. That means that opening a new connection per operation, e.g. a message published, is unnecessary and strongly discouraged as it will introduce a lot of network roundtrips and overhead.&lt;/p&gt;&lt;p&gt;Channels are also meant to be long-lived but since many recoverable protocol errors will result in channel closure, channel lifespan could be shorter than that of its connection. Closing and opening new channels per operation is usually unnecessary but can be appropriate. When in doubt, consider reusing channels first.&lt;/p&gt;&lt;p&gt;Channel-level exceptions such as attempts to consume from a queue that does not exist will result in channel closure. A closed channel can no longer be used and will not receive any more events from the server (such as message deliveries). &lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;翻译一下：&lt;/p&gt;&lt;p&gt;客户端连接是要长久存活的，基础协议(AMQP协议)里做了连接要长久存活的优化。就是说为了发一条消息而打开一个新的连接没有必要，而且强烈不推荐。因为会带来额外的通信开销。&lt;/p&gt;&lt;p&gt;Channel也是长久存活的，但是由于许多可以恢复的错误会导致Channel关闭，所以channel的生命周期会比连接短。每次操作都关闭和打开新Channel，没有必要但是却可以是比较合适的选择。如果不知道怎么做更好的时候，优先复用Channel。&lt;/p&gt;&lt;p&gt;Channel级别的异常比如尝试消费一个不存在的队列会导致Channel关闭。一个关闭的Channel不会再被使用，也不会再收到任何如消息传递之类的服务端事件。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;简单来说，Channel是为了复用连接产生的，如果Channel异常了，就可以直接关闭Channel不至于整个连接都关闭，减少开销。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Java的Channel和MQ的Channel比较&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;本质上，不管是Java的Channel还是MQ的Channel都为了连接的复用而生。所以Java的Channel出现在java.nio包里，做的是io多路复用的事情。只是因为Channel是个逻辑概念，究竟是先产生Channel，还是必须依附于连接由设计者自己说了算。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;很多公司都有渠道(Channel)一说，但是不同的场景意义各不相同。比如：业务渠道、支付渠道。本质上，这些渠道的对端各有不同，又希望复用，才产生了网关。从这个意义上来说，网关非常合适用多路复用来解释。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Channel这个概念是理解NIO、netty的基础，也是理解MQ底层通信过程的基础。不管是什么类型的MQ，在创建连接时都需要同时配置channel，只不过有时候使用了约定大于配置，不是显式的。其实这一篇我写了万把字。太长了所以拆成了几篇，看完这几篇，我预期上很多之前看不懂的源会清晰很多。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;往期推荐&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485567&amp;amp;idx=1&amp;amp;sn=0644277d2c046890a14442830a4ed0f3&amp;amp;chksm=fafde2d1cd8a6bc70307efef696654f89074c2219f824af72effe5eb027cee983b364e4279c8&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Redis集群搭建采坑总结&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span/&gt;&lt;/a&gt;&lt;/h1&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4e0c652a0e34016348e9f525c355aee2</guid>
<title>RocketMQ 分享</title>
<link>https://toutiao.io/k/to0i0qa</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entry-content e-content&quot; itemprop=&quot;description articleBody&quot;&gt;
&lt;pre&gt;&lt;code class=&quot;&quot;&gt;版权声明 本站原创文章 由 萌叔 发表
转载请注明 萌叔 | http://vearne.cc
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;1.简介&lt;/h3&gt;
&lt;p&gt;RocketMQ是一个分布式消息和流数据平台，具有低延迟、高性能、高可靠性、万亿级容量和灵活的可扩展性。RocketMQ是2012年阿里巴巴开源的第三代分布式消息中间件，2016年11月21日，阿里巴巴向Apache软件基金会捐赠了RocketMQ；第二年2月20日，Apache软件基金会宣布Apache RocketMQ成为顶级项目。&lt;/p&gt;
&lt;h3&gt;2.架构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://ut-bucket01.sh1a.qingstor.com/woshiaotian/20211123/bd8653d6-4c39-11ec-a55e-1e00da114f95.png&quot; alt=&quot;&quot; data-pagespeed-url-hash=&quot;150835160&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ut-bucket01.sh1a.qingstor.com/woshiaotian/20211124/9f7327d4-4cfc-11ec-b5be-1e00da114f95.jpeg&quot; alt=&quot;&quot; data-pagespeed-url-hash=&quot;3948743701&quot;/&gt;&lt;/p&gt;
&lt;p&gt;正常情况，写和读都走Master，Master如果宕机，读可以走Slave&lt;/p&gt;
&lt;p&gt;在 RocketMQ 4.5 版本之前，RocketMQ 只有 Master/Slave 一种部署方式，虽然这种模式可以提供一定的高可用性但也存在比较大的缺陷。为了实现新的高可用多副本架构，RockeMQ 最终选用了基于 Raft 协议的 commitlog 存储库 DLedger。&lt;/p&gt;
&lt;h4&gt;2.1 四种角色&lt;/h4&gt;
&lt;h5&gt;2.1.1 NameServer&lt;/h5&gt;
&lt;p&gt;存储元数据 topic -&amp;gt; broker&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无状态&lt;/li&gt;
&lt;li&gt;接收来自broker的心跳&lt;/li&gt;
&lt;li&gt;检查与borker的通讯是否过期&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;Topic路由信息&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&quot;&quot;&gt;{
    &quot;OrderTopicConf&quot;: &quot;&quot;,
    &quot;queueDatas&quot;: [{
        &quot;brokerName&quot;: &quot;broker-3&quot;,
        &quot;readQueueNums&quot;: 4,
        &quot;writeQueueNums&quot;: 4,
        &quot;perm&quot;: 6,
        &quot;topicSynFlag&quot;: 0
    }, {
        &quot;brokerName&quot;: &quot;broker-4&quot;,
        &quot;readQueueNums&quot;: 4,
        &quot;writeQueueNums&quot;: 4,
        &quot;perm&quot;: 6,
        &quot;topicSynFlag&quot;: 0
    }],
    &quot;brokerDatas&quot;: [{
        &quot;cluster&quot;: &quot;Default_Cluster&quot;,
        &quot;brokerName&quot;: &quot;broker-4&quot;,
        &quot;brokerAddrs&quot;: {
            &quot;0&quot;: &quot;192.168.12.123:10911&quot;,
            &quot;1&quot;: &quot;192.168.12.127:10911&quot;
        }
    }, {
        &quot;cluster&quot;: &quot;Default_Cluster&quot;,
        &quot;brokerName&quot;: &quot;broker-3&quot;,
        &quot;brokerAddrs&quot;: {
            &quot;1&quot;: &quot;192.168.12.220:10911&quot;,
            &quot;0&quot;: &quot;192.168.12.12:10911&quot;
        }
    }]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;2.1.2 Producter&lt;/h5&gt;
&lt;p&gt;有发往broker的心跳(Master)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;&quot;&gt;{
    &quot;clientID&quot;: &quot;192.168.20.139@67576&quot;,
    &quot;producerDataSet&quot;: [{
        &quot;groupName&quot;: &quot;PG-test&quot;
    }],
    &quot;consumerDataSet&quot;: []
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;2.1.3 Consumer&lt;/h5&gt;
&lt;p&gt;有发往broker的心跳(Master)&lt;br/&gt;
* 注意下面有2个Topic&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;&quot;&gt;{
    &quot;clientID&quot;: &quot;192.168.20.139@05B75F58-C651-451D-A5BE-5E7D3E388373&quot;,
    &quot;producerDataSet&quot;: [],
    &quot;consumerDataSet&quot;: [{
        &quot;groupName&quot;: &quot;CG-test&quot;,
        &quot;consumeType&quot;: &quot;CONSUME_PASSIVELY&quot;,
        &quot;messageModel&quot;: &quot;CLUSTERING&quot;,
        &quot;consumeFromWhere&quot;: &quot;CONSUME_FROM_FIRST_OFFSET&quot;,
        &quot;subscriptionDataSet&quot;: [{
            &quot;classFilterMode&quot;: false,
            &quot;topic&quot;: &quot;helloworld&quot;,
            &quot;subString&quot;: &quot;tag2&quot;,
            &quot;tagsSet&quot;: [&quot;tag2&quot;],
            &quot;codeSet&quot;: [&quot;3552216&quot;],
            &quot;subVersion&quot;: 1637657077446848000,
            &quot;expressionType&quot;: &quot;TAG&quot;
        }, {
            &quot;classFilterMode&quot;: false,
            &quot;topic&quot;: &quot;%RETRY%CG-test&quot;,
            &quot;subString&quot;: &quot;*&quot;,
            &quot;tagsSet&quot;: [],
            &quot;codeSet&quot;: [],
            &quot;subVersion&quot;: 1637657077514551000,
            &quot;expressionType&quot;: &quot;TAG&quot;
        }],
        &quot;unitMode&quot;: false
    }]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;2.1.4 Broker&lt;/h5&gt;
&lt;h5&gt;MessageQueue&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;MessageQueue类似于kafka中的partition&lt;/li&gt;
&lt;li&gt;MessageQueue的唯一坐标是topic -&amp;gt; brokerName -&amp;gt; queueId&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://ut-bucket01.sh1a.qingstor.com/woshiaotian/20211123/9d32b022-4c41-11ec-a57d-1e00da114f95.jpeg&quot; alt=&quot;&quot; data-pagespeed-url-hash=&quot;264087581&quot;/&gt;&lt;/p&gt;
&lt;p&gt;存储实际的消息数据&lt;br/&gt;
&lt;img src=&quot;http://ut-bucket01.sh1a.qingstor.com/woshiaotian/20211123/8390943c-4c3b-11ec-abe6-1e00da114f95.png&quot; alt=&quot;&quot; data-pagespeed-url-hash=&quot;1056159474&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;三种文件&lt;/li&gt;
&lt;li&gt;commitLog 顺序写的文件&lt;/li&gt;
&lt;li&gt;indexFile 索引&lt;/li&gt;
&lt;li&gt;consumeQueue 索引&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;2.1.4.1 注意与kafka的差异&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;http://ut-bucket01.sh1a.qingstor.com/woshiaotian/20211124/46993f72-4cca-11ec-9a55-1e00da114f95.jpeg&quot; alt=&quot;&quot; data-pagespeed-url-hash=&quot;2280386022&quot;/&gt;&lt;br/&gt;
topic -&amp;gt; partition -&amp;gt; segment&lt;br/&gt;
&lt;img src=&quot;http://ut-bucket01.sh1a.qingstor.com/woshiaotian/20211124/61a6b128-4cca-11ec-b2f7-1e00da114f95.jpeg&quot; alt=&quot;&quot; data-pagespeed-url-hash=&quot;1905141814&quot;/&gt;&lt;br/&gt;
多个topic共用commitLog&lt;/p&gt;
&lt;p&gt;Why?&lt;br/&gt;
&lt;img src=&quot;http://ut-bucket01.sh1a.qingstor.com/woshiaotian/20211123/38f49452-4c3e-11ec-a3d6-1e00da114f95.png&quot; alt=&quot;&quot; data-pagespeed-url-hash=&quot;1771738619&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;: 分区多文件多，那么局部的顺序读写会退化到随机IO&lt;/p&gt;
&lt;h3&gt;3.特性&amp;amp;新概念&lt;/h3&gt;
&lt;h4&gt;3.1 订阅与发布&lt;/h4&gt;
&lt;h4&gt;3.2 消息顺序&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;分区顺序&lt;/li&gt;
&lt;li&gt;全局顺序&lt;br/&gt;
全局顺序消息实际上是一种特殊的分区顺序消息，即Topic中只有一个分区，因此全局顺序和分区顺序的实现原理相同。因为分区顺序消息有多个分区，所以分区顺序消息比全局顺序消息的并发度和性能更高。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;3.3 2种消费方式&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;ConsumeMode.ORDERLY&lt;/li&gt;
&lt;li&gt;ConsumeMode.CONCURRENTLY&lt;br/&gt;
涉及特殊的Command和线程池&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;&quot;&gt;ReqLockBatchMQ = int16(41)
ReqUnlockBatchMQ = int16(42) 
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;3.4 消息过滤&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;支持SQL92和Tag 2种方式&lt;/li&gt;
&lt;li&gt;Tag过滤会在broker段和consumer端各过滤一次&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;3.5 至少一次&lt;/h4&gt;
&lt;h4&gt;3.6 回溯消费&lt;/h4&gt;
&lt;h4&gt;3.7 事务消息&lt;/h4&gt;
&lt;h4&gt;3.8 定时消息&lt;/h4&gt;
&lt;h4&gt;3.9 消息重试&amp;amp;重投&lt;/h4&gt;
&lt;h4&gt;3.10 消息类型&lt;/h4&gt;

&lt;h3&gt;4.延迟&amp;amp;重试机制&lt;/h3&gt;
&lt;h4&gt;4.1 延迟&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;&quot;&gt;messageDelayLevel=&quot;1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://ut-bucket01.sh1a.qingstor.com/woshiaotian/20211125/8ee147bc-4da0-11ec-8337-1e00da114f95.jpeg&quot; alt=&quot;&quot; data-pagespeed-url-hash=&quot;1551285259&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1) 修改消息Topic名称和队列信息&lt;br/&gt;
2) 转发消息到延迟主题的CosumeQueue中&lt;br/&gt;
3) 延迟服务消费SCHEDULE_TOPIC_XXXX消息&lt;br/&gt;
4) 将信息重新存储到CommitLog中&lt;br/&gt;
5) 将消息投递到目标Topic中&lt;br/&gt;
6) 消费者消费目标topic中的数据&lt;br/&gt;
&lt;img src=&quot;http://ut-bucket01.sh1a.qingstor.com/woshiaotian/20211125/129a51e0-4da4-11ec-b83c-1e00da114f95.png&quot; alt=&quot;&quot; data-pagespeed-url-hash=&quot;443944926&quot;/&gt;&lt;/p&gt;
&lt;p&gt;SCHEDULE_TOPIC_XXXX中的每个ConsumeQueue都相当于QelayQueue&lt;/p&gt;
&lt;h4&gt;4.2 重试&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;&quot;&gt;    err := c.Subscribe(TopicName,
        consumer.MessageSelector{Type: consumer.TAG, Expression: &quot;tag1||tag2&quot;},
        func(ctx context.Context,
            msgs ...*primitive.MessageExt) (consumer.ConsumeResult, error) {
            cCtx, _ := primitive.GetConcurrentlyCtx(ctx)
            //cCtx.DelayLevelWhenNextConsume = delayLevel // only run when return consumer.ConsumeRetryLater
            fmt.Println(&quot;DelayLevelWhenNextConsume&quot;, cCtx.DelayLevelWhenNextConsume)
            for i, msg := range msgs {
                counter++
                fmt.Println(&quot;ReconsumeTimes&quot;, msg.ReconsumeTimes, &quot;BornTimestamp&quot;, msg.BornTimestamp)
                fmt.Println(&quot;topic&quot;, msg.Topic)
                fmt.Println(string(msg.Body))
                fmt.Println(&quot;tags:&quot;, msg.GetTags())
                fmt.Printf(&quot;subscribe callback: %v, counter:%v \n&quot;, msgs[i], counter)
            }
            return consumer.ConsumeRetryLater, nil
            //return consumer.ConsumeSuccess, nil
        })
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;&quot;&gt;ReqConsumerSendMsgBack  = int16(36)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;消息再次收到来自%RETRY%{consumerGroup}&lt;/li&gt;
&lt;li&gt;如果多次重试还是无法成功，会进入死信队列 %DLQ%{consumerGroup}&lt;br/&gt;
&lt;img src=&quot;http://ut-bucket01.sh1a.qingstor.com/woshiaotian/20211115/4a1d527a-4601-11ec-b208-1e00da114f95.jpeg&quot; alt=&quot;&quot; data-pagespeed-url-hash=&quot;684603723&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;5.负载均衡&lt;/h3&gt;
&lt;h3&gt;5.1 触发时机&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;client启动时&lt;/li&gt;
&lt;li&gt;定时20s检查是否需要负载均衡&lt;/li&gt;
&lt;li&gt;broker推送通知 ReqNotifyConsumerIdsChanged&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;5.2 具体步骤&lt;/h3&gt;
&lt;h3&gt;1）获取MessageQueue List&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;从NameServer获取&lt;/li&gt;
&lt;li&gt;排序&lt;br/&gt;
[topic=helloworld, brokerName=broker-3, queueId=0]&lt;br/&gt;
[topic=helloworld, brokerName=broker-3, queueId=1]&lt;br/&gt;
[topic=helloworld, brokerName=broker-3, queueId=2]&lt;br/&gt;
[topic=helloworld, brokerName=broker-3, queueId=3]&lt;br/&gt;
[topic=helloworld, brokerName=broker-4, queueId=0]&lt;br/&gt;
[topic=helloworld, brokerName=broker-4, queueId=1]&lt;br/&gt;
[topic=helloworld, brokerName=broker-4, queueId=2]&lt;br/&gt;
[topic=helloworld, brokerName=broker-4, queueId=3]&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2）获取ConsumerList&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;&quot;&gt;192.168.100.20@24758
192.168.100.21@33922
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;3) 根据某种策略来计算自己的负载&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;AllocateByAveragely&lt;/li&gt;
&lt;li&gt;AllocateByAveragelyCircle&lt;/li&gt;
&lt;li&gt;AllocateByMachineNearby&lt;/li&gt;
&lt;li&gt;AllocateByConfig&lt;/li&gt;
&lt;li&gt;AllocateByMachineRoom&lt;/li&gt;
&lt;li&gt;AllocateByConsistentHash&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以AllocateByAveragely 举例&lt;br/&gt;
&lt;img src=&quot;http://ut-bucket01.sh1a.qingstor.com/woshiaotian/20211124/cdea8aa6-4d12-11ec-8f72-1e00da114f95.png&quot; alt=&quot;&quot; data-pagespeed-url-hash=&quot;2350260861&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;5.3 缺陷&lt;/h3&gt;

&lt;h3&gt;6.数据存储&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://ut-bucket01.sh1a.qingstor.com/woshiaotian/20211124/a3915cc8-4cf2-11ec-bbea-1e00da114f95.png&quot; alt=&quot;&quot; data-pagespeed-url-hash=&quot;887752462&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;7.数据查询&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://ut-bucket01.sh1a.qingstor.com/woshiaotian/20211124/603c9666-4cd6-11ec-9813-1e00da114f95.png&quot; alt=&quot;&quot; data-pagespeed-url-hash=&quot;91726621&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ut-bucket01.sh1a.qingstor.com/woshiaotian/20211124/6dc5a538-4cd7-11ec-8a42-1e00da114f95.png&quot; alt=&quot;&quot; data-pagespeed-url-hash=&quot;2845991600&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;7.1 按照msgID查询&lt;/h4&gt;
&lt;h5&gt;7.1.1 msgId和offsetMsgId&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;msgId&lt;/code&gt; 客户端生成 也叫做”UNIQ_KEY”&lt;br/&gt;
该ID 是消息发送者在消息发送时会首先在客户端生成，全局唯一&lt;br/&gt;
&lt;code&gt;offsetMsgId&lt;/code&gt; 服务端生成的&lt;br/&gt;
该ID 是消息发送者在消息发送时会首先在客户端生成，全局唯一，在 RocketMQ 中该 ID 还有另外的一个叫法：uniqId，无不体现其全局唯一性。&lt;br/&gt;
offsetMsgId：消息偏移ID，该 ID 记录了消息所在集群的物理地址，主要包含所存储 Broker 服务器的地址( IP 与端口号)以及所在commitlog 文件的物理偏移量。&lt;/p&gt;
&lt;p&gt;解析offsetMsgId获取broker的地址和phyOffset&lt;br/&gt;
此处phyOffset是commitLog(多个文件分片都是定长)的文件偏移量&lt;/p&gt;
&lt;h4&gt;7.2 按照Topic+key查询&lt;/h4&gt;
&lt;h4&gt;1条消息可以产生多条索引&lt;/h4&gt;
&lt;p&gt;topic + # + 消息的 key –&amp;gt; commitLogOffset&lt;br/&gt;
topic + # + uniqKey –&amp;gt; commitLogOffset&lt;/p&gt;
&lt;h4&gt;7.3 按照Topic+queueID + beginTimestamp + EndTimestamp&lt;/h4&gt;
&lt;h5&gt;7.3.1 通过beginTimestamp获得consumeQueue中的minOffset&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;根据beginTimestamp比对consumeQueue(多个文件分片)的LastModifiedTime，确定文件分片&lt;/li&gt;
&lt;li&gt;使用二分查找获得minOffset，过程中需要从commitLog获得StoreTimeStamp&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;7.3.2 通过EndTimestamp获得consumeQueue中maxOffset&lt;/h5&gt;
&lt;h5&gt;7.3.3 按照Topic+queueID+minOffset+maxOffset读取消息&lt;/h5&gt;
&lt;h3&gt;参考资料&lt;/h3&gt;
&lt;p&gt;1.&lt;a href=&quot;https://no.linkedin.com/pulse/rocketmq%E5%90%90%E8%A1%80%E6%80%BB%E7%BB%93-%E7%BA%A2%E5%96%9C-%E6%B2%88#:~:text=%E5%8D%95%E4%B8%AABroker%E8%B7%9F%E6%89%80%E6%9C%89Namesrv,%E8%B7%9FBroker%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB%E3%80%82&quot;&gt;RocketMQ吐血总结&lt;/a&gt;&lt;br/&gt;
2.&lt;a href=&quot;https://www.jianshu.com/p/345aaa18f71da&quot;&gt;rocketMq-Topic创建过程&lt;/a&gt;&lt;br/&gt;
3.&lt;a href=&quot;https://www.modb.pro/db/72475&quot;&gt;RocketMQ源码分析：Broker心跳原理&lt;/a&gt;&lt;br/&gt;
4.&lt;a href=&quot;https://jaskey.github.io/blog/2016/12/19/rocketmq-network-protocol/&quot;&gt;RocketMQ——通信协议&lt;/a&gt;&lt;br/&gt;
5.&lt;a href=&quot;https://www.jianshu.com/p/1723d0cda743&quot;&gt;RocketMq 消息Tag过滤&lt;/a&gt;&lt;br/&gt;
6.&lt;a href=&quot;https://blog.csdn.net/prestigeding/article/details/104739950&quot;&gt;RocketMQ msgId与offsetMsgId释疑(实战篇)&lt;/a&gt;&lt;br/&gt;
7.&lt;a href=&quot;https://blog.csdn.net/prestigeding/article/details/79156276&quot;&gt;源码分析RocketMQ之消费队列、Index索引文件存储结构与存储机制-上篇&lt;/a&gt;&lt;br/&gt;
8.&lt;a href=&quot;https://blog.csdn.net/prestigeding/article/details/79179607&quot;&gt;源码分析RocketMQ之消费队列、Index索引文件存储结构与存储机制-下篇&lt;/a&gt;&lt;br/&gt;
9.&lt;a href=&quot;https://cloud.tencent.com/developer/article/1581368&quot;&gt;深入理解RocketMQ延迟消息&lt;/a&gt;&lt;br/&gt;
10.&lt;a href=&quot;https://segmentfault.com/a/1190000023778797&quot;&gt;Kafka和RocketMQ底层存储之那些你不知道的事&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;h4&gt;打赏我&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://st.vearne.cc/2ob&quot; alt=&quot;微信支付码&quot; data-pagespeed-url-hash=&quot;552127054&quot;/&gt;&lt;/p&gt;

&lt;p class=&quot;clear&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>72401c537a3ad0661d7554ac786b88fc</guid>
<title>推荐几个可以写到简历上的 Go 方向优质开源项目</title>
<link>https://toutiao.io/k/3ec4pi8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哈喽，大家好，我是&lt;code&gt;asong&lt;/code&gt;。最近总有读者问我有没有&lt;code&gt;Go&lt;/code&gt;语言方向优质的开源项目，可以写在简历上那种，一时还真想不起来，花了两天时间调研了一下，针对有无工作经验的分别推荐几个开源项目，下面我们一起来看一下。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;无工作经验&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于还在上学的朋友们，除了知道必要的基础知识外，也要有1-2个拿的出手的项目，光有基础，没有实践，很难过去简历这一关，对于学生而言，简单的&lt;code&gt;crud&lt;/code&gt;还是要熟练掌握的，接下来就推荐几个文档比较齐全的&lt;code&gt;web&lt;/code&gt;项目，入门后可以在此基础上深度开发。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;bbs-go&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;bbs-go&lt;/code&gt;是一个使用&lt;code&gt;Go&lt;/code&gt;语言搭建的开源社区系统，后端使用技术栈：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;iris (https://github.com/kataras/iris) Go 语言 mvc 框架&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;gorm (http://gorm.io/) Go 语言 orm 框架&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Nuxt.js （https://nuxtjs.org/） 基于Vue.js的服务端页面渲染框架，简单、好用、功能强大&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;resty (https://github.com/go-resty/resty) Go 语言好用的 http-client&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;cron (https://github.com/robfig/cron) 定时任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;goquery (https://github.com/PuerkitoBio/goquery) html dom 元素解析&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有配套的前端项目，基于&lt;code&gt;Vue&lt;/code&gt;搭建的，功能还是比较全面的，通过这个项目可以了解开发一个开源社区的设计思路，对于一个新手入门&lt;code&gt;web&lt;/code&gt;开发还是很友好的，但是这个项目需要付费才能观看搭建文档，不过代码是开源的，大家可以把源码下载下来自己研究一下，代码内容不多且简洁，自己深耕几天应该可以掌握。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目地址：https://gitee.com/mlogclub/bbs-go&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Gin-vue-admin&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个项目在&lt;code&gt;Go&lt;/code&gt;语言领域还是很出名的，&lt;code&gt;Gin-vue-admin&lt;/code&gt;是一个基于 vue 和 gin 开发的全栈前后端分离的开发基础平台，集成jwt鉴权，动态路由，动态菜单，casbin鉴权，表单生成器，代码生成器等功能，提供多种示例文件，还配有完整的文档教程和视频教程。这个项目个人觉得是新手入门必看项目，跟着做一遍后基本的&lt;code&gt;crud&lt;/code&gt;就都掌握了，其中分片长传、代码生成器的功能还是挺有借鉴意义的，可以深入了解一下。这个项目不需要介绍太多，文档比较详细，可以达到手把手入门的程度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目地址：https://github.com/flipped-aurora/gin-vue-admin&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;rpcx&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在企业都是由单体应用向微服务架构转型，微服务的实践离不开&lt;code&gt;RPC&lt;/code&gt;框架的应用，目前服务治理型的&lt;code&gt;RPC&lt;/code&gt; 框架有&lt;code&gt;dubbo-go&lt;/code&gt;、&lt;code&gt;go-zero&lt;/code&gt;、&lt;code&gt;go-kit&lt;/code&gt; 等，跨语言调用型的 &lt;code&gt;RPC&lt;/code&gt; 框架有 &lt;code&gt;Thrift&lt;/code&gt;、&lt;code&gt;gRPC&lt;/code&gt;、&lt;code&gt;Hessian&lt;/code&gt;、&lt;code&gt;Finagle&lt;/code&gt;、&lt;code&gt;rpcx&lt;/code&gt; 等，对于一个小白而言理解&lt;code&gt;RPC&lt;/code&gt;的原理比较重要，所以可以先从&lt;code&gt;rpcx&lt;/code&gt;框架入手，rpcx 是一个分布式的&lt;code&gt;Go&lt;/code&gt;语言的&lt;code&gt;RPC&lt;/code&gt;框架，支持&lt;code&gt;Zookepper&lt;/code&gt;、&lt;code&gt;etcd&lt;/code&gt;、&lt;code&gt;consul&lt;/code&gt;多种服务发现方式，多种服务路由方式， 是目前性能最好的 RPC 框架之一，&lt;code&gt;rpcx&lt;/code&gt;的文档比较齐全，有专门的团队维护，是新手入门的不二选择。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目地址：https://github.com/smallnest/rpcx&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文档地址：https://doc.rpcx.io/&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;go-kit&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家可以关注一下&lt;code&gt;go-kit&lt;/code&gt;这个微服务项目，基于&lt;code&gt;go-kit&lt;/code&gt;可以快速构建健壮、可靠、可维护的微服务，go-kit提供了对consul、etcd、zookeeper、eureka等注册中心的支持，有一位大佬开源了一份&lt;code&gt;go-kit&lt;/code&gt;微服务实践教程：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;观看这个系列的博客：https://juejin.cn/post/6844903794380111886&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;源码地址在这里：https://github.com/hwholiday/learning_tools/tree/master/go-kit&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;go-kit自动生成代码的命令行工具：https://github.com/kujtimiihoxha/kit&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目地址：https://github.com/go-kit/kit&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;有工作经验&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;已经有工作经验的朋友们就可以不用看一些基础的项目和原理了，可以更多的关注项目的架构设计、性能优化、服务治理等，更多的去思考如何维护好一个项目，这其实并不需要来看开源框架，更多关注自己项目团队的框架，从中找出优缺点去做优化，更加体现自己的价值。如果自己项目团队的框架比较水的话，那么下面就推荐几个优秀的开源项目供你学习借鉴。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;zinx&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;zinx&lt;/code&gt;是一个基于&lt;code&gt;Go&lt;/code&gt;语言开发的&lt;code&gt;TCP&lt;/code&gt;长连接服务器框架，其可以应用在游戏领域或其他长连接领域；我们可以学习&lt;code&gt;zinx&lt;/code&gt;框架的设计思路，他有完整的视频教程和文档，通过这个我们可以完全理解如何设计一个轻量级并发服务器，然后自己基于&lt;code&gt;zinx&lt;/code&gt;自己写一个，并做一些优化，写在简历上岂不是可以吹一吹！！！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目地址：https://github.com/aceld/zinx&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文档地址：https://www.kancloud.cn/aceld/zinx&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;视频地址：https://www.bilibili.com/video/av71067087&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;go-zero&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于大多数朋友一进入公司就开始了&lt;code&gt;crud&lt;/code&gt;，使用的&lt;code&gt;web&lt;/code&gt;框架、&lt;code&gt;rpc&lt;/code&gt;框架也都是企业已经搭建好的，直接就拿来用了，很少有机会参与到如何设计一个&lt;code&gt;web&lt;/code&gt;框架、&lt;code&gt;rpc&lt;/code&gt;框架之中，但是面试中面试官还爱考查这些东西，所以就需要我们平常多关注如何设计一款高性能的企业框架，&lt;code&gt;go-zero&lt;/code&gt;就一款企业框架，我们可以从中学习到值得借鉴的的设计；&lt;code&gt;go-zero&lt;/code&gt;集成了&lt;code&gt;web&lt;/code&gt;和&lt;code&gt;rpc&lt;/code&gt;框架，是在&lt;code&gt;20&lt;/code&gt;年由好未来开源的一款微服务框架，由于&lt;code&gt;go-zero&lt;/code&gt;项目还是比较大的，建议大家带着目的性去学习，比如我想了解微服务注册与发现的原理实现、自适应负载均衡算法原理与实现，这样我们就可以带着目的性去查阅源码，总结学习文档并把它摘要出来形成自己的东西，写在简历上吹吹水他不香嘛！！！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;go-zero&lt;/code&gt;的文档体系还不是很完善，一些知识点的学习还需要大家自己去总结提炼。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目地址：https://github.com/zeromicro/go-zero/blob/master/readme-cn.md&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;go-nsq&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;NSQ&lt;/code&gt;是一个基于Go语言的分布式实时消息平台，可用于大规模系统中的实时消息服务，并且每天能够处理数亿级别的消息，其设计目标是为在分布式环境下运行的去中心化服务提供一个强大的基础架构。他的强大就不必多说了，我推荐这个项目的原因是让大家去学习&lt;code&gt;nsq&lt;/code&gt;是如何设计的，使用起来是简单的，但是如何设计才是重点，面试中如果让你设计一个高性能的实时消息平台，你知道该如何设计吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目地址：https://github.com/nsqio/go-nsq&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;学习地址：https://cloud.tencent.com/developer/article/1735996&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Tidb&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Tidb&lt;/code&gt;是&lt;code&gt;NewSQL&lt;/code&gt;行业中的代表性产品，由&lt;code&gt;PingCAP&lt;/code&gt;公司自主设计、研发的开源分布式关系型数据库，兼容MySQL 5.7 协议和 MySQL 生态等重要特性。目前很多公司都在使用&lt;code&gt;Tidb&lt;/code&gt;，解决了关系型数据库、弹性扩展以及全球分布的问题。&lt;code&gt;Tidb&lt;/code&gt;采用&lt;code&gt;Go&lt;/code&gt;语言开发&lt;code&gt;SQL&lt;/code&gt;层，下边的分布式存储引擎使用&lt;code&gt;rust&lt;/code&gt;语言，使用&lt;code&gt;Tidb&lt;/code&gt;具有以下优势：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;支持弹性的扩缩容；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;支持 SQL，兼容大多数 MySQL 的语法，在大多数场景下可以直接替换 MySQL；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;默认支持高可用，自动进行数据修复和故障转移；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;支持 ACID 事务；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果大家熟悉&lt;code&gt;Tidb&lt;/code&gt;的设计与实现，可以写到简历上，和面试官吹吹水！！！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目地址：https://github.com/pingcap/tidb&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文档地址：https://docs.pingcap.com/zh/tidb/stable&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;kubernetes&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一提到云原生就提不开&lt;code&gt;kubernetes&lt;/code&gt;，现在各个企业都在上云原生，那么我们每个人都要理解&lt;code&gt;kubernetes&lt;/code&gt;，即使你是一名业务开发，不会一点&lt;code&gt;kubernetes&lt;/code&gt;都不太好意思出去面试，这是一个必备技能。&lt;code&gt;Kubernetes&lt;/code&gt; 是一个可移植的、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。&lt;code&gt;Kubernetes&lt;/code&gt; 拥有一个庞大且快速增长的生态系统；&lt;code&gt;Kubernetes&lt;/code&gt;由于是&lt;code&gt;Go&lt;/code&gt;语言编写，我们可以从源码开始学习，配合着官方文档，仔细专研一番，找个&lt;code&gt;kubernetes&lt;/code&gt;相关的工作不久起飞了，现在很多做&lt;code&gt;kubernetes&lt;/code&gt;方向的朋友也都是由业务开发转去的，朋友们还不赶快学习来！！！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目地址：https://github.com/kubernetes/kubernetes&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官网文档：https://kubernetes.io/docs/home/&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;中文文档：https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推荐看英文文档，中文文档有些地方翻译过来有点难理解。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Prometheus&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Prometheus&lt;/code&gt; 是&lt;code&gt;Cloud Native Computing Foundation&lt;/code&gt; 的一个项目，是一个系统和服务监控系统。它以给定的时间间隔从配置的目标收集指标，评估规则表达式，显示结果，并可以在观察到指定条件时触发警报。现在企业基本都使用&lt;code&gt;Prometheus&lt;/code&gt;做监控上报，但是你知道他的工作原理是怎样的吗？已经工作的朋友不要只停留在使用阶段了，其核心原理我们还是要花点时间研究一下的，一样可以在面试中和面试官吹水。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目地址：https://github.com/prometheus/prometheus&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文档地址：https://prometheus.io/blog/&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文我们针对有无工作经验的朋友们推荐了几个优质的开源项目，有些项目已经广泛在企业中应用，其实现原理需要我们深究，真正做到知其所以然，才能做到和面试官的侃侃而谈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;好啦，本文到这里就结束了，我是&lt;code&gt;asong&lt;/code&gt;，我们下期见。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;创建了读者交流群，欢迎各位大佬们踊跃入群，一起学习交流。入群方式：关注公众号获取。更多学习资料请到公众号领取。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkyNzI1NzM5NQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/CqB2u93NwB96zTfSmymj9jWokyhvSIXMRcLRAfFJsrB4uz6HBsml4T6iaia3yyCSB4aicX97icT7xBUCgw4O1PsKFQ/0?wx_fmt=png&quot; data-nickname=&quot;Golang梦工厂&quot; data-alias=&quot;AsongDream&quot; data-signature=&quot;asong是一名后端程序员，目前就职于一家电商公司，专注于Golang技术，定期分享Go语言、MySQL、Redis、Elasticsearch、计算机基础、微服务架构设计、面试等知识。这里不仅有技术，还有故事！&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3ba388ae29f5d1c2c895627aa9ff8990</guid>
<title>我好像发现了一个 Go 的 Bug？</title>
<link>https://toutiao.io/k/z2el6ey</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;从一次重构说起&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这事儿还得从一次重构优化说起。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近在重构一个路由功能，由于路由比较复杂，需求变化也多，于是想通过&lt;code&gt;责任链模式&lt;/code&gt;来重构，刚好这段时间也在 &lt;code&gt;Sentinel-Go&lt;/code&gt; 中看到相关源码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用责任链模式，最大的好处是可以针对每次请求灵活地插拔路由能力，如：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.45845697329376855&quot; data-type=&quot;png&quot; data-w=&quot;1348&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0Sgysc8wUgaHwgaxhnO96NzzqaNNQzTum71czfudicmqibSPvdhvkA3kKg7RZ3ycNHdF8TAlR7a65kg/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样实现会在每次请求到来时去&lt;code&gt;new&lt;/code&gt; 出整个责任链，可以预见对象会频繁的创建、销毁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对 Java 来说，对象池并不推荐，除非对象的创建特别费力，像一个&lt;code&gt;连接对象&lt;/code&gt;，否则线程之间的锁竞争绝对比直接分配内存的消耗要多的多~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但 Go 不一样，它内置的 &lt;code&gt;sync.Pool&lt;/code&gt; 配合调度模型（GMP）能够刚好规避这种锁竞争。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家知道 Go 的对象池很牛逼就行了，具体原理不是本文重点，也不是一两句话能解释的清楚，有机会再写一篇文章详细说道~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但理论归理论，是骡子是马，得拉出来遛遛才知道是不是真的牛逼~&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9886363636363636&quot; data-type=&quot;jpeg&quot; data-w=&quot;440&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/xacdaKuBM0Sgysc8wUgaHwgaxhnO96NzH2N9hU50ibRGZCQpnEcTpptQOoeesvAqeAXhupgtHnTEHqUbwpyjLjQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Benchmark 超时！&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试这种性能，Benchmark 肯定是首选，于是我写了两个例子来对比，直接 New 对象和使用 sync.Pool 池化对象。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkPooledObject&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; b.RunParallel(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(pb *testing.PB)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; pb.Next() {&lt;br/&gt;   object := pool.Get().(*MyObject)&lt;br/&gt;   Consume(object)&lt;br/&gt;   &lt;span&gt;// 用完了放回对象池&lt;/span&gt;&lt;br/&gt;   object.Reset()&lt;br/&gt;   pool.Put(object)&lt;br/&gt;  }&lt;br/&gt; })&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkNewObject&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; b.RunParallel(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(pb *testing.PB)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; pb.Next() {&lt;br/&gt;   object := &amp;amp;MyObject{&lt;br/&gt;    Name: &lt;span&gt;&quot;hello&quot;&lt;/span&gt;,&lt;br/&gt;    Age:  &lt;span&gt;2&lt;/span&gt;,&lt;br/&gt;   }&lt;br/&gt;   Consume(object)&lt;br/&gt;  }&lt;br/&gt; })&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当时是这些测试参数&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go &lt;span&gt;test&lt;/span&gt; -bench=. -cpu=4 -count=2 -benchtime=10s&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;跑出了如下结果，似乎还是直接 New 对象更快，这和理论不符合啊！&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;BenchmarkPooledObject-4         1000000000               6.25 ns/op&lt;br/&gt;BenchmarkNewObject-4            1000000000               0.374 ns/op&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是就想，是不是我测试的方法哪里不太对？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;池化技术能减少对象的创建、销毁的消耗，有很大一部分得益于减少 GC 次数，是不是我这只跑了10s，还没开始 GC ？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是我查了下，什么时候 Go 会触发 GC，得到了如下的答案：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;主动调用 &lt;code&gt;runtime.GC&lt;/code&gt; 来触发&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;被动触发，分为两种：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;超过2分钟没有触发，则强制触发 GC&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内存增长达到一定比例，触发 GC，比如初始化堆大小为4MB，当增长 25%时，即5MB 时触发一次GC&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然主动触发不合适，被动触发没法确认增长比例，那只能依靠2分钟强制触发 GC 来达到目的了，于是我把基础测试的时间加长，改成了  &lt;code&gt;-benchtime=150s&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行后，就去泡了杯茶，上了个厕所...过了很久，终于执行完了，结果却是这样的结局：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;*** Test killed with quit: ran too long (11m0s).&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行失败了，而且还执行了11分钟~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我搜索了下这个报错，网上说的是，Go 的单元测试和 Benchmark 都有超时时间，默认是10分钟，可以通过 &lt;code&gt;-timeout&lt;/code&gt; 来修改。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这不是重点，重点是为啥我设置了150s，却执行了11分钟？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/xacdaKuBM0Sgysc8wUgaHwgaxhnO96Nz9AVpJwlDTvWylbhAGMF3VXcOHibTkmlOo8xyqznSvefT4ao2icxPNYxg/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;源码之下没有秘密&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直觉告诉我这事不简单，要么是我错了，要么是 Go 错了~ 幸好 Go 是开源的，源码之下没有秘密。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 Debug 和代码查阅后，先是找到了这段代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(b *B)&lt;/span&gt; &lt;span&gt;runN&lt;/span&gt;&lt;span&gt;(n &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; benchmarkLock.Lock()&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; benchmarkLock.Unlock()&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; b.runCleanup(normalPanic)&lt;br/&gt; &lt;span&gt;// 注意看这里，帮我们GC了&lt;/span&gt;&lt;br/&gt; runtime.GC()&lt;br/&gt; b.raceErrors = -race.Errors()&lt;br/&gt; b.N = n&lt;br/&gt; b.parallelism = &lt;span&gt;1&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// 重置计时器&lt;/span&gt;&lt;br/&gt; b.ResetTimer()&lt;br/&gt; &lt;span&gt;// 开始计时&lt;/span&gt;&lt;br/&gt; b.StartTimer()&lt;br/&gt; &lt;span&gt;// 执行 benchmark 方法 &lt;/span&gt;&lt;br/&gt; b.benchFunc(b)&lt;br/&gt; &lt;span&gt;// 停止计时&lt;/span&gt;&lt;br/&gt; b.StopTimer()&lt;br/&gt; b.previousN = n&lt;br/&gt; b.previousDuration = b.duration&lt;br/&gt; b.raceErrors += race.Errors()&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; b.raceErrors &amp;gt; &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;  b.Errorf(&lt;span&gt;&quot;race detected during execution of benchmark&quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码是在执行一次我们定义的 Benchmark 方法，n 就是传入到我们定义方法参数的 &lt;code&gt;*testing.B&lt;/code&gt; 结构中的一个属性。而且它计算的时间也非常合理，只计算了执行我们定义方法的时间，也就是 &lt;code&gt;-benchtime&lt;/code&gt; 的时间只是函数执行的时间，Benchmark 框架的耗时不计算在内。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更合理的是，框架在执行方法前，还帮我们触发了一次 GC，也就是说，只有我们的函数在执行的时候产生的内存垃圾才算到我们的 Benchmark 时间中，非常严谨。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这跟我们的执行失败毫无关系~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但从一个侧面来说，Benchmark 执行的总时间一定是大于 &lt;code&gt;-benchtime&lt;/code&gt; 设置的时间的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;真的是这样吗？我做了两组实验，就打破了这个规律：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go test -bench=. -cpu=4 -count=1 -benchtime=5s&lt;br/&gt; &lt;br/&gt;BenchmarkPooledObject-4         793896368                7.65 ns/op&lt;br/&gt;BenchmarkNewObject-4            1000000000               0.378 ns/op&lt;br/&gt;PASS&lt;br/&gt;ok      all-in-one/go-in-one/samples/object_pool        7.890s&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go test -bench=. -cpu=4 -count=1 -benchtime=10s&lt;br/&gt;&lt;br/&gt;BenchmarkPooledObject-4         1000000000               7.16 ns/op&lt;br/&gt;BenchmarkNewObject-4            1000000000               0.376 ns/op&lt;br/&gt;PASS&lt;br/&gt;ok      all-in-one/go-in-one/samples/object_pool        8.508s&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二组设置了执行 10s，但总的测试时间只有8.508s，很奇怪，更奇怪的是测试结果的第二列执行次数，他们居然都是 1000000000，这么巧吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;带着疑问，找到了 Benchmark 的这段核心代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(b *B)&lt;/span&gt; &lt;span&gt;launch&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   ...&lt;br/&gt; &lt;span&gt;// 标注①&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; b.benchTime.n &amp;gt; &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// We already ran a single iteration in run1.&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// If -benchtime=1x was requested, use that result.&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; b.benchTime.n &amp;gt; &lt;span&gt;1&lt;/span&gt; {&lt;br/&gt;   b.runN(b.benchTime.n)&lt;br/&gt;  }&lt;br/&gt; } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  d := b.benchTime.d&lt;br/&gt;   &lt;span&gt;// 标注②&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; n := &lt;span&gt;int64&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;); !b.failed &amp;amp;&amp;amp; b.duration &amp;lt; d &amp;amp;&amp;amp; n &amp;lt; &lt;span&gt;1e9&lt;/span&gt;; {&lt;br/&gt;   last := n&lt;br/&gt;   goalns := d.Nanoseconds()&lt;br/&gt;   prevIters := &lt;span&gt;int64&lt;/span&gt;(b.N)&lt;br/&gt;   prevns := b.duration.Nanoseconds()&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; prevns &amp;lt;= &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;    prevns = &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;    &lt;span&gt;// 标注③&lt;/span&gt;&lt;br/&gt;   n = goalns * prevIters / prevns&lt;br/&gt;   &lt;span&gt;// Run more iterations than we think we&#x27;ll need (1.2x).&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;// 标注④&lt;/span&gt;&lt;br/&gt;   n += n / &lt;span&gt;5&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;// Don&#x27;t grow too fast in case we had timing errors previously.&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;// 标注⑤&lt;/span&gt;&lt;br/&gt;   n = min(n, &lt;span&gt;100&lt;/span&gt;*last)&lt;br/&gt;   &lt;span&gt;// Be sure to run at least one more than last time.&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;// 标注⑥&lt;/span&gt;&lt;br/&gt;   n = max(n, last+&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;   &lt;span&gt;// Don&#x27;t run more than 1e9 times. (This also keeps n in int range on 32 bit platforms.)&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;// 标注⑦&lt;/span&gt;&lt;br/&gt;   n = min(n, &lt;span&gt;1e9&lt;/span&gt;)&lt;br/&gt;   &lt;span&gt;// 标注⑧&lt;/span&gt;&lt;br/&gt;   b.runN(&lt;span&gt;int&lt;/span&gt;(n))&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt; b.result = BenchmarkResult{b.N, b.duration, b.bytes, b.netAllocs, b.netBytes, b.extra}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;核心都标了序号，这里来解释下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;标注①&lt;/strong&gt;：Go 的 Benchmark 执行两种传参，执行次数和执行时间限制，我用的是执行时间，也可以用 &lt;code&gt;-benchtime=1000x&lt;/code&gt;来表示需要测试1000次。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;标注②&lt;/strong&gt;：这里是当设置了执行时间限制时，判断时间是否足够的条件，可以看到除了时间的判断外，还有 &lt;code&gt;n &amp;lt; 1e9&lt;/code&gt; 的限制，也就是最多执行次数是 &lt;code&gt;1e9&lt;/code&gt;，也就是 1000000000，这解释了上面的一个困惑，为啥执行时间还比设置的 benchtime 小。因为 Go 限制了最大执行次数为 1e9，并不是设置多少就是多少，还有个上限。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;标注③到⑧&lt;/strong&gt;:
Go 是如何知道 n 取多少时，时间刚好符合我们设置的 &lt;code&gt;benchtime&lt;/code&gt;？答案是试探！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;n 从1 开始试探，执行1次后，根据执行时间来估算 n。&lt;code&gt;n = goalns * prevIters / prevns&lt;/code&gt;，这就是估算公式，goalns 是设置的执行时间（单位纳秒），prevIters 是上次执行次数，prevns 是上一次执行时间（纳秒）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据上次执行的时间和目标设定的执行总时间，计算出需要执行的次数，大概是这样吧：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;目标执行次数 = 执行目标时间 / (上次执行时间 / 上次执行次数)&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;化简下得到：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;目标执行次数 = 执行目标时间 * 上次执行次数 / 上次执行时间&lt;/code&gt;，这不就是上面那个公式~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目标执行次数 n 的计算，源码中还做了一些其他处理：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;标注④：让实际执行次数大概是目标执行次数的&lt;code&gt;1.2&lt;/code&gt;倍，万一达不到目标时间不是有点尴尬？索性多跑一会&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;标注⑤：也不能让 n 增长的太快了，设置个最大增长幅度为100倍，当 n 增长太快时，被测试方法一定是执行时间很短，误差可能较大，缓慢增长好测出真实的水平&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;标注⑥：n 不能原地踏步，怎么也得+1&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;标注⑦：n 得设置个 1e9 的上限，这是为了在32位系统上不要溢出&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go Benchmark 的执行原理大致摸清了，但我们要的答案还未浮出水面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着我对 Benchmark 进行了断点调试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先是 &lt;code&gt;-benchtime=10s&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发现 n 的试探增长是 1，100，10000，1000000，100000000，1000000000，最终 n 是 1000000000&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这说明我们的执行方法耗时很短，执行次数达到了上限。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再看&lt;code&gt;-benchtime=150s&lt;/code&gt;，开始还挺正常：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;n 增长是 1，100，10000，1000000，100000000，但后一个出现了问题：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8748114630467572&quot; data-type=&quot;png&quot; data-w=&quot;1326&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0Sgysc8wUgaHwgaxhnO96NzezfOGy1z5rM17lREPezBicjGEiaM2OMbFqxkrzZhyXiax0p0LcZ55FKZA/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;n 居然变成了负数！显然这是溢出了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;n = goalns * prevIters / prevns 这个公式，在目标执行时间（goalns）很大，测试方法执行时间（prevns）很短时，会导致 n 溢出！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;溢出有什么后果呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后面的 &lt;code&gt;n = min(n, 100*last)&lt;/code&gt; 永远等于 100000000 了，但还有 &lt;code&gt;n = max(n, last+1)&lt;/code&gt; 保证，所以 n 还是在增加，不过很慢，每次都只 +1，所以后续试探的 n 序列为 100000001，100000002，100000003....&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就导致了 n 很难达到 1e9 的上限，而且总的执行耗时也很难达到设定的预期时间，所以测试程序会一直跑~直到超时！&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;这大概是一个Bug吧？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写这段 Benchamrk 逻辑的作者加入了这个 1e9 的执行次数上限，考虑了溢出，但没有考虑 n 在计算过程中的溢出情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我觉得这应该是一个 Bug，但不能完全确定。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网上没有找到相关的 Bug 报告，于是去给 Go 官方提了 issue 和相应的修复代码，由于 Go 的开发流程比较复杂和漫长，所以在本文发表时，官方并没有明确表明这是 Bug 还是其他。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果后续官方有回复或其他变故，我再来告诉大家~&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;搜索关注微信公众号&quot;捉虫大师&quot;，后端技术分享，架构设计、性能优化、源码阅读、问题排查、踩坑实践。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/xacdaKuBM0Sgysc8wUgaHwgaxhnO96Nzsse7nrwpkDRL7ynIX9RibYV329qVge6gZVTpAhmJB3F5mQktcqOvIdA/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4d57a1a95c6e3955a61825fc71b3a601</guid>
<title>关于小程序的一切，读这一篇就够了</title>
<link>https://toutiao.io/k/1i0tnxr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;h1&gt;&lt;strong&gt;1. 小程序发展史&lt;/strong&gt;&lt;/h1&gt;&lt;h2&gt;&lt;strong&gt;1.1 Native App&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;在智能机刚兴起的时代，网络还不是很发达，网页浏览速度也很慢，以文字为主。市面上的应用以 Native App 为主。&lt;/p&gt;&lt;p&gt;Native App 是基于 iOS 或者安卓的原生应用，特点是开发成本高，迭代慢，但是性能和体验很好，消息推送及时，比如 qq，微信等。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.2761904761904762&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCuJyV0KmAMXTzezibsHBjDaibMvQWGXolONI5dgG3VuHkR1B7qN3iaL5ubvvpUx2Mb82Fy0zPCuh0Anw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;630&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;1.2 H5&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;2014 年 HTML5 完成标准定制，他的设计目的是为了在移动设备上支持多媒体，引入了 Video、Audio 等技术。&lt;/p&gt;&lt;p&gt;在网页上浏览视频变得很方便，特点是开发和发布成本低，打开方便，无需下载到本地，但是性能受浏览器的处理能力的限制，相较于原生 App 来说差了一些，消息推送不及时。&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;1.3 Hybrid App&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;Hybrid App 就是混合式的 App，也就是在移动端原生应用的基础上，通过 JSBrdige 等方法，访问原生应用的 API 进行 JS 的交互，并通过 WebView 等技术实现 HTML 与 CSS 的渲染。&lt;/p&gt;&lt;p&gt;WebView 可以理解为嵌套了一个浏览器内核（比如 webkit）的移动端组件。&lt;/p&gt;&lt;p&gt;这种技术实现的应用一般都是跨平台的，并且维护起来比较容易，性能介于 H5 和原生应用之间。&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;1.4 小程序&lt;/strong&gt;&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;小程序是一种不需要下载安装即可使用的应用，它实现了应用 “触手可及” 的梦想，用户扫一扫或者搜一下即可打开应用。也体现了 “用完即走” 的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无需安装卸载。—— 百度百科&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;自 2017 年 1 月微信小程序正式发布以来，目前互联网上已经有多种小程序：&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;&lt;strong&gt;微信小程序&lt;/strong&gt;&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;&lt;strong&gt;百度智能小程序&lt;/strong&gt;&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;&lt;strong&gt;支付宝小程序&lt;/strong&gt;&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;&lt;strong&gt;QQ 小程序&lt;/strong&gt;&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.7786666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCuJyV0KmAMXTzezibsHBjDaib5D0g7Y9qicxLIS5xy1f8CGyuAsNlFe0DVDu9iaNaf7ia2ACBv1sh1KMVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;103&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;183&quot; data-ratio=&quot;1.7777777777777777&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCuJyV0KmAMXTzezibsHBjDaibamQVqoUAhicKBdjujkpva6Lcwvy3S8dDZpD4R2UtL1ePyEicvP2bWAVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;360&quot;/&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.9532908704883227&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCuJyV0KmAMXTzezibsHBjDaibibqlLCkZ3h6fCAuiaJE5Xkler2OxUtTrH72tgTPPExcJLWF5bthpvYXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;942&quot;/&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;2.1642512077294684&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCuJyV0KmAMXTzezibsHBjDaibBWibp4EX3HSviaaNz5ib0ANGyZu0PFdst77eGKH925dM6Fr2DFDmVyofQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;828&quot;/&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;2017.1&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;2018.7&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;2018.9&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;2019.6&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;基于小程序几乎相同的技术原理，以及小程序的方便快捷的特性，还衍生出了多款小程序，比如抖音小程序、快手小程序、京东小程序、美团小程序等，帮助各大厂商更好的为用户提供便捷的服务。&lt;/p&gt;&lt;p&gt;2018 年微信小程序 “跳一跳” 爆火，记得当年食堂排队打饭的时候很多同学都在玩，助力了微信小程序在用户中的扩张，也激发了其他厂商开发小程序的热潮。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.48515625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCuJyV0KmAMXTzezibsHBjDaibeTNOCicrrtGBwWA0edPh9MJnAdyOg9Uddd3MrO53E1fMLykuEibM8JzA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h1&gt;&lt;strong&gt;2. 原理分析&lt;/strong&gt;&lt;/h1&gt;&lt;h2&gt;&lt;strong&gt;2.1 双线程模型&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;无论是微信小程序还是支付宝小程序还是百度智能小程序等等，他们的总体架构都是基于双线程的。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;322&quot; data-ratio=&quot;0.5563829787234043&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xsw6Lt5pDCuJyV0KmAMXTzezibsHBjDaibBibY52hsdqhM0tcL6XeR9Ab9P9vtRtsuHLbicSvriasaWt1MFMzPsF9gQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;940&quot;/&gt;&lt;/p&gt;&lt;p&gt;其中用于处理业务逻辑的 JS 代码运行在单独的线程里，渲染层（template、css）则运行在另外一个单独的线程里。&lt;/p&gt;&lt;p&gt;以微信小程序为例：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.27890625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCuJyV0KmAMXTzezibsHBjDaib6ibudfC7GjuTNHuBzmdxvVBx1FAtVbpibnicy6XO9aEGCbNVMXtZh4ichQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;双线程模型不同于单线程模型，逻辑层与渲染层的数据交互需要通过 JSBridge，二者是通过发布订阅，基于当前比较比较著名的 MVVM，来实现数据的双向绑定的，从而实现数据通信。&lt;/p&gt;&lt;p&gt;这样我们在微信小程序中通过在逻辑层中 setData 来改变 Model 层的数据就能够实现视图数据的异步更新。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7888198757763976&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCuJyV0KmAMXTzezibsHBjDaibc1ljHdEicEsfnFYjlA4yS58p83ribWVzlv6ABgKYO6yC2hhXFGmbWicxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;483&quot;/&gt;&lt;/p&gt;&lt;p&gt;以下是微信小程序的生命周期：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.5317220543806647&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCuJyV0KmAMXTzezibsHBjDaibmOBufXBarRVyjyUr6ef0aNJUNAQY7ibG2qYAVttXnLsv4R4WGNjLFiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;662&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;2.2 整体架构&lt;/strong&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.61640625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCuJyV0KmAMXTzezibsHBjDaib6lfGwJud8vcV0iaLZKf9bBWYnhJeibuGqpuaLxqQibSf6WPWHrlN3nR3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;注：以下所有内容均围绕微信开发者工具展开。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;打开微信开发者工具的源代码，他是基于 NW.js 运行的，所以下图中的 package.nw 就是我们要重点钻研的对象：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.565625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCuJyV0KmAMXTzezibsHBjDaibGEiaAm0rnmkJHH2Odpecia8WdIUR2UlNy1NUuJxoaK8S5YyviaFUqFoxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;这里面有很多代码，都是经过混淆与压缩的，将代码在 VSCode 中打开，并安装 Prettier - Code formatter 插件可以实现对源码的格式化。但此时代码中已经不具有语义化的变量了，只能通过 API 大致推断代码是干什么的。&lt;/p&gt;&lt;p&gt;源码中有一个 vendor 文件夹是值得注意的，通过它可以快速新建一个示例项目，同时里面有一个十分重要的 &lt;strong&gt;2.17.0.wxvpkg&lt;/strong&gt; 包，它是微信小程序的基础库，包含了下文所提及的 WebService 与 WebView 等逻辑层与渲染层的处理。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.7574750830564785&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCuJyV0KmAMXTzezibsHBjDaibtibXjeCyUwV5mWicdxicB6MvkU6ve5yNmNtlWfEXD0KeGaXk2Hgs3Cwtw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;602&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;2.2.1 WAWebview&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;小程序视图层基础库，提供视图层的基础能力：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; __wxLibrary = {&lt;br/&gt;  &lt;span&gt;fileName&lt;/span&gt;: &lt;span&gt;&#x27;WAWebview.js&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;envType&lt;/span&gt;: &lt;span&gt;&#x27;WebView&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;contextType&lt;/span&gt;: &lt;span&gt;&#x27;others&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;execStart&lt;/span&gt;: &lt;span&gt;Date&lt;/span&gt;.now()&lt;br/&gt;};&lt;br/&gt;&lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; __WAWebviewStartTime__ = &lt;span&gt;Date&lt;/span&gt;.now();&lt;br/&gt;&lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; __libVersionInfo__ = {&lt;br/&gt;  &lt;span&gt;&quot;updateTime&quot;&lt;/span&gt;: &lt;span&gt;&quot;2020.4.4 10:25:02&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;version&quot;&lt;/span&gt;: &lt;span&gt;&quot;2.10.4&quot;&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * core-js 模块&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;!&lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;n, o, Ye&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  ...&lt;br/&gt;  }, &lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;e, t, i&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; n = i(&lt;span&gt;3&lt;/span&gt;),&lt;br/&gt;      o = &lt;span&gt;&quot;__core-js_shared__&quot;&lt;/span&gt;,&lt;br/&gt;      r = n[o] || (n[o] = {});&lt;br/&gt;    e.exports = &lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;e&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/span&gt; r[e] || (r[e] = {})&lt;br/&gt;    }&lt;br/&gt;  ...&lt;br/&gt;}(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; __wxConfig;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; __wxTest__ = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; wxRunOnDebug = &lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;e&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  e()&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 基础模块&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; Foundation = &lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;i&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  ...&lt;br/&gt;}]).default;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; nativeTrans = &lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;e&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  ...&lt;br/&gt;}(&lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 消息通信模块&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; WeixinJSBridge = &lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;e&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  ...&lt;br/&gt;}(&lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 监听 nativeTrans 相关事件&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;!&lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;() &lt;/span&gt;{&lt;br/&gt;  ...&lt;br/&gt;}();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 解析配置&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;!&lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;r&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  ...&lt;br/&gt;  __wxConfig = _(__wxConfig), __wxConfig = v(__wxConfig), Foundation.onConfigReady(&lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;() &lt;/span&gt;{&lt;br/&gt;    m()&lt;br/&gt;  }), n ? __wxConfig.__readyHandler = A : d ? Foundation.onBridgeReady(&lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;() &lt;/span&gt;{&lt;br/&gt;    WeixinJSBridge.on(&lt;span&gt;&quot;onWxConfigReady&quot;&lt;/span&gt;, A)&lt;br/&gt;  }) : Foundation.onLibraryReady(A)&lt;br/&gt;}(&lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 异常捕获（error、onunhandledrejection）&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;!&lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;e&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt; &lt;span&gt;&lt;strong&gt;t&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;e&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    Foundation.emit(&lt;span&gt;&quot;unhandledRejection&quot;&lt;/span&gt;, e) || &lt;span&gt;console&lt;/span&gt;.error(&lt;span&gt;&quot;Uncaught (in promise)&quot;&lt;/span&gt;, e.reason)&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;&quot;object&quot;&lt;/span&gt; == &lt;span&gt;&lt;strong&gt;typeof&lt;/strong&gt;&lt;/span&gt; e &amp;amp;&amp;amp; &lt;span&gt;&quot;function&quot;&lt;/span&gt; == &lt;span&gt;&lt;strong&gt;typeof&lt;/strong&gt;&lt;/span&gt; e.addEventListener ? (e.addEventListener(&lt;span&gt;&quot;unhandledrejection&quot;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;e&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    t({&lt;br/&gt;      &lt;span&gt;reason&lt;/span&gt;: e.reason,&lt;br/&gt;      &lt;span&gt;promise&lt;/span&gt;: e.promise&lt;br/&gt;    }), e.preventDefault()&lt;br/&gt;  }), e.addEventListener(&lt;span&gt;&quot;error&quot;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;e&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; t;&lt;br/&gt;    t = e.error, Foundation.emit(&lt;span&gt;&quot;error&quot;&lt;/span&gt;, t) || &lt;span&gt;console&lt;/span&gt;.error(&lt;span&gt;&quot;Uncaught&quot;&lt;/span&gt;, t), e.preventDefault()&lt;br/&gt;  })) : &lt;span&gt;&lt;strong&gt;void&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt; === e.onunhandledrejection &amp;amp;&amp;amp; &lt;span&gt;Object&lt;/span&gt;.defineProperty(e, &lt;span&gt;&quot;onunhandledrejection&quot;&lt;/span&gt;, {&lt;br/&gt;    &lt;span&gt;value&lt;/span&gt;: &lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;e&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;      t({&lt;br/&gt;        &lt;span&gt;reason&lt;/span&gt;: (e = e || {}).reason,&lt;br/&gt;        &lt;span&gt;promise&lt;/span&gt;: e.promise&lt;br/&gt;      })&lt;br/&gt;    }&lt;br/&gt;  })&lt;br/&gt;}(&lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 原生缓冲区&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; NativeBuffer = &lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;e&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  ...&lt;br/&gt;}(&lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; WeixinNativeBuffer = NativeBuffer;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; NativeBuffer = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 日志模块：wxConsole、wxPerfConsole、wxNativeConsole、__webviewConsole__&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; wxConsole = [&lt;span&gt;&quot;log&quot;&lt;/span&gt;, &lt;span&gt;&quot;info&quot;&lt;/span&gt;, &lt;span&gt;&quot;warn&quot;&lt;/span&gt;, &lt;span&gt;&quot;error&quot;&lt;/span&gt;, &lt;span&gt;&quot;debug&quot;&lt;/span&gt;, &lt;span&gt;&quot;time&quot;&lt;/span&gt;, &lt;span&gt;&quot;timeEnd&quot;&lt;/span&gt;, &lt;span&gt;&quot;group&quot;&lt;/span&gt;, &lt;span&gt;&quot;groupEnd&quot;&lt;/span&gt;].reduce(&lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;e, t&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/span&gt; e[t] = &lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;() &lt;/span&gt;{}, e&lt;br/&gt;}, {});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; wxPerfConsole = [&lt;span&gt;&quot;log&quot;&lt;/span&gt;, &lt;span&gt;&quot;info&quot;&lt;/span&gt;, &lt;span&gt;&quot;warn&quot;&lt;/span&gt;, &lt;span&gt;&quot;error&quot;&lt;/span&gt;, &lt;span&gt;&quot;time&quot;&lt;/span&gt;, &lt;span&gt;&quot;timeEnd&quot;&lt;/span&gt;, &lt;span&gt;&quot;trace&quot;&lt;/span&gt;, &lt;span&gt;&quot;profile&quot;&lt;/span&gt;, &lt;span&gt;&quot;profileSync&quot;&lt;/span&gt;].reduce(&lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;e, t&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/span&gt; e[t] = &lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;() &lt;/span&gt;{}, e&lt;br/&gt;}, {});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; wxNativeConsole = &lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;i&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  ...&lt;br/&gt;}([&lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;e, t, i&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  ...&lt;br/&gt;}]).default;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; __webviewConsole__ = &lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;i&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  ...&lt;br/&gt;}([&lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;e, t, i&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  ...&lt;br/&gt;}]);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 上报模块&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; Reporter = &lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;i&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  ...&lt;br/&gt;}([&lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;e, L, O&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  ...&lt;br/&gt;}]).default;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; Perf = &lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;i&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  ...&lt;br/&gt;}([&lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;e, t, i&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  ...&lt;br/&gt;}]).default;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 视图层 API&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; __webViewSDK__ = &lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;i&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  ...&lt;br/&gt;}([&lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;e, L, O&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  ...&lt;br/&gt;}]).default;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; wx = __webViewSDK__.wx;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 组件系统&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; exparser = &lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;i&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  ...&lt;br/&gt;}([&lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;e, t, i&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  ...&lt;br/&gt;}]);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 框架粘合层&lt;br/&gt; * &lt;br/&gt; * 使用 exparser.registerBehavior 和 exparser.registerElement 方法注册内置组件&lt;br/&gt; * 转发 window、wx 对象上到事件转发到 exparser&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;!&lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;i&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  ...&lt;br/&gt;}([&lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;e, t&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  ...&lt;br/&gt;}, &lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;e, t&lt;/span&gt;) &lt;/span&gt;{}, , &lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;e, t&lt;/span&gt;) &lt;/span&gt;{}]);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * Virtual DOM &lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; __virtualDOMDataThread__ = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; __virtualDOM__ = &lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;i&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  ...&lt;br/&gt;}([&lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;e, t, i&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  ...&lt;br/&gt;}]);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * __webviewEngine__&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; __webviewEngine__ = &lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;i&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  ...&lt;br/&gt;}([&lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;e, t, i&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  ...&lt;br/&gt;}]);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 注入默认样式到页面&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;!&lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;() &lt;/span&gt;{&lt;br/&gt;  ...&lt;br/&gt;  &lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt; &lt;span&gt;&lt;strong&gt;e&lt;/strong&gt;&lt;/span&gt;() &lt;/span&gt;{&lt;br/&gt;     &lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; e = i(&lt;span&gt;&#x27;...&#x27;&lt;/span&gt;);&lt;br/&gt;    __wxConfig.isReady ? &lt;span&gt;&lt;strong&gt;void&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt; !== __wxConfig.theme &amp;amp;&amp;amp; i(t, e.nextElementSibling) : __wxConfig.onReady(&lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;() &lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;&lt;strong&gt;void&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt; !== __wxConfig.theme &amp;amp;&amp;amp; i(t, e.nextElementSibling)&lt;br/&gt;    })&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;window&lt;/span&gt;.document &amp;amp;&amp;amp; &lt;span&gt;&quot;complete&quot;&lt;/span&gt; === &lt;span&gt;window&lt;/span&gt;.document.readyState ? e() : &lt;span&gt;window&lt;/span&gt;.onload = e&lt;br/&gt;}();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; __WAWebviewEndTime__ = &lt;span&gt;Date&lt;/span&gt;.now();&lt;br/&gt;&lt;span&gt;&lt;strong&gt;typeof&lt;/strong&gt;&lt;/span&gt; __wxLibrary.onEnd === &lt;span&gt;&#x27;function&#x27;&lt;/span&gt; &amp;amp;&amp;amp; __wxLibrary.onEnd();&lt;br/&gt;__wxLibrary = &lt;span&gt;undefined&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;WAWebview 主要由以下几个部分组件：&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;Foundation&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：基础模块&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;WeixinJSBridge&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：消息通信模块&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;exparser&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：组件系统模块&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;__virtualDOM__&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：Virtual DOM 模块&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;__webViewSDK__&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：WebView SDK 模块&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;Reporter&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：日志上报模块 (异常和性能统计数据)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;h3&gt;&lt;strong&gt;2.2.2 WAService&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;小程序逻辑层基础库，提供逻辑层基础能力：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; __wxLibrary = {&lt;br/&gt;  &lt;span&gt;fileName&lt;/span&gt;: &lt;span&gt;&#x27;WAService.js&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;envType&lt;/span&gt;: &lt;span&gt;&#x27;Service&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;contextType&lt;/span&gt;: &lt;span&gt;&#x27;App:Uncertain&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;execStart&lt;/span&gt;: &lt;span&gt;Date&lt;/span&gt;.now()&lt;br/&gt;};&lt;br/&gt;&lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; __WAServiceStartTime__ = &lt;span&gt;Date&lt;/span&gt;.now();&lt;br/&gt;&lt;br/&gt;(&lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;global&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; __exportGlobal__ = {};&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; __libVersionInfo__ = {&lt;br/&gt;    &lt;span&gt;&quot;updateTime&quot;&lt;/span&gt;: &lt;span&gt;&quot;2020.4.4 10:25:02&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;version&quot;&lt;/span&gt;: &lt;span&gt;&quot;2.10.4&quot;&lt;/span&gt;&lt;br/&gt;  };&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; __Function__ = &lt;span&gt;global&lt;/span&gt;.Function;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;var &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;Function&lt;/span&gt; = __Function__;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;/**&lt;br/&gt;   * core-js 模块&lt;br/&gt;   */&lt;/span&gt;&lt;br/&gt;  !&lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;r, o, Ke&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  }(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; __wxTest__ = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; wxRunOnDebug = &lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;e&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    e()&lt;br/&gt;  };&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; __wxConfig;&lt;br/&gt;  &lt;span&gt;/**&lt;br/&gt;   * 基础模块&lt;br/&gt;   */&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; Foundation = &lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;n&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;  }([&lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;e, t, n&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;  }]).default;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; nativeTrans = &lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;e&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;  }(&lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;/**&lt;br/&gt;   * 消息通信模块&lt;br/&gt;   */&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; WeixinJSBridge = &lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;e&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;  }(&lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;/**&lt;br/&gt;   * 监听 nativeTrans 相关事件&lt;br/&gt;   */&lt;/span&gt;&lt;br/&gt;  !&lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;() &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;  }();&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;/**&lt;br/&gt;   * 解析配置&lt;br/&gt;   */&lt;/span&gt;&lt;br/&gt;  !&lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;i&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;  }(&lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;/**&lt;br/&gt;   * 异常捕获（error、onunhandledrejection）&lt;br/&gt;   */&lt;/span&gt;&lt;br/&gt;  !&lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;e&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;  }(&lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;/**&lt;br/&gt;   * 原生缓冲区&lt;br/&gt;   */&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; NativeBuffer = &lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;e&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;  }(&lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;  WeixinNativeBuffer = NativeBuffer;&lt;br/&gt;  NativeBuffer = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; wxConsole = [&lt;span&gt;&quot;log&quot;&lt;/span&gt;, &lt;span&gt;&quot;info&quot;&lt;/span&gt;, &lt;span&gt;&quot;warn&quot;&lt;/span&gt;, &lt;span&gt;&quot;error&quot;&lt;/span&gt;, &lt;span&gt;&quot;debug&quot;&lt;/span&gt;, &lt;span&gt;&quot;time&quot;&lt;/span&gt;, &lt;span&gt;&quot;timeEnd&quot;&lt;/span&gt;, &lt;span&gt;&quot;group&quot;&lt;/span&gt;, &lt;span&gt;&quot;groupEnd&quot;&lt;/span&gt;].reduce(&lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;e, t&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/span&gt; e[t] = &lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;() &lt;/span&gt;{}, e&lt;br/&gt;    }, {});&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; wxPerfConsole = [&lt;span&gt;&quot;log&quot;&lt;/span&gt;, &lt;span&gt;&quot;info&quot;&lt;/span&gt;, &lt;span&gt;&quot;warn&quot;&lt;/span&gt;, &lt;span&gt;&quot;error&quot;&lt;/span&gt;, &lt;span&gt;&quot;time&quot;&lt;/span&gt;, &lt;span&gt;&quot;timeEnd&quot;&lt;/span&gt;, &lt;span&gt;&quot;trace&quot;&lt;/span&gt;, &lt;span&gt;&quot;profile&quot;&lt;/span&gt;, &lt;span&gt;&quot;profileSync&quot;&lt;/span&gt;].reduce(&lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;e, t&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/span&gt; e[t] = &lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;() &lt;/span&gt;{}, e&lt;br/&gt;  }, {});&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; wxNativeConsole = &lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;n&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;  }([&lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;e, t, n&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;  }]).default;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;/**&lt;br/&gt;   * Worker 模块&lt;br/&gt;   */&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; WeixinWorker = &lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;e&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;  }(&lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;/**&lt;br/&gt;   * JSContext&lt;br/&gt;   */&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; JSContext = &lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;n&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;  }([&lt;br/&gt;    ...&lt;br/&gt;  }]).default;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; __appServiceConsole__ = &lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;n&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;  }([&lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;e, N, R&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;  }]).default;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; Protect = &lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;n&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;  }([&lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;e, t, n&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;  }]);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; Reporter = &lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;n&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;  }([&lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;e, N, R&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;  }]).default;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; __subContextEngine__ = &lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;n&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;  }([&lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;e, t, n&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;  }]);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; __waServiceInit__ = &lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt;() &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;/span&gt; &lt;span&gt;&lt;strong&gt;__doWAServiceInit__&lt;/strong&gt;&lt;/span&gt;() &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; e;&lt;br/&gt;    &lt;span&gt;&quot;undefined&quot;&lt;/span&gt; != &lt;span&gt;&lt;strong&gt;typeof&lt;/strong&gt;&lt;/span&gt; wx &amp;amp;&amp;amp; wx.version &amp;amp;&amp;amp; (e = wx.version), __waServiceInit__(), e &amp;amp;&amp;amp; &lt;span&gt;&quot;undefined&quot;&lt;/span&gt; != &lt;span&gt;&lt;strong&gt;typeof&lt;/strong&gt;&lt;/span&gt; __exportGlobal__ &amp;amp;&amp;amp; __exportGlobal__.wx &amp;amp;&amp;amp; (__exportGlobal__.wx.version = e)&lt;br/&gt;  }&lt;br/&gt;  __subContextEngine__.isIsolateContext();&lt;br/&gt;  __subContextEngine__.isIsolateContext() || __doWAServiceInit__();&lt;br/&gt;  __subContextEngine__.initAppRelatedContexts(__exportGlobal__);&lt;br/&gt;})(&lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; __WAServiceEndTime__ = &lt;span&gt;Date&lt;/span&gt;.now();&lt;br/&gt;&lt;span&gt;&lt;strong&gt;typeof&lt;/strong&gt;&lt;/span&gt; __wxLibrary.onEnd === &lt;span&gt;&#x27;function&#x27;&lt;/span&gt; &amp;amp;&amp;amp; __wxLibrary.onEnd();&lt;br/&gt;__wxLibrary = &lt;span&gt;undefined&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;WAService 基本组成：&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;Foundation&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：基础模块&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;WeixinJSBridge&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：消息通信模块&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;WeixinNativeBuffer&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：原生 Buffer&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;WeixinWorker&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：Worker 线程&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;JSContext&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：JS Engine Context&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;Protect&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：JS 保护的对象&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;__subContextEngine__&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：提供 App、Page、Component、Behavior、getApp、getCurrentPages 等方法&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;h3&gt;&lt;strong&gt;2.2.3 虚拟 DOM&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;微信小程序在 WAService 里面实现了小程序的 &lt;code&gt;__virtualDOM__&lt;/code&gt;，通过 &lt;code&gt;__virtualDOM__&lt;/code&gt; 模块，可以实现 JS 对象到 DOM 对象的映射。&lt;/p&gt;&lt;p&gt;但是这个虚拟 DOM 通过 diff 和 patch 后并不是转换成原生的 DOM 元素，而是微信小程序里面自定义的 DOM 元素，这些 DOM 元素的操作通过 Exparser 模块来统一管理：&lt;/p&gt;&lt;p&gt;在 WAWebview 中包含了所有的 wx 自定义标签：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;2.8534201954397393&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCuJyV0KmAMXTzezibsHBjDaibTFXt6ICpSupqRcgkOsicA4zgPms81gPZO83iaDwr6Qib581qPhjITRpNQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;614&quot;/&gt;&lt;/p&gt;&lt;p&gt;同时，&lt;code&gt;__virtualDOM__&lt;/code&gt; 模块提供了很多的基础 API，比如：&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;（更多的 API 定义可以在 WAService.js 里面去查询）&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;2.2.4 WeiXinJSBridge&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;WeixinJSBridge 提供了视图层 JS 与 Native、视图层与逻辑层之间消息通信的机制，提供了如下几个方法：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7545271629778671&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCuJyV0KmAMXTzezibsHBjDaibE6KAo7iaqX6PLcEG5uej4Z28PQiayz4hvJonJoF0Sku5CGPwOh0eeNicw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;994&quot;/&gt;&lt;/p&gt;&lt;p&gt;里面最重要的便是 on 和 invoke，通过 on 来注册事件，通过 invoke 来触发相应的事件。&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;2.3 微信开发者工具&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;微信开发者工具中的小程序是跑在 NW.js 中的，这里是他的官方 API 文档：&lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxae224e32990b0036&quot; data-miniprogram-type=&quot;text&quot; data-miniprogram-path=&quot;pages/a?link=https%3A%2F%2Fnwjs.readthedocs.io%2Fen%2Flatest%2F&amp;amp;title=&quot; href=&quot;&quot;&gt;https://nwjs.readthedocs.io/en/latest/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;他是基于 &lt;code&gt;Chromium&lt;/code&gt; 和 &lt;code&gt;Node.js&lt;/code&gt; 的，因此我们编译后的虚拟 DOM 转换成真实 DOM 后，通过他来运行。&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;2.3.1 一些反编译技巧&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;我们可以通过开发者工具，在 Devtools 里输入 help 可以得到很多指令：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.38671875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCuJyV0KmAMXTzezibsHBjDaibjY6tIhgTPL52fq7pmdxLCANw251xpfM6ZWHA0UvgqHnO27DK21EHKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;其中比较有用的是 openVendor。这个函数可以打开当前项目的源码，其实也就是包含了 wcc 和 wcsc 编译工具的一个文件夹：&lt;/p&gt;&lt;p&gt;有了这些文件之后，对我们之后的分析会很有帮助。&lt;/p&gt;&lt;p&gt;我们可以将这些文件拷贝到一个单独的目录，在 VSCode 中打开该项目，并安装以下插件：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.24453125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCuJyV0KmAMXTzezibsHBjDaibHwJ4OXDYy2rLAC0boUicnicvDuDupxACpRqVzNmPwSPsHm2yAX2GcswA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;这个插件可以将微信开发者工具中的所有以 .wxvpkg 结尾的文件进行解压缩。&lt;/p&gt;&lt;p&gt;同时通过他来将 &lt;strong&gt;quickstart&lt;/strong&gt; 中的 &lt;strong&gt;miniProgramJs.wxvpkg&lt;/strong&gt; 进行解压，得到我们在开发者工具中的源码文件。&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;2.3.2 编译原理&lt;/strong&gt;&lt;/h3&gt;&lt;h4&gt;&lt;strong&gt;2.3.2.1 wcc 编译 wxml&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;微信小程序提供了 wcc 工具来编译 wxml 代码。通过上面得到的代码，我们可以实现对 wxml 的编译，以开发者工具创建的 Demo 项目中的首页为例：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;view&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;container&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;view&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;userinfo&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;block&lt;/span&gt; &lt;span&gt;wx:if&lt;/span&gt;=&lt;span&gt;&quot;{{canIUseOpenData}}&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;view&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;userinfo-avatar&quot;&lt;/span&gt; &lt;span&gt;bindtap&lt;/span&gt;=&lt;span&gt;&quot;bindViewTap&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;open-data&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;userAvatarUrl&quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span&gt;open-data&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;/&lt;span&gt;view&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;open-data&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;userNickName&quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span&gt;open-data&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;block&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;block&lt;/span&gt; &lt;span&gt;wx:elif&lt;/span&gt;=&lt;span&gt;&quot;{{!hasUserInfo}}&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;button&lt;/span&gt; &lt;span&gt;wx:if&lt;/span&gt;=&lt;span&gt;&quot;{{canIUseGetUserProfile}}&quot;&lt;/span&gt; &lt;span&gt;bindtap&lt;/span&gt;=&lt;span&gt;&quot;getUserProfile&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt; 获取头像昵称 &lt;span&gt;&amp;lt;/&lt;span&gt;button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;button&lt;/span&gt; &lt;span&gt;wx:elif&lt;/span&gt;=&lt;span&gt;&quot;{{canIUse}}&quot;&lt;/span&gt; &lt;span&gt;open-type&lt;/span&gt;=&lt;span&gt;&quot;getUserInfo&quot;&lt;/span&gt; &lt;span&gt;bindgetuserinfo&lt;/span&gt;=&lt;span&gt;&quot;getUserInfo&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt; 获取头像昵称 &lt;span&gt;&amp;lt;/&lt;span&gt;button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;view&lt;/span&gt; &lt;span&gt;wx:else&lt;/span&gt;&amp;gt;&lt;/span&gt; 请使用1.4.4及以上版本基础库 &lt;span&gt;&amp;lt;/&lt;span&gt;view&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;block&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;block&lt;/span&gt; &lt;span&gt;wx:else&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;image&lt;/span&gt; &lt;span&gt;bindtap&lt;/span&gt;=&lt;span&gt;&quot;bindViewTap&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;userinfo-avatar&quot;&lt;/span&gt; &lt;span&gt;src&lt;/span&gt;=&lt;span&gt;&quot;{{userInfo.avatarUrl}}&quot;&lt;/span&gt; &lt;span&gt;mode&lt;/span&gt;=&lt;span&gt;&quot;cover&quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span&gt;image&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;text&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;userinfo-nickname&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;{{userInfo.nickName}}&lt;span&gt;&amp;lt;/&lt;span&gt;text&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;block&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;view&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;view&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;usermotto&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;text&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;user-motto&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;{{motto}}&lt;span&gt;&amp;lt;/&lt;span&gt;text&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;view&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;view&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;经过以下指令编译：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;./wcc ./quickstart/miniProgramJs.unpack/pages/index/index.wxml &amp;gt; index.js&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;会得到 JS 描述文件：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4734133790737564&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCuJyV0KmAMXTzezibsHBjDaibwOk541uI8hgTshc1ZWQQWiblqktRiaZOyM1MkwrZG6m3KoVUpTVf2Z7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1166&quot;/&gt;&lt;/p&gt;&lt;p&gt;它会声明一个 $gwx 函数，通过它可以得到 Virtual DOM。接着我们在这个文件里添加几行代码去调用它，并通过 Node.js 或者 NW.js 执行这个文件：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;/span&gt; data = $gwx(&lt;span&gt;&#x27;./quickstart/miniProgramJs.unpack/pages/index/index.wxml&#x27;&lt;/span&gt;)();&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;JSON&lt;/span&gt;.stringify(data, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;));&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以得到我们想要的最终的 Virtual DOM 结构：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;{&lt;br/&gt;  &lt;span&gt;&quot;tag&quot;&lt;/span&gt;: &lt;span&gt;&quot;wx-page&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;children&quot;&lt;/span&gt;: [&lt;br/&gt;    {&lt;br/&gt;      &lt;span&gt;&quot;tag&quot;&lt;/span&gt;: &lt;span&gt;&quot;wx-view&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;attr&quot;&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;&quot;class&quot;&lt;/span&gt;: &lt;span&gt;&quot;container&quot;&lt;/span&gt;&lt;br/&gt;      },&lt;br/&gt;      &lt;span&gt;&quot;children&quot;&lt;/span&gt;: [&lt;br/&gt;        {&lt;br/&gt;          &lt;span&gt;&quot;tag&quot;&lt;/span&gt;: &lt;span&gt;&quot;wx-view&quot;&lt;/span&gt;,&lt;br/&gt;          &lt;span&gt;&quot;attr&quot;&lt;/span&gt;: {&lt;br/&gt;            &lt;span&gt;&quot;class&quot;&lt;/span&gt;: &lt;span&gt;&quot;userinfo&quot;&lt;/span&gt;&lt;br/&gt;          },&lt;br/&gt;          &lt;span&gt;&quot;children&quot;&lt;/span&gt;: [&lt;br/&gt;            {&lt;br/&gt;              &lt;span&gt;&quot;tag&quot;&lt;/span&gt;: &lt;span&gt;&quot;wx-view&quot;&lt;/span&gt;,&lt;br/&gt;              &lt;span&gt;&quot;attr&quot;&lt;/span&gt;: {},&lt;br/&gt;              &lt;span&gt;&quot;children&quot;&lt;/span&gt;: [&lt;br/&gt;                &lt;span&gt;&quot; 请使用1.4.4及以上版本基础库 &quot;&lt;/span&gt;&lt;br/&gt;              ],&lt;br/&gt;              &lt;span&gt;&quot;raw&quot;&lt;/span&gt;: {},&lt;br/&gt;              &lt;span&gt;&quot;generics&quot;&lt;/span&gt;: {}&lt;br/&gt;            }&lt;br/&gt;          ],&lt;br/&gt;          &lt;span&gt;&quot;raw&quot;&lt;/span&gt;: {},&lt;br/&gt;          &lt;span&gt;&quot;generics&quot;&lt;/span&gt;: {}&lt;br/&gt;        },&lt;br/&gt;        {&lt;br/&gt;          &lt;span&gt;&quot;tag&quot;&lt;/span&gt;: &lt;span&gt;&quot;wx-view&quot;&lt;/span&gt;,&lt;br/&gt;          &lt;span&gt;&quot;attr&quot;&lt;/span&gt;: {&lt;br/&gt;            &lt;span&gt;&quot;class&quot;&lt;/span&gt;: &lt;span&gt;&quot;usermotto&quot;&lt;/span&gt;&lt;br/&gt;          },&lt;br/&gt;          &lt;span&gt;&quot;children&quot;&lt;/span&gt;: [&lt;br/&gt;            {&lt;br/&gt;              &lt;span&gt;&quot;tag&quot;&lt;/span&gt;: &lt;span&gt;&quot;wx-text&quot;&lt;/span&gt;,&lt;br/&gt;              &lt;span&gt;&quot;attr&quot;&lt;/span&gt;: {&lt;br/&gt;                &lt;span&gt;&quot;class&quot;&lt;/span&gt;: &lt;span&gt;&quot;user-motto&quot;&lt;/span&gt;&lt;br/&gt;              },&lt;br/&gt;              &lt;span&gt;&quot;children&quot;&lt;/span&gt;: [&lt;br/&gt;                &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt;              ],&lt;br/&gt;              &lt;span&gt;&quot;raw&quot;&lt;/span&gt;: {},&lt;br/&gt;              &lt;span&gt;&quot;generics&quot;&lt;/span&gt;: {}&lt;br/&gt;            }&lt;br/&gt;          ],&lt;br/&gt;          &lt;span&gt;&quot;raw&quot;&lt;/span&gt;: {},&lt;br/&gt;          &lt;span&gt;&quot;generics&quot;&lt;/span&gt;: {}&lt;br/&gt;        }&lt;br/&gt;      ],&lt;br/&gt;      &lt;span&gt;&quot;raw&quot;&lt;/span&gt;: {},&lt;br/&gt;      &lt;span&gt;&quot;generics&quot;&lt;/span&gt;: {}&lt;br/&gt;    }&lt;br/&gt;  ]&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后通过 window.exparser.registerElemtent 方法将这些 tag 转换成真实 DOM：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.9840319361277445&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCuJyV0KmAMXTzezibsHBjDaib7GjH33gX3JUFmqZ1RsNZZsFIB4J7qaXSs4icPBWAKqNdF4txQIHCKoQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1002&quot;/&gt;&lt;/p&gt;&lt;p&gt;比如说，以上的 wx-text 就会被转换成类似于以下 DOM：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;span&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&amp;lt;&lt;span&gt;span&lt;/span&gt; &lt;span&gt;style&lt;/span&gt;=&lt;span&gt;&quot;display: none&quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span&gt;span&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&amp;lt;&lt;span&gt;span&lt;/span&gt;&amp;gt;&lt;/span&gt;{{这里是具体的文字内容}}&lt;span&gt;&amp;lt;/&lt;span&gt;span&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;span&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;strong&gt;2.3.2.2 wcsc 编译 wxss&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;同样的，以 Demo 项目里的 index.wxss 为例，运行一下指令：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;./wcsc ./quickstart/miniProgramJs.unpack/pages/index/index.wxss -js -o ./css.js&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以将该文件从 wxss 格式的内容，转换成 JS 的内容：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.83046875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCuJyV0KmAMXTzezibsHBjDaibSngQI1MWHxzms1NVBWFpquslaHCVsENd287YAic1TsUAdZIGrTU2kRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;这里面会生成 setCssToHead 方法，用于将相应的 css 转换后（如 rpx 转 px 等等），通过 style 标签插入到文档的 head 里面。&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;2.4 通信原理&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;小程序逻辑层和渲染层的通信会由 Native （微信客户端）做中转，逻辑层发送网络请求也经由 Native 转发。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;视图层组件&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;内置组件中有部分组件是利用到客户端原生提供的能力，既然需要客户端原生提供的能力，那就会涉及到视图层与客户端的交互通信。这层通信机制在 iOS 和安卓系统的实现方式并不一样，iOS 是利用了 WKWebView 的提供 messageHandlers 特性，而在安卓则是往 WebView 的 window 对象注入一个原生方法，最终会封装成 WeiXinJSBridge 这样一个兼容层，主要提供了调用（invoke）和监听（on）这两种方法。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;逻辑层接口&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;逻辑层与客户端原生通信机制与渲染层类似，不同在于，iOS 平台可以往 JavaScriptCore 框架注入一个全局的原生方法，而安卓方面则是跟渲染层一致的。&lt;/p&gt;&lt;p&gt;无论是视图层还是逻辑层，开发者都是间接地调用到与客户端原生通信的底层接口。一般微信小程序会对逻辑层接口做层封装后，才暴露给开发者，封装的细节可能是统一入参、做些参数校验、兼容各平台或版本问题等等。&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;2.5 启动机制&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;小程序有冷启动与热启动两种方式：&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;span&gt;小程序没有重启的概念：&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;启动流程：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;2.130879345603272&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCuJyV0KmAMXTzezibsHBjDaibGiaD9Zs6Imicd0SMjMbWkpiaWMTraib3t2YESX6hr6ZbHJSYnTiaiajYgR8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;489&quot;/&gt;&lt;/p&gt;&lt;h1&gt;&lt;strong&gt;3. 总结&lt;/strong&gt;&lt;/h1&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;小程序拥有接近原生 App 的体验。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;小程序并不是真正的 &lt;strong&gt;“无需下载”&lt;/strong&gt;，只是小程序的体积很小，在当今高速的网络环境下能够快速下载，用户感知不到，更确切的来说是 &lt;strong&gt;“无感下载”&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;基于移动端布局的局限性，可以高效且简单的开发，迭代快速。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;小程序是双线程模型，逻辑层和渲染层分别运行在不同的线程中，通过 JSBridge 进行通信。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在小程序里有实现专门的 JSBridge 来实现 JS 和 Native 的双向调用。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;wxml 文件通过 wcc 编译：wxml =&amp;gt; JS =&amp;gt; VirtualDOM。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;wxss 文件通过 wcsc 编译：wxss =&amp;gt; JS =&amp;gt; style。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;小程序其实也是一种 hybrid 技术，但是他围绕宿主应用，实现了更为强大的生态，提供更为便捷的服务。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;h1&gt;&lt;strong&gt;4. 参考文献&lt;/strong&gt;&lt;/h1&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>