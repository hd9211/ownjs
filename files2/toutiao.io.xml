<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>7cd61b448d79178c346599b82cb30482</guid>
<title>Salesforce服务可观测性设计模式</title>
<link>https://toutiao.io/k/ug27t5t</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;blockquote&gt;&lt;p&gt;&lt;em&gt;可观测性是大规模微服务的必备能力之一，离开了可观测性，微服务运维一定会是一场灾难。本文介绍了Salesforce在构建服务可观测性方面采用的5项设计模式，帮助我们完整系统的理解服务可观测性的架构原则。原文：5 Design Patterns for Building Observable Services&lt;span&gt;[1]&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;怎样让我们的服务容易被观察，让团队能够更方便的管理服务？本文介绍了5个通用设计模式，供开发人员参考。&lt;/p&gt;&lt;p&gt;软件开发中的设计模式是解决常见问题的可重复的解决方案和最佳实践。考虑在服务监控的场景下，如果使用得当，设计模式也可以帮助团队方便的管理服务，并在生产中排除故障。可以将服务监控设计模式分为三类：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;健康检查&lt;/span&gt;&lt;br/&gt;如何知道服务正在运行，并且正在做应该做的事情？服务反应是否及时？是否存在潜在的服务问题？是否可以在问题影响到客户之前解决？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;实时告警&lt;/span&gt;&lt;br/&gt;当出现问题时（比如服务无响应、速度变慢或使用了太多资源），是否配置了告警通知？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;排除故障&lt;/span&gt;&lt;br/&gt;服务有什么问题吗？如果有问题发生，可能需要知道三件事：什么时候发生的，在哪里发生的，是什么原因导致的。在问题发生后，通过日志和跟踪来诊断问题，并更新服务，使这些问题不会对客户产生持久影响。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;下面我们依次讨论不同类别的模式(以及反模式)。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.61&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9utHkjMdE0V4NlFFYIxLKVn4LxKv9nYM6jWOM2FyN8THu0y5PibzOTgy4g6HE3VnbticwKw9NGEckh7tGKQhJhicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;健康检查&lt;/h3&gt;&lt;p&gt;健康检查有两种模式：&lt;span&gt;由外向内的健康检查&lt;/span&gt;，验证服务是否正在运行，并确定服务的响应时间/延迟；&lt;span&gt;由内向外的健康检查&lt;/span&gt;，跟踪应用程序和系统指标，可以在事故发生前发现潜在的问题(包括性能问题)。&lt;/p&gt;&lt;h3&gt;1. 由外向内的健康检查&lt;/h3&gt;&lt;p&gt;在此模式中，可以运行健康检查服务或模拟测试工具来ping服务端点。可以用自己内部构建的工具，也可以用第三方工具，包括NewRelic、Gomez和DataDog等。服务对ping做出响应，并将检查的输出记录到时间序列度量系统(如Argus&lt;span&gt;[2]&lt;/span&gt;或任何用于此类服务的度量系统)中。一旦有了数据，就可以对一段时间内的服务运行状况和其他关键指标实现可视化，并在特定条件下发送告警信息。&lt;/p&gt;&lt;p&gt;概要模式如下所示。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6461159062885327&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9utHkjMdE0V4NlFFYIxLKVn4LxKv9nYMyOvlR42cUoDQTVy4YjKibGxpDmOfCI4oCXowWdBWACEFnjmNJllnicSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;811&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由外向内运行健康检查的概要设计图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;正常运行时间（Uptime）&lt;/span&gt; —— 这个指标回答了一个由来已久的问题，“我的服务是否在运行，是否在做应该做的事情?”健康检查程序ping了待查服务后，如果收到了响应，就说明服务启动了，如果没有响应，就意味着需要开始补救工作&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;用户感知的时延（User-perceived latency）&lt;/span&gt; —— 我们必须从全球多个位置检查服务时延。例如，从日本访问服务的用户感知的时延可能与从西班牙和美国访问服务的用户感知的时延不同。可以使用健康状况检查API调用的时延作为用户感知时延的代表。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;上述两组的组合还可以作为服务的综合可用性信号。&lt;/p&gt;&lt;h3&gt;2. 由内而外的健康检查&lt;/h3&gt;&lt;p&gt;在此模式中，我们通过检测系统和应用程序指标，从而在潜在问题导致服务中断之前就察觉到它们。&lt;/p&gt;&lt;p&gt;要确定是否存在可能影响服务性能或可用性的潜在问题，需要收集有关应用程序和基础设施的指标。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6319365798414496&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9utHkjMdE0V4NlFFYIxLKVn4LxKv9nYMBLuzQ8ZoASZ93BPhwNVkhicM5KqAnjAZmiaeJZoFAwkbhKKmicu9BoBHg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;883&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由内向外运行健康检查的概要设计图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;那么应该关注哪些应用程序指标呢？至少收集以下四种信号。&lt;/p&gt;&lt;p&gt;此外，对于服务使用的每种资源类型(例如CPU、内存、磁盘空间、IOPS)收集如下系统指标。&lt;/p&gt;&lt;p&gt;收集这些指标还允许我们计算服务的可用性，这将回答一个关键问题：对客户而言，服务或特性是否可用？在大多数情况下，可以结合正常运行时间、时长(延时)和错误率指标来计算服务的可用性，以代表客户体验。例如，如果只根据正常运行时间来计算服务可用性，那么即使查询需要很长时间才能响应/网页需要很长时间才能加载，仍然会被认为是可用的。因此，采用诸如错误率和时延等额外指标对于恰当定义可用性是至关重要的。&lt;/p&gt;&lt;h3&gt;反模式: 使用日志对指标建模&lt;/h3&gt;&lt;p&gt;日志数据对于故障排查非常有用，我们将很快讨论这个问题。然而，考虑到目前大多数应用程序生成的日志数据量很大，我们确实不希望基于日志数据生成度量指标。使用日志数据对度量建模开销很大(意味着需要花更多的钱)，并且增加了提取、处理和反馈的时间，从而增加了MTTD(平均检测时间)，这两种后果都不可接受。我们在Salesforce建立了有效的指标收集工具供开发人员使用。&lt;/p&gt;&lt;h3&gt;实时告警&lt;/h3&gt;&lt;p&gt;当服务出现问题时，告警和通知是服务所有者希望接收信息的主要方式。当服务和基础架构的关键运行状况和性能指标高于或低于指定的阈值(表明存在问题)时，应当配置告警。例如，服务的响应时间突然增加，超过了可接受的阈值，服务的可用性低于指定的阈值，违反了服务的SLA。&lt;/p&gt;&lt;p&gt;告警的目的是通知相关人员介入补救流程、修复问题，并将服务恢复到正常状态，以便继续为客户服务。尽管在收到告警时可以通过触发自动工作流自动修复问题，但并不是所有的问题(特别是复杂的服务问题)都可以这样解决。自动修复可能有帮助的典型场景包括重新启动服务、增加/减少云环境中的计算资源、如果有任何未经授权的端口开放(安全漏洞)则终止实例等。&lt;/p&gt;&lt;p&gt;通过使用更复杂的技术(包括机器学习)，可以主动发出告警并检测异常情况，从而为服务所有者提供更好的体验。主动告警允许我们在问题影响到客户之前采取补救措施。例如，根据当前的使用趋势，通知我们服务将在一周内耗尽磁盘空间，而不是等到磁盘只剩10%空间时才通知我们。主动告警为修复问题提供了更多的时间，让我们不需要在凌晨3点出现告警的时候来修复问题。这种类型的告警可以创建一个问题单，以便服务所有者在第二天早上查看问题。检测异常可以减少告警噪声，并使服务所有者不必配置静态阈值来获得告警。当系统检测到给定指标的模式中有异常时，可以发出告警。还可以考虑周期性因素，从而减少假阳性(噪音)，并在一段时间内自动调整阈值以及异常的定义。&lt;/p&gt;&lt;h3&gt;3. 故障修复&lt;/h3&gt;&lt;p&gt;一般的告警模式包括确定问题是否可以自动修复，或者是否需要人工干预，以避免违反公司与客户之间的服务水平协议(Service Level Agreement, SLA)。下面的流程图包含了自动修复和需要人工干预的修复。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.43872113676731794&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9utHkjMdE0V4NlFFYIxLKVn4LxKv9nYMicFZOlzB1f5Rs65Npb1CAIY74rBy6x5Iv6QTl6nqRAATTRia9rrXiaC8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1126&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;启动自动补救还是调用人工操作的决策流程图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;告警反模式&lt;/h3&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;不要依赖人工观察。&lt;/span&gt; 随着系统规模和复杂性的增加，我们不能依赖人工24/7的盯着监视器来查看服务运行状况趋势，并在超过阈值时呼叫某人来解决问题。我们需要依靠机器和算法，在出现问题时通知我们，这也能够排除人为错误，并尽可能将过程自动化。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;并非所有告警都是等价的。&lt;/span&gt; 不要以相同的方式对待所有告警，将服务中的每个小问题都作为告警发送电子邮件/Slack通知只会导致垃圾邮件泛滥，并大大降低信噪比。对于每一个可能导致客户问题/违反SLA(关键问题)的服务问题，都需要呼叫工程师(使用类似PagerDuty的东西)进行处理，其他所有内容都应该作为问题单记录，或者作为日志记录。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;排除故障&lt;/h3&gt;&lt;p&gt;当服务出现问题时，需要有关出错原因、出错时间和出错地点的信息。对服务进行编码，以便此类信息可以用于故障诊断，有两个关键方法可以获得这些可用信息。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;在日志中记录出错条件和相关信息&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在服务中启用分布式跟踪(特别是在微服务环境中)&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;4. 在日志中记录错误信息&lt;/h3&gt;&lt;p&gt;日志是帮助我们定位问题的好帮手，所以一定要记录服务的出错条件。可以在服务中包含日志库来捕获应用程序日志，并送到日志服务。我们在Salesforce使用Splunk&lt;span&gt;[3]&lt;/span&gt;，不过也可以采用其他选择，比如DataDog、NewRelic等。&lt;/p&gt;&lt;p&gt;在定位故障时，可以使用应用程序和基础设施日志来帮助我们确定是什么导致了问题，以及如何减少问题再次发生的机会。&lt;/p&gt;&lt;p&gt;下图描述了日志系统的概要架构。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6323529411764706&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9utHkjMdE0V4NlFFYIxLKVn4LxKv9nYMOAWrzJvFN2pWxqgu1m3L3Tibd9MjMykPc1dziclVr768DBzibvWx2VWicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;884&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;日志系统概要架构图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;5. 微服务的分布式跟踪&lt;/h3&gt;&lt;p&gt;在微服务体系架构下，当发生事故或性能下降时，不仅仅需要知道哪里出错，还需要知道是哪个微服务引起了问题。&lt;/p&gt;&lt;p&gt;分布式跟踪允许我们通过requestID标识每个请求来获得这些信息。当出现问题时，可以查看其在请求流中发生的位置，以及判断该问题是与我们的服务相关还是与依赖的服务相关。我们在Salesforce已经将所有应用与自主开发的分布式跟踪服务(构建在Zipkin之上)Tracer集成在一起，生成的span被发送到Tracer上，上下文通过B3报头&lt;span&gt;[4]&lt;/span&gt;传播到下游应用，使用Zipkin&lt;span&gt;[5]&lt;/span&gt;或OpenTelemetry&lt;span&gt;[6]&lt;/span&gt;库实现可视化。&lt;/p&gt;&lt;h3&gt;然后呢？&lt;/h3&gt;&lt;p&gt;通过采用关于健康检查、告警和故障排除的设计模式，可以从头开始构建可观察服务。有很多工具和资源可以帮助我们开始。强烈推荐阅读&lt;em&gt;谷歌的站点可靠性工程(SRE)&lt;/em&gt;一书&lt;span&gt;[7]&lt;/span&gt;，特别是&lt;em&gt;导论&lt;/em&gt;&lt;span&gt;[8]&lt;/span&gt;中的“监控”部分和&lt;em&gt;第6章: 监控分布式系统&lt;/em&gt;&lt;span&gt;[9]&lt;/span&gt;。此外，还可以查看我们的&lt;em&gt;可观测性101系列&lt;/em&gt;&lt;span&gt;[10]&lt;/span&gt;，了解更多关于微服务监控的信息。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;References:&lt;/span&gt;&lt;br/&gt;[1] 5 Design Patterns for Building Observable Services: https://engineering.salesforce.com/5-design-patterns-for-building-observable-services-d56e7a330419&lt;br/&gt;[2] Argus: https://github.com/salesforce/Argus&lt;br/&gt;[3] Splunk: https://www.splunk.com/&lt;br/&gt;[4] B3 propagation: https://github.com/openzipkin/b3-propagation&lt;br/&gt;[5] Zipkin: https://zipkin.io/&lt;br/&gt;[6] OpenTelemetry: https://opentelemetry.io/&lt;br/&gt;[7] Google SRE Book: https://landing.google.com/sre/sre-book/toc/&lt;br/&gt;[8] Google SRE Book Instroduction: https://landing.google.com/sre/sre-book/chapters/introduction/&lt;br/&gt;[9] Google SRE Book Monitoring distributed systems: https://landing.google.com/sre/sre-book/chapters/monitoring-distributed-systems/&lt;br/&gt;[10] Salesforce Observability 101: https://engineering.salesforce.com/tagged/observability&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;你好，我是俞凡，在Motorola做过研发，现在在Mavenir做技术工作，对通信、网络、后端架构、云原生、DevOps、CICD、区块链、AI等技术始终保持着浓厚的兴趣，平时喜欢阅读、思考，相信持续学习、终身成长，欢迎一起交流学习。&lt;br/&gt;微信公众号：DeepNoMind&lt;/p&gt;&lt;/blockquote&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>40bb0ac746b8af17ac1479d25e615f2c</guid>
<title>我的机器学习之路！</title>
<link>https://toutiao.io/k/y59f508</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文主要是介绍机器学习的一些基本内容，包含：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;除了分类和回归之外的其他机器学习形式&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;评估机器学习模型的规范流程&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;为深度学习准备数据&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;特征工程&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;解决过拟合&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;处理机器学习问题的通用流程&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5555555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/QeT5ql1LaZu4KMTLvbX16COyz8jXgRsVkcrKzbFvpicjQqF11qIwGM8K7Psyc4bQicCibADZKx4FHaPZAqMtQaYlQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;一、机器学习4个分支&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;监督学习supervised learning&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最常见的机器学习类型。给定一组样本（通常是人工标准），它可以学会将数据映射到已知目标（也叫标注）。监督学习广泛应用到光学字符识别、语音识别、图像分类和语言翻译。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;监督学习除了回归和分类，还有其他变体：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;序列生成&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;语法树预测&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;目标检测&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;图像分割&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;无监督学习&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;无监督学习是指在没有目标的情况下寻找输入数据的有趣变换，目的是在于&lt;strong&gt;数据可视化、数据压缩、数据去噪或者更好地理解数据中的相关性&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;主要是&lt;strong&gt;降维&lt;/strong&gt;和&lt;strong&gt;聚类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe videosnap_video_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAA3RQv9-pl2wAAAAstQy6ubaLX4KHWvLEZgBPEt6M0eHU3PZP8zNPgMIvPKOuimiyUl-FccPbtwKL6&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=S7s6ianIic0ia4PicKJSfB8EjyjpQibPUAXolgAz8Iowfr9qVlRv6FQpwu0yOygR4XluUv9E2icWzkX93ibevdD5NibOZicicDo2lwpccRUScNbQY3qgIYYibQe4aFbLw&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SZ&amp;amp;idx=1&amp;amp;m=&amp;amp;scene=0&amp;amp;token=x5Y29zUxcibDD9yuicxPBYKUaeDuQJ0sibSg76n1oHS52TBQxrqwriaWhVooAqqLHcpQ9KuTib8h2Wp8&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/Q3auHgzwzM7Q8TB2u2g0ibDIgy0Hn1BP45KMRYztDC0vR5uFia9eo8Ng/0&quot; data-username=&quot;v2_060000231003b20faec8c6e08918cad3ca02e432b077444ce8ece8882818c23e704bd244441c@finder&quot; data-nickname=&quot;尤而小屋&quot; data-desc=&quot;kaggle实战分享：用户聚类分群#python#kaggle#机器学习#聚类&quot; data-nonceid=&quot;605478066328445070&quot; data-type=&quot;video&quot;/&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;自监督学习&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;自监督学习是监督学习的特例。自监督学习可以看做是没有人工标注的标签的监督学习。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;标签是仍然存在的，但是他们是从输入数据中生成的，通常是使用启发式算法生成的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一个常见的例子就是：自编码器autoencoder，其目标就是未经修改的输入。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;给定视频中过去的帧来预测下一帧，或者给定文本中前面的词语来预测下一个词语，都是属于自监督学习的例子（这两个例子是&lt;strong&gt;时序监督学习&lt;/strong&gt;的例子）&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;强化学习&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;强化学习是因为谷歌的DeepMind公司将其成功应用于学习完Atari游戏（还有围棋阿尔法狗）中，才开始被广泛关注。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在强化学习中，智能体agent接收有关其环境的信息，并学会选择使其某种奖励最大化的行动。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;二、分类和回归术语&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结一下回归和分类中常出现的术语：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;样本、输入：进入模型的数据点&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;预测、输出：从模型出来的结果&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;目标：真实值。对于外部数据源，理想状态下，模型能够预测出真实值&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;预测误差、损失值：预测值和真实值之间的距离&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;类别：分类问题中供选择的一组标签。比如对猫狗图像进行分类时，猫和狗就是标签&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;标签：分类问题中类别标注的具体例子。比如1234号图像被标注为包含类别狗，那么“狗”就是1234号图像的标签&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;真实值和标注：数据集的所有目标。通常是人工收集&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;二分类：一种分类任务，每个输入样本应该被划分到&lt;strong&gt;两个互斥的类别&lt;/strong&gt;中&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;多分类：一种分类任务，每个输入样本应该被划分到多个不同的类别中，比如手写数字分类&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;多标签分类：一种分类任务，每个输入样本都可以分配多个标签。比如一幅图像中既有猫又有狗，那么应该同时标注猫标签和狗标签。每幅图像的标签个数通常是可变的。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;标量回归：目标是连续标量值的任务。比如预测房价&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;向量回归：目标是一组连续值（比如一个连续变量）的任务。如果对多个值进行回归，就是向量回归&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;小批量或批量：模型同时处理的一小部分样本，通常是8-128.样本数通常是2的幂，方便CPU上的内存分配。训练时，小批量用来为模型权重计算一次梯度下降更新。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;三、评估机器学习的模型&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;机器学习的目的是得到可以&lt;strong&gt;泛化&lt;/strong&gt;的模型：在前所未见的数据集上也能够表现的很好，而过拟合则是核心难点。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3大数据集&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;评估模型的重点是将数据划分为：训练集、验证集和测试集&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;训练集：训练模型&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;验证集：评估模型&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;测试集：最后一次的测试&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;模型一定不能读取与测试集任何相关的信息，即使是间接读取也不行。3大经典评估方法：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;简单的留出验证&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;K折验证&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;带有打乱数据的重复K折验证&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3大评估方法&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;简单的留出验证（hold-out validation）&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;留出一定的比例的数据作为测试集，在剩余的数据集上训练数据，然后在测试集上评估模型。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了防止信息泄露，我们不能基于测试集来调节模型，必须保留一个验证集。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6347826086956522&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/QeT5ql1LaZu4KMTLvbX16COyz8jXgRsV8B0U9LOAg8Rf881VV66iaz6yWvWic6WZicloffAD9ceJqylFrHVdfE0BA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1150&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;# 代码实现&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;num_validation_samples = &lt;span&gt;10000&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 打乱数据&lt;/span&gt;&lt;br/&gt;np.random.shuffle(data)&lt;br/&gt;&lt;br/&gt;validation_data = data[:num_validation_samples]  &lt;span&gt;# 验证集&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;data = data[num_validation_samples:]  &lt;br/&gt;train_data = data   &lt;span&gt;# 训练集&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;model = get_model()&lt;br/&gt;model.train(train_data)  &lt;span&gt;# 训练集训练模型&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;validation_score = model.evaluate(validation_data)  &lt;span&gt;# 验证集上评估模型&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 调节模型、重新训练、评估，然后再次调节，最后在测试集上评估&lt;/span&gt;&lt;br/&gt;model = get_model()&lt;br/&gt;&lt;span&gt;# 将训练集和验证合并起来进行重新训练&lt;/span&gt;&lt;br/&gt;model.train(np.concatenate([train_data,validation_data]))&lt;br/&gt;&lt;span&gt;# 测试集上进行评估&lt;/span&gt;&lt;br/&gt;test_score = model.evaluate(test_data)&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一个缺点：如果可用的数据很少，可能验证集和测试集包含的样本很少，从而无法从统计学上代表数据。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因此就有了K折验证和重复的K折验证来解决这个问题。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;K折验证&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;使用K折交叉验证的基本原理：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将数据划分为K个分区，通常是4或者5&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;实例化K个模型，将模型在K-1个分区上训练，剩下的一个区上进行评估&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;模型的验证分数等于K个验证分数的均值。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如何K折交叉验证：以3折交叉验证为例&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47721822541966424&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/QeT5ql1LaZu4KMTLvbX16COyz8jXgRsV85WgIbSvjZ9z6ayOD8BXWQAibNedjT7kTsny0KmHYGKbYbwm8JCm0dQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1668&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;img&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;# 代码实现&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;k = &lt;span&gt;4&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;num_validation_samples = len(data) // k&lt;br/&gt;&lt;span&gt;# 随机打乱数据&lt;/span&gt;&lt;br/&gt;np.random.shuffle(data)&lt;br/&gt;&lt;br/&gt;validation_scores = []&lt;br/&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; fold &lt;span&gt;in&lt;/span&gt; range(k):&lt;br/&gt;    &lt;span&gt;# 验证集&lt;/span&gt;&lt;br/&gt;    validation_data = data[fold * num_validation_samples: (fold + &lt;span&gt;1&lt;/span&gt;) * num_validation_samples]&lt;br/&gt;    &lt;span&gt;# 训练集&lt;/span&gt;&lt;br/&gt;    train_data = data[: fold * num_validation_samples] + data[(fold + &lt;span&gt;1&lt;/span&gt;) * num_validation_samples:]&lt;br/&gt;&lt;br/&gt;    model = get_model()&lt;br/&gt;    model.train(train_data)&lt;br/&gt;&lt;br/&gt;    validation_score = model.evaluate(validation_data)  &lt;span&gt;# 每个验证集上的得分&lt;/span&gt;&lt;br/&gt;    validation_scores.append(validation_score)  &lt;span&gt;# 放到列表中&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;validation_score = np.average(validation_scores)  &lt;span&gt;# K折验证的均值&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;model = get_model()&lt;br/&gt;model.train(data)  &lt;span&gt;# data = train_data + validation_data  所有非测试集上进行训练&lt;/span&gt;&lt;br/&gt;test_score = model.evaluate(test_data)  &lt;span&gt;#  测试集上进行评估&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;带有打乱数据的K折验证&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果数据很少，又想精确地评估模型，可以使用打乱数据的K折交叉验证：iterated K-fold validation with shuffling。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;具体做法：&lt;strong&gt;在每次将数据划分为k个分区之前，先将数据打乱，最终分数是每个K折验证分数的均值&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;注意：这个做法一共要训练和评估P*K个模型，P是重复次数，计算代价很大。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;评估模型的注意事项&lt;/span&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;数据代表性：随机打乱数据&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;时间箭头：如果想根据过去预测未来，即针对所谓的时间序列的数据，则不应该随机打乱数据，这样会造成&lt;strong&gt;时间泄露&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;数据冗余：确保训练集和验证集之间没有交集&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;四、数据预处理、特征工程和特征学习&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;预处理&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;预处理的主要步骤：&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;向量化&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;神经网络的所有输入和输出都必须是&lt;strong&gt;浮点张量&lt;/strong&gt;。都必须转成张量，这一步叫做向量化data vectorization&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;值标准化&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数据输入网络前，对每个特征分别做标准化，使其均值为0，标准差为1。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;输入神经网络的数据应该具有以下特征：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;取值较小：大部分取值在0-1范围内&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;同质性(homogenous)：所有特征的取值范围都在大致相同的范围内&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Numpy实现的标准化过程：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;X -= X.mean(axis=&lt;span&gt;0&lt;/span&gt;)  &lt;span&gt;# 假定X是个二维矩阵&lt;/span&gt;&lt;br/&gt;X -= X.std(axis=&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;缺失值处理&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在神经网络中，一般将缺失值用0填充。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;特征工程&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;根据已有的知识对数据进行编码的转换，以改善模型的效果。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;特征工程的本质：用更简单的方式表述问题，从而使得问题变得更容易。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在大部分的深度学习是不需要特征工程的，因为神经网络能够从原始数据中自动提取有用的特征。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7386489479512736&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/QeT5ql1LaZu4KMTLvbX16COyz8jXgRsVUQPHS4w7vZx6ApRrVGz1ExjEhDKXavTNic9vfCuSVXLl5rhSOHgsibzQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;903&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;img&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;五、解决过拟合&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;什么是过拟合和欠拟合&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;机器学习的根本问题是优化和泛化的对立。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;优化：调节模型以在训练集上得到最佳性能；泛化：训练好的模型在未知数据上的性能好坏。&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;过拟合overfit：模型在训练集上表现良好，但是在测试集上表现不好。过拟合存在所有的机器学习问题中。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;欠拟合underfit：训练数据上的损失越小，测试数据上的数据损失也越小。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;过拟合和欠拟合的产生&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、欠拟合问题，根本的原因是特征维度过少，导致拟合的函数无法满足训练集，误差较大。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;解决方法：欠拟合问题可以通过增加特征维度来解决。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、过拟合问题，根本的原因则是特征维度过多，导致拟合的函数完美的经过训练集，但是对新数据的预测结果则较差。解决过拟合问题，则有2个途径：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;减少特征维度；可以人工选择保留的特征，或者模型选择算法&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;正则化；保留所有的特征，通过降低参数θ的值，来影响模型&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3招解决过拟合&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;减小网络大小&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;防止过拟合最简单的方案：减小模型大小，即减少模型中学习参数的个数（层数和每层的单元个数决定）。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;容量：在深度学习中，模型中可学习参数的个数称之为容量。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;使用的模型必须具有足够多的参数，以防止过拟合，即模型应该避免记忆资源不足。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;# 电影评论分类的原网络&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; tensorflow &lt;span&gt;as&lt;/span&gt; tf  &lt;span&gt;# add&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; keras &lt;span&gt;as&lt;/span&gt; models&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; keras &lt;span&gt;as&lt;/span&gt; layers&lt;br/&gt;&lt;br/&gt;model = models.Sequential()&lt;br/&gt;model.add(tf.keras.Dense(&lt;span&gt;16&lt;/span&gt;, activation=&lt;span&gt;&quot;relu&quot;&lt;/span&gt;,input_shape=(&lt;span&gt;10000&lt;/span&gt;, )))&lt;br/&gt;model.add(tf.keras.Dense(&lt;span&gt;16&lt;/span&gt;, activation=&lt;span&gt;&quot;relu&quot;&lt;/span&gt;))&lt;br/&gt;model.add(tf.keras.Dense(&lt;span&gt;1&lt;/span&gt;, activation=&lt;span&gt;&quot;sigmoid&quot;&lt;/span&gt;))&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;用一个更小的网络来替代：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;model = models.Sequential()&lt;br/&gt;model.add(tf.keras.Dense(&lt;span&gt;4&lt;/span&gt;, activation=&lt;span&gt;&quot;relu&quot;&lt;/span&gt;,input_shape=(&lt;span&gt;10000&lt;/span&gt;, )))&lt;br/&gt;model.add(tf.keras.Dense(&lt;span&gt;4&lt;/span&gt;, activation=&lt;span&gt;&quot;relu&quot;&lt;/span&gt;))&lt;br/&gt;model.add(tf.keras.Dense(&lt;span&gt;1&lt;/span&gt;, activation=&lt;span&gt;&quot;sigmoid&quot;&lt;/span&gt;))&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6769394261424017&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/QeT5ql1LaZu4KMTLvbX16COyz8jXgRsVQtpslwAutJ58bGQekny7kE5PfLclrjRdBPZCSkObwFbJIU1HKjw8ug/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;941&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;img&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们发现：更小的网络开始过拟合的时间要晚于之前的网络；而且小网络的性能变差的速度也更慢。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;换成更大的模型：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;model = models.Sequential()&lt;br/&gt;model.add(tf.keras.Dense(&lt;span&gt;512&lt;/span&gt;, activation=&lt;span&gt;&quot;relu&quot;&lt;/span&gt;,input_shape=(&lt;span&gt;10000&lt;/span&gt;, )))&lt;br/&gt;model.add(tf.keras.Dense(&lt;span&gt;512&lt;/span&gt;, activation=&lt;span&gt;&quot;relu&quot;&lt;/span&gt;))&lt;br/&gt;model.add(tf.keras.Dense(&lt;span&gt;1&lt;/span&gt;, activation=&lt;span&gt;&quot;sigmoid&quot;&lt;/span&gt;))&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6683991683991684&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/QeT5ql1LaZu4KMTLvbX16COyz8jXgRsVTMmbqk2yYUQux7kSmWVclfUibNh7iaSrqxQiaFVS0OI0GX9GMVmzAYCcQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;962&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;img&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;网络的容量越大，拟合训练数据的速度也越快，更容易过拟合。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;添加权重正则化（最佳）&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;奥卡姆剃刀(Occams razor) 原理：如果一件事有两种解释，那么最可能正确的就是最简单的那个，即假设更少的那个。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;权重正则化：强制让模型权重只能取较小的值，从而限制模型的复杂度，使得权重的分布更加规则regular。其实现方法：向网络损失函数中添加与较大权重值相关的成本。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;具体两种方式：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;L1正则化：权重系数的绝对值；L1范数&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;L2正则化：权重系数的平方；L2范数&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;神经网络中的L2正则化也叫做权重衰减weight decay。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Keras中添加权重正则化的方法是向层传递：权重正则化实例 作为关键字参数，以添加L2权重正则化为例：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;from&lt;/span&gt; keras &lt;span&gt;import&lt;/span&gt; regularizers&lt;br/&gt;&lt;br/&gt;model = models.Sequential()&lt;br/&gt;model.add(tf.keras.layers.Dense(&lt;span&gt;16&lt;/span&gt;,kernel_regularizer=regularizers.l2(&lt;span&gt;0.001&lt;/span&gt;),&lt;br/&gt;                               activation=&lt;span&gt;&quot;relu&quot;&lt;/span&gt;,&lt;br/&gt;                               input_shape=(&lt;span&gt;10000&lt;/span&gt;,)))&lt;br/&gt;model.add(tf.keras.layers.Dense(&lt;span&gt;16&lt;/span&gt;,kernel_regularizer=regularizers.l2(&lt;span&gt;0.001&lt;/span&gt;),&lt;br/&gt;                               activation=&lt;span&gt;&quot;relu&quot;&lt;/span&gt;))&lt;br/&gt;model.add(tf.keras.layers.Dense(&lt;span&gt;1&lt;/span&gt;,activation=&lt;span&gt;&quot;sigmoid&quot;&lt;/span&gt;))&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;l2(0.001)的意思是该层权重矩阵的每个系数都会使网络总损失增加0.001*weight_coeffient_value&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;由于这个惩罚项只在训练时添加，所以网络的训练损失会比测试损失大的多&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;添加L2正则项前后对比：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6834381551362684&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/QeT5ql1LaZu4KMTLvbX16COyz8jXgRsVaEAHjEJUQ9vBeQ4GkknEob7laYqibJb5ichN4PvXGwP2X2N2Ficic3ttpQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;954&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;img&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其他权重正则化的添加方式：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;from&lt;/span&gt; keras &lt;span&gt;import&lt;/span&gt; regularizers&lt;br/&gt;&lt;br/&gt;regularizers.l1(&lt;span&gt;0.001&lt;/span&gt;)  &lt;span&gt;# l1正则化&lt;/span&gt;&lt;br/&gt;regularizers.l1_l2(l1=&lt;span&gt;0.001&lt;/span&gt;, l2=&lt;span&gt;0.001&lt;/span&gt;)  &lt;span&gt;# 同时添加&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;添加dropout正则化&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;dropout是神经网络中最有效也是最常用的正则化方式之一，&lt;strong&gt;做法：在训练过程中随机将该层的一些输入特征舍弃（设置为0）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;dropout的比例就是被设置为0的特征所占的比例，通常在0.2-0.5之间。添加dropout的具体过程：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;model.add(tf.keras.layers.Dropout(&lt;span&gt;0.5&lt;/span&gt;))&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;要应用在前面一层的输出&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;model = models.Sequential()&lt;br/&gt;model.add(tf.keras.layers.Dense(&lt;span&gt;16&lt;/span&gt;,activation=&lt;span&gt;&quot;relu&quot;&lt;/span&gt;,input_shape=(&lt;span&gt;10000&lt;/span&gt;,)))&lt;br/&gt;model.add(tf.keras.layers.Dropout(&lt;span&gt;0.5&lt;/span&gt;))  &lt;span&gt;# 添加&lt;/span&gt;&lt;br/&gt;model.add(tf.keras.layers.Dense(&lt;span&gt;16&lt;/span&gt;,activation=&lt;span&gt;&quot;relu&quot;&lt;/span&gt;))&lt;br/&gt;model.add(tf.keras.layers.Dropout(&lt;span&gt;0.5&lt;/span&gt;))  &lt;span&gt;# 添加&lt;/span&gt;&lt;br/&gt;model.add(tf.keras.layers.Dense(&lt;span&gt;1&lt;/span&gt;,activation=&lt;span&gt;&quot;sigmoid&quot;&lt;/span&gt;))&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;防止神经网络过拟合的方法：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;获取更多的训练数据&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;减小网络容量&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;添加权重正则化&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;添加dropout&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;六、机器学习的通用工作流程&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;问题定义、收集数据&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;选择衡量成功的标准&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;平衡分类问题：精度和接受者操作特征曲线下面积-ROC/AUC&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;分类不平衡问题：准确率和召回率&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;确定评估方法&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;准备数据&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;数据转成张量&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;取值缩放到0-1之间&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;数据标准化&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;特征工程&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;开发比基准更好的模型&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.20859375&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/QeT5ql1LaZu4KMTLvbX16COyz8jXgRsVkichAxokvZHqBdeJESzwcQJWx8icXagnABDOzR3vexoLEwiaP3rdebP2w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;img&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol start=&quot;6&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;扩发模型规模：开发过拟合的模型&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;机器学习中无处不在的对立是优化和泛化的对立，理想的模型是刚好在欠拟合和过拟合的边界上，在容量不足和容量过大的边界上。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了弄清楚我们需要多大的模型，就必须开发一个过拟合的模型：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在训练的过程中始终监控训练损失和验证损失，以及我们关心的指标。&lt;/span&gt;&lt;/p&gt;&lt;ol start=&quot;7&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;模型正则化和调节参数&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;添加dropout&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;尝试增加或者减少层数&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;添加L1或者L2正则化项&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;尝试不同的超参数&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;反复做特征工程&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzIyNjM2MzQyNg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/vI9nYe94fsEXsBwQkpYLtE2vhn7Z3RVOSRu5M1VicIgqgMRKLsxsibK7OUSqUb1rUO4pfXnQyFYKqhryAIeh4MOg/0?wx_fmt=png&quot; data-nickname=&quot;Datawhale&quot; data-alias=&quot;Datawhale&quot; data-signature=&quot;一个专注于AI领域的开源组织，汇聚了众多优秀学习者，愿景-for the learner，和学习者一起成长。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a1413ba9f90d044e9c62fa10eef6de30</guid>
<title>如何理解分治思想</title>
<link>https://toutiao.io/k/o4spslu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;p&gt;分治思想就是把复杂问题、拆分成诺干个相同的小问题，然后将问题逐步解决掉，合并到一起的过程，就是分治思想。简单来说，分治思想就是“分而治之”，将复杂问题拆分成诺干个相同的小问题进行解决。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eG1jA7faiceGZr4nv6jffHN8eOuBcabQY0gibHGjlUvLxOpLQ2kzl4XicYW8cffWZWWFlBRTxGJtPaDKFp811VeGA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/p&gt;&lt;p&gt;那么如何实现分治思维去解决问题呢？首先分解的问题要与整个问题的规则要一致，否则就无法使用分治去解决问题，总体可总结为：&lt;/p&gt;&lt;p&gt;有哪些场景中使用到了分治去解决问题呢，在上文中我们讲解了排序、当时我们只讲解了冒牌排序、选择排序，插入排序，高级一点的排序并没有涉及到，因为像归并排序、推排序、快速排序涉及到更多的知识点需要去讲解和个人去了解堆概念和递归思想。今天应用的分治思想就是完全适用于归并排序，归并排序同时还要去理解递归思想。&lt;/p&gt;&lt;p&gt;如果对递归不理解的，需要去学习下，要不没办法继续下去，分治思想最著名的体现就是汉诺塔。&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/eG1jA7faiceGZr4nv6jffHN8eOuBcabQYtGMHCQBFUSPW5XAQBoE4YS9RWAlryFuTOiawibNGA97vMwAhAFU1Ek4g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;相信大家都玩过汉诺塔吧，那么汉诺塔是如何来的呢？&lt;/p&gt;&lt;p&gt;传说越南河内某间寺院有三根银棒，上串 64 个金盘。寺院里的僧侣依照一个古老的预言，以上述规则移动这些盘子；预言说当这些盘子移动完毕， 世界就会灭亡。这个传说叫做梵天寺之塔问题（Tower of Brahma puzzle）。但不知道是卢卡斯自创的这个传说，还是他受他人启发。若传说属实，僧侣们需要二的64次方减去一步才能完成这个任务；若他们每秒可完成一个盘子的移动，就需要 5849 亿年才能完成。整个宇宙现在也不过 137 亿年。这就是汉诺塔的由来。&lt;/p&gt;&lt;p&gt;解法的基本思想是递归。假设有 A、B、C 三个塔，A塔有N块盘，目标是把这些盘全部移到 C 塔。那么先把 A 塔顶部的N-1块盘移动到 B 塔，再把 A 塔剩下的大盘移到 C，最后把B塔的N-1块盘移到 C。&lt;/p&gt;&lt;p&gt;从左到右有A、B、C三根柱子，其中A柱子 上面有从小叠到大的n个圆盘，现要求将A柱子上的圆盘移到C柱子上去，期间只有一个原则：一次只能移到 一个盘子且大盘子不能在小盘子上面，求移动的步骤和移动的次数&lt;/p&gt;&lt;p&gt;移动的规则：&lt;/p&gt;&lt;p&gt;1.每次只能移动一个圆盘；&lt;/p&gt;&lt;p&gt;2.大盘不能叠在小盘上面。&lt;/p&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;hanoi&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;a&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;b&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;c&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;n&lt;/span&gt; &lt;span&gt;=&lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&#x27;--&amp;gt;&#x27;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;c&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;hanoi&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;n&lt;/span&gt; &lt;span&gt;-&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;a&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;c&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;b&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;hanoi&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;a&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;b&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;c&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;hanoi&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;n&lt;/span&gt; &lt;span&gt;-&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;b&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;a&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;c&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; &lt;span&gt;=&lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;__main__&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;hanoi&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&#x27;A&#x27;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&#x27;B&#x27;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&#x27;C&#x27;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以用无向图来表示汉诺塔, 在表示的时候会更加地直观和清晰, 虽然说理解上有一点点小难度.&lt;/p&gt;&lt;p&gt;现在规定, 每一个节点表示盘子的位置一种可能性, 每一条边表示一种移动的方法.&lt;/p&gt;&lt;p&gt;注: 这里不考虑在两个柱子之间的, 没有意义的, 来回移动的情况.&lt;/p&gt;&lt;p&gt;对于只有一个盘子的汉诺塔，可以表示为：&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eG1jA7faiceGZr4nv6jffHN8eOuBcabQYvUia500jYA4STWn3S3Dia4xR5RiaF2iaJFJAXiaiaGRYPNOPGhsEOsyP7L6w/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/p&gt;&lt;p&gt;对于有两个盘子的汉诺塔, 可以表示为:&lt;/p&gt;&lt;p&gt;相互连接的三个三角形, 组成了一个较大三角形的三个角。&lt;/p&gt;&lt;p&gt;每一个节点的第二个字母表示更大的盘子, 且最初时没有被移动。&lt;/p&gt;&lt;p&gt;对于每一个顶端的小三角形, 表示两个盘子的一种移动的方法：&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eG1jA7faiceGZr4nv6jffHN8eOuBcabQYtPMssq65dvx8CEJGrf1UsYqpyh6ySwPaby9V4wab1m5LX29jpIfwYw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/p&gt;&lt;p&gt;外围的三角形的每一个节点, 表示在一个柱子上盘子的所有分布可能.。&lt;/p&gt;&lt;p&gt;对于 h+1 个盘子, 就可以”复制” h 个盘子时候的三角形图, 然后拼成一个新的大三角形图, 稍微改动一下,&lt;/p&gt;&lt;p&gt;这个大的三角形图就可以用来表示 h+1 个盘子时的情况了.&lt;/p&gt;&lt;p&gt;所以当有三个盘子时, 图形为：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eG1jA7faiceGZr4nv6jffHN8eOuBcabQYfibNkib1l46QWvY9P1Yz3Ag6A8VHhfQtiaqkoIC1UticiaBVGibpyqKRHLFA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/p&gt;&lt;p&gt;A, b 和 c 表示三个柱子&lt;/p&gt;&lt;p&gt;按照从小到大的顺序, 从左到右地列出的盘子的位置.&lt;/p&gt;&lt;p&gt;最外面的三角形的边, 表示了盘子从一个柱子移动到另一个柱子最快的方式. 最大的三角形可以沿着中线分成三个次小的三角形, 就是上面由二级的汉诺塔组成三级的汉诺塔的逆向操作, 次小三角形相互之间的连线, 表示着最大的盘子的移动方式.&lt;/p&gt;&lt;p&gt;同理, 在这次三角形的也可以沿其中线分割成为三个次次三角形, 一样的, 次次小三角形相互之间的连线, 表示着次大的盘子的移动方式. 继续下去, 也就可以表示出一个汉诺塔的移动方式.&lt;/p&gt;&lt;p&gt;通常，对于具有 n 个盘子的图, 有3n个节点; 每个节点都有三条边连接着其他节点, 但是在顶点的的节点只却只有有两条边连接着其他节点.所以说总是下都可以将最小的盘子移动到另外两个柱子中的一个, 对于多数情况, 是可以在两个柱子间移动一个盘子, 除了所有的盘子都在一个柱子上. 边角的节点表示着所有的盘子都在一个柱子的情况, 即可以在 a, b 或 c 柱上堆满盘子, 显然只要三种. 对于n+1个盘子的图, 可以通过表示n给盘子的图 “复制” 三份, 组合在一起的. 因此也就很方便地表示了每一层的汉诺塔移动方式, 每一个次小的三角形表示次小的盘子的所有可能的移动方式和放置状态, 次小的三角形之间的连接表示了大盘子的三种可能的移动方式. 所以图形有3n+1个节点, 基本都有三个与之相连接的边,而顶点只有两个.&lt;/p&gt;&lt;p&gt;在盘子数比较多的时候, 汉诺塔的图像就会开始和分形图比较相似了.&lt;/p&gt;&lt;p&gt;该图较为清楚地表达了：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;对于任意的全部盘子在一根柱子的情况下, 将所有盘子移动到另一个柱子的最短路径只有一个.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;对于任意的两个盘子分布情况之间转换的时候, 只有一个或者两个不同的最短路径.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;对于任意的盘子分布情况, 都有一个或者两个将所有盘子移动到任意一个柱子上的最长不相交路径.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;对于任意的两个盘子分布情况之间转换的时候, 只有一个或者两个不同的最长不相交路径.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;设Nh是将有h个盘子的塔, 将所有盘子从一个柱子移动到另一个柱子的非相交路径的数量(一开始盘子都在一个柱子上). 可以得出： &lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eG1jA7faiceGZr4nv6jffHN8eOuBcabQYfl3X5VzAicul9vnf48ynyAarYOyGDTjDRT9Zcic1SyyrujIIzkmPD2gQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这里的&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eG1jA7faiceGZr4nv6jffHN8eOuBcabQYCFuhkYIA0icucSib3CupoMbc5krRaHlwiaianc8b7o9F7LYpaahiag3rJvA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/p&gt;&lt;p&gt;除了汉诺塔，还有其他的案例&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;归并排序&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;二分搜索&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;大整数乘法&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Strassen矩阵乘法&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;棋盘覆盖&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;快速排序&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;线性时间选择&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;最接近点对问题&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;循环赛日程表&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;青蛙跳台阶问题&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;分治法的复杂性分析&lt;/span&gt;&lt;/p&gt;&lt;p&gt;一个分治法将规模为n的问题分成k个规模为n／m的子问题去解。设分解阀值n0=1，且adhoc解规模为1的问题耗费1个单位时间。再设将原问题分解为k个子问题以及用merge将k个子问题的解合并为原问题的解需用f(n)个单位时间。用T(n)表示该分治法解规模为|P|=n的问题所需的计算时间，则有：T（n）= k T(n/m)+f(n) 通过迭代法求得方程的解：递归方程及其解只给出n等于m的方幂时T(n)的值，但是如果认为T(n)足够平滑，那么由n等于m的方幂时T(n)的值可以估计T(n)的增长速度。通常假定T(n)是单调上升的，从而当 mi≤n&amp;lt;mi+1时，T(mi)≤T(n)&amp;lt;T(mi+1)。&lt;/p&gt;&lt;p&gt;&lt;span&gt;依据分治法设计程序时的思维过程&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实际上就是类似于数学归纳法，找到解决本问题的求解方程公式，然后根据方程公式设计递归程序。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;1、一定是先找到最小问题规模时的求解方法&lt;/p&gt;&lt;p&gt;2、然后考虑随着问题规模增大时的求解方法&lt;/p&gt;&lt;p&gt;3、找到求解的递归函数式后（各种规模或因子），设计递归程序即可。&lt;/p&gt;&lt;p&gt;我们通常使用分治思想去解决大数据量问题，以及可以给我们一个思考，当我们遇到无法解决的问题，可以将问题拆分开来，逐步解决，这样就可以实现赚它一个亿的小目标。&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                          
              &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b106d235b612298292bd4cd0914d1e32</guid>
<title>假期结束，该充充电啦！</title>
<link>https://toutiao.io/k/wqxfv6b</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;我爱程序员&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;developerWorks&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;我们的产品：《码农周刊》 http://manong.io/ 、《开发者头条》 http://toutiao.io/&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>77bd29dec5e6761f6cc3d823f9d698a0</guid>
<title>一日一技：抛掉JavaScript，用HTML和Python做网站</title>
<link>https://toutiao.io/k/yx82tqk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7581521739130435&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ohoo1dCmvqe20icgAGJZXQaic2k04l5Zumb0DBgWX8qJsIqZIIz3ZlCAA4ND4Zw0ibm8hvZrllUdwneq41AfvzSjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2208&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;摄影：产品经理&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;某种甜点&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，我们的电脑上没有安装Python，但你需要验证一段Python代码的运行效果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;又有时候，你想做一个网页，但是你只会HTML和Python。那么如果要做一个带有一些复杂逻辑的网页，只能去学JavaScript吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实未必。如果你不考虑网页美观的话，你可以用HTML + Python实现一个简单的网页。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天我们要介绍的东西，叫做&lt;code&gt;PyScript&lt;/code&gt;，使用它，&lt;strong&gt;不需要&lt;/strong&gt;安装任何软件。只要有一个记事本，就能写一段HTML+Python的代码。写完以后，双击这个HTML文件，用浏览器打开，就能直接看到Python代码的运行结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设我现在要写一段代码，使用高效的算法计算斐波那契数列前10项的值。现在我已经把代码写好了，想验证一下它是否正确：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;fib&lt;/span&gt;&lt;span&gt;(n)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; n &lt;span&gt;in&lt;/span&gt; [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;]:&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;    a = &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;    b = &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; _ &lt;span&gt;in&lt;/span&gt; range(&lt;span&gt;2&lt;/span&gt;, n):&lt;br/&gt;        a, b = b, a + b&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; b&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我的电脑上没有Python，我也不知道任何在线的Python解释器。怎么办呢？这个时候，你只需要在这个Python代码的前后再添加一些HTML代码，把它保存成一个&lt;code&gt;.html&lt;/code&gt;文件就可以了：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;head&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;link&lt;/span&gt; &lt;span&gt;rel&lt;/span&gt;=&lt;span&gt;&quot;stylesheet&quot;&lt;/span&gt; &lt;span&gt;href&lt;/span&gt;=&lt;span&gt;&quot;https://pyscript.net/alpha/pyscript.css&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;script&lt;/span&gt; &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;src&lt;/span&gt;=&lt;span&gt;&quot;https://pyscript.net/alpha/pyscript.js&quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;head&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;py-script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;def fib(n):&lt;br/&gt;    if n in [1, 2]:&lt;br/&gt;        return 1&lt;br/&gt;    a = 1&lt;br/&gt;    b = 1&lt;br/&gt;    for _ in range(2, n):&lt;br/&gt;        a, b = b, a + b&lt;br/&gt;    return b&lt;br/&gt;&lt;br/&gt;for i in range(1, 11):&lt;br/&gt;    print(f&#x27;第{i}项的结果是：{fib(i)}&#x27;)&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;py-script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;保存以后，双击这个HTML文件，用浏览器打开，就可以看到运行结果了，如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6072072072072072&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ohoo1dCmvqe20icgAGJZXQaic2k04l5ZumsuXW7DXl7lRzbHv9AnUJPV2z706gII037ATzhgNASRjPibPTbFAic6Fw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1110&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到目前为止，似乎跟那些在线的Python运行环境没什么区别。但PyScript更厉害的是，它自带了一些常见的第三方库，例如numpy或者Matplot，甚至它还可以手动安装第三方库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于它自带的numpy和matplotlib，可以直接使用&lt;code&gt;&amp;lt;py-env&amp;gt;&lt;/code&gt;标签声明：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;head&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;link&lt;/span&gt; &lt;span&gt;rel&lt;/span&gt;=&lt;span&gt;&quot;stylesheet&quot;&lt;/span&gt; &lt;span&gt;href&lt;/span&gt;=&lt;span&gt;&quot;https://pyscript.net/alpha/pyscript.css&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;script&lt;/span&gt; &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;src&lt;/span&gt;=&lt;span&gt;&quot;https://pyscript.net/alpha/pyscript.js&quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;py-env&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        - numpy&lt;br/&gt;        - matplotlib&lt;br/&gt;      &lt;span&gt;&amp;lt;/&lt;span&gt;py-env&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;head&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;Let&#x27;s plot random numbers&lt;span&gt;&amp;lt;/&lt;span&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;plot&quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;py-script&lt;/span&gt; &lt;span&gt;output&lt;/span&gt;=&lt;span&gt;&quot;plot&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;import matplotlib.pyplot as plt&lt;br/&gt;import numpy as np&lt;br/&gt;&lt;br/&gt;x = np.random.randn(1000)&lt;br/&gt;y = np.random.randn(1000)&lt;br/&gt;&lt;br/&gt;fig, ax = plt.subplots()&lt;br/&gt;ax.scatter(x, y)&lt;br/&gt;fig&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;py-script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行效果如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9831804281345565&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ohoo1dCmvqe20icgAGJZXQaic2k04l5Zumm3oVuUrrzCzVgnwYic2ncyelwjeIdeeoKhIhD3LRerlGO2icSeJT5Njg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1308&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想安装第三方库，只需要去下载这个库对应的&lt;code&gt;.whl&lt;/code&gt;文件，把它跟HTML文件放到一起，然后在&lt;code&gt;&amp;lt;py-env&amp;gt;&lt;/code&gt;中使用相对路径导入就可以了。但经过我的测试，导入的requests工作起来有点问题。因此就不多介绍了。看看官方是否会修复这个bug吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PyScript的&lt;span&gt;Github&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;上，给了不少Demo，甚至可以用它来做超级马里奥的网页游戏。大家有兴趣可以看看。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前仅仅从运行Python代码这个小功能上，PyScript做的比Jupyter还是差远了。但是PyScript可以编辑修改HTML元素，这样它就可以在一定程度上替代JavaScript，从而配合HTML实现一些功能复杂的网页。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;Github: &lt;em&gt;https://github.com/pyscript/pyscript&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>