<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>9e3b5fcd949db09481b3985fc75e5d41</guid>
<title>引入 Gateway 网关，这些坑一定要学会避开</title>
<link>https://toutiao.io/k/60gr6a8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring cloud gateway是替代zuul的网关产品，基于Spring 5、Spring boot 2.0以上、Reactor, 提供任意的路由匹配和断言、过滤功能。上一篇文章谈了一下&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&amp;amp;mid=2247502520&amp;amp;idx=1&amp;amp;sn=927f28ffcf5ad86ae56e0714b75e68a8&amp;amp;chksm=ebd5f594dca27c82d64a02d6ab07a75b007fdd6d42cbab539c8d317dfd70513a2c75e91bcaf5&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Gateway网关使用不规范，同事加班泪两行~&lt;/a&gt;，这篇文章将会侧重于其他的几个需要注意的地方。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;网关实现&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里介绍编码方式实现&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;HystrixObservableCommand.&lt;span&gt;Setter &lt;span&gt;getSetter&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        HystrixCommandGroupKey groupKey = HystrixCommandGroupKey.Factory.asKey(&lt;span&gt;&quot;group-accept&quot;&lt;/span&gt;);&lt;br/&gt;        HystrixObservableCommand.Setter setter = HystrixObservableCommand.Setter.withGroupKey(groupKey);&lt;br/&gt;        HystrixCommandKey commandKey = HystrixCommandKey.Factory.asKey(&lt;span&gt;&quot;command-accept&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        setter.andCommandKey(commandKey);&lt;br/&gt;&lt;br/&gt;        HystrixCommandProperties.Setter proertiesSetter = HystrixCommandProperties.Setter();&lt;br/&gt;        proertiesSetter&lt;br/&gt;                &lt;span&gt;/* *&lt;br/&gt;                 * 线程策略配置&lt;br/&gt;                 */&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;//设置线程模式 缺省 1000ms&lt;/span&gt;&lt;br/&gt;                .withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.THREAD)&lt;br/&gt;                &lt;span&gt;//执行是否启用超时时间 缺省 true&lt;/span&gt;&lt;br/&gt;                .withExecutionTimeoutEnabled(&lt;span&gt;true&lt;/span&gt;)&lt;br/&gt;                &lt;span&gt;//使用线程隔离时，是否对命令执行超时的线程调用中断 缺省false&lt;/span&gt;&lt;br/&gt;                .withExecutionIsolationThreadInterruptOnFutureCancel(&lt;span&gt;false&lt;/span&gt;)&lt;br/&gt;                &lt;span&gt;//执行超时的时候是否要它中断 缺省 true&lt;/span&gt;&lt;br/&gt;                .withExecutionIsolationThreadInterruptOnTimeout(&lt;span&gt;true&lt;/span&gt;)&lt;br/&gt;                &lt;span&gt;//执行的超时时间 缺省 1000ms&lt;/span&gt;&lt;br/&gt;                .withExecutionTimeoutInMilliseconds(&lt;span&gt;2000&lt;/span&gt;)&lt;br/&gt;                &lt;span&gt;/* *&lt;br/&gt;                 * 熔断策略&lt;br/&gt;                 */&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;//是否开启溶断 缺省 true&lt;/span&gt;&lt;br/&gt;                .withCircuitBreakerEnabled(&lt;span&gt;true&lt;/span&gt;)&lt;br/&gt;                &lt;span&gt;// 是否允许熔断器忽略错误,默认false, 不开启 ；&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// true，断路器强制进入“关闭”状态，它会接收所有请求。&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 如果forceOpen属性为true，该属性不生效&lt;/span&gt;&lt;br/&gt;                .withCircuitBreakerForceClosed(&lt;span&gt;false&lt;/span&gt;)&lt;br/&gt;                &lt;span&gt;// 是否强制开启熔断器阻断所有请求, 默认为false&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 为true时，所有请求都将被拒绝，直接到fallback.&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 如果该属性设置为true，断路器将强制进入“打开”状态，&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 它会拒绝所有请求。该属性优于forceClosed属性&lt;/span&gt;&lt;br/&gt;                .withCircuitBreakerForceOpen(&lt;span&gt;false&lt;/span&gt;)&lt;br/&gt;                &lt;span&gt;// 用来设置当断路器打开之后的休眠时间窗。&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 休眠时间窗结束之后，会将断路器设置为“半开”状态，尝试熔断的请求命令，&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 如果依然请求错误就将断路器继续设置为“打开”状态，如果成功，就设置为“关闭”状态&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 熔断器默认工作时间,默认:5000豪秒.&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 熔断器中断请求10秒后会进入半打开状态,放部分流量过去重试.&lt;/span&gt;&lt;br/&gt;                .withCircuitBreakerSleepWindowInMilliseconds(&lt;span&gt;5000&lt;/span&gt;)&lt;br/&gt;                &lt;span&gt;// 熔断器在整个统计时间内是否开启的阀值.&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 在metricsRollingStatisticalWindowInMilliseconds（默认10s）内默认至少请求10次，&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 熔断器才发挥起作用,9次熔断器都不起作用。&lt;/span&gt;&lt;br/&gt;                .withCircuitBreakerRequestVolumeThreshold(&lt;span&gt;100&lt;/span&gt;)&lt;br/&gt;                &lt;span&gt;// 该属性用来设置断路器打开的错误百分比条件。默认值为50.&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 表示在滚动时间窗中，在请求值超过requestVolumeThreshold阈值的前提下，&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 如果错误请求数百分比超过50，就把断路器设置为“打开”状态，否则就设置为“关闭”状态&lt;/span&gt;&lt;br/&gt;                .withCircuitBreakerErrorThresholdPercentage(&lt;span&gt;50&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        setter.andCommandPropertiesDefaults(proertiesSetter);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; setter;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; RouteLocator &lt;span&gt;customRouteLocator&lt;/span&gt;&lt;span&gt;(RouteLocatorBuilder builder)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; RouteLocatorBuilder.Builder routes = builder.routes();&lt;br/&gt; RouteLocatorBuilder.Builder serviceProvider = routes&lt;br/&gt;  .route(&lt;span&gt;&quot;accept&quot;&lt;/span&gt;,&lt;br/&gt;   r -&amp;gt; r.method(HttpMethod.GET)&lt;br/&gt;    .and()&lt;br/&gt;    .path(&lt;span&gt;&quot;/gateway-accept/**&quot;&lt;/span&gt;)&lt;br/&gt;    .and()&lt;br/&gt;    .header(HttpHeaders.CONTENT_TYPE, &lt;span&gt;&quot;application/json;charset=UTF-8&quot;&lt;/span&gt;)&lt;br/&gt;    .filters(f -&amp;gt; {&lt;br/&gt;     f.rewritePath(&lt;span&gt;&quot;/gateway-accept/(?&amp;lt;path&amp;gt;.*)&quot;&lt;/span&gt;, &lt;span&gt;&quot;/${path}&quot;&lt;/span&gt;);&lt;br/&gt;     f.requestRateLimiter(&lt;br/&gt;      config -&amp;gt; config.setKeyResolver(&lt;span&gt;new&lt;/span&gt; GenericAccessResolver())&lt;br/&gt;       .setRateLimiter(redisRateLimiter()));&lt;br/&gt;     f.hystrix(config -&amp;gt; config.setName(&lt;span&gt;&quot;accept&quot;&lt;/span&gt;)&lt;br/&gt;      .setFallbackUri(&lt;span&gt;&quot;forward:/gateway-fallback&quot;&lt;/span&gt;)&lt;br/&gt;      .setSetter(getSetter()));&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; f;&lt;br/&gt;    })&lt;br/&gt;    .uri(&lt;span&gt;&quot;http://localhost:8888&quot;&lt;/span&gt;)&lt;br/&gt;     );&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; serviceProvider.build();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面的代码中，主要做了3件事情：&lt;strong&gt;限流、熔断策略及降级方法配置&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;限流&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;spring:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;redis:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;database:&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;host:&lt;/span&gt; &lt;span&gt;127.0&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;port:&lt;/span&gt; &lt;span&gt;6379&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;password:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;timeout:&lt;/span&gt; &lt;span&gt;1500&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;lettuce:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;pool:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;max-active:&lt;/span&gt; &lt;span&gt;300&lt;/span&gt; &lt;span&gt;#连接池最大连接数（使用负值表示没有限制）&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;max-idle:&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;    &lt;span&gt;#连接池中的最大空闲连接&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;min-idle:&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;     &lt;span&gt;#连接池中的最小空闲连接&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;max-wait:&lt;/span&gt; &lt;span&gt;-1&lt;/span&gt;    &lt;span&gt;#连接池最大阻塞等待时间（使用负值表示没有限制）&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@description&lt;/span&gt;: 按照访问地址进行限流(也可以安装其他条件进行限流)，具体可以看exchange.getRequest()的方法和属性&lt;br/&gt; **/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;GenericAccessResolver&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;KeyResolver&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Mono&amp;lt;String&amp;gt; &lt;span&gt;resolve&lt;/span&gt;&lt;span&gt;(ServerWebExchange exchange)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Mono.just(exchange.getRequest().getPath().value());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;RedisRateLimiter &lt;span&gt;redisRateLimiter&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;//1000,1500对应replenishRate、burstCapacity&lt;/span&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RedisRateLimiter(&lt;span&gt;1000&lt;/span&gt;, &lt;span&gt;1500&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; RouteLocator &lt;span&gt;customRouteLocator&lt;/span&gt;&lt;span&gt;(RouteLocatorBuilder builder)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    RouteLocatorBuilder.Builder routes = builder.routes();&lt;br/&gt;    RouteLocatorBuilder.Builder serviceProvider = routes&lt;br/&gt;        .route(&lt;span&gt;&quot;accept&quot;&lt;/span&gt;,&lt;br/&gt;               r -&amp;gt; r.method(HttpMethod.GET)&lt;br/&gt;               .and()&lt;br/&gt;               .path(&lt;span&gt;&quot;/gateway-accept/**&quot;&lt;/span&gt;)&lt;br/&gt;               .and()&lt;br/&gt;               .header(HttpHeaders.CONTENT_TYPE, &lt;span&gt;&quot;application/json;charset=UTF-8&quot;&lt;/span&gt;)&lt;br/&gt;               &lt;span&gt;//.and()&lt;/span&gt;&lt;br/&gt;               &lt;span&gt;//.readBody(String.class, readBody -&amp;gt; true)&lt;/span&gt;&lt;br/&gt;               .filters(f -&amp;gt; {&lt;br/&gt;                   f.rewritePath(&lt;span&gt;&quot;/gateway-accept/(?&amp;lt;path&amp;gt;.*)&quot;&lt;/span&gt;, &lt;span&gt;&quot;/${path}&quot;&lt;/span&gt;);&lt;br/&gt;                   f.requestRateLimiter(config -&amp;gt; config.setKeyResolver(&lt;span&gt;new&lt;/span&gt; GenericAccessResolver()).setRateLimiter(redisRateLimiter()));                                   &lt;br/&gt;                   &lt;span&gt;return&lt;/span&gt; f;&lt;br/&gt;               })&lt;br/&gt;               .uri(&lt;span&gt;&quot;http://localhost:8888&quot;&lt;/span&gt;)&lt;br/&gt;              );&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; serviceProvider.build();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;测试&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4900924702774108&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufpdqVia7dZRZayVkxWySlQmJxC5gonS2LnNd8J3cGibK2sh7PiarmcqrVntc8c2fzLj17fb39n7zplQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;757&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6684073107049608&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufpdqVia7dZRZayVkxWySlQmXkiaicYictricPXRj4cyYcibfYtsu323ymib115GbxJPExEn4UEb9NFHWSVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;766&quot;/&gt;&lt;/p&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;其他&lt;/p&gt;&lt;p&gt;如果有多个路由，使用不同的限流策略，可以自定义KeyResolver和RedisRateLimiter， 在路由定义时加入&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//基于ip限流&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;OtherAccessResolver&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;KeyResolver&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Mono&amp;lt;String&amp;gt; &lt;span&gt;resolve&lt;/span&gt;&lt;span&gt;(ServerWebExchange exchange)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Mono.just(exchange.getRequest().getRemoteAddress().getHostName());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;RedisRateLimiter &lt;span&gt;otherRedisRateLimiter&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;//1000,1500对应replenishRate、burstCapacity&lt;/span&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RedisRateLimiter(&lt;span&gt;100&lt;/span&gt;, &lt;span&gt;500&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; RouteLocator &lt;span&gt;customRouteLocator&lt;/span&gt;&lt;span&gt;(RouteLocatorBuilder builder)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; RouteLocatorBuilder.Builder routes = builder.routes();&lt;br/&gt; RouteLocatorBuilder.Builder serviceProvider = routes&lt;br/&gt;  .route(&lt;span&gt;&quot;accept&quot;&lt;/span&gt;,&lt;br/&gt;   r -&amp;gt; r.method(HttpMethod.GET)&lt;br/&gt;    .and()&lt;br/&gt;    .path(&lt;span&gt;&quot;/gateway-accept/**&quot;&lt;/span&gt;)&lt;br/&gt;    .and()&lt;br/&gt;    .header(HttpHeaders.CONTENT_TYPE, &lt;span&gt;&quot;application/json;charset=UTF-8&quot;&lt;/span&gt;)&lt;br/&gt;    .filters(f -&amp;gt; {&lt;br/&gt;     f.rewritePath(&lt;span&gt;&quot;/gateway-accept/(?&amp;lt;path&amp;gt;.*)&quot;&lt;/span&gt;, &lt;span&gt;&quot;/${path}&quot;&lt;/span&gt;);&lt;br/&gt;     f.requestRateLimiter(&lt;br/&gt;      config -&amp;gt; config.setKeyResolver(&lt;span&gt;new&lt;/span&gt; GenericAccessResolver())&lt;br/&gt;       .setRateLimiter(redisRateLimiter()));&lt;br/&gt;     f.hystrix(config -&amp;gt; config.setName(&lt;span&gt;&quot;accept&quot;&lt;/span&gt;)&lt;br/&gt;      .setFallbackUri(&lt;span&gt;&quot;forward:/gateway-fallback&quot;&lt;/span&gt;)&lt;br/&gt;      .setSetter(getSetter()));&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; f;&lt;br/&gt;    })&lt;br/&gt;    .uri(&lt;span&gt;&quot;http://localhost:8888&quot;&lt;/span&gt;))&lt;br/&gt;        .route(&lt;span&gt;&quot;sign&quot;&lt;/span&gt;,&lt;br/&gt;   r -&amp;gt; r.method(HttpMethod.POST)&lt;br/&gt;    .and()&lt;br/&gt;    .path(&lt;span&gt;&quot;/gateway-sign/**&quot;&lt;/span&gt;)&lt;br/&gt;    .and()&lt;br/&gt;    .header(HttpHeaders.CONTENT_TYPE, &lt;span&gt;&quot;application/json;charset=UTF-8&quot;&lt;/span&gt;)&lt;br/&gt;    .filters(f -&amp;gt; {&lt;br/&gt;     f.rewritePath(&lt;span&gt;&quot;/gateway-sign/(?&amp;lt;path&amp;gt;.*)&quot;&lt;/span&gt;, &lt;span&gt;&quot;/${path}&quot;&lt;/span&gt;);&lt;br/&gt;     f.requestRateLimiter(&lt;br/&gt;      config -&amp;gt; config.setKeyResolver(&lt;span&gt;new&lt;/span&gt; OtherAccessResolver())&lt;br/&gt;       .setRateLimiter(otherRedisRateLimiter()));&lt;br/&gt;     f.hystrix(config -&amp;gt; config.setName(&lt;span&gt;&quot;sign&quot;&lt;/span&gt;)&lt;br/&gt;      .setFallbackUri(&lt;span&gt;&quot;forward:/gateway-fallback&quot;&lt;/span&gt;)&lt;br/&gt;      .setSetter(getSetter()));&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; f;&lt;br/&gt;    })&lt;br/&gt;    .uri(&lt;span&gt;&quot;http://localhost:7777&quot;&lt;/span&gt;)&lt;br/&gt;     );&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; serviceProvider.build();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;熔断策略&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;熔断策略主要是线程配置和熔断配置，上面已经说明很清楚了。在上篇文章中，为了解决网关调用后台服务&lt;strong&gt;Connection prematurely closed BEFORE response&lt;/strong&gt;的问题，要设置后台服务线程的空闲时间和网关线程池线程的空闲时间，并让网关线程池线程的空闲时间小于后台服务的空闲时间&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;配置方法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;spring:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;cloud:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;gateway:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;httpclient:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;pool:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;max-connections:&lt;/span&gt; &lt;span&gt;500&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;max-idle-time:&lt;/span&gt; &lt;span&gt;10000&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;编码实现&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;翻阅Spring Cloud Gateway英文资料，知道路由提供一个&lt;strong&gt;metadata&lt;/strong&gt;方法，可以设置路由的元数据(https://docs.spring.io/spring-cloud-gateway/docs/2.2.6.RELEASE/reference/html/#route-metadata-configuration)，这些元数据在&lt;strong&gt;RouteMetadataUtils&lt;/strong&gt;中定义：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; org.springframework.cloud.gateway.support;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RouteMetadataUtils&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String RESPONSE_TIMEOUT_ATTR = &lt;span&gt;&quot;response-timeout&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String CONNECT_TIMEOUT_ATTR = &lt;span&gt;&quot;connect-timeout&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;RouteMetadataUtils&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; AssertionError(&lt;span&gt;&quot;Must not instantiate utility class.&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中没有我要的线程数量（max-connection）和空闲时间（max-idle-time）的设置，没有关系，自己加上去：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; RouteLocator &lt;span&gt;customRouteLocator&lt;/span&gt;&lt;span&gt;(RouteLocatorBuilder builder)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        RouteLocatorBuilder.Builder routes = builder.routes();&lt;br/&gt;        RouteLocatorBuilder.Builder serviceProvider = routes&lt;br/&gt;           .route(&lt;span&gt;&quot;accept&quot;&lt;/span&gt;,&lt;br/&gt;               r -&amp;gt; r.method(HttpMethod.GET)&lt;br/&gt;                     .and()&lt;br/&gt;                     .path(&lt;span&gt;&quot;/gateway-accept/**&quot;&lt;/span&gt;)&lt;br/&gt;                     .and()&lt;br/&gt;                     .header(HttpHeaders.CONTENT_TYPE, &lt;span&gt;&quot;application/json;charset=UTF-8&quot;&lt;/span&gt;)&lt;br/&gt;                     .filters(f -&amp;gt; {&lt;br/&gt;                          f.rewritePath(&lt;span&gt;&quot;/gateway-accept/(?&amp;lt;path&amp;gt;.*)&quot;&lt;/span&gt;, &lt;span&gt;&quot;/${path}&quot;&lt;/span&gt;);&lt;br/&gt;                          f.requestRateLimiter(&lt;br/&gt;                             config -&amp;gt; config.setKeyResolver(&lt;span&gt;new&lt;/span&gt; GenericAccessResolver())&lt;br/&gt;                                           .setRateLimiter(redisRateLimiter()));&lt;br/&gt;                          f.hystrix(config -&amp;gt; config.setName(&lt;span&gt;&quot;accept&quot;&lt;/span&gt;)&lt;br/&gt;                                      .setFallbackUri(&lt;span&gt;&quot;forward:/gateway-fallback&quot;&lt;/span&gt;)&lt;br/&gt;                                      .setSetter(getSetter()));&lt;br/&gt;                                &lt;span&gt;return&lt;/span&gt; f;&lt;br/&gt;                          })&lt;br/&gt;                     .uri(&lt;span&gt;&quot;http://localhost:8888&quot;&lt;/span&gt;)&lt;br/&gt;                     .metadata(&lt;span&gt;&quot;max-idle-time&quot;&lt;/span&gt;, &lt;span&gt;10000&lt;/span&gt;)  &lt;span&gt;//网关调用后台线程空闲时间设置&lt;/span&gt;&lt;br/&gt;                     .metadata(&lt;span&gt;&quot;max-connections&quot;&lt;/span&gt;, &lt;span&gt;200&lt;/span&gt;)  &lt;span&gt;//网关调用后台服务线程数量设置&lt;/span&gt;&lt;br/&gt;          );&lt;br/&gt;&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; serviceProvider.build();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试果然和yml配置一样有效果。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;降级方法&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;降级方法本身没有什么特别，有一个问题需要注意，调用降级方法也是使用线程池的，缺省在&lt;strong&gt;HystrixThreadPoolProperties&lt;/strong&gt;中定义：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;HystrixThreadPoolProperties&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/* defaults */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; default_coreSize = &lt;span&gt;10&lt;/span&gt;;            &lt;span&gt;// core size of thread pool&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; default_maximumSize = &lt;span&gt;10&lt;/span&gt;;         &lt;span&gt;// maximum size of thread pool&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; default_keepAliveTimeMinutes = &lt;span&gt;1&lt;/span&gt;; &lt;span&gt;// minutes to keep a thread alive&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; default_maxQueueSize = -&lt;span&gt;1&lt;/span&gt;;        &lt;span&gt;// size of queue (this can&#x27;t be dynamically changed so we use &#x27;queueSizeRejectionThreshold&#x27; to artificially limit and reject)&lt;/span&gt;&lt;br/&gt;                                                 &lt;span&gt;// -1 turns it off and makes us use SynchronousQueue&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;错误&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果上面的限流设置比较大，比如1000，最大突发2000，网关调用后台服务发生熔断降级， 熔断后降级的方法调用太频繁，10个线程不够用，会导致以下500错误：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;2021-02-01 14:29:45.076 ERROR 64868 --- [ioEventLoop-5-1] a.w.r.e.AbstractErrorWebExceptionHandler : [a0ed6911-18982]  500 Server Error &lt;span&gt;for&lt;/span&gt; HTTP GET &lt;span&gt;&quot;/gateway-accept/test&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;com.netflix.hystrix.exception.HystrixRuntimeException: &lt;span&gt;command&lt;/span&gt;-accept fallback execution rejected.&lt;br/&gt; at com.netflix.hystrix.AbstractCommand.handleFallbackRejectionByEmittingError(AbstractCommand.java:1043) ~[hystrix-core-1.5.18.jar:1.5.18]&lt;br/&gt; Suppressed: reactor.core.publisher.FluxOnAssembly&lt;span&gt;$OnAssemblyException&lt;/span&gt;: &lt;br/&gt;Error has been observed at the following site(s):&lt;br/&gt; |_ checkpoint ⇢ org.springframework.cloud.gateway.filter.WeightCalculatorWebFilter [DefaultWebFilterChain]&lt;br/&gt; |_ checkpoint ⇢ HTTP GET &lt;span&gt;&quot;/gateway-accept/test&quot;&lt;/span&gt; [ExceptionHandlingWebHandler]&lt;br/&gt;com.netflix.hystrix.exception.HystrixRuntimeException: &lt;span&gt;command&lt;/span&gt;-accept fallback execution rejected.&lt;br/&gt; at com.netflix.hystrix.AbstractCommand.handleFallbackRejectionByEmittingError(AbstractCommand.java:1043) ~[hystrix-core-1.5.18.jar:1.5.18]&lt;br/&gt; Suppressed: reactor.core.publisher.FluxOnAssembly&lt;span&gt;$OnAssemblyException&lt;/span&gt;: &lt;br/&gt;Error has been observed at the following site(s):&lt;br/&gt; |_ checkpoint ⇢ org.springframework.cloud.gateway.filter.WeightCalculatorWebFilter [DefaultWebFilterChain]&lt;br/&gt; |_ checkpoint ⇢ HTTP GET &lt;span&gt;&quot;/gateway-accept/test&quot;&lt;/span&gt; [ExceptionHandlingWebHandler]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;配置方法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以要在yml中设置合适的调用降级方法的线程池, 合理的配置能够杜绝网关500错误的发生。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;hystrix:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;threadpool:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;group-accept:&lt;/span&gt;  &lt;span&gt;#代码里面设置的HystrixCommandGroupKey.Factory.asKey(&quot;group-accept&quot;)&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;coreSize:&lt;/span&gt; &lt;span&gt;50&lt;/span&gt; &lt;span&gt;#并发执行的最大线程数，默认10&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;maxQueueSize:&lt;/span&gt; &lt;span&gt;1500&lt;/span&gt; &lt;span&gt;#BlockingQueue的最大队列数&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;#即使maxQueueSize没有达到，达到queueSizeRejectionThreshold该值后，请求也会被拒绝&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;queueSizeRejectionThreshold:&lt;/span&gt; &lt;span&gt;1400&lt;/span&gt; &lt;br/&gt;                                        &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;网关异常截获&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的异常后，没有捕获异常直接返回前端500错误，一般情况下需要返回一个统一接口，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Data&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@ToString&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@EqualsAndHashCode&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Accessors&lt;/span&gt;(chain = &lt;span&gt;true&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Result&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Serializable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Integer code;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String message;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; T data;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String sign;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String SUCCESS = &lt;span&gt;&quot;成功&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String FAILURE = &lt;span&gt;&quot;失败&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Result&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; code, String message)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.code = code;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.message = message;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Result&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; code, String message, T data)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.code = code;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.message = message;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.data = data;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Result&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; code, String message, T data, String sign)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.code = code;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.message = message;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.data = data;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.sign = sign;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Result&amp;lt;Object&amp;gt; &lt;span&gt;success&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Result&amp;lt;Object&amp;gt;(&lt;span&gt;200&lt;/span&gt;, SUCCESS);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Result&amp;lt;Object&amp;gt; &lt;span&gt;success&lt;/span&gt;&lt;span&gt;(Object data)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Result&amp;lt;Object&amp;gt;(&lt;span&gt;200&lt;/span&gt;, SUCCESS, data);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Result&amp;lt;Object&amp;gt; &lt;span&gt;success&lt;/span&gt;&lt;span&gt;(Object data, String sign)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Result&amp;lt;Object&amp;gt;(&lt;span&gt;200&lt;/span&gt;, SUCCESS, data, sign);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Result&amp;lt;Object&amp;gt; &lt;span&gt;failure&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Result&amp;lt;Object&amp;gt;(&lt;span&gt;400&lt;/span&gt;, FAILURE);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Result&amp;lt;Object&amp;gt; &lt;span&gt;failure&lt;/span&gt;&lt;span&gt;(Object data)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Result&amp;lt;Object&amp;gt;(&lt;span&gt;400&lt;/span&gt;, FAILURE, data);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Result&amp;lt;Object&amp;gt; &lt;span&gt;failure&lt;/span&gt;&lt;span&gt;(Object data, String sign)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Result&amp;lt;Object&amp;gt;(&lt;span&gt;400&lt;/span&gt;, FAILURE, data, sign);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建&lt;strong&gt;GlobalExceptionConfiguration&lt;/strong&gt; 实现&lt;strong&gt;ErrorWebExceptionHandler&lt;/strong&gt;（这一段是来者网友提供的）&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;@Order&lt;/span&gt;(-&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@RequiredArgsConstructor&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;GlobalExceptionConfiguration&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ErrorWebExceptionHandler&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ObjectMapper objectMapper;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Mono&amp;lt;Void&amp;gt; &lt;span&gt;handle&lt;/span&gt;&lt;span&gt;(ServerWebExchange exchange, Throwable ex)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ServerHttpResponse response = exchange.getResponse();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (response.isCommitted()) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; Mono.error(ex);&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        response.getHeaders().setContentType(MediaType.APPLICATION_JSON_UTF8);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (ex &lt;span&gt;instanceof&lt;/span&gt; ResponseStatusException) {&lt;br/&gt;            response.setStatusCode(((ResponseStatusException) ex).getStatus());&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; response&lt;br/&gt;                .writeWith(Mono.fromSupplier(() -&amp;gt; {&lt;br/&gt;                    DataBufferFactory bufferFactory = response.bufferFactory();&lt;br/&gt;                    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                        &lt;span&gt;return&lt;/span&gt; bufferFactory.wrap(objectMapper.writeValueAsBytes(Result.failure(ex.getMessage())));&lt;br/&gt;                    } &lt;span&gt;catch&lt;/span&gt; (JsonProcessingException e) {&lt;br/&gt;                        log.warn(&lt;span&gt;&quot;Error writing response&quot;&lt;/span&gt;, ex);&lt;br/&gt;                        &lt;span&gt;return&lt;/span&gt; bufferFactory.wrap(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;0&lt;/span&gt;]);&lt;br/&gt;                    }&lt;br/&gt;                }));&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样，就会把网关异常统一包装在接口中返回：如：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.2794348508634223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufpdqVia7dZRZayVkxWySlQmkEibAg17CENpcvq31vviadlDK1pzW00Rby0g0qKrmHZAic9T0ARicW4IuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;637&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后台日志已经没有之前的错误日志了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;编码实现，没找到&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于&lt;strong&gt;Spring Cloud Gateway&lt;/strong&gt; 中的 &lt;strong&gt;Hystrix&lt;/strong&gt;采用的是&lt;strong&gt;HystrixObservableCommand.Setter&lt;/strong&gt;, 没有采用 &lt;strong&gt;HystrixCommand.Setter&lt;/strong&gt;， 在 &lt;strong&gt;HystrixCommand.Setter&lt;/strong&gt;中是可以编码实现线程池配置的, 但是在&lt;strong&gt;HystrixObservableCommand.Setter&lt;/strong&gt;没有提供：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Setter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; HystrixCommandGroupKey groupKey;&lt;br/&gt;        &lt;span&gt;protected&lt;/span&gt; HystrixCommandKey commandKey;&lt;br/&gt;        &lt;span&gt;protected&lt;/span&gt; HystrixThreadPoolKey threadPoolKey;  &lt;span&gt;//有属性但是没有set方法&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;protected&lt;/span&gt; HystrixCommandProperties.Setter commandPropertiesDefaults;&lt;br/&gt;        &lt;span&gt;protected&lt;/span&gt; HystrixThreadPoolProperties.Setter threadPoolPropertiesDefaults; &lt;span&gt;//有属性没有set方法&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;Setter&lt;/span&gt;&lt;span&gt;(HystrixCommandGroupKey groupKey)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.groupKey = groupKey;&lt;br/&gt;            &lt;span&gt;// default to using SEMAPHORE for ObservableCommand&lt;/span&gt;&lt;br/&gt;            commandPropertiesDefaults = setDefaults(HystrixCommandProperties.Setter());&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Setter &lt;span&gt;withGroupKey&lt;/span&gt;&lt;span&gt;(HystrixCommandGroupKey groupKey)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Setter(groupKey);&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Setter &lt;span&gt;andCommandKey&lt;/span&gt;&lt;span&gt;(HystrixCommandKey commandKey)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.commandKey = commandKey;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Setter &lt;span&gt;andCommandPropertiesDefaults&lt;/span&gt;&lt;span&gt;(HystrixCommandProperties.Setter commandPropertiesDefaults)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.commandPropertiesDefaults = setDefaults(commandPropertiesDefaults);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; HystrixCommandProperties.&lt;span&gt;Setter &lt;span&gt;setDefaults&lt;/span&gt;&lt;span&gt;(HystrixCommandProperties.Setter commandPropertiesDefaults)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (commandPropertiesDefaults.getExecutionIsolationStrategy() == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;// default to using SEMAPHORE for ObservableCommand if the user didn&#x27;t set it&lt;/span&gt;&lt;br/&gt;                commandPropertiesDefaults.withExecutionIsolationStrategy(ExecutionIsolationStrategy.SEMAPHORE);&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; commandPropertiesDefaults;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于本人水平有限，没有找到&lt;strong&gt;Setter&lt;/strong&gt;中设置&lt;strong&gt;HystrixThreadPoolKey&lt;/strong&gt;和&lt;strong&gt;HystrixThreadPoolProperties.Setter&lt;/strong&gt;的方法，所以只能在yml中配置。有知道的同学告诉我一声，不胜感激。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在&lt;strong&gt;Spring Cloud Gateway&lt;/strong&gt;网关的配置中，需要综合考虑限流大小、网关调用后台连接池设置大小、后台服务的连接池以及空闲时间，包括网关调用降级方法的线程池配置，都需要在压测中调整到一个合理的配置，才能发挥最大的功效。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本人水平有限，跟深入的研究还在继续，如果文章有表达错误或者不周，请大家指正，谢谢！&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1e722b2e2cde649971f90a11b76fdb36</guid>
<title>如何改变 Docker 的数据目录</title>
<link>https://toutiao.io/k/etee1wd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;container app-preview post-body&quot;&gt;
  &lt;div class=&quot;preview&quot;&gt;&lt;p&gt;在 Linux 系统中 Docker 默认的数据目录为 &lt;code&gt;/var/lib/docker&lt;/code&gt;, 如果系统磁盘空间
不够大我们需要给它移个位置&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;停止 docker &lt;code&gt;systemctl stop docker&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建一个新的目录并把数据同步过去&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir /srv/docker
rsync -aqxP /var/lib/docker/ /srv/docker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果是新安装就不需要移数据了&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改配置文件 &lt;code&gt;/etc/docker/daemon.json&lt;/code&gt;, 把数据目录添加进去&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &quot;data-root&quot;: &quot;/srv/docker&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;启动系统 &lt;code&gt;systemctl start docker&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
  &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b9d9a0dbad49a21f9cf9af9e4609d48a</guid>
<title>日常开发之重构</title>
<link>https://toutiao.io/k/zxi5ajb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为开发人员，应该让重构贯穿于你的开发日常的每一刻。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么这么说？&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;重构是为了改善软件的设计、结构和实现，同时保留其现有的功能。重构的潜在优势包括提高代码的可读性和降低复杂度。这些都可以提高源代码的可维护性，并创建一个更简单、更干净或更有表现力的内部架构或对象模型，从而提高程序的可扩展性。&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原因我觉得有两方便，一个是客观的因素，随着技术的不断更新迭代，语言的特性也在更新（朝着更高效便捷的方向）。另一个则是人为因素，不同的人由于开发水平的不同写出来的代码也各尽不同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在一个团队中你除了要写自己的代码，而且还要接手别人的代码，作为一个leader更要去给别人做code review。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，重构是如此的必要，而且悄无声息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子，最近在看到一段代码后，立刻让我产生重构的冲动。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;旧代码如下：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先定义两个常量，对象和数组&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;const data = {&lt;br/&gt;  Angular: 3,&lt;br/&gt;  React: 1,&lt;br/&gt;  Vue: 2,&lt;br/&gt;  Next: 1,&lt;br/&gt;  HTML: 2,&lt;br/&gt;  Other: 3&lt;br/&gt;};&lt;br/&gt;const colors = [&lt;br/&gt;  &lt;span&gt;&#x27;#d17a29&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&#x27;#da9554&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&#x27;#e3af7f&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&#x27;#edcaa9&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&#x27;#f6e4d4&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&#x27;#204e77&#x27;&lt;/span&gt;&lt;br/&gt;];&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;利用for操作，取出以上对象的key和value和数组元素组成新的数组&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; sortable = [];&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; index = 0;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; temp &lt;span&gt;in&lt;/span&gt; data) {&lt;br/&gt;  sortable.push([temp, data[temp], colors[index] ? colors[index] : &lt;span&gt;&#x27;#D3D3D3&#x27;&lt;/span&gt;]);&lt;br/&gt;  index++;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;sortable.sort(&lt;span&gt;function&lt;/span&gt;(a, b) {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; b[1] - a[1];&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终输出结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[&lt;br/&gt;  [&lt;span&gt;&#x27;Angular&#x27;&lt;/span&gt;, 3, &lt;span&gt;&#x27;#d17a29&#x27;&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;&#x27;Other&#x27;&lt;/span&gt;, 3, &lt;span&gt;&#x27;#204e77&#x27;&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;&#x27;Vue&#x27;&lt;/span&gt;, 2, &lt;span&gt;&#x27;#e3af7f&#x27;&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;&#x27;HTML&#x27;&lt;/span&gt;, 2, &lt;span&gt;&#x27;#f6e4d4&#x27;&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;&#x27;React&#x27;&lt;/span&gt;, 1, &lt;span&gt;&#x27;#da9554&#x27;&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;&#x27;Next&#x27;&lt;/span&gt;, 1, &lt;span&gt;&#x27;#edcaa9&#x27;&lt;/span&gt;]&lt;br/&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从逻辑实现上没有任何问题。但总感觉哪里不对，是不是有更高效的实现方式呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;重构后的代码&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也许是写代码的惯性使然，立马想到使用&lt;code&gt;Map&lt;/code&gt;方法可以将数据返回你想要的格式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是对象数据格式好像不支持Map方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们得先将对象转化成数组&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;const newOutput = Object.entries(data);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们将得到以下格式的数组&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[&lt;br/&gt;  [&lt;span&gt;&#x27;Angular&#x27;&lt;/span&gt;, 3],&lt;br/&gt;  [&lt;span&gt;&#x27;React&#x27;&lt;/span&gt;, 1],&lt;br/&gt;  [&lt;span&gt;&#x27;Vue&#x27;&lt;/span&gt;, 2],&lt;br/&gt;  [&lt;span&gt;&#x27;Next&#x27;&lt;/span&gt;, 1],&lt;br/&gt;  [&lt;span&gt;&#x27;HTML&#x27;&lt;/span&gt;, 2],&lt;br/&gt;  [&lt;span&gt;&#x27;Other&#x27;&lt;/span&gt;, 3]&lt;br/&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是不是和最终想要的结果有点类似了，数组的元素中还差了一个&lt;code&gt;color&lt;/code&gt;的值，以及最终需要将它们排序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着我们根据索引将&lt;code&gt;color&lt;/code&gt;的值添加到以上输出结果中&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;const newOutput = Object.entries(data)&lt;br/&gt;.map(&lt;br/&gt;  ([title, amount], index) =&amp;gt; [&lt;br/&gt;    title,&lt;br/&gt;    amount,&lt;br/&gt;    colors[index] || &lt;span&gt;&quot;#fff&quot;&lt;/span&gt;]&lt;br/&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里或者使用数组解构更容易理解一点&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;const newOutput = Object.entries(data)&lt;br/&gt;  .map((item, index) =&amp;gt; [&lt;br/&gt;    ...item,&lt;br/&gt;    colors[index] || &lt;span&gt;&#x27;#fff&#x27;&lt;/span&gt;]&lt;br/&gt;  )&lt;br/&gt;  .sort((a, b) =&amp;gt; b[1] - a[1]);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在取不到值的时候我们给添加了一个默认的颜色值&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[&lt;br/&gt;  [&lt;span&gt;&#x27;Angular&#x27;&lt;/span&gt;, 3, &lt;span&gt;&#x27;#d17a29&#x27;&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;&#x27;React&#x27;&lt;/span&gt;, 1, &lt;span&gt;&#x27;#da9554&#x27;&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;&#x27;Vue&#x27;&lt;/span&gt;, 2, &lt;span&gt;&#x27;#e3af7f&#x27;&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;&#x27;Next&#x27;&lt;/span&gt;, 1, &lt;span&gt;&#x27;#edcaa9&#x27;&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;&#x27;HTML&#x27;&lt;/span&gt;, 2, &lt;span&gt;&#x27;#f6e4d4&#x27;&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;&#x27;Other&#x27;&lt;/span&gt;, 3, &lt;span&gt;&#x27;#204e77&#x27;&lt;/span&gt;]&lt;br/&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后只剩下一步，我们需要按第二项给数组排序，很容易就想到用&lt;code&gt;sort&lt;/code&gt;方法&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;const newOutput = Object.entries(data)&lt;br/&gt;  .map(&lt;br/&gt;    ([title, amount], index) =&amp;gt; [&lt;br/&gt;      title,&lt;br/&gt;      amount,&lt;br/&gt;      colors[index] || &lt;span&gt;&quot;#fff&quot;&lt;/span&gt;]&lt;br/&gt;  )&lt;br/&gt;  .sort((a, b) =&amp;gt; b[1] - a[1])&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上代码输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[&lt;br/&gt;  [&lt;span&gt;&#x27;Angular&#x27;&lt;/span&gt;, 3, &lt;span&gt;&#x27;#d17a29&#x27;&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;&#x27;Other&#x27;&lt;/span&gt;, 3, &lt;span&gt;&#x27;#204e77&#x27;&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;&#x27;Vue&#x27;&lt;/span&gt;, 2, &lt;span&gt;&#x27;#e3af7f&#x27;&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;&#x27;HTML&#x27;&lt;/span&gt;, 2, &lt;span&gt;&#x27;#f6e4d4&#x27;&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;&#x27;React&#x27;&lt;/span&gt;, 1, &lt;span&gt;&#x27;#da9554&#x27;&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;&#x27;Next&#x27;&lt;/span&gt;, 1, &lt;span&gt;&#x27;#edcaa9&#x27;&lt;/span&gt;]&lt;br/&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没有问题，两种不同的代码都得到了最终的结果。但是重构后的代码量明显比之前的少了很多，而且结构更严谨。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写代码的过程中要学会举一反三，及时拥抱语言的新特性能给我们带来更好的编程体验。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另：以上代码在 &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4NTU1OTMwMQ==&amp;amp;mid=2650300918&amp;amp;idx=2&amp;amp;sn=1a56aab9baaea8de8780f14c76ea53bb&amp;amp;chksm=87dad09cb0ad598a8462e00caed136e8712cefc92de648617f5e97905734210ca4a48dc291a7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;【利好工具】JavaScript及时运行调试工具&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;【利好工具】JavaScript及时运行调试工具&lt;/a&gt;中运行更佳&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ed535a58b5ffa34bcf4b83d69889558c</guid>
<title>开源了！从 0 到 1 实现 “合成大西瓜”</title>
<link>https://toutiao.io/k/jpidpq7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot;&gt;&lt;blockquote&gt;&lt;p&gt;转自：shymean&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.shymean.com/article/%25E4%25BD%25BF%25E7%2594%25A8cocos%25E5%25AE%259E%25E7%258E%25B0%25E4%25B8%2580%25E4%25B8%25AA%25E5%2590%2588%25E6%2588%2590%25E5%25A4%25A7%25E8%25A5%25BF%25E7%2593%259C&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;www.shymean.com/article/使用cocos实现一个合成大西瓜&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近微博上曝出了很多瓜，&quot;合成大西瓜&quot;这个游戏也很火热，玩了一阵还挺有意思的。研究了一下原理，发现目前流传的版本都是魔改编译后的版本，代码经过压缩不具备可读性，因此决定自己照着实现一个。&lt;/p&gt;
&lt;p&gt;本项目主要用作 cocos creator 练手使用，所有美术素材和音频材料均来源于 &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.wesane.com/game/654/%25E6%2584%259F%25E8%25B0%25A2%25E5%258E%259F%25E4%25BD%259C%25E8%2580%2585%25EF%25BC%258C%25E5%2590%2591%25E6%25AF%258F%25E4%25B8%2580%25E4%25BD%258D%25E6%25B8%25B8%25E6%2588%258F%25E5%25BC%2580%25E5%258F%2591%25E8%2580%2585%25E8%2587%25B4%25E6%2595%25AC%25EF%25BC%2581&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;www.wesane.com/game/654/感谢原作者，向每一位游戏开发者致敬！&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文所有代码及素材都放在 Github上：
&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/tangxiangmin/cocos-big-watermelon&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/tangxiangmin&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;/cocos-big-watermelon&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;也可以通过在线预览地址体验：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//web-game-9gh6nrus14fec37e-1252170212.tcloudbaseapp.com/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;web-game-9gh6nrus14fec37e-1252170212.tcloudbaseapp.com&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;微信无法点击外链，请给我们公号发送&lt;code&gt;大西瓜&lt;/code&gt;获取入口&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;游戏逻辑&lt;/h2&gt;
&lt;p&gt;整个游戏逻辑比较简单，结合了俄罗斯方块与消除游戏的核心玩法&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在生成一个水果&lt;/li&gt;
&lt;li&gt;点击屏幕，水果移动到对应x轴位置并自由下落&lt;/li&gt;
&lt;li&gt;每个水果会与其他水果发生碰撞,两个相同的水果碰撞时会发生合并，升级成更高一级的水果&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;水果共有 11 种类型，&lt;/p&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-af092ce0e39a0cd1daac917899f92f40_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;167&quot; data-rawheight=&quot;272&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;167&quot; data-rawheight=&quot;272&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-af092ce0e39a0cd1daac917899f92f40_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;游戏目标是合成最高级的水果：大西瓜！当堆积的水果超过顶部红线时则游戏结束整理出需要实现的核心逻辑&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;生成水果&lt;/li&gt;
&lt;li&gt;水果下落与碰撞&lt;/li&gt;
&lt;li&gt;水果消除动画效果及升级逻辑&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;预备工作&lt;/h2&gt;
&lt;h3&gt;cocos creator基本概念&lt;/h3&gt;
&lt;p&gt;整个项目使用cocos creator v2.4.3实现，建议初次了解的同学可以先过一下官方文档，本文不会过多介绍creator的使用（主要是我也不太熟练hah）官方文档链接：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//docs.cocos.com/creator/2.3/manual/zh/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;docs.cocos.com/creator/&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;2.3/manual/zh/&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;游戏素材&lt;/h3&gt;
&lt;p&gt;首先需要准备美术资源，本位所有美术素材和音频材料均来源于 &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.wesane.com/game/654/%25E3%2580%2582%25E9%25A6%2596%25E5%2585%2588%25E8%25AE%25BF%25E9%2597%25AE%25E6%25B8%25B8%25E6%2588%258F%25E7%25BD%2591%25E7%25AB%2599%25EF%25BC%258C%25E6%2589%2593%25E5%25BC%2580network%25E9%259D%25A2%25E6%259D%25BF%25EF%25BC%258C%25E5%258F%25AF%25E4%25BB%25A5%25E7%259C%258B%25E8%25A7%2581%25E6%25B8%25B8%25E6%2588%258F%25E4%25BE%259D%25E8%25B5%2596%25E7%259A%2584%25E6%2589%2580%25E6%259C%2589%25E7%25BE%258E%25E6%259C%25AF%25E8%25B5%2584%25E6%25BA%2590%25EF%25BC%258C%25E6%2588%2591%25E4%25BB%25AC%25E4%25B8%258B%25E8%25BD%25BD%25E8%2587%25AA%25E5%25B7%25B1%25E6%2589%2580%25E9%259C%2580%25E7%259A%2584%25E6%2596%2587%25E4%25BB%25B6%25E5%258D%25B3%25E5%258F%25AF%25E3%2580%2582&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;www.wesane.com/game/654/。首先访问游戏网站，打开network面板，可以看见游戏依赖的所有美术资源，我们下载自己所需的文件即可。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-54261bc3c8eabd9df31fb4abfa5caae1_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;369&quot; data-rawheight=&quot;422&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;369&quot; data-rawheight=&quot;422&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-54261bc3c8eabd9df31fb4abfa5caae1_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;所需的图片资源包括&lt;/p&gt;

&lt;p&gt;音频文件同理，可以在Filter栏选择&lt;code&gt;.mp3&lt;/code&gt;后缀的请求快速筛选对应资源。&lt;/p&gt;

&lt;h2&gt;创建游戏场景和背景&lt;/h2&gt;
&lt;p&gt;打开cocos creator，新建一个项目（也可以直接导入从github下载的项目源码）。然后记得将刚才下载的素材资源拖拽到右下角的资源管理器中。&lt;/p&gt;
&lt;h3&gt;创建scene和背景节点&lt;/h3&gt;
&lt;p&gt;项目初始化之后，在左下角资源管理器新建一个游戏&lt;code&gt;Scene&lt;/code&gt;，取名game作为游戏主场景。&lt;/p&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d22b03c75695f2f4ff26cef647ef35af_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;682&quot; data-rawheight=&quot;432&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-d22b03c75695f2f4ff26cef647ef35af_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;682&quot; data-rawheight=&quot;432&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-d22b03c75695f2f4ff26cef647ef35af_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-d22b03c75695f2f4ff26cef647ef35af_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;创建完毕后就可以在资源管理器的assets中看见刚才创建的名为game的scene。选择game场景，在左上角的层级管理器中可以看见场景的Canvas画布根节点，cocos默认画布是横屏的&lt;code&gt;960*640&lt;/code&gt;，可以选择根节点然后再右侧属性检查器中调整宽高为&lt;code&gt;640*960&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b8b4f6b0481dc54b0fd351fb0f062bc3_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;790&quot; data-rawheight=&quot;446&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-b8b4f6b0481dc54b0fd351fb0f062bc3_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;790&quot; data-rawheight=&quot;446&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-b8b4f6b0481dc54b0fd351fb0f062bc3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-b8b4f6b0481dc54b0fd351fb0f062bc3_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;接下来创建背景层，我们在Canvas节点下面新建一个background节点，由于整个背景是纯色&lt;code&gt;#FBE79D&lt;/code&gt;的，因此使用一个单色Sprite填充即可&lt;/p&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-eb27589df928de712d64d969973c9409_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;493&quot; data-rawheight=&quot;629&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-eb27589df928de712d64d969973c9409_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;493&quot; data-rawheight=&quot;629&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-eb27589df928de712d64d969973c9409_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-eb27589df928de712d64d969973c9409_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;同样将background节点宽高调整为整个画布的大小，由于默认锚点均为&lt;code&gt;0.5*0.5&lt;/code&gt;，此时整个画布会被完全填充。现在整个游戏场景大概是这个样子的&lt;/p&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-206d49eb39bab4ead3ca73afec4b4546_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;657&quot; data-rawheight=&quot;654&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-206d49eb39bab4ead3ca73afec4b4546_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;657&quot; data-rawheight=&quot;654&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-206d49eb39bab4ead3ca73afec4b4546_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-206d49eb39bab4ead3ca73afec4b4546_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;接下来设计游戏的逻辑脚本部分&lt;/p&gt;
&lt;h3&gt;场景脚本组件&lt;/h3&gt;
&lt;p&gt;在assets目录下新建一个js脚本，按照惯例命令成&lt;code&gt;Game.js&lt;/code&gt;，creator会生成一个带基础&lt;code&gt;cc.Class&lt;/code&gt;的模板文件&lt;/p&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-574fd07cc35023c61fd1255267d72046_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;657&quot; data-rawheight=&quot;298&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-574fd07cc35023c61fd1255267d72046_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;657&quot; data-rawheight=&quot;298&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-574fd07cc35023c61fd1255267d72046_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-574fd07cc35023c61fd1255267d72046_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;先将脚本组件与节点关联起来，选择Canvas根节点，在右侧属性检查器中添加组件，然后选择刚才创建的这个&lt;code&gt;Game&lt;/code&gt;组件&lt;/p&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-17c711ddd9e6508bfa6cb19a98bd8ff4_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;513&quot; data-rawheight=&quot;205&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-17c711ddd9e6508bfa6cb19a98bd8ff4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;513&quot; data-rawheight=&quot;205&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-17c711ddd9e6508bfa6cb19a98bd8ff4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-17c711ddd9e6508bfa6cb19a98bd8ff4_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;然后编写具体的代码逻辑，打开Game.js文件（建议使用vscode或者webstrom打开整个项目的根目录进行编辑）里面的初始代码大概长这样&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// Game.js  
cc.Class({  
    extends: cc.Component,  

    properties: {  

    },  
    onLoad(){  

    },  
    start(){ }  
})  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们需要在这里维护整个游戏的逻辑，后面逐步添加代码内容。&lt;/p&gt;
&lt;h2&gt;创建水果&lt;/h2&gt;
&lt;p&gt;水果是整个游戏的核心元素，在游戏中被频繁创建和销毁。&lt;/p&gt;
&lt;h3&gt;生成单个水果预制资源&lt;/h3&gt;
&lt;p&gt;这种动态创建的节点可以通过预制资源&lt;code&gt;Prefab&lt;/code&gt;来控制，制作prefab最简单的方式就是将资源从资源管理器拖动到场景编辑器中，然后再将层级管理器中的节点拖回资源管理器。这里以等级最低的水果“葡萄”为例&lt;/p&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-68f4fa1c432c2b8f49aeb1dd25706337_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;657&quot; data-rawheight=&quot;728&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-68f4fa1c432c2b8f49aeb1dd25706337_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;657&quot; data-rawheight=&quot;728&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-68f4fa1c432c2b8f49aeb1dd25706337_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-68f4fa1c432c2b8f49aeb1dd25706337_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-13c46bbeb602b67cb7d37f4fefe6b7eb_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;421&quot; data-rawheight=&quot;729&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-13c46bbeb602b67cb7d37f4fefe6b7eb_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;421&quot; data-rawheight=&quot;729&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-13c46bbeb602b67cb7d37f4fefe6b7eb_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-13c46bbeb602b67cb7d37f4fefe6b7eb_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;然后将层级管理器中的节点删除，这样我们就得到了一个fruit的预制资源，在脚本组件中，就可以使用代码通过预制资源动态生成节点了。修改&lt;code&gt;Game.js&lt;/code&gt;，添加一个属性&lt;code&gt;fruitPrefab&lt;/code&gt;，其类型为&lt;code&gt;cc.Prefab&lt;/code&gt;，&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// Game.js  
properties: {  
    fruitPrefab: {  
        default: null,  
        type: cc.Prefab  
    },  
}  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;回到creator，。选择Canvas节点，可以在属性检查器中的&lt;code&gt;Game&lt;/code&gt;组件栏目看见和修改该属性了。我们将刚才制作的prefab资源从资源管理器拖动到这里，在初始化的时候，有cocos负责初始化对应的属性数据&lt;/p&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-76d9eedb8531dde55af3f73581d83ed5_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;986&quot; data-rawheight=&quot;138&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-76d9eedb8531dde55af3f73581d83ed5_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;986&quot; data-rawheight=&quot;138&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-76d9eedb8531dde55af3f73581d83ed5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-76d9eedb8531dde55af3f73581d83ed5_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3&gt;创建单个水果&lt;/h3&gt;
&lt;p&gt;回到Game.js，开始编写真正的逻辑：创建一个葡萄&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// Game.js  
onLoad(){  
    let fruit = cc.instantiate(this.fruitPrefab);  
    fruit.setPosition(cc.v2(0, 400));  

    this.node.addChild(fruit);  
}    &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;预览模式下就可以看见屏幕正上方有一个葡萄了&lt;/p&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-63f4b86f15467d0157dc7cc8e0969e1f_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;875&quot; data-rawheight=&quot;245&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-63f4b86f15467d0157dc7cc8e0969e1f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;875&quot; data-rawheight=&quot;245&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-63f4b86f15467d0157dc7cc8e0969e1f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-63f4b86f15467d0157dc7cc8e0969e1f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;nice，非常好的开始！&lt;/p&gt;
&lt;p&gt;此外，由于水果还包含一些特定的逻辑，我们可以向它添加一个&lt;code&gt;Fruit&lt;/code&gt;脚本组件，虽然目前看起来还没有什么用创建Fruit脚本组件与上面创建Game组件类似，然后选择刚才制作的prefab重新编辑，关联上Fruit用户脚本组件即可。&lt;/p&gt;
&lt;h3&gt;动态维护多种水果&lt;/h3&gt;
&lt;p&gt;整个游戏共11种水果（当然也可以添加或者改成其他的东西），如果每种水果都像上面去手动生成预制资源然后分别初始化，那也太繁琐了，我们需要解决动态渲染多种水果的方式。我们需要获得每种水果的贴图信息，然后在实例化水果时选择对应贴图即可，最简单的方式就是维护一个配置表，每行的数据字段包括&lt;code&gt;id&lt;/code&gt;和&lt;code&gt;iconSF&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;const FruitItem = cc.Class({  
    name: &#x27;FruitItem&#x27;,  
    properties: {  
        id: 0, // 水果的类型  
        iconSF: cc.SpriteFrame // 贴图资源  
    }  
});  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后为&lt;code&gt;Game&lt;/code&gt;脚本组件新增一个&lt;code&gt;fruits&lt;/code&gt;属性，用于保存每种水果的配置信息，其类型是数组，数组内元素类型为刚才创建的&lt;code&gt;FruitItem&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// Game.js  
properties: {  
    fruits: {  
        default: [],  
        type: FruitItem  
    },  
}  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;回到编辑器，这时候可以发现Game组件的属性下面多了一个&lt;code&gt;Fruits&lt;/code&gt;属性，将其长度修改为11，然后依次编写每个水果的id，同时将其贴图资源从资源编辑器贴过来（体力活）&lt;/p&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b84b59c50108a3b137ac43841b9f158d_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;593&quot; data-rawheight=&quot;641&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-b84b59c50108a3b137ac43841b9f158d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;593&quot; data-rawheight=&quot;641&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-b84b59c50108a3b137ac43841b9f158d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-b84b59c50108a3b137ac43841b9f158d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这样我们只需要传入想要制作的水果id，就可以获取到对应的配置信息，并动态修改贴图了这种初始化的逻辑应该由水果自己维护，因此放在刚才创建的&lt;code&gt;Fruit&lt;/code&gt;组件中，我们暴露一个init接口出来&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// Fruit.js  
properties: {  
    id: 0,  
},  
// 实例放在可以在其他组件中调用  
init(data) {  
    this.id = data.id  
    // 根据传入的参数修改贴图资源  
    const sp = this.node.getComponent(cc.Sprite)  
    sp.spriteFrame = data.iconSF  
},  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后修改一下上面的初始化水果的代码&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// Game.js  
createOneFruit(num) {  
    let fruit = cc.instantiate(this.fruitPrefab);  
    // 获取到配置信息  
    const config = this.fruits[num - 1]  

    // 获取到节点的Fruit组件并调用实例方法  
    fruit.getComponent(&#x27;Fruit&#x27;).init({  
        id: config.id,  
        iconSF: config.iconSF  
    });  
}  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样就可以愉快的创建各种水果了&lt;/p&gt;
&lt;h3&gt;监听点击事件&lt;/h3&gt;
&lt;p&gt;cocos提供了各种事件监听，前端和客户端同学一定不会陌生。整个游戏会在点击屏幕时创建一个水果，这只要监听一下全局点击事件即可，这个逻辑同样放在&lt;code&gt;Game&lt;/code&gt;脚本组件中&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;onLoad() {  
    // 监听点击事件  
    this.node.on(cc.Node.EventType.TOUCH_START, this.onTouchStart, this)  
},  
onTouchStart(){  
    this.createOneFruit(1) // 生成水果  
}  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;实际游戏中还需要处理随机生成水果、上一个水果在点击的x轴下落等细节逻辑，这里不再赘述。&lt;/p&gt;
&lt;h2&gt;物理系统：自由落体与刚体碰撞&lt;/h2&gt;
&lt;p&gt;上面处理了水果创建的逻辑，在整个游戏中，水果是可以产生下落及弹性碰撞等物理效果的，利用cocos内置的物理引擎，可以很方便的实现对cocos引擎不熟悉的同学可以先看看这个官方demo，里面展示的比较详细（起码比文档要更容易理解）&lt;/p&gt;
&lt;h3&gt;开启物理引擎与碰撞检测&lt;/h3&gt;
&lt;p&gt;首先是开启物理引擎，以及设置重力大小&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;const instance = cc.director.getPhysicsManager()  
instance.enabled = true  
// instance.debugDrawFlags = 4  
instance.gravity = cc.v2(0, -960);  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后需要开启碰撞检测，默认是关闭的&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;const collisionManager = cc.director.getCollisionManager();  
collisionManager.enabled = true  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后设置四周的墙壁用于碰撞，这样水果就不会无限制往下面掉落了&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// 设置四周的碰撞区域  
let width = this.node.width;  
let height = this.node.height;  

let node = new cc.Node();  

let body = node.addComponent(cc.RigidBody);  
body.type = cc.RigidBodyType.Static;  

const _addBound = (node, x, y, width, height) =&amp;gt; {  
    let collider = node.addComponent(cc.PhysicsBoxCollider);  
    collider.offset.x = x;  
    collider.offset.y = y;  
    collider.size.width = width;  
    collider.size.height = height;  
}  

_addBound(node, 0, -height / 2, width, 1);  
_addBound(node, 0, height / 2, width, 1);  
_addBound(node, -width / 2, 0, 1, height);  
_addBound(node, width / 2, 0, 1, height);  

node.parent = this.node;    &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在我们就开启了游戏世界的物理引擎，然后还需要配置需要受引擎影响的节点，也就是我们的水果。&lt;/p&gt;
&lt;h3&gt;水果刚体组件与碰撞组件&lt;/h3&gt;
&lt;p&gt;回到creator，找到我们的水果prefab，然后添加物理组件首先是Rigid Body（刚体）组件&lt;/p&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-a2d6630e86ecc458459362e7d85e1dae_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;988&quot; data-rawheight=&quot;636&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-a2d6630e86ecc458459362e7d85e1dae_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;988&quot; data-rawheight=&quot;636&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-a2d6630e86ecc458459362e7d85e1dae_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-a2d6630e86ecc458459362e7d85e1dae_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;然后是物理碰撞组件，因为我们的水果全是圆形的，都选择PhysicsCircleCollider组件就可以了,如果有个香蕉之类不规则多边形边的话，工作量就会增加不少~&lt;/p&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b4b6851403e3499cb1ef7f59f03c77fb_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;986&quot; data-rawheight=&quot;331&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-b4b6851403e3499cb1ef7f59f03c77fb_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;986&quot; data-rawheight=&quot;331&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-b4b6851403e3499cb1ef7f59f03c77fb_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-b4b6851403e3499cb1ef7f59f03c77fb_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;接下来可以看看整体效果，（记得把刚才的点击事件加上，然后控制一下随机生成水果类型）&lt;/p&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-51ca2e5fe51b31f5f6ef46f6f2840e85_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;482&quot; data-rawheight=&quot;855&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-51ca2e5fe51b31f5f6ef46f6f2840e85_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;482&quot; data-rawheight=&quot;855&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-51ca2e5fe51b31f5f6ef46f6f2840e85_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-51ca2e5fe51b31f5f6ef46f6f2840e85_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;完美！！&lt;/p&gt;
&lt;h3&gt;水果碰撞回调&lt;/h3&gt;
&lt;p&gt;添加完成之后，还需要开启刚体组件的碰撞属性&lt;code&gt;Enabled Contact Listener&lt;/code&gt;，这样可以接收到碰撞之后的回调&lt;/p&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-6e2e9bf1151c7cb61522a2a63c0e9a70_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;492&quot; data-rawheight=&quot;814&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-6e2e9bf1151c7cb61522a2a63c0e9a70_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;492&quot; data-rawheight=&quot;814&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-6e2e9bf1151c7cb61522a2a63c0e9a70_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-6e2e9bf1151c7cb61522a2a63c0e9a70_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这个碰撞回调同样写在Fruit脚本组件里面，&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// Fruit.js  
onBeginContact(contact, self, other) {  
    // 检测到是两个相同水果的碰撞  
    if (self.node &amp;amp;&amp;amp; other.node) {  
        const s = self.node.getComponent(&#x27;Fruit&#x27;)  
        const o = other.node.getComponent(&#x27;Fruit&#x27;)  
        if (s &amp;amp;&amp;amp; o &amp;amp;&amp;amp; s.id === o.id) {  
            self.node.emit(&#x27;sameContact&#x27;, {self, other});  
        }  
    }  
},  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;为了保证Fruit组件功能的单一性，在两个相同水果发生碰撞时，我们通过事件通知&lt;code&gt;Game.js&lt;/code&gt;，这样可以在初始化水果的时候注册&lt;code&gt;sameContact&lt;/code&gt;自定义事件的处理方法&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// Game.js  
createOneFruit(num) {  
    let fruit = cc.instantiate(this.fruitPrefab);  
    // ...其他初始化逻辑  
     fruit.on(&#x27;sameContact&#x27;, ({self, other}) =&amp;gt; {  
        // 两个node都会触发，临时处理，看看有没有其他方法只展示一次的  
        other.node.off(&#x27;sameContact&#x27;)   
        // 处理水果合并的逻辑，下面再处理  
        this.onSameFruitContact({self, other})  
     })  
}   &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样当水果发生碰撞时，我们就能够监听并处理消除升级逻辑了。&lt;/p&gt;
&lt;h2&gt;消除水果动画&lt;/h2&gt;
&lt;h3&gt;无动画版本&lt;/h3&gt;
&lt;p&gt;简单的消除逻辑就是将两个节点删除，然后在原水果位置生成高一级的水果即可，没有任何动画效果&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;self.node.removeFromParent(false)  
other.node.removeFromParent(false)  

const {x, y} = other.node // 获取合并的水果位置  
const id = other.getComponent(&#x27;Fruit&#x27;).id  

const nextId = id + 1  
const newFruit = this.createFruitOnPos(x, y, nextId) // 在指定位置生成新的水果  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;虽然看起来有点奇怪，但的确可以以玩了！&lt;/p&gt;
&lt;h3&gt;分析动画&lt;/h3&gt;
&lt;p&gt;打开源站，通过Performance面板分析一下动画效果（这里就不录gif了）&lt;/p&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-dd7fe3e16ac7e0b5ffaf44f0b46135dc_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;592&quot; data-rawheight=&quot;838&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-dd7fe3e16ac7e0b5ffaf44f0b46135dc_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;592&quot; data-rawheight=&quot;838&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-dd7fe3e16ac7e0b5ffaf44f0b46135dc_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-dd7fe3e16ac7e0b5ffaf44f0b46135dc_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可以看见合成的时候动画效果包括&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;碰撞水果向原水果中心移动&lt;/li&gt;
&lt;li&gt;果粒爆炸的粒子效果&lt;/li&gt;
&lt;li&gt;水珠爆炸的粒子效果&lt;/li&gt;
&lt;li&gt;一滩果汁的缩放动画&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此外还有爆炸声和水声的音效&lt;/p&gt;
&lt;h3&gt;管理爆炸素材资源&lt;/h3&gt;
&lt;p&gt;由于整个动画涉及到的素材较多，每种水果均包含3种颜色不同的贴图，与上面FruitItem类似，我们也采用prefab加动态资源的做法来管理对应素材和动画逻辑。首先定义一个&lt;code&gt;JuiceItem&lt;/code&gt;，保存单种水果爆炸需要的素材&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// Game.js  
const JuiceItem = cc.Class({  
    name: &#x27;JuiceItem&#x27;,  
    properties: {  
        particle: cc.SpriteFrame, // 果粒  
        circle: cc.SpriteFrame, // 水珠  
        slash: cc.SpriteFrame, // 果汁  
    }  
});   &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后为Game组件新增一个&lt;code&gt;juices&lt;/code&gt;属性&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// Game.js  
properties: {  
    juices: {  
        default: [],  
        type: JuiceItem  
    },  
    juicePrefab: {  
        default: null,  
        type: cc.Prefab  
    },  
}  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接下来又是卖劳力的时候了，将贴图资源都拖放到&lt;code&gt;juices&lt;/code&gt;属性下&lt;/p&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-35c2bc41fb00267a456472c7d40efeb8_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;740&quot; data-rawheight=&quot;831&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-35c2bc41fb00267a456472c7d40efeb8_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;740&quot; data-rawheight=&quot;831&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-35c2bc41fb00267a456472c7d40efeb8_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-35c2bc41fb00267a456472c7d40efeb8_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;然后新增一个空的预制资源，主要是为了挂载脚本组件，也就是下面的&lt;code&gt;Juice&lt;/code&gt;脚本，然后记得将该预制资源挂载到Game的&lt;code&gt;juicePrefab&lt;/code&gt;上。最后，新建&lt;code&gt;Juice&lt;/code&gt;组件，用来实现爆炸的动画逻辑，同样需要暴露init接口&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// Juice.js  
cc.Class({  
    extends: cc.Component,  

    properties: {  
        particle: {  
            default: null,  
            type: cc.SpriteFrame  
        },  
        circle: {  
            default: null,  
            type: cc.SpriteFrame  
        },  
        slash: {  
            default: null,  
            type: cc.SpriteFrame  
        }  
    },  
    // 同样暴露一个init接口  
    init(data) {  
        this.particle = data.particle  
        this.circle = data.particle  
        this.slash = data.slash  
    },  
    // 动画效果  
    showJuice(){  

    }  
}  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样，在合并的时候，我们初始化一个Juice节点，同时展示爆炸效果即可&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// Game.js  
let juice = cc.instantiate(this.juicePrefab);  
this.node.addChild(juice);  

const config = this.juices[id - 1]  
const instance = juice.getComponent(&#x27;Juice&#x27;)  
instance.init(config)  
instance.showJuice(pos, n) // 对应的爆炸逻辑   &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;爆炸粒子动画&lt;/h3&gt;
&lt;p&gt;关于粒子动画，网上能查到不少资料，如果感兴趣，也可以移步我之前整理的前端常见动画实现原理。粒子动画的主要的实现思路为：初始化N个粒子，控制他们的速度大小、方向和生命周期，然后控制每个粒子按照对应的参数执行动画，所有粒子汇集在一起的效果就组成了粒子动画。话虽如此，要把动画效果调好还是挺麻烦的，需要控制各种随机参数。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;showJuice(pos, width) {  
    // 果粒  
    for (let i = 0; i &amp;lt; 10; ++i) {  
        const node = new cc.Node(&#x27;Sprite&#x27;);  
        const sp = node.addComponent(cc.Sprite);  
        sp.spriteFrame = this.particle;  
        node.parent = this.node;  
        // ... 一堆随机的参数  

        node.position = pos;  
        node.runAction(  
            cc.sequence(  
                // ...各种action对应的动画逻辑  
                cc.callFunc(function () {  
                    // 动画结束后消除粒子  
                    node.active = false  
                }, this))  
        )  
    }  

    // 水珠  
    for (let f = 0; f &amp;lt; 20; f++) {  
        // 同果粒，使用的spriteFrame切换成 this.circle  
    }  
      
    // 果汁只有一张贴图，使用this.slash，展示常规的action缩放和透明动画即可  
},   &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;源项目的代码中使用&lt;code&gt;createFruitL&lt;/code&gt;这个方法来处理爆炸动画，虽然经过了代码压缩，但依稀能看出对应的动画参数逻辑，如果不想调整动画参数，可以借鉴一下&lt;/p&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-fd9c57a1c9414707cf85b543541134d0_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;935&quot; data-rawheight=&quot;439&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-fd9c57a1c9414707cf85b543541134d0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;935&quot; data-rawheight=&quot;439&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-fd9c57a1c9414707cf85b543541134d0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-fd9c57a1c9414707cf85b543541134d0_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这样，就完成了爆炸效果的展示，大概类似于这样，虽然有点丑&lt;/p&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5e6e356fdd77b6b4c81a8b44c39a7bf4_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;290&quot; data-rawheight=&quot;248&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;290&quot; data-rawheight=&quot;248&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-5e6e356fdd77b6b4c81a8b44c39a7bf4_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3&gt;音效&lt;/h3&gt;
&lt;p&gt;通过&lt;code&gt;cc.audioEngine&lt;/code&gt;直接播放&lt;code&gt;AudioClip&lt;/code&gt;资源来实现音效在Game组件下新增两个类型为AudioClip的资源，方便脚本组件访问&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;properties: {  
    boomAudio: {  
        default: null,  
        type: cc.AudioClip  
    },  
    waterAudio: {  
        default: null,  
        type: cc.AudioClip  
    }  
}  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;同上，在属性检查器中将两个音频资源从资源管理器拖动到Game组件的属性下方&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;onSameFruitContact(){  
    cc.audioEngine.play(this.boomAudio, false, 1);  
    cc.audioEngine.play(this.waterAudio, false, 1);  
}   &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样就可以在碰撞的时候听到声音了。&lt;/p&gt;
&lt;h2&gt;构建打包&lt;/h2&gt;
&lt;p&gt;完成整个游戏的开发之后，可以选择构建发布，打包成web-mobile版本，然后部署在服务器上，就可以给其他人快乐地玩耍了
&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-6a428c9ea7a8e157b12e90079d134bdc_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;1495&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-6a428c9ea7a8e157b12e90079d134bdc_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;1495&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-6a428c9ea7a8e157b12e90079d134bdc_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-6a428c9ea7a8e157b12e90079d134bdc_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;不知不就就写到了最后，貌似！！已经大工告成了！！虽然还有很多细节没有实现，比如添加得分、合成西瓜之后的撒花等功能，感兴趣的同学可以自己克隆去尝试修改一下。本文所有代码及素材都放在github上面了，也可以通过在线预览地址体验完成这个游戏花了这周六下午 + 一个晚上的时间，由于对 cocos creator 并不是很熟悉，因此花了一些时间去看文档、查资料，甚至去B站上看了点教学视频。不过收获的成就感与满足感还是很大的，也算是正儿八经写了点游戏。最后，尤其要感谢我媳妇，帮忙测试及提新需求。不说了，我还得再去加一个点击水果直接消除的功能！&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;微信无法点击游戏链接，请给我们公号发送&lt;code&gt;大西瓜&lt;/code&gt;获取入口
&lt;code&gt;开源前哨&lt;/code&gt; 日常分享热门、有趣和实用的开源项目。参与维护 10万+ Star 的开源技术资源库，包括：Python、Java、C/C++、Go、JS、CSS、Node.js、PHP、.NET 等。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9afc708d9e3e94822a0739b2f4532c99</guid>
<title>美团图数据库平台建设及业务实践</title>
<link>https://toutiao.io/k/c4zr3qj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section class=&quot;blog-content&quot;&gt;&lt;h1&gt;美团图数据库平台建设及业务实践&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;本文为 #nLive vol.001｜美团图数据库平台建设及业务实践# 主题演讲的文字稿，可前往 &lt;a href=&quot;https://www.bilibili.com/video/BV1qr4y1T7kZ/&quot;&gt;B站&lt;/a&gt; 观看本次视频&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://www-cdn.nebula-graph.com.cn/nebula-blog/meituan-graph-database-practice-01.jpg&quot; alt=&quot;美团图数据库平台建设及业务实践&quot;/&gt;&lt;/p&gt;&lt;p&gt;大家好，我是来自美团的赵登昌，今天我给大家分享下美团图数据库平台的建设以及业务实践。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www-cdn.nebula-graph.com.cn/nebula-blog/meituan-graph-database-practice-02.jpg&quot; alt=&quot;美团图数据库平台建设及业务实践&quot;/&gt;&lt;/p&gt;&lt;p&gt;这是本次报告的提纲，主要包括以下六方面内容。&lt;/p&gt;&lt;h2 id=&quot;背景介绍&quot;&gt;背景介绍&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://www-cdn.nebula-graph.com.cn/nebula-blog/meituan-graph-database-practice-03.jpg&quot; alt=&quot;美团图数据库平台建设及业务实践&quot;/&gt;&lt;/p&gt;&lt;p&gt;首先介绍下美团在图数据方面的业务需求。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www-cdn.nebula-graph.com.cn/nebula-blog/meituan-graph-database-practice-04.jpg&quot; alt=&quot;美团图数据库平台建设及业务实践&quot;/&gt;&lt;/p&gt;&lt;p&gt;美团内部有比较多的图数据存储以及多跳查询需求，总体来说有以下 4 个方面：&lt;/p&gt;&lt;p&gt;第一个方面是&lt;strong&gt;知识图谱&lt;/strong&gt;方向，美团内部有美食图谱、商品图谱、旅游图谱在内的近 10 个领域知识图谱，数据量级大概在千亿级别。在迭代、挖掘数据的过程中，需要一种组件对这些图谱数据进行统一管理。&lt;/p&gt;&lt;p&gt;第二个方面是&lt;strong&gt;安全风控&lt;/strong&gt;。业务部门有内容风控的需求，希望在商户、用户、评论中通过多跳查询来识别虚假评价；在支付时进行金融风控验证，实时多跳查询风险点。&lt;/p&gt;&lt;p&gt;第三个方面是&lt;strong&gt;链路分析&lt;/strong&gt;，比如说：数据血缘管理，公司数据平台上有很多 ETL Job，Job 和 Job 之间存在强弱依赖关系，这些强弱依赖关系形成了一张图，在进行 ETL Job 的优化或者故障处理时，需要对这个图进行分析。类似的需求还有代码分析、服务治理等。&lt;/p&gt;&lt;p&gt;第四个方面是&lt;strong&gt;组织架构管理&lt;/strong&gt;，包括：公司组织架构的管理，实线汇报链、虚线汇报链、虚拟组织的管理，以及商家连锁门店的管理。比如，需要管理一个商家在不同区域都有哪些门店，能够进行多层关系查找或者逆向关系搜索。&lt;/p&gt;&lt;p&gt;总体来说，我们需要一种组件来管理千亿级别的图数据，解决图数据存储以及多跳查询问题。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www-cdn.nebula-graph.com.cn/nebula-blog/meituan-graph-database-practice-05.jpg&quot; alt=&quot;美团图数据库平台建设及业务实践&quot;/&gt;&lt;/p&gt;&lt;p&gt;传统的关系型数据库、NoSQL 数据库可以用来存储图数据，但是不能很好处理图上多跳查询这一高频操作。Neo4j 公司在社交场景做了 MySQL 和 Neo4j 的多跳查询性能对比，具体测试场景是，在一个 100 万人、每个人大概有 50 个朋友的社交网络里找最大深度为 5 的朋友的朋友。从测试结果看，查询深度增大到 5 时， MySQL 已经查不出结果了，但 Neo4j 依然能在秒级返回数据。实验结果表明多跳查询中图数据库优势明显。&lt;/p&gt;&lt;h2 id=&quot;图数据库选型&quot;&gt;图数据库选型&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://www-cdn.nebula-graph.com.cn/nebula-blog/meituan-graph-database-practice-06.jpg&quot; alt=&quot;美团图数据库平台建设及业务实践&quot;/&gt;&lt;/p&gt;&lt;p&gt;下面介绍我们的图数据库选型工作。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www-cdn.nebula-graph.com.cn/nebula-blog/meituan-graph-database-practice-07.jpg&quot; alt=&quot;美团图数据库平台建设及业务实践&quot;/&gt;&lt;/p&gt;&lt;p&gt;我们主要有以下 5 个图数据库选型要求&lt;/p&gt;&lt;ul&gt;&lt;li&gt;A. 项目开源，暂时不考虑需要付费的图数据库；&lt;/li&gt;&lt;li&gt;B. 分布式的架构设计，具备良好的可扩展性；&lt;/li&gt;&lt;li&gt;C. 毫秒级的多跳查询延迟；&lt;/li&gt;&lt;li&gt;D. 支持千亿量级点边存储；&lt;/li&gt;&lt;li&gt;E. 具备批量从数仓导入数据的能力。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;我们分析了 DB-Engine 上排名 Top30 的图数据库，剔除不开源的项目后，把剩下的图数据库分成三类。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;第一类包括 Neo4j、ArangoDB、Virtuoso、TigerGraph、RedisGraph。此类图数据库只有单机版本开源可用，性能比较优秀，但是不能应对分布式场景中数据的规模增长，即不满足选型要求 B、D；&lt;/li&gt;&lt;li&gt;第二类包括 JanusGraph、HugeGraph。此类图数据库在现有存储系统之上新增了通用的图语义解释层，图语义层提供了图遍历的能力，但是受到存储层或者架构限制，不支持完整的计算下推，多跳遍历的性能较差，很难满足 OLTP 场景下对低延时的要求，即不满足选型要求 C；&lt;/li&gt;&lt;li&gt;第三类包括 Dgraph、Nebula Graph。此类图数据库根据图数据的特点对数据存储模型、点边分布、执行引擎进行了全新设计，对图的多跳遍历进行了深度优化，基本满足我们对图数据库的选型要求&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://www-cdn.nebula-graph.com.cn/nebula-blog/meituan-graph-database-practice-08.jpg&quot; alt=&quot;美团图数据库平台建设及业务实践&quot;/&gt;&lt;/p&gt;&lt;p&gt;之后我们在一个公开社交数据集上（大约 200 亿点边）对 Nebula Graph 、Dgraph 、HugeGraph 进行了深度性能测评。主要从三个方面进行评测：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;批量数据的导入&lt;/li&gt;&lt;li&gt;实时写入性能测试&lt;/li&gt;&lt;li&gt;数据多跳查询性能测试&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;测试详情见 Nebula 论坛：&lt;a href=&quot;https://discuss.nebula-graph.com.cn/t/topic/1377&quot;&gt;主流开源分布式图数据库Benchmark 🔗&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www-cdn.nebula-graph.com.cn/nebula-blog/meituan-graph-database-practice-09.jpg&quot; alt=&quot;美团图数据库平台建设及业务实践&quot;/&gt;&lt;/p&gt;&lt;p&gt;从测试结果看 Nebula Graph 在数据导入、实时写入及多跳查询方面性能均优于竞品。此外，Nebula Graph 社区活跃，问题的响应速度快，所以团队最终选择了基于 Nebula Graph 来搭建图数据库平台。&lt;/p&gt;&lt;h2 id=&quot;图数据库平台建设&quot;&gt;图数据库平台建设&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://www-cdn.nebula-graph.com.cn/nebula-blog/meituan-graph-database-practice-10.jpg&quot; alt=&quot;美团图数据库平台建设及业务实践&quot;/&gt;&lt;/p&gt;&lt;p&gt;下面介绍美团图数据库平台的建设，整个图数据库平台包括 4 层。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www-cdn.nebula-graph.com.cn/nebula-blog/meituan-graph-database-practice-11.jpg&quot; alt=&quot;美团图数据库平台建设及业务实践&quot;/&gt;&lt;/p&gt;&lt;p&gt;第一层是&lt;strong&gt;数据生产层&lt;/strong&gt;，平台的图数据主要有两种来源，第一种是业务方把数仓中数据通过 ETL Job 转成点和边的 Hive 表，然后离线导入到图数据库中；第二种是业务线上实时产生的数据、或者通过 Spark、Flink 等流式处理产生的近线数据，实时地通过 Nebula Graph 提供的在线批量接口灌到图数据库中。&lt;/p&gt;&lt;p&gt;第二层是&lt;strong&gt;数据存储层&lt;/strong&gt;，平台支持两种图数据库集群的部署方式。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;第一种是 CP 方案，即 Consistency &amp;amp; Partition tolerance，这是 Nebula Graph 原生支持的集群部署方式。单集群部署，集群中机器数量大于等于副本的数量，副本数量大于等于 3 。只要集群中有大于副本数一半的机器存活，整个集群就可以对外正常提供服务。CP 方案保证了数据读写的强一致性，但这种部署方式下集群可用性不高。&lt;/li&gt;&lt;li&gt;第二种部署方式是 AP 方案，即 Availability &amp;amp; Partition tolerance，在一个应用中部署多个图数据库集群，每个集群数据副本数为 1 ，多集群之间进行互备。这种部署方式的好处在于整个应用对外的可用性高，但数据读写的一致性要差点。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;第三层是&lt;strong&gt;数据应用层&lt;/strong&gt;，业务方可以在业务服务中引入平台提供的图谱 SDK，实时地对图数据进行增删改查。&lt;/p&gt;&lt;p&gt;第四层是&lt;strong&gt;支撑平台&lt;/strong&gt;，提供了 Schema 管理、权限管理、数据质检、数据增删改查、集群扩缩容、图谱画像、图数据导出、监控报警、图可视化、集群包管理等功能。&lt;/p&gt;&lt;p&gt;经过这四层架构设计，目前图数据库平台基本具备了对图数据的一站式自助管理功能。如果某个业务方要使用这种图数据库能力，那么业务方可以在这个平台上自助地创建图数据库集群、创建图的 Schema、导入图数据、配置导入数据的执行计划、引入平台提供的 SDK 对数据进行操作；平台侧主要负责各业务方图数据库集群的稳定性。目前有三、四十个业务在平台上真正落地，基本能满足各个业务方需求。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www-cdn.nebula-graph.com.cn/nebula-blog/meituan-graph-database-practice-12.jpg&quot; alt=&quot;美团图数据库平台建设及业务实践&quot;/&gt;&lt;/p&gt;&lt;p&gt;再介绍下图数据库平台中几个核心模块的设计。&lt;/p&gt;&lt;h3 id=&quot;高可用模块设计&quot;&gt;高可用模块设计&lt;/h3&gt;&lt;p&gt;首先是单应用多集群高可用模块的设计（AP 方案）。为什么有 AP 方案的设计呢？因为接入这个图数据库平台的业务方比较在意的指标是集群可用性。在线服务对集群的可用性要求非常高，最基础的要求是集群可用性能达到 4 个 9，即一年里集群的不可用时间要小于一个小时，对于在线服务来说，服务或者集群的可用性是整个业务的生命线，如果这点保证不了，即使集群提供的能力再多再丰富，那么业务方也不会考虑使用，可用性是业务选型的基础。&lt;/p&gt;&lt;p&gt;另外公司要求中间件要有跨区域容灾能力，即要具备在多个地域部署多集群的能力。我们分析了平台接入方的业务需求，大约 80% 的场景是 T+1 全量导入数据、线上只读；在这种场景下对图数据的读写强一致性要求并不高，因此我们设计了单应用多集群这种部署方案。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www-cdn.nebula-graph.com.cn/nebula-blog/meituan-graph-database-practice-30.png&quot; alt=&quot;美团图数据库平台建设及业务实践&quot;/&gt;&lt;/p&gt;&lt;p&gt;部署方式可以参考上图，一个业务方在图数据库平台上创建了 1 个应用并部署了 4 个集群，其中北京 2 个、上海 2 个，平时这 4 个集群同时对外提供服务。假如现在北京集群 1 挂了，那么北京集群 2 可以提供服务。如果说真那么不巧，北京集群都挂了，或者对外的网络不可用，那么上海的集群可以提供服务，这种部署方式下，平台会尽可能地通过一些方式来保证整个应用的可用性。然后每个集群内部尽量部署同机房的机器，因为图数据集群内部 RPC 是非常多的，如果有跨机房或者跨区域的频繁调用，整个集群对外的性能会比较低。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www-cdn.nebula-graph.com.cn/nebula-blog/meituan-graph-database-practice-13.jpg&quot; alt=&quot;美团图数据库平台建设及业务实践&quot;/&gt;&lt;/p&gt;&lt;p&gt;这个 AP 模块的设计主要包含下面 4 个部分：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;第一部分是右侧的图数据库 Agent，它是部署在图数据库集群的一个进程，用来收集机器和Nebula Graph 三个核心模块的信息，并上报到图数据库平台。Agent 能够接收图数据库平台的命令并对图数据库进行操作。&lt;/li&gt;&lt;li&gt;第二部分是图管理平台，它主要是对集群进行管理，并同步图数据库集群的状态到配置中心。&lt;/li&gt;&lt;li&gt;第三部分是图数据库 SDK，它主要做的事情是管理连接到图数据库集群的连接。如果业务方发送了某个查询请求，SDK 会进行集群的路由和负载均衡，选择出一条高质量的连接来发送请求。此外，SDK 还会处理图数据库集群中问题机器的自动降级以及恢复，并且要支持平滑切换集群的数据版本。&lt;/li&gt;&lt;li&gt;第四部分是配置中心，类似 ZooKeeper，存储集群的当前状态。&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;每小时百亿级数据导入模块设计&quot;&gt;每小时百亿级数据导入模块设计&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://www-cdn.nebula-graph.com.cn/nebula-blog/meituan-graph-database-practice-14.jpg&quot; alt=&quot;美团图数据库平台建设及业务实践&quot;/&gt;&lt;/p&gt;&lt;p&gt;第二个模块是每小时百亿量级数据导入模块，上面说了业务场景里 80% 是 T+1 全量导入数据，然后线上只读。平台在 19 年底 / 20 年初全量导入数据的方式是调用 Nebula Graph 对外提供的批量数据导入接口，这种方式的数据写入速率大概是每小时 10 亿级别，导入百亿数据大概要耗费 10 个小时，这个时间有点久。此外，在以几十万每秒的速度导数据的过程中，会长期占用机器的 CPU、IO 资源，一方面会对机器造成损耗，另一方面数据导入过程中集群对外提供的读性能会变弱。&lt;/p&gt;&lt;p&gt;为了解决上面两个问题，平台进行了如下优化：在 Spark 集群中直接生成图数据库底层文件 sst file，再借助 RocksDB 的 bulkload 功能直接 ingest 文件到图数据库。这部分提速优化工作在 19 年底的时候就开始了，但是中间遇到 core dump 问题没有上线。在 20 年六、七月份的时候，微信的本利大佬向社区提交了这方面的 pr，和他在线沟通之后解决了我们的问题，在这里感谢一下本利大佬 💐 。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www-cdn.nebula-graph.com.cn/nebula-blog/meituan-graph-database-practice-31.png&quot; alt=&quot;美团图数据库平台建设及业务实践&quot;/&gt;&lt;/p&gt;&lt;p&gt;图数据库平台数据导入的核心流程可以看右边这张图，当用户在平台上提交了导数据操作后，图数据库平台会向公司的 Spark 集群提交一个 Spark 任务，在 Spark 任务中会生成图数据库里相关的点、边以及点索引、边索引相关的 sst 文件，并上传到公司的 S3 云存储上。文件生成后，图数据库平台会通知应用里的多个集群去下载这些存储文件，之后完成 ingest 跟 compact 操作，最后完成数据版本的切换。&lt;/p&gt;&lt;p&gt;平台方为兼顾各个业务方的不同需求，统一了应用导入、集群导入、离线导入、在线导入以及全量导入、增量导入这些场景，然后细分成下面九个阶段，从流程上保证在导数据过程中应用整体的可用性。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;sst file生成&lt;/li&gt;&lt;li&gt;sst file下载&lt;/li&gt;&lt;li&gt;ingest&lt;/li&gt;&lt;li&gt;compact&lt;/li&gt;&lt;li&gt;数据校验&lt;/li&gt;&lt;li&gt;增量回溯&lt;/li&gt;&lt;li&gt;数据版本切换&lt;/li&gt;&lt;li&gt;集群重启&lt;/li&gt;&lt;li&gt;数据预热&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;实时写入多集群数据同步模块设计&quot;&gt;实时写入多集群数据同步模块设计&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://www-cdn.nebula-graph.com.cn/nebula-blog/meituan-graph-database-practice-15.jpg&quot; alt=&quot;美团图数据库平台建设及业务实践&quot;/&gt;&lt;/p&gt;&lt;p&gt;第三个模块是实时写入多集群数据同步，平台有 15% 的需求场景是在实时读取数据时，还要把新产生的业务数据实时写入集群，并且对数据的读写强一致性要求不高，就是说业务方写到图数据库里的数据，不需要立马能读到。&lt;/p&gt;&lt;p&gt;针对上述场景，业务方在使用单应用多集群这种部署方案时，多集群里的数据需要保证最终一致性。平台做了以下设计，&lt;strong&gt;第一部分是引入 Kafka 组件，业务方在服务中通过 SDK 对图数据库进行写操作时，SDK 并不直接写图数据库，而是把写操作写到 Kafka 队列里，之后由该应用下的多个集群异步消费这个 Kafka 队列&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www-cdn.nebula-graph.com.cn/nebula-blog/meituan-graph-database-practice-16.jpg&quot; alt=&quot;美团图数据库平台建设及业务实践&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第二部分是集群在应用级别可配置消费并发度，来控制数据写入集群的速度&lt;/strong&gt;。具体流程是&lt;/p&gt;&lt;ul&gt;&lt;li&gt;SDK 对用户写操作语句做语法解析，将其中点边的批量操作拆解成对单个点边操作，即对写语句做一次改写&lt;/li&gt;&lt;li&gt;Agent 消费 Kafka 时确保每个点及其出边相关操作在单个线程里顺序执行，保证这点就能保证各个集群执行完写操作后最终的结果是一致的。&lt;/li&gt;&lt;li&gt;并发扩展：通过改变 Kafka 分片数、Agent 中消费 Kafka 线程数来变更和调整 Kafka 中操作的消费速度。&lt;/li&gt;&lt;li&gt;如果未来 Nebula Graph 支持事务的话，上面的配置需要调整成单分片单线程消费，平台需要对设计方案再做优化调整。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://www-cdn.nebula-graph.com.cn/nebula-blog/meituan-graph-database-practice-17.jpg&quot; alt=&quot;美团图数据库平台建设及业务实践&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第三部分是在实时写入数据过程中，图数据库平台可以同步生成一个全量数据版本，并做平滑切换，通过右图里的流程来确保数据的不重不漏不延迟&lt;/strong&gt;。&lt;/p&gt;&lt;h3 id=&quot;图可视化模块设计&quot;&gt;图可视化模块设计&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://www-cdn.nebula-graph.com.cn/nebula-blog/meituan-graph-database-practice-18.jpg&quot; alt=&quot;美团图数据库平台建设及业务实践&quot;/&gt;&lt;/p&gt;&lt;p&gt;第四个模块是图可视化模块，平台在 2020 年上半年调研了 Nebula Graph 官方的图可视化设计跟一些第三方开源的可视化组件，然后在图数据库平台上增加了通用的图可视化功能，主要是用于解决子图探索问题；当用户在图数据库平台通过可视化组件查看图数据时，能尽量通过恰当的交互设计来避免因为节点过多而引发爆屏。&lt;/p&gt;&lt;p&gt;目前，平台上的可视化模块有下面几个功能。&lt;/p&gt;&lt;p&gt;第一个是通过 ID 或者索引查找顶点。&lt;/p&gt;&lt;p&gt;第二个是能查看顶点和边的卡片（卡片中展示点边属性和属性值），可以单选、多选、框选以及按类型选择顶点。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www-cdn.nebula-graph.com.cn/nebula-blog/meituan-graph-database-practice-32.png&quot; alt=&quot;美团图数据库平台建设及业务实践&quot;/&gt;&lt;/p&gt;&lt;p&gt;第三个是图探索，当用户点击某个顶点时，系统会展示它的一跳邻居信息，包括：该顶点有哪些出边？通过这个边它能 Touch 到几个点？该顶点的入边又是什么情况？通过这种一跳信息的展示，用户在平台上探索子图的时候，可快速了解到周边的邻居信息，更快地进行子图探索。在探索过程中，平台也支持对边进行过滤。&lt;/p&gt;&lt;p&gt;第四个是图编辑能力，让平台用户在不熟悉 Nebula Graph 语法的情况下也能增删改点边数据，对线上数据进行临时的干预。&lt;/p&gt;&lt;h2 id=&quot;业务实践&quot;&gt;业务实践&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://www-cdn.nebula-graph.com.cn/nebula-blog/meituan-graph-database-practice-19.jpg&quot; alt=&quot;美团图数据库平台建设及业务实践&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www-cdn.nebula-graph.com.cn/nebula-blog/meituan-graph-database-practice-20.jpg&quot; alt=&quot;美团图数据库平台建设及业务实践&quot;/&gt;&lt;/p&gt;&lt;p&gt;下面来介绍下接入我们平台的一些落地项目。&lt;/p&gt;&lt;p&gt;第一个项目是&lt;strong&gt;智能助理&lt;/strong&gt;，它的数据是基于美团商户数据、用户评论构建的餐饮娱乐知识图谱，覆盖美食、酒店、旅游等领域，包含 13 类实体和 22 类关系。目前点边数量大概在百亿级别，数据是 T+1 全量更新，主要用于解决搜索或者智能助理里 KBQA（全称：Knowledge Based Question Answer）类的问题。核心处理流程是通过 NLP 算法识别关系和实体后构造出 Nebula Graph SQL 语句，再到图数据库获取数据。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www-cdn.nebula-graph.com.cn/nebula-blog/meituan-graph-database-practice-33.png&quot; alt=&quot;美团图数据库平台建设及业务实践&quot;/&gt;&lt;/p&gt;&lt;p&gt;典型的应用场景有商场找店，比如，某个用户想知道望京新荟城这个商场有没有海底捞，智能助理就能快速查出结果告诉用户。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www-cdn.nebula-graph.com.cn/nebula-blog/meituan-graph-database-practice-34.png&quot; alt=&quot;美团图数据库平台建设及业务实践&quot;/&gt;&lt;/p&gt;&lt;p&gt;还有一个典型场景是标签找店，想知道望京 SOHO 附近有没有适合情侣约会的餐厅，或者你可以多加几个场景标签，系统都能给你查找出来。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www-cdn.nebula-graph.com.cn/nebula-blog/meituan-graph-database-practice-21.jpg&quot; alt=&quot;美团图数据库平台建设及业务实践&quot;/&gt;&lt;/p&gt;&lt;p&gt;第二个是&lt;strong&gt;搜索召回&lt;/strong&gt;，数据主要是基于医美商家信息构建的医美知识图谱，包含 9 类实体和 13 类关系，点边数量在百万级别，同样也是 T+1 全量更新，主要用于大搜底层实时召回，返回与 query 相关的商户、产品或医生信息，解决医美类搜索词少结果、无结果问题。比如，某个用户搜“啤酒肚”这种症状、或者“润百颜”这类品牌，系统都能给他召回相关的医美门店。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www-cdn.nebula-graph.com.cn/nebula-blog/meituan-graph-database-practice-22.jpg&quot; alt=&quot;美团图数据库平台建设及业务实践&quot;/&gt;&lt;/p&gt;&lt;p&gt;第三个是&lt;strong&gt;图谱推荐理由&lt;/strong&gt;，数据来自用户的画像信息、商户的特征信息、用户半年内收藏/购买行为，现在的数据量级是 10 亿级别， T+1 全量更新。这个项目的目标是给出美食列表推荐商户的可解释理由。为什么会做这个事呢？现在美团 App 和点评 App 上默认的商户推荐列表是由深度学习模型生成的，但模型并不会给出生成这个列表的理由，缺少可解释性。然而在图谱里用户跟商户之间天然存在多条连通路径，我们希望能选出一条合适路径来生成推荐理由，在 App 界面上展示给用户推荐某家店的原因。比如我们可以基于用户的协同过滤算法来生成推荐理由，在家乡、消费水平、偏好类目、偏好菜系等多个组合维度中找出多条路径，然后给这些路径打分，选出一条分值较高的路径，之后按照特定 pattern 产出推荐理由。通过上述方式，就可以获得&lt;code&gt;在北京喜欢北京菜的山东老乡都说这家店很赞&lt;/code&gt;，或者&lt;code&gt;广州老乡都中意他家的正宗北京炸酱面&lt;/code&gt;这类理由。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www-cdn.nebula-graph.com.cn/nebula-blog/meituan-graph-database-practice-23.jpg&quot; alt=&quot;美团图数据库平台建设及业务实践&quot;/&gt;&lt;/p&gt;&lt;p&gt;第四个是&lt;strong&gt;代码依赖分析&lt;/strong&gt;，是把公司里的代码库中代码依赖关系写到图数据库。公司代码库里有很多服务代码，这些服务都会有对外提供的接口，这些接口的实现依赖于该服务中某些类的成员函数，这些类的成员函数又依赖了本类的成员变量、成员函数、或者其它类的成员函数，那么它们之间的依赖关系就形成了一张图，我们把这个图写到图数据库里，做什么事呢？&lt;/p&gt;&lt;p&gt;典型场景是 QA 的精准测试，当 RD 完成需求并向公司的代码仓库提交了他的 pr 后，这些更改会实时地写到图数据库中，所以 RD 就能查到他所写的代码影响了哪些外部接口，并且能展示出调用路径来。如果 RD 本来是要改接口 A 的行为，他改了很多东西，但是他可能并不知道他改的东西也会影响到对外接口 B、C、D，这时候就可以用代码依赖分析来做个 Check。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www-cdn.nebula-graph.com.cn/nebula-blog/meituan-graph-database-practice-24.jpg&quot; alt=&quot;美团图数据库平台建设及业务实践&quot;/&gt;&lt;/p&gt;&lt;p&gt;第五个是&lt;strong&gt;服务治理&lt;/strong&gt;，美团内部有几十万个微服务，这些微服务之间存在互相调用关系，这些调用关系形成了一张图。我们把这些调用关系实时写入图数据库里，然后做一些服务链路治理和告警优化工作。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www-cdn.nebula-graph.com.cn/nebula-blog/meituan-graph-database-practice-25.jpg&quot; alt=&quot;美团图数据库平台建设及业务实践&quot;/&gt;&lt;/p&gt;&lt;p&gt;第六个项目是&lt;strong&gt;数据血缘&lt;/strong&gt;，把数仓中 ETL 任务的依赖关系写到了图数据库中，大概是千万级别的数据量级，数据实时写入，每天凌晨做一次全量 reload，主要是用来查找数据任务的上下游依赖。比如说，通过这个 FIND NOLOOP PATH FROM hash(‘task1’) OVER depend WHERE depend.type == ‘强依赖’ UPTO 50 STEPS 语句找出 task1 这个任务的所有强依赖路径。这里，我们针对 Nebula Graph 官方的 FIND PATH 功能做了一些加强，添加了无环路径的检索跟 WHERE 语句过滤。&lt;/p&gt;&lt;h2 id=&quot;美团和-nebula&quot;&gt;美团和 Nebula&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://www-cdn.nebula-graph.com.cn/nebula-blog/meituan-graph-database-practice-26.jpg&quot; alt=&quot;美团图数据库平台建设及业务实践&quot;/&gt;&lt;/p&gt;&lt;p&gt;最后，来介绍下团队对社区的贡献。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www-cdn.nebula-graph.com.cn/nebula-blog/meituan-graph-database-practice-27.jpg&quot; alt=&quot;美团图数据库平台建设及业务实践&quot;/&gt;&lt;/p&gt;&lt;p&gt;为了更好地满足图数据库平台上用户的需求，我们对 Nebula Graph 1.0的内核做了部分功能的扩充和部分性能的优化，并把相对来说比较通用的功能给 Nebula Graph 社区提了 PR，也向社区公众号投稿了一篇 &lt;a href=&quot;https://discuss.nebula-graph.com.cn/t/topic/1377&quot;&gt;主流开源分布式图数据库Benchmark 🔗 &lt;/a&gt;。&lt;/p&gt;&lt;p&gt;当然，我们通过 Nebula Graph 解决了公司内的很多业务问题，目前对 Nebula Graph 社区做的贡献还比较少，后续会加强在社区技术共享方面的工作，希望能够培养出越来越多的 Nebula Committer。&lt;/p&gt;&lt;h2 id=&quot;美团图数据库平台的未来规划&quot;&gt;美团图数据库平台的未来规划&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://www-cdn.nebula-graph.com.cn/nebula-blog/meituan-graph-database-practice-28.jpg&quot; alt=&quot;美团图数据库平台建设及业务实践&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www-cdn.nebula-graph.com.cn/nebula-blog/meituan-graph-database-practice-29.jpg&quot; alt=&quot;美团图数据库平台建设及业务实践&quot;/&gt;&lt;/p&gt;&lt;p&gt;未来规划主要有两个方面，第一方面是等 Nebula Graph 2.0 的内核相对稳定后，在我们图数据库平台上适配 Nebula Graph 2.0 内核。第二方面是去挖掘更多的图数据价值。现在美团图数据库平台支持了图数据存储及多跳查询这种基本能力，后续我们打算基于 Nebula Graph 去探索一下图学习、图计算的能力，给平台用户提供更多挖掘图数据价值的功能。&lt;/p&gt;&lt;p&gt;以上为本次美团 NLP 技术专家——赵登昌老师带来的图数据库平台建设方面的分享。&lt;/p&gt;&lt;p&gt;如果你对【图存储】、【图学习】、【图计算】感兴趣，欢迎向赵登昌老师投递简历，投递邮箱：zhaodengchang@meituan.com。&lt;/p&gt;&lt;p&gt;喜欢这篇文章？来来来，给我们的 &lt;a href=&quot;https://github.com/vesoft-inc/nebula&quot;&gt;GitHub&lt;/a&gt; 点个 star 表鼓励啦~~ 🙇‍♂️🙇‍♀️ [手动跪谢]&lt;/p&gt;&lt;p&gt;交流图数据库技术？交个朋友，Nebula Graph 官方小助手微信：&lt;a href=&quot;https://www-cdn.nebula-graph.com.cn/nebula-blog/nbot.png&quot;&gt;NebulaGraphbot&lt;/a&gt; 拉你进交流群~~&lt;/p&gt;&lt;blockquote class=&quot;star-ads&quot;&gt;&lt;span&gt;你喜欢这篇文章吗? 喜欢的话，给我们点个&lt;/span&gt;
&lt;span&gt;star 吧:&lt;/span&gt;
&lt;a href=&quot;https://github.com/vesoft-inc/nebula&quot;&gt;https://github.com/vesoft-inc/nebula&lt;/a&gt;&lt;/blockquote&gt;&lt;p id=&quot;discourse-comments&quot;/&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>