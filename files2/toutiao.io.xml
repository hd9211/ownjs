<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f3edf1b859ee8ff280db3074224f9fba</guid>
<title>从维护性工作到软件开发革命，运维 15 年间的大逆转</title>
<link>https://toutiao.io/k/xr13s7n</link>
<content:encoded>&lt;div&gt;&lt;body id=&quot;readabilityBody&quot;&gt;
&lt;p id=&quot;app&quot;/&gt;
&lt;img src=&quot;https://static001.infoq.cn/static/infoq/img/logo-121-75.yuij86g.png&quot; alt=&quot;从维护性工作到软件开发革命，运维15年间的大逆转_DevOps_Tina_InfoQ精选文章&quot;/&gt;





    

&lt;/body&gt;
&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ddbdb065bf9499af70fdb18f8f106621</guid>
<title>从HTTP.TRANSPORT看连接池的设计</title>
<link>https://toutiao.io/k/sl5a7p7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entry-content e-content&quot; itemprop=&quot;description articleBody&quot;&gt;&amp;#13;
            &lt;pre&gt;&lt;code class=&quot;&quot;&gt;版权声明 本站原创文章 由 萌叔 发表
转载请注明 萌叔 | http://vearne.cc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本文基于Golang 1.17.6&lt;/p&gt;
&lt;h2&gt;1.前言&lt;/h2&gt;
&lt;p&gt;之前萌叔曾在文章&lt;br/&gt;
&lt;a href=&quot;https://vearne.cc/archives/448&quot;&gt;imroc/req 连接池使用须知&lt;/a&gt; 提及过Golang标准库net/http提供的连接池http.Transport，但是是浅尝辄止。&lt;br/&gt;
本文萌叔想从http.Transport出发来谈谈一个连接池设计应该考虑哪些问题？&lt;/p&gt;
&lt;h2&gt;2.连接池的功能特征&lt;/h2&gt;
&lt;p&gt;下图是针对Grpc和Thrift压测结果(见参考资料1)。我么可以看出，长连接相比与短连接相比，QPS大概提升了1倍多。这是因为长连接减少连接建立的所需的3次握手。&lt;br/&gt;
&lt;img src=&quot;https://ut-bucket01.sh1a.qingstor.com/woshiaotian/20220620/607da666-f04a-11ec-8e33-5626e1cdcfe1.jpg&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;
要对长连接进行管理，特别是对闲置的长连接进行管理，就不可避免的引入连接池。&lt;/p&gt;
&lt;h2&gt;特征&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;需要一个连接时，并不一定真的创建新连接，而是优先尝试从连接池选出空闲连接;如果连接池对应的连接为空，才创建新连接。&lt;/li&gt;
&lt;li&gt;销毁并不是真的销毁，而是将使用完毕的连接放回连接池中（逻辑关闭）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里引出了几个问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Q1:获取连接阶段，我们有没有办法知道从连接池中取出的空闲连接(复用)是有效的，还是无效的？&lt;/li&gt;
&lt;li&gt;Q2:把使用完毕的连接放回连接池的阶段，空闲连接数量是否要做上限的约束。如果空闲连接数量有上限约束且空闲连接的数量已经达到上限。那么把连接放回连接池的过程，必然需要将之前的某个空闲连接进行关闭，那么按照什么规则选择这个需要关闭的连接。&lt;/li&gt;
&lt;li&gt;Q3:放置在连接池中的连接，随着时间的流逝，它可能会变成无效连接(stale)。比如由于Server端定时清理空闲连接。那么为了确保连接池中连接的有效性，是否需要引入定时的检查逻辑？&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;3.net/http中连接池的实现&lt;/h2&gt;
&lt;p&gt;net/http中连接池的实现代码在&lt;br/&gt;
&lt;a href=&quot;https://github.com/golang/go/blob/go1.17.6/src/net/http/transport.go#L95&quot;&gt;net/http/transport.go&lt;/a&gt; 中&lt;/p&gt;
&lt;h3&gt;获取连接&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;&quot;&gt;Transport.RoundTrip() -&amp;gt; Transport.getConn()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;放回连接(逻辑关闭)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;&quot;&gt;Response.Body.Close() -&amp;gt; bodyEOFSignal.Close() -&amp;gt; Transport.tryPutIdleConn()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://ut-bucket01.sh1a.qingstor.com/woshiaotian/20220620/a7f64d94-f05a-11ec-9d25-5626e1cdcfe1.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了约束空闲连接的数量，连接池引入了几个变量:&lt;br/&gt;
&lt;code&gt;MaxIdleConns&lt;/code&gt; MaxIdleConns controls the maximum number of idle (keep-alive) connections across all hosts.&lt;br/&gt;
所有host总的最大空闲连接数量，默认值是100&lt;br/&gt;
&lt;code&gt;MaxIdleConnsPerHost&lt;/code&gt;if non-zero, controls the maximum idle&lt;br/&gt;
(keep-alive) connections to keep per-host。&lt;br/&gt;
针对每个Host能够保持的最大空闲连接数量。默认值是2&lt;br/&gt;
这个是一个比较有意思的变量，因为默认情况，所有的HTTP请求都使用同一个连接池，由于&lt;code&gt;MaxIdleConns&lt;/code&gt;存在，如果针对某个Host的 连接占用了大量空间，那么针对其它Host的连接可能就没有存储空间了。&lt;br/&gt;
&lt;code&gt;MaxConnsPerHost&lt;/code&gt; MaxConnsPerHost optionally limits the total number of connections per host, including connections in the dialing, active, and idle states.&lt;br/&gt;
默认值是0，表示不限制。&lt;/p&gt;
&lt;h3&gt;有意思的点&lt;/h3&gt;
&lt;p&gt;transport中的连接是按照key存储，key可以对应到下面的结构&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;&quot;&gt;type connectMethod struct {
    _            incomparable
    proxyURL     *url.URL // nil for no proxy, else full proxy URL
    targetScheme string   // &quot;http&quot; or &quot;https&quot;
    // If proxyURL specifies an http or https proxy, and targetScheme is http (not https),
    // then targetAddr is not included in the connect method key, because the socket can
    // be reused for different targetAddr values.
    targetAddr string
    onlyH1     bool // whether to disable HTTP/2 and force HTTP/1
}
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;connectMethod.key().String()&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;|http|foo.com&lt;/td&gt;
&lt;td&gt;https directly to server, no proxy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;|https|foo.com&lt;/td&gt;
&lt;td&gt;https directly to server, no proxy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;|https,h1|foo.com&lt;/td&gt;
&lt;td&gt;https directly to server w/o HTTP/2, no proxy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;http://proxy.com|https|foo.com&lt;/td&gt;
&lt;td&gt;http to proxy, then CONNECT to foo.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;http://proxy.com|http&lt;/td&gt;
&lt;td&gt;http to proxy, http to anywhere after that&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;socks5://proxy.com|http|foo.com&lt;/td&gt;
&lt;td&gt;socks5 to proxy, then http to foo.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;socks5://proxy.com|https|foo.com&lt;/td&gt;
&lt;td&gt;socks5 to proxy, then https to foo.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;https://proxy.com|https|foo.com&lt;/td&gt;
&lt;td&gt;https to proxy, then CONNECT to foo.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;https://proxy.com|http&lt;/td&gt;
&lt;td&gt;https to proxy, http to anywhere after that&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;: 目标地址如果是同一个域名则算作同一个Host&lt;/p&gt;
&lt;h3&gt;Q2：把连接放回连接池的过程，必然需要将之前的某个空闲连接进行关闭，那么按照什么规则选择这个需要关闭的连接。&lt;/h3&gt;
&lt;h3&gt;A2：&lt;/h3&gt;
&lt;p&gt;如果连接池已经满了（MaxIdleConns），那么放回空闲连接的同时，还需要从连接池中选出一个旧连接进行关闭。这个选择的规则依据LRU进行筛选。net/http使用的双向链表。&lt;/p&gt;
&lt;h3&gt;Q3: 为了确保连接池中连接的有效性，是否需要引入定时的检查逻辑？&lt;/h3&gt;
&lt;h3&gt;A3:&lt;/h3&gt;
&lt;p&gt;net/http没有引入定期检查逻辑，但是额外的增加了一个变量&lt;br/&gt;
&lt;code&gt;IdleConnTimeout&lt;/code&gt;: IdleConnTimeout is the maximum amount of time an idle (keep-alive) connection will remain idle before closing itself.&lt;br/&gt;
超过&lt;code&gt;IdleConnTimeout&lt;/code&gt;的空闲连接将强制关闭。默认设置是90秒。&lt;/p&gt;
&lt;p&gt;这个逻辑可能是：”过长时间的空闲连接都是不可信赖的”&lt;/p&gt;
&lt;p&gt;一个从连接池中获得的连接只有在真正使用时，才能确定它是否有效。&lt;br/&gt;
如果连接在使用时报错，需要执行shouldRetryRequest()以确定是否需要获取新连接来执行失败的HTTP请求。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;&quot;&gt;func (pc *persistConn) shouldRetryRequest(req *Request, err error) bool {
        ...
    if err == errServerClosedIdle {
        // The server replied with io.EOF while we were trying to
        // read the response. Probably an unfortunately keep-alive
        // timeout, just as the client was writing a request.
        return true
    }
    return false // conservatively
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;比如如果是&lt;code&gt;errServerClosedIdle&lt;/code&gt;，服务端关闭了空闲连接导致请求失败，那么显然应该重新获取一个新连接，再发起一次请求。&lt;/p&gt;
&lt;h2&gt;4. 总结&lt;/h2&gt;
&lt;p&gt;看net/http的连接池，萌叔发现它与数据库的连接池、甚至与进程内的本地缓存在设计要点有很多相似之处。比如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;连接池大小的限制  缓存大小的限制&lt;/li&gt;
&lt;li&gt;stale空闲连接的检查  过期key的清理&lt;/li&gt;
&lt;li&gt;达到空闲连接上限后，连接的换入换出  缓存满了之后，数据的换入换出&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;5. 参考资料&lt;/h2&gt;
&lt;p&gt;1.&lt;a href=&quot;https://blog.csdn.net/Com_ma/article/details/97134775&quot;&gt;grpc和thrift性能对比&lt;/a&gt;&lt;br/&gt;
2.&lt;a href=&quot;https://juejin.cn/post/6844903853872119822&quot;&gt;如何设计并实现一个db连接池？&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;h4&gt;请我喝瓶饮料&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://ut-bucket01.sh1a.qingstor.com/woshiaotian/20220421/e824ac06-c136-11ec-8e0e-5626e1cdcfe2.jpg&quot; alt=&quot;微信支付码&quot;/&gt;&lt;/p&gt;


            &lt;p class=&quot;clear&quot;/&gt;&amp;#13;
        &lt;/div&gt;&amp;#13;
        
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>60b906bc208db3d6569275c07c574c47</guid>
<title>如何学习架构，一个系列帮助你构筑架构知识体系</title>
<link>https://toutiao.io/k/i9clyuy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;theme-default-content content__default&quot;&gt;&lt;h1 id=&quot;♥架构---知识体系详解♥&quot;&gt;&lt;a href=&quot;#♥架构---知识体系详解♥&quot; class=&quot;header-anchor&quot;&gt;¶&lt;/a&gt; ♥架构 - 知识体系详解♥&lt;/h1&gt; &lt;div class=&quot;custom-block tip&quot;&gt;&lt;p class=&quot;custom-block-title&quot;&gt;TIP&lt;/p&gt; &lt;p&gt;本系列将带你梳理下架构相关的知识体系。@pdai&lt;/p&gt;&lt;/div&gt;  &lt;h2 id=&quot;如何学习架构&quot;&gt;&lt;a href=&quot;#如何学习架构&quot; class=&quot;header-anchor&quot;&gt;¶&lt;/a&gt; 如何学习架构&lt;/h2&gt;  &lt;p&gt;&lt;img alt=&quot;&quot; data-src=&quot;/_images/arch/arch-x-overview-learn2.png&quot; loading=&quot;lazy&quot; class=&quot;lazy&quot;/&gt;&lt;/p&gt; &lt;h3 id=&quot;基础到方法论&quot;&gt;&lt;a href=&quot;#基础到方法论&quot; class=&quot;header-anchor&quot;&gt;¶&lt;/a&gt; 基础到方法论&lt;/h3&gt; &lt;blockquote&gt;&lt;p&gt;包括架构的概述，特点，目标，本质以及方法论等&lt;/p&gt;&lt;/blockquote&gt;  &lt;h3 id=&quot;如何理解架构&quot;&gt;&lt;a href=&quot;#如何理解架构&quot; class=&quot;header-anchor&quot;&gt;¶&lt;/a&gt; 如何理解架构&lt;/h3&gt; &lt;blockquote&gt;&lt;p&gt;理解架构，包括架构的视角，架构的演进，服务化演进，架构的核心要素&lt;/p&gt;&lt;/blockquote&gt; &lt;ul&gt;&lt;li&gt;&lt;a href=&quot;/md/arch/arch-x-view.html&quot;&gt;架构 - 理解构架的视角&lt;/a&gt; &lt;ul&gt;&lt;li&gt;在学习架构时，我认为首先要理清楚架构的视角，&lt;strong&gt;因为你所认知的架构和别人所说的架构可能是两码事&lt;/strong&gt;。对于不同职位的视角是不一样的，比如开发而言他更多的看到的是开发架构；对售前人员，他可能更多的看到的是业务架构；对于运维人员，他看到的可能是运维架构；而对于技术支持和部署人员，他更多的看到的网络和物理架构。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/arch/arch-x-evolution.html&quot;&gt;架构 - 理解架构的演进&lt;/a&gt; &lt;ul&gt;&lt;li&gt;在学习架构时，&lt;strong&gt;第一步不要去学习框架，而是要学习架构的演进&lt;/strong&gt;。强烈推荐李智慧老师的《大型网站技术架构》，这本书翻起来很快，对构筑你自己的体系很有帮助，本文的内容来源于它，在此基础上拓展了下。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/arch/arch-x-service.html&quot;&gt;架构 - 理解架构的服务演化&lt;/a&gt; &lt;ul&gt;&lt;li&gt;Kubernetes、Service Mesh 和 Serverless应该是最近比较火的了，而上文主要从&lt;strong&gt;逻辑架构角度&lt;/strong&gt;分析了架构演进，本文将从&lt;strong&gt;服务演化&lt;/strong&gt;和&lt;strong&gt;容器编排化&lt;/strong&gt;的角度帮你增强对架构演进的认识。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/arch/arch-x-pattern.html&quot;&gt;架构 - 理解架构的模式1&lt;/a&gt; &lt;ul&gt;&lt;li&gt;架构演进中有很多知识点，总体上可以归结为以下模式，&lt;strong&gt;这里说的模式本质是架构中技术点的抽象&lt;/strong&gt;。强烈推荐李智慧老师的《大型网站技术架构》，本文的内容也是来源于它，在此基础上拓展了下。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/arch/arch-x-pattern-2.html&quot;&gt;架构 - 理解架构的模式2&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/arch/arch-x-core-metrics.html&quot;&gt;架构 - 理解架构的核心要素&lt;/a&gt; &lt;ul&gt;&lt;li&gt;一般来说软件架构需要关注&lt;strong&gt;性能、可用性、伸缩性、扩展性和安全性这5个架构要素&lt;/strong&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt; &lt;h3 id=&quot;架构高并发和高可用&quot;&gt;&lt;a href=&quot;#架构高并发和高可用&quot; class=&quot;header-anchor&quot;&gt;¶&lt;/a&gt; 架构高并发和高可用&lt;/h3&gt; &lt;blockquote&gt;&lt;p&gt;架构高并发和高可用技术点主要包含如下方面。&lt;/p&gt;&lt;/blockquote&gt; &lt;ul&gt;&lt;li&gt;&lt;a href=&quot;/md/arch/arch-y-cache.html&quot;&gt;架构之高并发：缓存&lt;/a&gt; &lt;ul&gt;&lt;li&gt;&lt;strong&gt;高并发实现的三板斧：缓存，限流和降级&lt;/strong&gt;。缓存在高并发系统中有者极其广阔的应用，需要重点掌握，本文重点介绍下缓存及其实现。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/arch/arch-y-ratelimit.html&quot;&gt;架构之高并发：限流&lt;/a&gt; &lt;ul&gt;&lt;li&gt;每个系统都有服务的上线，所以当流量超过服务极限能力时，系统可能会出现卡死、崩溃的情况，所以就有了降级和限流。限流其实就是：当高并发或者瞬时高并发时，为了保证系统的稳定性、可用性，系统以牺牲部分请求为代价或者延迟处理请求为代价，保证系统整体服务可用。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/arch/arch-y-reduce.html&quot;&gt;架构之高并发：降级和熔断&lt;/a&gt; &lt;ul&gt;&lt;li&gt;在高并发环境下，&lt;strong&gt;服务之间的依赖关系导致调用失败，解决的方式通常是: 限流-&amp;gt;熔断-&amp;gt;隔离-&amp;gt;降级, 其目的是防止雪崩效应&lt;/strong&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/arch/arch-y-loadbalance.html&quot;&gt;架构之高可用：负载均衡&lt;/a&gt; &lt;ul&gt;&lt;li&gt;负载均衡（Load Balance），意思是将负载（工作任务，访问请求）进行平衡、分摊到多个操作单元（服务器，组件）上进行执行。是解决高性能，单点故障（高可用），扩展性（水平伸缩）的终极解决方案。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/arch/arch-y-backup.html&quot;&gt;架构之高可用：容灾备份,故障转移&lt;/a&gt; &lt;ul&gt;&lt;li&gt;容灾技术是系统的高可用性技术的一个组成部分，容灾系统更加强调处理外界环境对系统的影响，特别是灾难性事件对整个IT节点的影响，提供节点级别的系统恢复功能。故障转移（failover），即当活动的服务或应用意外终止时，快速启用&lt;strong&gt;冗余&lt;/strong&gt;或备用的服务器、系统、硬件或者网络接替它们工作。故障恢复是在计划内或计划外中断解决后&lt;strong&gt;切换回主站点&lt;/strong&gt;的过程。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt; &lt;p&gt;此外还需要关注下架构的安全。&lt;/p&gt;  &lt;h3 id=&quot;分层下看架构技术点&quot;&gt;&lt;a href=&quot;#分层下看架构技术点&quot; class=&quot;header-anchor&quot;&gt;¶&lt;/a&gt; 分层下看架构技术点&lt;/h3&gt; &lt;p&gt;&lt;img alt=&quot;&quot; data-src=&quot;/_images/arch/arch-x-overview-layer2.jpg&quot; loading=&quot;lazy&quot; class=&quot;lazy&quot;/&gt;&lt;/p&gt; &lt;p&gt;以上采用七层逻辑架构，第一层客户层，第二层前端优化层，第三层应用层，第四层服务层，第五层数据存储层，第六层大数据存储层，第七层大数据处理层。&lt;/p&gt; &lt;ul&gt;&lt;li&gt;&lt;strong&gt;客户层&lt;/strong&gt;：减少Http请求数，浏览器缓存，启用压缩，Js异步，减少Cookie传输；&lt;/li&gt; &lt;li&gt;&lt;strong&gt;前端层&lt;/strong&gt;：DNS负载均衡，CDN本地加速，反向代理服务；&lt;/li&gt; &lt;li&gt;&lt;strong&gt;应用层&lt;/strong&gt;：业务拆分；负载均衡，分级管理，应用缓存，服务集群，快速失败，异步调用，服务降级，消息队列，幂等设计等。&lt;/li&gt; &lt;li&gt;&lt;strong&gt;服务层&lt;/strong&gt;：提供公用服务，比如用户服务，订单服务，支付服务等；&lt;/li&gt; &lt;li&gt;&lt;strong&gt;数据层&lt;/strong&gt;：分布式, 数据库集群，读写分离，NOSQL集群，文件系统集群；分布式缓存；冗余备份（冷，热备[同步，异步]，温备），失效转移（确认，转移，恢复）。CAP理论，一致性算法。&lt;/li&gt; &lt;li&gt;&lt;strong&gt;大数据存储层&lt;/strong&gt;：支持应用层和服务层的日志数据收集，关系数据库和NOSQL数据库的结构化和半结构化数据收集；&lt;/li&gt; &lt;li&gt;&lt;strong&gt;大数据处理层&lt;/strong&gt;：通过Mapreduce进行离线数据分析或Storm实时数据分析，并将处理后的数据存入关系型数据库。（实际使用中，离线数据和实时数据会按照业务要求进行分类处理，并存入不同的数据库中，供应用层或服务层使用）。&lt;/li&gt;&lt;/ul&gt; &lt;h3 id=&quot;架构案例分析&quot;&gt;&lt;a href=&quot;#架构案例分析&quot; class=&quot;header-anchor&quot;&gt;¶&lt;/a&gt; 架构案例分析&lt;/h3&gt;  &lt;p&gt;&lt;strong&gt;更多待整合的文章&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;如何从 0 到 1 设计、构建移动分析架构
https://blog.csdn.net/weixin_44326589/article/details/93463878&lt;/p&gt; &lt;p&gt;蚂蚁金服面对亿级并发场景的组件体系设计
https://juejin.im/post/5cda3131e51d4514df42076f&lt;/p&gt; &lt;p&gt;高德服务单元化方案和架构实践
https://yq.aliyun.com/articles/728021&lt;/p&gt; &lt;p&gt;从 0 到 100——知乎架构变迁史
https://www.infoq.cn/article/2014/12/zhihu-architecture-evolution/
https://www.jianshu.com/p/2639b7bb0d74&lt;/p&gt; &lt;p&gt;蚂蚁金服 11.11：支付宝和蚂蚁花呗的技术架构及实践
https://www.infoq.cn/article/technical-architecture-of-alipay-and-ant-check-later/&lt;/p&gt; &lt;p&gt;新浪微博王传鹏：微博推荐架构的演进
http://www.uml.org.cn/zjjs/2015092801.asp&lt;/p&gt; &lt;p&gt;互联网公司技术架构，微信/淘宝/微博/腾讯/阿里/美团点评/百度/Google/Facebook/Amazon/eBay的架构
https://github.com/davideuler/architecture.of.internet-product&lt;/p&gt;&lt;/div&gt; &lt;footer class=&quot;page-edit&quot;&gt; &lt;p class=&quot;last-updated&quot;&gt;&lt;span class=&quot;prefix&quot;&gt;上次更新: &lt;/span&gt; &lt;span class=&quot;time&quot;&gt;2022/5/17 下午10:43:17&lt;/span&gt;&lt;/p&gt;&lt;/footer&gt; &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>352eb263dd2770c89f70f6ba4cb9c644</guid>
<title>字节跳动基于 Iceberg 的海量特征存储实践</title>
<link>https://toutiao.io/k/kekzyb3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;火山引擎开发者社区&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;VolcanoEngineToD&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;火山引擎开发者社区是火山引擎的 TOD 社区，致力于链接火山引擎和开发者，为大家提供前沿技术内容和丰富的技术活动，打造更好的开发者文化和氛围，共建开源生态。&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b40683fdb0640a00ecc0cf53725e88ec</guid>
<title>webpack5资源最佳加载方案</title>
<link>https://toutiao.io/k/qqlcr6f</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天我们一起探讨学习下&lt;code&gt;webpack5&lt;/code&gt;中关于&lt;span&gt;Asset Modules&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;的那些事&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;初始化基础项目&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新建一个文件夹&lt;code&gt;webpack-04-resource&lt;/code&gt;，&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npm init -y &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们安装项目一些基础支持的插件&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npm i webpack webpack-cli webpack-dev-server html-webpack-plugin babel-loader @babel&lt;br/&gt;l/core -D&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在根目录新建&lt;code&gt;webpack.config.js&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; path = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;path&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; HtmlWebpackPlugin = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;html-webpack-plugin&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; { CleanWebpackPlugin } = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;clean-webpack-plugin&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;module&lt;/span&gt;.exports = {&lt;br/&gt;  &lt;span&gt;entry&lt;/span&gt;: &lt;span&gt;&#x27;./src/index.js&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;output&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;filename&lt;/span&gt;: &lt;span&gt;&#x27;js/[name].js&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;path&lt;/span&gt;: path.resolve(__dirname, &lt;span&gt;&#x27;dist&#x27;&lt;/span&gt;)&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;mode&lt;/span&gt;: &lt;span&gt;&#x27;development&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;module&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;rules&lt;/span&gt;: [&lt;br/&gt;      {&lt;br/&gt;        &lt;span&gt;test&lt;/span&gt;: &lt;span&gt;/\.js$/&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;loader&lt;/span&gt;: &lt;span&gt;&#x27;babel-loader&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;options&lt;/span&gt;: {&lt;br/&gt;          &lt;span&gt;presets&lt;/span&gt;: [&lt;span&gt;&#x27;@babel/env&#x27;&lt;/span&gt;]&lt;br/&gt;        }&lt;br/&gt;      },&lt;br/&gt;      {&lt;br/&gt;        &lt;span&gt;test&lt;/span&gt;: &lt;span&gt;/\.(png|jpg)$/i&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;asset/resource&#x27;&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;    ]&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;plugins&lt;/span&gt;: [&lt;br/&gt;    &lt;span&gt;new&lt;/span&gt; CleanWebpackPlugin(),&lt;br/&gt;    &lt;span&gt;new&lt;/span&gt; HtmlWebpackPlugin({&lt;br/&gt;      &lt;span&gt;template&lt;/span&gt;: &lt;span&gt;&#x27;./public/index.html&#x27;&lt;/span&gt;&lt;br/&gt;    })&lt;br/&gt;  ]&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意我们加载图片没有使用&lt;code&gt;file-loader&lt;/code&gt;与&lt;code&gt;url-loader&lt;/code&gt;，我们使用的是&lt;code&gt;webpack5&lt;/code&gt;内置的&lt;code&gt;asset/rosource&lt;/code&gt;这个来处理&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &lt;span&gt;module&lt;/span&gt;.exports = {&lt;br/&gt;    &lt;span&gt;module&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;rules&lt;/span&gt;: [&lt;br/&gt;        {&lt;br/&gt;          &lt;span&gt;test&lt;/span&gt;: &lt;span&gt;/\.(png|jpg)$/i&lt;/span&gt;,&lt;br/&gt;          &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;asset/resource&#x27;&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;      ]&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;index.js&lt;/code&gt;中我们插入一张图片&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; img1Src &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;../assets/images/1.png&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; appDom = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;app&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; img = &lt;span&gt;new&lt;/span&gt; Image();&lt;br/&gt;img.src = img1Src;&lt;br/&gt;appDom.appendChild(img);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ok，运行&lt;code&gt;npm run server&lt;/code&gt;,打开浏览器&lt;code&gt;localhost:8080&lt;/code&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24597056762438682&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0jXCeiaibicNx58ZS4yleu5JQ4bt4aU6TDPokOPkvJ1WbrWFmpkTLaxGS8jopS0NptoqLp1zic8pHoFsTYNAwZ9jAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2854&quot;/&gt;我们会发现，生成的图片地址就是&lt;code&gt;&amp;lt;img src=&quot;http://localhost:8080/js/../b1640e009cff6a775ce5.png&quot;&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;generator配置&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在我想配置图片的默认输出地址与名字,在&lt;code&gt;module.rules&lt;/code&gt;中有一个&lt;code&gt;generator&lt;/code&gt;的属性可以配置匹配图片输出的文件&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// webpack.config.js&lt;/span&gt;&lt;br/&gt; &lt;span&gt;module&lt;/span&gt;.exports = {&lt;br/&gt;    &lt;span&gt;module&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;rules&lt;/span&gt;: [&lt;br/&gt;        ...&lt;br/&gt;        {&lt;br/&gt;          &lt;span&gt;test&lt;/span&gt;: &lt;span&gt;/\.(png|jpg)$/i&lt;/span&gt;,&lt;br/&gt;          &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;asset/resource&#x27;&lt;/span&gt;,&lt;br/&gt;          &lt;span&gt;generator&lt;/span&gt;: {&lt;br/&gt;            &lt;span&gt;filename&lt;/span&gt;: &lt;span&gt;&#x27;images/[name][ext]&#x27;&lt;/span&gt;&lt;br/&gt;          }&lt;br/&gt;        }&lt;br/&gt;      ]&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时页面加载图片的路径就变成&lt;code&gt;&amp;lt;img src=&quot;http://localhost:8080/js/../images/1.png&quot;&amp;gt;&lt;/code&gt;了&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你的图片地址是上传到&lt;code&gt;cdn&lt;/code&gt;上的，那么你可以像下面一样这么做，但是这种做法是不是在项目中真的需要，还有待商榷，因为这样会导致应用的所有图片用&lt;code&gt;cdn&lt;/code&gt;方式加载，如果项目中只是部分图片按需cdn加载，那么这种做法是不可取的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; {&lt;br/&gt;        &lt;span&gt;test&lt;/span&gt;: &lt;span&gt;/\.(png|jpg)$/i&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;// type: &#x27;asset/resource&#x27;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;asset&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;parser&lt;/span&gt;: {&lt;br/&gt;          &lt;span&gt;dataUrlCondition&lt;/span&gt;: {&lt;br/&gt;            &lt;span&gt;maxSize&lt;/span&gt;: &lt;span&gt;40&lt;/span&gt; * &lt;span&gt;1024&lt;/span&gt;&lt;br/&gt;          }&lt;br/&gt;        },&lt;br/&gt;        &lt;span&gt;generator&lt;/span&gt;: {&lt;br/&gt;          &lt;span&gt;publicPath&lt;/span&gt;: &lt;span&gt;&#x27;https://cdn/assets&#x27;&lt;/span&gt;, &lt;span&gt;// cdn域名前缀&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;filename&lt;/span&gt;: &lt;span&gt;&#x27;images/[name][ext]&#x27;&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;      }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自此页面的加载的图片就是&lt;code&gt;&amp;lt;img src=&quot;https://cdn/assets/images/3.png&quot;&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;assetModuleFilename&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了&lt;code&gt;generator.filename&lt;/code&gt;方式，你也可以在&lt;code&gt;output&lt;/code&gt;中加入&lt;code&gt;assetModuleFilename&lt;/code&gt;配置来修改图片默认的地址,不过注意这个属性只能是针对&lt;code&gt;rule&lt;/code&gt;中设置的type&lt;code&gt;&#x27;&#x27;asset/resource&#x27; | &#x27;asset&#x27;&lt;/code&gt;类型才生效。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;module&lt;/span&gt;.exports = {&lt;br/&gt;  &lt;span&gt;output&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;filename&lt;/span&gt;: &lt;span&gt;&#x27;js/[name].js&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;path&lt;/span&gt;: path.resolve(__dirname, &lt;span&gt;&#x27;dist&#x27;&lt;/span&gt;),&lt;br/&gt;    &lt;span&gt;assetModuleFilename&lt;/span&gt;: &lt;span&gt;&#x27;images/[name][ext]&#x27;&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常项目里我们会把比较小的图片直接坐&lt;code&gt;base64&lt;/code&gt;加载，大的图片就直接输出加载，或者上传到&lt;code&gt;cdn&lt;/code&gt;直接加载图片地址,你可以在&lt;code&gt;rules&lt;/code&gt;的&lt;code&gt;generator.publicPath&lt;/code&gt;设置地址图片地址。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此我引入两张大小不一样的图片测试，修改一下&lt;code&gt;index.js&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; img1Src &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;../assets/images/1.png&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; img3Src &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;../assets/images/3.png&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;renderImage&lt;/span&gt;(&lt;span&gt;imageSource&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; weakMap = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;WeakMap&lt;/span&gt;();&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; appDom = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;app&#x27;&lt;/span&gt;);&lt;br/&gt;  imageSource.forEach(&lt;span&gt;(&lt;span&gt;src&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; img = &lt;span&gt;new&lt;/span&gt; Image();&lt;br/&gt;    weakMap.set(img, img);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (weakMap.has(img)) {&lt;br/&gt;      weakMap.get(img).src = src;&lt;br/&gt;      appDom.appendChild(img);&lt;br/&gt;    }&lt;br/&gt;  });&lt;br/&gt;}&lt;br/&gt;renderImage([img1Src, img3Src]);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再修改下&lt;code&gt;webpack.config.js&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;module&lt;/span&gt;.exports = {&lt;br/&gt;  &lt;span&gt;module&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;rules&lt;/span&gt;: [&lt;br/&gt;       ...&lt;br/&gt;       {&lt;br/&gt;        &lt;span&gt;test&lt;/span&gt;: &lt;span&gt;/\.(png|jpg)$/i&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;// type: &#x27;asset/resource&#x27;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;asset&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;parser&lt;/span&gt;: {&lt;br/&gt;          &lt;span&gt;dataUrlCondition&lt;/span&gt;: {&lt;br/&gt;            &lt;span&gt;maxSize&lt;/span&gt;: &lt;span&gt;40&lt;/span&gt; * &lt;span&gt;1024&lt;/span&gt;&lt;br/&gt;          }&lt;br/&gt;        }&lt;br/&gt;      }&lt;br/&gt;    ]&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;rules&lt;/code&gt;中增加&lt;code&gt;parser&lt;/code&gt;属性，并且将&lt;code&gt;type&lt;/code&gt;改成&lt;code&gt;asset&lt;/code&gt;,当我们设置一个&lt;code&gt;dataUrlCondition: {maxSize: 40 * 1024}&lt;/code&gt;,小于&lt;code&gt;KB&lt;/code&gt;就用&lt;code&gt;base64&lt;/code&gt;加载了，大于&lt;code&gt;40KB&lt;/code&gt;就直接用图片路径加载&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48400556328233657&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0jXCeiaibicNx58ZS4yleu5JQ4bt4aU6TDPATzAgiaGpUXAOwQsgnMZMRBbia5h7CumUVs4IEeZZmFYNu7zKyQvyETA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2876&quot;/&gt;因此我们可以看到两张图片，一张图片是&lt;code&gt;base64&lt;/code&gt;一张图片就走文件路径了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在你的项目中你可以利用这个&lt;code&gt;parser.dataUrlCondition.maxSize&lt;/code&gt;特性来优化图片资源，有些资源小图片就可以用&lt;code&gt;base64&lt;/code&gt;来加载，这样可以减少页面图片的资源请求&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是并不是所有的图片都要&lt;code&gt;base64&lt;/code&gt;,&lt;code&gt;base64&lt;/code&gt;生成的字符串非常大，同时也是增加了&lt;code&gt;html&lt;/code&gt;的体积，无法利用缓存机制加载图片。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在优化的网页加载过程中，并不是全部都用&lt;code&gt;base64&lt;/code&gt;来加载图片。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;关于内置模块的几个参数&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要参考官网&lt;span&gt;asset-modules&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;webpack5之前&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;row-loader 将文件导入为字符串，比如导入.txt类型的文件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;url-loader 将文件作为&lt;code&gt;Data Url&lt;/code&gt;嵌入到打包后&lt;code&gt;bundle.js&lt;/code&gt;中，比如&lt;code&gt;base64&lt;/code&gt;文件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;file-loader 将文件输出目录，图片文件会被打包到指定目录中加载&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;webpack5现在&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用&lt;code&gt;asset module type&lt;/code&gt;通过添加以下四种类型来代替以上&lt;code&gt;loader&lt;/code&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;asset/resource 导出单独的&lt;code&gt;url&lt;/code&gt;,是&lt;code&gt;file-loader&lt;/code&gt;的替代品&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;asset/inline 导出资源Data Url,是&lt;code&gt;url-loader&lt;/code&gt;的替代品&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;asset/source 到处文件资源内容，是&lt;code&gt;row-loader&lt;/code&gt;的替代品&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;asset 在&lt;code&gt;url-loader&lt;/code&gt;和&lt;code&gt;file-loader&lt;/code&gt;中选择，配置&lt;code&gt;parse.dataUrlCondition.maxSize&lt;/code&gt;来输出图片资源是否&lt;code&gt;base64&lt;/code&gt;输出&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;相比较&lt;code&gt;webpack5&lt;/code&gt;之前我们加载图片资源文件使用&lt;code&gt;file-loader&lt;/code&gt;或者&lt;code&gt;url-loader&lt;/code&gt;在&lt;code&gt;webpack5&lt;/code&gt;中可以使用内置模块&lt;code&gt;type: &#x27;assets/resource&#x27;&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;基于webpack5内置模块&lt;code&gt;asset module type&lt;/code&gt;来设置资源的加载&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;图片资源&lt;code&gt;base64&lt;/code&gt;处理，根据图片资源的大小&lt;code&gt;parse.dataUrlCondition.maxSize&lt;/code&gt;来限制是否需要&lt;code&gt;base64&lt;/code&gt;输出&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;比较&lt;code&gt;asset module type&lt;/code&gt;几种模式区别，代替以前&lt;code&gt;row-loader&lt;/code&gt;、&lt;code&gt;file-loader&lt;/code&gt;、&lt;code&gt;url-loader&lt;/code&gt;方案，但是这仅仅是你的&lt;code&gt;webpack&lt;/code&gt;版本在5以后。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;本文&lt;span&gt;code example&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;Asset Modules: &lt;em&gt;https://webpack.docschina.org/guides/asset-modules/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;asset-modules: &lt;em&gt;https://webpack.docschina.org/guides/asset-modules/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;code example: &lt;em&gt;https://github.com/maicFir/lessonNote/tree/master/webpack/webpack-04-assets&lt;/em&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkwODIwMDY2OQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/sz_mmbiz_png/3GPT1CHiaSVssAs3fYdfweBskcYpVTrKpyGRwvSia0MOULHpGU8497uAkHic3CSPvqbr1BGQY45zoj0rvLexzLVVA/0?wx_fmt=png&quot; data-nickname=&quot;前端巅峰&quot; data-alias=&quot;Java-Script-&quot; data-signature=&quot;不止前端&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>