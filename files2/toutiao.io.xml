<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>fdd99580e59535b42875d5c2bd7a1c6f</guid>
<title>手撕Spring源码（三），彻底理解Spring循环依赖原理</title>
<link>https://toutiao.io/k/godfwci</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;很多朋友大概有注意到，我写过一些文章解释清楚了一些：全网没有其他文章解释清楚，或者大多数文章都是错误的问题。比如：《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486732&amp;amp;idx=1&amp;amp;sn=523d754d7944be46985d098c82f79af2&amp;amp;chksm=fafde7a2cd8a6eb47d6145a8538b907b8b118b09ddb530cd57ba80feaa7b539559279debe893&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;说透分布式事务&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;说透分布式事务&lt;/strong&gt;&lt;/a&gt;》里&lt;span&gt;BASE理论和分布式事务&lt;/span&gt;到底是什么关系。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;本篇文章我在动笔之前也搜索了一下，包含文章和收费视频。发现自己花了钱学习的东西老师(还是这个方面口碑很好的老师)在翻来覆去啰嗦那么几句话，就是没把问题讲透。为啥呢？我分析了一下，因为老师从一开始没有说明这么设计要解决的问题呀。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;上篇回顾&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;本篇是手撕Spring源码系列的第三篇。由于上下&lt;span&gt;文之间的逻辑关系，没看过前两篇的朋友强烈建议先看前两篇。上篇传送门：《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247487194&amp;amp;idx=1&amp;amp;sn=67bf87a4fdc41922d7a5e80b481d95b4&amp;amp;chksm=fafde474cd8a6d62d9a3d4f095e4ea32f342c734ea50e997edf346e7f00f4c2c2e10e39f0d30&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;手撕Spring后置处理器源码，彻底理解Spring核心&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;手撕Spring源码（二），彻底理解Spring&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247487194&amp;amp;idx=1&amp;amp;sn=67bf87a4fdc41922d7a5e80b481d95b4&amp;amp;chksm=fafde474cd8a6d62d9a3d4f095e4ea32f342c734ea50e997edf346e7f00f4c2c2e10e39f0d30&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;手撕Spring后置处理器源码，彻底理解Spring核心&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;后置处理器&lt;/strong&gt;&lt;/a&gt;&lt;/strong&gt;》。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;强化是深度记忆的有效手段。简单对上篇做个总结。Spring Bean创建的过程为：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.17768147345612134&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlibdH4v2HFX63pg5XPteibjRjLvTVS3MDHQ43Ix7JPZAnmKmFtMcLVOpokS8UO0PRvsZlvIQhJ1gPmw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;923&quot;/&gt;&lt;/p&gt;&lt;p&gt;1、根据class生成Bean定义&lt;/p&gt;&lt;p&gt;2、根据Bean进行实例化&lt;/p&gt;&lt;p&gt;3、将实例的Bean属性进行填充&lt;/p&gt;&lt;p&gt;4、初始化Bean&lt;/p&gt;&lt;p&gt;5、Bean后置处理&lt;/p&gt;&lt;p&gt;6、完成Bean对象的创建&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;本系列&lt;span&gt;的所有&lt;/span&gt;&lt;span&gt;代码文字在 https://github.com/xiexiaojing/yuna 里可以找到。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;引出问题&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在上篇最后的代码中，咱们来做这么一件事，让 testService 引用 userService ：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5674547983310153&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicA7m6G02opCfqvAeMiacTU6XXJ6npfEF3QQEU6whlcfelkRoRH8j2IY3Eus0qwdqKghhcicXT7MnVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;719&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;加上原来的 userService 引用了 testService ：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.49461312438785504&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicA7m6G02opCfqvAeMiacTU6wMZbWHlCLpcjNxHWq9C7ODTWR2tK7uyk3ib1em78lAMrsa9Y1zRAPSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1021&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;运行启动类：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.23414179104477612&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlibdH4v2HFX63pg5XPteibjRjSrXgrFpbIA87g7wqBj548gfpMaAD2NmyUICeCyrdIeicqz6jev1miamQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1072&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;循环引用导致栈溢出：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.38772077375946173&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicA7m6G02opCfqvAeMiacTU6XWibicxDvtXFicv7l2M8Rp07dUIKpEY2SVx7iaPibLOItv5EnDp9DQMia6gA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1189&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;原因看代码就很明白了，有递归调用导致&lt;span&gt;&lt;strong&gt;死循环依赖&lt;/strong&gt;&lt;/span&gt;：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8213914849428868&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlibdH4v2HFX63pg5XPteibjRjzfR97ibaUGRicU2Stj83QV0y3HXibVBThWg1axrWciasspGbxqFiclszUqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;963&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;咱们模拟的就是Spring源码，原理和Spring源码是一样的。那Spring最初也遇到了这个问题。它是怎么解决的呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;单例池二级缓存&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Spring解决的思路也是很常规的思路：testService 引用了 userService 。要创建userService需要先获取testService的Bean。那能不能先创建一个半成品先用着呢？这就是Spring解决循环依赖的二级缓存思想。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;有二级缓存，那就有一级缓存。什么是一级缓存呢？咱们头两节课里介绍获取Bean在Scope为单例时是从singletonObjects也就是单例池中获取的。这个单例池作用是缓存单例对象，这就是一级缓存。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6363636363636364&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9rywK5Vs4W4tOkqGhZN1I7P9sUH8h5MYvBjkrZ5bwiaVKRNHUKq7GCibEPaicDWHibkFDzdx8rj05hAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;968&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;那咱们来看二级缓存，也叫半成品池。思想就是如果获取Bean的时候发现Bean不存在，就从半成品池里获取。如果获取不到则立即实例化一个放到半成品池里。这样，其他Bean创建依赖于它时，就可以直接先拿来用。确保依赖它的可以实例化成功。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;定义半成品池：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.20202020202020202&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9rywK5Vs4W4tOkqGhZN1I7aJXy8TUvjRwZykGq8sq3z0jfUZuBRO39XXicTs26yZ8f9CRHiaUHqomQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;990&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;获取Bean时如果&lt;span&gt;如果获取不到&lt;/span&gt;&lt;span&gt;则&lt;/span&gt;&lt;span&gt;立即实例化一个放到半成品池里&lt;/span&gt;：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4594594594594595&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9rywK5Vs4W4tOkqGhZN1I7dT1wv5TA6PeBBeS4pS0IsIicjGnSDSNnhTMnGEjZGk5BYmXDP644Ufw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1147&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;总共加上了这四行代码之后咱们再来运行一次：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5233248515691263&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9rywK5Vs4W4tOkqGhZN1I7icbkcSGGRyCH3BrAxKDyxASTiaSVhEzm0XVsVkKia6Vm0ia5M54a8JsCIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1179&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.996309963099631&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRl9rywK5Vs4W4tOkqGhZN1I7kNJ6xtI7XwvibxJN0pvUiagtJvzvRic6rNudE08dY7zSPXtrMticiaC30kg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;271&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;单例池二级缓存存在的问题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;记不记得咱们曾经手撕过mybatis的源码？可以回顾一下《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485597&amp;amp;idx=1&amp;amp;sn=555efa9b4b4041a29c4816772b0c1f2c&amp;amp;chksm=fafde233cd8a6b25f5a98a025df7917cb0d27f81e9efece21d4ce0a1f43155598b4108626172&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;mybatis的本质和原理&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;&lt;span&gt;mybatis的本质和原理&lt;/span&gt;&lt;/strong&gt;&lt;/a&gt;&lt;span&gt;》这篇文章。想抽空写一篇手撕spring整合mybatis的，大家有兴趣的可以在评论区留言。本篇在看超15，就是默认想看了，8小时内我就把文章肝出来~&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;spring整合mybatis时，咱们使用时定义接口，并把扫描注解标注到接口上：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5495608531994981&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9rywK5Vs4W4tOkqGhZN1I7icOHZZjbOakgj2icib5GqQuFGE6NQiao4hNDiaQZgs53Ac8RpYg2eVVhq7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;797&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;本质上Repository就是一个Component注解：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9257884972170687&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9rywK5Vs4W4tOkqGhZN1I7gp4mqbFWNmovlVG4mjAWDreAT83I9pINZtzT7BD7vX3dicQTO7l4Iww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;539&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;那问题来了，mybatis的操作sql语句的方法是接口不是类，不能被实例化呀，二级缓存提前实例化是有问题的。不信咱们来试验一下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0528&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9rywK5Vs4W4tOkqGhZN1I7LZe4SXLUCHVTvuoOs8b4dUzU9Z6ibyRZuFOwjMftWl144zU7AdyTmwg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;625&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;注入一个接口，启动时就报错了：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5985239852398524&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9rywK5Vs4W4tOkqGhZN1I7EjprMvCG6pK1dib0mI4UyDjO5S2HozxiaH7HE8P6oxHicjeNib54iaSIHfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1355&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因为本身啊，咱们利用Spring注入的Bean是代理类。比如mybatis的接口最终使用的是mybatis在执行完Bean后置处理器之后的代理类。&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;问题明确了：二级缓存由于提前实例化，实例化了一些不能被实例化的接口，会报错。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;单例池三级缓存&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;那如果你是Spring的设计者怎么解决这个问题？那如果发现是接口就提前执行后置器处理器把代理类创建出来使用呗。别说，Spring的设计者还真也是这么处理的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;首先定义一个接口，这个接口直接从Spring源码里拷贝一下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6821608040201005&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9rywK5Vs4W4tOkqGhZN1I7I3lHOCXO2egkvyU7s6Bia20Ln0M9qXUJibXtCTWOSMvz9gH5kEd9AJGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;796&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个接口的实现类作用就是实现getObject把接口真正替换成代理类。这里举得是mybatis的实现，具体可参考《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485597&amp;amp;idx=1&amp;amp;sn=555efa9b4b4041a29c4816772b0c1f2c&amp;amp;chksm=fafde233cd8a6b25f5a98a025df7917cb0d27f81e9efece21d4ce0a1f43155598b4108626172&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;mybatis的本质和原理&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;mybatis的本质和原理&lt;/strong&gt;&lt;/a&gt;》：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.761049723756906&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9rywK5Vs4W4tOkqGhZN1I7E0rwu4YpNdLmh76BtYrDD8zfdicibVbqZOUKLvA55EzzYdaQ8HVib8ibIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;724&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;本质上Repository就是一个Component注解的别名。为了让咱们在spring的注解能扫描到，咱们把它替换成@Component注解：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5264527320034692&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9rywK5Vs4W4tOkqGhZN1I79goIecpgMhJuU2LSADrH9C5lujG3qVNibWhBv9cCf2Kld8YgdSlXiaww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1153&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;由于类所在的位置，咱们把扫描范围扩大些：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7712177121771218&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9rywK5Vs4W4tOkqGhZN1I7jVQSFic3SEX2M5QeEqEI0eNiaHGy7m4sdhOsMQiauJYXqBXyxnbqf6mVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;813&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;定义三级缓存也叫工厂池：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.22319474835886213&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9rywK5Vs4W4tOkqGhZN1I7vs8J7W064nzufv7tevCVUVnMS9KU4TRib4h5sSa4dLeK2DN6WTABogQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;914&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果是接口先实例化工厂池对象，从工厂池对象中获取真正的Bean对象：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6016877637130802&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9rywK5Vs4W4tOkqGhZN1I7DbadH9dvMop4HQbCoeqicBu3hpcplj7dEA8TSt0CxCz0Ld89U6jHSUw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1185&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这里只是一个put操作，为了尽量和Spring源码保持一致，单独拆成方法，加了下面判断，其实核心就一行：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.29287305122494434&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9rywK5Vs4W4tOkqGhZN1I7d4abrJCxpTSL6XTSjC3acdI1sn5rMAfkRBYfBzrlUZOzU6v0XvcCVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;898&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其他就是因为提前实例化了，在创建Bean时判断如果已经实例化则不必再次实例化，只是一个判断：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.40865384615384615&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9rywK5Vs4W4tOkqGhZN1I7sGWP7Tcj8aeaFOT2zZ5WiaAVAJ02lOt1FNVmeCHtqDfXibKNPyYED4aQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1040&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;改造就是这些，咱们来运行一下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8289902280130294&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9rywK5Vs4W4tOkqGhZN1I7cSxwUgCYiajniaP6VKrq7PqbWVVNPmN5LCd5yQ6m3MsLfMLicdNQxsXBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;614&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.93&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/2tk5ianItRl9rywK5Vs4W4tOkqGhZN1I7jv1qRlb8ZMib7xd1DZs59wVnaOekZJ7NVyAo1rmM1cuUHT4AWkkibVXw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;300&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;本篇针对Spring创建时会遇到的两个问题：死循环依赖问题和接口实例化问题给出了Spring的解决方案。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;虽然代码是我手撕的，和源码不完全一致，但原理是一样的。面试的时候跟人家说Spring就是这么实现的，一点问题也没有。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在本系列的第一篇《&lt;span&gt;手撕spring核心源码，彻底搞懂spring流程》里其实Spring IoC控制反转和依赖注入原理就已经讲完并实现了。这两篇文章都是针对在此基础上的需求和问题。&lt;span&gt;《&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247487194&amp;amp;idx=1&amp;amp;sn=67bf87a4fdc41922d7a5e80b481d95b4&amp;amp;chksm=fafde474cd8a6d62d9a3d4f095e4ea32f342c734ea50e997edf346e7f00f4c2c2e10e39f0d30&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;手撕Spring后置处理器源码，彻底理解Spring核心&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;手撕Spring源码（二），彻底理解Spring&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247487194&amp;amp;idx=1&amp;amp;sn=67bf87a4fdc41922d7a5e80b481d95b4&amp;amp;chksm=fafde474cd8a6d62d9a3d4f095e4ea32f342c734ea50e997edf346e7f00f4c2c2e10e39f0d30&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;手撕Spring后置处理器源码，彻底理解Spring核心&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;后置处理器&lt;/strong&gt;&lt;/a&gt;&lt;/strong&gt;&lt;span&gt;》&lt;/span&gt;解决的是对Bean做增强的问题，本篇是随着Bean的多样性引发的问题是怎么解决的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Spring本身就是如此：基于一个简单的想法，再解决设计中遇到的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong data-brushtype=&quot;text&quot;&gt;&lt;span&gt;编程一生&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;因为公众号平台更改了推送规则，如果不想错过内容，记得读完点一下“在看”，加个“星标”，这样每次新文章推送才会第一时间出现在你的订阅列表里。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486113&amp;amp;idx=1&amp;amp;sn=f3623b2cf257aa37ea83768fd4325762&amp;amp;chksm=fafde00fcd8a691928c66f7e484ab2b7f6fa7797dc32833a7f777bb4ebde58c010750f13c118&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;PDCA方法论&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;strong&gt;PDCA方法论&lt;/strong&gt;&lt;/a&gt;&lt;span&gt;，检查自己是否错过更新：每周三晚上8点左右，我都会更新文章，如果你没有收到，记得点开【编程一生】公众号找一下(*^▽^*)&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9abeae2558d318c6b3b6a694f197157b</guid>
<title>不用跑项目，组件效果所见即所得，绝了！</title>
<link>https://toutiao.io/k/8rf2rhw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们在写需求时都会封装一些组件，然后会为该组件定义一些 &lt;/span&gt;&lt;code&gt;props&lt;/code&gt;&lt;span&gt; ，使其跟业务分离，变得更通用。&lt;/span&gt;&lt;span&gt;写完组件后需要验证一下组件的效果，也就需要简单 &lt;/span&gt;&lt;code&gt;mock&lt;/code&gt;&lt;span&gt; 一下数据传进去，然后跑一下项目看一下&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// components/card/index.tsx  Card 组件 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 咱先来写个组件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;Card&lt;/span&gt; (&lt;span&gt;props&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; { name } = props&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;    &amp;lt;div&amp;gt;{name}&amp;lt;&lt;span&gt;/div&amp;gt;&lt;br/&gt;  )&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// index.tsx  项目根目录&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 组件写好了，找个地方引入一下，传点数据进去，免得项目崩了&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; Card form &lt;span&gt;&#x27;card&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;App&lt;/span&gt; (&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;    &amp;lt;Card name=&lt;span&gt;&quot;零一&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;  )&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; &lt;span&gt;# 跑一下项目，看看刚才写的组件的效果&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; yarn dev&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这套流程，你是不是很熟悉？大家可能都是这么干的，看完效果后还要回过头去把刚刚不要的测试代码都删掉&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然而，我找到了一个非常好用的 &lt;strong&gt;Vscode 插件&lt;/strong&gt; 大大简化了这个流程！！！！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它就是 &lt;strong&gt;Preview.js&lt;/strong&gt; ，一个用于项目中组件实时预览的插件&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它有什么&lt;strong&gt;优点&lt;/strong&gt;？&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;支持 &lt;code&gt;React（v16+）&lt;/code&gt;、&lt;code&gt;Vue2&lt;/code&gt;、&lt;code&gt;Vue3&lt;/code&gt;、&lt;code&gt;SolidJS&lt;/code&gt;，并即将支持 &lt;code&gt;Preact&lt;/code&gt; 和 &lt;code&gt;Svelte&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;无需启动项目，直接静态预览组件效果&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自动识别组件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自动生成 props 的 mock 数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实时刷新，无需疯狂点保存触发&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以针对同一个组件生成多个预览，并可快速切换&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持调整页面比例，以及切换不同分辨率的设备&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;暗黑模式切换&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;直接搜索项目中的其它组件，快速切换&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;香不香？我反正已经上手使用过了，是真的香！之前我自己也做过组件库的项目，写完一个组件，就需要写一个 &lt;code&gt;example&lt;/code&gt; 去看看效果，要是用了这个插件，项目也不用跑，实时预览，该有多爽啊（正在开发组件库的同学看过来，福利啊）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再讲一下这个插件的&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;插件是刚出的，可能会有一些bug，这是难免的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;上述优点中，6、7、8都是需要付费的，不过目前可以白嫖，等会讲&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;待发现...&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但我目前用下来是没啥问题的&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;接下来带大家体验一下&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;安装&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接在 VsCode 的插件市场搜索：&lt;code&gt;Preview.js&lt;/code&gt;，安装即可&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23484848484848486&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lgHVurTfTczSTEMHXML94icmpicms8BanXlbZzZIGH5UyREr8fOEkMfMgjUyxpZQX1lSvj8OX6ia86rnUT7XAqREQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;528&quot;/&gt;&lt;figcaption&gt;安装插件&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后最好重启一下 VsCode&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;emmmm，大多数同学应该会收到这样一条报错信息：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.16373056994818652&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lgHVurTfTczSTEMHXML94icmpicms8BanXxY4e33SNicjW1noGK6tiarvb99RgfiaZEyCJFaL1XoictCpKrJUb01PBdg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1930&quot;/&gt;&lt;figcaption&gt;npm 版本过低&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为重启后的初始化阶段，&lt;code&gt;Preview.js&lt;/code&gt; 插件会安装一些依赖包，并且它们最低支持的 &lt;code&gt;npm&lt;/code&gt; 版本是 &lt;code&gt;7+&lt;/code&gt;，估摸着大部分同学的 &lt;code&gt;npm&lt;/code&gt; 包都是小于 7 的，所以还是建议大家想要使用时切换一下 &lt;code&gt;node&lt;/code&gt; 版本，比如用 &lt;code&gt;nvm use 17.5.0&lt;/code&gt;，此时的 &lt;code&gt;npm&lt;/code&gt; 版本就到了 &lt;code&gt;8+&lt;/code&gt; 了，满足了需求，此时还需要重启一次&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;稍微耐心等待几秒钟，等它的依赖包都装好就ok了&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.40804597701149425&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lgHVurTfTczSTEMHXML94icmpicms8BanXuX0AZo3VoefWCxYy9p5YYIsgVGj7NaUsaBPFLXR8QSImZTptU0YqOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1044&quot;/&gt;&lt;figcaption&gt;preview.js 依赖包安装成功&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;基本使用&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;为了方便起见，我就拿 &lt;code&gt;React&lt;/code&gt; 的代码来做示例了，但刚才提到那些库也都是支持的哈，大家可以自行尝试&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;咱们随便找到项目中的一个组件打开&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6751968503937008&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lgHVurTfTczSTEMHXML94icmpicms8BanXK4KX5F4EhzyiaDMV1IPicT0FgLGreUmoOHUG69juxXYzjYCb0A3Xszicg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1016&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，插件自动识别到了我的 &lt;code&gt;Card&lt;/code&gt; 组件，并在上方悬浮了一个 &lt;code&gt;Open Card in Preview.js&lt;/code&gt; 的灰色按钮，点击以后右边就会出来一个预览窗口了（此时咱们都还没启动项目）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4347442680776014&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/lgHVurTfTczSTEMHXML94icmpicms8BanXLAGZicvdPVzrjIlxGymV1g7OEFfjnmmL2VhFVggQFribK03ia9Lo1A9Bg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1134&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还能看到，右下角也帮我们生成了该组件需要的 &lt;code&gt;props&lt;/code&gt; 的 mock 数据，不过这个前提条件是你项目是 TS 的，并且给 props 限定了类型才行，否则是不行的（我试过了）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一切（新增组件、修改文本、修改样式...）的修改都是实时的（除了修改 props 类型），我们来看一下&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.43562610229276894&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/lgHVurTfTczSTEMHXML94icmpicms8BanXvmkEichQYP8fLzz1Iq50uh6CrpkSCucN6oTobdT72yAD5rQBIIr5XJw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1134&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类型修改不能实时也算是一个小缺点，希望后续可以改进一下。如果咱们改了类型，目前只需重启预览窗口就可以了，点底部的刷新是没用的&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Pro 级别的功能&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来是高级用户可以使用的功能，我看到他们官网是有申请 30 天免费体验资格的，为了本文的效果，我先申请了&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;申请网址：https://previewjs.com/checkout&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;填一下自己的邮箱，就申请成功了&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.44224037339556593&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lgHVurTfTczSTEMHXML94icmpicms8BanXHcz0lmrJtPyr4wujjruNAhPicIjcomuYdaVJqRzLlc7syPxicGjd8XsA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1714&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后它会把一个兑换码发到你的邮箱里&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.834319526627219&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lgHVurTfTczSTEMHXML94icmpicms8BanX3KicO7kaAmxEO4NvHJPMiazSKE26N0j4yTzkQ7aVeVmyxqAPD7SYFp4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1014&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拿着这个码去 VsCode 的 Preview.js 预览窗口里填写即可&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.875438596491228&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lgHVurTfTczSTEMHXML94icmpicms8BanXRhI7Zscv7Gq4yiaKibqIvmOg0yfrtQlTlnpBUTMzAVhe9SknibDribsZZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1140&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6686991869918699&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lgHVurTfTczSTEMHXML94icmpicms8BanXbstpk3ETvKM8mHBKwTpgxyouGUqIrpXhniaib7iclSUQqNjYtib69pG4KQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;984&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后就成功了，页面现在多了一堆功能&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8880994671403197&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lgHVurTfTczSTEMHXML94icmpicms8BanXH6QuCYGplYleMibCLJ0W0LJk034bdOtgwiaYw0kbgXSPEJ2ZXWj4NiaZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1126&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来统一体验一下吧&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8774422735346359&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/lgHVurTfTczSTEMHXML94icmpicms8BanXATlTnfBrDE2VzbZIUWAKlmgTRCgz9ib4KEUPF30okR0IHe5KXfsfpKg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;563&quot;/&gt;&lt;figcaption&gt;体验pro付费功能&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总体来说这个插件已经很 nice 了，即使不用付费版本的功能，也可以满足基本的需求，而且这个功能在写业务时非常有用，大大提高工作效率，&lt;strong&gt;真的真的强烈推荐！！！！&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;Preview.js&lt;/strong&gt;: https://previewjs.com/&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7c8fa107608d90ce60479f7e69ed56bc</guid>
<title>golang开发:select多路选择-编程思维</title>
<link>https://toutiao.io/k/ozv9yzz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;blogpost-body cnblogs-markdown&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;select 是 Golang 中的一个控制结构，语法上类似于switch 语句，只不过select是用于 goroutine 间通信的 ，每个 case 必须是一个通信操作，要么是发送要么是接收，select 会随机执行一个可运行的 case。如果没有 case 可运行，goroutine 将阻塞，直到有 case 可运行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;select 多路选择&lt;/h3&gt;
&lt;p&gt;select写法上跟switch case的写法基本一致，只不过golang的select是通信控制语句。select的执行必须有通信的发送或者接受，如果没有就一直阻塞。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ch := make(chan bool, 0)
ch1 := make(chan bool, 0)
select {
case ret := &amp;lt;-ch:
fmt.Println(ret)
case ret := &amp;lt;-ch1:
fmt.Println(ret)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果ch和ch1都没有通信数据发送，select就一直阻塞，直到ch或者ch1有数据发送，select就执行相应的case来接受数据。&lt;/p&gt;
&lt;h3&gt;select 实现超时控制&lt;/h3&gt;
&lt;p&gt;我们可以利用select机制实现一种简单的超时控制。&lt;br/&gt;
先看下程序完整执行的代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;func service(ch chan bool) {
time.Sleep(time.Second*3)
ch&amp;lt;-true
}
func main() {
ch := make(chan bool, 0)
go service(ch)
select {
case ret := &amp;lt;-ch:
fmt.Println(ret)
case &amp;lt;-time.After(time.Second*5):
fmt.Println(&quot;timeout&quot;)
}
}

___go_build_main_go #gosetup
true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到使用time.After超时定义了5S，service程序执行3S，所以肯定没有超时，跟预想的一致。&lt;br/&gt;
我们再看看超时的执行，我们将service程序执行时间该为6S。超时控制继续是5S，再看下执行效果&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;func service(ch chan bool) {
time.Sleep(time.Second*6)
ch&amp;lt;-true
}
func main() {
ch := make(chan bool, 0)
go service(ch)
select {
case ret := &amp;lt;-ch:
fmt.Println(ret)
case &amp;lt;-time.After(time.Second*5):
fmt.Println(&quot;timeout&quot;)
}
}

___go_build_main_go #gosetup
timeout
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行到了超时的case，跟预想的其实是一致的。&lt;/p&gt;
&lt;h3&gt;select 判断channel是否关闭&lt;/h3&gt;
&lt;p&gt;先看下接受数据的语法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;val,ok &amp;lt;- ch
ok true 正常接收数据
ok false 通道关闭
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到接受数据其实有两个参数，第二个bool值会反应channel是否关闭，是否可以正常接受数据。&lt;/p&gt;
&lt;p&gt;看下测试代码&lt;br/&gt;
我们写了一个数据发送者，两个数据接收者，当发送者关闭channel的时候，两个接收者的 goroutine 可以通过以上的语法判断channel是否关闭，决定自己的 goroutine 是否结束。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;func sender(ch chan int, wg *sync.WaitGroup) {
for i:=0;i&amp;lt;10;i++ {
ch&amp;lt;-i
}
close(ch)
wg.Done()
}
func receiver(ch chan int, wg *sync.WaitGroup) {
for {
if val,ok := &amp;lt;-ch;ok {
fmt.Println(fmt.Sprintf(&quot;%d,%s&quot;,val, &quot;revevier&quot;))
} else {
fmt.Println(&quot;quit recevier&quot;)
break;
}
}
wg.Done()
}
func receiver2(ch chan int, wg *sync.WaitGroup) {
for {
if val,ok := &amp;lt;-ch;ok {
fmt.Println(fmt.Sprintf(&quot;%d,%s&quot;,val, &quot;revevier2&quot;))
} else {
fmt.Println(&quot;quit recevier2&quot;)
break;
}
}
wg.Done()
}
func main() {
ch := make(chan int, 0)
wg := &amp;amp;sync.WaitGroup{}
wg.Add(1)
go sender(ch, wg)
wg.Add(1)
go receiver(ch, wg)
wg.Add(1)
go receiver2(ch, wg)
wg.Wait()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行结果&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;0,revevier2
2,revevier2
3,revevier2
4,revevier2
5,revevier2
6,revevier2
7,revevier2
1,revevier
9,revevier
quit recevier
8,revevier2
quit recevier2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到一个数据发送者，两个数据接收者，当channel关闭的时候，两个数据接收者都收到了channel关闭的通知。&lt;br/&gt;
需要注意的是，给一个已经关闭的channel发送数据，程序会panic，从一个已经关闭的channel接收数据，会接收到没有参考意义的channel类型的0值数据，Int是0，string是空...&lt;/p&gt;
&lt;h3&gt;select 退出计时器等程序&lt;/h3&gt;
&lt;p&gt;开发中经常会经常会使用轮训计时器，但是当程序退出时，轮训计时器无法关闭的问题。其实select是可以解决这个问题的。&lt;br/&gt;
如果我们有一个轮训任务，需要一个timer，每隔3S执行逻辑，过完10S之后关闭这个timer。&lt;/p&gt;
&lt;p&gt;看下代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;func TimeTick(wg *sync.WaitGroup,q chan bool) {
defer wg.Done()
t := time.NewTicker(time.Second*3)
defer t.Stop()
for {
select {
case &amp;lt;-q:
fmt.Println(&quot;quit&quot;)
return
case &amp;lt;-t.C:
fmt.Println(&quot;seconds timer&quot;)
}
}
}
func main() {
q := make(chan bool)
wg := new(sync.WaitGroup)
wg.Add(1)
go TimeTick(wg,q)
time.Sleep(time.Second*10)
close(q)
wg.Wait()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;seconds timer
seconds timer
seconds timer
quit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;很优雅的通过关闭channel退出了轮训计时器 goroutine，&lt;/p&gt;
&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c8b1886fc158095f443540f9033360b7</guid>
<title>实效性与准确性的背后：多系统数据聚合展示</title>
<link>https://toutiao.io/k/24r8p3y</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;闲鱼技术&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;XYtech_Alibaba&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;阿里巴巴-闲鱼技术团队官方账号。 简历投递：guicai.gxy@alibaba-inc.com&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d8b2511f13b493472766781e5e438156</guid>
<title>升级到MySQL8.0，付出了惨痛的代价！</title>
<link>https://toutiao.io/k/k1kwav6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;pre data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-css=&quot;; border-radius: 8px;-webkit-align-items:center;-webkit-box-align:center;-webkit-box-pack:center;-webkit-justify-content:center;align-items: center;background-color: #ff6477;box-shadow: 0px 2px 4px rgba(46,15,23,0.37);color:#fff;display: -webkit-box;display: -webkit-box-flex;display: flex;font-size:12px;height:32px;justify-content: center;line-height: 0px;margin: 10px&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;以下内容来自公众号逆锋起笔，关注每日干货及时送达&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iaajvl7fD4ZCicMcjhXMp1v6UibM134tIsO1j5yqHyNhh9arj090oAL7zGhRJRq6cFqFOlDZMleLl4pw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;64&quot;/&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUyMzM2ODUwMA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/hs540iaTKoaIWQB73gicJGTicpAjbSjAjic3d4ytEoiaArkWw6hKMqicPSXrpd4FquTTdStuMoILtqGHS222lIQlh1mg/0?wx_fmt=png&quot; data-nickname=&quot;逆锋起笔&quot; data-alias=&quot;readdot&quot; data-signature=&quot;全网最新编程视频教程、大佬们推荐的 pdf 学习资料，全部免费分享！来到这里，你不懂程序都难。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;作者 | Herman Lee，Pradeep Nayak &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原文：https://engineering.fb.com/2021/07/22/data-infrastructure/mysql/ &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;译者 | 王雪迎  责编 | 晋兆雨 出品 | CSDN(ID:CSDNnews)&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Facebook 称，他们最近的一次大版本升级到 MySQL 5.6 花了一年多时间才完成，还在 5.6 版上开发 LSM 树存储引擎，MyRocks。在升级到 5.7 的同时构建一个新的存储引擎，会大大减慢 MyRocks 的进度，因此我们选择继续使用 5.6，直到 MyRocks 完成，MySQL 5.6 的寿命也即将结束，决定升级到 MySQL 8.0 。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;官博介绍说，此次过程比之前的升级更具挑战。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;MySQL 是由 Oracle 公司开发的一个开源数据库，它为 Facebook 的一些最重要的工作负载提供了动力。我们积极开发 MySQL 中的新特性，以支持不断演化的需求。这些特性对MySQL的许多方面进行了修改，包括客户机连接器、存储引擎、优化器以及复制。为了迁移工作负载，对于每个新的 MySQL 主版本，我们都需要投入大量的时间和精力。其中的挑战包括：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;将自定义功能移植到新版本&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;确保主要版本之间的复制兼容&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;最小化现有应用程序查询所需的更改&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对阻碍服务器支持我们工作负载的性能退化进行修复。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;我们最近一次的主版本升级是到 MySQL 5.6，它花了一年多的时间才推出。当5.7 版发布时，我们还在 5.6 版上开发 LSM 树存储引擎和 MyRocks。在升级到 5.7 的同时构建一个新的存储引擎，会大大减慢 MyRocks 的进度，因此我们选择继续使用 5.6，直到 MyRocks 完成。MySQL 8.0 发布之际，我们正在做 MyRocks 向用户数据库（UDB）服务层推出的收尾。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该版本包括一些引人注目的特性，如基于写集的并行复制和提供原子 DDL 支持的事务数据字典等。对我们来说，迁移到 8.0 还将带来包括文档存储在内的，我们已经错过的 5.7 特性。版本 5.6 的使命即将结束，我们希望在 MySQL 社区中保持活跃，尤其是在 MyRocks 存储引擎上的工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;8.0 中的增强功能，比如即时 DDL，可以加快 MyRocks 的模式更改，但是我们需要在 8.0 的代码库中使用它。考虑到更新代码的好处，我们决定迁移到 8.0。下面将分享我们如何解决 8.0 迁移项目的难题，以及在这个过程中发现的一些惊喜。当最初确定项目范围时，可以明确的是，迁移到 8.0 会比迁移到 5.6 或 MyRocks 更困难。&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;当时，我们定制的 5.6 分支有 1700 多个代码补丁需要移植到 8.0。在我们移植这些更改时，新的 Facebook 的 MySQL 特性和修复已被添加到5.6 的代码库中，从而使目标变得更加遥不可及。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;我们有许多 MySQL 服务器在生产环境中运行，为大量截然不同的应用程序提供服务。我们还有众多管理 MySQL 实例的软件架构。这些应用执行诸如收集统计数据或管理服务器备份之类的操作。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;从 5.6 升级到 8.0 完全跳过了 5.7。在 5.6 中处于活动状态的 API 在 5.7中可能被弃用，而在 8.0 中可能会被移除，这要求我们必须更新所有使用了现已删除API的应用程序。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;许多 Facebook 功能与 8.0 中的类似功能并不向前兼容，需要一种弃用或迁移途径。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;MyRocks 的增强功能需要在 8.0 中运行，包括本地化分区和崩溃恢复。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;1、代码补丁&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;首先我们建立了 8.0 分支，用于在开发环境中进行构建和测试。然后，我们开始从 5.6 分支移植补丁的漫长过程。开始的时候有 1700 多个补丁，但我们能将其组织成几个主要类别。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们的大多数自定义代码都有很好的注释和描述，因此可以很容易地确定应用程序是否仍然需要它，或者是否可以将它删除。通过特殊关键字或唯一变量名所启用的功能，也使得确定关联变得很容易，因为我们可以搜索应用程序代码库来找到它们的用例。有些补丁非常晦涩难懂，需要做调查工作 — 挖掘旧的设计文档、邮件或代码评审注释，以了解它们的历史。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;我们将每个补丁分入四类之一：&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Drop：不再使用，或在8.0中具有同等功能的特性，不需要移植。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Build/Client：支持我们构建环境的非服务器特性，修改过的 MySQL 工具，比如 mysqlbinlog，或者增加的功能，如异步客户端 API 等，需要移植。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;非 MyRocks 服务器：mysqld 服务器中与 MyRocks 存储引擎无关的特性，需要移植。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;MyRocks 服务器：支持 MyRocks 存储引擎的特性，需要移植。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;我们使用电子表格跟踪每个补丁的状态和相关历史信息，并且在删除补丁时记录理由。更新相同特性的多个补丁被组在一起进行移植。移植并提交到 8.0 分支的补丁，用 5.6 提交信息进行了注释。由于我们需要筛选大量的补丁，将不可避免地出现移植状态上的差异，这些注释帮助我们解决了此类问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;客户端和服务器类别中的每个补丁都自然而然地成为一个软件发布里程碑。随着所有与客户端相关的更改的移植，我们能够将客户端工具和连接器代码更新到8.0。一旦所有非 MyRocks 服务器特性都被移植，我们就可以为 InnoDB 服务器部署8.0 mysqld了。完成 MyRocks 服务器特性移植使我们能够更新 MyRocks 安装。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有些复杂特性需要对 8.0 进行重大更改，一些方面存在很大的兼容性问题。例如，上游 8.0 binlog 事件格式与我们一些对 5.6 的定制修改不兼容。Facebook 5.6 特性使用的错误代码与上游 8.0 分配给新特性的错误代码冲突。我们最终需要修补 5.6 服务器，以使其与 8.0 向前兼容。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;完成所有这些特性的移植花了几年时间。到最终结束时，我们已经评估了 2300 多个补丁，并将其中 1500 个移植到了 8.0 版本。另外，微信搜索readdot，关注后回复 视频教程 获取23种精品资料，非常齐全。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;2、迁移途径&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;我们将多个 mysqld 实例组合到一个 MySQL 副本集中。副本集中的每个实例都包含相同的数据，但在地理上分布到不同的数据中心，以提供数据可用性和故障切换支持。每个副本集都有一个主实例。其余的实例都是从实例。主实例处理所有写流量，并将数据异步复制到所有从实例。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由 5.6 主/5.6 从所组成的副本集开始，最终目标是包含 8.0 主/ 8.0 从的副本集。我们遵循一个类似于 UDB MyRocks migration plan 的迁移规划。&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对于每个副本集，通过一个使用 mysqldump 生成的逻辑备份，创建并添加到 8.0 的从实例。这些从实例不提供任何应用程序读取流量；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在 8.0 从实例上开启读取流量；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;允许将 8.0 从实例升级为主实例；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;禁用 5.6 实例的读取流量；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;移除所有 5.6 实例。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;每个副本集可以独立地通过上述步骤进行迁移，并可根据需要停留在一个步骤上。我们将副本集分成更小的组，在组中进行每一次迁移。如果发现问题，我们可以回滚到上一步。在某些情况下，副本集能够在其它副本集开始之前到达最后一步。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了自动化迁移大量副本集，我们需要构建新的软件架构。可以通过简单地更改配置文件中的一行，将副本集组合并在每个阶段中移动它们。任何遇到问题的副本集都能单独回滚。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;3、基于行的复制&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;作为 8.0 迁移工作的一部分，我们决定将使用基于行的复制（row-based replication，RBR）作为标准。一些 8.0 特性需要 RBR，并且它简化了 MyRocks 的移植工作。我们的大多数 MySQL 副本集已经在使用 RBR，而那些仍然运行基于语句的复制（statement-based replication，SBR）的副本集不容易迁移。这些副本集通常有不含任何高基数键的表。完全转向 RBR 是一个目标，但添加主键所需的长尾工作的优先级往往低于其它项目。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此，我们将 RBR 作为 8.0 的要求。在评估并向每个表添加主键之后，我们今年切换了最后一个 SBR 副本集。使用 RBR 还为我们提供了一个解决应用程序问题的替代解决方案，我们在将一些副本集移动到 8.0 主实例时遇到了这个问题，将在后面讨论。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;4、自动化验证&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;大多数 8.0 迁移过程都涉及使用我们的自动化架构和应用查询来测试和验证 mysqld 服务器。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们用来管理服务器的自动化基础架构在随着 MySQL 服务器的增长而增长。为了确保所有 MySQL 自动化组件都与 8.0 版本兼容，我们投资构建了一个测试环境，该环境利用虚拟机上的测试副本集来验证行为。我们为 canary 编写了在 5.6 版本和 8.0 版本上运行的每个自动化组件的集成测试，并验证了它们的正确性。在进行此演练时，我们发现了几个错误和行为差异。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当 MySQL 架构的每一部分都在我们的 8.0 服务器上进行验证时，我们发现并修复了（或解决了）一些有趣的问题：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;解析错误日志、mysqldump 输出或服务器 show 命令的文本输出的软件很容易损坏。服务器输出的细微变化常常会暴露出工具解析逻辑中的错误。&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;8.0 的默认 utf8mb4 排序规则设置导致 5.6 和 8.0 实例之间的排序规则不匹配。8.0 表可能会使用新的 utf8mb4_0900 排序规则，即使对于由 5.6 的show create table生成的create语句也是如此，因为使用utf8mb4_general_ci 的 5.6 模式没有显式指定排序规则。这些表差异通常会导致复制和模式验证工具出现问题；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;某些复制失败的错误代码发生了变化，我们必须修复我们的自动化程序来正确处理它们；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;8.0 版本的数据字典废弃了 table.frm 文件，但是我们的一些自动化系统使用它们来检测表模式的修改；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;我们必须更新自动化系统，以支持 8.0 中引入的动态权限。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;5、应用程序验证&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;我们希望迁移对应用程序尽可能透明，但是有些应用程序的查询会出现性能退化，或者在8.0 上会失败。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于 MyRocks 迁移，我们构建了一个 MySQL 影子测试框架，该框架捕获生产流量并将其重放到测试实例中。对于每个应用程序工作负载，我们在 8.0 上创建了测试实例，并向它们回放影子流量的查询。我们捕获并记录了从 8.0 服务器返回的错误，并发现了一些有趣的问题。不幸的是，并非所有这些问题都是在测试过程中发现的。例如，事务死锁是应用程序在迁移过程中发现的。在研究不同的解决方案时，我们可以暂时将这些应用程序回滚到 5.6 版本。&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;8.0 引入了新的保留关键字，其中一些关键字，如 groups 和 rank，与应用程序查询中常用的表列名或别名相冲突。这些查询没有通过反引号转义名称，导致解析错误。使用了自动转义查询中列名的软件库的应用程序没有遇到这些问题，但并非所有应用程序都使用这些软件库。解决这个问题很简单，但是需要时间来跟踪生成这些查询的应用程序属主和代码库。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在 5.6 和 8.0 之间还发现了有些 REGEXP 不兼容。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;一些包含在 InnoDB 上的 insert ... on duplicate key 查询的应用程序遇到了 repeatable-read 事务死锁。5.6 有一个 bug，在 8.0 中得到了修复，但是修复增加了事务死锁的可能性。在分析了查询之后，我们能够通过降低隔离级别来解决该问题。这个选项对我们来说是可用的，因为我们已经切换到基于行的复制。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;我们自定义的 5.6 文档存储和 JSON 函数与 8.0 不兼容。使用文档存储的应用程序需要将文档类型转换为文本以进行迁移。对于 JSON 函数，我们向 8.0 服务器中添加了兼容 5.6 的版本，以便应用程序以后可以迁移到 8.0 API。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;我们对 8.0 服务器的查询和性能测试发现了一些需要立即解决的问题。&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;我们发现在 ACL 缓存部分出现了新的互斥争用热点。当大量连接同时打开时，它们都会阻塞 ACL 检查；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;当存在大量 binlog 文件并且 binlog 的高速写入导致频繁轮换文件时，binlog 索引访问也发现了类似的争用；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;几个涉及临时表的查询被中断。这些查询会返回意外错误，或者运行时间太长以致超时。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;内存使用量与 5.6 相比有所增加，特别是对于 MyRocks 实例，因为必须加载 8.0 中的 InnoDB 。默认的 performance_schema 设置启用了所有工具集并消耗了大量内存。我们限制了内存使用，只启用了少量的工具，并对代码进行了更改，以禁用无法手动关闭的表。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然而，并不是所有增加的内存都是分配给 performance_schema 的。我们需要检查和修改各种 InnoDB 内部数据结构，以进一步减少内存占用。这一努力使 8.0 的内存使用率降到了可以接受的水平。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;6、接下来的工作&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;到目前为止，8.0 的移植已经花了几年时间。我们已将许多 InnoDB 副本集转换为完全在 8.0 上运行。剩下的大部分都处于迁移途径的不同阶段。现在，我们的大多数定制功能都已移植到 8.0，更新到 Oracle 的次版本相对容易些，我们计划跟上最新版本的步伐。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;跳过 5.7 这样的主版本会带来一些问题，我们的迁移需要解决这些问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先，我们无法就地升级服务器，需要使用逻辑转储和还原来构建新服务器。但是，对于非常大的 mysqld 实例，这可能需要在活跃生产服务器上运行很多天，而且这个脆弱的过程可能会在完成之前被中断。对于这些大型实例，我们必须修改备份和恢复系统来应对重建。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其次，检测 API 更改要困难得多，因为 5.7 可能会向我们的应用程序客户端发出不推荐警告，以提示修复潜在的问题。而我们需要在迁移生产工作负载之前，运行额外的影子测试来查找失败。使用自动转义模式对象名称的 mysql 客户端软件，有助于减少兼容性问题的数量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在一个副本集中支持两个主版本非常困难。一旦副本集将其主实例升级为 8.0，最好尽快禁用并移除 5.6 实例。应用程序用户往往会发现只有 8.0 支持的新特性，比如 utf8mb4_0900 排序规则，使用这些排序规则可能中断 8.0 和 5.6 实例之间的复制流。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;尽管我们在迁移过程中遇到了种种障碍，但我们已经看到了运行 8.0 带来的好处。一些应用程序选择了提早迁移到 8.0，以利用诸如文档存储和改进的日期时间支持等功能。我们一直在考虑如何在 MyRocks 上支持像即时DDL这样的存储引擎特性。总的来说，新版本大大扩展了 MySQL@Facebook 的功能。&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;逆锋起笔&lt;/code&gt;专注于程序员圈子，你不但可以学习到&lt;code&gt;java&lt;/code&gt;、&lt;code&gt;python&lt;/code&gt;等主流技术干货和N多个&lt;code&gt;源码&lt;/code&gt;分享，还可以第一时间获悉&lt;code&gt;最新技术动态&lt;/code&gt;、&lt;code&gt;内测资格&lt;/code&gt;、&lt;code&gt;BAT大佬的经验&lt;/code&gt;、&lt;code&gt;精品视频教程&lt;/code&gt;、&lt;code&gt;副业赚钱&lt;/code&gt;经验，微信搜索&lt;code&gt;readdot&lt;/code&gt;关注！&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMzM2ODUwMA==&amp;amp;mid=2247496513&amp;amp;idx=2&amp;amp;sn=cb9d32c5beca2799ab05bf9579de77d8&amp;amp;chksm=fa3f121acd489b0cde477f129ebec3409f2f4e71289322fc9f272a1b9e86286765225bbe094f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;MySQL 团队开发规范，太详细，建议收藏！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;MySQL 团队开发规范，太详细，建议收藏！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMzM2ODUwMA==&amp;amp;mid=2247496466&amp;amp;idx=2&amp;amp;sn=a2a6b6405ca08602af2e1eac811c774a&amp;amp;chksm=fa3f1249cd489b5fed6fad1b35197d0546b3a8cb26d93572b240da8c262c1323fd83a0903ead&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;MySQL 跨库分页/ 分表分页，为什么这么难？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;MySQL 跨库分页/ 分表分页，为什么这么难？&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMzM2ODUwMA==&amp;amp;mid=2247496098&amp;amp;idx=2&amp;amp;sn=199c481bdf4e8a8c107f371c6909d7b8&amp;amp;chksm=fa3f10f9cd4899ef96a1a3807e87cdb878cb8ebf177bc40161a1817eb6b93492568fd96c8aae&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;MySQL、Redis、MongoDB 网络抓包工具&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;MySQL、Redis、MongoDB 网络抓包工具&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMzM2ODUwMA==&amp;amp;mid=2247495256&amp;amp;idx=2&amp;amp;sn=f6cab657abb356869a63f94cc3bc6bb2&amp;amp;chksm=fa3f0f03cd48861552db1bf48c9a6bac0b097aa3e6ae7f907ea5e11fff55eba7806773c8b913&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;SQL 中如何给指定数据库创建只读用户？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;SQL 中如何给指定数据库创建只读用户？&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMzM2ODUwMA==&amp;amp;mid=2247495603&amp;amp;idx=2&amp;amp;sn=1530c7a01b0af0dfa501ca958570bf0e&amp;amp;chksm=fa3f0ee8cd4887fe5507427a7a2a2e5da5b0328f856fb0dc10a8c53efacb4b295e2aa7d57ca1&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;MySQL 8.0 可以操作 JSON 了！！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;MySQL 8.0 可以操作 JSON 了！！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.20555555555555555&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hs540iaTKoaLuzhKPBHe2SjggUdf1L0gvgSUlh0BGUNhwcVcSqe878WFZeibXfutEfN8b3cUJSLzT5INExmnibuYg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qlogo.cn/mmbiz_jpg/xe4FY1hGDmq17JSGmvlibgJjT73DIFV5hNpPbbL7bDtKBKyOka9bl1LLiam25MusZplIsuk5l0zQW2Pg1WhvCRJw/?wx_fmt=jpeg&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;193&quot; data-cropy1=&quot;63&quot; data-cropy2=&quot;246&quot; data-fileid=&quot;100014145&quot; data-ratio=&quot;0.9583333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xe4FY1hGDmq17JSGmvlibgJjT73DIFV5hkricMTLpuRLmhy0OV8C9hGF9CkdmvficOyYXtfZcNTbYGgibtSSGd3zmw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;192&quot;/&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt;你在看吗&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong/&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>