<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>81a426122bacfc3c908f02b1c37a1ad7</guid>
<title>字节跳动前端日常实习一二三面面经（Offer 还愿）</title>
<link>https://toutiao.io/k/lu4qgp2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-topic-des nc-post-content&quot;&gt;
&lt;h1&gt; 时间线 &lt;/h1&gt; 
&lt;p&gt;
  5.19投递简历 
&lt;/p&gt; 
&lt;p&gt;
  5.20hr约一面 
&lt;/p&gt; 
&lt;p&gt;
  5.24一面 
&lt;/p&gt; 
&lt;p&gt;
  5.25中午一面通过，hr约二面时间。本来约的是6月1号，但面试官临时请假，改到了3号 
&lt;/p&gt; 
&lt;p&gt;
  6.3二面 
&lt;/p&gt; 
&lt;p&gt;
  6.4下午二面通过，hr约三面时间 
&lt;/p&gt; 
&lt;p&gt;
  6.8三面 
&lt;/p&gt; 
&lt;p&gt;
  6.9中午三面通过，hr约10号三面 
&lt;/p&gt; 
&lt;p&gt;
  有些问题可能不是面试官的本意，还有一些问题没听懂，从场景题提取问题出来还是挺难的 
&lt;/p&gt; 
&lt;div&gt;
 &lt;span&gt; 其实15号中午的时候就offer了，现在来添加&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%9D%A2%E7%BB%8F&quot; target=&quot;_blank&quot;&gt;面经&lt;/a&gt;答案，答案只是我的见解哈，有些部分也没给出来，如果有错误欢迎指出 &lt;/span&gt;
&lt;/div&gt; 
 
&lt;h1&gt; &lt;span&gt;&lt;span&gt;一面（&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%89%9B%E5%AE%A2&quot; target=&quot;_blank&quot;&gt;牛客&lt;/a&gt;50mins）&lt;/span&gt;&lt;/span&gt; &lt;/h1&gt; 
&lt;div&gt; 
 &lt;span&gt; 
  &lt;ol&gt; 
   &lt;li&gt; &lt;p&gt; &lt;span&gt;怎么判断两个网站是否同域&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;浏览器从一个域向另一个域的服务器发送请求来访问其资源。 浏览器的同源策略：协议、域名、端口号一致。&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;保持登录状态能够使用什么实现&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;cookie,token&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;externals是怎么实现的&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span/&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;你这些外部的资源是存在公共的CDN上，还是有现成可以直接用的托管CDN&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;回答了公共的CDN&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;是哪种类型的CDN呢，具体是哪些域名&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;为什么CDN能够加速用户访问一个网站，它的原理是什么&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;最简单的CDN网络由一个DNS服务器和几台缓存服务器组成：&lt;/span&gt; &lt;/p&gt; 
     &lt;ol&gt; 
      &lt;li&gt; &lt;p&gt; &lt;span&gt;当用户点击网站页面上的内容URL，经过本地DNS系统解析，DNS系统会最终将域名的解析权交给CNAME指向的CDN专用DNS服务器。&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
      &lt;li&gt; &lt;p&gt; &lt;span&gt;CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回给用户&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
      &lt;li&gt; &lt;p&gt; &lt;span&gt;用户向CDN的全局负载均衡设备发起内容URL访问请求&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
      &lt;li&gt; &lt;p&gt; &lt;span&gt;CDN全局负载均衡设备根据用户IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
      &lt;li&gt; &lt;p&gt; &lt;span&gt;区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：根据用户IP地址，判断哪一台服务器距用户最近；根据用户所请求的URL中携带的内容名称，判断哪一台服务器上有用户所需内容；查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。基于以上这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
      &lt;li&gt; &lt;p&gt; &lt;span&gt;全局负载均衡设备把服务器的IP地址返回给用户&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
      &lt;li&gt; &lt;p&gt; &lt;span&gt;用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
     &lt;/ol&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;怎么确定哪个CDN节点离用户最近呢&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;上个问题答案的第4.5点&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;假设同样的资源，我用域名去访问，访问到哪个服务器取决于什么？&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;DNS &lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;DNS解析过程&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/yanshuanche3765/article/details/82589210&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;参考文章&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;简单的来说，浏览器先检查自身有没有缓存，如果没有就检查操作系统有没有缓存，如果还是没有就会向本地域名服务器发起一个请求来解析这个域名；如果本地域名服务器还是没有，则会从根域名服务器开始递归查找域名，直到找到为止。&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;DNS解析过程中，某个DNS服务器的记录被篡改过，指向一个恶意网站，这种情况会对用户的访问造成安全风险，这么防范。怎么防范DNS污染（应该是这个问题）&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;感觉这个问题不是很重要&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;DNS使用什么网络协议&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_41563161/article/details/106069473?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&amp;amp;spm=1001.2101.3001.4242&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;参考文章&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;&lt;strong&gt;DNS区域传输的时候使用TCP协议：&lt;/strong&gt;&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;1.辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;2.TCP是一种可靠连接，保证了数据的准确性。&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;&lt;strong&gt;域名解析时使用UDP协议：&lt;/strong&gt;&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;除了打包体积减小，还有哪些手段可以提升用户的访问速度&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;缓存，懒加载，代码优化，SSR...&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;HTTP缓存怎么设置&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/jiang_yonghui/article/details/100569565&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;参考这个&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;通过设置Cache-Control/Pragma、Expires(过期时间)、Last-Modified/Etag。&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;确定协商缓存有效性的协商过程是怎么样的&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;在第一次请求服务器时，服务器会返回资源，并且返回一个资源的缓存标识，一起存到浏览器的缓存数据库。当第二次请求资源时，浏览器会首先将缓存标识发送给服务器，服务器拿到标识后判断标识是否匹配，如果不匹配，表示资源有更新，服务器会将新数据和新的缓存标识一起返回到浏览器；如果缓存标识匹配，表示资源没有更新，并且返回 &lt;/span&gt;&lt;span&gt;304&lt;/span&gt;&lt;span&gt; 状态码，浏览器就读取本地缓存服务器中的数据。&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;有些资源打开页面的时候不需要，需要的时候在加载&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/bury_/article/details/79516223&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;懒加载原理&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;懒加载&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;不同类型的东西处理方式不一样，例如图片，js代码，他们分别怎么懒加载&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;js通过设置defer和async&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;建议图片懒加载多去看看实现方法&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/w1418899532/article/details/90515969?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-4.control&amp;amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-4.control&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;图片懒加载&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;有没有更简单的方式去判断图片离浏览器顶部距离的方法&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;阮一峰老师的文章&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;面试官建议：intersectionObserver?这个API，可以监控一个元素即将进入到窗口的范围&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;说一下Vue的工作原理（响应式原理）&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;Vue响应式底层实现方法是 Object.defineProperty() 方法，该方法中存在一个getter和setter的可选项，可以对属性值的获取和设置造成影响&lt;/span&gt; &lt;/p&gt; 
     &lt;ul&gt; 
      &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;当你把一个普通的 &lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=JavaScript&quot; target=&quot;_blank&quot;&gt;JavaScript&lt;/a&gt; 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的 property，并使用 Object.defineProperty 把这些 property 全部转为 getter/setter。&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
      &lt;li&gt; &lt;p&gt; &lt;span&gt;这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
      &lt;li&gt; &lt;p&gt; &lt;span&gt;每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
     &lt;/ul&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;我改变了一个Data中数据后，他怎么更新到实际页面的DOM，这个过程是怎样的&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;模板里面，对于一个字段的引用是怎么收集的&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;对于这个字段的依赖是在什么时候建立的呢，是怎么建立的呢&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;假设有A，B两个请求，希望在A请求完后拿到一个结果，之后将A的结果作为参数给B，B发起请求，这样的过程要怎么实现&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;异步操作&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;如果A，B没有依赖关系，希望两个都拿到结果之后，在执行一些操作，要怎么实现&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;Promise.all&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;你提到Promise.all，那假设浏览器没有这个东西，你给我整一个&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;div&gt; 
      &lt;span&gt;接下来是20分钟的修改代码过程...&lt;/span&gt;
      &lt;span&gt; &lt;pre class=&quot;prettyprint lang-js&quot; from-niu=&quot;default&quot;&gt;function myPromiseAll(promises) {
  let results = [];
  let promiseCount = 0;
  let promisesLength = promises.length;
  return new Promise(function(resolve, reject) {
    for(let i = 0; i &amp;lt; promises.length; i++){
      Promise.resolve(promises[i]).then(function(res) {
        promiseCount++;
        results[i] = res;
        // 当所有函数都正确执行了，resolve输出所有返回结果。
        if (promiseCount === promisesLength) {
          return resolve(results);
        }
      }, function(err) {
        return reject(err);
      });
    }
  });
};
&lt;/pre&gt; &lt;br/&gt; &lt;span/&gt;&lt;/span&gt; 
     &lt;/div&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;反问&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;部门：交叉面试&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;建议：多实践&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
  &lt;/ol&gt; &lt;br/&gt; &lt;/span&gt; 
&lt;/div&gt; 
&lt;h1&gt; &lt;span&gt;&lt;span&gt;二面（&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%89%9B%E5%AE%A2&quot; target=&quot;_blank&quot;&gt;牛客&lt;/a&gt;38mins）&lt;/span&gt;&lt;/span&gt; &lt;/h1&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;简单问了下&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;的东西&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
 &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;里有订单管理的功能，一般来说订单要考虑什么状态呢&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
 &lt;li&gt; &lt;p&gt; &lt;span&gt;如何实时拿到这些状态呢&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
 &lt;li&gt; &lt;p&gt; &lt;span&gt;最近在学什么呢&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
 &lt;li&gt; &lt;span&gt; &lt;p&gt; &lt;span&gt;vue框架有什么特点&lt;/span&gt; &lt;/p&gt; 
   &lt;blockquote&gt; 
    &lt;p&gt; &lt;span&gt;数据驱动、组件化&lt;/span&gt; &lt;/p&gt; 
   &lt;/blockquote&gt; &lt;/span&gt; &lt;/li&gt;
 &lt;li&gt; &lt;p&gt; &lt;span&gt;手撕代码（写完说思路&lt;/span&gt; &lt;/p&gt; 
  &lt;blockquote&gt; 
   &lt;div&gt; 
    &lt;span&gt;&lt;span&gt;冒泡，快速&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt; &lt;/span&gt;&lt;pre class=&quot;prettyprint lang-js&quot; from-niu=&quot;default&quot;&gt;function bubbleSort(array){
    let length = array.length;
    for(let i = 0; i &amp;lt; length - 1; i++){
        for(let j = 0; j &amp;lt; length - i -1; j++){
            if(array[j] &amp;lt; array[j+1]){
                [array[j],array[j+1]] = [array[j+1],array[j]];
            }
        }
    }
}

let test = [6,8,4,5,1];
bubbleSort(test);
console.log(test);

function quickSort(array){
    if(array.length &amp;lt; 2) return array;
    let leftArray = [];
    let rightArray = [];
    let base = array[0];
    array.forEach((element) =&amp;gt; {
        if(element &amp;gt; base){
            leftArray.push(element);
        } else if(element &amp;lt; base){
            rightArray.push(element);
        }
    });
    return quickSort(leftArray).concat(base,quickSort(rightArray));
};

let test2 = [5,3,2,1,4];
let res = quickSort(test2);

console.log(res);&lt;/pre&gt; &lt;br/&gt; &lt;span/&gt;&lt;/span&gt; 
   &lt;/div&gt; 
  &lt;/blockquote&gt; 
  &lt;blockquote&gt; 
   &lt;p&gt; &lt;span&gt;实现一个函数，把一个字符串数组（[&#x27;zm&#x27;, &#x27;za&#x27;, &#x27;b&#x27;, &#x27;lm&#x27;, &#x27;ln&#x27;, &#x27;k&#x27;]）格式化成一个对象 { &#x27;b&#x27;: [&#x27;b&#x27;], &#x27;k&#x27;: [&#x27;k&#x27;], &#x27;l&#x27;: [&#x27;lm&#x27;, &#x27;ln&#x27;], &#x27;z&#x27;: [&#x27;za&#x27;, &#x27;zm&#x27;] }&lt;/span&gt; &lt;/p&gt; 
  &lt;/blockquote&gt; &lt;p&gt; &lt;span&gt;这道题没写完整，说了下思路用伪代码写了下。&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
 &lt;li&gt; &lt;p&gt; &lt;span&gt;近一两年的规划&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
 &lt;li&gt; &lt;p&gt; &lt;span&gt;为什么选择字节&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt; &lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
&lt;/ol&gt; 
&lt;h1&gt; &lt;span&gt;&lt;span&gt;三面6.8（&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%89%9B%E5%AE%A2&quot; target=&quot;_blank&quot;&gt;牛客&lt;/a&gt;38mins）&lt;/span&gt;&lt;span/&gt;&lt;/span&gt; &lt;/h1&gt; 
&lt;div&gt; 
 &lt;span&gt; 
  &lt;ol&gt; 
   &lt;li&gt; &lt;p&gt; &lt;span&gt;聊了下之前的笔试&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;参与之前的面试下来，有什么感受，有没有总结出自己的长处与短板&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;&lt;span&gt;提到了要深入学原理&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%BA%90%E7%A0%81&quot; target=&quot;_blank&quot;&gt;源码&lt;/a&gt;啥的&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;你打算怎么看&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%BA%90%E7%A0%81&quot; target=&quot;_blank&quot;&gt;源码&lt;/a&gt;&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;聊一下&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;为什么做这个&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;有没有你自己想的一些功能&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;怎样从零搭建&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/baidu_41690072/article/details/88820400&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;感觉就是看你是不是真的自己做了一遍&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;使用vue-cli初始化的步骤&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;vue-cli主要帮你完成了哪些事情&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;1.ES6代码转换成ES5代码 2. scss/sass/less/stylus转css 3. .vue文件转换成js文件 4. 使用 jpg、png，font等资源文件 4. 自动添加css各浏览器产商的前缀 5. 代码热更新 6. 资源预加载 7. 每次构建代码清除之前生成的代码 8. 定义环境变量 9. 区分开发环境打包跟生产环境打包 ......&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;其中生成的那些文件，分别是干什么的&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;packjson文件里有一些key，value。其中一个key叫dependencies和devDependencies，能说说作用吗&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;package.json:&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;&lt;span&gt;主要用来定义&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;中需要依赖的包&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;package-lock.json：&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;在 &lt;/span&gt;&lt;span&gt;npm install&lt;/span&gt;&lt;span&gt;时候生成一份文件，用以记录当前状态下实际安装的各个npm package的具体来源和版本号。&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;&#x27;^&#x27; :&lt;/span&gt;放在版本号之前，表示向后兼容依赖，说白了就是在大版本号不变的情况下，下载最新版的包 &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;中引入的包版本号之前经常会加^号，每次在执行npm install之后，下载的包都会发生变化，为了系统的稳定性考虑，每次执行完npm install之后会对应生成package-lock文件，该文件记录了上一次安装的具体的版本号，相当于是提供了一个参考，在出现版本兼容性问题的时候，就可以参考这个文件来修改版本号即可。&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; 
    &lt;blockquote&gt; 
     &lt;ol&gt; 
      &lt;li&gt; &lt;p&gt; &lt;span&gt;“dependencies”&lt;/span&gt;&lt;span&gt; 运行依赖，需引入页面使用&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
      &lt;li&gt; &lt;p&gt; &lt;span&gt;“devDependencies”&lt;/span&gt;&lt;span&gt; 开发依赖(生产环境使用)，只是开发阶段需要&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
     &lt;/ol&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;babel.config.js的作用&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;Babel是一个JS编译器，主要作用是将ECMAScript 2015+ 版本的代码，转换为向后兼容的JS语法，以便能够运行在当前和旧版本的浏览器或其它环境中。&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;&lt;span&gt;Vue&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;中普遍使用ES6语法，若要求兼容低版本浏览器，就需要引入Babel，将ES6转换为ES5。&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;babel怎么把es6转成es5&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;es6哪些特性你觉得比较常用或者好用&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;let const var区别&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;&lt;strong&gt;变量提升方面&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：var声明的变量存在变量提升，即变量可以在声明之前调用，值为undefined。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;let和const不存在变量提升问题(&lt;/span&gt;&lt;span&gt;注意这个‘问题’后缀，其实是有提升的，只不过是let和const具有一个暂时性死区的概念，即没有到其赋值时，之前就不能用&lt;/span&gt;&lt;span&gt;)，即它们所声明的变量一定要在声明后使用，否则报错。&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;&lt;strong&gt;块级作用域方面&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：var不存在块级作用域,let和const存在块级作用域&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;&lt;strong&gt;声明方面&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：var允许重复声明变量,let和const在同一作用域不允许重复声明变量。其中const声明一个只读的常量(因为如此，其声明时就一定要赋值，不然报错)。一旦声明，常量的值就不能改变。&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;回到&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;，登录功能怎么实现的&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;token怎么保持登录状态&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/u014322206/article/details/85089481&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;&lt;span&gt;当用户请求页面，输入用户信息，服务端经过验证后，会生成一个token安全令牌（随机字符串），并返回给&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;，当&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;发送下一次请求的时候，直接携带这个token，服务端识别后，就可以直接访问页面，不需要再次登录了&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;sessionStorage有什么优势，token应该放在哪&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/fejerry/p/10898530.html&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;sessionStorage的特点&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;+各个标签页的sessionStorage 是独立的 。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;+在a标签页写入修改删除sessionStorage ，不会影响到已经打开的标签页中的sessionStorage 。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;+通过a标签，window.open,window.location,windows.history ，右键复制 等方式在新标签页，本页，iframe ，新窗口中打开新页面，当前标签页的 sessionStorage 会传递到新页面。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;+通过按住 ctrl键打开新标签页，或者右键菜单打开新标签页，新窗口 ，当前标签页的 sessionStorage 是不会传递到新页面的 。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;+关闭某个标签页，该标签页的sessionStorage 会被销毁。不影响其他标签页或者窗口 。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;+在某个标签页即使跳出了当前站点，返回来的时候，sessionStorage 也还在的 。&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;鉴于它有以上特点 ：&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;1，可以用来做多账户登录 ， sessionid 不用cookie存储，用 sessionStorage 来存储。spa应用比较适合 。&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;p&gt; &lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/qq_43618136/article/details/114656505&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;token存放位置参考&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;Cookie 的作用是与服务器进行交互，作为 HTTP 规范的一部分而存在 ，而 Web Storage 仅仅是为了在本地“存储”数据而生。而token的安全和性能都是中肯的，唯一的问题就是cookie的存储性能和提取安全性太低，而localstorage更安全而且能够跨会话实现身份鉴别，很明显token应该存在localstorage里。&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;localStorage里可以存图片吗，怎么存&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/cockroach02/article/details/49926595&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;参考文章&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;我们的想法是做到将已经当前页面中已缓存的图片保存到本地存储中。不过就像我们之前已经确定的，本地存储只支持字符串的存取，那么我们要做的就是将图片转换成 &lt;/span&gt;&lt;span&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Data_URI_scheme&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;Data URI&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;span&gt; 。其中一种实现方式就是用canvas元素来加载图片。然后你可以以Data URI的形式从canvas中读取出当前展示的内容。&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;token能放在cookie里吗&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;可以&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;xss能不能取到sessionStorage里的数据&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;可以&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;hash路由和history路由&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;除了这个&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;还有别的&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;吗&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;翻页功能怎么实现&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;数据是&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%89%8D%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;前端&lt;/a&gt;来分页还是后端来分页&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;能实现&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%89%8D%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;前端&lt;/a&gt;分页吗&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;怎么实现&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;数据存哪&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;vuex有用过吗&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;vuex的目的是什么&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;已经有sessionStorage这类的放数据的地方，为什么还要有vuex，有什么特别的价值吗&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;聊了下笔试&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;问了下是不是还没有开始复习&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;和数据结构&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;说一个最近在复习的&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;再说说对应的例题&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;说了道最大无重复子串，双指针&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;复杂度&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92&quot; target=&quot;_blank&quot;&gt;动态规划&lt;/a&gt;一般解决什么样类型的问题&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92&quot; target=&quot;_blank&quot;&gt;动态规划&lt;/a&gt;相比于回溯，有什么优势&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;异步组件的懒加载是你自己想的还是教程有的&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;怎么实现懒加载&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;优化效果有看过吗&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;看到面评，问实习是想积累经验还是想转正&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;反问&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;部门：技术中台&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;看重实习生哪些方面&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
  &lt;/ol&gt; &lt;br/&gt; &lt;/span&gt; 
&lt;/div&gt; 
&lt;h1&gt; 碎碎念 &lt;/h1&gt; 
&lt;div&gt;&lt;p&gt;
  字节的面试官是能够看到你之前投递的简历，参加过的笔试和面试结果，所以如果要投的话一定要认真对待面试和笔试吧。
 &lt;/p&gt;&lt;span&gt;&lt;span&gt;另外我看到&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%89%9B%E5%AE%A2&quot; target=&quot;_blank&quot;&gt;牛客&lt;/a&gt;网也有&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%89%8D%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;前端&lt;/a&gt;的课程，笔试面试会涉及到的知识点里边基本都会涵盖，如果大家不知道从哪里开始学起的话可以报名这种课程~&lt;/span&gt;&lt;img data-card-emoji=&quot;[考得全会]&quot; src=&quot;https://uploadfiles.nowcoder.com/images/20191018/63_1571399956257_2484A7DF36877A14689574EEBDA6DD7C&quot;/&gt;&lt;/span&gt; 
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c754b5e331946e9eced256584b3ac950</guid>
<title>推荐 7 个牛哄哄 Spring Cloud 实战项目</title>
<link>https://toutiao.io/k/016vv4f</link>
<content:encoded>&lt;div&gt;&lt;div&gt;

                

                
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1757b3cc46b3d3b2af00b2772f344ca9</guid>
<title>Java 类加载器：坑爹是我的特色</title>
<link>https://toutiao.io/k/gnxxx4b</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是头发还很多的阿星&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0480769230769231&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzynmJ9bWzU7WbaTHAUb6lKfwPh7MfJsd4ZGiaKxs8KCBnUlaLzoNLgRMzPROpl4HzqDianVCkQulpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;312&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天的主角是「在日常开发中，存在感非常低的&lt;strong&gt;类加载器&lt;/strong&gt;」，众所周知大佬除了头发比较少，还非常低调，如果想和大佬交朋友，那一定要先认识大佬，下面阿星来带大家认识一下&lt;strong&gt;类加载器&lt;/strong&gt;（本文不涉及源码）。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是类加载器&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们平时写了那么多的&lt;code&gt;Java&lt;/code&gt;代码，却不知&lt;code&gt;Java&lt;/code&gt;类的加载过程，岂不是很尴尬，为了打破尴尬，阿星得从&lt;code&gt;Java&lt;/code&gt;类说起。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们编写的&lt;code&gt;Java&lt;/code&gt;类也就是&lt;code&gt;.java&lt;/code&gt;文件，通过&lt;code&gt;Java&lt;/code&gt;编译器编译成&lt;code&gt;.class&lt;/code&gt;文件，&lt;code&gt;.class&lt;/code&gt;文件中保存着&lt;code&gt;Java&lt;/code&gt;代码转换后的虚拟机指令。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7701317715959004&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzynmJ9bWzU7WbaTHAUb6lKhoWWRy3r114ib0lppyMJiaUhMVibeyA00qvb78sYy7o56VOKWwmiaII8Aw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;683&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当程序使用某个&lt;code&gt;Java&lt;/code&gt;类时，&lt;code&gt;JVM&lt;/code&gt;虚拟机会加载它的&lt;code&gt;.class&lt;/code&gt;文件到虚拟机的内存中，负责加载工作的就是&lt;strong&gt;类加载器&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;类加载过程&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实类加载器和日常生活中坐地铁过安检是一样的道理，不信你看下面的图&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.33208676140613314&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzynmJ9bWzU7WbaTHAUb6lKqO7QkKWDkBV72tfLMtwmicd2L8A11EoFrepK2rAqM37Yrnjx3nnnWsw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1337&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安检要经过一系列的检查过程，目的是让进入地铁站的人群符合乘坐标准，比如你不能感冒，不能带威胁人生安全的物品等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样&lt;strong&gt;类加载&lt;/strong&gt;也要经过一系列检查过程，这个过程称为&lt;strong&gt;类加载过程&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类加载过程分为&lt;strong&gt;加载、验证、准备、解析、初始化&lt;/strong&gt;，下图是对&lt;strong&gt;类加载过程&lt;/strong&gt;简单的介绍。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.34366925064599485&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzynmJ9bWzU7WbaTHAUb6lKy9LBicibYXM8STEJQoTJbzLGv2NKyIl592uqC2NKnQfI2vGjxBR41H7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1161&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类加载过程不是本文的重点，如果对这块有兴趣深入研究的伙伴可以去自行百度或google。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面要说说本文的重点，双亲委派模式&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;实力坑爹&lt;/span&gt;&lt;/h1&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0238095238095237&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/23OQmC1ia8nzynmJ9bWzU7WbaTHAUb6lKK0lTx8iaseiaBGGSljqicTxg2Ilcw2yy69W8cX2w3tC8zicz3d3QXQksKw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;252&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双亲委派机制有点像实力坑爹，出了什么事情都让爹去擦屁股，爹解决不了，自己才承担。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;JVM&lt;/code&gt;虚拟机提供了&lt;code&gt;3&lt;/code&gt;种类加载器，它们分别是启动类加载器（&lt;code&gt;Bootstrap&lt;/code&gt;）、扩展类加载器（&lt;code&gt;Extension&lt;/code&gt;）、系统类加载器（&lt;code&gt;System&lt;/code&gt;）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个类加载器都有明确的加载范围：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;启动类加载器（&lt;code&gt;Bootstrap&lt;/code&gt;）：加载&lt;code&gt;&amp;lt;JAVA_HOME&amp;gt;/lib&lt;/code&gt;路径下的核心类库&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;扩展类加载器（&lt;code&gt;Extension&lt;/code&gt;）：加载&lt;code&gt;&amp;lt;JAVA_HOME&amp;gt;/lib/ext&lt;/code&gt;l路径下的&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;系统类加载器（&lt;code&gt;System&lt;/code&gt;）：加载系统类路径&lt;code&gt;classpath&lt;/code&gt;，也就是我们经常用到的&lt;code&gt;classpath&lt;/code&gt;路径，一般情况该类加载器是程序中默认的类加载器&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzynmJ9bWzU7WbaTHAUb6lKSk4JpD8ibwFLC9OAFdwXZFhzqvE9okrsaU1ASJO1uKN1ibSib0pAFibNjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;652&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双亲委派模式的原理也十分简单，类加载器收到类加载请求，会委托给父类加载器去执行，父类加载器还存在其父类加载器，则进一步向上委托，依次递归，直到顶层类加载器，如果顶层类加载器加载到该类，就成功返回&lt;code&gt;class&lt;/code&gt;对象，否则委托给下级类加载器去执行，依次递归（&lt;strong&gt;此处的父子关系并非通常所说的继承关系，而是采用组合关系来实现&lt;/strong&gt;）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9266666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/23OQmC1ia8nzynmJ9bWzU7WbaTHAUb6lKrKvNzRpO9LdkXPKsIbg1vlZXZDDqKY01A57q1ahPtAwHQrxsHYT90A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;300&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用大白话来说就是，每个儿子都很懒，有事就丢给爹去干，直到爹说这件事我也干不了，儿子自己再想办法完成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双亲委派模式是为了避免重复加载和核心类篡改。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;特殊需求&lt;/span&gt;&lt;/h1&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9246376811594202&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/23OQmC1ia8nzynmJ9bWzU7WbaTHAUb6lKqDfmzeNeTDhl4f3N5LD06yKlXdD7YKeazBaK9v6hick53MMqqDOhJlA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;345&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在日常开发中，我们可能会有特殊的业务需求，可能就需要使用到&lt;strong&gt;自定义类加载器&lt;/strong&gt;，该加载器的上级一定是&lt;strong&gt;系统类加载器&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;你们想要的特殊需求&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;资源隔离&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;web&lt;/code&gt;容器可能需要部署两个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，因此要保证每个应用程序的类库都是独立的，相互隔离&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;web&lt;/code&gt;容器有自己依赖的类库，不能与应用程序的类库混淆，基于安全考虑，应该让容器的类库和程序的类库隔离&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;加密保护&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;公司的一些核心类库，可能会把字节码加密，这样加载类的时候就必须对字节码进行解密&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;其他来源加载类&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;类重新加载&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;JVM&lt;/code&gt;中类对象的唯一性：类加载器实例+完整类名&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;程序运行中，类内容发生变化，创建自定义加载器实例重新加载类，达到的热部署效果。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6775&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/23OQmC1ia8nzynmJ9bWzU7WbaTHAUb6lKfJAWTpJjRwzYL58nPnurgUG7KFuRcDsz5K1afdNhye6Xgh0PMp3wLQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;400&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里大家有个概念，理解下就够了，想深入探索就需要涉及源码分析，如果大伙有兴趣，评论区留言，阿星后续单独补一篇源码分析~&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;强大的父亲&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些爹的实力恐怖如斯，为了啥事都能帮后代处理好，直接破坏双亲委派模式，深受孩儿们的喜爱。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7671232876712328&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/23OQmC1ia8nzynmJ9bWzU7WbaTHAUb6lKGrj1sME5fw2kwdPSYLaFhuU8X9N5kmo4lic7YYfQhhF1YlZH7fOqqqA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;292&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Java&lt;/code&gt;应用中存在着很多服务提供者接口（&lt;code&gt;Service Provider Interface，SPI&lt;/code&gt;），这些接口允许第三方为它们提供实现，如常见的&lt;code&gt;SPI&lt;/code&gt;有&lt;code&gt;JDBC、JNDI&lt;/code&gt;等，这些&lt;code&gt;SPI&lt;/code&gt;的接口属于&lt;code&gt;Java&lt;/code&gt;核心库，一般存在&lt;code&gt;rt.jar&lt;/code&gt;包中，由启动类加载器（&lt;code&gt;Bootstrap&lt;/code&gt;）加载，而&lt;code&gt;SPI&lt;/code&gt;的第三方实现代码则是作为&lt;code&gt;Java&lt;/code&gt;应用所依赖的&lt;code&gt;jar&lt;/code&gt;包被存放在&lt;code&gt;classpath&lt;/code&gt;路径下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于&lt;code&gt;SPI&lt;/code&gt;接口中的代码需要加载第三方实现类并调用其相关函数，但&lt;code&gt;SPI&lt;/code&gt;的核心接口类是由启动类加载器（&lt;code&gt;Bootstrap&lt;/code&gt;）加载的，&lt;code&gt;Bootstrap&lt;/code&gt;加载器无法直接加载&lt;code&gt;SPI&lt;/code&gt;的实现类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这种情况下，我们就需要一种特殊的类加载器来加载第三方的类库，它就是线程上下文类加载器，线程的上下文类加载器默认设置的就是系统类加载器（&lt;code&gt;System&lt;/code&gt;）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.549636803874092&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzynmJ9bWzU7WbaTHAUb6lKGNxzlzvtfIhiaCdkbZ3lDz3w2ZTO6URxUr0Nt6t44HGV5GEPnhnQWEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;826&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;后面的计划安排&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给各位读者们汇报下后续的安排，嗯....，不出意外的话，基本都是周更了，然后期间转载一些精品的文章，大伙们看完了，记得一键三连啊，报告完毕！&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;关于我&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里是阿星，一个热爱技术的Java程序猿，公众号  &lt;strong&gt;「程序猿阿星」&lt;/strong&gt; 里将会定期分享操作系统、计算机网络、Java、分布式、数据库等精品原创文章，2021，与您在 Be Better 的路上共同成长！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非常感谢各位小哥哥小姐姐们能看到这里，原创不易，文章有帮助可以关注、点个赞、分享与评论，都是支持（莫要白嫖）！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/23OQmC1ia8nzynmJ9bWzU7WbaTHAUb6lKvVzTH2TeVfISvjO0ULLgUOF7AGSWIbYc6wPURjbHuF2yB5DmRqyo2Q/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;240&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;愿你我都能奔赴在各自想去的路上，我们下篇文章见&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5d5e612b89c3c5a0fbc122a77f79291c</guid>
<title>Java 原生线程池源码解析及使用建议</title>
<link>https://toutiao.io/k/gq4b7nx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;97617&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;线程池概念&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;线程池的基本概念&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;90%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;线程池（Thread pool）是一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。（来源：维基百科）&lt;/p&gt;&lt;p&gt;Java线程池相关类是在1.5新增的，所属包是rt.jar，包路径是java.util.concurrent，作者是：Doug Lea，从属JSR-166。&lt;/p&gt;&lt;p&gt;Java线程池也遵循线程池的核心设计思路，复用线程，降低线程创建销毁的资源消耗，提供了多种线程池的实现模型，同时也允许开发者定制化开发其他特色线程池。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;span data-num=&quot;2&quot;&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;java线程池优势&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;90%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;A） 降低资源消耗，提升效率 ：通过重复利用已创建的线程，降低线程创建和销毁造成的消耗，从而提高整体的执行效率。&lt;/p&gt;&lt;p&gt;B） 提高线程的管理性：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。&lt;/p&gt;&lt;p&gt;C） 可扩展的开发模式：除JVM提供的三种线程池，可以通过实现AbstractExecutorService类定制自己的线程池而支持不同的业务场景。&lt;/p&gt;&lt;p&gt;（这里很多资料都会有额外一条：提高响应速度，即通过复用以创建好的线程，而无需等待新线程的创建，这里个人认为严格讲这一条不完全符合线程池的使用情况，而且复用线程和第一条优势基本吻合，所以合并到一起，至于特殊场景后面学习的过程中会详细讲解。）&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;span data-num=&quot;3&quot;&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;java原生线程池简介&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;90%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;首先介绍下java原生的三个线程池，ForkJoinPool，ThreadPoolExecutor，ScheduledThreadPoolExecutor。三个线程池的UML类图如下（version：1.8.0_131，后面的源码都是基于这个版本）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6218274111675127&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFic7dDdDdODHibR3DRemLfcxfsRzk6ukLJYPfg8ZS34UCs8KxWHibiauDTveomJMz0GdQjdbmZhHnjibwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1576&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;A） ForkJoinPool是Java 1.7 引入的一种新的并发框架，核心思想是将大的任务拆分成多个小任务（fork），然后在将多个小任务处理汇总到一个结果上（join），充分利用多cpu，多核CPU的优势，引入了“work-stealing”机制，更有效的利用线程。&lt;/p&gt;&lt;p&gt;B） ThreadPoolExecutor是 java常用的线程池，提供基础的线程池功能。初始化传入不同类型的工作队列和拒绝策略参数，可以定制不同类型和功能的线程池，应用最为广泛。&lt;/p&gt;&lt;p&gt;C） ScheduledThreadPoolExecutor 从类图上可以看出，它继承了ThreadPoolExecutor，并实现了ScheduledExecutorService，是对ThreadPoolExecutor做的功能扩展，本质上是一个使用线程池执行定时任务的类，可以用来在给定延时后执行异步任务或者周期性执行任务，较任务调度的Timer来说，其功能更加强大。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;97617&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;线程池的实现原理&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;接下来以java的基础线程池ThreadPoolExecutor为主介绍下线程池的工作原理和实现方式。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;ThreadPoolExector类&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;90%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.1.1 ThreadPoolExector介绍&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;A） ThreadPoolExecutor实现的顶层接口是Executor，内部只有一个方法execute(Runable)，标识出执行任务这个核心方法。限制了任务类型为：Runable，即线程的接口类。&lt;/p&gt;&lt;p&gt;B）ExecutorService接口扩展了很多能力，比如对线程池的管理。以及扩展了执行任务的能力，支持多个任务批量执行。&lt;/p&gt;&lt;p&gt;C）AbstractExecutorService是对ExecutorService抽象类，这里对任务的执行和调用做了基础的实现，可以看出目前都是在对任务的执行做层层抽象，也规范了任务的基础类型。&lt;/p&gt;&lt;p&gt;D）ThreadPoolExecutor是java原生线程池的一个基础实现类，完成了线程池的各种功能，内部维护了存储任务的阻塞队列，以及执行任务的worker线程，还有线程池的相关状态管理及任务管理。同时提供了一些扩展方法。供开发者定制特色能力。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.147196261682243&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFic7dDdDdODHibR3DRemLfcxfRUViax05X4GSZMS5jGZCFfFMLfZ7tMy9zQDeUYOrISxRzaNic7jcNu8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;856&quot;/&gt;&lt;/p&gt;&lt;p&gt;    &lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.1.2 线程池的基础参数&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;接下来说一下创建ThreadPoolExecutor比较重要的参数。&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;corePoolSize：线程池核心线程个数。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;queue：用于保存等待执行的任务的阻塞队列；如基于数组的有界 ArrayBlockingQueue，基于链表的无界 LinkedBlockingQueue，优先级队列 PriorityBlockingQueue 等。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;maximunPoolSize：线程池最大线程数量。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;ThreadFactory：创建线程的工厂。可以自定义工工厂，控制产生的线程名称辅助排查问题。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;RejectedExecutionHandler：饱和策略，当队列满了且线程个数到 达maximunPoolSize 后采取的策略，如AbortPolicy 抛出拒绝执行；DiscardPolicy 丢弃该任务。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;keeyAliveTime：存活时间。如果当前线程池中的线程数量比核心线程数量要多，并且是闲置状态的话，这些闲置的线程能存活的最大时间。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;TimeUnit，存活时间的时间单位。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.2594810379241517&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFic7dDdDdODHibR3DRemLfcxfRuiakNTuEld0afj3t6LnPWmUWotqqLr2dh3NEH4nib2BzPQpQ1lJ3dkw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1002&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.1.3 ThreadPoolExecutor.Worker内部类&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;ThreadPoolExecutor.Worker这个工作线程，实现了Runnable接口，同时继承AQS类，并持有一个线程thread，一个初始化的任务firstTask。负责处理任务，同时维护工作线程的状态。&lt;/p&gt;&lt;p&gt;thread是在调用构造方法时通过ThreadFactory来创建的线程，用来执行任务。&lt;/p&gt;&lt;p&gt;firstTask是传入的第一个任务，如果非空，那么线程在启动初期立即执行这个任务，也就对应核心线程创建时的情况；如果这个值是null，那么就需要创建一个线程去执行workQueue中的任务，也就是非核心线程的创建。单个任务执行完毕后，worker会继续在workQueue中获取下一个任务继续执行。&lt;/p&gt;&lt;p&gt;    &lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;span data-num=&quot;2&quot;&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;ThreadPoolExecutor 工作流程&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;90%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.2.1 总体介绍&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4358322744599746&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFic7dDdDdODHibR3DRemLfcxf0Dh2MPaokCVZgBULn0CBcNvkyDYxZdWibL76kujmVWgHicjXQMicczJ5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1574&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;线程池在内部实际上构建了一个生产者消费者模型，将线程和任务两者解耦，不直接关联，从而良好的缓冲任务，复用线程。线程池的运行主要分成两部分: 任务管理、线程管理。任务管理部分充当生产者的角色，当任务提交后，线程池会判断该任务后续的执行策略。主要有以下几种：&lt;/p&gt;&lt;p&gt;(1)直接申请线程执行该任务;&lt;/p&gt;&lt;p&gt;(2)缓冲到队列中等待线程执行;&lt;/p&gt;&lt;p&gt;(3)拒绝该任务，执行拒绝策略。&lt;/p&gt;&lt;p&gt;线程管理部分是消费者，它们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务的时候，线程就会被回收。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.2.2 状态变化&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.262532981530343&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFic7dDdDdODHibR3DRemLfcxffVXVq8Hksllc8or1jrqot8UrpfaOaCy0L7ibc6NOLPib7zbXIWL0vNiaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1516&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;ThreadPoolExector内部使用AtomicInteger类型的变量ctl来维护线程池的状态和线程池中的线程数量，即高三位为状态位，其余表示线程数目。&lt;/p&gt;&lt;p&gt;每种状态均可以通过调用不同的方法完成相应的状态转化。&lt;/p&gt;&lt;p&gt;1.  RUNNING(-1 : 111)：可以接受新的任务，也可以处理阻塞队列里的任务。&lt;/p&gt;&lt;p&gt;2.  SHUTDOWN(0 : 000) ：不接受新的任务，但是可以处理阻塞队列里的任务。&lt;/p&gt;&lt;p&gt;3.  STOP(1 : 001)：不接受新的任务，不处理阻塞队列里的任务，中断正在处理的任务。&lt;/p&gt;&lt;p&gt;4.  TIDYING(2 : 010)：过渡状态，也就是说所有的任务都执行完了，当前线程池已经没有有效的线程，这个时候线程池的状态将会TIDYING，并且将要调用terminated方法。&lt;/p&gt;&lt;p&gt;5.  TERMINATED(3: 011) ：终止状态。terminated方法调用完成以后的状态。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.2.3 源码解析-execute&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Execute是提交任务的方法入口方法，根据核心线程池的数量、线程池的状态，任务队列大小、最大数量、分成不同情况，创建不同线程，存储到不同位置，或执行拒绝策略。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6205583756345178&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFic7dDdDdODHibR3DRemLfcxfCCdiaevlpmF7iao9mT08J9RjlIRibiaMQKcdgFgzG8xxGHjEfALYLBgWFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1576&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.2.4 源码解析-addWorker&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;addWorker是添加工作线程的方法，通过Worker内部类封装一个Thread实例维护工作线程的执行，同时根据线程池的状态来判断是否增加相应的任务。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7325728770595691&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFic7dDdDdODHibR3DRemLfcxfkGRA0ZnM9BGAaBjI5e4VicWToYmFFldGGdC7Yp1Viad9vRBN8sQqpsWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1578&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.2.5 源码解析-runWorker&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;runWorker真正执行任务的地方，先执行第一个任务，再源源不断从任务队列中取任务来执行；如果线程池调用了shutDownNow，这里也会收到影响。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.752851711026616&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFic7dDdDdODHibR3DRemLfcxfUmYM9Qls3cAven863SHpSLJqRRwnrbfY6WibTD15IC1EAsj9uo0aicmw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1578&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.2.6 源码解析-getTask&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;从队列取任务的地方，默认情况下，根据工作线程数量与核心数量的关系判断使用队列的poll()还是take()方法，keepAliveTime参数也是在这里使用的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7825537294563844&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFic7dDdDdODHibR3DRemLfcxfCDnqsCI8Zqfxltkia7BTsOjEMibRC4EzUxfUSXPPI6JwR6B2SOdV7bzA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1582&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.2.7任务队列&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;阻塞队列BlockingQueue是用来存放任务的。当线程池中有空闲线程时就回去任务队列中拿任务并处理。&lt;/p&gt;&lt;p&gt;多线程环境中，通过队列可以很容易实现数据共享，比如经典的“生产者”和“消费者”模型中，通过队列可以很便利地实现两者之间的数据共享。&lt;/p&gt;&lt;p&gt;常见的集中队列有：&lt;/p&gt;&lt;p&gt;无界队列: 使用无界队列（如 LinkedBlockingQueue）将所有的任务都存储到阻塞队列中。这样，创建的线程就不会超过 corePoolSize。&lt;/p&gt;&lt;p&gt;有界队列: 当使用有限的 maximumPoolSizes 时，有界队列（如 ArrayBlockingQueue， PriorityBlockingQueue）有助于防止资源耗尽， PriorityBlockingQueue还可以定制任务的优先级。但是需要开发人员根据实际任务情况调整队列大小和线程池大小。&lt;/p&gt;&lt;p&gt;同步移交队列，如果不希望任务在队列中等待而是希望将任务直接移交给工作线程，可使用SynchronousQueue作为等待队列。SynchronousQueue不是一个真正的队列，而是一种线程之间移交的机制。要将一个元素放入SynchronousQueue中，必须有另一个线程正在等待接收这个元素。只有在使用无界线程池或者有饱和策略时才建议使用该队列。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.2.8 拒绝策略&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.19796954314720813&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFic7dDdDdODHibR3DRemLfcxfn56Ie3aGIFypYt1samkvDWuLIVVRlbZkVibHDCkFRQk52x43mraWkdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1576&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;1. CallerRunsPolicy 由调用线程执行该任务，不抛弃任务，会影响效率和性能。&lt;/p&gt;&lt;p&gt;2.  AbortPolicy 抛出拒绝执行的异常，java线程池的默认拒绝策略，保证线程池整体的执行效率。&lt;/p&gt;&lt;p&gt;3.  DiscardPolicy 丢弃该任务，不做任何处理，同时也不抛异常。使用中不太友好。&lt;/p&gt;&lt;p&gt;4.  DiscardOldestPolicy  如果线程池未关闭，则弹出任务队列的第一个，然后运行。&lt;/p&gt;&lt;p&gt;以上是默认提供的四种拒绝策略。除此之外还有一些其他框架中的值得参考的处理。&lt;/p&gt;&lt;p&gt;AbortPolicyWithReport 这是dubbo 中的拒绝策略，继承了AbortPolicy拒绝策略。但是在抛出异常前，打印了当前线程池的重要参数信息，以及运行状态，同时定制输出了此时的堆栈信息。方便后续排查问题处理。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;97617&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;线程池的应用场景&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;Tomcat中的线程池&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;90%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Tomcat作为一款优秀的web服务器，为了保证其性能，其内部也有自己的线程池对象：org.apache.tomcat.util.threads.ThreadPoolExecutor 继承自java.util.concurrent.ThreadPoolExecutor。&lt;/p&gt;&lt;p&gt;不同于原生ThreadPoolExecute达到最大线程后，对新增任务立即执行拒绝策略。Tomcat线程池会在此时再次尝试向队列中添加任务，失败后再执行拒绝策略。最大限度保证任务执行。&lt;/p&gt;&lt;p&gt;同时Tomcat内置了TaskQueue作为任务的缓存队列。继承了LinkedBlockingQueue但是重写了offer方法，即当前线程大于核心线程，且提交的任务数大于当前线程数，表示有线程空闲的情况下，返回false，也就是创建线程。主要是为了控制在线程队列无限增长时，无法创建更多的线程而达到最大线程数的问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;span data-num=&quot;2&quot;&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;Sirector 中的线程池&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;90%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Sirector是JD内一个事件处理编排框架，内置ExecutorService对象，负责对任务的分配处理。&lt;/p&gt;&lt;p&gt;初始化的对象是WorkerExecutor， WorkerExecutor继承自ThreadPoolExecutor，扩展了submit方法用于执行通过sirector编排的具体任务。&lt;/p&gt;&lt;p&gt;WorkerExecutor内置了工厂WorkerThreadFactory主要记录了当前线程池的名称、工厂创建的线程数目等。&lt;/p&gt;&lt;p&gt;使用的拒绝策略为RejectedTaskController，继承自RejectedExecutionHandler，处理方法类似于AbortPolicy策略，丢弃任务抛出异常，抛出异常前也打印了一些异常信息，辅助排查问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;span data-num=&quot;3&quot;&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;个人开发中的线程池&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;90%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;参考上面几种框架的线程池，可以得出大概几点结论。&lt;/p&gt;&lt;p&gt;如果个人开发中涉及线程池，要先确认任务场景，是I/O密集还是CPU密集任务，从而确定线程池类型。&lt;/p&gt;&lt;p&gt;再通过使用场景，是最大限度保证任务执行，还是为了保证服务性能，来定制自己的执行策略，并且确定选择任务队列以及拒绝策略。拒绝策略可以参考Dubbo中，同时打印线程信息，辅助排查问题。&lt;/p&gt;&lt;p&gt;然后确定是否需要自定义线程工厂，这里建议自定义线程工厂，在创建线程的时候打上标识，和系统线程加以区分。&lt;/p&gt;&lt;p&gt;在根据任务类型，配置上合理的线程池参数。一个属于你的线程池就搭好了！&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;97617&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;线程池参数设置&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这里个人认为，没有一种万能的参数一定适合所有的线程池使用场景。&lt;/p&gt;&lt;p&gt;但是有通用的思路来寻找适合当前线程池的最佳参数。&lt;/p&gt;&lt;p&gt;1、确定当前任务类型，是CPU密集还是I/O密集型任务。这两者差别很大。CPU密集和CPU核数以及CPU超线程有关。而I/O密集则和服务处理的任务有很大关联。&lt;/p&gt;&lt;p&gt;2、如果使用一些已有的技术框架中的线程池。初期建议以默认参数为佳，如Tomcat默认范围25-200，JSF默认cached线程池20-200。&lt;/p&gt;&lt;p&gt;3、在服务稳定之后的性能调优。需要对服务进行多次高保真压测，期间不断控制、调整线程池参数，这样尽可能得到当前服务最优的线程池参数。&lt;/p&gt;&lt;p&gt;4、只有最合适的、没有一定不变的，随着业务不断迭代，每隔一段时间对服务进行压测，通过结果调整相应的参数。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;97617&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;线程池使用过程中的建议&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;1 、当提交一个任务到线程池时,若线程数量 &amp;lt; corePoolSize,线程池会创建一个新线程放入workers(一个HashSet)中执行任务, 即使其他空闲的基本线程能够执行新任务也还是会创建新线程，直至达到corePoolSize。&lt;/p&gt;&lt;p&gt;2 、默认最初的线程池启动的时候是不初始化线程的，通过调用 prestartAllCoreThreads 方法，可以初始化所有核心线程。&lt;/p&gt;&lt;p&gt;3 、Worker中处理task如果抛出异常，这个work thread不会继续执行任务，但是会创建新的线程, 新线程可以运行其他task。&lt;/p&gt;&lt;p&gt;4 、最好不要使用Executors创建新线程池，因为Executors提供的很多方法，没有指定实际核心及最大线程池参数，容易发生OOM，推荐自己创建相应的线程池，适合自己的才是最好的，同时线程池中有很多钩子方法可以用来定制特色功能。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5a6fc4abd526674c107758cd7d28801c</guid>
<title>为了解开互联网大厂秋招内幕，我把他们全面了一遍</title>
<link>https://toutiao.io/k/gnyklq3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;八股文：&lt;/strong&gt; 各种面试题题目，主要是一些概念性的知识，比如 &lt;code&gt;jvm&lt;/code&gt; 的运行时数据区的构成、 &lt;code&gt;mysql&lt;/code&gt; 的索引之类的，这些问题的回答一般有固定套路。现在的面试主要就是八股文+算法。我在之后的文章也在总结面试八股文的重点，预计一周内能发出来。面试八股文背的熟是面试成功的必要不充分条件。现在背八股文也是一个潮流，但是我其实不太喜欢这个潮流。大家在平时学习时还是要打好基础，我把平时看到的比较好的计算机基础资料收集在我的公众号里，大家关注 &lt;span&gt;CS指南&lt;/span&gt; ，回复计算机基础就能领取。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;手撕算法&lt;/strong&gt; ：手撕算法简单来说就是完成面试官给你布置的算法题（有些公司提供思路即可）。国内现在的校招面试开始越来越重视算法了，尤其是像字节跳动、腾讯这类大公司。绝大部分公司的校招笔试是有算法题的，如果 AC 率比较低的话，基本就挂掉了。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;常规面试&lt;/strong&gt; ：现在互联网大厂的常规面试大多都采用这种形式，前半小时自我介绍、问项目、背面试八股文，后半小时一道代码题。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;内推&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;：每年的秋招开始以后大家可能会看到大量的内推宣传。但是不同形式的内推差别其实是很大的。如果只是从网上随便找一个内推码，内推人都不认识就把简历投了，这种内推是没用的。有用的内推是，内推者可以直接把你的简历交到筛选简历的部门HR手里，这样HR能快速看到你的简历，并且给你安排面试。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;面试记录&lt;/strong&gt; ：大家进行互联网公司组织的面试，都会留下自己的面试记录。面试记录上会有面试官的面试评语。这个面试记录，是以后面试你的面试官还有 HR 都能看到的。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;预面试&lt;/strong&gt; ：部门收到你的简历后，先不录入公司系统，由 HR 筛选。如果通过简历筛选。部门直接发起预面试，面试通过后，录入系统直接走下面的流程。面试不过，不影响你投这个公司的其它部门，因为公司没有你的面试记录。找预面试的途径是找自己在这个公司的师兄师姐，或者在牛客网上找部门直招的帖子。预面试在部分公司是不合规的。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;主管面&lt;/strong&gt; ：主管面指的是部门的技术主管对你进行面试，走到这一关可以证明大家的技术已经问题不大了。主管面基本上都会采用半问技术，半聊理想的形式对你进行面试。有时候也会问你在校的一些活动经历，甚至会问你毕业论文在做什么。主管面除了考察技术外，一个重要的考察点是考察你是否和团队契合。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;HR 面&lt;/strong&gt; ：HR 面指的就是人力资源对你进行面试。HR 通常第一个问题就是你是哪人，这个问题其实是想看你是不是来公司面试解闷子的。如果你面的是一家北京的公司，而且你是河北人、河南人、山西人等北京周边的城市，你说了你是哪人以后你就不用多说了。但是如果你家是西北那边的，上学又是在东北那嘎达上的，又恰巧你面的是一个广州深圳的公司，你最好说清楚你为啥想去那边工作。另外，HR 会问一些在校经历，通过交流来判断你的性格是否符合团队。对了，还有一个 HR 常问问题，你拿到了哪些 offer？这个问题你就要甩出一些比较硬的 offer 了，因为优质人才谁都想抢。但是你甩出的 offer 要和现在面试的公司是在一个量级上的。不要你面试的是一个小公司，你跟人家说你已经拿到了字节的工牌，你觉得人家相信不相信给了你 offer 你会来？&lt;/p&gt;&lt;p&gt;经过互联网公司秋招词汇扫盲以后，我结合我自己的经历具体介绍下各个大厂的秋招特点，大家拿好小本本。&lt;/p&gt;&lt;h2&gt;常见大厂面试特点&lt;/h2&gt;&lt;p&gt;下面有些公司并没有被介绍，比如某易、某手、某滴等。这些公司并不是我认为他们不是大厂，只是这里面有的公司我没投，有的笔试把我挂了，有的一面把我挂了，具体哪家公司笔试就把我挂了大家可以在评论区无奖竞猜。所以他们是什么特点我也不太清楚。下面列出来的都是我至少面试撑了两个回合以上的，比较清楚他们的特点的。&lt;/p&gt;&lt;h2&gt;百度&lt;/h2&gt;&lt;picture&gt;&lt;img data-ratio=&quot;0.56120826709062&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2Rp8GAOdFfCPhhSwTWlP9aRF5aCa8QDWYtZpefxJPMY2b6B2iaqGpwe1QgogiakZibeFialJNrF7lJdKPVlAH3q7CQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;629&quot;/&gt;&lt;/picture&gt;&lt;p&gt;百度部分部门是会组织预面试的，我在秋招初期 7 月份 就参加过一场，不过一面挂了（尴尬），还好参加的是预面试，没有面试记录。然后我 8 月份 重整旗鼓再战百度，终于找回了场子（自豪）。&lt;/p&gt;&lt;p&gt;另外嘱咐大家的是，面试百度除了尽可能参加预面试外。录入系统的面试也尽量参加部门直招，可以免笔试。&lt;/p&gt;&lt;p&gt;百度的面试形式是常规面试。面试流程中包含三轮技术面（第三轮是主管面）加一轮 HR 面。百度虽然这两年市值败下阵来，但是技术还不错，另外百度算是互联网公司里面加班比较少的。&lt;/p&gt;&lt;h2&gt;阿里&lt;/h2&gt;&lt;picture&gt;&lt;img data-ratio=&quot;0.6517412935323383&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2Rp8GAOdFfCPhhSwTWlP9aRF5aCa8QDWzFNf1uiapqLnVwSLklt3GLU5u74sgpicP8yWBluWt0pAxFicV4ibzR1Qfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;402&quot;/&gt;&lt;/picture&gt;&lt;p&gt;阿里每年的校招名额比较少，校招的时间也比较短，基本上就是 7 月底 开始到 9 月初 就结束了。虽然大家可能看到牛客上满满的都是阿里的内推，但是大部分都是因为面试 KPI 。阿里面试 KPI 比较重，也就是说每给一个部门一个名额，就要求部门收上来针对这个名额的数十倍简历，数量不达标 leader 还要被谈话。所以在投递简历的时候，一定要在内推员工红着眼要简历的情况下保持冷静。另外在准备投简历的时候最好对你要投的部门的秋招名额有个了解，虽然你很难问出来团队预计的 offer 个数，但是你可以问一下给你内推的人的团队有多少人，团队人数的 1/8 到 1/10 大致就是这个团队校招的名额。对了，阿里有些部门也会有预面试，参加预面试是一个不错的学习机会。&lt;/p&gt;&lt;p&gt;参加阿里的校招必须要做笔试。阿里会在每周固定时间组织笔试，你准备好了参加就行，笔试的形式是一个小时两道代码题，一道中等偏难的题，一道困难题。做出一道就能稳进面试，测试样例通过一部分也有进面试的可能。&lt;/p&gt;&lt;p&gt;阿里进入面试后就很少问代码题了，但是对原理性的问题问的比较深，经常会问一些你对技术的思考，比如，你觉得&lt;code&gt;Spring&lt;/code&gt;好在哪？如果答的比较浅的话，通常不能让面试官满意。&lt;/p&gt;&lt;h2&gt;腾讯&lt;/h2&gt;&lt;picture&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2Rp8GAOdFfCPhhSwTWlP9aRF5aCa8QDWBRHzZoKV2TZCgw6lnxbWZBb9oibYeMQAPF6EMwfgqp7f9d9jO6xZngw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;512&quot;/&gt;&lt;/picture&gt;&lt;p&gt;腾讯的笔试一般会组织两场，但是不是必须参加。不参加笔试也能直接开始面试。需要先把简历投在系统里，把简历投在系统里以后，你选择的事业群会优先看到你的简历，但各个事业群都可以看到你的简历并且捞你。&lt;/p&gt;&lt;p&gt;不过，说实话，腾讯对 &lt;code&gt;Java&lt;/code&gt; 程序员不太友好，腾讯内部使用 &lt;code&gt;Java&lt;/code&gt; 还是比较少的，很多新项目都在用 &lt;code&gt;Go&lt;/code&gt;。&lt;/p&gt;&lt;picture&gt;&lt;img data-ratio=&quot;0.9867549668874173&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2Rp8GAOdFfCPhhSwTWlP9aRF5aCa8QDWxgMTzdoTjz7d5Srib7VPBhqZyImDicLibqkOcgcUmeKeoDBrom48em6ibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;453&quot;/&gt;&lt;/picture&gt;&lt;p&gt;并且，腾讯的 KPI 面试比较严重，你的简历指不定被哪个部门捞起来。我面腾讯的经历比较狗血，投了简历没几天以后就直接收到一场面试。腾讯有部门捞你以后，会在微信上用腾讯招聘的公众号向你约面，但并看不到约面的部门，你可以选择接受或拒绝。第一次面试腾讯，自我介绍完，面试官第一个问题就是，你会&lt;code&gt;C++&lt;/code&gt;嘛？呃，我会一点。然后开始全程尬聊，结果可想而知。第二次面试，面试的开头我就问面试官您那边是哪个部门，他说无人驾驶...我当时心里面就许多卧槽，你特么你无人驾驶部门你捞我干啥？然后又是一阵尬聊，结束面试。然后我就不能忍了，主动找到了一个腾讯做&lt;code&gt;容器开发&lt;/code&gt;的部门的面试官，我请求他捞我简历，然后才面的比较顺畅。&lt;/p&gt;&lt;p&gt;腾讯的面试和大多数大厂一样，采用常规面试。技术面有时候两轮，有时候三轮，第三轮是主管加面。然后是 HR 面，HR 面后如果隔几天让你进行&lt;code&gt;云证&lt;/code&gt;，就说明你的 offer 十拿九稳了。&lt;/p&gt;&lt;h2&gt;京东&lt;/h2&gt;&lt;picture&gt;&lt;img data-ratio=&quot;0.5383333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2Rp8GAOdFfCPhhSwTWlP9aRF5aCa8QDWotIviaQMlGd1bd13vSA8F0vRII6glJWpNycQwKByPmMticgd00ia7n9Hg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;/picture&gt;&lt;p&gt;京东的技术面试采用常规面试，并且问的相对简单一些，而且可以部门直招，不需要笔试。技术面试有时候是两轮，有时候是三轮。在京东如果两轮面试以后你直接遇到了 HR 对你面试，你一般就是普通 offer 了。第三轮的主管面会决定是否给你 sp。但是！据我所知，京东 HR 面挂掉的人还挺多的，所以京东的技术面走完以后还不太稳。HR 面完你以后，如果隔一段时间问了你身份证号，并核对你毕业时间后，这就很稳了。我是 HR 面完的当天下午，HR 找我核对的。&lt;/p&gt;&lt;h2&gt;字节跳动&lt;/h2&gt;&lt;picture&gt;&lt;img data-ratio=&quot;0.614&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2Rp8GAOdFfCPhhSwTWlP9aRF5aCa8QDW8X8OomHtfWS2QCWkic0HcM5RfLQcjZfyjHTfqFprFcNeqT96iaJ46LUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;500&quot;/&gt;&lt;/picture&gt;&lt;p&gt;字节的面试有个好处是可以对你反复进行打捞，就是说你面挂一个部门以后，可以马上再转投另一个部门，并且好多部门是不用笔试直接进面试的。我前前后后面了字节三个部门，并且都是第二面，或者三面挂...我有种感觉就是整个 九月 都在跟字节面试官聊天。但最终也没通过字节面试。&lt;/p&gt;&lt;p&gt;字节的面试整体上感觉面试官的侵略性较强，语气相对较凶。对了，不要觉得面试官凶就觉得面试肯定没戏了。我有好几次遇到挺凶的面试官，我和面试官都快吵起来了，但是面完后面试官给了我很好的评价。也在面某手的时候遇见一个笑嘻嘻的面试官，面完后不仅把我挂了，而且我再投别的部门时候简历关都通不过。&lt;/p&gt;&lt;p&gt;字节的面试十分注重代码功底，有时候开始面试就会直接甩给你一道代码题，写出来再谈别的。也会问面试八股文，以及项目。&lt;/p&gt;&lt;h2&gt;美团&lt;/h2&gt;&lt;picture&gt;&lt;img data-ratio=&quot;0.44731977818853974&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2Rp8GAOdFfCPhhSwTWlP9aRF5aCa8QDWpOqTLhDj1HuKI0DJc3ibGiaw3fdq65MaahorzbBFS5ibq69MKIvUvNmZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;541&quot;/&gt;&lt;/picture&gt;&lt;p&gt;美团几乎没有部门直招，都是先把简历投在池子里，然后由部门从池子里进行打捞。内推可以定向推事业群，但是感觉内推作用不太大。美团的面试是五道代码题（我记得应该是，这记忆有些模糊）。做出三道就稳进面试了，做出两道也有可能进面试。&lt;/p&gt;&lt;p&gt;美团的面试是常规面试。美团的技术面有时候两轮，有时候三轮。不过美团只进行两轮技术面就给你 offer，有可能也是 sp，因为我就是~&lt;/p&gt;&lt;h2&gt;拼多多&lt;/h2&gt;&lt;picture&gt;&lt;img data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2Rp8GAOdFfCPhhSwTWlP9aRF5aCa8QDWjmib3ctmptpicGv9qQ6ibHezibP0Rhym5XnmBULe8MWwFGOhiaqwjmpy5fA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;550&quot;/&gt;&lt;/picture&gt;&lt;p&gt;拼多多秋招会有很多轮，拼越计划、提前批、正式批。我当时投的是拼越计划。面试也是常规面试。我当时一面通过，二面代码题写的有点问题，思路有了但是代码一直有个 bug 。面试官就把我调客户端了，又加了一轮面试。对了，客户端这两年各大厂都急缺，面试也相对容易。面 java 的完全可以没有客户端经验，然后转到客户端岗位面试，客户端考核计算机网络会比较多。&lt;/p&gt;&lt;p&gt;拼多多客户端技术面完以后迎来的是 HR 面，但是不知道怎么回事 HR 面没过。这也是我唯一的一场 HR 面没过。另外给大家说明下，拼多多开出的 offer 的薪资几乎是业界最高，但是拼多多是真的累，常态化的一周六天上班时间大部分人是顶不住的。&lt;/p&gt;&lt;h2&gt;华为&lt;/h2&gt;&lt;picture&gt;&lt;img data-ratio=&quot;0.22268907563025211&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2Rp8GAOdFfCPhhSwTWlP9aRF5aCa8QDWMVLC18OwULFzibnFQibcJ7R93xUQLeK9ML73NMGJspPjAXWSaib7hxeHg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;476&quot;/&gt;&lt;/picture&gt;&lt;p&gt;华为对面试者的学校卡的比较严，感觉就是按网上传的那张华为招聘生源表上的学校来的。如果你的学校符合华为的要求，你在投简历阶段会时常接到各个部门的 HR 的电话。在这段时间你会感受到你好像勒布朗詹姆斯一样，受到各个部门的径向追逐。但是你别高兴的太早，在你投到相应部门的简历锁死以后，就轮到你难受了。&lt;/p&gt;&lt;p&gt;华为的笔试是有三道题，第一道题 100 分，第二道题 200 分，第三道题 300 分。只要总得分在 100 分以上就能进面试，但是我建议你最好把前两道题都做出来。在笔试通过后，会迎来面试。第一轮面试会复盘你笔试的时候做的代码，需要你讲代码的解题思路，并且有没有更好的方法等。第一轮面试通过后，相隔半小时左右就可能会迎来第二轮面试，第二轮面试进行的是常规面试。两轮面试都通过以后隔一两天就是主管面。主管面通过后，你会收到一条短信，我记得好像是，恭喜您通过第三轮面试，今天所有的面试已结束。对，华为没有 HR 面。&lt;/p&gt;&lt;p&gt;然后后续的环节就是我不太喜欢的地方了。在你通过所有的面试以后，你会被放在一个很深的人才池里，然后分批给你发 offer。我是 9 月中旬面完，10 月底才给我的 offer，我三方都签完了好吧？甚至我都知道有来年才收到 offer 的。另外，给你 offer 的时候不会和你说任何信息。会请你到公司来，来了以后给你讲你的薪资，然后给你 5 分钟时间考虑，不签就可以走了。&lt;/p&gt;&lt;h2&gt;结语&lt;/h2&gt;&lt;p&gt;通过上面的介绍，大家对于各个互联网公司的秋招流程以及面试特点是不是清楚了许多？&lt;/p&gt;&lt;p&gt;大家有什么问题，欢迎在底下留言提问。另外也可以加我的微信号 &lt;strong&gt;dabai0016&lt;/strong&gt; 进行提问，我下班以后就会回复。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>