<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>ae8a5e84b1099453cbefe17bbbb78ed6</guid>
<title>幸福生活的三大准则｜码农周刊VIP会员专属邮件周报 Vol.084</title>
<link>https://toutiao.io/k/6tbdnkv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p id=&quot;js_tags&quot; class=&quot;article-tag__list single-tag__wrp js_single js_wx_tap_highlight wx_tap_card&quot; data-len=&quot;1&quot; role=&quot;link&quot; aria-labelledby=&quot;js_article-tag-card__left js_a11y_comma js_article-tag-card__right&quot;&gt;
                                            
                                                                                    &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__left&quot; class=&quot;article-tag-card__left&quot;&gt;
                                    &lt;span class=&quot;article-tag-card__title&quot;&gt;收录于话题&lt;/span&gt;
                                    &lt;span class=&quot;article-tag__item-wrp no-active js_tag&quot; data-url=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MjM5MzA0ODkyMA==&amp;amp;action=getalbum&amp;amp;album_id=2218111508427898886#wechat_redirect&quot; data-tag_id=&quot;&quot; data-album_id=&quot;2218111508427898886&quot; data-tag_source=&quot;1&quot;&gt;
                                        &lt;span class=&quot;article-tag__item&quot;&gt;#码农周刊&lt;/span&gt;
                                    &lt;/span&gt;
                                &lt;/span&gt;
                                &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__right&quot; class=&quot;article-tag-card__right&quot;&gt;9个&lt;/span&gt;
                                                                                        &lt;/p&gt;

                
                                
                
                

                
                                                                

                
                                


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;以下内容节选自「码农周刊VIP会员专属邮件周报 Vol.084」，查看完整链接版请微信扫描下方二维码，加入「码农周刊VIP会员」。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5493333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavicibroqCN98y5SNT9NbfA3oHYQiaicFScHFfppgek7ZGicJiaHK45qc2zoccBibfEzIvzTsI4AB2xO2IaOw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本期，首先分享的是&lt;strong&gt;查理·芒格幸福生活的三大准则&lt;/strong&gt;，供参考。&lt;br/&gt;1）&lt;strong&gt;降低期望值&lt;/strong&gt;；&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; 2）遇到挫折时，&lt;strong&gt;诚实面对并处理好&lt;/strong&gt;；&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; 3）&lt;strong&gt;说实话&lt;/strong&gt;，尤其是对自己。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;325&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavibHVJLA1Veb2tAXpnl02QjBibx9jXswWvKtM0RibSXRzPHGqwibAj3N2CxMQstlfzjONXS2swoianPvSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;叶军：我在阿里巴巴做 “CIO” 的日子&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://mp.weixin.qq.com/s/vqnP0jHNOYiZSAjQZnYiJw&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;阿里巴巴如何跨越从信息化（IT）到数字化（DT）转型的关键时刻？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Foresight Ventures: Crypto 思潮编年史（1997 - 2022）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://mp.weixin.qq.com/s/mtpUympekLcCQRddylJzSw&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以时间顺序重新回顾在 Crypto 发展史中那些重要的 “故事”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;微信全文搜索技术优化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://toutiao.io/k/fvhw2yp&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;全面升级经验&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;设计模式二三事&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://toutiao.io/k/xxsl3zv&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;讲解几类常用设计模式的应用&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;腾讯开源的云原生多运行时微服务框架&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://github.com/polarismesh/femas/blob/develop/README-zh.md&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;聚焦微服务运行时，提供给多框架统一服务发现、南北及东西流量治理、服务可观测、配置管理等一站式微服务管控能力，解决企业微服务架构转型中异构框架复用难、激增流量管控难、排障恢复耗时长等核心问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;京东开源的轻量级移动端 Vue2、Vue3 组件库&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://github.com/jdf2e/nutui&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;支持一套代码生成 H5 和小程序&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Android 13 第一个开发者预览版本来了&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://toutiao.io/k/6mcniy8&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;网友直呼：Android 12 还没透&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Go官方 - 1.18 发布说明&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://toutiao.io/k/vxpgeo7&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;正在进行中的发布说明&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2022年最值得关注的Chrome浏览器扩展插件&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://toutiao.io/k/lz60fko&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实用&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;程序员必备的几种常见排序算法和搜索算法总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://toutiao.io/k/j230wfq&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;供参考&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;查看完整链接版请微信扫描下方二维码，加入「码农周刊VIP会员」。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5493333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavicibroqCN98y5SNT9NbfA3oHYQiaicFScHFfppgek7ZGicJiaHK45qc2zoccBibfEzIvzTsI4AB2xO2IaOw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4f83f8a5a28225c34fa2feee22334e31</guid>
<title>[推荐] 架构师如何选型分布式业务网关</title>
<link>https://toutiao.io/k/enmg99d</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在日常工作中，不同的场合下，我们可能都会听说网关的概念，当然通常是指业务网关（API网关），负责API的输入和输出。有了业务网关之后，各个API服务提供者可以专注于自己的业务逻辑处理，而API网关更专注于安全、流量、路由等问题。从功能层次我们又会联想到一个概念——代理。网关与代理的区别：代理本质是数据的透传，协议不会发生变化；网关在数据透传的背景下，还会涉及协议的转换，比如从HTTP到Dubbo。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;那么作为一名架构师，我们该如何选型“业务网关”呢？我们自己先要学会做技术选型，自己预期有一个技术成本的预判，比如我推荐使用Spring Cloud Alibaba+Spring Gateway，就是我自己作为一个架构师的技术预判。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Zuul&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Zuul是Netflix开源的微服务网关，可以和Eureka、Ribbon、Hystrix等组件配合使用，Spring Cloud对Zuul进行了整合与增强，Zuul总共有两个大的版本：Zuul1.0和Zuul2.0，目前最新的版本为v2.2.0，Zuul1.0和Zuul2.0版本之间功能差异性非常大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Netflix的Zuul包含如下功能：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;身份认证与安全：&lt;/span&gt;&lt;span&gt;识别每个资源的验证要求，并拒绝那些与要求不符的请求；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;审查与监控：在边缘位置追踪有意义的数据和统计结果；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;动态路由：&lt;/span&gt;&lt;span&gt;动态地将请求路由到不同的后端集群；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;压力测试&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;逐渐增加指向集群的流量，以了解性能；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;负载分配：&lt;/span&gt;&lt;span&gt;为每一种负载类型分配对应容量&lt;/span&gt;&lt;span&gt;，并弃用超出限定值的请求&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;静态响应处理：在边缘位置直接建立部分响应，从而避免其转发到内部集群；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;多区域弹性：&lt;/span&gt;&lt;span&gt;跨越AWS &lt;/span&gt;&lt;span&gt;Region进行请求路由，旨在实现ELB（Elastic Load Balancing）使用的多样化和&lt;/span&gt;&lt;span&gt;以及让系统的边缘更贴近系统的使用者。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;以上介绍来自Zuul官方文档，但其实开源版本的Zuul以上功能一个都没有——开源的Zuul只是几个Jar包而已，以上能力指的应该是Netflix官方自用的Zuul的能力；Netflix自用的Zuul能力是比较强大的，可使用Groovy编写过滤器，并且可动态加载/卸载、修改规则，而且使用Cassandra作为数据库，然而开源版本这些一个都没有；Spring Cloud中，Zuul绝大部分功能都是Spring Cloud团队为Zuul开发的；所以Zuul 2.x的开源进度延后一年，Spring Cloud团队开发了自己的SCG，并宣布Spring Cloud不打算支持Zuul 2.x，你还觉得意外吗？看到这里，很多人可能没有动力学习Zuul了，个人认为还是可以了解一下的，后面讲到SCG时，你会发现很多设计理念是相通的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;span&gt;既然说到了Spring Cloud对Zuul的封装，那么我们来简单的分析下Spring Cloud与Zuul的关系。Spring Cloud通过Spring Cloud Netflix 1.X来封装Zuul1.0，1.X的最后一个版本是v1.4.7.RELEASE，对应的Zuul版本是1.3.1。Spring Cloud Netflix从3.X开始就没有封装Zuul网关，包括Zuul1.0和Zuul2.0，也就是说开发者想要通过Spring Cloud来复用Zuul，只能使用Zuul1.0，暂时不能复用Zuul2.0。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Zuul目前在github上的star数为10.2k，fork数为2k，也就是说还是有很多开源爱好者会基于Zuul来定制化业务网关。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了开源的Spring Cloud定制化Zuul，开源微服务框架jhipster也参与了定制，并集成到它的生态中。Jhipster主要包含generator-jhipster和jhipster-registry，前者star数微17.7k，fork数为3.5k，后者star数为604，fork为607。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Zuul1.0整体架构设计如图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7104377104377104&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Eb8TPxx4xwyWT6MTWtPib6eKFUI9D02lCqb1SicPrjI8bzZZFdZz2t6USvVP17Akn6veAmiaBvmanamgadXJSjsZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;594&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Zuul2.0整体架构设计如图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6771929824561403&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Eb8TPxx4xwyWT6MTWtPib6eKFUI9D02lC4HskII7icXnrOakI3f1qYqrpW5vsvjfUT2LYRXWPIaCvxkFCoctliaIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;570&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Spring Cloud Gateway&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;SCG是基于Spring Framework 5.0和Spring Boot 2.0构建的API网关，提供路由等功能。其旨在提供一种简单而有效的方法路由到API，并为它们提供跨领域的关注点，例如：安全性、监视/指标和弹性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主要特性：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;J&lt;/span&gt;&lt;span&gt;ava8&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Spring Framework5&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Spring Boot2&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;动态路由&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Spring Handler Mapping&lt;/span&gt;&lt;span&gt;内置的路由匹配&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;HTTP&lt;/span&gt;&lt;span&gt;请求的路由匹配（路径、方法、&lt;/span&gt;&lt;span&gt;Hea&lt;/span&gt;&lt;span&gt;der&lt;/span&gt;&lt;span&gt;、主机等）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;过滤器限定范围以匹配路由&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;过滤器可以修改下游&lt;/span&gt;&lt;span&gt;HTTP&lt;/span&gt;&lt;span&gt;请求和&lt;/span&gt;&lt;span&gt;HTTP&lt;/span&gt;&lt;span&gt;响应（添加、删除&lt;/span&gt;&lt;span&gt;Header&lt;/span&gt;&lt;span&gt;、添加&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;删除参数、重写路径、设置路径等）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;API或配置驱动&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持Spring Cloud Discovery Client配置路由&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;SCG的专业术语包括：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;路由：它是基本构建模块，主要包含ID、URI、断言集合以及过滤器集合，如果能够匹配断言就会执行路由；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;断言：&lt;/span&gt;&lt;span&gt;主要是指Java8的函数式断言，输入类型是Spring Framework的ServerWebExchange，基于断言可以匹配基于headers或者parameters的http请求；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;过滤器：&lt;/span&gt;&lt;span&gt;它是通过特殊的工厂方法构造的基于Spring Framework GatewayFilter的实现，通过过滤器开发者可以在http请求下行之前修改请求响应参数，在请求响应返回之后可以修改响应的结果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;SCG整体架构设计如图所示。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7508896797153025&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Eb8TPxx4xwyWT6MTWtPib6eKFUI9D02lCM4JFeJpgVrodhL3nEt9ibS4l0C0ibwoKp5BgbAAMhWiakpSlzaQKneq2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;562&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;自研网关&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个API网关的基本功能包括统一接入、协议适配、流量管控与容错，以及安全防护，这个四大基本功能构成了网关的核心能力。网关首要的功能是负责统一接入，然后将请求的协议转换成内部的接口协议，在调用的过程中还要限流、降级和熔断等容错的方式来保护网关的整体稳定，同时网关还要做到基本的安全防护（防刷控制），以及黑白名单（比如IP地址白名单）等基本的安全措施，主要包括：统一标准接入，具备高性能、高并发和高可靠性，具备负载均衡的能力；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5185185185185185&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Eb8TPxx4xwyWT6MTWtPib6eKFUI9D02lCKumL0Y3CqMic3uclBq11OK1SLz0nbSyibVYOfVuYq5t2Z28bhkx8Odew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;486&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了基本的四个功能，网关运行良好的环境还包括注册中心（比如通过Nacos读取已经发布的API接口的动态配置）。为了实现高性能，将数据全部异构到缓存（比如Redis）中，同时还可以配合本机缓存来进一步的提高网关系统的性能。为了提高网关的吞吐率，可以使用NIO+Servlet3异步的方式，还可以利用Servlet3的异步特性将请求线程与业务处理线程分开，为后续的线程池隔离做好基本的支撑。访问日志的存储我们可以放到Hbase或者ES中，如果要作为开放网关使用，那么需要一个支持OAuth2.0协议的授权中心，同时还可以引入Nginx+Lua的方式，将一些基本的校验判断前置到应用系统之上，这样可以更加轻量级的处理网关接入的问题。&lt;/span&gt;&lt;span/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7288135593220338&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Eb8TPxx4xwyWT6MTWtPib6eKFUI9D02lC95FriaJKLRcKeuhXcBrfGIfbbeJtI05ic4Tx5VmzqcfRHfty44O5iaL8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;590&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主要包括接入层，开发者可以通过Nginx和Lua脚本，解决限流、黑白名单、路由、负载均衡、长短连接以及容灾切换的问题。网关需要保证服务的稳定性，需要接入注册中心，因为本书是Spring Cloud Alibaba的布道书籍，所以强烈推荐使用Nacos作为注册中心和配置中心。统一的鉴权中心，主要是统一解决网关为各个API服务的鉴权问题，当然可以按照服务维度做隔离，自定义鉴权规则。统一用户中心主要是解决用户登录问题，确保微服务调用的安全性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;自研网关还需要有泛化功能，使用者在调用提供者的接口的时候，不再需要API提供者的客户端JAR包，因此也就没有了POJO，通过泛化的方式进行远程调用。一般情况下我们要通过RPC调用接口提供方的服务，首先在系统中嵌入接口提供者的JAR包，然后使用JAR包里面的类和方法。对于一个网关系统来说，如果要调用N个接口，就需要N个JAR包，这样的网关是很难维护的，当然Dubbo RPC是支持泛化的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;网关要具备时间校验、方法校验、版本校验和签名校验等功能，当然网关还需要具备服务降级、日志记录以及监控与告警功能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;对比以上三种网关&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;网关&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;限流&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;鉴权&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;监控&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;易用性&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;可维护性&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;成熟度&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;SCG&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;可以通过IP，用户，集群限流，提供了相应的接口进行扩展&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;普通鉴权auth2.0&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;Gateway Metrics Filter&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;简单易用&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;Spring系列可扩展强，易配置和可维护性好&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;Spring社区成熟，但Gateway资源少。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;Zuul2&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;可以通过配置文件配置集群限流和单服务器限流，也可以通过filter实现限流扩展&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;filter中实现&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;Filter中实现&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;参考资料比较少&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;可维护性差&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;开源不就资源少。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;Zuul1&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;同上&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;同上&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;同上&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;同上&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;同上&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;同上&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;自研网关&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;需要开发&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;需要开发&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;需要开发&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;需要开发&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;可维护性极高&lt;/span&gt;&lt;span lang=&quot;ZH-CN&quot;&gt;&lt;span/&gt;&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;需要开发&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;推荐使用Spring Cloud Alibaba+Spring Cloud Gateway，可以更加高效的利用Spring Cloud ALibaba的服务治理能力去融合网关API的治理，从而提升业务服务API的系统稳定性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>602dd2835c93d4a13e54f86265982787</guid>
<title>[推荐] 2万字 + 50 张图，细说 JVM 内存分布、内存对齐、压缩指针！</title>
<link>https://toutiao.io/k/02whm5c</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.75&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/J0g14CUwaZdwkxf9KpduegYClib9mbvJlw6YSlyXwar1e8wLuxcWPUmRpNOU9tZwdaLPx85rf14z0uXBLsaeASw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天为大家带来一篇 2 万字的硬核技术文章。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3618421052631579&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeaKYVicAZVk1VAnhiamA41gT2ojtuPGEJjia3kBwibBnsR9zTsFUWjwGWQvhAYSI5MhM59te7XE8Kadg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;304&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文我们将从计算机组成原理的角度详细阐述对象在JVM内存中是如何布局的，以及什么是内存对齐，如果我们头比较铁，就是不进行内存对齐会造成什么样的后果，最后引出压缩指针的原理和应用。同时我们还介绍了在高并发场景下，False Sharing产生的原因以及带来的性能影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信大家看完本文后，一定会收获很多，话不多说，下面我们正式开始本文的内容~~&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2274193548387098&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3ricXgeszzmZ697l6f7qkJF65XDsfCVIyhTiagCtzNVc0qj75ULcmE8GWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;本文概要.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们的日常工作中，有时候我们为了防止线上应用发生&lt;code&gt;OOM&lt;/code&gt;，所以我们需要在开发的过程中计算一些核心对象在内存中的占用大小，目的是为了更好的了解我们的应用程序内存占用的一个大概情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进而根据我们服务器的内存资源限制以及预估的对象创建数量级计算出应用程序占用内存的高低水位线，如果内存占用量超过&lt;code&gt;高水位线&lt;/code&gt;，那么就有可能有发生&lt;code&gt;OOM&lt;/code&gt;的风险。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以在程序中根据估算出的&lt;code&gt;高低水位线&lt;/code&gt;，做一些防止&lt;code&gt;OOM&lt;/code&gt;的处理逻辑或者发出告警。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;那么核心问题是如何计算一个Java对象在内存中的占用大小呢？？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在为大家解答这个问题之前，笔者先来介绍下Java对象在内存中的布局，也就是本文的主题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. Java对象的内存布局&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5758064516129032&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3r3I5lLLo8slEicxFgVfFAdGqDVOBdRPgVkduFxd2BEe6LplnF30pr72A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;Java对象的内存布局.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图所示，Java对象在JVM中是用&lt;code&gt;instanceOopDesc &lt;/code&gt;结构表示而Java对象在JVM堆中的内存布局可以分为三部分：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1 对象头（Header）&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个Java对象都包含一个对象头，对象头中包含了两类信息：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;MarkWord&lt;/code&gt;：在JVM中用&lt;code&gt;markOopDesc &lt;/code&gt;结构表示用于存储对象自身运行时的数据。比如：hashcode，GC分代年龄，锁状态标志，线程持有的锁，偏向线程Id，偏向时间戳等。在32位操作系统和64位操作系统中&lt;code&gt;MarkWord&lt;/code&gt;分别占用4B和8B大小的内存。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;类型指针&lt;/code&gt;：JVM中的类型指针封装在&lt;code&gt;klassOopDesc &lt;/code&gt;结构中，类型指针指向了&lt;code&gt;InstanceKclass对象&lt;/code&gt;，Java类在JVM中是用InstanceKclass对象封装的，里边包含了Java类的元信息，比如：继承结构，方法，静态变量，构造函数等。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在不开启指针压缩的情况下(-XX:-UseCompressedOops)。在32位操作系统和64位操作系统中类型指针分别占用4B和8B大小的内存。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在开启指针压缩的情况下(-XX:+UseCompressedOops)。在32位操作系统和64位操作系统中类型指针分别占用4B和4B大小的内存。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果Java对象是一个数组类型的话，那么在数组对象的对象头中还会包含一个4B大小的用于记录数组长度的属性。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;由于在对象头中用于记录数组长度大小的属性只占4B的内存，所以Java数组可以申请的最大长度为：&lt;code&gt;2^32&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2 实例数据（Instance Data)&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java对象在内存中的实例数据区用来存储Java类中定义的实例字段，包括所有父类中的实例字段。也就是说，虽然子类无法访问父类的私有实例字段，或者子类的实例字段隐藏了父类的同名实例字段，但是子类的实例还是会为这些父类实例字段分配内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java对象中的字段类型分为两大类：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;基础类型：Java类中实例字段定义的基础类型在实例数据区的内存占用如下：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;long | double占用8个字节。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;int | float占用4个字节。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;short | char占用2个字节。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;byte | boolean占用1个字节。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;引用类型：Java类中实例字段的引用类型在实例数据区内存占用分为两种情况：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;不开启指针压缩(-XX:-UseCompressedOops)：在32位操作系统中引用类型的内存占用为4个字节。在64位操作系统中引用类型的内存占用为8个字节。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;开启指针压缩(-XX:+UseCompressedOops)：在64为操作系统下，引用类型内存占用则变为为4个字节，32位操作系统中引用类型的内存占用继续为4个字节。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;为什么32位操作系统的引用类型占4个字节，而64位操作系统引用类型占8字节？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Java中，引用类型所保存的是被引用对象的内存地址。在32位操作系统中内存地址是由32个bit表示，因此需要4个字节来记录内存地址，能够记录的虚拟地址空间是2^32大小，也就是只能够表示4G大小的内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在64位操作系统中内存地址是由64个bit表示，因此需要8个字节来记录内存地址，&lt;strong&gt;但在 64 位系统里只使用了低 48 位，所以它的虚拟地址空间是 2^48大小，能够表示256T大小的内存&lt;/strong&gt;，其中低 128T 的空间划分为用户空间，高 128T 划分为内核空间，可以说是非常大了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们从整体上介绍完Java对象在JVM中的内存布局之后，下面我们来看下Java对象中定义的这些实例字段在实例数据区是如何排列布局的：&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 字段重排列&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实我们在编写Java源代码文件的时候定义的那些实例字段的顺序会被JVM重新分配排列，这样做的目的其实是为了内存对齐，那么什么是内存对齐，为什么要进行内存对齐，笔者会随着文章深入的解读为大家逐层揭晓答案~~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本小节中，笔者先来为大家介绍一下JVM字段重排列的规则:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JVM重新分配字段的排列顺序受&lt;code&gt;-XX:FieldsAllocationStyle&lt;/code&gt;参数的影响，默认值为&lt;code&gt;1&lt;/code&gt;，实例字段的重新分配策略遵循以下规则：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果一个字段占用&lt;code&gt;X&lt;/code&gt;个字节，那么这个字段的偏移量&lt;code&gt;OFFSET&lt;/code&gt;需要对齐至&lt;code&gt;NX&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;偏移量是指字段的内存地址与Java对象的起始内存地址之间的差值。比如long类型的字段，它内存占用8个字节，那么它的OFFSET应该是8的倍数8N。不足8N的需要填充字节。&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在开启了压缩指针的64位JVM中，Java类中的第一个字段的OFFSET需要对齐至4N，在关闭压缩指针的情况下类中第一个字段的OFFSET需要对齐至8N。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;JVM默认分配字段的顺序为：long / double，int / float，short / char，byte / boolean，oops(Ordianry Object Point 引用类型指针)，&lt;strong&gt;并且父类中定义的实例变量会出现在子类实例变量之前&lt;/strong&gt;。当设置JVM参数&lt;code&gt;-XX +CompactFields &lt;/code&gt;时（默认），占用内存小于long / double 的字段会允许被插入到对象中第一个 long / double字段之前的间隙中，以避免不必要的内存填充。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;CompactFields选项参数在JDK14中以被标记为过期了，并在将来的版本中很可能被删除。详细细节可查看issue：https://bugs.openjdk.java.net/browse/JDK-8228750&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上边的三条字段重排列规则非常非常重要，但是读起来比较绕脑，很抽象不容易理解，笔者把它们先列出来的目的是为了让大家先有一个朦朦胧胧的感性认识，下面笔者举一个具体的例子来为大家详细说明下，在阅读这个例子的过程中也方便大家深刻的理解这三条重要的字段重排列规则。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设现在我们有这样一个类定义&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Parent&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; l;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Child&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Parent&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; l;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;根据上面介绍的&lt;code&gt;规则3&lt;/code&gt;我们知道父类中的变量是出现在子类变量之前的，并且字段分配顺序应该是long型字段l，应该在int型字段i之前。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如果JVM开启了&lt;code&gt;-XX +CompactFields&lt;/code&gt;时，int型字段是可以插入对象中的第一个long型字段（也就是Parent.l字段）之前的空隙中的。如果JVM设置了&lt;code&gt;-XX -CompactFields&lt;/code&gt;则int型字段的这种插入行为是不被允许的。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;根据&lt;code&gt;规则1&lt;/code&gt;我们知道long型字段在实例数据区的OFFSET需要对齐至8N，而int型字段的OFFSET需要对齐至4N。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;根据&lt;code&gt;规则2&lt;/code&gt;我们知道如果开启压缩指针&lt;code&gt;-XX:+UseCompressedOops&lt;/code&gt;，Child对象的第一个字段的OFFSET需要对齐至4N，关闭压缩指针时&lt;code&gt;-XX:-UseCompressedOops&lt;/code&gt;，Child对象的第一个字段的OFFSET需要对齐至8N。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于JVM参数&lt;code&gt;UseCompressedOops &lt;/code&gt;和&lt;code&gt;CompactFields &lt;/code&gt;的存在，导致Child对象在实例数据区字段的排列顺序分为四种情况，下面我们结合前边提炼出的这三点规则来看下字段排列顺序在这四种情况下的表现。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 -XX:+UseCompressedOops  -XX -CompactFields 开启压缩指针，关闭字段压缩&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23629032258064517&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rTn3QqBMZRFMoibE8Z73erHr9SbSXMZXXCUL9yztHqeZSueFdOxQMugA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;偏移量OFFSET = 8的位置存放的是类型指针，由于开启了压缩指针所以占用4个字节。对象头总共占用12个字节：MarkWord(8字节) + 类型指针(4字节)。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;根据&lt;code&gt;规则3：&lt;/code&gt;父类Parent中的字段是要出现在子类Child的字段之前的并且long型字段在int型字段之前。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;根据规则2：&lt;/code&gt;在开启压缩指针的情况下，Child对象中的第一个字段需要对齐至4N。这里Parent.l字段的OFFSET可以是12也可以是16。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;根据规则1：&lt;/code&gt;long型字段在实例数据区的OFFSET需要对齐至8N，所以这里Parent.l字段的OFFSET只能是16，因此OFFSET = 12的位置就需要被填充。Child.l字段只能在OFFSET = 32处存储，不能够使用OFFSET = 28位置，因为28的位置不是8的倍数无法对齐8N，因此OFFSET = 28的位置被填充了4个字节。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;规则1也规定了int型字段的OFFSET需要对齐至4N，所以Parent.i与Child.i分别存储以OFFSET = 24和OFFSET = 40的位置。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;因为JVM中的内存对齐除了存在于字段与字段之间还存在于对象与对象之间，Java对象之间的内存地址需要对齐至8N&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以Child对象的末尾处被填充了4个字节，对象大小由开始的44字节被填充到48字节。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2  -XX:+UseCompressedOops  -XX +CompactFields 开启压缩指针，开启字段压缩&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1814516129032258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rDUgEBKWWc9ahzQR8rqV39GoH6b2dbub8ViaiaCt5WE5n3pIOsaxFSFbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在第一种情况的分析基础上，我们开启了&lt;code&gt;-XX +CompactFields&lt;/code&gt;压缩字段，所以导致int型的Parent.i字段可以插入到OFFSET = 12的位置处，以避免不必要的字节填充。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;根据&lt;code&gt;规则2：&lt;/code&gt;Child对象的第一个字段需要对齐至4N，这里我们看到&lt;code&gt;int型&lt;/code&gt;的Parent.i字段是符合这个规则的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;根据&lt;code&gt;规则1：&lt;/code&gt;Child对象的所有long型字段都对齐至8N，所有的int型字段都对齐至4N。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终得到Child对象大小为36字节，由于Java对象与对象之间的内存地址需要对齐至8N，所以最后Child对象的末尾又被填充了4个字节最终变为40字节。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里我们可以看到在开启字段压缩&lt;code&gt;-XX +CompactFields&lt;/code&gt;的情况下，Child对象的大小由48字节变成了40字节。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3 -XX:-UseCompressedOops  -XX -CompactFields 关闭压缩指针，关闭字段压缩&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23306451612903226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rUIwxgUGicbCZ6bkcIT0gnpMSRAm1Ky5MmEkcCticjCaialUgZBqUuxRcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先在关闭压缩指针&lt;code&gt;-UseCompressedOops&lt;/code&gt;的情况下，对象头中的类型指针占用字节变成了8字节。导致对象头的大小在这种情况下变为了16字节。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;根据&lt;code&gt;规则1：&lt;/code&gt;long型的变量OFFSET需要对齐至8N。根据&lt;code&gt;规则2：&lt;/code&gt;在关闭压缩指针的情况下，Child对象的第一个字段Parent.l需要对齐至8N。所以这里的Parent.l字段的OFFSET  = 16。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;由于long型的变量OFFSET需要对齐至8N，所以Child.l字段的OFFSET
需要是32，因此OFFSET = 28的位置被填充了4个字节。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样计算出来的Child对象大小为44字节，但是考虑到Java对象与对象的内存地址需要对齐至8N，于是又在对象末尾处填充了4个字节，最终Child对象的内存占用为48字节。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.4  -XX:-UseCompressedOops  -XX +CompactFields 关闭压缩指针，开启字段压缩&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在第三种情况的分析基础上，我们来看下第四种情况的字段排列情况：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2153225806451613&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rkd3BpQQERqordT5gAdsgiaicyvIqEr9rFyFZmw1MqJjU29eaesHScn8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于在关闭指针压缩的情况下类型指针的大小变为了8个字节，所以导致Child对象中第一个字段Parent.l前边并没有空隙，刚好对齐8N，并不需要int型变量的插入。所以即使开启了字段压缩&lt;code&gt;-XX +CompactFields&lt;/code&gt;，字段的总体排列顺序还是不变的。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;默认情况下指针压缩&lt;code&gt;-XX:+UseCompressedOops&lt;/code&gt;以及字段压缩&lt;code&gt;-XX +CompactFields&lt;/code&gt;都是开启的&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 对齐填充（Padding)&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前一小节关于实例数据区字段重排列的介绍中为了内存对齐而导致的字节填充不仅会出现在字段与字段之间，还会出现在对象与对象之间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边我们介绍了字段重排列需要遵循的三个重要规则，其中规则1，规则2定义了字段与字段之间的内存对齐规则。规则3定义的是对象字段之间的排列规则。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了内存对齐的需要，对象头与字段之间，以及字段与字段之间需要填充一些不必要的字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如前边提到的字段重排列的第一种情况&lt;code&gt;-XX:+UseCompressedOops -XX -CompactFields&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23629032258064517&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rTn3QqBMZRFMoibE8Z73erHr9SbSXMZXXCUL9yztHqeZSueFdOxQMugA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而以上提到的四种情况都会在对象实例数据区的后边在填充4字节大小的空间，原因是除了需要满足字段与字段之间的内存对齐之外，还需要满足对象与对象之间的内存对齐。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 虚拟机堆中对象之间的内存地址需要对齐至8N（8的倍数），如果一个对象占用内存不到8N个字节，那么就必须在对象后填充一些不必要的字节对齐至8N个字节。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;虚拟机中内存对齐的选项为&lt;code&gt;-XX:ObjectAlignmentInBytes&lt;/code&gt;，默认为8。也就是说对象与对象之间的内存地址需要对齐至多少倍，是由这个JVM参数控制的。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还是以上边第一种情况为例说明：图中对象实际占用是44个字节，但是不是8的倍数，那么就需要再填充4个字节，内存对齐至48个字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上这些为了内存对齐的目的而在字段与字段之间，对象与对象之间填充的不必要字节，我们就称之为&lt;code&gt;对齐填充（Padding）&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. 对齐填充的应用&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们知道了对齐填充的概念之后，大家可能好奇了，为啥我们要进行对齐填充，是要解决什么问题吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么就让我们带着这个问题，来接着听笔者往下聊~~&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.1 解决伪共享问题带来的对齐填充&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了以上介绍的两种对齐填充的场景（字段与字段之间，对象与对象之间），在JAVA中还有一种对齐填充的场景，那就是通过对齐填充的方式来解决&lt;code&gt;False Sharing（伪共享）&lt;/code&gt;的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在介绍False Sharing（伪共享）之前，笔者先来介绍下CPU读取内存中数据的方式。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.1.1 CPU缓存&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据摩尔定律：芯片中的晶体管数量每隔&lt;code&gt;18&lt;/code&gt;个月就会翻一番。导致CPU的性能和处理速度变得越来越快，而提升CPU的运行速度比提升内存的运行速度要容易和便宜的多，所以就导致了CPU与内存之间的速度差距越来越大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了弥补CPU与内存之间巨大的速度差异，提高CPU的处理效率和吞吐，于是人们引入了&lt;code&gt;L1,L2,L3&lt;/code&gt;高速缓存集成到CPU中。当然还有&lt;code&gt;L0&lt;/code&gt;也就是寄存器，寄存器离CPU最近，访问速度也最快，基本没有时延。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6556451612903226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3ruGeiaJSUicRiboqYgiaAWqhLFI8lDanK1q52jytoe5w9xibl51u246UUmWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;CPU缓存结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个CPU里面包含多个核心，我们在购买电脑的时候经常会看到这样的处理器配置，比如&lt;code&gt;4核8线程&lt;/code&gt;。意思是这个CPU包含4个物理核心8个逻辑核心。4个物理核心表示在同一时间可以允许4个线程并行执行，8个逻辑核心表示处理器利用&lt;code&gt;超线程的技术&lt;/code&gt;将一个物理核心模拟出了两个逻辑核心，一个物理核心在同一时间只会执行一个线程，而&lt;code&gt;超线程芯片&lt;/code&gt;可以做到线程之间快速切换，当一个线程在访问内存的空隙，超线程芯片可以马上切换去执行另外一个线程。因为切换速度非常快，所以在效果上看到是8个线程在同时执行。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;图中的CPU核心指的是物理核心。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图中我们可以看到L1Cache是离CPU核心最近的高速缓存，紧接着就是L2Cache，L3Cache，内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;离CPU核心越近的缓存访问速度也越快，造价也就越高，当然容量也就越小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中L1Cache和L2Cache是CPU物理核心私有的（&lt;strong&gt;注意：这里是物理核心不是逻辑核心&lt;/strong&gt;）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而L3Cache是整个CPU所有物理核心共享的。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;CPU逻辑核心共享其所属物理核心的L1Cache和L2Cache&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;L1Cache&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;L1Cache离CPU是最近的，它的访问速度最快，容量也最小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图中我们看到L1Cache分为两个部分，分别是：Data Cache和Instruction Cache。它们一个是存储数据的，一个是存储代码指令的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以通过&lt;code&gt;cd /sys/devices/system/cpu/&lt;/code&gt;来查看linux机器上的CPU信息。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.10483870967741936&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rQDoCpOjBGDjIRQFgYz5PpQvR7WjNkM34wibLLreU7cjhnicMyicyynTow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;/sys/devices/system/cpu/&lt;/code&gt;目录里，我们可以看到CPU的核心数，&lt;strong&gt;当然这里指的是逻辑核心&lt;/strong&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;笔者机器上的处理器并没有使用超线程技术所以这里其实是4个物理核心。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们进入其中一颗CPU核心（cpu0）中去看下L1Cache的情况：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CPU缓存的情况在&lt;code&gt;/sys/devices/system/cpu/cpu0/cache&lt;/code&gt;目录下查看：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.07231920199501247&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rdBic5LNCpCTfiacvTic6bE1vnpvQS8QtdA3okiaNE4BibjicFv6RTgw8IxdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;802&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;index0&lt;/code&gt;描述的是L1Cache中DataCache的情况：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1774193548387097&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3r5Ztzic9ubE7Yao8kwqDNrE4Th9yFMGbjp02EgsDmWdP5D5NRTDRnz6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;level&lt;/code&gt;：表示该cache信息属于哪一级，1表示L1Cache。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;type&lt;/code&gt;：表示属于L1Cache的DataCache。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;size&lt;/code&gt;：表示DataCache的大小为32K。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;shared_cpu_list&lt;/code&gt;：之前我们提到L1Cache和L2Cache是CPU物理核所私有的，而由物理核模拟出来的逻辑核是&lt;strong&gt;共享L1Cache和L2Cache的&lt;/strong&gt;，&lt;code&gt;/sys/devices/system/cpu/&lt;/code&gt;目录下描述的信息是逻辑核。shared_cpu_list描述的正是哪些逻辑核共享这个物理核。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;index1&lt;/code&gt;描述的是L1Cache中Instruction Cache的情况：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.14965986394557823&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3raUkia8dMPfuZycmq6V3yxPEgsOibdPkXdOcf8jiacjsKibIoZCA0pTYwUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1176&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到L1Cache中的Instruction Cache大小也是32K。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;L2Cache&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;L2Cache的信息存储在&lt;code&gt;index2&lt;/code&gt;目录下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.15172413793103448&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rBPG6d6wMicBXC6XNicM4Q4xmwAPvCUVoqicqtegyV1mibEr8gMCOlPjo9g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1160&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;L2Cache的大小为256K，比L1Cache要大些。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;L3Cache&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;L3Cache的信息存储在&lt;code&gt;index3&lt;/code&gt;目录下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.15411558669001751&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3r8EhWk8gMQibcobiaSg6jBXwDYesjukUia4SRXU6d9h9Bf4rm4ZTRMAib4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1142&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里我们可以看到L1Cache中的DataCache和InstructionCache大小一样都是32K而L2Cache的大小为256K，L3Cache的大小为6M。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然这些数值在不同的CPU配置上会是不同的，但是总体上来说L1Cache的量级是几十KB，L2Cache的量级是几百KB，L3Cache的量级是几MB。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.1.2 CPU缓存行&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边我们介绍了CPU的高速缓存结构，引入高速缓存的目的在于消除CPU与内存之间的速度差距，根据&lt;code&gt;程序的局部性原理&lt;/code&gt;我们知道，CPU的高速缓存肯定是用来存放热点数据的。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;程序局部性原理表现为：时间局部性和空间局部性。时间局部性是指如果程序中的某条指令一旦执行，则不久之后该指令可能再次被执行；如果某块数据被访问，则不久之后该数据可能再次被访问。空间局部性是指一旦程序访问了某个存储单元，则不久之后，其附近的存储单元也将被访问。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么在高速缓存中存取数据的基本单位又是什么呢？？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事实上热点数据在CPU高速缓存中的存取并不是我们想象中的以单独的变量或者单独的指针为单位存取的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CPU高速缓存中存取数据的基本单位叫做缓存行&lt;code&gt;cache line&lt;/code&gt;。缓存行存取字节的大小为2的倍数，在不同的机器上，缓存行的大小范围在32字节到128字节之间。目前所有主流的处理器中缓存行的大小均为&lt;code&gt;64字节&lt;/code&gt;（&lt;strong&gt;注意：这里的单位是字节&lt;/strong&gt;）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1685483870967742&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rFp5pibic2ibgK0RhpiaNSzG8LY5TVRjoLibakY8jIicsxTu4EoYgUzGXq7tA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图中我们可以看到L1Cache,L2Cache,L3Cache中缓存行的大小都是&lt;code&gt;64字节&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也就意味着每次CPU从内存中获取数据或者写入数据的大小为64个字节，即使你只读一个bit，CPU也会从内存中加载64字节数据进来。同样的道理，CPU从高速缓存中同步数据到内存也是按照64字节的单位来进行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如你访问一个long型数组，当CPU去加载数组中第一个元素时也会同时将后边的7个元素一起加载进缓存中。&lt;strong&gt;这样一来就加快了遍历数组的效率。&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;long类型在Java中占用8个字节，一个缓存行可以存放8个long型变量。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事实上，你可以非常快速的遍历在连续的内存块中分配的任意数据结构，如果你的数据结构中的项在内存中不是彼此相邻的（比如：链表），这样就无法利用CPU缓存的优势。由于数据在内存中不是连续存放的，所以在这些数据结构中的每一个项都可能会出现缓存行未命中（&lt;code&gt;程序局部性原理&lt;/code&gt;）的情况。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;还记得我们在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247483907&amp;amp;idx=1&amp;amp;sn=084c470a8fe6234c2c9461b5f713ff30&amp;amp;chksm=ce77c444f9004d52e7c6244bee83479070effb0bc59236df071f4d62e91e25f01715fca53696&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;?&lt;/span&gt;《Reactor在Netty中的实现(创建篇)》&lt;/a&gt;中介绍Selector的创建时提到，Netty利用数组实现的自定义SelectedSelectionKeySet类型替换掉了JDK利用HashSet类型实现的&lt;code&gt;sun.nio.ch.SelectorImpl#selectedKeys&lt;/code&gt;。&lt;strong&gt;目的就是利用CPU缓存的优势来提高IO活跃的SelectionKeys集合的遍历性能&lt;/strong&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2 False Sharing（伪共享）&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来看一个这样的例子，笔者定义了一个示例类FalseSharding，类中有两个long型的volatile字段a，b。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FalseSharding&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; a;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; b;&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;字段a，b之间逻辑上是独立的，它们之间一点关系也没有，分别用来存储不同的数据，数据之间也没有关联。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;FalseSharding类中字段之间的内存布局如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1282258064516129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rIkusicdpvzH08AqomqdzO2kTIoFr11Zgm4AD8321M6juwibgGibBZeJiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;FalseSharding类中的字段a,b在内存中是相邻存储，分别占用8个字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果恰好字段a，b被CPU读进了同一个缓存行，而此时有两个线程，线程a用来修改字段a，同时线程b用来读取字段b。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7330645161290322&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rp7SqclFcyfHiaq64J2oQgXg8e9ictC2Er2TqjgGygFM9w9ToXhKakSxg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;falsesharding1.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;在这种场景下，会对线程b的读取操作造成什么影响呢&lt;/strong&gt;？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道声明了&lt;code&gt;volatile关键字&lt;/code&gt;的变量可以在多线程处理环境下，确保内存的可见性。计算机硬件层会保证对被volatile关键字修饰的共享变量进行写操作后的内存可见性，而这种内存可见性是由&lt;code&gt;Lock前缀指令&lt;/code&gt;以及&lt;code&gt;缓存一致性协议（MESI控制协议）&lt;/code&gt;共同保证的。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Lock前缀指令可以使修改线程所在的处理器中的相应缓存行数据被修改后立马刷新回内存中，并同时&lt;code&gt;锁定&lt;/code&gt;所有处理器核心中缓存了该修改变量的缓存行，防止多个处理器核心并发修改同一缓存行。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;缓存一致性协议主要是用来维护多个处理器核心之间的CPU缓存一致性以及与内存数据的一致性。每个处理器会在总线上嗅探其他处理器准备写入的内存地址，如果这个内存地址在自己的处理器中被缓存的话，就会将自己处理器中对应的缓存行置为&lt;code&gt;无效&lt;/code&gt;，下次需要读取的该缓存行中的数据的时候，就需要访问内存获取。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;基于以上volatile关键字原则，我们首先来看第一种影响&lt;/strong&gt;：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5919354838709677&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3r7wY7nnNnOPoKmzuicta6VYXzeUqVyQ80rBPniabpvAhiaTFUqYFDDs4dA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;falsesharding2.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当线程a在处理器core0中对字段a进行修改时，&lt;code&gt;Lock前缀指令&lt;/code&gt;会将所有处理器中缓存了字段a的对应缓存行进行&lt;code&gt;锁定&lt;/code&gt;，&lt;strong&gt;这样就会导致线程b在处理器core1中无法读取和修改自己缓存行的字段b&lt;/strong&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;处理器core0将修改后的字段a所在的缓存行刷新回内存中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图中我们可以看到此时字段a的值在处理器core0的缓存行中以及在内存中已经发生变化了。但是处理器core1中字段a的值还没有变化，并且core1中字段a所在的缓存行处于&lt;code&gt;锁定状态&lt;/code&gt;，无法读取也无法写入字段b。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上述过程中我们可以看出即使字段a，b之间逻辑上是独立的，它们之间一点关系也没有，但是线程a对字段a的修改，导致了线程b无法读取字段b。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第二种影响&lt;/strong&gt;：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7693548387096775&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rnB60WxJJOpAyczIn2FuP2j5QgEgr2MNN0qOlBhDVAjFjib9bzo92wpw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;faslesharding3.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当处理器core0将字段a所在的缓存行刷新回内存的时候，处理器core1会在总线上嗅探到字段a的内存地址正在被其他处理器修改，所以将自己的缓存行置为&lt;code&gt;失效&lt;/code&gt;。当线程b在处理器core1中读取字段b的值时，发现缓存行已被置为&lt;code&gt;失效&lt;/code&gt;，core1需要重新从内存中读取字段b的值即使字段b没有发生任何变化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从以上两种影响我们看到字段a与字段b实际上并不存在共享，它们之间也没有相互关联关系，理论上线程a对字段a的任何操作，都不应该影响线程b对字段b的读取或者写入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但事实上线程a对字段a的修改导致了字段b在core1中的缓存行被锁定（Lock前缀指令），进而使得线程b无法读取字段b。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程a所在处理器core0将字段a所在缓存行同步刷新回内存后，导致字段b在core1中的缓存行被置为&lt;code&gt;失效&lt;/code&gt;（缓存一致性协议），进而导致线程b需要重新回到内存读取字段b的值无法利用CPU缓存的优势。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于字段a和字段b在同一个缓存行中，导致了字段a和字段b事实上的共享（原本是不应该被共享的）。这种现象就叫做&lt;code&gt;False Sharing（伪共享）&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在高并发的场景下，这种伪共享的问题，会对程序性能造成非常大的影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果线程a对字段a进行修改，与此同时线程b对字段b也进行修改，这种情况对性能的影响更大，因为这会导致core0和core1中相应的缓存行相互失效。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.3 False Sharing的解决方案&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然导致False Sharing出现的原因是字段a和字段b在同一个缓存行导致的，那么我们就要想办法让字段a和字段b不在一个缓存行中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么我们怎么做才能够使得字段a和字段b一定不会被分配到同一个缓存行中呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候，本小节的主题字节填充就派上用场了~~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Java8之前我们通常会在字段a和字段b前后分别填充7个long型变量(缓存行大小64字节)，目的是让字段a和字段b各自独占一个缓存行避免&lt;code&gt;False Sharing&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我们将一开始的实例代码修改成这个这样子，就可以保证字段a和字段b各自独占一个缓存行了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FalseSharding&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; p1,p2,p3,p4,p5,p6,p7;&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; a;&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; p8,p9,p10,p11,p12,p13,p14;&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; b;&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; p15,p16,p17,p18,p19,p20,p21;&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;修改后的对象在内存中布局如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47580645161290325&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rUI6HrVY89690zicQejoWhiaIguq7jBiaujKzicrbqxjo3RJ53BGb45ozng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到为了解决False Sharing问题，我们将原本占用32字节的FalseSharding示例对象硬生生的填充到了200字节。这对内存的消耗是非常可观的。通常为了极致的性能，我们会在一些高并发框架或者JDK的源码中看到False Sharing的解决场景。因为在高并发场景中，任何微小的性能损失比如False Sharing，都会被无限放大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但解决False Sharing的同时又会带来巨大的内存消耗，所以即使在高并发框架比如disrupter或者JDK中也只是&lt;strong&gt;针对那些在多线程场景下被频繁写入的共享变量&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这里笔者想强调的是在我们日常工作中&lt;/strong&gt;，我们不能因为自己手里拿着锤子，就满眼都是钉子，看到任何钉子都想上去锤两下。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rHkkic5QPnrIgdFMNicgPufSU5znYlN8rfUdVey7zP9GWl93fYqkdGO4g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;255&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们要清晰的分辨出一个问题会带来哪些影响和损失，这些影响和损失在我们当前业务阶段是否可以接受？是否是瓶颈？同时我们也要清晰的了解要解决这些问题我们所要付出的代价。一定要综合评估，讲究一个投入产出比。某些问题虽然是问题，但是在某些阶段和场景下并不需要我们投入解决。而有些问题则对于我们当前业务发展阶段是瓶颈，我们&lt;strong&gt;不得不&lt;/strong&gt;去解决。我们在架构设计或者程序设计中，方案一定要&lt;code&gt;简单&lt;/code&gt;，&lt;code&gt;合适&lt;/code&gt;。并预估一些提前量留有一定的&lt;code&gt;演化空间&lt;/code&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.3.1 @Contended注解&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Java8中引入了一个新注解&lt;code&gt;@Contended&lt;/code&gt;，用于解决False Sharing的问题，同时这个注解也会影响到Java对象中的字段排列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上一小节的内容介绍中，我们通过手段填充字段的方式解决了False Sharing的问题，但是这里也有一个问题，因为我们在手动填充字段的时候还需要考虑CPU缓存行的大小，因为虽然现在所有主流的处理器缓存行大小均为64字节，但是也还是有处理器的缓存行大小为32字节，有的甚至是128字节。我们需要考虑很多硬件的限制因素。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java8中通过引入@Contended注解帮我们解决了这个问题，我们不在需要去手动填充字段了。下面我们就来看下@Contended注解是如何帮助我们来解决这个问题的~~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上小节介绍的手动填充字节是在共享变量前后填充64字节大小的空间，这样只能确保程序在缓存行大小为32字节或者64字节的CPU下独占缓存行。但是如果CPU的缓存行大小为128字节，这样依然存在False Sharing的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引入@Contended注解可以使我们忽略底层硬件设备的差异性，做到Java语言的初衷：平台无关性。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;@Contended注解默认只是在JDK内部起作用，如果我们的程序代码中需要使用到@Contended注解，那么需要开启JVM参数&lt;code&gt;-XX:-RestrictContended&lt;/code&gt;才会生效。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Retention&lt;/span&gt;(RetentionPolicy.RUNTIME)&lt;br/&gt;&lt;span&gt;@Target&lt;/span&gt;({ElementType.FIELD, ElementType.TYPE})&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;@interface&lt;/span&gt; Contended {&lt;br/&gt;    &lt;span&gt;//contention group tag&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;String &lt;span&gt;value&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;@Contended注解可以标注在类上也可以标注在类中的字段上，被@Contended标注的对象会独占缓存行，不会和任何变量或者对象共享缓存行。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;@Contended标注在类上表示该类对象中的&lt;code&gt;实例数据整体&lt;/code&gt;需要独占缓存行。不能与其他实例数据共享缓存行。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;@Contended标注在类中的字段上表示该字段需要独占缓存行。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;除此之外@Contended还提供了分组的概念，注解中的value属性表示&lt;code&gt;contention group &lt;/code&gt;。属于统一分组下的变量，它们在内存中是连续存放的，可以允许共享缓存行。不同分组之间不允许共享缓存行。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来分别看下@Contended注解在这三种使用场景下是怎样影响字段之间的排列的。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;@Contended标注在类上&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Contended&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FalseSharding&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; a;&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; b;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; c;&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; d;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当@Contended标注在FalseSharding示例类上时，表示FalseSharding示例对象中的&lt;code&gt;整个实例数据区&lt;/code&gt;需要独占缓存行，不能与其他对象或者变量共享缓存行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种情况下的内存布局：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1870967741935484&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rwE6v9iaC7nRQBSTl61ibVbibmqCUHkVrex4zbnwLMrzbJiblBuuKoUuk3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图中所示，FalseSharding示例类被标注了@Contended之后，JVM会在FalseSharding示例对象的实例数据区前后填充&lt;code&gt;128个字节&lt;/code&gt;，保证实例数据区内的字段之间内存是连续的，并且保证整个实例数据区独占缓存行，不会与实例数据区之外的数据共享缓存行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;细心的朋友可能已经发现了问题，我们之前不是提到缓存行的大小为64字节吗？为什么这里会填充128字节呢&lt;/strong&gt;？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且之前介绍的手动填充也是填充的&lt;code&gt;64字节&lt;/code&gt;，为什么@Contended注解会采用&lt;code&gt;两倍&lt;/code&gt;的缓存行大小来填充呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实这里的原因有两个：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;首先第一个原因，我们之前也已经提到过了，目前大部分主流的CPU缓存行是64字节，但是也有部分CPU缓存行是32字节或者128字节，如果只填充64字节的话，在缓存行大小为32字节和64字节的CPU中是可以做到独占缓存行从而避免FalseSharding的，但在缓存行大小为&lt;code&gt;128字节&lt;/code&gt;的CPU中还是会出现FalseSharding问题，这里Java采用了悲观的一种做法，默认都是填充&lt;code&gt;128字节&lt;/code&gt;，虽然对于大部分情况下比较浪费，但是屏蔽了底层硬件的差异。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;不过@Contended注解填充字节的大小我们可以通过JVM参数&lt;code&gt;-XX:ContendedPaddingWidth&lt;/code&gt;指定，有效值范围&lt;code&gt;0 - 8192&lt;/code&gt;，默认为&lt;code&gt;128&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;第二个原因其实是最为核心的一个原因，主要是为了防止CPU Adjacent Sector Prefetch（CPU相邻扇区预取）特性所带来的FalseSharding问题。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;CPU Adjacent Sector Prefetch：https://www.techarp.com/bios-guide/cpu-adjacent-sector-prefetch/&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;CPU Adjacent Sector Prefetch&lt;/strong&gt;是Intel处理器特有的BIOS功能特性，默认是enabled。主要作用就是利用&lt;code&gt;程序局部性原理&lt;/code&gt;，当CPU从内存中请求数据，并读取当前请求数据所在缓存行时，&lt;code&gt;会进一步预取&lt;/code&gt;与当前缓存行相邻的下一个缓存行，这样当我们的程序在顺序处理数据时，会提高CPU处理效率。&lt;strong&gt;这一点也体现了程序局部性原理中的空间局部性特征&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当CPU Adjacent Sector Prefetch特性被disabled禁用时，CPU就只会获取当前请求数据所在的缓存行，不会预取下一个缓存行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在当&lt;code&gt;CPU Adjacent Sector Prefetch&lt;/code&gt;启用（enabled）的时候，CPU其实同时处理的是两个缓存行，在这种情况下，就需要填充两倍缓存行大小（128字节）来避免CPU Adjacent Sector Prefetch所带来的的FalseSharding问题。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;@Contended标注在字段上&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FalseSharding&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Contended&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; a;&lt;br/&gt;    &lt;span&gt;@Contended&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; b;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; c;&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; d;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.20806451612903226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rYjQZSvYydAafvXRFNYjiciax54q8PDibqKWRPZH4ZCTksjmkAurvXd7sg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这次我们将 @Contended注解标注在了FalseSharding示例类中的字段a和字段b上，这样带来的效果是字段a和字段b各自独占缓存行。从内存布局上看，字段a和字段b前后分别被填充了128个字节，来确保字段a和字段b不与任何数据共享缓存行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而没有被@Contended注解标注字段c和字段d则在内存中连续存储，可以共享缓存行。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;@Contended分组&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FalseSharding&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Contended&lt;/span&gt;(&lt;span&gt;&quot;group1&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; a;&lt;br/&gt;    &lt;span&gt;@Contended&lt;/span&gt;(&lt;span&gt;&quot;group1&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; b;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Contended&lt;/span&gt;(&lt;span&gt;&quot;group2&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;  c;&lt;br/&gt;    &lt;span&gt;@Contended&lt;/span&gt;(&lt;span&gt;&quot;group2&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; d;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.20967741935483872&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3r31YIiaAib4AemgAaw7rdkMDg478ibd9mt4B70FkK7YvsBEa7Eribqe6Ylg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这次我们将字段a与字段b放在同一content group下，字段c与字段d放在另一个content group下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样处在同一分组&lt;code&gt;group1&lt;/code&gt;下的字段a与字段b在内存中是连续存储的，可以共享缓存行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同理处在同一分组group2下的字段c与字段d在内存中也是连续存储的，也允许共享缓存行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;但是分组之间是不能共享缓存行的&lt;/strong&gt;，所以在字段分组的前后各填充&lt;code&gt;128字节&lt;/code&gt;，来保证分组之间的变量不能共享缓存行。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. 内存对齐&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过以上内容我们了解到Java对象中的实例数据区字段需要进行内存对齐而导致在JVM中会被重排列以及通过填充缓存行避免false sharding的目的所带来的字节对齐填充。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们也了解到内存对齐不仅发生在对象与对象之间，也发生在对象中的字段之间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么在本小节中笔者将为大家介绍什么是内存对齐，在本节的内容开始之前笔者先来抛出两个问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;为什么要进行内存对齐？如果就是头比较铁，就是不内存对齐，会产生什么样的后果？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Java 虚拟机堆中对象的起始地址为什么需要对齐至 &lt;code&gt;8&lt;/code&gt;的倍数？为什么不对齐至4的倍数或16的倍数或32的倍数呢？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;带着这两个问题，下面我们正式开始本节的内容~~~&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.1 内存结构&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们平时所称的内存也叫随机访问存储器（random-access memory）也叫RAM。而RAM分为两类：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;一类是静态RAM（&lt;code&gt;SRAM&lt;/code&gt;），这类SRAM用于前边介绍的CPU高速缓存L1Cache，L2Cache，L3Cache。其特点是访问速度快，访问速度为&lt;code&gt;1 - 30个&lt;/code&gt;时钟周期，但是容量小，造价高。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;另一类则是动态RAM(&lt;code&gt;DRAM&lt;/code&gt;)，这类DRAM用于我们常说的主存上，其特点的是访问速度慢（相对高速缓存），访问速度为&lt;code&gt;50 - 200个&lt;/code&gt;时钟周期，但是容量大，造价便宜些（相对高速缓存）。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存由一个一个的存储器模块（memory module）组成，它们插在主板的扩展槽上。常见的存储器模块通常以&lt;strong&gt;64位为单位（8个字节）&lt;/strong&gt;传输数据到存储控制器上或者从存储控制器传出数据。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42318840579710143&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rnrSgvb85ibv3U8g3LG5F8RVIA7kRicdROicicYCcnrISY4QFwhgakZhib0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;345&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图所示内存条上黑色的元器件就是存储器模块（memory module）。多个存储器模块连接到存储控制器上，就聚合成了主存。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.582258064516129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rHJU9YqekfN52K1HLNncfs3WqVP9hde7eVPeat9VIddbGgEn7nLyZ6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;内存结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而前边介绍到的&lt;code&gt;DRAM芯片&lt;/code&gt;就包装在存储器模块中，每个存储器模块中包含&lt;code&gt;8个DRAM芯片&lt;/code&gt;，依次编号为&lt;code&gt;0 - 7&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5225806451612903&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rB3u6R4hGOFJRfKU90sxBFYVaR2ia3YBMKsXxxPkRXAibueRUZOZkM0zw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;存储器模块.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而每一个&lt;code&gt;DRAM芯片&lt;/code&gt;的存储结构是一个二维矩阵，二维矩阵中存储的元素我们称为超单元（&lt;code&gt;supercell&lt;/code&gt;），每个supercell大小为一个字节（&lt;code&gt;8 bit&lt;/code&gt;）。每个supercell都由一个坐标地址（i，j）。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;i表示二维矩阵中的行地址，在计算机中行地址称为RAS(row access strobe，行访问选通脉冲)。j表示二维矩阵中的列地址，在计算机中列地址称为CAS(column access strobe,列访问选通脉冲)。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下图中的supercell的RAS = 2，CAS = 2。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4161290322580645&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rTpkjjIriaZlz2u5aBwkVibNANtyB4fF4X9NxbbUuuCLmwtAeAoY1LsibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;DRAM结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;DRAM芯片&lt;/code&gt;中的信息通过引脚流入流出DRAM芯片。每个引脚携带&lt;code&gt;1 bit&lt;/code&gt;的信号。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图中DRAM芯片包含了两个地址引脚(&lt;code&gt;addr&lt;/code&gt;)，因为我们要通过RAS，CAS来定位要获取的&lt;code&gt;supercell&lt;/code&gt;。还有8个数据引脚（&lt;code&gt;data&lt;/code&gt;）,&lt;strong&gt;因为DRAM芯片的IO单位为一个字节（8 bit）&lt;/strong&gt;,所以需要8个data引脚从DRAM芯片传入传出数据。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意这里只是为了解释地址引脚和数据引脚的概念，实际硬件中的引脚数量是不一定的。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2 DRAM芯片的访问&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们现在就以读取上图中坐标地址为（2，2）的supercell为例，来说明访问DRAM芯片的过程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6290322580645161&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3r7jkYERTnvHcJ8wQkly8dUiba6vorz5ziaEibDOA22B7QySuibElTW2o2pw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;DRAM芯片访问.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;首先存储控制器将行地址&lt;code&gt;RAS = 2&lt;/code&gt;通过地址引脚发送给&lt;code&gt;DRAM芯片&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;DRAM芯片根据&lt;code&gt;RAS = 2&lt;/code&gt;将二维矩阵中的第二行的全部内容拷贝到&lt;code&gt;内部行缓冲区&lt;/code&gt;中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;接下来存储控制器会通过地址引脚发送&lt;code&gt;CAS = 2&lt;/code&gt;到DRAM芯片中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;DRAM芯片从内部行缓冲区中根据&lt;code&gt;CAS = 2&lt;/code&gt;拷贝出第二列的supercell并通过数据引脚发送给存储控制器。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;DRAM芯片的IO单位为一个supercell，也就是一个字节(8 bit)。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3 CPU如何读写主存&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边我们介绍了内存的物理结构，以及如何访问内存中的DRAM芯片获取supercell中存储的数据（&lt;code&gt;一个字节&lt;/code&gt;）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本小节我们来介绍下CPU是如何访问内存的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4443548387096774&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rBuTZIXQof8eoW6ibAYpcULFoibX0dKoES48Y3vG39BQibhEfbPtIuvMdw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;CPU与内存之间的总线结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中关于CPU芯片的内部结构我们在介绍false sharding的时候已经详细的介绍过了，这里我们主要聚焦在CPU与内存之间的总线架构上。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.1 总线结构&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CPU与内存之间的数据交互是通过总线（bus）完成的，而数据在总线上的传送是通过一系列的步骤完成的，这些步骤称为总线事务（bus transaction）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中数据从内存传送到CPU称之为&lt;code&gt;读事务（read transaction）&lt;/code&gt;，数据从CPU传送到内存称之为&lt;code&gt;写事务（write transaction）&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总线上传输的信号包括：地址信号，数据信号，控制信号。其中控制总线上传输的控制信号可以同步事务，并能够标识出当前正在被执行的事务信息：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;当前这个事务是到内存的？还是到磁盘的？或者是到其他IO设备的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这个事务是读还是写？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;总线上传输的地址信号（&lt;code&gt;内存地址&lt;/code&gt;），还是数据信号（&lt;code&gt;数据&lt;/code&gt;）？。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;还记得我们前边讲到的MESI缓存一致性协议吗？当core0修改字段a的值时，其他CPU核心会在总线上&lt;code&gt;嗅探&lt;/code&gt;字段a的内存地址，如果嗅探到总线上出现字段a的内存地址，说明有人在修改字段a，这样其他CPU核心就会&lt;code&gt;失效&lt;/code&gt;自己缓存字段a所在的&lt;code&gt;cache line&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图所示，其中系统总线是连接CPU与IO bridge的，存储总线是来连接IO bridge和主存的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;IO bridge&lt;/code&gt;负责将系统总线上的电子信号转换成存储总线上的电子信号。IO bridge也会将系统总线和存储总线连接到IO总线（磁盘等IO设备）上。这里我们看到IO bridge其实起的作用就是转换不同总线上的电子信号。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.2 CPU从内存读取数据过程&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设CPU现在要将内存地址为&lt;code&gt;A&lt;/code&gt;的内容加载到寄存器中进行运算。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4596774193548387&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rN11lLbPfeAJzGCk3REBStPEKsvn2pemCqM0ib5C8OKcnNp9IicOq0toA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;CPU读取内存.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先CPU芯片中的&lt;code&gt;总线接口&lt;/code&gt;会在总线上发起读事务（&lt;code&gt;read transaction&lt;/code&gt;）。该读事务分为以下步骤进行：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;CPU将内存地址A放到系统总线上。随后&lt;code&gt;IO bridge&lt;/code&gt;将信号传递到存储总线上。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;主存感受到存储总线上的&lt;code&gt;地址信号&lt;/code&gt;并通过存储控制器将存储总线上的内存地址A读取出来。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;存储控制器通过内存地址A定位到具体的存储器模块，从&lt;code&gt;DRAM芯片&lt;/code&gt;中取出内存地址A对应的&lt;code&gt;数据X&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;存储控制器将读取到的&lt;code&gt;数据X&lt;/code&gt;放到存储总线上，随后IO bridge将&lt;code&gt;存储总线&lt;/code&gt;上的数据信号转换为&lt;code&gt;系统总线&lt;/code&gt;上的数据信号，然后继续沿着系统总线传递。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;CPU芯片感受到系统总线上的数据信号，将数据从系统总线上读取出来并拷贝到寄存器中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是CPU读取内存数据到寄存器中的完整过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是其中还涉及到一个重要的过程，这里我们还是需要摊开来介绍一下，那就是存储控制器如何通过&lt;code&gt;内存地址A&lt;/code&gt;从主存中读取出对应的&lt;code&gt;数据X&lt;/code&gt;的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们结合前边介绍的内存结构以及从DRAM芯片读取数据的过程，来总体介绍下如何从主存中读取数据。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.3 如何根据内存地址从主存中读取数据&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边介绍到，当主存中的存储控制器感受到了存储总线上的&lt;code&gt;地址信号&lt;/code&gt;时，会将内存地址从存储总线上读取出来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随后会通过内存地址定位到具体的存储器模块。还记得内存结构中的存储器模块吗？？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.582258064516129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rHJU9YqekfN52K1HLNncfs3WqVP9hde7eVPeat9VIddbGgEn7nLyZ6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;内存结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而每个存储器模块中包含了8个DRAM芯片，编号从&lt;code&gt;0 - 7&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5225806451612903&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rB3u6R4hGOFJRfKU90sxBFYVaR2ia3YBMKsXxxPkRXAibueRUZOZkM0zw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;存储器模块.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;存储控制器会将内存地址转换为DRAM芯片中supercell在二维矩阵中的坐标地址(&lt;code&gt;RAS&lt;/code&gt;，&lt;code&gt;CAS&lt;/code&gt;)。并将这个坐标地址发送给对应的存储器模块。随后存储器模块会将&lt;code&gt;RAS&lt;/code&gt;和&lt;code&gt;CAS&lt;/code&gt;广播到存储器模块中的所有&lt;code&gt;DRAM芯片&lt;/code&gt;。依次通过(&lt;code&gt;RAS&lt;/code&gt;，&lt;code&gt;CAS&lt;/code&gt;)从DRAM0到DRAM7读取到相应的supercell。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6290322580645161&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3r7jkYERTnvHcJ8wQkly8dUiba6vorz5ziaEibDOA22B7QySuibElTW2o2pw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;DRAM芯片访问.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道一个supercell存储了&lt;code&gt;8 bit&lt;/code&gt;数据，这里我们从DRAM0到DRAM7
依次读取到了8个supercell也就是&lt;code&gt;8个字节&lt;/code&gt;，然后将这8个字节返回给存储控制器，由存储控制器将数据放到存储总线上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;CPU总是以word size为单位从内存中读取数据，在64位处理器中的word size为8个字节。64位的内存也只能每次吞吐8个字节。&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;CPU每次会向内存读写一个&lt;code&gt;cache line&lt;/code&gt;大小的数据（&lt;code&gt;64个字节&lt;/code&gt;），但是内存一次只能吞吐&lt;code&gt;8个字节&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在内存地址对应的存储器模块中，&lt;code&gt;DRAM0芯片&lt;/code&gt;存储第一个低位字节（supercell），&lt;code&gt;DRAM1芯片&lt;/code&gt;存储第二个字节，......依次类推&lt;code&gt;DRAM7芯片&lt;/code&gt;存储最后一个高位字节。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;内存一次读取和写入的单位是8个字节。而且在程序员眼里连续的内存地址实际上在物理上是不连续的&lt;/strong&gt;。因为这连续的&lt;code&gt;8个字节&lt;/code&gt;其实是存储于不同的&lt;code&gt;DRAM芯片&lt;/code&gt;上的。每个DRAM芯片存储一个字节（supercell）。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6540322580645161&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rxuq3wSWAjzItUEATFbumn4CQ3nngGbG9ibK9ymH6xUCFiaicMicPzvBicMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;读取存储器模块数据.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.4 CPU向内存写入数据过程&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们现在假设CPU要将寄存器中的数据X写到内存地址A中。同样的道理，CPU芯片中的总线接口会向总线发起写事务（&lt;code&gt;write transaction&lt;/code&gt;）。写事务步骤如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;CPU将要写入的内存地址A放入系统总线上。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;通过&lt;code&gt;IO bridge&lt;/code&gt;的信号转换，将内存地址A传递到存储总线上。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;存储控制器感受到存储总线上的地址信号，将内存地址A从存储总线上读取出来，并等待数据的到达。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;CPU将寄存器中的数据拷贝到系统总线上，通过&lt;code&gt;IO bridge&lt;/code&gt;的信号转换，将数据传递到存储总线上。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;存储控制器感受到存储总线上的数据信号，将数据从存储总线上读取出来。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;存储控制器通过内存地址A定位到具体的存储器模块，最后将数据写入存储器模块中的8个DRAM芯片中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. 为什么要内存对齐&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在了解了内存结构以及CPU读写内存的过程之后，现在我们回过头来讨论下本小节开头的问题：为什么要内存对齐？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面笔者从三个方面来介绍下要进行内存对齐的原因：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;速度&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CPU读取数据的单位是根据&lt;code&gt;word size&lt;/code&gt;来的，在64位处理器中&lt;code&gt;word size = 8字节&lt;/code&gt;，所以CPU向内存读写数据的单位为&lt;code&gt;8字节&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在64位内存中，内存IO单位为&lt;code&gt;8个字节&lt;/code&gt;，我们前边也提到内存结构中的存储器模块通常以64位为单位（8个字节）传输数据到存储控制器上或者从存储控制器传出数据。因为每次内存IO读取数据都是从数据所在具体的存储器模块中包含的这8个DRAM芯片中以相同的(&lt;code&gt;RAM&lt;/code&gt;,&lt;code&gt;CAS&lt;/code&gt;)依次读取一个字节，然后在存储控制器中聚合成&lt;code&gt;8个字节&lt;/code&gt;返回给CPU。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6540322580645161&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rxuq3wSWAjzItUEATFbumn4CQ3nngGbG9ibK9ymH6xUCFiaicMicPzvBicMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;读取存储器模块数据.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;由于存储器模块中这种由8个DRAM芯片组成的物理存储结构的限制，内存读取数据只能是按照地址顺序8个字节的依次读取----8个字节8个字节地来读取数据。&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4685483870967742&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3ribMl20O9znTgEfP42FRNnCSg4ELsbIIU6r0se5xGJs9cHfLeqWUqibyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;内存IO单位.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;假设我们现在读取&lt;code&gt;0x0000 - 0x0007&lt;/code&gt;这段连续内存地址上的8个字节。由于内存读取是按照&lt;code&gt;8个字节&lt;/code&gt;为单位依次顺序读取的，&lt;strong&gt;而我们要读取的这段内存地址的起始地址是0（8的倍数）&lt;/strong&gt;，所以0x0000 - 0x0007中每个地址的坐标都是相同的（&lt;code&gt;RAS&lt;/code&gt;,&lt;code&gt;CAS&lt;/code&gt;）。所以他可以在8个DRAM芯片中通过相同的（&lt;code&gt;RAS&lt;/code&gt;,&lt;code&gt;CAS&lt;/code&gt;）一次性读取出来。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果我们现在读取&lt;code&gt;0x0008 - 0x0015&lt;/code&gt;这段连续内存上的8个字节也是一样的，&lt;strong&gt;因为内存段起始地址为8（8的倍数）&lt;/strong&gt;，所以这段内存上的每个内存地址在DREAM芯片中的坐标地址（&lt;code&gt;RAS&lt;/code&gt;,&lt;code&gt;CAS&lt;/code&gt;）也是相同的，我们也可以一次性读取出来。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意：&lt;code&gt;0x0000 - 0x0007&lt;/code&gt;内存段中的坐标地址（RAS,CAS）与&lt;code&gt;0x0008 - 0x0015&lt;/code&gt;内存段中的坐标地址（RAS,CAS）是不相同的。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;但如果我们现在读取&lt;code&gt;0x0007 - 0x0014&lt;/code&gt;这段连续内存上的8个字节情况就不一样了，由于起始地址&lt;code&gt;0x0007&lt;/code&gt;在DRAM芯片中的（RAS,CAS）与后边地址&lt;code&gt;0x0008 - 0x0014&lt;/code&gt;的（RAS,CAS）不相同，所以CPU只能先从&lt;code&gt;0x0000 - 0x0007&lt;/code&gt;读取8个字节出来先放入&lt;code&gt;结果寄存器&lt;/code&gt;中并左移7个字节（目的是只获取&lt;code&gt;0x0007&lt;/code&gt;），然后CPU在从&lt;code&gt;0x0008 - 0x0015&lt;/code&gt;读取8个字节出来放入临时寄存器中并右移1个字节（目的是获取&lt;code&gt;0x0008 - 0x0014&lt;/code&gt;）最后与结果寄存器&lt;code&gt;或运算&lt;/code&gt;。最终得到&lt;code&gt;0x0007 - 0x0014&lt;/code&gt;地址段上的8个字节。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从以上分析过程来看，当CPU访问内存对齐的地址时，比如&lt;code&gt;0x0000&lt;/code&gt;和&lt;code&gt;0x0008&lt;/code&gt;这两个起始地址都是对齐至&lt;code&gt;8的倍数&lt;/code&gt;。CPU可以通过一次read transaction读取出来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是当CPU访问内存没有对齐的地址时，比如&lt;code&gt;0x0007&lt;/code&gt;这个起始地址就没有对齐至&lt;code&gt;8的倍数&lt;/code&gt;。CPU就需要两次read transaction才能将数据读取出来。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;还记得笔者在小节开头提出的问题吗  ？&quot;Java 虚拟机堆中对象的&lt;code&gt;起始地址&lt;/code&gt;为什么需要对齐至 &lt;code&gt;8的倍数&lt;/code&gt;？为什么不对齐至4的倍数或16的倍数或32的倍数呢？&quot;
现在你能回答了吗？？？&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;原子性&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CPU可以原子地操作一个对齐的word size memory。64位处理器中&lt;code&gt;word size = 8字节&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;尽量分配在一个缓存行中&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边在介绍&lt;code&gt;false sharding&lt;/code&gt;的时候我们提到目前主流处理器中的&lt;code&gt;cache line&lt;/code&gt;大小为&lt;code&gt;64字节&lt;/code&gt;，堆中对象的起始地址通过内存对齐至&lt;code&gt;8的倍数&lt;/code&gt;，可以让对象尽可能的分配到一个缓存行中。&lt;strong&gt;一个内存起始地址未对齐的对象可能会跨缓存行存储，这样会导致CPU的执行效率慢2倍&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中对象中字段内存对齐的其中一个重要原因也是让字段只出现在同一 CPU 的缓存行中。如果字段不是对齐的，那么就有可能出现跨缓存行的字段。也就是说，该字段的读取可能需要替换两个缓存行，而该字段的存储也会同时污染两个缓存行。这两种情况对程序的执行效率而言都是不利的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外在《2. 字段重排列》这一小节介绍的三种字段对齐规则，&lt;strong&gt;是保证在字段内存对齐的基础上使得实例数据区占用内存尽可能的小&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7. 压缩指针&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在介绍完关于内存对齐的相关内容之后，我们来介绍下前边经常提到的压缩指针。可以通过JVM参数&lt;code&gt;XX:+UseCompressedOops&lt;/code&gt;开启，当然默认是开启的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本小节内容开启之前，我们先来讨论一个问题，&lt;strong&gt;那就是为什么要使用压缩指针？？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设我们现在正在准备将32位系统切换到64位系统，起初我们可能会期望系统性能会立马得到提升，但现实情况可能并不是这样的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在JVM中导致性能下降的最主要原因就是64位系统中的&lt;code&gt;对象引用&lt;/code&gt;。在前边我们也提到过，64位系统中对象的引用以及类型指针占用&lt;code&gt;64 bit&lt;/code&gt;也就是8个字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就导致了在64位系统中的对象引用占用的内存空间是32位系统中的两倍大小，因此间接的导致了在64位系统中更多的内存消耗以及更频繁的GC发生，GC占用的CPU时间越多，那么我们的应用程序占用CPU的时间就越少。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外一个就是对象的引用变大了，那么CPU可缓存的对象相对就少了，增加了对内存的访问。综合以上几点从而导致了系统性能的下降。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从另一方面来说，在64位系统中内存的寻址空间为&lt;code&gt;2^48 = 256T&lt;/code&gt;，在现实情况中我们真的需要这么大的寻址空间吗？？好像也没必要吧~~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;于是我们就有了新的想法：那么我们是否应该切换回32位系统呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们切换回32位系统，我们怎么解决在32位系统中拥有超过&lt;code&gt;4G&lt;/code&gt;的内存寻址空间呢？因为现在4G的内存大小对于现在的应用来说明显是不够的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我想以上的这些问题，也是当初JVM的开发者需要面对和解决的，当然他们也交出了非常完美的答卷，那就是&lt;strong&gt;使用压缩指针可以在64位系统中利用32位的对象引用获得超过4G的内存寻址空间&lt;/strong&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.1 压缩指针是如何做到的呢？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还记得之前我们在介绍对齐填充和内存对齐小节中提到的，在Java虚拟机堆中对象的起始地址必须对齐至&lt;code&gt;8的倍数&lt;/code&gt;吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于堆中对象的起始地址均是对齐至8的倍数，所以对象引用在开启压缩指针情况下的32位二进制的后三位始终是&lt;code&gt;0&lt;/code&gt;（因为它们始终可以被8整除）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然JVM已经知道了这些对象的内存地址后三位始终是0，那么这些无意义的0就没必要在堆中继续存储。相反，我们可以利用存储0的这3位bit存储一些有意义的信息，这样我们就多出&lt;code&gt;3位bit&lt;/code&gt;的寻址空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样在存储的时候，JVM还是按照32位来存储，只不过后三位原本用来存储0的bit现在被我们用来存放有意义的地址空间信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当寻址的时候，JVM将这32位的对象引用&lt;code&gt;左移3位&lt;/code&gt;（后三位补0）。这就导致了在开启压缩指针的情况下，我们原本32位的内存寻址空间一下变成了&lt;code&gt;35位&lt;/code&gt;。可寻址的内存空间变为2^32 * 2^3 = 32G。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3604838709677419&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rV5yqCxeLpAbBDYhzdviaBKhfRic98w2ZC93tRwyBMHgg0Ku4iaQdjUicTg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;压缩指针.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这样一来，JVM虽然额外的执行了一些位运算但是极大的提高了寻址空间，并且将对象引用占用内存大小降低了一半，节省了大量空间。况且这些位运算对于CPU来说是非常容易且轻量的操作&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过压缩指针的原理我挖掘到了&lt;strong&gt;内存对齐的另一个重要原因&lt;/strong&gt;就是通过内存对齐至&lt;code&gt;8的倍数&lt;/code&gt;，我们可以在64位系统中使用压缩指针通过32位的对象引用将寻址空间提升至&lt;code&gt;32G&lt;/code&gt;.&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;从Java7开始，当maximum heap size小于32G的时候，压缩指针是默认开启的。但是当maximum heap size大于32G的时候，压缩指针就会关闭。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;那么我们如何在压缩指针开启的情况下进一步扩大寻址空间呢？？？&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.2 如何进一步扩大寻址空间&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边提到我们在Java虚拟机堆中对象起始地址均需要对其至&lt;code&gt;8的倍数&lt;/code&gt;，不过这个数值我们可以通过JVM参数&lt;code&gt;-XX:ObjectAlignmentInBytes &lt;/code&gt;来改变（默认值为8）。当然这个数值的必须是2的次幂，数值范围需要在&lt;code&gt;8 - 256之间&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正是因为对象地址对齐至8的倍数，才会多出3位bit让我们存储额外的地址信息，进而将4G的寻址空间提升至32G。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样的道理，如果我们将&lt;code&gt;ObjectAlignmentInBytes&lt;/code&gt;的数值设置为16呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对象地址均对齐至16的倍数，那么就会多出4位bit让我们存储额外的地址信息。寻址空间变为2^32 * 2^4 = 64G。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过以上规律，我们就能知道，在64位系统中开启压缩指针的情况，寻址范围的计算公式：&lt;code&gt;4G * ObjectAlignmentInBytes = 寻址范围&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是笔者并不建议大家贸然这样做，因为增大了&lt;code&gt;ObjectAlignmentInBytes&lt;/code&gt;虽然能扩大寻址范围，但是这同时也可能增加了对象之间的字节填充，导致压缩指针没有达到原本节省空间的效果。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8. 数组对象的内存布局&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边大量的篇幅我们都是在讨论Java普通对象在内存中的布局情况，最后这一小节我们再来说下Java中的数组对象在内存中是如何布局的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8.1 基本类型数组的内存布局&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6774193548387096&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rpzq9LdqXNnfBciatEr9eg01iaTDSTZ4vJNqPBDqKeoXOdLryulBJPPzQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;基本类型数组内存布局.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图表示的是基本类型数组在内存中的布局，基本类型数组在JVM中用&lt;code&gt;typeArrayOop&lt;/code&gt;结构体表示，基本类型数组类型元信息用&lt;code&gt;TypeArrayKlass &lt;/code&gt;结构体表示。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数组的内存布局大体上和普通对象的内存布局差不多，唯一不同的是在数组类型对象头中多出了&lt;code&gt;4个字节&lt;/code&gt;用来表示数组长度的部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还是分别以开启指针压缩和关闭指针压缩两种情况，通过下面的例子来进行说明：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;long&lt;/span&gt;[] longArrayLayout = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;[&lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;开启指针压缩 -XX:+UseCompressedOops&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.12016129032258065&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rXQQicaytwdQoSvqrB3XCyoK1odU5kU3pqUFASKOyS4n6kdPgs7nIsGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到红框部分即为数组类型对象头中多出来一个&lt;code&gt;4字节&lt;/code&gt;大小用来表示数组长度的部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为我们示例中的long型数组只有一个元素，所以实例数据区的大小只有8字节。如果我们示例中的long型数组变为两个元素，那么实例数据区的大小就会变为16字节，以此类推................。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;关闭指针压缩  -XX:-UseCompressedOops&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.14919354838709678&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rrKkFvaCtPYvpI7x4FYk4eibF6d4NnXuGr365gsJ7WXXSVXWusuykxUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当关闭了指针压缩时，对象头中的MarkWord还是占用8个字节，但是类型指针从4个字节变为了8个字节。数组长度属性还是不变保持4个字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们发现是实例数据区与对象头之间发生了对齐填充。大家还记得这是为什么吗？？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们前边在字段重排列小节介绍了三种字段排列规则在这里继续适用：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;规则1&lt;/code&gt;：如果一个字段占用&lt;code&gt;X&lt;/code&gt;个字节，那么这个字段的偏移量OFFSET需要对齐至&lt;code&gt;NX&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;规则2&lt;/code&gt;：在开启了压缩指针的64位JVM中，Java类中的第一个字段的OFFSET需要对齐至&lt;code&gt;4N&lt;/code&gt;，在关闭压缩指针的情况下类中第一个字段的OFFSET需要对齐至&lt;code&gt;8N&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里基本数组类型的实例数据区中是long型，在关闭指针压缩的情况下，根据规则1和规则2需要对齐至8的倍数，所以要在其与对象头之间填充4个字节，达到内存对齐的目的，起始地址变为&lt;code&gt;24&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8.2 引用类型数组的内存布局&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6774193548387096&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rJsDCu7IWm5Lp5iaW2XTDpfRfQq8Fhuf4wGqPcgc2d7agzX7VGZhNxkg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;引用类型数组的内存布局.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图表示的是引用类型数组在内存中的布局，引用类型数组在JVM中用&lt;code&gt;objArrayOop&lt;/code&gt;结构体表示，基本类型数组类型元信息用&lt;code&gt;ObjArrayKlass &lt;/code&gt;结构体表示。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样在引用类型数组的对象头中也会有一个&lt;code&gt;4字节&lt;/code&gt;大小用来表示数组长度的部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还是分别以开启指针压缩和关闭指针压缩两种情况，通过下面的例子来进行说明：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ReferenceArrayLayout&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;char&lt;/span&gt; a;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; b;&lt;br/&gt;    &lt;span&gt;short&lt;/span&gt; c;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;ReferenceArrayLayout[] referenceArrayLayout = &lt;span&gt;new&lt;/span&gt; ReferenceArrayLayout[&lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;开启指针压缩 -XX:+UseCompressedOops&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1782258064516129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rI0EhfK0wH5ZBVhiaeHn6PNB7xIhtpjgIEbGw5yWHstINGM9brJqh2KQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引用数组类型内存布局与基础数组类型内存布局最大的不同在于它们的实例数据区。由于开启了压缩指针，所以对象引用占用内存大小为&lt;code&gt;4个字节&lt;/code&gt;，而我们示例中引用数组只包含一个引用元素，所以这里实例数据区中只有4个字节。相同的到道理，如果示例中的引用数组包含的元素变为两个引用元素，那么实例数据区就会变为8个字节，以此类推......。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后由于Java对象需要内存对齐至&lt;code&gt;8的倍数&lt;/code&gt;，所以在该引用数组的实例数据区后填充了4个字节。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;关闭指针压缩 -XX:-UseCompressedOops&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.16129032258064516&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rqryHvFaRNvVKp50Hb27F97WroKVW73r2sHr1gxTWHT5bU5WBn8LrKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当关闭压缩指针时，对象引用占用内存大小变为了&lt;code&gt;8个字节&lt;/code&gt;，所以引用数组类型的实例数据区占用了8个字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据字段重排列规则2，在引用数组类型对象头与实例数据区中间需要填充&lt;code&gt;4个字节&lt;/code&gt;以保证内存对齐的目的。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文笔者详细介绍了Java普通对象以及数组类型对象的内存布局，以及相关对象占用内存大小的计算方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以及在对象内存布局中的实例数据区字段重排列的三个重要规则。以及后边由字节的对齐填充引出来的false sharding问题，还有Java8为了解决false sharding而引入的@Contented注解的原理及使用方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了讲清楚内存对齐的底层原理，笔者还花了大量的篇幅讲解了内存的物理结构以及CPU读写内存的完整过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后又由内存对齐引出了压缩指针的工作原理。由此我们知道进行内存对齐的四个原因：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;CPU访问性能&lt;/code&gt;：当CPU访问内存对齐的地址时，可以通过一个read transaction读取一个字长（word size）大小的数据出来。否则就需要两个read transaction。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;原子性&lt;/code&gt;：CPU可以原子地操作一个对齐的word size memory。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;尽可能利用CPU缓存&lt;/code&gt;：内存对齐可以使对象或者字段尽可能的被分配到一个缓存行中，避免跨缓存行存储，导致CPU执行效率减半。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;提升压缩指针的内存寻址空间：&lt;/code&gt; 对象与对象之间的内存对齐，可以使我们在64位系统中利用32位对象引用将内存寻址空间提升至32G。既降低了对象引用的内存占用，又提升了内存寻址空间。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本文中我们顺带还介绍了和内存布局相关的几个JVM参数：-XX:+UseCompressedOops&lt;code&gt;,&lt;/code&gt; -XX +CompactFields &lt;code&gt;,&lt;/code&gt;-XX:-RestrictContended &lt;code&gt;,&lt;/code&gt;-XX:ContendedPaddingWidth&lt;code&gt;,&lt;/code&gt; -XX:ObjectAlignmentInBytes。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后感谢大家能看到这里，我们下篇文章再见~~~&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e36fd489d5285043358f1a8ea575ac4f</guid>
<title>[推荐] 我的命令行开发环境 ❤️</title>
<link>https://toutiao.io/k/hjda293</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-body&quot;&gt;
  &lt;p&gt;常言道，工欲善其事、必先利其器，熟练一套高效且趁手的工具，对开发工作的重要性不言而喻。&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;marked&quot;&gt;本文分享我的命令行开发环境，文章较长，配图较多&lt;/span&gt;，
其中几处详细内容，已将其折叠起来，读者可视兴趣展开阅读。&lt;/p&gt;

&lt;p&gt;命令行工具非常多，称得上神器的，提炼为以下四个：&lt;/p&gt;





&lt;p&gt;我选择工具的标准是：&lt;span class=&quot;marked&quot;&gt;美、快、爽&lt;/span&gt;。&lt;/p&gt;
      &lt;h4 id=&quot;终端程序--alacritty&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          终端程序 — Alacritty &lt;a href=&quot;#终端程序--alacritty&quot; class=&quot;heading-anchor&quot;&gt;¶&lt;/a&gt;
        
        &lt;/span&gt;
      &lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/alacritty/alacritty&quot; target=&quot;_blank&quot;&gt;Alacritty&lt;/a&gt; 是一款 rust 编写的、
启用 GPU 加速的终端模拟器。&lt;/p&gt;

&lt;p&gt;天下武功，唯快不破，它唯一特点就是：快。&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-70&quot; src=&quot;/assets/images/posts/commandline-dev-tools/1.1-alacritty.png-small.svg&quot; data-src=&quot;/assets/images/posts/commandline-dev-tools/1.1-alacritty.png&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图1.1 alacritty 终端模拟器
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;在 2018 年之前，我一直在用流行的 &lt;a href=&quot;https://iterm2.com/&quot; target=&quot;_blank&quot;&gt;iterm 2&lt;/a&gt;。
不过，自从邂逅 alacritty 后，就从未离开。相比 iterm2 来说，alacritty 的功能要简单的多，
但是，它足够快。&lt;/p&gt;

&lt;p&gt;下面的动图展示了同时在 alacritty（左） 和 iterm2 中用 &lt;a href=&quot;https://github.com/atanunq/viu&quot; target=&quot;_blank&quot;&gt;viu&lt;/a&gt;
打开一张图片时的渲染速度：&lt;/p&gt;

&lt;figure&gt; 
  &lt;img id=&quot;pic-1-2&quot; class=&quot;post-img lazyload max-width-100&quot; src=&quot;/assets/images/posts/commandline-dev-tools/1.2-alacritty-vs-iterm2-render-image.gif-small.svg&quot; data-src=&quot;/assets/images/posts/commandline-dev-tools/1.2-alacritty-vs-iterm2-render-image.gif&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图1.2 左边 alacritty 和 右边 iterm2 渲染图片对比
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;作为终端，一定要颜值在线。 Alacritty 也支持配色，可参考 &lt;a href=&quot;https://github.com/eendroroy/alacritty-theme&quot; target=&quot;_blank&quot;&gt;alacritty-theme&lt;/a&gt; ，
我用的配色是 &lt;a href=&quot;https://github.com/alebelcor/alacritty-snazzy&quot; target=&quot;_blank&quot;&gt;snazzy&lt;/a&gt; ，从未换过。
此外，选择一款 &lt;span class=&quot;marked&quot;&gt;等宽的&lt;/span&gt; 字体，对终端的整体颜值至关重要，我一直在用的字体是 InconsolataLGC Nerd Font。&lt;/p&gt;

&lt;p&gt;我对 alacritty 的功能需求非常少，只要它够快，够漂亮 就好。比如说，我是没有用终端 Tab 页的习惯的，
这些事情 &lt;a href=&quot;#终端复用--tmux&quot;&gt;tmux&lt;/a&gt; 完全可以搞定。作为终端模拟器，简单快速就好！&lt;/p&gt;
    
      &lt;h4 id=&quot;shell--fish&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          Shell – Fish &lt;a href=&quot;#shell--fish&quot; class=&quot;heading-anchor&quot;&gt;¶&lt;/a&gt;
        
        &lt;/span&gt;
      &lt;/h4&gt;

&lt;p&gt;无独有偶，选择 &lt;a href=&quot;https://fishshell.com/&quot; target=&quot;_blank&quot;&gt;fish shell&lt;/a&gt; 的原因，仍然是它更快，同时也更轻。&lt;/p&gt;

&lt;p&gt;这里所说的「快」，是指 shell 的 &lt;span class=&quot;marked&quot;&gt;prompt 加载快&lt;/span&gt;，
如下图中，进入 fish 几乎是没有延迟的：&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-70&quot; src=&quot;/assets/images/posts/commandline-dev-tools/2.1-fish-prompt-fast.gif-small.svg&quot; data-src=&quot;/assets/images/posts/commandline-dev-tools/2.1-fish-prompt-fast.gif&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图2.1 配置的少的 shell 才快
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;当然，不带任何配置的 zsh 和 bash 也很快。 但是，为了酷炫的颜值、快捷的功能，
许多 zsh 用户都会搭配类似 &lt;a href=&quot;https://ohmyz.sh&quot; target=&quot;_blank&quot;&gt;oh-my-zsh&lt;/a&gt; 的东西，
或者是搞一大堆配置，这都会让 shell 变慢。&lt;/p&gt;

&lt;p&gt;但是真正的不同在于，&lt;span class=&quot;marked&quot;&gt;fish 是开箱即用的&lt;/span&gt;，大可不必自己折腾那么多。
比如 fish 的一大特色是自带补全暗示功能:&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-55&quot; src=&quot;/assets/images/posts/commandline-dev-tools/2.2-fish-hint.jpg-small.svg&quot; data-src=&quot;/assets/images/posts/commandline-dev-tools/2.2-fish-hint.jpg&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图2.2 fish 自带的 hint 提示
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;还有自带的 ManPage 补全功能等等，这一切都无需插件。&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-60&quot; src=&quot;/assets/images/posts/commandline-dev-tools/2.3-fish-complete.jpg-small.svg&quot; data-src=&quot;/assets/images/posts/commandline-dev-tools/2.3-fish-complete.jpg&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图2.3 fish 自带的 ManPage 补全功能
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;因此 fish 的插件要相对少得多。我在用的也很少:&lt;/p&gt;



&lt;p&gt;除去工具本身外，unix 中 &lt;a href=&quot;https://tiswww.cwru.edu/php/chet/readline/rluserman.html&quot; target=&quot;_blank&quot;&gt;emacs 风格的 shell 快捷键&lt;/a&gt; 也值得推荐，
它们在常见的 shell (fish, zsh, bash) 中都是通用的，其中部分快捷键甚至可以在网页文本框中使用。&lt;/p&gt;

&lt;details&gt;
  &lt;summary&gt;
  Emacs 风格的 shell 快捷键 - 光标移动和编辑
&lt;/summary&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C-a&lt;/code&gt; 光标回到行首, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C-e&lt;/code&gt; 光标回到行尾&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C-f&lt;/code&gt; 光标向前移动一个字符，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C-b&lt;/code&gt; 光标向后移动一个字符&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Alt-f&lt;/code&gt; 光标向前移动一个单词, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Alt-b&lt;/code&gt; 光标向后移动一个单词&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C-k&lt;/code&gt; 清掉光标后面的部分, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C-d&lt;/code&gt; 删掉光标后的一个字符 或 退出&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C-l&lt;/code&gt; 相当于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;clear&lt;/code&gt; 命令，清屏&lt;/li&gt;
  &lt;/ul&gt;

  &lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-60&quot; src=&quot;/assets/images/posts/commandline-dev-tools/2.5-shell-unix-key.gif-small.svg&quot; data-src=&quot;/assets/images/posts/commandline-dev-tools/2.5-shell-unix-key.gif&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图2.5 unix 默认的 emacs 风格快捷键
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
  &lt;p/&gt;

  &lt;p&gt;甚至，当命令非常长的时候，还可以跳入编辑器来编辑命令
（ &lt;a href=&quot;https://github.com/hit9/dotfiles/blob/4b80a9048b7204ce6fb30dcd6d4f7d597696cd05/fish/config.fish#L72&quot; target=&quot;_blank&quot;&gt;fish 配置&lt;/a&gt; ）：&lt;/p&gt;

  &lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-80&quot; src=&quot;/assets/images/posts/commandline-dev-tools/2.7-shell-unix-ctrl-x.gif-small.svg&quot; data-src=&quot;/assets/images/posts/commandline-dev-tools/2.7-shell-unix-ctrl-x.gif&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图2.7 调用编辑器来编辑长命令
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
  &lt;p/&gt;

&lt;/details&gt;

&lt;details&gt;
  &lt;summary&gt;
    Emacs 风格的 shell 快捷键 - 回翻历史命令
  &lt;/summary&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C-p&lt;/code&gt; 向上翻历史命令， &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C-n&lt;/code&gt; 向下翻历史命令&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C-r&lt;/code&gt; 向上搜索历史命令 (顺手推荐搜索命令历史的增强工具 &lt;a href=&quot;https://github.com/junegunn/fzf&quot; target=&quot;_blank&quot;&gt;fzf&lt;/a&gt;)&lt;/li&gt;
  &lt;/ul&gt;

  &lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-80&quot; src=&quot;/assets/images/posts/commandline-dev-tools/2.6-shell-fzf-ctrl-r.jpg-small.svg&quot; data-src=&quot;/assets/images/posts/commandline-dev-tools/2.6-shell-fzf-ctrl-r.jpg&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图2.6 FZF C-R 搜索历史命令
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
  &lt;p/&gt;

&lt;/details&gt;

&lt;details&gt;
  &lt;summary&gt;
    Emacs 风格的 shell 快捷键 - 进程挂起
  &lt;/summary&gt;

  

  &lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-70&quot; src=&quot;/assets/images/posts/commandline-dev-tools/2.6.1-shell-fg.gif-small.svg&quot; data-src=&quot;/assets/images/posts/commandline-dev-tools/2.6.1-shell-fg.gif&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图2.6.1 挂起当前进程到后台
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
  &lt;p/&gt;

&lt;/details&gt;

&lt;p&gt;其实，主流的 shell (fish, zsh, bash) 也都支持 vi 风格的操作模式。
虽然身为 vim 用户，之所以在 shell 中选择 emacs 风格，是因为它在大部分情况下都是
&lt;span class=&quot;marked&quot;&gt;默认的&lt;/span&gt; 设定。&lt;/p&gt;

&lt;p&gt;在带过的每一支技术团队中，我总会提醒小伙伴们要勤用这些 emacs 风格的快捷键，它看似麻烦，
但是一旦熟练起来，一定比鼠标快。只要刻意地去用，就会熟起来，将大有裨益。&lt;/p&gt;
    
      &lt;h4 id=&quot;终端复用--tmux&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          终端复用 — Tmux &lt;a href=&quot;#终端复用--tmux&quot; class=&quot;heading-anchor&quot;&gt;¶&lt;/a&gt;
        
        &lt;/span&gt;
      &lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/tmux/tmux&quot; target=&quot;_blank&quot;&gt;Tmux&lt;/a&gt; 是一款终端复用神器，不必多言，它早已声名远扬。&lt;/p&gt;

&lt;p&gt;简单讲，终端复用就是在一个终端中，可以开多个 shell 会话。
一些现代的终端应用，比如 &lt;a href=&quot;https://iterm2.com/documentation-general-usage.html&quot; target=&quot;_blank&quot;&gt;iterm2&lt;/a&gt;，
也支持 Tab 页 和 切屏，不过它们在 tmux 的颜值和效率面前，都相形见绌。&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-70&quot; src=&quot;/assets/images/posts/commandline-dev-tools/3.1-tmux.gif-small.svg&quot; data-src=&quot;/assets/images/posts/commandline-dev-tools/3.1-tmux.gif&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图3.1 tmux 常用的功能
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;几乎所有的 tmux 功能，都需要按一下 &lt;span class=&quot;marked&quot;&gt;前缀键&lt;/span&gt; 来触发，
默认的是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C-b&lt;/code&gt;，我则是习惯用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C-a&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;我常用的 tmux 功能有：面板、窗口、Copy 模式、会话保持 还有 两三个小插件。&lt;/p&gt;

&lt;details&gt;
  &lt;summary&gt;
    tmux - 面板和窗口快捷键
 &lt;/summary&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C-a &quot;&lt;/code&gt; 横向打开一个面板&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C-a %&lt;/code&gt; 纵向打开一个面板&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C-a o&lt;/code&gt; 在面板之间切换&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C-a q&lt;/code&gt; 展示当前窗口的所有面板的标号&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C-a z&lt;/code&gt; 放大或缩小一个窗口&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C-a c&lt;/code&gt; 创建一个窗口&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C-a n&lt;/code&gt; 切换下一个窗口&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C-a p&lt;/code&gt; 切换上一个窗口&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;作为一枚 vim 党，我习惯用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hjkl&lt;/code&gt; 来切换面板，例如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C-a h&lt;/code&gt; 会跳入右边的面板、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C-a j&lt;/code&gt; 会跳入下边的面板 等
（ &lt;a href=&quot;https://github.com/hit9/dotfiles/blob/9c78c08a14c8cbf25dbd40aebdd25049b2b987b5/tmux/tmux.conf#L37&quot; target=&quot;_blank&quot;&gt;相关 tmux 配置&lt;/a&gt; ）。&lt;/p&gt;

&lt;/details&gt;

&lt;details&gt;
  &lt;summary&gt;
    tmux - copy 模式
  &lt;/summary&gt;

  &lt;p&gt;刚进入 tmux 的同学，常会遇到一个问题：如何滚屏 ?&lt;/p&gt;

  &lt;p&gt;在 tmux 中可以 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C-a [&lt;/code&gt; 来进入一个叫做 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;copy mode&lt;/code&gt; 的模式，
然后就可以用方向键滚屏了。 但是方向键太难用了，可以设定 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;copy mode&lt;/code&gt; 下采用 vim 键位
( &lt;a href=&quot;https://github.com/hit9/dotfiles/blob/9c78c08a14c8cbf25dbd40aebdd25049b2b987b5/tmux/tmux.conf#L62&quot; target=&quot;_blank&quot;&gt;相关配置&lt;/a&gt; )。&lt;/p&gt;

  &lt;p&gt;在 copy 模式下，vim 键位可谓如鱼得水：&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C-u&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C-d&lt;/code&gt; 来上下翻页&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hjkl&lt;/code&gt; 来上下左右移动光标&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; 来跳到行首、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$&lt;/code&gt; 来跳到行尾&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;w&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt; 来按单词为单位前后移动光标&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F&lt;/code&gt; 来前后搜索字符以跳跃光标&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;v&lt;/code&gt; 开始选择一块区域，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;V&lt;/code&gt; 开始按行选择一块区域&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;y&lt;/code&gt; 以拷贝内容，并退出 copy 模式, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;q&lt;/code&gt; 也可退出 copy 模式&lt;/li&gt;
  &lt;/ul&gt;

  &lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-70&quot; src=&quot;/assets/images/posts/commandline-dev-tools/3.2-tmux-copy-mode.gif-small.svg&quot; data-src=&quot;/assets/images/posts/commandline-dev-tools/3.2-tmux-copy-mode.gif&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图3.2 tmux 的 copy 模式
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
  &lt;p/&gt;

  &lt;p&gt;还可以在 copy 模式下调整面板大小，
仍然采用 vim 风格的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C-hjkl&lt;/code&gt; ，是不是很有趣？
(&lt;a href=&quot;https://github.com/hit9/dotfiles/blob/9c78c08a14c8cbf25dbd40aebdd25049b2b987b5/tmux/tmux.conf#L43&quot; target=&quot;_blank&quot;&gt;相关配置&lt;/a&gt;)&lt;/p&gt;

  &lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-70&quot; src=&quot;/assets/images/posts/commandline-dev-tools/3.3-tmux-copy-mode-scale-panels.gif-small.svg&quot; data-src=&quot;/assets/images/posts/commandline-dev-tools/3.3-tmux-copy-mode-scale-panels.gif&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图3.3 tmux 的 copy 模式下调整面板的大小
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
  &lt;p/&gt;

&lt;/details&gt;

&lt;details&gt;
  &lt;summary&gt;
    tmux - 会话保持
  &lt;/summary&gt;

  &lt;p&gt;Tmux 还有一个非常棒的功能，就是会话保持。简单来说，就是可以暂时保存工作环境，稍后可重新进入。
这个功能对于需要服务器跑脚本这种事情，非常合适，不必再担心 ssh 断掉后进程断掉。&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C-a d&lt;/code&gt; 临时离开当前 tmux 会话 (detach 之意)&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tmux a&lt;/code&gt; 重新进入 tmux 会话 (attach 之意)&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;甚至如果把整个终端模拟器退出，仍然可以重新进去，工作环境不会丢失。
当我的 alacritty 出现讨厌的闪屏之类的小问题时，我会直接 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cmd-q&lt;/code&gt; 杀掉终端，重启终端后即可直接回到 tmux 中。
前面的 &lt;a href=&quot;#pic-1-2&quot;&gt;图1.2&lt;/a&gt; 就是在两个不同的终端应用中运行同一个 tmux 会话，两边的交互完全是同步进行的。&lt;/p&gt;

  &lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-70&quot; src=&quot;/assets/images/posts/commandline-dev-tools/3.4-tmux-d-a.gif-small.svg&quot; data-src=&quot;/assets/images/posts/commandline-dev-tools/3.4-tmux-d-a.gif&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图3.4 tmux 的会话临时退出和恢复
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
  &lt;p/&gt;

&lt;/details&gt;

&lt;details&gt;
  &lt;summary&gt;
    tmux - 用到的三个小插件
  &lt;/summary&gt;

  &lt;p&gt;Tmux 拥有着 &lt;a href=&quot;https://github.com/rothgar/awesome-tmux&quot; target=&quot;_blank&quot;&gt;丰富的社区生态&lt;/a&gt;，
其中不乏一些 “花里胡哨” 的插件，我不怎么用，状态栏比较干净。
比较喜欢的插件则是这三个：&lt;/p&gt;

  

&lt;/details&gt;

&lt;p&gt;Tmux 的可配置性很强，我的建议是，&lt;span class=&quot;marked&quot;&gt;多用默认的快捷键，只做少许的自定义快捷键&lt;/span&gt;，
毕竟我们许多时候会在服务器等其他环境下使用它。&lt;/p&gt;
    
      &lt;h4 id=&quot;编辑器--vim&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          编辑器 — Vim &lt;a href=&quot;#编辑器--vim&quot; class=&quot;heading-anchor&quot;&gt;¶&lt;/a&gt;
        
        &lt;/span&gt;
      &lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://www.vim.org/&quot; target=&quot;_blank&quot;&gt;Vim&lt;/a&gt; 有着「编辑器之神」的美誉，
如果把程序员比作武林中的侠客，那么 vim 就是倚天屠龙的利器。
已诞生 30 余年, 宝刀虽老，但是在 2022 年的今天，&lt;span class=&quot;marked&quot;&gt;它的文本编辑效率仍尚无敌手&lt;/span&gt;。&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-70&quot; src=&quot;/assets/images/posts/commandline-dev-tools/4.1-vim.jpg-small.svg&quot; data-src=&quot;/assets/images/posts/commandline-dev-tools/4.1-vim.jpg&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图4.1 我的 vim 编辑器的样子
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;相对于现代编辑器 或 IDE 来说，上手 vim 的难度曲线要陡峭许多。
据说有许多新手在刚刚进入 vim 时，不得不关机或重启终端程序来退出它 …&lt;/p&gt;

&lt;p&gt;不过，这是个先苦后甜的过程。&lt;span class=&quot;marked&quot;&gt;
如果前面花功夫去学，坚持用下去，甚至形成肌肉记忆，就会爱上它，而 vim 也会在后期带来惊喜&lt;/span&gt;。
熟练之后，自会入境，享受 「指随心动、码字如飞」的感觉。&lt;/p&gt;

&lt;p&gt;Vim 中的学问很多，我用 vim 码字也蛮多年了，但也远远不敢妄称精通，只能说是经常用。&lt;/p&gt;

&lt;p&gt;但是，&lt;span class=&quot;marked&quot;&gt;只需要了解 vim 中少部分的知识点，就足够完成大部分的编辑工作&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;我将基本内容总结为下面几块。&lt;/p&gt;

&lt;details&gt;
  &lt;summary&gt;
  Vim - 5 种常用的模式
&lt;/summary&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Normal&lt;/code&gt; 普通模式，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Esc&lt;/code&gt; 或 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C-c&lt;/code&gt; 进入&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Visual&lt;/code&gt; 可视模式，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;v, V, C-v&lt;/code&gt; 等键进入&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Insert&lt;/code&gt; 插入模式，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i, I, a, A, o, O&lt;/code&gt; 等键进入&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Command&lt;/code&gt; 命令模式，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:&lt;/code&gt; 进入，常用的有: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:w&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:q&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:wq&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:%s&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;q:&lt;/code&gt; 等&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Replace&lt;/code&gt; 替换模式，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R&lt;/code&gt; 进入&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;普通模式是最常用的模式，其他模式都要从普通模式进入。&lt;/p&gt;

  &lt;p&gt;推荐采用 &lt;a href=&quot;https://github.com/itchyny/lightline.vim&quot; target=&quot;_blank&quot;&gt;lightline&lt;/a&gt; 插件，
可以更好的看到当前的 vim 模式。&lt;/p&gt;

  &lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-90&quot; src=&quot;/assets/images/posts/commandline-dev-tools/4.1.1-vim-lightline.png-small.svg&quot; data-src=&quot;/assets/images/posts/commandline-dev-tools/4.1.1-vim-lightline.png&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图4.1.1 lightline 插件效果图
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
  &lt;p/&gt;

&lt;/details&gt;

&lt;details id=&quot;vim-motion&quot;&gt;
  &lt;summary&gt;
  Vim - 快速移动光标 motion
&lt;/summary&gt;

  &lt;ul&gt;
    &lt;li&gt;字符粒度：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;h j k l&lt;/code&gt; 左、下、上、右&lt;/li&gt;
    &lt;li&gt;单词粒度：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;w W e E&lt;/code&gt; 向前，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b B&lt;/code&gt; 向后&lt;/li&gt;
    &lt;li&gt;行内移动：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; 行首，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$&lt;/code&gt; 行尾，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f{c}&lt;/code&gt; 向前搜字符、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F{c}&lt;/code&gt; 向后搜字符 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;按块移动：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(  )&lt;/code&gt; 句子、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{  }&lt;/code&gt; 段落 等&lt;/li&gt;
    &lt;li&gt;翻页：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C-u&lt;/code&gt; 向上翻页，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C-d&lt;/code&gt; 向下翻页&lt;/li&gt;
    &lt;li&gt;全文：文首 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gg&lt;/code&gt;，文尾 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;G&lt;/code&gt; ，等价于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:0&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:$&lt;/code&gt;&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;这些键位，&lt;span class=&quot;marked&quot;&gt;最好结合其英文含义来理解&lt;/span&gt;，
比如说 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;w&lt;/code&gt; 是 “word” 的意思，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e&lt;/code&gt; 是 “end” 的意思，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt; 是 “backward” 的意思，
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt; 是 “find” 的意思，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C-u&lt;/code&gt; 是 “up” 的意思 等等。&lt;/p&gt;

  &lt;p&gt;悄悄地说，我其实并未真正去记 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hjkl&lt;/code&gt; 到底哪个向上、哪个向下，但是手熟了之后，
手放在键盘上自然就可以运用起来。这和许多人背不过键盘布局，但是仍然可以熟练打字是一样的。
&lt;span class=&quot;marked&quot;&gt;我认为 vim 的键位更多地依赖于熟练度，而不是死记硬背&lt;/span&gt;。&lt;/p&gt;

  &lt;p&gt;我比较常用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt; 跳转，有一款加强 vim 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt; 效果的插件，叫做
&lt;a href=&quot;https://github.com/unblevable/quick-scope&quot; target=&quot;_blank&quot;&gt;quick-scope&lt;/a&gt;，
它会自动高亮一些字符，方便 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt; 去跳转，小巧有趣。&lt;/p&gt;

  &lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-80&quot; src=&quot;/assets/images/posts/commandline-dev-tools/4.3.1.1-vim-quick-scope.gif-small.svg&quot; data-src=&quot;/assets/images/posts/commandline-dev-tools/4.3.1.1-vim-quick-scope.gif&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图4.3.1.1 vim 插件 quick-scope 高亮辅助 f 跳转效果图
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
  &lt;p/&gt;

  &lt;p&gt;对于行内跳转光标，有一款插件叫做
&lt;a href=&quot;https://github.com/jayflo/vim-skip&quot; target=&quot;_blank&quot;&gt;vim-ship&lt;/a&gt; ，
它以 &lt;span class=&quot;marked&quot;&gt;二分的形式&lt;/span&gt; 移动光标，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s&lt;/code&gt; 向前移动到一半，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;S&lt;/code&gt; 向后移动一半，
是不是很聪明！正是由于这个插件，我经常使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s&lt;/code&gt; 来二分跳进光标，可以很快地靠近编辑目标附近。&lt;/p&gt;

  &lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-80&quot; src=&quot;/assets/images/posts/commandline-dev-tools/4.3.1.2-vim-skip.gif-small.svg&quot; data-src=&quot;/assets/images/posts/commandline-dev-tools/4.3.1.2-vim-skip.gif&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图4.3.1.2 vim 插件 vim-skip 的二分跳跃效果
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
  &lt;p/&gt;

  &lt;p&gt;这些在 vim 中都叫做 &lt;a href=&quot;http://vimdoc.sourceforge.net/htmldoc/motion.html&quot;&gt;motion&lt;/a&gt;，
它的重要之处不仅仅在于光标移动本身，还可以
&lt;span class=&quot;marked&quot;&gt;和数字、文本编辑、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;visual&lt;/code&gt;&lt;/span&gt; 模式相结合，举例来说：&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;可以 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;4j&lt;/code&gt; 来直接向下移动 4 行、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;4e&lt;/code&gt; 来向前跳 4 个单词 等&lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;可以用 motion 来帮助选择文本块，比如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vaw&lt;/code&gt; 会选中一个单词、
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;v&lt;/code&gt; 进入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;visual&lt;/code&gt; 模式后可以 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hl&lt;/code&gt; 左右调整区域范围 等等&lt;/p&gt;

      &lt;figure&gt; 
&lt;img class=&quot;post-img lazyload max-width-80&quot; src=&quot;/assets/images/posts/commandline-dev-tools/4.3.2.1-vim-motion-visual-1.gif-small.svg&quot; data-src=&quot;/assets/images/posts/commandline-dev-tools/4.3.2.1-vim-motion-visual-1.gif&quot; alt=&quot;&quot;/&gt;
    
     
     &lt;figcaption&gt;图4.3.2.1 vim 中 单词粒度 motion 向左向右选中一块区域
       
     &lt;/figcaption&gt;
     
   
  &lt;/figure&gt;
      &lt;p/&gt;

      &lt;figure&gt; 
&lt;img class=&quot;post-img lazyload max-width-80&quot; src=&quot;/assets/images/posts/commandline-dev-tools/4.3.2.2-vim-motion-visual-2.gif-small.svg&quot; data-src=&quot;/assets/images/posts/commandline-dev-tools/4.3.2.2-vim-motion-visual-2.gif&quot; alt=&quot;&quot;/&gt;
    
     
     &lt;figcaption&gt;图4.3.2.2 vim 中 motion 结合 C-v 调整一块区域的选择
       
     &lt;/figcaption&gt;
     
   
  &lt;/figure&gt;
      &lt;p/&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;结合文本编辑，例如：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;de&lt;/code&gt; 可以删除当前位置到单词尾巴的内容，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c$&lt;/code&gt; 可以清除当前位置到行尾的内容，
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c0&lt;/code&gt; 可以清除到行首的内容等。&lt;/p&gt;

      &lt;figure&gt; 
&lt;img class=&quot;post-img lazyload max-width-80&quot; src=&quot;/assets/images/posts/commandline-dev-tools/4.3.3.1-vim-motion-edit.gif-small.svg&quot; data-src=&quot;/assets/images/posts/commandline-dev-tools/4.3.3.1-vim-motion-edit.gif&quot; alt=&quot;&quot;/&gt;
    
     
     &lt;figcaption&gt;图4.3.3.1 vim 中 de 和 d$ 的效果
       
     &lt;/figcaption&gt;
     
   
  &lt;/figure&gt;
      &lt;p/&gt;

      &lt;p&gt;有一类 motion 叫做 文本对象 &lt;a href=&quot;https://gist.github.com/webdevel/4050973ffcb19edb07f72540c71ae38f#text-objects&quot; target=&quot;_blank&quot;&gt;text objects&lt;/a&gt;，
例如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ciw&lt;/code&gt; 可以编辑一个单词 等等。&lt;/p&gt;

      &lt;figure&gt; 
&lt;img class=&quot;post-img lazyload max-width-80&quot; src=&quot;/assets/images/posts/commandline-dev-tools/4.3.3.1-vim-text-object-ciw.gif-small.svg&quot; data-src=&quot;/assets/images/posts/commandline-dev-tools/4.3.3.1-vim-text-object-ciw.gif&quot; alt=&quot;&quot;/&gt;
    
     
     &lt;figcaption&gt;图4.3.3.1 vim 文本对象 - ciw 重新编辑一个单词的实例
       
     &lt;/figcaption&gt;
     
   
  &lt;/figure&gt;
      &lt;p/&gt;

      &lt;p&gt;有一款插件叫做 &lt;a href=&quot;https://github.com/wellle/targets.vim&quot; target=&quot;_blank&quot;&gt;targets.vim&lt;/a&gt; ，它极大地扩充了可用的文本对象。
比如说 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vi&quot;&lt;/code&gt; 可选中双引号之内的内容，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;di)&lt;/code&gt; 可删除括号内的内容等等。&lt;/p&gt;

      &lt;figure&gt; 
&lt;img class=&quot;post-img lazyload max-width-80&quot; src=&quot;/assets/images/posts/commandline-dev-tools/4.3.3.2-vim-text-object-targets.gif-small.svg&quot; data-src=&quot;/assets/images/posts/commandline-dev-tools/4.3.3.2-vim-text-object-targets.gif&quot; alt=&quot;&quot;/&gt;
    
     
     &lt;figcaption&gt;图4.3.3.2 vim 文本对象 targets.vim 插件- vi&quot; 和 vi) 的效果
       
     &lt;/figcaption&gt;
     
   
  &lt;/figure&gt;
      &lt;p/&gt;
    &lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;我使用 vim-skip 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s&lt;/code&gt; 二分跳进 和  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0 $&lt;/code&gt; 的频率是很高的，
因为它们可以在行内 &lt;span class=&quot;marked&quot;&gt;大幅度地跳转光标&lt;/span&gt;。
当光标靠近想要编辑的文本时，才开始采用小粒度移动方式（按字符或者单词）。
我也几乎不用段落跳转 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;}&lt;/code&gt;，而是直接使用翻页 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C-u/d&lt;/code&gt;，并不是说后者更好，而是说习惯一种就好。
&lt;span class=&quot;marked&quot;&gt; 人总是很难记住很多东西的，更多的情况是，用起来一些顺手了，就会经常用它们 &lt;/span&gt;。&lt;/p&gt;

&lt;/details&gt;

&lt;details&gt;
  &lt;summary&gt;
  Vim - 快速编辑文本
&lt;/summary&gt;

  &lt;p&gt;常用编辑快键位：&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; 向右插入，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i&lt;/code&gt; 向左插入，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;o&lt;/code&gt; 向下插入，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;O&lt;/code&gt; 向上插入&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt; 删除一个字符，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d&lt;/code&gt; 删除选中文本，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dd&lt;/code&gt; 删除一行&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;r&lt;/code&gt; 替换当前字符, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R&lt;/code&gt; 进入替换模式&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;u&lt;/code&gt; 撤销最近一次编辑&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;J&lt;/code&gt; 把下一行提上来，合到当前行&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c&lt;/code&gt; 清空重新编辑、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cc&lt;/code&gt; 清空当前行&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt; 向右递进、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt; 向左递进, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;gt;&amp;gt;&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;&amp;lt;&lt;/code&gt; 缩进一行&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;y&lt;/code&gt; 拷贝选中区域，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yy&lt;/code&gt; 拷贝一行，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p&lt;/code&gt; 粘贴&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;可以发现，对于一些操作，连续两次即可操作一行，例如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dd&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cc&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yy&lt;/code&gt; 等：&lt;/p&gt;

  &lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-70&quot; src=&quot;/assets/images/posts/commandline-dev-tools/4.4.1.1-vim-dd-cc-shit.gif-small.svg&quot; data-src=&quot;/assets/images/posts/commandline-dev-tools/4.4.1.1-vim-dd-cc-shit.gif&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图4.4.1.1 Vim 中 dd, &amp;gt;&amp;gt;, cc 的操作效果
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
  &lt;p/&gt;

  &lt;p&gt;其中，一些编辑操作是可以结合数字使用，例如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;4x&lt;/code&gt; 可以连续删除 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;4&lt;/code&gt; 个字符。
也可以结合前面所说的 motion ，例如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c$&lt;/code&gt; 可以清掉到行尾的内容。
还可以结合 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;visual mode&lt;/code&gt;，例如选中一块区域后 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt; 来缩进 等等，不再展开。&lt;/p&gt;

  &lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-90&quot; src=&quot;/assets/images/posts/commandline-dev-tools/4.4.1.2-vim-visual-shift.gif-small.svg&quot; data-src=&quot;/assets/images/posts/commandline-dev-tools/4.4.1.2-vim-visual-shift.gif&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图4.4.1.2 Vim 中缩进一块选中区域
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
  &lt;p/&gt;

  &lt;p&gt;Vim 中也可以对多行编辑：&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;
      &lt;p&gt;比如要批量注释一段代码，可以 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C-v&lt;/code&gt; 进入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;visual mode&lt;/code&gt; ，然后 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;I&lt;/code&gt; 插入注释字符：&lt;/p&gt;

      &lt;figure&gt; 
&lt;img class=&quot;post-img lazyload max-width-90&quot; src=&quot;/assets/images/posts/commandline-dev-tools/4.4.2.1-vim-multiple-line-1.gif-small.svg&quot; data-src=&quot;/assets/images/posts/commandline-dev-tools/4.4.2.1-vim-multiple-line-1.gif&quot; alt=&quot;&quot;/&gt;
    
     
     &lt;figcaption&gt;图4.4.2.1 Vim 中 C-v 编辑多行，操作: C-v I ESC
       
     &lt;/figcaption&gt;
     
   
  &lt;/figure&gt;
      &lt;p/&gt;

      &lt;p&gt;单单对于注释多行来说，有一个更便捷的插件，叫做 &lt;a href=&quot;https://github.com/tpope/vim-commentary&quot; target=&quot;_blank&quot;&gt;vim-commentary&lt;/a&gt;，
可以直接选中多行，然后按 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\\&lt;/code&gt; 就可以了
( &lt;a href=&quot;https://github.com/hit9/dotfiles/blob/4b80a9048b7204ce6fb30dcd6d4f7d597696cd05/vim/vimrc#L288&quot; target=&quot;_blank&quot;&gt;相关key mapping 配置&lt;/a&gt; )&lt;/p&gt;

      &lt;figure&gt; 
&lt;img class=&quot;post-img lazyload max-width-90&quot; src=&quot;/assets/images/posts/commandline-dev-tools/4.4.2.2-vim-commentary.gif-small.svg&quot; data-src=&quot;/assets/images/posts/commandline-dev-tools/4.4.2.2-vim-commentary.gif&quot; alt=&quot;&quot;/&gt;
    
     
     &lt;figcaption&gt;图4.4.2.2 vim-commentary 快速注释插件
       
     &lt;/figcaption&gt;
     
   
  &lt;/figure&gt;
      &lt;p/&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;也可以把多行聚合成一行，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C-v&lt;/code&gt; 选中多行，然后 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;J&lt;/code&gt; 即可：&lt;/p&gt;

      &lt;figure&gt; 
&lt;img class=&quot;post-img lazyload max-width-90&quot; src=&quot;/assets/images/posts/commandline-dev-tools/4.4.2.3-vim-multiple-line-2.gif-small.svg&quot; data-src=&quot;/assets/images/posts/commandline-dev-tools/4.4.2.3-vim-multiple-line-2.gif&quot; alt=&quot;&quot;/&gt;
    
     
     &lt;figcaption&gt;图4.4.2.3 Vim 中聚合多行为一行，操作：C-v J
       
     &lt;/figcaption&gt;
     
   
  &lt;/figure&gt;
      &lt;p/&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;说到多行注释，vim 的世界中有一个出名的插件叫做
&lt;a href=&quot;https://github.com/terryma/vim-multiple-cursors&quot; target=&quot;_blank&quot;&gt;vim-multiple-cursors&lt;/a&gt; ，不过它已经年久失修，
而且性能贼差。我在用的是 &lt;a href=&quot;https://github.com/mg979/vim-visual-multi&quot; target=&quot;_blank&quot;&gt;vim-visual-multi&lt;/a&gt;，还是很快的。
它的一个优点在于，我们可以在多行编辑时运用 vim motion，比如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;w e b f&lt;/code&gt; 等。&lt;/p&gt;

      &lt;figure&gt; 
&lt;img class=&quot;post-img lazyload max-width-90&quot; src=&quot;/assets/images/posts/commandline-dev-tools/4.4.2.4-vim-visual-multi.gif-small.svg&quot; data-src=&quot;/assets/images/posts/commandline-dev-tools/4.4.2.4-vim-visual-multi.gif&quot; alt=&quot;&quot;/&gt;
    
     
     &lt;figcaption&gt;图4.4.2.4 vim-visual-multi 编辑多行的效果，操作: C-n tab fi a ESC
       
     &lt;/figcaption&gt;
     
   
  &lt;/figure&gt;
      &lt;p/&gt;
    &lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;另一类常见的编辑需求，是搜索和替换：&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/{text}&lt;/code&gt; 当前文档内向后搜索文本，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;?{text}&lt;/code&gt; 向前搜索文本&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt; 以继续下一个结果，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N&lt;/code&gt; 以回到上一个搜索结果&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:%s/a/b/&lt;/code&gt; 当前文档内全局替换 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; 到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt;&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;默认地，在 vim 中搜索文本，是没有高亮的，可以设置 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set hlsearch&lt;/code&gt; 。
有一个叫做 &lt;a href=&quot;https://github.com/markonm/traces.vim&quot; target=&quot;_blank&quot;&gt;traces.vim&lt;/a&gt; 的插件，
它可以实时地高亮搜索命中的部分。&lt;/p&gt;

  &lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-100&quot; src=&quot;/assets/images/posts/commandline-dev-tools/4.4.3.1-vim-traces.gif-small.svg&quot; data-src=&quot;/assets/images/posts/commandline-dev-tools/4.4.3.1-vim-traces.gif&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图4.4.3.1 vim-traces 实时显示搜索和替换效果
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
  &lt;p/&gt;

&lt;/details&gt;

&lt;details&gt;
  &lt;summary&gt;
  Vim - 窗口和标签页
&lt;/summary&gt;

  &lt;p&gt;Vim 也支持切屏和标签页，常用的操作有：&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:spl&lt;/code&gt; 横向切屏、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:vsp&lt;/code&gt; 纵向切屏&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C-w hjkl&lt;/code&gt; 来跳到不同窗口&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:tabnew&lt;/code&gt; 新建标签页&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gt&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gT&lt;/code&gt; 来切换标签页&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;我平时用切屏比较多，因为写代码时，经常需要一边写这里、一边写那里。&lt;/p&gt;

  &lt;p&gt;推荐两个插件：&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;https://github.com/simeji/winresizer&quot; target=&quot;_blank&quot;&gt;winresizer&lt;/a&gt; - 用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hjkl&lt;/code&gt; 的方式更方便地调整 vim 窗口的大小 (和 tmux 中类似)&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;https://github.com/troydm/zoomwintab.vim&quot; target=&quot;_blank&quot;&gt;zoomwintab.vim&lt;/a&gt; - 放大和缩小 vim 窗口
 (和 shell 中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C-z&lt;/code&gt;, tmux 中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;z&lt;/code&gt; 类似, 我也采用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;z&lt;/code&gt; 作为快捷键)&lt;/li&gt;
  &lt;/ul&gt;

  &lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-75&quot; src=&quot;/assets/images/posts/commandline-dev-tools/4.5.1-vim-window-resize-and-zoom.gif-small.svg&quot; data-src=&quot;/assets/images/posts/commandline-dev-tools/4.5.1-vim-window-resize-and-zoom.gif&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图4.5.1 vim 窗口大小调整和缩放效果
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
  &lt;p/&gt;

&lt;/details&gt;

&lt;details&gt;
  &lt;summary&gt;
  Vim - 开发和编程
&lt;/summary&gt;

  &lt;p&gt;大部分情况下，vim 都是用来做编程开发，在这一方面，它的表现丝毫不比流行的 IDE 差：&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;
      &lt;p&gt;&lt;strong&gt;语法高亮&lt;/strong&gt;&lt;/p&gt;

      &lt;p&gt;所有主流的编程语言，都有对 vim 的高亮的插件。对我而言，可能唯一的问题是，
有些编程语言的插件做的太臃肿了，它们提供一揽子配套，比如 &lt;a href=&quot;https://github.com/fatih/vim-go&quot; target=&quot;_blank&quot;&gt;vim-go&lt;/a&gt;，
&lt;a href=&quot;https://github.com/python-mode/python-mode&quot; target=&quot;_blank&quot;&gt;python-mode&lt;/a&gt; 等等，
但我一般只需要语法高亮，并不想去学习它们额外的一些命令、键位什么的，因为这些都不通用。
针对这种 “绑上编程语言 IDE 式” 的插件，我要么找更轻量的替代品，要么就 fork 出来，只扒出来语法高亮的部分用。&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;&lt;strong&gt;Git 集成&lt;/strong&gt;&lt;/p&gt;

      &lt;p&gt;我没有在用 &lt;a href=&quot;https://github.com/tpope/vim-fugitive&quot; target=&quot;_blank&quot;&gt;vim-fugitive&lt;/a&gt; 之类的插件，
因为我觉得这些事情都可以在 shell 中完成，也不必单独去记其特殊的命令。&lt;/p&gt;

      &lt;p&gt;在用的一个插件叫做 &lt;a href=&quot;https://github.com/mhinz/vim-signify&quot; target=&quot;_blank&quot;&gt;vim-signify&lt;/a&gt; ，
它可以显示出改了哪些行。&lt;/p&gt;

      &lt;figure&gt; 
&lt;img class=&quot;post-img lazyload max-width-80&quot; src=&quot;/assets/images/posts/commandline-dev-tools/4.6.1-vim-signify.jpg-small.svg&quot; data-src=&quot;/assets/images/posts/commandline-dev-tools/4.6.1-vim-signify.jpg&quot; alt=&quot;&quot;/&gt;
    
     
     &lt;figcaption&gt;图4.6.1 vim-signify 显示修改的 diff 情况
       
     &lt;/figcaption&gt;
     
   
  &lt;/figure&gt;
      &lt;p/&gt;

      &lt;p&gt;另一款在用的插件叫做 &lt;a href=&quot;sindrets/diffview.nvim&quot; target=&quot;_blank&quot;&gt;diffview&lt;/a&gt; ，它可以让我们一览所有改动的情况，
简单说，就是相比 vimdiff 多了导航栏。我一般用在 code review 中。这是一款仅支持 &lt;a href=&quot;https://neovim.io/&quot; target=&quot;_blank&quot;&gt;neovim&lt;/a&gt;
的插件。&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;&lt;strong&gt;缩进&lt;/strong&gt;&lt;/p&gt;

      &lt;p&gt;对于写 Python 的人而言，显示缩进的层级可能非常重要，推荐 &lt;a href=&quot;https://github.com/Yggdroot/indentLine&quot; target=&quot;_blank&quot;&gt;indentLine&lt;/a&gt; 。&lt;/p&gt;

      &lt;figure&gt; 
&lt;img class=&quot;post-img lazyload max-width-80&quot; src=&quot;/assets/images/posts/commandline-dev-tools/4.6.3.1-vim-indentline.jpg-small.svg&quot; data-src=&quot;/assets/images/posts/commandline-dev-tools/4.6.3.1-vim-indentline.jpg&quot; alt=&quot;&quot;/&gt;
    
     
     &lt;figcaption&gt;图4.6.3.1 vim-indentline 在 Python 代码中的效果
       
     &lt;/figcaption&gt;
     
   
  &lt;/figure&gt;
      &lt;p/&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;&lt;strong&gt;补全和定义跳转&lt;/strong&gt;&lt;/p&gt;

      &lt;p&gt;补全和定义跳转，是对编程效率至关重要的一环。我在用的是 &lt;a href=&quot;https://github.com/neoclide/coc.nvim&quot; target=&quot;_blank&quot;&gt;coc.nvim&lt;/a&gt; ，
它支持大部分的编程语言， 速度上不快不慢，够用，大部分情况都表现良好。&lt;/p&gt;

      &lt;p&gt;coc 中，补全列表中的条目浏览采用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C-p&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C-n&lt;/code&gt; ，也符合 shell 中的快捷键风格。
定义跳转，我用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gd&lt;/code&gt; 来映射。&lt;/p&gt;

      &lt;p&gt;在编程中，相信和大家一样，&lt;span class=&quot;marked&quot;&gt;我是非常依赖补全和定义跳转的&lt;/span&gt;。&lt;/p&gt;

      &lt;figure&gt; 
&lt;img class=&quot;post-img lazyload max-width-80&quot; src=&quot;/assets/images/posts/commandline-dev-tools/4.6.4.1-vim-coc.jpg-small.svg&quot; data-src=&quot;/assets/images/posts/commandline-dev-tools/4.6.4.1-vim-coc.jpg&quot; alt=&quot;&quot;/&gt;
    
     
     &lt;figcaption&gt;图4.6.4.1 coc.nvim 的补全效果
       
     &lt;/figcaption&gt;
     
   
  &lt;/figure&gt;
      &lt;p/&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;&lt;strong&gt;格式检查&lt;/strong&gt;&lt;/p&gt;

      &lt;p&gt;许多编程语言都有一套约定俗成的风格和检查工具，比如 black 之于 Python，clang-format 之于 C/C++，
gofmt 之于 Golang 等等。Vim 中也有支持格式检查的插件，比如 &lt;a href=&quot;https://github.com/dense-analysis/ale&quot; target=&quot;_blank&quot;&gt;ale&lt;/a&gt; ，
它可以在编辑保存时，自动格式化代码，目前我用上去没觉得卡。&lt;/p&gt;

      &lt;figure&gt; 
&lt;img class=&quot;post-img lazyload max-width-80&quot; src=&quot;/assets/images/posts/commandline-dev-tools/4.6.5.1-vim-ale.gif-small.svg&quot; data-src=&quot;/assets/images/posts/commandline-dev-tools/4.6.5.1-vim-ale.gif&quot; alt=&quot;&quot;/&gt;
    
     
     &lt;figcaption&gt;图4.6.5.1 ale 自动格式化代码
       
     &lt;/figcaption&gt;
     
   
  &lt;/figure&gt;
      &lt;p/&gt;
    &lt;/li&gt;
  &lt;/ul&gt;

&lt;/details&gt;

&lt;p&gt;顺带一提，目前在用的配色是 &lt;a href=&quot;https://github.com/NLKNguyen/papercolor-theme&quot; target=&quot;_blank&quot;&gt;PaperColor&lt;/a&gt; ，用了好久了，
中间偶尔会烦一下，换换配色、换换心情，不过，最终又总是回到这个配色上来。&lt;/p&gt;

&lt;p&gt;Vim 的键位集中在字母区，大部分情况下，在 vim 中编辑，手是不用离开键盘的。
话说，是不是许多 &lt;a href=&quot;https://happyhackingkb.com/&quot; target=&quot;_blank&quot;&gt;HHKB&lt;/a&gt; 用户都喜欢用 vim 呢？&lt;/p&gt;

&lt;p&gt;如果非要去理解 vim 编辑器之高效到底来自何处，恐怕只能亲身体会才能知晓。我看来，高效的不是 vim 本身，
而是它帮用户养成的编辑习惯。&lt;/p&gt;

&lt;p&gt;目前有一款社区维护的、脱胎于 vim 的编辑器，叫做 &lt;a href=&quot;https://neovim.io/&quot; target=&quot;_blank&quot;&gt;NeoVim&lt;/a&gt; ，
它支持 lua 语言的插件， 对 &lt;a href=&quot;https://microsoft.github.io/language-server-protocol/&quot; target=&quot;_blank&quot;&gt;LSP&lt;/a&gt;
作了 &lt;a href=&quot;https://neovim.io/doc/user/lsp.html&quot; target=&quot;_blank&quot;&gt;内建支持&lt;/a&gt;，
而且完全兼容 vim ，在社区驱动下，neovim 的迭代要比 vim 快多了，社区生态也是遍地开花。
不过我仍然没有离开 vim8，因为目前为止还找不到什么动力去换，或许未来会尝试切过去试一段时间，
所谓，&lt;span class=&quot;marked&quot;&gt; 生命不息，折腾不止 &lt;/span&gt; 嘛。&lt;/p&gt;
    
      &lt;h4 id=&quot;结尾语&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          结尾语 &lt;a href=&quot;#结尾语&quot; class=&quot;heading-anchor&quot;&gt;¶&lt;/a&gt;
        
        &lt;/span&gt;
      &lt;/h4&gt;
    &lt;hr/&gt;

&lt;p&gt;命令行下的快捷键虽然多，但是不同工具的快捷键，都具有一定的共通性。
而这些快捷键熟练之后，将体会到，键盘操作是比鼠标要快的。&lt;/p&gt;

&lt;p&gt;在配置方面，许多人都把配置做成了仓库托管在 &lt;a href=&quot;https://github.com/topic/dotfiles&quot; target=&quot;_blank&quot;&gt;github 上&lt;/a&gt; ，
我的在这里 - &lt;a href=&quot;https://github.com/hit9/dotfiles&quot;&gt;hit9/dotfiles&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;最后，天下神器，因人而异。不同的工具在不同的人手上、发挥的效果不尽相同。
&lt;span class=&quot;marked&quot;&gt; 工具的强大，因为它们的高上限，而最终威力几何，取决于执剑之人 &lt;/span&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;神兵之神，不在兵器本身，而在于用兵器的人。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;（完）&lt;/p&gt;
  &lt;/div&gt;


&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4c5b1e5455bc04e85f40fad85452314c</guid>
<title>[推荐] 阿里巴巴开源的低代码引擎</title>
<link>https://toutiao.io/k/gsosp6w</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>