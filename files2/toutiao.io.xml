<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>1ddc8ed066d978f3aff442bdff7c86eb</guid>
<title>关于代码质量退化的思考</title>
<link>https://toutiao.io/k/zzaz6vu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;blogpost-body cnblogs-markdown&quot;&gt;
&lt;p&gt;一个软件项目从探索阶段到发展方向明确阶段，会经历从简单到复杂的一个过程，需求的不断叠加，会让系统越来越庞大，功能繁多，公司业务的扩展也让软件系统的生命周期变的更长。在业务变复杂软的过程中，各种原因的驱使，代码质量会退化，维护和开发新功能的成本也会相应的变高，推倒重新开发的成本也是高的吓人。&lt;/p&gt;
&lt;h2 id=&quot;代码质量退化的步骤&quot;&gt;代码质量退化的步骤&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;大多情况下编码设计质量最高的时候是根据第一版需求进行编码实现的时候&lt;/strong&gt;，但只要需求一变更，就会打乱原来的编码设计，软件质量也就会越来越差。或者就没有了设计。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/342595/202201/342595-20220107144131123-305134580.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到了项目中期，有新的功能或者bug的修复，老板就给我了一天时间，让我写好处理代码？逾期是要被骂的；这个没用的功能，做了也没人用，随便写吧，早点结束，早去干别的；我手上现在这么多活，你又插进来个新功能，我只能乱搞了，团队内人员水平的不同写的代码更是天差地别，等等，这都是我们实际工作中会遇到的问题。责任心让我们也会想先这样写，以后再重构，&lt;strong&gt;一般以后重构表示永远不会重构&lt;/strong&gt;。&lt;br/&gt;
上面说的这些都会让我们增加糟糕的代码，混乱的业务逻辑分布在我们系统的各个地方，部门人员变动，新的员工更不可能理解那些杂乱无章的东西，再接着推糟糕的代码，想要理清楚一个业务逻辑，非常容易在混乱的代码中迷路。最直接的后果就是这些混乱的代码会增加新功能的开发周期，领导层问为啥现在开发个功能这么慢？是不是人手不够，再招几个人吧。这杂乱的项目，不是新员工能理的清的，你会发现，&lt;strong&gt;虽然员工变多了。但开发效率还是上不去。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/342595/202201/342595-20220107144221410-1475304617.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那我们重新来做一个新的系统完全替代这个老项目吧，我们可以用最新的框架，更好的实现方式去完成这个系统，这种天真的想法会在团队成员的脑海里无数次出现，旧的系统业务很复杂，新的系统在兼容旧系统逻辑的同时，旧的系统也在更新需求，增加功能，在新系统完全可以抗衡旧系统之前，旧的系统会一直运行。如果你的新系统开发的时间过长，等完成的时候，可能员工都已经不知道换了几批了，代码又乱成了一锅粥，周而复始。&lt;/p&gt;
&lt;p&gt;软件的退化变的越来越严重的过程中，我们也在思考和改变现有的系统，如何才能让系统的在拥有更长的生命周期的同时，提高代码的质量，不让其退化，并拥有更好的可维护性和扩展性？那就是根据需求的变化去调整架构、代码，不断的打破原来的设计，保持清晰，而不是让他烂在那里。&lt;/p&gt;
&lt;h2 id=&quot;渐进式架构&quot;&gt;渐进式架构&lt;/h2&gt;
&lt;p&gt;大多数人能想到的最直接的方案是从架构入手，引入多维度的架构，微服务化，领域驱动模型(DDD)等等&lt;br/&gt;
从顶层设计出发引入新的架构模型，或者说根据需求的变动不断的调整代码的分层和模块，加上理论知识的应用，会让业务代码在结构归属上更清晰。分层的严密能让整体的&lt;strong&gt;业务边界&lt;/strong&gt;更明确，前提是我们要从多维度去审视系统的构架，思考如何去现有的架构做出合理的改动。&lt;/p&gt;
&lt;h3 id=&quot;从不同的角度去分析和改进现有架构&quot;&gt;从不同的角度去分析和改进现有架构&lt;/h3&gt;
&lt;p&gt;比如在项目初期业务比较简单，最简单的分层架构就实现了项目需求，观察我们的架构可能是这样子的，从上而下的松散分层架构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/342595/202201/342595-20220107144305648-1556510597.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;后来又加入了缓存，又加入了消息队列，业务的不断扩张又加入了不同的数据库nosql,业务的升级有了v2.0,v3.0,新业务要兼容旧功能等等，如果还是原来的分层结构，很快就会出现逻辑代码堆积的问题，业务层之间引用杂乱，一个代码文件几千行代码，需求变动时牵一发动全身，及时调整架构的必要性就体现出来了。&lt;br/&gt;
一定要复用好&lt;strong&gt;依赖倒置原则&lt;/strong&gt;,层与层之间不应该依赖实现，要依赖于抽象，比如我们的基础设施层要为其他三层提供支持，基础设施层可以实现其他层定义的接口来进行抽象，从这个角度来开的话我们的基础设施层应该在最上面，也可以是左边或者右边&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/342595/202201/342595-20220107144331003-1956239261.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;应用依赖倒置后，我们调用的是抽象接口，你会发现层的概念没有了，层的概念被打破了，我们可以更激进一点把基础设施层剥离出去用各种适配器去接入各种组件，把层的关系拉平，把架构调整为&lt;strong&gt;六边形构架&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/342595/202201/342595-20220107144346648-1137144759.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不要固化自己的思维，根据业务和系统的发展去调整你的系统架构，能让系统能更高的可扩展和可维护性。&lt;br/&gt;
对于非常老的项目调整架构是痛苦的，一定要得到管理层充分的支持下再去做改造，这样的工作只能是从上往下推进，痛苦的过程终会换来后期维护的喜悦。&lt;/p&gt;
&lt;h2 id=&quot;代码层面&quot;&gt;代码层面&lt;/h2&gt;
&lt;p&gt;在团队内除了要有代码规范，所有人都要遵守，这样代码的风格才能更统一，和使用Lint工具去检查代码，各种语言lint工具，能在早期查检出你代码中不合理的地方。还有下面一些办法&lt;/p&gt;
&lt;h3 id=&quot;功能模块化&quot;&gt;功能模块化&lt;/h3&gt;
&lt;p&gt;程序员最喜欢的就是编码实现具体的功能，在这里才是我们真正秀内功的地方，可以应用各种模式把代码和逻辑写的很漂亮，但是放到整个项目结构里，被调用和使用的过程又感觉那么的不协调，根源是我们模块划分不正确，模块之间的依赖耦合性太强。&lt;br/&gt;
这就是典型的&lt;strong&gt;写的很优雅，使用的很粗糙&lt;/strong&gt;。依赖倒置原则，依然适用于模块间的划分，模块与模块之间的依赖是倒置的，用依赖注入的方式去解耦，模块对外暴露出尽可能少的接口，之间的调用依赖于接口。抽象的好处能让你把模块的边界定义的更明确。&lt;/p&gt;
&lt;h3 id=&quot;对象之间是协作关系不是纠缠&quot;&gt;对象之间是协作关系，不是纠缠&lt;/h3&gt;
&lt;p&gt;业务越复杂，需要操作的对象也就越多，对象的边界不明确就会出现纠缠不清的情况，要不就是一个对象负责的东西过多；要不就是几个对象同时做一件事，逻辑杂乱。&lt;br/&gt;
当你发现你的对象之前不再是协作关系时就要停下来，从高处去看你组织的代码，把大对象分解，职责界线理清楚也就是&lt;strong&gt;功能单一原则&lt;/strong&gt;，很多同学不知道如何确定一个对象的职责，不清楚一个属性是不是属于某个对象，最简单的方法就是，判断这个属性的变动会不影响某个对象，如果没有就不属于这个对象。&lt;br/&gt;
还有就是，面对新的业务需求&lt;strong&gt;敢于打破原有的代码设计，不破不立。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;不要过度开发删除没用的代码&quot;&gt;不要过度开发，删除没用的代码&lt;/h3&gt;
&lt;p&gt;定期要检查和删除没用的代码。少写或者不写感觉未来可能会用到的方法，这些多出来的代码会成为将来重构的绊脚石，会浪费精力在这些没有用到的代码上，查找有没有地方在使用他。&lt;/p&gt;
&lt;h3 id=&quot;solid-原则&quot;&gt;SOLID 原则&lt;/h3&gt;
&lt;p&gt;不能不提的，就是Bob大叔（Robert C. Martin）的SOLID编码原则，他是设计模式的基石，要不断的去应用和实践。&lt;br/&gt;
随着编码时间的增长，越来越感觉SOLID真的是一盏明灯，当你在黑暗中找不到方向的时候，指引你回归正确的道路。&lt;br/&gt;
如果你对SOLID原则应用的比较熟练，我上面说的几项完全都可以忽略。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单一职责原则(Single Responsibility Principle)&lt;br/&gt;
每个对象只有一个职责，明确对象的边界,文章上面说的对象之间是协作关系，不是纠缠里就说过如何确定一个属性是否属于某个对象。&lt;/li&gt;
&lt;li&gt;开闭原则(Open Closed Principle)&lt;br/&gt;
即可扩展(extension)，不可修改(modification)原则，抽取出代码中不变的逻辑，封装可变的代码，&lt;br/&gt;
策略模式就很好的表达这个原则的模式，可以查看之前的博客: &lt;a href=&quot;https://www.cnblogs.com/li-peng/archive/2013/02/18/2915594.html&quot; target=&quot;_blank&quot;&gt;策略模式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;里氏替换原则(Liskov Substitution Principle)&lt;br/&gt;
继承必须确保超类所拥有的性质在子类中仍然成立，里氏替换原则主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。关于里氏替换原则的例子，最有名的是“正方形不是长方形&lt;/li&gt;
&lt;li&gt;接口隔离原则(Interface Segregation Principle)&lt;br/&gt;
尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含调用方感兴趣的方法，这也是我们把复杂功能分模块的应用法则。&lt;br/&gt;
接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，但两者是不同的：&lt;br/&gt;
单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。&lt;br/&gt;
单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。&lt;/li&gt;
&lt;li&gt;依赖倒置原则(Dependence Inversion Principle)&lt;br/&gt;
抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对抽象（接口）编程，而不是针对实现细节编程。上面在说改进架构的时候有说这个原则&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体的代码示例这篇帖子就不写了。&lt;br/&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/342595/202201/342595-20220107144429253-693163030.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;被bob大叔指到的你，一定能写出更完美的代码&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;重构代码&quot;&gt;重构代码&lt;/h3&gt;
&lt;p&gt;新功能的开发的同时要重构之前逻辑，坚持开闭原则，能达到事半功倍的效果。&lt;br/&gt;
工作闲暇时间去浏览现有的代码逻辑，我们每天都在成长，对系统的认知也在改变，思维方式也在不断的变化，用现在的眼光去审视旧的代码逻辑，大多数是能找可以优化的地方，或者隐藏的bug，重构他，不要以为这些只是一些挤牙膏式的调优，所有的事情都有一个从质变到量变的过程。&lt;/p&gt;
&lt;h2 id=&quot;代码评审code-review&quot;&gt;代码评审(code review)&lt;/h2&gt;
&lt;p&gt;代码评审在团队里还是很有必要的，代码评审不是口水战，也不是批斗大会，如果只是走形式code review的意义也就不存在了。&lt;br/&gt;
你写的代码是需要让团队的成员能看明白的，将来也是会有新的员工来维护你写的功能的，code review是一个能让团队内的其他成员快速了解新代码意图的办法。&lt;br/&gt;
大多数团队里程序员的水平参差不齐的，对业务和系统的理解深度也是不一样的，让团队内不同的人去code review能及时发现代码中的不足之处，哪些地方逻辑上有问题，哪里的业务没有考虑全面。&lt;br/&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/342595/202201/342595-20220107144445467-1134347927.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当一次提交的代码太多时，一下子是看不完，也可能理解不了，就要很评审整体思路，再review实现主干逻辑，最后才是实现细节。&lt;br/&gt;
需说明一下的是，&lt;strong&gt;code review 并不能完全发现代码中隐藏的bug，不要把找bug的任务和他混在一起。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;学习多少构架或者框架知识，都不能阻止我们写烂代码。但当你沉下心来去打磨产品或者认真去实现一个功能时，你会在意你写的代码，会主动去写更清晰的逻辑，并改变和想办法去并处理糟糕的代码，希望这篇帖子有能帮助到你的地方。&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9c1bfeba4ec305892b490cd6f0913fea</guid>
<title>美团实时数仓架构演进与建设实践</title>
<link>https://toutiao.io/k/3luzmvf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                                    


                
                
                
                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img __bg_gif&quot; data-backh=&quot;156&quot; data-backw=&quot;562&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;160&quot; data-fileid=&quot;100072321&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5497881355932204&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3EcuPIickyyEmibWOTAjeqXsIhUow7jib3PaicG3RzOuKtJWnTTKpLebksYcbR3DXCcfu6dBaFM1TfOoAOwVibPD0ibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1888&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPjdrlkyhHH3BZDV05IvhuKOic0so28M9B0cD8Hqia6HMpWBZhzfsTqP48RHZwSfonCSA3OtgJoM212A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section data-width=&quot;100%&quot; data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-style=&quot;margin-bottom: -10px; margin-left: -8px; max-width: 100%; width: 18px; height: 18px; border-top: 8px solid rgb(54, 65, 173); border-left: 8px solid rgb(54, 65, 173); box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;br data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;/&gt;&lt;/section&gt;&lt;section data-bgopacity=&quot;50%&quot; data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot; data-style=&quot;max-width: 100%; width: 543.333px; background: rgb(247, 247, 247); box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;p data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;span&gt;分享嘉宾：汤楚熙 美团&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;span&gt;编辑整理：李瑶 DataFun&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;span&gt;出品平台：DataFunTalk&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-style=&quot;max-width: 100%; width: 18px; height: 18px; border-bottom: 8px solid rgb(54, 65, 173); border-right: 8px solid rgb(54, 65, 173); box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;导读：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;大家好，我叫汤楚熙，来自美团数据平台中心的计算平台团队，当前主要工作内容是实时数仓平台的研发。&lt;/span&gt;&lt;span&gt;今天和大家分享一下实时数据在美团的典型应用场景，实时数仓建设中的挑战和解决方案，包括一些关键的设计细节。主要介绍以下几方面内容：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;01&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;建设背景&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;首先，来介绍一下美团实时数据的典型应用场景以及建设过程遇到的一些问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;实时数据在美团的典型应用场景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBYFqejv3H9cOFUiaYZMMtWHlQIFU2ZNicMOHo0Ir7xFmoHEvlZPE1t8icg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;美团作为本地生活领域的头部公司，在内部孵化了许多独立业务，可以看到有大家所熟悉的美团外卖、酒店、美团优选等，这些业务通过实时数据来支撑其内部各种各样的数据应用场景，比如BI、算法、骑手调度等等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBUZBnjRrm4hw0O5g2e6zS26FpavVq3eMN4N0Zu10MTTiaw18TIQl2C3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们对业务场景做了一个简单的分类：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;指标监控：比如有实时大盘，用来即时反馈业务当日运转的健康度等场景；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;实时特征：比如搜索、广告CTR预估、骑手调度等，对算法特征数据新鲜度要求较高的场景；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;事件处理：比如一些风控类、运营活动发券等事件驱动型场景；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据对账：比如&lt;/span&gt;&lt;span&gt;金融的支付业务，支付部门与业务部门各自独立，当业务部门的支付单据与支付部门不一致时，会造成资损，这时数据的实时对账就非常关键。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBltMbWY2ZMQeDxvVmvlkUbEBbmibAml51DKUby922H1AnDu1UU2Y32RA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上图可以看到，截至目前，实时计算平台所支撑的实时数据处理场景的整体规模，&lt;/span&gt;&lt;span&gt;说明实时数据在美团已经影响到了业务的方方面面。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQB0uzg3I8AelZ5NWuGWj9aphsyvuhaHIgLcnk6bXZibDJC4gPicLwcfyuw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实时计算平台从成立以来，经历了上图中的几个关键发展阶段。&lt;/span&gt;&lt;span&gt;平台正式成立于2014年，我们引入Storm和Spark Streaming作为美团的第一代实时计算引擎，并且发布了第一版作业托管平台。接下来在2017年，平台正式引进了Flink，并开始初步探索以Flink SQL为主的实时数仓开发方式。并于2019年，正式将Flink SQL作为主要编程接口暴露给业务，将以任务为中心的开发模式，升级为以数据为中心的开发模式。当前，计算平台紧跟业界发展潮流，将工作内容都聚焦在数仓增量化生产、流批语义统一、统一实时离线数仓建模方式等几个方向上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 实时数仓建设过程中的问题及痛点&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBGQLyjJ6tk2ItdkURNXZKD5wcZAQhjBxoVFhnN18Qcy6oHP8wFZQARA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在正式开始介绍数仓平台的建设实践之前，先来回顾下平台初期所遇到的问题。&lt;/span&gt;&lt;span&gt;实时数据开始建设之初，是没有离&lt;/span&gt;&lt;span&gt;线数仓那样成熟的建设方法论的，而且也没有离线数仓领域那样成熟的开发工具，所以带来了以下几点问题&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;首先就是高昂的开发运维成本，每次计算框架的升级，业务都需要学习一遍计算框架的API。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;代码本地开发，再去线上调试，本地的case难以覆盖线上的数据问题。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;业务各自的数据协议不统一，相互之间进行数据交换，沟通协作的成本也是比较高昂的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数仓的建设方式没有统一规范，导致数据的冗余和重复建设，给后期的资源治理带来了非常大的麻烦。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBvM4Pjq9dOW3mX6JKWKtEefZNS8GJ7EqUH5dulF3cZ0iaQZdhoAW2MFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从上面的问题出发，我们制定了平台的建设路线。&lt;/span&gt;&lt;span&gt;主要集中在两个层面，&lt;/span&gt;&lt;span&gt;首先是降低业务的开发运维门槛，让实时数仓开发可以像离线数仓开发那样简单高效。&lt;/span&gt;&lt;span&gt;比如我们提供了标准的ETL作业模板，web集成开发环境，并且扩展了SQL的能力，使业务可以尽量以符合其认知的形式去进行代码开发。&lt;/span&gt;&lt;span&gt;还有数仓建设中业务最关心的数据质量问题，我们也提供了相应的配套工具，帮助业务以尽可能低的成本将可靠的数据交付应用方。&lt;/span&gt;&lt;span&gt;可用性在离线数仓建设过程中可能大多体现在数据是否按时就绪，那么实时数仓对数据的时延要求更高，所以可用性的保障也非常关键。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;前面提到的都是在开发运维效率方面我们所做的一些建设规划，在大数据领域，一个&lt;/span&gt;&lt;span&gt;底层算子性能的小小改进，都会使执行效率成倍的放大，所以我们也会花费一些精力在底层算子的优化上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;两横三纵，其中&lt;/span&gt;&lt;span&gt;两横包括&lt;/span&gt;&lt;span&gt;开发迭代效率，面向人的优化，重点在于对工作流。&lt;/span&gt;&lt;span&gt;三纵包括&lt;/span&gt;&lt;span&gt;能做（&lt;/span&gt;&lt;span&gt;看得见、摸得着的问题）、&lt;/span&gt;&lt;span&gt;做好和&lt;/span&gt;&lt;span&gt;最优化。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;02&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;平台架构设计&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;接下来开始着重介绍我们是如何解决上面所提到的问题的。&lt;/span&gt;&lt;span/&gt;&lt;span&gt;首先从整体上来介绍下平台解决上面问题的思路。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQB98QiaZpChXWSFTYzbS2nRYAxb3sWicmzfxFnmsxJPXL7cEJ13kRdIibUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上图是平台整体架构。&lt;/span&gt;&lt;span&gt;从下向上来看，存储、计&lt;/span&gt;&lt;span&gt;算、调度加上日志服务构成了我们的基础服务层。&lt;/span&gt;&lt;span&gt;基础服务层之上是平台对业务提供的一些中间件。&lt;/span&gt;&lt;span&gt;上层是平台抽象出的一些可自行组合的微服务集合，比如作业模板服务、&lt;/span&gt;&lt;span&gt;UDF&lt;/span&gt;&lt;span&gt;托管服务、元数据服务、指标采集监控、数据质量管理等，这些服务业务可以按自身的场景需要来在自己的业务内部自行组合，也可以直接使用平台包装好的大而全的集成开发平台。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQB4HY4vx39LcKJPn4eNW2DAdGw3bkicP69ve7H8xVnSs3wYNQcGaCYuwA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上图展示了平台基础服务中最关键的计算服务的选型过程。&lt;/span&gt;&lt;span&gt;实时数仓场景的最根本业务诉求是数据的时效性，这里的时效性通常指的是秒级的延迟，所以这里Flink和Storm胜出。&lt;/span&gt;&lt;span&gt;其次是数据的正确性，Flink是这里唯一能够保证Exectly-Once计算语义的框架，所以Flink要优于storm。&lt;/span&gt;&lt;span&gt;之后我们有做了benchmark测试，通过实验证明了，在绝大多数场景下Flink任务的吞吐要优于Storm，而且Flink还提供了更加成熟的SQL编程接口，&lt;/span&gt;&lt;span&gt;所以我们最终确认选择Flink作为实时数仓的核心计算框架。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBaWbN38PIibEQB6ubYWibEejXRlvYgXnm52IwRMXs6fyEdENhBIE4Nhpg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;解决了计算框架的问题，接下来我们要从上层概念入手，让熟悉离线数仓开发的同学能够更快的上手实时数仓的开发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从下向上看，我们先统一了离线和实时数仓的数据模型，无论是&lt;/span&gt;&lt;span&gt;HiveT&lt;/span&gt;&lt;span&gt;able&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Kafka&lt;/span&gt;&lt;span&gt;Topic&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Redis&lt;/span&gt;&lt;span&gt;的一个域，在上层暴露给业务的都是一张&lt;/span&gt;&lt;span&gt;Table&lt;/span&gt;&lt;span&gt;，这样业务没有过多认知上的负担了，可以在不同开发场景的概念之间轻松切换。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从上向下看，我们又统一了编程接口，使用SQL作为数仓开发的首选，这样实时和离线数仓的ETL逻辑甚至可以完全共用一套，对开发效率上也有显著的提升。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBgVSWYyNU8mM1d2LhfUIuZrlaccT4TLLngd9wOxn2r2DW1nicicdFcRvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有同学可能会问，实时和离线场景的计算语义不完全相同，实时计算场景需要包含大量跟时态相关的语法，比如window，interval等，离线场景上没有，那么怎么统一呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;的确如此，所以我们独立出一套SQL服务，短期用户也可以在SQL中加入HINT提升或者是直接提供一些参数，来告诉我们这是什么离线还是实时场景的ETL，未来我们会自动根据业务的输入、输出表的存储类型，ETL的模式，自动判断使用哪种类型的执行模式更有效。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;跟社区如果对不齐怎么办：&lt;/span&gt;&lt;span&gt;先对内解问题，如果效果真的不错，可以推回社区，如果社区有更好的方案，我们可以判断是否能够&lt;/span&gt;&lt;span&gt;merge&lt;/span&gt;&lt;span&gt;进来，如果不行，说明我们的架构设计本身就是有问题的。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;03&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;平台建设实践&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 实时数仓开发解决方案&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBneF2W9VxhscZ6DEaWnny3PeCM8POTNvllHQ4DsiatwQjQR9ibPx586lg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们对数仓平台的定位是：集需求准备、开发测试、发布和运维监控能力的一站式实时数仓生产解决方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面简单来介绍一下用户在平台上的工作流程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在需求准备阶段，用户可以结合业务需求先来检索是否有满足需求的数据模&lt;/span&gt;&lt;span&gt;型，如果没有找到，那么可以选择从源头开始接入，或者新建模型。模型接入或创建好之后，进入&lt;/span&gt;&lt;span&gt;ETL&lt;/span&gt;&lt;span&gt;开发阶段，开发过程可能会伴随着一些简单的任务调试，这些工作也全部都可以在平台上完成。在开发完成准备上线之前，用户可以创建一条发布流水线，这块内容后面还有详细的介绍，待流水线执行通过后，就可以正式发布作业了，作业上线后，平台会自动收集作业的运行时指标，用来监控作业的运行状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBp5Mumbhu569BCsOKajL31De9oB7CLzib58sGzEV1mPOE2rqZ4yG7Inw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面介绍下，平台是如何规范业务的数仓接入流程的。&lt;/span&gt;&lt;span&gt;从上图（左）&lt;/span&gt;&lt;span&gt;大家可以看到，跟离线数仓的入仓流程相比，在没有数仓平台前，实时数仓的入参过程突出了一个乱字，而这样会带来如下问题：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数&lt;/span&gt;&lt;span&gt;据建设过程没有规范，后面接手的同学不知道从何入手。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;接着上面的问题，如果后面同学按照自己的理解，重新接入一遍数据，长此以往，会造成大量的冗余数据，造成烟囱林立，资源浪费，后面还&lt;/span&gt;&lt;span&gt;需要花大量的时间治理。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数仓接入这个动作本身是没有过多业务逻辑的，是可以标准化和系统化的，这样重复机械的工作内容，会造成人力资源的浪费。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQB88KCrrpm37m535yQ9ZbicE1NMtvE8sNQYzxjJY3x4uvA47G6sfFwoQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;面对上述问题，数仓平台提供了一套完整的实时数仓接入方案。&lt;/span&gt;&lt;span&gt;明确的帮用户生成&lt;/span&gt;&lt;span&gt;ODS&lt;/span&gt;&lt;span&gt;层，这样同项目成员之间的合作，有了共同的规范和约束，不会再有因信息未对齐而造成的数据重复接入。&lt;/span&gt;&lt;span&gt;我们不光帮助用户规范了入仓的流程，还提供了一系列数据正确性、作业稳定性的保障机制，使业务同学可以将精力集中在数仓的建设上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBvIQ1OCelPys7JeKECarpg3YZcb1I47fB43V6nvUNlCNhaghCJNFfDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在规范化业务数仓接入流程的方案设计过程中，有个小小的挑战，那就是我们的数据源并不仅仅来自MySQL binlog和nginx日志，还有大量业务自行通过SDK上报的日志，这些日志的格式难以从整体上进行抽象，而且不同业务因为服务场景不同，数据的序列化方式也难以统一，所以我们抽象出一个Adapter模块，专门用来解决这个问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;P&lt;span&gt;arser&lt;/span&gt;&lt;span&gt;用来适配业务自定义消息格式，&lt;/span&gt;&lt;span&gt;Formatter&lt;/span&gt;&lt;span&gt;将用来监控作业稳定性和数据正确性的元数据信息融入到消息中，最后按照业务场景的实际诉求，允许业务根据自身场景定义序列化方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBiaBtOvNsHeZA481jLn7UzEsm5sJLNGcXJuhtFHKPNNPFAMHtYXT9e0Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;前面介绍了平台在数据入仓阶段如何提升开发效率。&lt;/span&gt;&lt;span&gt;接下来介绍如何帮助业务更低门槛的进行实时数据的开发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;平台上线之初是基于&lt;/span&gt;&lt;span&gt;Flink1.&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;实现的模板任务，在当时来看，他们的能力并不成熟，一些在离线场景比如&lt;/span&gt;&lt;span&gt;SparkSQL&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;HiveSQL&lt;/span&gt;&lt;span&gt;都支持的语法，在&lt;/span&gt;&lt;span&gt;Flink&lt;/span&gt;&lt;span&gt;上支持的并不好。&lt;/span&gt;&lt;span&gt;所以我们决定先由平台自行根据业务需求对语法进行扩展。&lt;/span&gt;&lt;span&gt;比如t&lt;/span&gt;&lt;span&gt;able&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;UDF&lt;/span&gt;&lt;span&gt;的声明，还有insert into&lt;/span&gt;&lt;span&gt;等语法的支持。&lt;/span&gt;&lt;span&gt;当然这并不是全部。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBGsYT3LRI7PkSXdGoVsj4AeRa91oHTc0V8qpFbNBLuc90cwHEgbCLVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们不仅仅在&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;语法层面进行了改进，&lt;/span&gt;&lt;span&gt;还对作业模板进行了增强。像&lt;/span&gt;&lt;span&gt;watermark&lt;/span&gt;&lt;span&gt;提取对业务时间格式有一些要求，&lt;/span&gt;&lt;span&gt;这种业务场景强相关的逻辑并不适合直接写死在我们的模板程序代码中。&lt;/span&gt;&lt;span&gt;所以我们在作业模板中加入了几个切面，可以由业务自行上传代码来扩充这部分能力。&lt;/span&gt;&lt;span&gt;比如我们会在&lt;/span&gt;&lt;span&gt;Source&lt;/span&gt;&lt;span&gt;注册之后，提供一个切面，引入用户代码，进行日期格式转换，再执行&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;官方虽然已经提供了计算列，我们也调研了相关能力，但是我们认为除非有一个数量级的开发效率优化效果，否则我们没必要一定&lt;/span&gt;&lt;span&gt;follow&lt;/span&gt;&lt;span&gt;官方的语法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBwOuETjKDeaBYib0If5Bvy6iczgCk8omeU2uQ0I2eZEBg9BmQhw0DrDWw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经&lt;/span&gt;&lt;span&gt;过对模板的升级改造，可以看到平台能够支持的&lt;/span&gt;&lt;span&gt;ETL&lt;/span&gt;&lt;span&gt;模式已经非常丰富了，后面我们也会继续迭代，目标是可以覆盖&lt;/span&gt;&lt;span&gt;95%&lt;/span&gt;&lt;span&gt;以上的实时&lt;/span&gt;&lt;span&gt;ETL&lt;/span&gt;&lt;span&gt;场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBjNMjAURAQpcYyrQWNcxj1tlLQ4Tr6Fke0icTMnlQPb9ymZqNh6nTBjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;UDF是一种扩展SQL表意能力的重要功能，在没有平台的时候，用户UDF都是散布在各自的代码仓库中的，这样一些较通用的UDF，不能被其他业务直接使用，业务在代码中执行一些有安全风险的行为，平台也无法有效管控。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以我们建设了一套&lt;/span&gt;&lt;span&gt;UDF&lt;/span&gt;&lt;span&gt;托管服务，帮助业务集中托管&lt;/span&gt;&lt;span&gt;UDF&lt;/span&gt;&lt;span&gt;代码，可以编译打包时，进行提前检查、并暴露安全风险，而且通用&lt;/span&gt;&lt;span&gt;UDF&lt;/span&gt;&lt;span&gt;可以在业务之间共享，也能够帮助业务提升开发效率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBAIZ160SJIQjjicC9Eibs6zlYoQlMWveRaiaz6VRM6M8LcSBpoaewAFPicQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;前面的内容，主要是如何解决开发效率的问题，下&lt;/span&gt;&lt;span&gt;部分内容的重点是，如何保证业务的数据质量。&lt;/span&gt;&lt;span&gt;可能在场的各位同学，有后台开发的相关经验，大家可能都了解&lt;/span&gt;&lt;span&gt;Devops&lt;/span&gt;&lt;span&gt;方法论的核心目标，是保证迭代效率和工程质量。&lt;/span&gt;&lt;span&gt;实时数据开发其实与后台服务开发过程有相似的地方，作业发布后，数据就会立即生效，&lt;/span&gt;&lt;span&gt;并作用于线上，所以我们也需要一套流程，来保证我们每次实时任务发布的数据质量不用影响到我们的数据服务质量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们设计了一套数仓发布的&lt;/span&gt;&lt;span&gt;Pipeline&lt;/span&gt;&lt;span&gt;，在每次任务迭代上线过程都会执行一次&lt;/span&gt;&lt;span&gt;Pipeline&lt;/span&gt;&lt;span&gt;过程，&lt;/span&gt;&lt;span&gt;TestCase&lt;/span&gt;&lt;span&gt;就类似于单测用例，理论上所有&lt;/span&gt;&lt;span&gt;TestCase&lt;/span&gt;&lt;span&gt;都通过才可以发布作业。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Pipeline服务是通过一个异步任务调度框架来实现的，每个Worker内会启动一个Flink的MiniCluster进程，执行后会将结果存入DB并在前端打印执行结果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBfz5pZlAyAB3MsjTdZicicjQjzSQQHQ1cibIGd7RANicq2INkicwb7DDVn0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于数据质量，业务还有一项非常关心的事项，也就是数据的时延。时延一方面可以说明业务交付的数据是否符合应用方的预期，另一方面也方便业务自己去排查问题，确定作业的性能瓶颈点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Flink&lt;/span&gt;&lt;span&gt;官方提供了一个用来计算延迟情况的机制，&lt;/span&gt;&lt;span&gt;Latency Marker&lt;/span&gt;&lt;span&gt;，这个东西近似于&lt;/span&gt;&lt;span&gt;Watermark&lt;/span&gt;&lt;span&gt;，是一类与业务数据无关的，由框架周期性产生的消息，我们要做的是根据业务的流量和业务延迟时间精度的要求，控制这类消息的发送频率和发送量，&lt;/span&gt;&lt;span&gt;并支持跨任务传递&lt;/span&gt;&lt;span&gt;Marker&lt;/span&gt;&lt;span&gt;。因为平台收口了数仓接入层，所以这也使我们获取到真正的端到端延迟成为可能，&lt;/span&gt;&lt;span&gt;我们会通过&lt;/span&gt;&lt;span&gt;emitter&lt;/span&gt;&lt;span&gt;向下游发送特殊的消息协议，并且下游任务的&lt;/span&gt;&lt;span&gt;Reciver&lt;/span&gt;&lt;span&gt;会对这类消息做特殊判断，在发送和接受数据时都会将指标上报到&lt;/span&gt;&lt;span&gt;Raptor&lt;/span&gt;&lt;span&gt;，即美团内部的一个业务指标监控，并最终提供给业务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBOPQP4lGiaWIM7etaHsiaicaznYjOKRLdS2ic0otEEsuPbcCwlwVIWgucNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;前面我们分别介绍了平台是如何提升开发效率和保证业务的数据质量的，主要解决的是数仓开发者的问&lt;/span&gt;&lt;span&gt;题。&lt;/span&gt;&lt;span&gt;平台还有一类用户是数仓架构师，他们不仅仅要参与数仓的建设，还需要对数仓的建设情况做整体性把控。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以前大家都是通过wiki的形式来进行数仓的规范和约束。数仓平台提出了一个项目空间的概念，每个项目空间都可以由架构师定义符合自身业务场景的一些约束项，比如架构师可以定义数仓的主题、分层规范，表、字段的命名规则，同项目空间下的实体都必须遵守负责人做定义的规范。&lt;/span&gt;&lt;span&gt;这样可以在开发之前就保证数仓的建设质量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 算子性能优化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面来分享下我们在flink算子层面所做的一些优化工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBsib9hIGK6FWianKfdhLpibIlYTf7KhcQ1tSzj3XYNHZQak2CeDh8SFdXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先实时数仓有很大一部分计算场景是用来做扩维的，也就是流表关联。流数据来自kafka，表数据通常是借助redis、hbase等分布式kv存储，当流量小的时候，每一条流数据都请求一次外存，发起一次网络io，也没有多大影响。但是像基础流量等业务，每天几百上千亿条消息，都去单独请求外存，压力可想而知。所以平台为用户准备了本地缓存机制，通过一个多级缓存的架构，来缓解超大流量下外存访问的IO的压力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBAY2Z54cKqOjGDQmSRcJibxVA85Sia23apphkRaaicoWzxb2JKm7MXicDEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数仓&lt;/span&gt;&lt;span&gt;ETL&lt;/span&gt;&lt;span&gt;会包含大量聚合、关联和排序等逻辑，在有界数据处理的时候，我们对算子行为能够做出较准确的判断。&lt;/span&gt;&lt;span&gt;但是在无界数据处理的情况下，像关联、聚合等逻辑为了保证数据的正确性，会在更新一条记录的同时产生一条回撤消息，用来修复下游已经受到影响的数据，所以实际向下游传递的消息量可能会翻倍。而当涉及到多层算子嵌套，比如聚合嵌套关联，那么消息量还会继续膨胀。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了解决这个问题，我们研究了框架的源码，并分析了业务数据的特征，发现实际上大多数情况消息在极短的时间内会被频繁更新多次，这也就意味着我们可以将多次请求合并成一次请求，来减少状态更新的次数，从而减少向下游发送的消息量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBeuh9E26WdjtRQqPLxgP1qeGTt6ibpxydfeSKXwWBuMG3icf1hiaHCeMhg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上图是一个&lt;/span&gt;&lt;span&gt;Join&lt;/span&gt;&lt;span&gt;算子的&lt;/span&gt;&lt;span&gt;优化案例，在分析了原理后，&lt;/span&gt;&lt;span&gt;我们认为可以分三个阶段来对算子进行优化：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;首先在输入阶段，可以对输入的消息做预处理，如果发现同key数据紧跟一条回撤事件，我们这两条消息可以同时消除，而保留最新的一条消息；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;接下来在计算阶段，因为双流关联需要缓存左右流各自的状态，这样我们可以将短时间同&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;对状态的访问，合并成一次，减少状态访问次数；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;最后在事件下发阶段，可以判断消息之间的关系，重复记录直接可被直接消除。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3. 建设成果展示&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBs4diaNcHdWBcSlVorf9jOzzlan7QcgVMmRw7RfBORhIIbjEtLsz8a4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先是我们的Web IDE，左面是菜单栏，可以用来管理项目空间，右面是一个web编辑器，用来开发ETL脚本，编辑器下还提供了控制台，用来查看调试日志和对比调试结果，还有语法错误提示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBeOmVm0x2IXh98nicBibbv3c0pIHD9TOq3orVL2Sqe6YOhFx721SRwDXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上图是我们的逻辑模型管理模块，在此我们可以编辑自己的模型信息，查看血缘，资源占用量，数仓相关的业务属性等元数据，来辅助业务更好地进行数仓建模。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBROVS5khzLInia3S8YkT6bMIdxoovquk1HU6a0LC8CXVwMt51FicLajcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后展示的是运维中心，所有的作业运行状况，运行指标，操作日志都可以通过这个平台来管理。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;04&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;未来计划&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBFrJatQcJlib3YQDHc9FSSns7LL5NqPxqXibKYaPtb0gUmkUac2oHJkwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从前面的分享大家可能会看出，平台前期的大部分精力都集中在解决业务实时数仓建设流程方面的问题上。&lt;/span&gt;&lt;span&gt;随着数仓平台在业务上的逐渐推广，以及业务的深度使用，问题更多的出现在框架的&lt;/span&gt;&lt;span&gt;runtime&lt;/span&gt;&lt;span&gt;层面，比如超大作业的调度成功率和时长问题，&lt;/span&gt;&lt;span&gt;超大数据量作业的状态访问性能问题。&lt;/span&gt;&lt;span&gt;希望通过流批一套语义、一套执行层、一套存储，来彻底解决开发运维的成本问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，&lt;/span&gt;&lt;span&gt;随着实时数据扩展至一些ToC业务场景，这些应用有着非常高的可用性要求，所以在这个方向上我们也要继续攻关下去。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后就是终极问题，资源和性能比的问题，也就是在确定性的条件下，用最少的资源做最多的事情。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBDafUPSRtF5CoibhFle6iaIj2b4EhZZia3Gc4rOKcxicyRN54tibkSo21gYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是我们平台当前在建设的一个重点项目——数仓增量化生产，为达成真正的流批一体做一些前置性的技术储备和路径探索。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;今天的分享就到这里，谢谢大家。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;在文末分享、点赞、在看，给个3连击呗~&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分享嘉宾：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;289&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPjdrlkyhHH3BZDV05IvhuKOLmiagvjMPlliaqSQNYsx5T6c3b9RgSj29egrVabhnl5n6Av9MqAGUhibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.52&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3EcuPIickyyEwbzUrMVnXJaXicEHYVRUz1Xar9X3Tic8ZUNJ3IfuVNP8wUpaKiafwYOY6lfXjlYbcJUJklKI7psbsg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f1395036c1a4b2590d5d5240a72538ea</guid>
<title>深度好文｜实时数仓不用愁，StarRocks+Flink 来解忧！</title>
<link>https://toutiao.io/k/wklhvr1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-width=&quot;100%&quot; data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-bgopacity=&quot;50%&quot; data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;section data-width=&quot;100%&quot; data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-bgopacity=&quot;50%&quot; data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;p data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;span&gt; 2022年1月9日， StarRocks 亮相 Flink Forward Asia 2021 大会开源解决方案专场， StarRocks 解决方案架构师谢寅做了题为【双剑合璧：Flink + StarRocks 构建实时数仓解决方案】的主题演讲。本文以主讲嘉宾从技术方案的角度，为社区的小伙伴带来最全、最详细的文字版和视频实录回顾！&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section/&gt;&lt;p&gt;&lt;span&gt;本文从以下5个方面介绍：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;第一部分，实时数仓技术的发展趋势和技术挑战，以及为什么 Flink+StarRocks 能够提供端到端的极速实时数仓体验。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;第二部分，介绍什么是 StarRocks，它有哪些技术特点，擅长的场景是什么，以及为什么作为 OLAP 层的极速分析引擎，它能够很好与 Flink 技术进行整合。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;第三部分，重点介绍联合 Flink 和 StarRocks 两大技术栈构建实时数仓的方法论。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;第四部分，介绍一些利用 Flink 和 StarRocks 构建实时数仓的最佳实践案例。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;第五部分，展望了 StarRocks 在实时数仓方向以及 Flink 社区贡献等方面的后续规划。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;86134&quot;&gt;&lt;section hm_fix=&quot;344:425&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;20%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;实时数仓概述&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;随着各行各业对数据越来越重视，实时计算技术也在不断的演进。从时效性上来讲，对于小时级或者分钟级的计算已经不能满足客户业务的需要，需求逐渐从时窗驱动，升级到事件驱动，甚至每产生一条数据，都想尽快看到数据。ETL 过程也从离线或者微批的 ETL，变为 Flink 擅长的实时流式处理。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;数据源上，早先只能支持单一的数据源，整体的数据表现力较差。而当下，人们不仅希望能对单一数据流进行分析计算，还希望能联合多个数据源进行多流计算，为此不惜想尽一切办法，来让数据的表现力更加丰富。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从工程效率的角度上看，技术团队也逐渐意识到，工程代码开发的成本高企不下，更希望能构建自己的平台化 IDE 工具，让业务人员能基于其上直接进行 FlinkSQL 的开发。在这些演进的过程也逐渐浮现出一些技术难点亟待解决，比如：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;乱序数据怎么更好的处理？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;通过Watermark之类的手段，是让过去的数据随即失效，还是希望所有的明细数据都能入库？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;多流Join到底应该怎么做合适？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;维表是一次性加载进来，还是放到外存储做热查询，除此之外还有没有其他的技术选择？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据处理作业一旦重启，怎么保证在恢复之后还能做到不丢不重的续接消费？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;怎么才能提高整体的业务开发效率，保证业务上线时没有业务中断，更优雅快捷的进行业务逻辑迭代？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;在此之外，还有一件事也是业务人员或平台架构师最关注的，那就是通过 Flink 这么强大的实时计算引擎，费劲千辛万苦好不容易把计算层效率从小时级或者分钟级的延迟提升到了秒级，结果现有的 OLAP 产品拖了后腿，查询耗费了好几分钟，辜负了计算团队的大量心血。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;以上种种，充分证明了极速 OLAP+实时计算的重要性，以此我们就可以打造一套端到端的极速实时数仓解决方案，即所谓“双剑合璧”！&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;谈到数仓，目前业界落地较多的还是 Lambda 架构，也就是离线数仓和实时数仓分开构建。逻辑分层的形式，也基本形成了业界的共识。业务数据有的是 RDBMS 采集上来的，有的是日志采集上来的，有的是批量抽取上来的，有的是 CDC 或者流式写上来的。原始操作层（ODS）基本都是保持数据原貌，然后经过维度扩展、清洗过滤、转换，构建成明细层（DWD）。再往上层走，数据开始做轻度聚合，并有原子指标出现。最后按照主题或者应用的需要产出 ADS 层里的派生指标或者衍生指标。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;企业构建实时数仓，为了让整体的逻辑清晰，通常情况下也会沿用这种分层模式，只不过受限于实时数据到达的先后情况以及业务需要，可能会有些层次的裁剪，不像离线数仓里那么丰富。中间的一些维度信息，可能会同时被离线数仓和实时数仓共享使用。最后将数据送入 OLAP 产品，供报表系统、接口或者Adhoc查询所调用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于前面对数仓典型逻辑分层的探讨，问题也随之而来：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;是否有一款 OLAP 产品能够很好的和Flink结合，满足持续的秒级的数据摄入和极速分析查询能力？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;答案是一定的，StarRocks 的定位正是要提供极速分析查询能力，来适应各种各样的 OLAP 场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;85696&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;86134&quot;&gt;&lt;section hm_fix=&quot;347:443&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;20%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;StarRocks 是什么&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;这是 StarRocks 的宏观架构图。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;322&quot; data-backw=&quot;578&quot; data-height=&quot;790&quot; data-ratio=&quot;0.5543478260869565&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Sq4ia0xXeMC6JXZvQz2JsLyCgJDCzQOX7JwwfsqICiagWnTcvLfvO4Mty6OicJYyNrfpjPPdRIssaicVrELfF7jFBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;92&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从左边我们可以看到常见的 Kafka、分布式文件系统、传统关系型数据库，都可以作为 StarRocks 的数据源。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;StarRocks 提供了4种模型：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果业务场景只涉及数据的持续 Append，可以选择 Duplicate 明细模型，在其上可以实时构建物化视图加速 DWS 层查询；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果业务场景不关注明细的下钻，StarRocks 还有 Aggregate 聚合模型表，相当于数据直接秒级打入DWS 层，满足高并发的聚合指标查询；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对于 ODS 层做业务库数据还原时，若涉及到数据更新的场合，可以采用 Unique 模型，利用 Flink 的Append 流 Sink 数据进来，完成 ODS 数据去重和更新；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;另外，StarRocks 最新2.0版本提供的 PrimaryKey 主键模型，比 Unique 模型查询性能快3倍以上，内置了 OP 字段来标记 Upsert/Delete 操作，并且能够很好的吻合 Flink 的 Retract 回撤流语义，聚合计算不必非要开窗转为 Append 流来 Sink，进一步增强了 FlinkSQL 的表现力。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;StarRocks 还提供了逻辑 View 和物化视图，提供了更丰富的建模能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在上图的右侧是 StarRocks 的物理架构，整体还是非常简洁的，主要就是两种角色：FE 前端节点和 BE 后端节点。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;FE 负责查询规划、元数据管理、集群高可用，并包含 CBO 优化器，为分布式多表关联和复杂 Adhoc 查询提供最优的执行规划。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;BE 节点承载了列式存储引擎和 全面向量化的执行引擎，保障在 OLAP 分析场景中提供极速查询体验。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对上层应用提供 MySQL 连接协议，可以用 MySQL 客户端轻松连入进行开发和查询，和主流 BI 工具有很好的兼容性，也可以服务于 OLAP 报表和 API 封装。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;86134&quot;&gt;&lt;section&gt;&lt;section hm_fix=&quot;325:445&quot;&gt;&lt;span&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;20%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;StarRocks 擅长哪些场景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;基于 StarRocks 的4种模型，可以提供明细查询和聚合查询，能够应对 OLAP 报表的上卷和下钻，比如在广告主报表场景应对高并发点查询。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;StarRocks 基于 Roaring Bitmap 提供了 Bitmap 数据结构，并配套有集合计算函数，可以用于精确去重计算和用户画像的客群圈选业务。在实时方面，StarRocks可以用于支撑实时大屏看板、实时数仓，秒级延迟的呈现业务原貌和数仓指标。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后，基于 CBO 优化器，StarRorcks 在 OLAP 场景下有很好的多表关联、子查询嵌套等复杂查询的性能，可以用于自助BI平台、自助指标平台和即席数据探查等自助分析场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;StarRocks 能够用于构建实时数仓，得益于他的三种实时数据摄入能力：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;利用 Flink-Connector-StarRocks 插件，可以实现从 TP 库  Binlog 实时同步 Upsert 和 Delete 等操作，更好的服务于 ODS 层业务库还原。配套的 SMT（StarRocks Migration Tool）工具，可以自动映射 Flink 中的 TP库 Source 和 StarRocks 库的 Sink 建表语句，使得基于 FlinkSQL 的开发工作变得简单便捷。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，Flink-Connector 更重要的功能是提供了通用 Sink 能力，开发者把依赖加入后，无论是工程编码还是 FlinkSQL 都可以轻松 Add Sink，保障数据秒级导入时效性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;结合 Flink 的 Checkpoint 机制和 StarRocks 的导入事务标签，还可以保障不丢不重的精准一次导入。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;StarRocks 的实时物化视图构建能力，结合 Flink-Connector 的持续增量数据导入，可以在流量类指标计算的建模中，实现 DWD 明细数据导入完成的同时，DWS 聚合指标也同步增量构建完成，极大提升聚合指标产出效率，缩短分层 ETL 的旅程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;StarRocks 提供的 Replace_if_not_null 能力比较有意思，正如语义所述，只要插入的数据不是 null，那么就可以去替换数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如图所示，右侧是个建表示例，里面维度列为日期和 Uid，其余3列中 SRC 表示数据源，另外带了 v1，v2两个 Metric；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;786&quot; data-ratio=&quot;0.5606276747503567&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Sq4ia0xXeMC6JXZvQz2JsLyCgJDCzQOX73NIok7NZicGckEoMHmautvM3gxjdWsibfQbLLL1tJ8OUo30aeVo9ccZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1402&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过2个 Insert 语句我们可以看到，来自2个 Kafka 主题的数据源的数据，轻松的实现了同时写入一张表的不同列。因此，这个功能提供了两种实时数仓能力：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1) Join on Load，也就是在导入的过程中，基于 StarRocks 来实现流式 Join。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2) 部分列更新能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;StarRocks 为了支持更好的 Upsert/Delete，提供了 PrimaryKey 表模型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;792&quot; data-ratio=&quot;0.5569620253164557&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Sq4ia0xXeMC6JXZvQz2JsLyCgJDCzQOX7UUPn9y6zeACG3U53Tic8uliaNIdiaYWmib7rWbEecFUozY216g4JvF3gAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1422&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如上图所示，最左侧是经典的 LSM 模型，也就是 Merge-on-Read 的形式。这种模型写入时不用去判断既有键位，对写友好，但读取时需要 Merge 合并，所以对读取数据不友好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而最右侧是 Copy-on-Write 的模型，典型的产品就是 DeltaLake。这种模型和 LSM 正好相反，有比较好的读效率，但是对于写入不是很友好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比较平衡读取和写入的，就是上图中间的两种 Record 级别冲突检查的模型，Kudu 的 Write Delta和StarRocks 的 Delete+Insert 模型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于维护了内存表，PrimaryKey 模型更适合冷热特征明显的场合，对热数据频繁的更新和删除更友好；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外非常适合 PrimaryKey 较少的表（如用户画像的宽表），虽然列很多，但是主键其实只有 UUID 这种字段。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;StarRocks 早期的 Unique 模型就是采用了最左边的 LSM 模型，因此查询效率较差，并且对于 Delete 不友好，结合 Flink 开发应用时，只能使用 Append 流进行 Sink。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;StarRocks 2.0 版本中新增加的 PrimaryKey 模型，提供了软删除字段，通过在内存中维护最新数据，使得查询时避免了 Merge 的过程，从而极大提升了查询性能，并且既可以使用 Append 流也可以使用 Retract 流进行 Sink，丰富了与 Flink 结合时的应用场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;86134&quot;&gt;&lt;section hm_fix=&quot;357:432&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;20%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;构建实时数仓的具体方法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;众所周知，在按照逻辑分层自下而上的构建实时数仓时，多流 Join 是有一定的技术门槛的。传统的实时计算引擎如  Storm、Spark Streaming 在这方面做的都不是很好。而Flink其实提供了很多通用的解决方法，如：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;基于 MapStat 做状态计算，或者 BroadcastStat 将维度缓存广播出去；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;用 Flink 关联外部热存储，如 HBase/Redis 等；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;一些相对稳定、更新频率低的维度数据或者码表数据，可以利用 RichFlatMapFunc 的Open方法，在启动时就全部加装到内存里；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;不限于以上这些，其实 Flink 已经在维度扩展上，给了开发者很多可以落地的选择。然而有了 StarRocks，我们会有更多的想象空间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如利用前面介绍的 Replace_if_not_null 的能力，开发者可以实现多个数据源稀疏写入宽表的不同列，来实现 Join-on-Load 的效果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外 StarRocks 强悍的 CBO 优化器在多表关联查询能力方面也表现优异，如果数据量不大或者在查询并发不高的场景，甚至可以把 Join 的逻辑下推到 OLAP 层来做，这样可以释放掉 Flink 上的一些构建负荷，让 Flink 专注于清洗和稳定的数据导入，而多表关联和复杂查询等业务逻辑在 StarRocks 上进行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不仅如此，还可以结合 Join-on-Load 和 Join on StarRocks 的两种形式，也就是稀疏写入有限张表，通过表之间做 Colocation join 策略，保证有限的表之间数据分布一致，做 Join 的时候没有节点间 Shuffle，在上层构建逻辑 View 面向查询。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;双剑方案1. 微批调度&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;792&quot; data-ratio=&quot;0.5649072753209701&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Sq4ia0xXeMC6JXZvQz2JsLyCgJDCzQOX7ricTb16iaeYZAvM6kDQ3ol01Csw9sS8Z7ZDjysiagltdtRribaBia9DnjzQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1402&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Flink 清洗导入 Kafka 的日志或者用 Flink-CDC-StarRocks 读取 MySQL Binlog 导入 StarRocks，ETL 过程中埋入批次处理时间，采用外围调度系统，基于批次处理时间筛选数据，做分钟级微批调度，向上构建逻辑分层。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种方案的主要特点是：StarRocks 作为 ETL 的 Source 和 Sink，计算逻辑在 StarRocks 侧，适用于分钟级延迟，数据体量不大的场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;双剑方案2. Flink 增量构建&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;327&quot; data-backw=&quot;578&quot; data-height=&quot;786&quot; data-ratio=&quot;0.5652173913043478&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Sq4ia0xXeMC6JXZvQz2JsLyCgJDCzQOX7CPzibGkCElBPHkqEukU44pjvOuAibj5e1NcHuOlVSl5B03orqFWPL87w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;92&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实时消息流通过 Kafka 接⼊，采用 Flink 进⾏流式 ETL、多流 Join、增量聚合等，在内存中完成分层构建，然后将相应的数据，层对层的通过 Flink-connector 写出到 StarRocks 对应表内。各层按需面向下游提供 OLAP 查询能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该方案的主要特点是：计算逻辑在Flink侧，适用于需要前导做较重ETL的场景，StarRocks 不参与 ETL，只承载 OLAP 查询，应对较高 QPS 查询负荷。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;双剑方案3. StarRocksView视图&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;778&quot; data-ratio=&quot;0.5613275613275613&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Sq4ia0xXeMC6JXZvQz2JsLyCgJDCzQOX7KTRua1aUX74IV64QyZvooiaLqTwkACs7uianXJQs0v6En18NbMjykgAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1386&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Flink 清洗导入 Kafka 的日志或者用 Flink-CDC-StarRocks 工具读取 MySQL Binlog 导入 StarRocks；根据需要选用明细、聚合、更新、主键各种模型，只物理落地 ODS 和 DIM层，向上采用 View 视图；利用StarRocks 向量化极速查询和 CBO 优化器满足多表关联、嵌套子查询等复杂 SQL，查询时现场计算指标结果，保证指标上卷和下钻高度同源一致。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该方案主要特点是：计算逻辑在 StarRocks 侧(现场查询)，适用于业务库高频数据更新的场景，实体数据只在 ODS 或 DWD 存储 (未来 StarRocks 提供多表 Materialized Views，将会进一步提升查询性能)。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;86134&quot;&gt;&lt;section hm_fix=&quot;365:434&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;20%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;最佳实践案例&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;前面我们介绍了一些联合 Flink 和 StarRocks 构建实时数仓的几种方法论，下面我们来看4个实际的客户案例。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;984&quot; data-ratio=&quot;0.5584562996594779&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Sq4ia0xXeMC6JXZvQz2JsLyCgJDCzQOX7ynFpKmnFxJg5nicltMGz4of8g1Bms2drFsnEzW5mW8gicgZIzLS0OicnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1762&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;汽车之家目前在智能推荐的效果分析、物料点击、曝光、计算点击率、流量宽表等场景，对实时分析的需求日益强烈。经过多轮的探索，最终选定 StarRocks 作为实时 OLAP 分析引擎，实现了对数据的秒级实时分析。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在数据处理流程上，SQLServer、MySQL、TiDB 等数据源，通过 CDC 打入多个 Topic主题，用 FlinkSQL 进行 ETL 清洗和聚合计算，然后通过 Flink-Connector 导入 StarRocks。早期选择的 Unique 表模型，由于业务有很多 Delete 操作，而 Merge-on-Read 的模型对Delete 支持不好，如果只做Update 而不做 Delete，会造成结果数据比业务库多的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最新的 PrimaryKey 模型支持了OP 字段（更新/删除操作），改为 PrimaryKey 模型后，数据结果与上游业务完全一致。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上图右侧是在硬件配置 6x 48c 256G、数据量 3500W+、有持续写入情况下，22 个 SQL 用例的测试情况，查询性能也比 Unique 模型有大幅提升。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在合理的选型和建模之后，汽车之家在实时平台 IDE上也做了很多工作，开发运维人员可以在页面里进行 DDL 建表，FlinkSQL 开发，作业的起停、上线管理等工作。结合 Flink-Connecotor，可以直接通过FlinkSQL 将加工后的数据导入 StarRocks，完成端到端的实时平台集成。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，利用 StarRocks 提供的 200 多个监控 Metric，汽车之家用 Prometheus 和 Grafana 等组件做了充分的可视化监控，即时查看集群的统计指标，把握集群的健康状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;964&quot; data-ratio=&quot;0.5578703703703703&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Sq4ia0xXeMC6JXZvQz2JsLyCgJDCzQOX7JjUibPiaNaIqjSL2YiaeqibgXqhZQeD9v5pt42Rltp2XDiaGKXTX1q4iafWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1728&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第2个案例&lt;/span&gt;&lt;span&gt;，顺丰科技的运单分析场景实践。在2021年双11大促活动中，运单分析场景应对了15w TPS 消息体量的实时数据导入和更新。整体的处理流程如图所示，多个业务系统中的数据源打到几个 Source Kafka，用 Flink 来对数据进行加工、字段补充、重新组织，然后整理后的数据打到若干个 Sink Kafka 主题，最后利用前面介绍的 Join-on-Load 的形式，将多个数据源的数据，稀疏的写入宽表的不同列，以此来实现宽表拼齐的过程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在具体使用上，顺丰科技将运单的数据根据更新的频度，划分为了2张宽表，按照相同的数据分布做成 Colocation 组，保证 Join 的时候没有额外的节点 Shuffle。一张表涉及的更新较少，命名为公表。另一张表涉及的更新较多，命名为私表。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;每个子表都利用了 Replace_if_not_null 的部分列更新的能力，合理的设计了维度和聚合指标，并引入了 Bloom Filter 索引加速筛选的效率，用日期做范围分区，用订单号做数据分布，配置了动态分区，自动淘汰冷数据。对外通过逻辑 View 的形式关联成一张宽表，底层是以现场 Join 的形式，整体面向业务提供查询服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;996&quot; data-ratio=&quot;0.5595505617977528&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Sq4ia0xXeMC6JXZvQz2JsLyCgJDCzQOX727n48whTgrAcxh3pYJtIywkUCbBjaagyYA5YEaZoHXib0iaavQOdAmZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1780&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第3个案例是来自多点 DMALL 的实时数仓实践。实时更新场景主要对实时监控经营的各项指标进行分析，如当前时间段内的 GMV 、下单数量、妥投数量、指标达成、对比、环比等指标分析，为客户的经营决策提供更具时效性的参考依据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;早期，针对数据为实时（秒级）更新的场景，主要使用 Impala on Kudu 引擎，采用 Lambda 架构，基于相同的主键，将流式的预计算的结果数据、批计算的结果数据，基于相同的主键进行 Merge。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个 Case 早期的架构如左图所示，ODS、DWD、DWS等分层在Kafka里承载，ADS层 在 Kudu/MySQL里，维表放在 HBase 里，采用 Flink 查询外表热存储的形式实现维度数据和事实消息的关联。如右图所示，经过梳理和改造，顺丰科技将 DWD 到 DWS 的聚合处理从 Flink 下沉到 OLAP 层，用 StarRocks 替换了Kudu，简化了预聚合链路，提升了开发效率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;994&quot; data-ratio=&quot;0.5553072625698324&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Sq4ia0xXeMC6JXZvQz2JsLyCgJDCzQOX7aYZKbajXS4dkKKnFNVibS5yah8P52FjicG7XHuGp7Bs3WwLpRkibNsrWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1790&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第4个案例是来自一个某车联网企业的 Fusion 数仓建设。随着新能源汽车的普及，车联网 IOT 数据的实时接入分析的需求也越来越多。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;业务逻辑如左图所示，传感器上报的仪表、空调、发动机、整车控制器、电池电压、电池温度等1000+传感器 Metric 要通过 Flink 做实时 ETL 清洗，同时要完成功能主题实时分拣、数据质量实时报告，最终满足于时序数据综合分析和可视化展示。技术上，大量采用 Flink.Jar 的工程代码开发，对于某些码值还涉及到 Flink 多流 Join 及状态计算。流量类的主题，采用 StarRocks 的增量聚合模型出聚合指标。也利用 FlinkSQL 对于运营分析类业务进行了实时数仓构建，将 ADS 层结果导入 StarRocks 供统一接口查询。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;整体上也是按照 Lambda 模型设计的，FLink 清洗整合后的合规数据，会通过落盘程序沉降到 HDFS，用于持久存储、离线数仓进行跑批及更复杂的模型训练，最终 Hive 的结果数据也会送到 StarRocks 供接口查询使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据逻辑设计如右图所示，上面为离线数仓，下面为实时数仓逻辑分层。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看到实时清洗后的 DWD 层数据会成为离线数仓的 ODS 层，而离线数仓构建好的一些相对固定的维表数据，也会用于实时数仓的流式维度扩展。实时数仓的逻辑分层相较于离线数仓更为简约，DWD明细层会存在于独立的 Kafka 或者在 Flink 内存中，DWS 层在 FlinkSQL 聚合完成后就直接下沉到 StarRocks了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里其实是进行了两次聚合，在 Flink 里进行了秒级的聚合，而 StarRocks 里的时间信息相关的维度列是到分钟或者15分钟的，利用 StarRocks 的聚合模型，将 Flink 汇聚的5-10s的聚合结果，再次汇聚到分钟级键位。这样设计有两个好处，第一，能够减少 LSM 模型的 Version版本，提升查询性能；第二，抽稀到分钟级后，更便于可视化展示，降低了前端取数的压力。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;86134&quot;&gt;&lt;section hm_fix=&quot;346:436&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;6&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;20%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;实时即未来， StarRocks 后续规划&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;关于 PrimaryKey 模型，后续版本即将支持部分列更新，进一步丰富 TP 业务库还原的能力；并在 PrimaryKey 模型上支持 Bloom Filter、Bitmap 等索引能力，进一步提升数据查询性能。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;资源隔离方面，后续 StarRocks 会发布自适应内存、CPU 分配能力，客户不再需要手动调整配置参数；未来也会支持多租户资源隔离的 Feature。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于 Apache Flink 项目的贡献方面，当前 Flink-Connector-StarRocks 还只具备 Sink 能力，后续会在Source 方面提供支撑，届时用户可以通过 Flink 分布式读取 StarRocks 数据，用 FlinkSQL 做跑批任务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，在 CDC 适配上，后续也会提供 Oracle/PostgreSQL 等更丰富的 TP 库的 DDL 自动映射能力，适应更多 CDC 应用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在云原生时代，StarRocks 已经开始了积极探索和实践，很快就会提供存储计算分离、异地容灾等能力，为客户提供弹性、可靠的 OLAP 层查询分析体验。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上就是本次分享的全部内容。实时即未来，欢迎大家一起加入到 Apache Flink 和 StarRocks 社区建设，共同探索出更多实时数仓的最佳实践。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>95e39acedae90e5a680ebef952b6e12c</guid>
<title>leo：从工程化角度出发的脚手架开源工具</title>
<link>https://toutiao.io/k/caqw3rq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;107046&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;strong data-brushtype=&quot;text&quot;&gt;前端脚手架的由来&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;前端脚手架是伴随着业务复杂度提升而来的提效工具。&lt;/p&gt;&lt;p&gt;在团队规模小或者业务比较简单的时候，项目的初始化往往是直接从一个已有的项目中拷贝出来，根据情况删掉一部分代码（之前业务强相关的或者不需要的功能等），再修修补补一部分，即可开始新的开发。&lt;/p&gt;&lt;p&gt;随着业务发展，几个人之间的拷贝已经不能满足需要（拷贝的源头无法追溯，出了问题也不知道是哪个版本的问题），项目初始化也变成了把这个模板代码放在 git 仓库中维护起来，需要新建项目时，将代码克隆下来，删除 .git 目录，再重新上传到新项目的仓库。&lt;/p&gt;&lt;p&gt;伴随着业务的复杂度上升，模板代码的仓库也变得多了起来，在新建一个项目时，开发人员不仅要在众多仓库中找到应该克隆哪个仓库，还需要每次都走一遍流程：克隆代码 → 删除.git目录 → 关联并 push 到新仓库，为了提高效率，开发将这个过程封装成 CLI 命令，如 fe-cli，在新建项目时仅需执行fe-cli projectName即可。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;107046&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;strong data-brushtype=&quot;text&quot;&gt;前端脚手架的现状&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在前端开发的流程中，一个典型的开发流程大概是这样的：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.09259259259259259&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFibCeUhemgqlhp0PJaYgtojEEsxxiaqRxHUkoPOTkJNF7ViaQeaWY86GuFlhQ2iaLq2mG4ONmSLdyYhVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1404&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;脚手架的作用仅存在于第一步，在初始化后的每一步骤中，全部是由开发自定义的（通常是小组或团队内部的规范）：使用什么方式构建，使用哪个测试工具，代码 lint 的标准，部署时如何审批等等。即便是小范围的内部规范，在不同的项目内，也有可能存在差异。&lt;/p&gt;&lt;p&gt;不仅如此，脚手架通常存在于内部的小团队内，这些脚手架提供的模板即便是非常优秀，也往往局限在内部，无法被其他团队发现和使用，导致只能做到团队内部的提效，无法在团队、部门甚至公司层面做到复用和标准化。&lt;/p&gt;&lt;p&gt;上述的是老团队的情况，而对于一个新组建的团队来说，在繁重业务开发中想要抽取人力去开发一个脚手架往往是有心无力的，团队内的初始化可能又回到了复制粘贴的时代。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;107046&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;strong data-brushtype=&quot;text&quot;&gt;leo提供的解决方案&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;针对上述痛点，我们的团队在调研并收集开发同学意见后，开发了leo脚手架作为解决方案，如下图所示，各团队内部相互闭塞的开发改为由leo统一提供服务，团队内部不仅降低了维护自己脚手架的成本，还可以享受到其他团队提供的服务。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5583892617449664&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFibCeUhemgqlhp0PJaYgtojESAk9FHKxLXWb3Zg1hUjlKZW1e5b5sic6qcPHMYDYluHjgmONSykgOnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1490&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;零成本接入&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;90%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;无论是新团队接入，还是老团队将就有项目模板迁移，仅需使用leo init template初始化出一个模板文件，将自己的模板项目移入template文件夹中并推送到远端（在初始化时，leo会在template市场中自动创建并关联项目）。推送后，就可以通过leo init your-template-name来初始化你的模板了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;覆盖开发全链路&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;90%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;不同于过去脚手架仅在初始化中发挥作用，leo通过模块化的设计，使得指令覆盖于开发的全链路当中。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.20885200553250347&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFibCeUhemgqlhp0PJaYgtojELia4TVAXyuiaa4ia0xl3lTPogCjHXNISynQ4ib4MUE3g3tibKCyf9R0bfSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1446&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在开发的每个流程中，都可以使用官方或者自定义的工具来支持当前流程的功能，以开发调试为例，官方提供了react-builder作为默认的构建工具，但是如果你使用的是gulp，rollup等其他构建工具，可以通过编写一个builder来支持项目的构建流程（与模板接入相同，仅需初始化后写入构建功能并推送即可）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;03&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;leo市场&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;90%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在上述接入的描述中你可能已经发现，在初始化一个模板或者builder文件时，leo会同时将这个项目同步到对应市场中，从前仅在团队内部使用的模板与构建功能将会服务于更多的leo使用者。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.264&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFibCeUhemgqlhp0PJaYgtojE5zF19Cpb5dbmcvy0HGiaJoWiaibfOdaX7t4AjSicn6JmS0h1sa0ibdpf4aA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1500&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;107046&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;strong data-brushtype=&quot;text&quot;&gt;leo的设计思路&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5501355013550135&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFibCeUhemgqlhp0PJaYgtojESCMicqe9S9QqYVrUtVhTtYW2wRRgHAPia5zW5ZR4z41MTR2kKhDvHIyg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1476&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;分层设计&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;leo的结构设计分为3层，核心逻辑层，功能模块层和业务逻辑层，每个分层如命名所示按照功能区分，分层之间单向依赖。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;模块化&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在每个分层中，不同的功能模块负责各自的使命，Core负责登录，埋点（leo的数据统计）等，Cli负责处理命令行指令，并提供命令行交互，Generator负责模板生成，builder负责构建及本地开发。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;多扩展&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;业务逻辑层的template市场和builder市场实际是由开发者共同维护的，leo仅提供了一些基础的模板和构建器，每个开发者及团队都可以在市场中进行发布，发布后受惠的也不再局限于个人和团队内部，任何人都可以看到下载并使用（最佳实践：使用leo开发的通天塔ihub楼层已达300+）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;107046&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;strong data-brushtype=&quot;text&quot;&gt;如何使用&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;leo作为一个脚手架框架，你需要做一些必要的配置才能在本地运行。&lt;/p&gt;&lt;p&gt;1. 创建项目并安装&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2857142857142857&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFibCeUhemgqlhp0PJaYgtojE1MVejcibLEOVibEylMgj8J7fibAtFlv6fbc6CBIyc6x3PXC8HNDDgA1qw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;532&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2. 新建一个脚手架项目目录如下&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.721830985915493&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFibCeUhemgqlhp0PJaYgtojEicB7WoEMYsKaicBiaZPn0llE78vric5mf31yWzpEBtWwQeg71Ewmj6pvsw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;568&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;3. package.json中声明你的指令入口&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.450402144772118&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFibCeUhemgqlhp0PJaYgtojEXKzAs4AbehRX4NIysJSD0rbBicxMoY46rR716DibvTQcmDT6zib3VSBvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;746&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;4. 在bin/index.js中配置leo/core并启动&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.1137931034482758&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFibCeUhemgqlhp0PJaYgtojELvHgGbmkhicvo29sDuESYpr3Bic2aV8ShSzX4WtUXTbZXVVBHIT6NpSg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1160&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;查看更多配置项&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;https://github.com/JDFED/leo/blob/master/docs/config.md&lt;/p&gt;&lt;p&gt;&lt;strong&gt;更多文档&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;* rc 配置说明&lt;/p&gt;&lt;p&gt;https://github.com/JDFED/leo/blob/master/docs/leorc.md&lt;/p&gt;&lt;p&gt;* meta配置说明&lt;/p&gt;&lt;p&gt;https://github.com/JDFED/leo/blob/master/docs/meta.md&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;107046&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;strong data-brushtype=&quot;text&quot;&gt;开源撒花（对内、对外）&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;leo脚手架作为脚手架框架（与内部使用略有不同）已开源至github，为更多开发者提供了便利，github地址（https://github.com/JDFED/leo），欢迎star~&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d29920772e8ba2a9e36a55a602178fb6</guid>
<title>基于etcd实现大规模服务治理应用实战</title>
<link>https://toutiao.io/k/dx6dcgu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                                    


                
                
                
                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;fieldset&gt;&lt;section data-brushtype=&quot;text&quot;&gt;架构师（JiaGouX）&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;我们都是架构师！&lt;br/&gt;架构未来，你来不来？&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/fieldset&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAwNjQwNzU2NQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/sXiaukvjR0RCNb3RYsCgx02T4J55ia2SnemY7uJHsDChxq6jAibbATlIKDgzLxz0zekXWjblzCDcL86AjbMNp02Tg/0?wx_fmt=png&quot; data-nickname=&quot;架构师&quot; data-alias=&quot;JiaGouX&quot; data-signature=&quot;架构师云集，三高（高可用、高性能、高稳定）架构、大数据、机器学习、Java架构、系统架构、大规模分布式架构、人工智能等的架构讨论交流，以及结合互联网技术的架构调整，大规模架构实战分享。欢迎有想法、乐于分享的架构师交流学习。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;导读：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;服务治理目前越来越被企业建设所重视，特别现在云原生，微服务等各种技术被更多的企业所应用，本文内容是百度小程序团队基于大模型服务治理实战经验的一些总结，同时结合当前较火的分布式开源kv产品etcd，不仅会深入剖析ectd两大核心技术Raft与boltdb的实现原理，也会披露服务治理真实实践的经验，希望帮助大家在服务治理的道路上获得更多帮助。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;全文8243字，预计阅读时间21分钟。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一、服务治理概念介绍&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;服务治理是IT治理的一部分，它关注服务生命周期中的相关要素，其重点环节包括服务注册和发现、服务平滑升级、流量监控、流量管控、故障定位、安全性等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;服务是需要&quot;治理&quot;的，但是治理是需要成本的，如果一个服务的业务逻辑简单，运行流程清晰，出现问题也能及时定位和回滚，那么该服务治理的成本可能非常低，甚至只需要人工处理就行，但是在复杂业务中，服务的提供者和服务的使用者可能分别运行在不同的进程中（甚至在不同的物理节点上），并由不同的团队开发和维护。团队协作和服务协同，都需要进行大量的协调工作。协调工作越多，复杂度越高，这样就有了服务治理的需求，通过建设统一的服务治理平台，就可以有有效的提升业务的服务治理能力，包括协同的规范化、实时监控，不断优化调用链路的效率，以及辅助降低依赖复杂度，规避风险等。在大型业务系统中，服务治理已经是技术架构中必不可缺的一部分，也是整个业务系统最重要的基础设施之一。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5598290598290598&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5p8giadRibbOicObQbU2lbIEmpzNCM2YicVgasUVyJIdaD7ibTHsoMWAsqxy8Via6aBpIbbof90N4hyTWCiawNkhkT1oA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;936&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;上图是网上流传的netflix的服务拓扑图，图中密密麻麻的白色小点就是netflix的服务节点，节点之间的连线表明服务之间有调用，节点和连线构成了复杂的服务调用链，如此庞大的应用系统必须要通过一个强力的服务治理平台来进行管理。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;服务治理本质上是对服务生命周期的管控，因而服务治理平台的核心需求就是如何解决服务生命周期中的痛点问题，其包括以下几个方面：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;1、注册和发现&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;服务调用方在调用服务之前必须要得到服务提供方的地址，也就是调用方需要通过一种方式“发现“服务提供方，这就是服务发现。而要完成服务发现，就需要将服务提供方的信息存储到某个载体，这个存储的动作即是”服务注册“，而存储的载体则称为”服务注册中心“。在任何一个服务治理平台中，&quot;注册中心&quot;是必不可少的一个模块。服务注册和发现是服务治理中最基础的功能，在服务生命周期中，它负责服务的初始环节。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;2、流量监控&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;在服务注册发现之后，就是服务的调用，大量的服务调用，形成了流量。流量监控就是对众多服务间的调用关系、状态的清晰掌控。其主要包括了调用拓扑关系、调用追踪、日志、监控告警等，服务治理通过调用拓扑来整体监控服务调用关系，通过建立监控体系来快速发现、定位问题，从而在整体上感知业务系统的运行状况。在服务生命周期中，流量监控负责服务的运行态感知。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;3、流量调度&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;在业务系统运行过程中，经常会有比如促销、秒杀、明星绯闻等热点问题，或者机房断网、断电、系统大范围升级等突发事件，带来业务系统中局部服务的流量突增突降，这样就需要对服务的流量进行调度和管理。流量管理包括两个方面：从微观的单个服务来说，就是服务调用过程的管理，包括在何时采用何种均衡负载策略、路由策略以及熔断限流策略，这些策略统称为调用策略；从宏观上来说，就是流量分发的管理，可以根据某些流量特征和流量占比进行灰度发布、蓝绿发布等，这些称为流量分发策略。服务调用策略、流量分发策略，都需要通过流量监控收集的调用数据进行分析，从而制定出决策，然后在服务治理平台上落地。流量调度负责服务的运行态管理。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;4、服务控制&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;流量调度的策略如何在服务的提供方和调用方生效，可以重启生效，也可以在运行态实时生效，这就是看服务治理平台对服务的控制力度，服务治理平台在充分建设服务治理能力后，能实时把服务治理的策略向服务进行分发并立即生效。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;5、服务安全&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;每个服务都承载自身的业务职责，一些业务敏感的服务，需要对其他服务的访问进行认证与鉴权，也就是安全问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;本文把拥有成千上万的服务称之为大型应用系统，该系统的特征是大量的服务、大量的服务实例、以及海量的服务调用，服务治理平台在管理这类业务系统的服务时，需要面对&lt;strong&gt;以下巨大的挑战：&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;1.  高可靠性&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;大型业务系统，海量的服务调用，错综复杂的调用关系，对服务的可靠性要求很高，很多基层的服务都要求99.99%的可靠性，因而维护这些服务的服务治理平台，其可靠性的要求也非常高，而要达到这么高的可靠性，服务治理平台本身也需要做到多级部署、多地热备、降级隔离、平滑上线等方案。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;2.  高性能&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;在保证可靠性的前提下，服务治理还必须有很高的性能，比如在监控数据中，快速准确的感知到某个服务的出现了单点故障，从而能够将流量分发到该服务的其他进程上去。如果业务系统的服务数不多，调用量不高，那么监控数据量也不会很大，服务的单点故障很容易就能查到，但是在实时的海量调用数据中，一些常规的查询手段要花费大量的时间，等感知到单点故障时，可能已经造成了不可挽回的业务损失。所以性能是考量服务治理平台治理能力的一项重要指标，如何保证高性能，高速的存储、多级缓存、线性部署都是必不可少的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;3.  高扩展&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;高扩展包含两个方面：大型应用系统的服务，可能是由多个团队在开发运维，其水平和技术能力也是参差不齐的，因而服务治理平台需要提供兼容和扩展的能力，通过扩展性，尽可能的把不同的服务治理起来；同时，在业务系统服务量增长时，服务治理平台也应该具备同步扩展的能力，来保证其高可靠和高性能。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;面对海量服务的治理挑战，服务治理平台也需要有一个强大好用的存储工具来应对，etcd就是一个不错的选择。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二、etcd介绍&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.1 etcd发展背景与相关竞品介绍&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;2013年CoreOS创业团队在构建一款开源，轻量级的操作系统ContainerLinux时，为了应对用户服务多副本之间协调的问题，自研开发的一款用于配置共享和服务发现的高可用KV分布式存储组件——ETCD。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;下面我们也针对Zookeeper和Consul两个选型做了一下对比：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;·       ZooKeeper&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;ZooKeeper从高可用性，数据一致性，功能这三个方面而言是完全符合需求的，但CoreOS还是坚持自研etcd的原因总结有以下两点：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1.  ZooKeeper不支持通过API安全地变更成员，需要人工修改节点配置并重启进程.如果操作有误，有可能导致脑裂等线上故障，同时CoreOS对适配云环境，集群规模的平滑调整，运行时配置的在线变更都是有期望目标的，这方面ZooKeeper的维护成本比较高。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2.  &lt;/span&gt;&lt;span&gt;高负载读写性能，ZooKeeper在大规模的实例连接情况下性能表现并不佳。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;etcd名字是由&lt;span&gt;“&lt;/span&gt;&lt;span&gt;/etc”&lt;/span&gt;文件夹和”d”分布式系统组成。“/etc”文件夹是用来存储单系统配置数据的，而&lt;span&gt;“&lt;/span&gt;etcd”用于存储大规模分布式系统的配置数据，etcd集群可提供高稳定性，高可靠性，高伸缩性和高性能的分布式KV存储服务。etcd是基于复制状态机实现的，由Raft一致性模块，日志模块，基于boltdb持久化存储的状态机组成，可应用于分布式系统的配置管理，服务发现，分布式一致性等等。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;ZooKeeper与etcd一样，可解决分布式系统一致性和元数据存储等问题，但是etcd相较于ZooKeeper有以下几点优势：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1.  动态集群成员关系重新配置&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2.  高负载下稳定的读写能力&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3.  多版本并发控制数据模型&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4.  可靠的键监控&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;5.  Lease(租约)原语将连接和会话分离&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;6.  分布式锁保证API安全性&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;7.  ZooKeeper使用自己的RPC协议，使用受限；而etcd客户端协议是基于gRPC的，可支持多种语言。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;·       Consul&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Consul与etcd解决的是不同的问题，etcd用于分布式一致性KV存储，而Consul侧重于端到端的服务发现，它提供了内置的健康检查，失败检测和DNS服务等等，另外Consul通过RESTfulHTTPAPIs提供KV存储能力.但是当KV使用量达到百万级时，会出现高延迟和内存压力等问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一致性算法方面，etcd、Consul基于Raft算法实现数据复制，ZooKeeper则是基于Zab算法实现。Raft算法由Leader选举，日志同步，安全性组成，而Zab协议则由Leader选举、发现、同步、广播组成。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;分布式CAP方面，etcd、Consul和ZooKeeper都是CP系统，发生网络分区时，无法写入新数据。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;下表是针对三者的关键能力做了一下对比分析:&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6393805309734514&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5p8giadRibbOicObQbU2lbIEmpzNCM2YicVgJUdUy5nkI3Nsx6MB1eBZ9RdqUibKdATA58htMuQsctXicHKXVck4ZchA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;904&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.2 etcd核心技术介绍&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;基于Raft协议实现数据高可用和强一致性&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;早期数据存储服务引入多副本复制技术方案来解决单点问题，但是无论是主从复制还是去中性化复制，都存在一定的缺陷。主从复制运维困难，且一致性与可用性难以兼顾；去中心化复制，存在各种写入冲突问题需要业务处理。而分布式一致性算法，正是解决多副本复制存在问题的关键。分布式一致性算法，又称为共识算法，最早是基于复制状态机背景下提出来的。Paxos作为第一个共识算法，过于复杂，不容易理解，难以在工程上落地。斯坦福大学的Diego提出的Raft算法，通过将问题拆解为三个子问题，易于理解，降低了工程落地难度。这三个子问题是：&lt;strong&gt;Leader选举，日志复制，安全性。&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Leader选举&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;etcd(版本3.4+)中Raft协议定义集群节点有4种状态：&lt;/span&gt;&lt;strong&gt;Leader、Follower、Candidate、PreCandidate。&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;正常情况下，Leader节点会按照心跳间隔时间，定时广播心跳消息给Follower节点，以维持Leader身份。Follower收到后回复心跳应答包消息给Leader。Leader都会带有一个任期号(term)，任期表示从一次选举开始，赢得选举的节点在该任期内担当Leader。任期号单调递增，在Raft算法中充当逻辑时钟，用于比较各个节点数据新旧，识别过期Leader等等。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当Leader节点异常时，Follower节&lt;/span&gt;&lt;span&gt;点会接收Leader的心跳消息超时，当超时时间大于竞选超时时间后，会进入PreCandidate状态，不自增任期号，仅发起预投票(民意调查，防止由于节点数据远远落后于其他节点而发起无效选举)，获得大多数节点认可后，进入Candidate状态.进入Candidate状态的节点，会等待一个随机时间，然后发起选举流程，自增任期号，投票给自己，并向其他节点发送竞选投票信息。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;当节点B收到节点A竞选消息后，有2种情况：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1.  节点B判断节点A的数据至少和自己一样新，节点A任期号大于节点B任期号，并且节点B未投票给其他候选者，即可投票给节点A，节点A获得集群大多数节点支持，可成为新Leader。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2.  如果节点B也发起了选举，并投票给自己，那么它将拒绝投票给节点A。此时若没有节点可以得到大多数投票支持，则只能等待竞选超时，开启新一轮选举。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.42450142450142453&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5p8giadRibbOicObQbU2lbIEmpzNCM2YicVgjCgB1UwdpzUnGk4icLRbPS0tDX0IExQqF88CPXkLIuvRRFWAticV5Fgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;702&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;span/&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;日志复制&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;Raft日志结构如下图所示：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4843304843304843&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5p8giadRibbOicObQbU2lbIEmpzNCM2YicVgzEletIaWgl0iaUOrK5OhYGKzZWUJbtUwGOibqVSzY6Q1UPjTwhPwn97w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;702&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Raft日志由有序索引的一个个条目组成，每个日志条目包含了任期号和提案内容.Leader通过维护两个字段来追踪各个Follower的进度信息.一个是NextIndex，表示Leader发送给该Follower节点的下一个日志条目索引;另一个是MatchIndex，表示该F&lt;/span&gt;&lt;span&gt;ollower节点已复制的最大日志条目索引。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;本文以Client提交“hello=world”提案，至接收到响应的整个流程为例，简单介绍&lt;/span&gt;&lt;span&gt;etcd日志复制流程：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1.  当Leader接收到Client提交的提案信息后，生成日志条目，同时遍历各个Follower的日志进度，生成对各个Follower追加日志的RPC消息；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2.  通过网络模块将追加日志的RPC消息广播给各个Follower；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3.  Follower接收到追加日志消息并持久化之后，回复Leader已复制最大日志条目索引，即MatchIndex；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4.  Leader接收到Follower应答后，更新对应Follower的MatchIndex；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;5.  Leader根据各个Follower提交的MatchIndex信息，计算出日志条目已提交索引位置，该位置代表日志条目被一半以上节点持久化；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;6.  Leader通过心跳告知各个Follower已提交日志索引位置；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;7.  当Client的提案，被标识为已提交后，Leader回复Client该提案通过。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;通过以上流程，Leader同步日志条目给各个Follower，保证etcd集群的数据一致性。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;安全性&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;etcd通过给选举和日志复制增加了一系列规则，来保证Raft算法的安全性。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;选举规则:&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1.  一个任期号，只能有一个Leader被选举，Leader选举需要集群一半以上节点支持；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2.  节点收到选举投票时，如果候选者最新日志条目的任期号小于自己，拒绝投票，任期号相同但是日志比自己短，同样拒绝投票。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;日志复制规则:&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1.  Leader完全特性，如果某个日志条目在某个任期号中已被提交，则这个日志条目必然出现在更大任期号的所有Leader中；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2.  只附加原则，Leader只能追加日志条目，不能删除已持久化的日志条目；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3.  日志匹配特性，Leader发送日志追加信息时，会带上前一个日志条目的索引位置(用P表示)和任期号，Follower接收到Leader的日志追加信息后，会校验索引位置P的任期号与Leader是否一致，一致才能追加。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;boltdb存储技术&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;ectd的另一个核心技术是boltdb存储，提供高效的b+树的检索能力，同时支持事务操作，他是支撑etcd高性能读写的关键能力之一。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;boltdb的实现参见了LMDB(LightningMemory-Mappe&lt;/span&gt;&lt;span&gt;dDatabase)设计思路，基于高效快速的内存映射数据库方案.基于B+树的结构设计。数据文件设计上bolt使用一个单独的内存映射的文件，实现一个写入时拷贝的B+树，这能让读取更快。而且，BoltDB的载入时间很快，特别是在从crash恢复的时候，因为它不需要去通过读log（其实它压根也没有）去找到上次成功的事务，它仅仅从两个B+树的根节点读取ID。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;br/&gt;&lt;/h4&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;文件存储设计&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;由于采用了单文件映射存储，所以bolt对文件按指定长度进行分块处理，每块存储不同的内容类型。默认使用4096字节的长度进行分块。每一块的开头有单独的pageid(int64)标识。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;文件块的类型有以下几种：&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;类型&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;Flag标识&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;个数&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;长度&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;说明&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;meta&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;0x04&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;2&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;80字节。其余为空&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;元数据信息。包含存储B+树root buck位置，可用块的数量freelist，当前最大块的offset等。分为metaA与metaB, 用来控制进行中的事务与已完成的事务(写事务只有一个进行中).  根据meta中的txid的值的大小来判断当前生效的是哪个meta。（txid会根据事务操作递增）&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;freelist&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;0x10&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;1或多个&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Overflow引用&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;变长&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;Freelist用于管理当前可用的pageid列表。由Meta元数据信息中的freelist字段来定位所在的pageid位置。&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;【data】bucket&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;0x01&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;1或多个&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Overflow引用&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;变长&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;存储bucket名称数据，bucket名称也是采用B+树结构存储。根root bucket的pageid由meat的root字段指定&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;【data】branch&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;0x01&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;1或多个&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Overflow引用&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;变长&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;存储分支数据内容。分支数据结构中只有key信息，没有value信息。指向的都是下一级节点的pageid信息&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;【data】leaf&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;0x02&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;1或多个&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Overflow引用&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;变长&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;存储叶子数据内容。&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;554&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.9586864406779662&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5p8giadRibbOicObQbU2lbIEmpzNCM2YicVgoL3xRVjcibyoEDMbIlPRh9mPicw23RdbqRIS8NnAVhK1YZxkIfibFEZNg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;944&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据文件全景结构&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;说明：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;ul type=&quot;disc&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;metapage固定在page0与page1位置&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Pagesize大小固定在4096字节&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul type=&quot;disc&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;bolt的文件写入采用了本地序（小端序）的模式，比如16进制0x0827(2087)写入的内容为2708000000000000&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;单文件方案的优势就是不需要做文件的合并删除等操作，只需要在原文件上追加扩展长度就可以了。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;br/&gt;&lt;/h4&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;查询设计&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;boltdb提供了非常高效的查询能力，可以先看一下它的对象设计：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.963265306122449&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5p8giadRibbOicObQbU2lbIEmpzNCM2YicVgfnZMLEgrUeHdXE6HXdrGuQ9kqmalXOpLsrkHqlmJoCApho5iaiaaFU0A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;490&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;从对象设计上，boltdb在加载时，会先loadmeta数据进内存，然后根据bucket，来定位数据块所在的位置，然后再根据key的值，来定位branchnode的位置，然后定位到叶子值节点。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们以查询为例，来讲解一下，下面是一个基本的查询示例代码：&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;tx, err := db.Begin(&lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  b := tx.Bucket([]&lt;span class=&quot;code-snippet__keyword&quot;&gt;byte&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;MyBucket&quot;&lt;/span&gt;)) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  v := b.Get([]&lt;span class=&quot;code-snippet__keyword&quot;&gt;byte&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;answer20&quot;&lt;/span&gt;)) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  fmt.Println(&lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;(v))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  tx.Commit()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对应上面的代码，下面的序列图，可以更详细的了解一次查询的操作流程：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0655270655270654&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5p8giadRibbOicObQbU2lbIEmpzNCM2YicVgNdNNsZ5I6zN0giaL2fJIUicpzicL1U8ickOMwFoPia7UVNuVibPAApyRROvw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;702&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;上面最关键的代码就是search方法，下面是主要的代码片断，已添加了注释说明方便阅读。&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__built_in&quot;&gt;c&lt;/span&gt; *Cursor)&lt;/span&gt;&lt;/span&gt; search(key []byte, pgid pgid) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    p, n := &lt;span class=&quot;code-snippet__built_in&quot;&gt;c&lt;/span&gt;.bucket.pageNode(pgid)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; p != &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; &amp;amp;&amp;amp; (p.flags&amp;amp;(branchPageFlag|leafPageFlag)) == &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        panic(fmt.&lt;span class=&quot;code-snippet__type&quot;&gt;Sprintf&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;invalid page type: %d: %x&quot;&lt;/span&gt;, p.id, p.flags))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    e := elemRef{page: p, node: n}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;c&lt;/span&gt;.stack = append(&lt;span class=&quot;code-snippet__built_in&quot;&gt;c&lt;/span&gt;.stack, e)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; e.isLeaf() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__built_in&quot;&gt;c&lt;/span&gt;.nsearch(key)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; n != &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__built_in&quot;&gt;c&lt;/span&gt;.searchNode(key, n)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;c&lt;/span&gt;.searchPage(key, p)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;三、百度基于etcd打造大规模服务治理建设思路&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.1 具体的挑战&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;天路是百度小程序团队开发打造的面向大型业务服务治理需求的一套解决方案，其目标之一就是打造成百度的服务治理规范样板。天路由注册中心、可视化管理平台、SDK框架、统一网关、tianlu-mesher五个部分组成，目前已经接入了150+产品线，实例数已达数十万级别。随着接入平台的团队数增多、以及服务实例的快速增长，大量团队间如何轻松的协作以及实现大规模服务治理平台的高可用、高性能一直是天路持续面临的挑战。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.2 整体架构建设思路与方案&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;天路作为一个服务治理平台，核心理念是为所有的服务提供便捷的调用，统一的服务监控管理，简化服务的开发和维护成本。我们从以下不同的方面思考基于etcd打造大规模服务治理平台：高可用、高性能、高扩展、易用性。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;·       高可用&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;·       高性能&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;·       高扩展&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;·       易用性&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;用户通过可视化的管理平台可以查看已注册的服务，也可通过管理平台实时更新服务治理策略的配置，实时调整服务治理策略。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;将调用日志接入trace平台，用户可通过traceId在trace平台查到整个调用链的记录，便于出错时进行快速的问题定位。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;多语言 SDK，支持多种rpc技术，包括百度自研的rpc技术brpc(&lt;/span&gt;&lt;span&gt;https://github.com/baidu/Jprotobuf-rpc-socket【java&lt;/span&gt;&lt;span&gt;/go sdk】）和http jsonrpc协议等&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6296296296296297&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;702&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5p8giadRibbOicObQbU2lbIEmpzNCM2YicVggJdBcCmqmd7XD83Gib7g6NmMp2DSaD9EjwPmVSoJoibtdcxNicZwW1Wyg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;架构方案图&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.3 关键的指标与运维目标&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;此外针对更好的实施服务治理平台的运维，还需要以下的关键考核指标与运维要求。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;关键指标：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;·       可用性达99.99以上；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;·       平响100ms以下。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;运维目标：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;·       配置监控告警，包括注册中心实例健康、etcd平响、内存和cpu监控。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;·       自动处理：通过noah的回调机制，自动处理一些故障，提高处理速度。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;·       手动处理：值班机制。&lt;/span&gt;&lt;/section&gt;&lt;h1&gt;&lt;br/&gt;&lt;/h1&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;四、总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;服务治理目前越来越被企业建设所重视，特别现在云原生，微服务等各种技术被更多的企业所应用，但是要真正在应用好，融合好，还是有非常多的挑战，除了一套成熟的服务治理产品外，包括团队整体对服务治理的认知，技术经验的深淀，遵循服务化的设计能力水平的能力等，都会影响到最终的实施效果。本文也仅在服务治理产品选型上给大家一些启发，希望在服务治理的道路上帮大家走得更好更稳。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;如喜欢本文，请点击右上角，把文章分享到朋友圈&lt;/span&gt;&lt;br/&gt;&lt;span&gt;如有想了解学习的技术点，请留言给若飞安排分享&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;·END·&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong/&gt;&lt;/p&gt;&lt;pre&gt;&lt;p&gt;&lt;strong&gt;相关阅读：&lt;/strong&gt;&lt;/p&gt;&lt;hr/&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools-id=&quot;23409&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;作者：百度小程序团队&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;来源：百度Geek说&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;版权申明：&lt;/span&gt;&lt;span&gt;内容来源网络，版权归原创者所有。&lt;/span&gt;&lt;span&gt;除非无法确认，我们都会标明作者及出处，如有侵权烦请告知，我们会立即删除并表示歉意。&lt;/span&gt;&lt;span&gt;谢谢!&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;article ng-controller=&quot;EntryCtrl&quot; ui-lightbox=&quot;&quot;&gt;&lt;section ng-bind-html=&quot;postContentTrustedHtml&quot;&gt;&lt;section data-id=&quot;702&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong data-brushtype=&quot;text&quot;&gt;架构师&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;我们都是架构师！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img border=&quot;0&quot; class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/sXiaukvjR0RB58TtkIHwhn4lpsqLnZgian9d5tr1BibP7XpibGTFFib1nq9YuYq209XZUEfCOqMzepDOBbN9KD9wMSg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot; data-width=&quot;200px&quot; height=&quot;&quot; opacity=&quot;&quot; title=&quot;&quot; vspace=&quot;0&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;strong&gt;关注&lt;/strong&gt;架构师(JiaGouX)，添加“星标”&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;获取每天技术干货，一起成为牛逼架构师&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;技术群请&lt;/strong&gt;&lt;strong&gt;加若飞：&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;1321113940 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;进架构师群&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;投稿、合作、版权等邮箱：&lt;strong&gt;&lt;span&gt;admin@137x.com&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/article&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>