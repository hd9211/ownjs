<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>bed58551b89afef0225eee9128756f4a</guid>
<title>给老板解释解释，为什么要用 Spring Cloud Alibaba 作为微服务开发框架？</title>
<link>https://toutiao.io/k/pzyuz5d</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;什么是微服务&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提到微服务不得不提Martin Fowler在2014年3月25日发表的文章 Microservices，里面给出了微服务的定义。后续国内所有关于微服务的介绍都是基于这篇文章的翻译，或加上自己的理解而成。其中最重要的一段如下：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;In short, the microservice architectural style [&lt;/span&gt;1]&lt;span&gt; is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery. There is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies.&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;翻译过来就是：微服务这种架构风格就是把一组小服务演化成为一个单一的应用的一种方法。每个应用都运行在自己的进程中，并通过轻量级的机制保持通信，就像HTTP这样的API。这些服务要基于业务场景，并使用自动化布署工具进行独立的发布。可以有一个非常轻量级的集中式管理来协调这些服务，可以使用不同的语言来编写服务，也可以使用不同的数据存储。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;如何实现微服务&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相对于单体式架构的简单粗暴，微服务架构将应用打散，形成多个微服务进行独立开发、测试、部署与运维。虽然从管理与逻辑上更符合业务需要，但微服务架构也带来了诸多急需解决的核心问题：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如何发现新服务节点以及检查服务节点的状态？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如何发现服务及负载均衡如何实现？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;服务间如何进行消息通信？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如何对使用者暴露服务 API？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如何集中管理众多服务节点的配置文件？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如何收集服务节点的日志并统一管理？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如何实现服务间调用链路追踪？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如何对系统进行链路保护，避免微服务雪崩？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以发现，上述这些问题并不是针对某种语言或某种技术的，任何软件厂商要构建微服务架构就必须面对这些问题，要么独立开发要么将已有多种技术整合形成整体解决方案。好在经过多年沉淀，业内已经有了标准答案，下图清晰的说明微服务架构需要的标准组件。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.091816367265469&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4gib1YOYq1OPet1rIUeLWz8kljSuQGYsxk7VeJibD8Vr2DkOIGI1Xic2ISs8DKh8nnaCvQYAicKicWzcYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;501&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;br/&gt;API网关：&lt;/strong&gt; 封装了系统内部架构，为每个客户端提供一个定制的 API。在微服务架构中，服务网关的核心要点是，所有的客户端和消费端都通过统一的网关接入微服务，在网关层处理所有的非业务功能。&lt;img data-ratio=&quot;0.7970660146699267&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4gib1YOYq1OPet1rIUeLWz8k7viazGticwK2QzuSndkD6nM5ibbSibUt1p6TrQ2dN10S2rDcg5iaiaiaXBsibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;409&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注册中心：&lt;/strong&gt; 微服务架构体系中最核心的技术组件，它起到新服务节点的注册与状态维护的作用。诸如 Dubbo、Spring Cloud 等主流的微服务框架都基于 Zookeeper、Eureka 等分布式系统协调工具构建了服务注册中心。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7211394302848576&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4gib1YOYq1OPet1rIUeLWz8kFDdPrVjGyiayJDFbLB7vMGB6J2lhVSSib2iaWqhqWiaEibdIexsyBdV86Ng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;667&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;br/&gt;服务路由：&lt;/strong&gt; 通过注册中心构建了一个多服务的集群化环境中，当客户端请求到达集群，如何确定由哪一台服务器进行请求响应呢？这就是服务路由问题。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7953615279672579&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4gib1YOYq1OPet1rIUeLWz8k5vOzTicS4ZBNzMicicJKgzRQ4YJkalZvFPK5t1vvNYJvkAllKcKnRo2IQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;733&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;br/&gt;服务通信：&lt;/strong&gt; 在微服务定义中阐述服务间通信采用轻量级协议，通常是 HTTP RESTful 风格。但因 RESTful 风格过于灵活，必须加以约束，通常在应用时对其进行上层封装，例如在 Spring Cloud 中就提供了 Feign 和 RestTemplate 两种技术屏蔽底层实现 RESTful 通信细节。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8740740740740741&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4gib1YOYq1OPet1rIUeLWz8kfVxic4CibnzYDpyCRgnumTibiaT6WvsbsmCVl7wMO22ib3UmfU50oj9oldg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;675&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;br/&gt;服务保护：&lt;/strong&gt; 对于分布式环境中的服务而言，服务在自身失败引发生错误的同时，还会因为依赖其他服务而导致失败。除了比较容易想到和实现的超时、重试和异步解耦等手段之外，我们需要考虑针对各种场景的容错机制。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8841642228739003&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4gib1YOYq1OPet1rIUeLWz8kXrLhZPOJHqbBOvvrjicmkrO3MPmiaRaXdoyd2iaRyEzYvbc7TEfKSh8HA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;682&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;strong&gt;链路跟踪：&lt;/strong&gt;一个复杂的业务流程可能需要连续调用多个微服务，我们需要记录一个完整业务逻辑涉及的每一个微服务的运行状态，再通过可视化链路图展现，帮助软件工程师在系统出错时分析解决问题，常见的解决方案有Zipkin，SkyWalking。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7834394904458599&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4gib1YOYq1OPet1rIUeLWz8kKoZicY92tEWiaiaLqWCylibPvzmia9dQRuKp4aKG4eDLfNleIQCibbL6KCZg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;942&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;br/&gt;统一日志管理：&lt;/strong&gt; 微服务架构默认将应用日志分散保存在每一个微服务节点上，当系统进行用户行为分析、数据统计时必须收集所有节点日志数据，非常不方便。这时候我们需要一个独立的日志平台，收集所有节点的日志数据并可方便对其进行汇总分析，常见的解决方案有ELK，EFK。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7102115915363385&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4gib1YOYq1OPet1rIUeLWz8kq6lsCxltx1iaDd6puW8Jhl2icKgkYwuVQ7ic5yz81tvcoJJtTRVo16vzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1087&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;br/&gt;配置中心：&lt;/strong&gt; 在微服务架构中，考虑到服务数量和配置信息的分散性，一般都需要引入配置中心的设计思想和相关工具。通过部署配置中心服务器，将原本分散的配置文件从应用中剥离，集中转存到配置中心。一般配置中心会提供 UI 界面，可以方便快捷的实现大规模集群的配置调整。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.737511353315168&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4gib1YOYq1OPet1rIUeLWz8kNkPTMAHRSv4109c7TrzJ8SbjiajOeCQVsqpDqv1ZUGw6gCdYrcnwc1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1101&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;为什么选择SpringCloud&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，Spring Cloud 具备一个天生的优势，因为它是 Spring 家庭的一员，而 Spring 在 Java EE 开发领域的强大地位，给 Spring Cloud 起到很好的推动作用。同时，Spring Cloud 所基于的 Spring Boot，已经成为 Java EE 领域中最流行的开发框架，用来简化 Spring 应用程序的框架搭建和开发过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其次，技术组件的完备性是我们选择 Spring Cloud 的主要原因。Spring Cloud 中包含了开发一个完整的微服务系统所需的几乎所有技术组件，包括服务注册和发现、API 网关、配置中心、消息处理、负载均衡、熔断器、数据监控等常见技术组件都可以基于 Spring Boot 快速集成到业务系统中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下为SpringCloud 中常用的技术组件&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7383627608346709&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4gib1YOYq1OPet1rIUeLWz8kbdJ9vzBnoonaXVhVniaUuUB6IsswqJ6XEa6ECxgEWBicsFrTWibYz6yRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;623&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;为什么选择SpringCloud alibaba&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先， SpringCloud中的技术组件是集众家之长，如注册中心 Eureka，Zuul等都是依赖于Netflix的，这也导致它受制于第三方厂商。如Zuul宣布停止维护，Spring机构便不得不寻找替代品或自研；Eureka2.x 闭源不允许使用；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其次，Springcloud作为国外产品引入到国内后出现了水土不服，如SpringCloud Config默认将文件存在Github上，且没有维护界面，国内软件公司很少会同意这么做。比如我们部门就是使用了Apollo配置中心替代了原生的SpringCloud Config。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring Cloud Alibaba是国产的微服务开发一站式解决方案，与原有 Spring Cloud 兼容的同时对微服务生态进行扩展，通过添加少量的配置注解，便可实现更符合国情的微服务架构，当前Spring Cloud Alibaba已经是直接隶属于 Spring Cloud 的子项目。官网是：https://spring.io/projects/spring-cloud-alibaba#overview&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5683192261185006&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4gib1YOYq1OPet1rIUeLWz8kogpV1gZXLfLRufTBoJj1QicU3RsCmsObB4KObNEaCVMsCRGiboJtNIHg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;827&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;Spring Cloud Alibaba 对服务注册、配置中心与负载均衡功能都整合进 Nacos，有图形化界面，简化了微服务架构的复杂度，出问题的概率也会降低。原有的服务保护组件也调整为 Sentinel，相较Hystrix功能更强大，使用也更加友好。同时还支持了对Dubbo的调用，而且还有Seata用于支持分布式事务。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>61a2912e422323939112b06c47c9652f</guid>
<title>杭州某大厂：MySQL 连环问</title>
<link>https://toutiao.io/k/xjnx4kp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是yes。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL 面试题又更新啦！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请继续接招。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;说说分库分表？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着用户量的激增和时间的堆砌，存在数据库里面的数据越来越多，此时的数据库就会产生瓶颈，出现资源报警、查询慢等场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先单机数据库所能承载的连接数、I/O及网络的吞吐等都是有限的，所以当并发量上来了之后，数据库就渐渐顶不住了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.40814299900695133&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nEWAm9e6WibicVVnudWpTXSpbLKZHAvclSNUEknzcbZW02kVoUtBInLibrATW08HISruNjxULAicJSiakw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1007&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再则，如果单表的数据量过大，查询的性能也会下降。因为数据越多 B+ 树就越高，树越高则查询 I/O 的次数就越多，那么性能也就越差。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为上述的原因，不得已就得上分库分表了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把以前存在一个数据库实例里的数据拆分成多个数据库实例，部署在不同的服务器中，&lt;span&gt;这是分库&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把以前存在一张表里面的数据拆分成多张表，&lt;span&gt;这是分表&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般而言：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;分表：是为了解决由于单张表数据量多大，而导致查询慢的问题。大致三、四千万行数据就得拆分，不过具体还是得看每一行的数据量大小，有些字段都很小的可能支持更多行数，有些字段大的可能一千万就顶不住了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分库：是为了解决服务器资源受单机限制，顶不住高并发访问的问题，把请求分配到多台服务器上，降低服务器压力。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;你们一般怎么分库的？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般分库都是按照业务划分的，比如订单库、用户库等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候会针对一些特殊的库再作切分，比如一些活动相关的库都做了拆分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为做活动的时候并发可能会比较高，怕影响现有的核心业务，所以即使有关联，也会单独做拆分。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7423971377459749&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nEWAm9e6WibicVVnudWpTXSpb6yoRNpHXmcfQqEqlOKaXxPqjotTEiaib2uCoXtWA3AebKEgiapcW6f3Aw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;559&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;那你觉得分库会带来什么问题呢？&lt;/span&gt;&lt;/h1&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;首先是&lt;span&gt;事务&lt;/span&gt;的问题。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们使用关系型数据库，有很大一点在于它保证事务完整性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而分库之后单机事务就用不上了，必须使用分布式事务来解决，而分布式事务基本的都是残缺的(我之前文章把分布式事务汇总了一波，后台搜索分布式事务就有了)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是很重要的一点需要考虑。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;连表 JOIN 问题&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在一个库中的时候我们还可以利用 JOIN 来连表查询，而跨库了之后就无法使用 JOIN 了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时的解决方案就是&lt;span&gt;在业务代码中进行关联&lt;/span&gt;，也就是先把一个表的数据查出来，然后通过得到的结果再去查另一张表，然后利用代码来关联得到最终的结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式实现起来稍微比较复杂，不过也是可以接受的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有可以&lt;span&gt;适当的冗余一些字段&lt;/span&gt;。比如以前的表就存储一个关联 ID，但是业务时常要求返回对应的 Name 或者其他字段。这时候就可以把这些字段冗余到当前表中，来去除需要关联的操作。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;那你们怎么分表的？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分表其实有两种：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;垂直分表，来看个图，很直观：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6628982528263104&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nEWAm9e6WibicVVnudWpTXSpb4eaOkdIoQsksMWPEyDJvonV78gfmqqelicN2FFfb7RZ7OJwFF6cSdEg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;973&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;垂直分表&lt;/span&gt;就是把一些不常用的大字段剥离出去。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像上面的例子：用户名是很常见的搜索结果，性别和年龄占用的空间又不大，而地址和个人简介占用的空间相对而言就较大，我们都知道一个数据页的空间是有限的，把一些无用的数据拆分出去，一页就能存放更多行的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存存放更多有用的数据，就减少了磁盘的访问次数，性能就得到提升。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;水平分表&lt;/span&gt;，则是因为一张表内的数据太多了，上文也提到了数据越多 B+ 树就越高，访问的性能就差，所以进行水平拆分。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.39633638634471274&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nEWAm9e6WibicVVnudWpTXSpbC6sWOAAMlgwXMpYNlvgsf6FrWLQD1JFHqCe7bjjKFEOq3wFWj5RiabQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1201&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实不管这些，浅显的理解下，在一百个数据里面找一个数据快，还是在一万个数据里面找一个数据快？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即使有索引，那厚的书目录多，翻目录也慢~&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;那分表会有什么问题？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;垂直分表还好，就是需要关联一下，而水平分表就有点麻烦了。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;排序、count、分页问题&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一个用户的数据被拆分到多个表中，那查询结果分页就不像以前单张表那样直接就能查出来了，像 count 操作也是一样的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只能由业务代码来实现或者用中间件将各表中的数据汇总、排序、分页然后返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像 count 操作的结果其实可以缓存下来，然后每次数据增删都更新计数。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;路由问题&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分表的路由可以分：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Hash 路由&lt;/span&gt;，其实就是选择表中的某一列，然后进行 Hash 运算，将 Hash 运算得到的结果再对子表数进行取模，这样就能均匀的将数据分到不同的子表上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这跟 HashMap 选哪个桶是一样的原理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优点就是数据分布均匀。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺点就是增加子表的时候麻烦，想想 HashMap的扩容，是不是得搬迁数据？这个分表也是一样的，我们可都知道，数据迁移一件麻烦事！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;范围路由&lt;/span&gt;，其实很简单，可以是时间，也可以是地址，表示一定的范围的即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如本来一张 User 表，我可以分 User_HZ、User_BJ、User_SH，按照地名来划分 User。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再比如 log 表，我可以将表分为 log_202103、 log_202104，把日志按照年月来划分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优点就是相对而言比较容易扩展，比如现在来个 GZ，那就加个 User_GZ。如果到了 5 月，那就建个 log_202105。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺点就是数据可能分布不均匀，例如 BJ 的用户特别多或者某个月搞了促销，日志量特别大，等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;路由表&lt;/span&gt;，就是专门搞个表来记录路由信息，来看个图就很清楚了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.653276955602537&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nEWAm9e6WibicVVnudWpTXSpblrE8Xmfc4av0iaHIDchGDc8lnyynXU6epNicRcyeE5W6amZqy3rLRzZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;473&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图中我们就能得知，UserID 为 2 的用户数据在要去 User_3 这个用户表查询。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优点就是灵活咯，如果要迁移数据，直接迁移然后路由表一改就完事儿了~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺点就是得多查一次，每次查询都需要访问路由表，不过这个一般会做缓存的。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;全局主键问题&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以前单表的时候很简单，就是主键自增，现在分表了之后就有点尴尬了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以需要一些手段来保证全局主键唯一。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;还是自增，只不过自增步长设置一下。比如现在有三张表，步长设置为3，三张表 ID 初始值分别是1、2、3。这样第一张表的 ID 增长是 1、4、7。第二张表是2、5、8。第三张表是3、6、9，这样就不会重复了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;UUID，这种最简单，但是不连续的主键插入会导致严重的页分裂，性能比较差。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分布式 ID，比较出名的就是 Twitter 开源的 sonwflake 雪花算法，具体就不展开了，不然就又是一篇文章了，简单点利用 redis 来递增也行。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;那上面说的路由问题的 Sharding-Key 如何设计呢？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们分表是按照某个列来拆分的，那个列就是 Sharding-Key，查询的时候必须带上这个列才行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如上面提到的  log_202103，那表明查询条件一定得带上日期，这样才能找到正确的表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以设计上得考虑查询的条件来作为 Sharding-Key。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个常常会被问的订单表 Sharding-Key 例子。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你想着查找订单的时候会通过订单号去找，所以应该利用订单 ID 来作为 Sharding-Key。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是你想想，你打开外卖软件想查找你的历史订单的时候，你是没有订单 ID 的，你只有你的 UserID，那此时只能把所有子表都通过 UserID 遍历一遍，这样效率就很低了！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以你想着那用 UserID 来作为 Sharding-Key 吧！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，商家呢？商家肯定关心自己今天卖了多少单，所以他也要查找订单，但他只有自己的商家 ID，所以如果要查询订单，只能把所有子表都通过商家 ID 遍历一遍，这样效率就很低了！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以 Sharding-Key 是满足不了所有查询需求的，只能曲线救国。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般做法就是&lt;span&gt;冗余数据&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将订单同步到另一张表中给商家使用，这个表按商家 ID 来作为 Sharding-Key，也可以将数据同步到 ES 中。一般而言这里的数据同步都是异步处理，不会影响正常流程。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最后&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天的面试题主要是分库分表相关的，基本上常问的都涵盖了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL 面试题未完，持续更新~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为分库分表会带来很多复杂性，所以能不分库分表，就不要分库分表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个前提请牢记。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有，&lt;span&gt;面试题交流群&lt;/span&gt;持续开放，已经分享了近 50 个面经。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加我微信: yes_oba，备注面试，拉你进群。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我是 yes，从一点点到亿点点，我们下篇见~&lt;/p&gt;&lt;section data-recommend-type=&quot;list-title&quot; data-recommend-tid=&quot;8&quot; data-mpa-template=&quot;t&quot; data-mid=&quot;&quot; data-from=&quot;yb-recommend&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;往期推荐&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-title&quot; data-recomment-template-id=&quot;8&quot; data-recommend-article-id=&quot;2247489107_1&quot; data-recommend-article-time=&quot;1619081400&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/eSdk75TK4nGygiam8LvNnHpvoNO012TInP3YB3cYuqicIzOJudn4Tu3Q0UYiab4KKBo8hx0LFxNsb1Ys1OtHzsVNA/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;我给总监打了包票，结果......我不想3.25&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkxNTE3NjQ3MA==&amp;amp;mid=2247489107&amp;amp;idx=1&amp;amp;sn=12c449ae8afc6d1d6d89b8236854eede&amp;amp;chksm=c1627b2af615f23c55fe23b3686c6c95f0512f4ce2a7559f78e751283b159b81968a40644274#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkxNTE3NjQ3MA==&amp;amp;mid=2247489107&amp;amp;idx=1&amp;amp;sn=12c449ae8afc6d1d6d89b8236854eede&amp;amp;chksm=c1627b2af615f23c55fe23b3686c6c95f0512f4ce2a7559f78e751283b159b81968a40644274&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;section data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;我给总监打了包票，结果......我不想3.25&lt;/p&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-title&quot; data-recomment-template-id=&quot;8&quot; data-recommend-article-id=&quot;2247489047_1&quot; data-recommend-article-time=&quot;1618878060&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/eSdk75TK4nHQJOTMnuMpLPx77KCicwSYCRicy2RIibkVavVB9skjWIbOXNHEvicXibQfCu7BuXo02dxpjicLdhDg2ic2w/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;总监问我：Kafka为什么要抛弃ZooKeeper？| 文末送书&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkxNTE3NjQ3MA==&amp;amp;mid=2247489047&amp;amp;idx=1&amp;amp;sn=ac16366e70fce619409360a972562f28&amp;amp;chksm=c1627b6ef615f278cee7ffe2a3d68111dbd2292d99a83e6cad15de7bd66af8ed54a4c11e784a#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkxNTE3NjQ3MA==&amp;amp;mid=2247489047&amp;amp;idx=1&amp;amp;sn=ac16366e70fce619409360a972562f28&amp;amp;chksm=c1627b6ef615f278cee7ffe2a3d68111dbd2292d99a83e6cad15de7bd66af8ed54a4c11e784a&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;section data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;总监问我：Kafka为什么要抛弃ZooKeeper？| 文末送书&lt;/p&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1b64f48533f0b4c5b1e5e1829b2a3126</guid>
<title>​手把手教你如何进行 Golang 单元测试</title>
<link>https://toutiao.io/k/k1fr9de</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：stevennzhou，腾讯 PCG 前端开发工程师&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;本篇是对单元测试的一个总结，通过完整的单元测试手把手教学，能够让刚接触单元测试的开发者从整体上了解一个单元测试编写的全过程。最终通过两个问题，也能让写过单元测试的开发者收获单测执行时的一些底层细节知识。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;引入&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着工程化开发在司内大力的推广，单元测试越来越受到广大开发者的重视。在学习的过程中，发现网上针对 Golang 单元测试大多从理论角度出发介绍，缺乏完整的实例说明，晦涩难懂的 API 让初学接触者难以下手。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本篇不准备大而全的谈论单元测试、笼统的介绍 Golang 的单测工具，而将从 Golang 单测的使用场景出发，以最简单且实际的例子讲解如何进行单测，最终由浅入深探讨 go 单元测试的两个比较细节的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在阅读本文时，请务必对 Golang 的单元测试有最基本的了解。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一段需要单测的 Golang 代码&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; unit&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;encoding/json&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;errors&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;github.com/gomodule/redigo/redis&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;regexp&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; PersonDetail &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Username &lt;span&gt;string&lt;/span&gt; &lt;span&gt;`json:&quot;username&quot;`&lt;/span&gt;&lt;br/&gt; Email    &lt;span&gt;string&lt;/span&gt; &lt;span&gt;`json:&quot;email&quot;`&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 检查用户名是否非法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;checkUsername&lt;/span&gt;&lt;span&gt;(username &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;const&lt;/span&gt; pattern = &lt;span&gt;`^[a-z0-9_-]{3,16}$`&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; reg := regexp.MustCompile(pattern)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; reg.MatchString(username)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 检查用户邮箱是否非法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;checkEmail&lt;/span&gt;&lt;span&gt;(email &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;const&lt;/span&gt; pattern = &lt;span&gt;`^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$`&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; reg := regexp.MustCompile(pattern)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; reg.MatchString(email)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 通过 redis 拉取对应用户的资料信息&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;getPersonDetailRedis&lt;/span&gt;&lt;span&gt;(username &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(*PersonDetail, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; result := &amp;amp;PersonDetail{}&lt;br/&gt;&lt;br/&gt; client, err := redis.Dial(&lt;span&gt;&quot;tcp&quot;&lt;/span&gt;, &lt;span&gt;&quot;:6379&quot;&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; client.Close()&lt;br/&gt; data, err := redis.Bytes(client.Do(&lt;span&gt;&quot;GET&quot;&lt;/span&gt;, username))&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; err = json.Unmarshal(data, result)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; result, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 拉取用户资料信息并校验&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;GetPersonDetail&lt;/span&gt;&lt;span&gt;(username &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(*PersonDetail, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// 检查用户名是否有效&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; ok := checkUsername(username); !ok {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, errors.New(&lt;span&gt;&quot;invalid username&quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 从 redis 接口获取信息&lt;/span&gt;&lt;br/&gt; detail, err := getPersonDetailRedis(username)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 校验&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; ok := checkEmail(detail.Email); !ok {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, errors.New(&lt;span&gt;&quot;invalid email&quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; detail, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一段典型的有 I/O 的功能代码，主体功能是传入用户名，校验合法性之后通过 redis 获取信息，之后校验获取值内容的合法性后并返回。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;后台服务单测场景&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于一个传统的后端服务，它主要有以下几点的职责和功能：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;接收外部请求，controller 层分发请求、校验请求参数&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;请求有效分发后，在 service 层与 dao 层进行交互后做逻辑处理&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;dao 层负责数据操作，主要是数据库或持久化存储相关的操作&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，从职责出发来看，在做后台单测中，核心主要是验证 service 层和 dao 层的相关逻辑，此外 controller 层的参数校验也在单测之中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;细分来看，对于相关逻辑的单元测试，笔者倾向于把单测分为两种：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;无第三方依赖，纯逻辑代码&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;有第三方依赖，如文件、网络 I/O、第三方依赖库、数据库操作相关的代码&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注：单元测试中只是针对单个函数的测试，关注其内部的逻辑，对于网络/数据库访问等，需要通过相应的手段进行 mock。&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Golang 单测工具选型&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于我们把单测简单的分为了两种：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;对于无第三方依赖的纯逻辑代码，我们只需要验证&lt;strong&gt;相关逻辑&lt;/strong&gt;即可，这里只需要使用 &lt;code&gt;assert&lt;/code&gt; &lt;strong&gt;（断言）&lt;/strong&gt;，通过控制输入输出比对结果即可。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;对于有第三方依赖的代码，在验证相关代码逻辑之前，我们需要将相关的依赖 &lt;code&gt;mock&lt;/code&gt; &lt;strong&gt;（模拟）&lt;/strong&gt;，之后才能通过断言验证逻辑。这里需要借助第三方工具库来处理。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，对于 &lt;code&gt;assert&lt;/code&gt; &lt;strong&gt;（断言）&lt;/strong&gt;工具，可以选择 testify 或 convery，笔者这里选择了 testify。对于 &lt;code&gt;mock&lt;/code&gt; &lt;strong&gt;（模拟）&lt;/strong&gt;工具，笔者这里选择了 gomock 和 gomonkey。关于 mock 工具同时使用 gomock 和 gomonkey，这里跟 Golang 的语言特性有关，下面会详细的说明。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;完善测试用例&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们开始对示例代码中的函数做单元测试。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;生成单测模板代码&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先在 Goland 中打开项目，加载对应文件后右键找到 Generate 项，点击后选择 Tests for package，之后生成以 &lt;code&gt;_test.go&lt;/code&gt; 结尾的单测文件。（如果想针对某一特定函数做单测，请选择对应的函数后右键选定 Generate 项执行 Tests for selection。）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里展示通过 IDE 生成的 &lt;code&gt;TestGetPersonDetail&lt;/code&gt; 测试函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; unit&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt;  &lt;span&gt;&quot;reflect&quot;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&quot;testing&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;TestGetPersonDetail&lt;/span&gt;&lt;span&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;type&lt;/span&gt; args &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;  username &lt;span&gt;string&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; tests := []&lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;  name    &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;  args    args&lt;br/&gt;  want    *PersonDetail&lt;br/&gt;  wantErr &lt;span&gt;bool&lt;/span&gt;&lt;br/&gt; }{&lt;br/&gt;  &lt;span&gt;// &lt;span&gt;TODO:&lt;/span&gt; Add test cases.&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; _, tt := &lt;span&gt;range&lt;/span&gt; tests {&lt;br/&gt;  t.Run(tt.name, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   got, err := GetPersonDetail(tt.args.username)&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (err != &lt;span&gt;nil&lt;/span&gt;) != tt.wantErr {&lt;br/&gt;    t.Errorf(&lt;span&gt;&quot;GetPersonDetail() error = %v, wantErr %v&quot;&lt;/span&gt;, err, tt.wantErr)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; !reflect.DeepEqual(got, tt.want) {&lt;br/&gt;    t.Errorf(&lt;span&gt;&quot;GetPersonDetail() got = %v, want %v&quot;&lt;/span&gt;, got, tt.want)&lt;br/&gt;   }&lt;br/&gt;  })&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由 Goland 生成的单测模板代码使用的是官方的 testing 框架，为了更方便的断言，我们把 testing 改造成 testify 的断言方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里其实只需要引入 testify 后修改 test 函数最后的断言代码即可，这里我们以 &lt;code&gt;TestGetPersonDetail&lt;/code&gt; 为例子，其他函数不赘述。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; unit&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt;  &lt;span&gt;&quot;github.com/stretchr/testify/assert&quot;&lt;/span&gt; &lt;span&gt;// 这里引入了 testify&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&quot;reflect&quot;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&quot;testing&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;TestGetPersonDetail&lt;/span&gt;&lt;span&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;type&lt;/span&gt; args &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;  username &lt;span&gt;string&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; tests := []&lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;  name    &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;  args    args&lt;br/&gt;  want    *PersonDetail&lt;br/&gt;  wantErr &lt;span&gt;bool&lt;/span&gt;&lt;br/&gt; }{&lt;br/&gt;  &lt;span&gt;// &lt;span&gt;TODO:&lt;/span&gt; Add test cases.&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; _, tt := &lt;span&gt;range&lt;/span&gt; tests {&lt;br/&gt;  got, err := GetPersonDetail(tt.args.username)&lt;br/&gt;  &lt;span&gt;// 改写这里断言的方式即可&lt;/span&gt;&lt;br/&gt;  assert.Equal(t, tt.want, got)&lt;br/&gt;  assert.Equal(t, tt.wantErr, err != &lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;分析代码生成测试用例&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对 &lt;code&gt;checkUsername&lt;/code&gt; 、 &lt;code&gt;checkEmail&lt;/code&gt; 纯逻辑函数编写测试用例，这里以 &lt;code&gt;checkEmail&lt;/code&gt; 为例。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Test_checkEmail&lt;/span&gt;&lt;span&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;type&lt;/span&gt; args &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;  email &lt;span&gt;string&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; tests := []&lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;  name &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;  args args&lt;br/&gt;  want &lt;span&gt;bool&lt;/span&gt;&lt;br/&gt; }{&lt;br/&gt;  {&lt;br/&gt;   name: &lt;span&gt;&quot;email valid&quot;&lt;/span&gt;,&lt;br/&gt;   args: args{&lt;br/&gt;    email: &lt;span&gt;&quot;1234567@qq.com&quot;&lt;/span&gt;,&lt;br/&gt;   },&lt;br/&gt;   want: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;  },&lt;br/&gt;  {&lt;br/&gt;   name: &lt;span&gt;&quot;email invalid&quot;&lt;/span&gt;,&lt;br/&gt;   args: args{&lt;br/&gt;    email: &lt;span&gt;&quot;test.com&quot;&lt;/span&gt;,&lt;br/&gt;   },&lt;br/&gt;   want: &lt;span&gt;false&lt;/span&gt;,&lt;br/&gt;  },&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; _, tt := &lt;span&gt;range&lt;/span&gt; tests {&lt;br/&gt;  got := checkEmail(tt.args.email)&lt;br/&gt;  assert.Equal(t, tt.want, got)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;使用 gomonkey 打桩&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 &lt;code&gt;GetPersonDetail&lt;/code&gt; 函数而言，该函数调用了 &lt;code&gt;getPersonDetailRedis&lt;/code&gt; 函数获取具体的 &lt;code&gt;PersonDetail&lt;/code&gt; 信息。为此，我们需要为它打一个“桩”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;所谓的“桩”，也叫做“桩代码”，是指用来代替关联代码或者未实现代码的代码。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于函数、成员方法或者是变量的打桩，我们通常使用 gomonkey 来进行打桩。具体 API 请参考：https://pkg.go.dev/github.com/agiledragon/gomonkey&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 拉取用户资料信息并校验&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;GetPersonDetail&lt;/span&gt;&lt;span&gt;(username &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(*PersonDetail, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// 检查用户名是否有效&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; ok := checkUsername(username); !ok {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, errors.New(&lt;span&gt;&quot;invalid username&quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 从 redis 接口获取信息&lt;/span&gt;&lt;br/&gt; detail, err := getPersonDetailRedis(username)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 校验&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; ok := checkEmail(detail.Email); !ok {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, errors.New(&lt;span&gt;&quot;invalid email&quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; detail, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从 &lt;code&gt;GetPersonDetail&lt;/code&gt; 函数可见，为了能够完全覆盖该函数，我们需要控制 &lt;code&gt;getPersonDetailRedis&lt;/code&gt; 函数不同的输出来保证后续代码都能够被覆盖运行到。因此，这里需要使用 gomonkey 来给 &lt;code&gt;getPersonDetailRedis&lt;/code&gt; 函数打一个“桩序列”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所谓的函数“桩序列”指的是提前指定好调用函数的返回值序列，当该函数多次调用时候，能够按照原先指定的返回值序列依次返回。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;TestGetPersonDetail&lt;/span&gt;&lt;span&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;type&lt;/span&gt; args &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;  username &lt;span&gt;string&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; tests := []&lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;  name    &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;  args    args&lt;br/&gt;  want    *PersonDetail&lt;br/&gt;  wantErr &lt;span&gt;bool&lt;/span&gt;&lt;br/&gt; }{&lt;br/&gt;  {name: &lt;span&gt;&quot;invalid username&quot;&lt;/span&gt;, args: args{username: &lt;span&gt;&quot;steven xxx&quot;&lt;/span&gt;}, want: &lt;span&gt;nil&lt;/span&gt;, wantErr: &lt;span&gt;true&lt;/span&gt;},&lt;br/&gt;  {name: &lt;span&gt;&quot;invalid email&quot;&lt;/span&gt;, args: args{username: &lt;span&gt;&quot;invalid_email&quot;&lt;/span&gt;}, want: &lt;span&gt;nil&lt;/span&gt;, wantErr: &lt;span&gt;true&lt;/span&gt;},&lt;br/&gt;  {name: &lt;span&gt;&quot;throw err&quot;&lt;/span&gt;, args: args{username: &lt;span&gt;&quot;throw_err&quot;&lt;/span&gt;}, want: &lt;span&gt;nil&lt;/span&gt;, wantErr: &lt;span&gt;true&lt;/span&gt;},&lt;br/&gt;  {name: &lt;span&gt;&quot;valid return&quot;&lt;/span&gt;, args: args{username: &lt;span&gt;&quot;steven&quot;&lt;/span&gt;}, want: &amp;amp;PersonDetail{Username: &lt;span&gt;&quot;steven&quot;&lt;/span&gt;, Email: &lt;span&gt;&quot;12345678@qq.com&quot;&lt;/span&gt;}, wantErr: &lt;span&gt;false&lt;/span&gt;},&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 为函数打桩序列&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// 使用 gomonkey 打函数桩序列&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// 第一个用例不会调用 getPersonDetailRedis，所以只需要 3 个值&lt;/span&gt;&lt;br/&gt; outputs := []gomonkey.OutputCell{&lt;br/&gt;  {&lt;br/&gt;   Values: gomonkey.Params{&amp;amp;PersonDetail{Username: &lt;span&gt;&quot;invalid_email&quot;&lt;/span&gt;, Email: &lt;span&gt;&quot;test.com&quot;&lt;/span&gt;}, &lt;span&gt;nil&lt;/span&gt;},&lt;br/&gt;  },&lt;br/&gt;  {&lt;br/&gt;   Values: gomonkey.Params{&lt;span&gt;nil&lt;/span&gt;, errors.New(&lt;span&gt;&quot;request err&quot;&lt;/span&gt;)},&lt;br/&gt;  },&lt;br/&gt;  {&lt;br/&gt;   Values: gomonkey.Params{&amp;amp;PersonDetail{Username: &lt;span&gt;&quot;steven&quot;&lt;/span&gt;, Email: &lt;span&gt;&quot;12345678@qq.com&quot;&lt;/span&gt;}, &lt;span&gt;nil&lt;/span&gt;},&lt;br/&gt;  },&lt;br/&gt; }&lt;br/&gt; patches := gomonkey.ApplyFuncSeq(getPersonDetailRedis, outputs)&lt;br/&gt; &lt;span&gt;// 执行完毕后释放桩序列&lt;/span&gt;&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; patches.Reset()&lt;br/&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; _, tt := &lt;span&gt;range&lt;/span&gt; tests {&lt;br/&gt;  got, err := GetPersonDetail(tt.args.username)&lt;br/&gt;  assert.Equal(t, tt.want, got)&lt;br/&gt;  assert.Equal(t, tt.wantErr, err != &lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当使用桩序列时，要分析好单元测试用例和序列值的对应关系，保证最终被测试的代码块都能被完整覆盖。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;使用 gomock 打桩&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后剩下 &lt;code&gt;getPersonDetailRedis&lt;/code&gt; 函数，我们先来看一下这个函数的逻辑。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 通过 redis 拉取对应用户的资料信息&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;getPersonDetailRedis&lt;/span&gt;&lt;span&gt;(username &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(*PersonDetail, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; result := &amp;amp;PersonDetail{}&lt;br/&gt;&lt;br/&gt; client, err := redis.Dial(&lt;span&gt;&quot;tcp&quot;&lt;/span&gt;, &lt;span&gt;&quot;:6379&quot;&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; client.Close()&lt;br/&gt; data, err := redis.Bytes(client.Do(&lt;span&gt;&quot;GET&quot;&lt;/span&gt;, username))&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; err = json.Unmarshal(data, result)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; result, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;getPersonDetailRedis&lt;/code&gt; 函数的核心在于生成了 &lt;code&gt;client&lt;/code&gt; 调用了它的 &lt;code&gt;Do&lt;/code&gt; 方法，通过分析得知 &lt;code&gt;client&lt;/code&gt; 实际上是一个符合 &lt;code&gt;Conn&lt;/code&gt; 接口的结构体。如果我们使用 gomonkey 来进行打桩，需要先声明一个结构体并实现 &lt;code&gt;Client&lt;/code&gt; 接口拥有的方法，之后才能使用 gomonkey 给函数打桩。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// redis 包中关于 Conn 的定义&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Conn represents a connection to a Redis server.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Conn &lt;span&gt;interface&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// Close closes the connection.&lt;/span&gt;&lt;br/&gt; Close() error&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// Err returns a non-nil value when the connection is not usable.&lt;/span&gt;&lt;br/&gt; Err() error&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// Do sends a command to the server and returns the received reply.&lt;/span&gt;&lt;br/&gt; Do(commandName &lt;span&gt;string&lt;/span&gt;, args ...&lt;span&gt;interface&lt;/span&gt;{}) (reply &lt;span&gt;interface&lt;/span&gt;{}, err error)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// Send writes the command to the client&#x27;s output buffer.&lt;/span&gt;&lt;br/&gt; Send(commandName &lt;span&gt;string&lt;/span&gt;, args ...&lt;span&gt;interface&lt;/span&gt;{}) error&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// Flush flushes the output buffer to the Redis server.&lt;/span&gt;&lt;br/&gt; Flush() error&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// Receive receives a single reply from the Redis server&lt;/span&gt;&lt;br/&gt; Receive() (reply &lt;span&gt;interface&lt;/span&gt;{}, err error)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 实现接口&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Client &lt;span&gt;struct&lt;/span&gt; {}&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Client)&lt;/span&gt; &lt;span&gt;Close&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Client)&lt;/span&gt; &lt;span&gt;Err&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Client)&lt;/span&gt; &lt;span&gt;Do&lt;/span&gt;&lt;span&gt;(commandName &lt;span&gt;string&lt;/span&gt;, args ...&lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;(&lt;span&gt;interface&lt;/span&gt;{}, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Client)&lt;/span&gt; &lt;span&gt;Send&lt;/span&gt;&lt;span&gt;(commandName &lt;span&gt;string&lt;/span&gt;, args ...&lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Client)&lt;/span&gt; &lt;span&gt;Flush&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Client)&lt;/span&gt; &lt;span&gt;Receive&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;(&lt;span&gt;interface&lt;/span&gt;{}, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 实现接口&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Client &lt;span&gt;struct&lt;/span&gt; {}&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Client)&lt;/span&gt; &lt;span&gt;Close&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Client)&lt;/span&gt; &lt;span&gt;Err&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Client)&lt;/span&gt; &lt;span&gt;Do&lt;/span&gt;&lt;span&gt;(commandName &lt;span&gt;string&lt;/span&gt;, args ...&lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;(&lt;span&gt;interface&lt;/span&gt;{}, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Client)&lt;/span&gt; &lt;span&gt;Send&lt;/span&gt;&lt;span&gt;(commandName &lt;span&gt;string&lt;/span&gt;, args ...&lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Client)&lt;/span&gt; &lt;span&gt;Flush&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Client)&lt;/span&gt; &lt;span&gt;Receive&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;(&lt;span&gt;interface&lt;/span&gt;{}, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 进行测试&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; c := &amp;amp;Client{}&lt;br/&gt; gomonkey.ApplyFunc(redis.Dial, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(_ &lt;span&gt;string&lt;/span&gt;, _ &lt;span&gt;string&lt;/span&gt;, _ ...redis.DialOption)&lt;/span&gt; &lt;span&gt;(redis.Conn, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; c, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; })&lt;br/&gt; gomonkey.ApplyMethod(reflect.TypeOf(c), &lt;span&gt;&quot;Do&quot;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(commandName &lt;span&gt;string&lt;/span&gt;, args ...&lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;(&lt;span&gt;interface&lt;/span&gt;{}, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; result &lt;span&gt;interface&lt;/span&gt;{}&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; result, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; })&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可见，如果接口实现的方法更多，那么打桩需要手写的代码会更多。因此这里需要一种能自动根据原接口的定义生成接口的 mock 代码以及更方便的接口 mock 方式。于是这里我们使用 gomock 来解决这个问题。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;本地安装 gomock&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 打开终端后依次执行&lt;/span&gt;&lt;br/&gt;go get -u github.com/golang/mock/gomock&lt;br/&gt;go install github.com/golang/mock/mockgen&lt;br/&gt;&lt;span&gt;# 备注说明，很重要！！！&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 安装完成之后，执行 mockgen 看命令是否生效 # 如果显示命令无效，请找到本机的 GOPATH 安装目录下的 bin 文件夹是否有 mockgen 二进制文件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# GOPATH 可以执行 go env 命令找到&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 如果命令无效但是 GOPATH 路径下的 bin 文件夹中存在 mockgen，请将 GOPATH 下 bin 文件夹的绝对路径添加到全局 PATH 中&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;生成 gomock 桩代码&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安装完毕后，找到要进行打桩的接口，这里是 github.com/gomodule/redigo/redis 包里面的 &lt;code&gt;Conn&lt;/code&gt; 接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在当前代码目录下执行以下指令，这里我们只对某个特定的接口生成 mock 代码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;mockgen -destination=mock_redis.go -package=unit github.com/gomodule/redigo/redis Conn&lt;br/&gt;&lt;span&gt;# 更多指令参考：https://github.com/golang/mock#flags&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生成的代码参考 &lt;a href=&quot;https://github.com/xunan007/go_unit_test/blob/master/mock_redis.go&quot; data-linktype=&quot;2&quot;&gt;mock_redis.go&lt;/a&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;完善 gomock 相关逻辑&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Test_getPersonDetailRedis&lt;/span&gt;&lt;span&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; tests := []&lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;  name    &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;  want    *PersonDetail&lt;br/&gt;  wantErr &lt;span&gt;bool&lt;/span&gt;&lt;br/&gt; }{&lt;br/&gt;  {name: &lt;span&gt;&quot;redis.Do err&quot;&lt;/span&gt;, want: &lt;span&gt;nil&lt;/span&gt;, wantErr: &lt;span&gt;true&lt;/span&gt;},&lt;br/&gt;  {name: &lt;span&gt;&quot;json.Unmarshal err&quot;&lt;/span&gt;, want: &lt;span&gt;nil&lt;/span&gt;, wantErr: &lt;span&gt;true&lt;/span&gt;},&lt;br/&gt;  {name: &lt;span&gt;&quot;success&quot;&lt;/span&gt;, want: &amp;amp;PersonDetail{&lt;br/&gt;   Username: &lt;span&gt;&quot;steven&quot;&lt;/span&gt;,&lt;br/&gt;   Email:    &lt;span&gt;&quot;1234567@qq.com&quot;&lt;/span&gt;,&lt;br/&gt;  }, wantErr: &lt;span&gt;false&lt;/span&gt;},&lt;br/&gt; }&lt;br/&gt; ctrl := gomock.NewController(t)&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; ctrl.Finish()&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 1. 生成符合 redis.Conn 接口的 mockConn&lt;/span&gt;&lt;br/&gt; mockConn := NewMockConn(ctrl)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 2. 给接口打桩序列&lt;/span&gt;&lt;br/&gt; gomock.InOrder(&lt;br/&gt;  mockConn.EXPECT().Do(&lt;span&gt;&quot;GET&quot;&lt;/span&gt;, gomock.Any()).Return(&lt;span&gt;&quot;&quot;&lt;/span&gt;, errors.New(&lt;span&gt;&quot;redis.Do err&quot;&lt;/span&gt;)),&lt;br/&gt;  mockConn.EXPECT().Close().Return(&lt;span&gt;nil&lt;/span&gt;),&lt;br/&gt;  mockConn.EXPECT().Do(&lt;span&gt;&quot;GET&quot;&lt;/span&gt;, gomock.Any()).Return(&lt;span&gt;&quot;123&quot;&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;),&lt;br/&gt;  mockConn.EXPECT().Close().Return(&lt;span&gt;nil&lt;/span&gt;),&lt;br/&gt;  mockConn.EXPECT().Do(&lt;span&gt;&quot;GET&quot;&lt;/span&gt;, gomock.Any()).Return([]&lt;span&gt;byte&lt;/span&gt;(&lt;span&gt;`{&quot;username&quot;: &quot;steven&quot;, &quot;email&quot;: &quot;1234567@qq.com&quot;}`&lt;/span&gt;), &lt;span&gt;nil&lt;/span&gt;),&lt;br/&gt;  mockConn.EXPECT().Close().Return(&lt;span&gt;nil&lt;/span&gt;),&lt;br/&gt; )&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 3. 给 redis.Dail 函数打桩&lt;/span&gt;&lt;br/&gt; outputs := []gomonkey.OutputCell{&lt;br/&gt;  {&lt;br/&gt;   Values: gomonkey.Params{mockConn, &lt;span&gt;nil&lt;/span&gt;},&lt;br/&gt;   Times:  &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;// 3 个用例&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt; }&lt;br/&gt; patches := gomonkey.ApplyFuncSeq(redis.Dial, outputs)&lt;br/&gt; &lt;span&gt;// 执行完毕之后释放桩序列&lt;/span&gt;&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; patches.Reset()&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 4. 断言&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; _, tt := &lt;span&gt;range&lt;/span&gt; tests {&lt;br/&gt;  actual, err := getPersonDetailRedis(tt.name)&lt;br/&gt;  &lt;span&gt;// 注意，equal 函数能够对结构体进行 deap diff&lt;/span&gt;&lt;br/&gt;  assert.Equal(t, tt.want, actual)&lt;br/&gt;  assert.Equal(t, tt.wantErr, err != &lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面可以看到，给 &lt;code&gt;getPersonDetailRedis&lt;/code&gt; 函数做单元测试主要做了四件事情：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;生成符合 &lt;code&gt;redis.Conn&lt;/code&gt; 接口的 &lt;code&gt;mockConn&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;给接口打桩序列&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;给函数 &lt;code&gt;redis.Dial&lt;/code&gt; 打桩&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;断言&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里面同时使用了 gomock、gomonkey 和 testify 三个包作为压测工具，日常使用中，由于复杂的调用逻辑带来繁杂的单测，也无外乎使用这三个包协同完成。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;查看单测报告&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单元测试编写完毕之后，我们可以调用相关的指令来查看覆盖范围，帮助我们查看单元测试是否已经完全覆盖逻辑代码，以便我们及时调整单测逻辑和用例。本文中完整的单测代码参考：&lt;a href=&quot;https://github.com/xunan007/go_unit_test/blob/master/get_person_detail_test.go&quot; data-linktype=&quot;2&quot;&gt;get_person_detail_test.go&lt;/a&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;使用 go test 指令&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认情况下，我们在当前代码目录下执行 &lt;code&gt;go test&lt;/code&gt; 指令，会自动的执行当前目录下面带 &lt;code&gt;_test.go&lt;/code&gt; 后缀的文件进行测试。如若想展示具体的测试函数以及覆盖率，可以添加 &lt;code&gt;-v&lt;/code&gt; 和 &lt;code&gt;-cover&lt;/code&gt; 参数，如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;☁️  go_unit_test [master] 🚗  go &lt;span&gt;test&lt;/span&gt; -v -cover&lt;br/&gt;=== RUN   TestGetPersonDetail&lt;br/&gt;--- PASS: TestGetPersonDetail (0.00s)&lt;br/&gt;=== RUN   Test_checkEmail&lt;br/&gt;--- PASS: Test_checkEmail (0.00s)&lt;br/&gt;=== RUN   Test_checkUsername&lt;br/&gt;--- PASS: Test_checkUsername (0.00s)&lt;br/&gt;=== RUN   Test_getPersonDetailRedis&lt;br/&gt;--- PASS: Test_getPersonDetailRedis (0.00s)&lt;br/&gt;PASS&lt;br/&gt;coverage: 60.8% of statements&lt;br/&gt;ok      unit    0.131s&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想指定测试某一个函数，可以在指令后面添加 &lt;code&gt;-run ${test文件内函数名}&lt;/code&gt; 来指定执行。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;☁️  go_unit_test [master] 🚗  go &lt;span&gt;test&lt;/span&gt; -cover -v  -run Test_getPersonDetailRedis&lt;br/&gt;=== RUN   Test_getPersonDetailRedis&lt;br/&gt;--- PASS: Test_getPersonDetailRedis (0.00s)&lt;br/&gt;PASS&lt;br/&gt;coverage: 41.9% of statements&lt;br/&gt;ok      unit    0.369s&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在执行 &lt;code&gt;go test&lt;/code&gt; 命令时，需要加上 &lt;code&gt;-gcflags=all=-l&lt;/code&gt; 防止编译器内联优化导致单测出现问题，这跟打桩代码存在密切的关系，后面我们会详细的介绍这一点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，一个完整的单测指令可以是 &lt;code&gt;go test -v -cover -gcflags=all=-l -coverprofile=coverage.out&lt;/code&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;生成覆盖报告&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，我们可以执行 &lt;code&gt;go tool cover -html=coverage.out&lt;/code&gt; ，查看代码的覆盖情况，使用前请先安装好 go tool 工具。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.1175799086757991&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavpL7c6oxP7Ljy42sicg1DjUjPUpUgA0klGWlac2f0J8XSYyF5AqBEgcTfk3de7sF8y9UxL74ibGPkQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;876&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到待测的代码覆盖率达到 100% 了，完整的代码仓库可以参考：https://github.com/xunan007/go_unit_test&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于 &lt;code&gt;go test&lt;/code&gt; 更多的使用方法，可以参考：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://golang.org/pkg/cmd/go/internal/test/&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;思考&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面我们已经详细的介绍了如何对 go 代码进行单元测试。下面探讨两个问题，帮助我们深入理解 go 单元测试的过程。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Q1：桩代码在单测中是如何执行的&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面的案例中，针对 interface 我们通过 gomock 来帮我们自动生成符合接口的类后，只需要通过 gomock 约定的 API 就能够对 interface 中的函数按期望和需要来模拟，这个很好理解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于函数以及方法的 mock，由于本身代码逻辑已经声明好（go 是静态强类型语言），我们很难通过编码的方式将其 mock 掉，这对我们做单元测试提供了很大的挑战。实际上 gomonkey 提供了让我们在运行时替换原函数/方法的能力。虽然说我们在语言层面很难去替换运行中的函数体，但是本身代码最终都会转换成机器可以理解的汇编指令，我们可以通过创建指令来改写函数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 gomonkey 打桩的过程中，其核心函数其实是 &lt;code&gt;ApplyCore&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(this *Patches)&lt;/span&gt; &lt;span&gt;ApplyCore&lt;/span&gt;&lt;span&gt;(target, double reflect.Value)&lt;/span&gt; *&lt;span&gt;Patches&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; this.check(target, double)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; _, ok := this.originals[target]; ok {&lt;br/&gt;  &lt;span&gt;panic&lt;/span&gt;(&lt;span&gt;&quot;patch has been existed&quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; this.valueHolders[double] = double&lt;br/&gt; original := replace(*(*&lt;span&gt;uintptr&lt;/span&gt;)(getPointer(target)), &lt;span&gt;uintptr&lt;/span&gt;(getPointer(double)))&lt;br/&gt; this.originals[target] = original&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; this&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不管是对函数打桩还是对方法打桩，实际上最后都会调用这个 &lt;code&gt;ApplyCore&lt;/code&gt; 函数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在第 8 行的位置，获取到传入的原始函数和替换函数做了一个 &lt;code&gt;replace&lt;/code&gt; 的操作，这里就是替换的逻辑所在了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;replace&lt;/span&gt;&lt;span&gt;(target, double &lt;span&gt;uintptr&lt;/span&gt;)&lt;/span&gt; []&lt;span&gt;byte&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; code := buildJmpDirective(double)&lt;br/&gt; bytes := entryAddress(target, &lt;span&gt;len&lt;/span&gt;(code))&lt;br/&gt; original := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;len&lt;/span&gt;(bytes))&lt;br/&gt; &lt;span&gt;copy&lt;/span&gt;(original, bytes)&lt;br/&gt; modifyBinary(target, code)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; original&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 关键函数：构建跳转指令&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;buildJmpDirective&lt;/span&gt;&lt;span&gt;(double &lt;span&gt;uintptr&lt;/span&gt;)&lt;/span&gt; []&lt;span&gt;byte&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    d0 := &lt;span&gt;byte&lt;/span&gt;(double)&lt;br/&gt;    d1 := &lt;span&gt;byte&lt;/span&gt;(double &amp;gt;&amp;gt; &lt;span&gt;8&lt;/span&gt;)&lt;br/&gt;    d2 := &lt;span&gt;byte&lt;/span&gt;(double &amp;gt;&amp;gt; &lt;span&gt;16&lt;/span&gt;)&lt;br/&gt;    d3 := &lt;span&gt;byte&lt;/span&gt;(double &amp;gt;&amp;gt; &lt;span&gt;24&lt;/span&gt;)&lt;br/&gt;    d4 := &lt;span&gt;byte&lt;/span&gt;(double &amp;gt;&amp;gt; &lt;span&gt;32&lt;/span&gt;)&lt;br/&gt;    d5 := &lt;span&gt;byte&lt;/span&gt;(double &amp;gt;&amp;gt; &lt;span&gt;40&lt;/span&gt;)&lt;br/&gt;    d6 := &lt;span&gt;byte&lt;/span&gt;(double &amp;gt;&amp;gt; &lt;span&gt;48&lt;/span&gt;)&lt;br/&gt;    d7 := &lt;span&gt;byte&lt;/span&gt;(double &amp;gt;&amp;gt; &lt;span&gt;56&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; []&lt;span&gt;byte&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;0x48&lt;/span&gt;, &lt;span&gt;0xBA&lt;/span&gt;, d0, d1, d2, d3, d4, d5, d6, d7, &lt;span&gt;// MOV rdx, double&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0x22&lt;/span&gt;,     &lt;span&gt;// JMP [rdx]&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 关键函数：重写目标函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;modifyBinary&lt;/span&gt;&lt;span&gt;(target &lt;span&gt;uintptr&lt;/span&gt;, bytes []&lt;span&gt;byte&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    function := entryAddress(target, &lt;span&gt;len&lt;/span&gt;(bytes))&lt;br/&gt;&lt;br/&gt;    page := entryAddress(pageStart(target), syscall.Getpagesize())&lt;br/&gt;    err := syscall.Mprotect(page, syscall.PROT_READ|syscall.PROT_WRITE|syscall.PROT_EXEC)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;panic&lt;/span&gt;(err)&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;copy&lt;/span&gt;(function, bytes)&lt;br/&gt;&lt;br/&gt;    err = syscall.Mprotect(page, syscall.PROT_READ|syscall.PROT_EXEC)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;panic&lt;/span&gt;(err)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的代码可以看出，&lt;code&gt;buildJmpDirective&lt;/code&gt; 构建了一个函数跳转的指令，把目标函数指针移动到寄存器 rdx 中，然后跳转到寄存器 rdx 中函数指针指向的地址。之后通过 &lt;code&gt;modifyBinary&lt;/code&gt; 函数，先通过 &lt;code&gt;entryAddress&lt;/code&gt; 方法获取到原函数所在的内存地址，之后通过 &lt;code&gt;syscall.Mprotect&lt;/code&gt; 方法打开内存保护，将函数跳转指令以 bytes 数组的形式调用 &lt;code&gt;copy&lt;/code&gt; 方法写入到原函数所在内存之中，最终达到替换的目的。此外，这里 &lt;code&gt;replace&lt;/code&gt; 方法还保留了原函数的副本，方便后续函数 mock 的恢复。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么 &lt;code&gt;buildJmpDirective&lt;/code&gt; 要构建这样的跳转指令呢？这里只说结论，具体的推导过程可以参考：https://bou.ke/blog/monkey-patching-in-go&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;a&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; }&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  f := a&lt;br/&gt;  f()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这段代码，&lt;code&gt;a&lt;/code&gt; 是一个指向函数实体的指针，&lt;code&gt;f&lt;/code&gt; 是指向函数 &lt;code&gt;a&lt;/code&gt; 指针的指针。把上面函数的调用反汇编，能够看到操作寄存器的具体细节。（ 如果对汇编不是很了解，可以先阅读 http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html ）&lt;img data-ratio=&quot;0.09728506787330317&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavpL7c6oxP7Ljy42sicg1DjU9hr0TyVCsX1S68ibA9T4A2dCwngticm2JlXjLXFlLjMq4TMzH9oYFxdA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;884&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一行，&lt;code&gt;lea&lt;/code&gt; 为 load effective address，这里是将 &lt;code&gt;f&lt;/code&gt; 变量这个值直接赋给 rdx 寄存器， &lt;code&gt;f&lt;/code&gt; 变量的值是指向 &lt;code&gt;a&lt;/code&gt; 函数的地址。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二行，&lt;code&gt;mov&lt;/code&gt; 表示移动，这里是取到内存地址为 rdx 的数据赋值给 rbx，此时内存地址 rbx 指向的刚好就是 &lt;code&gt;a&lt;/code&gt; 函数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，调用 rbx 里面的内容，其实也就是执行函数体。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，我们想改写函数，只要想办法把需要跳转的函数的地址加载到 rdx 寄存器中，之后使用指令跳转执行。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;MOV rdx, double&lt;br/&gt;JMP [rdx]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终，把汇编指令翻译成 go 能够识别的版本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这其实也是汇编里面很常见的热补丁，多用于进程中函数的替换。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Q2：执行 -gcflags=all=-l 具体有什么作用&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;-gcflags&lt;/code&gt; 用于在 go 编译构建时进行参数的传递，&lt;code&gt;all&lt;/code&gt; 表示覆盖所有在 &lt;code&gt;GOPATH&lt;/code&gt; 中的包，&lt;code&gt;-l&lt;/code&gt; 表示禁止编译的内联优化。该指令可以防止编译时代码内联优化使得 mock 失败，&lt;strong&gt;最终导致执行单元测试不通过&lt;/strong&gt;。下面我们具体来探讨一下“内联”以及给单元测试带来的影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通俗来讲，内联指的是把简短的函数在调用它的地方展开。由于函数调用有固定的开销（栈和抢占检查），在编译过程中，编译器可以针对代码进行内联，减少函数调用开销。内联优化是高性能编程的一种重要手段。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 go 中，编译器不会对所有简单函数进行内联优化。go 在决策是否要对函数进行内联时有一个标准：函&lt;strong&gt;数体内包含：闭包调用，select ，for ，defer，go 关键字的的函数不会进行内联。并且除了这些，还有其它的限制。当解析 AST 时，Go 申请了 80 个节点作为内联的预算。每个节点都会消耗一个预算。当一个函数的开销超过了这个预算，就无法内联。&lt;/strong&gt;（ 参考自：https://juejin.cn/post/6924888439577903117 ）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们通过一段简短的代码来理解 go 编译过程的内联优化过程。我们从 gomonkey 关于内联的 issue 摘取了一段代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;G2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;/span&gt; {  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;G2&quot;&lt;/span&gt; }&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;G&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;/span&gt; {  &lt;span&gt;return&lt;/span&gt; G2() }&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  g := G()&lt;br/&gt;  fmt.Println(g)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这段代码很简单，&lt;code&gt;main&lt;/code&gt; 函数中调用了 &lt;code&gt;G&lt;/code&gt; 函数拿到返回值赋值变量给 &lt;code&gt;g&lt;/code&gt; 后打印结果。其中 &lt;code&gt;G&lt;/code&gt; 函数调用了 &lt;code&gt;G2&lt;/code&gt; 函数，&lt;code&gt;G2&lt;/code&gt; 函数返回了字符串 &lt;code&gt;&quot;G2&quot;&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然而，经过编译器内联优化后的代码，&lt;code&gt;G&lt;/code&gt; 函数实际被展开了，最终 &lt;code&gt;main&lt;/code&gt; 函数被内联优化成：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// 展开 g := G()&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// =&amp;gt; g := &quot;G2&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 展开 fmt.Println(g)&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// =&amp;gt; 相关&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可见，&lt;code&gt;G&lt;/code&gt; 函数和 &lt;code&gt;G2&lt;/code&gt; 函数原本执行时候带来函数栈申请回收，优化过后将不再有。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们执行 &lt;code&gt;go run -gcflags=&quot;-m -m&quot; main.go&lt;/code&gt; 来查看编译在进行以上代码的内联优化。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;☁️  &lt;span&gt;test&lt;/span&gt;  go run -gcflags=&lt;span&gt;&quot;-m -m&quot;&lt;/span&gt; main.go&lt;br/&gt;&lt;span&gt;# command-line-arguments&lt;/span&gt;&lt;br/&gt;./main.go:5:6: can inline G2 as: func() string { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;G2&quot;&lt;/span&gt; } ./main.go:9:6: can inline G as: func() string { &lt;span&gt;return&lt;/span&gt; G2() } ./main.go:10:11: inlining call to G2 func() string { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;G2&quot;&lt;/span&gt; } ./main.go:13:6: cannot inline main: &lt;span&gt;function&lt;/span&gt; too complex: cost 87 exceeds budget 80&lt;br/&gt;./main.go:14:8: inlining call to G func() string { &lt;span&gt;return&lt;/span&gt; G2() } ./main.go:14:8: inlining call to G2 func() string { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;G2&quot;&lt;/span&gt; } ./main.go:15:13: inlining call to fmt.Println func(...interface {}) (int, error) { var fmt..autotmp_3 int; fmt..autotmp_3 = &amp;lt;N&amp;gt;; var fmt..autotmp_4 error; fmt..autotmp_4 = &amp;lt;N&amp;gt;; fmt..autotmp_3, fmt..autotmp_4 = fmt.Fprintln(io.Writer(os.Stdout), fmt.a...); &lt;span&gt;return&lt;/span&gt; fmt..autotmp_3, fmt..autotmp_4 }&lt;br/&gt;./main.go:15:13: g escapes to heap ./main.go:15:13: main []interface {} literal does not escape&lt;br/&gt;./main.go:15:13: io.Writer(os.Stdout) escapes to heap &amp;lt;autogenerated&amp;gt;:1: (*File).close .this does not escape G2&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从打印出的内容可以看，&lt;code&gt;G2\G\fmt.Println&lt;/code&gt; 都被内联了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面提到了 gomokey 打桩的逻辑，它是在函数调用的时候通过机器指令将函数的指向替换了。由于函数编译后被内联，实际上不存在函数的调用，导致单测执行不通过，这也是内联导致 gomonkey 打桩无效的问题所在。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;参考&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://juejin.cn/post/6924888439577903117&quot; data-linktype=&quot;2&quot;&gt;内联函数和编译器对 Go 代码的优化&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://bou.ke/blog/monkey-patching-in-go/&quot; data-linktype=&quot;2&quot;&gt;monkey patching in go&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html&quot; data-linktype=&quot;2&quot;&gt;阮一峰--汇编入门&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://pureage.info/2015/12/22/thundering-herd.html&quot; data-linktype=&quot;2&quot;&gt;最近好文：&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&amp;amp;mid=2649760092&amp;amp;idx=1&amp;amp;sn=23a5631e3abf7f2c28d0b1d01c471cba&amp;amp;chksm=beccb22789bb3b312637a3844ab44db7c977682a1fdf1d8fb73d9882cbaf2acd55aff9ee32ac&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;GPU虚拟化，算力隔离，和qGPU&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&amp;amp;mid=2649760076&amp;amp;idx=1&amp;amp;sn=545b46f541e0b7fd1a6e3022673afdc5&amp;amp;chksm=beccb23789bb3b21e8ec991184f16f46e68587941556e1079dcd811a777d3cc1cfb16c076f68&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;一文入门 Kafka&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&amp;amp;mid=2649759487&amp;amp;idx=1&amp;amp;sn=96c6b0f0d0b2857a792563aec2fc51d0&amp;amp;chksm=becc8d8489bb0492ce3dc4bfd79feccfae5208f8a3991eb661318b38fdbdc271f62d600c71c0&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;腾讯代码安全指南开源，涉及 C/C++、Go 等六门编程语言&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;“码上有趣” 视频挑战活动来了！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;上传视频赢HHKB键盘和罗技鼠标！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;了解活动可加微信：&lt;/span&gt;&lt;span&gt;teg_helper&lt;/span&gt;&lt;span&gt;（备注码上有&lt;/span&gt;&lt;span&gt;趣）&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;img data-ratio=&quot;1.3324074074074075&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasg12cLWBGqUL4GiclM1jU5YjdBLvBnAQrnuYGGsiaGag3QNy0ib7icicRfXm8MJctLcov9KJntty967sQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;最新视频&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAAoBUAOTnJJQAAAAstQy6ubaLX4KHWvLEZgBPEjaN0QAApJJf_zNPgMIvofJEifkRj1ywvLQ5m9Keo&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=RBfjicXSHKCOONJnTbRmmlD8cOQPXE48ib2PkNNJPMFAn028OFBZtja8142qjh9uYSnw1NPcfXRrn8497UPHhseibHr3ugPxpNx83f0IAuqZN6bUpcyWt0JY2097py0kLdARIypzJOYbnOBzgnWSCsNFZyx9bKBnUQjSDbIZSvrwqc&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SH&amp;amp;idx=1&amp;amp;m=2ce6ff89e2e82054e7d72197ca4841d6&amp;amp;token=x5Y29zUxcibDHxWfF8R3ao4TicE90YRAWc7bGXgen0SYnTicb9CdRkjaellSOwZyrrn&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/I7awtksbibjQe7RZAy84xEecUymmic8cw4v7Y2zbnVDuo/0&quot; data-username=&quot;v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder&quot; data-nickname=&quot;腾讯程序员&quot; data-desc=&quot;没想到python还能这么好玩！最后一个超温暖……#码上有趣 #程序员 #腾讯&quot; data-nonceid=&quot;11550590430847462750&quot; data-type=&quot;video&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>063cba9c04d191f5aebe85459aa196f9</guid>
<title>分布式下的区域问题，让我们大战了 300 回合</title>
<link>https://toutiao.io/k/4zvww14</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我最近参与了公司的一个新项目，需要通过openapi接口把&lt;code&gt;接入方&lt;/code&gt;的数据，比如：企业、订单、合同、物流等，同步到我们平台，然后我们平台给他们提供金融能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于&lt;code&gt;我方&lt;/code&gt;跟&lt;code&gt;对接方&lt;/code&gt;不在同一个城市，为了提高工作效率，双方进行了多次在线视频沟通。刚开始比较顺利，没想到在沟通企业信息上传接口时，接口文档中有个非常不起眼的&lt;code&gt;企业注册地id&lt;/code&gt;字段，让我们一下子进入了僵局。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到底是怎么回事呢？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.地区问题&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们平台的&lt;code&gt;企业表&lt;/code&gt;中有一个&lt;code&gt;企业注册地id&lt;/code&gt;字段，是必填的，用户在注册企业的页面需要选择一个地区，作为该企业的注册地，实际上数据库保存的是地区的id。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果该企业注册成功了，会在企业详情页面上展示该地区名称。当然我们系统的后台逻辑是先通过&lt;code&gt;地区id&lt;/code&gt;到&lt;code&gt;地区表&lt;/code&gt;反查出地区名称，然后在用户界面中展示出来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了跟&lt;code&gt;企业表&lt;/code&gt;保持一致，我方在定义接口文档时，企业注册地id字段也做成必填了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当时的情况是这样的：我方地区表中有id、地区名称、国标码、等级等字段，但这里的id，是我方数据库的主键，对接方系统中肯定是没有的。对接方系统中也有一套地区表，不过id是他们的数据库id，他们的表中也有地区名称、国标码、等级等字段。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5217391304347826&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDH9CPvtPSb6SMTh0xSaYiat2szO0UNeUVvOUHkJVibLickoxnSeTqvwbpPttul0ZIxY668212XRMCLDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1012&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以他们系统内部需要经过一番转换，才能把我们所需的地区id传给我们。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1.1 持久化本地地区表&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实这个项目我是中途才加入的，之前在处理别的事情，我加入的时候接口文档已经定义好了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我方跟对接方进行第二次在线沟通的时候，双方一起过接口文档的细节，包括：接口的作用、每个参数的含义，以及他们是否有值传过来等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中过到企业信息上传接口时，接口文档中有个&lt;code&gt;企业注册地id&lt;/code&gt;字段，对方没法传值过来。为了解决这个问题，我方第一版的方案是：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6478632478632479&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDH9CPvtPSb6SMTh0xSaYiat2icpuCesXSiaQAOXwiaOp9oOTa2wxb6kI8cia9jVLe2r3r1L7Imxq0NuhIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1170&quot;/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;对接方调用我方地区查询接口，通过多次分页查询，最终能获取我方所有地区数据，落库到他们本地的地区表。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;他们在调用我方企业信息上传接口之前，先查询本地的地区表，转换成我方所需要的地区id。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在讨论的过程中，对接方觉得他们也是平台，不应该做这些额外的事情。所以在那次会议中，双方针对这个问题，谁也没有说服谁，最终也没能达成共识。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后来，我思考了一下，确实这个方案太过理想化了，没有真正站到用户的角度思考问题，忽略了很多细节。可能跟文档设计者不对地区表不太熟悉有关系。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1.2 按名称调用地区查询接口&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那次会议当中，我们这边的几位同事，短暂的讨论了一下。既然对接方不愿意接受在他们本地持久化地区表，我们就退而求其次，不要求他们持久化了。这时我们这边有个同事提出，改成按名称调用地区查询接口，反查出地区id，具体方案如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6953271028037383&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDH9CPvtPSb6SMTh0xSaYiat2jK0CCy8d9heCN3Pq0ScvfuXM734WUQibWahtmx6sJVCr5xW1byStGrA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1070&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方案表面上看起来没有问题，但我之前负责过区域相关功能，我知道，就怕出现如下情况：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果对接方传的地区名称不完整，比如：本来是&lt;code&gt;成都市&lt;/code&gt;，实际上传的&lt;code&gt;成都&lt;/code&gt;。这样，我们地区查询接口，需要做模糊匹配，如果并发调用接口可能影响接口性能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果输入关键字&lt;code&gt;北京市&lt;/code&gt;，在我们这边的地区表中，可以找到两条数据，一条是跟&lt;code&gt;省级别&lt;/code&gt;一样的，另一条是跟&lt;code&gt;市级别&lt;/code&gt;一样的。到底对应哪条数据呢？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我当时把这两个问题抛出来了，不建议使用地区名称查询。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1.3 按国标码调用地区查询接口&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那个同事听完之后，也觉得用地区名称查询有点不靠谱。他马上修改方案，改成使用地区的国标码查询地区id，具体方案如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.662431941923775&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDH9CPvtPSb6SMTh0xSaYiat2C3icsD0VwdhWiblcUS9fqo3v2U1kZVanGrPibPE9uNzibcOxicHGWhV66lA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1102&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于当时讨论时间非常短，我们没来得及考虑太多，暂且打算用这套方案。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1.4 企业上传接口入参传国标码&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;过了一会儿，双方继续过接口文档，重新讨论企业信息上传接口中&lt;code&gt;企业注册地id&lt;/code&gt;字段传值问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;他们在调企业信息上传接口之前，先调一下我们地区查询接口，查出地区id，入参是国标码。然后再将这个地区id，在企业信息上传接口中传过来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对接方仔细听了我们的方案，犹豫了一下，他们觉得没有必要再调一次地区查询接口，双方都使用国标码不就行了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;他们的想法是：在企业信息上传接口中，入参由&lt;code&gt;企业注册地id&lt;/code&gt;改成&lt;code&gt;企业注册地国标码&lt;/code&gt;，由于国标码是国家统一的唯一编码，双方肯定是一样，能保证数据的一致性。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6938775510204082&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDH9CPvtPSb6SMTh0xSaYiat2gibiaV5Y3Y99dLicuMGibTVwSxO5BrKc2seWrIwmIVTOHgJic8icPMqicozag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1078&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.想起了一个问题&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说实话，如果你没接触过地区功能的话，大部分人可能会同意这套方案的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但比较巧合的是我之前正好接触过类似的功能，当时我突然想起了一个问题：&lt;strong&gt;双方数据的一致性如何保证？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道，由于国家的发展，有些城市可能会改名，比如：&lt;code&gt;襄樊&lt;/code&gt;改成了&lt;code&gt;襄阳&lt;/code&gt;，另外有时候多个地级市合并成一个市，这样国标码会变化，所以国家统计网每年都会调整地区名称和国标码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我方的地区表是两年之前创建的，数据初始化好之后没有就更新过。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而对接方不是跟我们在同一时刻初始化的数据，而且他们会定期更新地区数据，这样就导致了两边的数据不一致。如果对接方的业务表单中使用了新加的城市名和国标码，而这些信息在我方的地区表中没有，就无法查询出我方所需的地区id。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种情况该怎么办？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2.1 双方同一时刻更新地区表&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然上面的问题是一个非常棘手的问题，这时候有些小伙伴可能会说：&lt;code&gt;双方使用job同一时刻更新地区表&lt;/code&gt;，不就能解决问题了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3938931297709924&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDH9CPvtPSb6SMTh0xSaYiat2ibibsziaDvXx5mOalpdtiafhhic0oVOic152opSKTxrELxicRVL6dT2DJ1S0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1310&quot;/&gt;我不太赞成这种方案，主要原因如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;我方仅跟这个对接方有个同步执行的job，没问题。但如果还有其他的对接方，也需要调用企业信息上传接口，是不是也要整一个job，而且还要求大家都同一时刻执行，耦合性太大了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果我方和对接方同时执行job，但万一有任意一方执行失败了，也会导致数据不一致的情况。如果恰好这时候对接方在调用企业信息上传接口，会不会出问题？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2.2 以一方的地区数据为准？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的双方同一时刻更新地区表的方案确实有点不靠谱，但有些读者可能会问，以一方的地区数据为准，另一方把数据同步过来不就行了。具体方案如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7231503579952268&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDH9CPvtPSb6SMTh0xSaYiat2xMibQmXyBJ15sDUN7njGMqbrkYLg2XSZvmjCDzicvRpianZdBicYliaFQVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;838&quot;/&gt;这个方案其实跟之前我方给出的第一个方案很相似，已经被对接方拒绝了。站在他们的角度来说，确实没有必要因为上传企业信息，而保存我们的地区数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说实话，即使他们同意了，这种跨公司跨系统的数据一致性问题，也不好保证，因为如果对接方调用我们的地区接口失败了，此时，正好在上传企业信息，是不是也有问题？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.其他解决方案&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，我们当时为了解决问题，还穿插着讨论过这些方案。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1 上传的数据存快照&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我当时提出既然是保存对接方的数据，为啥不能存快照呢？我们可以把数据写到mongodb，数据格式用json，简单又高效。我的方案是：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7620137299771167&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDH9CPvtPSb6SMTh0xSaYiat2H5yXoGiaQ0anZO6mhyBbicOVsBv5DT12gfIpUlWROavV6xtcRokOkgaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;874&quot;/&gt;我们自己的业务数据存到mysql的业务表，而对接方的数据存在mongodb，互不干扰。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看起来，没有问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，当时产品说：银行那边规定，审查数据时只看我们mysql的业务表，其他的数据源不看。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好吧，不得不承认银行惹不起。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2 人工更新数据&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外一个同事的想法是，先让他们调用企业信息上传接口，如果发现有地区问题，我们手动帮他们调整地区表的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体方案如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7197696737044146&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDH9CPvtPSb6SMTh0xSaYiat2qCBT3Hgicy7ZgltzuqlxDejsn77xjf9h6hB383qIKsLp0kk3bGqOyPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1042&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果调用企业信息上传接口时，出现地区不存在的情况，则发报警邮件给指定人员。然后，指定人员手动新增或修改相关的地区数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这套方案看起来也可以，不过有个比较坑爹的地方就是，就怕在下班或者周末的时候出问题，反正我是不愿意去做这个事情的，你愿意吗？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.3 提供更新接口&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，我们还相关这套方案：对接方在调我们企业信息上传接口之前，先调我们地区查询接口查一下数据是否存在，如果不存在，则保存地区接口（保存包括：新增和修改），如果存在，则正常上传数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体方案如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7066666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDH9CPvtPSb6SMTh0xSaYiat2Qrde8ZGXicgGljp6Tib21s1jkdYGfeeSSog6CGibmKsJOtibaWdicC3wg7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方案还可以简化一下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7336343115124153&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDH9CPvtPSb6SMTh0xSaYiat27gg6BZmsfmeCShJSEian2UPCzXlLeesbrGfA5HGLLsibMysJAEZxYdiag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;886&quot;/&gt;将查询并保存地区的逻辑可以放到企业信息上传接口中，这样对接方肯定非常高兴，对他们来说是透明的，地区问题不存在了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但产品觉得地区是我们的基础数据，处于安全考虑，不能提供入口给他们修改，不然以后可能会乱套的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样不行，那也不行。我们一下子进入了困境，但为了不影响整体进度，只能先记录一下问题，然后跳过这个问题，继续讨论其他字段了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.如何解决这个问题？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我当天晚上思考了良久，第二天早上，发现跟我们老大的想法不谋而合。得出的结论是，既然存在差异化，没办法避免，我们就要从系统设计上接受差异化。在企业信息上传接口中增加两个字段：&lt;code&gt;企业注册地国标码&lt;/code&gt; 和 &lt;code&gt;地区名称&lt;/code&gt;，对接方改成传入这两个字段，具体方案如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8110091743119267&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDH9CPvtPSb6SMTh0xSaYiat2CgFEDfX0j87lSUsSPgAJHXc6y7nlmCKBhRQBUKicCzw1fG3ic1HtrsWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1090&quot;/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在我方的企业表中增加地区名称字段，是非必填的，同时把之前的地区id字段也改成非必填。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对接方在调用我方企业信息上传接口时，同时传入地区国标码和地区名称。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我方企业信息上传接口中判断，如果通过国标码能够找到地区id，则将地区id写入db，如果找不到，则将地区名称写入db。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们评估了一下影响范围，在企业表中的地区字段，只做展示用，没有修改入口，所以上面的这套方案是可行的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后来，再次跟对接方在线沟通时，把我们的这套方案告诉他们了，他们非常赞同。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5 总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽说这个地区问题，在众多技术问题中不值得一提。但是我仔细思考了一下，还是有一些宝贵的经验值得总结一下的，给有需要的小伙伴一个参考。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;5.1 要从用户的角度设计接口&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在设计接口文档时，要真正做到从用户的角度出发。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尤其是像这种openapi接口，定义的参数应该尽量选择通用的，大家都认可的参数，避免出现我方定制化的参数，比如：地区id。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽量减少用户的复杂度，让他们调用接口时更简单一些。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;5.2 技术方案要有包容性&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;技术方案要有包容性，不是非黑即白，需要有柔性的思想。在分布式环境中，如果去一味地追求数据的强一致性，不会有太好的结果。就像高并发下的商品秒杀系统，如果非要用同步方案去实现，系统最终可能会挂掉，更好的方案其实是改成异步队列处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我方和对接方都有地区表，数据很难保证完全一致，我们不要为了一致性而一致性，这样会适得其反。为了工作能够顺利进行下去，必然有一方要妥协，我的建议是openapi接口方做妥协，这种技术方案才够通用。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;5.3 没有最好的方案，只有最适合的&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我方最后的那个方案，其实并没有完全解决地区id找不到的问题，但是从业务的角度来看，即使没有地区id，有地区名称也是一样的。很显然，最后的方案是非常适合我们实际业务场景的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以没有最好的方案，只有最适合业务场景的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;5.4 进行有效的沟通&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在跟对接方在线沟通时，不要因为某个问题卡壳了，而一直僵持下去。如果当时没有好的技术方案，可以先选择暂时跳过这个问题，而沟通其他的内容。后面我们再私下单独花时间，仔细思考当时的问题，从而能够提出更合理的方案。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;5.5 技术是为业务服务的&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文的这个地区问题，咋一看比较简单。如果一细想，会发现里面有点东西。再加上各种外部因素的限制，你会发现分布式的环境中保证地区数据一致性，并不是那么好实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整个过程当中，我们提出了很多种技术方案，有些方案看似可以完美解决问题，但都被我们实际的业务场景给否定了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;技术是为业务服务的，技术虽说非常重要，但是如果离开了业务都是纸上谈兵。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>91cbbb74105250d80815a8c7a7250936</guid>
<title>神奇的 init 函数</title>
<link>https://toutiao.io/k/ks6lux9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;哈喽，兄弟们，我是&lt;code&gt;asong&lt;/code&gt;。今天与大家聊一聊&lt;code&gt;Go&lt;/code&gt;语言中的神奇函数&lt;code&gt;init&lt;/code&gt;，为什么叫他神奇函数呢？因为该函数可以在所有程序执行开始前被调用，并且每个包下可以有多个&lt;code&gt;init&lt;/code&gt;函数。这个函数使用起来比较简单，但是你们知道他的执行顺序是怎样的嘛？本文我们就一起来解密。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;code&gt;init&lt;/code&gt;函数的特性&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先简单介绍一下&lt;code&gt;init&lt;/code&gt;函数的基本特性：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;init&lt;/code&gt;函数先于&lt;code&gt;main&lt;/code&gt;函数自动执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个包中可以有多个&lt;code&gt;init&lt;/code&gt;函数，每个包中的源文件中也可以有多个&lt;code&gt;init&lt;/code&gt;函数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;init&lt;/code&gt;函数没有输入参数、返回值，也未声明，所以无法引用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不同包的&lt;code&gt;init&lt;/code&gt;函数按照包导入的依赖关系决定执行顺序&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;无论包被导入多少次，&lt;code&gt;init&lt;/code&gt;函数只会被调用一次，也就是只执行一次&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;code&gt;init&lt;/code&gt;函数的执行顺序&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我在刚学习&lt;code&gt;init&lt;/code&gt;函数时就对他的执行顺序很好奇，在谷歌上搜了几篇文章，他们都有一样的图：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下图来源于网络：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5228161668839635&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/k5430ljpYPOxmlhZQKTcFasm9DJiboFV8x3libJ9QgmfOtjeQic09HPGkKuRgZYQ8DxEm6xckYDopZUrRiaQ2iaXhtw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1534&quot;/&gt;&lt;figcaption&gt;截屏2021-06-05 上午9.55.15&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这张图片很清晰的反应了&lt;code&gt;init&lt;/code&gt;函数的加载顺序：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;包加载优先级排在第一位，先层层递归进行包加载&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个包中加载顺序为：&lt;code&gt;const&lt;/code&gt; &amp;gt; &lt;code&gt;var&lt;/code&gt; &amp;gt; &lt;code&gt;init&lt;/code&gt;，首先进行初始化的是常量，然后是变量，最后才是&lt;code&gt;init&lt;/code&gt;函数。针对包级别的变量初始化顺序，&lt;code&gt;Go&lt;/code&gt;官方文档给出这样一个例子：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; (&lt;br/&gt; a = c + b  &lt;span&gt;// == 9&lt;/span&gt;&lt;br/&gt; b = f()    &lt;span&gt;// == 4&lt;/span&gt;&lt;br/&gt; c = f()    &lt;span&gt;// == 5&lt;/span&gt;&lt;br/&gt; d = &lt;span&gt;3&lt;/span&gt;      &lt;span&gt;// == 5 after initialization has finished&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; d++&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; d&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;变量的初始化按出现的顺序从前往后进行，假若某个变量需要依赖其他变量，则被依赖的变量先初始化。所以这个例子中，初始化顺序是 &lt;code&gt;d&lt;/code&gt; -&amp;gt; &lt;code&gt;b&lt;/code&gt; -&amp;gt; &lt;code&gt;c&lt;/code&gt; -&amp;gt; &lt;code&gt;a&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图只是表达了&lt;code&gt;init&lt;/code&gt;函数大概的加载顺序，有些细节我们还是不知道的，比如：当前包下有多个&lt;code&gt;init&lt;/code&gt;函数，按照什么顺序执行，当前源文件下有多个&lt;code&gt;init&lt;/code&gt;函数，这又按照什么顺序执行呢？本来想写个例子挨个验证一下的，后来一看&lt;code&gt;Go&lt;/code&gt;官方文档中都有说明，也就没有必要再写一个例子啦，直接说结论吧：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果当前包下有多个&lt;code&gt;init&lt;/code&gt;函数，首先按照源文件名的字典序从前往后执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;若一个文件中出现多个&lt;code&gt;init&lt;/code&gt;函数，则按照出现顺序从前往后执行。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面说的有点乱，对&lt;code&gt;init&lt;/code&gt;函数的加载顺序做一个小结：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;从当前包开始，如果当前包包含多个依赖包，则先初始化依赖包，层层递归初始化各个包，在每一个包中，按照源文件的字典序从前往后执行，每一个源文件中，优先初始化常量、变量，最后初始化&lt;code&gt;init&lt;/code&gt;函数，当出现多个&lt;code&gt;init&lt;/code&gt;函数时，则按照顺序从前往后依次执行，每一个包完成加载后，递归返回，最后在初始化当前包！&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;code&gt;init&lt;/code&gt;函数的使用场景&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还记得我之前的这篇文章吗：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIzMDU0MTA3Nw==&amp;amp;mid=2247483947&amp;amp;idx=2&amp;amp;sn=32442f6f855162c2185a10e4329c74fa&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;go解锁设计模式之单例模式&lt;/a&gt;，借用&lt;code&gt;init&lt;/code&gt;函数的加载机制我们可以实现单例模式中的饿汉模式，具体怎么实现可以参考这篇文章，这里就不在写一遍了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;init&lt;/code&gt;函数的使用场景还是挺多的，比如进行服务注册、进行数据库或各种中间件的初始化连接等。&lt;code&gt;Go&lt;/code&gt;的标准库中也有许多地方使用到了&lt;code&gt;init&lt;/code&gt;函数，比如我们经常使用的&lt;code&gt;pprof&lt;/code&gt;工具，他就使用到了&lt;code&gt;init&lt;/code&gt;函数，在&lt;code&gt;init&lt;/code&gt;函数里面进行路由注册：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//go/1.15.7/libexec/src/cmd/trace/pprof.go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; http.HandleFunc(&lt;span&gt;&quot;/io&quot;&lt;/span&gt;, serveSVGProfile(pprofByGoroutine(computePprofIO)))&lt;br/&gt; http.HandleFunc(&lt;span&gt;&quot;/block&quot;&lt;/span&gt;, serveSVGProfile(pprofByGoroutine(computePprofBlock)))&lt;br/&gt; http.HandleFunc(&lt;span&gt;&quot;/syscall&quot;&lt;/span&gt;, serveSVGProfile(pprofByGoroutine(computePprofSyscall)))&lt;br/&gt; http.HandleFunc(&lt;span&gt;&quot;/sched&quot;&lt;/span&gt;, serveSVGProfile(pprofByGoroutine(computePprofSched)))&lt;br/&gt;&lt;br/&gt; http.HandleFunc(&lt;span&gt;&quot;/regionio&quot;&lt;/span&gt;, serveSVGProfile(pprofByRegion(computePprofIO)))&lt;br/&gt; http.HandleFunc(&lt;span&gt;&quot;/regionblock&quot;&lt;/span&gt;, serveSVGProfile(pprofByRegion(computePprofBlock)))&lt;br/&gt; http.HandleFunc(&lt;span&gt;&quot;/regionsyscall&quot;&lt;/span&gt;, serveSVGProfile(pprofByRegion(computePprofSyscall)))&lt;br/&gt; http.HandleFunc(&lt;span&gt;&quot;/regionsched&quot;&lt;/span&gt;, serveSVGProfile(pprofByRegion(computePprofSched)))&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里就不扩展太多了，更多标准库中的使用方法大家可以自己去探索一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这最后总结一下使用&lt;code&gt;init&lt;/code&gt;要注意的问题吧：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;编程时不要依赖&lt;code&gt;init&lt;/code&gt;的顺序&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个源文件下可以有多个&lt;code&gt;init&lt;/code&gt;函数，代码比较长时可以考虑分多个&lt;code&gt;init&lt;/code&gt;函数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;复杂逻辑不建议使用&lt;code&gt;init&lt;/code&gt;函数，会增加代码的复杂性，可读性也会下降&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在&lt;code&gt;init&lt;/code&gt;函数中也可以启动&lt;code&gt;goroutine&lt;/code&gt;，也就是在初始化的同时启动新的&lt;code&gt;goroutine&lt;/code&gt;，这并不会影响初始化顺序&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;init&lt;/code&gt;函数不应该依赖任何在&lt;code&gt;main&lt;/code&gt;函数里创建的变量，因为&lt;code&gt;init&lt;/code&gt;函数的执行是在&lt;code&gt;main&lt;/code&gt;函数之前的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;init&lt;/code&gt;函数在代码中不能被显示的调用，不能被引用（赋值给函数变量），否则会出现编译错误。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;导入包不要出现循环依赖，这样会导致程序编译失败&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Go&lt;/code&gt;程序仅仅想要用一个&lt;code&gt;package&lt;/code&gt;的&lt;code&gt;init&lt;/code&gt;执行，我们可以这样使用：&lt;code&gt;import _ &quot;test_xxxx&quot;&lt;/code&gt;，导入包的时候加上下划线就&lt;code&gt;ok&lt;/code&gt;了&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;包级别的变量初始化、&lt;code&gt;init&lt;/code&gt;函数执行，这两个操作都是在同一个&lt;code&gt;goroutine&lt;/code&gt;中调用的，按顺序调用，一次一个包&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好啦，这篇文章到这里就结束了，本身&lt;code&gt;init&lt;/code&gt;函数就很好理解，写这篇文章的目的就是让大家了解他的执行顺序，这样在日常开发中才不会写出&lt;code&gt;bug&lt;/code&gt;。希望本文对大家有所帮助，我们下期见！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;素质三连（分享、点赞、在看）都是笔者持续创作更多优质内容的动力！我是&lt;code&gt;asong&lt;/code&gt;，我们下期见。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;创建了一个Golang学习交流群，欢迎各位大佬们踊跃入群，我们一起学习交流。入群方式：关注公众号获取。更多学习资料请到公众号领取。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.31875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/k5430ljpYPOYL7ficz61N0y6PibjhbNIdeDNg5icqibFyib3OwN6dOOIoe5ibSUhj2pnvDHPSeFLCuLO6VZwb0EkrhOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;推荐往期文章：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;/&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>