<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>bcfe1691f96dc402d49e615902401123</guid>
<title>我在拼多多的三年</title>
<link>https://toutiao.io/k/jkvyo8g</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;
&lt;p&gt;表明身份1，没必要匿名了，根据拼多多的能力，稍微匹配一下时间段，想找到谁发帖非常容易。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;表明身份2，楼主2013年入学2017年毕业，曾在cc98非常活跃，毕业后渐渐远离。2018年6月18日社招入职拼多多，工作2.5年，特地R回来cc98讲讲关于拼多多这三年的变化，总结一下，就是越来越差，希望学弟学妹们千万不要去。另外本人已离职，未收到离职证明和全年的加班费，HR承诺4-7天内寄出，本周三是第八天，如果还没有收到离职证明或者快递单号的话，楼主会来更新《如何不体面地从拼多多离职》【2021年01月13日12:33:40，已收到离职证明一份。】，离职比日常更刺激哦。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;插曲，编写本文的过程中，1月11日，某拼多多员工在校友群劝退学弟学妹，已经被开除了，还好我已经离职了，不能给公司开除我的机会。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;声明立场，楼主对拼多多不满已经很久很久了，并不是墙倒众人推才来发帖，楼主在2020年12月9日递交了辞职通知，本来想着安安静静满30天走人，写个总结。结果从2021年1月1日到现在，该公司一直整活，导致我都没空来写文了，今天能发出来也是加班加点。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;拼多多，2018环境正常，2019环境变差，2020环境很差，2021已黑化，已离职；想直接看重点的从2019开始看。&lt;/p&gt;
&lt;h1&gt;# 2018&lt;/h1&gt;
&lt;p&gt;总体来说，2018年的拼多多还是挺好的，我待的挺开心。&lt;/p&gt;
&lt;h3&gt;### 入职&lt;/h3&gt;
&lt;p&gt;入职前，轩辕（花名，常用名 flanker）：”我去了一个创业公司，缺人，岗位很适合你，你要不要来，创立者是一些上交和浙大的。”。调查了一下，学弟A也去了，每周上六天班，严格打卡，也不是不能接受吧，在被蚂蚁金服的offer放鸽子之后，就去了pdd。&lt;/p&gt;
&lt;p&gt;2018.6.18 入职，当时技术安全组里只有*个人，看到了主管轩辕（现已离职，有大瓜：拼多多安全主管），相识多年学弟B（实习结束后离职），久仰大名的学长C，一面之缘的D，出现在业内新闻中的学姐E（现已离职），打听了一下还有SRC排行第一的大佬F，以及其他几位优秀的同事。看来我成了全场唯一指定最菜的人，来这里还有很多东西要学，后来发现自己很carry，不菜。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;入职当天的感受：当时办公设施确实挺简陋的，工位很挤，没有员工食堂，吃饭需要使用”美餐”APP进行点餐，按照自己的编号去货架拿，之后带到座位上吃。 基本是饿了就可以吃的，11:30-12:00之间随缘去取餐，虽然取餐室非常小，但还不拥挤，体验普通，但比 zju 的饭还是好一些的。（这里埋下伏笔1，2019 年制度更新）&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;办公室当时是没有座位号的，需要找人时候，只能大概描述自己的位置，非常难受；数月后，行政使用”五大洲”和座位编号，解决了这个棘手的问题，非常好。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;最开始住的”员工宿舍”，说是员工宿舍，其实条件挺一般的。1990年的房子，两室零厅，客厅是一个长条，每个卧室里两张床（我旁边的床位暂空），没有别的设备了。另外两个室友人挺好的，一位室友办理了宽带，还和我一起联机打游戏，虽然下班晚，但挺乐观的，另一位室友在七天后，从拼多多离职，入职了上海的字节跳动。这个屋子可能是我毕业后见过最破的住处了，临街很吵，停留在姑且能住的水平。对短期的实习生来说，还是比较方便的，不适合长期居住。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;15 天后，我和组里的入职不久的G（现已离职）合租，住在办公室对面的、1990年建造的老破小里面，一人一个卧室，在办公室可以看到房间窗户那种，上班 3 分钟。当然这个地方也挺破的，好在室友G很会过日子，指导我活着一起买了遮光窗帘、电热毯、水泵、灯泡，姑且能活下去洗个热水澡，唯一的优点就是离公司近，非常近，拼多多周日需要上班，周六没事干，就去办公室坐着，能使用”美餐”点饭（伏笔2），有网络可以自由使用（伏笔3），和实习生H一起在办公室渡过周六的无聊时光。&lt;/p&gt;
&lt;h3&gt;### 逐渐熟悉&lt;/h3&gt;
&lt;p&gt;慢慢组里的人多了起来，项目也多了起来，其乐融融。由于人少项目多，我从零开始，在 2018 年先后创立和负责了 A、B、C、D、E 等多个项目，并且多次参与公司的安全应急响应，有些工作做得很好，获得优秀绩效，也因为和其他组的开发同事由于意见不合吵架，获得了一次差评的绩效。虽然和2020年一样，每周上六天班，但2018时真的觉得拼多多挺好的，能做很多实事，在安全组，保卫拼多多的服务器、用户安全、商家安全、防止黑客入侵，切实看到成果，这些事情让我很自豪。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;在那时候我在大厅里看到98水友 @xxx 也入职拼多多了，感觉多了一个朋友挺开心的，于是这里就不得不说一下管培生的经历了。水友xxx当时是市场管培生，而我是一个技术，公司对二者的职业安排是完全不一样的。某日，我21-22点下班了，听说水友xxx还在办公到23点，我就惊了，原来校招应届生来了的前半年是当客服的，商家客服23点下班，而且有效率评估和 KPI，有严格的汇报制度，工作内容容易让人精神崩溃，我已经察觉到这个人有些不对劲了，我把我键盘借给她了，减缓痛苦程度。反正我下班也没事干，出于人道主义，有时就送她半夜回去，然后再自己走回去。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;由于在拼多多伙食较好（后来发现是每天吃官方外卖过于油腻），从 110 吃到了 130 斤，于是开始思考减肥，和周围5个同事把头像改成了”不瘦十斤不改头像”，在那时候晚上下班有时间去跑步，有几天是23点之后跑步，现在觉得还好自己没死；后来天气冷了就在室内锻炼，差不多减到了110-120之间。&lt;/p&gt;
&lt;p&gt;除了上六天班之外，好像也没什么想吐槽的，单身时候周末真是闲的蛋疼的。&lt;/p&gt;
&lt;h3&gt;### 11.11值班&lt;/h3&gt;
&lt;p&gt;半年后，双十一来了，第一次经历这个规模的事件，要求技术人员分为三波人，分别值守11.10晚上、11.11早上、11.11晚上，安全组总共也没几个人；由于我住得近，主动给住得远的同学承担了当天晚上。当时还是很兴奋的，一方面自己想要买东西，一方面也想看看到底有没有黑客在双十一时候搞入侵，虽然凌晨才离开，但挺满足的。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;双十一时候，好像连续上了十天班，然后获得两天的休息时间，在这时候，学姐E带我去杭州见闺蜜学妹，后来她的闺蜜成了我的女朋友，在爱情的鼓励下，余下的这几个月，我一直过的很开心，一周上六天班，空闲那天去做高铁去杭州约会，早上走晚上回，一点也感觉不到累。&lt;/p&gt;
&lt;h3&gt;### 全员大会和年会&lt;/h3&gt;
&lt;p&gt;拼多多上市后，听说有商家在楼下拉横幅也没有看到，也有挺多负面言论，但我本身是一个工程师，和我没什么关系。在上市静默期结束后，公司举行了全员大会，展望未来并且鼓励大家。目前我仅记得一句话：黄峥：”有同事的提问，我们什么时候可以双休呢？”（欢呼）”等我们成为中国第二，就可以双休了”（欢呼）。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;2021年了，情况好转了吗？没有。。。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;再之后便是年会了，节目中规中矩，吃的挺不错，我做出较多贡献，获得了年度优秀员工，这个 title 的人挺多的，应该是每个组拥有几个名额。听到几个熟悉的名字，感觉评价实至名归。&lt;/p&gt;
&lt;h3&gt;### 不愉快的小插曲&lt;/h3&gt;
&lt;p&gt;细节我实在是不记得了，可能时间点穿插在上文中。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;办公软件是企业QQ，有一个 xxxx 人的大群，名为上海员工群，99%的人都在群里，日常闲聊和吐槽。某日，有银行的人来办理香港银行卡，他们创建并且拉了一个微信群，同事之间相互推荐，可能有100个同事，我也在群里。突然，有HR在微信群里混进来了，请本群立刻解散，于是我被移除群聊。第二天，办公室大群宣布解散，官方给出的解散原因为：”为防止个人信息泄露，解散办公室的企业QQ群”。后来这种事情就很频繁了，包括解散了单身员工交友群（本来也没什么人说话），球类运动群，等。&lt;/p&gt;
&lt;p&gt;这件事我至今都一头雾水，不知道内部办公软件是怎样泄露个人信息的，群里都是员工是如何相互泄露信息的，公司只是随便找个借口解散大群罢了，关上员工的嘴而已。&lt;/p&gt;
&lt;h1&gt;# 2019&lt;/h1&gt;
&lt;p&gt;一切，在那件事之后就变了。。。。。&lt;/p&gt;
&lt;h3&gt;### 100元优惠券事件引发的全员7*24值班&lt;/h3&gt;
&lt;p&gt;2019.1.10 那是个周末，醒来时候女朋友和我说，”你们公司出事了，可以一百元优惠券随便领”。”扯什么呢，骗人的”。”哦，我没领到”。于是我去上班了，到了办公室，女朋友没有唬我，是真的，出大事了，后面也陆陆续续有各种各样的报道，这件事只是个导火索而已。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;这是一个非常大的问题，风控、大盘都有责任，本以为会让每个系统都接风控、全盘核查 API、重构代码等，从技术角度来解决类似问题，但拼多多的操作实在让我惊呆了。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;过年后，风控组开始7*24小时值班，每个技术岗必须值班，早班7-19点，晚班19-7点。虽然说不怎么合理，但也算是个临时的办法吧。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;数日后，技术全员开始7*24小时值班，多强调几遍，技术全员！技术全员！技术全员！&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;当晚，我印象非常深刻，主管召集组里 xx 个人，在会议室，气氛沉重，”告诉大家一个坏消息，我们也要全员值班了，具体规则我原文念一下xxxxxx”。所有人非常不情愿，大致规则是：每天两个班次，每个组派出1个人，校招生半年内不值班，女生不值晚班，社招x月内不值班，晚班有额外0.5天加班费，早班可以早下班。由于我们组满足条件的人太太太太少，因此只安排晚班，不安排早班。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;从个人角度评价一下这个制度。首先，我是没有线上业务的，有线上业务的人也就那么几个，总不能让人家每天24h在线吧；然后，我没有任何权限去处理其他人的业务；再次，别人的业务挂了，我也不知道如何恢复它；最后我得到结论，我的责任就是看报障信息，谁的服务挂了就把他打电话叫醒来。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;晚班是19点到7点，按照官方解释，需要在办公室通宵，允许不干活儿，允许玩手机，允许放下手头任务专心收报警邮件，但由于体谅员工，允许员工凌晨1点下班打卡，会房间里继续值班。结合我多次值班的经历，中间就是祈祷千万千万别出锅，让我睡个安稳觉。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;分享一下第一次值班时候的回忆：19:00 签到，继续搬砖，继续搬砖，没人了，玩手机，01:00了，下班打卡，在床上玩手机，玩手机，玩手机；03:00睡觉，偶尔醒来看一下消息；07:00起床，签退。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;基本是一晚上没睡觉，换来0.5倍工资，整个过程非常枯燥无聊，纯属就是在折腾人；在看破这个本质后，出于对健康的考虑，一方面把值班交给需要的人（比如夜猫子，非贬义），一方面真给不出去，就划划水渡过，基本都是平安夜。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;最开始我还存有侥幸心理，认为这个值班持续几个月发现没有效果，就可以结束了。现在 2021 年了，我的视角里值班制度至今没有任何效果，这个制度甚至成为了默认的制度，但我无法找到明文的制度规定，最早的保护体系也不存在了，女生也值晚班，刚入职的社招也值晚班，这里我狠狠踩一脚，做决策的人就是没脑子。&lt;/p&gt;
&lt;h3&gt;### 搬工位与人满为患&lt;/h3&gt;
&lt;p&gt;由于招的人越来越多，原先的工位不够用了就必须整个组都搬走，从入职到离职，我已经搬了大约8次工位了。三个月一小搬，六个月一大搬，最开始确实是因为人数问题，后来发现这个是拼多多的传统，就是折腾人而已，频繁的搬工位只能说明行政水平差，不会提前规划。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;然后就会遇到厕所问题，例如知名的”屎”厂新闻，所有人都在骂的事情，我就不展开说了，这么多年了没有任何改进。&lt;/p&gt;
&lt;h3&gt;### 消除伏笔&lt;/h3&gt;
&lt;p&gt;上文提到 2018 年一些较好的制度，在 2019 年都不复存在，公司在更强烈地约束员工。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;伏笔1：宽松的吃饭时间被取消，像喂猪一样卡点进食&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;2019 年的某日，可能是因为侦测到部分员工21:30去吃夜宵，突然来了一条规定，说禁止12/18/22点之前到取餐室。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;原先的制度：9-10点早饭，12点午饭，18点晚饭，（可以早点去拿，早点吃完早点干活儿）。周二周四22:00夜宵。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;优化后的制度：时间点不变，禁止提前去吃饭。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;我个人作息是9:30到办公室，吃早饭，午饭不饿，点一份水果下午吃并且减肥（埋下伏笔4），17:00开始饿，差不多就去吃晚饭，由于取餐是随机的，取餐室虽然小但是不拥挤。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;这个新政策一来，11:59:59，门口排队一条龙，工作人员掐着表，不让你进去，一到点，所有人都哗啦啦跑去排队，开始进食！如果去晚了，没个5分钟排队是领不到饭的。其实呢，送餐的11:30就差不多送完了，饭都凉了，就是卡着不让你吃，你气不气，你气不气？？？&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;监管不严时，这个制度会放松，例如11:59:30就可以进去了，但经常会收紧，举个例子。例1：有专员看着，说没到呢，不能拿，主管批评。例2：供应商说，不能提早给你，提早给你要扣我们钱的。前者是公司的走狗，后者只是公司克扣人家钱罢了。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;我愿称这个政策为喂猪政策，据我所知，只有喂猪才卡这么严格的时间，早一秒都不行。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;伏笔2：美餐的水果被移除，美餐的甜点被移除。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;原先的制度：点餐供应商丰富，午餐、晚餐可以点水果，晚餐可以点甜点。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;某日，由于有些员工住得近，周六中午点一份水果，到办公室带走，回家吃。对此，我提出批评，这个员工做的不对。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;有意思的来了，由于周六中午有不本分的员工来白嫖水果，公司决定取消每天的水果供应。我这个减肥的人表示非常苦恼，9:30吃早饭，午饭完全吃不下，只能象征性地点一份主食，对此我只想骂人。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;伏笔3：从某天起，办公网禁止访问某些网站。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;其实我是支持这个制度的，办公时间禁止刷视频，防止员工划水，也算正常。但坑爹的在于，这个网络屏蔽范围很迷，存在不合理的范围，举例：微软更新，微软商店，IntellijIdea官网，手机应用商店，华为login（无法理解），苹果更新推送（后解除），AppleStore（后解除）。一开始和管理员说一下就可以把误封的网站加白，后来不行了，要走流程，让主管审批，我就直接连热点了进行测试了（伏笔5)。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;再讲个笑话，某日大老板的某个APP无法访问，于是大赦天下，把该网站加白了；但我访问某些编程站点，确实是正规正当的请求，被拦截了，向IT提出意见，但是IT说不行，可能因为我不是大老板，是是是，他们说啥就是啥吧。&lt;/p&gt;
&lt;h3&gt;### 公司的消息流通&lt;/h3&gt;
&lt;p&gt;例如上文的三个伏笔，都是没有官方通知的，由高层转给主管，主管在群里，粘贴一下高层的意见，员工才能知道。如果这个公告容易引起舆论，公司会选择口口相传，最后让员工慢慢知道。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;官方一般只通知两件事，一是有员工被开除，二是下一个假期克扣几天假期。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;讲个笑话，公司内部发生的事情内部是没有任何公告的，员工获取公告的渠道是相互打听，去脉脉社区里闲逛，非常讽刺，称之为出口转内销。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;上文提到解散了QQ大群和部分民间微信群，终于有一天，公司变本加厉，大约是2019年6月，有用hr的微信群统统被解散，部门微信群也被责令解散，慢慢民间的微信群就消失殆尽，只有非常熟悉的几个人为了说话方便才会有微信群，一旦被hr发现，就会勒令解散，毫无人权。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;堵上员工的嘴，捂住员工的耳朵，一心搬砖领工资，这就是本分的奥义吧。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;顺带再提一下，由于长期缺乏文档和搜索功能，做什么事情基本都是靠问，技术方面举例：公司的xxx如何配置，xxx无法打日志怎么办；非技术方面举例，员工手册是什么，7*24值班的规章在哪，本分指的是什么，本分是口袋罪吗。&lt;/p&gt;
&lt;h3&gt;### 经典事件1：查监控确认考勤&lt;/h3&gt;
&lt;p&gt;拼多多上班和下班都是需要打卡的，分别是11点前20点后。举例，我10点到公司开始办公，我可以使用开机记录、浏览器记录、git记录、聊天记录等来证明自己确实来过，主管承认即可。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;某日，据传有员工替旁边员工开机的行为，高层大怒，决定以后补卡都需要HR查监控来执行，不再认可一切证明。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;当时我还是挺心疼HR的，屁大点事情都要他们来调监控。一年后，逐渐出现奇葩操作，补卡需要提供一份候选人的简历，补卡和主管绩效挂钩，主管开始强调大家上班一定要打卡。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;公司是非常不信任员工的，一切都会朝着坏的方向去思考。&lt;/p&gt;
&lt;h3&gt;### 经典事件2：周六值班旷班被集体开除&lt;/h3&gt;
&lt;p&gt;某个周六，一些不本分的员工值白班，7-19点，午饭期间溜出去，过了几个小时还没回来。几天后，查出后全部全员公告并且开除。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;员工确实做错了，但罪不至死，因为之前被开除的只有一类人，收受贿赂的运营，这是第一次技术公开被开除的事件。&lt;/p&gt;
&lt;h3&gt;### 经典事件3：查员工手机，并开除一位在脉脉发帖质疑空气质量的学弟&lt;/h3&gt;
&lt;h3&gt;### 经典事件4：变本加厉的值班&lt;/h3&gt;
&lt;p&gt;拼多多有四次大促，分别在 618、1010、1111、1212，本以为和 18 年的一样，但我还是太天真了。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;这次要求，技术全员值班，所有人都需要值班到凌晨一点，第二天早班的人除外。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;对了，这个值班是公益的、无偿的，连续两个晚上凌晨下班，通俗来讲，就是白嫖。由于我做底层支持，没有线上业务，无论呆到几点都没有任何帮助，不少人也是设个现象，但没有办法，命令就得执行。凌晨一点，电梯挤得就跟爆炸一样，xxxx 人，6 部电梯，等真正到楼下，已经凌晨1:30了。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;哦对了，如果大促在周一，公司会要求周末两天也要上班，也就是最多可以连上 13 天班，即 日一二三四五六日一二三四五，期间还要全员两天凌晨下班，这谁顶得住啊。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;我对公司的这种安排非常不屑，引以为耻。&lt;/p&gt;
&lt;h3&gt;### 经典事件5：公司wiki移除搜索、最近访问等功能&lt;/h3&gt;
&lt;p&gt;wiki是用来存放笔记和share工作内容的一个地方，为了防止信息泄露，官方移除了相关功能。代价就是，切断各个部门、各个业务之间的连接，自己哪天编辑过的文档也不知道放哪了，公司的组件出现问题不知道去哪搜，不知道去找谁，开发全靠问。对新入职的人来说，无疑是巨大的考验，但管理者并不 care 技术的死活，这种事也不是一天两天了。&lt;/p&gt;
&lt;h3&gt;### 经典事件6：公司禁止从事副业&lt;/h3&gt;
&lt;p&gt;某日，公司宣布禁止从事副业，需要诚实报备。按照我的认知，副业指签订劳动或者劳务合同，是不应该的行为，但这又是一个口袋罪，只有”禁止从事副业”这六个字，没有详细解释，这也是很常见的口头通知。为此有一名同事，微信里做微商卖东西被开除。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;分享这个例子，想说明公司的初衷可能是好的，但实行起来不考虑实际情况，没有明文判决，全靠大佬一句话。&lt;/p&gt;
&lt;h3&gt;### 记录日记&lt;/h3&gt;
&lt;p&gt;“正经人谁写日记呢”，确实，我不是正经人，因为我 2019年末 就想辞职了，于是专门开了一个笔记本，记录心态爆炸的瞬间，下文摘自日记。离职总是一瞬间的事，真正忙起来可能就懒得离职了，因此专门记录，防止忘掉伤痛。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;2019年11月&lt;/p&gt;
&lt;p&gt;腱鞘炎，手快断了，去医院，医生说少活动&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;2019年11月&lt;/p&gt;
&lt;p&gt;接到业务，本来我只是提供一些分析和参考，对网络编程完全不懂，现学现卖，补充大量不知道的知识，压力巨大，虽然我最后搞定了，但这样的功能交给专业的人来写，比我现学要好很多。那段时间每天做噩梦，非常难受。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;2019年11-12月&lt;/p&gt;
&lt;p&gt;接到业务的测试需求，不提供账号，不提供手机，让我凭空操作；&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;2019年12月&lt;/p&gt;
&lt;p&gt;生病了，基本所有人都生病了一遍，挨个传染，办公室人员太密集了；&lt;/p&gt;
&lt;p&gt;取饭时候排队的人太多了，吃饭会路过感染区，导致大面积感染，状态堪忧；&lt;/p&gt;
&lt;p&gt;生病发烧快死了，至少有女朋友可以照顾我；&lt;/p&gt;
&lt;p&gt;…&lt;/p&gt;
&lt;p&gt;再早的爷不记得了&lt;/p&gt;
&lt;h3&gt;### 跨年值班&lt;/h3&gt;
&lt;p&gt;说出来感觉又是个笑话，2019年快跨年了而31日是上班的，12月20日左右，作为年轻人我当然要请假出去玩，已经请好假。那么有意思的来了，大约12月25日突然发布消息，31日跨年夜要求全体员工值守在办公室，凌晨一点才下班，没有特殊原因不许请假。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;看到这个消息又一次惊呆了，第一次听说跨年还有大促，而且提前几天才通知，这不是搞人么，于是脉脉就有经典的帖子：”跨年时候整个公司的人都在办公室，大家相亲相爱，就像一个大家庭”，太讽刺了。&lt;/p&gt;
&lt;h3&gt;### 尾声&lt;/h3&gt;
&lt;p&gt;这一年我仍然在认真搬砖，拿到了优秀的绩效，但和上一年相比，我已经不大愿意推荐朋友们来拼多多了，毕竟我自己也想走，没必要带别人来，公司越来越严厉，对待员工越来越差。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;另外2020年初，爆发了疫情，世界都开始重新洗牌，我的离职计划也打乱了。&lt;/p&gt;
&lt;h1&gt;# 2020&lt;/h1&gt;
&lt;p&gt;加速，加速，加速&lt;/p&gt;
&lt;h3&gt;### 春节过后&lt;/h3&gt;
&lt;p&gt;正月初七后，由于大佬们的意见，部门主管们鼓励上海员工回去上班，这个部分懒得讲了，已经被人吐槽烂了，公司公然漠视上海的制度，已经忽视员工的健康和安全了。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;上班后，我问湖北来的同事，公司表面上说没上班的日子可以用周末和值班来补，暗示当月工资照常发，据同事说，当月工资已经被扣过了，gtmd，加班的话过年才给，我也懒得加班了，就当自费请假了。&lt;/p&gt;
&lt;h3&gt;### 为什么不离职&lt;/h3&gt;
&lt;p&gt;是想走的，由于2020整年疫情带来很大的不确定性，浑浑噩噩一年也可以这么过去。我个人么，我承认，由于工资涨了，女朋友也不着急，外界环境扑朔迷离，决定再干一段时间再走，这一干，就是一整年了，这一年真是见证各种历史。&lt;/p&gt;
&lt;h3&gt;### 消除伏笔&lt;/h3&gt;
&lt;p&gt;伏笔4：取消美餐&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;可能由于公司非常非常非常喜欢让员工定点进食，早一秒钟都不行。假设员工晚饭点了面包，就可以在外面吃饭，饭后回来带走面包，就绕过了”奴隶”的进食时间。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;按照公司的管理经验，出去吃饭是不本分的行为，毕竟这表示公司的饭不好吃，是大逆不道的行为，于是取消晚饭的甜点，取消周黑鸭。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;并且由于疫情的原因，2020年不再使用美餐作为供应商，原先20+的选择，现在只有4家餐饮可以选择，这个不是重点。重点在于，公司依然执行严格的进食时间，11:59:59后才允许去拿，原先是货架上的物品，现在需要供应商手动发放，效率应该是更低了。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;伏笔5：办公室进行手机信号屏蔽&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;连接手机热点，称为自费上网已经持续了好几个月了，一直用的挺好的，办公网只有10M带宽，下载个东西慢的要死。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;2020年8月，突然发现每天一到11点，手机网络剧烈卡顿，接近无法使用的状态。由于需要上网的设备很多，平时测试时我用热点，在那之后，我的工作就受到严重的阻碍。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;一开始我认为是蜂窝网接入者过多，导致网络卡顿无法使用，经过调研发现是区域问题，仅有我所在的工位无法使用流量，其他楼层、其他工区都可以。慢慢的，各个楼层，各个工区也无法使用，越来越多的证据表示是信号干扰，怎么说呢，只能祝拼多多越办越好了呗。&lt;/p&gt;
&lt;h3&gt;### 久病成医&lt;/h3&gt;
&lt;p&gt;公司不喜欢提前发放假通知，一般都是放假前几天才通知，由于我是老本分人了，早已对假期预测了如指掌。例如清明、端午一定会扣一天，国庆一定会扣两天，大促的周末不休息等。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;入职不久的员工经常来问我假期安排，每次我预测得都很准确，我知道公司会克扣假期，甚至连规律都总结出来了，不知道是该不该笑一下。&lt;/p&gt;
&lt;h3&gt;### 记录日记&lt;/h3&gt;
&lt;p&gt;2020至今&lt;/p&gt;
&lt;p&gt;办公室网络常年爆炸，访问外网慢的要死，尤其是 github 和 github-release&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;2020年03月07日&lt;/p&gt;
&lt;p&gt;第N次接到傻逼的需求，大老板缺乏安全感，证明其他大厂APP没有偷拼多多的数据&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;2020年03月07日&lt;/p&gt;
&lt;p&gt;连续 3 天工作时间超 12h，左胳膊肌肉疼&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;2020年03月07日&lt;/p&gt;
&lt;p&gt;巧妇难为无米之炊，开局一张图，无法复现全靠猜，手机也急缺，难&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;2020年05月09日&lt;/p&gt;
&lt;p&gt;wifi又双叒叕改了，瞎屏蔽应用商店，每天认证一次&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;2020年05月11日&lt;/p&gt;
&lt;p&gt;办公司wifi把应用商店、厂商官网给墙了&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;2020年05月11日&lt;/p&gt;
&lt;p&gt;接到傻逼需求，为防止被抹黑，需要对某现象进行技术上的解释，就这一件小事还非常着急，跟线上故障似的&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;2020年08月17日&lt;/p&gt;
&lt;p&gt;每到中午网络就巨差，今天4G 直接断网了，艹&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;2020年08月25日&lt;/p&gt;
&lt;p&gt;是真的信号干扰断网，迷，只能离线办公&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;2020年09月01日&lt;/p&gt;
&lt;p&gt;gitlab 的 readme.md 改为不展示，文档不公开，严重影响工作效率，不知道哪个脑残想出来的&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;2020年12月10日&lt;/p&gt;
&lt;p&gt;办公室也太吵了，隔壁就跟网吧开黑一样，神经衰弱无法上班，耳塞和降噪耳机也无法解决问题，还好我要离职了&lt;/p&gt;
&lt;h3&gt;### 公众事件&lt;/h3&gt;
&lt;p&gt;2020年我对拼多多感情急速下降，其实和公众的认知是一致的，无非以下几个事件&lt;/p&gt;
&lt;p&gt;1、大楼禁止员工穿拖鞋，被保安锁喉并且轻伤，公司未做任何声明；&lt;/p&gt;
&lt;p&gt;2、由于没有坑位，情急之下在男士便池里大便，公司未做任何声明；&lt;/p&gt;
&lt;p&gt;3、网传公司使用刁钻的计算方式，给离职员工发放0.3倍的周日加班费（正常结算是1.0倍，劳动法规定是2.0倍）；&lt;/p&gt;
&lt;p&gt;4、黄峥公开表示硬核奋斗模式，非技术员工被抽调去多多买菜，全年无休，租房中介都和我说你们公司最近走了好多人；&lt;/p&gt;
&lt;p&gt;5、略，其实公众都知道的。&lt;/p&gt;
&lt;h3&gt;### 又一次校招&lt;/h3&gt;
&lt;p&gt;校招季来了。好消息和坏消息，好消息是今年校招生的水平比去年强很多了；坏消息呢，公司最近出了很多负面事件，学生也会来问评价和看法，说实话我挺难受的。&lt;/p&gt;
&lt;h3&gt;### 丧心病狂的通宵值班&lt;/h3&gt;
&lt;p&gt;由于2019年的618、1010、1111、1212、跨年被安排了，我对即将发生的一切骚操作都不再感到意外，最经典的是十二月。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;双十二大促，员工需要连续上班 13 天，并且12.11、12.12需要全员加班到凌晨一点，然后12.31再次全员加班到凌晨一点。因为我已经提交离职了，没有必要再为公司卖命，这三天依然是没有额外工资的，说白了就是全员白嫖哈，你只是个机器人，服从命令就可以了。&lt;/p&gt;
&lt;h3&gt;### 提出辞职&lt;/h3&gt;
&lt;p&gt;女朋友和我异地快两年了，一直这样也不是个办法，反正我也厌恶公司的行为，混一混个年终奖就走吧。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;2020年12月9日，我无法忍受公司的文化和制度，flanker也走了，没什么好留恋的了，我自己也有家庭原因，决定离开这个鬼地方，网传公司有卡离职的操作，当天写了辞职信并且ems。这里打住，我将可能会有更精彩的第二篇文章《如何不体面地从拼多多离职》。&lt;/p&gt;
&lt;h3&gt;### 何为本分&lt;/h3&gt;
&lt;p&gt;本来以为2021年1月10日就可以悄无声息地离开了，不料2021年更精彩，就不用我多说了吧，猝死、跳楼、看到救护车被开除、围观开除被开除。。。至此，拼多多在我心中已完全黑化，没有一丝人性了。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;因为我只在腾讯和拼多多工作过，这里我要表扬一下腾讯，最开始的校招培训挺多是关于历史和价值观的，往坏了说是洗脑，至今我还记得是合作、正直、创新、进取。以前我总认为价值观这个东西没什么用，现在觉得腾讯价值观还是正确的，我在离开拼多多时思考，本分到底是什么，我粗浅地谈一下我的理解，不代表官方解释，期待有一天官方能有个解释。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;强调员工遵守公司的一切安排，无论安排合理与否；强调不做任何与公司无关的事，即使是在休息时间；强调你就是公司的一个包身工，一个雇佣兵，一个人肉电池，让你做什么你就做什么。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;拼多多是没有灵魂的，本分二字早已变味了，成为奴役员工的工具，私下调侃，例如”今天早上你本分了吗”指”今天11:00你打卡了吗”，”中午要去本分吗”指”中午在办公室吃还是去外面吃”，”今天晚上我不本分了”指”今天晚上我不加班，要早点跑了”，”你这个人不本分”指”你在发表反动言论了”，”这周日我不来本分了”指”这周日老子不来加班了”,”我以后永远都不本分了”指”我要离职了”。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;引用某位同事的反动言论：”在拼多多，除了给钱之外，其他事别多嘴，发生任何事情都不要意外”，颇有一种2077夜之城的感觉。&lt;/p&gt;
&lt;h1&gt;# 结语&lt;/h1&gt;
&lt;p&gt;劝学弟学妹不要来并不是因为加班严重，而是这个地方没有把你当做一个人，我自认为员工是一个电池、奴隶、包身工，这个地方是血汗工厂、监狱、集中营。拼多多给钱的确实比其他公司要多，如果家境普通当下缺钱的话可以来卖命，否则还是另寻他处吧。我并没有后悔加入拼多多，每个时代都有其局限性，2018年的拼多多还不是现在的拼多多，当时对我来说是最好的选择了，如果是2020年找工作，我是绝对不会考虑这个地方的。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;花了两天时间写完了我三年的回忆录，现在看着其实第一年的回忆最多，大部分都是美好的；后两年虽然痛苦，但能想起来的好像也就这么多，我认为是加班实在太严重了，无法思考我到底讨厌什么东西，还好有个日记做记录。还有其他不满是关于工作的，动不动就是”这是来自 叮当（CTO）、阿布（COO） 的紧急需求”，”这个方案不合理，但是是阿布说的”，出于保密我不能说太多，现在看看，后两年更多是流水账吧，没什么要害，只是一个一线员工的感受而已。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;后两年有多忙呢，举个例子，我平时购物都是女朋友负责的，身边大大小小的事情都由她来分担，甚至买房也是她负责，因为我太忙了无法考虑这些事情，我真的非常感谢她也非常爱她，在我离开拼多多后，终于有时间陪伴她了。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;最后把2020年的打卡记录分享一下吧，我的工时不算长，一切尽在不言中。&lt;/p&gt;
&lt;p/&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f2acaf33a28050099821a8fe9f60491d</guid>
<title>工具 | 滴滴开源的，高性能高可用的跨端开发框架</title>
<link>https://toutiao.io/k/afb7a01</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;大家好，我是周刊菌。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以下内容选自「码农周刊 VIP 会员」圈子，每日更新，精彩不断&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;1529&quot; data-ratio=&quot;1.9226666666666667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavicDGyUHukUCpLTzqjcCnRkd4oyd0Aic0FOFZHqN8r3NcLbpJLxxI1PmbDUBux9j8O3OUL1nV0D22Dg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;「码农周刊 VIP 会员」推出 37 周啦！感谢亲们的大力支持！第 037 期「码农周刊 VIP 会员专属邮件周报」已发送完毕，请注意查收。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;告诉大家一个好消息&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：已有数位上市公司 CTO 低调订阅了我们的「码农周刊 VIP 会员专属邮件周报」，感谢肯定！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;255&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;255&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;300&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/t8lpVibticjQ7PeUupLzwuuAibicnrRNxKcfCY7fIva78efKsUzANlCCAeuSQEGkGm34rKkzNRpzy6IiaiaHmBNA6DcA/640?wx_fmt=jpeg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;「码农周刊 VIP 会员」是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;简介版&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;码农周刊 VIP 会员 = 全年 52 期「VIP 会员专属邮件周报」 + 只限 VIP 会员加入的交流圈子 + 大厂「内推机会」 + N 多福利&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;详细版&lt;/span&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点击「阅读原文」即可查看详细介绍&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;码农周刊 VIP 新年特惠&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;原价 365 元/年&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;，现价仅需 108 元！&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;全年 52 期「VIP 会员专属邮件周报」&lt;br/&gt;只限 VIP 会员加入的交流圈子&lt;br/&gt;大厂「内推机会」&lt;br/&gt;N 多福利，你值得拥有！&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;CTO 们邀请你加入码农周刊 VIP，升职加薪不再难！&lt;br/&gt;↓↓↓&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;31&quot; data-cropselx2=&quot;291&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;350&quot; data-ratio=&quot;1.0857487922705313&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNav9LRTqibic3sUoh5tv76OXCpNTWbZ0gCYsFDShjwfRVvM157WDel2cr2dy5ghjxDCCwRc2Mu8bgehnA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;828&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2d89cbc99b4f6d5d0056e55bfaba90bc</guid>
<title>数据全景洞察概念简介</title>
<link>https://toutiao.io/k/0t26f76</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;h1&gt;&lt;span&gt;一、全景洞察简介&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1、行业背景&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;智能数字时代，数据不论形态、格式和类型，已经迅速成为企业最有战略意义的资产；数据资产已经成为了可以形成业务洞察及优势的战略资源，数据的体量、多样性和复杂性也正以指数级增长。就像其他重要的企业资产，数据需要适当的管理和治理水平,以确保它的潜在价值得到认识和发挥作用。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2、基础概念&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;DMP数据管理平台是DataManagementPlatform简称，是把分散的多方数据进行整合纳入统一的技术平台，并对这些数据进行标准化建模和细致分析，让用户可以把这些细分结果推向现有的互动营销环境里的平台。核心作用如下：可以对统一对数据快速查询、圈选符合条件的人群，生成特定场景对数据分析报告；可以基于此结果帮助客户快进入到市场周期中，并且可以对数据对洞察分析，对市场预测并作出反应，可以提升企业各方面的竞争优势，降低信息获取、运营、人力等各项成本。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3、核心因素&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;围绕实体-关系-标签这三个元素进行建模，从业务的角度出发对数据进行组织管理，以概念模型的形态透出，形成数据的画像报告，让人人都能看得懂。业务数据长期运营形成以标签为中心的智能数据体系，激活数据资产，实现数据资产的变现。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4、产生作用&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;精准营销投放：针对产品进行人群透视，挖掘潜在客，熟悉潜客偏好；产品研发：分析目标人群的行为特征，找到相关品类及产品特征，给新品带来数据参考；市场分析：掌握竞争趋势和差异，对于制定市场计划提供指引。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;二、核心概念&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1、标签工厂&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;标签管理是一件非常复杂的事情，数据基于准确的标签才会发挥出最大的价值。这里涉及到标签模型、更新&lt;/span&gt;迭代&lt;span&gt;、标签资源、标签云、私有标签池等各种功能管理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2、智能引擎&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;这个模块就是核心的业务模块，针对客户需求提供各种公共的或者定制化的营销流程，例如：主动式营销，触发式营销，周期性营销，特定时间营销等各种业务规则的引擎封装，还需要根据效果不断的优化改进。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3、画像报告&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;基于对数据的整理分析，以及在实际业务中的使用场景和效果，形成通用的或者定制的画像分析，例如：标签画像、人群画像、行业画像、营销画像等等。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4、应用工厂&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;基于DMP系统数据，提供开放的API能力，数据分析能力、标签查询、标签补齐、分析报告等各种综合业务。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;5、数据安全&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;对系统数据处理建立安全保护机制，保护计算机硬件、软件和数据不因偶然和人为的突发原因造成破坏、更改和泄露。最简单直白的解释和做法就是数据加密，保证数据不直白的在各种环境中流转。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;三、建设过程&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1、数据积累&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;形成数据治理意识，专注多个数据的产生渠道，汇总数据进而管理，例如Web端，APP端等数据源头，包括用户属性信息，行为信息等，形成流动的数据链条，管理结构化和非结构化数据，搭建数据基础仓库等。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2、分析能力&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;数据的价值体现在对数据对分析报告上，通过对海量数据分析来获得各类业务画像，进而对企业对营销产生价值。对数据状态有实时精准的更新，提供高效的数据生命周期管理，给业务评估或运营带来有价值的参考。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3、数据资产&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;企业数据不断积累，发展成为的企业资产，强调战略性业务成长、成本、风险与合规。数据意识，分析驱动，建立数据使用对综合能力。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3783359497645212&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvCjMheLZtcM2iaVMBOpIUKR4CDRCG9FLT5K6NmGXvG7exrW0TSuDjnTKJQ5PDq8j8Y7PHDd17Z3gicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1274&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>dc110962b631601209fd808e5f462cae</guid>
<title>一文带你解密 Go 语言之通道 channel</title>
<link>https://toutiao.io/k/jhyptjc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是煎鱼。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天这篇文章主要是针对 Go channel 的重点分析，一开始写的时候以为范围不会太大，但洋洋洒洒还是写破了万字，成为了一篇覆盖面较广和有一定深度的长文分析。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.24736842105263157&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4gL0h9gxv3OeDudYzvuHrYXJcs2pOFXoEXib2iaGuYV46aa7QWAqTseJsJavGBKE5SxAqU3VEwPeatQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1520&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家觉得不错的话，欢迎关注煎鱼和三连一波 ✍️。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接下来和煎鱼一起正式开始 Go channel 的学习之旅！&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 语言中的一大利器那就是能够非常方便的使用 &lt;code&gt;go&lt;/code&gt; 关键字来进行各种并发，而并发后又必然会涉及通信。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Channel 自然而然就成为了 Go 语言开发者中必须要明白明了的一个 “东西” 了，更别提实际工程应用和日常面试了，属于必知必会。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文目录：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.152112676056338&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4gL0h9gxv3OeDudYzvuHrYXdP4QY9cVLDia0PAQqCVZu7xkBEIKYTop8cJ5IX8dGjV8GBdjITvbpsQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;710&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;什么是 channel&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Go 语言中，channel 可以称其为通道，也可以叫管道。channel 主要常见于与 goroutine+select 搭配使用，再结合语录的描述。可以知道 channel 就是用于 goroutine 的数据通信：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;演示代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt; ch := make(chan string)&lt;br/&gt; go &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;  ch &amp;lt;- &lt;span&gt;&quot;煎鱼&quot;&lt;/span&gt;&lt;br/&gt; }()&lt;br/&gt;&lt;br/&gt; msg := &amp;lt;-ch&lt;br/&gt; fmt.Println(msg)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 goroutine1 中写入 “煎鱼” 到变量 &lt;code&gt;ch&lt;/code&gt; 中，goroutine2 监听变量 &lt;code&gt;ch&lt;/code&gt;，并阻塞等待读取到值 “煎鱼” 最终返回，结束流程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在此 channel 承载着一个衔接器的桥梁：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.424483306836248&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4gYzazJ7HcwarAl724nqI0rwRX244EkQF5w6LF2pibrHLUeo8xI5mJia8l0Tc9B57MribeMu8yvNuKrA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1258&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也是 channel 的经典思想了，&lt;strong&gt;不要通过共享内存来通信，而是通过通信来实现内存共享&lt;/strong&gt;（Do not communicate by sharing memory; instead, share memory by communicating）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从模式上来看，其就是在多个 goroutine 借助 channel 来传输数据，实现了跨 goroutine 间的数据传输，多者独立运行，不需要强关联，更不影响对方的 goroutine 状态。不存在 goroutine1 对 goroutine2 进行直传的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里思考一个问题，那 goroutine1 和 goroutine2 又怎么互相知道自己的数据 ”到“ 了呢？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;channel 基本特性&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Go 语言中，channel 的关键字为 &lt;code&gt;chan&lt;/code&gt;，数据流向的表现方式为 &lt;code&gt;&amp;lt;-&lt;/code&gt;，代码解释方向是从左到右，据此就能明白通道的数据流转方向了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;channel 共有两种模式，分别是：双向和单向；三种表现方式，分别是：声明双向通道：&lt;code&gt;chan T&lt;/code&gt;、声明只允许发送的通道：&lt;code&gt;chan &amp;lt;- T&lt;/code&gt;、声明只允许接收的通道：&lt;code&gt;&amp;lt;- chan T&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;channel 中还分为 “无缓冲 channel” 和 “缓冲 channel”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;演示代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 无缓冲&lt;br/&gt;ch1 := make(chan int)&lt;br/&gt;&lt;br/&gt;// 缓冲区为 3&lt;br/&gt;ch2 := make(chan int, 3)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们进一步展开这两类来看。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;无缓冲 channel&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无缓冲的 channel（unbuffered channel），其缓冲区大小则默认为 0。在功能上其接受者会阻塞等待并阻塞应用程序，直至收到通信和接收到数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种常用于两个 goroutine 间互相同步等待的应用场景：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7643884892086331&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4gYzazJ7HcwarAl724nqI0rm5u8zW20Lm9Kd7ibmfQzpTVB7ZQz5yZ4mUbd7ytJe15uNs3wNj48GEA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1112&quot;/&gt;&lt;figcaption&gt;unbuffered channel(via @William Kennedy)&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;缓冲 channel&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有缓存的 channel（buffered channel），其缓存区大小是根据所设置的值来调整。在功能上，若缓冲区未满则不会阻塞，会源源不断的进行传输。当缓冲区满了后，发送者就会阻塞并等待。而当缓冲区为空时，接受者就会阻塞并等待，直至有新的数据：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5089928057553957&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4gYzazJ7HcwarAl724nqI0rDbW2LD4ySQr9Tx9O5aAahVibqu87rCYcJp1qRz2Z8hTPsaU74R9ttKA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;556&quot;/&gt;&lt;figcaption&gt;buffered channel(via @William Kennedy)&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实际的应用场景中，两者根据业务情况选用就可以了，不需要太过纠结于两者是否有性能差距，没意义。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;channel 本质&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;channel 听起来实现了一个非常酷的东西，也是日常工作中常常会被面试官问到的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但其实 channel 并没有那么的 &quot;神秘&quot;，就是一个环形队列的配合。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们一步步的剖开 channel，看看里面到底是什么，怎么实现的跨 goroutine 通信，数据结构又是什么，两者又如何实现数据传输的？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;基本原理&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本质上 channel 在设计上就是环形队列。其包含发送方队列、接收方队列，加上互斥锁 &lt;code&gt;mutex&lt;/code&gt; 等结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;channel 是一个有锁的环形队列：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5016666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4gYzazJ7HcwarAl724nqI0rJ1KHjk5ERZeF2dqbrQbiaXffAv4YGEzopNuHRj7bGjic3Js1BhLibjZog/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;数据结构&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;hchan 结构体是 channel 在运行时的具体表现形式：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// src/runtime/chan.go&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; hchan struct {&lt;br/&gt; qcount   uint      &lt;br/&gt; dataqsiz uint     &lt;br/&gt; buf      unsafe.Pointer &lt;br/&gt; elemsize uint16&lt;br/&gt; closed   uint32&lt;br/&gt; elemtype *_type &lt;br/&gt; sendx    uint  &lt;br/&gt; recvx    uint  &lt;br/&gt; recvq    waitq  &lt;br/&gt; sendq    waitq  &lt;br/&gt;&lt;br/&gt; lock mutex&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;qcount：队列中的元素总数量。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;dataqsiz：循环队列的长度。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;buf：指向长度为 dataqsiz 的底层数组，仅有当 channel 为缓冲型的才有意义。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;elemsize：能够接受和发送的元素大小。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;closed：是否关闭。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;elemtype：能够接受和发送的元素类型。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;sendx：已发送元素在循环队列中的索引位置。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;recvx：已接收元素在循环队列中的索引位置。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;recvq：接受者的 sudog 等待队列（缓冲区不足时阻塞等待的 goroutine）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;sendq：发送者的 sudog 等待队列。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在数据结构中，我们可以看到 &lt;code&gt;recvq&lt;/code&gt; 和 &lt;code&gt;sendq&lt;/code&gt;，其表现为等待队列，其类型为 &lt;code&gt;runtime.waitq&lt;/code&gt; 的双向链表结构：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; waitq struct {&lt;br/&gt; first *sudog&lt;br/&gt; last  *sudog&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;且无论是 &lt;code&gt;first&lt;/code&gt; 属性又或是 &lt;code&gt;last&lt;/code&gt;，其类型都为 &lt;code&gt;runtime.sudog&lt;/code&gt; 结构体：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; sudog struct {&lt;br/&gt; g *g&lt;br/&gt;&lt;br/&gt; next *sudog&lt;br/&gt; prev *sudog&lt;br/&gt; elem unsafe.Pointer&lt;br/&gt; ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;g：指向当前的 goroutine。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;next：指向下一个 g。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;prev：指向上一个 g。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;elem：数据元素，可能会指向堆栈。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sudog 是 Go 语言中用于存放协程状态为阻塞的 goroutine 的双向链表抽象，你可以直接理解为一个正在等待的 goroutine 就可以了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在后续的实现原理分析中，基本围绕着上述数据结构进行大量的讨论，建议可以认真思考一下。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;channel 实现原理&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在了解了 channel 的基本原理后，我们进入到与应用工程中更紧密相关的部分，那就是 channel 的四大块操作，分别是：“创建、发送、接收、关闭”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们将针对这四块进行细致的分析和讲解。因此接下来的内容比较庞大，内容上将分为两个角度来讲述，分别是先从源码角度进行分析，再进行图示汇总。以便于大家更好的理解和思考&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;创建 chan&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建 channel 的演示代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ch := make(chan string)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其在编译器翻译后对应 &lt;code&gt;runtime.makechan&lt;/code&gt; 或 &lt;code&gt;runtime.makechan64&lt;/code&gt; 方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 通用创建方法&lt;br/&gt;func makechan(t *chantype, size int) *hchan&lt;br/&gt;&lt;br/&gt;// 类型为 int64 的进行特殊处理&lt;br/&gt;func makechan64(t *chantype, size int64) *hchan&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过前面我们得知 channel 的基本单位是 &lt;code&gt;hchan&lt;/code&gt; 结构体，那么在创建 channel 时，究竟还需要做什么是呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们一起分析一下 &lt;code&gt;makechan&lt;/code&gt; 方法，就能知道了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// src/runtime/chan.go&lt;br/&gt;func makechan(t *chantype, size int) *hchan {&lt;br/&gt; elem := t.elem&lt;br/&gt; mem, _ := math.MulUintptr(elem.size, uintptr(size))&lt;br/&gt;&lt;br/&gt; var c *hchan&lt;br/&gt; switch {&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; mem == 0:&lt;br/&gt;  c = (*hchan)(mallocgc(hchanSize, nil, &lt;span&gt;true&lt;/span&gt;))&lt;br/&gt;  c.buf = c.raceaddr()&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; elem.ptrdata == 0:&lt;br/&gt;  c = (*hchan)(mallocgc(hchanSize+mem, nil, &lt;span&gt;true&lt;/span&gt;))&lt;br/&gt;  c.buf = add(unsafe.Pointer(c), hchanSize)&lt;br/&gt; default:&lt;br/&gt;  c = new(hchan)&lt;br/&gt;  c.buf = mallocgc(mem, elem, &lt;span&gt;true&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; c.elemsize = uint16(elem.size)&lt;br/&gt; c.elemtype = elem&lt;br/&gt; c.dataqsiz = uint(size)&lt;br/&gt; lockInit(&amp;amp;c.lock, lockRankHchan)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; c&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建 channel 的逻辑主要分为三大块：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当前 channel 不存在缓冲区，也就是元素大小为 0 的情况下，就会调用 &lt;code&gt;mallocgc&lt;/code&gt; 方法分配一段连续的内存空间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当前 channel 存储的类型存在指针引用，就会连同 &lt;code&gt;hchan&lt;/code&gt; 和底层数组同时分配一段连续的内存空间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通用情况，默认分配相匹配的连续内存空间。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意到一块特殊点，那就是 channel 的创建都是调用的 &lt;code&gt;mallocgc&lt;/code&gt; 方法，也就是 channel 都是创建在堆上的。因此 channel 是会被 GC 回收的，自然也不总是需要 &lt;code&gt;close&lt;/code&gt; 方法来进行显示关闭了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从整体上来讲，&lt;code&gt;makechan&lt;/code&gt; 方法的逻辑比较简单，就是创建 &lt;code&gt;hchan&lt;/code&gt; 并分配合适的 &lt;code&gt;buf&lt;/code&gt; 大小的堆上内存空间。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;发送数据&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;channel 发送数据的演示代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    ch &amp;lt;- &lt;span&gt;&quot;煎鱼&quot;&lt;/span&gt;&lt;br/&gt;}()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其在编译器翻译后对应 &lt;code&gt;runtime.chansend1&lt;/code&gt; 方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func chansend1(c *hchan, elem unsafe.Pointer) {&lt;br/&gt; chansend(c, elem, &lt;span&gt;true&lt;/span&gt;, getcallerpc())&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其作为编译后的入口方法，实则指向真正的实现逻辑，也就是 &lt;code&gt;chansend&lt;/code&gt; 方法。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;前置处理&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在第一部分中，我们先看看 chan 发送的一些前置判断和处理：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; c == nil {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; !block {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  gopark(nil, nil, waitReasonChanSendNilChan, traceEvGoStop, 2)&lt;br/&gt;  throw(&lt;span&gt;&quot;unreachable&quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt; &lt;br/&gt; &lt;span&gt;if&lt;/span&gt; !block &amp;amp;&amp;amp; c.closed == 0 &amp;amp;&amp;amp; full(c) {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; // 省略一些调试相关&lt;br/&gt; ...&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func full(c *hchan) bool {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; c.dataqsiz == 0 {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; c.recvq.first == nil&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; c.qcount == c.dataqsiz&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一开始 &lt;code&gt;chansend&lt;/code&gt; 方法在会先判断当前的 channel 是否为 nil。若为 nil，在逻辑上来讲就是向 nil channel 发送数据，就会调用 &lt;code&gt;gopark&lt;/code&gt; 方法使得当前 Goroutine 休眠，进而出现死锁崩溃，表象就是出现 &lt;code&gt;panic&lt;/code&gt; 事件来快速失败。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;紧接着会对非阻塞的 channel 进行一个上限判断，看看是否快速失败。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;失败的场景如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;若非阻塞且未关闭，同时底层数据 dataqsiz 大小为 0（缓冲区无元素），则会返回失败。。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;若是 qcount 与 dataqsiz 大小相同（缓冲区已满）时，则会返回失败。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;上互斥锁&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在完成了 channel 的前置判断后，即将在进入发送数据的处理前，channel 会进行上锁：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {&lt;br/&gt; ...&lt;br/&gt; lock(&amp;amp;c.lock)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上锁后就能保住并发安全。另外我们也可以考虑到，这种场景会相对依赖单元测试的覆盖，因为一旦没考虑周全，漏上锁了，基本就会出问题。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;直接发送&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在正式开始发送前，加锁之后，会对 channel 进行一次状态判断（是否关闭）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {&lt;br/&gt; ...&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; c.closed != 0 {&lt;br/&gt;  unlock(&amp;amp;c.lock)&lt;br/&gt;  panic(plainError(&lt;span&gt;&quot;send on closed channel&quot;&lt;/span&gt;))&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; sg := c.recvq.dequeue(); sg != nil {&lt;br/&gt;  send(c, sg, ep, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;/span&gt;() { unlock(&amp;amp;c.lock) }, 3)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种情况是最为基础的，也就是当前 channel 有正在阻塞等待的接收方，那么只需要直接发送就可以了。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;缓冲发送&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非直接发送，那么就考虑第二种场景，判断 channel 缓冲区中是否还有空间：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {&lt;br/&gt; ...&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; c.qcount &amp;lt; c.dataqsiz {&lt;br/&gt;  qp := chanbuf(c, c.sendx)&lt;br/&gt;  typedmemmove(c.elemtype, qp, ep)&lt;br/&gt;  c.sendx++&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; c.sendx == c.dataqsiz {&lt;br/&gt;   c.sendx = 0&lt;br/&gt;  }&lt;br/&gt;  c.qcount++&lt;br/&gt;  unlock(&amp;amp;c.lock)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; !block {&lt;br/&gt;  unlock(&amp;amp;c.lock)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;会对缓冲区进行判定（&lt;code&gt;qcount&lt;/code&gt; 和 &lt;code&gt;dataqsiz&lt;/code&gt; 字段），以此识别缓冲区的剩余空间。紧接进行如下操作：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;调用 &lt;code&gt;chanbuf&lt;/code&gt; 方法，以此获得底层缓冲数据中位于 sendx 索引的元素指针值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用 &lt;code&gt;typedmemmove&lt;/code&gt; 方法，将所需发送的数据拷贝到缓冲区中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据拷贝后，对 sendx 索引自行自增 1。同时若 sendx 与 dataqsiz 大小一致，则归 0（环形队列）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自增完成后，队列总数同时自增 1。解锁互斥锁，返回结果。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此针对缓冲区的数据操作完成。但若没有走进缓冲区处理的逻辑，则会判断当前是否阻塞 channel，若为非阻塞，将会解锁并直接返回失败。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配合图示如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4431818181818182&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4gYzazJ7HcwarAl724nqI0rh6icAgz61McWviceS0n1TdErxVXzfvM7S3aTAMMYv1jZMoXq5GUZa65g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1760&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;阻塞发送&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在进行了各式各样的层层筛选后，接下来进入阻塞等待发送的过程：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {&lt;br/&gt; ...&lt;br/&gt; gp := getg()&lt;br/&gt; mysg := acquireSudog()&lt;br/&gt; mysg.releasetime = 0&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; t0 != 0 {&lt;br/&gt;  mysg.releasetime = -1&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; mysg.elem = ep&lt;br/&gt; mysg.waitlink = nil&lt;br/&gt; mysg.g = gp&lt;br/&gt; mysg.isSelect = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt; mysg.c = c&lt;br/&gt; gp.waiting = mysg&lt;br/&gt; gp.param = nil&lt;br/&gt; c.sendq.enqueue(mysg)&lt;br/&gt;&lt;br/&gt; atomic.Store8(&amp;amp;gp.parkingOnChan, 1)&lt;br/&gt; gopark(chanparkcommit, unsafe.Pointer(&amp;amp;c.lock), waitReasonChanSend, traceEvGoBlockSend, 2)&lt;br/&gt;&lt;br/&gt; KeepAlive(ep)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;调用 &lt;code&gt;getg&lt;/code&gt; 方法获取当前 goroutine 的指针，用于后续发送数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用 &lt;code&gt;acquireSudog&lt;/code&gt; 方法获取 &lt;code&gt;sudog&lt;/code&gt; 结构体，并设置当前 sudog 具体的待发送数据信息和状态。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用 &lt;code&gt;c.sendq.enqueue&lt;/code&gt; 方法将刚刚所获取的 &lt;code&gt;sudog&lt;/code&gt; 加入待发送的等待队列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用 &lt;code&gt;gopark&lt;/code&gt; 方法挂起当前 goroutine（会记录执行位置），状态为 waitReasonChanSend，阻塞等待 channel。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用 &lt;code&gt;KeepAlive&lt;/code&gt; 方法保证待发送的数据值是活跃状态，也就是分配在堆上，避免被 GC 回收。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配合图示如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6289198606271778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4gYzazJ7HcwarAl724nqI0rGgbUe3ibexj9Pv7ZBYnr5fC4MYHyQVC8TEBAoBEpqkYEcFJyZcHtMfA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1148&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在当前 goroutine 被挂起后，其将会在 channel 能够发送数据后被唤醒：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {&lt;br/&gt; ...&lt;br/&gt; // 从这里开始唤醒，并恢复阻塞的发送操作&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; mysg != gp.waiting {&lt;br/&gt;  throw(&lt;span&gt;&quot;G waiting list is corrupted&quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt; gp.waiting = nil&lt;br/&gt; gp.activeStackChans = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; gp.param == nil {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; c.closed == 0 {&lt;br/&gt;   throw(&lt;span&gt;&quot;chansend: spurious wakeup&quot;&lt;/span&gt;)&lt;br/&gt;  }&lt;br/&gt;  panic(plainError(&lt;span&gt;&quot;send on closed channel&quot;&lt;/span&gt;))&lt;br/&gt; }&lt;br/&gt; gp.param = nil&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; mysg.releasetime &amp;gt; 0 {&lt;br/&gt;  blockevent(mysg.releasetime-t0, 2)&lt;br/&gt; }&lt;br/&gt; mysg.c = nil&lt;br/&gt; releaseSudog(mysg)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;唤醒 goroutine（调度器在停止 g 时会记录运行线程和方法内执行的位置）并完成 channel 的阻塞数据发送动作后。进行基本的参数检查，确保是符合要求的（纵深防御），接着开始取消 mysg 上的 channel 绑定和 sudog 的释放。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此完成所有类别的 channel 数据发送管理。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;接收数据&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;channel 接受数据的演示代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;msg := &amp;lt;-ch&lt;br/&gt;&lt;br/&gt;msg, ok := &amp;lt;-ch&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两种方法在编译器翻译后分别对应 &lt;code&gt;runtime.chanrecv1&lt;/code&gt; 和 &lt;code&gt;runtime.chanrecv2&lt;/code&gt; 两个入口方法，其再在内部再进一步调用 &lt;code&gt;runtime.chanrecv&lt;/code&gt; 方法：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意，发送和接受 channel 是相对的，也就是其核心实现也是相对的。因此在理解时也可以结合来看。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;前置处理&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; c == nil {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; !block {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  gopark(nil, nil, waitReasonChanReceiveNilChan, traceEvGoStop, 2)&lt;br/&gt;  throw(&lt;span&gt;&quot;unreachable&quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一开始时 &lt;code&gt;chanrecv&lt;/code&gt; 方法会判断其是否为 nil channel。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;场景如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;若 channel 是 nil channel，且为阻塞接收则调用 &lt;code&gt;gopark&lt;/code&gt; 方法挂起当前 goroutine。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;若 channel 是非阻塞模式，则直接返回。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而接下来对于非阻塞模式的 channel 会进行快速失败检查，检测 channel 是否已经准备好接收。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;if&lt;/span&gt; !block &amp;amp;&amp;amp; empty(c) {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; atomic.Load(&amp;amp;c.closed) == 0 {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; empty(c) {&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; ep != nil {&lt;br/&gt;    typedmemclr(c.elemtype, ep)&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt; ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其分以下几种情况：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;无缓冲区：循环队列为 0 及等待队列 sendq 内没有 goroutine 正在等待。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有缓冲区：缓冲区数组为空。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随后会对 channel 的 closed 状态进行判断，因为 channel 是无法重复打开的，需要确定当前 channel 是否为未关闭状态。再确定接收失败，返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但若是 channel 已经关闭且不存在缓存数据了，则会清理 &lt;code&gt;ep&lt;/code&gt; 指针中的数据并返回。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;直接接收&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当发现 channel 上有正在阻塞等待的发送方时，则直接进行接收：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) {&lt;br/&gt;&lt;br/&gt; lock(&amp;amp;c.lock)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; sg := c.sendq.dequeue(); sg != nil {&lt;br/&gt;  recv(c, sg, ep, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;/span&gt;() { unlock(&amp;amp;c.lock) }, 3)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;缓冲接收&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当发现 channel 的缓冲区中有元素时：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) {&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; c.qcount &amp;gt; 0 {&lt;br/&gt;  qp := chanbuf(c, c.recvx)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; ep != nil {&lt;br/&gt;   typedmemmove(c.elemtype, ep, qp)&lt;br/&gt;  }&lt;br/&gt;  typedmemclr(c.elemtype, qp)&lt;br/&gt;  c.recvx++&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; c.recvx == c.dataqsiz {&lt;br/&gt;   c.recvx = 0&lt;br/&gt;  }&lt;br/&gt;  c.qcount--&lt;br/&gt;  unlock(&amp;amp;c.lock)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; !block {&lt;br/&gt;  unlock(&amp;amp;c.lock)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将会调用 &lt;code&gt;chanbuf&lt;/code&gt; 方法根据 &lt;code&gt;recvx&lt;/code&gt; 的索引位置取出数据，找到要接收的元素进行处理。若所接收到的数据和所传入的变量均不为空，则会调用 &lt;code&gt;typedmemmove&lt;/code&gt; 方法将缓冲区中的数据拷贝到所传入的变量中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后数据拷贝完毕后，进行各索引项和队列总数的自增增减，并调用 &lt;code&gt;typedmemclr&lt;/code&gt; 方法进行内存数据的清扫。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;阻塞接收&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当发现 channel 上既没有待发送的 goroutine，缓冲区也没有数据时。将会进入到最后一个阶段阻塞接收：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) {&lt;br/&gt;&lt;br/&gt; gp := getg()&lt;br/&gt; mysg := acquireSudog()&lt;br/&gt; mysg.releasetime = 0&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; t0 != 0 {&lt;br/&gt;  mysg.releasetime = -1&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; mysg.elem = ep&lt;br/&gt; mysg.waitlink = nil&lt;br/&gt; gp.waiting = mysg&lt;br/&gt; mysg.g = gp&lt;br/&gt; mysg.isSelect = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt; mysg.c = c&lt;br/&gt; gp.param = nil&lt;br/&gt; c.recvq.enqueue(mysg)&lt;br/&gt;&lt;br/&gt; atomic.Store8(&amp;amp;gp.parkingOnChan, 1)&lt;br/&gt; gopark(chanparkcommit, unsafe.Pointer(&amp;amp;c.lock), waitReasonChanReceive, traceEvGoBlockRecv, 2)&lt;br/&gt; ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一块接收逻辑与发送也基本类似，主体就是获取当前 goroutine，构建 sudog 结构保存当前待接收数据（发送方）的地址信息，并将 sudog 加入等待接收队列。最后调用 &lt;code&gt;gopark&lt;/code&gt; 方法挂起当前 goroutine，等待唤醒。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) {&lt;br/&gt;&lt;br/&gt; // 被唤醒后从此处开始&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; mysg != gp.waiting {&lt;br/&gt;  throw(&lt;span&gt;&quot;G waiting list is corrupted&quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt; gp.waiting = nil&lt;br/&gt; gp.activeStackChans = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; mysg.releasetime &amp;gt; 0 {&lt;br/&gt;  blockevent(mysg.releasetime-t0, 2)&lt;br/&gt; }&lt;br/&gt; closed := gp.param == nil&lt;br/&gt; gp.param = nil&lt;br/&gt; mysg.c = nil&lt;br/&gt; releaseSudog(mysg)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;, !closed&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;被唤醒后，将恢复现场，回到对应的执行点，完成最后的扫尾工作。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;关闭 chan&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关闭 channel 主要是涉及到 &lt;code&gt;close&lt;/code&gt; 关键字：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;close(ch)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其对应的编译器翻译方法为 &lt;code&gt;closechan&lt;/code&gt; 方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func closechan(c *hchan)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;前置处理&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func closechan(c *hchan) {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; c == nil {&lt;br/&gt;  panic(plainError(&lt;span&gt;&quot;close of nil channel&quot;&lt;/span&gt;))&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; lock(&amp;amp;c.lock)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; c.closed != 0 {&lt;br/&gt;  unlock(&amp;amp;c.lock)&lt;br/&gt;  panic(plainError(&lt;span&gt;&quot;close of closed channel&quot;&lt;/span&gt;))&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; c.closed = 1&lt;br/&gt; ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基本检查和关闭标志设置，保证 channel 不为 nil 和未关闭，保证边界。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;释放接收方&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在完成了异常边界判断和标志设置后，会将接受者的 sudog 等待队列（recvq）加入到待清除队列 glist 中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func closechan(c *hchan) {&lt;br/&gt;&lt;br/&gt; var glist gList&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;  sg := c.recvq.dequeue()&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; sg == nil {&lt;br/&gt;   &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; sg.elem != nil {&lt;br/&gt;   typedmemclr(c.elemtype, sg.elem)&lt;br/&gt;   sg.elem = nil&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; sg.releasetime != 0 {&lt;br/&gt;   sg.releasetime = cputicks()&lt;br/&gt;  }&lt;br/&gt;  gp := sg.g&lt;br/&gt;  gp.param = nil&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; raceenabled {&lt;br/&gt;   raceacquireg(gp, c.raceaddr())&lt;br/&gt;  }&lt;br/&gt;  glist.push(gp)&lt;br/&gt; }&lt;br/&gt; ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所取出并加入的 goroutine 状态需要均为 &lt;code&gt;_Gwaiting&lt;/code&gt;，以保证后续的新一轮调度。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;释放发送方&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样，与释放接收方一样。会将发送方也加入到到待清除队列 glist 中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func closechan(c *hchan) {&lt;br/&gt;&lt;br/&gt; // release all writers (they will panic)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;  sg := c.sendq.dequeue()&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; sg == nil {&lt;br/&gt;   &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  sg.elem = nil&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; sg.releasetime != 0 {&lt;br/&gt;   sg.releasetime = cputicks()&lt;br/&gt;  }&lt;br/&gt;  gp := sg.g&lt;br/&gt;  gp.param = nil&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; raceenabled {&lt;br/&gt;   raceacquireg(gp, c.raceaddr())&lt;br/&gt;  }&lt;br/&gt;  glist.push(gp)&lt;br/&gt; }&lt;br/&gt; unlock(&amp;amp;c.lock)&lt;br/&gt; ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;协程调度&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将所有 glist 中的 goroutine 状态从 &lt;code&gt;_Gwaiting&lt;/code&gt; 设置为 &lt;code&gt;_Grunnable&lt;/code&gt; 状态，等待调度器的调度：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func closechan(c *hchan) {&lt;br/&gt;&lt;br/&gt; // Ready all Gs now that we&lt;span&gt;&#x27;ve dropped the channel lock.&lt;br/&gt; for !glist.empty() {&lt;br/&gt;  gp := glist.pop()&lt;br/&gt;  gp.schedlink = 0&lt;br/&gt;  goready(gp, 3)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后续所有的 goroutine 允许被重新调度后。若原本还在被动阻塞的发送方或接收方，将重获自由，后续该干嘛就去干嘛了，再跑回其所属的应用流程。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;channel send/recv 分析&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;send&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;send&lt;/code&gt; 方法承担向 channel 发送具体数据的功能：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func send(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; sg.elem != nil {&lt;br/&gt;  sendDirect(c.elemtype, sg, ep)&lt;br/&gt;  sg.elem = nil&lt;br/&gt; }&lt;br/&gt; gp := sg.g&lt;br/&gt; unlockf()&lt;br/&gt; gp.param = unsafe.Pointer(sg)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; sg.releasetime != 0 {&lt;br/&gt;  sg.releasetime = cputicks()&lt;br/&gt; }&lt;br/&gt; goready(gp, skip+1)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func sendDirect(t *_type, sg *sudog, src unsafe.Pointer) {&lt;br/&gt; dst := sg.elem&lt;br/&gt; typeBitsBulkBarrier(t, uintptr(dst), uintptr(src), t.size)&lt;br/&gt; memmove(dst, src, t.size)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;调用 &lt;code&gt;sendDirect&lt;/code&gt; 方法将待发送的数据直接拷贝到待接收变量的内存地址（执行栈）。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;例如：&lt;code&gt;msg := &amp;lt;-ch&lt;/code&gt; 语句，也就是将数据从 &lt;code&gt;ch&lt;/code&gt; 直接拷贝到了 &lt;code&gt;msg&lt;/code&gt; 的内存地址。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;调用 &lt;code&gt;sg.g&lt;/code&gt; 属性， 从 sudog 中获取等待接收数据的 goroutine，并传递后续唤醒所需的参数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用 &lt;code&gt;goready&lt;/code&gt; 方法唤醒需接收数据的 goroutine，期望从 &lt;code&gt;_Gwaiting&lt;/code&gt; 状态调度为 &lt;code&gt;_Grunnable&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;recv&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;recv&lt;/code&gt; 方法承担在 channel 中接收具体数据的功能：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func recv(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; c.dataqsiz == 0 {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; ep != nil {&lt;br/&gt;   recvDirect(c.elemtype, sg, ep)&lt;br/&gt;  }&lt;br/&gt; } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  qp := chanbuf(c, c.recvx)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; ep != nil {&lt;br/&gt;   typedmemmove(c.elemtype, ep, qp)&lt;br/&gt;  }&lt;br/&gt;  typedmemmove(c.elemtype, qp, sg.elem)&lt;br/&gt;  c.recvx++&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; c.recvx == c.dataqsiz {&lt;br/&gt;   c.recvx = 0&lt;br/&gt;  }&lt;br/&gt;  c.sendx = c.recvx // c.sendx = (c.sendx+1) % c.dataqsiz&lt;br/&gt; }&lt;br/&gt; sg.elem = nil&lt;br/&gt; gp := sg.g&lt;br/&gt; unlockf()&lt;br/&gt; gp.param = unsafe.Pointer(sg)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; sg.releasetime != 0 {&lt;br/&gt;  sg.releasetime = cputicks()&lt;br/&gt; }&lt;br/&gt; goready(gp, skip+1)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该方法在接受上分为两种情况，分别是直接接收和缓冲接收：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;直接接收（不存在缓冲区）：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;调用 &lt;code&gt;recvDirect&lt;/code&gt; 方法，其作用与 &lt;code&gt;sendDirect&lt;/code&gt; 方法相对，会直接从发送方的 goroutine 调用栈中将数据拷贝过来到接收方的 goroutine。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;缓冲接收（存在缓冲区）：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;调用 &lt;code&gt;chanbuf&lt;/code&gt; 方法，根据 &lt;code&gt;recvx&lt;/code&gt; 索引的位置读取缓冲区元素，并将其拷贝到接收方的内存地址。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;拷贝完毕后，对 &lt;code&gt;sendx&lt;/code&gt; 和 &lt;code&gt;recvx&lt;/code&gt; 索引位置进行调整。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后还是常规的 goroutine 调度动作，会调用 &lt;code&gt;goready&lt;/code&gt; 方法来唤醒当前所处理的 sudog 的对应 goroutine。那么在下一轮调度时，既然已经接收了数据，自然发送方也就会被唤醒。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本文中我们针对 Go 语言的 channel 进行了基本概念的分析和讲解，同时还针对 channel 的设计原理和四大操作（创建、发送、接收、关闭）进行了源码分析和图示分析。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初步看过一遍后，再翻看。不难发现，Go 的 channel 设计并不复杂，记住他的数据结构就是带缓存的环形队列，再加上对称的 sendq、recvq 等双向链表的辅助属性，就能勾画出 channel 的基本逻辑流转模型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在具体的数据传输上，都是围绕着 “边界上下限处理，上互斥锁，阻塞/非阻塞，缓冲/非缓冲，缓存出队列，拷贝数据，解互斥锁，协程调度” 在不断地流转处理。在基本逻辑上也是相对重合的，因为发送和接收，创建和关闭总是相对的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果更进一步深入探讨，还可以围绕着 CSP 模型、goroutine 调度等进一步的思考和理解。这一块会在后续的章节中再一步展开。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>66ba7554904aeb2d2a16b8ba3b02f8e6</guid>
<title>Kubernetes 存储原理解析</title>
<link>https://toutiao.io/k/mhbru1t</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.39791666666666664&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7YuFI2AsdNDW6wxUgkibfZJvpM5u0TgdZ5URv9doG9MiblqqqC19IbK5XVdcfXjxQ3IpEia3bqJMNhujQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面的章节中我们介绍了在 Kubernetes 中的持久化存储的使用，了解了 PV、PVC 以及 StorageClass 的使用方法，从本地存储到 Ceph 共享存储都有学习，到这里我们其实已经可以完成应用各种场景的数据持久化了，但是难免在实际的使用过程中会遇到各种各样的问题，要解决这些问题最好的方式就是来了解下 Kubernetes 中存储的实现原理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kubernetes 默认情况下就提供了主流的存储卷接入方案，我们可以执行命令 &lt;code&gt;kubectl explain pod.spec.volumes&lt;/code&gt; 查看到支持的各种存储卷，另外也提供了插件机制，允许其他类型的存储服务接入到 Kubernetes 系统中来，在 Kubernetes 中就对应 &lt;code&gt;In-Tree&lt;/code&gt; 和 &lt;code&gt;Out-Of-Tree&lt;/code&gt; 两种方式，&lt;code&gt;In-Tree&lt;/code&gt; 就是在 Kubernetes 源码内部实现的，和 Kubernetes 一起发布、管理的，但是更新迭代慢、灵活性比较差，&lt;code&gt;Out-Of-Tree&lt;/code&gt; 是独立于 Kubernetes 的，目前主要有 &lt;code&gt;CSI&lt;/code&gt; 和 &lt;code&gt;FlexVolume&lt;/code&gt; 两种机制，开发者可以根据自己的存储类型实现不同的存储插件接入到 Kubernetes 中去，其中 &lt;code&gt;CSI&lt;/code&gt; 是现在也是以后主流的方式，所以当然我们的重点也会是 &lt;code&gt;CSI&lt;/code&gt; 的使用介绍。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;NFS&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们这里为了演示方便，先使用相对简单的 NFS 这种存储资源，接下来我们在节点 &lt;code&gt;10.151.30.11&lt;/code&gt; 上来安装 NFS 服务，数据目录：&lt;code&gt;/data/k8s/&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关闭防火墙&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; systemctl stop firewalld.service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; systemctl &lt;span&gt;disable&lt;/span&gt; firewalld.service&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安装配置 nfs&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; yum -y install nfs-utils rpcbind&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;共享目录设置权限：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; mkdir -p /data/k8s/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; chmod 755 /data/k8s/&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置 nfs，nfs 的默认配置文件在 &lt;code&gt;/etc/exports&lt;/code&gt; 文件下，在该文件中添加下面的配置信息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; vi /etc/exports&lt;/span&gt;&lt;br/&gt;/data/k8s  *(rw,sync,no_root_squash)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置说明：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;/data/k8s：是共享的数据目录&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;*：表示任何人都有权限连接，当然也可以是一个网段，一个 IP，也可以是域名&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;rw：读写的权限&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;sync：表示文件同时写入硬盘和内存&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;no_root_squash：当登录 NFS 主机使用共享目录的使用者是 root 时，其权限将被转换成为匿名使用者，通常它的 UID 与 GID，都会变成 nobody 身份&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然 nfs 的配置还有很多，感兴趣的同学可以在网上去查找一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;启动服务 nfs 需要向 rpc 注册，rpc 一旦重启了，注册的文件都会丢失，向他注册的服务都需要重启
注意启动顺序，先启动 rpcbind&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; systemctl start rpcbind.service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; systemctl &lt;span&gt;enable&lt;/span&gt; rpcbind&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; systemctl status rpcbind&lt;/span&gt;&lt;br/&gt;● rpcbind.service - RPC bind service&lt;br/&gt;   Loaded: loaded (/usr/lib/systemd/system/rpcbind.service; disabled; vendor preset: enabled)&lt;br/&gt;   Active: active (running) since Tue 2018-07-10 20:57:29 CST; 1min 54s ago&lt;br/&gt;  Process: 17696 ExecStart=/sbin/rpcbind -w $RPCBIND_ARGS (code=exited, status=0/SUCCESS)&lt;br/&gt; Main PID: 17697 (rpcbind)&lt;br/&gt;    Tasks: 1&lt;br/&gt;   Memory: 1.1M&lt;br/&gt;   CGroup: /system.slice/rpcbind.service&lt;br/&gt;           └─17697 /sbin/rpcbind -w&lt;br/&gt;&lt;br/&gt;Jul 10 20:57:29 master systemd[1]: Starting RPC bind service...&lt;br/&gt;Jul 10 20:57:29 master systemd[1]: Started RPC bind service.&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到上面的 Started 证明启动成功了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后启动 nfs 服务：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; systemctl start nfs.service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; systemctl &lt;span&gt;enable&lt;/span&gt; nfs&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; systemctl status nfs&lt;/span&gt;&lt;br/&gt;● nfs-server.service - NFS server and services&lt;br/&gt;   Loaded: loaded (/usr/lib/systemd/system/nfs-server.service; enabled; vendor preset: disabled)&lt;br/&gt;  Drop-In: /run/systemd/generator/nfs-server.service.d&lt;br/&gt;           └─order-with-mounts.conf&lt;br/&gt;   Active: active (exited) since Tue 2018-07-10 21:35:37 CST; 14s ago&lt;br/&gt; Main PID: 32067 (code=exited, status=0/SUCCESS)&lt;br/&gt;   CGroup: /system.slice/nfs-server.service&lt;br/&gt;&lt;br/&gt;Jul 10 21:35:37 master systemd[1]: Starting NFS server and services...&lt;br/&gt;Jul 10 21:35:37 master systemd[1]: Started NFS server and services.&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样看到 Started 则证明 NFS Server 启动成功了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外我们还可以通过下面的命令确认下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; rpcinfo -p|grep nfs&lt;/span&gt;&lt;br/&gt;    100003    3   tcp   2049  nfs&lt;br/&gt;    100003    4   tcp   2049  nfs&lt;br/&gt;    100227    3   tcp   2049  nfs_acl&lt;br/&gt;    100003    3   udp   2049  nfs&lt;br/&gt;    100003    4   udp   2049  nfs&lt;br/&gt;    100227    3   udp   2049  nfs_acl&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看具体目录挂载权限：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; cat /var/lib/nfs/etab&lt;/span&gt;&lt;br/&gt;/data/k8s    *(rw,sync,wdelay,hide,nocrossmnt,secure,no_root_squash,no_all_squash,no_subtree_check,secure_locks,acl,no_pnfs,anonuid=65534,anongid=65534,sec=sys,secure,no_root_squash,no_all_squash)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里我们就把 nfs server 给安装成功了，然后就是前往节点安装 nfs 的客户端来验证，安装 nfs 当前也需要先关闭防火墙：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; systemctl stop firewalld.service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; systemctl &lt;span&gt;disable&lt;/span&gt; firewalld.service&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后安装 nfs&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; yum -y install nfs-utils rpcbind&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安装完成后，和上面的方法一样，先启动 rpc、然后启动 nfs：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; systemctl start rpcbind.service &lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; systemctl &lt;span&gt;enable&lt;/span&gt; rpcbind.service &lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; systemctl start nfs.service    &lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; systemctl &lt;span&gt;enable&lt;/span&gt; nfs.service&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;挂载数据目录 客户端启动完成后，我们在客户端来挂载下 nfs 测试下，首先检查下 nfs 是否有共享目录：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; showmount -e 10.151.30.11&lt;/span&gt;&lt;br/&gt;Export list for 10.151.30.11:&lt;br/&gt;/data/k8s *&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后我们在客户端上新建目录：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; mkdir -p /root/course/kubeadm/data&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将 nfs 共享目录挂载到上面的目录：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; mount -t nfs 10.151.30.11:/data/k8s /root/course/kubeadm/data&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;挂载成功后，在客户端上面的目录中新建一个文件，然后我们观察下 nfs 服务端的共享目录下面是否也会出现该文件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; touch /root/course/kubeadm/data/test.txt&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后在 nfs 服务端查看：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; ls -ls /data/k8s/&lt;/span&gt;&lt;br/&gt;total 4&lt;br/&gt;4 -rw-r--r--. 1 root root 4 Jul 10 21:50 test.txt&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果上面出现了 test.txt 的文件，那么证明我们的 nfs 挂载成功了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;存储架构&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面我们了解到了 PV、PVC、StorgeClass 的使用，但是他们是如何和我们的 Pod 关联起来使用的呢？这就需要从 Volume 的处理流程和原理说起了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下所示，我们创建了一个 nfs 类型的 PV 资源对象：（volume.yaml）&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;apiVersion:&lt;/span&gt; &lt;span&gt;v1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;kind:&lt;/span&gt; &lt;span&gt;PersistentVolume&lt;/span&gt;&lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;nfs-pv&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;storageClassName:&lt;/span&gt; &lt;span&gt;manual&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;capacity:&lt;/span&gt; &lt;br/&gt;    &lt;span&gt;storage:&lt;/span&gt; &lt;span&gt;1Gi&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;accessModes:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;ReadWriteOnce&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;persistentVolumeReclaimPolicy:&lt;/span&gt; &lt;span&gt;Retain&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;nfs:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;path:&lt;/span&gt; &lt;span&gt;/data/k8s&lt;/span&gt;  &lt;span&gt;# 指定nfs的挂载点&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;server:&lt;/span&gt; &lt;span&gt;10.151&lt;/span&gt;&lt;span&gt;.30&lt;/span&gt;&lt;span&gt;.11&lt;/span&gt;  &lt;span&gt;# 指定nfs服务地址&lt;/span&gt;&lt;br/&gt;&lt;span&gt;---&lt;/span&gt;&lt;br/&gt;&lt;span&gt;apiVersion:&lt;/span&gt; &lt;span&gt;v1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;kind:&lt;/span&gt; &lt;span&gt;PersistentVolumeClaim&lt;/span&gt;&lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;nfs-pvc&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;storageClassName:&lt;/span&gt; &lt;span&gt;manual&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;accessModes:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;ReadWriteOnce&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;resources:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;requests:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;storage:&lt;/span&gt; &lt;span&gt;1Gi&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道用户真正使用的是 PVC，而要使用 PVC 的前提就是必须要先和某个符合条件的 PV 进行一一绑定，比如存储容器、访问模式，以及 PV 和 PVC 的 storageClassName 字段必须一样，这样才能够进行绑定，当 PVC 和 PV 绑定成功后就可以直接使用这个 PVC 对象了：(pod.yaml)&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;apiVersion:&lt;/span&gt; &lt;span&gt;v1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;kind:&lt;/span&gt; &lt;span&gt;Pod&lt;/span&gt;&lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;test-volumes&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;volumes:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;nfs&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;persistentVolumeClaim:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;claimName:&lt;/span&gt; &lt;span&gt;nfs-pvc&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;containers:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;web&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;image:&lt;/span&gt; &lt;span&gt;nginx&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;ports:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;web&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;containerPort:&lt;/span&gt; &lt;span&gt;80&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;volumeMounts:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;nfs&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;subPath:&lt;/span&gt; &lt;span&gt;test-volumes&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;mountPath:&lt;/span&gt; &lt;span&gt;&quot;/usr/share/nginx/html&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接创建上面的资源对象即可：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; kubectl apply -f volume.yaml&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; kubectl apply -f pod.yaml&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们只是在 volumes 中指定了我们上面创建的 PVC 对象，当这个 Pod 被创建之后， kubelet 就会把这个 PVC 对应的这个 NFS 类型的 Volume（PV）挂载到这个 Pod 容器中的目录中去。前面我们也提到了这样的话对于普通用户来说完全就不用关心后面的具体存储在 NFS 还是 Ceph 或者其他了，只需要直接使用 PVC 就可以了，因为真正的存储是需要很多相关的专业知识的，这样就完全职责分离解耦了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;普通用户直接使用 PVC 没有问题，但是也会出现一个问题，那就是当普通用户创建一个 PVC 对象的时候，这个时候系统里面并没有合适的 PV 来和它进行绑定，因为 PV 大多数情况下是管理员给我们创建的，这个时候启动 Pod 肯定就会失败了，如果现在管理员如果去创建一个对应的 PV 的话，PVC 和 PV 当然就可以绑定了，然后 Pod 也会自动的启动成功，这是因为在 Kubernetes 中有一个专门处理持久化存储的控制器 Volume Controller，这个控制器下面有很多个控制循环，其中一个就是用于 PV 和 PVC 绑定的 PersistentVolumeController。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PersistentVolumeController 会不断地循环去查看每一个 PVC，是不是已经处于 Bound（已绑定）状态。如果不是，那它就会遍历所有的、可用的 PV，并尝试将其与未绑定的 PVC 进行绑定，这样，Kubernetes 就可以保证用户提交的每一个 PVC，只要有合适的 PV 出现，它就能够很快进入绑定状态。而所谓将一个 PV 与 PVC 进行&lt;code&gt;“绑定”&lt;/code&gt;，其实就是将这个 PV 对象的名字，填在了 PVC 对象的 &lt;code&gt;spec.volumeName&lt;/code&gt; 字段上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PV 和 PVC 绑定上了，那么又是如何将容器里面的数据进行持久化的呢，前面我们学习过 Docker 的 Volume 挂载，其实就是&lt;span&gt;将一个宿主机上的目录和一个容器里的目录绑定挂载在了一起&lt;/span&gt;，具有持久化功能当然就是指的宿主机上面的这个目录了，当容器被删除或者在其他节点上重建出来以后，这个目录里面的内容依然存在，所以一般情况下实现持久化是需要一个远程存储的，比如 NFS、Ceph 或者云厂商提供的磁盘等等。所以接下来需要做的就是持久化宿主机目录这个过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 Pod 被调度到一个节点上后，节点上的 kubelet 组件就会为这个 Pod 创建它的 Volume 目录，默认情况下 kubelet 为 Volume 创建的目录在 kubelet 工作目录下面：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/var/lib/kubelet/pods/&amp;lt;Pod的ID&amp;gt;/volumes/kubernetes.io~&amp;lt;Volume类型&amp;gt;/&amp;lt;Volume名字&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如上面我们创建的 Pod 对应的 Volume 目录完整路径为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/var/lib/kubelet/pods/d4fcdb11-baf7-43d9-8d7d-3ede24118e08/volumes/kubernetes.io~nfs/nfs-pv&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;要获取 Pod 的唯一标识 uid，可通过命令 &lt;code&gt;kubectl get pod pod名 -o jsonpath={.metadata.uid}&lt;/code&gt; 获取。&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后就需要根据我们的 Volume 类型来决定需要做什么操作了，比如上节课我们用的 Ceph RBD，那么 kubelet 就需要先将 Ceph 提供的 RBD 挂载到 Pod 所在的宿主机上面，这个阶段在 Kubernetes 中被称为 Attach 阶段。Attach 阶段完成后，为了能够使用这个块设备，kubelet 还要进行第二个操作，即：格式化这个块设备，然后将它挂载到宿主机指定的挂载点上。这个挂载点，也就是上面我们提到的 Volume 的宿主机的目录。将块设备格式化并挂载到 Volume 宿主机目录的操作，在 Kubernetes 中被称为 Mount 阶段。上节课我们使用 Ceph RBD 持久化的 Wordpress 的 MySQL 数据，我们可以查看对应的 Volume 信息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; kubectl get pods -o wide -l app=wordpress&lt;/span&gt;&lt;br/&gt;NAME                              READY   STATUS    RESTARTS   AGE   IP             NODE         NOMINATED NODE   READINESS GATES&lt;br/&gt;wordpress-5b886cf59b-dv2zt        1/1     Running   0          20d   10.244.1.158   ydzs-node1   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;&lt;br/&gt;wordpress-mysql-b9ddd6d4c-pjhbt   1/1     Running   0          20d   10.244.4.70    ydzs-node4   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以看到 MySQL 运行在 node4 节点上，然后可以在该节点上查看 Volume 信息，Pod 对应的 uid 可以通过如下命令获取：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; kubectl get pod wordpress-mysql-b9ddd6d4c-pjhbt -o jsonpath={.metadata.uid}&lt;/span&gt;&lt;br/&gt;3f84af87-9f58-4c69-9e38-5ef234498133&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; ls /var/lib/kubelet/pods/3f84af87-9f58-4c69-9e38-5ef234498133/volumes/kubernetes.io~csi/pvc-c8861c23-c03d-47aa-96f6-73c4d4093109/&lt;/span&gt;&lt;br/&gt;mount  vol_data.json&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后通过如下命令可以查看 Volume 的持久化信息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; findmnt /var/lib/kubelet/pods/3f84af87-9f58-4c69-9e38-5ef234498133/volumes/kubernetes.io~csi/pvc-c8861c23-c03d-47aa-96f6-73c4d4093109/mount&lt;/span&gt;&lt;br/&gt;TARGET                                                                                            SOURCE    FSTYPE OPTIONS&lt;br/&gt;/var/lib/kubelet/pods/3f84af87-9f58-4c69-9e38-5ef234498133/volumes/kubernetes.io~csi/pvc-c8861c23-c03d-47aa-96f6-73c4d4093109/mount    /dev/rbd0 ext4   rw,relatime,&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到这里的 Volume 是挂载到 &lt;code&gt;/dev/rbd0&lt;/code&gt; 这个设备上面的，通过 &lt;code&gt;df&lt;/code&gt; 命令也是可以看到的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; df -h |grep dev&lt;/span&gt;&lt;br/&gt;devtmpfs        3.9G     0  3.9G   0% /dev&lt;br/&gt;tmpfs           3.9G     0  3.9G   0% /dev/shm&lt;br/&gt;/dev/vda3        18G  4.7G   13G  27% /&lt;br/&gt;/dev/vda1       497M  158M  340M  32% /boot&lt;br/&gt;/dev/vdb1       197G   24G  164G  13% /data&lt;br/&gt;/dev/rbd0        20G  160M   20G   1% /var/lib/kubelet/pods/3f84af87-9f58-4c69-9e38-5ef234498133/volumes/kubernetes.io~csi/pvc-c8861c23-c03d-47aa-96f6-73c4d4093109/mount&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们就经过了 &lt;code&gt;Attach&lt;/code&gt; 和 &lt;code&gt;Mount&lt;/code&gt; 两个阶段完成了 Volume 的持久化。但是对于上面我们使用的 NFS 就更加简单了， 因为 NFS 存储并没有一个设备需要挂载到宿主机上面，所以这个时候 kubelet 就会直接进入第二个 &lt;code&gt;Mount&lt;/code&gt; 阶段，相当于直接在宿主机上面执行如下的命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; mount -t nfs 10.151.30.11:/data/k8s /var/lib/kubelet/pods/d4fcdb11-baf7-43d9-8d7d-3ede24118e08/volumes/kubernetes.io~nfs/nfs-pv&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样可以在测试的 Pod 所在节点查看 Volume 的挂载信息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; findmnt /var/lib/kubelet/pods/d4fcdb11-baf7-43d9-8d7d-3ede24118e08/volumes/kubernetes.io~nfs/nfs-pv&lt;/span&gt;&lt;br/&gt;TARGET                                                                               SOURCE                 FSTYPE OPTIONS&lt;br/&gt;/var/lib/kubelet/pods/d4fcdb11-baf7-43d9-8d7d-3ede24118e08/volumes/kubernetes.io~nfs/nfs-pv&lt;br/&gt;                                                                                     10.151.30.11:/data/k8s nfs4   rw,relatime,&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以看到这个 Volume 被挂载到了 NFS（10.151.30.11:/data/k8s）下面，以后我们在这个目录里写入的所有文件，都会被保存在远程 NFS 服务器上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样在经过了上面的两个阶段过后，我们就得到了一个持久化的宿主机上面的 Volume 目录了，接下来 kubelet 只需要把这个 Volume 目录挂载到容器中对应的目录即可，这样就可以为 Pod 里的容器挂载这个持久化的 Volume 了，这一步其实也就相当于执行了如下所示的命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; docker run -v /var/lib/kubelet/pods/&amp;lt;Pod的ID&amp;gt;/volumes/kubernetes.io~&amp;lt;Volume类型&amp;gt;/&amp;lt;Volume名字&amp;gt;:/&amp;lt;容器内的目标目录&amp;gt; 我的镜像 ...&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整个存储的架构可以用下图来说明：&lt;img data-ratio=&quot;0.35714285714285715&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7YuFI2AsdNDW6wxUgkibfZJvpprxD07bvQDGMsXgCT50nYBMCTJOntXN7r4UL3FL3oa3zabSq6Xa1Bw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1260&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;PV Controller：负责 PV/PVC 的绑定，并根据需求进行数据卷的 Provision/Delete 操作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;AD Controller：负责存储设备的 Attach/Detach 操作，将设备挂载到目标节点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Volume Manager：管理卷的 Mount/Unmount 操作、卷设备的格式化等操作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Volume Plugin：扩展各种存储类型的卷管理能力，实现第三方存储的各种操作能力和 Kubernetes 存储系统结合&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们上面使用的 NFS 就属于 In-Tree 这种方式，而上节课使用的 Ceph RBD 就是 Out-Of-Tree 的方式，而且是使用的是 CSI 插件。下面我们再来了解下 &lt;code&gt;FlexVolume&lt;/code&gt; 和 &lt;code&gt;CSI&lt;/code&gt; 两种插件方式。&lt;mpcpc js_editor_cpcad=&quot;&quot; class=&quot;js_cpc_area cpc_iframe&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/cpc_tmpl#1610278363109&quot; data-category_id_list=&quot;1|11|16|17|22|24|26|27|28|29|3|31|32|35|36|37|39|41|42|43|45|46|47|48|49|5|50|51|52|53|54|55|6|7|8&quot; data-id=&quot;1610278363109&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;FlexVolume&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;FlexVolume 提供了一种扩展 Kubernetes 存储插件的方式，用户可以自定义自己的存储插件。要使用 FlexVolume 需要在每个节点上安装存储插件二进制文件，该二进制需要实现 FlexVolume 的相关接口，默认存储插件的存放路径为&lt;code&gt;/usr/libexec/kubernetes/kubelet-plugins/volume/exec/&amp;lt;vendor~driver&amp;gt;/&amp;lt;driver&amp;gt;&lt;/code&gt;，&lt;code&gt;VolumePlugins&lt;/code&gt; 组件会不断 watch 这个目录来实现插件的添加、删除等功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中 &lt;code&gt;vendor~driver&lt;/code&gt; 的名字需要和 Pod 中&lt;code&gt;flexVolume.driver&lt;/code&gt; 的字段名字匹配，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/usr/libexec/kubernetes/kubelet-plugins/volume/&lt;span&gt;exec&lt;/span&gt;/foo~cifs/cifs&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对应的 Pod 中的 &lt;code&gt;flexVolume.driver&lt;/code&gt; 属性为：&lt;code&gt;foo/cifs&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们实现自定义存储插件的时候，需要实现 FlexVolume 的部分接口，因为要看实际需求，并不一定所有接口都需要实现。比如对于类似于 NFS 这样的存储就没必要实现 &lt;code&gt;attach/detach&lt;/code&gt; 这些接口了，因为不需要，只需要实现 &lt;code&gt;init/mount/umount&lt;/code&gt; 3个接口即可。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;init: &lt;code&gt;&amp;lt;driver executable&amp;gt; init&lt;/code&gt; - kubelet/kube-controller-manager 初始化存储插件时调用，插件需要返回是否需要要 attach 和 detach 操作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;attach: &lt;code&gt;&amp;lt;driver executable&amp;gt; attach &amp;lt;json options&amp;gt; &amp;lt;node name&amp;gt;&lt;/code&gt; - 将存储卷挂载到 Node 节点上&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;detach: &lt;code&gt;&amp;lt;driver executable&amp;gt; detach &amp;lt;mount device&amp;gt; &amp;lt;node name&amp;gt;&lt;/code&gt; - 将存储卷从 Node 上卸载&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;waitforattach: &lt;code&gt;&amp;lt;driver executable&amp;gt; waitforattach &amp;lt;mount device&amp;gt; &amp;lt;json options&amp;gt;&lt;/code&gt; - 等待 attach 操作成功（超时时间为 10 分钟）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;isattached: &lt;code&gt;&amp;lt;driver executable&amp;gt; isattached &amp;lt;json options&amp;gt; &amp;lt;node name&amp;gt;&lt;/code&gt; - 检查存储卷是否已经挂载&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;mountdevice: &lt;code&gt;&amp;lt;driver executable&amp;gt; mountdevice &amp;lt;mount dir&amp;gt; &amp;lt;mount device&amp;gt; &amp;lt;json options&amp;gt;&lt;/code&gt; - 将设备挂载到指定目录中以便后续 bind mount 使用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;unmountdevice: &lt;code&gt;&amp;lt;driver executable&amp;gt; unmountdevice &amp;lt;mount device&amp;gt;&lt;/code&gt; - 将设备取消挂载&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;mount: &lt;code&gt;&amp;lt;driver executable&amp;gt; mount &amp;lt;mount dir&amp;gt; &amp;lt;json options&amp;gt;&lt;/code&gt; - 将存储卷挂载到指定目录中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;unmount: &lt;code&gt;&amp;lt;driver executable&amp;gt; unmount &amp;lt;mount dir&amp;gt;&lt;/code&gt; - 将存储卷取消挂载&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现上面的这些接口需要返回如下所示的 JSON 格式的数据：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;{&lt;br/&gt;    &lt;span&gt;&quot;status&quot;&lt;/span&gt;: &lt;span&gt;&quot;&amp;lt;Success/Failure/Not supported&amp;gt;&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;message&quot;&lt;/span&gt;: &lt;span&gt;&quot;&amp;lt;Reason for success/failure&amp;gt;&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;device&quot;&lt;/span&gt;: &lt;span&gt;&quot;&amp;lt;Path to the device attached. This field is valid only for attach &amp;amp; waitforattach call-outs&amp;gt;&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;volumeName&quot;&lt;/span&gt;: &lt;span&gt;&quot;&amp;lt;Cluster wide unique name of the volume. Valid only for getvolumename call-out&amp;gt;&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;attached&quot;&lt;/span&gt;: &amp;lt;True/False (Return &lt;span&gt;true&lt;/span&gt; if volume is attached on the node. Valid only for isattached call-out)&amp;gt;&lt;br/&gt;    &lt;span&gt;&quot;capabilities&quot;&lt;/span&gt;: &amp;lt;Only included as part of the Init response&amp;gt;&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;&quot;attach&quot;&lt;/span&gt;: &amp;lt;True/False (Return &lt;span&gt;true&lt;/span&gt; if the driver implements attach and detach)&amp;gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我们来实现一个 NFS 的 FlexVolume 插件，最简单的方式就是写一个脚本，然后实现 init、mount、unmount 3个命令即可，然后按照上面的 JSON 格式返回数据，最后把这个脚本放在节点的 FlexVolume 插件目录下面即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面就是官方给出的一个 NFS 的 FlexVolume 插件示例，可以从 https://github.com/kubernetes/examples/blob/master/staging/volumes/flexvolume/nfs 获取脚本：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/bin/bash&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 注意:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;  - 在使用插件之前需要先安装 jq。&lt;/span&gt;&lt;br/&gt;usage() {&lt;br/&gt; err &quot;Invalid usage. Usage: &quot;&lt;br/&gt; err &quot;\t$0 init&quot;&lt;br/&gt; err &quot;\t$0 mount &amp;lt;mount dir&amp;gt; &amp;lt;json params&amp;gt;&quot;&lt;br/&gt; err &quot;\t$0 unmount &amp;lt;mount dir&amp;gt;&quot;&lt;br/&gt; exit 1&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;err() {&lt;br/&gt; echo -ne $* 1&amp;gt;&amp;amp;2&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;log() {&lt;br/&gt; echo -ne $* &amp;gt;&amp;amp;1&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;ismounted() {&lt;br/&gt; MOUNT=`findmnt -n ${MNTPATH} 2&amp;gt;/dev/null | cut -d&#x27; &#x27; -f1`&lt;br/&gt; if [ &quot;${MOUNT}&quot; == &quot;${MNTPATH}&quot; ]; then&lt;br/&gt;  echo &quot;1&quot;&lt;br/&gt; else&lt;br/&gt;  echo &quot;0&quot;&lt;br/&gt; fi&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;domount() {&lt;br/&gt; MNTPATH=$1&lt;br/&gt;&lt;br/&gt; NFS_SERVER=$(echo $2 | jq -r &#x27;.server&#x27;)&lt;br/&gt; SHARE=$(echo $2 | jq -r &#x27;.share&#x27;)&lt;br/&gt;&lt;br/&gt; if [ $(ismounted) -eq 1 ] ; then&lt;br/&gt;  log &#x27;{&quot;status&quot;: &quot;Success&quot;}&#x27;&lt;br/&gt;  exit 0&lt;br/&gt; fi&lt;br/&gt;&lt;br/&gt; mkdir -p ${MNTPATH} &amp;amp;&amp;gt; /dev/null&lt;br/&gt;&lt;br/&gt; mount -t nfs ${NFS_SERVER}:/${SHARE} ${MNTPATH} &amp;amp;&amp;gt; /dev/null&lt;br/&gt; if [ $? -ne 0 ]; then&lt;br/&gt;  err &quot;{ \&quot;status\&quot;: \&quot;Failure\&quot;, \&quot;message\&quot;: \&quot;Failed to mount ${NFS_SERVER}:${SHARE} at ${MNTPATH}\&quot;}&quot;&lt;br/&gt;  exit 1&lt;br/&gt; fi&lt;br/&gt; log &#x27;{&quot;status&quot;: &quot;Success&quot;}&#x27;&lt;br/&gt; exit 0&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;unmount() {&lt;br/&gt; MNTPATH=$1&lt;br/&gt; if [ $(ismounted) -eq 0 ] ; then&lt;br/&gt;  log &#x27;{&quot;status&quot;: &quot;Success&quot;}&#x27;&lt;br/&gt;  exit 0&lt;br/&gt; fi&lt;br/&gt;&lt;br/&gt; umount ${MNTPATH} &amp;amp;&amp;gt; /dev/null&lt;br/&gt; if [ $? -ne 0 ]; then&lt;br/&gt;  err &quot;{ \&quot;status\&quot;: \&quot;Failed\&quot;, \&quot;message\&quot;: \&quot;Failed to unmount volume at ${MNTPATH}\&quot;}&quot;&lt;br/&gt;  exit 1&lt;br/&gt; fi&lt;br/&gt;&lt;br/&gt; log &#x27;{&quot;status&quot;: &quot;Success&quot;}&#x27;&lt;br/&gt; exit 0&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;op=$1&lt;br/&gt;&lt;br/&gt;if ! command -v jq &amp;gt;/dev/null 2&amp;gt;&amp;amp;1; then&lt;br/&gt; err &quot;{ \&quot;status\&quot;: \&quot;Failure\&quot;, \&quot;message\&quot;: \&quot;&#x27;jq&#x27; binary not found. Please install jq package before using this driver\&quot;}&quot;&lt;br/&gt; exit 1&lt;br/&gt;fi&lt;br/&gt;&lt;br/&gt;if [ &quot;$op&quot; = &quot;init&quot; ]; then&lt;br/&gt; log &#x27;{&quot;status&quot;: &quot;Success&quot;, &quot;capabilities&quot;: {&quot;attach&quot;: false}}&#x27;&lt;br/&gt; exit 0&lt;br/&gt;fi&lt;br/&gt;&lt;br/&gt;if [ $# -lt 2 ]; then&lt;br/&gt; usage&lt;br/&gt;fi&lt;br/&gt;&lt;br/&gt;shift&lt;br/&gt;&lt;br/&gt;case &quot;$op&quot; in&lt;br/&gt; mount)&lt;br/&gt;  domount $*&lt;br/&gt;  ;;&lt;br/&gt; unmount)&lt;br/&gt;  unmount $*&lt;br/&gt;  ;;&lt;br/&gt; *)&lt;br/&gt;  log &#x27;{&quot;status&quot;: &quot;Not supported&quot;}&#x27;&lt;br/&gt;  exit 0&lt;br/&gt;esac&lt;br/&gt;&lt;br/&gt;exit 1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将上面脚本命名成 nfs，放置到 node1 节点对应的插件下面：&lt;code&gt;/usr/libexec/kubernetes/kubelet-plugins/volume/exec/ydzs~nfs/nfs&lt;/code&gt;，并设置权限为 700：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; chmod 700 /usr/libexec/kubernetes/kubelet-plugins/volume/&lt;span&gt;exec&lt;/span&gt;/ydzs~nfs/nfs&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 安装 jq 工具&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; yum -y install https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; yum install jq -y&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个时候我们部署一个应用到 node1 节点上，并用 &lt;code&gt;flexVolume&lt;/code&gt; 来持久化容器中的数据（当然也可以通过定义 flexvolume 类型的 PV、PVC 来使用），如下所示：(test-flexvolume.yaml)&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;apiVersion:&lt;/span&gt; &lt;span&gt;v1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;kind:&lt;/span&gt; &lt;span&gt;Pod&lt;/span&gt;&lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;test-flexvolume&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;nodeSelector:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;kubernetes.io/hostname:&lt;/span&gt; &lt;span&gt;ydzs-node1&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;volumes:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;flexVolume:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;driver:&lt;/span&gt; &lt;span&gt;&quot;ydzs/nfs&quot;&lt;/span&gt;  &lt;span&gt;# 定义插件类型，根据这个参数在对应的目录下面找到插件的可执行文件&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;fsType:&lt;/span&gt; &lt;span&gt;&quot;nfs&quot;&lt;/span&gt;  &lt;span&gt;# 定义存储卷文件系统类型&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;options:&lt;/span&gt;  &lt;span&gt;# 定义所有与存储相关的一些具体参数&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;server:&lt;/span&gt; &lt;span&gt;&quot;10.151.30.11&quot;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;share:&lt;/span&gt; &lt;span&gt;&quot;data/k8s&quot;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;containers:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;web&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;image:&lt;/span&gt; &lt;span&gt;nginx&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;ports:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;containerPort:&lt;/span&gt; &lt;span&gt;80&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;volumeMounts:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;subPath:&lt;/span&gt; &lt;span&gt;testflexvolume&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;mountPath:&lt;/span&gt; &lt;span&gt;/usr/share/nginx/html&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中 &lt;code&gt;flexVolume.driver&lt;/code&gt; 就是插件目录 &lt;code&gt;ydzs~nfs&lt;/code&gt; 对应的 &lt;code&gt;ydzs/nfs&lt;/code&gt; 名称，&lt;code&gt;flexVolume.options&lt;/code&gt; 中根据上面的 nfs 脚本可以得知里面配置的是 NFS 的 Server 地址和挂载目录路径，直接创建上面的资源对象：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; kubectl apply -f &lt;span&gt;test&lt;/span&gt;-flexvolume.yaml&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; kubectl get pods &lt;/span&gt;&lt;br/&gt;NAME                                      READY   STATUS    RESTARTS   AGE&lt;br/&gt;test-flexvolume                           1/1     Running   0          13h&lt;br/&gt;......&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; kubectl &lt;span&gt;exec&lt;/span&gt; -it &lt;span&gt;test&lt;/span&gt;-flexvolume mount |grep &lt;span&gt;test&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;10.151.30.11:/data/k8s/testflexvolume on /usr/share/nginx/html type nfs4 (rw,relatime,vers=4.1,rsize=524288,wsize=524288,namlen=255,hard,proto=tcp,timeo=600,retrans=2,sec=sys,clientaddr=10.151.30.22,local_lock=none,addr=10.151.30.11)&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; mount |grep &lt;span&gt;test&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;10.151.30.11:/data/k8s on /var/lib/kubelet/pods/a376832a-7638-4faf-b1a0-404956e8e60a/volumes/ydzs~nfs/test type nfs4 (rw,relatime,vers=4.1,rsize=524288,wsize=524288,namlen=255,hard,proto=tcp,timeo=600,retrans=2,sec=sys,clientaddr=10.151.30.22,local_lock=none,addr=10.151.30.11)&lt;br/&gt;10.151.30.11:/data/k8s/testflexvolume on /var/lib/kubelet/pods/a376832a-7638-4faf-b1a0-404956e8e60a/volume-subpaths/test/web/0 type nfs4 (rw,relatime,vers=4.1,rsize=524288,wsize=524288,namlen=255,hard,proto=tcp,timeo=600,retrans=2,sec=sys,clientaddr=10.151.30.22,local_lock=none,addr=10.151.30.11)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样我们可以查看到 Pod 的本地持久化目录是被 mount 到了 NFS 上面，证明上面我们的 FlexVolume 插件是正常的。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;当我们要去真正的 mount NFS 的时候，就是通过 kubelet 调用 VolumePlugin，然后直接执行命令&lt;code&gt;/usr/libexec/kubernetes/kubelet-plugins/volume/exec/ydzs~nfs/nfs mount &amp;lt;mount dir&amp;gt; &amp;lt;json param&amp;gt;&lt;/code&gt; 来完成的，就相当于平时我们在宿主机上面手动挂载 NFS 的方式一样的，所以存储插件 nfs 是一个可执行的二进制文件或者 shell 脚本都是可以的。&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;CSI&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然已经有了 FlexVolume 插件了，为什么还需要 CSI 插件呢？上面我们使用 FlexVolume 插件的时候可以看出 FlexVolume 插件实际上相当于就是一个普通的 shell 命令，类似于平时我们在 Linux 下面执行的 &lt;code&gt;ls&lt;/code&gt; 命令一样，只是返回的信息是 JSON 格式的数据，并不是我们通常认为的一个常驻内存的进程，而 CSI 是一个更加完善、编码更加方便友好的一种存储插件扩展方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CSI 是由来自 Kubernetes、Mesos、 Cloud Foundry 等社区成员联合制定的一个行业标准接口规范，旨在将任意存储系统暴露给容器化应用程序。CSI 规范定义了存储提供商实现 CSI 兼容插件的最小操作集合和部署建议，CSI 规范的主要焦点是声明插件必须实现的接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Kubernetes 上整合 CSI 插件的整体架构如下图所示：&lt;img data-ratio=&quot;0.5627777777777778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7YuFI2AsdNDW6wxUgkibfZJvpI8qM9rZSm3ucpjzibP9H8D8DJGhlvccUAJpWgpY7iayUVRTiczSltWb5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1800&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kubernetes CSI 存储体系主要由两部分组成：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Kubernetes 外部组件：包含 Driver registrar、External provisioner、External attacher 三部分，这三个组件是从 Kubernetes 原本的 in-tree 存储体系中剥离出来的存储管理功能，实际上是 Kubernetes 中的一种外部 controller ，它们 watch kubernetes 的 API 资源对象，根据 watch 到的状态来调用下面提到的第二部分的 CSI 插件来实现存储的管理和操作。这部分是 Kubernetes 团队维护的，插件开发者完全不必关心其实现细节。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Driver registra：用于将插件注册到 kubelet 的 sidecar 容器，并将驱动程序自定义的 NodeId 添加到节点的 Annotations 上，通过与 CSI 上面的 Identity 服务进行通信调用 CSI 的 GetNodeId 方法来完成该操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;External provisioner：用于 watch Kubernetes 的 PVC 对象并调用 CSI 的 CreateVolume 和 DeleteVolume 操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;External attacher：用于 Attach/Detach 阶段，通过 watch Kubernetes 的 VolumeAttachment 对象并调用 CSI 的 ControllerPublish 和 ControllerUnpublish 操作来完成对应的 Volume 的 Attach/Detach。而 Volume 的 Mount/Unmount 阶段并不属于外部组件，当真正需要执行 Mount 操作的时候，kubelet 会去直接调用下面的 CSI Node 服务来完成 Volume 的 Mount/UnMount 操作。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;CSI 存储插件: 这部分正是开发者需要实现的 CSI 插件部分，都是通过 gRPC 实现的服务，一般会用一个二进制文件对外提供服务，主要包含三部分：CSI Identity、CSI Controller、CSI Node。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;CSI Identity — 主要用于负责对外暴露这个插件本身的信息，确保插件的健康状态。&lt;pre&gt;&lt;span/&gt;&lt;code&gt;service Identity {&lt;br/&gt;    &lt;span&gt;// 返回插件的名称和版本&lt;/span&gt;&lt;br/&gt;    rpc GetPluginInfo(GetPluginInfoRequest)&lt;br/&gt;        returns (GetPluginInfoResponse) {}&lt;br/&gt;    &lt;span&gt;// 返回这个插件的包含的功能，比如非块存储类型的 CSI 插件不需要实现 Attach 功能，GetPluginCapabilities 就可以在返回中标注这个 CSI 插件不包含 Attach 功能&lt;/span&gt;&lt;br/&gt;    rpc GetPluginCapabilities(GetPluginCapabilitiesRequest)&lt;br/&gt;        returns (GetPluginCapabilitiesResponse) {}&lt;br/&gt;    &lt;span&gt;// 插件插件是否正在运行&lt;/span&gt;&lt;br/&gt;    rpc Probe (ProbeRequest)&lt;br/&gt;        returns (ProbeResponse) {}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CSI Controller - 主要实现 Volume 管理流程当中的 Provision 和 Attach 阶段，Provision 阶段是指创建和删除 Volume 的流程，而 Attach 阶段是指把存储卷附着在某个节点或脱离某个节点的流程，另外只有块存储类型的 CSI 插件才需要  Attach 功能。&lt;pre&gt;&lt;span/&gt;&lt;code&gt;service Controller {&lt;br/&gt;    &lt;span&gt;// 创建存储卷，包括云端存储介质以及PV对象&lt;/span&gt;&lt;br/&gt;    rpc CreateVolume (CreateVolumeRequest)&lt;br/&gt;        returns (CreateVolumeResponse) {}&lt;br/&gt;        &lt;br/&gt;    &lt;span&gt;//  删除存储卷&lt;/span&gt;&lt;br/&gt;    rpc DeleteVolume (DeleteVolumeRequest)&lt;br/&gt;        returns (DeleteVolumeResponse) {}&lt;br/&gt;        &lt;br/&gt;    &lt;span&gt;// 挂载存储卷，将存储介质挂载到目标节点&lt;/span&gt;&lt;br/&gt;    rpc ControllerPublishVolume (ControllerPublishVolumeRequest)&lt;br/&gt;        returns (ControllerPublishVolumeResponse) {}&lt;br/&gt;        &lt;br/&gt;    &lt;span&gt;// 卸载存储卷&lt;/span&gt;&lt;br/&gt;    rpc ControllerUnpublishVolume (ControllerUnpublishVolumeRequest)&lt;br/&gt;        returns (ControllerUnpublishVolumeResponse) {}&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 例如：是否可以同时用于多个节点的读/写&lt;/span&gt;&lt;br/&gt;    rpc ValidateVolumeCapabilities (ValidateVolumeCapabilitiesRequest)&lt;br/&gt;        returns (ValidateVolumeCapabilitiesResponse) {}&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 返回所有可用的 volumes&lt;/span&gt;&lt;br/&gt;    rpc ListVolumes (ListVolumesRequest)&lt;br/&gt;        returns (ListVolumesResponse) {}&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 可用存储池的总容量&lt;/span&gt;&lt;br/&gt;    rpc GetCapacity (GetCapacityRequest)&lt;br/&gt;        returns (GetCapacityResponse) {}&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 例如. 插件可能未实现 GetCapacity、Snapshotting&lt;/span&gt;&lt;br/&gt;    rpc ControllerGetCapabilities (ControllerGetCapabilitiesRequest)&lt;br/&gt;        returns (ControllerGetCapabilitiesResponse) {}&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 创建快照&lt;/span&gt;&lt;br/&gt;    rpc CreateSnapshot (CreateSnapshotRequest)&lt;br/&gt;        returns (CreateSnapshotResponse) {}&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 删除指定的快照&lt;/span&gt;&lt;br/&gt;    rpc DeleteSnapshot (DeleteSnapshotRequest)&lt;br/&gt;        returns (DeleteSnapshotResponse) {}&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取所有的快照&lt;/span&gt;&lt;br/&gt;    rpc ListSnapshots (ListSnapshotsRequest)&lt;br/&gt;        returns (ListSnapshotsResponse) {}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CSI Node — 负责控制 Kubernetes 节点上的 Volume 操作。其中 Volume 的挂载被分成了 NodeStageVolume 和 NodePublishVolume 两个阶段。NodeStageVolume 接口主要是针对块存储类型的 CSI 插件而提供的，块设备在 &quot;Attach&quot; 阶段被附着在 Node 上后，需要挂载至 Pod 对应目录上，但因为块设备在 linux 上只能 mount 一次，而在 kubernetes volume 的使用场景中，一个 volume 可能被挂载进同一个 Node 上的多个 Pod 实例中，所以这里提供了 NodeStageVolume 这个接口，使用这个接口把块设备格式化后先挂载至 Node 上的一个临时全局目录，然后再调用 NodePublishVolume 使用 linux 中的 &lt;code&gt;bind mount&lt;/code&gt; 技术把这个全局目录挂载进 Pod 中对应的目录上。&lt;pre&gt;&lt;span/&gt;&lt;code&gt;service Node {&lt;br/&gt;    &lt;span&gt;// 在节点上初始化存储卷（格式化），并执行挂载到Global目录&lt;/span&gt;&lt;br/&gt;    rpc NodeStageVolume (NodeStageVolumeRequest)&lt;br/&gt;        returns (NodeStageVolumeResponse) {}&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// umount 存储卷在节点上的 Global 目录&lt;/span&gt;&lt;br/&gt;    rpc NodeUnstageVolume (NodeUnstageVolumeRequest)&lt;br/&gt;        returns (NodeUnstageVolumeResponse) {}&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 在节点上将存储卷的 Global 目录挂载到 Pod 的实际挂载目录&lt;/span&gt;&lt;br/&gt;    rpc NodePublishVolume (NodePublishVolumeRequest)&lt;br/&gt;        returns (NodePublishVolumeResponse) {}&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// unmount 存储卷在节点上的 Pod 挂载目录&lt;/span&gt;&lt;br/&gt;    rpc NodeUnpublishVolume (NodeUnpublishVolumeRequest)&lt;br/&gt;        returns (NodeUnpublishVolumeResponse) {}&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取节点上Volume挂载文件系统统计信息（总空间、可用空间等）&lt;/span&gt;&lt;br/&gt;    rpc NodeGetVolumeStats (NodeGetVolumeStatsRequest)&lt;br/&gt;        returns (NodeGetVolumeStatsResponse) {}&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取节点的唯一 ID&lt;/span&gt;&lt;br/&gt;    rpc NodeGetId (NodeGetIdRequest)&lt;br/&gt;        returns (NodeGetIdResponse) {&lt;br/&gt;        option deprecated = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 返回节点插件的能力&lt;/span&gt;&lt;br/&gt;    rpc NodeGetCapabilities (NodeGetCapabilitiesRequest)&lt;br/&gt;        returns (NodeGetCapabilitiesResponse) {}&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取节点的一些信息&lt;/span&gt;&lt;br/&gt;    rpc NodeGetInfo (NodeGetInfoRequest)&lt;br/&gt;        returns (NodeGetInfoResponse) {}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只需要实现上面的接口就可以实现一个 CSI 插件了。虽然 Kubernetes 并未规定 CSI 插件的打包安装，但是提供了以下建议来简化我们在 Kubernetes 上容器化 CSI Volume 驱动程序的部署方案，具体的方案介绍可以查看 CSI 规范介绍文档 https://github.com/kubernetes/community&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7YuFI2AsdNDW6wxUgkibfZJvpiaeF9GU8FVkm5icBtlsB0lALQITI7RLlRQxTCDice0DRYbYI0UKib5WQAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;960&quot;/&gt;&lt;figcaption&gt;container storage interface deploy&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照上图的推荐方案，CSI Controller 部分以 StatefulSet 或者 Deployment 方式部署，CSI Node 部分以 DaemonSet 方式部署。因为这两部分实现在同一个 CSI 插件程序中，因此只需要把这个 CSI 插件与 External Components 以容器方式部署在同一个 Pod中，把这个 CSI 插件与 Driver registrar 以容器方式部署在 DaemonSet 的 Pod 中，即可完成 CSI 的部署。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面我们使用的 Rook 部署的 Ceph 集群就是实现了 CSI 插件的:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; kubectl get pods -n rook-ceph |grep plugin&lt;/span&gt;&lt;br/&gt;csi-cephfsplugin-2s9d5                                 3/3     Running     0          21d&lt;br/&gt;csi-cephfsplugin-fgp4v                                 3/3     Running     0          17d&lt;br/&gt;csi-cephfsplugin-fv5nx                                 3/3     Running     0          21d&lt;br/&gt;csi-cephfsplugin-mn8q4                                 3/3     Running     0          17d&lt;br/&gt;csi-cephfsplugin-nf6h8                                 3/3     Running     0          21d&lt;br/&gt;csi-cephfsplugin-provisioner-56c8b7ddf4-68h6d          4/4     Running     0          21d&lt;br/&gt;csi-cephfsplugin-provisioner-56c8b7ddf4-rq4t6          4/4     Running     0          21d&lt;br/&gt;csi-cephfsplugin-xwnl4                                 3/3     Running     0          21d&lt;br/&gt;csi-rbdplugin-7r88w                                    3/3     Running     0          21d&lt;br/&gt;csi-rbdplugin-95g5j                                    3/3     Running     0          21d&lt;br/&gt;csi-rbdplugin-bnzpr                                    3/3     Running     0          21d&lt;br/&gt;csi-rbdplugin-dvftb                                    3/3     Running     0          21d&lt;br/&gt;csi-rbdplugin-jzmj2                                    3/3     Running     0          17d&lt;br/&gt;csi-rbdplugin-provisioner-6ff4dd4b94-bvtss             5/5     Running     0          21d&lt;br/&gt;csi-rbdplugin-provisioner-6ff4dd4b94-lfn68             5/5     Running     0          21d&lt;br/&gt;csi-rbdplugin-trxb4                                    3/3     Running     0          17d&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里其实是实现了 RBD 和 CephFS 两种 CSI，用 DaemonSet 在每个节点上运行了一个包含 &lt;code&gt;Driver registra&lt;/code&gt; 容器的 Pod，当然和节点相关的操作比如 Mount/Unmount 也是在这个 Pod 里面执行的，其他的比如 Provision、Attach 都是在另外的 &lt;code&gt;csi-rbdplugin-provisioner-xxx&lt;/code&gt; Pod 中执行的。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>