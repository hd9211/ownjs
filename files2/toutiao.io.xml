<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>dd6ad9c195f5cdb1bf78b6cc356af4ed</guid>
<title>线程池最佳线程数量到底要如何配置？</title>
<link>https://toutiao.io/k/pf728mr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一、前言&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;对于从事后端开发的同学来说，线程是必须要使用了，因为使用它可以提升系统的性能。但是，创建线程和销毁线程都是比较耗时的操作，频繁的创建和销毁线程会浪费很多CPU的资源。此外，如果每个任务都创建一个线程去处理，这样线程会越来越多。我们知道每个线程默认情况下占1M的内存空间，如果线程非常多，内存资源将会被耗尽。这时，我们需要线程池去管理线程，不会出现内存资源被耗尽的情况，也不会出现频繁创建和销毁线程的情况，因为它内部是可以复用线程的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;二、从实战开始&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;在介绍线程池之前，让我们先看个例子。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;MyCallable&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Callable&lt;/span&gt;&amp;lt;&lt;span class=&quot;code-snippet__title&quot;&gt;String&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;code-snippet__title&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          System.out.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;MyCallable call&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;success&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        ExecutorService threadPool = Executors.newSingleThreadExecutor();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            Future&amp;lt;String&amp;gt; future = threadPool.submit(&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; MyCallable());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            System.out.println(future.get());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (Exception e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           System.out.println(e);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;finally&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            threadPool.shutdown();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;这个类的功能就是使用Executors类的newSingleThreadExecutor方法创建了的一个单线程池，他里面会执行Callable线程任务。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;三、创建线程池的方法&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;我们仔细看看Executors类，会发现它里面给我们封装了不少创建线程池的静态方法，如下图所示：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-height=&quot;1052&quot; data-ratio=&quot;0.9734375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uL371281oDHHAdsqI8jRgpibpksVCk0xKxY4ibAoO1JG0dYhEndlhLz9ZArQs0NTTP0JmsnzC7FEPwCAjKodfWjQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot; data-width=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;其实，我们总结一下其实只有6种：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1.newCachedThreadPool可缓冲线程池&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-height=&quot;212&quot; data-ratio=&quot;0.2150101419878296&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uL371281oDHHAdsqI8jRgpibpksVCk0xKphHPHQQR49VoHRecTibBnibnibXEL2an3WUm4ZibNfJR1OWN0YEXUnBFdA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;986&quot; data-width=&quot;986&quot;/&gt;&lt;/p&gt;&lt;p&gt;      它的核心线程数是0，最大线程数是integer的最大值，每隔60秒回收一次空闲线程，使用SynchronousQueue队列。SynchronousQueue队列比较特殊，内部只包含一个元素，插入元素到队列的线程被阻塞，直到另一个线程从队列中获取了队列中存储的元素。同样，如果线程尝试获取元素并且当前不存在任何元素，则该线程将被阻塞，直到线程将元素插入队列。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.newFixedThreadPool固定大小线程池&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-height=&quot;206&quot; data-ratio=&quot;0.18558558558558558&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uL371281oDHHAdsqI8jRgpibpksVCk0xKibht0SKwZIzkrwbOtB6mVysBPMGdfSicNK5TuOM79Wa7gib4BZeWXbPwQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1110&quot; data-width=&quot;1110&quot;/&gt;&lt;/p&gt;&lt;p&gt;      它的核心线程数 和 最大线程数是一样，都是nThreads变量的值，该变量由用户自己决定，所以说是固定大小线程池。此外，它的每隔0毫秒回收一次线程，换句话说就是不回收线程，因为它的核心线程数 和 最大线程数是一样，回收了没有任何意义。此外，使用了LinkedBlockingQueue队列，该队列其实是有界队列，很多人误解了，只是它的初始大小比较大是integer的最大值。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3.newScheduledThreadPool定时任务线程池&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-height=&quot;186&quot; data-ratio=&quot;0.16970802919708028&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uL371281oDHHAdsqI8jRgpibpksVCk0xKSMcf4PP00OJtuA0WLJUWNoMlwWkrVzHGKCFCLMflSSwbJ1GibCEiby4Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1096&quot; data-width=&quot;1096&quot;/&gt;&lt;/p&gt;&lt;p&gt;      它的核心线程数是corePoolSize变量，需要用户自己决定，最大线程数是integer的最大值，同样，它的每隔0毫秒回收一次线程，换句话说就是不回收线程。使用了DelayedWorkQueue队列，该队列具有延时的功能。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4.newSingleThreadExecutor单个线程池&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-height=&quot;248&quot; data-ratio=&quot;0.23709369024856597&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uL371281oDHHAdsqI8jRgpibpksVCk0xKoPpWwYcBJsn8PxvWicZWXRTfOxbzwlSc5bicHLUpxhTNk1Ir9KlZibhkg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1046&quot; data-width=&quot;1046&quot;/&gt;&lt;/p&gt;&lt;p&gt;       其实，跟上面的newFixedThreadPool是一样的，稍微有一点区别是核心线程数 和 最大线程数 都是1，这就是为什么说它是单线程池的原因。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;5.newSingleThreadScheduledExecutor单线程定时任务线程池&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-height=&quot;178&quot; data-ratio=&quot;0.14037854889589904&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uL371281oDHHAdsqI8jRgpibpksVCk0xKqvHx8q77wOQuCic9Xc5YyeCoWhms47SMwH7lLvUNtKeLaVKLxzuOcQQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1268&quot; data-width=&quot;1268&quot;/&gt;&lt;/p&gt;&lt;p&gt;      该线程池是对上面介绍过的ScheduledThreadPoolExecutor定时任务线程池的简单封装，核心线程数固定是1，其他的功能一模一样。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;6.newWorkStealingPool窃取线程池&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-height=&quot;246&quot; data-ratio=&quot;0.23518164435946462&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uL371281oDHHAdsqI8jRgpibpksVCk0xKxsFSia88P7bDojj0KXuF5ez7cEAOXtopnuKt5ErKnYvw6nMxPLkfEwg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1046&quot; data-width=&quot;1046&quot;/&gt;&lt;/p&gt;&lt;p&gt;        它是JDK1.8增加的新线程池，跟其他的实现方式都不一样，它底层是通过ForkJoinPool类来实现的。会创建一个含有足够多线程的线程池，来维持相应的并行级别，它会通过工作窃取的方式，使得多核的 CPU 不会闲置，总会有活着的线程让 CPU 去运行。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;讲了这么多，具体要怎么用呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;     其实newFixedThreadPool、newCachedThreadPool、newSingleThreadExecutor 和 newWorkStealingPool方法创建和使用线程池的方法是一样的。这四个方法创建线程池返回值是ExecutorService，通过它的execute方法执行线程。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;MyWorker&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Runnable&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.out.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;MyWorker run&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        ExecutorService threadPool = Executors.newFixedThreadPool(&lt;span class=&quot;code-snippet__number&quot;&gt;8&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            threadPool.execute(&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; MyWorker());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (Exception e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            System.out.println(e);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;finally&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            threadPool.shutdown();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;       newScheduledThreadPool 和 newSingleThreadScheduledExecutor 方法创建和使用线程池的方法也是一样的&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;MyTask&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Runnable&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.out.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;MyTask call&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(&lt;span class=&quot;code-snippet__number&quot;&gt;8&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            scheduledExecutorService.schedule(&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; MyRunnable(), &lt;span class=&quot;code-snippet__number&quot;&gt;60&lt;/span&gt;, TimeUnit.SECONDS);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;finally&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            scheduledExecutorService.shutdown();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;      以上两个方法创建的线程池返回值是ScheduledExecutorService，通过它的schedule提交线程，并且可以配置延迟执行的时间。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;四、自定义线程池&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;       Executors类有这么多方法可以创建线程池，但是阿里巴巴开发规范中却明确规定不要使用Executors类创建线程池，这是为什么呢？&lt;/p&gt;&lt;p&gt;      newCachedThreadPool可缓冲线程池，它的最大线程数是integer的最大值，意味着使用它创建的线程池，可以创建非常多的线程，我们都知道一个线程默认情况下占用内存1M，如果创建的线程太多，占用内存太大，最后肯定会出现内存溢出的问题。&lt;/p&gt;&lt;p&gt;        newFixedThreadPool和newSingleThreadExecutor在这里都称为固定大小线程池，它的队列使用的LinkedBlockingQueue，我们都知道这个队列默认大小是integer的最大值，意味着可以往该队列中加非常多的任务，每个任务也是要内存空间的，如果任务太多，最后肯定也会出现内存溢出的问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;        阿里建议使用ThreadPoolExecutor类创建线程池，其实从刚刚看到的Executors类创建线程池的newFixedThreadPool等方法可以看出，它也是使用ThreadPoolExecutor类创建线程池的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-height=&quot;206&quot; data-ratio=&quot;0.128428927680798&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uL371281oDHHAdsqI8jRgpibpksVCk0xKvmMe3iaEN1Z9QsERwWSefNq7pjA09Wcj8cONYIQjHaf14xOlMT1IibLw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1604&quot; data-width=&quot;1604&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-height=&quot;792&quot; data-ratio=&quot;0.66875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uL371281oDHHAdsqI8jRgpibpksVCk0xK71FgMd9KvPfdjRkqqmC7OeCbR0RDINkpScicw8IzCuEUvGdRYdRYGtQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot; data-width=&quot;1184&quot;/&gt;&lt;/p&gt;&lt;p&gt;       从上图可以看出ThreadPoolExecutor类的构造方法有4个，里面包含了很多参数，让我们先一起认识一下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;corePoolSize：核心线程数&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;maximumPoolSize：最大线程数&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;keepAliveTime：空闲线程回收时间间隔&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;unit：空闲线程回收时间间隔单位&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;workQueue：提交任务的队列，当线程数量超过核心线程数时，可以将任务提交到任务队列中。比较常用的有：ArrayBlockingQueue; LinkedBlockingQueue; SynchronousQueue;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;threadFactory：线程工厂，可以自定义线程的一些属性，比如：名称或者守护线程等&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;handler&lt;/span&gt;：表示当拒绝处理任务时的策略&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.AbortPolicy&lt;/span&gt;:丢弃任务并抛出&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;RejectedExecutionException&lt;/span&gt;异常。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.DiscardPolicy&lt;/span&gt;：也是丢弃任务，但是不抛出异常。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.DiscardOldestPolicy&lt;/span&gt;：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.CallerRunsPolicy&lt;/span&gt;：由调用线程处理该任务&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;我们根据上面的内容自定义一个线程池：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;MyThreadPool&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;implements&lt;/span&gt;  &lt;span class=&quot;code-snippet__title&quot;&gt;Runnable&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; ExecutorService  executorService = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ThreadPoolExecutor(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__number&quot;&gt;8&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__number&quot;&gt;10&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__number&quot;&gt;30&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            TimeUnit.SECONDS,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ArrayBlockingQueue&amp;lt;&amp;gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;500&lt;/span&gt;),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ThreadPoolExecutor.AbortPolicy());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.out.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;MyThreadPool run&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; availableProcessors = Runtime.getRuntime().availableProcessors();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            executorService.execute(&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; MyThreadPool());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (Exception e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            System.out.println(e);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;finally&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            executorService.shutdown();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;       从上面可以看到，我们使用ThreadPoolExecutor类自定义了一个线程池，它的核心线程数是8，最大线程数是 10，空闲线程回收时间是30，单位是秒，存放任务的队列用的ArrayBlockingQueue，而队列满的处理策略用的AbortPolicy。使用这个队列，基本可以保持线程在系统的可控范围之内，不会出现内存溢出的问题。但是也不是绝对的，只是出现内存溢出的概率比较小。&lt;/p&gt;&lt;p&gt;     当然，阿里巴巴开发规范建议不使用Executors类创建线程池，并不表示它完全没用，在一些低并发的业务场景照样可以使用。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;五、最佳线程数&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;在使用线程池时，很多同学都有这样的疑问，不知道如何配置线程数量，今天我们一起探讨一下这个问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1.经验值&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;配置线程数量之前，首先要看任务的类型是 IO密集型，还是CPU密集型？&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;什么是IO密集型？&lt;/p&gt;&lt;p&gt;比如：频繁读取磁盘上的数据，或者需要通过网络远程调用接口。&lt;/p&gt;&lt;p&gt;什么是CPU密集型？&lt;/p&gt;&lt;p&gt;比如：非常复杂的调用，循环次数很多，或者递归调用层次很深等。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;IO密集型配置线程数经验值是：2N，其中N代表CPU核数。&lt;/p&gt;&lt;p&gt;CPU密集型配置线程数经验值是：N + 1，其中N代表CPU核数。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果获取N的值？&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; availableProcessors = Runtime.getRuntime().availableProcessors();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;      那么问题来了，混合型（既包含IO密集型，又包含CPU密集型）的如何配置线程数？&lt;/p&gt;&lt;p&gt;混合型如果IO密集型，和CPU密集型的执行时间相差不太大，可以拆分开，以便于更好配置。如果执行时间相差太大，优化的意义不大，比如IO密集型耗时60s，CPU密集型耗时1s。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.最佳线程数目算法&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;除了上面介绍是经验值之外，其实还提供了计算公式：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;最佳线程数目 = （（线程等待时间+线程CPU时间）/线程CPU时间 ）* CPU数目&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;        很显然线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程。&lt;/p&gt;&lt;p&gt;        虽说最佳线程数目算法更准确，但是线程等待时间和线程CPU时间不好测量，实际情况使用得比较少，一般用经验值就差不多了。再配合系统压测，基本可以确定最适合的线程数。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2946a67bae3bf60fa930c7bc1fa9d3e8</guid>
<title>全网最全！彻底弄透 Java 处理 GMT/UTC 日期时间</title>
<link>https://toutiao.io/k/mmjgntt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4255555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/crPesQVeyKINn8r0WeMibKibUXPlV1FRgiajibfiadsVv65T3LvyMy0gVz10VBtxV3RfeT0MOmMOticOI8iaEicibx1tSOw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你好，我是A哥(YourBatman)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本系列的目的是明明白白、彻彻底底的搞定日期/时间处理的几乎所有case。&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI0MTUwOTgyOQ==&amp;amp;mid=2247491787&amp;amp;idx=1&amp;amp;sn=37e8b0af5a7ffda54003d4280a70d638&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;上篇文章&lt;/a&gt; 铺设所有涉及到的概念解释，例如GMT、UTC、夏令时、时间戳等等，若你还没看过，不仅强烈建议而是&lt;strong&gt;强制建议&lt;/strong&gt;你前往用花5分钟看一下，因为日期时间处理较为特殊，实战必须基于对概念的了解，否则很可能依旧雾里看花。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;说明：日期/时间的处理是日常开发非常常见的老大难，究其原因就是对日期时间的相关概念、应用场景不熟悉，所以不要忽视它&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上篇概念，本文落地实操，二者相辅相成，缺一不可。本文内容较多，文字较长，预计超2w字，旨在全面的彻底帮你搞定Java对日期时间的处理，&lt;strong&gt;建议你可收藏&lt;/strong&gt;，作为参考书留以备用。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;本文提纲&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.598825831702544&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/crPesQVeyKINn8r0WeMibKibUXPlV1FRgianUaaPdusoc7iaxn7JJV4MDm6jaibSJFGBVwBw2Q6RX86LVBDARe8w15g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1022&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;版本约定&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;✍正文&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上文铺了这么多概念，作为一枚Javaer最关心当然是这些“概念”在Java里的落地。平时工作中遇到时间如何处理？用Date还是JDK 8之后的日期时间API？如何解决跨时区转换等等头大问题。A哥向来管生管养，管杀管埋，因此本文就带你领略一下，Java是如何实现GMT和UTC的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;众所周知，JDK以版本8为界，有两套处理日期/时间的API：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8917378917378918&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/crPesQVeyKINn8r0WeMibKibUXPlV1FRgiaKnNf6RseCKI56uHepy9knzZcX3sMGwriaGhAoGJgMUDh8rtcQOaTDyg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;351&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然我一直鼓励弃用Date而支持在项目中只使用JSR 310日期时间类型，但是呢，由于Date依旧有庞大的存量用户，所以本文也不落单，对二者的实现均进行阐述。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Date类型实现&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;java.util.Date在JDK 1.0就已存在，用于表示日期 + 时间的类型，纵使年代已非常久远，并且此类的具有职责不单一，使用很不方便等诸多毛病，但由于十几二十年的历史原因存在，它的生命力依旧顽强，用户量巨大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先来认识下Date，看下这个例子的输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Date currDate = &lt;span&gt;new&lt;/span&gt; Date();&lt;br/&gt;    System.out.println(currDate.toString());&lt;br/&gt;    &lt;span&gt;// 已经@Deprecated&lt;/span&gt;&lt;br/&gt;    System.out.println(currDate.toLocaleString());&lt;br/&gt;    &lt;span&gt;// 已经@Deprecated&lt;/span&gt;&lt;br/&gt;    System.out.println(currDate.toGMTString());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行程序，输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Fri Jan &lt;span&gt;15&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;:&lt;span&gt;22&lt;/span&gt;:&lt;span&gt;34&lt;/span&gt; CST &lt;span&gt;2021&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2021&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;-&lt;span&gt;15&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;:&lt;span&gt;22&lt;/span&gt;:&lt;span&gt;34&lt;/span&gt;&lt;br/&gt;&lt;span&gt;15&lt;/span&gt; Jan &lt;span&gt;2021&lt;/span&gt; &lt;span&gt;02&lt;/span&gt;:&lt;span&gt;22&lt;/span&gt;:&lt;span&gt;34&lt;/span&gt; GMT&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第一个：标准的UTC时间（CST就代表了偏移量 +0800）&lt;/strong&gt;第二个：本地时间，根据本地时区显示的时间格式
第三个：GTM时间，也就是格林威治这个时候的时间，可以看到它是凌晨2点（北京时间是上午10点哦）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二个、第三个其实在JDK 1.1就都标记为@Deprecated过期了，基本禁止再使用。若需要转换为本地时间 or GTM时间输出的话，请使用格式化器java.text.DateFormat去处理。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;时区/偏移量TimeZone&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在JDK8之前，Java对时区和偏移量都是使用&lt;code&gt;java.util.TimeZone&lt;/code&gt;来表示的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般情况下，使用静态方法&lt;code&gt;TimeZone#getDefault()&lt;/code&gt;即可获得当前JVM所运行的时区，比如你在中国运行程序，这个方法返回的就是中国时区（也叫北京时区、北京时间）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有的时候你需要做&lt;strong&gt;带时区&lt;/strong&gt;的时间转换，譬如：接口返回值中既要有展示北京时间，也要展示纽约时间。这个时候就要获取到纽约的时区，以北京时间为基准在其上进行带时区转换一把：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    String patternStr = &lt;span&gt;&quot;yyyy-MM-dd HH:mm:ss&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;// 北京时间（new出来就是默认时区的时间）&lt;/span&gt;&lt;br/&gt;    Date bjDate = &lt;span&gt;new&lt;/span&gt; Date();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 得到纽约的时区&lt;/span&gt;&lt;br/&gt;    TimeZone newYorkTimeZone = TimeZone.getTimeZone(&lt;span&gt;&quot;America/New_York&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;// 根据此时区 将北京时间转换为纽约的Date&lt;/span&gt;&lt;br/&gt;    DateFormat newYorkDateFormat = &lt;span&gt;new&lt;/span&gt; SimpleDateFormat(patternStr);&lt;br/&gt;    newYorkDateFormat.setTimeZone(newYorkTimeZone);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;这是北京时间：&quot;&lt;/span&gt; + &lt;span&gt;new&lt;/span&gt; SimpleDateFormat(patternStr).format(bjDate));&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;这是纽约时间：&quot;&lt;/span&gt; + newYorkDateFormat.format(bjDate));&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行程序，输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;这是北京时间：&lt;span&gt;2021&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;15&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;:&lt;span&gt;48&lt;/span&gt;:&lt;span&gt;16&lt;/span&gt;&lt;br/&gt;这是纽约时间：&lt;span&gt;2021&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;14&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;48&lt;/span&gt;:&lt;span&gt;16&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(11 + 24) - 22 = 13，北京比纽约快13个小时没毛病。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;注意：两个时间表示的应该是同一时刻，也就是常说的时间戳值是相等的&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么问题来了，你怎么知道获取纽约的时区用&lt;code&gt;America/New_York&lt;/code&gt;这个zoneId呢？随便写个字符串行不行？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是当然不行，这是有章可循的。下面我介绍两种查阅zoneId的方式，任你挑选：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;方式一&lt;/strong&gt;：用Java程序把所有可用的zoneId打印出来，然后查阅&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test3&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    String[] availableIDs = TimeZone.getAvailableIDs();&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;可用zoneId总数：&quot;&lt;/span&gt; + availableIDs.length);&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (String zoneId : availableIDs) {&lt;br/&gt;        System.out.println(zoneId);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行程序，输出（大部分符合规律：/前表示所属州，/表示城市名称）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;可用zoneId总数：&lt;span&gt;628&lt;/span&gt;&lt;br/&gt;Africa/Abidjan&lt;br/&gt;Africa/Accra&lt;br/&gt;...&lt;br/&gt;Asia/Chongqing &lt;span&gt;// 亚洲/重庆&lt;/span&gt;&lt;br/&gt;Asia/Shanghai &lt;span&gt;// 亚洲/上海&lt;/span&gt;&lt;br/&gt;Asia/Dubai &lt;span&gt;// 亚洲/迪拜&lt;/span&gt;&lt;br/&gt;...&lt;br/&gt;America/New_York &lt;span&gt;// 美洲/纽约&lt;/span&gt;&lt;br/&gt;America/Los_Angeles &lt;span&gt;// 美洲/洛杉矶&lt;/span&gt;&lt;br/&gt;...&lt;br/&gt;Europe/London &lt;span&gt;// 欧洲/伦敦&lt;/span&gt;&lt;br/&gt;...&lt;br/&gt;Etc/GMT&lt;br/&gt;Etc/GMT+&lt;span&gt;0&lt;/span&gt;&lt;br/&gt;Etc/GMT+&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;值得注意的是并没有 Asia/Beijing 哦。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;说明：此结果基于JDK 8版本，不同版本输出的总个数可能存在差异，但主流的ZoneId一般不会有变化&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;方式二&lt;/strong&gt;：zoneId的列表是jre维护的一个文本文件，路径是你JDK/JRE的安装路径。地址在.\jre\lib目录的名为&lt;code&gt;tzmappings&lt;/code&gt;的文本文件里。打开这个文件去ctrl + f找也是可以达到查找的目的的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两种房子可以帮你找到ZoneId的字典方便查阅，但是还有这么一种情况：当前所在的城市呢，在&lt;strong&gt;tzmappings&lt;/strong&gt;文件里根本没有（比如没有收录），那要获取这个地方的时间去显示怎么破呢？虽然概率很小，但不见得没有嘛，毕竟全球那么多国家那么多城市呢~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java自然也考虑到了这一点，因此也是有办法的：指定其时区数字表示形式，其实也叫偏移量（不要告诉我这个地方的时区都不知道，那就真没救了），如下示例&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test4&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    System.out.println(TimeZone.getTimeZone(&lt;span&gt;&quot;GMT+08:00&quot;&lt;/span&gt;).getID());&lt;br/&gt;    System.out.println(TimeZone.getDefault().getID());&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 纽约时间&lt;/span&gt;&lt;br/&gt;    System.out.println(TimeZone.getTimeZone(&lt;span&gt;&quot;GMT-05:00&quot;&lt;/span&gt;).getID());&lt;br/&gt;    System.out.println(TimeZone.getTimeZone(&lt;span&gt;&quot;America/New_York&quot;&lt;/span&gt;).getID());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行程序，输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;GMT+&lt;span&gt;08&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; &lt;span&gt;// 效果等同于Asia/Shanghai&lt;/span&gt;&lt;br/&gt;Asia/Shanghai&lt;br/&gt;GMT-&lt;span&gt;05&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; &lt;span&gt;// 效果等同于America/New_York&lt;/span&gt;&lt;br/&gt;America/New_York &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;值得注意的是，这里只能用&lt;code&gt;GMT+08:00&lt;/code&gt;，而不能用&lt;code&gt;UTC+08:00&lt;/code&gt;，原因下文有解释。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;设置默认时区&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般来说，JVM在哪里跑，默认时区就是哪。对于国内程序员来讲，一般只会接触到东八区，也就是北京时间（本地时间）。随着国际合作越来越密切，很多时候需要日期时间国际化处理，举个很实际的例子：同一份应用在阿里云部署、在AWS（海外）上也部署一份供海外用户使用，此时&lt;strong&gt;同一份代码&lt;/strong&gt;部署在不同的时区了，怎么破？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;倘若时区不同，那么势必影响到程序的运行结果，很容易带来计算逻辑的错误，很可能就乱套了。Java让我们有多种方式可以&lt;strong&gt;手动&lt;/strong&gt;设置/修改默认时区：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;API方式：强制将时区设为北京时区&lt;code&gt;TimeZone.setDefault(TimeZone.getDefault().getTimeZone(&quot;GMT+8&quot;));&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;JVM参数方式：&lt;code&gt;-Duser.timezone=GMT+8&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;运维设置方式：将操作系统主机时区设置为北京时区，这是推荐方式，可以完全对开发者无感，也方便了运维统一管理&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;据我了解，很多公司在阿里云、腾讯云、国内外的云主机上部署应用时，全部都是采用运维设置统一时区：中国时区，这种方式来管理的，这样对程序来说就消除了默认时区不一致的问题，对开发者友好。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;让人恼火的夏令时&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你知道吗，中国曾经也使用过夏令时。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;什么是夏令时？&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI0MTUwOTgyOQ==&amp;amp;mid=2247491787&amp;amp;idx=1&amp;amp;sn=37e8b0af5a7ffda54003d4280a70d638&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;戳这里&lt;/a&gt;&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;离现在最近是1986年至1991年用过夏令时（每年4月中旬的第一个周日2时 - 9月中旬的第一个星期日2时止）：&lt;span&gt;1986年5月4日至9月14日&lt;/span&gt;&lt;span&gt;1987年4月12日至9月13日&lt;/span&gt;&lt;span&gt;1988年4月10日至9月11日&lt;/span&gt;&lt;span&gt;1989年4月16日至9月17日&lt;/span&gt;&lt;span&gt;1990年4月15日至9月16日&lt;/span&gt;&lt;span&gt;1991年4月14日至9月15日&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;夏令时是一个“非常烦人”的东西，大大的增加了日期时间处理的复杂度。比如这个灵魂拷问：若你的出生日期是1988-09-11 00:00:00（夏令时最后一天）且存进了数据库，想一想，对此日期的格式化有没有可能就会出问题呢，有没有可能被你格式化成1988-09-10 23:00:00呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对此拷问，我模拟了如下代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test5&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; ParseException &lt;/span&gt;{&lt;br/&gt;    String patterStr = &lt;span&gt;&quot;yyyy-MM-dd&quot;&lt;/span&gt;;&lt;br/&gt;    DateFormat dateFormat = &lt;span&gt;new&lt;/span&gt; SimpleDateFormat(patterStr);&lt;br/&gt;&lt;br/&gt;    String birthdayStr = &lt;span&gt;&quot;1988-09-11&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;// 字符串 -&amp;gt; Date -&amp;gt; 字符串&lt;/span&gt;&lt;br/&gt;    Date birthday = dateFormat.parse(birthdayStr);&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; birthdayTimestamp = birthday.getTime();&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;老王的生日是：&quot;&lt;/span&gt; + birthday);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;老王的生日的时间戳是：&quot;&lt;/span&gt; + birthdayTimestamp);&lt;br/&gt;&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;==============程序经过一番周转，我的同时 方法入参传来了生日的时间戳=============&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;// 字符串 -&amp;gt; Date -&amp;gt; 时间戳 -&amp;gt; Date -&amp;gt; 字符串&lt;/span&gt;&lt;br/&gt;    birthday = &lt;span&gt;new&lt;/span&gt; Date(birthdayTimestamp);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;老王的生日是：&quot;&lt;/span&gt; + birthday);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;老王的生日的时间戳是：&quot;&lt;/span&gt; + dateFormat.format(birthday));&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码，在不同的JDK版本下运行，&lt;strong&gt;可能&lt;/strong&gt;出现不同的结果，有兴趣的可copy过去自行试试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于JDK处理夏令时（特指中国的夏令时）确实出现过问题且造成过bug，当时对应的JDK版本是&lt;code&gt;1.8.0_2xx&lt;/code&gt;之前版本格式化那个日期出问题了，在这之后的版本貌似就没问题了。这里我提供的版本信息仅供参考，若有遇到类似case就升级JDK版本到最新吧，一般就不会有问题了。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;发生这个情况是在JDK非常小的版本号之间，不太好定位精确版本号界限，所以仅供参考&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总的来说，只要你使用的是较新版本的JDK，开发者是无需关心夏令时问题的，即使全球仍有很多国家在使用夏令时，咱们只需要面向&lt;strong&gt;时区&lt;/strong&gt;做时间转换就没问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;Date时区无关性&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类Date表示一个特定的时间&lt;strong&gt;瞬间&lt;/strong&gt;，精度为毫秒。既然表示的是瞬间/时刻，那它必然和时区是无关的，看下面代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test6&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    String patterStr = &lt;span&gt;&quot;yyyy-MM-dd HH:mm:ss&quot;&lt;/span&gt;;&lt;br/&gt;    Date currDate = &lt;span&gt;new&lt;/span&gt; Date(System.currentTimeMillis());&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 北京时区&lt;/span&gt;&lt;br/&gt;    DateFormat bjDateFormat = &lt;span&gt;new&lt;/span&gt; SimpleDateFormat(patterStr);&lt;br/&gt;    bjDateFormat.setTimeZone(TimeZone.getDefault());&lt;br/&gt;    &lt;span&gt;// 纽约时区&lt;/span&gt;&lt;br/&gt;    DateFormat newYorkDateFormat = &lt;span&gt;new&lt;/span&gt; SimpleDateFormat(patterStr);&lt;br/&gt;    newYorkDateFormat.setTimeZone(TimeZone.getTimeZone(&lt;span&gt;&quot;America/New_York&quot;&lt;/span&gt;));&lt;br/&gt;    &lt;span&gt;// 伦敦时区&lt;/span&gt;&lt;br/&gt;    DateFormat londonDateFormat = &lt;span&gt;new&lt;/span&gt; SimpleDateFormat(patterStr);&lt;br/&gt;    londonDateFormat.setTimeZone(TimeZone.getTimeZone(&lt;span&gt;&quot;Europe/London&quot;&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;毫秒数:&quot;&lt;/span&gt; + currDate.getTime() + &lt;span&gt;&quot;, 北京本地时间:&quot;&lt;/span&gt; + bjDateFormat.format(currDate));&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;毫秒数:&quot;&lt;/span&gt; + currDate.getTime() + &lt;span&gt;&quot;, 纽约本地时间:&quot;&lt;/span&gt; + newYorkDateFormat.format(currDate));&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;毫秒数:&quot;&lt;/span&gt; + currDate.getTime() + &lt;span&gt;&quot;, 伦敦本地时间:&quot;&lt;/span&gt; + londonDateFormat.format(currDate));&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行程序，输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;毫秒数:&lt;span&gt;1610696040244&lt;/span&gt;, 北京本地时间:&lt;span&gt;2021&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;15&lt;/span&gt; &lt;span&gt;15&lt;/span&gt;:&lt;span&gt;34&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;&lt;br/&gt;毫秒数:&lt;span&gt;1610696040244&lt;/span&gt;, 纽约本地时间:&lt;span&gt;2021&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;15&lt;/span&gt; &lt;span&gt;02&lt;/span&gt;:&lt;span&gt;34&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;&lt;br/&gt;毫秒数:&lt;span&gt;1610696040244&lt;/span&gt;, 伦敦本地时间:&lt;span&gt;2021&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;15&lt;/span&gt; &lt;span&gt;07&lt;/span&gt;:&lt;span&gt;34&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，同一个毫秒值，根据时区/偏移量的不同可以展示多地的时间，这就证明了Date它的时区无关性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;确切的说：Date对象里存的是自格林威治时间（ GMT）1970年1月1日0点至Date所表示时刻所经过的毫秒数&lt;/strong&gt;，是个数值。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;读取字符串为Date类型&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是开发中极其常见的一种需求：client请求方扔给你一个字符串如&quot;2021-01-15 18:00:00&quot;，然后你需要把它转为Date类型，怎么破？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题来了，光秃秃的扔给我个字符串说是15号晚上6点时间，我咋知道你指的是北京的晚上6点，还是东京的晚上6点呢？还是纽约的晚上6点呢？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0220820189274449&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/crPesQVeyKINn8r0WeMibKibUXPlV1FRgiaQl7ZfWk3mInFv5L5icum64Ww3YNlibsEhDCQNRiaIZfhaVbfDyRyBM2YA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;317&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，对于字符串形式的日期时间，只有指定了时区才有意义。也就是说&lt;strong&gt;字符串 + 时区&lt;/strong&gt; 才能精确知道它是什么时刻，否则是存在歧义的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也许你可能会说了，自己平时开发中前端就是扔个字符串给我，然后我就给格式化为一个Date类型，并没有传入时区参数，运行这么久也没见出什么问题呀。如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test7&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; ParseException &lt;/span&gt;{&lt;br/&gt;    String patterStr = &lt;span&gt;&quot;yyyy-MM-dd HH:mm:ss&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 模拟请求参数的时间字符串&lt;/span&gt;&lt;br/&gt;    String dateStrParam = &lt;span&gt;&quot;2020-01-15 18:00:00&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 模拟服务端对此服务换转换为Date类型&lt;/span&gt;&lt;br/&gt;    DateFormat dateFormat = &lt;span&gt;new&lt;/span&gt; SimpleDateFormat(patterStr);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;格式化器用的时区是：&quot;&lt;/span&gt; + dateFormat.getTimeZone().getID());&lt;br/&gt;    Date date = dateFormat.parse(dateStrParam);&lt;br/&gt;    System.out.println(date);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行程序，输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;格式化器用的时区是：Asia/Shanghai&lt;br/&gt;Wed Jan &lt;span&gt;15&lt;/span&gt; &lt;span&gt;18&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; CST &lt;span&gt;2020&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看起来结果没问题。事实上，这是因为默认情况下你们交互双发就达成了契约：双方均使用的是北京时间（时区），既然是相同时区，所以互通有无不会有任何问题。不信你把你接口给海外用户调试试？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于格式化器来讲，虽然说编程过程中一般情况下我们并不需要给DateFormat设置时区（那就用默认时区呗）就可正常转换。但是作为高手的你必须清清楚楚，明明白白的知道这是由于交互双发默认&lt;strong&gt;有个相同时区的契约存在&lt;/strong&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;SimpleDateFormat格式化&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java中对Date类型的输入输出/格式化，推荐使用DateFormat而非用其&lt;code&gt;toString()&lt;/code&gt;方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DateFormat是一个时间格式化器抽象类，SimpleDateFormat是其具体实现类，用于以&lt;strong&gt;语言环境敏感&lt;/strong&gt;的方式格式化和解析日期。它允许格式化(日期→文本)、解析(文本→日期)和规范化。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;划重点：对语言环境敏感，也就是说对环境Locale、时区TimeZone都是敏感的。既然敏感，那就是&lt;strong&gt;可定制的&lt;/strong&gt;&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于一个格式化器来讲，&lt;strong&gt;模式&lt;/strong&gt;（模版）是其关键因素，了解一下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;日期/时间模式&lt;/strong&gt;：格式化的模式由指定的字符串组成，未加引号的大写/小写字母（A-Z a-z）代表特定模式，用来表示模式含义，若想&lt;strong&gt;原样输出&lt;/strong&gt;可以用单引号&#x27;&#x27;包起来，除了英文字母其它均不解释原样输出/匹配。下面是它规定的模式字母（其它字母原样输出）：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;字母&lt;/th&gt;&lt;th&gt;含义&lt;/th&gt;&lt;th&gt;匹配类型&lt;/th&gt;&lt;th&gt;示例&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;y&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;年&lt;/td&gt;&lt;td&gt;Year&lt;/td&gt;&lt;td&gt;2020,20&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;M&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;月&lt;/td&gt;&lt;td&gt;Month&lt;/td&gt;&lt;td&gt;July; Jul; 07&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;d&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;月中的天数（俗称日，最大值31）&lt;/td&gt;&lt;td&gt;Number&lt;/td&gt;&lt;td&gt;10&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;H&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;小时(0-23)&lt;/td&gt;&lt;td&gt;Number&lt;/td&gt;&lt;td&gt;0,23&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;m&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;分钟(0-59)&lt;/td&gt;&lt;td&gt;Number&lt;/td&gt;&lt;td&gt;30,59&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;s&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;秒(0-59)&lt;/td&gt;&lt;td&gt;Number&lt;/td&gt;&lt;td&gt;30,59&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;---&lt;/td&gt;&lt;td&gt;---&lt;/td&gt;&lt;td&gt;---&lt;/td&gt;&lt;td&gt;yyyy-MM-dd HH:mm:ss（分隔符可以是任意字符，甚至汉字）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Y&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;当前周所在的年份&lt;/td&gt;&lt;td&gt;Year&lt;/td&gt;&lt;td&gt;2020（不建议使用，周若跨年有坑）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;S&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;毫秒数(1-999)&lt;/td&gt;&lt;td&gt;Number&lt;/td&gt;&lt;td&gt;999&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;a&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;am/pm&lt;/td&gt;&lt;td&gt;Text&lt;/td&gt;&lt;td&gt;PM&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;z&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;时区&lt;/td&gt;&lt;td&gt;通用时区&lt;/td&gt;&lt;td&gt;Pacific Standard Time; PST; GMT-08:00&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Z&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;时区&lt;/td&gt;&lt;td&gt;RFC 822时区&lt;/td&gt;&lt;td&gt;-0800,+0800&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;X&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;时区&lt;/td&gt;&lt;td&gt;ISO 8601时区&lt;/td&gt;&lt;td&gt;-08; -0800; -08:00&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;G&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;年代&lt;/td&gt;&lt;td&gt;Text&lt;/td&gt;&lt;td&gt;AD(公元)、BC(公元前)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;D&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;年中的天数(1-366)&lt;/td&gt;&lt;td&gt;Number&lt;/td&gt;&lt;td&gt;360&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;w&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;年中的周数(1-54)&lt;/td&gt;&lt;td&gt;Number&lt;/td&gt;&lt;td&gt;27&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;W&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;月中的周数(1-5)&lt;/td&gt;&lt;td&gt;Number&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;E&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;星期几名称&lt;/td&gt;&lt;td&gt;Text&lt;/td&gt;&lt;td&gt;Tuesday; Tue&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;u&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;星期几数字(1=Monday...)&lt;/td&gt;&lt;td&gt;Number&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;k&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;小时(1-24)&lt;/td&gt;&lt;td&gt;Number&lt;/td&gt;&lt;td&gt;不建议使用&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;K/h&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;am/pm小时数字&lt;/td&gt;&lt;td&gt;Number&lt;/td&gt;&lt;td&gt;一般配合a一起使用&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个表格里出现了一些“特殊”的匹配类型，做如下解释：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Text&lt;/strong&gt;：格式化(Date -&amp;gt; String)，如果模式字母的数目是4个或更多，则使用完整形式；否则，如果可能的话，使用简短或缩写形式。对于解析（String -&amp;gt; Date），这两种形式都一样，与模式字母的数量无关&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test9&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; ParseException &lt;/span&gt;{&lt;br/&gt;    String patternStr = &lt;span&gt;&quot;G GG GGGGG E EE EEEEE a aa aaaaa&quot;&lt;/span&gt;;&lt;br/&gt;    Date currDate = &lt;span&gt;new&lt;/span&gt; Date();&lt;br/&gt;&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓中文地区模式↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓&quot;&lt;/span&gt;);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;====================Date-&amp;gt;String====================&quot;&lt;/span&gt;);&lt;br/&gt;    DateFormat dateFormat = &lt;span&gt;new&lt;/span&gt; SimpleDateFormat(patternStr, Locale.CHINA);&lt;br/&gt;    System.out.println(dateFormat.format(currDate));&lt;br/&gt;&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;====================String-&amp;gt;Date====================&quot;&lt;/span&gt;);&lt;br/&gt;    String dateStrParam = &lt;span&gt;&quot;公元 公元 公元 星期六 星期六 星期六 下午 下午 下午&quot;&lt;/span&gt;;&lt;br/&gt;    System.out.println(dateFormat.parse(dateStrParam));&lt;br/&gt;&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓英文地区模式↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓&quot;&lt;/span&gt;);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;====================Date-&amp;gt;String====================&quot;&lt;/span&gt;);&lt;br/&gt;    dateFormat = &lt;span&gt;new&lt;/span&gt; SimpleDateFormat(patternStr, Locale.US);&lt;br/&gt;    System.out.println(dateFormat.format(currDate));&lt;br/&gt;&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;====================String-&amp;gt;Date====================&quot;&lt;/span&gt;);&lt;br/&gt;    dateStrParam = &lt;span&gt;&quot;AD ad bC Sat SatUrday sunDay PM PM Am&quot;&lt;/span&gt;;&lt;br/&gt;    System.out.println(dateFormat.parse(dateStrParam));&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行程序，输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓中文地区模式↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓&lt;br/&gt;====================Date-&amp;gt;String====================&lt;br/&gt;公元 公元 公元 星期六 星期六 星期六 下午 下午 下午&lt;br/&gt;====================String-&amp;gt;Date====================&lt;br/&gt;Sat Jan &lt;span&gt;03&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; CST &lt;span&gt;1970&lt;/span&gt;&lt;br/&gt;↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓英文地区模式↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓&lt;br/&gt;====================Date-&amp;gt;String====================&lt;br/&gt;AD AD AD Sat Sat Saturday PM PM PM&lt;br/&gt;====================String-&amp;gt;Date====================&lt;br/&gt;Sun Jan &lt;span&gt;01&lt;/span&gt; &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; CST &lt;span&gt;1970&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;观察打印结果，除了符合模式规则外，还能在&lt;strong&gt;String -&amp;gt; Date解析时&lt;/strong&gt;总结出两点结论：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;英文单词，不分区大小写。如SatUrday sunDay都是没问题，但是&lt;strong&gt;不能&lt;/strong&gt;有拼写错误&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;若有多个part表示一个意思，那么last win。如Sat SatUrday sunDay最后一个生效&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于Locale地域参数，因为中文不存在格式、缩写方面的特性，因此这些规则只对英文地域（如Locale.US生效）&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Number&lt;/strong&gt;：格式化(Date -&amp;gt; String)，模式字母的数量是数字的【最小】数量，较短的数字被零填充到这个数量。对于解析(String -&amp;gt; Date)，模式字母的数量将被忽略，除非需要分隔两个相邻的字段&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Year&lt;/strong&gt;：对于格式化和解析，如果模式字母的数量是4个或更多，则使用特定于日历的长格式。否则，使用日历特定的简短或缩写形式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Month&lt;/strong&gt;：如果模式字母的数量是3个或更多，则被解释为文本；否则，它将被解释为一个数字。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;通用时区&lt;/strong&gt;：如果该时区有名称，如Pacific Standard Time、PST、CST等那就用名称，否则就用GMT规则的字符串，如：GMT-08:00&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;RFC 822时区&lt;/strong&gt;：遵循RFC 822格式，向下兼容通用时区（名称部分除外）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;ISO 8601时区&lt;/strong&gt;：对于格式化，如果与GMT的偏移值为0（也就是格林威治时间喽），则生成“Z”；如果模式字母的数量为1，则忽略小时的任何分数。例如，如果模式是“X”，时区是“GMT+05:30”，则生成“+05”。在进行解析时，“Z”被解析为UTC时区指示符。一般时区不被接受。如果模式字母的数量是4个或更多，在构造SimpleDateFormat或应用模式时抛出IllegalArgumentException。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这个规则理解起来还是比较费劲的，在开发中一般不太建议使用此种模式。若要使用请务必本地做好测试&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SimpleDateFormat的使用很简单，重点是了解其规则模式。最后关于SimpleDateFormat的使用再强调这两点哈：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;SimpleDateFormat并非线程安全类，使用时请务必注意并发安全问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;若使用SimpleDateFormat去格式化成非本地区域（默认Locale）的话，那就必须在构造的时候就指定好，如Locale.US&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于Date类型的任何格式化、解析请统一使用SimpleDateFormat&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JSR 310类型&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;曾经有个人做了个很有意思的投票，统计对Java API的&lt;strong&gt;不满意&lt;/strong&gt;程度。最终Java Date/Calendar API斩获第二烂（第一烂是Java XML/DOM），体现出它烂的点较多，这里给你例举几项：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;定义并不一致，在java.util和java.sql包中竟然都有Date类，而且呢对它进行格式化/解析类竟然又跑到java.text去了，精神分裂啊&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;java.util.Date等类在建模日期的设计上行为不一致，缺陷明显。包括易变性、糟糕的偏移值、默认值、命名等等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;java.util.Date同时包含日期和时间，而其子类java.sql.Date却仅包含日期，这是什么&lt;span&gt;神&lt;/span&gt;继承？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4180790960451977&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/crPesQVeyKINn8r0WeMibKibUXPlV1FRgia12yAjpnNQXB5kFNGL1rbglcUicNfpSs5ibiatiaYloF3GiaXjub94A5c3rQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;354&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test10&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; currMillis = System.currentTimeMillis();&lt;br/&gt;&lt;br/&gt;    java.util.Date date = &lt;span&gt;new&lt;/span&gt; Date(currMillis);&lt;br/&gt;    java.sql.Date sqlDate = &lt;span&gt;new&lt;/span&gt; java.sql.Date(currMillis);&lt;br/&gt;    java.sql.Time time = &lt;span&gt;new&lt;/span&gt; Time(currMillis);&lt;br/&gt;    java.sql.Timestamp timestamp = &lt;span&gt;new&lt;/span&gt; Timestamp(currMillis);&lt;br/&gt;&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;java.util.Date：&quot;&lt;/span&gt; + date);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;java.sql.Date：&quot;&lt;/span&gt; + sqlDate);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;java.sql.Time：&quot;&lt;/span&gt; + time);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;java.sql.Timestamp：&quot;&lt;/span&gt; + timestamp);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行程序，输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;java.util.Date：Sat Jan &lt;span&gt;16&lt;/span&gt; &lt;span&gt;21&lt;/span&gt;:&lt;span&gt;50&lt;/span&gt;:&lt;span&gt;36&lt;/span&gt; CST &lt;span&gt;2021&lt;/span&gt;&lt;br/&gt;java.sql.Date：&lt;span&gt;2021&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;16&lt;/span&gt;&lt;br/&gt;java.sql.Time：&lt;span&gt;21&lt;/span&gt;:&lt;span&gt;50&lt;/span&gt;:&lt;span&gt;36&lt;/span&gt;&lt;br/&gt;java.sql.Timestamp：&lt;span&gt;2021&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;16&lt;/span&gt; &lt;span&gt;21&lt;/span&gt;:&lt;span&gt;50&lt;/span&gt;:&lt;span&gt;36.733&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 自己也实在忍不了这么难用的日期时间API了，于是在2014年随着Java 8的发布引入了全新的JSR 310日期时间。JSR-310源于精品时间库joda-time打造，解决了上面提到的&lt;strong&gt;所有问题&lt;/strong&gt;，是整个Java 8最大亮点之一。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JSR 310日期/时间 &lt;strong&gt;所有的&lt;/strong&gt; API都在java.time这个包内，没有例外。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;2.2889908256880735&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/crPesQVeyKINn8r0WeMibKibUXPlV1FRgiapQvMfqwRqXWCbRllrMicoD3iaI5EOEhTJsuvmaZb95Q7f8PIpiaowibZIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;218&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然喽，本文重点并不在于讨论JSR 310日期/时间体系，而是看看JSR 310日期时间类型是如何处理上面Date类型遇到的那些case的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;时区/偏移量ZoneId&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在JDK 8之前，Java使用&lt;code&gt;java.util.TimeZone&lt;/code&gt;来表示时区。而在JDK 8里分别使用了ZoneId表示时区，ZoneOffset表示UTC的偏移量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;值得提前强调，时区和偏移量在概念和实际作用上是有较大区别的，主要体现在：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;UTC偏移量仅仅记录了偏移的小时分钟而已，除此之外无任何其它信息。举个例子：+08:00的意思是比UTC时间早8小时，没有地理/时区含义，相应的-03:30代表的意思仅仅是比UTC时间晚3个半小时&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;时区是特定于地区而言的，它和地理上的地区（包括规则）强绑定在一起。比如整个中国都叫东八区，纽约在西五区等等&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;中国没有夏令时，所有东八区对应的偏移量永远是+8；纽约有夏令时，因此它的偏移量可能是-4也可能是-5哦&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;综合来看，时区更好用&lt;/strong&gt;。令人恼火的夏令时问题，若你使用UTC偏移量去表示那么就很麻烦，因为它可变：一年内的某些时期在原来基础上偏移量 +1，某些时期 -1；但若你使用ZoneId时区去表示就很方便喽，比如纽约是西五区，你在任何时候获取其当地时间都是能得到正确答案的，因为它内置了对夏令时规则的处理，也就是说啥时候+1啥时候-1时区自己门清，不需要API调用者关心。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;UTC偏移量更像是一种写死偏移量数值的做法，这在天朝这种没有时区规则（没有夏令时）的国家不会存在问题，东八区和UTC+08:00效果永远一样。但在一些夏令时国家（如美国、法国等等），就只能根据时区去获取当地时间喽。所以当你不了解当地规则时，最好是使用时区而非偏移量。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;ZoneId&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5076400679117148&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/crPesQVeyKINn8r0WeMibKibUXPlV1FRgia6BkbRUGyZKxYH4QUlwlepj7LyDPqtDvkRaM2BQDRuAIhT4ic3sT0xMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;589&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它代表一个时区的ID，如Europe/Paris。它规定了一些规则可用于将一个Instant时间戳转换为本地日期/时间LocalDateTime。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面说了时区ZoneId是包含有规则的，实际上描述偏移量何时以及如何变化的实际规则由&lt;code&gt;java.time.zone.ZoneRules&lt;/code&gt;定义。ZoneId则只是一个用于获取底层规则的ID。之所以采用这种方法，是因为&lt;strong&gt;规则是由政府定义的，并且经常变化，而ID是稳定的&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于API调用者来说只需要使用这个ID（也就是ZoneId）即可，而无&lt;span&gt;需&lt;/span&gt;关心更为底层的时区规则ZoneRules，和“政府”同步规则的事是它领域内的事就交给它喽。如：夏令时这条规则是由各国政府制定的，而且不同国家不同年一般都不一样，这个事就交由JDK底层的ZoneRules机制自行sync，使用者无需关心。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ZoneId在系统内是唯一的，它共包含三种类型的ID：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;最简单的ID类型：ZoneOffset，它由&#x27;Z&#x27;和以&#x27;+&#x27;或&#x27;-&#x27;开头的id组成。如：Z、+18:00、-18:00&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;另一种类型的ID是带有某种前缀形式的偏移样式ID，例如&#x27;GMT+2&#x27;或&#x27;UTC+01:00&#x27;。可识别的（合法的）前缀是&#x27;UTC&#x27;， &#x27;GMT&#x27;和&#x27;UT&#x27;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第三种类型是基于区域的ID（推荐使用）。基于区域的ID必须包含两个或多个字符，且不能以&#x27;UTC&#x27;、&#x27;GMT&#x27;、&#x27;UT&#x27; &#x27;+&#x27;或&#x27;-&#x27;开头。基于区域的id由配置定义好的，如Europe/Paris&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;概念说了一大推，下面给几个代码示例感受下吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、获取系统默认的ZoneId：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// JDK 1.8之前做法&lt;/span&gt;&lt;br/&gt;    System.out.println(TimeZone.getDefault());&lt;br/&gt;    &lt;span&gt;// JDK 1.8之后做法&lt;/span&gt;&lt;br/&gt;    System.out.println(ZoneId.systemDefault());&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;输出：&lt;br/&gt;Asia/Shanghai&lt;br/&gt;sun.util.calendar.ZoneInfo[id=&lt;span&gt;&quot;Asia/Shanghai&quot;&lt;/span&gt;,offset=&lt;span&gt;28800000&lt;/span&gt;,dstSavings=&lt;span&gt;0&lt;/span&gt;,useDaylight=&lt;span&gt;false&lt;/span&gt;,transitions=&lt;span&gt;29&lt;/span&gt;,lastRule=&lt;span&gt;null&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;二者结果是一样的，都是Asia/Shanghai。因为ZoneId方法底层就是依赖TimeZone，如图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.17177914110429449&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/crPesQVeyKINn8r0WeMibKibUXPlV1FRgiaicsGwqyKbk0OohO4mUdMRY9jHyRRtekFeiayql9xGv4EIVJlTJkU0nWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;326&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4669811320754717&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/crPesQVeyKINn8r0WeMibKibUXPlV1FRgiaxPHkGZXf3ySmia5TSZIY32rQ6O2UWX9BSSfCia1Qjvn8iak5a7bJqLlNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;424&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、指定字符串得到一个ZoneId：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    System.out.println(ZoneId.of(&lt;span&gt;&quot;Asia/Shanghai&quot;&lt;/span&gt;));&lt;br/&gt;    &lt;span&gt;// 报错：java.time.zone.ZoneRulesException: Unknown time-zone ID: Asia/xxx&lt;/span&gt;&lt;br/&gt;    System.out.println(ZoneId.of(&lt;span&gt;&quot;Asia/xxx&quot;&lt;/span&gt;));&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很明显，这个字符串也是不能随便写的。那么问题来了，可写的有哪些呢？同样的ZoneId提供了API供你获取到所有可用的字符串id，有兴趣的同学建议自行尝试：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test3&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ZoneId.getAvailableZoneIds();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、根据偏移量得到一个ZoneId：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test4&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ZoneId zoneId = ZoneId.ofOffset(&lt;span&gt;&quot;UTC&quot;&lt;/span&gt;, ZoneOffset.of(&lt;span&gt;&quot;+8&quot;&lt;/span&gt;));&lt;br/&gt;    System.out.println(zoneId);&lt;br/&gt;    &lt;span&gt;// 必须是大写的Z&lt;/span&gt;&lt;br/&gt;    zoneId = ZoneId.ofOffset(&lt;span&gt;&quot;UTC&quot;&lt;/span&gt;, ZoneOffset.of(&lt;span&gt;&quot;Z&quot;&lt;/span&gt;));&lt;br/&gt;    System.out.println(zoneId);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;输出：&lt;br/&gt;UTC+&lt;span&gt;08&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;&lt;br/&gt;UTC&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里第一个参数传的前缀，可用值为：&quot;GMT&quot;, &quot;UTC&quot;, or &quot;UT&quot;。当然还可以传空串，那就直接返回第二个参数ZoneOffset。若以上都不是就报错&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：根据偏移量得到的ZoneId内部并无现成时区规则可用，因此对于有夏令营的国家转换可能出问题，一般不建议这么去做。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、从日期里面获得时区：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test5&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    System.out.println(ZoneId.from(ZonedDateTime.now()));&lt;br/&gt;    System.out.println(ZoneId.from(ZoneOffset.of(&lt;span&gt;&quot;+8&quot;&lt;/span&gt;)));&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 报错：java.time.DateTimeException: Unable to obtain ZoneId from TemporalAccessor:&lt;/span&gt;&lt;br/&gt;    System.out.println(ZoneId.from(LocalDateTime.now()));&lt;br/&gt;    System.out.println(ZoneId.from(LocalDate.now()));&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然方法入参是TemporalAccessor，但是只接受带时区的类型，LocalXXX是不行的，使用时稍加注意。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;ZoneOffset&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;距离格林威治/UTC的时区偏移量，例如+02:00。值得注意的是它继承自ZoneId，所以也可当作一个ZoneId来使用的，当然并不建议你这么去做，请独立使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;时区偏移量是时区与格林威治/UTC之间的时间差。这通常是固定的小时数和分钟数。世界不同的地区有不同的时区偏移量。在ZoneId类中捕获关于偏移量如何随一年的地点和时间而变化的规则（主要是夏令时规则），所以继承自ZoneId。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、最小/最大偏移量：因为偏移量传入的是数字，这个是有限制的哦&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test6&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;最小偏移量：&quot;&lt;/span&gt; + ZoneOffset.MIN);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;最小偏移量：&quot;&lt;/span&gt; + ZoneOffset.MAX);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;中心偏移量：&quot;&lt;/span&gt; + ZoneOffset.UTC);&lt;br/&gt;    &lt;span&gt;// 超出最大范围&lt;/span&gt;&lt;br/&gt;    System.out.println(ZoneOffset.of(&lt;span&gt;&quot;+20&quot;&lt;/span&gt;));&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;输出：&lt;br/&gt;最小偏移量：-&lt;span&gt;18&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;&lt;br/&gt;最小偏移量：+&lt;span&gt;18&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;&lt;br/&gt;中心偏移量：Z&lt;br/&gt;&lt;br/&gt;java.time.DateTimeException: Zone offset hours not in valid range: value &lt;span&gt;20&lt;/span&gt; is not in the range -&lt;span&gt;18&lt;/span&gt; to &lt;span&gt;18&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、通过时分秒构造偏移量（使用很方便，推荐）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test7&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    System.out.println(ZoneOffset.ofHours(&lt;span&gt;8&lt;/span&gt;));&lt;br/&gt;    System.out.println(ZoneOffset.ofHoursMinutes(&lt;span&gt;8&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;));&lt;br/&gt;    System.out.println(ZoneOffset.ofHoursMinutesSeconds(&lt;span&gt;8&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;    System.out.println(ZoneOffset.ofHours(-&lt;span&gt;5&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 指定一个精确的秒数  获取实例（有时候也很有用处）&lt;/span&gt;&lt;br/&gt;    System.out.println(ZoneOffset.ofTotalSeconds(&lt;span&gt;8&lt;/span&gt; * &lt;span&gt;60&lt;/span&gt; * &lt;span&gt;60&lt;/span&gt;));&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 输出：&lt;/span&gt;&lt;br/&gt;+&lt;span&gt;08&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;&lt;br/&gt;+&lt;span&gt;08&lt;/span&gt;:&lt;span&gt;08&lt;/span&gt;&lt;br/&gt;+&lt;span&gt;08&lt;/span&gt;:&lt;span&gt;08&lt;/span&gt;:&lt;span&gt;08&lt;/span&gt;&lt;br/&gt;-&lt;span&gt;05&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;&lt;br/&gt;+&lt;span&gt;08&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看来，偏移量是能精确到秒的哈，只不过一般来说精确到分钟已经到顶了。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;设置默认时区&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ZoneId并没有提供设置默认时区的方法，但是通过文章可知ZoneId获取默认时区底层依赖的是&lt;code&gt;TimeZone.getDefault()&lt;/code&gt;方法，因此设置默认时区方式完全遵照TimeZone的方式即可（共三种方式，还记得吗？）。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;让人恼火的夏令时&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为有夏令时规则的存在，让操作日期/时间的复杂度大大增加。但还好JDK尽量的屏蔽了这些规则对使用者的影响。因此：推荐使用时区（ZoneId）转换日期/时间，一般情况下不建议使用偏移量ZoneOffset去搞，这样就不会有夏令时的烦恼啦。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;JSR 310时区相关性&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;java.util.Date类型它具有时区无关性，带来的弊端就是一旦涉及到国际化时间转换等需求时，使用Date来处理是很不方便的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JSR 310解决了Date存在的一系列问题：对日期、时间进行了分开表示（LocalDate、LocalTime、LocalDateTime），对本地时间和带时区的时间进行了分开管理。LocalXXX表示本地时间，也就是说是当前JVM所在时区的时间；ZonedXXX表示是一个&lt;strong&gt;带有时区&lt;/strong&gt;的日期时间，它们能非常方便的互相完成转换。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test8&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 本地日期/时间&lt;/span&gt;&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;================本地时间================&quot;&lt;/span&gt;);&lt;br/&gt;    System.out.println(LocalDate.now());&lt;br/&gt;    System.out.println(LocalTime.now());&lt;br/&gt;    System.out.println(LocalDateTime.now());&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 时区时间&lt;/span&gt;&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;================带时区的时间ZonedDateTime================&quot;&lt;/span&gt;);&lt;br/&gt;    System.out.println(ZonedDateTime.now()); &lt;span&gt;// 使用系统时区&lt;/span&gt;&lt;br/&gt;    System.out.println(ZonedDateTime.now(ZoneId.of(&lt;span&gt;&quot;America/New_York&quot;&lt;/span&gt;))); &lt;span&gt;// 自己指定时区&lt;/span&gt;&lt;br/&gt;    System.out.println(ZonedDateTime.now(Clock.systemUTC())); &lt;span&gt;// 自己指定时区&lt;/span&gt;&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;================带时区的时间OffsetDateTime================&quot;&lt;/span&gt;);&lt;br/&gt;    System.out.println(OffsetDateTime.now()); &lt;span&gt;// 使用系统时区&lt;/span&gt;&lt;br/&gt;    System.out.println(OffsetDateTime.now(ZoneId.of(&lt;span&gt;&quot;America/New_York&quot;&lt;/span&gt;))); &lt;span&gt;// 自己指定时区&lt;/span&gt;&lt;br/&gt;    System.out.println(OffsetDateTime.now(Clock.systemUTC())); &lt;span&gt;// 自己指定时区&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行程序，输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;================本地时间================&lt;br/&gt;&lt;span&gt;2021&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;17&lt;/span&gt;&lt;br/&gt;&lt;span&gt;09&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;:&lt;span&gt;40.703&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2021&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;17&lt;/span&gt;T09:&lt;span&gt;18&lt;/span&gt;:&lt;span&gt;40.703&lt;/span&gt;&lt;br/&gt;================带时区的时间ZonedDateTime================&lt;br/&gt;&lt;span&gt;2021&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;17&lt;/span&gt;T09:&lt;span&gt;18&lt;/span&gt;:&lt;span&gt;40.704&lt;/span&gt;+&lt;span&gt;08&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;[Asia/Shanghai]&lt;br/&gt;&lt;span&gt;2021&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;16&lt;/span&gt;T20:&lt;span&gt;18&lt;/span&gt;:&lt;span&gt;40.706&lt;/span&gt;-&lt;span&gt;05&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;[America/New_York]&lt;br/&gt;&lt;span&gt;2021&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;17&lt;/span&gt;T01:&lt;span&gt;18&lt;/span&gt;:&lt;span&gt;40.709&lt;/span&gt;Z&lt;br/&gt;================带时区的时间OffsetDateTime================&lt;br/&gt;&lt;span&gt;2021&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;17&lt;/span&gt;T09:&lt;span&gt;18&lt;/span&gt;:&lt;span&gt;40.710&lt;/span&gt;+&lt;span&gt;08&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2021&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;16&lt;/span&gt;T20:&lt;span&gt;18&lt;/span&gt;:&lt;span&gt;40.710&lt;/span&gt;-&lt;span&gt;05&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2021&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;17&lt;/span&gt;T01:&lt;span&gt;18&lt;/span&gt;:&lt;span&gt;40.710&lt;/span&gt;Z&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本地时间的输出非常“干净”，可直接用于显示。带时区的时间显示了该时间代表的是哪个时区的时间，毕竟不指定时区的时间是没有任何意义的。LocalXXX因为它具有时区无关性，因此它不能代表一个瞬间/时刻。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，关于LocalDateTime、OffsetDateTime、ZonedDateTime三者的跨时区转换问题，以及它们的详解，因为内容过多放在了下文专文阐述，保持关注。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;读取字符串为JSR 310类型&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个独立的日期时间类型字符串如2021-05-05T18:00-04:00它是没有任何意义的，因为没有时区无法确定它代表那个瞬间，这是理论当然也适合JSR 310类型喽。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;遇到一个日期时间格式字符串，要解析它一般有这两种情况：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;不带时区/偏移量的字符串：要么不理它说转换不了，要么就&lt;strong&gt;约定一个时区&lt;/strong&gt;（一般用系统默认时区），使用LocalDateTime来解析&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test11&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    String dateTimeStrParam = &lt;span&gt;&quot;2021-05-05T18:00&quot;&lt;/span&gt;;&lt;br/&gt;    LocalDateTime localDateTime = LocalDateTime.parse(dateTimeStrParam);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;解析后：&quot;&lt;/span&gt; + localDateTime);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;输出：&lt;br/&gt;解析后：&lt;span&gt;2021&lt;/span&gt;-&lt;span&gt;05&lt;/span&gt;-&lt;span&gt;05&lt;/span&gt;T18:&lt;span&gt;00&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;带时区字/偏移量的符串：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test12&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 带偏移量 使用OffsetDateTime &lt;/span&gt;&lt;br/&gt;    String dateTimeStrParam = &lt;span&gt;&quot;2021-05-05T18:00-04:00&quot;&lt;/span&gt;;&lt;br/&gt;    OffsetDateTime offsetDateTime = OffsetDateTime.parse(dateTimeStrParam);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;带偏移量解析后：&quot;&lt;/span&gt; + offsetDateTime);&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 带时区 使用ZonedDateTime &lt;/span&gt;&lt;br/&gt;    dateTimeStrParam = &lt;span&gt;&quot;2021-05-05T18:00-05:00[America/New_York]&quot;&lt;/span&gt;;&lt;br/&gt;    ZonedDateTime zonedDateTime = ZonedDateTime.parse(dateTimeStrParam);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;带时区解析后：&quot;&lt;/span&gt; + zonedDateTime);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;输出：&lt;br/&gt;带偏移量解析后：&lt;span&gt;2021&lt;/span&gt;-&lt;span&gt;05&lt;/span&gt;-&lt;span&gt;05&lt;/span&gt;T18:&lt;span&gt;00&lt;/span&gt;-&lt;span&gt;04&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;&lt;br/&gt;带时区解析后：&lt;span&gt;2021&lt;/span&gt;-&lt;span&gt;05&lt;/span&gt;-&lt;span&gt;05&lt;/span&gt;T18:&lt;span&gt;00&lt;/span&gt;-&lt;span&gt;04&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;[America/New_York]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请注意&lt;strong&gt;带时区解析后&lt;/strong&gt;这个结果：字符串参数偏移量明明是-05，为毛转换为ZonedDateTime后偏移量成为了-04呢？？？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里是我故意造了这么一个case引起你的重视，对此结果我做如下解释：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3365921787709497&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/crPesQVeyKINn8r0WeMibKibUXPlV1FRgia4cEIky0fvJhv2d9HxiarcDI0x9oBP78WM36B7ayiajEBiczVRdRYeS3iag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;716&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图，在2021.03.14 - 2021.11.07期间，纽约的偏移量是-4，其余时候是-5。本例的日期是2021-05-05处在夏令时之中，因此偏移量是-4，这就解释了为何你显示的写了-5最终还是成了-4。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;JSR 310格式化&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对JSR 310日期时间类型的格式化/解析，有个专门的类&lt;code&gt;java.time.format.DateTimeFormatter&lt;/code&gt;用于处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DateTimeFormatter也是一个不可变的类，所以是线程安全的，比SimpleDateFormat靠谱多了吧。另外它还内置了非常多的格式化模版&lt;strong&gt;实例&lt;/strong&gt;供以使用，形如：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;格式化器&lt;/th&gt;&lt;th&gt;示例&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;ofLocalizedDate(dateStyle)&lt;/td&gt;&lt;td&gt;&#x27;2021-01-03&#x27;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ofLocalizedTime(timeStyle)&lt;/td&gt;&lt;td&gt;&#x27;10:15:30&#x27;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ofLocalizedDateTime(dateTimeStyle)&lt;/td&gt;&lt;td&gt;&#x27;3 Jun 2021 11:05:30&#x27;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;ISO_LOCAL_DATE&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;&#x27;2021-12-03&#x27;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;ISO_LOCAL_TIME&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;&#x27;10:15:30&#x27;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;ISO_LOCAL_DATE_TIME&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;&#x27;2021-12-03T10:15:30&#x27;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ISO_OFFSET_DATE_TIME&lt;/td&gt;&lt;td&gt;&#x27;2021-12-03T10:15:30+01:00&#x27;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ISO_ZONED_DATE_TIME&lt;/td&gt;&lt;td&gt;&#x27;2021-12-03T10:15:30+01:00[Europe/Paris]&#x27;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test13&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    System.out.println(DateTimeFormatter.ISO_LOCAL_DATE.format(LocalDate.now()));&lt;br/&gt;    System.out.println(DateTimeFormatter.ISO_LOCAL_TIME.format(LocalTime.now()));&lt;br/&gt;    System.out.println(DateTimeFormatter.ISO_LOCAL_DATE_TIME.format(LocalDateTime.now()));&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;输出：&lt;br/&gt;&lt;span&gt;2021&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;17&lt;/span&gt;&lt;br/&gt;&lt;span&gt;22&lt;/span&gt;:&lt;span&gt;43&lt;/span&gt;:&lt;span&gt;21.398&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2021&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;17&lt;/span&gt;T22:&lt;span&gt;43&lt;/span&gt;:&lt;span&gt;21.4&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;若想自定义模式pattern，和Date一样它也可以自己指定任意的pattern &lt;strong&gt;日期/时间模式&lt;/strong&gt;。由于本文在Date部分详细介绍了日期/时间模式，各个字母代表什么意思以及如何使用，这里就不再赘述了哈。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;虽然DateTimeFormatter支持的模式比Date略有增加，但大体还保持一致，个人觉得这块无需再花精力。若真有需要再查官网也不迟&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test14&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&lt;span&gt;&quot;第Q季度 yyyy-MM-dd HH:mm:ss&quot;&lt;/span&gt;, Locale.US);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 格式化输出&lt;/span&gt;&lt;br/&gt;    System.out.println(formatter.format(LocalDateTime.now()));&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 解析&lt;/span&gt;&lt;br/&gt;    String dateTimeStrParam = &lt;span&gt;&quot;第1季度 2021-01-17 22:51:32&quot;&lt;/span&gt;;&lt;br/&gt;    LocalDateTime localDateTime = LocalDateTime.parse(dateTimeStrParam, formatter);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;解析后的结果：&quot;&lt;/span&gt; + localDateTime);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Q/q：季度，如3; 03; Q3; 3rd quarter。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最佳实践&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每每说到JSR 310日期/时间时我都会呼吁，保持惯例我这里继续啰嗦一句：放弃Date甚至禁用Date，使用JSR 310日期/时间吧，它才是日期时间处理的最佳实践。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，在使用期间关于制定时区（默认时区时）依旧有一套我心目中的最佳实践存在，这里分享给你：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;永远显式的指定你需要的时区，即使你要获取的是默认时区&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 方式一：普通做法&lt;/span&gt;&lt;br/&gt;LocalDateTime.now();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 方式二：最佳实践&lt;/span&gt;&lt;br/&gt;LocalDateTime.now(ZoneId.systemDefault());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上代码二者效果一模一样。但是方式二是最佳实践。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理由是：这样做能让代码带有&lt;strong&gt;明确的意图&lt;/strong&gt;，消除模棱两可的可能性，即使获取的是默认时区。拿方式一来说吧，它就存在意图不明确的地方：到底是代码编写者忘记指定时区欠考虑了，还是就想用默认时区呢？这个答案如果不通读上下文是无法确定的，从而造成了不必要的沟通维护成本。因此即使你是要获取默认时区，也请显示的用ZoneId.systemDefault()写上去。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;使用JVM的默认时区需当心，建议时区和当前会话保持绑定&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个最佳实践在特殊场景用得到。这么做的理由是：JVM的默认时区通过静态方法TimeZone#setDefault()可全局设置，因此JVM的任何一个线程都可以随意更改默认时区。若关于时间处理的代码&lt;strong&gt;对时区非常敏感&lt;/strong&gt;的话，最佳实践是你把时区信息和当前会话绑定，这样就可以不用再受到其它线程潜在影响了，确保了健壮性。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;说明：会话可能只是当前请求，也可能是一个Session，具体case具体分析&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;✍总结&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI0MTUwOTgyOQ==&amp;amp;mid=2247491787&amp;amp;idx=1&amp;amp;sn=37e8b0af5a7ffda54003d4280a70d638&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;上篇文章&lt;/a&gt; 对日期时间相关概念的铺垫，加上本文的实操代码演示，达到弄透Java对日期时间的处理基本不成问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两篇文章的内容较多，信息量均比较大，消化起来需要些时间。一方面我建议你先搜藏留以当做参考书备用，另一方面建议多实践，代码这东西只有多写写才能有更深体会。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后面会&lt;strong&gt;再用3 -4篇文章&lt;/strong&gt;对这前面这两篇的细节、使用场景进行补充，比如如何去匹配ZoneId和Offset的对应关系，LocalDateTime、OffsetDateTime、ZonedDateTime跨时区互转问题、在Spring MVC场景下使用的最佳实践等等，敬请关注，一起进步。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;♨本文思考题♨&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看完了不一定懂，看懂了不一定会。来，文末3个思考题帮你复盘：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Date类型如何处理夏令时？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ZoneId和ZoneOffset有什么区别？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;平时项目若遇到日期时间的处理，有哪些最佳实践？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;☀推荐阅读☀&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;♚声明♚&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文所属专栏：&lt;strong&gt;JDK日期时间&lt;/strong&gt;，公号后台回复专栏名即可获取全部内容，或加我 fsx1056342982 私聊索取。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;分享、成长，拒绝浅藏辄止。关注【BAT的乌托邦】，回复关键字&lt;strong&gt;专栏&lt;/strong&gt;有Spring技术栈、中间件等小而美的&lt;strong&gt;原创专栏&lt;/strong&gt;供以免费学习。本文已被 https://www.yourbatman.cn 收录。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文是 A哥(YourBatman)原创文章，未经允许/开白不得转载，谢谢合作。&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/crPesQVeyKINn8r0WeMibKibUXPlV1FRgiaicicOcMguMTwczdP1MibkdpuoKjVk3xnFTsHV0gTUHOeoOkz5NR56N0Dg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3ec1f1325fb8ae48f8602e5ef5bea03b</guid>
<title>把 VSCode 打造成技术写作神器</title>
<link>https://toutiao.io/k/4n0p7ex</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;作为技术开发，大家平时肯定需要记录技术笔记。甚至有的同学还开通可自己的技术博客或者技术公众号进行创作。&lt;/p&gt;&lt;p&gt;这个时候有套趁手的写作工具尤为重要，节省下时间好好休息一下，对于咱们程序员来说更加重要。因为最近在自己学习golang，为了找个顺手的IDE尝试了一下VScode，用后总结两个字：“真香”。集编码、写作、&lt;span&gt;划水&lt;/span&gt; 于一身。&lt;/p&gt;&lt;p&gt;话不多说，我们今天先说说写作这部分。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;文字内容&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;文字写作推荐大家使用markdown。大家的经历应该主要放在文字内容上，可以节省大家的排版时间。虽然marakdown的语法非常简单，但是一款&lt;/span&gt;称&lt;span&gt;手的markdown编辑器也非常重要。&lt;/span&gt;&lt;span&gt;因为今天的主角的VScode，所以大家可以直接在安装VScode中安装一下markdown插件即可，比如：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Markdown All in One&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;markdownlint&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3683883011823273&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/bymGBmLC3zHHpBOxu9TYZst8Q2qU06AC5k75ibya1PicGSBldZ4m7Gia2nc7hHHEYbMQDQFknIy4iak1YuEWyZ4O3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1607&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;现在大部分博客平台都支持markdown，可以直接讲我们写的内容复制过去，可惜的是公众号现在还不支持。所以要借助Md2all在线渲染网站，可以一键复制到公众号，并且还可以美化一些样式，比较简约美观一些。还可以选择不同主题或者自己改一些CSS样式，像下面这样：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.47879109225874866&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/bymGBmLC3zHHpBOxu9TYZst8Q2qU06AC98qdDL1nWLc0j2tibtYaFoV2o3LQgHSuITemYV3fhAwoKSptJgCFd8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1886&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;h3&gt;&lt;span&gt;图片内容&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;技术写作经常会画一些流程图，架构图。尤其图解会让复杂的问题更加直观，更容易理解。所以有个方便的画图软件很重要。原来一直用processon在线画图，但是因为个人免费用户有文件个数限制，所以不太友好（还是因为穷，哈哈哈）。最近一直用draw.io，并且支持将文件自动存储到github，用起来很方便。尤其现在VScode还有对应的插件，写字、画图都在一个编辑器里，沉浸感更强了，防止思路再来回切软件时被打断。下面&lt;/span&gt;是在&lt;span&gt;VScode里创建一个drawio文件：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5170701427684667&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/bymGBmLC3zHHpBOxu9TYZst8Q2qU06ACbv1fyvNKEE3MHMlD5hduTFn9zXtPFwZJfsHJdDhAV9bRHzic5kcVOYQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1611&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;画完图导出为图片，然后借助PicGo插件+github+jsDelivr（不了解的同学可以搜索一下，网上很多详细文档），自动上传图片到github图床并自动插入到markdown文件中。VScode也有PicGo对应的插件，所以这些操作也全&lt;/span&gt;在&lt;span&gt;VScode中完成，很方便。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;代码&lt;/span&gt;&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;Talk is cheap. Show me the code.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;对于文章中的代码，有人习惯用markdown本身的代码片段，也有人习惯放代码截图。但是截图很难截的统一大小，导致不太美观。这里推荐用插件Polacode-2020。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5628891656288917&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/bymGBmLC3zHHpBOxu9TYZst8Q2qU06ACREkKHGVuicDC6qmibbZaBGV1fBzN3swZGib3wRryndr3mn2y8CUSRzwDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;803&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;可以把代码保存为统一大小的图片，然后使用图片部分的插件，自动将代码图片插入到文章中。&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;最后我们再把上面提到的插件汇总一下，希望对你的写作有所帮助：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Markdown All in One&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;markdownlint&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Draw.io intergration&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;PicGo&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Polacode-2020&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大家如果喜欢，记得关注哦&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/bymGBmLC3zHHpBOxu9TYZst8Q2qU06ACgJyP4Quveae3pll9icg8Nl6ZWQWzf8XsqSnRynaQ6LzT42sC7e5vicbw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;19&quot;/&gt;。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;430&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/bymGBmLC3zFrU5uVDYrTUQD0HibXxMoNcR08Pa4fbKq0GxBICEfUOvRW3rfe1qpsvzTm3Y7KGMcJ2hOSHNicOyvQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;&gt;赞助呼噜个罐头吃&lt;/p&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>92f263ad4b88c7423703383c7e160bf3</guid>
<title>数字指纹有什么用？赶紧来了解一下</title>
<link>https://toutiao.io/k/tjed3sk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在大文件上传的场景中，为了提高大文件上传的用户体验，我们会支持断点续传。在上传过程中，我们会对大文件进行分片处理，然后使用 md5 算法计算分片的哈希值，再把该分片的内容和其对应的哈希值一起提交到服务器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当服务器接收到分片对应的哈希值时，会先查询该哈希值是否已经存在。如果存在，则表示该分片已经上传过。这时可以返回大文件已上传的字节数，从而让客户端可以继续上传剩余的内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实分片对应的哈希值也可以被称为分片的 “数字指纹”，那么什么是 “数字指纹” 呢？要理解 “数字指纹”，我们需要先来了解一下什么是消息摘要算法。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;一、什么是消息摘要算法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息摘要算法是密码学算法中非常重要的一个分支，它通过对所有数据提取指纹信息以实现数据签名、数据完整性校验等功能，由于其不可逆性，有时候会被用做敏感信息的加密。消息摘要算法也被称为哈希（Hash）算法或散列算法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;任何消息经过散列函数处理后，都会获得唯一的散列值，这一过程称为 “消息摘要”，其散列值称为 “数字指纹”，其算法自然就是 “消息摘要算法” 了。换句话说，如果其数字指纹一致，就说明其消息是一致的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jQmwTIFl1V2nGM76Y6bicVfRuTib5fvvjtsicmD9OZNIpzA72PD0wkRBVr9oV8SHc2vKdzxHWPLrvHxPEEQQfzDRA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6772727272727272&quot; data-w=&quot;660&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（图片来源 —— https://zh.wikipedia.org/wiki/散列函數）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息摘要算法不存在密钥的管理与分发问题，适合于分布式网络上使用。消息摘要算法主要应用在 “数字签名” 领域，作为对明文的摘要算法。著名的摘要算法有 RSA 公司的 MD5 算法和 SHA-1 算法及其大量的变体。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1 消息摘要算法的特点&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;无论输入的消息有多长，计算出来的消息摘要的长度总是固定的。&lt;/strong&gt;例如应用 MD5 算法摘要的消息有 128 个比特位，用 SHA-1 算法摘要的消息最终有 160 个比特位的输出，SHA-1的变体可以产生 192 个比特位和 256 个比特位的消息摘要。一般认为，摘要的最终输出越长，该摘要算法就越安全。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;消息摘要看起来是 “随机的”。&lt;/strong&gt;这些比特看上去是胡乱的杂凑在一起的，可以用大量的输入来检验其输出是否相同，一般，不同的输入会有不同的输出，而且输出的摘要消息可以通过随机性检验。&lt;strong&gt;一般地，只要输入的消息不同，对其进行摘要以后产生的摘要消息也必不相同；但相同的输入必会产生相同的输出。&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;消息摘要函数是单向函数，即只能进行正向的信息摘要，而无法从摘要中恢复出任何的消息，甚至根本就找不到任何与原信息相关的信息。&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;好的摘要算法，没有人能从中找到 “碰撞” 或者说极度难找到，虽然 “碰撞” 是肯定存在的（碰撞即不同的内容产生相同的摘要）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2 消息摘要算法的家谱&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;消息摘要算法主要分为三大类：MD（Message Digest，消息摘要算法）、SHA-1（Secure Hash Algorithm，安全散列算法）和 MAC（Message Authentication Code，消息认证码算法）。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MD 系列算法包括 MD2、MD4 和 MD5 共 3 种算法；SHA 算法主要包括其代表算法 SHA-1 和 SHA-1 算法的变种 SHA-2 系列算法（包含 SHA-224、SHA-256、SHA-384 和 SHA-512）；MAC 算法综合了上述两种算法，主要包括 HmacMD5、HmacSHA1、HmacSHA256、HmacSHA384 和 HmacSHA512 算法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽管上述内容列举了各种消息摘要算法，但仍不能满足应用需要。基于这些消息摘要算法，又衍生出了 RipeMD 系列（包含 RipeMD128、RipeMD160、RipeMD256、RipeMD320）、Tiger、GOST3411 和 Whirlpool 算法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于大多数前端开发者来说，接触得比较多的应该是 MD5 算法。所以，接下来阿宝哥将重点介绍 MD5 算法。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;二、什么是 MD5 算法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MD5（Message Digest Algorithm 5，消息摘要算法版本5），它由 MD2、MD3、MD4 发展而来，由 Ron Rivest（RSA 公司）在 1992 年提出，目前被广泛应用于数据完整性校验、数据（消息）摘要、数据签名等。&lt;strong&gt;MD2、MD4、MD5 都产生 16 字节（128 位）的校验值，一般用 32 位十六进制数表示。MD2 的算法较慢但相对安全，MD4 速度很快，但安全性下降，MD5 比 MD4 更安全、速度更快。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着计算机技术的发展和计算水平的不断提高，MD5 算法暴露出来的漏洞也越来越多。1996 年后被证实存在弱点，可以被加以破解，对于需要高度安全性的数据，专家一般建议改用其他算法，如 SHA-2。2004 年，证实 MD5 算法无法防止碰撞（collision），因此不适用于安全性认证，如 SSL 公开密钥认证或是数字签名等用途。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 MD5 特点&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;稳定、运算速度快。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;压缩性：输入任意长度的数据，输出长度固定（128 比特位）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;运算不可逆：已知运算结果的情况下，无法通过通过逆运算得到原始字符串。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;高度离散：输入的微小变化，可导致运算结果差异巨大。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 MD5 散列&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;128 位的 MD5 散列在大多数情况下会被表示为 32 位十六进制数字。以下是一个 43 位长的仅 ASCII 字母列的 MD5 散列：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;MD5(&quot;The quick brown fox jumps over the lazy dog&quot;)&lt;br/&gt;= 9e107d9d372bb6826bd81d3542a419d6&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即使在原文中作一个小变化（比如把 dog 改为 cog，只改变一个字符）其散列也会发生巨大的变化：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;MD5(&quot;The quick brown fox jumps over the lazy cog&quot;)&lt;br/&gt;= 1055d3e698d289f2af8663725127bd4b&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着我们再来举几个 MD5 散列的例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;MD5(&quot;&quot;) -&amp;gt; d41d8cd98f00b204e9800998ecf8427e &lt;br/&gt;MD5(&quot;semlinker&quot;) -&amp;gt; 688881f1c8aa6ffd3fcec471e0391e4d&lt;br/&gt;MD5(&quot;kakuqo&quot;) -&amp;gt; e18c3c4dd05aef020946e6afbf9e04ef&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;三、MD5 算法的用途&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1 防止被篡改&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1.1 文件分发防篡改&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在互联网上分发软件安装包时，出于安全性考虑，为了防止软件被篡改，比如在软件安装程序中添加木马程序。软件开发者通常会使用消息摘要算法，比如 MD5 算法产生一个与文件匹配的数字指纹，这样接收者在接收到文件后，就可以利用一些现成的工具来检查文件完整性。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jQmwTIFl1V2nGM76Y6bicVfRuTib5fvvjtooq851ggk6AIicEtibKn4YGYQficDT9ewWvu7QicIHVE7QUPcuHv8icYo7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;1.1071428571428572&quot; data-w=&quot;700&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（图片来源 —— https://en.wikipedia.org/wiki/MD5）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们来举一个实际的例子，下图是 MySQL Community Server 8.0.19 版本的下载页，该下载页通过 MD5 算法分别计算出不同软件包的数字指纹，具体如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V2nGM76Y6bicVfRuTib5fvvjtKe76vDZRJLt05jf6RvkiaDialuSfCLX8dpg1AjR3MJCFNyaaoM1lBL6A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.2740740740740741&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（图片来源 —— https://dev.mysql.com/downloads/mysql/）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当用户从官网上下载到对应的安装包之后，可以利用一些 MD5 校验工具对已下载的文件进行校验，然后比对最终的 MD5 数字指纹。&lt;strong&gt;若结果与官网公布的数字指纹一致，则表示该安装包未经过任何修改是安全的，基本可以放心安装&lt;/strong&gt;。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1.2 消息传输防篡改&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设在网络上你需要发送电子文档给你的朋友，在文件发送前，先对文档的内容进行 MD5 运算，得出该电子文档的 “数字指纹”，并把该 “数字指纹” 随电子文档一同发送给对方。当对方接收到电子文档之后，也使用 MD5 算法对文档的内容进行哈希运算，在运算完成后也会得到一个对应 “数字指纹”，当该指纹与你所发送文档的 “数字指纹” 一致时，表示文档在传输过程中未被篡改。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2 信息保密&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在互联网初期很多网站在数据库中以明文的形式存储用户的密码，这存在很大的安全隐患，比如数据库被黑客入侵，从而导致网站用户信息的泄露。针对这个问题，一种解决方案是在保存用户密码时，不再使用明文，而是使用消息摘要算法，比如 MD5 算法对明文密码进行哈希运算，然后把运算的结果保存到数据库中。使用上述方案，避免了在数据库中以明文方式保存密码，提高了系统的安全性，不过这种方案并不安全，后面我们会详细分析。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V2nGM76Y6bicVfRuTib5fvvjtTpufgwmmIHKQFwibiaafOOd7jYbwnTFyfxx3xHPZtgfhADm2JjNZZ9wg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.3340961098398169&quot; data-w=&quot;874&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当用户登录时，登录系统对用户输入的密码执行 MD5 哈希运算，然后再使用用户 ID 和密码对应的 MD5 “数字指纹” 进行用户认证。若认证通过，则当前的用户可以正常登录系统。用户密码经过 MD5 哈希运算后存储的方案至少有两个好处：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;防内部攻击：因为在数据库中不会以明文的方式保存密码，因此可以避免系统中用户的密码被具有系统管理员权限的人员知道。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;防外部攻击：网站数据库被黑客入侵，黑客只能获取经过 MD5 运算后的密码，而不是用户的明文密码。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;四、MD5 算法使用示例&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Node.js 环境中，我们可以使用 &lt;code&gt;crypto&lt;/code&gt; 原生模块提供的 md5 实现，当然也可以使用主流的 MD5 第三方库，比如 md5 这个可以同时运行在服务端和客户端的第三方库。在介绍具体使用前，我们需要提前安装 md5 这个第三方库，具体安装方式如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; npm install md5 --save&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.1 crypto 模块使用示例&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; crypto = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&quot;crypto&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; msg = &lt;span&gt;&quot;阿宝哥&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;md5&lt;/span&gt;(&lt;span&gt;data&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; hash = crypto.createHash(&lt;span&gt;&quot;md5&quot;&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; hash.update(data).digest(&lt;span&gt;&quot;hex&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;Node.js Crypto MD5: &quot;&lt;/span&gt; + msg + &lt;span&gt;&quot; -&amp;gt; &quot;&lt;/span&gt; + md5(msg));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2 MD5 库使用示例&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; md5 = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;md5&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; msg = &lt;span&gt;&quot;阿宝哥&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;MD5 Lib MD5: &quot;&lt;/span&gt; + msg + &lt;span&gt;&quot; -&amp;gt; &quot;&lt;/span&gt; + md5(msg));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上示例代码正常运行后，在控制台中会输出以下结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Node.js Crypto MD5: 阿宝哥 -&amp;gt; 8eec7fcf817f7340b791b32ecdbed570&lt;br/&gt;MD5 Lib MD5: 阿宝哥 -&amp;gt; 8eec7fcf817f7340b791b32ecdbed570&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;五、MD5 算法的缺陷&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哈希碰撞是指不同的输入却产生了相同的输出，好的哈希算法，应该没有人能从中找到 “碰撞” 或者说极度难找到，虽然 “碰撞” 是肯定存在的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2005 年山东大学的王小云教授发布算法可以轻易构造 MD5 碰撞实例，此后 2007 年，有国外学者在王小云教授算法的基础上，提出了更进一步的 MD5 前缀碰撞构造算法 “chosen prefix collision”，此后还有专家陆续提供了MD5 碰撞构造的开源的库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2009 年，中国科学院的谢涛和冯登国仅用了 220.96 的碰撞算法复杂度，破解了 MD5 的碰撞抵抗，该攻击在普通计算机上运行只需要数秒钟。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;MD5 碰撞很容易构造，基于 MD5 来验证数据完整性已不可靠，考虑到近期谷歌已成功构造了 SHA-1（英语：Secure Hash Algorithm 1，中文名：安全散列算法1）的碰撞实例，对于数据完整性，应使用 SHA256 或更强的算法代替。&lt;/strong&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.1 MD5 碰撞样本&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们先来看一下 MD5 碰撞的样本：&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.1.1 HEX（十六进制）样本 A1&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;4dc968ff0ee35c209572d4777b721587&lt;br/&gt;d36fa7b21bdc56b74a3dc0783e7b9518&lt;br/&gt;afbfa200a8284bf36e8e4b55b35f4275&lt;br/&gt;93d849676da0d1555d8360fb5f07fea2&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.1.2 HEX（十六进制）样本 A2&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;4dc968ff0ee35c209572d4777b721587&lt;br/&gt;d36fa7b21bdc56b74a3dc0783e7b9518&lt;br/&gt;afbfa202a8284bf36e8e4b55b35f4275&lt;br/&gt;93d849676da0d1d55d8360fb5f07fea2&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两个样本之间的差异如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V2nGM76Y6bicVfRuTib5fvvjtbqL7uOSmoVFvLk6aq5owFDIib0b1tXa0wnsJBFIiamb458JS1BwnibtjA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.1574074074074074&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2 验证 MD5 碰撞&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来使用 Node.js 实际验证一下样本 A1 和样本 A2 经过 MD5 运算后输出的结果是否一致：&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2.1 设置样本数据&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; sample1 = &lt;span&gt;`&lt;br/&gt;4dc968ff0ee35c209572d4777b721587&lt;br/&gt;d36fa7b21bdc56b74a3dc0783e7b9518&lt;br/&gt;afbfa200a8284bf36e8e4b55b35f4275&lt;br/&gt;93d849676da0d1555d8360fb5f07fea2`&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; sample2 = &lt;span&gt;`&lt;br/&gt;4dc968ff0ee35c209572d4777b721587&lt;br/&gt;d36fa7b21bdc56b74a3dc0783e7b9518&lt;br/&gt;afbfa202a8284bf36e8e4b55b35f4275&lt;br/&gt;93d849676da0d1d55d8360fb5f07fea2&lt;br/&gt;`&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2.2 定义 getHashResult 方法&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;function &lt;span&gt;getHashResult&lt;/span&gt;&lt;span&gt;(hexString)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; hash = crypto.createHash(&lt;span&gt;&quot;md5&quot;&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; buffer = Buffer.from(hexString.replace(/\s/g, &lt;span&gt;&quot;&quot;&lt;/span&gt;), &lt;span&gt;&quot;hex&quot;&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; hash.update(buffer).digest(&lt;span&gt;&quot;hex&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2.3  执行碰撞检测&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; sample1Md5 = getHashResult(sample1);&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; sample2Md5 = getHashResult(sample2);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (sample1Md5 === sample2Md5) {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`出现 MD5 碰撞: &lt;span&gt;${sample1Md5}&lt;/span&gt;`&lt;/span&gt;);&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`未出现 MD5 碰撞`&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上代码成功运行后，在控制台中会输出以下结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;出现 MD5 碰撞: 008ee33a9d58b51cfeb425b0959121c9&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你对其它 MD5 碰撞的样本感兴趣，可以查看 MD5碰撞的一些例子 这篇文章。由于基于 MD5 来验证数据完整性不太可靠，所以 Node.js 使用了 SHA256 算法来确保数据的完整性。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V2nGM76Y6bicVfRuTib5fvvjtwnT1gAKNC4AKkc7gQ6QYn8fCFMiatvXvtxmgUrjdycId70K9NkfyZ6Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.21666666666666667&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（图片来源 —— https://nodejs.org/download/release/v15.6.0/SHASUMS256.txt.asc）&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;六、MD5 密码安全性&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.1 MD5 密文反向查询&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面我们已经提到通过对用户密码进行 MD5 运算可以提高系统的安全性。但实际上，这样的安全性还是不高。为什么呢？因为只要输入相同就会产生相同的输出。接下来我们来举一个示例，字符串 &lt;code&gt;123456789&lt;/code&gt; 是一个很常用的密码，它经过 MD5 运算后会生成一个对应的哈希值：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;MD5(&lt;span&gt;&quot;123456789&quot;&lt;/span&gt;) -&amp;gt; 25f9e794323b453885f5181f1b624d0b&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于输入相同就会产生相同的结果，因此攻击者就可以根据哈希结果反推输入。其中一种常见的破解方式就是使用彩虹表。&lt;strong&gt;彩虹表是一个用于加密散列函数逆运算的预先计算好的表，常用于破解加密过的密码散列。&lt;/strong&gt; 查找表常常用于包含有限字符固定长度纯文本密码的加密。&lt;strong&gt;这是以空间换时间的典型实践，在每一次尝试都计算的暴力破解中使用更少的计算能力和更多的储存空间，但却比简单的每个输入一条散列的翻查表使用更少的储存空间和更多的计算性能。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前网上某些站点，比如 cmd5.com 已经为我们提供了 MD5 密文的反向查询服务，我们以 &lt;code&gt;MD5(&quot;123456789&quot;)&lt;/code&gt; 生成的结果，做个简单的验证，具体如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V2nGM76Y6bicVfRuTib5fvvjtW8u1osp4zFUlAQVOMWvib18v4Bob4d4uVNb1A4HHnSB7sBNXVqnuyNA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.3194444444444444&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为 &lt;strong&gt;123456789&lt;/strong&gt; 是很常见的密码，因此该网站能够反向得出正确结果那就不足为奇了。以下是 cmd5 网站的站点说明，大家可以参考一下，感兴趣的小伙伴可以亲自验证一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在我们已经知道如果用户的密码相同 MD5 的值就会一样，通过一些 MD5 密文的反向查询网站，密码大概率会被解析出来，这样使用相同密码的用户就会受到影响。那么该问题如何解决呢？答案是密码加盐。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.2 密码加盐&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;盐（Salt），在密码学中，是指在散列之前将散列内容（例如：密码）的任意固定位置插入特定的字符串。&lt;/strong&gt;这个在散列中加入字符串的方式称为 “加盐”。其作用是让加盐后的散列结果和没有加盐的结果不相同，在不同的应用情景中，这个处理可以增加额外的安全性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在大部分情况，盐是不需要保密的。盐可以是随机产生的字符串，其插入的位置可以也是随意而定。如果这个散列结果在将来需要进行验证（例如：验证用户输入的密码），则需要将已使用的盐记录下来。为了便于理解，我们来举个简单的示例。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.2.1 Node.js MD5 加盐示例&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; crypto = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&quot;crypto&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;cryptPwd&lt;/span&gt;(&lt;span&gt;password, salt&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; saltPassword = password + &lt;span&gt;&quot;:&quot;&lt;/span&gt; + salt;&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;原始密码：%s&quot;&lt;/span&gt;, password);&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;加盐后的密码：%s&quot;&lt;/span&gt;, saltPassword);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; md5 = crypto.createHash(&lt;span&gt;&quot;md5&quot;&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; result = md5.update(saltPassword).digest(&lt;span&gt;&quot;hex&quot;&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;加盐密码的md5值：%s&quot;&lt;/span&gt;, result);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;cryptPwd(&lt;span&gt;&quot;123456789&quot;&lt;/span&gt;,&lt;span&gt;&quot;exe&quot;&lt;/span&gt;);&lt;br/&gt;cryptPwd(&lt;span&gt;&quot;123456789&quot;&lt;/span&gt;,&lt;span&gt;&quot;eft&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上示例代码正常运行后，在控制台中会输出以下结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;原始密码：123456789&lt;br/&gt;加盐后的密码：123456789:exe&lt;br/&gt;加盐密码的md5值：3328003d9f786897e0749f349af490ca&lt;br/&gt;原始密码：123456789&lt;br/&gt;加盐后的密码：123456789:eft&lt;br/&gt;加盐密码的md5值：3c45dd21ba03e8216d56dce8fe5ebabf&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过观察以上结果，我们发现原始密码一致，但使用的盐值不一样，最终生成的 MD5 哈希值差异也比较大。此外为了提高破解的难度，我们可以随机生成盐值并且提高盐值的长度。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.3 bcrypt&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哈希加盐的方式确实能够增加攻击者的成本，但是今天来看还远远不够，我们需要一种更加安全的方式来存储用户的密码，这也就是今天被广泛使用的 &lt;code&gt;bcrypt&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;bcrypt 是一个由 Niels Provos 以及 David Mazières 根据 Blowfish 加密算法所设计的密码散列函数，于 1999 年在 USENIX 中展示。&lt;code&gt;bcrypt&lt;/code&gt; 这一算法就是为哈希密码而专门设计的，所以它是一个执行相对较慢的算法，这也就能够减少攻击者每秒能够处理的密码数量，从而避免攻击者的字典攻击。&lt;strong&gt;实现中 bcrypt 会使用一个加盐的流程以防御彩虹表攻击，同时 bcrypt 还是适应性函数，它可以借由增加迭代之次数来抵御日益增进的电脑运算能力透过暴力法破解。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由 bcrypt 加密的文件可在所有支持的操作系统和处理器上进行转移。它的口令必须是 8 至 56 个字符，并将在内部被转化为 448 位的密钥。然而，所提供的所有字符都具有十分重要的意义。密码越强大，您的数据就越安全。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们以 Node.js 平台的 bcryptjs 为例，介绍一下如何使用 &lt;code&gt;bcrypt&lt;/code&gt; 算法来处理用户的密码。首先我们需要先安装 &lt;code&gt;bcryptjs&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; npm install bcryptjs --save&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.3.1 使用 bcryptjs 处理密码&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; bcrypt = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&quot;bcryptjs&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; password = &lt;span&gt;&quot;123456789&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; saltRounds = &lt;span&gt;10&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;async&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;bcryptHash&lt;/span&gt;(&lt;span&gt;str, saltRounds&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; hashedResult;&lt;br/&gt;  &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; salt = &lt;span&gt;await&lt;/span&gt; bcrypt.genSalt(saltRounds);&lt;br/&gt;    hashedResult = &lt;span&gt;await&lt;/span&gt; bcrypt.hash(str, salt);&lt;br/&gt;  } &lt;span&gt;catch&lt;/span&gt; (error) {&lt;br/&gt;    &lt;span&gt;throw&lt;/span&gt; error;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; hashedResult;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;bcryptHash(password, saltRounds).then(&lt;span&gt;console&lt;/span&gt;.log);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上示例代码正常运行后，在控制台中会输出以下结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$2a&lt;/span&gt;&lt;span&gt;$10&lt;/span&gt;&lt;span&gt;$O1SrEy3KsgN0NQdQjaSU6OxjxDo0jf&lt;/span&gt;.j/e2goSwSEu4esz9i58dRm&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很明显密码 &lt;code&gt;123456789&lt;/code&gt; 经过 bcrypt 的哈希运算后，得到了一串读不懂的 “乱码”。这里我们已经完成第一步，即用户登录密码的加密。下一步我们要实现登录密码的比对，即要保证用户输入正确的密码后，能正常登录系统。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.3.2 使用 bcryptjs 校验密码&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;async&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;bcryptCompare&lt;/span&gt;(&lt;span&gt;str, hashed&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; isMatch;&lt;br/&gt;  &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    isMatc = &lt;span&gt;await&lt;/span&gt; bcrypt.compare(str, hashed);&lt;br/&gt;  } &lt;span&gt;catch&lt;/span&gt; (error) {&lt;br/&gt;    &lt;span&gt;throw&lt;/span&gt; error;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; isMatch;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;bcryptCompare(&lt;br/&gt;  &lt;span&gt;&quot;123456789&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;$2a$10$O1SrEy3KsgN0NQdQjaSU6OxjxDo0jf.j/e2goSwSEu4esz9i58dRm&quot;&lt;/span&gt;&lt;br/&gt;).then(&lt;span&gt;console&lt;/span&gt;.log);&lt;br/&gt;&lt;br/&gt;bcryptCompare(&lt;br/&gt;  &lt;span&gt;&quot;123456&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;$2a$10$O1SrEy3KsgN0NQdQjaSU6OxjxDo0jf.j/e2goSwSEu4esz9i58dRm&quot;&lt;/span&gt;&lt;br/&gt;).then(&lt;span&gt;console&lt;/span&gt;.log);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上示例代码正常运行后，在控制台中会输出以下结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;true&lt;br/&gt;false&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为我们的原始密码是 &lt;code&gt;123456789&lt;/code&gt;，很明显与 &lt;code&gt;123456&lt;/code&gt; 并不匹配，所以会输出以上的匹配结果。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;七、总结&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文首先介绍了消息摘要算法、MD5 算法的相关概念和特点，然后详细介绍了 MD5 算法的用途和 Node.js 平台的使用示例，最后我们还分析了 MD5 算法存在的缺陷和 MD5 密码的安全性问题。&lt;span&gt;这里需要大家注意的是，基于 MD5 来验证数据完整性已不可靠，考虑到近期谷歌已成功构造了 SHA-1（英语：&lt;/span&gt;&lt;span&gt;Secure Hash Algorithm 1，中文名：&lt;/span&gt;&lt;span&gt;安全散列算法1）的碰撞实例，对于数据完整性校验，应使用 SHA256 或更强的算法代替。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了文中介绍的 MD5 应用场景，MD5 还可以用于实现 CDN（Content Delivery Network，内容分发网络）内容资源的防盗链，感兴趣的小伙伴可以阅读 “深入了解 Token 防盗链” 这篇文章。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;近期阿宝哥突然对&lt;strong&gt; JS 逆向 &lt;/strong&gt;很感兴趣，因此打算系统学习一下相关的知识，目前已有初步的学习计划，想一起学习的小伙伴可以私聊阿宝哥哈。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;八、参考资源&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;维基百科 - MD5&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;维基百科 - 彩虹表&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;维基百科 - 盐_(密码学)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;加密基础知识一 MD5 SHA-1 CRC 加盐&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;MD、SHA、MAC消息摘要算法实现与应用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;MD5 碰撞的一些例子&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2d31943d57ab43fb9e2932733f993d55</guid>
<title>可恶的爬虫直接把生产 6 台机器爬挂了</title>
<link>https://toutiao.io/k/hs71cxw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;&lt;span&gt;点击上方“&lt;span&gt;Java金融&lt;/span&gt;”，选择“&lt;/span&gt;&lt;span&gt;设为星标”&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;后台回复&quot;888&lt;/span&gt;&lt;span&gt;&quot;获取bat面试题集&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;引言&lt;/span&gt;&lt;/h1&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;正在午睡，突然收到线上疯狂报警的邮件，查看这个邮件发现这个报警的应用最近半个月都没有发布，应该不至于会有报警，但是还是打开邮件通过监控发现是由于某个接口某个接口流量暴增，&lt;code&gt;CPU&lt;/code&gt;暴涨。为了先解决问题只能先暂时扩容机器了，把机器扩容了一倍，问题得到暂时的解决。最后复盘为什么流量暴增？由于最近新上线了一个商品列表查询接口，主要用来查询商品信息，展示给到用户。业务逻辑也比较简单，直接调用底层一个&lt;code&gt;soa&lt;/code&gt;接口，然后把数据进行整合过滤，排序推荐啥的，然后吐给前端。这个接口平时流量都很平稳。线上只部署了6台机器，面对这骤增的流量，只能进行疯狂的扩容来解决这个问题。扩容机器后问题得到暂时的解决。后来经过请求分析原来大批的请求都是无效的，都是爬虫过来爬取信息的。这个接口当时上线的时候是裸着上的也没有考虑到会有爬虫过来。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;解决办法&lt;/span&gt;&lt;/h1&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;既然是爬虫那就只能通过反爬来解决了。自己写一套反爬虫系统，根据用户的习惯，请求特征啥的，浏览器&lt;code&gt;cookie&lt;/code&gt;、同一个请求频率、用户&lt;code&gt;ID&lt;/code&gt;、以及用户注册时间等来实现一个反爬系统。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;直接接入公司现有的反爬系统，需要按照它提供的文档来提供指定的格式请求日志让它来分析。&lt;strong&gt;既然能够直接用现成的，又何必自己重新造轮子呢&lt;/strong&gt;。最后决定还是采用接入反爬系统的爬虫组件。爬虫系统提供了两种方案如下：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;方案1:&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;爬虫系统提供批量获取黑名单&lt;code&gt;IP&lt;/code&gt;的接口（&lt;code&gt;getBlackIpList&lt;/code&gt;）和移除黑名单&lt;code&gt;IP&lt;/code&gt;接口（&lt;code&gt;removeBlackIp&lt;/code&gt;）。业务项目启动的时候,调用&lt;code&gt;getBlackIpList&lt;/code&gt;接口把所有&lt;code&gt;IP&lt;/code&gt;黑名单全部存入到本地的一个容器里面（Map、List），中间会有一个定时任务去调用&lt;code&gt;getBlackIpList&lt;/code&gt;接口全量拉取黑名单（黑名单会实时更新，可能新增，也可能减少）来更新这个容器。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每次来一个请求先经过这个本地的黑名单&lt;code&gt;IP&lt;/code&gt;池子，&lt;code&gt;IP&lt;/code&gt;是否在这个池子里面，如果在这个池子直接返回爬虫错误码，然后让前端弹出一个复杂的图形验证码，如果用户输入验证码成功（爬虫基本不会去输入验证码），然后把&lt;code&gt;IP&lt;/code&gt;从本地容器移除，同时发起一个异步请求调用移除黑名单&lt;code&gt;IP&lt;/code&gt;接口（&lt;code&gt;removeBlackIp&lt;/code&gt;）,以防下次批量拉取黑单的时候又拉入进来了。然后在发送一个&lt;code&gt;activemq&lt;/code&gt;消息告诉其他机器这个&lt;code&gt;IP&lt;/code&gt;是被误杀的黑名单，其他机器接受到了这个消息也就会把自己容器里面这个&lt;code&gt;IP&lt;/code&gt;移除掉。（其实同步通知其他机器也可以通过把这个&lt;code&gt;IP&lt;/code&gt;存入&lt;code&gt;redis&lt;/code&gt;里面，如果在命中容器里面是黑名单的时候，再去&lt;code&gt;redis&lt;/code&gt;里面判断这个&lt;code&gt;ip&lt;/code&gt;是否存在&lt;code&gt;redis&lt;/code&gt;里面，如果存在则说明这个ip是被误杀的，应该是正常请求，下次通过定时任务批量拉取黑名单的时候，拉取完之后把这个&lt;code&gt;redis&lt;/code&gt;里面的数据全部删除，或者让它自然过期。这种方案：&lt;strong&gt;性能较好，基本都是操作本地内存。但是实现有点麻烦，要维护一份IP黑名单放在业务系统中。&lt;/strong&gt;&lt;img data-ratio=&quot;0.9228998849252014&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qu3ItokgsAqgPvuliafHSuOFNxJn0PPTCVZxFxOicfQer32bfmtsKUf8yp66BsZwiaQklMVdhxB5WlEicfibf4DQ7sg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;869&quot;/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;方案2：&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;爬虫系统提供单个判断IP是否黑名单接口&lt;code&gt;checkIpIsBlack&lt;/code&gt;（但是接口耗时有点长5s）和移除黑名单&lt;code&gt;IP&lt;/code&gt;接口（&lt;code&gt;removeBlackIp&lt;/code&gt;）。每一个请求过来都去调用爬虫系统提供的接口（判断&lt;code&gt;IP&lt;/code&gt;是否在黑名单里面）这里有一个网络请求会有点耗时。如果爬虫系统返回是黑名单，就返回一个特殊的错误码给到前端，然后前端弹出一个图形验证码，如果输入的验证码正确，则调用爬虫系统提供的移除&lt;code&gt;IP&lt;/code&gt;黑名单接口，把&lt;code&gt;IP&lt;/code&gt;移除。这种方案：&lt;strong&gt;对于业务系统使用起来比较简单，直接调用接口就好，没有业务逻辑，但是这个接口耗时是没法忍受的，严重影响用户的体验&lt;/strong&gt;最终综合考虑下来最后决定采用&lt;strong&gt;方案1&lt;/strong&gt;.毕竟系统对响应时间是有要求的尽量不要增加不必要的耗时。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;方案1 实现&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方案1伪代码实现 我们上文&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIyMjQwMTgyNA==&amp;amp;mid=2247485069&amp;amp;idx=1&amp;amp;sn=77d5c2d227eb3b1a746abb714f505df0&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《看了CopyOnWriteArrayList后自己实现了一个CopyOnWriteHashMap》&lt;/a&gt;有提到过对于读多写少的线程安全的容器我们可以选择&lt;code&gt;CopyOnWrite&lt;/code&gt;容器。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;static&lt;/span&gt; CopyOnWriteArraySet blackIpCopyOnWriteArraySet = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 初始化&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@PostConstruct&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 调用反爬系统接口 拉取批量黑名单&lt;/span&gt;&lt;br/&gt;        List&amp;lt;String&amp;gt; blackIpList = getBlackIpList();&lt;br/&gt;        &lt;span&gt;// 初始化&lt;/span&gt;&lt;br/&gt;        blackIpCopyOnWriteArraySet = &lt;span&gt;new&lt;/span&gt; CopyOnWriteArraySet(blackIpList);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 判断IP 是否黑名单&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; ip&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;checkIpIsBlack&lt;/span&gt;&lt;span&gt;(String ip)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;boolean&lt;/span&gt; checkIpIsBlack =  blackIpCopyOnWriteArraySet.contains(ip);&lt;br/&gt;       &lt;span&gt;if&lt;/span&gt; (!checkIpIsBlack ) &lt;br/&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;       &lt;span&gt;// 不在redis白名单里面&lt;/span&gt;&lt;br/&gt;       &lt;span&gt;if&lt;/span&gt; (!RedisUtils.exist(String.format(&lt;span&gt;&quot;whiteIp_%&quot;&lt;/span&gt;, ip)){&lt;br/&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;  } &lt;br/&gt;       &lt;span&gt;return&lt;/span&gt;  &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上线后经过一段时间让爬虫系统消费我们的请求日志，经过一定模型特征的训练，效果还是很明显的。由于大部分都是爬虫很多请求直接就被拦截了，所以线上的机器可以直接缩容掉一部分了又回到了6台。但是好景不长，突然发现&lt;code&gt;GC&lt;/code&gt;次数频繁告警不断。为了暂时解决问题，赶紧把生产机器进行重启（&lt;strong&gt;生产出问题之后，除了重启和回退还有什么解决办法吗&lt;/strong&gt;），并且保留了一台机器把它拉出集群，重启之后发现过又是一样的还是没啥效果。通过&lt;code&gt;dump&lt;/code&gt;线上的一台机器，通过&lt;code&gt;MemoryAnalyzer&lt;/code&gt;分析发现一个大对象就是我们存放&lt;code&gt;IP&lt;/code&gt;的大对象，存放了大量的的IP数量。这个IP存放的黑名单是放在一个全局的静态&lt;code&gt;CopyOnWriteArraySet&lt;/code&gt;，所以每次&lt;code&gt;gc&lt;/code&gt; 它都不会被回收掉。只能临时把线上的机器配置都进行升级，由原来的8核16g直接变为16核32g，新机器上线后效果很显著。&lt;strong&gt;为啥测试环境没有复现？&lt;/strong&gt;测试环境本来就没有什么其他请求，都是内网&lt;code&gt;IP&lt;/code&gt;，几个黑名单&lt;code&gt;IP&lt;/code&gt;还是开发手动构造的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;解决方案&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业务系统不再维护&lt;code&gt;IP&lt;/code&gt;黑名单池子了，由于黑名单来自反爬系统，爬虫黑名单的数量不确定。所以最后决定采取方案2和方案1结合优化。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;1.项目启动的时候把所有的&lt;code&gt;IP&lt;/code&gt;黑名单全部初始化到一个全局的布隆过滤器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2.一个请求过来先经过布隆过滤器，判断是否在布隆过滤器里面，如果在的话我们再去看看是否在&lt;code&gt;redis&lt;/code&gt;白名单里面（误杀用户需要进行洗白）我们再去请求反爬系统判断&lt;code&gt;IP&lt;/code&gt;是否是黑名单接口，如果接口返回是&lt;code&gt;IP&lt;/code&gt;黑名单直接返回错误码给到前端，如果不是直接放行（布隆过滤器有一定的误判，但是误判率是非常小的，所以即使被误判了，最后再去实际请求接口，这样的话就不会存在真正的误判真实用户）。如果不存在布隆器直接放行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;3.如果是被误杀的用户，用户进行了&lt;code&gt;IP&lt;/code&gt;洗白，布隆过滤器的数据是不支持删除（布谷鸟布隆器可以删除（可能误删）），把用户进行正确洗白后的&lt;code&gt;IP&lt;/code&gt;存入&lt;code&gt;redis&lt;/code&gt;里面。（或者一个本地全局容器，&lt;code&gt;mq&lt;/code&gt;消息同步其他机器）
下面我们先来了解下什么是布隆过滤器吧。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;什么是布隆过滤器&lt;span/&gt;&lt;/h5&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;布隆过滤器（英语：Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述出自百度百科。说白了布隆过滤器主要用来判断一个元素是否在一个集合中，它可以使用一个位数组简洁的表示一个数组。它的空间效率和查询时间远远超过一般的算法，不过它存在一定的误判的概率，适用于容忍误判的场景。&lt;strong&gt;如果布隆过滤器判断元素存在于一个集合中，那么大概率是存在在集合中，如果它判断元素不存在一个集合中，那么一定不存在于集合中。&lt;/strong&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;实现原理&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;布隆过滤器的原理是，当一个元素被加入集合时，通过 K 个散列函数将这个元素映射成一个位数组（Bit array）中的 K 个点，把它们置为 1 。检索时，只要看看这些点是不是都是1就知道元素是否在集合中；如果这些点有任何一个 0，则被检元素一定不在；如果都是1，则被检元素很可能在（之所以说“可能”是误差的存在）。底层是采用一个bit数组和几个哈希函数来实现。&lt;img data-ratio=&quot;0.11944091486658195&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qu3ItokgsAqgPvuliafHSuOFNxJn0PPTCTk0XU2KGKYAO1aicYl8ArZsDP5ec4icPoJ0yUV8zF8KbYlWhQXkPiaS3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;787&quot;/&gt;&lt;img data-ratio=&quot;0.7521263669501823&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qu3ItokgsAqgPvuliafHSuOFNxJn0PPTCmYgutFq470Biab8P1XgTYQYRtNibXrrpibkIJ5PDAeKkAAFmMhqZPukMQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;823&quot;/&gt;下面我们以一个 &lt;code&gt;bloom filter&lt;/code&gt; 插入&quot;&lt;code&gt;java&lt;/code&gt;&quot; 和&quot;&lt;code&gt;PHP&lt;/code&gt;&quot;为例，每次插入一个元素都进行了三次hash函数
java第一次hash函数得到下标是2，所以把数组下标是2给置为1
java第二次Hash函数得到下标是3，所以把数组下标是3给置为1
java第三次Hash函数得到下标是5，所以把数组下标是5给置为1
PHP 第一次Hash函数得到下标是5，所以把数组下标是5给置为1
...
查找的时候，当我们去查找&lt;code&gt;C++&lt;/code&gt;的时候发现第三次&lt;code&gt;hash&lt;/code&gt;位置为0，所以&lt;code&gt;C++&lt;/code&gt;一定是不在不隆过滤器里面。但是我们去查找“&lt;code&gt;java&lt;/code&gt;”这个元素三次&lt;code&gt;hash&lt;/code&gt;出来对应的点都是1。只能说这个元素是可能存在集合里面。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;将要添加的元素给k个哈希函数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;得到对应于位数组上的k个位置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将这k个位置设为1&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;将要查询的元素给k个哈希函数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;得到对应于位数组上的k个位置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果k个位置有一个为0，则肯定不在集合中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果k个位置全部为1，则可能在集合中&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;使用BloomFilter&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引入pom&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &amp;lt;dependency&amp;gt;&lt;br/&gt;            &amp;lt;groupId&amp;gt;com.google.guava&amp;lt;/groupId&amp;gt;&lt;br/&gt;            &amp;lt;artifactId&amp;gt;guava&amp;lt;/artifactId&amp;gt;&lt;br/&gt;            &amp;lt;version&amp;gt;&lt;span&gt;23.0&lt;/span&gt;&amp;lt;/version&amp;gt;&lt;br/&gt;  &amp;lt;/dependency&amp;gt; &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;1000000&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; BloomFilter&amp;lt;String&amp;gt; bf = BloomFilter.create(Funnels.stringFunnel(Charset.forName(&lt;span&gt;&quot;utf-8&quot;&lt;/span&gt;)), count,&lt;span&gt;0.009&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; missCount = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; count; i++) {&lt;br/&gt;            bf.put(i+&lt;span&gt;&quot;&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = count; i &amp;lt; count+&lt;span&gt;1000000&lt;/span&gt;; i++) {&lt;br/&gt;            &lt;span&gt;boolean&lt;/span&gt; b = bf.mightContain(i +&lt;span&gt;&quot;&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (b) {&lt;br/&gt;                missCount++;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        System.out.println(&lt;span&gt;new&lt;/span&gt; BigDecimal(missCount).divide(&lt;span&gt;new&lt;/span&gt; BigDecimal(count)));&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;解决问题&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;布隆过滤器介绍完了，我们再回到上述的问题，我们把上述问题通过伪代码来实现下；&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;   &lt;span&gt;/**&lt;br/&gt;     * 初始化&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@PostConstruct&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 这个可以通过配置中心来读取&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;double&lt;/span&gt; fpp = &lt;span&gt;0.001&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;// 调用反爬系统接口 拉取批量黑名单&lt;/span&gt;&lt;br/&gt;        List&amp;lt;String&amp;gt; blackIpList = getBlackIpList();&lt;br/&gt;        &lt;span&gt;// 初始化 不隆过滤器&lt;/span&gt;&lt;br/&gt;        blackIpBloomFilter = BloomFilter.create(Funnels.stringFunnel(Charset.forName(&lt;span&gt;&quot;utf-8&quot;&lt;/span&gt;)), blackIpList.size(), fpp);&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (String ip: blackIpList) {&lt;br/&gt;            blackIpBloomFilter.put(ip);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 判断是否是爬虫&lt;br/&gt;  */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;checkIpIsBlack&lt;/span&gt;&lt;span&gt;(String ip)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;boolean&lt;/span&gt; contain = blackIpBloomFilter.mightContain(ip);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!contain) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;         &lt;span&gt;// 不在redis白名单里面&lt;/span&gt;&lt;br/&gt;       &lt;span&gt;if&lt;/span&gt; (!RedisUtils.exist(String.format(&lt;span&gt;&quot;whiteIp_%&quot;&lt;/span&gt;, ip)){&lt;br/&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;  } &lt;br/&gt;        &lt;span&gt;// 调用反爬系统接口 判断IP是否在黑名单里面&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述只是列举了通过&lt;code&gt;IP&lt;/code&gt;来反爬虫，这种反爬的话只能应对比较低级的爬虫，如果稍微高级一点的爬虫也可以通过代理&lt;code&gt;IP&lt;/code&gt;来继续爬你的网站，这样的话成本可能就会加大了一点。爬虫虽然好，但是还是不要乱爬，“&lt;strong&gt;爬虫爬的好，牢饭吃到饱&lt;/strong&gt;”&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;结束&lt;/span&gt;&lt;/h1&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;由于自己才疏学浅，难免会有纰漏，假如你发现了错误的地方，还望留言给我指出来,我会对其加以修正。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果你觉得文章还不错，你的转发、分享、赞赏、点赞、留言就是对我最大的鼓励。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;感谢您的阅读,十分欢迎并感谢您的关注。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5555555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qu3ItokgsAqGERRdd3z4vHn9SHGCudYZMwwTqRMHs8j5CvET142QTd2218cicicfw2XKH4f2TvvtokKRsUiac0Jhg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;往期精选&lt;span/&gt;&lt;/h3&gt;&lt;/section&gt;&lt;pre&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;最近面试BAT，整理一份面试资料&lt;/span&gt;&lt;span&gt;《&lt;strong&gt;Java面试BATJ通关手册&lt;/strong&gt;》&lt;/span&gt;&lt;span&gt;，覆盖了Java核心技术、JVM、Java并发、SSM、微服务、数据库、数据结构、等等。&lt;/span&gt;&lt;span&gt;获取方式：点“&lt;/span&gt;&lt;span&gt;&lt;strong&gt;在看&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;”，关注公众号并回复 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;666&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 领取，更多内容陆续奉上。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p data-style=&quot;font-size: 16px; white-space: normal; letter-spacing: 0.544px; widows: 1; word-spacing: 2px; caret-color: rgb(255, 0, 0); color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); font-family: 微软雅黑; text-align: right; margin-left: 0.5em; margin-right: 0.5em;&quot; class=&quot;js_darkmode__117&quot;&gt;&lt;span&gt;&lt;strong&gt;文章有帮助的话，在看，转发吧。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-style=&quot;font-size: 16px; white-space: normal; letter-spacing: 0.544px; widows: 1; word-spacing: 2px; caret-color: rgb(255, 0, 0); color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); font-family: 微软雅黑; text-align: right; margin-left: 0.5em; margin-right: 0.5em;&quot; class=&quot;js_darkmode__118&quot;&gt;&lt;span&gt;&lt;strong&gt;谢谢支持哟 (*^__^*）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>