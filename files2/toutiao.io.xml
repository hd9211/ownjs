<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>a3c99f4c2ae888083ad383d6ea3b872a</guid>
<title>懂得三境界：使用 Dubbo 时请求超过问题</title>
<link>https://toutiao.io/k/mgynadi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;引子&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;刚才下班回家路上，无意中听到大街上放的歌，歌词有这么一句：“毡房外又有驼铃声声响起，我知道那一定不是你”。这一句我似乎听懂了歌者的魂牵梦绕和绝望，如果在十年前我大概只能感受出悠扬的声调里溢出的悲凉吧。&lt;/p&gt;&lt;p&gt;在工作上，我没有十年的时间来把思考能力上升一个等级。对于一个问题，需要在很短的时间反复思考，深层次的弄懂。懂得，有三个初级境界，对应三个方法：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1&amp;gt;字面理解-what、why、how&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2&amp;gt;前因后果-5why&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3&amp;gt;选择最优-SMART&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;回到主线：为什么是初级境界？我自己也不知道更高级别的境界是有什么，因为自己境界没有达到。但是至少有：刻入骨髓 这一境界。&lt;/p&gt;&lt;p&gt;举个例子：十二年前，有次在大街上走，我走过一个【北京银行】的大门，银行二楼的玻璃哗啦啦掉下来。我知道身后有危险，有很多玻璃落到了距离我身后不到十公分的地方。我当时很镇定的继续向前走。等过了危险区，我很想神经质的大叫。因为走路时再多犹豫2秒，可能脑袋上被扎的全是玻璃。所以走路时时时刻刻都会想着离楼房远一些，并且好像感受到了自己脑袋被玻璃扎。我理解这可以算作把楼房玻璃很危险的理解刻入骨髓。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;字面理解&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;今天举的这个例子纯粹是技术问题，终于不需要用蹩脚的比喻把事情描述的更难理解来达到脱敏的效果。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;what&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;我们采用的是dubbo服务，这是个稳定成熟的RPC框架。但是我们在某些应用中会发现，只要这个应用一发布(或者重启),就会出现请求超时的问题，如下图所示:&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;252&quot; data-backw=&quot;472&quot; data-ratio=&quot;0.5346097201767305&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9NHC7202k2LDdz4wH8nD5XUgCaGLfRbfSh0TJW5GSH207kcpbI76zc1P2xaVQian8cw4BlMaTLdbQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1358&quot;/&gt;&lt;br/&gt;而且都是第一笔请求会报错，之后就再也没有问题了。&lt;span&gt;(上图来源于网络，下面有参考文章。如果可以，我想把这些字调的再小一些)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;why&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;我当时很快就定位了问题，因为在内网wiki上、技术博客上，很多人都写了这个坑。所以不讲排查思路了，直接讲结论：&lt;/p&gt;&lt;p&gt;在server端连接数过多, linux系统有个连接队列溢出了。溢出的连接被丢弃，但是client端不知道，仍然给此server发送消息。连接没有建立自然发送不成功。client发第一笔消息超时，相当于探活失败，client端于是重新建立连接。连接成功建立后开始正常的通信，所以后面都成功了。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;how&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;怎么来解决这个问题呢？四个思路。&lt;/p&gt;&lt;p&gt;第一个是队列溢出了，那就说明队列太小。可以把队列值改大。dubbo使用的是一个写死的默认值：50。可以修改dubbo源码把值改大或者干脆动态获取队列值。&lt;/p&gt;&lt;p&gt;第二个是队列数不变，实际连接数减少。减少server端的连接方，比如有些client端其实没有实际业务调用这个server端了，就双方聊聊把无用的依赖去掉。&lt;/p&gt;&lt;p&gt;第三个是可以让服务端在丢弃连接的同时给client端通知一下，linux有个系统参数/proc/sys/net/ipv4/tcp_abort_on_overflow，默认为0。不会给client端发通知，但是设置为1时会给server端发一个reset请求，客户端收到会重连。&lt;/p&gt;&lt;p&gt;第四个是让client端定时心跳探测。探测发现超时了马上重连，超时的那笔只是探测请求，不影响业务。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRlib44sDJUIqssEoeTxDraMgfDmk6rVUuibn8wySzuSicrUaCHeX0kWSsQc7ynWzECDZ6hjiaZCoR1wM7g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;300&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;前因后果&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;作为软件工程师，重要的一个软素质是批判性思维。多问几个问题，找到答案，理解就能更进一步。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Q1: &lt;/span&gt;&lt;/strong&gt;提到溢出的队列到底是什么队列？&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;A: &lt;/span&gt;&lt;/strong&gt;下图是TCP连接三次握手的示意图。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;367&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.634375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRlib44sDJUIqssEoeTxDraMgftETk0CBEtY8ZaMgYicltxFBCX8FO8ibJJic8pjcaIcSmMWudZtEHC5n7w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;一次握手：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;一开始client端和server端都处于closed状态(未建立连接状态)。client端主动向server端发起syn请求建立连接请求，server端收到后将与client端的连接设置为listen状态(半连接状态)。问题来了，server端怎么保存与client端的状态呢？总需要有地方存呀，存的地方就是队列。连接队列又叫backlog队列。到这里，server端与client端的半连接建立了。这里的backlog队列也叫半连接队列。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;二次握手：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;server端返回ack应答+syn请求给client，意思是：ack我收到了你的请求，syn你收到我的了没？client端收到server端响应，将自己的状态设置为established状态(连接状态)。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;三次握手：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;client向server端发送一个ack响应，告诉server端收到。然后server端收到后将与client端的连接设置为established状态(全连接状态)。同样，全连接状态在server端也需要一个backlog队列存储。这里的backlog队列也叫全连接队列。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Q2: &lt;/span&gt;&lt;/strong&gt;backlog队列到底是全连接队列还是半连接队列？&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;A: &lt;/span&gt;&lt;/strong&gt;这个问题让我想起别的事情。我大学是东北大学，有次看到校内论坛上有个帖子：“东北大学和东南大学谁更有资格叫东大？”最终没啥结论，东北大学内网再论证自己该叫东大，东南大学内网肯定不认。&lt;/p&gt;&lt;p&gt;但是backlog的问题还是有达成共识的可能的。backlog其实是一个连接队列，在Linux内核2.2之前，backlog包括半连接状态和全连接状态两种队列。在Linux内核2.2之后，分离为两个backlog来分别限制半连接（SYN_RCVD状态）队列大小和全连接（ESTABLISHED状态）队列大小。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;半连接队列：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;队列长度由/proc/sys/net/ipv4/tcp_max_syn_backlog指定，默认为2048。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;全连接队列：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;队列长度由/proc/sys/net/core/somaxconn和使用listen函数时传入的参数，二者取最小值。默认为128。&lt;/p&gt;&lt;p&gt;在Linux内核2.4.25之前，是写死在代码常量 SOMAXCONN ，在Linux内核2.4.25之后，在配置文件/proc/sys/net/core/somaxconn中直接修改，或者在 /etc/sysctl.conf 中配置 net.core.somaxconn = 128 。&lt;/p&gt;&lt;p&gt;想到这里我恍然大悟，东北大学、东方大学、东南大学在自己的地盘都有资格简称东大（这里讲这个插曲是为了澄清一件事情：我昨天下午4点发的文章里标题是一个北大妹子，那篇文章是帮朋友的忙，北大妹子不是我，我是东大妹子）。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Q3: &lt;/span&gt;&lt;/strong&gt;到底是全连接队列还是半连接队列溢出导致了超时？&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;A: &lt;/span&gt;&lt;/strong&gt;server端与client端进行二次握手的前提是server端认为自己与client建立连接是没有任何问题的。如果server端半连接队列溢出了，自己这边都没有处于半连接状态，自然不会发送ack+syn给client端。client端做的应该是重新尝试建立连接，不是发送数据。请求会发送到已经建立好连接的server端(server端是多机器多活部署的)不会造成请求超时。&lt;/p&gt;&lt;p&gt;而二次握手一旦完成，进行三次握手时，如果全连接队列已满，服务器收到客户端发来的ACK, 不会将该连接的状态从SYN_RCVD变为ESTABLISHED。但是客户端已经认为连接建立好了开始发送数据了，这时候是有可能造成超时的。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Q4: &lt;/span&gt;&lt;/strong&gt;全连接队列满了之后server端是怎么处理的呢？&lt;/p&gt;&lt;p&gt;当全连接队列已满时，则根据 tcp_abort_on_overflow 的值来执行相应动作。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;tcp_abort_on_overflow = 0 处理：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;则服务器建立该连接的定时器，这个定时器是一个服务器的规则是从新发送syn+ack的时间间隔成倍的增加，比如从新了第二次握手，进行了5次，这五次的时间分别是 1s, 2s,4s,8s,16s,这种倍数规则叫“二进制指数退让”(binary exponential backoff)。&lt;/p&gt;&lt;p&gt;给客户端定时从新发回SYN+ACK即重新进行第二次握手，(如果客户端设定的超时时间比较短就很容易出现异常)服务器重新进行第二次握手的次数由/proc/sys/net/ipv4/tcp_synack_retries 这个linux系统参数决定。&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;tcp_abort_on_overflow = 1 &lt;strong&gt;处理：&lt;/strong&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;当 tcp_abort_on_overflow 等于1 时,发送一个reset请求重置连接。客户端收到可以尝试再次从第一次握手开始建立连接或者其他处理。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Q5: &lt;/span&gt;&lt;/strong&gt;怎么验证确实是backlog队列溢出呢？&lt;/p&gt;&lt;p&gt;&lt;span&gt;ss 是 Socket Statistics 的缩写。ss 命令可以用来获取 socket 统计信息&lt;/span&gt;。ss -l 是显示listen状态的数据，如下所示：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-attr&quot;&gt;[root@localhost ~]&lt;/span&gt;# &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;ss&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;-l&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;State&lt;/span&gt;       &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Recv-Q&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Send-Q&lt;/span&gt;        &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Local&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Address&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:Port&lt;/span&gt;           &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Peer&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Address&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:Port&lt;/span&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;LISTEN&lt;/span&gt;      0      128                       *&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:http&lt;/span&gt;                         *:*       &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;LISTEN&lt;/span&gt;      0      128                       :&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;::ssh&lt;/span&gt;                        :::*       &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;LISTEN&lt;/span&gt;      0      128                        *&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:ssh&lt;/span&gt;                         *:*       &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;LISTEN&lt;/span&gt;      0      100                     &lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;::1&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:smtp&lt;/span&gt;                        :::*       &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;LISTEN&lt;/span&gt;      0      100               127&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.1&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:smtp&lt;/span&gt;                         *:*       &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;在LISTEN状态，其中 Send-Q 即为全连接队列的最大值，Recv-Q 则表示全连接队列中等待被server段处理的数量。数量为0，说明处理能力很够；Send-Q =Recv-Q ，满了，再来就丢弃掉了。&lt;/p&gt;&lt;p&gt;但是这是一个实时的数据，一段时间有拥塞，过一会儿就好了怎么查呢？&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以使用netstat -s 可以查看被全连接队列丢弃的数据。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;apache&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;[&lt;span class=&quot;code-snippet__attribute&quot;&gt;root&lt;/span&gt;@localhost ~]# netstat -s | grep &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;times the listen queue of a socket overflowed&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;35552&lt;/span&gt; times the listen queue of a socket overflowed&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;strong&gt;&lt;span&gt;补充说明: &lt;/span&gt;&lt;/strong&gt;半连接队列很多文章叫做&lt;span&gt;SYN QUEUE队列。&lt;/span&gt;&lt;span&gt;全连接队列很多文章叫做ACCEPT QUEUE队列。&lt;/span&gt;&lt;span&gt;这是一些研究linux源码的同学根据源码的命名来叫的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.1802721088435375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicFPQQW5JXfQVCIb9lGSSj5fw7ypyia2HmibQ3QGUxELbTGZoOF6n5lU14IrNRjTlpWJeFqALibxV6Xg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;294&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;选择最优&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;马云说：“选择比努力重要” 。懂得三境界，第三境界的重点不是懂，而是得。最终要根据懂了的内容决策出最优方案。&lt;/p&gt;&lt;p&gt;除了字面理解里提到的四种思路，前因后果里还提到了重新进行第二次握手的次数由/proc/sys/net/ipv4/tcp_synack_retries 这个linux系统参数决定。&lt;/p&gt;&lt;p&gt;分别来分析一下各个方案的可行性和优缺点：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;方案1：把队列值调大&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;这个队列值是指&lt;span&gt;全连接队列&lt;/span&gt;，调大之后，client端的二次握手就在这个队列里排队等待server端真正建立连接。假设队列值调到上限65535。第65535号请求在排队的过程，client端是established状态，数据可能会发送过来，服务端还没有established状态，还不能处理。&lt;/p&gt;&lt;p&gt;到什么时候能处理呢？65535个请求全部处理完需要13s的样子。对一般的服务来说妥妥的超时。所以nginx和redis都是使用的511，让响应时间在100ms内完成。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;方案2：减少连接数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;只要能减少的下来，这是理想的法子。现在server端都过载了，可想而知，接入的client端不再少数，推动他们一个个去梳理和改造，就算大家执行力很强，把改下的下了。可想而知，废弃的也一般不会有多少。不展开了啊，现在已经三千多字了，争取五千字内结束。&lt;/p&gt;&lt;p&gt;还有没有别的方法减少连接数呢？最简单的就是使用分治法。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;划分子集&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;跟同事讨论请教的时候，他给我提供了一个划分子集的思路。让client端只和server端一部分服务器建立连接。有两种分配谁跟谁连接的算法，一个是随机算法。但是server端服务器我最多见过几千台组成一个集群的。对随机(虽然连接数是服务器台数的n倍)来说，样本是很少的，会很不均匀；另外一个是确定性算法，思路也很简单。连接的client端及数量是确定的，那就排个序，按照server端数量分配一下。这样连接数是均匀的，但是就没办法做到请求级别的流量均匀。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;粘滞连接&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;尽可能让客户端总是向同一提供者发起调用，除非该提供者挂了，再连另一台。&amp;lt;dubbo:protocol name=&quot;dubbo&quot; sticky=&quot;true&quot; /&amp;gt;。如果每个client端都只和一个server端建立连接。那server端压力就是原来的(1/机器台数)。不够加机器就行了，横向可扩展。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRlicFPQQW5JXfQVCIb9lGSSj5ibugHkicE4Y3vVmicpgmBg9sRk0JjjvsAcQUWkJHnyLFMgdOR5EzHZ2Eg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;208&quot;/&gt;&lt;/p&gt;&lt;p&gt;这种做法最大的问题是高可用和并发请求的问题，对于可用性要求不高、请求量不高的服务(比如后台定时任务定时拉取可重试)其实是可以用的。但是这需要client端的自觉性，而对维护这个client端的人员来讲，他们自身是没有好处的，因为原本也就是只是重启时发生一次超时嘛。所以客户端在可以的情况下愿不愿意这样做就看格局了。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;方案3：服务端通知&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;服务端通知上面&lt;strong&gt;&lt;span&gt;前因后果&lt;/span&gt;&lt;/strong&gt;中有提到可以设置&lt;/p&gt;&lt;p&gt;/proc/sys/net/ipv4/tcp_synack_retries&lt;/p&gt;&lt;p&gt;重新进行几次进行第二次握手。但是这个阶段，client端可能会发数据包过来造成超时；另外，可以设置&lt;/p&gt;&lt;p&gt;/proc/sys/net/ipv4/tcp_abort_on_overflow=1&lt;/p&gt;&lt;p&gt;整个握手直接断掉，client端是closed状态，它会找其他established状态的连接进行数据包发送，不会造成超时。事实上，调研了一些大厂，&lt;/p&gt;&lt;p&gt;tcp_abort_on_overflow=1是作为默认配置的。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;方案4：客户端探测&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;客户端探测想自己做的话比较麻烦，比如说把，客户端调了n个服务，每个服务建立了n个连接。资源开销大，还必须要复用这些已经建立的连接，复杂度高。&lt;/p&gt;&lt;p&gt;其实provider 和consumer 有双向心跳(探测)的，那为什么没检测出并进行重连？&lt;/p&gt;&lt;p&gt;这个首先面临的问题：client端认为连接成功了，但server端认为没有成功。那么server端 是不会发送心跳给 client端的。&lt;/p&gt;&lt;p&gt;client端是不是应该发心跳给server端呢？是的，原来使用dubbo2.5.3版本时3分钟client端会发送一个探测，之后把问题连接closed掉。只是dubbo 2.6.9使用了netty4。他们强强联手搞出来一个bug，探测机制楞没生效！&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7559262510974539&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicFPQQW5JXfQVCIb9lGSSj5ops591LdnVaVjIDDNca8t5leL2ejdKia21JNHthANia9hMthhTbyoNxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1139&quot;/&gt;&lt;/p&gt;&lt;p&gt;心跳有个条件，就是lastRead 和 lastWrite 不为空。那就需要看哪里设置了这两个参数。通过代码查到client端连接成功和server端连接成功的时候都会设置。这里只考虑client端情况，对比netty3发现netty4里少了&lt;/p&gt;&lt;p&gt;NettyServerHandler的handler链处理。这个handler链处理就是用来初始化那两个值的。&lt;/p&gt;&lt;p&gt;除了改client端源码，有没有别的方法让client端探测生效呢？其实什么都不用TCP就有keepalive(探活)机制。默认是7200秒，也就是2小时。可以修改：&lt;/p&gt;&lt;h2&gt;/proc/sys/net/ipv4/tcp_keepalive_time &lt;/h2&gt;&lt;h2&gt;单位是秒&lt;/h2&gt;&lt;h2&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;好了，解决问题的方法就讲到这里，完结撒花~~&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRlicFPQQW5JXfQVCIb9lGSSj5rfdtsiaavV53WDy0biaOsSwyBqRZ08XKOJP58DXwNrnUXUIhTbDy5ibWw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;850&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;咦，说好的SMART原则呢？&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;1&quot; data-url=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247484071&amp;amp;idx=1&amp;amp;sn=52157bf558c74a94de69e6fa8f138d51&amp;amp;chksm=fafde809cd8a611f0ec4dd66e40efa74f1f3ce4d69d89c23a2bc243e31dd3442cec8fc0a300d&amp;amp;token=199412102&amp;amp;lang=zh_CN#rd&quot; data-author-name=&quot;编程一生&quot; data-content-utf8-length=&quot;100&quot; data-source-title=&quot;知名互联网公司需要什么样的人才&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;S代表具体的(Specific)&lt;/p&gt;&lt;p&gt;M代表可衡量的(Measurable)&lt;/p&gt;&lt;p&gt;A代表可达到的(Attainable)&lt;/p&gt;&lt;p&gt;R代表与最终目标是相关的(Relevant) &lt;/p&gt;&lt;p&gt;T代表有明确的截止期限(Time-bound)&lt;/p&gt;&lt;/section&gt;&lt;section class=&quot;blockquote_info js_blockquote_source&quot; data-json=&quot;%7B%22type%22%3A%22inner%22%2C%22source%22%3A%22url%22%2C%22digest%22%3A%22%3Cp%3ES%E4%BB%A3%E8%A1%A8%E5%85%B7%E4%BD%93%E7%9A%84(Specific)%5CnM%E4%BB%A3%E8%A1%A8%E5%8F%AF%E8%A1%A1%E9%87%8F%E7%9A%84(Measurable)%5CnA%E4%BB%A3%E8%A1%A8%E5%8F%AF%E8%BE%BE%E5%88%B0%E7%9A%84(Attainable)%5CnR%E4%BB%A3%E8%A1%A8%E4%B8%8E%E6%9C%80%E7%BB%88%E7%9B%AE%E6%A0%87%E6%98%AF%E7%9B%B8%E5%85%B3%E7%9A%84(Relevant)%5CnT%E4%BB%A3%E8%A1%A8%E6%9C%89%E6%98%8E%E7%A1%AE%E7%9A%84%E6%88%AA%E6%AD%A2%E6%9C%9F%E9%99%90(Time-bound)%3C%2Fp%3E%22%2C%22digestLen%22%3A103%2C%22text%22%3A%22%22%2C%22article%22%3A%7B%22title%22%3A%22%E7%9F%A5%E5%90%8D%E4%BA%92%E8%81%94%E7%BD%91%E5%85%AC%E5%8F%B8%E9%9C%80%E8%A6%81%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BA%BA%E6%89%8D%22%2C%22url%22%3A%22https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzUzNjAxODg4MQ%3D%3D%26mid%3D2247484071%26idx%3D1%26sn%3D52157bf558c74a94de69e6fa8f138d51%26chksm%3Dfafde809cd8a611f0ec4dd66e40efa74f1f3ce4d69d89c23a2bc243e31dd3442cec8fc0a300d%26token%3D199412102%26lang%3Dzh_CN%23rd%22%2C%22nickname%22%3A%22%E7%BC%96%E7%A8%8B%E4%B8%80%E7%94%9F%22%2C%22authorName%22%3A%22%E7%BC%96%E7%A8%8B%E4%B8%80%E7%94%9F%22%7D%2C%22hasReportOverSize%22%3Afalse%2C%22editorReportData%22%3A%5B%7B%22id%22%3A%22122333%22%2C%22key%22%3A%2275%22%2C%22len%22%3A1%7D%2C%7B%22id%22%3A%22122333%22%2C%22key%22%3A%2276%22%2C%22len%22%3A1%7D%2C%7B%22id%22%3A%22122333%22%2C%22key%22%3A%2277%22%2C%22len%22%3A1%7D%2C%7B%22id%22%3A%22122333%22%2C%22key%22%3A%2278%22%2C%22len%22%3A1%7D%5D%7D&quot;&gt;&lt;span class=&quot;blockquote_biz&quot;&gt;编程一生，公众号：编程一生&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247484071&amp;amp;idx=1&amp;amp;sn=52157bf558c74a94de69e6fa8f138d51&amp;amp;chksm=fafde809cd8a611f0ec4dd66e40efa74f1f3ce4d69d89c23a2bc243e31dd3442cec8fc0a300d&amp;amp;token=199412102&amp;amp;lang=zh_CN#rd&quot; class=&quot;blockquote_article&quot;&gt;知名互联网公司需要什么样的人才&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;方案这么多，哪种是最好的呢？看场景。方案4提到了问题其实是开源组件有bug导致。但改开源组件，看公司规划、开源社区支持，A可行性上有制约；&lt;/p&gt;&lt;p&gt;方案2涉及很多整改和推动，T时效上有制约。方案虽多，排除法排除一下能剩下一个就不错了。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8482758620689655&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRlicFPQQW5JXfQVCIb9lGSSj57vztCTRsRZwAtbicghze8UsrYMiaFAcde7skbgBKfyCZAp7R8dbb0t4g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;290&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;往期推荐&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考文章：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.cnblogs.com/alchemystar/p/13473999.html&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>62ae1e9f5cfb1652078b64b85e42f30f</guid>
<title>技术团队如何追求高效能</title>
<link>https://toutiao.io/k/nqsycdm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;对于一个技术团队来说，高效能是最大的追求，因为这样团队和产品才更有可能成功，技术不会成为绊脚石。&lt;/p&gt;&lt;p&gt;有些人希望通过优秀的组织结构，或者通过完备的流程，或者寄希望于管理法术，再或者找到一个牛逼的架构，可实际上并没有银弹。&lt;/p&gt;&lt;p&gt;看完了《高效能团队模式》这本书，给了自己很多启发，其他的一些书籍感觉很有用，可又感觉很虚无缥缈，原因有自身的，也有外部的。&lt;/p&gt;&lt;p&gt;但这本书本身就来源于敏捷思想，所以DevOps一流，其中的理论感觉是解剖，有理有据，结合自己工作中遇到的问题，看起来更有收获。&lt;/p&gt;&lt;p&gt;为此按照自己的方式总结了本书，再到明年春暖花开之时，看看自己是否进步了吗？&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;组织结构的思维模式才是最重要的，要专注于全局优化，聚焦于完整的工作流，识别并消灭瓶颈。&lt;/p&gt;&lt;p&gt;每个组织实际上有三种，官方、个体影响、价值创造结构，但大家可能聚焦于官方定义的结构，认为只要采用”正确“的流程和”正确“的工具，就会成功，认为团队是可以替换的个体，实际上个人和团队才是最重要的。&lt;/p&gt;&lt;p&gt;传统或不合适的组织不利于创新，也无法产生稳定高效的团队模式和协作方法，更不利于软件快速流动。&lt;/p&gt;&lt;p&gt;设计组织一定要考虑：是否有合适的理由设计，这个设计背后的开发决策；选择正确的时机；寻找事物偏离轨迹的线索；对未来保持警惕。&lt;/p&gt;&lt;p&gt;康威定律认为，如果一个组织的沟通路径不存在，则最后的系统架构和设计方案就很难落地，也就是说组织架构决定了系统架构。如果希望得到一种系统架构，就要重新思考组织架构来满足它，这就是逆康威定律。&lt;/p&gt;&lt;p&gt;软件架构一定要利于团队之间协作，团队之间一定要能够快速流动，为此可以采取一些良好的最佳实践，比如松耦合和高内聚（怎么哪儿都有它们）。&lt;/p&gt;&lt;p&gt;组织设计有时候要参考专家的意见，避免临时起意的团队设计，也不要轻易频繁调动团队成员，更不要为了一些管理原因进行组织结构的调整，私以为进行调整是为了灵活性，实际上上下文切换成本也很高。&lt;/p&gt;&lt;p&gt;限制非必要沟通，康威定律说明，太多的沟通会产生高度耦合和相互依赖的系统，导致流动阻塞，所以过多的沟通不一定是好事。&lt;/p&gt;&lt;p&gt;一定要有团队优先的思维方式：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;比如小而美的团队更聚焦，更容易决策，更容易产生信任；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;要维持团队的稳定性，布鲁克斯定律表示给一个团队添加新成员并不会立即提升团队的容量；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;软件的每一部分必须有单一的团队负责（并不是为了限制共享，也不是为了划分地盘），而是为了减少混乱；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;团队的成员必须具备团队思维方式，团队需求必须大于个人需求，聚焦团队目标；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;团队中也必须拥抱多样性，不同的员工能激发正能量，不同的员工能让员工和组织受益&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;奖励团队而非个人&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;要意识到团队和个人都是有认知负荷的，所以才要小和美。认知负荷包含三种（固有认知负荷，额外认知负荷，相关认知负荷），负荷一多，就会带来压力，就做不到全局考虑，无法给团队带来最大收益。&lt;/p&gt;&lt;p&gt;过多的认知负荷会导致频繁的切换，从而打消积极性，无法让人自治，精通，目标过多。所以一定要限制团队的认知负荷。&lt;/p&gt;&lt;p&gt;怎么样度量认知负荷？你觉得高效吗？你觉得能响应交代的工作吗？团队心理都有一杆秤。也不能用代码数量等评估，应该用领域复杂度来评估。&lt;/p&gt;&lt;p&gt;每个团队承受的不同复杂度的任务数量都应该是有限的。&lt;/p&gt;&lt;p&gt;团队小而美很好说，那么如何划分呢？必须有一个边界，而软件边界可能是一种比较好的评估方式，选择什么架构，必须考虑所有团队的认知负荷，比如我们也想做SRE，可目前并没有这样的能力，所以只能选择合适目前的架构。&lt;/p&gt;&lt;p&gt;团队边界必须以一种好的方式表现出来，团队API是一种很好的方式，文档、接口契约。&lt;/p&gt;&lt;p&gt;不管是团队优先理论，还是流程优化，必须采用那些被证明过的团队实践，比如持续交付、测试优先的开发，否则很难实现。&lt;/p&gt;&lt;p&gt;设计组织架构，都开始重视变更流程，提倡“低摩擦”的软件交付方式，从而获得快速的交付方式，以及及时得到反馈，精心设计的组织更有可能成功。&lt;/p&gt;&lt;p&gt;DevOps和SRE都是“低摩擦”的软件交付方式，DevOps的关键贡献在于让不同团队意识到对其他团队缺少理解和关心；而SRE让可扩展性成为可能，它是比较动态的一种交付方式，是平衡交付速度和软件可用性，强调布道师的作用。&lt;/p&gt;&lt;p&gt;选择一个团队拓扑，必须考虑几个方面：&lt;/p&gt;&lt;p&gt;说到依赖，主要分为三种：知识依赖，任务依赖，资源依赖。&lt;/p&gt;&lt;p&gt;四类基本团队拓扑：流动式团队，赋能团队，复杂子系统团队，平台团队。&lt;/p&gt;&lt;p&gt;对于稍大规模的组织，这几种团队拓扑都会存在，强调“够用就好“。&lt;/p&gt;&lt;p&gt;团队之间有三种交互模式，也对应了上述集中团队拓扑，分别是协作、服务、促进。&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>08fb886b09f20079cdbdc966176b7a3d</guid>
<title>URI/URL/URN，傻傻分不清？</title>
<link>https://toutiao.io/k/oj7shrp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p id=&quot;js_tags&quot; class=&quot;article-tag__list single-tag__wrp js_single js_wx_tap_highlight wx_tap_card&quot; data-len=&quot;1&quot; role=&quot;link&quot; aria-labelledby=&quot;js_article-tag-card__left&quot; aria-describedby=&quot;js_article-tag-card__right&quot;&gt;
                                            
                                                                                    &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__left&quot; class=&quot;article-tag-card__left&quot;&gt;
                                    &lt;span class=&quot;article-tag-card__title&quot;&gt;收录于话题&lt;/span&gt;
                                    &lt;span class=&quot;article-tag__item-wrp no-active js_tag&quot; data-url=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU2MTgxODgwNA==&amp;amp;action=getalbum&amp;amp;album_id=1962688186782908417#wechat_redirect&quot; data-tag_id=&quot;&quot; data-album_id=&quot;1962688186782908417&quot; data-tag_source=&quot;4&quot;&gt;
                                        &lt;span class=&quot;article-tag__item&quot;&gt;#网络&lt;/span&gt;
                                    &lt;/span&gt;
                                &lt;/span&gt;
                                &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__right&quot; class=&quot;article-tag-card__right&quot;&gt;15个&lt;span class=&quot;weui-hidden_abs&quot;&gt;内容&lt;/span&gt;&lt;/span&gt;
                                                                                        &lt;/p&gt;

                
                                
                
                

                
                                                                

                
                                


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;blockquote&gt;&lt;p&gt;&lt;em&gt;当我们上网的时候，浏览器地址栏里显示的那一串字符串是什么意思？这串字符叫URL，是URI的一种，还有个兄弟叫URN，这篇文章就带你了解这几个概念。原文：URI vs URL vs URN&lt;span&gt;[1]&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0WOLiabzCIE9qGuFsVHticZr0Hu2ty2HxBqtTZSHAq4cjTHQroP46iaUq1aSefqeGYicOZR7YYAIwarGw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1200&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;em&gt;当我们处理互联网和在线内容时，URI、URL和URN是我们能听到的最熟悉的单词，下面让我们深入了解它们的含义……&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;hr/&gt;&lt;h1&gt;URI - 统一资源识别符（Uniform Resource Identifier）&lt;/h1&gt;&lt;p&gt;URI是标识所有连接到万维网（World Wide Web）的资源的通用术语，是用来标识逻辑资源或者物理资源的字符串序列。换句话说，它可以用来识别互联网上的资源的位置、或名称、或两者兼有。URI有两个主要的子集，即URL和URN。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6276477146042363&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0WOLiabzCIE9qGuFsVHticZr0a9r3EILhmEI83cya7rSmJXugGAjERibn6ibGibkB03eD0JTjyciaN1DlTw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;897&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;URI语法&lt;/span&gt;：scheme:[//[user:password@]host[:port]][/]path[?query][#fragment]&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;URI示例&lt;/span&gt;：foo://example.com:8042/over/there?name=ferret#nose&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Scheme&lt;/span&gt;：URI的起始点，并与URI协议相关。URI schema对大小写不敏感，后面带有一个“:”。尽管在实践中可以使用未注册的schema，但URI schema应该向Internet Assigned Numbers Authority (IANA)注册。几个流行的URI schema的例子：HTTP、HTTPS、FTP和mailto。&lt;/p&gt;&lt;p&gt;&lt;span&gt;Authority（权限）&lt;/span&gt;：Authority字段是位于schema字段之后的第二个条目，以两个斜杠(//)开头。这个字段由多个子字段组成：&lt;/p&gt;&lt;p&gt;&lt;span&gt;Path（路径）&lt;/span&gt;：Path是第三个字段，由斜杠分隔的段序列来表示，用来提供资源的位置。注意，不管authority部分存在或不存在，path都应该以一个斜杠开始，而不是双斜杠(//)。&lt;/p&gt;&lt;p&gt;&lt;span&gt;Query（查询）&lt;/span&gt;：Query是第四个字段，是URI的可选字段，包含一串非结构数据并以“?”和Path隔开。&lt;/p&gt;&lt;p&gt;&lt;span&gt;Fragment（片段）&lt;/span&gt;：Fragment是第五个组成部分，也是一个可选字段，提供指向辅助资源的方向，并以“#”开始。简单来说，Fragment字段可以用于指向HTML页面的特定元素(主资源)。&lt;/p&gt;&lt;hr/&gt;&lt;h1&gt;URL - 统一资源定位符（Uniform Resource Locator）&lt;/h1&gt;&lt;p&gt;如上所述，&lt;span&gt;URL&lt;/span&gt;是&lt;span&gt;URI&lt;/span&gt;的一个子集。&lt;span&gt;URL&lt;/span&gt;是一个给定唯一Web资源的地址，表明了这个唯一的Web资源的位置，用户可以通过&lt;span&gt;URL&lt;/span&gt;浏览互联网。如果我们在任何应用程序中点击任何超链接，它会将我们重定向到相关的&lt;span&gt;URL&lt;/span&gt;，这些&lt;span&gt;URL&lt;/span&gt;也可以很容易的输入到浏览器地址栏中，并可以加载特定的资源。&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;URL语法&lt;/span&gt;：scheme://host:port/path?query-string#fragment-id&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;URL示例&lt;/span&gt;: https://medium.com/p/51b8167cafad&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Scheme&lt;/span&gt;：URL的第一部分，表示浏览器请求资源时必须使用的协议。常见例子有HTTPS(安全版本)和HTTP(非安全版本)。&lt;/p&gt;&lt;p&gt;&lt;span&gt;Authority&lt;/span&gt;：Authority是URL的第二个字段，同样使用“//”开头，包含一些子部分：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;host（主机名）&lt;/span&gt;—分配给主机的域名或IP地址，是主机的本地名称和它的父域名的组合&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;port（端口）&lt;/span&gt;—表示用于访问Web服务器上特定资源的标识，通常80表示HTTP, 443表示HTTPS，这是一个可选字段&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;Path to resource（资源路径）&lt;/span&gt;：路径是URL的第三个字段，是Web服务器上资源的路径&lt;/p&gt;&lt;p&gt;&lt;span&gt;Query（查询）&lt;/span&gt;：查询是URL的第四个字段，由传递给服务器端脚本的数据组成，并在Web服务器上运行。查询将执行带有“?”的搜索参数，参数通常由名字和值对组成的字符串组成，并由“&amp;amp;”分隔。&lt;/p&gt;&lt;p&gt;&lt;span&gt;Fragment Identifier（片段标识符）&lt;/span&gt;：片段是可选字段，用于表示页面中的位置，由“#”标识片段标识符。&lt;/p&gt;&lt;hr/&gt;&lt;h1&gt;URN - 统一资源名（Uniform Resource Name）&lt;/h1&gt;&lt;p&gt;&lt;span&gt;URN&lt;/span&gt;是一种具有静态名称的互联网资源，即使它的数据被移动到另一个位置也仍然有效。&lt;span&gt;URL&lt;/span&gt;在内容被移动后就失效了，与之不同的是，&lt;span&gt;URN&lt;/span&gt;可以始终跟踪Web上某些数据的资源，从而解决了频繁移动数据的问题。&lt;/p&gt;&lt;p&gt;更进一步的，我们可以说，当用户知道唯一资源的位置时，可以使用URL，但URN只需要知道特定资源的名称，而不用指定其位置。&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;URN语法&lt;/span&gt;：scheme:NID: NSS&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;URN示例&lt;/span&gt;：urn:ISSN:0167–6423&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Scheme&lt;/span&gt;：URN的前导部分，以“:”结尾，不区分大小写&lt;/p&gt;&lt;p&gt;&lt;span&gt;NID（Namespace ID）&lt;/span&gt;：URN的第二个字段，是向IANA注册的命名空间标识符。NID后面跟着一个&quot;:&quot;，可以由字母、数字和&quot; - &quot;组成。&lt;/p&gt;&lt;p&gt;&lt;span&gt;NSS（Namespace Specific String）&lt;/span&gt;：NID之后的下一个字段，是一个特定于命名空间的字符串。NID确定NSS的语法解释。NSS可以由ASCII字母、数字、标点符号和特殊字符组成。&lt;/p&gt;&lt;hr/&gt;&lt;h1&gt;区分识别URI、URL和URN的小技巧&lt;/h1&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;URL是一个可以检索网络资源的链接；URN是唯一标识符，但不能创建可单击的链接。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;人们经常用名字作为例子来描述URI和URN。人的名字就像URI，因为它标识了一个人，但并没有告诉你在世界上的哪个地方可以找到这样一个特定的人，甚至也没有告诉你我们谈论的是哪个人。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;简单的名字不能作为URN的例子，因为没有唯一性，世界上有很多人有同样的名字。URN是一个带有全局唯一标识符的名称，如身份证号或社会保险号。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在网络中，URN很容易被发现。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;em&gt;本文到此结束，如果你正好想要了解关于URI、URL和URN的知识，希望这篇文章对你有用。&lt;/em&gt;&lt;/p&gt;&lt;p&gt;感谢阅读本文…!!!🤗🤗🤗&lt;span/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;References:&lt;/span&gt;&lt;br/&gt;[1] https://enlear.academy/uri-vs-url-vs-urn-51b8167cafad&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;你好，我是俞凡，在Motorola做过研发，现在在Mavenir做技术工作，对通信、网络、后端架构、云原生、DevOps、CICD、区块链、AI等技术始终保持着浓厚的兴趣，平时喜欢阅读、思考，相信持续学习、终身成长，欢迎一起交流学习。&lt;br/&gt;微信公众号：DeepNoMind&lt;/p&gt;&lt;/blockquote&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8791a2236022aafb14a6f5a5d0e7f3f2</guid>
<title>vivo 统一告警平台建设与实践</title>
<link>https://toutiao.io/k/1l6vn4m</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;30&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;作者：vivo互联网服务器团队-Chen Ningning&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;一、背景&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;一套监控系统检测和告警是密不可分的，检测用来发现异常，告警用来将问题信息发送给相应的人。vivo监控系统1.0时代各个监控系统分别维护一套计算、存储、检测、告警收敛逻辑，这种架构下对底层数据融合非常不利，也就无法实现监控系统更广泛场景的应用，所以需要进行整体规划，重新对整个监控系统架构进行调整，在这样的背景下统一监控的目标被确立。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;以前监控被划分为基础监控、通用监控、调用链、日志监控、拨测监控等几大系统，统一监控的目标是将各个监控指标数据进行统一计算、统一存储、统一检测、统一告警、统一展示。这里不作赘述，后面会出一期vivo监控系统演进的文章进一步说明。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;上面我们说了监控统一的大背景。以前各个监控系统会各自进行告警收敛、消息组装等工作，为了减少冗余，需要将收敛等工作由一个服务统一做处理，与此同时告警中心平台也到了更新迭代的阶段，这样就需要建设一个对内部各业务统一提供告警收敛、消息组装、告警发送的告警平台，有了这个构想，我们准备将各系统告警收敛能力与告警发送能力下沉，将统一告警服务做成一个与各监控服务解偶的通用服务。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;二、现状分析&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;对于1.0时代的监控系统来说，如图1所示各个监控系统要先进行告警收敛，然后分别和老的告警中心进行对接，才能将告警消息发送出来。每一套系统都要单独进行维护一套规则，有很多重复功能建设，而实际这些功能具有高度通用性，完全可以建立合理模型对异常检测服务生成的异常进行统一处理，从而生成问题，然后进行统一的消息组装，最后发送告警消息。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.63359375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6icd9QRN6NrpC0BEHkBtqsqlvvungBRDibMmQqCtDbPiahQTwWNXqnibmgYxLz152z2ian5ialibQQ8GAlw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; (&lt;span&gt;图1&lt;/span&gt; 老监控系统告警流程图）&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在监控系统中一个异常从被检测出来到最终发出告警有几个重要概念：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;异常&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在一个检测窗口(窗口大小可以自定义)，一个或几个指标值达到检测规则定义的异常阈值，就产生一个异常。如图2所示，检测规则定义当指标值在一个检测窗口为6的检测周期内，有3个数据点超过阈值就认为有异常，我们简称这个检测规则为6-3，如图所示第一个检测窗口内(蓝色虚线筐内)只有6和7两个点的指标值超过阈值(95)，不满足6-3的条件，所以第一个检测窗口没有异常。在第二个检测窗口内(绿色虚线框内)有6、7、8三个点的指标值超过阈值(95)，所以第二个窗口就是一个异常。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;一个连续的周期内产生的所有同类异常的集合，我们称之为问题。如图2所示，第二个检测窗口就是一个异常，同时这个异常也会对应有一个问题A，如果第三个检测窗口也是一个异常，那么这个异常对应的问题也是A，所以问题和异常是一对多的关系。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;告警&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;当一个问题通过告警系统将消息以短信、电话、邮件等方式告知给用户时，我们称之为一条告警。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;恢复&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;当问题对应的异常不满足检测规则定义的异常条件时，就认为所有异常都恢复了，同时问题也认为恢复了，恢复也会发送相应的恢复通知。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;272&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.47109375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6icd9QRN6NrpC0BEHkBtqsqOMHbPWS7e6kWLkMrSeib5hcbWqZ7nibV4ELLMzW93gnUrrvR0kujftzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; (&lt;span&gt;图2&lt;/span&gt; 时序数据异常检测原理图）&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;三、衡量指标&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;一个系统我们如何衡量它的好坏，如何提升它，如何管理它？&lt;span&gt;管理学大师彼得·德鲁克曾说“你如果无法度量它，就无法管理它(If you can’t measure it, you can’t manage it)&lt;/span&gt;&lt;span&gt;”。&lt;/span&gt;从这里可以看出，如果想全面管理提升一个系统，就需要先对它的各项性能指标有一个衡量，知道它的薄弱点在哪里，找到病症所在才能对症下药。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;127&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.2203125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6icd9QRN6NrpC0BEHkBtqsqiarr4syHyr3afPfs5sA6jlUTZ0tQvroaLLGMS1DB8Jo7khxkd7nBbiaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; （&lt;span&gt;图3&lt;/span&gt; 运维指标时间节点关系图）&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;图3是监控系统运营指标和对应时间节点关系图，主要体现了MTTD、MTTA、MTTF、MTTR、MTBF等指标与时间节点的对应关系，这些指标对于提升系统性能，帮助运维团队及早发现问题有很高的参考价值。业界有很多云告警平台也很注重这些指标，下面我们着重介绍一下MTTA、MTTR这两个和告警平台关系紧密的指标：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;MTTA&lt;/strong&gt;(Mean time to acknowledge,平均应答时间)：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.32413793103448274&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6icd9QRN6NrpC0BEHkBtqsq4riagN1Omm5rfQybVicWCWMv47kG0xJIwL9d2wWyBZIbWISx70Obtzxg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;290&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（图4 MTTA计算公式）&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;平均应答时间是运维团队或者研发团队响应所有问题所花费的平均时间。MTTA度量标准用于衡量运维团队或研发团队的响应能力和警报系统的效率。通过跟踪和最小化MTTA，项目管理团队可以优化流程，提高问题解决效率，保障服务可用性，提升用户满意度[1]。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;MTTR&lt;/strong&gt;(Mean Time To Repair,平均维修时间)：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6icd9QRN6NrpC0BEHkBtqsqB53cERnGib6lXZiaDdOmz2t2yJufBtPGwVMhC8M7BHjGtCibFMgQn9Zjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;300&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（图5 MTTR计算公式[2]）&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;平均修复时间（MTTR）是修复系统并将其恢复到正常功能所需的平均时间。运维或研发人员开始处理异常，MTTR便开始计算，并且一直进行到被中断的服务完全恢复（包括所需的任何测试时间）为止。在IT服务管理行业中，MTTR中的R并不总是表示维修。它也可以表示恢复，响应或解决。尽管这些指标都对应MTTR，但是它们都有各自的含义，因此，要弄清楚要使用哪个MTTR，有助于我们更好的分析理解问题。让我们简要地看一下它们各自的含义：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;88&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;strong&gt;1）平均恢复时间&lt;/strong&gt;(Mean time to recovery)是从系统告警中恢复所需的平均时间。这涵盖了从服务异常导致告警到恢复正常的整个过程。MTTR是衡量整个恢复过程速度的指标。&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;105&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;strong&gt;2）平均响应时间&lt;/strong&gt;(Mean time to respond)表示从出现第一个告警开始到系统从故障中恢复到正常状态所需的平均时间，不包括告警系统中的任何延迟。该MTTR通常用于网络安全中，以衡量团队缓解系统攻击的效率。&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;111&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;strong&gt;3）平均解决时间&lt;/strong&gt;(Mean time to resolve)表示完全解决系统故障所花费的平均时间，包括检测故障、诊断问题以及确保故障不再发生来解决问题所需的时间。此 MTTR 指标主要用于衡量不可预见事件的解决过程，而不是服务请求。&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;提升 MTTA 的核心是找对人、找到人[3]，只有在最短的时间内找对能处理问题的人才能有效提升MTTR。通常在生产实践过程中我们会遇到“告警泛滥”的问题，大量的告警出现时需要运维人员或者开发同学去解决，对于应激敏感的同学来说很容易出现“狼来了”的现象，只要收到告警就会很紧张，同时当大量的告警信息频发骚扰我们运维人员，会引发告警疲劳，体现为不重要的事件太多，最根本的问题较少，频繁处理普通事件，重要的信息淹没在汪洋大海中。[4]&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;158&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.27421875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6icd9QRN6NrpC0BEHkBtqsqjC7iaEbKuvr9kznjUcvHOGL7LTZwJF9HJnywOa2Io41q2FmZopxcTaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（图6 告警泛滥问题图[5]）&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;四、功能设计&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;通过上面两个重要指标的分析，我们总结出要从&lt;strong&gt;告警数量&lt;/strong&gt;、&lt;strong&gt;告警收敛&lt;/strong&gt;、&lt;strong&gt;告警升级&lt;/strong&gt;等方面着手，减少告警发送的数量，提升告警准确性，最终提升解决问题的效率，降低问题恢复时长。下面我们从系统和功能层面说明如何降低告警量，把真正有价值的告警信息发送到用户手中。本文也将重点围绕告警消息收敛进行讲解。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;从图1中可以看出各个监控系统中都有很多重复的功能模块，所以针对这些功能模块我们可以将其抽离出来，如图7所示将告警收敛、告警屏蔽、告警升级等能力统一建设在统一告警服务中。这种架构下统一告警服务与检测相关服务完全解耦，在能力上具有一定的通用性。例如其它有告警或消息收敛需求的业务团队想接入统一告警，统一告警要能满足消息收敛发送的需求，同时也要满足消息直接发送的需求。统一告警会提供灵活可配置的消息发送方式，提供简单、多样的功能满足各类需求。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;199&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.34395973154362414&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6icd9QRN6NrpC0BEHkBtqsqfBgyfibpfopiaJmeegeicjGzaU95Mz0Agf5ib4ESr1Z0bHQYI6OTgcochg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1192&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（图7 统一告警系统结构图）&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;4.1 告警收敛&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;对于告警平台每天会产生数以万计的告警，这些告警对于运维或开发人员都需要去分析、甄别优先级、并处理故障。数以万计的告警如果不加收敛每条异常都发送告警，势必会增大运维人员的工作压力，当然也不是所有的告警都需要并且有必要发送给运维人员进行处理。所以我们需要对告警通过多种手段进行收敛，下面我们从四个方面介绍一下如何进行告警收敛。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;首次告警等待&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;当一个异常产生之后我们不会立即去做告警，而是通过等待一段时间才会去做告警发送，一般这个时间可以通过系统自定义，这个值如果太大就会影响告警延迟，太小不能提升告警合并效果。例如首次告警等待时间为5s，当一个服务下节点1出现A指标异常，5s内节点2也出现了A指标异常，那么发送告警时节点1和节点2会被合并到一起发送告警通知。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;告警间隔&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;问题在没有恢复前，系统会根据告警间隔的配置每隔一段时间发送一条告警信息，告警间隔用来控制告警发送的频率。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;异常收敛维度&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;异常收敛维度用来将同个维度下的异常合并在一起。例如同个节点路径A下，通过同一个检测规则产生的异常，会在告警发送的时候根据配置的异常收敛维度合并在一起。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;消息合并维度&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;当多个异常收敛成一个问题，在发送告警的时候会涉及到消息合并，消息合并维度就是用来指定哪些维度可以合并。可能这样理解有些晦涩，我们可以通过图8看一下从异常到消息的转换过程。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;假如一个异常有两个维度名字和性别，当这两个异常经过统一告警，我们会根据配置的收敛策略进行合并，从图中我们可以看到性别被定义为异常收敛维度，通常异常收敛维度的选择一定是两个或两个以上具有相同的属性的异常，这样在消息合并后只取相同属性的同一个值，对应到示例图，我们会将${sex}占位符替换成男。而名字是被定义为告警合并维度，就表示所有异常中名字是都要展示在消息文本中，所以在消息合并的时候我们会将${name}占位符对应的信息一一拼接在消息文本中。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;202&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.3497164461247637&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6icd9QRN6NrpC0BEHkBtqsqarKjU8SENwZ4SmufDeksTDcpLkg1AWLFIpFKicwS5UbZ9AYWcP8lORw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1058&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（图8 消息文本替换示意图 ）&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;4.2 告警认领&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;当出现告警后如果有人认领了该告警，那么后续相同告警只会发送给告警认领人。告警认领主要是为了解决告警有人跟进后，减少将告警发给其他人员，也能从一定程度上解决告警被重复处理的问题。被认领的告警可以取消认领。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;4.3 告警屏蔽&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;对于同一个问题，可以设置告警屏蔽，后续如果有该问题对应的告警产生，那么将不会被发送出去。告警屏蔽能减少故障在定位解决过程中，或者服务在发版变更过程中造成的告警，能有效减少无效告警对运维人员造成的困扰，屏蔽可以设置为周期性的，也可以设置为屏蔽某一时段，当然也可以取消屏蔽。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;4.4 告警回调&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;当告警规则配置了回调，那么当产生告警，就会调用回调接口，使服务或业务恢复正常。告警回调的目的是当某个服务有告警产生，希望系统能够通过一些自动化的配置，使服务恢复到正常状态，缩短故障恢复的时间，也能够紧急情况下第一时间快速恢复服务。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;4.5 误告标注&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;对于一个问题，用户可以通过误告标注备注该异常是否为误告警。误告标注的主要目的是通过标注让系统开发人员知道异常检测过程中，哪些点还需要提升优化，提高告警的准确性，为用户提供真实有效的告警提供保障。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;4.6 告警升级&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;当告警发生一定时间仍没有恢复，那么系统就会根据配置自动进行告警升级处理，然后将告警升级信息通过配置发送给对应的人员。告警升级一定程度上是为了缩短MTTA，当告警长时间未恢复，可以认为故障没有及时得到响应，这时就需要更高级别的人员介入处理。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;如图9所示，每天告警系统会发送大量的告警，当然这些告警会分别发送给不同服务的告警接收人。告警并不是越多越好，而是应该第一时间准确反映出服务的异常情况，所以如何提升有效告警，提高告警准确性，减少告警量至关重要。通过以上系统设计和功能设计能够有效减少重复告警发送。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;438&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.7583732057416268&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6icd9QRN6NrpC0BEHkBtqsqBz8Ovacg7ghWSIuCnyELzqicwuYjQ80Co5tP8sfAGche4EqCYTw4aAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;836&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（图9 主机监控告警次数图）&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;五、架构设计&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;上面我们从系统和功能层名讲解了如何针对老架构下存在的各种问题进行解决，那么对于这个构想我们应该用一套什么架构来实现。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下面我们看下如何设计这套架构。统一告警作为整个监控最后一环，既要满足告警发送能力也要满足业务服务发送通知的需求，所以统一告警的各种能力要具有通用性。统一告警服务要做到与其它服务低耦合，尤其是与已有监控系统做到解偶，这样才能真正把通用能力释放出来。服务要能做到根据业务场景的不同适配不同的业务逻辑，比如有的业务需要做告警收敛，有的业务不需要，那么服务要提供灵活的接入方式以适用业务需要。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如图10所示，统一告警核心逻辑由收敛服务实现，收敛服务可以消费kafka中的异常，也可以通过RestFul接口接收推送过来的异常，异常会先经过异常处理生成一个问题，然后将问题和异常存入MySql库，经过告警收敛模块问题会被推送到Redis延时队列中，延时队列会用来控制消息出队时间，消息从队列取出之后会进行文本组装等操作，最后会通过配置发送出去。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;337&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.58359375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6icd9QRN6NrpC0BEHkBtqsq761LoDhmbrGMuuVHbp9PuAtHLjztZseTMMOefArzv1usPhL7QgH3Ow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（图10 统一告警架构图）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;配置管理服务用来管理应用、事件、告警等配置信息，元数据同步服务用来从其它服务同步告警收敛所需的元数据。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;六、核心实现&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;统一告警的核心是告警收敛，收敛的目的就是减少发送重复的告警消息，避免因为大量的告警对于告警接收人造成告警麻痹。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;前文已经说到使用延时队列做告警收敛，延时队列在电商和支付项目中使用较多，比如商品下单后10分钟未支付就要自动取消订单。在告警系统中使用延时队列主要目的是，在一定的时间内尽可能多的将同一个问题对应的异常合并在一起，减少告警发送的数量。举个例，如果一个服务A有三个节点，当发生异常时，一般情况下每个节点的异常都会生成一条告警发送出去，但是经过告警收敛时候我们可以将三个节点的告警合并，由一条告警做通知。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;延时队列有很多种方式实现，这里我们选择了Redis实现延时队列，选用 Redis 延时队列主要的原因就是其支持高性能的 score 排序，同时 Redis 的持久化特性，保证了消息的消费和存贮问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如图11所示，一个问题通过一系列校验去重之后放入redis延时队列，队列中到期时间最小的问题会被排到最前面，同时有一个监听任务不断查看队列中是否有过期的任务，如果有过期的任务会被取出，取出的消息会经过消息组装等操作最终形成一条消息文本，然后根据配置通过不同的通道发送出去。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4318429661941112&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6icd9QRN6NrpC0BEHkBtqsqKJEI56amNJvqsVxaZKApFvaWvN77lOKFcoWCs0eppzRDwtUEhpezjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;917&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（图11 延时任务执行原理图[6]）&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;七、未来展望&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;基于统一告警服务定位来看，告警服务要能简单、高效、准确的告诉运维或者开发人员，哪里有故障需要去处理。所以对于后续服务的建设，应该考虑如何进一步减少人为的配置，增强告警智能化收敛的能力，同时还要增强根因定位的能力，以上通过AI的加持能够很好的解决此类问题。目前各大厂商都在向着AIOps探索前进，并且已经有一些产品投入使用，但是AIOps何时大规模落地，就目前来看还需要一段时间。相较于AI的使用，当前最紧迫的就是让统一告警串联起上下游服务，从而打通数据，为数据流转铺平道路，增强服务的自动化程度，并且支持从更高维度实现告警发送，为故障的发现和解决提供更准确的信息。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;八、参考资料&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;[1]&lt;a target=&quot;_blank&quot; href=&quot;https://www.motadata.com/blog/incident-management-metrics/&quot; textvalue=&quot;What are MTTR, MTBF, MTTF, and MTTA? A guide to Incident Management metrics&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;What are MTTR, MTBF, MTTF, and MTTA? A guide to Incident Management metrics&lt;/a&gt;&lt;/p&gt;&lt;p&gt;[2]&lt;a target=&quot;_blank&quot; href=&quot;https://zh.wikipedia.org/wiki/%E5%B9%B3%E5%9D%87%E4%BF%AE%E5%BE%A9%E6%99%82%E9%96%93%EF%BC%8C2020-10-09.&quot; textvalue=&quot;平均修复时间[Z]&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;平均修复时间[Z]&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;[3]&lt;a target=&quot;_blank&quot; href=&quot;http://blog.oneapm.com/apm-tech/289.html&quot; textvalue=&quot;运维不容错过的4个关键指标！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;运维不容错过的4个关键指标！&lt;/a&gt;&lt;/p&gt;&lt;p&gt;[4]&lt;a target=&quot;_blank&quot; href=&quot;http://www.netistate.com/news1/452.html&quot; textvalue=&quot;PIGOSS TOC 智慧服务中心让告警管理更智能&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;PIGOSS TOC 智慧服务中心让告警管理更智能&lt;/a&gt;&lt;/p&gt;&lt;p&gt;[5]&lt;a target=&quot;_blank&quot; href=&quot;https://www.docin.com/p-2505292466.html&quot; textvalue=&quot;大规模智能告警收敛与告警根因技术实践[EB/OL]&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;大规模智能告警收敛与告警根因技术实践[EB/OL]&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;[6]&lt;a target=&quot;_blank&quot; href=&quot;https://www.cnblogs.com/xiaowei123/p/13222710.html&quot; textvalue=&quot;你知道Redis可以实现延迟队列吗?&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;你知道Redis可以实现延迟队列吗?&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;END&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span title=&quot;&quot; opera-tn-ra-cell=&quot;_$.pages:0.layers:0.comps:93.title1&quot;&gt;&lt;p&gt;猜你喜欢&lt;/p&gt;&lt;/span&gt; &lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>38a561ff8ae35e08a3cf58efe96b6b9f</guid>
<title>sockfwd：一个数据转发的小工具</title>
<link>https://toutiao.io/k/4dygq68</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;content&quot;&gt;&lt;p&gt;最近在看containerd的代码，上手试的时候才发现它监听的是unix socket，没法从外部访问containerd。&lt;br/&gt;而我要验证的是从远端能不能访问containerd、管理containerd的容器，所以需要一个从远端访问unix socket的工具。&lt;/p&gt;
&lt;p&gt;网上搜了一圈，没有现成的实现，就自己写了 &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/robberphex/sockfwd&quot;&gt;sockfwd&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;用法&quot;&gt;用法&lt;/span&gt;&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Usage:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  sockfwd [flags]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;Flags:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  -d, --destination string   目的地址，即要转发到的地址&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  -s, --source string        源地址，即接收请求的地址&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  -q, --quiet                静默模式&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2&gt;&lt;span id=&quot;例子&quot;&gt;例子&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;将本地的containerd实例暴露到网络上：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;./sockfwd -s tcp://127.0.0.1:8090 -d unix:///var/run/containerd.sock&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;将本地的&lt;code&gt;127.0.0.1:8080&lt;/code&gt;端口暴露到&lt;code&gt;0.0.0.0:8090&lt;/code&gt;端口上：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;./sockfwd -s tcp://127.0.0.1:8090 -d unix://127.0.0.1:8090&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;将本地的服务暴露到网络上，需要格外注意是否有安全隐患！&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;其他碎碎念&quot;&gt;其他碎碎念&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;最近在写golang，发现如果仅仅是处理数据面的话，golang提供的goroute再加channel就能够很优雅地处理数据转发，比如这篇文章写的sockfwd。&lt;/p&gt;
&lt;p&gt;但是如果涉及管控面，比如复杂的状态管理，信息跨线程/goroute同步，那么channel的抽象能力还是不够的，需要写很多额外代码。&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;后续计划&quot;&gt;后续计划&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;可以加上支持tls认证来更加安全地转发数据。&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>