<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>984a75641ef8d8e8cd4dce1607c0d36a</guid>
<title>WICC 2020 重磅来袭！你关心的通信前沿技术都在这里！</title>
<link>https://toutiao.io/k/fwudviq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.2413793103448276&quot; data-type=&quot;gif&quot; data-w=&quot;638&quot; data-backw=&quot;578&quot; data-backh=&quot;140&quot; data-before-oversubscription-url=&quot;https://mmbiz.qpic.cn/mmbiz_gif/AUS4TZmVkaEY7hxNFbvia18U3jCictMrnoZ3B9marXlrRpKImKoMDIKQSianz68PAaAEQEJUiaqtvsSMlEMblU62Dw/0?wx_fmt=gif&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/AUS4TZmVkaEY7hxNFbvia18U3jCictMrnoZ3B9marXlrRpKImKoMDIKQSianz68PAaAEQEJUiaqtvsSMlEMblU62Dw/640?wx_fmt=gif&quot;/&gt;&lt;/p&gt;&lt;p&gt;随着信息技术的不断发展，以云计算技术理念和服务模式所提供的 IP 通信能力，已经开始被广泛应用于互联网应用、企业级应用和新兴的智能硬件场景中。毋庸置疑的是，以云方式来实现话音、视频、消息等能力的运营、维护和管理，并以服务的方式向应用提供支持，将带来业务运营和产品体验上的显著升级和突破。&lt;/p&gt;&lt;p&gt;如今，面对开发者企业对通信的新诉求，通信的场景正由单一走向多样化。尤其是在新基建及 5G 技术的浪潮下，通信云将在提升互联网应用及企业通信开发和使用的效率、降低成本方面发挥出巨大的价值。不在变革中兴起，就在沉默中灭亡。&lt;span&gt;&lt;strong&gt;10 月 31 日，WICC 2020 全球互联网通信云大会&lt;/strong&gt;&lt;/span&gt;将于深圳前海华侨城 JW 万豪酒店拉开帷幕，本届大会将以“融汇通信，云启未来”为主题，探讨在新基建、5G 生态等国家发展战略中，通信云技术未来所发挥的价值与作用。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;WICC 2020 将汇聚全球通信云技术领袖和行业领导企业，开展技术及行业的巅峰对话，同时现场将以多形式进行互动交流，为开发者提供更多的行业发展、前沿技术趋势，以及一线实践经验。&lt;/strong&gt;&lt;/span&gt;此外，在现场还将有丰富的礼品以及免费自助午宴值得期待~&lt;/p&gt;&lt;section&gt;&lt;span&gt;1&lt;/span&gt;作为一场通信领域的全球技术盛会，本次大会将有哪些重磅干货？&lt;/section&gt;&lt;p&gt;当前，通信云正在从传统通信迈向互联网通信时代，5G、云计算等技术的迅猛发展，更加速了这一变革。在这样的时代浪潮下，我们更需要洞悉未来趋势，把握机遇，明确发展方向。&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 行业新风向&lt;/section&gt;&lt;p&gt;来自信息通信领域的专家将为你解读新基建下的国家通信云生态建设；华为 5G 通信技术专家将从前台通信到架构构建，详细剖析 5G 生态的关键技术挑战；还有通信领域投资人带你洞悉通信云产业的格局与未来发展趋势！&lt;/p&gt;&lt;p&gt;此外，本次大会将围绕 5G 下的新通信技术突破、实时音视频新应用场景和通信技术在业务架构中的演进三大主题展开讨论，并关注 VR、IoT、AI、国产化等热点领域下正在发生的通信技术变革，解读通信云技术在后疫情时代下的机遇与挑战。&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 技术最解码&lt;/section&gt;&lt;p&gt;VR、车联网等新应用场景将成为 5G 大有可为之领域。在此次全球互联网通信云大会上，行业领军企业将揭秘 VR 沉浸式体验背后的低延迟通信技术。车联网优秀企业也将带来 5G 出行时代高互动性能实现路径的前沿探索与分享。与此同时，互联网巨头将现场解读实时音视频直播的架构建设，解读国产化统一操作系统架构下的多边技术融合，也会带来在亿级终端数据体量下的高并发架构的深度解析 ，从技术角度解码“架构”。&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 实践出真知&lt;/section&gt;&lt;p&gt;随着网络基础设施的优化和底层技术的成熟，实时音视频在互联网通信中的地位逐渐提升，并能够与即时通讯结合发挥协同效应。实时音视频云服务可以满足用户对线上实时音频、视频交流的需求，除了高质量的音视频通话外，还可应用于视频会议、无接触服务、智能硬件等诸多场景中。对于用户来讲，极致的体验才是“王道”，而通信技术能力的优劣直接关系到用户的使用体验。&lt;strong&gt;本次大会将探讨实时音视频背后的场景实践及技术发展策略，并展现头部厂商在远程会议、电商、在线教育等领域为用户带来的全新体验与技术突破。&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;2&lt;/span&gt;参与这次全球技术盛会，你将收获什么？&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;洞见通信云领域的前沿趋势，了解通信技术在新基建、5G 生态下的机遇与挑战；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;技术领袖巅峰对话，为你照亮通信云的未来发展之路；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;深入了解音视频领域在多种新场景下的最新实践与技术应用；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;丰富的开发者互动环节，现场多种形式的深度交流，让你与志同道合者分享经验与心得，一起进行思维碰撞；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;礼品丰厚，五星酒店免费自助午餐，现场福利不断，在提升认知、开拓思维和眼界的同时，尽情享受福利，把礼品带回家！&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;全球通信云时代已经到来！你还在等待什么？&lt;/p&gt;&lt;p&gt;点击&lt;span&gt;阅读原文&lt;/span&gt;或扫描下方&lt;span&gt;海报二维码&lt;/span&gt;，快速报名：&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://wicc.rongcloud.cn/?utm_source=wechat&amp;amp;utm_term=wicc&quot; textvalue=&quot;你已选中了添加链接的内容&quot; tab=&quot;outerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;312&quot; data-ratio=&quot;0.5555555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AUS4TZmVkaHfKkvpcm0tzib5cDaVNSEuGCPHnEXibeOWvexFXvjhOgGlWavZyooyDfjaAn5Yp0fxGguh0EPg4enQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section label=&quot;Copyright © 2014 playhudong All Rights Reserved.&quot; donone=&quot;shifuMouseDownOther(&#x27;shifu_o_028&#x27;)&quot;&gt;&lt;img data-ratio=&quot;0.45454545454545453&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/AUS4TZmVkaE7mKqiamP9Qc99skibiaMM3kqt2wASCXHaP3QmZGLQjlqrZibduRfqQPz7epcVaXgEtXt7HA8gbpL0bQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;22&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;section xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;section label=&quot;Copyleft 2018 iPaiban All lefts Reserved （本样式已做版权保护，未经正式授权不允许任何第三方编辑器、企业、个人使用，违者必纠）&quot; donone=&quot;shifuMouseDownPayStyle(&#x27;shifu_qmi_015&#x27;)&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;往 届 WICC 精 彩 推 荐 &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;【PPT 下载】走进 WICC 2019 预见互联网通信云未来技术&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzI1MTIyNTU2MQ==&amp;amp;mid=2247485988&amp;amp;idx=2&amp;amp;sn=d0f176b2d7fbcc0dad95d32a646519ea&amp;amp;chksm=e9f77e92de80f7845a20092af36408f70c88e3b9df5da01e533c21e4bc5e0bdb8f26db5c79a5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; tab=&quot;outerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;167&quot; data-backw=&quot;578&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;167&quot; data-ratio=&quot;0.28923076923076924&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AUS4TZmVkaHfKkvpcm0tzib5cDaVNSEuGPVGfIp0miaY6DicTPerVpfBYdS67Y5UmOnEcmXz2KYVecib80dIYaOicNw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;650&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;一张图领略 WICC 精彩看点&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzI1MTIyNTU2MQ==&amp;amp;mid=2247485988&amp;amp;idx=3&amp;amp;sn=a14a851c979170ee3533ba9cd5e9b2c6&amp;amp;chksm=e9f77e92de80f78419b97f3c51486d75426ab7139df2355ba7e7a7e78eb69774e292ae7a0f3d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; tab=&quot;outerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;167&quot; data-backw=&quot;578&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;167&quot; data-ratio=&quot;0.28923076923076924&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AUS4TZmVkaHfKkvpcm0tzib5cDaVNSEuGREKhkPAdKuvYkFEnwQzicw3PwHDZcnEiak3PKyuSqUicQS3oBCqAwSnrg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;650&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;WICC 2019：融云首次解密全球通信网底层基础架构&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzI1MTIyNTU2MQ==&amp;amp;mid=2247486025&amp;amp;idx=1&amp;amp;sn=013248f0e94261c506a4c1da6f21b085&amp;amp;chksm=e9f77effde80f7e9599bb645dd51a3b15c2d94df2dc9e83ddb2dadd119ab404ab23d173275e3&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; tab=&quot;outerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;167&quot; data-backw=&quot;578&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;167&quot; data-ratio=&quot;0.28923076923076924&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AUS4TZmVkaHfKkvpcm0tzib5cDaVNSEuG7vzTo8OmNeadibSRDEzGauIMgianBvia0XPdE7MoqbQnLWEK9ichUdo9jA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;650&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5712050078247262&quot; data-type=&quot;gif&quot; data-w=&quot;639&quot; data-backw=&quot;578&quot; data-backh=&quot;330&quot; data-before-oversubscription-url=&quot;https://mmbiz.qpic.cn/mmbiz_gif/AUS4TZmVkaEY7hxNFbvia18U3jCictMrnomGCQ2sj4hJTSLIzpPIE0GJHG7dAQAoG1icLhyichyMIctPn2T1yOszTg/0?wx_fmt=gif&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/AUS4TZmVkaEY7hxNFbvia18U3jCictMrnomGCQ2sj4hJTSLIzpPIE0GJHG7dAQAoG1icLhyichyMIctPn2T1yOszTg/640?wx_fmt=gif&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;点击阅读原文&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;立刻免费报名&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;↓↓&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f1b0a56258e969585edad1e500695315</guid>
<title>Go 使用标准库 net/http 包构建服务器</title>
<link>https://toutiao.io/k/ah8srmt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.0374331550802138&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gf7zJ2NXUibEatLJbcDLrEklG7PpIJibibEZ243hQfTYAOnUKKO8WJGtNK0FtNOyibfohow3qklfpW5e7l6y8hXefA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;748&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;01&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;概念&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在 Go 语言中，使用标准库 net/http 可以很方便的构建服务器，只要调用 ListenAndServe 函数，并传入参数IP地址与端口组成的字符串和处理器（handler）即可。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;func ListenAndServe(addr string, &lt;span class=&quot;code-snippet__keyword&quot;&gt;handler&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;Handler&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;error&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果 IP 地址与端口组成的字符串参数为空字符串，那么服务器默认使用 80 端口进行网络连接，如果处理器（handler）参数为 nil，那么服务器将使用默认多路复用器 DefaultServeMux。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;02&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;构建服务器&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;细心的读者可能会说，服务器配置信息除了 IP 地址和端口之外，还有很多其它配置信息，应该怎么配置给服务器呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Go 语言为我们提供了一个结构体 Server，其中包含了很多对服务器的其它配置，结构体 Server 的完整代码如下：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;type &lt;span class=&quot;code-snippet__type&quot;&gt;Server&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__type&quot;&gt;Addr&lt;/span&gt;              string&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__type&quot;&gt;Handler&lt;/span&gt;           &lt;span class=&quot;code-snippet__type&quot;&gt;Handler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__type&quot;&gt;TLSConfig&lt;/span&gt;         *tls.&lt;span class=&quot;code-snippet__type&quot;&gt;Config&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__type&quot;&gt;ReadTimeout&lt;/span&gt;       time.&lt;span class=&quot;code-snippet__type&quot;&gt;Duration&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__type&quot;&gt;ReadHeaderTimeout&lt;/span&gt; time.&lt;span class=&quot;code-snippet__type&quot;&gt;Duration&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__type&quot;&gt;WriteTimeout&lt;/span&gt;      time.&lt;span class=&quot;code-snippet__type&quot;&gt;Duration&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__type&quot;&gt;IdleTimeout&lt;/span&gt;       time.&lt;span class=&quot;code-snippet__type&quot;&gt;Duration&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__type&quot;&gt;MaxHeaderBytes&lt;/span&gt;    int&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__type&quot;&gt;TLSNextProto&lt;/span&gt;      &lt;span class=&quot;code-snippet__built_in&quot;&gt;map&lt;/span&gt;[string]&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(*Server, *tls.Conn, Handler)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__type&quot;&gt;ConnState&lt;/span&gt;         &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(net.Conn, ConnState)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__type&quot;&gt;ErrorLog&lt;/span&gt;          *log.&lt;span class=&quot;code-snippet__type&quot;&gt;Logger&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__type&quot;&gt;BaseContext&lt;/span&gt;       &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(net.Listener)&lt;/span&gt;&lt;/span&gt; context.&lt;span class=&quot;code-snippet__type&quot;&gt;Context&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__type&quot;&gt;ConnContext&lt;/span&gt;       &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(ctx context.Context, &lt;span class=&quot;code-snippet__built_in&quot;&gt;c&lt;/span&gt; net.Conn)&lt;/span&gt;&lt;/span&gt; context.&lt;span class=&quot;code-snippet__type&quot;&gt;Context&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    inShutdown        atomicBool&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    disableKeepAlives int32&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    nextProtoOnce     sync.&lt;span class=&quot;code-snippet__type&quot;&gt;Once&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    nextProtoErr      error&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    mu                sync.&lt;span class=&quot;code-snippet__type&quot;&gt;Mutex&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    listeners         &lt;span class=&quot;code-snippet__built_in&quot;&gt;map&lt;/span&gt;[*net.&lt;span class=&quot;code-snippet__type&quot;&gt;Listener&lt;/span&gt;]&lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt;&lt;/span&gt;{}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    activeConn        &lt;span class=&quot;code-snippet__built_in&quot;&gt;map&lt;/span&gt;[*conn]&lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt;&lt;/span&gt;{}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    doneChan          chan &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt;&lt;/span&gt;{}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    onShutdown        []&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;使用结构体 Server 构建服务器：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;server := http.Server{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Addr: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;:8080&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Handler: nil,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;server.ListenAndServe()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;03&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;接收 HTTP 请求&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在 Go 语言中，一个处理器就是一个拥有 ServeHTTP 方法的接口，这个 ServeHTTP 方法需要接收两个参数，第一个参数是一个 ResponseWriter 接口，&lt;span&gt;第二个参数是一个指向 Request 结构的指针。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;DefaultServeMux 默认多路复用器是多路复用器 ServeMux 结构的一个实例，ServeMux 也拥有 ServeHTTP 方法。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;所以 DefaultServeMux 既是 ServeMux 结构的实例，也是处理器 Handler 结构的实例，因此 DefaultServeMux 不仅是一个多路复用器，还是一个处理器。&lt;span&gt;但是 DefaultServeMux 是一个特殊的处理器，它唯一要做的就是根据请求的 URL 将请求重定向到不同的处理器。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;自定义一个处理器，替代 DefaultServeMux。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; MyHandler &lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(h *MyHandler)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;ServeHTTP&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(w http.ResponseWriter, r *http.Request)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  fmt.Fprintf(w, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Hello World!&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;使用自定义处理器，配置服务器。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;handler&lt;/span&gt; := MyHandler{}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;server&lt;/span&gt; := http.Server{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Addr: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;127.0.0.1:8080&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;Handler&lt;/span&gt;: &amp;amp;&lt;span class=&quot;code-snippet__keyword&quot;&gt;handler&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;server.ListenAndServe()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;细心的读者可能已经发现，使用自定义的处理器与服务器进行绑定，启动服务器，不管浏览器访问什么地址，服务器返回的都是同样的响应 Hello World!&lt;/p&gt;&lt;p&gt;&lt;br/&gt;这是因为使用自定义的处理器替代了默认多路复用器 DefaultServeMux，服务器不会再通过 URL 匹配来将请求路由至不同的处理器。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;怎么解决这个问题呢？&lt;/p&gt;&lt;p&gt;使用多个处理器。&lt;span&gt;使用 http 包的 Handle 函数绑定到 DefaultServeMux。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;为了使用多个处理器去处理不同的 URL，我们不再在 Serve 结构&lt;/p&gt;&lt;p&gt;的 Handler 字段中指定处理器，而是让服务器使用默认多路复用器 DefaultServeMux，&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后通过 http.Handle 函数将处理器绑定到 DefaultServeMux。&lt;/span&gt;&lt;span&gt;http 包的 Handle 函数实际上是 ServeMux 结构的方法，为了操作便利而创建的函数，调用它们等同于调用 DefaultServeMux 的某个方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;例如，调用 &lt;/span&gt;&lt;span&gt;http.Handle，实际上就是在调用 DefaultServeMux 的 Handle 方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;示例代码：&lt;/p&gt;&lt;p&gt;编写多个处理器，处理请求&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; FirstHandler &lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(f *FirstHandler)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;ServeHTTP&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(w http.ResponseWriter, r *http.Request)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  fmt.Fprintf(w, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;FirstHandler&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; SecondHandler &lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(s *SecondHandler)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;ServeHTTP&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(w http.ResponseWriter, r *http.Request)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  fmt.Fprintf(w, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;SecondHandler&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;构建服务器：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;first := FirstHandler{}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;second := SecondHandler{}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;server := http.Server{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Addr: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;127.0.0.1:8080&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;http.Handle(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/first&quot;&lt;/span&gt;, &amp;amp;first)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;http.Handle(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/second&quot;&lt;/span&gt;, &amp;amp;second)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;server.ListenAndServe()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;以上我们通过使用 http.Handle 函数，将一个创建的处理器绑定到一个 URL 上，实现使用多个处理器处理不同的 URL。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;现在，可能有读者会说，创建多个处理器来处理多个请求，这也太不优雅了，有没有其它方式呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;先告诉大家答案，有其它方式，使用处理器函数。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;http.HandleFunc 函数将自定义函数转换成一个处理器 Handler，并将它与 DefaultServeMux 进行绑定，从而简化创建并绑定 Handler 的工作。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;示例代码：&lt;/p&gt;&lt;p&gt;编写多个函数，处理请求&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(w http.ResponseWriter, r *http.Request)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  fmt.&lt;span class=&quot;code-snippet__type&quot;&gt;Fprintf&lt;/span&gt;(w, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;func first&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(w http.ResponseWriter, r *http.Request)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  fmt.&lt;span class=&quot;code-snippet__type&quot;&gt;Fprintf&lt;/span&gt;(w, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;func second&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;构建服务器：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;server := http.Server{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Addr: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;127.0.0.1:8080&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;// http.HandleFunc&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;http.HandleFunc(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/first&quot;&lt;/span&gt;, first)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;http.HandleFunc(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/second&quot;&lt;/span&gt;, second)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;server.ListenAndServe()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;使用处理器函数和使用处理器，都可以实现根据请求的 URL 将请求重定向到不同的处理器，而且处理器函数比处理器的代码更为简洁。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;但是也不是完全使用处理器函数代替处理器，因为如果代码已经包含了某个接口或某种类型，我们只需为它们添加 ServeHTTP 方法就可以将它们转变为处理器。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;ServeMux 无法使用变量实现 URL 模式匹配，使用三方多路复用器 httprouter 包可以实现 URL 模式匹配。&lt;span&gt;此外，还有一个非常优秀的三方多路复用器，gorilla/mux。&lt;/span&gt;&lt;span&gt;篇幅限制，这里就不展开了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;04&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;处理 HTTP 请求&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;客户端和服务器端传递的消息，我们称之为 HTTP 报文，有两种类型，分别是 HTTP 请求和 HTTP 响应，并且这两种类型的结构相同。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;请求行/响应行&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;零个/多个首部&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;一个空行&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;一个可选的报文主体&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在 Go 语言中，标准库 net/http 提供了一系列用于表示 HTTP 报文的结构体。其中，Request 结构体代表 HTTP 请求报文。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Request 结构体的组成部分：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;请求/响应的首部都是使用 Header 类型描述，Header 类型使用一个 map 来表示 HTTP 首部中的多个键值对。Header 类型有 4 个基本方法，这些方法可以根据给定的键执行添加、删除、获取和设置等操作。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;获取请求首部的示例代码：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;headers&lt;/span&gt;(&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.ResponseWriter&lt;/span&gt;, &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;r&lt;/span&gt; *&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.Request&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attribute&quot;&gt;h &lt;/span&gt;:= r.Header&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  fmt.&lt;span class=&quot;code-snippet__built_in&quot;&gt;Fprintln&lt;/span&gt;(w, h)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  h2 := r.Header[&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;User-Agent&quot;&lt;/span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  fmt.&lt;span class=&quot;code-snippet__built_in&quot;&gt;Fprintln&lt;/span&gt;(w, h2)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  h3 := r.Header.&lt;span class=&quot;code-snippet__built_in&quot;&gt;Get&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;User-Agent&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  fmt.&lt;span class=&quot;code-snippet__built_in&quot;&gt;Fprintln&lt;/span&gt;(w, h3)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;构建服务器：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;server := http.Server{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Addr: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;127.0.0.1:8080&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;http.HandleFunc(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/headers&quot;&lt;/span&gt;, headers)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;server.ListenAndServe()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;代码中，通过 r.Header 获取所有首部，通过 r.Header[&quot;key&quot;] 获取指定的首部，直接引用 Header 获取的是一个字符串切片，如果我们需要获取字符串格式的首部值，可以使用 r.Header.Get(&quot;key&quot;) 方法。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;请求/响应的主体都是用 Request 结构体的 Body 字段表示，这个字段是一个io.ReadCloser 接口，该接口即包含了 Reader 接口，也包含了 Closer 接口。其中 Reader 接口有 Read 方法，该方法接收一个字节切片参数，返回一个被读取内容的字节数和一个可选的错误。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;获取请求主体中的数据的代码：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;body&lt;/span&gt;(&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.ResponseWriter&lt;/span&gt;, &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;r&lt;/span&gt; *&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.Request&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attribute&quot;&gt;len &lt;/span&gt;:= r.ContentLength&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  body := &lt;span class=&quot;code-snippet__built_in&quot;&gt;make&lt;/span&gt;([]byte, len)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  r.Body.&lt;span class=&quot;code-snippet__built_in&quot;&gt;Read&lt;/span&gt;(body)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  fmt.&lt;span class=&quot;code-snippet__built_in&quot;&gt;Fprintln&lt;/span&gt;(w, string(body))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;构建服务器：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;server := http.Server{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Addr: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;127.0.0.1:8080&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;http.HandleFunc(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/body&quot;&lt;/span&gt;, body)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;server.ListenAndServe()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;代码中，通过 r.ContentLength 方法获取主体数据的字节长度，然后根据字节长度创建一个字节数组，然后调用 Read 方法将主体数据读取到字节数组中。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;可能有的读者朋友们开始抱怨了，这也太麻烦了。别担心，Go 语言标准库net/http 提供了相关函数来满足用户对数据提取方面的需求，通过调用 Request 结构体提供的方法，可以将 URL、主体的数据提取到该结构体的 Form、PostForm 和 MultipartForm 等字段中。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;示例代码：&lt;/p&gt;&lt;p&gt;使用 Request 结构体提供的方法提取数据&lt;span&gt;（enctype 属性的值为&lt;/span&gt;&lt;span&gt;application/x-www-form-urlencoded&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;getVal&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(w http.ResponseWriter, r *http.Request)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  r.&lt;span class=&quot;code-snippet__type&quot;&gt;ParseForm&lt;/span&gt;()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  fmt.&lt;span class=&quot;code-snippet__type&quot;&gt;Fprintln&lt;/span&gt;(w, r.&lt;span class=&quot;code-snippet__type&quot;&gt;Form&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  fmt.&lt;span class=&quot;code-snippet__type&quot;&gt;Fprintln&lt;/span&gt;(w, r.&lt;span class=&quot;code-snippet__type&quot;&gt;PostForm&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  fmt.&lt;span class=&quot;code-snippet__type&quot;&gt;Fprintln&lt;/span&gt;(w, r.&lt;span class=&quot;code-snippet__type&quot;&gt;FormValue&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;username&quot;&lt;/span&gt;)) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  fmt.&lt;span class=&quot;code-snippet__type&quot;&gt;Fprintln&lt;/span&gt;(w, r.&lt;span class=&quot;code-snippet__type&quot;&gt;PostFormValue&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;username&quot;&lt;/span&gt;)) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用 Request 结构体提供的方法&lt;/span&gt;&lt;span&gt;提取数据（enctype 属性的值为multipart/form-data&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;getMultipart&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(w http.ResponseWriter, r *http.Request)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  r.&lt;span class=&quot;code-snippet__type&quot;&gt;ParseMultipartForm&lt;/span&gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;1024&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  fmt.&lt;span class=&quot;code-snippet__type&quot;&gt;Fprintln&lt;/span&gt;(w, r.&lt;span class=&quot;code-snippet__type&quot;&gt;Form&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  fmt.&lt;span class=&quot;code-snippet__type&quot;&gt;Fprintln&lt;/span&gt;(w, r.&lt;span class=&quot;code-snippet__type&quot;&gt;PostForm&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  fmt.&lt;span class=&quot;code-snippet__type&quot;&gt;Fprintln&lt;/span&gt;(w, r.&lt;span class=&quot;code-snippet__type&quot;&gt;MultipartForm&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  fmt.&lt;span class=&quot;code-snippet__type&quot;&gt;Fprintln&lt;/span&gt;(w, r.&lt;span class=&quot;code-snippet__type&quot;&gt;FormValue&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;username&quot;&lt;/span&gt;)) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  fmt.&lt;span class=&quot;code-snippet__type&quot;&gt;Fprintln&lt;/span&gt;(w, r.&lt;span class=&quot;code-snippet__type&quot;&gt;PostFormValue&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;username&quot;&lt;/span&gt;)) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;构建服务器：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;server := http.Server{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Addr: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;127.0.0.1:8080&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;http.HandleFunc(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/getVal&quot;&lt;/span&gt;, getVal)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;http.HandleFunc(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/getMultipart&quot;&lt;/span&gt;, getMultipart)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;server.ListenAndServe()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;使用 Request 结构的方法获取表单数据：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;1. 调用 ParseForm 方法或者 ParseMultipartForm 方法，对请求进行语法分析。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;2. 取值：&lt;/p&gt;&lt;p&gt;r.Form，map 类型，键是字符串，值是字符串切片。&lt;/p&gt;&lt;p&gt;如果键同时存在表单和 URL，值包含表单值和 URL 值，并且表单值排在前面。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;r.PostForm，如果键同时存在表单和 URL，只取要表单的值。&lt;/p&gt;&lt;p&gt;只支持 application/x-www-form-urlencoded 编码。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;r.MultipartForm，支持 multipart/form-data 编码。&lt;/p&gt;&lt;p&gt;只取表单的值，不取 URL 的值。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;上面提到的几个方法，可能有些读者朋友感觉比较繁琐，别担心，Request 结构体还提供了另外一些方法，FormValue &lt;span&gt;和 PostFormValue，&lt;/span&gt;&lt;span&gt;它们可以让用户更容易地获取表单中的键值对。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;FormValue 方法直接获取指定键的值，不需要在之前调用语法分析的方法。&lt;/p&gt;&lt;p&gt;如果键同时存在表单和 URL，只取表单的值。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;PostFormValue 方法只会取表单的值，不取 URL 的值。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;05&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;给客户端发送响应&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;处理器通过 ResponseWriter 接口创建 HTTP 响应。ResponseWriter 接口有以下 3 个方法：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;示例代码：&lt;/p&gt;&lt;p&gt;写主体：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;setVal&lt;/span&gt;(&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.ResponseWriter&lt;/span&gt;, &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;r&lt;/span&gt; *&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.Request&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attribute&quot;&gt;str &lt;/span&gt;:= &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Hello World!&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  w.&lt;span class=&quot;code-snippet__built_in&quot;&gt;WriteHeader&lt;/span&gt;(501) // 设置响应返回的状态码，必须在 Write 方法之前调用。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  w.&lt;span class=&quot;code-snippet__built_in&quot;&gt;Write&lt;/span&gt;([]byte(str)) // 写入响应主体&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;写首部：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;setHeader&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(w http.ResponseWriter, r *http.Request)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  w.&lt;span class=&quot;code-snippet__type&quot;&gt;Header&lt;/span&gt;().&lt;span class=&quot;code-snippet__type&quot;&gt;Set&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Location&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;https://www.baidu.com&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  w.&lt;span class=&quot;code-snippet__type&quot;&gt;WriteHeader&lt;/span&gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;302&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;构建服务器：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;server := http.Server{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Addr: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;127.0.0.1:8080&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;http.HandleFunc(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/setVal&quot;&lt;/span&gt;, setVal)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;http.HandleFunc(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/setHeader&quot;&lt;/span&gt;, setHeader)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;server.ListenAndServe()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;需要注意的是，&lt;span&gt;WriteHeader 方法执行完，不能再对首部写入，所以要提前对首部写入。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;06&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Cookie&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;关于 Cookie 本身的内容，可以阅读我们之前的一篇文章&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4Mjc1NTMyOQ==&amp;amp;mid=2247483895&amp;amp;idx=1&amp;amp;sn=f380337159998cc8b21ceb5d0956ba6b&amp;amp;chksm=9f81ab99a8f6228fc98a2dbc3b2dd426518ebfb3b216a8f1e1e595f9736e624fa73bd87f9398&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Gin 学习之 cookie 读写&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;本篇文章，我们只演示一些如何使用标准库 net/http 操作 cookie，包括写 cookie、读 cookie 和删 cookie。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在 Go 语言中，使用 Cookie 结构体表示 cookie。Cookie 结构体完整字段：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;Cookie struct {&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;Name&lt;/span&gt;       &lt;span class=&quot;code-snippet__string&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;Value&lt;/span&gt;      &lt;span class=&quot;code-snippet__string&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;Path&lt;/span&gt;       &lt;span class=&quot;code-snippet__string&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;Domain&lt;/span&gt;     &lt;span class=&quot;code-snippet__string&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;Expires&lt;/span&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;time.Time&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;RawExpires&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;MaxAge&lt;/span&gt;     &lt;span class=&quot;code-snippet__string&quot;&gt;int&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;Secure&lt;/span&gt;     &lt;span class=&quot;code-snippet__string&quot;&gt;bool&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;HttpOnly&lt;/span&gt;   &lt;span class=&quot;code-snippet__string&quot;&gt;bool&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;SameSite&lt;/span&gt;   &lt;span class=&quot;code-snippet__string&quot;&gt;SameSite&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;Raw&lt;/span&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;Unparsed&lt;/span&gt;   &lt;span class=&quot;code-snippet__string&quot;&gt;[]string&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通过代码，我们演示如何使用标准库 net/http 操作 cookie。&lt;/p&gt;&lt;p&gt;示例代码：&lt;/p&gt;&lt;p&gt;操作 cookie：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;setCookie&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(w http.ResponseWriter, r *http.Request)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  c1 := http.Cookie{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Name:  &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;c1&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Value: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;val1&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  c2 := http.Cookie{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Name:  &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;c2&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Value: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;val2&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  c3 := http.Cookie{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Name:  &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;c3&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Value: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;val3&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  w.Header().Set(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Set-Cookie&quot;&lt;/span&gt;, c1.String())&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  w.Header().Add(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Set-Cookie&quot;&lt;/span&gt;, c2.String())&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  http.SetCookie(w, &amp;amp;c3) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;getCookie&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(w http.ResponseWriter, r *http.Request)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  fmt.Fprintln(w, r.Header[&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Cookie&quot;&lt;/span&gt;])&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  c1, _ := r.Cookie(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;c1&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  fmt.Fprintln(w, c1)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  fmt.Fprintln(w, r.Cookies())&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;delCookie&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(w http.ResponseWriter, r *http.Request)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  c2 := http.Cookie{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Name:    &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;c2&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    MaxAge:  &lt;span class=&quot;code-snippet__number&quot;&gt;-1&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Expires: time.Unix(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  http.SetCookie(w, &amp;amp;c2)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;构建服务器：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;server := http.Server{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Addr: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;127.0.0.1:8080&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;http.HandleFunc(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/setCookie&quot;&lt;/span&gt;, setCookie)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;http.HandleFunc(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/getCookie&quot;&lt;/span&gt;, getCookie)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;http.HandleFunc(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/delCookie&quot;&lt;/span&gt;, delCookie)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;server.ListenAndServe()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.5405405405405406&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gf7zJ2NXUibHrBBNc13c09hsck0LRuBWagGRXUlOPE7Nto7kj7M5peJTpdZlgatE5HwOkQibCPDOjUC0FfcboIbA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;370&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐阅读：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4Mjc1NTMyOQ==&amp;amp;mid=2247483931&amp;amp;idx=1&amp;amp;sn=1f9ab3dd100b9c300175f0db6b6fb31b&amp;amp;chksm=9f81a875a8f62163d1ced8c835e0e3dbf516908a4dd870c44cc245086979d14acddf09579af1&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Go 使用三方 Redis 包操作 Redis&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>63f36a30202e37a6ca0335373b873597</guid>
<title>[译] VueJS 中更好的组件组合方式</title>
<link>https://toutiao.io/k/algd8ut</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;原文地址：https://itnext.io/better-composition-in-vue-fd35b9fe9c79&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;原文作者：&lt;span&gt;👉&lt;/span&gt;Francesco Vitullo&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;译文出自：&lt;span&gt;👉&lt;/span&gt;掘金翻译计划&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;本文永久链接：https://github.com/xitu/gold-miner/blob/master/article/2020/better-composition-in-vue.md&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;校对者：&lt;span&gt;👉&lt;/span&gt;Gesj-yean, &lt;span&gt;👉&lt;/span&gt;dupanpan&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;383&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.6625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/aqicFmRvjIbiayf0KbLeBiaQOwLxSYzMfI2pfAEibOssdC0etlKPOfSm7YcTn6P6sVibY3uqQhqWJia1XWxZIXalTD3g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;VueJS&lt;/strong&gt; 中有一些组合组件并复用逻辑的方法。在本文中，我将展示一种在 Vuejs (2.* 及 3.*) 中改进组合方式的方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我的确欣赏最近的 &lt;strong&gt;Composition API&lt;/strong&gt; 提案，但我认为视野还可以更开阔。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面，你可以看到一个实现了一种常规用例（从远端获取一个简单的数据并将其搭配不同的转场效果显示出来）的组件，尽管大部分逻辑及其相关的模版、数据和其它变量等与出现在其它地方或组件中的相同逻辑并无不同，它们还是出现在了该组件中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&amp;lt;template&amp;gt;&lt;br/&gt;&amp;lt;div&amp;gt;&lt;br/&gt;    &amp;lt;div v-if=&quot;loading&quot;&amp;gt; Loading... &amp;lt;/div&amp;gt;&lt;br/&gt;    &amp;lt;div v-if=&quot;error&quot;&amp;gt; An Error occured, please try again&amp;lt;/div&amp;gt;&lt;br/&gt;    &amp;lt;div v-if=&quot;hasData&quot;&amp;gt; {{ data }} &amp;lt;/div&amp;gt;&lt;br/&gt;&amp;lt;/div&amp;gt;&lt;br/&gt;&amp;lt;/template&amp;gt;&lt;br/&gt;&lt;br/&gt;&amp;lt;/template&amp;gt;&lt;br/&gt;&lt;br/&gt;&amp;lt;script&amp;gt;&lt;br/&gt;    export default {&lt;br/&gt;        data() {&lt;br/&gt;            return {&lt;br/&gt;                loading: false,&lt;br/&gt;                error: false,&lt;br/&gt;                data: {}&lt;br/&gt;            }&lt;br/&gt;        },&lt;br/&gt;        methods: {&lt;br/&gt;            fetchData() {&lt;br/&gt;                this.loading = true;&lt;br/&gt;                setTimeout(() =&amp;gt; {&lt;br/&gt;                    this.data = { text: &#x27;example&#x27; };&lt;br/&gt;                    this.loading = false;&lt;br/&gt;                }, 4000);&lt;br/&gt;            }&lt;br/&gt;        },&lt;br/&gt;        computed: {&lt;br/&gt;            hasData() {&lt;br/&gt;                return this.data &amp;amp;&amp;amp; !!this.data.text;&lt;br/&gt;            }&lt;br/&gt;        },&lt;br/&gt;        mounted() {&lt;br/&gt;            this.fetchData();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&amp;lt;/script&amp;gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该如何重构并改善这个组件呢？让我们一步步地让其更易读且更容易复用。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Vue Composition API&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;感谢新的 Vue Composition API，使得我们可以在不丢失由 Vue 组件提供的响应性或其它特性的前提下，抽出一些逻辑以来复用它。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式有助于组织代码、让组件更易读，并有助于降低总体复杂度。作为一种建议，我相信这些应该是重构巨大、复杂和混乱的组件时的首要之事。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们将抽取与获取数据有关的部分及相关的变量（&lt;strong&gt;loading、error&lt;/strong&gt; 等……），但我并不想谈论什么是 Composition API 以及其特性、优点和缺点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让我们来创建一个提供了获取数据必要功能及若干响应式变量的简单函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; { reactive, toRefs, computed, Ref, ComputedRef } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;@vue/composition-api&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;interface&lt;/span&gt; ReceivedData {&lt;br/&gt;    text?: &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;interface&lt;/span&gt; FetchState {&lt;br/&gt;    loading: &lt;span&gt;boolean&lt;/span&gt;,&lt;br/&gt;    error: &lt;span&gt;boolean&lt;/span&gt;,&lt;br/&gt;    data: ReceivedData&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;interface&lt;/span&gt; FetchDataVars {&lt;br/&gt;    loading: Ref&amp;lt;&lt;span&gt;boolean&lt;/span&gt;&amp;gt;;&lt;br/&gt;    error: Ref&amp;lt;&lt;span&gt;boolean&lt;/span&gt;&amp;gt;;&lt;br/&gt;    data: Ref&amp;lt;object&amp;gt;;&lt;br/&gt;    fetchData: &lt;span&gt;Function&lt;/span&gt;;&lt;br/&gt;    hasData: ComputedRef&amp;lt;&lt;span&gt;boolean&lt;/span&gt;&amp;gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; (): &lt;span&gt;&lt;span&gt;FetchDataVars&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; state = reactive&amp;lt;FetchState&amp;gt;({&lt;br/&gt;        loading: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;        error: &lt;span&gt;false&lt;/span&gt;,&lt;br/&gt;        data: {}&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; fetchData = &lt;span&gt;async&lt;/span&gt; () =&amp;gt; {&lt;br/&gt;        state.loading = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;            state.data = { text: &lt;span&gt;&#x27;example&#x27;&lt;/span&gt; };&lt;br/&gt;            state.loading = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        }, &lt;span&gt;4000&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; hasData = computed(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; state.data &amp;amp;&amp;amp; !!state.data.text)&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;        ...toRefs(state),&lt;br/&gt;        fetchData,&lt;br/&gt;        hasData&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新创建的函数现在返回了可被用于组件的一组响应式变量 (&lt;strong&gt;loading、error、data&lt;/strong&gt;，及 &lt;strong&gt;hasData&lt;/strong&gt;) 及一个用来执行数据获取任务的异步函数 (&lt;strong&gt;fetchData&lt;/strong&gt;，将会改变上述响应式变量) 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而后，来使用 Composition API 重构组件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&amp;lt;template&amp;gt;&lt;br/&gt;&amp;lt;div&amp;gt;&lt;br/&gt;    &amp;lt;div v-if=&quot;loading&quot;&amp;gt; Loading... &amp;lt;/div&amp;gt;&lt;br/&gt;    &amp;lt;div v-if=&quot;error&quot;&amp;gt; An Error occured, please try again&amp;lt;/div&amp;gt;&lt;br/&gt;    &amp;lt;div v-if=&quot;hasData&quot;&amp;gt; {{ data }} &amp;lt;/div&amp;gt;&lt;br/&gt;&amp;lt;/div&amp;gt;&lt;br/&gt;&amp;lt;/template&amp;gt;&lt;br/&gt;&lt;br/&gt;&amp;lt;/template&amp;gt;&lt;br/&gt;&lt;br/&gt;&amp;lt;script lang=&quot;ts&quot;&amp;gt;&lt;br/&gt;    import useFetchData from &#x27;../composables/use-fetch-data&#x27;;&lt;br/&gt;    import { defineComponent } from &#x27;@vue/composition-api&#x27;;&lt;br/&gt;&lt;br/&gt;    export default defineComponent({&lt;br/&gt;        setup() {&lt;br/&gt;            const { loading, error, data, fetchData, hasData } = useFetchData();&lt;br/&gt;            return {&lt;br/&gt;                loading,&lt;br/&gt;                error,&lt;br/&gt;                data, fetchData,&lt;br/&gt;                hasData&lt;br/&gt;            }&lt;br/&gt;        },&lt;br/&gt;        mounted() {&lt;br/&gt;            this.fetchData();&lt;br/&gt;        }&lt;br/&gt;    });&lt;br/&gt;&amp;lt;/script&amp;gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正如你所注意到的，我们的组件还包含了 setup 方法，由其调用 &lt;strong&gt;useFetchData&lt;/strong&gt; 函数，同时解构返回的变量和函数并将它们返回给组件实例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个例子中，我在 mounted 生命周期钩子中使用了 &lt;strong&gt;fetchData&lt;/strong&gt; 函数，但其实你可以在期望的任意位置调用它。无论何时，被该函数求值或改变的结果都会反映在组件中，因为它们都是响应式属性。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;JSX 和 TSX&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在假设我们想要将获取的数据传递到一个内部组件中。借助 VueJS 有多种实现的方法，但我却想使用  &lt;strong&gt;TSX&lt;/strong&gt; (你若更喜欢 &lt;strong&gt;JSX&lt;/strong&gt; 也行) 来重构代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&amp;lt;script lang=&quot;tsx&quot;&amp;gt;&lt;br/&gt;    import useFetchData from &#x27;../composables/use-fetch-data&#x27;;&lt;br/&gt;    import { defineComponent } from &#x27;@vue/composition-api&#x27;;&lt;br/&gt;&lt;br/&gt;    export default defineComponent({&lt;br/&gt;        setup() {&lt;br/&gt;            const { loading, error, data, fetchData, hasData } = useFetchData();&lt;br/&gt;            return {&lt;br/&gt;                loading,&lt;br/&gt;                error,&lt;br/&gt;                data, fetchData,&lt;br/&gt;                hasData&lt;br/&gt;            }&lt;br/&gt;        },&lt;br/&gt;        mounted() {&lt;br/&gt;            this.fetchData();&lt;br/&gt;        },&lt;br/&gt;        render() {&lt;br/&gt;            return (&lt;br/&gt;                &amp;lt;div&amp;gt;&lt;br/&gt;                    { this.loading &amp;amp;&amp;amp; &amp;lt;div&amp;gt; Loading ... &amp;lt;/div&amp;gt; }&lt;br/&gt;                    { this.error &amp;amp;&amp;amp; &amp;lt;div&amp;gt; An Error occured, please try again &amp;lt;/div&amp;gt; }&lt;br/&gt;                    { &amp;lt;div&amp;gt; { this.data } &amp;lt;/div&amp;gt; }&lt;br/&gt;                &amp;lt;/div&amp;gt;&lt;br/&gt;            )&lt;br/&gt;        }&lt;br/&gt;    });&lt;br/&gt;&amp;lt;/script&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我知道这看起来很像 React，但我相信这开启了以更好的方法优化组合方式的许多可能之门。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这其实很易懂，它完成了和模板同样的事情，但我们将 HTML 部分移入了 render 函数中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们尚未完成将数据传递进内部组件的任务，实际上我们像下面这样改进一点代码就行，也就是将所有东西导出成一个我们可复用的函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;import useFetchData from &#x27;../composables/use-fetch-data&#x27;;&lt;br/&gt;import { defineComponent } from &#x27;@vue/composition-api&#x27;;&lt;br/&gt;&lt;br/&gt;export default () =&amp;gt; defineComponent({&lt;br/&gt;    setup() {&lt;br/&gt;        const { loading, error, data, fetchData, hasData } = useFetchData();&lt;br/&gt;        return {&lt;br/&gt;            loading,&lt;br/&gt;            error,&lt;br/&gt;            data, fetchData,&lt;br/&gt;            hasData&lt;br/&gt;        }&lt;br/&gt;    },&lt;br/&gt;    mounted() {&lt;br/&gt;        this.fetchData();&lt;br/&gt;    },&lt;br/&gt;    render() {&lt;br/&gt;        return (&lt;br/&gt;            &amp;lt;div&amp;gt;&lt;br/&gt;                { this.loading &amp;amp;&amp;amp; &amp;lt;div&amp;gt; Loading ... &amp;lt;/div&amp;gt; }&lt;br/&gt;                { this.error &amp;amp;&amp;amp; &amp;lt;div&amp;gt; An Error occured, please try again &amp;lt;/div&amp;gt; }&lt;br/&gt;                { &amp;lt;div&amp;gt; { this.data } &amp;lt;/div&amp;gt; }&lt;br/&gt;            &amp;lt;/div&amp;gt;&lt;br/&gt;        )&lt;br/&gt;    }&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在我们已经更上一层楼了，摆脱 &lt;strong&gt;SFC&lt;/strong&gt; (单文件组件 -- Single File Component 文件) 后我们就可以真正的改进组织方式了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在此阶段，我们使用 defineComponent 创建了一个使用 Composition API 的组件并依托 JSX/TSX 消除了模板部分。这种方式的妙处在于可以将一个组件视为一个函数并自如运用函数式编程范式（如一级函数、纯函数等等……）了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举例来说，render 函数也包含了一个显示数据的 div，但想象下若将一个组件作为刚才所导出函数的一个参数，并在返回的 JSX/TSX 中使用它（将响应/数据作为属性传递给组件）是如何的呢。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看起来可能会是这样的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;import useFetchData from &#x27;../composables/use-fetch-data&#x27;;&lt;br/&gt;import { defineComponent } from &#x27;@vue/composition-api&#x27;;&lt;br/&gt;import { Component } from &#x27;vue&#x27;;&lt;br/&gt;&lt;br/&gt;export default (component: Component) =&amp;gt; defineComponent({&lt;br/&gt;    setup() {&lt;br/&gt;        const { loading, error, data, fetchData, hasData } = useFetchData();&lt;br/&gt;        return {&lt;br/&gt;            loading,&lt;br/&gt;            error,&lt;br/&gt;            data, fetchData,&lt;br/&gt;            hasData&lt;br/&gt;        }&lt;br/&gt;    },&lt;br/&gt;    mounted() {&lt;br/&gt;        this.fetchData();&lt;br/&gt;    },&lt;br/&gt;    render() {&lt;br/&gt;        const injectedComponentProps = {&lt;br/&gt;            data: this.data&lt;br/&gt;        }&lt;br/&gt;        return (&lt;br/&gt;            &amp;lt;div&amp;gt;&lt;br/&gt;                { this.loading &amp;amp;&amp;amp; &amp;lt;div&amp;gt; Loading ... &amp;lt;/div&amp;gt; }&lt;br/&gt;                { this.error &amp;amp;&amp;amp; &amp;lt;div&amp;gt; An Error occured, please try again &amp;lt;/div&amp;gt; }&lt;br/&gt;                &amp;lt;component props={ injectedComponentProps } /&amp;gt;&lt;br/&gt;            &amp;lt;/div&amp;gt;&lt;br/&gt;        )&lt;br/&gt;    }&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在我们正期待着将一个组件作为参数并在 render 函数中使用它。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还可以做得更多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上，我们也可以期待将 &lt;strong&gt;useFetchData&lt;/strong&gt; 函数作为所导出函数的一个参数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;import useFetchData from &#x27;../composables/use-fetch-data&#x27;;&lt;br/&gt;import { defineComponent, ComputedRef, Ref } from &#x27;@vue/composition-api&#x27;;&lt;br/&gt;import { Component } from &#x27;vue&#x27;;&lt;br/&gt;&lt;br/&gt;interface FetchDataVars {&lt;br/&gt;    loading: Ref&amp;lt;boolean&amp;gt;;&lt;br/&gt;    error: Ref&amp;lt;boolean&amp;gt;;&lt;br/&gt;    data: Ref&amp;lt;object&amp;gt;;&lt;br/&gt;    fetchData: Function;&lt;br/&gt;    hasData: ComputedRef&amp;lt;boolean&amp;gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;type FetchData = () =&amp;gt; FetchDataVars ;&lt;br/&gt;&lt;br/&gt;export default (component: Component, factoryFetchData: FetchData) =&amp;gt; defineComponent({&lt;br/&gt;    setup() {&lt;br/&gt;        const { loading, error, data, fetchData, hasData } = factoryFetchData();&lt;br/&gt;        return {&lt;br/&gt;            loading,&lt;br/&gt;            error,&lt;br/&gt;            data, fetchData,&lt;br/&gt;            hasData&lt;br/&gt;        }&lt;br/&gt;    },&lt;br/&gt;    mounted() {&lt;br/&gt;        this.fetchData();&lt;br/&gt;    },&lt;br/&gt;    render() {&lt;br/&gt;        const injectedComponentProps = {&lt;br/&gt;            data: this.data&lt;br/&gt;        }&lt;br/&gt;        return (&lt;br/&gt;            &amp;lt;div&amp;gt;&lt;br/&gt;                { this.loading &amp;amp;&amp;amp; &amp;lt;div&amp;gt; Loading ... &amp;lt;/div&amp;gt; }&lt;br/&gt;                { this.error &amp;amp;&amp;amp; &amp;lt;div&amp;gt; An Error occured, please try again &amp;lt;/div&amp;gt; }&lt;br/&gt;                &amp;lt;component data={ injectedComponentProps } /&amp;gt;&lt;br/&gt;            &amp;lt;/div&amp;gt;&lt;br/&gt;        )&lt;br/&gt;    }&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;借助这些改变，在组件之上，接受一个类型为 &lt;strong&gt;FetchData&lt;/strong&gt; 并返回一组符合预期的变量/函数/计算值的 &lt;strong&gt;函数&lt;/strong&gt; 作为参数，就可以使用包装过的新组件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一种依托函数式途径达成的相当有用的替代继承/扩展的方法。所以，不同于扩展已有的组件并覆写组件的函数的是，我们可以真正传入期望的组件和函数了。Typescript 在此仅有助于强类型化和类型推断，所以只用 Javascript 也是足够的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，如果我们想要使用它，看起来会是这样的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; withLoaderAndFetcher &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;./components/withLoaderAndFetcher&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; useFetchDataForEndpointOne &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;./composables/useFetchDataForEndpointOne&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; useFetchDataForEndpointTwo &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;./composables/useFetchDataForEndpointTwo&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; useFetchDataForEndpointThree &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;./composables/useFetchDataForEndpointThree&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; ComponentA &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;./components/ComponentA.vue&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; ComponentB &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;./components/ComponentB.vue&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; ComponentC &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;./components/ComponentC.vue&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; composedA = withLoaderAndFetcher(ComponentA, useFetchDataForEndpointOne);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; composedB = withLoaderAndFetcher(ComponentB, useFetchDataForEndpointTwo);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; composedC = withLoaderAndFetcher(ComponentC, useFetchDataForEndpointThree);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们将上例导出的函数称为 &lt;strong&gt;withLoaderAndFetcher&lt;/strong&gt; 并使用其组合了 3 个不同的组件和 3 个不同的函数（装饰者模式）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这项工作还能推进得更远，但我想展示的是达到这种状态的可能性并增加趋向函数式组合方式的方法数量。这只是示例代码，也可能不会工作得很好，但这种想法和概念才是要义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;干杯 :)&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如果发现译文存在错误或其他需要改进的地方，欢迎到 &lt;span&gt;👉&lt;/span&gt;掘金翻译计划 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 &lt;strong&gt;本文永久链接&lt;/strong&gt; 即为本文在 GitHub 上的 MarkDown 链接。&lt;/p&gt;&lt;/blockquote&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;👉&lt;/span&gt;掘金翻译计划 是一个翻译优质互联网技术文章的社区，文章来源为 &lt;span&gt;👉&lt;/span&gt;掘金 上的英文分享文章。内容覆盖 &lt;span&gt;👉&lt;/span&gt;Android、&lt;span&gt;👉&lt;/span&gt;iOS、&lt;span&gt;👉&lt;/span&gt;前端、&lt;span&gt;👉&lt;/span&gt;后端、&lt;span&gt;👉&lt;/span&gt;区块链、&lt;span&gt;👉&lt;/span&gt;产品、&lt;span&gt;👉&lt;/span&gt;设计、&lt;span&gt;👉&lt;/span&gt;人工智能等领域，想要查看更多优质译文请持续关注 &lt;span&gt;👉&lt;/span&gt;掘金翻译计划、&lt;span&gt;👉&lt;/span&gt;官方微博、&lt;span&gt;👉&lt;/span&gt;知乎专栏。&lt;/p&gt;&lt;/blockquote&gt;&lt;center data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;--End--&lt;/strong&gt;&lt;br/&gt;&lt;br/&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/aqicFmRvjIbiayf0KbLeBiaQOwLxSYzMfI2GTViajXvmiaCyzVTVV0DI96eFbRzjuIFPWEZkSbJibhJef6u4gMTY6ibVw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;p&gt;查看更多前端好文&lt;br/&gt;请搜索 fewelife 关注公众号&lt;br/&gt;&lt;br/&gt;&lt;span&gt;转载请注明出处&lt;/span&gt;&lt;/p&gt;&lt;/center&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fc3c9368bce46176ba93ffe78d42d444</guid>
<title>[推荐] 23 个问题 TCP 疑难杂症全解析</title>
<link>https://toutiao.io/k/yktjpks</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;每个时代，都不会亏待会学习的人。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是 yes。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在进入今天主题之前我先抛几个问题，这篇文章一共提出 23 个问题。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;TCP 握手一定是三次？TCP 挥手一定是四次？&lt;/p&gt;&lt;p&gt;为什么要有快速重传，超时重传不够用？为什么要有 SACK，为什么要有 D-SACK？&lt;/p&gt;&lt;p&gt;都知道有滑动窗口，那由于接收方的太忙了滑动窗口降为了 0 怎么办？发送方就永远等着了？&lt;/p&gt;&lt;p&gt;Silly Window 又是什么？&lt;/p&gt;&lt;p&gt;为什么有滑动窗口流控还需要拥塞控制？&lt;/p&gt;&lt;p&gt;快速重传一定要依赖三次重复 ACK ？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章我想&lt;span&gt;由浅到深地过一遍 TCP，不是生硬的搬出各个知识点，从问题入手，然后从发展、演进的角度来看 TCP&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;起初我在学计算机网络的时候就有非常非常多的疑问，脑子里简直充满了十万个为什么，而网络又非常的复杂，发展了这么多年东西真的太多了，今天我就&lt;span&gt;大致的浅显地说一说我对 TCP 这些要点的理解&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，废话不多说，开始上正菜。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;TCP 是用来解决什么问题？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCP 即 Transmission Control Protocol，可以看到是一个传输控制协议，重点就在这个&lt;span&gt;控制&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;控制什么？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;控制可靠、按序地传输以及端与端之间的流量控制。够了么？还不够，它需要更加智能，因此还需要加个拥塞控制，需要为整体网络的情况考虑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是&lt;span&gt;出行你我他，安全靠大家&lt;/span&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;为什么要 TCP，IP 层实现控制不行么？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道网络是分层实现的，网络协议的设计就是为了通信，从链路层到 IP 层其实就已经可以完成通信了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你看链路层不可或缺毕竟咱们电脑都是通过链路相互连接的，然后 IP 充当了地址的功能，所以通过 IP 咱们找到了对方就可以进行通信了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那加个 TCP 层干啥？IP 层实现控制不就完事了嘛？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之所以要&lt;span&gt;提取出一个 TCP 层来实现控制是因为 IP 层涉及到的设备更多&lt;/span&gt;，一条数据在网络上传输需要经过很多设备，而设备之间需要靠 IP 来寻址。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设 IP 层实现了控制，那是不是涉及到的设备都需要关心很多事情？整体传输的效率是不是大打折扣了？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0527426160337552&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3WoFibEeUXMM8oghHkbjedwjAo4zlzm5ymHSWRm3WE9w5rp9YicoQa0keJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;474&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我举个例子，假如 A 要传输给 F 一个积木，但是无法直接传输到，需要经过 B、C、D、E 这几个中转站之手。这里有两种情况：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;假设 BCDE 都需要关心这个积木搭错了没，都拆开包裹仔细的看看，没问题了再装回去，最终到了 F 的手中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;假设 BCDE 都不关心积木的情况，来啥包裹只管转发就完事了，由最终的 F 自己来检查这个积木答错了没。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你觉得哪种效率高？明显是第二种，转发的设备不需要关心这些事，只管转发就完事！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以把控制的逻辑独立出来成 TCP 层，让真正的接收端来处理，这样网络整体的传输效率就高了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;连接到底是什么？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们已经知道了为什么需要独立出 TCP 这一层，并且这一层主要是用来干嘛的，接下来就来看看它到底是怎么干的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道 TCP 是面向连接的，那这个连接到底是个什么东西？真的是拉了一条线让端与端之间连起来了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所谓的连接其实只是双方都维护了一个状态，通过每一次通信来维护状态的变更&lt;/span&gt;，使得看起来好像有一条线关联了对方。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;TCP 协议头&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在具体深入之前我们需要先来看看一些 TCP 头的格式，这很基础也很重要。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8130081300813008&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3WotC8rJxducKgmovDgJBcDDgsGRf0WiabU0eTEDJmz9mRv47QYa23nvUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;369&quot;/&gt;&lt;figcaption&gt;图来自网络&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我就不一一解释了，挑重点的说。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先可以看到 TCP 包只有端口，没有 IP。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Seq 就是 Sequence Number 即序号，它是用来解决乱序问题的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ACK 就是 Acknowledgement Numer 即确认号，它是用来解决丢包情况的，告诉发送方这个包我收到啦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标志位就是 TCP flags 用来标记这个包是什么类型的，用来控制 TPC 的状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;窗口就是滑动窗口，Sliding Window，用来流控。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三次握手&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;明确了协议头的要点之后，我们再来看三次握手。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;三次握手真是个老生常谈的问题了，但是真的懂了么？不是浮在表面？能不能延伸出一些点别的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来看一下熟悉的流程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5629032258064516&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3WoBAbxNgZSCpE74PyCgckpGyKLaFpUgrvpaAFyN4QRy8OSsHMHTa3VyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;图来自网络&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先为什么要握手，&lt;span&gt;其实主要就是为了初始化Seq Numer&lt;/span&gt;，SYN 的全称是 Synchronize Sequence Numbers，这个序号是用来保证之后传输数据的顺序性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你要说是为了测试保证双方发送接收功能都正常，我觉得也没毛病，&lt;span&gt;不过我认为重点在于同步序号&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那为什么要三次，就拿我和你这两个角色来说，首先我告诉你我的初始化序号，你听到了和我说你收到了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后你告诉我你的初始序号，然后我对你说我收到了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这好像四次了？如果真的按一来一回就是四次，但是中间一步可以合在一起，就是你和我说你知道了我的初始序号的时候同时将你的初始序号告诉我。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此四次握手就可以减到三次了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过你没有想过这么一种情形，我和你同时开口，一起告诉对方各自的初始序号，然后分别回应收到了，这不就是四次握手了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我来画个图，清晰一点。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6103646833013435&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3Wo60ILBhTZiaqDAx6GlA8iaAZBn5fscygTmCtXFw8jAD3tj8RaGcicqia7qw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;521&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看看是不是四次握手了? 不过具体还是得看实现，有些实现可能不允许这种情况出现，但是这不影响我们思考，因为&lt;span&gt;握手的重点就是同步初始序列号&lt;/span&gt;，这种情况也完成了同步的目标。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;初始序列号 ISN 的取值&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道大家有没有想过 ISN 的值要设成什么？代码写死从零开始？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想象一下如果写死一个值，比如 0 ，那么假设已经建立好连接了，client 也发了很多包比如已经第 20 个包了，然后网络断了之后 client 重新，端口号还是之前那个，然后序列号又从 0 开始，此时服务端返回第 20 个包的ack，客户端是不是傻了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以 RFC793 中认为 ISN 要和一个假的时钟绑定在一起&lt;span&gt;ISN 每四微秒加一，当超过 2 的 32 次方之后又从 0 开始，要四个半小时左右发生 ISN 回绕&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以 ISN 变成一个递增值，真实的实现还需要加一些随机值在里面，防止被不法份子猜到 ISN。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;SYN 超时了怎么处理？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是 client 发送 SYN 至 server 然后就挂了，此时 server 发送 SYN+ACK 就一直得不到回复，怎么办？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我脑海中一想到的就是重试，但是不能连续快速重试多次，你想一下，假设 client 掉线了，你总得给它点时间恢复吧，所以呢需要&lt;span&gt;慢慢重试，阶梯性重试&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Linux 中就是默认重试 5 次，并且就是阶梯性的重试，间隔就是1s、2s、4s、8s、16s，再第五次发出之后还得等 32s 才能知道这次重试的结果，所以说总共等63s 才能断开连接。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;SYN Flood 攻击&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你看到没 SYN 超时需要耗费服务端 63s 的时间断开连接，也就说 63s 内服务端需要保持这个资源，所以不法分子就可以构造出大量的 client 向 server 发 SYN 但就是不回 server。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6983122362869199&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3WomI7iao6PlT5NwRpJIicRH95kEaK5XgnrgnmpY9gMJvNE8TTLvtMdMhnw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;474&quot;/&gt;&lt;figcaption&gt;图来自网络&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使得 server 的 SYN 队列耗尽，无法处理正常的建连请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以怎么办？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以开启 tcp_syncookies，那就用不到 SYN 队列了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SYN 队列满了之后 TCP 根据自己的 ip、端口、然后对方的 ip、端口，对方 SYN 的序号，时间戳等一波操作生成一个特殊的序号（即 cookie）发回去，如果对方是正常的 client 会把这个序号发回来，然后 server 根据这个序号建连。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;或者调整 tcp_synack_retries 减少重试的次数，设置 tcp_max_syn_backlog 增加 SYN 队列数，设置 tcp_abort_on_overflow SYN 队列满了直接拒绝连接。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;为什么要四次挥手？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;四次挥手和三次握手成双成对，同样也是 TCP 中的一线明星，让我们重温一下熟悉的图。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.43902439024390244&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3Woh6ia91zo0kAoKKm8grBVQeBD78d98g9w4b4oa6HWTCRKK4CMxs6gicrg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;615&quot;/&gt;&lt;figcaption&gt;图来自网络&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么挥手需要四次？&lt;span&gt;因为 TCP 是全双工协议&lt;/span&gt;，也就是说双方都要关闭，每一方都向对方发送 FIN 和回应 ACK。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就像我对你说我数据发完了，然后你回复好的你收到了。然后你对我说你数据发完了，然后我向你回复我收到了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以看起来就是四次。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图中可以看到主动关闭方的状态是 FIN_WAIT_1 到 FIN_WAIT_2 然后再到 TIME_WAIT，而被动关闭方是 CLOSE_WAIT 到 LAST_ACK。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;四次挥手状态一定是这样变迁的吗&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;状态一定是这样变迁的吗？让我们再来看个图。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7897897897897898&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3WoFjVCKRI3KYFb0KPUReW1l8MZ2msibxYRIub9YTyX4KU3c73ibAPW6ibsA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;666&quot;/&gt;&lt;figcaption&gt;图来自网络&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到双方都主动发起断开请求所以各自都是主动发起方，状态会从 FIN_WAIT_1 都进入到 CLOSING 这个过度状态然后再到 TIME_WAIT。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;挥手一定需要四次吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设 client 已经没有数据发送给 server 了，所以它发送 FIN 给 server 表明自己数据发完了，不再发了，如果这时候 server 还是有数据要发送给 client 那么它就是先回复 ack ，然后继续发送数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;等 server 数据发送完了之后再向 client 发送 FIN 表明它也发完了，然后等 client 的 ACK 这种情况下就会有四次挥手。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么假设 client 发送 FIN 给 server 的时候 server 也没数据给 client，那么 server 就可以将 ACK 和它的 FIN 一起发给client ，然后等待 client 的 ACK，这样不就三次挥手了？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;为什么要有 TIME_WAIT?&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;断开连接发起方在接受到接受方的 FIN 并回复 ACK 之后并没有直接进入 CLOSED 状态，而是进行了一波等待，等待时间为 2MSL。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MSL 是 Maximum Segment Lifetime，即报文最长生存时间，RFC 793 定义的 MSL 时间是 2 分钟，Linux 实际实现是 30s，那么 2MSL 是一分钟。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么为什么要等 2MSL 呢？&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;就是怕被动关闭方没有收到最后的 ACK，如果被动方由于网络原因没有到，那么它会再次发送 FIN， 此时如果主动关闭方已经 CLOSED 那就傻了，因此等一会儿。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;假设立马断开连接，但是又重用了这个连接，就是五元组完全一致，并且序号还在合适的范围内，虽然概率很低但理论上也有可能，那么新的连接会被已关闭连接链路上的一些残留数据干扰，因此给予一定的时间来处理一些残留数据。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;等待 2MSL 会产生什么问题？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果服务器主动关闭大量的连接，那么会出现大量的资源占用，需要等到 2MSL 才会释放资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是客户端主动关闭大量的连接，那么在 2MSL 里面那些端口都是被占用的，端口只有 65535 个，如果端口耗尽了就无法发起送的连接了，不过我觉得这个概率很低，这么多端口你这是要建立多少个连接？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;如何解决 2MSL 产生的问题？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;快速回收&lt;/span&gt;，即不等 2MSL 就回收， Linux 的参数是 tcp_tw_recycle，还有 tcp_timestamps 不过默认是打开的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实上面我们已经分析过为什么需要等 2MSL，所以如果等待时间果断就是出现上面说的那些问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以不建议开启，而且 Linux 4.12 版本后已经咔擦了这个参数了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前不久刚有位朋友在群里就提到了这玩意。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.48007414272474513&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3WoVbOVyBfowGJZSoHI3mwtzcxbmuBkj3jIoCR5l9gv4l9IQXzPQm7ugA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1079&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一问果然有 NAT 的身影。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现象就是请求端请求服务器的静态资源偶尔会出现 20-60 秒左右才会有响应的情况，从抓包看请求端连续三个 SYN 都没有回应。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如你在学校，对外可能就一个公网 IP，然后开启了 tcp_tw_recycle（tcp_timestamps 也是打开的情况下），在 60 秒内对于同源 IP 的连接请求中 timestamp 必须是递增的，不然认为其是过期的数据包就会丢弃。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;学校这么多机器，你无法保证时间戳是一致的，因此就会出问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以这玩意不推荐使用。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3WoE8V7lW2ynFgEnibX5IvFBSsTuY5UKXqe7TcfT2hsiaDaC2XLngAOBxfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;720&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;重用&lt;/span&gt;，即开启 tcp_tw_reuse 当然也是需要 tcp_timestamps 的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有个重点，&lt;span&gt;tcp_tw_reuse 是用在连接发起方的，而我们的服务端基本上是连接被动接收方&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;tcp_tw_reuse 是发起新连接的时候，可以复用超过 1s 的处于 TIME_WAIT 状态的连接，所以它压根没有减少我们服务端的压力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;它重用的是发起方处于 TIME_WAIT 的连接&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里还有一个 SO_REUSEADDR ，这玩意有人会和 tcp_tw_reuse 混为一谈，首先 tcp_tw_reuse 是内核选项而 SO_REUSEADDR 是用户态选项。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后 SO_REUSEADDR 主要用在你启动服务的时候，如果此时的端口被占用了并且这个连接处于 TIME_WAIT 状态，那么你可以重用这个端口，如果不是 TIME_WAIT，那就是给你个 Address already in use。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以这两个玩意好像都不行，而且 tcp_tw_reuse 和tcp_tw_recycle，其实是违反 TCP 协议的，说好的等我到天荒地老，你却偷偷放了手？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.1333333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3WoJ3Fkmian3UwwacQhqwKQLR1xVf2WSu9g0cDjWCK6G7stc3XSL4bqodQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;240&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要么就是调小 MSL 的时间，不过也不太安全，要么调整 tcp_max_tw_buckets 控制 TIME_WAIT 的数量，不过默认值已经很大了 180000，这玩意应该是用来对抗 DDos 攻击的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我给出的建议是&lt;span&gt;服务端不要主动关闭，把主动关闭方放到客户端&lt;/span&gt;。毕竟咱们服务器是一对很多很多服务，我们的资源比较宝贵。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;自己攻击自己&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一个很骚的解决方案，我自己瞎想的，就是自己攻击自己。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Socket 有一个选项叫 IP_TRANSPARENT ，可以绑定一个非本地的地址，然后服务端把建连的 ip 和端口都记下来，比如写入本地某个地方。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后启动一个服务，假如现在服务端资源很紧俏，那么你就定个时间，过了多久之后就将处于 TIME_WAIT 状态的对方 ip 和端口告诉这个服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后这个服务就利用 IP_TRANSPARENT 伪装成之前的那个 client 向服务端发起一个请求，然后服务端收到会给真的 client 一个 ACK， 那 client 都关了已经，说你在搞啥子，于是回了一个 RST，然后服务端就中止了这个连接。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3WoNP85d4y3CP2ZcJumABnBIXCaCuzgDb0aia6icUDPj3668XcY5mf89djA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;超时重传机制是为了解决什么问题？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面我们提到 TCP 要提供可靠的传输，那么网络又是不稳定的如果传输的包对方没收到却又得保证可靠那么就必须重传。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCP 的可靠性是靠确认号的，比如我发给你1、2、3、4这4个包，你告诉我你现在要 5 那说明前面四个包你都收到了，就是这么回事儿。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过这里要注意，SeqNum 和 ACK 都是&lt;span&gt;以字节数为单位的&lt;/span&gt;，也就是说假设你收到了1、2、4 但是 3 没有收到你不能 ACK 5，如果你回了 5 那么发送方就以为你5之前的都收到了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以&lt;span&gt;只能回复确认最大连续收到包&lt;/span&gt;，也就是 3。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而发送方不清楚 3、4 这两个包到底是还没到呢还是已经丢了，于是发送方需要等待，这等待的时间就比较讲究了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果太心急可能 ACK 已经在路上了，你这重传就是浪费资源了，如果太散漫，那么接收方急死了，这死鬼怎么还不发包来，我等的花儿都谢了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以这个等待超时重传的时间很关键，怎么搞？聪明的小伙伴可能一下就想到了，你估摸着正常来回一趟时间是多少不就好了，我就等这么长。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就来回一趟的时间就叫 RTT，即 Round Trip Time，然后根据这个时间制定超时重传的时间 RTO，即 Retransmission Timeout。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过这里大概只好了 RTO 要参考下 RTT ，但是具体要怎么算？首先肯定是采样，然后一波加权平均得到 RTO。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RFC793 定义的公式如下：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;1、先采样 RTT
2、SRTT = ( ALPHA * SRTT ) + ((1-ALPHA) * RTT)
3、RTO = min[UBOUND,max[LBOUND,(BETA*SRTT)]]&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ALPHA 是一个平滑因子取值在 0.8~0.9之间，UBOUND 就是超时时间上界-1分钟，LBOUND 是下界-1秒钟，BETA 是一个延迟方差因子，取值在 1.3~2.0。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是还有个问题，RTT 采样的时间用一开始发送数据的时间到收到 ACK 的时间作为样本值还是重传的时间到 ACK 的时间作为样本值？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.44563758389261743&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3WoOSQzGrAHoqsPG5YoTDslkIDZ67icC174z0Y4ic3CUER052OWedseHEEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;745&quot;/&gt;&lt;figcaption&gt;图来自网络&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图中就可以看到，一个时间算长了，一个时间算短了，这有点难，因为你不知道这个  ACK 到底是回复谁的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以怎么办？&lt;span&gt;发生重传的来回我不采样不就好了&lt;/span&gt;，我不知道这次 ACK 到底是回复谁的，我就不管他，我就采样正常的来回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是 Karn / Partridge 算法，不采样重传的RTT。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是不采样重传会有问题，比如某一时刻网络突然就是很差，你要是不管重传，那么还是按照正常的 RTT 来算 RTO， 那么超时的时间就过短了，于是在网络很差的情况下还疯狂重传加重了网络的负载。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此 Karn 算法就很粗暴的搞了个发生重传我就将现在的 RTO 翻倍，哼！就是这么简单粗暴。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3WoicyHpaEcpicmvwcD3h21d9jRpNB3v3MhsBibhWOOERwTrW4mnib4Zpx1xA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;255&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这种平均的计算很容易把一个突然间的大波动，平滑掉，所以又搞了个算法，叫 Jacobson / Karels Algorithm。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它把最新的 RTT 和平滑过的 SRTT 做了波计算得到合适的 RTO，公式我就不贴了，反正我不懂，不懂就不哔哔了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;为什么还需要快速重传机制？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;超时重传是按时间来驱动的，如果是网络状况真的不好的情况，超时重传没问题，但是如果网络状况好的时候，只是恰巧丢包了，那等这么长时间就没必要。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是又引入了数据驱动的重传叫快速重传，什么意思呢？就是发送方如果连续三次收到对方相同的确认号，那么马上重传数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为连续收到三次相同 ACK 证明当前网络状况是 ok 的，那么确认是丢包了，于是立马重发，没必要等这么久。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6466666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3WoSmvbyBEQJcO4b3zaTl71PZA1nxK30DppqZvYdYzEwZe1w5waku43hg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;450&quot;/&gt;&lt;figcaption&gt;图来自网络&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看起来好像挺完美的，但是你有没有想过我发送1、2、3、4这4个包，就 2 对方没收到，1、3、4都收到了，然后不管是超时重传还是快速重传反正对方就回 ACK 2。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候要重传 2、3、4 呢还是就 2 呢？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;SACK 的引入是为了解决什么问题？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SACK 即 Selective Acknowledgment，它的引入就是为了解决发送方不知道该重传哪些数据的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看一下下面的图就知道了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3Woaa9JU7r5iaUH5bLXq2s2JhBkjrEic1RZCDAibCEaDqB7MU1tO7t4ekJrg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;figcaption&gt;图来自网络&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SACK 就是接收方会回传它已经接受到的数据，这样发送方就知道哪一些数据对方已经收到了，所以就可以选择性的发送丢失的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图，通过 ACK 告知我接下来要 5500 开始的数据，并一直更新 SACK，6000-6500 我收到了，6000-7000的数据我收到了，6000-7500的数据我收到了，发送方很明确的知道，5500-5999 的那一波数据应该是丢了，于是重传。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且如果数据是多段不连续的， SACK 也可以发送，比如 SACK 0-500,1000-1500，2000-2500。就表明这几段已经收到了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;D-SACK 又是什么东西？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;D-SACK 其实是 SACK 的扩展，它利用 SACK 的第一段来描述重复接受的不连续的数据序号，如果第一段描述的范围被 ACK 覆盖，说明重复了，比如我都 ACK 到6000了你还给我回 SACK 5000-5500 呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说白了就是从第一段的反馈来和已经接受到的 ACK 比一比，参数是 tcp_dsack，Linux 2.4 之后默认开启。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那知道重复了有什么用呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、知道重复了说明对方收到刚才那个包了，所以是回来的 ACK 包丢了。2、是不是包乱序的，先发的包后到？3、是不是自己太着急了，RTO 太小了？4、是不是被数据复制了，抢先一步呢？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;滑动窗口干嘛用？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们已经知道了 TCP 有序号，并且还有重传，但是这还不够，因为我们不是愣头青，还需要根据情况来控制一下发送速率，因为网络是复杂多变的，有时候就会阻塞住，而有时候又很通畅。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以发送方需要知道接收方的情况，好控制一下发送的速率，不至于蒙着头一个劲儿的发然后接受方都接受不过来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此 TCP 就有个叫滑动窗口的东西来做流量控制，也就是接收方告诉发送方我还能接受多少数据，然后发送方就可以根据这个信息来进行数据的发送。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下是&lt;span&gt;发送方维护的窗口&lt;/span&gt;，就是黑色圈起来的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4090909090909091&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3WoNSsZclruxoCbllRg8lMKRkr3Lmc5CtzDcuKjicv2U81ibicuFS5KL3eGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;660&quot;/&gt;&lt;figcaption&gt;图来自网络&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图中的 #1 是已收到 ACK 的数据，#2 是已经发出去但是还没收到 ACK 的数据，#3 就是在窗口内可以发送但是还没发送的数据。#4 就是还不能发送的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后此时收到了 36 的 ACK，并且发出了 46-51 的字节，于是窗口向右滑动了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3181818181818182&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3WodrthnVRfouI4U8ViaCL9lqBwiboIQI5f9jC9Rf6PgswPCBjasJITgMCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;660&quot;/&gt;&lt;figcaption&gt;图片来自网络&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCP/IP Guide 上还有一张完整的图，画的十分清晰，大家看一下。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.2552552552552552&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3WoNAWqUEzJl8z8tVhJELibN8k5ic6gc2E7Uzaqeh51t6W9jCr6NsqgAbfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;666&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;如果接收方回复的窗口一直是 0 怎么办？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上文已经说了发送方式根据接收方回应的 window 来控制能发多少数据，如果接收方一直回应 0，那发送方就杵着？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你想一下，发送方发的数据都得到 ACK 了，但是呢回应的窗口都是 0 ，这发送方此时不敢发了啊，那也不能一直等着啊，这 Window 啥时候不变 0 啊？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是 TCP 有一个 Zero Window Probe 技术，发送方得知窗口是 0 之后，会去探测探测这个接收方到底行不行，也就是发送 ZWP 包给接收方。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体看实现了，可以发送多次，然后还有间隔时间，多次之后都不行可以直接 RST。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;假设接收方每次回应窗口都很小怎么办？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你想象一下，如果每次接收方都说我还能收 1 个字节，发送方该不该发？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCP + IP 头部就 40 个字节了，这传输不划算啊，如果傻傻的一直发这就叫 Silly Window。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那咋办，一想就是发送端等着，等养肥了再发，要么接收端自己自觉点，数据小于一个阈值就告诉发送端窗口此时是 0 算了，也等养肥了再告诉发送端。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发送端等着的方案就是纳格算法，这个算法相信看一下代码就知道了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3745019920318725&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3WoFcVQjDWNXZhB3PQdYZRz76Lp3pjicFAjXhSOBNgLiaWQwPcViaPHU4DrA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;753&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单的说就是当前能发送的数据和窗口大于等于 MSS 就立即发送，否则再判断一下之前发送的包 ACK 回来没，回来再发，不然就攒数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接收端自觉点的方案是 David D Clark’s 方案，如果窗口数据小于某个阈值就告诉发送方窗口 0 别发，等缓过来数据大于等于 MSS 或者接受 buffer 腾出一半空间了再设置正常的 window 值给发送方。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对了提到纳格算法不得不再提一下延迟确认，纳格算法在等待接收方的确认，而开启延迟确认则会延迟发送确认，会等之后的包收到了再一起确认或者等待一段时候真的没了再回复确认。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就相互等待了，然后延迟就很大了，两个不可同时开启。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;已经有滑动窗口了为什么还要拥塞控制？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面我已经提到了，加了拥塞控制是因为 TCP 不仅仅就管两端之间的情况，还需要知晓一下整体的网络情形，毕竟只有大家都守规矩了道路才会通畅。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面我们提到了重传，如果不管网络整体的情况，肯定就是对方没给 ACK ，那我就无脑重传。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果此时网络状况很差，所有的连接都这样无脑重传，是不是网络情况就更差了，更加拥堵了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后越拥堵越重传，一直冲冲冲！然后就 GG 了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.74&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3WoPG6iaCX4gdzfRcfqqgfVX2aR9bvrTOK1oWMe0VkOOiaLUkt1RxS0NMLQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;400&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以需要个拥塞控制，来避免这种情况的发送。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;拥塞控制怎么搞？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要有以下几个步骤来搞：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、慢启动，探探路。2、拥塞避免，感觉差不多了减速看看
3、拥塞发生快速重传/恢复&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5316642120765832&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3WoMnoDxDMyia49rX7kt1D3BM267MG3qXSqxHFGy9MfMcQMdYmhd5Z5Dtg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;679&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;慢启动，就是新司机上路慢慢来，初始化 cwnd（Congestion Window）为 1，然后每收到一个 ACK 就 cwnd++ 并且每过一个 RTT ，cwnd = 2*cwnd 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线性中带着指数，指数中又夹杂着线性增。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后到了一个阈值，也就是 ssthresh（slow start threshold）的时候就进入了拥塞避免阶段。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个阶段是每收到一个 ACK 就 cwnd = cwnd + 1/cwnd并且每一个 RTT 就 cwnd++。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到都是线性增。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后就是一直增，直到开始丢包的情况发生，前面已经分析到重传有两种，一种是超时重传，一种是快速重传。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果发生超时重传的时候，那说明情况有点糟糕，于是直接把 ssthresh 置为当前 cwnd 的一半，然后 cwnd 直接变为 1，进入慢启动阶段。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3Wom2icNGibxk7Fria6KJyWEaSNibgKIASFIhnxqqK6OhJIpV7xxhfeVwugicQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;225&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是快速重传，那么这里有两种实现，一种是 TCP Tahoe ，和超时重传一样的处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一种是 TCP Reno，这个实现是把 cwnd = cwnd/2 ，然后把 ssthresh 设置为当前的 cwnd 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后进入快速恢复阶段，将 cwnd = cwnd + 3（因为快速重传有三次），&lt;span&gt;重传 DACK 指定的包&lt;/span&gt;，如果再收到一个DACK则 cwnd++，如果收到是正常的 ACK 那么就将 cwnd 设为 ssthresh 大小，进入拥塞避免阶段。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到快速恢复就重传了指定的一个包，那有可能是很多包都丢了，然后其他的包只能等待超时重传，超时重传就会导致 cwnd 减半，多次触发就指数级下降。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以又搞了个 New Reno，多加了个 New，它是在没有SACK 的情况下改进快速恢复，它会观察重传 DACK 指定的包的响应 ACK 是否是已经发送的最大 ACK，比如你发了1、2、3、4，对方没收到 2，但是 3、4都收到了，于是你重传 2 之后 ACK 肯定是 5，说明就丢了这一个包。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不然就是还有其他包丢了，如果就丢了一个包就是之前的过程一样，如果还有其他包丢了就继续重传，直到 ACK 是全部的之后再退出快速恢复阶段。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单的说就是一直探测到全部包都收到了再结束这个环节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有个 FACK，它是基于 SACK 用来作为重传过程中的拥塞控制，相对于上面的 New Reno 我们就知道它有 SACK 所以不需要一个一个试过去，具体我不展开了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;还有哪些拥塞控制算法？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从维基上看有这么多。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9972451790633609&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3Wo3OYibLU4Qj5Lj8QSOx3bkDScGaxKzW1M7pQ8UUfcfpNdxBl5Yj8gN6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;363&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本来我还想哔哔几句了，哔哔了之后又删了，感觉说了和没说一样，&lt;span&gt;想深入但是实力不允许&lt;/span&gt;，有点惆怅啊。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;各位看官自个儿查查吧，或者等我日后修炼有成再来哔哔。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说了这么多来总结一下吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCP 是面向连接的，提供可靠、有序的传输并且还提供流控和拥塞控制，单独提取出 TCP 层而不是在 IP层实现是因为 IP 层有更多的设备需要使用，加了复杂的逻辑不划算。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;三次握手主要是为了定义初始序列号为了之后的传输打下基础，四次挥手是因为 TCP 是全双工协议，因此双方都得说拜拜。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SYN 超时了就阶梯性重试，如果有 SYN攻击，可以加大半队列数，或减少重试次数，或直接拒绝。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TIME_WAIT 是怕对方没收到最后一个 ACK，然后又发了 FIN 过来，并且也是等待处理网络上残留的数据，怕影响新连接。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3WoKnL07ym9A1ribRGibMhZxiazzwvrU1IJ93KLQjxA8YhXMibAmCr9fnfV1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TIME_WAIT 不建议设小，或者破坏 TIME_WAIT 机制，如果真想那么可以开启快速回收，或者重用，不过注意受益的对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;超时重传是为了保证对端一定能收到包，快速重传是为了避免在偶尔丢包的时候需要等待超时这么长时间，SACK 是为了让发送方知道重传哪些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;D-SACK 是为了让发送方知道这次重传的原因是对方真的没收到还是自己太心急了 RTO 整小了，不至于两眼一抹黑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;滑动窗口是为了平衡发送方的发送速率和接收方的接受数率，不至于瞎发，当然还需要注意 Silly Window 的情况，同时还要注意纳格算法和延迟确认不能一起搭配。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而滑动窗口还不够，还得有个拥塞控制，因为&lt;span&gt;出行你我他，安全靠大家&lt;/span&gt;，TCP 还得跳出来看看关心下当前大局势。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最后&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此就差不多了，不过还是有很多很多细节的，TCP 协议太复杂了，这可能是我文章里面图画的最少的一篇了，你看复杂到我图都画不来了哈哈哈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天我就说了个皮毛，如有纰漏请赶紧后台联系鞭挞我。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3WoSuzOZut05TVKS71AaKl5N4jSBI21MFFKKPlt9JrsPMQzSwE77zic3Og/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;240&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;巨人的肩膀&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;http://www.tcpipguide.com/&lt;/em&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;https://www.ionos.com/digitalguide/server/know-how/introduction-to-tcp/&lt;/em&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;https://www.ibm.com/developerworks/cn/linux/l-tcp-sack/&lt;/em&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;https://coolshell.cn/articles/11564.html/&lt;/em&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;https://tools.ietf.org/html/rfc793&lt;/em&gt;&lt;em&gt;https://nmap.org/book/tcpip-ref.html&lt;/em&gt;&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我是 yes，从一点点到亿点点，我们下篇见&lt;/span&gt;。&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a2f6ba9277b228f11d589c4ec8f9e1ec</guid>
<title>[推荐] 分享一个作为面试官的面试思路</title>
<link>https://toutiao.io/k/dvtlxd4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6389850057670127&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8wj3hUrm4CzAZAm62AuZiafOxhdj1icCzdxfWKSEA4GibfoNLINA1jLo6OkO9Tiac1wLqpJxrSO9vNcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;867&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;做面试官也是一个需要持续完善和改进的技能，避免面试官和面试者都没有收获或者面试感觉不舒服，间接影响公司的形象。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;作为面试官的核心要点&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;1. 不要透露公司内未官方宣传的数据和信息。&lt;br/&gt;2. 面试官代表公司的形象，要尊重面试者。信息的传达注意对公司的影响。&lt;br/&gt;3. 要明确招人的标准，找：能做事、会做事、做成事  的人。&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;面试步骤&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;面试前准备&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;和HR约好面试时间，定日程提醒。有变化提前通知。&lt;br/&gt;拿到面试者的简历，先浏览一遍，根据面试者情况定制面试提纲。&lt;br/&gt;举个例子，本周面试一人。名校硕士，工作7年时间，共经历2家公司，都是技术上靠前面的大厂。工作经验和目前职位匹配。总体是不错的。但是从简历可看出缺少一些这边必需的技术栈。&lt;br/&gt;针对他的情况我首先制定了一个面试大纲：&lt;/p&gt;&lt;p&gt;1.自我介绍&lt;/p&gt;&lt;p&gt;2.过往经历项目考察&lt;/p&gt;&lt;p&gt;在此过程中遇到了什么问题，采取了什么措施，取得了什么成果。总结了什么经验和方法。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;3.基础题&lt;/p&gt;&lt;p&gt;3.1 稳定性方面所做的工作&lt;/p&gt;&lt;p&gt;3.2 因为简历里写明对基础算法有了解。所以让他谈谈什么是归并排序，什么是快速排序，两者的区别和联系。&lt;/p&gt;&lt;p&gt;怎么用原地算法做归并排序(故意带坑题，我了解到的是归并排序不能用原地算法)&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;4.场景题：怎么设计一个自动化回归平台&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;5.软素质考察&lt;/p&gt;&lt;p&gt;5.1 平时怎么自我提升&lt;/p&gt;&lt;p&gt;5.2 为什么会考虑我司&lt;/p&gt;&lt;p&gt;5.3 你有什么要问的吗&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;面试过程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;自我介绍和过往经历&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;面试者总共经历了四个项目，都做了稍微详细些的介绍。中间有问他一些涉及的技术。回答和简历上标注能力程度在我的角度看是匹配的。&lt;/p&gt;&lt;p&gt;举例来说他项目中有提到做数据删除。我就问他删除数据有没有风险。他提到有反作弊风险。我提示说提到风险一般会从两方面来阐述。一个是业务上的，一个是系统上的。反作弊风险是业务上的，在系统上有没有遇到什么问题。比如删除数据可能会涉及磁盘IO，这个怎么来规避。&lt;/p&gt;&lt;p&gt;他提到数据库采用的高性能SSD盘，在操作时也会限制并发度。&lt;/p&gt;&lt;p&gt;回答不是很深入，但是对于他在项目中的角色来说，这个回答是可以接受的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;基础题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;有请他介绍一些分布式一致性的相关技术。他提到了两阶段提交、分布式锁和他在区块链项目中用到的独有的基于类似全局唯一ID的技术。总体不是特别全面和成体系。但是对于这个技术我这边判断他是了解的。&lt;/p&gt;&lt;p&gt;谈谈什么是归并排序，什么是快速排序，两者的区别和联系。这个他的回答没有什么问题，谈到了快速排序之所以叫快速是因为时间复杂度的系数小。&lt;/p&gt;&lt;p&gt;然后我就让他谈谈怎么用原地算法做归并排序。他说了一个方法，我没有听太懂，我明确告诉他我理解归并排序是不能用原地算法来实现的,请他在面试结束后把代码发给我,算做交流学习。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;场景题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;场景题中，他的回答可以看到他到他平时工作重心的一些缩影。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;软素质考察&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;总体是我司有一定的了解，沟通流畅，没有什么问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;面试结束&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;虽然没有明确表态，但是根据我的一贯风格，从沟通中面试者也是可以了解到一面在我这里是通过的。面试结束他将自己面试时介绍的使用插入实现归并的博客和另外一种使用旋转实现O(1)空间复杂度的方法博客发给我&lt;/p&gt;&lt;p&gt;到此一面流程真正结束,我按照&lt;/p&gt;&lt;p&gt;1&amp;gt;综合评价&lt;/p&gt;&lt;p&gt;2&amp;gt;优势&lt;/p&gt;&lt;p&gt;3&amp;gt;劣势&lt;/p&gt;&lt;p&gt;4&amp;gt;具体点描述&lt;/p&gt;&lt;p&gt;的模板给HR发了面试反馈。评价建议尽可以具体，让下一位面试官了解情况，不用每次面试对面试者某一方面重复考察。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结思考&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;面试是一个交流碰撞的过程,对于面试者和面试官都是一个学习交流的机会.最好是双方都花些时间做些准备,这样面试过程轻松愉快,通过面试提升了自己的自信,过程中也都有收获.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;PS: 有对金融方向、高并发、高可用感兴趣的朋友可发简历到98749055@qq.com。加入我们，你将直面这个领域全球最大日单量和并发量，无上限对稳定性的要求(一般的业务团队对稳定性会设置SLA指标，稳定性高于一定程度，业务的拓展更加重要，对稳定性问题深度的提升有一定限制)。挑战无限，机会多多。&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>