<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>98ee5bbf770316434e25a88816084598</guid>
<title>面试：为了进阿里，必须掌握 HashMap 源码原理和面试题（图解版一）</title>
<link>https://toutiao.io/k/vl7rvfr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;h1 cid=&quot;n0&quot; mdtype=&quot;heading&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;欢迎关注公众号【&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;Ccww技术博客&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;】，原创技术文章第一时间推出&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/h1&gt;&lt;hr/&gt;&lt;h3 cid=&quot;n2&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p cid=&quot;n3&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;集合在基础面试中是必备可缺的一部分，其中重要的HashMap更是少不了，那面试官会面试中提问那些问题呢，这些在JDK1.7和1.8有什么区别？？&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n4&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n6&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;HashMap的底层原理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n8&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;HashMap的hash哈希函数的设计原理，以及HashMap下标获取方式？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n10&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;HashMap扩容机制，hashMap中什么时候需要进行扩容，扩容resize()又是如何实现的&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n12&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;hashMap中put是如何实现的 ，JDK1.7和1.8有什么区别？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n14&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;hashMap中get是如何实现的&lt;/strong&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n16&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;其他涉及问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n17&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n19&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;HashMap具备的特性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n21&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;为什么Hash的底层数据长度总为2的N次方？如果输入值不是2的幂比如10会怎么样？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n23&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;加载因子为什么是 0.75？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n25&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;哈希表如何解决Hash冲突&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n27&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;当有哈希冲突时，HashMap 是如何查找并确认元素的？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n29&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;HashMap 是线程安全的吗，为什么不是线程安全的？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;hr/&gt;&lt;h3 cid=&quot;n32&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;1. HashMap的底层原理&lt;/span&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p cid=&quot;n33&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;JDK1.7使用的是数组+ 单链表的数据结构。JDK1.8之后，使用的是数组+链表+红黑树的数据结构&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n34&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;HashMap数据结构图（jdk1.8）&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n35&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.573943661971831&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDriatqsuMHWsaacfH3j6lpw9YmAsnANIrHEz6efzy1BvJDibR7ib8pRaPC6Ik4Qdhiae8Ym3UKJknoLOYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;568&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; TREEIFY_THRESHOLD = &lt;span class=&quot;code-snippet__number&quot;&gt;8&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; UNTREEIFY_THRESHOLD = &lt;span class=&quot;code-snippet__number&quot;&gt;6&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; MIN_TREEIFY_CAPACITY = &lt;span class=&quot;code-snippet__number&quot;&gt;64&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p cid=&quot;n37&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;从HashMap常量中可以看出，当链表的深度达到8的时候，也就是默认阈值TREEIFY_THRESHOLD=8，就会自动扩容把链表转成红黑树的数据结构来把时间复杂度从O(n)变成O(logN)提高了效率，而且当进行resize操作时，若桶中数量少于6则从树转成链表。&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n38&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;那为什么数据结构需要从JDK1.7换成JDK1.8的数组+链表+红黑树？&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n39&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;在JDK1.7中，当相同的hash值时，HashMap不断地产生碰撞，那么相同key位置的链表就会不断增长，当查询HashMap的相应key值的Vaule值时，就会去循环遍历这个超级大的链表，查询性能非常低下。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n40&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;但在JDK1.8当链表超过8个节点数时，将会让红黑树来替代链表，查询性能得到了很好的提升，从原来的是O(n)到O(logn)。&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;h3 cid=&quot;n42&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;2. HashMap的hash哈希函数的设计原理，以及HashMap下标获取 hash &amp;amp;（n - 1）？&lt;/span&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h4 cid=&quot;n43&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;hash哈希函数的设计原理&lt;/span&gt;&lt;/h4&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;java&quot; cid=&quot;n44&quot; mdtype=&quot;fences&quot;&gt;&lt;span&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;hash&lt;/span&gt;(&lt;span&gt;Object&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    &lt;span&gt;int&lt;/span&gt; &lt;span&gt;h&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    &lt;span&gt;return&lt;/span&gt; (&lt;span&gt;key&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;?&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; : (&lt;span&gt;h&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;.&lt;span&gt;hashCode&lt;/span&gt;()) &lt;span&gt;^&lt;/span&gt; (&lt;span&gt;h&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.32936507936507936&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDriatqsuMHWsaacfH3j6lpw9YDRqM9pcmhradXMYnxd3AwDG1nKSzxeoaoZ6KEE8frPKic89rp9PhhyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;756&quot;/&gt;&lt;/p&gt;&lt;h4 cid=&quot;n51&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;HashMap下标获取h % n = h &amp;amp;（n - 1）&lt;/span&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5994729907773386&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDriatqsuMHWsaacfH3j6lpw9YS3QHaO147Jxib8Z1r3iaZv1q9C4KE8jOqQnMia8q82GeSo0moQGiafz7eA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;759&quot;/&gt;&lt;/h4&gt;&lt;p cid=&quot;n58&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;设计原因：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; cid=&quot;n59&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n61&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;一定要尽可能降低hash碰撞，越分散越好；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n63&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;算法一定要尽可能高效，因为这是高频操作, 因此采用位运算；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p cid=&quot;n64&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h3 cid=&quot;n65&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;3. HashMap扩容机制resize（）&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n66&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;HashMap扩容步骤分成两步：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n73&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;获取新值：新的容量值newCap ，新的扩容阀界值newThr获取&lt;/span&gt;&lt;/h4&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Node&amp;lt;K,V&amp;gt;[] oldTab = table;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; oldCap = (oldTab == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) ? &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; : oldTab.length;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; oldThr = threshold;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; newCap, newThr = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;threshold = newThr;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Node&amp;lt;K,V&amp;gt;[] newTab = (Node&amp;lt;K,V&amp;gt;[])&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Node[newCap];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; table = newTab;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (oldCap &amp;gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (oldCap &amp;gt;= MAXIMUM_CAPACITY) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            threshold = Integer.MAX_VALUE;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;             &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; oldTab;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; ((newCap = oldCap &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;) &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                   oldCap &amp;gt;= DEFAULT_INITIAL_CAPACITY)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           newThr = oldThr &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n74&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n81&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n83&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;如果此时oldCap&amp;gt;=MAXIMUM_CAPACITY(1 &amp;lt;&amp;lt; 30)，表示已经到了最大容量，这时还要往map中put数据，则阈值设置为整数的最大值 Integer.MAX_VALUE，直接返回这个oldTab的内存地址&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n85&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;如果扩容之后的新容量小于最大容量 ，且老的数组容量大于等于默认初始化容量（16），那么新数组的扩容阀值设置为老阀值的2倍（左移1位相当于乘以2，newCap = oldCap &amp;lt;&amp;lt; 1），阈值也double（newThr= oldThr &amp;lt;&amp;lt; 1）;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (oldThr &amp;gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;newCap = oldThr;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;....&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (newThr == &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;float&lt;/span&gt; ft = (&lt;span class=&quot;code-snippet__keyword&quot;&gt;float&lt;/span&gt;)newCap * loadFactor;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     newThr = (newCap &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp; ft &amp;lt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;float&lt;/span&gt;)MAXIMUM_CAPACITY ?&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              (&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;)ft : Integer.MAX_VALUE);  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; { &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           newCap = DEFAULT_INITIAL_CAPACITY;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           newThr = (&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p cid=&quot;n93&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p cid=&quot;n93&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;数据迁移&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n96&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;如果oldTab老数组不为空，说明是扩容操作，那么涉及到元素的转移操，遍历老数组，如果当前位置元素不为空，那么需要转移该元素到新数组。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (e.next == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;)  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;newTab[e.hash &amp;amp; (newCap - &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;)] = e;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (e &lt;span class=&quot;code-snippet__keyword&quot;&gt;instanceof&lt;/span&gt; TreeNode)  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          ((TreeNode&amp;lt;K,V&amp;gt;)e).split(&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;, newTab, j, oldCap);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Node&amp;lt;K,V&amp;gt; loHead = &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;, loTail = &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Node&amp;lt;K,V&amp;gt; hiHead = &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;, hiTail = &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Node&amp;lt;K,V&amp;gt; next;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;do&lt;/span&gt; {  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    next = e.next;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; ((e.hash &amp;amp; oldCap) == &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) {  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (loTail == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                 loHead = e;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              loTail.next = e;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          loTail = e;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (hiTail == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                      hiHead = e;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                   hiTail.next = e;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                hiTail = e;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;} &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt; ((e = next) != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (loTail != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) { &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      loTail.next = &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      newTab[j] = loHead;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (hiTail != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       hiTail.next = &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       newTab[j + oldCap] = hiHead;                  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/ul&gt;&lt;p cid=&quot;n744&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span&gt;JDK1.8对&lt;/span&gt;&lt;code&gt;resize()&lt;/code&gt;&lt;span&gt;扩容方法进行了优化，&lt;/span&gt;&lt;strong&gt;经过rehash之后，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n744&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;是不是有点不明白呢？那我们来用图来解析一下：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n746&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;结合&lt;code&gt;e.hash &amp;amp; oldCapn&lt;/code&gt;取值判断是在高位还是在低位，即如图（a）表示扩容前的key1和key2两种key确定索引位置的示例，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.27328431372549017&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDriatqsuMHWsaacfH3j6lpw9YBHLgyPRCRaOWZZFFF2y2Jh19A0r6BnwazHiaEAmP4sAdAcoslj6so5w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1632&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图（b）表示扩容后key1和key2两种key确定索引，元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.18984962406015038&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDriatqsuMHWsaacfH3j6lpw9Yms5OpiboDtic3ZScNgicBBx8sgerWlElOnZQLN4p31QcQD2KVP0iahQFVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1064&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“&lt;/span&gt;&lt;code&gt;&lt;span&gt;原索引+oldCap&lt;/span&gt;&lt;/code&gt;&lt;span&gt;”，可以看看下图为16扩充为32的resize示意图：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5757097791798107&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDriatqsuMHWsaacfH3j6lpw9YYvu72ssibnLME4icwlRWbWF5bVRQnXia85OleqdibVTBdPsYAzOxldBaqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1268&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在JDK1.7中rehash扩容的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同的链表元素会倒置，但是在JDK1.8进行了优化，从上图可以看出，JDK1.8链表元素不会倒置。&lt;/span&gt;&lt;span&gt;因此不会出现链表死循环的问题。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于篇幅过长，将分成两篇来介绍，接下来内容看&lt;/span&gt;&lt;span&gt;《面试：为了进阿里，必须掌握HashMap源码原理和面试题（图解版二）》&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n158&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;各位看官还可以吗？喜欢的话，动动手指点个再看💗呗！！谢谢支持！&lt;span md-inline=&quot;linebreak&quot;&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n158&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;欢迎扫码关注，原创技术文章第一时间推出&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.36857142857142855&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;350&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDrgfBz2Ve78FylxcGWmXaueSuqPguurBCWEkeY1ibeLl1wlxUyibdesc4YeuiaJJjSt6HTiab2iaHyXyyicA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>60f1c571a071dece68020c2dce89b28e</guid>
<title>老生常谈 Spring Aop 日志收集与处理做的工具包</title>
<link>https://toutiao.io/k/b79camp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;blogpost-body cnblogs-markdown&quot;&gt;
    &lt;h4 id=&quot;aoplog是基于spring-aop-和threadlocal实现的一个专门对请求方法内容日志的拦截与处理的日志工具包。&quot;&gt;AopLog是基于Spring Aop 和ThreadLocal实现的一个专门对请求方法内容日志的拦截与处理的日志工具包。&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img.shields.io/static/v1?label=release&amp;amp;message=2.1&amp;amp;color=green&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;img src=&quot;https://img.shields.io/static/v1?label=jar&amp;amp;message=16k&amp;amp;color=green&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;img src=&quot;https://img.shields.io/badge/License-Apache%202.0-blue.svg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;img src=&quot;https://img.shields.io/badge/JDK-1.8+-red.svg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;场景 :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用Spring Aop拦截参数日志目前大部分做法都基本上大同小异,不想日后每个项目工程都写一份这样的Aop拦截处理日志的代码,甚至代码侵入。&lt;/li&gt;
&lt;li&gt;我想知道一些相对重要的请求方法的请求参数,响应参数,请求头,以及内部耗时,方法是成功还是失败等等信息。发生错误时我也不知道执行到哪一步发生了异常，是不是某个参数导致出的逻辑问题。&lt;/li&gt;
&lt;li&gt;普通的log.info或warn信息没有所属请求的上下关系,并不方便查看和分析。&lt;/li&gt;
&lt;li&gt;正式环境中,我并不想打印太多无意义的info日志(有些只是为了排查问题打印的日志,程序正常运行时其实毫无意义)，只希望在发生异常时记录日志或者只希望每次请求只记录一条关键的请求信息。&lt;/li&gt;
&lt;li&gt;日志的收集,我希望将这些请求的日志记录下来，记录的实现方式我自己决定，比如正常的日志打印，常见的日志写入数据库，日志写入到文件，日志入队列等等。&lt;/li&gt;
&lt;li&gt;整个日志的记录完全不干扰正常请求方法的流程,日志的收集处理异步化,完全不影响正常请求方法的性能与响应。&lt;/li&gt;
&lt;li&gt;只需要通过&lt;code&gt;@AopLog&lt;/code&gt;注解决定是否记录。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;快速开始&quot;&gt;快速开始&lt;/h3&gt;
&lt;h4 id=&quot;项目通过maven的pomxml引入&quot;&gt;项目通过maven的pom.xml引入&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.github.ealenxie&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;aop-log&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;或者通过gradle引入&quot;&gt;或者通过gradle引入&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-gradle&quot;&gt;compile group: &#x27;com.github.ealenxie&#x27;, name: &#x27;aop-log&#x27;, version: &#x27;2.1&#x27;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;aoplog注解使用，进行日志记录&quot;&gt;@AopLog注解使用，进行日志记录&lt;/h4&gt;
&lt;p&gt;直接在类(作用类的所有方法)或类方法(作用于方法)上加上注解@AopLog,进行日志记录&lt;/p&gt;
&lt;p&gt;例如 :&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;import com.github.AopLog;
import name.ealen.infra.base.resp.RespBody;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * @author EalenXie create on 2020/6/22 14:28
 */
@AopLog(type = &quot;测试&quot;,stackTraceOnErr = true)
@RestController
public class AppController {

    @GetMapping(&quot;/app/sayHello&quot;)
    public RespBody&amp;lt;String&amp;gt; sayHello() {
        return RespBody.ok(&quot;hello EalenXie&quot;);
    }

}

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;自定义全局的日志收集器实现收集-logcollector&quot;&gt;自定义全局的日志收集器实现收集 LogCollector&lt;/h4&gt;
&lt;p&gt;例如只是简单打印,或写入到库等等。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.github.LogData;
import com.github.collector.LogCollector;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

/**
 * @author EalenXie create on 2020/9/15 13:46
 * 此为样例参考
 * 配置一个简单的日志收集器 这里只是做了一个log.info打印一下，可以在这里写入到数据库中或者写入
 */
@Slf4j
@Component
public class AopLogCollector implements LogCollector {
    private ObjectMapper objectMapper = new ObjectMapper();
    @Override
    public void collect(LogData logData) {
        try {
            log.info(objectMapper.writeValueAsString(logData));
        } catch (JsonProcessingException e) {
            e.printStackTrace();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置@Component的全局日志收集器只能配置一个。&lt;/p&gt;
&lt;p&gt;接口调用 &lt;code&gt;/say/hello&lt;/code&gt; 测试即可看看到控制台打印出结果 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2020-09-16 16:01:04.782  INFO 2012 --- [AsyncExecutor-2] name.ealen.infra.advice.AopLogCollector  : {&quot;appName&quot;:&quot;app-template&quot;,&quot;host&quot;:&quot;127.0.0.1&quot;,&quot;port&quot;:8080,&quot;clientIp&quot;:&quot;192.168.110.1&quot;,&quot;reqUrl&quot;:&quot;http://localhost:8080/app/sayHello&quot;,&quot;httpMethod&quot;:&quot;GET&quot;,&quot;headers&quot;:{&quot;User-Agent&quot;:&quot;Apache-HttpClient/4.5.10 (Java/11.0.5)&quot;},&quot;type&quot;:&quot;测试&quot;,&quot;content&quot;:&quot;&quot;,&quot;method&quot;:&quot;name.ealen.api.facade.AppController#sayHello&quot;,&quot;args&quot;:null,&quot;respBody&quot;:{&quot;code&quot;:&quot;200&quot;,&quot;desc&quot;:&quot;OK&quot;,&quot;message&quot;:&quot;请求成功&quot;,&quot;dateTime&quot;:&quot;2020-09-16 16:01:04&quot;,&quot;body&quot;:&quot;hello EalenXie&quot;},&quot;logDate&quot;:1600243264780,&quot;costTime&quot;:1,&quot;threadName&quot;:&quot;http-nio-8080-exec-3&quot;,&quot;threadId&quot;:33,&quot;success&quot;:true}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;记录的日志对象logdata属性说明&quot;&gt;记录的日志对象LogData属性说明&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;LogData 记录的内容&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;注释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;appName&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;应用名称&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;host&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;主机&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;port&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;端口号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;clientIp&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;请求客户端的Ip&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;reqUrl&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;请求地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;headers&lt;/td&gt;
&lt;td&gt;Object&lt;/td&gt;
&lt;td&gt;请求头部信息(可选择记录) 默认记录user-agent,content-type&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;type&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;操作类型,默认值undefined&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;content&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;方法步骤内容,默认是空,可使用LogData.step进行内容步骤记录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;method&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;请求的本地java方法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;args&lt;/td&gt;
&lt;td&gt;Object&lt;/td&gt;
&lt;td&gt;方法请求参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;respBody&lt;/td&gt;
&lt;td&gt;Object&lt;/td&gt;
&lt;td&gt;方法响应参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;costTime&lt;/td&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;td&gt;整个方法耗时&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;logDate&lt;/td&gt;
&lt;td&gt;Date&lt;/td&gt;
&lt;td&gt;Log产生时间,LogData对象初始化的时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;threadName&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;线程名称&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;threadId&lt;/td&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;td&gt;线程Id&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;success&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;执行状态,成功(true)/异常(false)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&quot;aoplog-注解选项说明&quot;&gt;AopLog 注解选项说明&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;选项&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;默认&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;logOnErr&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;仅当发生异常时才记录收集&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;type&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;操作类型&lt;/td&gt;
&lt;td&gt;默认值&quot;undefined&quot;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;headers&lt;/td&gt;
&lt;td&gt;String[]&lt;/td&gt;
&lt;td&gt;记录的header信息 ,选择要记录哪些header信息&lt;/td&gt;
&lt;td&gt;默认&quot;User-Agent&quot;,&quot;content-type&quot;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;args&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;是否记录请求参数&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;respBody&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;是否记录响应参数&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;stackTraceOnErr&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;当目标方法发生异常时,是否追加异常堆栈信息到LogData的content中&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;asyncMode&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;异步方式收集&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;collector&lt;/td&gt;
&lt;td&gt;Class&amp;lt;? extends LogCollector&amp;gt;&lt;/td&gt;
&lt;td&gt;指定日志收集器&lt;/td&gt;
&lt;td&gt;默认不调整收集器,使用全局的日志收集器&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&quot;logdata的step方法。&quot;&gt;LogData的step方法。&lt;/h4&gt;
&lt;p&gt;记录步骤。(如果某些重要步骤希望被记录下来)&lt;br/&gt;
例如 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import com.github.AopLog;
import com.github.LogData;
import name.ealen.infra.base.resp.RespBody;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;


/**
 * @author EalenXie create on 2020/6/22 14:28
 */
@AopLog(type = &quot;测试&quot;,stackTraceOnErr = true)
@RestController
public class AppController {


    @GetMapping(&quot;/app/sayHello&quot;)
    public RespBody&amp;lt;String&amp;gt; sayHello() {
        LogData.step(&quot;1. 第一步执行完成&quot;);
        //......
        LogData.step(&quot;2. 第二步执行完成&quot;);
        //.....
        LogData.step(&quot;3. service的方法执行完成&quot;);
        //.....
        return RespBody.ok(&quot;hello EalenXie&quot;);
    }

}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意: 此方法如果不在被@AopLog注解的方法的整体调用链路中使用，则当前线程中的ThreadLocal中的LogData不会释放，需要手动调用LogData.removeCurrent();&lt;/p&gt;
&lt;p&gt;此时再次接口调用 &lt;code&gt;/say/hello&lt;/code&gt; 测试即可看看到控制台打印出结果，重点观察content字段 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2020-09-16 17:26:20.285  INFO 3284 --- [AsyncExecutor-2] name.ealen.infra.advice.AopLogCollector  : {&quot;appName&quot;:&quot;app-template&quot;,&quot;host&quot;:&quot;127.0.0.1&quot;,&quot;port&quot;:8080,&quot;clientIp&quot;:&quot;192.168.110.1&quot;,&quot;reqUrl&quot;:&quot;http://localhost:8080/app/sayHello&quot;,&quot;httpMethod&quot;:&quot;GET&quot;,&quot;headers&quot;:{&quot;User-Agent&quot;:&quot;Apache-HttpClient/4.5.10 (Java/11.0.5)&quot;},&quot;type&quot;:&quot;测试&quot;,&quot;content&quot;:&quot;1. 第一步执行完成\n2. 第二步执行完成\n3. service的方法执行完成\n&quot;,&quot;method&quot;:&quot;name.ealen.api.facade.AppController#sayHello&quot;,&quot;args&quot;:null,&quot;respBody&quot;:{&quot;code&quot;:&quot;200&quot;,&quot;desc&quot;:&quot;OK&quot;,&quot;message&quot;:&quot;请求成功&quot;,&quot;dateTime&quot;:&quot;2020-09-16 17:26:20&quot;,&quot;body&quot;:&quot;hello EalenXie&quot;},&quot;logDate&quot;:1600248380283,&quot;costTime&quot;:1,&quot;threadName&quot;:&quot;http-nio-8080-exec-2&quot;,&quot;threadId&quot;:32,&quot;success&quot;:true}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;关于&quot;&gt;关于&lt;/h4&gt;
&lt;p&gt;开源Github地址 : &lt;a href=&quot;https://github.com/EalenXie/aop-log&quot;&gt;https://github.com/EalenXie/aop-log&lt;br/&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;感谢各位提出意见和支持。&lt;/p&gt;
&lt;p&gt;我的博客即将同步至腾讯云+社区，邀请大家一同入驻：&lt;a href=&quot;https://cloud.tencent.com/developer/support-plan?invite_code=2xarst7a9zsw8&quot;&gt;https://cloud.tencent.com/developer/support-plan?invite_code=2xarst7a9zsw8&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>53b6c73b207428153551725bfa2a60be</guid>
<title>多图，一文了解 8 种常见的数据结构</title>
<link>https://toutiao.io/k/d392rnj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;前几天和丙弟交流，他说我们写作的人都是在不停地燃烧自己，所以需要不停地补充燃料。对于他的观点，我不能再苟同了——所以我开始狂补计算机方面的基础知识，这其中就包括我相对薄弱的数据结构。&lt;/p&gt;&lt;p&gt;百度百科对数据结构的定义是：相互之间存在一种或多种特定关系的数据元素的集合。定义很抽象，需要大声地朗读几遍，才有点感觉。怎么让这种感觉来得更强烈，更亲切一些呢？我来列举一下常见的 8 种数据结构，数组、链表、栈、队列、树、堆、图、哈希表。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.47619047619047616&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaB93GW1ZTzqzXpD9CCprJZGt0iauuLJzMUkicfMhOARZhIGnyFCibjGJ1yg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1218&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这 8 种数据结构有什么区别呢？&lt;/p&gt;&lt;p&gt;&lt;strong&gt;①、数组&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;优点：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;按照索引查询元素的速度很快；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;按照索引遍历数组也很方便。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;缺点：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;②、链表&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;《算法（第 4 版）》一书中是这样定义链表的：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;链表是一种递归的数据结构，它或者为空（null），或者是指向一个结点（node）的引用，该节点还有一个元素和一个指向另一条链表的引用。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Java 的 LinkedList 类可以很形象地通过代码的形式来表示一个链表的结构：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LinkedList&lt;/span&gt;&amp;lt;&lt;span&gt;E&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;transient&lt;/span&gt; Node&amp;lt;E&amp;gt; first;&lt;br/&gt;    &lt;span&gt;transient&lt;/span&gt; Node&amp;lt;E&amp;gt; last;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt;&amp;lt;&lt;span&gt;E&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;        E item;&lt;br/&gt;        Node&amp;lt;E&amp;gt; next;&lt;br/&gt;        Node&amp;lt;E&amp;gt; prev;&lt;br/&gt;&lt;br/&gt;        Node(Node&amp;lt;E&amp;gt; prev, E element, Node&amp;lt;E&amp;gt; next) {&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.item = element;&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.next = next;&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.prev = prev;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这是一种双向链表，当前元素 item 既有 prev 又有 next，不过 first 的 prev 为 null，last 的 next 为 null。如果是单向链表的话，就只有 next，没有 prev。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaBVCicPIQYibicdxouzxnVM4uVFXzGuDKFE66zDiav3Zu1rmw2HGPl0CiafGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;670&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;单向链表的缺点是只能从头到尾依次遍历，而双向链表可进可退，既能找到下一个，也能找到上一个——每个节点上都需要多分配一个存储空间。&lt;/p&gt;&lt;p&gt;链表中的数据按照“链式”的结构存储，因此可以达到内存上非连续的效果，数组必须是一块连续的内存。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5788888888888889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaBkmpbvsf8IUTrTgwbNdeXjW4iba1tJPSmZR4jZsL5THQhMZZewibDmIibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;由于不必按照顺序的方式存储，链表在插入、删除的时候可以达到 O(1) 的时间复杂度（只需要重新指向引用即可，不需要像数组那样移动其他元素）。除此之外，链表还克服了数组必须预先知道数据大小的缺点，从而可以实现灵活的内存动态管理。&lt;/p&gt;&lt;p&gt;优点：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;不需要初始化容量；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;可以添加任意元素；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;插入和删除的时候只需要更新引用。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;缺点：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;含有大量的引用，占用的内存空间大；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;查找元素需要遍历整个链表，耗时。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;③、栈&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;栈就好像水桶一样，底部是密封的，顶部是开口，水可以进可以出。用过水桶的小伙伴应该明白这样一个道理：先进去的水在桶的底部，后进去的水在桶的顶部；后进去的水先被倒出来，先进去的水后被倒出来。&lt;/p&gt;&lt;p&gt;同理，栈按照“后进先出”、“先进后出”的原则来存储数据，先插入的数据被压入栈底，后插入的数据在栈顶，读出数据的时候，从栈顶开始依次读出。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.9454545454545454&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaBbpJ3J7DZLmox5PicUyzBM5hnVC2W37CEKIwKbibvKZeaLlQbP3efwV4g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;220&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;④、队列&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;队列就好像一段水管一样，两端都是开口的，水从一端进去，然后从另外一端出来。先进去的水先出来，后进去的水后出来。&lt;/p&gt;&lt;p&gt;和水管有些不同的是，队列会对两端进行定义，一端叫队头，另外一端就叫队尾。队头只允许删除操作（出队），队尾只允许插入操作（入队）。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.531700288184438&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaBuqsHCTFJJS1QEbMQlWGYNibF1U0s2VBVQE9arW7rpjSmxHZhvgGEicOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;694&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;注意，栈是先进后出，队列是先进先出——两者虽然都是线性表，但原则是不同的，结构不一样嘛。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;⑤、树&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;树是一种典型的非线性结构，它是由 n（n&amp;gt;0）个有限节点组成的一个具有层次关系的集合。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.9416666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaBNG5VquqaTNkXHazARMOOHWI3hXmeKc8Pqibk63EFSHKCAh1XD7ccIVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;之所以叫“树”，是因为这种数据结构看起来就像是一个倒挂的树，只不过根在上，叶在下。树形数据结构有以下这些特点：&lt;/p&gt;&lt;p&gt;下图展示了树的一些术语：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.8258064516129032&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaB5fBXNTAjhGAkGPK1GSEtuWia41G9tutOp4sNS5qByTy6QFxYzfLibgzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;根节点是第 0 层，它的子节点是第 1 层，子节点的子节点为第 2 层，以此类推。&lt;/p&gt;&lt;p&gt;树的种类有很多种，常见的有：&lt;/p&gt;&lt;p&gt;假如有三个节点，一个是父节点，两个是同级的子节点，那么就有三种情况：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.2653225806451613&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaBlzDo0iadbvynC8D3O2VQwCJib581GmjqibPlhM09Mz9sHKwvfTmZbwOqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;假如有三个节点，一个是父节点，两个是不同级的子节点，那么就有六种情况：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.45483870967741935&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaBvHIqQT4AgkchWGGIc86w157X4iaORtNbK1ia8WZ9qD0yGdLY8ibMjlC0A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;三个节点组成的无序树，合起来就是九种情况。&lt;/p&gt;&lt;p&gt;完全二叉树：对于一颗二叉树，假设其深度为 d（d &amp;gt; 1）。除了第 d 层，其它各层的节点数目均已达最大值，且第 d 层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.716931216931217&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaBibF1D0NMh3ELjuOuvN9kjlibkEJbIhyjcubicaia6ajugIOaS8kMyFG9uw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;756&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;拿上图来说，d 为 3，除了第 3 层，第 1 层、第 2 层 都达到了最大值（2 个子节点），并且第 3 层的所有节点从左向右联系地紧密排列（H、I、J、K、L），符合完全二叉树的要求。&lt;/p&gt;&lt;p&gt;满二叉树：一颗每一层的节点数都达到了最大值的二叉树。有两种表现形式，第一种，像下图这样（每一层都是满的），满足每一层的节点数都达到了最大值 2。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6475409836065574&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaBe3ctGhq7WqiapWQpNJNHAibn74hPPK6zUG8a359gb3RQ92PiaDDdcG4lA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;第二种，像下图这样（每一层虽然不满），但每一层的节点数仍然达到了最大值 2。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7481060606060606&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaB92VnLZdZEFYRW2f73UnhVuZAtTVzQRk0lhxhibgz1BnxWOhPuAOQ2Ew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1056&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;二叉查找树：英文名叫 Binary Search Tree，即 BST，需要满足以下条件：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5298387096774193&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaByCLXibBBJdRBBiclOiaeLMxySmPxECdFOO43DpicHl0OGZIicmYC3LYel3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;基于二叉查找树的特点，它相比较于其他数据结构的优势就在于查找、插入的时间复杂度较低，为 O(logn)。假如我们要从上图中查找 5 个元素，先从根节点 7 开始找，5 必定在 7 的左侧，找到 4，那 5 必定在 4 的右侧，找到 6，那 5 必定在 6 的左侧，找到了。&lt;/p&gt;&lt;p&gt;理想情况下，通过 BST 查找节点，所需要检查的节点数可以减半。&lt;/p&gt;&lt;p&gt;平衡二叉树：当且仅当任何节点的两棵子树的高度差不大于 1 的二叉树。由前苏联的数学家 Adelse-Velskil 和 Landis 在 1962 年提出的高度平衡的二叉树，根据科学家的英文名也称为 AVL 树。&lt;/p&gt;&lt;p&gt;平衡二叉树本质上也是一颗二叉查找树，不过为了限制左右子树的高度差，避免出现倾斜树等偏向于线性结构演化的情况，所以对二叉搜索树中每个节点的左右子树作了限制，左右子树的高度差称之为平衡因子，树中每个节点的平衡因子绝对值不大于 1。&lt;/p&gt;&lt;p&gt;平衡二叉树的难点在于，当删除或者增加节点的情况下，如何通过左旋或者右旋的方式来保持左右平衡。&lt;/p&gt;&lt;p&gt;Java 中最常见的平衡二叉树就是红黑树，节点是红色或者黑色，通过颜色的约束来维持着二叉树的平衡：&lt;/p&gt;&lt;p&gt;1）每个节点都只能是红色或者黑色&lt;/p&gt;&lt;p&gt;2）根节点是黑色&lt;/p&gt;&lt;p&gt;3）每个叶节点（NIL 节点，空节点）是黑色的。&lt;/p&gt;&lt;p&gt;4）如果一个节点是红色的，则它两个子节点都是黑色的。也就是说在一条路径上不能出现相邻的两个红色节点。&lt;/p&gt;&lt;p&gt;5）从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5724815724815725&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaBrmu2nPLWWjKOtn3TkgjDFBordKkDFBakyLRuQG6lrTFZdhUTEWhlgA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;814&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5630252100840336&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaBLHPViaSrBvypPqwsDJs7sFjUE2V1dL9RDBo0F9FJevfA8P2CtO8xLaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1190&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;⑥、堆&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;堆可以被看做是一棵树的数组对象，具有以下特点：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;堆中某个节点的值总是不大于或不小于其父节点的值；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;堆总是一棵完全二叉树。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.42096774193548386&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaBxz4ddlo5D4aLLkhoGj7hScRQR8Ipv0ototruVb7VVfJxd6pbQcXQzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;⑦、图&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;图是一种复杂的非线性结构，由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G（V，E），其中，G 表示一个图，V 是图 G 中顶点的集合，E 是图 G 中边的集合。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5199501246882793&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaB5uNbXoX3qxZS5j4lakLGo6fcia44HylHMw57socSNs7lf0ul4oNnPiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;802&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;上图共有 V0，V1，V2，V3 这 4 个顶点，4 个顶点之间共有 5 条边。&lt;/p&gt;&lt;p&gt;在线性结构中，数据元素之间满足唯一的线性关系，每个数据元素（除第一个和最后一个外）均有唯一的“前驱”和“后继”；&lt;/p&gt;&lt;p&gt;在树形结构中，数据元素之间有着明显的层次关系，并且每个数据元素只与上一层中的一个元素（父节点）及下一层的多个元素（子节点）相关；&lt;/p&gt;&lt;p&gt;而在图形结构中，节点之间的关系是任意的，图中任意两个数据元素之间都有可能相关。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;⑧、哈希表&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;哈希表（Hash Table），也叫散列表，是一种可以通过关键码值（key-value）直接访问的数据结构，它最大的特点就是可以快速实现查找、插入和删除。&lt;/p&gt;&lt;p&gt;数组的最大特点就是查找容易，插入和删除困难；而链表正好相反，查找困难，而插入和删除容易。哈希表很完美地结合了两者的优点， Java 的 HashMap 在此基础上还加入了树的优点。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.756701030927835&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaBcJg9UngrA7Yh40PkVSOCIkcabXgUqCrxNTaWg9F7Vgn8v4WcsfBGKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;970&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;哈希函数在哈希表中起着⾮常关键的作⽤，它可以把任意长度的输入变换成固定长度的输出，该输出就是哈希值。哈希函数使得一个数据序列的访问过程变得更加迅速有效，通过哈希函数，数据元素能够被很快的进行定位。&lt;/p&gt;&lt;p&gt;若关键字为 k，则其值存放在 &lt;code&gt;hash(k)&lt;/code&gt; 的存储位置上。由此，不需要遍历就可以直接取得 k 对应的值。&lt;/p&gt;&lt;p&gt;对于任意两个不同的数据块，其哈希值相同的可能性极小，也就是说，对于一个给定的数据块，找到和它哈希值相同的数据块极为困难。再者，对于一个数据块，哪怕只改动它的一个比特位，其哈希值的改动也会非常的大——这正是 Hash 存在的价值！&lt;/p&gt;&lt;p&gt;尽管可能性极小，但仍然会发生，如果哈希冲突了，Java 的 HashMap 会在数组的同一个位置上增加链表，如果链表的长度大于 8，将会转化成红黑树进行处理——这就是所谓的拉链法（数组+链表）。&lt;/p&gt;&lt;p&gt;说句实在话，照这个进度恶补下去，我感觉要秃的节奏，不过，如果能够变得更强，值了——对，值了。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1c074b971507360f57f4173a3c949f57</guid>
<title>Python 之父为什么嫌弃 lambda 匿名函数？</title>
<link>https://toutiao.io/k/tvchzyj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;Python 支持 lambda 匿名函数，其扩展的 BNF 表示法是&lt;code&gt;&lt;span&gt;lambda_expr ::= &quot;lambda&quot; [parameter_list] &quot;:&quot; expression&lt;/span&gt;&lt;/code&gt;，也就是&lt;code&gt;&lt;span&gt;lambda 参数序列:表达式&lt;/span&gt;&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;这是一种便捷的函数定义方式，若翻译成我们熟知的函数形式，会是这个样子：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &amp;lt;&lt;span&gt;lambda&lt;/span&gt;&amp;gt;&lt;span&gt;(parameter_list)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; expression&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也就是说，&lt;strong&gt;Python 中的 lambda 函数是一种可接收多个参数的函数，返回值是一个表达式。&lt;/strong&gt; &lt;/p&gt;&lt;p&gt;它最大的好处是单行简洁，不需要函数命名与换行缩进。&lt;/p&gt;&lt;p&gt;不得不说，匿名函数有时候是挺好用的，比如下文会介绍到的一些常见用法，它因此受到了不少人的推崇。&lt;/p&gt;&lt;p&gt;但是，匿名函数通常也会造成代码难以阅读，容易被人滥用，再加上 Python 只提供了对它的“残疾的”支持，所以又有一些观点不建议使用匿名函数。&lt;/p&gt;&lt;p&gt;事实上，&lt;strong&gt;Python 之父 &lt;span&gt;Guido van Rossum&lt;/span&gt; 就属于“不推荐使用派”，他甚至曾经（2005年）想要移除 &lt;span&gt;lambda&lt;/span&gt;，只不过最后妥协了。&lt;/strong&gt; &lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5329768270944741&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LLRiaS9YfFTNSj00ComX3SuXopK3H6Rib9tNVVanR5ichhanXgCD4QWaM69DBBaWYFdwjvu2CPpPTesgnV4ibgqo7A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1122&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;出处：&lt;span&gt;https://www.artima.com/weblogs/viewpost.jsp?thread=98196&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;lambda 这一个由其他开发者贡献进来的特性（借鉴自 lisp 语言），存在了十多年，但是却被这门语言的创造者（兼首席设计师）所嫌弃，最后竟然还奇迹般地幸存了下来，对于这个故事，大家是否觉得挺有戏剧性的？&lt;/p&gt;&lt;p&gt;接下来，本文就仔细聊一聊这个处境尴尬却生命力顽强的 lambda 匿名函数吧！&lt;/p&gt;&lt;h2&gt;&lt;span&gt;1、lambda 怎么使用？&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;lambda 函数通常的用法是结合 map()、reduce()、filter()、sorted() 等函数一起使用，这些函数的共性是：&lt;strong&gt;都可以接收其它函数作为参数。&lt;/strong&gt; &lt;/p&gt;&lt;p&gt;例如下面的几个例子：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;my_list = [&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;]&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 元素全加1，结果：[4, 2, 6, 5, 11]&lt;/span&gt;&lt;br/&gt;list(map(&lt;span&gt;lambda&lt;/span&gt; i:i+&lt;span&gt;1&lt;/span&gt;, my_list)) &lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 过滤小于10的元素，结果：[3, 1, 5, 4]&lt;/span&gt;&lt;br/&gt;list(filter(&lt;span&gt;lambda&lt;/span&gt; i:i&amp;lt;&lt;span&gt;10&lt;/span&gt;, my_list)) &lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 元素累加，结果：33&lt;/span&gt;&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; functools &lt;span&gt;import&lt;/span&gt; reduce&lt;br/&gt;reduce(&lt;span&gt;lambda&lt;/span&gt; i,j:i+j, my_list, &lt;span&gt;10&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 字典按值排序，结果：[(&#x27;b&#x27;, 1), (&#x27;a&#x27;, 3), (&#x27;d&#x27;, 4), (&#x27;c&#x27;, 5)]&lt;/span&gt;&lt;br/&gt;my_dict = {&lt;span&gt;&#x27;a&#x27;&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;&#x27;b&#x27;&lt;/span&gt;:&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&#x27;c&#x27;&lt;/span&gt;:&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;&#x27;d&#x27;&lt;/span&gt;:&lt;span&gt;4&lt;/span&gt;}&lt;br/&gt;sorted(my_dict.items(), key=&lt;span&gt;lambda&lt;/span&gt; item:item[&lt;span&gt;1&lt;/span&gt;])&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;初学者也许会觉得代码读不懂，但是只要记住“&lt;strong&gt;Python中的函数是一等公民&lt;/strong&gt;”，知道一个函数可以被作为另一个函数的参数或者返回值，就容易理解了。&lt;/p&gt;&lt;p&gt;比如对于 map() 函数的例子，你可以理解成这个形式：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;my_func = &lt;span&gt;lambda&lt;/span&gt; i:i+&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;list(map(my_func, my_list)) &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;甚至可以还原成普通的函数：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;add_one&lt;/span&gt;&lt;span&gt;(i)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; i+&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;list(map(add_one, my_list)) &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;map() 函数的第一个参数是一个函数，第二个参数是一个可迭代对象。这第一个参数会迭代地调用第二个参数中的元素，调用的结果以迭代器的形式返回。&lt;/p&gt;&lt;p&gt;这个例子使用了 list()，是为了方便一次性取出迭代器中的元素，直观地展示出来，在实际使用中，很可能会是基于迭代器的形式。&lt;/p&gt;&lt;section&gt;由这几种用法，我们可以总结出 lambda 函数的使用规律：&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;它出现在需要使用函数的地方&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;它适合实现简单的功能&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;它是一次性的用途，不能在其它地方复用&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;它一般不会被独立使用，总是作为其它函数的一部分&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;2、lambda 有什么问题？&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;由上面的用法可以看出，使用 lambda 函数的代码比较紧凑简洁，所以有人称它体现了“Pythonic”的优雅思想。&lt;/p&gt;&lt;p&gt;但是，lambda 函数有没有什么缺陷呢？&lt;/p&gt;&lt;p&gt;有！当前的 lambda 函数有一个最大的问题，即只支持单行表达式，无法实现丰富的功能，例如无法在函数创建时使用语句（statement），无法使用 if-else 的判断条件，也无法使用 try-except 的异常捕获机制，等等。&lt;/p&gt;&lt;p&gt;这极大地限制了它的能力，导致了它被人诟病为“残疾的”。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;从技术实现的角度上看，&lt;/strong&gt; 这个问题可以通过语法层面的设计来解决。&lt;/p&gt;&lt;p&gt;在当年的邮件组讨论中，有人提出过一些解决思路，比如这封邮件：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.45154419595314166&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LLRiaS9YfFTNSj00ComX3SuXopK3H6Rib9U7W346dFAiarxWjwB1JJpYdyAX2wGlakiagibsDLWiatzdaHgPDSrDAPaw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;939&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;出处：&lt;/span&gt;&lt;span&gt;https://mail.python.org/pipermail/python-dev/2006-February/060654.html&lt;/span&gt;&lt;/section&gt;&lt;p&gt;它提出了一个&lt;code&gt;lambda args::suite&lt;/code&gt; 的想法，支持写成这样的形式：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;ss = sorted(seq, key=(&lt;span&gt;lambda&lt;/span&gt; x::&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt;: &lt;span&gt;return&lt;/span&gt; abs(x)&lt;br/&gt;            &lt;span&gt;except&lt;/span&gt; TypeError: &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;))&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是，Guido 很快就否决了这个思路。&lt;/p&gt;&lt;p&gt;他写了一篇文章《&lt;span&gt;Language Design Is Not Just Solving Puzzles&lt;/span&gt;》来回应：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5336538461538461&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LLRiaS9YfFTNSj00ComX3SuXopK3H6Rib9j5PEib0VSVt0AqYzNm33opqJNvWTLn2qpFbAtpjfbicHWxq1zDyIynUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1248&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;出处：&lt;/span&gt;&lt;span&gt;https://www.artima.com/weblogs/viewpost.jsp?thread=147358&lt;/span&gt;&lt;/section&gt;&lt;p&gt;其基本观点是：&lt;strong&gt;不能光顾着解决一个问题/实现某种功能，就引入缺乏“Pythonicity”的语言设计。&lt;/strong&gt; &lt;/p&gt;&lt;p&gt;那么，为什么 Guido 会认为这是一种不好的设计呢？&lt;/p&gt;&lt;section&gt;我试着概括一下，理由是：&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;双冒号“::”凭空在此引入，但是跟切片语法中的“::”完全不同，而且跟 C++/Perl 中的作用域操作符用法也不同&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;即使不用双冒号，用其它符号表示（比如单冒号），还是难以接受，因为都会在一个表达式中嵌入缩进代码块。这就跟使用花括号和 begin/end 关键字来作语句分组（statement grouping）一样，都令人难以接受&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在 lambda 中实现其它功能并不重要，这还会让解析器变得复杂（需区分是否有缩进、记录缩进级别），显得小题大做了&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;简而言之，&lt;strong&gt;他认为简洁友好的用户体验更为重要，如果简洁的语法无法满足需求，就应该写成具名函数的形式，而非设计出复杂的匿名函数。&lt;/strong&gt; &lt;/p&gt;&lt;h2&gt;&lt;span&gt;3、为什么 Guido 想移除 lambda？&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;上文提到的多行 lambda 语句（multi-statement lambda）事件发生在 2006 年，我们看到了 Guido 不想给 lambda 引入复杂设计的原因。&lt;/p&gt;&lt;p&gt;但是，早在 2005 年，Guido 就曾经想要从 Python 移除 lambda，他对它的“嫌弃”是一个“历史悠久”的传统……&lt;/p&gt;&lt;p&gt;在《&lt;span&gt;The fate of reduce() in Python 3000&lt;/span&gt;》这篇短文中，Guido 提出要一次性移除 reduce()、map()、filter() 以及 lambda。&lt;/p&gt;&lt;section&gt;移除 lambda 的理由如下：&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对于不熟悉 Lisp 或 Scheme 的用户，lambda 这名字容易造成混淆&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;很多人误以为匿名函数能做嵌套函数不能做的事，但其实并无区别；存在lambda，就会造成不必要的选择，减少选择，可以简化思维&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;移除 reduce()、map() 和 filter() 后，就没必要写简短的局部函数了&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;回顾一下我们在前文中总结出的 lambda 的 4 条使用规律，可以发现它跟几个高阶函数（可以接收其它函数作为参数的函数）有较强的“寄生关系”，如果它们能移除了的话，lambda 确实就没有什么独立存留的意义了。&lt;/p&gt;&lt;p&gt;那么，为什么 Guido 觉得应该移除那几个高阶函数呢？&lt;/p&gt;&lt;section&gt;主要的理由有：&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;可以替换成更加清晰的列表解析式或者生成器表达式，例如 filter(P,S) 可以写成 [x for x in S if P(x)]，map(F, S) 写成 [F(x) for x in S]&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;至于 reduce()，他说这是最讨厌的，除了涉及 + 和 * 的少数用法，其它时候他总要拿出纸笔来画图解才能搞清楚。除了显式地写循环，他还针对 reduce() 的几种用法而提出了几个替代用法，包括引入新的 any() 和 all() 函数&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;总体而言，Guido 的想法暗合了《The Zen of Python》中的这一条：&lt;span&gt;&lt;strong&gt;There should be one-- and preferably only one --obvious way to do it。&lt;/strong&gt;&lt;/span&gt;&lt;strong/&gt; &lt;/p&gt;&lt;p&gt;但是回到现实，为了照顾某些人的习惯，以及对兼容性的考虑，Guido 最后保守地放弃了“清理异端”的计划。&lt;/p&gt;&lt;p&gt;因此，lambda 得以从 Python 最高独裁者的手上死里逃生。直到一年后，它试图兴风作浪（多行表达式），却惨遭镇压。&lt;/p&gt;&lt;p&gt;我仿佛听到了 Guido 的内心 OS：当初我想删除东西的时候，你们百般阻挠，现在你们想添加东西，哼，没门！……&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.8&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LLRiaS9YfFTNSj00ComX3SuXopK3H6Rib9lUibu3gfZcn38YFhK63B93mVb9OBibKZSmicEvwKHbsa4rU6LxuwbB2Aw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1000&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;哈哈，开了个玩笑。&lt;/p&gt;&lt;p&gt;Guido 的所有决定都体现了他的 Pythonic 设计美学、自恰的逻辑一致性以及对社区声音的权衡。&lt;/p&gt;&lt;p&gt;对于 lambda，我认可他的观点，而通过回溯语法发展的历史，我觉得自己对于 Python 的理解变得更为丰富了。不知道你可有同感？&lt;/p&gt;&lt;section&gt;&lt;mp-qa class=&quot;js_uneditable custom_select_card qa_iframe&quot; data-pluginname=&quot;insertquestion&quot; data-id=&quot;1527011052679430146&quot; data-bizuin=&quot;MzUyOTk2MTcwNg==&quot; data-title=&quot;聊聊你是怎么看的？&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;最后，附上几篇 Python 程序设计相关的文章作为延伸阅读：&lt;/section&gt;&lt;section&gt;&lt;span&gt;1、&lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247484171&amp;amp;idx=1&amp;amp;sn=1dded6a1fe55a0821c7e9eef11b4ce36&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;len(x) 击败 x.len()，从内置函数看 Python 的设计思想&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2、&lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247484343&amp;amp;idx=1&amp;amp;sn=3eaa4edfd9a26fee4918b969be7305d6&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;编程语言之问：何时该借用，何时该创造？&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3、&lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247484675&amp;amp;idx=1&amp;amp;sn=8436b89275654b994458405d42f393ae&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Python 为什么要保留显式的 self ？&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;4、&lt;/span&gt;&lt;span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247485399&amp;amp;idx=1&amp;amp;sn=1bff48bcb6352f5a09cb7400e2ef8868&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Python 为什么使用缩进来划分代码块？&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ca7b1683b01879920d7a83d2ca230803</guid>
<title>[译] 仅用 18 行 JavaScript 构建一个倒数计时器</title>
<link>https://toutiao.io/k/qijww23</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3724053724053724&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0ANAsyE4nMbsnrRoddRZl3UltwVTlHofjZZWC4VtyKS2BtDaLdB1cXKyZOpLj4GvWpaSntOJvYWwgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1638&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;来源：https://www.sitepoint.com，作者：Nilson Jacques&lt;/span&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第100期了，回馈粉丝，文末参与送书活动！&lt;/span&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;有时候，你会需要构建一个JavaScript倒计时时钟。你可能会有一个活动、一个销售、一个促销或一个游戏。你可以用原生的JavaScript构建一个时钟，而不是去找一个插件。尽管有很多很棒的时钟插件，但是使用原生JavaScript可以带来以下好处：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;你的代码将是轻量级的，因为它将具有零依赖性。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;你的网站将表现得更好。你不需要加载外部脚本和样式表。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;你将拥有更多的控制权。你将会建立一个完全按照你的意愿来表现的时钟。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所以，废话不多说，下面是如何在短短的18行JavaScript中制作自己的倒计时钟。&lt;/span&gt;&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;目录：&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;1.基本时钟：倒数到特定的日期或时间&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;2.设置有效的结束日期&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.计算剩余时间&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4.将时间转换为可用格式&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;5.将时钟数据输出为可重复使用的对象&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;6.在页面上显示时钟，并在时钟为零时停止时钟&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;7.准备展示你的时钟&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;7.1 消除初始延迟&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;7.2 避免不断重建时钟&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;7.3 添加前导0&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;8.更进一步&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;8.1 自动调节时钟&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;8.2 从用户到达起将计时器设置为10分钟&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;8.3 跨页面保持时钟进度&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;9.有关客户端时间的重要警告&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;10.总结&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;11.代码&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.基本时钟：倒数到特定的日期或时间&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以下是创建基本时钟所需步骤的简要概述：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;设置有效的结束日期。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;计算剩余时间。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将时间转换为可用格式。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将时钟数据输出为可重复使用的对象。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在页面上显示时钟，并在时钟为零时停止时钟。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.设置有效的结束日期&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先，你需要设置一个有效的结束日期。这应该是JavaScript的 Date.parse() 方法可以理解的任何格式的字符串。例如：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;ISO 8601格式：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; deadline = &lt;span&gt;&#x27;2015-12-31&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;简短格式：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; deadline = &lt;span&gt;&#x27;31/12/2015&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;或者，长格式：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; deadline = &lt;span&gt;&#x27;December 31 2015&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这些格式中的每一种都允许你指定一个准确的时间和一个时区（或者在ISO日期的情况下指定一个与UTC的偏移）。例如：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; deadline = &lt;span&gt;&#x27;December 31 2015 23:59:59 GMT+0200&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.计算剩余时间&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下一步是计算剩余时间。我们需要编写一个函数，该函数需要一个表示给定结束时间的字符串（如上所述）。然后，我们计算该时间与当前时间之间的时差。看起来像这样：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;getTimeRemaining&lt;/span&gt;(&lt;span&gt;endtime&lt;/span&gt;)&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; total = &lt;span&gt;Date&lt;/span&gt;.parse(endtime) - &lt;span&gt;Date&lt;/span&gt;.parse(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;());&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; seconds = &lt;span&gt;Math&lt;/span&gt;.floor( (total/&lt;span&gt;1000&lt;/span&gt;) % &lt;span&gt;60&lt;/span&gt; );&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; minutes = &lt;span&gt;Math&lt;/span&gt;.floor( (total/&lt;span&gt;1000&lt;/span&gt;/&lt;span&gt;60&lt;/span&gt;) % &lt;span&gt;60&lt;/span&gt; );&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; hours = &lt;span&gt;Math&lt;/span&gt;.floor( (total/(&lt;span&gt;1000&lt;/span&gt;*&lt;span&gt;60&lt;/span&gt;*&lt;span&gt;60&lt;/span&gt;)) % &lt;span&gt;24&lt;/span&gt; );&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; days = &lt;span&gt;Math&lt;/span&gt;.floor( total/(&lt;span&gt;1000&lt;/span&gt;*&lt;span&gt;60&lt;/span&gt;*&lt;span&gt;60&lt;/span&gt;*&lt;span&gt;24&lt;/span&gt;) );&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;    total,&lt;br/&gt;    days,&lt;br/&gt;    hours,&lt;br/&gt;    minutes,&lt;br/&gt;    seconds&lt;br/&gt;  };&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先，我们要创建一个变量 &lt;/span&gt;&lt;code&gt;&lt;span&gt;total&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 以保留到截止日期为止的剩余时间。&lt;/span&gt;&lt;code&gt;&lt;span&gt;Date.parse()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 函数将时间字符串转换为毫秒值，这样我们就可以将两次相减，得到中间的时间量。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; total = &lt;span&gt;Date&lt;/span&gt;.parse(endtime) - &lt;span&gt;Date&lt;/span&gt;.parse(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.将时间转换为可用格式&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在我们要将毫秒转换为天，小时，分钟和秒。让我们以秒为例：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; seconds = &lt;span&gt;Math&lt;/span&gt;.floor( (t/&lt;span&gt;1000&lt;/span&gt;) % &lt;span&gt;60&lt;/span&gt; );&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;让我们分解一下这里发生的事情。&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将毫秒除以1000可转换为秒：&lt;/span&gt;&lt;code&gt;&lt;span&gt;(t/1000)&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将总秒数除以60，然后取余数。你不需要所有的秒，只需要计算分钟数后剩下的那些：&lt;/span&gt;&lt;code&gt;&lt;span&gt;(t/1000) % 60&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;四舍五入到最接近的整数。这是因为你需要完整的秒数，而不是几分之一秒：&lt;/span&gt;&lt;code&gt;&lt;span&gt;Math.floor((t/1000)％60)&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;重复此逻辑，将毫秒转换为分钟，小时和天。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;mpcpc js_editor_cpcad=&quot;&quot; class=&quot;js_cpc_area cpc_iframe&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/cpc_tmpl#1600180410767&quot; data-category_id_list=&quot;1|11|16|17|22|24|26|27|28|29|3|31|32|35|36|37|39|41|42|43|45|46|47|48|49|5|50|51|52|53|54|55|6|7|8&quot; data-id=&quot;1600180410767&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.将时钟数据输出为可重复使用的对象&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在准备好几天，几小时，几分钟和几秒钟之后，我们现在可以将数据作为可重复使用的对象返回：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;  total,&lt;br/&gt;  days,&lt;br/&gt;  hours,&lt;br/&gt;  minutes,&lt;br/&gt;  seconds&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个对象允许你调用你的函数，并获得任何计算值。这是如何获取剩余分钟数的示例：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;getTimeRemaining(deadline).minutes&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;方便吧？&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6.在页面上显示时钟，并在时钟为零时停止时钟&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在我们有了一个可以吐出剩余天数、小时、分钟和秒数的函数，我们就可以建立我们的时钟了。首先，我们将创建以下HTML元素来保存时钟：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;clockdiv&quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;然后，我们将编写一个函数，在新的div中输出时钟数据：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;initializeClock&lt;/span&gt;(&lt;span&gt;id, endtime&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; clock = &lt;span&gt;document&lt;/span&gt;.getElementById(id);&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; timeinterval = setInterval(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; t = getTimeRemaining(endtime);&lt;br/&gt;    clock.innerHTML = &lt;span&gt;&#x27;days: &#x27;&lt;/span&gt; + t.days + &lt;span&gt;&#x27;&amp;lt;br&amp;gt;&#x27;&lt;/span&gt; +&lt;br/&gt;                      &lt;span&gt;&#x27;hours: &#x27;&lt;/span&gt;+ t.hours + &lt;span&gt;&#x27;&amp;lt;br&amp;gt;&#x27;&lt;/span&gt; +&lt;br/&gt;                      &lt;span&gt;&#x27;minutes: &#x27;&lt;/span&gt; + t.minutes + &lt;span&gt;&#x27;&amp;lt;br&amp;gt;&#x27;&lt;/span&gt; +&lt;br/&gt;                      &lt;span&gt;&#x27;seconds: &#x27;&lt;/span&gt; + t.seconds;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (t.total &amp;lt;= &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;      clearInterval(timeinterval);&lt;br/&gt;    }&lt;br/&gt;  },&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;该函数有两个参数，这两个参数是包含时钟的元素的id，以及倒计时的结束时间。在函数内部，我们将声明一个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;clock&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 变量，并使用它来保存对时钟容器div的引用。这意味着我们不必一直查询DOM。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接下来，我们将使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;setInterval&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 每秒执行一个匿名函数。此功能将执行以下操作：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;计算剩余时间。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将剩余时间输出到我们的div。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果剩余时间为零停止计时。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;此时，剩下的唯一步骤是像这样运行时钟：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;initializeClock(&lt;span&gt;&#x27;clockdiv&#x27;&lt;/span&gt;, deadline);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;恭喜你！现在，你仅用18行JavaScript就拥有了一个基本时钟。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;7.准备展示你的时钟&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在设置时钟样式之前，我们需要进行一些改进。&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;消除初始延迟，使你的时钟立即显示。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;让时钟脚本更有效率，这样它就不会连续重建整个时钟。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;根据需要添加前导零。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;7.1 消除初始延迟&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在时钟中，我们使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;setInterval&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 每秒更新一次显示。多数情况下，这很好，除非在开始时会有一秒钟的延迟。要消除此延迟，我们必须在间隔开始之前更新一次时钟。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;让我们将传递给 &lt;/span&gt;&lt;code&gt;&lt;span&gt;setInterval&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的匿名函数移到其自己的单独函数中，我们可以将此函数命名为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;updateClock&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;setInterval&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 外调用一次 &lt;/span&gt;&lt;code&gt;&lt;span&gt;updateClock&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 函数，然后在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;setInterval&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 内再次调用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在你的JavaScript中，替换这个&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; timeinterval = setInterval(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; { ... },&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;新代码&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;updateClock&lt;/span&gt;()&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; t = getTimeRemaining(endtime);&lt;br/&gt;  clock.innerHTML = &lt;span&gt;&#x27;days: &#x27;&lt;/span&gt; + t.days + &lt;span&gt;&#x27;&amp;lt;br&amp;gt;&#x27;&lt;/span&gt; +&lt;br/&gt;                    &lt;span&gt;&#x27;hours: &#x27;&lt;/span&gt;+ t.hours + &lt;span&gt;&#x27;&amp;lt;br&amp;gt;&#x27;&lt;/span&gt; +&lt;br/&gt;                    &lt;span&gt;&#x27;minutes: &#x27;&lt;/span&gt; + t.minutes + &lt;span&gt;&#x27;&amp;lt;br&amp;gt;&#x27;&lt;/span&gt; +&lt;br/&gt;                    &lt;span&gt;&#x27;seconds: &#x27;&lt;/span&gt; + t.seconds;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (t.total &amp;lt;= &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;    clearInterval(timeinterval);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;updateClock(); &lt;span&gt;// 首先运行一函数能以避免延迟&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; timeinterval = setInterval(updateClock,&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;7.2 避免不断重建时钟&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们需要使时钟脚本更高效，我们只想更新时钟中的数字，而不是每秒重建整个时钟。实现此目的的一种方法是将每个数字放在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;span&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 标签内，并仅更新这些 &lt;/span&gt;&lt;code&gt;&lt;span&gt;span&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的内容。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这是HTML：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;clockdiv&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    Days: &lt;span&gt;&amp;lt;&lt;span&gt;span&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;days&quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span&gt;span&lt;/span&gt;&amp;gt;&amp;lt;&lt;span&gt;br&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    Hours: &lt;span&gt;&amp;lt;&lt;span&gt;span&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;hours&quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span&gt;span&lt;/span&gt;&amp;gt;&amp;lt;&lt;span&gt;br&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    Minutes: &lt;span&gt;&amp;lt;&lt;span&gt;span&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;minutes&quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span&gt;span&lt;/span&gt;&amp;gt;&amp;lt;&lt;span&gt;br&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    Seconds: &lt;span&gt;&amp;lt;&lt;span&gt;span&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;seconds&quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span&gt;span&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在让我们参考这些元素。在定义 &lt;/span&gt;&lt;code&gt;&lt;span&gt;clock&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 变量的位置之后添加以下代码&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; daysSpan = clock.querySelector(&lt;span&gt;&#x27;.days&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; hoursSpan = clock.querySelector(&lt;span&gt;&#x27;.hours&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; minutesSpan = clock.querySelector(&lt;span&gt;&#x27;.minutes&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; secondsSpan = clock.querySelector(&lt;span&gt;&#x27;.seconds&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接下来，我们需要修改 &lt;/span&gt;&lt;code&gt;&lt;span&gt;updateClock&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 函数，使其只更新数字。新的代码是这样的：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;updateClock&lt;/span&gt;()&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; t = getTimeRemaining(endtime);&lt;br/&gt;&lt;br/&gt;    daysSpan.innerHTML = t.days;&lt;br/&gt;    hoursSpan.innerHTML = t.hours;&lt;br/&gt;    minutesSpan.innerHTML = t.minutes;&lt;br/&gt;    secondsSpan.innerHTML = t.seconds;&lt;br/&gt;&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;7.3 添加前导0&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在时钟不再每秒都在重建，我们还有另一件事要做：添加前导零。例如，不是让时钟显示7秒，而是显示07秒。一种简单的方法是在一个数的开头加上一串“0”，然后切掉最后两个数字。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;例如，要在“seconds”值上添加前导零，你可以更改以下设置：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;secondsSpan.innerHTML = t.seconds;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;secondsSpan.innerHTML = (&lt;span&gt;&#x27;0&#x27;&lt;/span&gt; + t.seconds).slice(&lt;span&gt;-2&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果你愿意，你也可以在分钟和小时的前面加零。如果你已经走到这一步，恭喜你！你的时钟现在已经可以显示了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;mpcpc js_editor_cpcad=&quot;&quot; class=&quot;js_cpc_area cpc_iframe&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/cpc_tmpl#1600180422775&quot; data-category_id_list=&quot;1|11|16|17|22|24|26|27|28|29|3|31|32|35|36|37|39|41|42|43|45|46|47|48|49|5|50|51|52|53|54|55|6|7|8&quot; data-id=&quot;1600180422775&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;8.更进一步&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以下示例演示了如何为某些用例扩展时钟。它们都是基于上面的基本例子。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;8.1 自动调节时钟&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;假设我们想让时钟在特定的日子出现，而不是在其他的日子。例如，我们可能有一系列事件即将发生，而不希望每次都手动更新时钟。以下是如何提前安排事情的方法。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;通过在CSS中将其 &lt;/span&gt;&lt;code&gt;&lt;span&gt;display&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 属性设置为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;none&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 来隐藏时钟，然后将以下内容添加到 &lt;/span&gt;&lt;code&gt;&lt;span&gt;initializeClock&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 函数中（以 &lt;/span&gt;&lt;code&gt;&lt;span&gt;var clock&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 开头的行之后）。这将导致只有在调用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;initializeClock&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 函数后才会显示时钟：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;clock.style.display = &lt;span&gt;&#x27;block&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接下来，我们可以指定显示时钟的日期。这将替换截止日期变量（ &lt;/span&gt;&lt;code&gt;&lt;span&gt;deadline&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ）：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; schedule = [&lt;br/&gt;    [&lt;span&gt;&#x27;Jul 25 2015&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;Sept 20 2015&#x27;&lt;/span&gt;],&lt;br/&gt;    [&lt;span&gt;&#x27;Sept 21 2015&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;Jul 25 2016&#x27;&lt;/span&gt;],&lt;br/&gt;    [&lt;span&gt;&#x27;Jul 25 2016&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;Jul 25 2030&#x27;&lt;/span&gt;]&lt;br/&gt;];&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Schedule&lt;/code&gt;&lt;span&gt;数组中的每个元素代表一个开始日期和一个结束日期。如上所述，它可以包含时间和时区，但我在这里使用了普通的日期，以保持代码的可读性。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最后，当用户加载页面时，我们需要检查是否在指定的时间范围内。此代码应替换先前对 &lt;/span&gt;&lt;code&gt;&lt;span&gt;initializeClock&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 函数的调用：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 遍历schedule中的每个元素&lt;/span&gt;&lt;br/&gt;schedule.forEach(&lt;span&gt;(&lt;span&gt;[startDate, endDate]&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// 以毫秒为单位放置日期以便于比较&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; startMs = &lt;span&gt;Date&lt;/span&gt;.parse(startDate);&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; endMs = &lt;span&gt;Date&lt;/span&gt;.parse(endDate);&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; currentMs = &lt;span&gt;Date&lt;/span&gt;.parse(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;());&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 如果当前日期在开始日期和结束日期之间，则显示时钟&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (endMs &amp;gt; currentMs &amp;amp;&amp;amp; currentMs &amp;gt;= startMs ) {&lt;br/&gt;    initializeClock(&lt;span&gt;&#x27;clockdiv&#x27;&lt;/span&gt;, endDate);&lt;br/&gt;  }&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在，你可以提前安排你的时钟，而不必手动更新它。如果你愿意，你可以缩短代码。为了便于阅读，我把我的代码写得很啰嗦。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;8.2 从用户到达起将计时器设置为10分钟&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;用户到达或开始特定任务后，有必要在给定的时间内设置倒计时。我们将在此处将计时器设置为10分钟，但是你可以使用任意时间。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们需要做的就是用以下命令替换 &lt;/span&gt;&lt;code&gt;&lt;span&gt;deadline&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 变量：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; timeInMinutes = &lt;span&gt;10&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; currentTime = &lt;span&gt;Date&lt;/span&gt;.parse(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;());&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; deadline = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;(currentTime + timeInMinutes*&lt;span&gt;60&lt;/span&gt;*&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这段代码以当前时间为基准，增加10分钟。这些值将转换为毫秒，因此可以将它们加在一起并变成新的截止日期。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在我们有一个时钟，从用户到达时开始倒计时十分钟，你可以自由发挥，尝试不同的时间长度。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;8.3 跨页面保持时钟进度&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;有时，除了当前页面外，还需要保留时钟状态。如果我们想在整个网站上设置10分钟的计时器，则我们不希望在用户转到其他页面时重置该计时器。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一个解决方案是将时钟的结束时间保存在一个cookie中。这样一来，导航到一个新的页面就不会把结束时间重置到十分钟以后。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这是逻辑：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果Cookie中记录了截止日期，使用该截止日期。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果不存在Cookie，请设置一个新的截止日期并将其存储在Cookie中。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;要实现这一点，请使用以下命令替换 &lt;/span&gt;&lt;code&gt;&lt;span&gt;deadline&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 变量：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; deadline;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 如果有一个名为myClock的cookie，则使用该值作为截止日期&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;document&lt;/span&gt;.cookie &amp;amp;&amp;amp; &lt;span&gt;document&lt;/span&gt;.cookie.match(&lt;span&gt;&#x27;myClock&#x27;&lt;/span&gt;)){&lt;br/&gt;  &lt;span&gt;// 从Cookie获取截止日期值&lt;/span&gt;&lt;br/&gt;  deadline = &lt;span&gt;document&lt;/span&gt;.cookie.match(&lt;span&gt;/(^|;)myClock=([^;]+)/&lt;/span&gt;)[&lt;span&gt;2&lt;/span&gt;];&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// 否则，请设置从现在开始10分钟的截止日期，&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 将其保存在具有该名称的cookie中&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 创建从现在开始10分钟的截止日期&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; timeInMinutes = &lt;span&gt;10&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; currentTime = &lt;span&gt;Date&lt;/span&gt;.parse(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;());&lt;br/&gt;  deadline = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;(currentTime + timeInMinutes*&lt;span&gt;60&lt;/span&gt;*&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 将截止日期存储在cookie中以供将来引用&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;document&lt;/span&gt;.cookie = &lt;span&gt;&#x27;myClock=&#x27;&lt;/span&gt; + deadline + &lt;span&gt;&#x27;; path=/; domain=.yourdomain.com&#x27;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;需要注意的是，你需要将 &lt;/span&gt;&lt;code&gt;&lt;span&gt;.yourdomain.com&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 改为你的实际域名。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;9.有关客户端时间的重要警告&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;JavaScript日期和时间是从用户的计算机上获取的，这意味着用户可以通过更改计算机上的时间来影响JavaScript时钟。在大多数情况下，这并不重要，但在一些超级敏感的情况下，就需要从服务器上获取时间。可以使用一些Node.js或Ajax来完成，这两者都超出了本教程的范围。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从服务器获取时间后，我们可以使用本教程中的相同技术来使用它。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;10.总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在完成本文中的示例之后，你现在知道了如何使用几行简单的JavaScript代码创建自己的倒计时计时器！我们已经了解了如何制作一个基本的倒计时时钟并有效地显示它。我们还介绍了添加一些有用的附加功能，包括日程安排、绝对时间与相对时间，以及在页面和网站访问之间用cookie保存状态。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下一步是什么？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;试着添加一些创意风格，或者新的功能（比如暂停和恢复按钮）。之后，如果你想出了任何很酷的时钟例子，你想分享，让我们在评论区见。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;11.代码&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本示例代码和演示地址：https://coding.zhangbing.site/view.html?url=./list/down-click.html&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5199374511336982&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0ANAsyE4nMbsnrRoddRZl3Ulz4YSjStP8ld5zicpEzrVUTPZFM8TsUrv018LNU7mnIAGrBmVomqtj9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2558&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;section&gt;&lt;mpcps frameborder=&quot;0&quot; class=&quot;js_editor_cps&quot; data-datakey=&quot;1600178414761_0.7220740555156842&quot; data-uid=&quot;1600178414759&quot; data-type=&quot;1&quot; data-product=&quot;&quot; data-templateid=&quot;list&quot; data-pid=&quot;29120617&quot; data-packid=&quot;&quot; data-smartnum=&quot;&quot; data-categoryid=&quot;3&quot; data-appid=&quot;wx831660fe3ded4389&quot; data-report=&quot;s0%3D0%26s1%3D0%26s2%3D0%26s3%3DJavaScript%25E9%25AB%2598%25E7%25BA%25A7%25E7%25A8%258B%25E5%25BA%258F%25E8%25AE%25BE%25E8%25AE%25A1%26s4%3D0%26s5%3D10%26s6%3Did_1600179496139_855052%26s7%3D%26s8%3D%26s9%3D%26s10%3D%26pid%3Dwx831660fe3ded4389_29120617%26uuid%3D3240205452442390687%26title%3DJavaScript%25E9%25AB%2598%25E7%25BA%25A7%25E7%25A8%258B%25E5%25BA%258F%25E8%25AE%25BE%25E8%25AE%25A1%2B%25E7%25AC%25AC4%25E7%2589%2588%26sid%3D3%26cid%3D3%26ratio%3D17.00%2525%26price%3D96.80%26&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;mpcps frameborder=&quot;0&quot; class=&quot;js_editor_cps&quot; data-datakey=&quot;1600178414762_0.4332142757043733&quot; data-uid=&quot;1600178414760&quot; data-type=&quot;1&quot; data-product=&quot;&quot; data-templateid=&quot;list&quot; data-pid=&quot;12883028&quot; data-packid=&quot;&quot; data-smartnum=&quot;&quot; data-categoryid=&quot;3&quot; data-appid=&quot;wxbdbc4659744ed70d&quot; data-report=&quot;s0%3D0%26s1%3D0%26s2%3D0%26s3%3DJavaScript%25E8%25AF%25AD%25E8%25A8%2580%25E7%25B2%25BE%25E9%25AB%2593%26s4%3D0%26s5%3D10%26s6%3Did_1600179516463_23250%26s7%3D%26s8%3D%26s9%3D%26s10%3D%26pid%3Dwxbdbc4659744ed70d_12883028%26uuid%3D32402054522077153266%26title%3DJavaScript%25E8%25AF%25AD%25E8%25A8%2580%25E7%25B2%25BE%25E9%25AB%2593%25E4%25B8%258E%25E7%25BC%2596%25E7%25A8%258B%25E5%25AE%259E%25E8%25B7%25B5%25EF%25BC%2588%25E7%25AC%25AC3%25E7%2589%2588%25EF%25BC%2589(%25E5%258D%259A%25E6%2596%2587%25E8%25A7%2586%25E7%2582%25B9%25E5%2587%25BA%25E5%2593%2581)%26sid%3D1%26cid%3D3%26ratio%3D18.00%2525%26price%3D136.80%26&quot;/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;福利时间&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，我又来给大家送福利了，这么好的书不送几本给大家怎么行呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;福利送给「阅读、点赞、在看、评论」我的文章的读者们，你们的支持也是我持续输出最大的动力，&lt;span&gt;感恩&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本次抽奖有三个参与方式&lt;span&gt;「留言、在看&lt;span&gt;、现金&lt;/span&gt;红包抽奖」&lt;/span&gt;，当然都参与中奖概率更高哈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;为了避免中奖后失联，提前加我微信哈。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0ANpQDTG8tzUI7XTrYCicQaUYCZvxu69zuIYjJ5YB2icua8zRG0MPL9IFU09iboV7XOKwTicrr3ghkYeZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;430&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>