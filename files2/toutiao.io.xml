<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>3d118c2e31438a47014e34138dfd3c44</guid>
<title>精通那么多技术，你为何还是受不到重用？| 码农周刊第 324 期</title>
<link>https://toutiao.io/k/3ininot</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;issue&quot; id=&quot;readabilityBody&quot;&gt;
        &lt;h1&gt;精通那么多技术，你为何还是受不到重用？| 码农周刊第 324 期&lt;/h1&gt;
        &lt;h2&gt;码农周刊第324期（2020-11-11）&lt;/h2&gt;
        &lt;p&gt;☞ &lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3240&quot; target=&quot;_blank&quot;&gt;双十一，买它买它买它！&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3240&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_324.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;small&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=19185&amp;amp;url=https%3A%2F%2Fjinshuju.net%2Ff%2FV7DxN9&quot; target=&quot;_blank&quot;&gt;商务合作&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
        
        &lt;h3 id=&quot;程序设计&quot;&gt;程序设计&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;基于 Kubernetes 的云原生批量计算平台&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;VIP会员专区&quot;&gt;VIP会员专区&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;工作地点：成都 | 薪资：15-30K | 简历投递邮箱：xiexiaofang@huobi.com&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;对以 Transformer 为基础的序列特征提取器 (Encoder) 和自回归的序列解码器 (Decoder) 做了深度优化&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;技术雷达是 ThoughtWorks 每半年发布一次的技术趋势报告&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;这是德勤第 11 年发布技术趋势年度报告&lt;/p&gt;
        &lt;h3 id=&quot;工具资料&quot;&gt;工具资料&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;个人经历&lt;/p&gt;
        
        &lt;p&gt;你知道吗？&lt;/p&gt;
        
        &lt;p&gt;试试吧&lt;/p&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;经验总结&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;欢迎探讨&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;图文并茂&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;欢迎探讨&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;适合入门&lt;/p&gt;
        
        &lt;p&gt;结合代码&lt;/p&gt;
        
        &lt;p&gt;深入探讨&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程语言&quot;&gt;编程语言&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;基于 Swift 推出的函数响应框架&lt;/p&gt;
        
        &lt;p&gt;使用 JavaScript 来自动化 iOS&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;实践总结&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;细致讲解&lt;/p&gt;
        
        &lt;p&gt;代码示例&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;试试吧&lt;/p&gt;
        &lt;h3 id=&quot;每周独家号推荐&quot;&gt;每周独家号推荐&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;7年工作经验，技术总监&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 451915 即可&lt;/p&gt;
        
        &lt;p&gt;坚持原创，持续分享技术，包括但不限于：分布式、微服务架构，spring cloud、Dubbo微服务框架，Java核心技术，Redis缓存、Kafka消息队列中间件等。&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 450130 即可&lt;/p&gt;
        
        &lt;p&gt;一个工作10年的程序猿，分享技术干货及内心的声音。&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 413084 即可&lt;/p&gt;
        
        &lt;p&gt;详解数据结构与算法&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 142771 即可&lt;/p&gt;
        
        &lt;p&gt;Web前端、服务端、小程序、App、学习资料、工具、资讯&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 125297 即可&lt;/p&gt;
        &lt;h3 id=&quot;每周一书&quot;&gt;每周一书&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=20115&amp;amp;url=http%3A%2F%2Fproduct.dangdang.com%2F29132383.html&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/book_324.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程之外&quot;&gt;编程之外&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;一个技术总监的忠告&lt;/p&gt;
        
        &lt;p&gt;写作不易&lt;/p&gt;
        
        &lt;p&gt;同理心&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;p&gt;
        &lt;/p&gt;
        
        
        
        
        &lt;div class=&quot;qrcode&quot;&gt;
  &lt;img src=&quot;https://img.toutiao.io/ads/vip_qrcode.png&quot; alt=&quot;Qrcode 258&quot;/&gt;&lt;span&gt;加入码农周刊VIP会员&lt;/span&gt;
&lt;/div&gt;
    &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cb21a54e3d1e2c47c9ff0efe661df0c8</guid>
<title>MySQL 的 join 功能弱爆了？</title>
<link>https://toutiao.io/k/031qbdy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;点击上方&quot;&lt;span&gt;程序员历小冰&lt;/span&gt;&quot;，选择“置顶或者星标”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;   你的关注意义重大!&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n868&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;大家好，我是历小冰，今天我们来学习和吐槽一下 MySQL 的 Join 功能。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n870&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;关于MySQL 的 join，大家一定了解过很多它的“轶事趣闻”，比如两表 join 要小表驱动大表，阿里开发者规范禁止三张表以上的 join 操作，MySQL 的 join 功能弱爆了等等。这些规范或者言论亦真亦假，时对时错，需要大家自己对 join 有深入的了解后才能清楚地理解。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n871&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;下面，我们就来全面的了解一下 MySQL 的 join 操作。&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n873&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;正文&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n875&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;在日常数据库查询时，我们经常要对多表进行连表操作来一次性获得多个表合并后的数据，这是就要使用到数据库的 join 语法。join 是在数据领域中十分常见的将两个数据集进行合并的操作，如果大家了解的多的话，会发现 MySQL，Oracle，PostgreSQL 和 Spark 都支持该操作。本篇文章的主角是 MySQL，下文没有特别说明的话，就是以 MySQL 的 join 为主语。而 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;Oracle ，PostgreSQL 和 Spark 则可以算做将其吊打的大boss，其对 join 的算法优化和实现方式都要优于 MySQL。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n876&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n877&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;MySQL 的 join 有诸多规则，可能稍有不慎，可能一个不好的 join 语句不仅会导致对某一张表的全表查询，还有&lt;/span&gt;&lt;span&gt;&lt;strong&gt;可能会影响数据库的缓存，导致大部分热点数据都被替换出去，拖累整个数据库性能。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n878&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n879&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;所以，业界针对 MySQL 的 join 总结了很多规范或者原则，比如说小表驱动大表和禁止三张表以上的 join 操作。下面我们会依次介绍 MySQL join 的算法，和 Oracle 和 Spark 的 join 实现对比，并在其中穿插解答为什么会形成上述的规范或者原则。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n880&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n881&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;对于 join 操作的实现，大概有 Nested Loop Join (循环嵌套连接)，Hash Join(散列连接) 和 Sort Merge Join(排序归并连接) 三种较为常见的算法&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;strong&quot;&gt;，它们各有优缺点和适用条件，接下来我们会依次来介绍。&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n886&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;MySQL 中的 Nested Loop Join 实现&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n887&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Nested Loop Join 是扫描驱动表，每读出一条记录，就根据 join 的关联字段上的索引去被驱动表中查询对应数据。它适用于被连接的数据子集较小的场景，它也是 MySQL join 的唯一算法实现，关于它的细节我们接下来会详细讲解。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n888&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;MySQL 中有两个 Nested Loop Join 算法的变种，分别是 Index Nested-Loop Join 和 Block Nested-Loop Join。&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n889&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;Index Nested-Loop Join 算法&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n890&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;下面，我们先来初始化一下相关的表结构和数据&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;&quot; cid=&quot;n892&quot; mdtype=&quot;fences&quot;&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;CREATE TABLE `t1` (&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;  `id` int(11) NOT NULL,&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;  `a` int(11) DEFAULT NULL,&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;  `b` int(11) DEFAULT NULL,&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;  PRIMARY KEY (`id`),&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;  KEY `a` (`a`)&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;) ENGINE=InnoDB;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;delimiter ;;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;# 定义存储过程来初始化t1&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;create procedure init_data()&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;begin&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;  declare i int;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;  set i=1;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;  while(i&amp;lt;=10000)do&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    insert into t1 values(i, i, i);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    set i=i+1;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;  end while;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;end;;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;delimiter ;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;# 调用存储过来来初始化t1&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;call init_data();&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;# 创建并初始化t2&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;create table t2 like t1;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;insert into t2 (select * from t1 where id&amp;lt;=500)&lt;/span&gt;&lt;/pre&gt;&lt;p cid=&quot;n893&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;有上述命令可知，这两个表都有一个主键索引 id 和一个索引 a，字段 b 上无索引。存储过程 init_data 往表 t1 里插入了 10000 行数据，在表 t2 里插入的是 500 行数据。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1079&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n894&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;为了避免 MySQL 优化器会自行选择表作为驱动表，影响分析 SQL 语句的执行过程，我们直接使用 straight_join 来让 MySQL 使用固定的连接表顺序进行查询，如下语句中，t1是驱动表，t2是被驱动表。&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;&quot; cid=&quot;n895&quot; mdtype=&quot;fences&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;select * from t2 straight_join t1 on (t2.a=t1.a);&lt;/span&gt;&lt;/pre&gt;&lt;p cid=&quot;n896&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;使用我们之前&lt;a spellcheck=&quot;false&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2NjE5NDQyOA==&amp;amp;mid=2247484242&amp;amp;idx=1&amp;amp;sn=119c2972357d57b6575fb790f8a25a4d&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;文章&lt;/span&gt;&lt;/a&gt;介绍的 explain 命令查看一下该语句的执行计划。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.30078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtcPKcRIjNYP0dkic8Yu9crGNMUcEv1V6eIjpqaW4icDC63FvAiabuGyzgO8337XeTs3Sa65QuGK9uzHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n898&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;从上图可以看到，t1 表上的 a 字段是由索引的，join 过程中使用了该索引，因此该 SQL 语句的执行流程如下：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n908&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;这个流程我们就称之为 Index Nested-Loop Join，简称 NLJ，它对应的流程图如下所示。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n909&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://cdn.remcarpediem.net/2020-11-10-145533.png&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtcPKcRIjNYP0dkic8Yu9crGNb59c86YWzMkWQVz1TlE7MJnolPNGicibyRKuf1bT1yWKZFlmtVMxSgOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6940418679549114&quot; data-w=&quot;621&quot;/&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; &lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n910&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;需要注意的是，在第二步中，根据 a 字段去表t1中查询时，使用了索引，所以每次扫描只会扫描一行(从explain结果得出，根据不同的案例场景而变化)。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n911&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n912&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;假设驱动表的行数是N，被驱动表的行数是 M。因为在这个 join 语句执行过程中，驱动表是走全表扫描，而被驱动表则使用了索引，并且驱动表中的每一行数据都要去被驱动表中进行索引查询，所以整个 join 过程的近似复杂度是 N&lt;em&gt;2&lt;/em&gt;log2M。显然，N 对扫描行数的影响更大，因此这种情况下应该让小表来做驱动表。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n913&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n914&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;当然，这一切的前提是 join 的关联字段是 a，并且 t1 表的 a 字段上有索引。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n915&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;如果没有索引时，再用上图的执行流程时，每次到 t1 去匹配的时候，就要做一次全表扫描。这也导致整个过程的时间复杂度编程了 N * M，这是不可接受的。所以，当没有索引时，MySQL 使用 Block Nested-Loop Join 算法。&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n917&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;Block Nested-Loop Join&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n919&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Block Nested-Loop Join的算法，简称 BNL，它是 MySQL 在被驱动表上无可用索引时使用的 join 算法，其具体流程如下所示：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n926&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;比如下面这条 SQL&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;&quot; cid=&quot;n927&quot; mdtype=&quot;fences&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;select * from t2 straight_join t1 on (t2.b=t1.b);&lt;/span&gt;&lt;/pre&gt;&lt;p cid=&quot;n928&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;这条语句的 explain 结果如下所示。可以看出&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.30078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtcPKcRIjNYP0dkic8Yu9crGNMlI7EH23UYB3ACyuR4UOmHfvfMkC9cmxf59qlR238Hp6L9Ql9mmzAw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n929&quot; mdtype=&quot;paragraph&quot;&gt;可以看出，这次 join 过程对 t1 和 t2 都做了一次全表扫描，并且将表 t2 中的 500 条数据全部放入内存 join_buffer 中，并且对于表 t1 中的每一行数据，都要去 join_buffer 中遍历一遍，都要做 500 次对比，所以一共要进行 500 * 10000 次内存对比操作，具体流程如下图所示。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.8668885191347754&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtcPKcRIjNYP0dkic8Yu9crGNe5TjXlIrqNqubPg6jU2rbKuIUZUibf3LHgH77JFbmzMATlJQAia6x7TA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;601&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n933&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;主要注意的是，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;第一步中，并不是将表 t2 中的所有数据都放入 join_buffer，而是根据具体的 SQL 语句，而放入不同行的数据和不同的字段&lt;/span&gt;&lt;/strong&gt;。&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;比如下面这条 join 语句则只会将表 t2 中符合 b &amp;gt;= 100 的数据的 b 字段存入 join_buffer。&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;&quot; cid=&quot;n934&quot; mdtype=&quot;fences&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;select t2.b,t1.b from t2 straight_join t1 on (t2.b=t1.b) where t2.b &amp;gt;= 100;&lt;/span&gt;&lt;/pre&gt;&lt;p cid=&quot;n935&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;join_buffer 并不是无限大的，由 join_buffer_size 控制，默认值为 256K。当要存入的数据过大时，就只有分段存储了，整个执行过程就变成了：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n936&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n938&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;扫描表 t2，将符合条件的数据行存入 join_buffer，因为其大小有限，存到100行时满了，则执行第二步；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n940&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;扫描表 t1，每取出一行数据，就跟 join_buffer 中的数据进行对比，满足 join 条件的，则放入结果集；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n942&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;清空 join_buffer；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n944&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;再次执行第一步，直到全部数据被扫描完，由于 t2 表中有 500行数据，所以一共重复了 5次&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n945&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;这个流程体现了该算法名称中 Block 的由来，分块去执行 join 操作。因为表 t2 的数据被分成了 5 次存入 join_buffer，导致表 t1 要被全表扫描 5次。&lt;/span&gt;&lt;/p&gt;&lt;figure cid=&quot;n946&quot; mdtype=&quot;table&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr cid=&quot;n947&quot; mdtype=&quot;table_row&quot;&gt;&lt;th&gt;&lt;br/&gt;&lt;/th&gt;&lt;th&gt;&lt;span cid=&quot;n949&quot; mdtype=&quot;table_cell&quot;&gt;全部存入&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span cid=&quot;n950&quot; mdtype=&quot;table_cell&quot;&gt;分5次存入&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr cid=&quot;n951&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n952&quot; mdtype=&quot;table_cell&quot;&gt;内存操作&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n953&quot; mdtype=&quot;table_cell&quot;&gt;10000 * 500&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n954&quot; mdtype=&quot;table_cell&quot;&gt;10000 * (100 * 5)&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n955&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n956&quot; mdtype=&quot;table_cell&quot;&gt;扫描行数&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n957&quot; mdtype=&quot;table_cell&quot;&gt;10000 + 500&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n958&quot; mdtype=&quot;table_cell&quot;&gt;10000 *  5 + 500&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p cid=&quot;n963&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;如上所示，和表数据可以全部存入 join_buffer 相比，内存判断的次数没有变化，都是两张表行数的乘积，也就是 10000 * 500，但是被驱动表会被多次扫描，每多存入一次，被驱动表就要扫描一遍，影响了最终的执行效率。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n964&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n965&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;基于上述两种算法，我们可以得出下面的结论，这也是网上大多数对 MySQL join 语句的规范。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n971&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n972&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;因为上述两个 join 算法的时间复杂度&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;至少&lt;/span&gt;&lt;/strong&gt;也和涉及表的行数成一阶关系，并且要花费大量的内存空间，所以阿里开发者规范所说的严格禁止三张表以上的 join 操作也是可以理解的了。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n973&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;但是上述这两个算法只是 join 的算法之一，还有&lt;/span&gt;&lt;span&gt;&lt;strong&gt;更加高效的 join 算法，比如 Hash Join 和 Sorted Merged join。可惜这两个算法 MySQL 的主流版本中目前都不提供，而 Oracle ，PostgreSQL 和 Spark 则都支持，这也是网上吐槽 MySQL 弱爆了的原因&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;(MySQL 8.0 版本支持了 Hash join，但是8.0目前还不是主流版本)。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n974&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n1147&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;其实阿里开发者规范也是在从 Oracle 迁移到 MySQL 时，因为 MySQL 的 join 操作性能太差而定下的禁止三张表以上的 join 操作规定的 。&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n975&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;Hash Join 算法&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n976&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Hash Join 是扫描驱动表，利用 join 的关联字段在内存中建立散列表，然后扫描被驱动表，每读出一行数据，并从散列表中找到与之对应数据。它是大数据集连接操时的常用方式，适用于驱动表的数据量较小，可以放入内存的场景，它对于&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;没有索引的大表&lt;/span&gt;&lt;/strong&gt;和并行查询的场景下能够提供最好的性能。可惜它只适用于等值连接的场景，比如 on a.id = where b.a_id。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1083&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;还是上述两张表 join 的语句，其执行过程如下&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.8668885191347754&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtcPKcRIjNYP0dkic8Yu9crGNicswJwpEaHDncHQsERVxIrXFHb6CQtkY6IDIudygG9oAWy5ibRoZU4sg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;601&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n977&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;可以看出，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;该算法和 Block Nested-Loop Join 有类似之处，只不过是将无序的 Join Buffer 改为了散列表 hash table，从而让数据匹配不再需要将 join buffer 中的数据全部遍历一遍，而是直接通过 hash，以接近 O(1) 的时间复杂度获得匹配的行&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;，这极大地提高了两张表的 join 速度。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1103&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;不过由于 hash 的特性，该算法只能适用于等值连接的场景，其他的连接场景均无法使用该算法。&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n978&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;Sorted Merge Join 算法&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n979&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Sort Merge Join 则是先根据 join 的关联字段将两张表排序(如果已经排序好了，比如字段上有索引则不需要再排序)，然后在对两张表进行一次归并操作。如果两表已经被排过序，在执行排序合并连接时不需要再排序了，这时Merge Join的性能会优于Hash Join。Merge Join可适于于非等值Join（&amp;gt;，&amp;lt;，&amp;gt;=，&amp;lt;=，但是不包含!=，也即&amp;lt;&amp;gt;）。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1107&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;需要注意的是，如果连接的字段已经有索引，也就说已经排好序的话，可以直接进行归并操作，但是如果连接的字段没有索引的话，则它的执行过程如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5522388059701493&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtcPKcRIjNYP0dkic8Yu9crGNuUTmPgYY5IRfnuNEBesMVktGMzHwHvNEjJm35FB3K41zlF1LGqgdtA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;871&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n1119&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Sorted Merge Join 算法的主要时间消耗在于对两个表的排序操作，所以如果两个表已经按照连接字段排序过了，该算法甚至比 Hash Join 算法还要快。在一边情况下，该算法是比 Nested Loop Join 算法要快的。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1131&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n980&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;下面，我们来总结一下上述三种算法的区别和优缺点。&lt;/span&gt;&lt;/p&gt;&lt;figure cid=&quot;n982&quot; mdtype=&quot;table&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr cid=&quot;n983&quot; mdtype=&quot;table_row&quot;&gt;&lt;th&gt;&lt;br/&gt;&lt;/th&gt;&lt;th&gt;&lt;span cid=&quot;n985&quot; mdtype=&quot;table_cell&quot;&gt;Nested Loop Join&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span cid=&quot;n986&quot; mdtype=&quot;table_cell&quot;&gt;Hash Join&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span cid=&quot;n987&quot; mdtype=&quot;table_cell&quot;&gt;Sorted Merge Join&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr cid=&quot;n988&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n989&quot; mdtype=&quot;table_cell&quot;&gt;连接条件&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n990&quot; mdtype=&quot;table_cell&quot;&gt;适用于任何条件&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n991&quot; mdtype=&quot;table_cell&quot;&gt;只适用于等值连接（=）&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n992&quot; mdtype=&quot;table_cell&quot;&gt;等值或非等值连接(&amp;gt;，&amp;lt;，=，&amp;gt;=，&amp;lt;=)，‘&amp;lt;&amp;gt;’除外&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n993&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n994&quot; mdtype=&quot;table_cell&quot;&gt;主要消耗资源&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n995&quot; mdtype=&quot;table_cell&quot;&gt;CPU、磁盘I/O&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n996&quot; mdtype=&quot;table_cell&quot;&gt;内存、临时空间&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n997&quot; mdtype=&quot;table_cell&quot;&gt;内存、临时空间&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n998&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n999&quot; mdtype=&quot;table_cell&quot;&gt;特点&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1000&quot; mdtype=&quot;table_cell&quot;&gt;当有高选择性索引或进行限制性搜索时效率比较高，能够快速返回第一次的搜索结果&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1001&quot; mdtype=&quot;table_cell&quot;&gt;当缺乏索引或者索引条件模糊时，Hash Join 比 Nested Loop 有效。通常比 Merge Join 快。在数据仓库环境下，如果表的纪录数多，效率高&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1002&quot; mdtype=&quot;table_cell&quot;&gt;当缺乏索引或者索引条件模糊时，Sort Merge Join 比 Nested Loop 有效。当连接字段有索引或者提前排好序时，比 hash join 快，并且支持更多的连接条件&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n1003&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1004&quot; mdtype=&quot;table_cell&quot;&gt;缺点&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1005&quot; mdtype=&quot;table_cell&quot;&gt;无索引或者表记录多时效率低&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1006&quot; mdtype=&quot;table_cell&quot;&gt;建立哈希表需要大量内存，第一次的结果返回较慢&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1007&quot; mdtype=&quot;table_cell&quot;&gt;所有的表都需要排序。它为最优化的吞吐量而设计，并且在结果没有全部找到前不返回数据&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n1008&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1009&quot; mdtype=&quot;table_cell&quot;&gt;需要索引&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1010&quot; mdtype=&quot;table_cell&quot;&gt;是(没有索引效率太差)&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1011&quot; mdtype=&quot;table_cell&quot;&gt;否&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1012&quot; mdtype=&quot;table_cell&quot;&gt;否&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h4 cid=&quot;n1020&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;对于 Join 操作的理解&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n1022&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;讲完了 Join 相关的算法，我们这里也聊一聊对于 join 操作的业务理解。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1023&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;在业务不复杂的情况下，大多数join并不是无可替代。比如订单记录里一般只有订单用户的 user_id，返回信息时需要取得用户姓名，可能的实现方案有如下几种：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; cid=&quot;n1024&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n1026&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;一次数据库操作，使用  join 操作，订单表和用户表进行 join，连同用户名一起返回；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1028&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;两次数据库操作，分两次查询，第一次获得订单信息和 user_id，第二次根据 user_id 取姓名，使用代码程序进行信息合并；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1030&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;使用冗余用户名称或者从 ES 等非关系数据库中读取。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p cid=&quot;n1036&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;上述方案都能解决数据聚合的问题，而且基于程序代码来处理，比数据库 join 更容易调试和优化，比如取用户姓名不从数据库中取，而是先从缓存中查找。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1043&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n1045&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;当然， join 操作也不是一无是处，所以技术都有其使用场景，&lt;/span&gt;&lt;span&gt;上边这些方案或者规则都是互联网开发团队总结出来的，适用于高并发、轻写重读、分布式、业务逻辑简单的情况，这些场景一般对数据的一致性要求都不高，甚至允许脏读&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1046&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;但是，&lt;/span&gt;&lt;span&gt;在金融银行或者财务等企业应用场景，join 操作则是不可或缺的&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;，这些应用一般都是低并发、频繁复杂数据写入、CPU密集而非IO密集，主要业务逻辑通过数据库处理甚至包含大量存储过程、对一致性与完整性要求很高的系统。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;-关注我&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5075921908893709&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtehL5KdOC0Uib7CdHkxwGibQdibjs4kC3FpEO9ehCCjHwFa1ZSS8QoEgb9AtomP8cDZmz8jC1gR8qvzg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;922&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5b556afc497eb90a4c3f5708211d86f0</guid>
<title>小团队如何落地敏捷开发</title>
<link>https://toutiao.io/k/hg0jmdy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article class=&quot;_2rhmJa&quot;&gt;&lt;h1&gt;小团队如何落地敏捷开发&lt;/h1&gt;
&lt;hr/&gt;
&lt;p&gt;You can&#x27;t manage what you don&#x27;t measure. - Peter Drucker&lt;/p&gt;
&lt;p&gt;你如果无法度量它，就无法管理它。&lt;/p&gt;
&lt;p&gt;这是现代管理学之父，彼得·德鲁克的一句名言。项目管理、敏捷开发的前提，还是需要把数据串起来，进行可视化、数据化，这样才能看到它，管理它。&lt;/p&gt;
&lt;p&gt;本文将以公司SaaS产品为例，介绍下“小团队”是如何进行敏捷研发的落地的。&lt;/p&gt;
&lt;h1&gt;为什么要实施&lt;/h1&gt;
&lt;hr/&gt;
&lt;ul&gt;
&lt;li&gt;需求的进展不透明，不知道现在到哪里了&lt;/li&gt;
&lt;li&gt;需求延期发布成为了家常便饭，不知道什么时候会发布上线&lt;/li&gt;
&lt;li&gt;需求发布上线后，心里总是忐忑不安，不知道什么时候会出现问题和故障&lt;/li&gt;
&lt;li&gt;团队沟通成本太高，经常性出现RD、FE、QA、PM信息不一致&lt;/li&gt;
&lt;li&gt;需求插入随意、频繁，不计成本&lt;/li&gt;
&lt;li&gt;不清楚，研发团队的工作量，是正常、超负荷、还是有人不饱和&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在互联网初创公司里，需求和有限的资源，永远是矛盾命题，如何在矛盾中寻找平衡，把有限的资源专注于符合公司战略的需求，保持团队的节奏和良好的情绪，就是要实施敏捷管理的痛点，也是我们为什么要实施，敏捷管理也可以很好的回答上面出现的各种问题，给出答案。&lt;/p&gt;
&lt;h1&gt;使用的工具&lt;/h1&gt;
&lt;hr/&gt;
&lt;p&gt;下面是我们所使用的工具，Confluence主要是知识库和文档的汇集，JIRA是项目管理工具和BUG管理工具，下面是之前写的如何搭建这些工具的文章，大家可以参考&lt;/p&gt;
&lt;h2&gt;✔️Atlassian Confluence&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/bda2638fdbc2&quot; target=&quot;_blank&quot;&gt;创业公司基础设施如何搭建（三） -- Confluence（Docker版本）&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;✔️Atlassian Jira&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/093cf14361ed&quot; target=&quot;_blank&quot;&gt;创业公司基础设施如何搭建（四） -- Jira（Docker版本）&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;如何做好这件事情&lt;/h1&gt;
&lt;hr/&gt;
&lt;p&gt;需求评审 ➡️ 设计评审 ➡️ 研发实现 ➡️ 测试 ➡️ 验收 ➡️ 发布 ➡️ 后评估&lt;/p&gt;
&lt;p&gt;为了让产品和研发过程可视化，更加可控，信息互通，我们采用&lt;strong&gt;&lt;em&gt;4个看板&lt;/em&gt;&lt;/strong&gt;模型进行敏捷管理实践，看板名称和功能如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;公开需求看板（Kanban Board）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;
&lt;p&gt;通过「看板」建立一个公开需求池，向跨部门成员广泛收集需求，一切市场反馈及时传递到位。看板类型为Kanban Board。&lt;/p&gt;
&lt;br/&gt;

&lt;blockquote&gt;
&lt;p&gt;需求看板（Kanban Board）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;
&lt;p&gt;为需求生命周期搭建流程，按「Backlog - 评审 - 排期 - 设计 - 开发 - 发布」设立多个阶段，需求流转可视化。&lt;/p&gt;
&lt;br/&gt;

&lt;blockquote&gt;
&lt;p&gt;任务效能看板（Scrum Board）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;
&lt;p&gt;为需求预设好发版时间，所有人都可以及时预知逾期风险；产品、开发和需求提出者随时发起沟通，及时同步需求变化或者开发进展。&lt;/p&gt;
&lt;br/&gt;

&lt;blockquote&gt;
&lt;p&gt;BUG看板（Kanban Board）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;
&lt;p&gt;通过看板查询，迭代中的各种类型的BUG数量情况，清楚明了。&lt;/p&gt;
&lt;br/&gt;

&lt;h1&gt;公开需求管理&lt;/h1&gt;
&lt;hr/&gt;
&lt;p&gt;公司属于教育类SaaS，其公开需求主要来源有下面几类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重要客户（学校）&lt;/li&gt;
&lt;li&gt;用户日常使用反馈（教师、学生、家长）&lt;/li&gt;
&lt;li&gt;销售渠道&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;甄别和过滤伪需求和次要或者不符合战略的需求，在这里进行，但是“业务方”提出的众多的需求如何管理，也是一件头疼的事情，这里主要流程发生有下列几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;用户使用体验  ➡️ 客户成功同学  ➡️ 记录问题  ➡️ 反馈处理结果&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;
&lt;strong&gt;大客户需求&lt;/strong&gt;  &lt;strong&gt;➡️ 客户成功同学  ➡️ 记录问题  ➡️ 反馈处理结果&lt;/strong&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;客户成功同学、销售同学或者其他干系人，都可以在这个看板内，提交原始需求问题，产品同学会过滤、调研，转化为产品需求，到产品需求池内，下面是&lt;strong&gt;&lt;em&gt;公开需求看板&lt;/em&gt;&lt;/strong&gt;，卡片的内容主要包含了：需求描述、问题类型、解决状态、经办人&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;判断价值很低或者肯定不会做的需求，直接拖到已完成&lt;/li&gt;
&lt;li&gt;判断有一定价值或需要在分析的需求，拖到调研讨论，最终确定后，再拖到已完成&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;产品研发需求管理&lt;/h1&gt;
&lt;hr/&gt;
&lt;blockquote&gt;
&lt;p&gt;需求分类&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;
&lt;p&gt;产品研发内部，我们把需求分成2类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;产品需求：PM提出的迭代、紧急、日常类需求&lt;/li&gt;
&lt;li&gt;技术需求：研发内部为了稳定性、扩展性、维护性而进行的技术重构类需求&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;需求等级&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;
&lt;p&gt;古语云：师出有名，需求的提出也是如此，为了让研发同学知道需求的重要和紧急程度，需求等级划分是特别需要的一件事情。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;产品需求等级划分&lt;/p&gt;
&lt;p&gt;P0：紧急任务，必须穷尽所能，最短时间完成；可以调人支援，可以停止其他项目，需要加班&lt;/p&gt;
&lt;p&gt;P1：非常重要任务，有Deadline，并且不可以Delay；如遇到P0，那么就需要加班保证P1的Deadline&lt;/p&gt;
&lt;p&gt;P2：重要、有影响力的任务，有Deadline，如遇到P0和P1，可以顺延（应该是大部分任务）&lt;/p&gt;
&lt;p&gt;P3：锦上添花的正常任务，优先级最低&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;技术需求等级划分&lt;/p&gt;
&lt;p&gt;T0：重大性能和漏洞，需要加班加点进行修复&lt;/p&gt;
&lt;p&gt;T1：扩展性和性能风险问题，一般是单独任务进行修复&lt;/p&gt;
&lt;p&gt;T2：设计或者一般性能缺陷，一般是随着迭代进行相关改进&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;产品需求管理（需求看板）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;
&lt;p&gt;PM和研发同学，通过PRD的方式进行沟通和交流，研发同学最终也是通过PRD进行开发、测试工作，所以第一步是需要创建PRD，PRD的管理方式采用相对灵活的方式，PM写PRD的工具有的是蓝湖，有的墨刀，我们这里为了统一归档，在Confluence做了归档的统一管理（PRD的详细链接可以是任何工具的链接）， 在Confluence创建时选择模板创建，见下图：&lt;/p&gt;
&lt;br/&gt;


&lt;p&gt;主要包含了&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;技术需求管理（需求看板）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;类似数据结构的变更、技术架构的改进，比如：更换配置中心为Apollo，这类需要简称技术需求，其数据显示和看板功能，和产品需求基本一致，也显示在&lt;strong&gt;&lt;em&gt;需求看板&lt;/em&gt;&lt;/strong&gt;内，看板如下：&lt;br/&gt;
&lt;/p&gt;&lt;p/&gt;
&lt;h1&gt;技术任务管理（任务效能看板）&lt;/h1&gt;
&lt;p&gt;这个阶段，主要是从需求阶段进入到了研发阶段，这个阶段主要包含如下类型的任务：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开发任务：RD、FE&lt;/li&gt;
&lt;li&gt;开发自测：RD、FE&lt;/li&gt;
&lt;li&gt;测试用例编写：QA&lt;/li&gt;
&lt;li&gt;测试用例执行：QA&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;技术任务类型的问题，主要来源于2个方面&lt;/p&gt;

&lt;p&gt;对于此类任务管理，我们使用的看板是&lt;strong&gt;&lt;em&gt;任务效能看板&lt;/em&gt;&lt;/strong&gt;。在开始之前，我们需要在Backlog内，拖动需要进行迭代的技术需求或产品需求，如下图：&lt;br/&gt;
&lt;/p&gt;&lt;p/&gt;
&lt;p&gt;然后，以产品需求和技术需求为父任务，在&lt;strong&gt;&lt;em&gt;需求看板&lt;/em&gt;&lt;/strong&gt;内，创建子任务，界面如下：&lt;br/&gt;
&lt;/p&gt;&lt;p/&gt;
&lt;p&gt;创建好后，可以查看父子任务详情，并有工作量体现&lt;/p&gt;
&lt;br/&gt;

&lt;p&gt;点击开始Sprint，并设置好时间，如下图：&lt;/p&gt;
&lt;br/&gt;

&lt;p&gt;RD &amp;amp; QA &amp;amp; FE，在每天下班前，填写其任务的工作量即可达到任务工作量跟踪的效果，如下图：&lt;/p&gt;
&lt;br/&gt;

&lt;h1&gt;测试BUG管理（BUG看板）&lt;/h1&gt;
&lt;hr/&gt;
&lt;p&gt;在Sprint中产生的BUG都会显示在&lt;strong&gt;&lt;em&gt;BUG看板&lt;/em&gt;&lt;/strong&gt;中，工作流主要是打开 ➡️ 处理中 ➡️ 已解决 ➡️  已关闭，如下图：&lt;br/&gt;
&lt;/p&gt;&lt;p/&gt;
&lt;p&gt;我们所采用的BUG类的问题类型有以下几种：&lt;/p&gt;

&lt;h1&gt;小结&lt;/h1&gt;
&lt;hr/&gt;
&lt;p&gt;需求和效能的生命周期管理，这里仅仅是按照目前产品和团队的需求和阶段，规定了一些适合我们的方法，这个周期管理，还是需要随着人员和阶段的不同而进行不断的改造和演进的，下面是我们在JIRA和Confluence使用的一些核心流程和方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;4个看板&lt;/p&gt;
&lt;p&gt;公开需求看板：处理市场、销售前端部门提出的“大客户需求”和“用户使用体验问题”&lt;/p&gt;
&lt;p&gt;需求看板：主要是管理技术需求和产品需求&lt;/p&gt;
&lt;p&gt;任务效能看板：主要是管理开发阶段，RD &amp;amp; FE &amp;amp; QA的任务和工作量，跟踪其任务合理性&lt;/p&gt;
&lt;p&gt;BUG看板：主要是管理迭代内产生的5类BUG问题，功能优化 &amp;amp; 功能错误 &amp;amp; 界面优化 &amp;amp; 性能问题 &amp;amp; 安全相关&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2个模板&lt;/p&gt;
&lt;p&gt;产品需求模板：产品需求的管理&lt;/p&gt;
&lt;p&gt;测试报告模块：迭代后，针对BUG和其他问题，进行的测试相关的总结&lt;/p&gt;
&lt;p&gt;目前，敏捷相关的管理，这个阶段也仅仅是做了一小部分，还有很多实践方法，在后续的变化中，会加入和实施&lt;/p&gt;
&lt;p&gt;敏捷管理是为了快速、稳定的交付产品而服务的，切忌不要为了追求敏捷工具的使用而耽误了实际要达成的目标。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/article&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>22a3e160411ab16611e0df4d96388b02</guid>
<title>80%人都理解错误的 Event Loop</title>
<link>https://toutiao.io/k/58l8j37</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-body&quot; itemprop=&quot;articleBody&quot;&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;/&gt; 前言 🎤&lt;/h2&gt;
&lt;p&gt;本文的目的在于，一次性推翻80%人构建好的关于Event Loop的知识体系和一次性的完整的理解Nodejs(13以上)和浏览器中的Event Loop。&lt;/p&gt;
&lt;a id=&quot;more&quot;/&gt;
&lt;h2 id=&quot;划分&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#划分&quot;/&gt; 划分&lt;/h2&gt;
&lt;p&gt;首先进行一下基础概念的划分。&lt;br/&gt;
Node下特有的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Immediate&lt;/li&gt;
&lt;li&gt;process.nextTick&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;浏览器中特有的:🈚️&lt;/p&gt;
&lt;p&gt;双方共有的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;queueMicroTask (nodejs &amp;gt; v11)&lt;/li&gt;
&lt;li&gt;setTimeout&lt;/li&gt;
&lt;li&gt;setInterval&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;宏任务&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#宏任务&quot;/&gt; 宏任务&lt;/h3&gt;
&lt;p&gt;这里补充一下宏任务&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;#&lt;/th&gt;
&lt;th&gt;Node&lt;/th&gt;
&lt;th&gt;Browser&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;setTimeout&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;setInterval&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;I/O&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;setImmediate&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;❌&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;mouseover(之类的事件)&lt;/td&gt;
&lt;td&gt;❌&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Web API大部分异步返回方法(XHR,fetch)&lt;/td&gt;
&lt;td&gt;❌&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;逗知识：其实setTimeout和setInterval也属于Web API&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;宏任务注意️️️️️浏览器中&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#宏任务注意️️️️️浏览器中&quot;/&gt; 宏任务：注意⚠️⚠️⚠️⚠️⚠️(浏览器中)&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;requestAnimationFrame&lt;/code&gt;和&lt;code&gt;render&lt;/code&gt;不为宏任务，也不为微任务。他们两个的触发时机在宏任务和微任务之外。&lt;br/&gt;
&lt;code&gt;requestAnimationFrame&lt;/code&gt;的触发时机在&lt;code&gt;render&lt;/code&gt;之前。而&lt;code&gt;render&lt;/code&gt;的触发时机在&lt;strong&gt;所有微任务处理结束&lt;/strong&gt;之后。&lt;br/&gt;
但是他们的触发顺序为&lt;code&gt;microTask-&amp;gt;requestAnimationFrame-&amp;gt;render&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;requestAnimationFrame(&lt;span class=&quot;function&quot;&gt;()=&amp;gt;&lt;/span&gt;{&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#x27;animation&#x27;&lt;/span&gt;)})&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;queueMicrotask(&lt;span class=&quot;function&quot;&gt;()=&amp;gt;&lt;/span&gt;{&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#x27;micro&#x27;&lt;/span&gt;)})&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;micro&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;animation&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;微任务&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#微任务&quot;/&gt; 微任务&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;#&lt;/th&gt;
&lt;th&gt;Node&lt;/th&gt;
&lt;th&gt;Browser&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Promise.then catch finally&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MutationObserver&lt;/td&gt;
&lt;td&gt;❌&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;queueMicrotask&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&quot;微任务注意️️️️️&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#微任务注意️️️️️&quot;/&gt; 微任务：注意⚠️⚠️⚠️⚠️⚠️&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;process.nextTick&lt;/code&gt;不是微任务&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;queueMicrotask(&lt;span class=&quot;function&quot;&gt;()=&amp;gt;&lt;/span&gt;{&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#x27;micro&#x27;&lt;/span&gt;)})&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;process.nextTick(&lt;span class=&quot;function&quot;&gt;()=&amp;gt;&lt;/span&gt;{&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#x27;i am not micro&#x27;&lt;/span&gt;)})&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;i am not micro&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;micro&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果以上两个注意，都让你原有的知识大厦倾倒，那么请继续往下看，看完后你将会得到一切的答案。&lt;/p&gt;
&lt;h2 id=&quot;nodejs&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#nodejs&quot;/&gt; Nodejs&lt;/h2&gt;
&lt;p&gt;先看官方定义&lt;/p&gt;
&lt;img src=&quot;/images/Eventloop-Timeout-Immediate-Interval-QueueMicrotask-2020-11-11-14-11-56.png&quot; class=&quot;&quot;/&gt;
&lt;blockquote&gt;
&lt;p&gt;阶段概述&lt;br/&gt;
定时器：本阶段执行已经被 setTimeout() 和 setInterval() 的调度回调函数。&lt;br/&gt;
待定回调：执行延迟到下一个循环迭代的 I/O 回调。&lt;br/&gt;
idle, prepare：仅系统内部使用。&lt;br/&gt;
轮询：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 setImmediate() 调度的之外），其余情况 node 将在适当的时候在此阻塞。&lt;br/&gt;
检测：setImmediate() 回调函数在这里执行。&lt;br/&gt;
关闭的回调函数：一些关闭的回调函数，如：socket.on(‘close’, …)。&lt;br/&gt;
在每次运行的事件循环之间，Node.js 检查它是否在等待任何异步 I/O 或计时器，如果没有的话，则完全关闭。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单来说就是我都不知道他在说什么，😄。&lt;br/&gt;
所以我特意找了一张比较容易看懂的图，来简单的概括一下这些学术语言。&lt;/p&gt;
&lt;img src=&quot;/images/Eventloop-Timeout-Immediate-Interval-QueueMicrotask-2020-11-11-13-00-10.png&quot; class=&quot;&quot;/&gt;
&lt;p&gt;图片来自互联网&lt;/p&gt;
&lt;p&gt;细心的同学已经看出来了，在图片的中间的红色区域写着&lt;code&gt;process.nextTick&lt;/code&gt;和&lt;code&gt;microTasks&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;第一个重点&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#第一个重点&quot;/&gt; 第一个重点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;在Node中，nextTick和microTask会在每一个阶段执行结束后被立刻执行。&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;他们不属于任何阶段，但是他们又属于任何阶段 ——Box&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单的来说，在Node中，每一个处理阶段结束，都会执行并清空&lt;code&gt;nextTick&lt;/code&gt;和&lt;code&gt;microTask&lt;/code&gt;的任务。&lt;br/&gt;
而Node中，分为四个阶段&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;setTimeout和setInterval的到期回调执行阶段&lt;/li&gt;
&lt;li&gt;IO轮询阶段&lt;/li&gt;
&lt;li&gt;处理setImmediate的回调阶段&lt;/li&gt;
&lt;li&gt;处理某些关闭句柄的回掉阶段&lt;br/&gt;
反复执行。&lt;br/&gt;
所以说，在这个四个阶段执行间隔中，只要出现了任何&lt;code&gt;nextTick&lt;/code&gt;或者&lt;code&gt;microTask&lt;/code&gt;都会被执行知道清空&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;第二个重点&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#第二个重点&quot;/&gt; 第二个重点&lt;/h3&gt;
&lt;p&gt;先说重点然后看代码：&lt;strong&gt;在处理nextTick和microTask时，会一直循环直到两个任务队列清空，如果你在他们的逻辑中循环创建了新的任务，那么将无法离开这个阶段&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#x27;timeout&#x27;&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;{ &lt;span class=&quot;comment&quot;&gt;// flag 1&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    process.nextTick(&lt;span class=&quot;function&quot;&gt;()=&amp;gt;&lt;/span&gt;{&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#x27;next timeout&#x27;&lt;/span&gt;)})&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; loop = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;/&gt;)&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        process.nextTick(loop)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    process.nextTick(loop)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;{ &lt;span class=&quot;comment&quot;&gt;// flag 2&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    queueMicrotask(&lt;span class=&quot;function&quot;&gt;()=&amp;gt;&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#x27;micro&#x27;&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    })&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; micro = &lt;span class=&quot;function&quot;&gt;()=&amp;gt;&lt;/span&gt;{queueMicrotask(micro)}&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    queueMicrotask(micro)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;setImmediate(&lt;span class=&quot;function&quot;&gt;()=&amp;gt;&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#x27;immediate&#x27;&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;})&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以尝试把flag1或者flag2处的true改成false，只要有任何一个循环存在，那么都无法离开这个&lt;strong&gt;尾部处理阶段&lt;/strong&gt;——我自己编的名词。&lt;/p&gt;
&lt;h3 id=&quot;第三个重点&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#第三个重点&quot;/&gt; 第三个重点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;每个尾部处理阶段一定会执行，就算当前阶段什么都没做，但是依然会执行&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;尾部处理阶段顺序是nextTick-&amp;gt;queueMicroTask 也就是 tickTask-&amp;gt;microTask，并且这个顺序是固定的，不可以翻转，也不可以回退&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#x27;timeout&#x27;&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;queueMicrotask(&lt;span class=&quot;function&quot;&gt;()=&amp;gt;&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#x27;micro&#x27;&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    process.nextTick(&lt;span class=&quot;function&quot;&gt;()=&amp;gt;&lt;/span&gt;{ &lt;span class=&quot;comment&quot;&gt;// 在microTask之前执行的tickTask一旦执行完成，那么在同一个尾部阶段是不会继续被执行的。&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#x27;next&#x27;&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    })&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;})&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;setImmediate(&lt;span class=&quot;function&quot;&gt;()=&amp;gt;&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#x27;immediate&#x27;&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;})&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;timeout&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;micro&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;next&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;immediate&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;第四个重点&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#第四个重点&quot;/&gt; 第四个重点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;事件循环有一种维持在poll阶段的倾向&lt;/strong&gt;&lt;br/&gt;
在poll阶段时，会进行一些判定处理，比如会进行计算，大概会在这个阶段停留多久——一般根据下一个要被执行的&lt;code&gt;setTimeout&lt;/code&gt;或者&lt;code&gt;setInterval&lt;/code&gt;来决定。&lt;br/&gt;
然后会在可停留时间中进行等待。直到需要执行&lt;code&gt;timer&lt;/code&gt;的时候才会退出。&lt;br/&gt;
举个例子，假设进入poll时，又一个100ms以后的才会被执行的setTimeout，那么，就会尝试在这100ms之中，尽可能的等待IO事件触发，并处理。每当处理完后依然会判断，是否需要退出。&lt;br/&gt;
所以在大多数情况下，Nodejs都会在poll阶段运行。并且，会尝试清空所有返回的IO事件的回调（这个不是无限制的，有一个硬性限制）。&lt;/p&gt;
&lt;p&gt;与此同时，这里有出现来个新问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果回调队列中有大量的回调完成事件并且他们会堵塞100ms以上，那么setTimeout(fn,10)会怎么样&lt;br/&gt;
这里就是一个很有趣的地方了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; fs = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#x27;fs&#x27;&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#x27;start&#x27;&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; globalStart = &lt;span class=&quot;built_in&quot;&gt;Date&lt;/span&gt;.now()&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;call&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;callback&lt;/span&gt;) &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    fs.readFile(__filename, callback);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; i =&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;;i++&lt;/span&gt;)&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    call(&lt;span class=&quot;function&quot;&gt;()=&amp;gt;&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; start = &lt;span class=&quot;built_in&quot;&gt;Date&lt;/span&gt;.now()&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Date&lt;/span&gt;.now() - start &amp;lt; &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;{}&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;`done:&lt;span class=&quot;subst&quot;&gt;${i}&lt;/span&gt;`&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    })&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;setTimeout&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;()=&amp;gt;&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;`&lt;span class=&quot;subst&quot;&gt;${&lt;span class=&quot;built_in&quot;&gt;Date&lt;/span&gt;.now()-globalStart}&lt;/span&gt;ms`&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#x27;timeout&#x27;&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;},&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这段代码中模拟了每次IO调用超过100ms，并且触发了20次，同时也创建了一个timeout为10ms的任务。感兴趣的可以猜一猜他的运行结果？&lt;br/&gt;
运行结果&lt;/p&gt;
&lt;img src=&quot;/images/Eventloop-Timeout-Immediate-Interval-QueueMicrotask-2020-11-11-15-18-42.png&quot; class=&quot;&quot;/&gt;
&lt;p&gt;很明显，在有些情况下，还没等poll中回调全部执行完成，就直接开始进入了下一个循环，而有些情况，又是执行完了全部的回调才进入下一个阶段。&lt;br/&gt;
不过这里不是我们讨论的重点，因为这个想说的是&lt;code&gt;pending callbacks&lt;/code&gt;这个阶段。我们可以看到有些&lt;code&gt;done:x&lt;/code&gt;是在已经打印了timeout之后才出现。那么也就可以说明，已经从poll阶段循环到了timer阶段，最后在&lt;code&gt;pending callbacks&lt;/code&gt;触发回调。所以这个就是&lt;code&gt;pending callbacks&lt;/code&gt;阶段的作用。&lt;br/&gt;
有些人可能保持怀疑的态度，认为并没有进入&lt;code&gt;pending callbacks&lt;/code&gt;，可能之前的&lt;code&gt;read&lt;/code&gt;事件并没有返回，所以重新进入了poll进行等待。我只能告诉你，我确实也无法证明他们究竟是在&lt;code&gt;pending callbacks&lt;/code&gt;还是&lt;code&gt;poll&lt;/code&gt;阶段被执行，如果有更好的方法，还请多多赐教。&lt;/p&gt;
&lt;h3 id=&quot;第五个重点&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#第五个重点&quot;/&gt; 第五个重点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;setImmediate也没有那么的immediate&lt;/strong&gt;&lt;br/&gt;
所有人都知道&lt;code&gt;setImmediate&lt;/code&gt;的执行一般会比&lt;code&gt;setTimeout&lt;/code&gt;优先，但是其实他们也存在相反的情况。有时候是&lt;code&gt;immediate&lt;/code&gt;快，有时候是&lt;code&gt;timeout&lt;/code&gt;快，这种情况在直接写出&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;setTimeout&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;()=&amp;gt;&lt;/span&gt;{&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#x27;timeout&#x27;&lt;/span&gt;)},&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;setImmediate(&lt;span class=&quot;function&quot;&gt;()=&amp;gt;&lt;/span&gt;{&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#x27;immediate&#x27;&lt;/span&gt;)})&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;有时候&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;timeout&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;immediate&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;有时候&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;immediate&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;timeout&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这种毫无意义的代码下会更容易出现。所以为什么会有这种情况？&lt;/p&gt;
&lt;img src=&quot;/images/Eventloop-Timeout-Immediate-Interval-QueueMicrotask-2020-11-11-15-59-29.png&quot; class=&quot;&quot;/&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://medium.com/softup-technologies/node-js-internals-event-loop-in-action-59cde8ff7e8d&quot;&gt;图片来源&lt;/a&gt;&lt;br/&gt;
简单的来说，在进入事件循环之前，你只需要进行js代码执行。那么这里也会产生耗时，所以，这里的运算时间就充满了不确定性。也许在运行&lt;code&gt;setTimeout(fn,1)&lt;/code&gt;的那一瞬间，当前的ms可能为10，但是当node执行完所有代码之后，导入了一大堆杂七杂八的库，此时的ms可能已经成为了14，很明显，&lt;code&gt;setTimeout&lt;/code&gt;被优先执行。那么如果说，当前的ms可能还是10，那么就会跳过&lt;code&gt;timer&lt;/code&gt;阶段，所以看起来就像是&lt;code&gt;setImmediate&lt;/code&gt;优先执行。那么有人可能会问，为啥要&lt;code&gt;setTimeout(fn,1)&lt;/code&gt;，而不是&lt;code&gt;setTimeout(fn,0)&lt;/code&gt;？这就是下一个重点。&lt;/p&gt;
&lt;h3 id=&quot;第六个重点&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#第六个重点&quot;/&gt; 第六个重点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;在Nodejs下，&lt;code&gt;setTimeout&lt;/code&gt;的最小延迟数是1，最大数为2147483647，如果小于或者大于最大，那么都会被修改为1&lt;/strong&gt;&lt;br/&gt;
这里其实没啥好说的，就是这么设计的。不过有趣的是，最小为1其实是向浏览器看齐而这么做的。（源码的注释中是这么写的😄）&lt;/p&gt;
&lt;h3 id=&quot;第七个重点&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#第七个重点&quot;/&gt; 第七个重点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Promise.then中使用的微任务，和microTask为同一等级&lt;/strong&gt;（存疑）&lt;br/&gt;
为什么有个存疑🤨，因为从表现上来看，没有错误，但是我并没有去阅读详细的代码来证明它的确定性。&lt;br/&gt;
运行代码如下&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;queueMicrotask(&lt;span class=&quot;function&quot;&gt;()=&amp;gt;&lt;/span&gt;{&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#x27;micro&#x27;&lt;/span&gt;)})&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt;.resolve(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;).then(&lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;v&lt;/span&gt;)=&amp;gt;&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(v)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;})&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;queueMicrotask(&lt;span class=&quot;function&quot;&gt;()=&amp;gt;&lt;/span&gt;{&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#x27;micro2&#x27;&lt;/span&gt;)})&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;micro&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;micro2&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但是，根据这个结论来看，&lt;code&gt;Promise.then&lt;/code&gt;就是一个微任务。并没有高人一等。&lt;/p&gt;
&lt;h2 id=&quot;browser&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#browser&quot;/&gt; Browser&lt;/h2&gt;
&lt;img src=&quot;/images/Eventloop-Timeout-Immediate-Interval-QueueMicrotask-2020-11-11-16-30-53.png&quot; class=&quot;&quot;/&gt;
&lt;p&gt;是不是看起来和Node的Event loop有很大的不同？如果我告诉你可以这么理解，会不会更好？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Browser中，去除了&lt;code&gt;pending callbacks&lt;/code&gt;,&lt;code&gt;poll&lt;/code&gt;,&lt;code&gt;check&lt;/code&gt;,&lt;code&gt;close callbacks&lt;/code&gt;,并全部塞入&lt;code&gt;timer&lt;/code&gt;，微任务处理时机不变&lt;br/&gt;
但是有一点小问题，就是事件循环的结束时机。但是等会会讲。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而浏览器中的执行顺序是这样。&lt;code&gt;one macroTask-&amp;gt;all microTask-&amp;gt;requestAnimationFrame-&amp;gt;render&lt;/code&gt;。&lt;br/&gt;
而且，和Node相似的是，他们的&lt;code&gt;setTimeout&lt;/code&gt;或者&lt;code&gt;setInterval&lt;/code&gt;都是尽可能的执行（时间无法保证完全符合预期）。&lt;br/&gt;
还有一点，那就是&lt;code&gt;Web API&lt;/code&gt;，在浏览器中，所有涉及到&lt;code&gt;Web API&lt;/code&gt;的内容都交给C++引擎进行处理。也就是说，当你的&lt;code&gt;setTimeout&lt;/code&gt;到底预计时间了，就算你的js引擎被某个&lt;code&gt;while(true)&lt;/code&gt;给堵住了，这个&lt;code&gt;setTimeout&lt;/code&gt;的内容依然会被推入到一个&lt;code&gt;TaskQueue&lt;/code&gt;之中。等待下一次&lt;code&gt;Event Loop&lt;/code&gt;的取出。&lt;/p&gt;
&lt;h3 id=&quot;重点一&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#重点一&quot;/&gt; 重点一&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;在浏览器中，微任务的执行时机是在调用栈清空时&lt;/strong&gt;&lt;br/&gt;
&lt;strong&gt;浏览器中一次性只执行一个宏任务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;浏览器中的宏任务处理方式和Node稍微有一点点不同，Node会在一个阶段把所有到期任务都执行完成。而浏览器中，是会在执行完成一个宏观任务时清空微任务队列。而且微任务队列不会收到网络相应或者其他类型的回掉任务干扰。也就是说，和Node一样，如果你在微任务中无限创建新的微任务，那么你基本可以和这个页面说再见了👋。&lt;br/&gt;
如果不信，可以试试这个。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; call = &lt;span class=&quot;function&quot;&gt;()=&amp;gt;&lt;/span&gt;{queueMicrotask(call)}&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;queueMicrotask(call)&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;重点二&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#重点二&quot;/&gt; 重点二&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;setTimeout&lt;/code&gt;的最小时间为1ms，而当嵌套等级达到一定时（跟随浏览器，3-5层），为4ms&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; startTime = &lt;span class=&quot;built_in&quot;&gt;Date&lt;/span&gt;.now()&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; call = &lt;span class=&quot;function&quot;&gt;()=&amp;gt;&lt;/span&gt;{&lt;span class=&quot;built_in&quot;&gt;setTimeout&lt;/span&gt;(call);&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;`&lt;span class=&quot;subst&quot;&gt;${&lt;span class=&quot;built_in&quot;&gt;Date&lt;/span&gt;.now() - startTime}&lt;/span&gt;`&lt;/span&gt;)}&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;call()&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;img src=&quot;/images/Eventloop-Timeout-Immediate-Interval-QueueMicrotask-2020-11-11-19-11-53.png&quot; class=&quot;&quot;/&gt;
&lt;p&gt;不要问1到哪去了，如果实在不懂可以重新看文章，还是不懂可以悄悄问我，咱们别丢人。&lt;/p&gt;
&lt;h3 id=&quot;重点三&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#重点三&quot;/&gt; 重点三&lt;/h3&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#总结&quot;/&gt; 总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;process.nextTick不是微任务&lt;/li&gt;
&lt;li&gt;requestAnimationFrame也不是微任务&lt;/li&gt;
&lt;li&gt;Promise.then中的创建方式就是创建微任务，并且和queueMicrotask同级&lt;/li&gt;
&lt;li&gt;setTimeout(fn,0)并不是0，最小为1&lt;/li&gt;
&lt;li&gt;如果你还不懂，可以直接问我，如果你有更好的想法，那么我们一起构建更好的文章，如果你不懂而且也不问我，那么我直接切腹自尽😭。&lt;/li&gt;
&lt;li&gt;有些内容我可能没有写出来，或者你有任何疑问，我都会补充在文章之中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9cf10d0621adc87b8bb0467a02811fb3</guid>
<title>10 张图 22 段代码，万字长文带你搞懂虚拟内存模型和 malloc 内部原理</title>
<link>https://toutiao.io/k/cqnqfjo</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;/**&lt;br/&gt; * main - 使用strdup创建一个字符串的拷贝，strdup内部会使用malloc分配空间，&lt;br/&gt; * 返回新空间的地址，这段地址空间需要外部自行使用free释放&lt;br/&gt; *&lt;br/&gt; * Return: EXIT_FAILURE &lt;span&gt;if&lt;/span&gt; malloc failed. Otherwise EXIT_SUCCESS&lt;br/&gt; */&lt;br/&gt;int main(void)&lt;br/&gt;{&lt;br/&gt;    char *s;&lt;br/&gt;&lt;br/&gt;    s = strdup(&lt;span&gt;&quot;test_memory&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (s == NULL)&lt;br/&gt;    {&lt;br/&gt;        fprintf(stderr, &lt;span&gt;&quot;Can&#x27;t allocate mem with malloc\n&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; (EXIT_FAILURE);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;%p\n&quot;&lt;/span&gt;, (void *)s);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; (EXIT_SUCCESS);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;编译运行：gcc -Wall -Wextra -pedantic -Werror main.c -o &lt;span&gt;test&lt;/span&gt;; ./&lt;span&gt;test&lt;/span&gt;&lt;br/&gt;输出：0x88f010&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我的机器是64位机器，进程的虚拟内存高地址为0xffffffffffffffff， 低地址为0x0，而0x88f010远小于0xffffffffffffffff，因此大概可以推断出被复制的字符串的地址(堆地址)是在内存低地址附近，具体可以通过/proc文件系统验证.&lt;br/&gt;ls /proc目录可以看到好多文件，这里主要关注/proc/[pid]/mem和/proc/[pid]/maps&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;mem &amp;amp; maps&lt;/span&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;man proc&lt;br/&gt;&lt;br/&gt;/proc/[pid]/mem&lt;br/&gt;    This file can be used to access the pages of a process&lt;span&gt;&#x27;s memory through open(2), read(2), and lseek(2).&lt;br/&gt;&lt;br/&gt;/proc/[pid]/maps&lt;br/&gt;    A  file containing the currently mapped memory regions and their access permissions.&lt;br/&gt;          See mmap(2) for some further information about memory mappings.&lt;br/&gt;&lt;br/&gt;              The format of the file is:&lt;br/&gt;&lt;br/&gt;       address           perms offset  dev   inode       pathname&lt;br/&gt;       00400000-00452000 r-xp 00000000 08:02 173521      /usr/bin/dbus-daemon&lt;br/&gt;       00651000-00652000 r--p 00051000 08:02 173521      /usr/bin/dbus-daemon&lt;br/&gt;       00652000-00655000 rw-p 00052000 08:02 173521      /usr/bin/dbus-daemon&lt;br/&gt;       00e03000-00e24000 rw-p 00000000 00:00 0           [heap]&lt;br/&gt;       00e24000-011f7000 rw-p 00000000 00:00 0           [heap]&lt;br/&gt;       ...&lt;br/&gt;       35b1800000-35b1820000 r-xp 00000000 08:02 135522  /usr/lib64/ld-2.15.so&lt;br/&gt;       35b1a1f000-35b1a20000 r--p 0001f000 08:02 135522  /usr/lib64/ld-2.15.so&lt;br/&gt;       35b1a20000-35b1a21000 rw-p 00020000 08:02 135522  /usr/lib64/ld-2.15.so&lt;br/&gt;       35b1a21000-35b1a22000 rw-p 00000000 00:00 0&lt;br/&gt;       35b1c00000-35b1dac000 r-xp 00000000 08:02 135870  /usr/lib64/libc-2.15.so&lt;br/&gt;       35b1dac000-35b1fac000 ---p 001ac000 08:02 135870  /usr/lib64/libc-2.15.so&lt;br/&gt;       35b1fac000-35b1fb0000 r--p 001ac000 08:02 135870  /usr/lib64/libc-2.15.so&lt;br/&gt;       35b1fb0000-35b1fb2000 rw-p 001b0000 08:02 135870  /usr/lib64/libc-2.15.so&lt;br/&gt;       ...&lt;br/&gt;       f2c6ff8c000-7f2c7078c000 rw-p 00000000 00:00 0    [stack:986]&lt;br/&gt;       ...&lt;br/&gt;       7fffb2c0d000-7fffb2c2e000 rw-p 00000000 00:00 0   [stack]&lt;br/&gt;       7fffb2d48000-7fffb2d49000 r-xp 00000000 00:00 0   [vdso]&lt;br/&gt;&lt;br/&gt;              The address field is the address space in the process that the mapping occupies.&lt;br/&gt;          The perms field is a set of permissions:&lt;br/&gt;&lt;br/&gt;                   r = read&lt;br/&gt;                   w = write&lt;br/&gt;                   x = execute&lt;br/&gt;                   s = shared&lt;br/&gt;                   p = private (copy on write)&lt;br/&gt;&lt;br/&gt;              The offset field is the offset into the file/whatever;&lt;br/&gt;          dev is the device (major:minor); inode is the inode on that device.   0  indicates&lt;br/&gt;              that no inode is associated with the memory region,&lt;br/&gt;          as would be the case with BSS (uninitialized data).&lt;br/&gt;&lt;br/&gt;              The  pathname field will usually be the file that is backing the mapping.&lt;br/&gt;          For ELF files, you can easily coordinate with the offset field&lt;br/&gt;              by looking at the Offset field in the ELF program headers (readelf -l).&lt;br/&gt;&lt;br/&gt;              There are additional helpful pseudo-paths:&lt;br/&gt;&lt;br/&gt;                   [stack]&lt;br/&gt;                          The initial process&#x27;&lt;/span&gt;s (also known as the main thread&lt;span&gt;&#x27;s) stack.&lt;br/&gt;&lt;br/&gt;                   [stack:&amp;lt;tid&amp;gt;] (since Linux 3.4)&lt;br/&gt;                          A thread&#x27;&lt;/span&gt;s stack (&lt;span&gt;where&lt;/span&gt; the &amp;lt;tid&amp;gt; is a thread ID).&lt;br/&gt;              It corresponds to the /proc/[pid]/task/[tid]/ path.&lt;br/&gt;&lt;br/&gt;                   [vdso] The virtual dynamically linked shared object.&lt;br/&gt;&lt;br/&gt;                   [heap] The process&lt;span&gt;&#x27;s heap.&lt;br/&gt;&lt;br/&gt;              If the pathname field is blank, this is an anonymous mapping as obtained via the mmap(2) function.&lt;br/&gt;          There is no easy  way  to  coordinate&lt;br/&gt;              this back to a process&#x27;&lt;/span&gt;s &lt;span&gt;source&lt;/span&gt;, short of running it through gdb(1), strace(1), or similar.&lt;br/&gt;&lt;br/&gt;              Under Linux 2.0 there is no field giving pathname.&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过mem文件可以访问和修改整个进程的内存页，通过maps可以看到进程当前已映射的内存区域，有地址和访问权限偏移量等，从maps中可以看到堆空间是在低地址而栈空间是在高地址.  从maps中可以看到heap的访问权限是rw，即可写，所以可以通过堆地址找到上个示例程序中字符串的地址，并通过修改mem文件对应地址的内容，就可以修改字符串的内容啦，程序：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;/**              &lt;br/&gt; * main - uses strdup to create a new string, loops forever-ever&lt;br/&gt; *                &lt;br/&gt; * Return: EXIT_FAILURE &lt;span&gt;if&lt;/span&gt; malloc failed. Other never returns&lt;br/&gt; */&lt;br/&gt;int main(void)&lt;br/&gt;{&lt;br/&gt;     char *s;&lt;br/&gt;     unsigned long int i;&lt;br/&gt;&lt;br/&gt;     s = strdup(&lt;span&gt;&quot;test_memory&quot;&lt;/span&gt;);&lt;br/&gt;     &lt;span&gt;if&lt;/span&gt; (s == NULL)&lt;br/&gt;     {&lt;br/&gt;          fprintf(stderr, &lt;span&gt;&quot;Can&#x27;t allocate mem with malloc\n&quot;&lt;/span&gt;);&lt;br/&gt;          &lt;span&gt;return&lt;/span&gt; (EXIT_FAILURE);&lt;br/&gt;     }&lt;br/&gt;     i = 0;&lt;br/&gt;     &lt;span&gt;while&lt;/span&gt; (s)&lt;br/&gt;     {&lt;br/&gt;          &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;[%lu] %s (%p)\n&quot;&lt;/span&gt;, i, s, (void *)s);&lt;br/&gt;          sleep(1);&lt;br/&gt;          i++;&lt;br/&gt;     }&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; (EXIT_SUCCESS);&lt;br/&gt;}&lt;br/&gt;编译运行：gcc -Wall -Wextra -pedantic -Werror main.c -o loop; ./loop&lt;br/&gt;输出：&lt;br/&gt;[0] test_memory (0x21dc010)&lt;br/&gt;[1] test_memory (0x21dc010)&lt;br/&gt;[2] test_memory (0x21dc010)&lt;br/&gt;[3] test_memory (0x21dc010)&lt;br/&gt;[4] test_memory (0x21dc010)&lt;br/&gt;[5] test_memory (0x21dc010)&lt;br/&gt;[6] test_memory (0x21dc010)&lt;br/&gt;...&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里可以写一个脚本通过/proc文件系统找到字符串所在位置并修改其内容，相应的输出也会更改。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;首先找到进程的进程号&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ps aux | grep ./loop | grep -v grep&lt;br/&gt;zjucad    2542  0.0  0.0   4352   636 pts/3    S+   12:28   0:00 ./loop&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2542即为loop程序的进程号，cat /proc/2542/maps得到&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;00400000-00401000 r-xp 00000000 08:01 811716                             /home/zjucad/wangzhiqiang/loop&lt;br/&gt;00600000-00601000 r--p 00000000 08:01 811716                             /home/zjucad/wangzhiqiang/loop&lt;br/&gt;00601000-00602000 rw-p 00001000 08:01 811716                             /home/zjucad/wangzhiqiang/loop&lt;br/&gt;021dc000-021fd000 rw-p 00000000 00:00 0                                  [heap]&lt;br/&gt;7f2adae2a000-7f2adafea000 r-xp 00000000 08:01 8661324                    /lib/x86_64-linux-gnu/libc-2.23.so&lt;br/&gt;7f2adafea000-7f2adb1ea000 ---p 001c0000 08:01 8661324                    /lib/x86_64-linux-gnu/libc-2.23.so&lt;br/&gt;7f2adb1ea000-7f2adb1ee000 r--p 001c0000 08:01 8661324                    /lib/x86_64-linux-gnu/libc-2.23.so&lt;br/&gt;7f2adb1ee000-7f2adb1f0000 rw-p 001c4000 08:01 8661324                    /lib/x86_64-linux-gnu/libc-2.23.so&lt;br/&gt;7f2adb1f0000-7f2adb1f4000 rw-p 00000000 00:00 0&lt;br/&gt;7f2adb1f4000-7f2adb21a000 r-xp 00000000 08:01 8661310                    /lib/x86_64-linux-gnu/ld-2.23.so&lt;br/&gt;7f2adb3fa000-7f2adb3fd000 rw-p 00000000 00:00 0&lt;br/&gt;7f2adb419000-7f2adb41a000 r--p 00025000 08:01 8661310                    /lib/x86_64-linux-gnu/ld-2.23.so&lt;br/&gt;7f2adb41a000-7f2adb41b000 rw-p 00026000 08:01 8661310                    /lib/x86_64-linux-gnu/ld-2.23.so&lt;br/&gt;7f2adb41b000-7f2adb41c000 rw-p 00000000 00:00 0&lt;br/&gt;7ffd51bb3000-7ffd51bd4000 rw-p 00000000 00:00 0                          [stack]&lt;br/&gt;7ffd51bdd000-7ffd51be0000 r--p 00000000 00:00 0                          [vvar]&lt;br/&gt;7ffd51be0000-7ffd51be2000 r-xp 00000000 00:00 0                          [vdso]&lt;br/&gt;ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看见堆地址范围021dc000-021fd000，并且可读可写，而且021dc000&amp;lt;0x21dc010&amp;lt;021fd000，这就可以确认字符串的地址在堆中，在堆中的索引是0x10(至于为什么是0x10，后面会讲到)，这时可以通过mem文件到0x21dc010地址修改内容，字符串输出的内容也会随之更改，这里通过python脚本实现此功能.&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#!/usr/bin/env python3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&#x27;&#x27;&#x27;             &lt;br/&gt;Locates and replaces the first occurrence of a string in the heap&lt;br/&gt;of a process    &lt;br/&gt;&lt;br/&gt;Usage: ./read_write_heap.py PID search_string replace_by_string&lt;br/&gt;Where:           &lt;br/&gt;- PID is the pid of the target process&lt;br/&gt;- search_string is the ASCII string you are looking to overwrite&lt;br/&gt;- replace_by_string is the ASCII string you want to replace&lt;br/&gt;  search_string with&lt;br/&gt;&#x27;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;import sys&lt;br/&gt;&lt;br/&gt;def print_usage_and_exit():&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&#x27;Usage: {} pid search write&#x27;&lt;/span&gt;.format(sys.argv[0]))&lt;br/&gt;    sys.exit(1)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# check usage  &lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; len(sys.argv) != 4:&lt;br/&gt;    print_usage_and_exit()&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# get the pid from args&lt;/span&gt;&lt;br/&gt;pid = int(sys.argv[1])&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; pid &amp;lt;= 0:&lt;br/&gt;    print_usage_and_exit()&lt;br/&gt;search_string = str(sys.argv[2])&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; search_string  == &lt;span&gt;&quot;&quot;&lt;/span&gt;:&lt;br/&gt;    print_usage_and_exit()&lt;br/&gt;write_string = str(sys.argv[3])&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; search_string  == &lt;span&gt;&quot;&quot;&lt;/span&gt;:&lt;br/&gt;    print_usage_and_exit()&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# open the maps and mem files of the process&lt;/span&gt;&lt;br/&gt;maps_filename = &lt;span&gt;&quot;/proc/{}/maps&quot;&lt;/span&gt;.format(pid)&lt;br/&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;[*] maps: {}&quot;&lt;/span&gt;.format(maps_filename))&lt;br/&gt;mem_filename = &lt;span&gt;&quot;/proc/{}/mem&quot;&lt;/span&gt;.format(pid)&lt;br/&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;[*] mem: {}&quot;&lt;/span&gt;.format(mem_filename))&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# try opening the maps file&lt;/span&gt;&lt;br/&gt;try:&lt;br/&gt;    maps_file = open(&lt;span&gt;&#x27;/proc/{}/maps&#x27;&lt;/span&gt;.format(pid), &lt;span&gt;&#x27;r&#x27;&lt;/span&gt;)&lt;br/&gt;except IOError as e:&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;[ERROR] Can not open file {}:&quot;&lt;/span&gt;.format(maps_filename))&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;        I/O error({}): {}&quot;&lt;/span&gt;.format(e.errno, e.strerror))&lt;br/&gt;    sys.exit(1)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt; maps_file:&lt;br/&gt;    sline = line.split(&lt;span&gt;&#x27; &#x27;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;# check if we found the heap&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; sline[-1][:-1] != &lt;span&gt;&quot;[heap]&quot;&lt;/span&gt;:&lt;br/&gt;        &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;[*] Found [heap]:&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# parse line&lt;/span&gt;&lt;br/&gt;    addr = sline[0]&lt;br/&gt;    perm = sline[1]&lt;br/&gt;    offset = sline[2]&lt;br/&gt;    device = sline[3]&lt;br/&gt;    inode = sline[4]&lt;br/&gt;    pathname = sline[-1][:-1]&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;\tpathname = {}&quot;&lt;/span&gt;.format(pathname))&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;\taddresses = {}&quot;&lt;/span&gt;.format(addr))&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;\tpermisions = {}&quot;&lt;/span&gt;.format(perm))&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;\toffset = {}&quot;&lt;/span&gt;.format(offset))&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;\tinode = {}&quot;&lt;/span&gt;.format(inode))&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# check if there is read and write permission&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; perm[0] != &lt;span&gt;&#x27;r&#x27;&lt;/span&gt; or perm[1] != &lt;span&gt;&#x27;w&#x27;&lt;/span&gt;:&lt;br/&gt;        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;[*] {} does not have read/write permission&quot;&lt;/span&gt;.format(pathname))&lt;br/&gt;        maps_file.close()&lt;br/&gt;        &lt;span&gt;exit&lt;/span&gt;(0)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# get start and end of the heap in the virtual memory&lt;/span&gt;&lt;br/&gt;    addr = addr.split(&lt;span&gt;&quot;-&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; len(addr) != 2: &lt;span&gt;# never trust anyone, not even your OS :)&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;[*] Wrong addr format&quot;&lt;/span&gt;)&lt;br/&gt;        maps_file.close()&lt;br/&gt;        &lt;span&gt;exit&lt;/span&gt;(1)&lt;br/&gt;    addr_start = int(addr[0], 16)&lt;br/&gt;    addr_end = int(addr[1], 16)&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;\tAddr start [{:x}] | end [{:x}]&quot;&lt;/span&gt;.format(addr_start, addr_end))&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# open and read mem&lt;/span&gt;&lt;br/&gt;    try:&lt;br/&gt;        mem_file = open(mem_filename, &lt;span&gt;&#x27;rb+&#x27;&lt;/span&gt;)&lt;br/&gt;    except IOError as e:&lt;br/&gt;        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;[ERROR] Can not open file {}:&quot;&lt;/span&gt;.format(mem_filename))&lt;br/&gt;        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;        I/O error({}): {}&quot;&lt;/span&gt;.format(e.errno, e.strerror))&lt;br/&gt;        maps_file.close()&lt;br/&gt;        &lt;span&gt;exit&lt;/span&gt;(1)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# read heap  &lt;/span&gt;&lt;br/&gt;    mem_file.seek(addr_start)&lt;br/&gt;    heap = mem_file.read(addr_end - addr_start)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# find string&lt;/span&gt;&lt;br/&gt;    try:&lt;br/&gt;        i = heap.index(bytes(search_string, &lt;span&gt;&quot;ASCII&quot;&lt;/span&gt;))&lt;br/&gt;    except Exception:&lt;br/&gt;        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;Can&#x27;t find &#x27;{}&#x27;&quot;&lt;/span&gt;.format(search_string))&lt;br/&gt;        maps_file.close()&lt;br/&gt;        mem_file.close()&lt;br/&gt;        &lt;span&gt;exit&lt;/span&gt;(0)&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;[*] Found &#x27;{}&#x27; at {:x}&quot;&lt;/span&gt;.format(search_string, i))&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# write the new string&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;[*] Writing &#x27;{}&#x27; at {:x}&quot;&lt;/span&gt;.format(write_string, addr_start + i))&lt;br/&gt;    mem_file.seek(addr_start + i)&lt;br/&gt;    mem_file.write(bytes(write_string, &lt;span&gt;&quot;ASCII&quot;&lt;/span&gt;))&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# close files&lt;/span&gt;&lt;br/&gt;    maps_file.close()&lt;br/&gt;    mem_file.close()&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# there is only one heap in our example&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行这个Python脚本&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;zjucad@zjucad-ONDA-H110-MINI-V3-01:~/wangzhiqiang$ sudo ./loop.py 2542 test_memory test_hello&lt;br/&gt;[*] maps: /proc/2542/maps&lt;br/&gt;[*] mem: /proc/2542/mem&lt;br/&gt;[*] Found [heap]:&lt;br/&gt;        pathname = [heap]&lt;br/&gt;        addresses = 021dc000-021fd000&lt;br/&gt;        permisions = rw-p&lt;br/&gt;        offset = 00000000&lt;br/&gt;        inode = 0&lt;br/&gt;        Addr start [21dc000] | end [21fd000]&lt;br/&gt;[*] Found &lt;span&gt;&#x27;test_memory&#x27;&lt;/span&gt; at 10&lt;br/&gt;[*] Writing &lt;span&gt;&#x27;test_hello&#x27;&lt;/span&gt; at 21dc010&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时字符串输出的内容也已更改&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;[633] test_memory (0x21dc010)&lt;br/&gt;[634] test_memory (0x21dc010)&lt;br/&gt;[635] test_memory (0x21dc010)&lt;br/&gt;[636] test_memory (0x21dc010)&lt;br/&gt;[637] test_memory (0x21dc010)&lt;br/&gt;[638] test_memory (0x21dc010)&lt;br/&gt;[639] test_memory (0x21dc010)&lt;br/&gt;[640] test_helloy (0x21dc010)&lt;br/&gt;[641] test_helloy (0x21dc010)&lt;br/&gt;[642] test_helloy (0x21dc010)&lt;br/&gt;[643] test_helloy (0x21dc010)&lt;br/&gt;[644] test_helloy (0x21dc010)&lt;br/&gt;[645] test_helloy (0x21dc010)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实验成功.&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;通过实践画出虚拟内存空间分布图&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再列出内存空间分布图&lt;br/&gt;&lt;img data-ratio=&quot;0.8752886836027713&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9lFFFiaKpEr8ZWrBt9SoqIMmdjw6L2WqPDeXpWzBLtqDpFkcHYS8ulT4v6R9XCScDia1en8bnkfJrEt6nnCbQ6Jg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;433&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基本上每个人或多或少都了解虚拟内存的空间分布，那如何验证它呢，下面会提到.&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;堆栈空间&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先验证栈空间的位置，我们都知道C中局部变量是存储在栈空间的，malloc分配的内存是存储在堆空间，所以可以通过打印出局部变量地址和malloc的返回内存地址的方式来验证堆栈空间在整个虚拟空间中的位置.&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;/**&lt;br/&gt; * main - &lt;span&gt;print&lt;/span&gt; locations of various elements&lt;br/&gt; *&lt;br/&gt; * Return: EXIT_FAILURE &lt;span&gt;if&lt;/span&gt; something failed. Otherwise EXIT_SUCCESS&lt;br/&gt; */&lt;br/&gt;int main(void)&lt;br/&gt;{&lt;br/&gt;    int a;&lt;br/&gt;    void *p;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;Address of a: %p\n&quot;&lt;/span&gt;, (void *)&amp;amp;a);&lt;br/&gt;    p = malloc(98);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (p == NULL)&lt;br/&gt;    {&lt;br/&gt;        fprintf(stderr, &lt;span&gt;&quot;Can&#x27;t malloc\n&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; (EXIT_FAILURE);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;Allocated space in the heap: %p\n&quot;&lt;/span&gt;, p);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; (EXIT_SUCCESS);&lt;br/&gt;}&lt;br/&gt;编译运行:gcc -Wall -Wextra -pedantic -Werror main.c -o &lt;span&gt;test&lt;/span&gt;; ./&lt;span&gt;test&lt;/span&gt;&lt;br/&gt;输出：&lt;br/&gt;Address of a: 0x7ffedde9c7fc&lt;br/&gt;Allocated space &lt;span&gt;in&lt;/span&gt; the heap: 0x55ca5b360670&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过结果可以看出堆地址空间在栈地址空间下面，整理如图:&lt;br/&gt;&lt;img data-ratio=&quot;1.0392609699769053&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9lFFFiaKpEr8ZWrBt9SoqIMmdjw6L2WqPYIYRBuic7Pn6fesfZicUzdJqj2UgnxyTZRro4m3FGicT8dRDYbr1d4b3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;433&quot;/&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可执行程序&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可执行程序也在虚拟内存中，可以通过打印main函数的地址，并与堆栈地址相比较，即可知道可执行程序地址相对于堆栈地址的分布.&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;/**&lt;br/&gt; * main - &lt;span&gt;print&lt;/span&gt; locations of various elements&lt;br/&gt; *&lt;br/&gt; * Return: EXIT_FAILURE &lt;span&gt;if&lt;/span&gt; something failed. Otherwise EXIT_SUCCESS&lt;br/&gt; */&lt;br/&gt;int main(void)&lt;br/&gt;{&lt;br/&gt;    int a;&lt;br/&gt;    void *p;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;Address of a: %p\n&quot;&lt;/span&gt;, (void *)&amp;amp;a);&lt;br/&gt;    p = malloc(98);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (p == NULL)&lt;br/&gt;    {&lt;br/&gt;        fprintf(stderr, &lt;span&gt;&quot;Can&#x27;t malloc\n&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; (EXIT_FAILURE);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;Allocated space in the heap: %p\n&quot;&lt;/span&gt;, p);&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;Address of function main: %p\n&quot;&lt;/span&gt;, (void *)main);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; (EXIT_SUCCESS);&lt;br/&gt;}&lt;br/&gt;编译运行:gcc main.c -o &lt;span&gt;test&lt;/span&gt;; ./&lt;span&gt;test&lt;/span&gt;&lt;br/&gt;输出：&lt;br/&gt;Address of a: 0x7ffed846de2c&lt;br/&gt;Allocated space &lt;span&gt;in&lt;/span&gt; the heap: 0x561b9ee8c670&lt;br/&gt;Address of &lt;span&gt;function&lt;/span&gt; main: 0x561b9deb378a&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于main(0x561b9deb378a) &amp;lt; heap(0x561b9ee8c670) &amp;lt; (0x7ffed846de2c)，可以画出分布图如下:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0392609699769053&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9lFFFiaKpEr8ZWrBt9SoqIMmdjw6L2WqPy4P6RORCspJLRFjPFiaqKYeLBiaNeRjJG0zA7uqvrR50wxfC9bAqz67g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;433&quot;/&gt;&lt;figcaption&gt;virtual_memory_stack_heap_executable.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;命令行参数和环境变量&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序入口main函数可以携带参数:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一个参数(argc): 命令行参数的个数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二个参数(argv): 指向命令行参数数组的指针&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第三个参数(env): 指向环境变量数组的指针&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过程序可以看见这些元素在虚拟内存中的位置：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;/**&lt;br/&gt; * main - &lt;span&gt;print&lt;/span&gt; locations of various elements&lt;br/&gt; *&lt;br/&gt; * Return: EXIT_FAILURE &lt;span&gt;if&lt;/span&gt; something failed. Otherwise EXIT_SUCCESS&lt;br/&gt; */&lt;br/&gt;int main(int ac, char **av, char **env)&lt;br/&gt;{&lt;br/&gt;        int a;&lt;br/&gt;        void *p;&lt;br/&gt;        int i;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;Address of a: %p\n&quot;&lt;/span&gt;, (void *)&amp;amp;a);&lt;br/&gt;        p = malloc(98);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (p == NULL)&lt;br/&gt;        {&lt;br/&gt;                fprintf(stderr, &lt;span&gt;&quot;Can&#x27;t malloc\n&quot;&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; (EXIT_FAILURE);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;Allocated space in the heap: %p\n&quot;&lt;/span&gt;, p);&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;Address of function main: %p\n&quot;&lt;/span&gt;, (void *)main);&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;First bytes of the main function:\n\t&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; 15; i++)&lt;br/&gt;        {&lt;br/&gt;                &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;%02x &quot;&lt;/span&gt;, ((unsigned char *)main)[i]);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;\n&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;Address of the array of arguments: %p\n&quot;&lt;/span&gt;, (void *)av);&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;Addresses of the arguments:\n\t&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; ac; i++)&lt;br/&gt;        {&lt;br/&gt;                &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;[%s]:%p &quot;&lt;/span&gt;, av[i], av[i]);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;\n&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;Address of the array of environment variables: %p\n&quot;&lt;/span&gt;, (void *)env);&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;Address of the first environment variable: %p\n&quot;&lt;/span&gt;, (void *)(env[0]));&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; (EXIT_SUCCESS);&lt;br/&gt;}&lt;br/&gt;编译运行:gcc main.c -o &lt;span&gt;test&lt;/span&gt;; ./&lt;span&gt;test&lt;/span&gt; nihao hello&lt;br/&gt;输出：&lt;br/&gt;Address of a: 0x7ffcc154a748&lt;br/&gt;Allocated space &lt;span&gt;in&lt;/span&gt; the heap: 0x559bd1bee670&lt;br/&gt;Address of &lt;span&gt;function&lt;/span&gt; main: 0x559bd09807ca&lt;br/&gt;First bytes of the main &lt;span&gt;function&lt;/span&gt;:&lt;br/&gt;        55 48 89 e5 48 83 ec 40 89 7d dc 48 89 75 d0&lt;br/&gt;Address of the array of arguments: 0x7ffcc154a848&lt;br/&gt;Addresses of the arguments:&lt;br/&gt;        [./&lt;span&gt;test&lt;/span&gt;]:0x7ffcc154b94f [nihao]:0x7ffcc154b956 [hello]:0x7ffcc154b95c&lt;br/&gt;Address of the array of environment variables: 0x7ffcc154a868&lt;br/&gt;Address of the first environment variable: 0x7ffcc154b962&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结果如下：&lt;br/&gt;main(0x559bd09807ca) &amp;lt; heap(0x559bd1bee670) &amp;lt; stack(0x7ffcc154a748) &amp;lt; argv(0x7ffcc154a848) &amp;lt; env(0x7ffcc154a868) &amp;lt; arguments(0x7ffcc154b94f-&amp;gt;0x7ffcc154b95c + 6)(6为hello+1(&#x27;\0&#x27;)) &amp;lt; env first(0x7ffcc154b962)&lt;br/&gt;可以看出所有的命令行参数都是相邻的，并且紧接着就是环境变量.&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;argv和env数组地址是相邻的吗&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上例中argv有4个元素，命令行中有三个参数，还有一个NULL指向标记数组的末尾，每个指针是8字节，8*4=32, argv(0x7ffcc154a848) + 32(0x20) = env(0x7ffcc154a868)，所以argv和env数组指针是相邻的.&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;命令行参数地址紧随环境变量地址之后吗&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先需要获取环境变量数组的大小，环境变量数组是以NULL结束的，所以可以遍历env数组，检查是否为NULL，获取数组大小，代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;/**                                                                                                      &lt;br/&gt; * main - &lt;span&gt;print&lt;/span&gt; locations of various elements                                                            &lt;br/&gt; *                                                                                                       &lt;br/&gt; * Return: EXIT_FAILURE &lt;span&gt;if&lt;/span&gt; something failed. Otherwise EXIT_SUCCESS                                      &lt;br/&gt; */&lt;br/&gt;int main(int ac, char **av, char **env)&lt;br/&gt;{&lt;br/&gt;     int a;&lt;br/&gt;     void *p;&lt;br/&gt;     int i;&lt;br/&gt;     int size;&lt;br/&gt;&lt;br/&gt;     &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;Address of a: %p\n&quot;&lt;/span&gt;, (void *)&amp;amp;a);&lt;br/&gt;     p = malloc(98);&lt;br/&gt;     &lt;span&gt;if&lt;/span&gt; (p == NULL)&lt;br/&gt;     {&lt;br/&gt;          fprintf(stderr, &lt;span&gt;&quot;Can&#x27;t malloc\n&quot;&lt;/span&gt;);&lt;br/&gt;          &lt;span&gt;return&lt;/span&gt; (EXIT_FAILURE);&lt;br/&gt;     }&lt;br/&gt;     &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;Allocated space in the heap: %p\n&quot;&lt;/span&gt;, p);&lt;br/&gt;     &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;Address of function main: %p\n&quot;&lt;/span&gt;, (void *)main);&lt;br/&gt;     &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;First bytes of the main function:\n\t&quot;&lt;/span&gt;);&lt;br/&gt;     &lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; 15; i++)&lt;br/&gt;     {&lt;br/&gt;          &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;%02x &quot;&lt;/span&gt;, ((unsigned char *)main)[i]);&lt;br/&gt;     }&lt;br/&gt;     &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;\n&quot;&lt;/span&gt;);&lt;br/&gt;     &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;Address of the array of arguments: %p\n&quot;&lt;/span&gt;, (void *)av);&lt;br/&gt;     &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;Addresses of the arguments:\n\t&quot;&lt;/span&gt;);&lt;br/&gt;     &lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; ac; i++)&lt;br/&gt;     {&lt;br/&gt;          &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;[%s]:%p &quot;&lt;/span&gt;, av[i], av[i]);&lt;br/&gt;     }&lt;br/&gt;     &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;\n&quot;&lt;/span&gt;);&lt;br/&gt;     &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;Address of the array of environment variables: %p\n&quot;&lt;/span&gt;, (void *)env);&lt;br/&gt;     &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;Address of the first environment variables:\n&quot;&lt;/span&gt;);&lt;br/&gt;     &lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; 3; i++)&lt;br/&gt;     {&lt;br/&gt;          &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;\t[%p]:\&quot;%s\&quot;\n&quot;&lt;/span&gt;, env[i], env[i]);&lt;br/&gt;     }&lt;br/&gt;     /* size of the env array */&lt;br/&gt;     i = 0;&lt;br/&gt;     &lt;span&gt;while&lt;/span&gt; (env[i] != NULL)&lt;br/&gt;     {&lt;br/&gt;          i++;&lt;br/&gt;     }&lt;br/&gt;     i++; /* the NULL pointer */&lt;br/&gt;     size = i * sizeof(char *);&lt;br/&gt;     &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;Size of the array env: %d elements -&amp;gt; %d bytes (0x%x)\n&quot;&lt;/span&gt;, i, size, size);&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; (EXIT_SUCCESS);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;编译运行:gcc main.c -o &lt;span&gt;test&lt;/span&gt;; ./&lt;span&gt;test&lt;/span&gt; nihao hello&lt;br/&gt;输出：&lt;br/&gt;Address of a: 0x7ffd5ebadff4&lt;br/&gt;Allocated space &lt;span&gt;in&lt;/span&gt; the heap: 0x562ba4e13670&lt;br/&gt;Address of &lt;span&gt;function&lt;/span&gt; main: 0x562ba2f1881a&lt;br/&gt;First bytes of the main &lt;span&gt;function&lt;/span&gt;:&lt;br/&gt;        55 48 89 e5 48 83 ec 40 89 7d dc 48 89 75 d0&lt;br/&gt;Address of the array of arguments: 0x7ffd5ebae0f8&lt;br/&gt;Addresses of the arguments:&lt;br/&gt;        [./&lt;span&gt;test&lt;/span&gt;]:0x7ffd5ebae94f [nihao]:0x7ffd5ebae956 [hello]:0x7ffd5ebae95c&lt;br/&gt;Address of the array of environment variables: 0x7ffd5ebae118&lt;br/&gt;Address of the first environment variables:&lt;br/&gt;        [0x7ffd5ebae962]:&lt;span&gt;&quot;LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:&quot;&lt;/span&gt;&lt;br/&gt;        [0x7ffd5ebaef4e]:&lt;span&gt;&quot;HOSTNAME=3e8650948c0c&quot;&lt;/span&gt;&lt;br/&gt;        [0x7ffd5ebaef64]:&lt;span&gt;&quot;OLDPWD=/&quot;&lt;/span&gt;&lt;br/&gt;Size of the array env: 11 elements -&amp;gt; 88 bytes (0x58)&lt;br/&gt;&lt;br/&gt;运算结果如下：&lt;br/&gt;root@3e8650948c0c:/ubuntu&lt;span&gt;# bc&lt;/span&gt;&lt;br/&gt;bc 1.07.1&lt;br/&gt;Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006, 2008, 2012-2017 Free Software Foundation, Inc.&lt;br/&gt;This is free software with ABSOLUTELY NO WARRANTY.&lt;br/&gt;For details &lt;span&gt;type&lt;/span&gt; `warranty&lt;span&gt;&#x27;.&lt;br/&gt;obase=16&lt;br/&gt;ibase=16&lt;br/&gt;58+7ffd5ebae118&lt;br/&gt;(standard_in) 3: syntax error&lt;br/&gt;58+7FFD5EBAE118&lt;br/&gt;7FFD5EBAE170&lt;br/&gt;quit&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过结果可知7FFD5EBAE170 != 0x7ffd5ebae94f，所以命令行参数地址不是紧随环境变量地址之后。&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;截至目前画出图表如下：&lt;br/&gt;&lt;img data-ratio=&quot;1.0392609699769053&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9lFFFiaKpEr8ZWrBt9SoqIMmdjw6L2WqPtJ2QKexupKQztkaJGYkk4MZVN0f711e9kfDdWuRXVH59D1Tsuic1nLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;433&quot;/&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;栈内存真的向下增长吗&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过调用函数来确认，如果真的是向下增长，那么调用函数的地址应该高于被调用函数地址, 代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;void f(void)&lt;br/&gt;{&lt;br/&gt;     int a;&lt;br/&gt;     int b;&lt;br/&gt;     int c;&lt;br/&gt;&lt;br/&gt;     a = 98;&lt;br/&gt;     b = 1024;&lt;br/&gt;     c = a * b;&lt;br/&gt;     &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;[f] a = %d, b = %d, c = a * b = %d\n&quot;&lt;/span&gt;, a, b, c);&lt;br/&gt;     &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;[f] Adresses of a: %p, b = %p, c = %p\n&quot;&lt;/span&gt;, (void *)&amp;amp;a, (void *)&amp;amp;b, (void *)&amp;amp;c);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;int main(int ac, char **av, char **env)&lt;br/&gt;{&lt;br/&gt;     int a;&lt;br/&gt;     void *p;&lt;br/&gt;     int i;&lt;br/&gt;     int size;&lt;br/&gt;&lt;br/&gt;     &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;Address of a: %p\n&quot;&lt;/span&gt;, (void *)&amp;amp;a);&lt;br/&gt;     p = malloc(98);&lt;br/&gt;     &lt;span&gt;if&lt;/span&gt; (p == NULL)&lt;br/&gt;     {&lt;br/&gt;          fprintf(stderr, &lt;span&gt;&quot;Can&#x27;t malloc\n&quot;&lt;/span&gt;);&lt;br/&gt;          &lt;span&gt;return&lt;/span&gt; (EXIT_FAILURE);&lt;br/&gt;     }&lt;br/&gt;     &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;Allocated space in the heap: %p\n&quot;&lt;/span&gt;, p);&lt;br/&gt;     &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;Address of function main: %p\n&quot;&lt;/span&gt;, (void *)main);&lt;br/&gt;     f();&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; (EXIT_SUCCESS);&lt;br/&gt;}&lt;br/&gt;编译运行:gcc main.c -o &lt;span&gt;test&lt;/span&gt;; ./&lt;span&gt;test&lt;/span&gt;&lt;br/&gt;输出：&lt;br/&gt;Address of a: 0x7ffefc75083c&lt;br/&gt;Allocated space &lt;span&gt;in&lt;/span&gt; the heap: 0x564d46318670&lt;br/&gt;Address of &lt;span&gt;function&lt;/span&gt; main: 0x564d45b9880e&lt;br/&gt;[f] a = 98, b = 1024, c = a * b = 100352&lt;br/&gt;[f] Adresses of a: 0x7ffefc7507ec, b = 0x7ffefc7507f0, c = 0x7ffefc7507f4&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结果可知: f{a} 0x7ffefc7507ec &amp;lt; main{a} 0x7ffefc75083c&lt;br/&gt;可画图如下：&lt;br/&gt;&lt;img data-ratio=&quot;1.0392609699769053&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9lFFFiaKpEr8ZWrBt9SoqIMmdjw6L2WqPAqIqGjw2icLSic85QJUdU3If9WC9XsGpTf4I5RoOngLKNDU7aq1GMSHg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;433&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实也可以写一个简单的代码，通过查看/proc文件系统中map内容来查看内存分布，这里就不举例啦.&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;堆内存(malloc)&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;malloc&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;malloc是常用的动态分配内存的函数，malloc申请的内存分配在堆中，注意malloc是glibc函数，不是系统调用.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;man malloc:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;[...] allocate dynamic memory[...]&lt;br/&gt;void *malloc(size_t size);&lt;br/&gt;[...]&lt;br/&gt;The malloc() &lt;span&gt;function&lt;/span&gt; allocates size bytes and returns a pointer to the allocated memory.&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不调用malloc，就不会有堆空间[heap]&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看一段不调用malloc的代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;/**&lt;br/&gt; * main - &lt;span&gt;do&lt;/span&gt; nothing&lt;br/&gt; *&lt;br/&gt; * Return: EXIT_FAILURE &lt;span&gt;if&lt;/span&gt; something failed. Otherwise EXIT_SUCCESS&lt;br/&gt; */&lt;br/&gt;int main(void)&lt;br/&gt;{&lt;br/&gt;    getchar();&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; (EXIT_SUCCESS);&lt;br/&gt;}&lt;br/&gt;编译运行：gcc test.c -o 2; ./2&lt;br/&gt;step 1 : ps aux | grep \ \./2$&lt;br/&gt;输出：&lt;br/&gt;zjucad    3023  0.0  0.0   4352   788 pts/3    S+   13:58   0:00 ./2&lt;br/&gt;step 2 : /proc/3023/maps&lt;br/&gt;输出：&lt;br/&gt;00400000-00401000 r-xp 00000000 08:01 811723                             /home/zjucad/wangzhiqiang/2&lt;br/&gt;00600000-00601000 r--p 00000000 08:01 811723                             /home/zjucad/wangzhiqiang/2&lt;br/&gt;00601000-00602000 rw-p 00001000 08:01 811723                             /home/zjucad/wangzhiqiang/2&lt;br/&gt;007a4000-007c5000 rw-p 00000000 00:00 0                                  [heap]&lt;br/&gt;7f954ca02000-7f954cbc2000 r-xp 00000000 08:01 8661324                    /lib/x86_64-linux-gnu/libc-2.23.so&lt;br/&gt;7f954cbc2000-7f954cdc2000 ---p 001c0000 08:01 8661324                    /lib/x86_64-linux-gnu/libc-2.23.so&lt;br/&gt;7f954cdc2000-7f954cdc6000 r--p 001c0000 08:01 8661324                    /lib/x86_64-linux-gnu/libc-2.23.so&lt;br/&gt;7f954cdc6000-7f954cdc8000 rw-p 001c4000 08:01 8661324                    /lib/x86_64-linux-gnu/libc-2.23.so&lt;br/&gt;7f954cdc8000-7f954cdcc000 rw-p 00000000 00:00 0&lt;br/&gt;7f954cdcc000-7f954cdf2000 r-xp 00000000 08:01 8661310                    /lib/x86_64-linux-gnu/ld-2.23.so&lt;br/&gt;7f954cfd2000-7f954cfd5000 rw-p 00000000 00:00 0&lt;br/&gt;7f954cff1000-7f954cff2000 r--p 00025000 08:01 8661310                    /lib/x86_64-linux-gnu/ld-2.23.so&lt;br/&gt;7f954cff2000-7f954cff3000 rw-p 00026000 08:01 8661310                    /lib/x86_64-linux-gnu/ld-2.23.so&lt;br/&gt;7f954cff3000-7f954cff4000 rw-p 00000000 00:00 0&lt;br/&gt;7ffed68a1000-7ffed68c2000 rw-p 00000000 00:00 0                          [stack]&lt;br/&gt;7ffed690e000-7ffed6911000 r--p 00000000 00:00 0                          [vvar]&lt;br/&gt;7ffed6911000-7ffed6913000 r-xp 00000000 00:00 0                          [vdso]&lt;br/&gt;ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，如果不调用malloc，maps中就没有[heap]&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面运行一个带有malloc的程序&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;/**&lt;br/&gt; * main - prints the malloc returned address&lt;br/&gt; *&lt;br/&gt; * Return: EXIT_FAILURE &lt;span&gt;if&lt;/span&gt; something failed. Otherwise EXIT_SUCCESS&lt;br/&gt; */&lt;br/&gt;int main(void)&lt;br/&gt;{&lt;br/&gt;    void *p;&lt;br/&gt;&lt;br/&gt;    p = malloc(1);&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;%p\n&quot;&lt;/span&gt;, p);&lt;br/&gt;    getchar();&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; (EXIT_SUCCESS);&lt;br/&gt;}&lt;br/&gt;编译运行：gcc test.c -o 3; ./3&lt;br/&gt;输出：0xcc7010&lt;br/&gt;验证步骤及输出：&lt;br/&gt;zjucad@zjucad-ONDA-H110-MINI-V3-01:~/wangzhiqiang$ ps aux | grep \ \./3$&lt;br/&gt;zjucad    3113  0.0  0.0   4352   644 pts/3    S+   14:06   0:00 ./3&lt;br/&gt;zjucad@zjucad-ONDA-H110-MINI-V3-01:~/wangzhiqiang$ cat /proc/3113/maps&lt;br/&gt;00400000-00401000 r-xp 00000000 08:01 811726                             /home/zjucad/wangzhiqiang/3&lt;br/&gt;00600000-00601000 r--p 00000000 08:01 811726                             /home/zjucad/wangzhiqiang/3&lt;br/&gt;00601000-00602000 rw-p 00001000 08:01 811726                             /home/zjucad/wangzhiqiang/3&lt;br/&gt;00cc7000-00ce8000 rw-p 00000000 00:00 0                                  [heap]&lt;br/&gt;7fc7e9128000-7fc7e92e8000 r-xp 00000000 08:01 8661324                    /lib/x86_64-linux-gnu/libc-2.23.so&lt;br/&gt;7fc7e92e8000-7fc7e94e8000 ---p 001c0000 08:01 8661324                    /lib/x86_64-linux-gnu/libc-2.23.so&lt;br/&gt;7fc7e94e8000-7fc7e94ec000 r--p 001c0000 08:01 8661324                    /lib/x86_64-linux-gnu/libc-2.23.so&lt;br/&gt;7fc7e94ec000-7fc7e94ee000 rw-p 001c4000 08:01 8661324                    /lib/x86_64-linux-gnu/libc-2.23.so&lt;br/&gt;7fc7e94ee000-7fc7e94f2000 rw-p 00000000 00:00 0&lt;br/&gt;7fc7e94f2000-7fc7e9518000 r-xp 00000000 08:01 8661310                    /lib/x86_64-linux-gnu/ld-2.23.so&lt;br/&gt;7fc7e96f8000-7fc7e96fb000 rw-p 00000000 00:00 0&lt;br/&gt;7fc7e9717000-7fc7e9718000 r--p 00025000 08:01 8661310                    /lib/x86_64-linux-gnu/ld-2.23.so&lt;br/&gt;7fc7e9718000-7fc7e9719000 rw-p 00026000 08:01 8661310                    /lib/x86_64-linux-gnu/ld-2.23.so&lt;br/&gt;7fc7e9719000-7fc7e971a000 rw-p 00000000 00:00 0&lt;br/&gt;7ffc91c18000-7ffc91c39000 rw-p 00000000 00:00 0                          [stack]&lt;br/&gt;7ffc91d5f000-7ffc91d62000 r--p 00000000 00:00 0                          [vvar]&lt;br/&gt;7ffc91d62000-7ffc91d64000 r-xp 00000000 00:00 0                          [vdso]&lt;br/&gt;ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序中带有malloc，那maps中就有[heap]段，并且malloc返回的地址在heap的地址段中，但是返回的地址却不再heap的最开始地址上，相差了0x10字节，为什么呢?看下面：&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;strace, brk, sbrk&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;malloc不是系统调用，它是一个正常函数，它必须调用某些系统调用才可以操作堆内存，通过使用strace工具可以追踪进程的系统调用和信号，为了确认系统调用是malloc产生的，所以在malloc前后添加write系统调用方便定位问题。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;/**&lt;br/&gt; * main - &lt;span&gt;let&lt;/span&gt;&lt;span&gt;&#x27;s find out which syscall malloc is using&lt;br/&gt; *&lt;br/&gt; * Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS&lt;br/&gt; */&lt;br/&gt;int main(void)&lt;br/&gt;{&lt;br/&gt;    void *p;&lt;br/&gt;&lt;br/&gt;    write(1, &quot;BEFORE MALLOC\n&quot;, 14);&lt;br/&gt;    p = malloc(1);&lt;br/&gt;    write(1, &quot;AFTER MALLOC\n&quot;, 13);&lt;br/&gt;    printf(&quot;%p\n&quot;, p);&lt;br/&gt;    getchar();&lt;br/&gt;    return (EXIT_SUCCESS);&lt;br/&gt;}&lt;br/&gt;编译运行：gcc test.c -o 4&lt;br/&gt;zjucad@zjucad-ONDA-H110-MINI-V3-01:~/wangzhiqiang$ strace ./4&lt;br/&gt;execve(&quot;./4&quot;, [&quot;./4&quot;], [/* 34 vars */]) = 0&lt;br/&gt;brk(NULL)                               = 0x781000&lt;br/&gt;access(&quot;/etc/ld.so.nohwcap&quot;, F_OK)      = -1 ENOENT (No such file or directory)&lt;br/&gt;access(&quot;/etc/ld.so.preload&quot;, R_OK)      = -1 ENOENT (No such file or directory)&lt;br/&gt;open(&quot;/etc/ld.so.cache&quot;, O_RDONLY|O_CLOEXEC) = 3&lt;br/&gt;fstat(3, {st_mode=S_IFREG|0644, st_size=111450, ...}) = 0&lt;br/&gt;mmap(NULL, 111450, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f37720fa000&lt;br/&gt;close(3)                                = 0&lt;br/&gt;access(&quot;/etc/ld.so.nohwcap&quot;, F_OK)      = -1 ENOENT (No such file or directory)&lt;br/&gt;open(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;, O_RDONLY|O_CLOEXEC) = 3&lt;br/&gt;read(3, &quot;\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&amp;gt;\0\1\0\0\0P\t\2\0\0\0\0\0&quot;..., 832) = 832&lt;br/&gt;fstat(3, {st_mode=S_IFREG|0755, st_size=1868984, ...}) = 0&lt;br/&gt;mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f37720f9000&lt;br/&gt;mmap(NULL, 3971488, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f3771b27000&lt;br/&gt;mprotect(0x7f3771ce7000, 2097152, PROT_NONE) = 0&lt;br/&gt;mmap(0x7f3771ee7000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1c0000) = 0x7f3771ee7000&lt;br/&gt;mmap(0x7f3771eed000, 14752, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f3771eed000&lt;br/&gt;close(3)                                = 0&lt;br/&gt;mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f37720f8000&lt;br/&gt;mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f37720f7000&lt;br/&gt;arch_prctl(ARCH_SET_FS, 0x7f37720f8700) = 0&lt;br/&gt;mprotect(0x7f3771ee7000, 16384, PROT_READ) = 0&lt;br/&gt;mprotect(0x600000, 4096, PROT_READ)     = 0&lt;br/&gt;mprotect(0x7f3772116000, 4096, PROT_READ) = 0&lt;br/&gt;munmap(0x7f37720fa000, 111450)          = 0&lt;br/&gt;write(1, &quot;BEFORE MALLOC\n&quot;, 14BEFORE MALLOC&lt;br/&gt;)         = 14&lt;br/&gt;brk(NULL)                               = 0x781000&lt;br/&gt;brk(0x7a2000)                           = 0x7a2000&lt;br/&gt;write(1, &quot;AFTER MALLOC\n&quot;, 13AFTER MALLOC&lt;br/&gt;)          = 13&lt;br/&gt;fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 3), ...}) = 0&lt;br/&gt;write(1, &quot;0x781010\n&quot;, 90x781010&lt;br/&gt;)               = 9&lt;br/&gt;fstat(0, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 3), ...}) = 0&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后几行的输出可知，malloc主要调用brk系统调用来操作堆内存.&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;man brk&lt;br/&gt;...&lt;br/&gt;       int brk(void *addr);&lt;br/&gt;       void *sbrk(intptr_t increment);&lt;br/&gt;...&lt;br/&gt;DESCRIPTION&lt;br/&gt;       brk() and sbrk() change the location of the program  &lt;span&gt;break&lt;/span&gt;,  &lt;span&gt;which&lt;/span&gt;  defines&lt;br/&gt;       the end of the process&lt;span&gt;&#x27;s data segment (i.e., the program break is the first&lt;br/&gt;       location after the end of the uninitialized data segment).  Increasing  the&lt;br/&gt;       program  break has the effect of allocating memory to the process; decreas‐&lt;br/&gt;       ing the break deallocates memory.&lt;br/&gt;&lt;br/&gt;       brk() sets the end of the data segment to the value specified by addr, when&lt;br/&gt;       that  value  is  reasonable,  the system has enough memory, and the process&lt;br/&gt;       does not exceed its maximum data size (see setrlimit(2)).&lt;br/&gt;&lt;br/&gt;       sbrk() increments the program&#x27;&lt;/span&gt;s data space  by  increment  bytes.   Calling&lt;br/&gt;       sbrk()  with  an increment of 0 can be used to find the current location of&lt;br/&gt;       the program &lt;span&gt;break&lt;/span&gt;.&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序中断是虚拟内存中程序数据段结束后的第一个位置的地址，malloc通过调用brk或者sbrk，增加程序中断的值就可以创建新空间来动态分配内存，首次调用brk会返回当前程序中断的地址，第二次调用brk也会返回程序中断的地址，可以发现第二次brk返回地址大于第一次brk返回地址，brk就是通过增加程序中断地址的方式来分配内存，可以看出现在的堆地址范围是0x781000-0x7a2000，通过cat /proc/[pid]/maps也可以验证，此处就不贴上实际验证的结果啦。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;多次malloc&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果多次malloc会出现什么现象呢，代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;/**&lt;br/&gt; * main - many calls to malloc&lt;br/&gt; *&lt;br/&gt; * Return: EXIT_FAILURE &lt;span&gt;if&lt;/span&gt; something failed. Otherwise EXIT_SUCCESS&lt;br/&gt; */&lt;br/&gt;int main(void)&lt;br/&gt;{&lt;br/&gt;    void *p;&lt;br/&gt;&lt;br/&gt;    write(1, &lt;span&gt;&quot;BEFORE MALLOC #0\n&quot;&lt;/span&gt;, 17);&lt;br/&gt;    p = malloc(1024);&lt;br/&gt;    write(1, &lt;span&gt;&quot;AFTER MALLOC #0\n&quot;&lt;/span&gt;, 16);&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;%p\n&quot;&lt;/span&gt;, p);&lt;br/&gt;&lt;br/&gt;    write(1, &lt;span&gt;&quot;BEFORE MALLOC #1\n&quot;&lt;/span&gt;, 17);&lt;br/&gt;    p = malloc(1024);&lt;br/&gt;    write(1, &lt;span&gt;&quot;AFTER MALLOC #1\n&quot;&lt;/span&gt;, 16);&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;%p\n&quot;&lt;/span&gt;, p);&lt;br/&gt;&lt;br/&gt;    write(1, &lt;span&gt;&quot;BEFORE MALLOC #2\n&quot;&lt;/span&gt;, 17);&lt;br/&gt;    p = malloc(1024);&lt;br/&gt;    write(1, &lt;span&gt;&quot;AFTER MALLOC #2\n&quot;&lt;/span&gt;, 16);&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;%p\n&quot;&lt;/span&gt;, p);&lt;br/&gt;&lt;br/&gt;    write(1, &lt;span&gt;&quot;BEFORE MALLOC #3\n&quot;&lt;/span&gt;, 17);&lt;br/&gt;    p = malloc(1024);&lt;br/&gt;    write(1, &lt;span&gt;&quot;AFTER MALLOC #3\n&quot;&lt;/span&gt;, 16);&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;%p\n&quot;&lt;/span&gt;, p);&lt;br/&gt;&lt;br/&gt;    getchar();&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; (EXIT_SUCCESS);&lt;br/&gt;}&lt;br/&gt;编译运行：gcc test.c -o 5; strace ./5&lt;br/&gt;摘要输出结果如下：&lt;br/&gt;write(1, &lt;span&gt;&quot;BEFORE MALLOC #0\n&quot;&lt;/span&gt;, 17BEFORE MALLOC &lt;span&gt;#0&lt;/span&gt;&lt;br/&gt;)      = 17&lt;br/&gt;brk(NULL)                               = 0x561605c7a000&lt;br/&gt;brk(0x561605c9b000)                     = 0x561605c9b000&lt;br/&gt;write(1, &lt;span&gt;&quot;AFTER MALLOC #0\n&quot;&lt;/span&gt;, 16AFTER MALLOC &lt;span&gt;#0&lt;/span&gt;&lt;br/&gt;)       = 16&lt;br/&gt;fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 0), ...}) = 0&lt;br/&gt;write(1, &lt;span&gt;&quot;0x561605c7a260\n&quot;&lt;/span&gt;, 150x561605c7a260&lt;br/&gt;)        = 15&lt;br/&gt;write(1, &lt;span&gt;&quot;BEFORE MALLOC #1\n&quot;&lt;/span&gt;, 17BEFORE MALLOC &lt;span&gt;#1&lt;/span&gt;&lt;br/&gt;)      = 17&lt;br/&gt;write(1, &lt;span&gt;&quot;AFTER MALLOC #1\n&quot;&lt;/span&gt;, 16AFTER MALLOC &lt;span&gt;#1&lt;/span&gt;&lt;br/&gt;)       = 16&lt;br/&gt;write(1, &lt;span&gt;&quot;0x561605c7aa80\n&quot;&lt;/span&gt;, 150x561605c7aa80&lt;br/&gt;)        = 15&lt;br/&gt;write(1, &lt;span&gt;&quot;BEFORE MALLOC #2\n&quot;&lt;/span&gt;, 17BEFORE MALLOC &lt;span&gt;#2&lt;/span&gt;&lt;br/&gt;)      = 17&lt;br/&gt;write(1, &lt;span&gt;&quot;AFTER MALLOC #2\n&quot;&lt;/span&gt;, 16AFTER MALLOC &lt;span&gt;#2&lt;/span&gt;&lt;br/&gt;)       = 16&lt;br/&gt;write(1, &lt;span&gt;&quot;0x561605c7ae90\n&quot;&lt;/span&gt;, 150x561605c7ae90&lt;br/&gt;)        = 15&lt;br/&gt;write(1, &lt;span&gt;&quot;BEFORE MALLOC #3\n&quot;&lt;/span&gt;, 17BEFORE MALLOC &lt;span&gt;#3&lt;/span&gt;&lt;br/&gt;)      = 17&lt;br/&gt;write(1, &lt;span&gt;&quot;AFTER MALLOC #3\n&quot;&lt;/span&gt;, 16AFTER MALLOC &lt;span&gt;#3&lt;/span&gt;&lt;br/&gt;)       = 16&lt;br/&gt;write(1, &lt;span&gt;&quot;0x561605c7b2a0\n&quot;&lt;/span&gt;, 150x561605c7b2a0&lt;br/&gt;)        = 15&lt;br/&gt;fstat(0, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 0), ...}) = 0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以发现并不是每次调用malloc都会触发brk系统调用，首次调用malloc，内部会通过brk系统调用更改程序中断地址，分配出一大块内存空间，后续再调用malloc，malloc内部会优先使用之前分配出来的内存空间，直到内部内存空间已经不够再次分配给外部时才会再次触发brk系统调用.&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;0x10 那丢失的16字节是什么&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面分析可以看见程序第一次调用malloc返回的地址并不是heap段的首地址，而是相差了0x10个字节，那这16个字节究竟是什么，可以通过程序打印出这前16个字节的内容.&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;编译运行：gcc test.c -o &lt;span&gt;test&lt;/span&gt;;./&lt;span&gt;test&lt;/span&gt;&lt;br/&gt;输出：&lt;br/&gt;0x5589436ce260&lt;br/&gt;bytes at 0x5589436ce250:&lt;br/&gt;00 00 00 00 00 00 00 00 11 04 00 00 00 00 00 00&lt;br/&gt;0x5589436cea80&lt;br/&gt;bytes at 0x5589436cea70:&lt;br/&gt;00 00 00 00 00 00 00 00 11 08 00 00 00 00 00 00&lt;br/&gt;0x5589436cf290&lt;br/&gt;bytes at 0x5589436cf280:&lt;br/&gt;00 00 00 00 00 00 00 00 11 0c 00 00 00 00 00 00&lt;br/&gt;0x5589436cfea0&lt;br/&gt;bytes at 0x5589436cfe90:&lt;br/&gt;00 00 00 00 00 00 00 00 11 10 00 00 00 00 00 00&lt;br/&gt;0x5589436d0eb0&lt;br/&gt;bytes at 0x5589436d0ea0:&lt;br/&gt;00 00 00 00 00 00 00 00 11 14 00 00 00 00 00 00&lt;br/&gt;0x5589436d22c0&lt;br/&gt;bytes at 0x5589436d22b0:&lt;br/&gt;00 00 00 00 00 00 00 00 11 18 00 00 00 00 00 00&lt;br/&gt;0x5589436d3ad0&lt;br/&gt;bytes at 0x5589436d3ac0:&lt;br/&gt;00 00 00 00 00 00 00 00 11 1c 00 00 00 00 00 00&lt;br/&gt;0x5589436d56e0&lt;br/&gt;bytes at 0x5589436d56d0:&lt;br/&gt;00 00 00 00 00 00 00 00 11 20 00 00 00 00 00 00&lt;br/&gt;0x5589436d76f0&lt;br/&gt;bytes at 0x5589436d76e0:&lt;br/&gt;00 00 00 00 00 00 00 00 11 24 00 00 00 00 00 00&lt;br/&gt;0x5589436d9b00&lt;br/&gt;bytes at 0x5589436d9af0:&lt;br/&gt;00 00 00 00 00 00 00 00 11 28 00 00 00 00 00 00&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看出规律：这16个字节相当于malloc出来的地址的头，包含一些信息，目前可以看出它包括已经分配的地址空间的大小，第一次malloc申请了0x400(1024)字节，可以发现11 04 00 00 00 00 00 00大于0x400(1024)，这8个字节表示数字 0x 00 00 00 00 00 00 04 11 = 0x400(1024) + 0x10(头的大小16) + 1(后面会说明它的含义)，可以发现每次调用malloc，这前8个字节代表的含义都是malloc字节数+16+1.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;可以猜测，malloc内部会把这前16个字节强转成某种数据结构，数据结构包含某些信息，最主要的是已经分配的字节数，尽管我们不了解具体结构，但是也可以通过代码操作这16个字节验证我们上面总结的规律是否正确，注意代码中不调用free释放内存.&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;/**                                                                &lt;br/&gt; * pmem - &lt;span&gt;print&lt;/span&gt; mem                                                &lt;br/&gt; * @p: memory address to start printing from                       &lt;br/&gt; * @bytes: number of bytes to &lt;span&gt;print&lt;/span&gt;                                &lt;br/&gt; *                                                                 &lt;br/&gt; * Return: nothing&lt;br/&gt; */&lt;br/&gt;void pmem(void *p, unsigned int bytes)&lt;br/&gt;{&lt;br/&gt;    unsigned char *ptr;&lt;br/&gt;    unsigned int i;&lt;br/&gt;&lt;br/&gt;    ptr = (unsigned char *)p;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; bytes; i++)&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (i != 0)&lt;br/&gt;        {&lt;br/&gt;            &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot; &quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;%02x&quot;&lt;/span&gt;, *(ptr + i));&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;\n&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;/**&lt;br/&gt; * main - confirm the &lt;span&gt;source&lt;/span&gt; code&lt;br/&gt; *&lt;br/&gt; * Return: EXIT_FAILURE &lt;span&gt;if&lt;/span&gt; something failed. Otherwise EXIT_SUCCESS&lt;br/&gt; */&lt;br/&gt;int main(void)&lt;br/&gt;{&lt;br/&gt;    void *p;&lt;br/&gt;    int i;&lt;br/&gt;    size_t size_of_the_chunk;&lt;br/&gt;    size_t size_of_the_previous_chunk;&lt;br/&gt;    void *chunks[10];&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; 10; i++)&lt;br/&gt;    {&lt;br/&gt;        p = malloc(1024 * (i + 1));&lt;br/&gt;        chunks[i] = (void *)((char *)p - 0x10);&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;%p\n&quot;&lt;/span&gt;, p);&lt;br/&gt;    }&lt;br/&gt;    free((char *)(chunks[3]) + 0x10);&lt;br/&gt;    free((char *)(chunks[7]) + 0x10);&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; 10; i++)&lt;br/&gt;    {&lt;br/&gt;        p = chunks[i];&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;chunks[%d]: &quot;&lt;/span&gt;, i);&lt;br/&gt;        pmem(p, 0x10);&lt;br/&gt;        size_of_the_chunk = *((size_t *)((char *)p + 8)) - 1;&lt;br/&gt;        size_of_the_previous_chunk = *((size_t *)((char *)p));&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;chunks[%d]: %p, size = %li, prev = %li\n&quot;&lt;/span&gt;,&lt;br/&gt;              i, p, size_of_the_chunk, size_of_the_previous_chunk);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; (EXIT_SUCCESS);&lt;br/&gt;}&lt;br/&gt;编译运行输出：&lt;br/&gt;root@3e8650948c0c:/ubuntu&lt;span&gt;# gcc test.c -o test&lt;/span&gt;&lt;br/&gt;root@3e8650948c0c:/ubuntu&lt;span&gt;# ./test&lt;/span&gt;&lt;br/&gt;0x559721de4260&lt;br/&gt;0x559721de4a80&lt;br/&gt;0x559721de5290&lt;br/&gt;0x559721de5ea0&lt;br/&gt;0x559721de6eb0&lt;br/&gt;0x559721de82c0&lt;br/&gt;0x559721de9ad0&lt;br/&gt;0x559721deb6e0&lt;br/&gt;0x559721ded6f0&lt;br/&gt;0x559721defb00&lt;br/&gt;chunks[0]: 00 00 00 00 00 00 00 00 11 04 00 00 00 00 00 00&lt;br/&gt;chunks[0]: 0x559721de4250, size = 1040, prev = 0&lt;br/&gt;chunks[1]: 00 00 00 00 00 00 00 00 11 08 00 00 00 00 00 00&lt;br/&gt;chunks[1]: 0x559721de4a70, size = 2064, prev = 0&lt;br/&gt;chunks[2]: 00 00 00 00 00 00 00 00 11 0c 00 00 00 00 00 00&lt;br/&gt;chunks[2]: 0x559721de5280, size = 3088, prev = 0&lt;br/&gt;chunks[3]: 00 00 00 00 00 00 00 00 11 10 00 00 00 00 00 00&lt;br/&gt;chunks[3]: 0x559721de5e90, size = 4112, prev = 0&lt;br/&gt;chunks[4]: 10 10 00 00 00 00 00 00 10 14 00 00 00 00 00 00&lt;br/&gt;chunks[4]: 0x559721de6ea0, size = 5135, prev = 4112&lt;br/&gt;chunks[5]: 00 00 00 00 00 00 00 00 11 18 00 00 00 00 00 00&lt;br/&gt;chunks[5]: 0x559721de82b0, size = 6160, prev = 0&lt;br/&gt;chunks[6]: 00 00 00 00 00 00 00 00 11 1c 00 00 00 00 00 00&lt;br/&gt;chunks[6]: 0x559721de9ac0, size = 7184, prev = 0&lt;br/&gt;chunks[7]: 00 00 00 00 00 00 00 00 11 20 00 00 00 00 00 00&lt;br/&gt;chunks[7]: 0x559721deb6d0, size = 8208, prev = 0&lt;br/&gt;chunks[8]: 10 20 00 00 00 00 00 00 10 24 00 00 00 00 00 00&lt;br/&gt;chunks[8]: 0x559721ded6e0, size = 9231, prev = 8208&lt;br/&gt;chunks[9]: 00 00 00 00 00 00 00 00 11 28 00 00 00 00 00 00&lt;br/&gt;chunks[9]: 0x559721defaf0, size = 10256, prev = 0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结果可以看出，malloc返回的地址往前的16个字节可以表示已经分配的内存大小, 如图：&lt;br/&gt;&lt;img data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9lFFFiaKpEr8ZWrBt9SoqIMmdjw6L2WqPa3r1JwOX4yDkDfomHLknMfa6VrdaRBrLdEy6q0Qd1daHJCBJAtP2ZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意上述是没有调用free释放内存的结果，然而malloc只用了8个字节表示已经分配的内存大小，那么另外8个字节被用来表示什么含义呢，看下malloc函数的注释:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;1055 /*&lt;br/&gt;1056       malloc_chunk details:&lt;br/&gt;1057    &lt;br/&gt;1058        (The following includes lightly edited explanations by Colin Plumb.)&lt;br/&gt;1059    &lt;br/&gt;1060        Chunks of memory are maintained using a `boundary tag&lt;span&gt;&#x27; method as&lt;br/&gt;1061        described in e.g., Knuth or Standish.  (See the paper by Paul&lt;br/&gt;1062        Wilson ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps for a&lt;br/&gt;1063        survey of such techniques.)  Sizes of free chunks are stored both&lt;br/&gt;1064        in the front of each chunk and at the end.  This makes&lt;br/&gt;1065        consolidating fragmented chunks into bigger chunks very fast.  The&lt;br/&gt;1066        size fields also hold bits representing whether chunks are free or&lt;br/&gt;1067        in use.&lt;br/&gt;1068    &lt;br/&gt;1069        An allocated chunk looks like this:&lt;br/&gt;1070    &lt;br/&gt;1071    &lt;br/&gt;1072        chunk-&amp;gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+&lt;br/&gt;1073                |             Size of previous chunk, if unallocated (P clear)  |&lt;br/&gt;1074                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+&lt;br/&gt;1075                |             Size of chunk, in bytes                     |A|M|P|&lt;br/&gt;1076          mem-&amp;gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+&lt;br/&gt;1077                |             User data starts here...                          .&lt;br/&gt;1078                .                                                               .&lt;br/&gt;1079                .             (malloc_usable_size() bytes)                      .&lt;br/&gt;1080                .                                                               |&lt;br/&gt;1081    nextchunk-&amp;gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+&lt;br/&gt;1082                |             (size of chunk, but used for application data)    |&lt;br/&gt;1083                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+&lt;br/&gt;1084                |             Size of next chunk, in bytes                |A|0|1|&lt;br/&gt;1085                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+&lt;br/&gt;1086    &lt;br/&gt;1087        Where &quot;chunk&quot; is the front of the chunk for the purpose of most of&lt;br/&gt;1088        the malloc code, but &quot;mem&quot; is the pointer that is returned to the&lt;br/&gt;1089        user.  &quot;Nextchunk&quot; is the beginning of the next contiguous chunk.&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看出这16字节有两个含义，前8个字节表示之前的空间有多少没有被分配的字节大小，后8个字节表示当前malloc已经分配的字节大小，通过一段调用free的代码查看：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;/**                                                                                            &lt;br/&gt; * pmem - &lt;span&gt;print&lt;/span&gt; mem                                                                            &lt;br/&gt; * @p: memory address to start printing from                                                   &lt;br/&gt; * @bytes: number of bytes to &lt;span&gt;print&lt;/span&gt;                                                            &lt;br/&gt; *                                                                                             &lt;br/&gt; * Return: nothing                                                                             &lt;br/&gt; */&lt;br/&gt;void pmem(void *p, unsigned int bytes)&lt;br/&gt;{&lt;br/&gt;    unsigned char *ptr;&lt;br/&gt;    unsigned int i;&lt;br/&gt;&lt;br/&gt;    ptr = (unsigned char *)p;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; bytes; i++)&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (i != 0)&lt;br/&gt;        {&lt;br/&gt;            &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot; &quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;%02x&quot;&lt;/span&gt;, *(ptr + i));&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;\n&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;/**&lt;br/&gt; * main - confirm the &lt;span&gt;source&lt;/span&gt; code&lt;br/&gt; *&lt;br/&gt; * Return: EXIT_FAILURE &lt;span&gt;if&lt;/span&gt; something failed. Otherwise EXIT_SUCCESS&lt;br/&gt; */&lt;br/&gt;int main(void)&lt;br/&gt;{&lt;br/&gt;    void *p;&lt;br/&gt;    int i;&lt;br/&gt;    size_t size_of_the_chunk;&lt;br/&gt;    size_t size_of_the_previous_chunk;&lt;br/&gt;    void *chunks[10];&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; 10; i++)&lt;br/&gt;    {&lt;br/&gt;        p = malloc(1024 * (i + 1));&lt;br/&gt;        chunks[i] = (void *)((char *)p - 0x10);&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;%p\n&quot;&lt;/span&gt;, p);&lt;br/&gt;    }&lt;br/&gt;    free((char *)(chunks[3]) + 0x10);&lt;br/&gt;    free((char *)(chunks[7]) + 0x10);&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; 10; i++)&lt;br/&gt;    {&lt;br/&gt;        p = chunks[i];&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;chunks[%d]: &quot;&lt;/span&gt;, i);&lt;br/&gt;        pmem(p, 0x10);&lt;br/&gt;        size_of_the_chunk = *((size_t *)((char *)p + 8)) - 1;&lt;br/&gt;        size_of_the_previous_chunk = *((size_t *)((char *)p));&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;chunks[%d]: %p, size = %li, prev = %li\n&quot;&lt;/span&gt;,&lt;br/&gt;              i, p, size_of_the_chunk, size_of_the_previous_chunk);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; (EXIT_SUCCESS);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;编译运行输出：&lt;br/&gt;root@3e8650948c0c:/ubuntu&lt;span&gt;# gcc test.c -o test&lt;/span&gt;&lt;br/&gt;root@3e8650948c0c:/ubuntu&lt;span&gt;# ./test&lt;/span&gt;&lt;br/&gt;0x55fbebf20260&lt;br/&gt;0x55fbebf20a80&lt;br/&gt;0x55fbebf21290&lt;br/&gt;0x55fbebf21ea0&lt;br/&gt;0x55fbebf22eb0&lt;br/&gt;0x55fbebf242c0&lt;br/&gt;0x55fbebf25ad0&lt;br/&gt;0x55fbebf276e0&lt;br/&gt;0x55fbebf296f0&lt;br/&gt;0x55fbebf2bb00&lt;br/&gt;chunks[0]: 00 00 00 00 00 00 00 00 11 04 00 00 00 00 00 00&lt;br/&gt;chunks[0]: 0x55fbebf20250, size = 1040, prev = 0&lt;br/&gt;chunks[1]: 00 00 00 00 00 00 00 00 11 08 00 00 00 00 00 00&lt;br/&gt;chunks[1]: 0x55fbebf20a70, size = 2064, prev = 0&lt;br/&gt;chunks[2]: 00 00 00 00 00 00 00 00 11 0c 00 00 00 00 00 00&lt;br/&gt;chunks[2]: 0x55fbebf21280, size = 3088, prev = 0&lt;br/&gt;chunks[3]: 00 00 00 00 00 00 00 00 11 10 00 00 00 00 00 00&lt;br/&gt;chunks[3]: 0x55fbebf21e90, size = 4112, prev = 0&lt;br/&gt;chunks[4]: 10 10 00 00 00 00 00 00 10 14 00 00 00 00 00 00&lt;br/&gt;chunks[4]: 0x55fbebf22ea0, size = 5135, prev = 4112&lt;br/&gt;chunks[5]: 00 00 00 00 00 00 00 00 11 18 00 00 00 00 00 00&lt;br/&gt;chunks[5]: 0x55fbebf242b0, size = 6160, prev = 0&lt;br/&gt;chunks[6]: 00 00 00 00 00 00 00 00 11 1c 00 00 00 00 00 00&lt;br/&gt;chunks[6]: 0x55fbebf25ac0, size = 7184, prev = 0&lt;br/&gt;chunks[7]: 00 00 00 00 00 00 00 00 11 20 00 00 00 00 00 00&lt;br/&gt;chunks[7]: 0x55fbebf276d0, size = 8208, prev = 0&lt;br/&gt;chunks[8]: 10 20 00 00 00 00 00 00 10 24 00 00 00 00 00 00&lt;br/&gt;chunks[8]: 0x55fbebf296e0, size = 9231, prev = 8208&lt;br/&gt;chunks[9]: 00 00 00 00 00 00 00 00 11 28 00 00 00 00 00 00&lt;br/&gt;chunks[9]: 0x55fbebf2baf0, size = 10256, prev = 0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序代码通过free释放了3和7数据块的空间，所以4和8的前8个字节已经不全是0啦，和其它不同，它们表示之前数据块没有被分配的大小，也可以注意到4和8块的后8个字节不像其它块一样需要加1啦，可以得出结论，malloc通过是否加1来作为前一个数据块是否已经分配的标志，加1表示前一个数据块已经分配。所以之前的程序代码可以修改为如下形式：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;/**                                                                                            &lt;br/&gt; * pmem - &lt;span&gt;print&lt;/span&gt; mem                                                                            &lt;br/&gt; * @p: memory address to start printing from                                                   &lt;br/&gt; * @bytes: number of bytes to &lt;span&gt;print&lt;/span&gt;                                                            &lt;br/&gt; *                                                                                             &lt;br/&gt; * Return: nothing                                                                             &lt;br/&gt; */&lt;br/&gt;void pmem(void *p, unsigned int bytes)&lt;br/&gt;{&lt;br/&gt;    unsigned char *ptr;&lt;br/&gt;    unsigned int i;&lt;br/&gt;&lt;br/&gt;    ptr = (unsigned char *)p;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; bytes; i++)&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (i != 0)&lt;br/&gt;        {&lt;br/&gt;            &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot; &quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;%02x&quot;&lt;/span&gt;, *(ptr + i));&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;\n&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;/**&lt;br/&gt; * main - updating with correct checks&lt;br/&gt; *&lt;br/&gt; * Return: EXIT_FAILURE &lt;span&gt;if&lt;/span&gt; something failed. Otherwise EXIT_SUCCESS&lt;br/&gt; */&lt;br/&gt;int main(void)&lt;br/&gt;{&lt;br/&gt;    void *p;&lt;br/&gt;    int i;&lt;br/&gt;    size_t size_of_the_chunk;&lt;br/&gt;    size_t size_of_the_previous_chunk;&lt;br/&gt;    void *chunks[10];&lt;br/&gt;    char prev_used;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; 10; i++)&lt;br/&gt;    {&lt;br/&gt;        p = malloc(1024 * (i + 1));&lt;br/&gt;        chunks[i] = (void *)((char *)p - 0x10);&lt;br/&gt;    }&lt;br/&gt;    free((char *)(chunks[3]) + 0x10);&lt;br/&gt;    free((char *)(chunks[7]) + 0x10);&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; 10; i++)&lt;br/&gt;    {&lt;br/&gt;        p = chunks[i];&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;chunks[%d]: &quot;&lt;/span&gt;, i);&lt;br/&gt;        pmem(p, 0x10);&lt;br/&gt;        size_of_the_chunk = *((size_t *)((char *)p + 8));&lt;br/&gt;        prev_used = size_of_the_chunk &amp;amp; 1;&lt;br/&gt;        size_of_the_chunk -= prev_used;&lt;br/&gt;        size_of_the_previous_chunk = *((size_t *)((char *)p));&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;chunks[%d]: %p, size = %li, prev (%s) = %li\n&quot;&lt;/span&gt;,&lt;br/&gt;              i, p, size_of_the_chunk,&lt;br/&gt;              (prev_used? &lt;span&gt;&quot;allocated&quot;&lt;/span&gt;: &lt;span&gt;&quot;unallocated&quot;&lt;/span&gt;), size_of_the_previous_chunk);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; (EXIT_SUCCESS);&lt;br/&gt;}&lt;br/&gt;编译运行输出：&lt;br/&gt;root@3e8650948c0c:/ubuntu&lt;span&gt;# gcc test.c -o test&lt;/span&gt;&lt;br/&gt;root@3e8650948c0c:/ubuntu&lt;span&gt;# ./test&lt;/span&gt;&lt;br/&gt;chunks[0]: 00 00 00 00 00 00 00 00 11 04 00 00 00 00 00 00&lt;br/&gt;chunks[0]: 0x56254f888250, size = 1040, prev (allocated) = 0&lt;br/&gt;chunks[1]: 00 00 00 00 00 00 00 00 11 08 00 00 00 00 00 00&lt;br/&gt;chunks[1]: 0x56254f888660, size = 2064, prev (allocated) = 0&lt;br/&gt;chunks[2]: 00 00 00 00 00 00 00 00 11 0c 00 00 00 00 00 00&lt;br/&gt;chunks[2]: 0x56254f888e70, size = 3088, prev (allocated) = 0&lt;br/&gt;chunks[3]: 00 00 00 00 00 00 00 00 11 04 00 00 00 00 00 00&lt;br/&gt;chunks[3]: 0x56254f889a80, size = 1040, prev (allocated) = 0&lt;br/&gt;chunks[4]: 00 0c 00 00 00 00 00 00 10 14 00 00 00 00 00 00&lt;br/&gt;chunks[4]: 0x56254f88aa90, size = 5136, prev (unallocated) = 3072&lt;br/&gt;chunks[5]: 00 00 00 00 00 00 00 00 11 18 00 00 00 00 00 00&lt;br/&gt;chunks[5]: 0x56254f88bea0, size = 6160, prev (allocated) = 0&lt;br/&gt;chunks[6]: 00 00 00 00 00 00 00 00 11 1c 00 00 00 00 00 00&lt;br/&gt;chunks[6]: 0x56254f88d6b0, size = 7184, prev (allocated) = 0&lt;br/&gt;chunks[7]: 00 00 00 00 00 00 00 00 11 20 00 00 00 00 00 00&lt;br/&gt;chunks[7]: 0x56254f88f2c0, size = 8208, prev (allocated) = 0&lt;br/&gt;chunks[8]: 10 20 00 00 00 00 00 00 10 24 00 00 00 00 00 00&lt;br/&gt;chunks[8]: 0x56254f8912d0, size = 9232, prev (unallocated) = 8208&lt;br/&gt;chunks[9]: 00 00 00 00 00 00 00 00 11 28 00 00 00 00 00 00&lt;br/&gt;chunks[9]: 0x56254f8936e0, size = 10256, prev (allocated) = 0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;堆空间是向上增长吗？&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过代码验证：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;/**&lt;br/&gt; * main - moving the program &lt;span&gt;break&lt;/span&gt;&lt;br/&gt; *&lt;br/&gt; * Return: EXIT_FAILURE &lt;span&gt;if&lt;/span&gt; something failed. Otherwise EXIT_SUCCESS&lt;br/&gt; */&lt;br/&gt;int main(void)&lt;br/&gt;{&lt;br/&gt;    int i;&lt;br/&gt;&lt;br/&gt;    write(1, &lt;span&gt;&quot;START\n&quot;&lt;/span&gt;, 6);&lt;br/&gt;    malloc(1);&lt;br/&gt;    getchar();&lt;br/&gt;    write(1, &lt;span&gt;&quot;LOOP\n&quot;&lt;/span&gt;, 5);&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; 0x25000 / 1024; i++)&lt;br/&gt;    {&lt;br/&gt;        malloc(1024);&lt;br/&gt;    }&lt;br/&gt;    write(1, &lt;span&gt;&quot;END\n&quot;&lt;/span&gt;, 4);&lt;br/&gt;    getchar();&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; (EXIT_SUCCESS);&lt;br/&gt;}&lt;br/&gt;编译运行部分摘要输出：&lt;br/&gt;root@3e8650948c0c:/ubuntu&lt;span&gt;# gcc test.c -o test&lt;/span&gt;&lt;br/&gt;root@3e8650948c0c:/ubuntu&lt;span&gt;# strace ./test&lt;/span&gt;&lt;br/&gt;execve(&lt;span&gt;&quot;./test&quot;&lt;/span&gt;, [&lt;span&gt;&quot;./test&quot;&lt;/span&gt;], 0x7ffe0d7cbd80 /* 10 vars */) = 0&lt;br/&gt;brk(NULL)                               = 0x555a2428f000&lt;br/&gt;access(&lt;span&gt;&quot;/etc/ld.so.nohwcap&quot;&lt;/span&gt;, F_OK)      = -1 ENOENT (No such file or directory)&lt;br/&gt;access(&lt;span&gt;&quot;/etc/ld.so.preload&quot;&lt;/span&gt;, R_OK)      = -1 ENOENT (No such file or directory)&lt;br/&gt;openat(AT_FDCWD, &lt;span&gt;&quot;/etc/ld.so.cache&quot;&lt;/span&gt;, O_RDONLY|O_CLOEXEC) = 3&lt;br/&gt;fstat(3, {st_mode=S_IFREG|0644, st_size=13722, ...}) = 0&lt;br/&gt;mmap(NULL, 13722, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f6423455000&lt;br/&gt;close(3)                                = 0&lt;br/&gt;access(&lt;span&gt;&quot;/etc/ld.so.nohwcap&quot;&lt;/span&gt;, F_OK)      = -1 ENOENT (No such file or directory)&lt;br/&gt;openat(AT_FDCWD, &lt;span&gt;&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;&lt;/span&gt;, O_RDONLY|O_CLOEXEC) = 3&lt;br/&gt;&lt;span&gt;read&lt;/span&gt;(3, &lt;span&gt;&quot;\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&amp;gt;\0\1\0\0\0\260\34\2\0\0\0\0\0&quot;&lt;/span&gt;..., 832) = 832&lt;br/&gt;fstat(3, {st_mode=S_IFREG|0755, st_size=2030544, ...}) = 0&lt;br/&gt;mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f6423453000&lt;br/&gt;mmap(NULL, 4131552, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f6422e41000&lt;br/&gt;mprotect(0x7f6423028000, 2097152, PROT_NONE) = 0&lt;br/&gt;mmap(0x7f6423228000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1e7000) = 0x7f6423228000&lt;br/&gt;mmap(0x7f642322e000, 15072, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f642322e000&lt;br/&gt;close(3)                                = 0&lt;br/&gt;arch_prctl(ARCH_SET_FS, 0x7f64234544c0) = 0&lt;br/&gt;mprotect(0x7f6423228000, 16384, PROT_READ) = 0&lt;br/&gt;mprotect(0x555a22f5f000, 4096, PROT_READ) = 0&lt;br/&gt;mprotect(0x7f6423459000, 4096, PROT_READ) = 0&lt;br/&gt;munmap(0x7f6423455000, 13722)           = 0&lt;br/&gt;write(1, &lt;span&gt;&quot;START\n&quot;&lt;/span&gt;, 6START&lt;br/&gt;)                  = 6&lt;br/&gt;brk(NULL)                               = 0x555a2428f000&lt;br/&gt;brk(0x555a242b0000)                     = 0x555a242b0000&lt;br/&gt;fstat(0, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 0), ...}) = 0&lt;br/&gt;&lt;span&gt;read&lt;/span&gt;(0,&lt;br/&gt;&lt;span&gt;&quot;\n&quot;&lt;/span&gt;, 1024)                     = 1&lt;br/&gt;write(1, &lt;span&gt;&quot;LOOP\n&quot;&lt;/span&gt;, 5LOOP&lt;br/&gt;)                   = 5&lt;br/&gt;brk(0x555a242d1000)                     = 0x555a242d1000&lt;br/&gt;brk(0x555a242f2000)                     = 0x555a242f2000&lt;br/&gt;brk(0x555a24313000)                     = 0x555a24313000&lt;br/&gt;brk(0x555a24334000)                     = 0x555a24334000&lt;br/&gt;brk(0x555a24355000)                     = 0x555a24355000&lt;br/&gt;brk(0x555a24376000)                     = 0x555a24376000&lt;br/&gt;brk(0x555a24397000)                     = 0x555a24397000&lt;br/&gt;brk(0x555a243b8000)                     = 0x555a243b8000&lt;br/&gt;brk(0x555a243d9000)                     = 0x555a243d9000&lt;br/&gt;brk(0x555a243fa000)                     = 0x555a243fa000&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看出堆空间是向上增长的.&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;随机化地址空间布局&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从开始到现在运行了好多个进程，通过查看对应进程的maps，发现每个进程的heap的起始地址和可执行程序的结束地址都不紧邻，而且差距还每次都不相同.&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;[3718]: 01195000 – 00602000 = b93000&lt;br/&gt;[3834]: 024d6000 – 00602000 = 1ed4000&lt;br/&gt;[4014]: 00e70000 – 00602000 = 86e000&lt;br/&gt;[4172]: 01314000 – 00602000 = d12000&lt;br/&gt;[7972]: 00901000 – 00602000 = 2ff000&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看出这个差值是随机的，查看fs/binfmt_elf.c源代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; ((current-&amp;gt;flags &amp;amp; PF_RANDOMIZE) &amp;amp;&amp;amp; (randomize_va_space &amp;gt; 1)) {&lt;br/&gt;                current-&amp;gt;mm-&amp;gt;brk = current-&amp;gt;mm-&amp;gt;start_brk =&lt;br/&gt;                        arch_randomize_brk(current-&amp;gt;mm);&lt;br/&gt;&lt;span&gt;#ifdef compat_brk_randomized&lt;/span&gt;&lt;br/&gt;                current-&amp;gt;brk_randomized = 1;&lt;br/&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;// current-&amp;gt;mm-&amp;gt;brk是当前进程程序中断的地址&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;arch_randomize_brk函数在arch/x86/kernel/process.c中&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;unsigned long arch_randomize_brk(struct mm_struct *mm)&lt;br/&gt;{&lt;br/&gt;        unsigned long range_end = mm-&amp;gt;brk + 0x02000000;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; randomize_range(mm-&amp;gt;brk, range_end, 0) ? : mm-&amp;gt;brk;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;randomize_range函数在drivers/char/random.c中&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;/*&lt;br/&gt; * randomize_range() returns a start address such that&lt;br/&gt; *&lt;br/&gt; *    [...... &amp;lt;range&amp;gt; .....]&lt;br/&gt; *  start                  end&lt;br/&gt; *&lt;br/&gt; * a &amp;lt;range&amp;gt; with size &lt;span&gt;&quot;len&quot;&lt;/span&gt; starting at the &lt;span&gt;return&lt;/span&gt; value is inside &lt;span&gt;in&lt;/span&gt; the&lt;br/&gt; * area defined by [start, end], but is otherwise randomized.&lt;br/&gt; */&lt;br/&gt;unsigned long&lt;br/&gt;randomize_range(unsigned long start, unsigned long end, unsigned long len)&lt;br/&gt;{&lt;br/&gt;        unsigned long range = end - len - start;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (end &amp;lt;= start + len)&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; 0;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; PAGE_ALIGN(get_random_int() % range + start);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看出上面所说的这个差值其实就是0-0x02000000中的一个随机数，这种技术称为ASLR(Address Space Layout Randomisation)，是一种计算机安全技术，随机安排虚拟内存中堆栈空间的位置，可以有效防止黑客攻击。通过以上分析，可以画出内存分布图如下：&lt;br/&gt;&lt;img data-ratio=&quot;1.0392609699769053&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9lFFFiaKpEr8ZWrBt9SoqIMmdjw6L2WqPUC372KUlkenuVHnRO3hSwCBib0WtjhfPPMdtkIzJxBG5Ap64vDuvaHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;433&quot;/&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;malloc(0)发生了什么？&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当调用malloc(0)会发生什么，代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;/**                                                                                            &lt;br/&gt; * pmem - &lt;span&gt;print&lt;/span&gt; mem                                                                            &lt;br/&gt; * @p: memory address to start printing from                                                   &lt;br/&gt; * @bytes: number of bytes to &lt;span&gt;print&lt;/span&gt;                                                            &lt;br/&gt; *                                                                                             &lt;br/&gt; * Return: nothing                                                                             &lt;br/&gt; */&lt;br/&gt;void pmem(void *p, unsigned int bytes)&lt;br/&gt;{&lt;br/&gt;    unsigned char *ptr;&lt;br/&gt;    unsigned int i;&lt;br/&gt;&lt;br/&gt;    ptr = (unsigned char *)p;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; bytes; i++)&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (i != 0)&lt;br/&gt;        {&lt;br/&gt;            &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot; &quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;%02x&quot;&lt;/span&gt;, *(ptr + i));&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;\n&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;/**&lt;br/&gt; * main - moving the program &lt;span&gt;break&lt;/span&gt;&lt;br/&gt; *&lt;br/&gt; * Return: EXIT_FAILURE &lt;span&gt;if&lt;/span&gt; something failed. Otherwise EXIT_SUCCESS&lt;br/&gt; */&lt;br/&gt;int main(void)&lt;br/&gt;{&lt;br/&gt;    void *p;&lt;br/&gt;    size_t size_of_the_chunk;&lt;br/&gt;    char prev_used;&lt;br/&gt;&lt;br/&gt;    p = malloc(0);&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;%p\n&quot;&lt;/span&gt;, p);&lt;br/&gt;    pmem((char *)p - 0x10, 0x10);&lt;br/&gt;    size_of_the_chunk = *((size_t *)((char *)p - 8));&lt;br/&gt;    prev_used = size_of_the_chunk &amp;amp; 1;&lt;br/&gt;    size_of_the_chunk -= prev_used;&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;chunk size = %li bytes\n&quot;&lt;/span&gt;, size_of_the_chunk);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; (EXIT_SUCCESS);&lt;br/&gt;}&lt;br/&gt;编译运行输出如下：&lt;br/&gt;root@3e8650948c0c:/ubuntu&lt;span&gt;# gcc test.c -o test&lt;/span&gt;&lt;br/&gt;root@3e8650948c0c:/ubuntu&lt;span&gt;# ./test&lt;/span&gt;&lt;br/&gt;0x564ece64b260&lt;br/&gt;00 00 00 00 00 00 00 00 21 00 00 00 00 00 00 00&lt;br/&gt;chunk size = 32 bytes&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看出malloc(0)实际使用了32个字节，其中包括我们之前说的16个字节头部，然而有时候malloc(0)可能会有不同的结果输出，也有可能会返回NULL.&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;man malloc&lt;br/&gt;NULL may also be returned by a successful call to malloc() with a size of zero&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;操作环境&lt;/span&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;示例代码主要在两种环境下跑过：&lt;br/&gt;ubuntu 16.04&lt;br/&gt;gcc (Ubuntu 7.4.0-1ubuntu1~16.04~ppa1) 7.4.0&lt;br/&gt;&lt;br/&gt;ubuntu 18.04 docker&lt;br/&gt;gcc (Ubuntu 7.4.0-1ubuntu1~18.04.1) 7.4.0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>