<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>289017e79ce7f789224aa67cefe0f2a5</guid>
<title>比尔·盖茨推荐夏季书单；Web3.0行业全景及代表项目研究；实战中的架构设计方法｜码农周刊VIP会员专属邮件周报 Vol.094</title>
<link>https://toutiao.io/k/7z24yub</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;我爱程序员&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;developerWorks&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;我们的产品：《码农周刊》 http://manong.io/ 、《开发者头条》 http://toutiao.io/&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f762a377afa67c60db5a55da3b0623a5</guid>
<title>我们公司使用了 5 年的系统限流方案！从实现到部署实战详解，稳的一批!​</title>
<link>https://toutiao.io/k/4tls39t</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;大家好，我是老赵&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;！&lt;/span&gt;&lt;/strong&gt;&lt;em&gt;&lt;span&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;span/&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/span&gt;&lt;/em&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;什么是限流呢？限流是限制到达系统的并发请求数量，保证系统能够正常响应部分用户请求，而对于超过限制的流量，则通过拒绝服务的方式保证整体系统的可用性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据限流作用范围，可以分为&lt;strong&gt;单机限流和分布式限流&lt;/strong&gt;；根据限流方式，又分为&lt;strong&gt;计数器、滑动窗口、漏桶和令牌桶限流&lt;/strong&gt;，下面我们对这块详细进行讲解。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;常用限流方式&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;计数器&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;计数器是一种最简单限流算法，其原理就是：在一段时间间隔内，对请求进行计数，与阀值进行比较判断是否需要限流，一旦到了时间临界点，将计数器清零。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个就像你去坐车一样，车厢规定了多少个位置，满了就不让上车了，不然就是超载了，被交警叔叔抓到了就要罚款的，如果我们的系统那就不是罚款的事情了，可能直接崩掉了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序执行逻辑：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;可以在程序中设置一个变量 count，当过来一个请求我就将这个数 +1，同时记录请求时间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当下一个请求来的时候判断 count 的计数值是否超过设定的频次，以及当前请求的时间和第一次请求时间是否在 1 分钟内。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果在 1 分钟内并且超过设定的频次则证明请求过多，后面的请求就拒绝掉。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果该请求与第一个请求的间隔时间大于计数周期，且 count 值还在限流范围内，就重置 count。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么问题来了，如果有个需求对于某个接口 /query 每分钟最多允许访问 200 次，假设有个用户在第 59 秒的最后几毫秒瞬间发送 200 个请求，当 59 秒结束后 Counter 清零了，他在下一秒的时候又发送 200 个请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么在 1 秒钟内这个用户发送了 2 倍的请求，这个是符合我们的设计逻辑的，这也是计数器方法的设计缺陷，系统可能会承受恶意用户的大量请求，甚至击穿系统。&lt;strong&gt;这种方法虽然简单，但也有个大问题就是没有很好的处理单位时间的边界。&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3443708609271523&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHVUYY15MYFpF1D5fDtiao11VLPh0WuiaSUMmcNOiaYDksmxA9TqRZnv4IedWP2scGicHdict68U1lfd5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;906&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过说实话，这个计数引用了锁，在高并发场景，这个方式可能不太实用，我建议将锁去掉，然后将 l.count++ 的逻辑通过原子计数处理，这样就可以保证 l.count 自增时不会被多个线程同时执行，&lt;strong&gt;即通过原子计数的方式实现限流。&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;滑动窗口&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;滑动窗口是针对计数器存在的临界点缺陷，所谓滑动窗口（Sliding window）是一种流量控制技术，这个词出现在 TCP 协议中。滑动窗口把固定时间片进行划分，并且随着时间的流逝，进行移动，固定数量的可以移动的格子，进行计数并判断阀值。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42314814814814816&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHVUYY15MYFpF1D5fDtiao11JkTOP1RcxEScGNVtu1iaHKMjkZftZMZAS5UyFk7ULtZsjsMMbmqUoEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图中我们用红色的虚线代表一个时间窗口（一分钟），每个时间窗口有 6 个格子，每个格子是 10 秒钟。每过 10 秒钟时间窗口向右移动一格，可以看红色箭头的方向。我们为每个格子都设置一个独立的计数器 Counter，假如一个请求在 0:45 访问了那么我们将第五个格子的计数器 +1（也是就是 0:40~0:50），在判断限流的时候需要把所有格子的计数加起来和设定的频次进行比较即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么滑动窗口如何解决我们上面遇到的问题呢？来看下面的图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42314814814814816&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHVUYY15MYFpF1D5fDtiao117EDRACZWlicN0CrozU4omsVR8aHXeEsib3JhER7Y01t8SvKCicviaLXxgg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当用户在 0:59 秒钟发送了 200 个请求就会被第六个格子的计数器记录 +200，当下一秒的时候时间窗口向右移动了一个，此时计数器已经记录了该用户发送的 200 个请求，所以再发送的话就会触发限流，则拒绝新的请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实计数器就是滑动窗口啊，只不过只有一个格子而已，所以想让限流做的更精确只需要划分更多的格子就可以了，为了更精确我们也不知道到底该设置多少个格子，&lt;strong&gt;格子的数量影响着滑动窗口算法的精度，依然有时间片的概念，无法根本解决临界点问题。&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;漏桶&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;漏桶算法（Leaky Bucket），原理就是一个固定容量的漏桶，按照固定速率流出水滴。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用过水龙头都知道，打开龙头开关水就会流下滴到水桶里，而漏桶指的是水桶下面有个漏洞可以出水,如果水龙头开的特别大那么水流速就会过大，这样就可能导致水桶的水满了然后溢出。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5666666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHVUYY15MYFpF1D5fDtiao11ic3Ly4IDNcADnCGUfsicicslXf2PR9ARDtasyFpVeUib2cuKsOZSiaxSqdw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个固定容量的桶，有水流进来，也有水流出去。对于流进来的水来说，我们无法预计一共有多少水会流进来，也无法预计水流的速度。但是对于流出去的水来说，这个桶可以固定水流出的速率（处理速度），从而达到流量整形和流量控制的效果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;漏桶算法有以下特点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;漏桶具有固定容量，出水速率是固定常量（流出请求）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果桶是空的，则不需流出水滴&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以以任意速率流入水滴到漏桶（流入请求）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果流入水滴超出了桶的容量，则流入的水滴溢出（新请求被拒绝）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;漏桶限制的是常量流出速率（即流出速率是一个固定常量值），&lt;strong&gt;所以最大的速率就是出水的速率，不能出现突发流量。&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;令牌桶&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;令牌桶算法（Token Bucket）是网络流量整形（Traffic Shaping）和速率限制（Rate Limiting）中最常使用的一种算法。典型情况下，令牌桶算法用来控制发送到网络上的数据的数目，并允许突发数据的发送。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6158357771260997&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHVUYY15MYFpF1D5fDtiao11icVOHT78cSGcDtjicoSxWVWic35PRlHYJWZOva2urwIToreQ9Wbq5MLbw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1023&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们有一个固定的桶，桶里存放着令牌（token）。一开始桶是空的，系统按固定的时间（rate）往桶里添加令牌，直到桶里的令牌数满，多余的请求会被丢弃。当请求来的时候，从桶里移除一个令牌，如果桶是空的则拒绝请求或者阻塞。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;令牌桶有以下特点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;令牌按固定的速率被放入令牌桶中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;桶中最多存放 B 个令牌，当桶满时，新添加的令牌被丢弃或拒绝&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果桶中的令牌不足 N 个，则不会删除令牌，且请求将被限流（丢弃或阻塞等待）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;令牌桶限制的是平均流入速率&lt;/strong&gt;（允许突发请求，只要有令牌就可以处理，支持一次拿3个令牌，4个令牌...），&lt;strong&gt;并允许一定程度突发流量，所以也是非常常用的限流算法。&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis + Lua 分布式限流&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单机版限流仅能保护自身节点，但无法保护应用依赖的各种服务，并且在进行节点扩容、缩容时也无法准确控制整个服务的请求限制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而分布式限流，以集群为维度，可以方便的控制这个集群的请求限制，从而保护下游依赖的各种服务资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;分布式限流最关键的是要将限流服务做成原子化&lt;/strong&gt;，我们可以借助 Redis 的计数器，Lua 执行的原子性，进行分布式限流，大致的 Lua 脚本代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;local&lt;/span&gt; key = &lt;span&gt;&quot;rate.limit:&quot;&lt;/span&gt; .. KEYS[1] --限流KEY  &lt;br/&gt;&lt;br/&gt;&lt;span&gt;local&lt;/span&gt; &lt;span&gt;limit&lt;/span&gt; = tonumber(ARGV[1])        --限流大小  &lt;br/&gt;&lt;br/&gt;&lt;span&gt;local&lt;/span&gt; current = tonumber(redis.call(&lt;span&gt;&#x27;get&#x27;&lt;/span&gt;, key) or &lt;span&gt;&quot;0&quot;&lt;/span&gt;)  &lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; current + 1 &amp;gt; &lt;span&gt;limit&lt;/span&gt; &lt;span&gt;then&lt;/span&gt; --如果超出限流大小  &lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; 0  &lt;br/&gt;&lt;br/&gt;&lt;span&gt;else&lt;/span&gt;  --请求数+1，并设置1秒过期  &lt;br/&gt;&lt;br/&gt;  redis.call(&lt;span&gt;&quot;INCRBY&quot;&lt;/span&gt;, key,&lt;span&gt;&quot;1&quot;&lt;/span&gt;)  &lt;br/&gt;&lt;br/&gt;   redis.call(&lt;span&gt;&quot;expire&quot;&lt;/span&gt;, key,&lt;span&gt;&quot;1&quot;&lt;/span&gt;)  &lt;br/&gt;&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; current + 1  &lt;br/&gt;&lt;br/&gt;end  &lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;限流逻辑（Java 语言）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public static boolean accquire() throws IOException, URISyntaxException {  &lt;br/&gt;&lt;br/&gt;    Jedis jedis = new Jedis(&lt;span&gt;&quot;127.0.0.1&quot;&lt;/span&gt;);  &lt;br/&gt;&lt;br/&gt;    File luaFile = new File(RedisLimitRateWithLUA.class.getResource(&lt;span&gt;&quot;/&quot;&lt;/span&gt;).toURI().getPath() + &lt;span&gt;&quot;limit.lua&quot;&lt;/span&gt;);  &lt;br/&gt;&lt;br/&gt;    String luaScript = FileUtils.readFileToString(luaFile);  &lt;br/&gt;&lt;br/&gt;  &lt;br/&gt;&lt;br/&gt;    String key = &lt;span&gt;&quot;ip:&quot;&lt;/span&gt; + System.currentTimeMillis()/1000; // 当前秒  &lt;br/&gt;&lt;br/&gt;    String &lt;span&gt;limit&lt;/span&gt; = &lt;span&gt;&quot;5&quot;&lt;/span&gt;; // 最大限制  &lt;br/&gt;&lt;br/&gt;    List&amp;lt;String&amp;gt; keys = new ArrayList&amp;lt;String&amp;gt;();  &lt;br/&gt;&lt;br/&gt;    keys.add(key);  &lt;br/&gt;&lt;br/&gt;    List&amp;lt;String&amp;gt; args = new ArrayList&amp;lt;String&amp;gt;();  &lt;br/&gt;&lt;br/&gt;    args.add(&lt;span&gt;limit&lt;/span&gt;);  &lt;br/&gt;&lt;br/&gt;    Long result = (Long)(jedis.eval(luaScript, keys, args)); // 执行lua脚本，传入参数  &lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; result == 1;  &lt;br/&gt;&lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;聊聊其它&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的限流方式，主要是针对服务器进行限流，&lt;strong&gt;我们也可以对容器进行限流，比如 Tomcat、Nginx 等限流手段。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Tomcat 可以设置最大线程数（maxThreads），当并发超过最大线程数会排队等待执行；而 Nginx 提供了两种限流手段：一是控制速率，二是控制并发连接数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 Java 语言，我们其实有相关的限流组件，比如&lt;strong&gt;大家常用的 RateLimiter，其实就是基于令牌桶算法&lt;/strong&gt;，大家知道为什么唯独选用令牌桶么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实际的限流场景中，我们也可以控制单个 IP、城市、渠道、设备 id、用户 id 等在一定时间内发送的请求数；如果是开放平台，需要为每个 appkey 设置独立的访问速率规则。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;限流对比&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们就对常用的线程策略，总结它们的优缺点，便于以后选型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;计数器：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;优点：固定时间段计数，实现简单，适用不太精准的场景；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;缺点：对边界没有很好处理，导致限流不能精准控制。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;滑动窗口：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;优点：将固定时间段分块，时间比“计数器”复杂，适用于稍微精准的场景；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;缺点：实现稍微复杂，还是不能彻底解决“计数器”存在的边界问题。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;漏桶：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;优点：可以很好的控制消费频率；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;缺点：实现稍微复杂，单位时间内，不能多消费，感觉不太灵活。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;令牌桶：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;优点：可以解决“漏桶”不能灵活消费的问题，又能避免过渡消费，强烈推荐；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;缺点：实现稍微复杂，其它缺点没有想到。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Redis + Lua 分布式限流：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;优点：支持分布式限流，有效保护下游依赖的服务资源；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;缺点：依赖 Redis，对边界没有很好处理，导致限流不能精准控制。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;精彩&lt;/strong&gt;&lt;strong&gt;推荐&lt;/strong&gt;&lt;/span&gt;&lt;strong/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;pre&gt;&lt;section data-source=&quot;bj.96weixin.com&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxNDMwMTMwMw==&amp;amp;mid=2247537632&amp;amp;idx=1&amp;amp;sn=4cb61580361df556d7d543ca755ed696&amp;amp;chksm=9b9772f8ace0fbee9e44783d4aa2bc6db6c89691153a14860a0783ffed78383937eb07f99342&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;1.&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;1&lt;/a&gt;.&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxNDMwMTMwMw==&amp;amp;mid=2247538742&amp;amp;idx=1&amp;amp;sn=bf1636d689d56f7607f4c4c385b8884f&amp;amp;chksm=9b97792eace0f038953d9a2170f1eb94a92558620ee0752b0c69fcc323c21e2cfb9ace24f828&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;40个SpringBoot常用注解：让生产力爆表！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;40个SpringBoot常用注解：让生产力爆表！&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxNDMwMTMwMw==&amp;amp;mid=2247538724&amp;amp;idx=1&amp;amp;sn=07b263cc1ac6b0d3c734574aeb4f7227&amp;amp;chksm=9b97793cace0f02ab1fbebf8aacbbe30163b893700fbd04bb3bc7cc306d89ab2eda8f902182a&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;SpringBoot+CAS这套单点登录通用方案，打通我司几十个系统，稳的一批！大Pass平台&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;2.SpringBoot+CAS这套单点登录通用方案，打通我司几十个系统，稳的一批！大Pass平台&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxNDMwMTMwMw==&amp;amp;mid=2247538709&amp;amp;idx=1&amp;amp;sn=0fe6c71db01493d384ce3afde9475b5c&amp;amp;chksm=9b97790dace0f01b4c997654dbad71bb0875cbafa84df897c501d0136cb91850ed967ad16393&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;MyBatisPlus又在搞事了！发布神器，一个依赖轻松搞定权限问题！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;.MyBatisPlus又在搞事了！发布神器，一个依赖轻松搞定权限问题！&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxNDMwMTMwMw==&amp;amp;mid=2247538597&amp;amp;idx=1&amp;amp;sn=f19606a3a13950aa3bb9064b05207233&amp;amp;chksm=9b9776bdace0ffab26b470f571a09fb38fb2a5587a37757c75a39ce3a45efa7e9548e521b746&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;SpringBoot+WebSocket实时监控异常，真的太顶了！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;.SpringBoot+WebSocket实时监控异常，真的太顶了！&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxNDMwMTMwMw==&amp;amp;mid=2247538592&amp;amp;idx=1&amp;amp;sn=1e46e6c99a50c5780c03d09471031eab&amp;amp;chksm=9b9776b8ace0ffae1749e26b812c55df5c60f55b0ea28e19ee2058e84563d7f7fefa51149b47&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;求求你以后别再乱用@Validated 和 @Valid 了，要不然把你同事都的搞疯！！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;求求你以后别再乱用@Validated 和 @Valid 了，要不然把你同事都的搞疯！！&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;6&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxNDMwMTMwMw==&amp;amp;mid=2247538587&amp;amp;idx=1&amp;amp;sn=63ad71280c84d241c345a5936246ae8d&amp;amp;chksm=9b977683ace0ff95d23d88a3b3ed8f50282ee1969c02c1d61cc8cd467a2798eb61daa2346a6e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;求求你别再手动部署jar包了，太low了！动态上传热部署真的太爽了！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;.求求你别再手动部署jar包了，太low了！动态上传热部署真的太爽了！&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;7&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxNDMwMTMwMw==&amp;amp;mid=2247538536&amp;amp;idx=1&amp;amp;sn=da822525b03e3bd8d64120a3a2d4602d&amp;amp;chksm=9b977670ace0ff66e8fae29299371e0d5fddeab156414becbda691e6c3e80b3f4ae3660e9e89&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;10G大文件上传最全方案：秒传、断点续传、分片上传，包教会！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;.10G大文件上传最全方案：秒传、断点续传、分片上传，包教会！&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;8.&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxNDMwMTMwMw==&amp;amp;mid=2247538517&amp;amp;idx=2&amp;amp;sn=5f87ece45fa7ea583c189b1e9a6b03f5&amp;amp;chksm=9b97764dace0ff5b9f30fb977c8b40fe95d0528e4d0a12ab15b2efc560efb105e8ef233f0bc5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;新技能 MyBatis 千万数据表，快速分页！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;新技能 MyBatis 千万数据表，快速分页！&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;9.&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxNDMwMTMwMw==&amp;amp;mid=2247538507&amp;amp;idx=1&amp;amp;sn=c1ef419328484e223ead06e3142c2369&amp;amp;chksm=9b977653ace0ff45a8121dc9960626208af7eb43ebe1c9e601d9afc0e7403ae795f8667c853b&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;最新 955 不加班的公司名单&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;最新 955 不加班的公司名单&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;10&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxNDMwMTMwMw==&amp;amp;mid=2247538494&amp;amp;idx=1&amp;amp;sn=11288e6e5d81038f84560cd226ba23da&amp;amp;chksm=9b977626ace0ff300e8e476ed3a301272d24b616386aeda3af26ee25bdc46158ab8e1365c36a&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;我这些年我用过的12 个企业级开源系统，亲测非常好用，非常适合公司开发&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;.我这些年我用过的12 个企业级开源系统，亲测非常好用，非常适合公司开发&lt;/a&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.30833333333333335&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WwPkUCFX4x4MHA9rPDtd9gNpfNOsRKlZdHiaTHx0NMsQg2sRNJpn5f2ncEZktssAthOznC80afHmuAuAbRY5TMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7f59ada35d67581c52564f43e64e88fb</guid>
<title>Java 基础常见知识点&amp;面试题总结(中)，2022 最新版！</title>
<link>https://toutiao.io/k/3wmokgz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-9scqi7&quot; options=&quot;[object Object]&quot;&gt;&lt;p data-first-child=&quot;&quot; data-pid=&quot;0DjCuIHW&quot;&gt;你好，我是 Guide。秋招即将到来，我对 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//javaguide.cn/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;JavaGuide&lt;/a&gt; 的内容进行了重构完善，公众号同步一下最新更新，希望能够帮助你。&lt;/p&gt;&lt;p data-pid=&quot;xtO5KVuI&quot;&gt;上篇：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/526448236&quot; class=&quot;internal&quot;&gt;Java 基础常见知识点&amp;amp;面试题总结(上)，2022 最新版！&lt;/a&gt;&lt;/p&gt;&lt;p data-pid=&quot;AQyFMyIE&quot;&gt;原文地址：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//javaguide.cn/java/basis/java-basic-questions-02.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Java基础常见知识&amp;amp;面试题总结(中)&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;面向对象基础&lt;/b&gt;&lt;/h2&gt;&lt;h3&gt;&lt;b&gt;面向对象和面向过程的区别&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;7Xk_sc4z&quot;&gt;两者的主要区别在于解决问题的方式不同：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;tJkdM8Jg&quot;&gt;面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。&lt;/li&gt;&lt;li data-pid=&quot;F5oe-YwM&quot;&gt;面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;uAq1RSwG&quot;&gt;另外，面向对象开发的程序一般更易维护、易复用、易扩展。&lt;/p&gt;&lt;p data-pid=&quot;_MYTAOFr&quot;&gt;相关 issue : &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Snailclimb/JavaGuide/issues/431&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;面向过程 ：面向过程性能比面向对象高？？&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;h3&gt;&lt;b&gt;成员变量与局部变量的区别&lt;/b&gt;&lt;/h3&gt;&lt;ul&gt;&lt;li data-pid=&quot;RqW2v1YE&quot;&gt;&lt;b&gt;语法形式&lt;/b&gt; ：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 &lt;code&gt;public&lt;/code&gt;,&lt;code&gt;private&lt;/code&gt;,&lt;code&gt;static&lt;/code&gt; 等修饰符所修饰，而局部变量不能被访问控制修饰符及 &lt;code&gt;static&lt;/code&gt; 所修饰；但是，成员变量和局部变量都能被 &lt;code&gt;final&lt;/code&gt; 所修饰。&lt;/li&gt;&lt;li data-pid=&quot;IpP6-I4S&quot;&gt;&lt;b&gt;存储方式&lt;/b&gt; ：从变量在内存中的存储方式来看,如果成员变量是使用 &lt;code&gt;static&lt;/code&gt; 修饰的，那么这个成员变量是属于类的，如果没有使用 &lt;code&gt;static&lt;/code&gt; 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。&lt;/li&gt;&lt;li data-pid=&quot;eRJiPPRU&quot;&gt;&lt;b&gt;生存时间&lt;/b&gt; ：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。&lt;/li&gt;&lt;li data-pid=&quot;TFeHiDY-&quot;&gt;&lt;b&gt;默认值&lt;/b&gt; ：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 &lt;code&gt;final&lt;/code&gt; 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;创建一个对象用什么运算符?对象实体与对象引用有何不同?&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;skxdzjs5&quot;&gt;new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。&lt;/p&gt;&lt;p data-pid=&quot;DmI62dCd&quot;&gt;一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;对象的相等和引用相等的区别&lt;/b&gt;&lt;/h3&gt;&lt;ul&gt;&lt;li data-pid=&quot;Z19Tk_Rz&quot;&gt;对象的相等一般比较的是内存中存放的内容是否相等。&lt;/li&gt;&lt;li data-pid=&quot;c10d5jXW&quot;&gt;引用相等一般比较的是他们指向的内存地址是否相等。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;类的构造方法的作用是什么?&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;l61FtTcx&quot;&gt;构造方法是一种特殊的方法，主要作用是完成对象的初始化工作。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;如果一个类没有声明构造方法，该程序能正确执行吗?&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;hyEiZOB-&quot;&gt;如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会再添加默认的无参数的构造方法了，我们一直在不知不觉地使用构造方法，这也是为什么我们在创建对象的时候后面要加一个括号（因为要调用无参的构造方法）。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;构造方法有哪些特点？是否可被 override?&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;1eiqSlgw&quot;&gt;构造方法特点如下：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;eC9epbln&quot;&gt;名字与类名相同。&lt;/li&gt;&lt;li data-pid=&quot;cQySc9pi&quot;&gt;没有返回值，但不能用 void 声明构造函数。&lt;/li&gt;&lt;li data-pid=&quot;RUG9CmF-&quot;&gt;生成类的对象时自动执行，无需调用。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;FQa9-77v&quot;&gt;构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;面向对象三大特征&lt;/b&gt;&lt;/h3&gt;&lt;h3&gt;&lt;b&gt;封装&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;guGm35kT&quot;&gt;封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了（当然现在还有很多其他方法 ，这里只是为了举例子）。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;public class Student {
    private int id;//id属性私有化
    private String name;//name属性私有化

    //获取id的方法
    public int getId() {
        return id;
    }

    //设置id的方法
    public void setId(int id) {
        this.id = id;
    }

    //获取name的方法
    public String getName() {
        return name;
    }

    //设置name的方法
    public void setName(String name) {
        this.name = name;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;&lt;b&gt;继承&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;hiFqNt67&quot;&gt;不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。&lt;/p&gt;&lt;p data-pid=&quot;6z_71ouL&quot;&gt;&lt;b&gt;关于继承如下 3 点请记住：&lt;/b&gt;&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;un34UhQ4&quot;&gt;子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，&lt;b&gt;只是拥有&lt;/b&gt;。&lt;/li&gt;&lt;li data-pid=&quot;hrR3D4Oa&quot;&gt;子类可以拥有自己属性和方法，即子类可以对父类进行扩展。&lt;/li&gt;&lt;li data-pid=&quot;T3_puBS3&quot;&gt;子类可以用自己的方式实现父类的方法。（以后介绍）。&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;&lt;b&gt;多态&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;xEiy04s-&quot;&gt;多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。&lt;/p&gt;&lt;p data-pid=&quot;H0pcZcdb&quot;&gt;&lt;b&gt;多态的特点:&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;qsUCobS9&quot;&gt;对象类型和引用类型之间具有继承（类）/实现（接口）的关系；&lt;/li&gt;&lt;li data-pid=&quot;DdapUHTv&quot;&gt;引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；&lt;/li&gt;&lt;li data-pid=&quot;hOMQJzvV&quot;&gt;多态不能调用“只在子类存在但在父类不存在”的方法；&lt;/li&gt;&lt;li data-pid=&quot;v39FZCGW&quot;&gt;如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;接口和抽象类有什么共同点和区别？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;4a94w1-1&quot;&gt;&lt;b&gt;共同点&lt;/b&gt; ：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;q8aamGzU&quot;&gt;都不能被实例化。&lt;/li&gt;&lt;li data-pid=&quot;9OlIbFvy&quot;&gt;都可以包含抽象方法。&lt;/li&gt;&lt;li data-pid=&quot;b0Df8R-I&quot;&gt;都可以有默认实现的方法（Java 8 可以用 &lt;code&gt;default&lt;/code&gt; 关键字在接口中定义默认方法）。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;SRH5OI0h&quot;&gt;&lt;b&gt;区别&lt;/b&gt; ：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;kyiXlZEZ&quot;&gt;接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系（比如说我们抽象了一个发送短信的抽象类，）。&lt;/li&gt;&lt;li data-pid=&quot;2tdA0aqM&quot;&gt;一个类只能继承一个类，但是可以实现多个接口。&lt;/li&gt;&lt;li data-pid=&quot;NabFSScm&quot;&gt;接口中的成员变量只能是 &lt;code&gt;public static final&lt;/code&gt; 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;深拷贝和浅拷贝区别了解吗？什么是引用拷贝？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;k5mQrrob&quot;&gt;关于深拷贝和浅拷贝区别，我这里先给结论：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;F2y-EvLD&quot;&gt;&lt;b&gt;浅拷贝&lt;/b&gt;：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。&lt;/li&gt;&lt;li data-pid=&quot;gVTNn_43&quot;&gt;&lt;b&gt;深拷贝&lt;/b&gt; ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;qr4X9Mky&quot;&gt;上面的结论没有完全理解的话也没关系，我们来看一个具体的案例！&lt;/p&gt;&lt;p data-pid=&quot;VqNtTy7v&quot;&gt;&lt;b&gt;浅拷贝&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;XQhxZXe0&quot;&gt;浅拷贝的示例代码如下，我们这里实现了 &lt;code&gt;Cloneable&lt;/code&gt; 接口，并重写了 &lt;code&gt;clone()&lt;/code&gt; 方法。&lt;/p&gt;&lt;p data-pid=&quot;VKI9OGfa&quot;&gt;&lt;code&gt;clone()&lt;/code&gt; 方法的实现很简单，直接调用的是父类 &lt;code&gt;Object&lt;/code&gt; 的 &lt;code&gt;clone()&lt;/code&gt; 方法。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;public class Address implements Cloneable{
    private String name;
    // 省略构造函数、Getter&amp;amp;Setter方法
    @Override
    public Address clone() {
        try {
            return (Address) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new AssertionError();
        }
    }
}

public class Person implements Cloneable {
    private Address address;
    // 省略构造函数、Getter&amp;amp;Setter方法
    @Override
    public Person clone() {
        try {
            Person person = (Person) super.clone();
            return person;
        } catch (CloneNotSupportedException e) {
            throw new AssertionError();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;xfCikeWz&quot;&gt;测试 ：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;Person person1 = new Person(new Address(&quot;武汉&quot;));
Person person1Copy = person1.clone();
// true
System.out.println(person1.getAddress() == person1Copy.getAddress());
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;GYmGUyCr&quot;&gt;从输出结构就可以看出， &lt;code&gt;person1&lt;/code&gt; 的克隆对象和 &lt;code&gt;person1&lt;/code&gt; 使用的仍然是同一个 &lt;code&gt;Address&lt;/code&gt; 对象。&lt;/p&gt;&lt;p data-pid=&quot;3-4_V9pE&quot;&gt;&lt;b&gt;深拷贝&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;QIkYuh90&quot;&gt;这里我们简单对 &lt;code&gt;Person&lt;/code&gt; 类的 &lt;code&gt;clone()&lt;/code&gt; 方法进行修改，连带着要把 &lt;code&gt;Person&lt;/code&gt; 对象内部的 &lt;code&gt;Address&lt;/code&gt; 对象一起复制。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;@Override
public Person clone() {
    try {
        Person person = (Person) super.clone();
        person.setAddress(person.getAddress().clone());
        return person;
    } catch (CloneNotSupportedException e) {
        throw new AssertionError();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;ovmSjx1j&quot;&gt;测试 ：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;Person person1 = new Person(new Address(&quot;武汉&quot;));
Person person1Copy = person1.clone();
// false
System.out.println(person1.getAddress() == person1Copy.getAddress());
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;yjprz84t&quot;&gt;从输出结构就可以看出，虽然 &lt;code&gt;person1&lt;/code&gt; 的克隆对象和 &lt;code&gt;person1&lt;/code&gt; 包含的 &lt;code&gt;Address&lt;/code&gt; 对象已经是不同的了。&lt;/p&gt;&lt;p data-pid=&quot;Yphwt-G3&quot;&gt;&lt;b&gt;那什么是引用拷贝呢？&lt;/b&gt; 简单来说，引用拷贝就是两个不同的引用指向同一个对象。&lt;/p&gt;&lt;p data-pid=&quot;s5mK2S7J&quot;&gt;我专门画了一张图来描述浅拷贝、深拷贝、引用拷贝：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-9b874d203c215855fa4e2e8ac4f16bbe_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1308&quot; data-rawheight=&quot;879&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-9b874d203c215855fa4e2e8ac4f16bbe_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1308&quot; data-rawheight=&quot;879&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-9b874d203c215855fa4e2e8ac4f16bbe_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-9b874d203c215855fa4e2e8ac4f16bbe_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;&lt;b&gt;Java 常见类&lt;/b&gt;&lt;/h2&gt;&lt;h3&gt;&lt;b&gt;Object&lt;/b&gt;&lt;/h3&gt;&lt;h3&gt;&lt;b&gt;Object 类的常见方法有哪些？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;3rpXPygE&quot;&gt;Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;/**
 * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。
 */
public final native Class&amp;lt;?&amp;gt; getClass()
/**
 * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。
 */
public native int hashCode()
/**
 * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。
 */
public boolean equals(Object obj)
/**
 * naitive 方法，用于创建并返回当前对象的一份拷贝。
 */
protected native Object clone() throws CloneNotSupportedException
/**
 * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。
 */
public String toString()
/**
 * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。
 */
public final native void notify()
/**
 * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。
 */
public final native void notifyAll()
/**
 * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。
 */
public final native void wait(long timeout) throws InterruptedException
/**
 * 多了 nanos 参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 毫秒。。
 */
public final void wait(long timeout, int nanos) throws InterruptedException
/**
 * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念
 */
public final void wait() throws InterruptedException
/**
 * 实例被垃圾回收器回收的时候触发的操作
 */
protected void finalize() throws Throwable { }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;&lt;b&gt;== 和 equals() 的区别&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;JpYsp_GG&quot;&gt;&lt;b&gt;&lt;code&gt;==&lt;/code&gt;&lt;/b&gt; 对于基本类型和引用类型的作用效果是不同的：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;rcBKInSH&quot;&gt;对于基本数据类型来说，&lt;code&gt;==&lt;/code&gt; 比较的是值。&lt;/li&gt;&lt;li data-pid=&quot;gssCZCLI&quot;&gt;对于引用数据类型来说，&lt;code&gt;==&lt;/code&gt; 比较的是对象的内存地址。&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-pid=&quot;EmcrQVaU&quot;&gt; 因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。&lt;br/&gt; &lt;/blockquote&gt;&lt;p data-pid=&quot;FN1wrp-H&quot;&gt;&lt;b&gt;&lt;code&gt;equals()&lt;/code&gt;&lt;/b&gt; 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。&lt;code&gt;equals()&lt;/code&gt;方法存在于&lt;code&gt;Object&lt;/code&gt;类中，而&lt;code&gt;Object&lt;/code&gt;类是所有类的直接或间接父类，因此所有的类都有&lt;code&gt;equals()&lt;/code&gt;方法。&lt;/p&gt;&lt;p data-pid=&quot;PMb1w54v&quot;&gt;&lt;code&gt;Object&lt;/code&gt; 类 &lt;code&gt;equals()&lt;/code&gt; 方法：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;public boolean equals(Object obj) {
     return (this == obj);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;Z0ZXnSts&quot;&gt;&lt;code&gt;equals()&lt;/code&gt; 方法存在两种使用情况：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;buIYJxxr&quot;&gt;&lt;b&gt;类没有重写 &lt;code&gt;equals()&lt;/code&gt;方法&lt;/b&gt; ：通过&lt;code&gt;equals()&lt;/code&gt;比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 &lt;code&gt;Object&lt;/code&gt;类&lt;code&gt;equals()&lt;/code&gt;方法。&lt;/li&gt;&lt;li data-pid=&quot;EOaYAxVh&quot;&gt;&lt;b&gt;类重写了 &lt;code&gt;equals()&lt;/code&gt;方法&lt;/b&gt; ：一般我们都重写 &lt;code&gt;equals()&lt;/code&gt;方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;-BK1hWME&quot;&gt;举个例子（这里只是为了举例。实际上，你按照下面这种写法的话，像 IDEA 这种比较智能的 IDE 都会提示你将 &lt;code&gt;==&lt;/code&gt; 换成 &lt;code&gt;equals()&lt;/code&gt; ）：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;String a = new String(&quot;ab&quot;); // a 为一个引用
String b = new String(&quot;ab&quot;); // b为另一个引用,对象的内容一样
String aa = &quot;ab&quot;; // 放在常量池中
String bb = &quot;ab&quot;; // 从常量池中查找
System.out.println(aa == bb);// true
System.out.println(a == b);// false
System.out.println(a.equals(b));// true
System.out.println(42 == 42.0);// true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;Q2-9-hI7&quot;&gt;&lt;code&gt;String&lt;/code&gt; 中的 &lt;code&gt;equals&lt;/code&gt; 方法是被重写过的，因为 &lt;code&gt;Object&lt;/code&gt; 的 &lt;code&gt;equals&lt;/code&gt; 方法是比较的对象的内存地址，而 &lt;code&gt;String&lt;/code&gt; 的 &lt;code&gt;equals&lt;/code&gt; 方法比较的是对象的值。&lt;/p&gt;&lt;p data-pid=&quot;-H22Ymf0&quot;&gt;当创建 &lt;code&gt;String&lt;/code&gt; 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 &lt;code&gt;String&lt;/code&gt; 对象。&lt;/p&gt;&lt;p data-pid=&quot;h_2bXvbM&quot;&gt;&lt;code&gt;String&lt;/code&gt;类&lt;code&gt;equals()&lt;/code&gt;方法：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;public boolean equals(Object anObject) {
    if (this == anObject) {
        return true;
    }
    if (anObject instanceof String) {
        String anotherString = (String)anObject;
        int n = value.length;
        if (n == anotherString.value.length) {
            char v1[] = value;
            char v2[] = anotherString.value;
            int i = 0;
            while (n-- != 0) {
                if (v1[i] != v2[i])
                    return false;
                i++;
            }
            return true;
        }
    }
    return false;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;&lt;b&gt;hashCode() 有什么用？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;UrYl6zfd&quot;&gt;&lt;code&gt;hashCode()&lt;/code&gt; 的作用是获取哈希码（&lt;code&gt;int&lt;/code&gt; 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。&lt;/p&gt;&lt;p data-pid=&quot;lZDnftOP&quot;&gt;&lt;code&gt;hashCode()&lt;/code&gt;定义在 JDK 的 &lt;code&gt;Object&lt;/code&gt; 类中，这就意味着 Java 中的任何类都包含有 &lt;code&gt;hashCode()&lt;/code&gt; 函数。另外需要注意的是： &lt;code&gt;Object&lt;/code&gt; 的 &lt;code&gt;hashCode()&lt;/code&gt; 方法是本地方法，也就是用 C 语言或 C++ 实现的，该方法通常用来将对象的内存地址转换为整数之后返回。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;public native int hashCode();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;rgOTCtpx&quot;&gt;散列表存储的是键值对(key-value)，它的特点是：&lt;b&gt;能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）&lt;/b&gt;&lt;/p&gt;&lt;h3&gt;&lt;b&gt;为什么要有 hashCode？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;vofD2QWv&quot;&gt;我们以“&lt;code&gt;HashSet&lt;/code&gt; 如何检查重复”为例子来说明为什么要有 &lt;code&gt;hashCode&lt;/code&gt;？&lt;/p&gt;&lt;p data-pid=&quot;h35VcB92&quot;&gt;下面这段内容摘自我的 Java 启蒙书《Head First Java》:&lt;/p&gt;&lt;blockquote data-pid=&quot;t5jW6rDB&quot;&gt; 当你把对象加入 &lt;code&gt;HashSet&lt;/code&gt; 时，&lt;code&gt;HashSet&lt;/code&gt; 会先计算对象的 &lt;code&gt;hashCode&lt;/code&gt; 值来判断对象加入的位置，同时也会与其他已经加入的对象的 &lt;code&gt;hashCode&lt;/code&gt; 值作比较，如果没有相符的 &lt;code&gt;hashCode&lt;/code&gt;，&lt;code&gt;HashSet&lt;/code&gt; 会假设对象没有重复出现。但是如果发现有相同 &lt;code&gt;hashCode&lt;/code&gt; 值的对象，这时会调用 &lt;code&gt;equals()&lt;/code&gt; 方法来检查 &lt;code&gt;hashCode&lt;/code&gt; 相等的对象是否真的相同。如果两者相同，&lt;code&gt;HashSet&lt;/code&gt; 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 &lt;code&gt;equals&lt;/code&gt; 的次数，相应就大大提高了执行速度。&lt;br/&gt; &lt;/blockquote&gt;&lt;p data-pid=&quot;4L2u4jGz&quot;&gt;其实， &lt;code&gt;hashCode()&lt;/code&gt; 和 &lt;code&gt;equals()&lt;/code&gt;都是用于比较两个对象是否相等。&lt;/p&gt;&lt;p data-pid=&quot;9PJDkJsR&quot;&gt;&lt;b&gt;那为什么 JDK 还要同时提供这两个方法呢？&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;ZmYc97oN&quot;&gt;这是因为在一些容器（比如 &lt;code&gt;HashMap&lt;/code&gt;、&lt;code&gt;HashSet&lt;/code&gt;）中，有了 &lt;code&gt;hashCode()&lt;/code&gt; 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进&lt;code&gt;HashSet&lt;/code&gt;的过程）！&lt;/p&gt;&lt;p data-pid=&quot;Nsx-9U5Z&quot;&gt;我们在前面也提到了添加元素进&lt;code&gt;HashSet&lt;/code&gt;的过程，如果 &lt;code&gt;HashSet&lt;/code&gt; 在对比的时候，同样的 &lt;code&gt;hashCode&lt;/code&gt; 有多个对象，它会继续使用 &lt;code&gt;equals()&lt;/code&gt; 来判断是否真的相同。也就是说 &lt;code&gt;hashCode&lt;/code&gt; 帮助我们大大缩小了查找成本。&lt;/p&gt;&lt;p data-pid=&quot;RvKOYYqq&quot;&gt;&lt;b&gt;那为什么不只提供 &lt;code&gt;hashCode()&lt;/code&gt; 方法呢？&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;eznKp2IJ&quot;&gt;这是因为两个对象的&lt;code&gt;hashCode&lt;/code&gt; 值相等并不代表两个对象就相等。&lt;/p&gt;&lt;p data-pid=&quot;nGX1l_U_&quot;&gt;&lt;b&gt;那为什么两个对象有相同的 &lt;code&gt;hashCode&lt;/code&gt; 值，它们也不一定是相等的？&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;Ane5pzW5&quot;&gt;因为 &lt;code&gt;hashCode()&lt;/code&gt; 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 &lt;code&gt;hashCode&lt;/code&gt; )。&lt;/p&gt;&lt;p data-pid=&quot;wkmL64Hv&quot;&gt;总结下来就是 ：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;I2JIpsF4&quot;&gt;如果两个对象的&lt;code&gt;hashCode&lt;/code&gt; 值相等，那这两个对象不一定相等（哈希碰撞）。&lt;/li&gt;&lt;li data-pid=&quot;lUtklhM4&quot;&gt;如果两个对象的&lt;code&gt;hashCode&lt;/code&gt; 值相等并且&lt;code&gt;equals()&lt;/code&gt;方法也返回 &lt;code&gt;true&lt;/code&gt;，我们才认为这两个对象相等。&lt;/li&gt;&lt;li data-pid=&quot;3sRumLkd&quot;&gt;如果两个对象的&lt;code&gt;hashCode&lt;/code&gt; 值不相等，我们就可以直接认为这两个对象不相等。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;j0g_21hu&quot;&gt;相信大家看了我前面对 &lt;code&gt;hashCode()&lt;/code&gt; 和 &lt;code&gt;equals()&lt;/code&gt; 的介绍之后，下面这个问题已经难不倒你们了。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;为什么重写 equals() 时必须重写 hashCode() 方法？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;JcLrvWiB&quot;&gt;因为两个相等的对象的 &lt;code&gt;hashCode&lt;/code&gt; 值必须是相等。也就是说如果 &lt;code&gt;equals&lt;/code&gt; 方法判断两个对象是相等的，那这两个对象的 &lt;code&gt;hashCode&lt;/code&gt; 值也要相等。&lt;/p&gt;&lt;p data-pid=&quot;0NY7PuM4&quot;&gt;如果重写 &lt;code&gt;equals()&lt;/code&gt; 时没有重写 &lt;code&gt;hashCode()&lt;/code&gt; 方法的话就可能会导致 &lt;code&gt;equals&lt;/code&gt; 方法判断是相等的两个对象，&lt;code&gt;hashCode&lt;/code&gt; 值却不相等。&lt;/p&gt;&lt;p data-pid=&quot;ovDn1kXT&quot;&gt;&lt;b&gt;思考&lt;/b&gt; ：重写 &lt;code&gt;equals()&lt;/code&gt; 时没有重写 &lt;code&gt;hashCode()&lt;/code&gt; 方法的话，使用 &lt;code&gt;HashMap&lt;/code&gt; 可能会出现什么问题。&lt;/p&gt;&lt;p data-pid=&quot;7CfGqOme&quot;&gt;&lt;b&gt;总结&lt;/b&gt; ：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;3bt3h44z&quot;&gt;&lt;code&gt;equals&lt;/code&gt; 方法判断两个对象是相等的，那这两个对象的 &lt;code&gt;hashCode&lt;/code&gt; 值也要相等。&lt;/li&gt;&lt;li data-pid=&quot;6RG0E5av&quot;&gt;两个对象有相同的 &lt;code&gt;hashCode&lt;/code&gt; 值，他们也不一定是相等的（哈希碰撞）。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;VwXLRUSB&quot;&gt;更多关于 &lt;code&gt;hashCode()&lt;/code&gt; 和 &lt;code&gt;equals()&lt;/code&gt; 的内容可以查看：&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.cnblogs.com/skywang12345/p/3324958.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Java hashCode() 和 equals()的若干问题解答&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;h3&gt;&lt;b&gt;String&lt;/b&gt;&lt;/h3&gt;&lt;h3&gt;&lt;b&gt;String、StringBuffer、StringBuilder 的区别？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;-KwVR_8e&quot;&gt;&lt;b&gt;可变性&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;4S2CdrJw&quot;&gt;&lt;code&gt;String&lt;/code&gt; 是不可变的（后面会详细分析原因）。&lt;/p&gt;&lt;p data-pid=&quot;Y6M99MZP&quot;&gt;&lt;code&gt;StringBuilder&lt;/code&gt; 与 &lt;code&gt;StringBuffer&lt;/code&gt; 都继承自 &lt;code&gt;AbstractStringBuilder&lt;/code&gt; 类，在 &lt;code&gt;AbstractStringBuilder&lt;/code&gt; 中也是使用字符数组保存字符串，不过没有使用 &lt;code&gt;final&lt;/code&gt; 和 &lt;code&gt;private&lt;/code&gt; 关键字修饰，最关键的是这个 &lt;code&gt;AbstractStringBuilder&lt;/code&gt; 类还提供了很多修改字符串的方法比如 &lt;code&gt;append&lt;/code&gt; 方法。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;abstract class AbstractStringBuilder implements Appendable, CharSequence {
    char[] value;
    public AbstractStringBuilder append(String str) {
        if (str == null)
            return appendNull();
        int len = str.length();
        ensureCapacityInternal(count + len);
        str.getChars(0, len, value, count);
        count += len;
        return this;
    }
   //...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;5QesLWoB&quot;&gt;&lt;b&gt;线程安全性&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;kW6i9NvB&quot;&gt;&lt;code&gt;String&lt;/code&gt; 中的对象是不可变的，也就可以理解为常量，线程安全。&lt;code&gt;AbstractStringBuilder&lt;/code&gt; 是 &lt;code&gt;StringBuilder&lt;/code&gt; 与 &lt;code&gt;StringBuffer&lt;/code&gt; 的公共父类，定义了一些字符串的基本操作，如 &lt;code&gt;expandCapacity&lt;/code&gt;、&lt;code&gt;append&lt;/code&gt;、&lt;code&gt;insert&lt;/code&gt;、&lt;code&gt;indexOf&lt;/code&gt; 等公共方法。&lt;code&gt;StringBuffer&lt;/code&gt; 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。&lt;code&gt;StringBuilder&lt;/code&gt; 并没有对方法进行加同步锁，所以是非线程安全的。&lt;/p&gt;&lt;p data-pid=&quot;kuhrNz3h&quot;&gt;&lt;b&gt;性能&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;pwu2PMXS&quot;&gt;每次对 &lt;code&gt;String&lt;/code&gt; 类型进行改变的时候，都会生成一个新的 &lt;code&gt;String&lt;/code&gt; 对象，然后将指针指向新的 &lt;code&gt;String&lt;/code&gt; 对象。&lt;code&gt;StringBuffer&lt;/code&gt; 每次都会对 &lt;code&gt;StringBuffer&lt;/code&gt; 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 &lt;code&gt;StringBuilder&lt;/code&gt; 相比使用 &lt;code&gt;StringBuffer&lt;/code&gt; 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。&lt;/p&gt;&lt;p data-pid=&quot;ualFcGsd&quot;&gt;&lt;b&gt;对于三者使用的总结：&lt;/b&gt;&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;_gOmiak5&quot;&gt;操作少量的数据: 适用 &lt;code&gt;String&lt;/code&gt;&lt;/li&gt;&lt;li data-pid=&quot;WQhPFmFd&quot;&gt;单线程操作字符串缓冲区下操作大量数据: 适用 &lt;code&gt;StringBuilder&lt;/code&gt;&lt;/li&gt;&lt;li data-pid=&quot;ak57wXyE&quot;&gt;多线程操作字符串缓冲区下操作大量数据: 适用 &lt;code&gt;StringBuffer&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;&lt;b&gt;String 为什么是不可变的?&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;vaL0HADL&quot;&gt;&lt;code&gt;String&lt;/code&gt; 类中使用 &lt;code&gt;final&lt;/code&gt; 关键字修饰字符数组来保存字符串，所以&lt;code&gt;String&lt;/code&gt; 对象是不可变的。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;public final class String implements java.io.Serializable, Comparable&amp;lt;String&amp;gt;, CharSequence {
    private final char value[];
 //...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote data-pid=&quot;pfK4IMRC&quot;&gt;   修正 ： 我们知道被 &lt;code&gt;final&lt;/code&gt; 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。因此，&lt;code&gt;final&lt;/code&gt; 关键字修饰的数组保存字符串并不是 &lt;code&gt;String&lt;/code&gt; 不可变的根本原因，因为这个数组保存的字符串是可变的（&lt;code&gt;final&lt;/code&gt; 修饰引用类型变量的情况）。&lt;br/&gt; &lt;code&gt;String&lt;/code&gt; 真正不可变有下面几点原因：&lt;br/&gt; &lt;/blockquote&gt;&lt;ol&gt;&lt;li data-pid=&quot;A6YLtGh1&quot;&gt;保存字符串的数组被 &lt;code&gt;final&lt;/code&gt; 修饰且为私有的，并且&lt;code&gt;String&lt;/code&gt; 类没有提供/暴露修改这个字符串的方法。&lt;/li&gt;&lt;li data-pid=&quot;UyKyQ5wS&quot;&gt;&lt;code&gt;String&lt;/code&gt; 类被 &lt;code&gt;final&lt;/code&gt; 修饰导致其不能被继承，进而避免了子类破坏 &lt;code&gt;String&lt;/code&gt; 不可变。&lt;/li&gt;&lt;/ol&gt;&lt;p data-pid=&quot;ODiQH-GX&quot;&gt; 相关阅读：&lt;b&gt;&lt;a href=&quot;https://www.zhihu.com/question/20618891/answer/114125846&quot; class=&quot;internal&quot;&gt;如何理解 String 类型值的不可变？ - 知乎提问&lt;/a&gt;&lt;/b&gt;&lt;br/&gt; 补充（来自&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Snailclimb/JavaGuide/issues/675&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;issue 675&lt;/a&gt;&lt;/b&gt;）：在 Java 9 之后，&lt;code&gt;String&lt;/code&gt; 、&lt;code&gt;StringBuilder&lt;/code&gt; 与 &lt;code&gt;StringBuffer&lt;/code&gt; 的实现改用 &lt;code&gt;byte&lt;/code&gt; 数组存储字符串。&lt;br/&gt; public final class String implements java.io.Serializable,Comparable&amp;lt;String&amp;gt;, CharSequence {&lt;br/&gt; &lt;i&gt;// @Stable 注解表示变量最多被修改一次，称为“稳定的”。&lt;/i&gt;&lt;br/&gt; @Stable&lt;br/&gt; private final byte[] value;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;abstract class AbstractStringBuilder implements Appendable, CharSequence {&lt;br/&gt; byte[] value;&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt; &lt;b&gt;Java 9 为何要将 &lt;code&gt;String&lt;/code&gt; 的底层实现由 &lt;code&gt;char[]&lt;/code&gt; 改成了 &lt;code&gt;byte[]&lt;/code&gt; ?&lt;/b&gt;&lt;br/&gt; 新版的 String 其实支持两个编码方案： Latin-1 和 UTF-16。如果字符串中包含的汉字没有超过 Latin-1 可表示范围内的字符，那就会使用 Latin-1 作为编码方案。Latin-1 编码方案下，&lt;code&gt;byte&lt;/code&gt; 占一个字节(8 位)，&lt;code&gt;char&lt;/code&gt; 占用 2 个字节（16），&lt;code&gt;byte&lt;/code&gt; 相较 &lt;code&gt;char&lt;/code&gt; 节省一半的内存空间。&lt;br/&gt; JDK 官方就说了绝大部分字符串对象只包含 Latin-1 可表示的字符。&lt;br/&gt; &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-64b74ac46dd7fe0334131d28a5851787_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;635&quot; data-rawheight=&quot;170&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-64b74ac46dd7fe0334131d28a5851787_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;635&quot; data-rawheight=&quot;170&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-64b74ac46dd7fe0334131d28a5851787_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-64b74ac46dd7fe0334131d28a5851787_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;4HYNZlVg&quot;&gt; 如果字符串中包含的汉字超过 Latin-1 可表示范围内的字符，&lt;code&gt;byte&lt;/code&gt; 和 &lt;code&gt;char&lt;/code&gt; 所占用的空间是一样的。&lt;br/&gt; 这是官方的介绍：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//openjdk.java.net/jeps/254&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;openjdk.java.net/jeps/2&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;54&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt; 。&lt;br/&gt; &lt;/p&gt;&lt;h3&gt;&lt;b&gt;字符串拼接用“+” 还是 StringBuilder?&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;M39JvTFz&quot;&gt;Java 语言本身并不支持运算符重载，“+”和“+=”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的元素符。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;String str1 = &quot;he&quot;;
String str2 = &quot;llo&quot;;
String str3 = &quot;world&quot;;
String str4 = str1 + str2 + str3;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;ap08oC0P&quot;&gt;上面的代码对应的字节码如下：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-6547eddb812a54c9ba649805ed866681_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1143&quot; data-rawheight=&quot;461&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-6547eddb812a54c9ba649805ed866681_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1143&quot; data-rawheight=&quot;461&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-6547eddb812a54c9ba649805ed866681_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-6547eddb812a54c9ba649805ed866681_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;P_ydK0t3&quot;&gt;可以看出，字符串对象通过“+”的字符串拼接方式，实际上是通过 &lt;code&gt;StringBuilder&lt;/code&gt; 调用 &lt;code&gt;append()&lt;/code&gt; 方法实现的，拼接完成之后调用 &lt;code&gt;toString()&lt;/code&gt; 得到一个 &lt;code&gt;String&lt;/code&gt; 对象 。&lt;/p&gt;&lt;p data-pid=&quot;-Rk2zfDz&quot;&gt;不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：&lt;b&gt;编译器不会创建单个 &lt;code&gt;StringBuilder&lt;/code&gt; 以复用，会导致创建过多的 &lt;code&gt;StringBuilder&lt;/code&gt; 对象&lt;/b&gt;。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;String[] arr = {&quot;he&quot;, &quot;llo&quot;, &quot;world&quot;};
String s = &quot;&quot;;
for (int i = 0; i &amp;lt; arr.length; i++) {
    s += arr[i];
}
System.out.println(s);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;AOoVg5fi&quot;&gt;&lt;code&gt;StringBuilder&lt;/code&gt; 对象是在循环内部被创建的，这意味着每循环一次就会创建一个 &lt;code&gt;StringBuilder&lt;/code&gt; 对象。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-31abbb6e2a3bb49fcbf5da2fd13a82fe_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1098&quot; data-rawheight=&quot;671&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-31abbb6e2a3bb49fcbf5da2fd13a82fe_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1098&quot; data-rawheight=&quot;671&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-31abbb6e2a3bb49fcbf5da2fd13a82fe_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-31abbb6e2a3bb49fcbf5da2fd13a82fe_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;bckhKsJ_&quot;&gt;如果直接使用 &lt;code&gt;StringBuilder&lt;/code&gt; 对象进行字符串拼接的话，就不会存在这个问题了。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;String[] arr = {&quot;he&quot;, &quot;llo&quot;, &quot;world&quot;};
StringBuilder s = new StringBuilder();
for (String value : arr) {
    s.append(value);
}
System.out.println(s);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e3e725a5e85058ff2dcb045ae9c96c7e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1072&quot; data-rawheight=&quot;601&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-e3e725a5e85058ff2dcb045ae9c96c7e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1072&quot; data-rawheight=&quot;601&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-e3e725a5e85058ff2dcb045ae9c96c7e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-e3e725a5e85058ff2dcb045ae9c96c7e_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;J943Ru0A&quot;&gt;如果你使用 IDEA 的话，IDEA 自带的代码检查机制也会提示你修改代码。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;String#equals() 和 Object#equals() 有何区别？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;c4jabJMA&quot;&gt;&lt;code&gt;String&lt;/code&gt; 中的 &lt;code&gt;equals&lt;/code&gt; 方法是被重写过的，比较的是 String 字符串的值是否相等。 &lt;code&gt;Object&lt;/code&gt; 的 &lt;code&gt;equals&lt;/code&gt; 方法是比较的对象的内存地址。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;字符串常量池的作用了解吗？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;Abpz0SlI&quot;&gt;&lt;b&gt;字符串常量池&lt;/b&gt; 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// 在堆中创建字符串对象”ab“
// 将字符串对象”ab“的引用保存在字符串常量池中
String aa = &quot;ab&quot;;
// 直接返回字符串常量池中字符串对象”ab“的引用
String bb = &quot;ab&quot;;
System.out.println(aa==bb);// true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;-YLDbdMI&quot;&gt;更多关于字符串常量池的介绍可以看一下 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//javaguide.cn/java/jvm/memory-area.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Java 内存区域详解&lt;/a&gt;&lt;/b&gt; 这篇文章。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;String s1 = new String(&quot;abc&quot;);这句话创建了几个字符串对象？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;Butwv0nr&quot;&gt;会创建 1 或 2 个字符串对象。&lt;/p&gt;&lt;p data-pid=&quot;g1d_k1PB&quot;&gt;1、如果字符串常量池中不存在字符串对象“abc”的引用，那么会在堆中创建 2 个字符串对象“abc”。&lt;/p&gt;&lt;p data-pid=&quot;hjvBK0KP&quot;&gt;示例代码（JDK 1.8）：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;String s1 = new String(&quot;abc&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;o5el4BTf&quot;&gt;对应的字节码：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d338d54eb9757926237c92f05ffb5234_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;821&quot; data-rawheight=&quot;208&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-d338d54eb9757926237c92f05ffb5234_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;821&quot; data-rawheight=&quot;208&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-d338d54eb9757926237c92f05ffb5234_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-d338d54eb9757926237c92f05ffb5234_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;St_ObzKO&quot;&gt;&lt;code&gt;ldc&lt;/code&gt; 命令用于判断字符串常量池中是否保存了对应的字符串对象的引用，如果保存了的话直接返回，如果没有保存的话，会在堆中创建对应的字符串对象并将该字符串对象的引用保存到字符串常量池中。&lt;/p&gt;&lt;p data-pid=&quot;VAivLgl9&quot;&gt;2、如果字符串常量池中已存在字符串对象“abc”的引用，则只会在堆中创建 1 个字符串对象“abc”。&lt;/p&gt;&lt;p data-pid=&quot;jMDtPko-&quot;&gt;示例代码（JDK 1.8）：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// 字符串常量池中已存在字符串对象“abc”的引用
String s1 = &quot;abc&quot;;
// 下面这段代码只会在堆中创建 1 个字符串对象“abc”
String s2 = new String(&quot;abc&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;PNBrEwMp&quot;&gt;对应的字节码：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c0403fa8e0d69111e09972512638e88d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;917&quot; data-rawheight=&quot;208&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-c0403fa8e0d69111e09972512638e88d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;917&quot; data-rawheight=&quot;208&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-c0403fa8e0d69111e09972512638e88d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-c0403fa8e0d69111e09972512638e88d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;oj0lCGCd&quot;&gt;这里就不对上面的字节码进行详细注释了，7 这个位置的 &lt;code&gt;ldc&lt;/code&gt; 命令不会在堆中创建新的字符串对象“abc”，这是因为 0 这个位置已经执行了一次 &lt;code&gt;ldc&lt;/code&gt; 命令，已经在堆中创建过一次字符串对象“abc”了。7 这个位置执行 &lt;code&gt;ldc&lt;/code&gt; 命令会直接返回字符串常量池中字符串对象“abc”对应的引用。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;intern 方法有什么作用?&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;k0ehISyW&quot;&gt;&lt;code&gt;String.intern()&lt;/code&gt; 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;Siwx_WA9&quot;&gt;如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。&lt;/li&gt;&lt;li data-pid=&quot;U1SmxCqr&quot;&gt;如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;YHSEdYCS&quot;&gt;示例代码（JDK 1.8） :&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// 在堆中创建字符串对象”Java“
// 将字符串对象”Java“的引用保存在字符串常量池中
String s1 = &quot;Java&quot;;
// 直接返回字符串常量池中字符串对象”Java“对应的引用
String s2 = s1.intern();
// 会在堆中在单独创建一个字符串对象
String s3 = new String(&quot;Java&quot;);
// 直接返回字符串常量池中字符串对象”Java“对应的引用
String s4 = s3.intern();
// s1 和 s2 指向的是堆中的同一个对象
System.out.println(s1 == s2); // true
// s3 和 s4 指向的是堆中不同的对象
System.out.println(s3 == s4); // false
// s1 和 s4 指向的是堆中的同一个对象
System.out.println(s1 == s4); //true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;&lt;b&gt;String 类型的变量和常量做“+”运算时发生了什么？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;Wjo6emJf&quot;&gt;先来看字符串不加 &lt;code&gt;final&lt;/code&gt; 关键字拼接的情况（JDK1.8）：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;String str1 = &quot;str&quot;;
String str2 = &quot;ing&quot;;
String str3 = &quot;str&quot; + &quot;ing&quot;;
String str4 = str1 + str2;
String str5 = &quot;string&quot;;
System.out.println(str3 == str4);//false
System.out.println(str3 == str5);//true
System.out.println(str4 == str5);//false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote data-pid=&quot;7GIq_NGV&quot;&gt;&lt;b&gt;注意&lt;/b&gt; ：比较 String 字符串的值是否相等，可以使用 &lt;code&gt;equals()&lt;/code&gt; 方法。 &lt;code&gt;String&lt;/code&gt; 中的 &lt;code&gt;equals&lt;/code&gt; 方法是被重写过的。 &lt;code&gt;Object&lt;/code&gt; 的 &lt;code&gt;equals&lt;/code&gt; 方法是比较的对象的内存地址，而 &lt;code&gt;String&lt;/code&gt; 的 &lt;code&gt;equals&lt;/code&gt; 方法比较的是字符串的值是否相等。如果你使用 &lt;code&gt;==&lt;/code&gt; 比较两个字符串是否相等的话，IDEA 还是提示你使用 &lt;code&gt;equals()&lt;/code&gt; 方法替换。&lt;br/&gt; &lt;/blockquote&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9b2d1f10d3386fc0202312df554fb374_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;750&quot; data-rawheight=&quot;294&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-9b2d1f10d3386fc0202312df554fb374_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;750&quot; data-rawheight=&quot;294&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-9b2d1f10d3386fc0202312df554fb374_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-9b2d1f10d3386fc0202312df554fb374_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;1hzDeXc-&quot;&gt;&lt;b&gt;对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;1Qy618Dt&quot;&gt;在编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 &lt;b&gt;常量折叠(Constant Folding)&lt;/b&gt; 的代码优化。《深入理解 Java 虚拟机》中是也有介绍到：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-74fa0364afebdd28aea199a76e9efed9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1123&quot; data-rawheight=&quot;437&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-74fa0364afebdd28aea199a76e9efed9_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1123&quot; data-rawheight=&quot;437&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-74fa0364afebdd28aea199a76e9efed9_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-74fa0364afebdd28aea199a76e9efed9_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;6eMN3Iad&quot;&gt;常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。&lt;/p&gt;&lt;p data-pid=&quot;-dRV-8HU&quot;&gt;对于 &lt;code&gt;String str3 = &quot;str&quot; + &quot;ing&quot;;&lt;/code&gt; 编译器会给你优化成 &lt;code&gt;String str3 = &quot;string&quot;;&lt;/code&gt; 。&lt;/p&gt;&lt;p data-pid=&quot;IkwYLKhP&quot;&gt;并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;gmxVwkFD&quot;&gt;基本数据类型( &lt;code&gt;byte&lt;/code&gt;、&lt;code&gt;boolean&lt;/code&gt;、&lt;code&gt;short&lt;/code&gt;、&lt;code&gt;char&lt;/code&gt;、&lt;code&gt;int&lt;/code&gt;、&lt;code&gt;float&lt;/code&gt;、&lt;code&gt;long&lt;/code&gt;、&lt;code&gt;double&lt;/code&gt;)以及字符串常量。&lt;/li&gt;&lt;li data-pid=&quot;fv_p1ePG&quot;&gt;&lt;code&gt;final&lt;/code&gt; 修饰的基本数据类型和字符串变量&lt;/li&gt;&lt;li data-pid=&quot;nTfJROUF&quot;&gt;字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&amp;lt;&amp;lt;、&amp;gt;&amp;gt;、&amp;gt;&amp;gt;&amp;gt; ）&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;isiY3UyL&quot;&gt;&lt;b&gt;引用的值在程序编译期是无法确定的，编译器无法对其进行优化。&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;zK4rm7r8&quot;&gt;对象引用和“+”的字符串拼接方式，实际上是通过 &lt;code&gt;StringBuilder&lt;/code&gt; 调用 &lt;code&gt;append()&lt;/code&gt; 方法实现的，拼接完成之后调用 &lt;code&gt;toString()&lt;/code&gt; 得到一个 &lt;code&gt;String&lt;/code&gt; 对象 。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;String str4 = new StringBuilder().append(str1).append(str2).toString();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;f3dzu1GB&quot;&gt;我们在平时写代码的时候，尽量避免多个字符串对象拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 &lt;code&gt;StringBuilder&lt;/code&gt; 或者 &lt;code&gt;StringBuffer&lt;/code&gt;。&lt;/p&gt;&lt;p data-pid=&quot;CN7KiBiP&quot;&gt;不过，字符串使用 &lt;code&gt;final&lt;/code&gt; 关键字声明之后，可以让编译器当做常量来处理。&lt;/p&gt;&lt;p data-pid=&quot;blD7OrEM&quot;&gt;示例代码：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;final String str1 = &quot;str&quot;;
final String str2 = &quot;ing&quot;;
// 下面两个表达式其实是等价的
String c = &quot;str&quot; + &quot;ing&quot;;// 常量池中的对象
String d = str1 + str2; // 常量池中的对象
System.out.println(c == d);// true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;UQuj_Ax_&quot;&gt;被 &lt;code&gt;final&lt;/code&gt; 关键字修改之后的 &lt;code&gt;String&lt;/code&gt; 会被编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就相当于访问常量。&lt;/p&gt;&lt;p data-pid=&quot;x5tIv4bc&quot;&gt;如果 ，编译器在运行时才能知道其确切值的话，就无法对其优化。&lt;/p&gt;&lt;p data-pid=&quot;VLXJO3us&quot;&gt;示例代码（&lt;code&gt;str2&lt;/code&gt; 在运行时才能确定其值）：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;final String str1 = &quot;str&quot;;
final String str2 = getStr();
String c = &quot;str&quot; + &quot;ing&quot;;// 常量池中的对象
String d = str1 + str2; // 在堆上创建的新的对象
System.out.println(c == d);// false
public static String getStr() {
      return &quot;ing&quot;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;&lt;b&gt;后记&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;FNkmufdR&quot;&gt;&lt;b&gt;近期文章精选&lt;/b&gt; ：&lt;/p&gt;&lt;p data-pid=&quot;EsGt_EDs&quot;&gt;&lt;b&gt;走近作者&lt;/b&gt; ：&lt;/p&gt;&lt;p data-pid=&quot;kVy03F6_&quot;&gt;如果本文对你有帮助的话，欢迎点赞&amp;amp;在看&amp;amp;分享，这对我继续分享&amp;amp;创作优质文章非常重要。感谢  &lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e80466d0f38681c14b89f73b4f14ef98</guid>
<title>数据库连接数设置多少合适？</title>
<link>https://toutiao.io/k/sxjkz9c</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;引子&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;很多工程师习惯于使用一个组件时，参数设置依赖于默认值。或者有时候希望依赖数据分析获取到更合适的值，最终发现考虑的数据过于片面或者数据难以收集最终还是拍脑袋决定了参数的大小。今天咱们就以数据库连接数参数为例说明怎么去设计参数。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;前提知识&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;先说明一下数据库连接数大小是什么概念。数据库连接数一般指数据库连接池。 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5466998754669987&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRlicuAAicKzzsfZorQwMibhcJ7WTEfiaFzNeqiaOMSxu2HGAAutgW3Z1icN71eSxbsQGCjwnUicQ3nR7T0nDg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;803&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由最小数据库连接数制约。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.44783715012722647&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicuAAicKzzsfZorQwMibhcJ7Wk7rNvUZichQSySUufIk9URaqcls4Hb9lJzwSMHbeOZJLaBQBppljypw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;786&quot;/&gt;&lt;/p&gt;&lt;p&gt;数据库连接池的最小连接数和最大连接数的设置要考虑到下列几个因素：&lt;/p&gt;&lt;p&gt;1.最大连接数&lt;/p&gt;&lt;p&gt;它(maxActive)是连接池能申请的最大连接数，如果数据库连接请求超过此数，后面的数据库连接请求将被加入到等待队列中，这会影响之后的数据库操作。&lt;/p&gt;&lt;p&gt;2. 最小连接数&lt;/p&gt;&lt;p&gt;它(minIdle)是连接池一直保持的数据库连接，所以如果应用程序对数据库连接的使用量不大，将会有大量的数据库连接资源被浪费。&lt;/p&gt;&lt;p&gt;3. 最小连接数与最大连接数差距&lt;/p&gt;&lt;p&gt;最小连接数与最大连接数相差太大，那么最先的连接请求将会获利，之后超过最小连接数量的连接请求等价于建立一个新的数据库连接。不过，这些大于最小连接数的数据库连接在使用完不会马上被释放，它将被放到连接池中等待重复使用或是空闲超时后被释放。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;怎样决定最大连接数？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;很多朋友觉得自己的系统需要很大的吞吐，并发量高，那就应该尽量将连接数设置的大一些。我们来看之前歪果仁做的一个实验：&lt;/p&gt;&lt;p&gt;歪果仁对 Oracle 数据库进行了压力测试，模拟 9600 个并发线程来操作数据库，每两次数据库操作之间 sleep 550ms，刚开始设置的线程池大小为 2048。&lt;/p&gt;&lt;p&gt;结果：&lt;/p&gt;&lt;p&gt;每个请求要在连接池队列里等待 33ms，获得连接之后，执行SQL需要耗时77ms, CPU 消耗维持在 95% 左右；&lt;/p&gt;&lt;p&gt;接下来，我们将连接池的大小改小点，设置成 1024，其他测试参数不变。&lt;/p&gt;&lt;p&gt;结果：&lt;/p&gt;&lt;p&gt;获取连接等待时长基本不变，但是 SQL 的执行耗时降低了。&lt;/p&gt;&lt;p&gt;接下来，我们再设置小些，连接池的大小降低到 96，并发数等其他参数不变。&lt;/p&gt;&lt;p&gt;结果：&lt;/p&gt;&lt;p&gt;每个请求在连接池队列中的平均等待时间为 1ms, SQL 执行耗时为 2ms.&lt;/p&gt;&lt;p&gt;其实，对于一般情况来说，最大连接数200是DBA看了都会害怕的数值。200个连接，就意味着有200个并发通道。从系统影响来说，并发量高时，它会影响CPU、内存、磁盘IO的指标，甚至可能打垮服务器。从业务影响来说，很多SQL并行执行，增加了SQL之间相互影响的几率，造成更高的锁等待率。&lt;/p&gt;&lt;p&gt;对服务端的影响可参考我之前对并发数研究的文章。这里要说明的是连接数是对数据库服务器的保护，对一般数据库服务器质量还可以的SSD硬盘设备，无慢查询，平均数据库处理时长在2ms以下的请求，最大连接数10可达到TPS到5000。对于一般的系统足够用。更精确的还是要靠实际压测结果。&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong data-brushtype=&quot;text&quot;&gt;编程一生&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;因为公众号平台更改了推送规则，如果不想错过内容，记得读完点一下“在看”，加个“星标”，这样每次新文章推送才会第一时间出现在你的订阅列表里。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;想知道自己错过了哪些更新，可参考我不定期更新的《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247487380&amp;amp;idx=2&amp;amp;sn=4e71d679e2c22f9c5af4ea3abc667b76&amp;amp;chksm=fafde53acd8a6c2c9d2fb5eb83de5e5a2e3f244a57fa275394d9d61a0cdfa154290fe7a21fe8&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;系列文章分类汇总&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;em&gt;&lt;strong&gt;系列文章分类汇总&lt;/strong&gt;&lt;/em&gt;&lt;/a&gt;》。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f659e9a3d68d6cd70d41a8fee15fa7bd</guid>
<title>【第2638期】前端安全之 CSRF 攻击原理和防护方法</title>
<link>https://toutiao.io/k/g24rvnn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;前言&lt;/p&gt;&lt;p&gt;各位要懂得保护自己。今日前端早读课文章由腾讯@camdyzeng分享。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;@camdyzeng：腾讯CSIG前端开发高级工程师。团队主要致力于前端相关技术的研究和在腾讯业务的应用，团队内部每周有内部分享会，有兴趣的读者可以加入我们或者参与一起讨论。邮箱：camdyzeng@qq.com。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;正文从这开始~~&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;关于 CSRF 你想知道的都在这里了。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;CSRF（Cross-site request forgery）简称：跨站请求伪造，学习 CSRF 攻击原理和防护方法是我们团队新成员的必修课，通常我都是先让新同学自己研究自己讲，然后我再通过其中细节再给他们讲一遍，讲的次数多了，也慢慢总结出一种比较容易理解的讲法。这里我整理成文分享给有需要的人。&lt;/p&gt;&lt;h4&gt;引言：必修课为什么选择 CSRF？&lt;/h4&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;CSRF 涉及到的前端知识点比较多，全面理解需要系统的学习 Cookie，前端跨域，HTTP 协议，web 浏览器等知识。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;理解 CSRF 攻击和防护方法是前端进阶要去，我也希望大家都能够掌握。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;个人兴趣，我个人对前端性能优化和前端安全比较感兴趣，也算参与和推动了公司内的 CSRF 防护方案从无到有的过程。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;一、CSRF 攻击原理&lt;/h4&gt;&lt;h5&gt;1、Cookie 的使用&lt;/h5&gt;&lt;p&gt;HTTP 是无状态协议，服务器只能根据当前请求的参数(包括 Head 和 Body 的数据)来判断本次请求需要达到的目的(Get 或者 Post 都一样)，服务器并不知道这个请求之前干了什么事，所以这就是无状态协议。&lt;/p&gt;&lt;p&gt;但是我们现实很多情况需要有状态，比如登录态的身份信息，网页上很多操作需要登录之后才能操作，比如相册的上传照片和删除照片等功能都需要登录之后才能操作。那么怎么判断登录态？(通常我会问如果你遇到这个问题你回怎么做？)，其实解决方案都是类似的，只能是每次 HTTP 请求都要把登录态信息(这里用 Key 表示)传给后台服务器，后台通过 Key 字段是判断用户合法性之后再处理这个请求要处理的敏感操作。&lt;/p&gt;&lt;p&gt;怎么方便的让每次 HTTP 请求都带上 Key？所以就设计出了 Cookie，这里列举 Cookie 主要的一些特性。&lt;/p&gt;&lt;h5&gt;2、CSRF 的攻击过程&lt;/h5&gt;&lt;p&gt;根据上面介绍，登录态 Cookie 的 Key 是浏览器默认自动携带的，Key 通常是会话 Cookie，只要浏览器不关闭，Key 一直存在。所以只要用户 A 曾经登录过相册网站(这里用 http://www.photo.com 举例)，浏览器没有关闭，用户在没有关闭的浏览器打开一个黑客网页(这里用 http://www.hacker.com)，黑客页面发送 HTTP 请求到 http://www.photo.com 的后台会默认带上 http://www.photo.com 的登录态 Cookie，也就能模拟用户 A 做一些增删改等敏感操作。Get 和 Post 都一样，这就是 CSRF 攻击原理。这种攻击过程也是最常见的攻击过程，后面还会介绍另外一种少见的攻击过程。&lt;/p&gt;&lt;h5&gt;3、读操作能否被攻击到？&lt;/h5&gt;&lt;p&gt;上面说的增删改都是写操作，会对后台数据产生负面影响，所以是能被攻击的。另外一种读操作，是具有幂等性，不会对后台数据残生负面影响，能否被攻击到？读操作也可能是敏感数据，举个例子，比如www.photo.com上的私密相册数据能否被www.hacker.com页面拿到？这就涉及到前端跨域知识点了，默认大部分情况是拿不到，这里列举两种特殊情是可以拿到的：&lt;/p&gt;&lt;p&gt;除了这两种特殊情况，读操作都是不能被攻击到的，因为浏览器跨域限制是天然的安全的。&lt;/p&gt;&lt;h4&gt;二、CSRF 防护方法&lt;/h4&gt;&lt;p&gt;知道攻击原理，防护方法也很简单，找到能够区分请求发送的页面是自己的页面还是黑客的页面的方法就可以了。&lt;/p&gt;&lt;h5&gt;1、Referrer&lt;/h5&gt;&lt;p&gt;HTTP 请求头 Referrer 字段是浏览器默认带上，含义是发送请求的页面地址，比如同样是删除相册的操作http://www.photo.com/del?id=xxx;如果是从相册自己页面发送出来，Referrre的值是http://www.photo.com/index.html（以首页举例），如果是从黑客页面发送出来的Referrer的值是http://www.hacker.com/index.html（以首页举例），所以后端只要通过Referrrer做白名单判断就能防这种常见的CSRF攻击。下面探讨几个容易被忽悠的问题。&lt;/p&gt;&lt;h6&gt;1.1 Referrer 会不会被伪造或者篡改？&lt;/h6&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;在浏览器环境下，Referrer 是浏览器自己带上的，js 是改不了 Rerferrer，所以是不能被伪造和篡改的。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;浏览器插件能改 Referrer 么？答案：能改，但是浏览器插件攻击不属于 CSRF 攻击范畴，如果用户浏览器都已经被安装了黑客插件了就有更方便的攻击方法，但是不可能在所有用户浏览器都安装上黑客的插件。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;通过网关或者抓包修改 Referrer？答案：能改，这是中间人攻击，也不属于 CSRF 攻击范畴。防中间人攻击用 HTTPS。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;黑客通过自己后台代理，请求发到黑客自己的后台，黑客后台修改 Referrer 再转发到相册后台，可以改么？可行么？答案：能改，但不可行，请求发送到黑客自己后台不会带上相册的 Cookie，登录态校验通不过，敏感操作做不了。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h6&gt;1.2 用 Referrer 防 CSRF 安全么？&lt;/h6&gt;&lt;p&gt;处理了下面几种特殊情况，用 Referrer 防 CSRF 是安全&lt;/p&gt;&lt;p&gt;写操作不能用 Get，如果写操作可以用 Get，由于 Img 标签，A 标签能发 Get 请求。所以在一些 UGC 网站，比如用户写日志可以插入自定义图片，能插入自定义连接，图片 img 标签 src 或者 A 标签的 href 就指向写操作的 URL，这样只要打开这篇日志就会发送这个 Get 请求，或者点击了日志上的连接，就帮用户做了写操作。并且 Referrer 还是合法的。这就是一种少见的 CSRF 攻击过程，其实也是最早期的 CSRF 攻击。这种攻击一旦成功，很方便做成蠕虫病毒，危害性极大。_PS 有人觉得这种少见的攻击过程不算 CSRF，应该算 XSS，好像也有点道理，但是常规的防 XSS 的方法貌似不好防这种特殊情况，下面要讲的 CSRF 的 Token 的防护方式是能防这种特殊情况的。&lt;/p&gt;&lt;h6&gt;1.3 用 Origin 可以么？&lt;/h6&gt;&lt;p&gt;可以，原理跟 Referrer 一样，Origin 请求头是 XHR2.0 里增加的，含义是发送请求页面的域名，主要目的是解决跨域问题。如果用来校验 CSRF 请求，就有一些细节要处理好，后台判断 Origin 时也要使用白名单，并且不能为空，不在白名单内的请求都直接返回失败，不能执行请求里的写操作(有一些 web server 是请求执行了，也返回了数据，只是没有配 ACAO 响应头，浏览器收不到，这种情况能限制跨域请求，但是不能防 CSRF 的写操作)。另外一种做法就是自定义 HTTP 请求头，把 HTTP 请求升级为复杂请求，这样在跨域的情况就会先发一个 Option 预检请求，预检请求通不过也就不会执行后面真实请求了。&lt;/p&gt;&lt;h6&gt;1.4 既然能做到安全，为什么现在很少见用这种方案？&lt;/h6&gt;&lt;p&gt;因为有更简单的方案，就是下面要讲的 Token 方案。&lt;/p&gt;&lt;h5&gt;2、Token&lt;/h5&gt;&lt;p&gt;上面讲到 Cookie 的一些特性的第二条，读写 Cookie 有跨域限制(作用域，Domain,Path)，所以我们可以用这个特性来区分是自己页面还是黑客页面。只要页面能读（或者写）www.photo.com域名 Cookie,就证明是自己的页面。懂了原理，方案就很简单，比如服务器通过 cookie 下发一个 token，token 值是随机数，页面发请求的时候从 cookie 取出 token 通过 HTTP 请求参数传给后台，后台比对参数里的 token 和 cookie 里的 token 是否一致，如果一致就证明是自己页面发的请求，如果不一致就返回失败。防 CSRF 的方案就是这么简单，这种方法能够 100%防 CSRF，但是可能会有几个变种，下面探讨几种情况。&lt;/p&gt;&lt;h6&gt;2.1 Token 是前台生产还是后台生产？&lt;/h6&gt;&lt;p&gt;我上面举例例子是后台生成传到前台的，大家发现其实后台并没有存这个 token，所以原理上前后台生成都可以，只要保证随机性。如果前端生成 token 然后写到 Cookie 里，然后 HTTP 请求参数也带上 token，后端逻辑一样比对参数里的 token 和 cookie 里的 token 是否一致，如果一致就证明是自己页面发的请求，如果不一致就返回失败。这就是 Cookie 读和写的差别，只要能读写自己域名的 Cookie 就是自己页面。&lt;/p&gt;&lt;h6&gt;2.2 推荐的最佳实践方案&lt;/h6&gt;&lt;p&gt;由于登录态已经下发了一个登录态 key，防 CSRF 的 token 就复用这个 key，由于登录态 key 比较重要，尽量少明文暴露，所以前端拿到 key 后做了一次 Hash 放到 http 请求参数里，后端通过同样的 Hash 算法对 Cookie 里的 key 做 Hash 后跟参数里的 token 比对是否一致，如果一致就证明是自己页面发的请求，如果不一致就返回失败。这里对 Hash 算法要求不高，简单高效就可以。&lt;/p&gt;&lt;h6&gt;2.3 Token 放在 HTTP 参数里的哪里？&lt;/h6&gt;&lt;p&gt;放在 URL 的 querystring 里，Post 请求的 Data 里或者 HTTP 请求头里，这三种方式都可以，只是有一点点细微的差别，如果 querystring 里，可能会影响 Get 请求的缓存效果，因为重新登录之后 token 会变，url 也就变了，之前的缓存就失效了。如果放在 HTTP 请求头里，就需要使用 fetch 或者 XHR 发请求，这样会变成复杂请求，跨域时需要多一次 Option 预检请求，对性能多少有一点点影响。&lt;/p&gt;&lt;h6&gt;2.4 用 Token 方案后写操作可以用 Get 么？&lt;/h6&gt;&lt;p&gt;可以，从安全角度考虑是可以的，用了 Token 之后，Get 和 Post 的安全等级是一样的，上面讨论的那种少见的 CSRF 攻击过程也攻击不到了。但是从语义化考虑建议 Get 是还是处理读操作方便理解。&lt;/p&gt;&lt;h6&gt;2.5 用 Token 方案后读操作可以用 JSONP 跨域么？&lt;/h6&gt;&lt;p&gt;可以，可以使用 JSONP 跨域了，另外如果使用 CORS 处理跨域，建议还是需要对请求头的 Origin 做白名单限制，防止不同子域名相互影响。&lt;/p&gt;&lt;h6&gt;2.6 如果页面有 XSS 漏洞，黑客拿到 Cookie 怎么办？&lt;/h6&gt;&lt;p&gt;这个方法防不了 XSS，防 XSS 需要其他方法，比如 CSP,用户输入/输出做转义等。&lt;/p&gt;&lt;h4&gt;3、是否还有其他方案&lt;/h4&gt;&lt;h5&gt;3.1 Cookie 的 SameSite 属性可以么？&lt;/h5&gt;&lt;p&gt;不好用，SameSite 设计的目的貌似就是防 CSRF，但是我觉得不好用，SameSite 有三个值 Strict/Lax/None，设置的太严格，会影响自己业务的体验，设置的太松没有效果，就算最严格 Strict 模式，也防不了我上面提到写操作用 Get 请求，UGC 页面有自定义照片的情况。并且还有小部分老浏览器不支持，最终其实还是 Token 方案好用。&lt;/p&gt;&lt;h5&gt;3.2 Cookie 的 HTTPOnly 属性可以么？&lt;/h5&gt;&lt;p&gt;不行，HTTPOnly 表示这个 Cookie 只能是 HTTP 请求可以读写，js 没有读写权限，浏览器还是会默认带上，所以登录态校验是通过的。如果设置了 HTTPOnly 还有副作用，上面说的 Token 方案就用不了了。&lt;/p&gt;&lt;h5&gt;3.3 验证码可以么？&lt;/h5&gt;&lt;p&gt;不行，验证码是用来防机器暴力攻击的，验证码是用来确认敏感操作是自然人发送还是机器自动发送。这里举个图片验证码的例子，大概原理是前端通过 img 标签展示图片验证码给用户看(图片字母经过噪音处理的)，这个图片 HTTP 请求也会设置一个 cookie 如 codeID=xxx(加密的),用户在输入框输入图片中展示的字母，敏感操作的 HTTP 请求通过参数把用户输入的 code 传给后台，后台拿到用户输入的 code 和 cookie 里的 codeID(通常需要通过 id 查数据库)做比较，如果一致就通过。这种验证码系统能够防机器攻击，但是防不了 CSRF，黑客同样可以在黑客的页面展示验证码给用户，通过诱导用户输入验证码完成攻击操作，只能是提高了 CSRF 攻击成功的门槛，但是只要黑客页面诱导信息劲爆还是有很大部分用户会上当的。因为用户不知道输入验证码后会产生什么影响。&lt;/p&gt;&lt;p&gt;验证码我在一些资料上看到说可以用来防 CSRF，我个人觉得是不行，包括手机验证码都不行，详细情况大家可以研究各种验证码的实现原理。我猜测有些人可能有不同意见，但是如果非要构造一种能防 CSRF 的验证码技术上也是可行的。我这里推演一下防护过程。就拿我上面举得验证码举例。验证码图片的 url 是固定格式的http://code.photo.com/codeImg.jpg?v=123。v是随机数，换一张时防止缓存用的。验证码每次请求会种一个Cookie,codeID=xxx,后台会存储这个codeID对应的真实code，用户输入图片看到验证码，要校验验证码的请求参数会带上用户输入的code，后台拿到参数code和Cookie里的CodeID查数据库后对比来判断是否输入正确。攻击方式，黑客可以在黑客页面用img标签展示这个验证码，因为验证码url是固定格式的，后面的流程是一样的。你可能的改进方案：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;验证码图片做防盗链。黑客破解方案：可以用 Referrer-Policy 的 no-referrer&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;no-referrer 不给通过。黑客破解方案：可以用 iframe 嵌入你自己的页面，只把你自己页面种的验证码区域展示出来&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;我的页面不给 iframe 嵌入。黑客说，你成功的防住了&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;所以需要对验证码做(1)(2)(3)的改造才能防 CSRF 攻击。其实加的(1)(2)(3)措施都不是验证码的本意，验证码是本意用来的防机器攻击的，不加(1)(2)(3)措施也一样可以防机器攻击。这里就有三种观点了。观点一：我只要找到一个反例，找到验证码不能防 CSRF 的一个例子，我就证明了验证码不能防 CSRF。观点二：我只要构造一个能防的例子，对验证码做一系列额外的改造来防 CSRF，我就证明了验证码能防 CSRF。观点三：验证码提高了攻击门槛，攻防就是魔高一丈道高一尺的过程，加上验证码更安全。我个人赞成观点一。读者们你们觉得呢？&lt;/p&gt;&lt;h5&gt;3.4 HTTPS 可以么？&lt;/h5&gt;&lt;p&gt;不行，HTTPS 是防中间人攻击的，不是防 CSRF 的&lt;/p&gt;&lt;h5&gt;3.5 不用 Cookie 可以么？&lt;/h5&gt;&lt;p&gt;可以。个人觉得非常不好用，这里讨论两种方案。&lt;/p&gt;&lt;p&gt;方案一：登录态 key 不放在 Cookie。所以 HTTP 请求也不会自动携带 key，也就不存在 CSRF 漏洞，也就不用防了。但是这种设计我个人觉得在一些大型复杂网站是非常棘手难搞的，因为涉及到新开页面，多个页面之间登录态需要同步(其中一个页面退出登录，登录另外账户，或者登录态过期续期等都需要同步给其他页面)，跨页面通讯也有好多方案，如果你使用 localstorage 等本地缓存的话，关闭页面还要清理缓存，缓存满了要清理，浏览器兼容问题等。这种大型系统还会遇到其他的一系列问题，也会有一些列的解决方案，系统会比较复杂，最终还不如用 Cookie 方便。&lt;/p&gt;&lt;p&gt;方案二：登录态 key 放 Cookie。CSRF 的 Token 不放 Cookie，后台生成 Token 藏在 HTML 页面里，后台也存了这个 Token。HTTP 请求通过参数带上这个 Token，后台拿到参数里的 Token 跟自己后台存的 Token 做校验。这个方案也是在一些资料里看到的。但是这个方案也是相当复杂，比如这个方案需要处理好几个关键问题，这个 Token 是有用户属性，要跟用户绑定的。如果 Token 跟用户无关，那么黑客可以用自己账户的 Token 欺骗做水平攻击。另外也有新开页面，多个页面是同一个 Token 还是不同 Token？如果不同 Token，后台需要存一个 Token 列表，列表长度有最大值？另外还有如果其中一个页面退出登录，再登录另外账户。那么其他页面登录态是同步了，但是 Token 如何同步？同样你也会有一些列的解决方案。当你把这些问题都解决了，最后你发现既然 Token 有用户属性，那么就可以当登录态用，就不用 Cookie 的登录态 key 了，又回到了方案一。&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于本文&lt;br/&gt;作者：@曾健&lt;br/&gt;原文：https://zhuanlan.zhihu.com/p/522562168&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4166666666666667&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;720&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/meG6Vo0MevgiaJGuXA28v4rRxoibyhrCjcAWn51S1CYXu0S95uXBUZTn6z15bA8ARkzAhdqgwxSBSl3lFCFAPbGg/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为你推荐&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;amp;mid=2651223127&amp;amp;idx=1&amp;amp;sn=dc7ac5a1757fa152e253a828a62f8125&amp;amp;chksm=bd49add38a3e24c51cab6e745ac07abccf88ff83ee37187369a0662dbd56328fd9317f4583ab&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;【第712期】前后端分离架构下CSRF防御机制&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【第712期】前后端分离架构下CSRF防御机制&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;amp;mid=2651225720&amp;amp;idx=1&amp;amp;sn=780700316f7c3c245b6366269cc9257d&amp;amp;chksm=bd49a7fc8a3e2eeaccaff02f223f95fe249baa5523578a9dd3988e04caef472c29b9da47f289&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;【第849期】如何让前端更安全？——XSS攻击和防御详解&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【第849期】如何让前端更安全？——XSS攻击和防御详解&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;欢迎自荐投稿，前端早读课等你。&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>