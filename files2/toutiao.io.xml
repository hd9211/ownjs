<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>083ba4851def872a5d5de52dd01cce64</guid>
<title>Golang 调试分析的高阶技巧</title>
<link>https://toutiao.io/k/p2sogse</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5268817204301075&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsesdolc6YJHWRf1C8UTPs3scrsXWFoCHYsntUfbpKFrDicJ5tFbLPxBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;186&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;大纲&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5520833333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsl8Q8jryjW8fJDBj8r4A48RcHDMj7ibJfRRhRWSJUUWNTqiaibDr9dmstQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;192&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Golang tools&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;nm&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;compile&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;objdump&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;pprof&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;trace&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;单元测试&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;程序 Debug&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;小技巧&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;总结&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5268817204301075&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsesdolc6YJHWRf1C8UTPs3scrsXWFoCHYsntUfbpKFrDicJ5tFbLPxBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;186&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;Golang 高阶调试&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5520833333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsl8Q8jryjW8fJDBj8r4A48RcHDMj7ibJfRRhRWSJUUWNTqiaibDr9dmstQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;192&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文专注 golang debug 的一些技巧应用，以及相关工具的实用用法，再也不用怕 golang 怎么调试。golang 作为一门现代化语音，出生的时候就自带完整的 debug 手段：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;golang tools 是直接集成在语言工具里，支持内存分析，cpu分析，阻塞锁分析等；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;delve，gdb 作为最常用的 debug 工具，让你能够更深入的进入程序调试；&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;delve 当前是最友好的 golang 调试程序，ide 调试其实也是调用 dlv 而已，比如 goland；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;单元测试的设计深入到语言设计级别，可以非常方便执行单元测试并且生成代码覆盖率；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Golang tools&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;golang 从语言原生层面就集成了大量的实用工具，这些都是 Robert Griesemer, Rob Pike, Ken Thompson 这几位大神经验沉淀下的精华。你安装好 golang 之后，执行 &lt;code&gt;go tool&lt;/code&gt; 就能看到内置支持的所有工具了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;root@ubuntu:~&lt;span&gt;# go tool&lt;/span&gt;&lt;br/&gt;addr2line&lt;br/&gt;asm&lt;br/&gt;buildid&lt;br/&gt;cgo&lt;br/&gt;compile&lt;br/&gt;cover&lt;br/&gt;dist&lt;br/&gt;doc&lt;br/&gt;fix&lt;br/&gt;link&lt;br/&gt;nm&lt;br/&gt;objdump&lt;br/&gt;pack&lt;br/&gt;pprof&lt;br/&gt;test2json&lt;br/&gt;trace&lt;br/&gt;vet&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我这里专注挑选几个 debug 常用的：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;nm：查看符号表（等同于系统 &lt;code&gt;nm&lt;/code&gt; 命令）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;objdump：反汇编工具，分析二进制文件（等同于系统 &lt;code&gt;objdump&lt;/code&gt; 命令）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;pprof：指标，性能分析工具&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;cover：生成代码覆盖率&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;trace：采样一段时间，指标跟踪分析工具&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;compile：代码汇编&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;nm&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看符号表的命令，等同于系统的 nm 命令，非常有用。在断点的时候，如果你不知道断点的函数符号，那么用这个命令查一下就知道了（命令处理的是二进制程序文件）。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# exmple 为你编译的二进制文件&lt;/span&gt;&lt;br/&gt;go tool nm ./example&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一列是地址，第二列是类型，第三列是符号：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img data-ratio=&quot;0.43540183112919634&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChOjKKUqUH7qJInwJdQGPKmtzErnNyN1xZP029OJnpl4Ira8cQ7tq9YK42ibXEaBszVyLnEibZzSBYibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;983&quot;/&gt;&lt;span/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;compile&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;汇编某个文件&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go tool compile -N -l -S example.go&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你就能看到你 golang 语言对应的汇编代码了（注意了，命令处理的是 golang 代码文本），酷。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;objdump&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反汇编二进制的工具，等同于系统 &lt;code&gt;objdump&lt;/code&gt;（注意了，命令解析的是二进制格式的程序文件）。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go tool objdump example.o&lt;br/&gt;go tool objdump -s DoFunc example.o  // 反汇编具体函数&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;汇编代码这个东西在 90% 的场景可能都用不上，但是如果你处理过 c 的程序，在某些特殊场景，通过反汇编一段逻辑来推断应用程序行为将是你唯一的出路。因为线上的代码一般都是会开启编译优化，所以这里会导致你的代码对不上。再者，线上不可能让你随意 attach 进程，很多时候都是出 core 了，你就只有一个 core 文件去排查。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;pprof&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;pprof 支持四种类型的分析：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;CPU ：CPU 分析，采样消耗 cpu 的调用，这个一般用来定位排查程序里耗费计算资源的地方；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Memroy ：内存分析，一般用来排查内存占用，内存泄露等问题；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Block ：阻塞分析，会采样程序里阻塞的调用情况；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Mutex ：互斥锁分析，采样互斥锁的竞争情况；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们这里详细以内存占用分析举例（其他的类似），pprof 这个是内存分析神器。基本上，golang 有了这个东西，99% 的内存问题（比如内存泄露，内存占用过大等等）都是可以非常快的定位出来的。首先，对于 golang 的内存分析（或者其他的锁消耗，cpu 消耗）我们明确几个重要的点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;golang 内存 pprof 是采样的，每 512KB 采样一次；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;golang 的内存采样的是堆栈路径，而不是类型信息；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;golang 的内存采样入口一定是通过&lt;code&gt;mProf_Malloc&lt;/code&gt;，&lt;code&gt;mProf_Free&lt;/code&gt; 这两个函数。所以，如果是 cgo 分配的内存，那么是没有机会调用到这两个函数的，所以如果是 cgo 导致的内存问题，go tool pprof 是分析不出来的；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;详细原理，可以复习另一篇文章：内存分析；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分析的形式有两种：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果是 &lt;code&gt;net/http/pporf&lt;/code&gt; 方式开启的，那么可以直接在控制台上输入，浏览器就能看；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;另一种方式是先把信息 dump 到本地文件，然后用 &lt;code&gt;go tool&lt;/code&gt; 去分析（我们以这个举例，因为这种方式才是生产环境通用的方式）&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 查看累计分配占用&lt;/span&gt;&lt;br/&gt;go tool pprof -alloc_space ./29075_20190523_154406_heap&lt;br/&gt;&lt;span&gt;# 查看当前的分配占用&lt;/span&gt;&lt;br/&gt;go tool pprof -inuse_space ./29075_20190523_154406_allocs&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你也可以不指定类型，直接 &lt;code&gt;go tool pprof ./xxx&lt;/code&gt; ，进入分析之后，调用 &lt;code&gt;o&lt;/code&gt; 选项，指定类型：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我写了一个 demo 程序，然后 dump 出了一份 heap 的 pprof 采样文件，我们先通过这个 pprof 得出一些结论，最后我再贴出源代码，再品一品。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go tool pprof ./29075_20190523_154406_heap&lt;br/&gt;(pprof) o              &lt;br/&gt;...          &lt;br/&gt;  sample_index              = inuse_space          //: [alloc_objects | alloc_space | inuse_objects | inuse_space]&lt;br/&gt;...       &lt;br/&gt;(pprof) alloc_space&lt;br/&gt;(pprof) top&lt;br/&gt;Showing nodes accounting &lt;span&gt;for&lt;/span&gt; 290MB, 100% of 290MB total&lt;br/&gt;      flat  flat%   sum%        cum   cum%&lt;br/&gt;     140MB 48.28% 48.28%      140MB 48.28%  main.funcA (inline)&lt;br/&gt;     100MB 34.48% 82.76%      190MB 65.52%  main.funcB (inline)&lt;br/&gt;      50MB 17.24%   100%      140MB 48.28%  main.funcC (inline)&lt;br/&gt;         0     0%   100%      290MB   100%  main.main&lt;br/&gt;         0     0%   100%      290MB   100%  runtime.main&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个 top 信息表明了这么几点信息：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;main.funcA&lt;/code&gt;  这个函数现场分配了 140M 的内存，&lt;code&gt;main.funcB&lt;/code&gt; 这个函数现场分配了 100M 内存，&lt;code&gt;main.funcC&lt;/code&gt; 现场分配了 50M 内存；&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;现场的意思：纯粹自己函数直接分配的，而不是调用别的函数分配的；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这些信息通过 flat 得知；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;main.funcA&lt;/code&gt;  分配的 140M 内存纯粹是自己分配的，没有调用别的函数分配过内存；&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这个信息通过 &lt;code&gt;main.funcA&lt;/code&gt; flat 和 cum 都为 140 M 得出；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;main.funcB&lt;/code&gt;  自己分配了 100MB，并且还调用了别的函数，别的函数里面涉及了 90M 的内存分配；&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这个信息通过 &lt;code&gt;main.funcB&lt;/code&gt; flat 和 cum 分别为 100 M，190M 得出；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;main.funcC&lt;/code&gt;  自己分配了 50MB，并且还调用了别的函数，别的函数里面涉及了 90M 的内存分配；&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这个信息通过 &lt;code&gt;main.funcC&lt;/code&gt; flat 和 cum 分别为 50 M，140 M 得出；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;main.main&lt;/code&gt; ：所有分配内存的函数调用都是走这个函数出去的。main 函数本身没有函数分配，但是他调用的函数分配了 290M；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;demo 的源代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;net/http&quot;&lt;/span&gt;&lt;br/&gt; _ &lt;span&gt;&quot;net/http/pprof&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;funcA&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; []&lt;span&gt;byte&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; a := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; a&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;funcB&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;([]&lt;span&gt;byte&lt;/span&gt;, []&lt;span&gt;byte&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; a := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;)&lt;br/&gt; b := funcA()&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; a, b&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;funcC&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;([]&lt;span&gt;byte&lt;/span&gt;, []&lt;span&gt;byte&lt;/span&gt;, []&lt;span&gt;byte&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; a := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;)&lt;br/&gt; b, c := funcB()&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; a, b, c&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;5&lt;/span&gt;; i++ {&lt;br/&gt;  funcA()&lt;br/&gt;  funcB()&lt;br/&gt;  funcC()&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; http.ListenAndServe(&lt;span&gt;&quot;0.0.0.0:9999&quot;&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;dump 命令&lt;/strong&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;curl -sS &lt;span&gt;&#x27;http://127.0.0.1:9999/debug/pprof/heap?seconds=5&#x27;&lt;/span&gt; -o heap.pporf&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对照着代码，再品一品。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;trace&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序 trace 调试&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go tool trace -http=&lt;span&gt;&quot;:6060&quot;&lt;/span&gt; ./ssd_336959_20190704_105540_trace&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;trace 这个命令允许你跟踪采集一段时间的信息，然后 dump 成文件，最后调用 &lt;code&gt;go tool trace&lt;/code&gt; 分析 dump 文件，并且以 web 的形式打开。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5268817204301075&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsesdolc6YJHWRf1C8UTPs3scrsXWFoCHYsntUfbpKFrDicJ5tFbLPxBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;186&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;单元测试&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5520833333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsl8Q8jryjW8fJDBj8r4A48RcHDMj7ibJfRRhRWSJUUWNTqiaibDr9dmstQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;192&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单元测试的重要性就不再论述。golang 里面 &lt;code&gt;_test.go&lt;/code&gt; 结尾的文件认为是测试文件，golang 作为现代化的语言，语言工具层面支持单元测试。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;执行单元测试&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行单元测试有两种方式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;go test 直接运行，这个是最简单的；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;先编译测试文件，再运行。这种方式更灵活；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;go test 运行&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 直接在你项目目录里运行 go &lt;span&gt;test&lt;/span&gt; .&lt;br/&gt;go &lt;span&gt;test&lt;/span&gt; .&lt;br/&gt;// 指定运行函数&lt;br/&gt;go &lt;span&gt;test&lt;/span&gt; -run=TestPutAndGetKeyValue&lt;br/&gt;// 打印详细信息&lt;br/&gt;go &lt;span&gt;test&lt;/span&gt; -v&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;编译，运行&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本质上，golang 跑单测是先编译 &lt;code&gt;*_test.go&lt;/code&gt; 文件，编译成二进制后，再运行这个二进制文件。你执行 &lt;code&gt;go test&lt;/code&gt; 的时候，工具帮你做好了，这些动作其实也是可以拆开来自己做的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译生成单元测试可执行文件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 先编译出 .&lt;span&gt;test&lt;/span&gt; 文件&lt;br/&gt;$ go &lt;span&gt;test&lt;/span&gt; -c &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 指定跑某一个文件&lt;br/&gt;$ ./raftexample.test -test.timeout=10m0s -test.v=&lt;span&gt;true&lt;/span&gt; -test.run=TestPutAndGetKeyValue&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式通常会出现在以下几种场景：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这台机器上编译，另一个地方跑单测；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;debug 单测程序；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;统计代码覆盖率&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;golang 的代码覆盖率是基于单测的，由单测作为出发点，来看你的业务代码覆盖率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;操作很简单：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;加一个 &lt;code&gt;-coverprofile&lt;/code&gt; 的参数，声明在跑单测的时候，记录代码覆盖率；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用 &lt;code&gt;go tool cover&lt;/code&gt; 命令分析，得出覆盖率报告；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go &lt;span&gt;test&lt;/span&gt; -coverprofile=coverage.out&lt;br/&gt;go tool cover -func=coverage.out&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类似如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;root@ubuntu:~/opensource/readcode-etcd-master/src/go.etcd.io/etcd/contrib/raftexample&lt;span&gt;# go tool cover -func=coverage.out&lt;/span&gt;&lt;br/&gt;go.etcd.io/etcd/v3/contrib/raftexample/httpapi.go:33: ServeHTTP  25.0%&lt;br/&gt;go.etcd.io/etcd/v3/contrib/raftexample/httpapi.go:108: serveHttpKVAPI  0.0%&lt;br/&gt;go.etcd.io/etcd/v3/contrib/raftexample/kvstore.go:41: newKVStore  100.0%&lt;br/&gt;go.etcd.io/etcd/v3/contrib/raftexample/kvstore.go:50: Lookup   100.0%&lt;br/&gt;go.etcd.io/etcd/v3/contrib/raftexample/kvstore.go:57: Propose   75.0%&lt;br/&gt;go.etcd.io/etcd/v3/contrib/raftexample/kvstore.go:71: readCommits  55.0%&lt;br/&gt;go.etcd.io/etcd/v3/contrib/raftexample/kvstore.go:107: getSnapshot  100.0%&lt;br/&gt;go.etcd.io/etcd/v3/contrib/raftexample/kvstore.go:113: recoverFromSnapshot 85.7%&lt;br/&gt;go.etcd.io/etcd/v3/contrib/raftexample/listener.go:30: newStoppableListener 75.0%&lt;br/&gt;go.etcd.io/etcd/v3/contrib/raftexample/listener.go:38: Accept   92.9%&lt;br/&gt;go.etcd.io/etcd/v3/contrib/raftexample/main.go:24: main   0.0%&lt;br/&gt;total:       (statements)  57.1%&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样的话，你就知道每个函数的代码覆盖率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5268817204301075&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsesdolc6YJHWRf1C8UTPs3scrsXWFoCHYsntUfbpKFrDicJ5tFbLPxBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;186&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;程序 Debug&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5520833333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsl8Q8jryjW8fJDBj8r4A48RcHDMj7ibJfRRhRWSJUUWNTqiaibDr9dmstQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;192&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序的调试主要由两个工具：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;dlv&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;gdb&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里推荐 dlv，因为 gdb 功能实在是有限，gdb 不理解 golang 的业务类型和协程。但是 gdb 有一个功能是无法替代的，就是 gcore 的功能。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;dlv 调试用法&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;调试二进制&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;dlv &lt;span&gt;exec&lt;/span&gt; &amp;lt;path/to/binary&amp;gt; [flags]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;dlv &lt;span&gt;exec&lt;/span&gt; ./example&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;dlv 调试二进制，并带参数&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;dlv &lt;span&gt;exec&lt;/span&gt; ./example -- --audit=./d&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;调试进程&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;dlv attach &lt;span&gt;${pid}&lt;/span&gt; [executable] [flags]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进程号是必选的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;dlv attach 12808 ./example&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;调试 core 文件&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;dlv 调试core文件；并且标准输出导出到文件&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;dlv core &amp;lt;executable&amp;gt; &amp;lt;core&amp;gt; [flags]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;dlv core ./example core.277282&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;调试常用语法&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;系统整理&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;程序运行&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;call ：call 函数（注意了，这个会导致整个程序运行的）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;continue ：往下运行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;next ：单步调试&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;restart ：重启&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;step ：单步调试，某个函数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;step-instruction ：单步调试某个汇编指令&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;stepout ：从当前函数跳出&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;断点相关&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;break (alias: b) ：设置断点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;breakpoints (alias: bp)  ：打印所有的断点信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;clear ：清理断点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;clearall ：清理所有的断点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;condition (alias: cond)  ：设置条件断点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;on ：设置一段命令，当断点命中的时候&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;trace (alias: t) ：设置一个跟踪点，这个跟踪点也是一个断点，只不过运行道德时候不会断住程序，只是打印一行信息，这个命令在某些场景是很有用的，比如你断住程序就会影响逻辑（业务有超时），而你仅仅是想打印某个变量而已，那么用这种类型的断点就行；；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;信息打印&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;args : 打印程序的传参&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;examinemem (alias: x)  ：这个是神器，解析内存用的，和 gdb 的 x 命令一样；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;locals ：打印本地变量&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;print (alias: p) ：打印一个表达式，或者变量&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;regs ：打印寄存器的信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;set ：set 赋值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;vars ：打印全局变量（包变量）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;whatis ：打印类型信息&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;协程相关&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;goroutine (alias: gr) ：打印某个特定协程的信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;goroutines (alias: grs)  ：列举所有的协程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;thread (alias: tr) ：切换到某个线程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;threads ：打印所有的线程信息&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;栈相关&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;deferred ：在 defer 函数上下文里执行命令&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;down ：上堆栈&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;frame ：跳到某个具体的堆栈&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;stack (alias: bt)  ：打印堆栈信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;up ：下堆栈&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;其他命令&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;config ：配置变更&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;disassemble (alias: disass) ：反汇编&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;edit (alias: ed) ：略&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;exit (alias: quit | q) ：略&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;funcs ：打印所有函数符号&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;libraries ：打印所有加载的动态库&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;list (alias: ls | l) ：显示源码&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;source ：加载命令&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;sources ：打印源码&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;types ：打印所有类型信息&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是完整的 dlv 的支持的命令，从这个来看，是完全满足我们的调试需求的（有的只适用于开发调试环节，比如线上的程序不可能让你随意单步调试的，有的使用于线上生产环节）。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;应用举例&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;打印全局变量&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;(dlv) vars&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个非常有用，帮助你看一些全局变量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;条件断点&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 先断点&lt;/span&gt;&lt;br/&gt;(dlv) b &lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 查看断点信息&lt;/span&gt;&lt;br/&gt;(dlv) bp&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 然后定制条件&lt;/span&gt;&lt;br/&gt;(dlv) condition 2 i==2 &amp;amp;&amp;amp; j==7 &amp;amp;&amp;amp; z==32&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;查看堆栈&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 展示所有堆栈&lt;/span&gt;&lt;br/&gt;(dlv) goroutines&lt;br/&gt;&lt;span&gt;# 所有堆栈展开&lt;/span&gt;&lt;br/&gt;(dlv) goroutines -t&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;解析内存&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;(dlv) x -fmt hex -len 20 0xc00008af38&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;x&lt;/code&gt; 命令和 gdb 的 &lt;code&gt;x&lt;/code&gt; 是一样的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;gdb 调试&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;gdb 对 golang 的调试支持是通过一个 python 脚本文件 &lt;code&gt;src/runtime/runtime-gdb.py&lt;/code&gt; 来扩展的，所以功能非常有限。gdb 只能做到最基本的变量打印，却理解不了 golang 的一些特殊类型，比如 channel，map，slice 等，gdb 原生是无法调适 goroutine 协程的，因为这个是用户态的调度单位，gdb 只能理解线程。所以只能通过 python 脚本的扩展，把协程结构按照链表输出出来，支持的命令：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img data-ratio=&quot;0.43457943925233644&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChOjKKUqUH7qJInwJdQGPKmtKelWeTNYiaWaDr9BrbjuyC4YORJcKttKnlMyNl6ZGUQs17a9Qksedbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;428&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;gdb当前只支持6个命令：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3个 cmd 命令&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;info goroutines；打印所有的goroutines&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;goroutine ${id} bt；打印一个goroutine的堆栈&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;iface；打印静态或者动态的接口类型&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3个函数&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;len；打印string，slices，map，channels 这四种类型的长度&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;cap；打印slices，channels 这两种类型的cap&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;dtype；强制转换接口到动态类型。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;打印全局变量&lt;/strong&gt; (注意单引号)&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;(gdb) p &lt;span&gt;&#x27;runtime.firstmoduledata&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于 gdb 不理解 golang 的一些类型系统，所以调试打印的时候经常打印不出来，这个要注意下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;打印数组变量长度&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;(gdb) p &lt;span&gt;$len&lt;/span&gt;(xxx)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，我一般只用 gdb 来 gcore 而已。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5268817204301075&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsesdolc6YJHWRf1C8UTPs3scrsXWFoCHYsntUfbpKFrDicJ5tFbLPxBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;186&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;小技巧&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5520833333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsl8Q8jryjW8fJDBj8r4A48RcHDMj7ibJfRRhRWSJUUWNTqiaibDr9dmstQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;192&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;不知道怎么断点函数？&lt;span/&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候不知道怎么断点函数：可以通过nm查询下，然后再断点，就一定能断到了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img data-ratio=&quot;0.22040816326530613&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChOjKKUqUH7qJInwJdQGPKmtJjIAnEVLaCISe9ibaPELKN18v9GprR970Jonh6mSCAjNjxuwlcEFkYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;980&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img data-ratio=&quot;0.07482014388489208&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChOjKKUqUH7qJInwJdQGPKmtvtDBf67HhQantibQ4RscF07VSNic1lMkDXJTlsSPL1pnDFianLT3Wic5Sw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;695&quot;/&gt;&lt;span/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;不知道调用上下文？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在你的代码里添加一行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;debug.PrintStack()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就能当前代码位置的堆栈给打印出来，这样你就直到怎么函数的调用路径了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;不知道怎么开启 pprof ？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;pprof 功能有两种开启方式，对应两种包：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;net/http/pprof ：使用在 web 服务器的场景；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;runtime/pprof  ：使用在非服务器应用程序的场景；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两个本质上是一致的，&lt;code&gt;net/http/pporf&lt;/code&gt; 也只是在 &lt;code&gt;runtime/pprof&lt;/code&gt; 上的一层 web 封装。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;code&gt;net/http/pprof&lt;/code&gt; 方式&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;import _ &lt;span&gt;&quot;net/http/pprof&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;code&gt;runtime/pprof&lt;/code&gt; 方式&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种通常用于程序调优的场景，程序只是一个应用程序，跑一次就结束，你想找到瓶颈点，那么通常会使用到这个方式。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;// cpu pprof 文件路径&lt;/span&gt;&lt;br/&gt;    f, err := os.Create(&lt;span&gt;&quot;cpufile.pprof&quot;&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  log.Fatal(err)&lt;br/&gt; }&lt;br/&gt;    &lt;span&gt;// 开启 cpu pprof&lt;/span&gt;&lt;br/&gt; pprof.StartCPUProfile(f)&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; pprof.StopCPUProfile()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;为什么有时候单点调试的时候，总是非预期的执行代码？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种情况一般是被编译器优化了，比如函数内联了，编译出的二进制删减了无效逻辑、无效参数。这种情况就会导致你 dlv 单步调试的时候，总是非预期的执行，或者打印某些变量打印不出来。这种情况解决方法就是：禁止编译优化。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go build -gcflags &lt;span&gt;&quot;-N -l&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5268817204301075&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsesdolc6YJHWRf1C8UTPs3scrsXWFoCHYsntUfbpKFrDicJ5tFbLPxBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;186&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;总结&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5520833333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsl8Q8jryjW8fJDBj8r4A48RcHDMj7ibJfRRhRWSJUUWNTqiaibDr9dmstQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;192&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该篇文章系统的分享了 golang 程序调试的技巧和用法：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;语言工具包里内置 tool 工具，支持汇编，反汇编，pprof 分析，符号表查询等实用功能；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;语言工具包集成单元测试，代码覆盖率依赖于单元测试的触发；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;常用 dlv/gdb 这两个工具作为大杀器，可以分析二进制，进程，core 文件；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1141daa7f27b7e551d2b728134268f2b</guid>
<title>Go 什么时候会触发 GC？</title>
<link>https://toutiao.io/k/rmtthaf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是煎鱼。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 语言作为一门新语言，在早期经常遭到唾弃的就是在垃圾回收（下称：GC）机制中 STW（Stop-The-World）的时间过长。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么这个时候，我们又会好奇一点，作为 STW 的起始，Go 语言中什么时候才会触发 GC 呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天就由煎鱼带大家一起来学习研讨一轮。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;什么是 GC&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在计算机科学中，垃圾回收（GC）是一种自动管理内存的机制，垃圾回收器会去尝试回收程序不再使用的对象及其占用的内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最早 John McCarthy 在 1959 年左右发明了垃圾回收，以简化 Lisp 中的手动内存管理的机制（来自 @wikipedia）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3930769230769231&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4gfRBhtlmurGILyzqmfnUXY08RQiaLVL8PsbRv9nR0A13VAaicRrIScibEbQggaNkZQRgrDqsVxyINoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2600&quot;/&gt;&lt;figcaption&gt;图来自网络&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;为什么要 GC&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;手动管理内存挺麻烦，管错或者管漏内存也很糟糕，将会直接导致程序不稳定（持续泄露）甚至直接崩溃。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;GC 触发场景&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GC 触发的场景主要分为两大类，分别是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;系统触发：运行时自行根据内置的条件，检查、发现到，则进行 GC 处理，维护整个应用程序的可用性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;手动触发：开发者在业务代码中自行调用 &lt;code&gt;runtime.GC&lt;/code&gt; 方法来触发 GC 行为。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;系统触发&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在系统触发的场景中，Go 源码的 &lt;code&gt;src/runtime/mgc.go&lt;/code&gt; 文件，明确标识了 GC 系统触发的三种场景，分别如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; (&lt;br/&gt; gcTriggerHeap gcTriggerKind = &lt;span&gt;iota&lt;/span&gt;&lt;br/&gt; gcTriggerTime&lt;br/&gt; gcTriggerCycle&lt;br/&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;gcTriggerHeap：当所分配的堆大小达到阈值（由控制器计算的触发堆的大小）时，将会触发。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;gcTriggerTime：当距离上一个 GC 周期的时间超过一定时间时，将会触发。-时间周期以 &lt;code&gt;runtime.forcegcperiod&lt;/code&gt; 变量为准，默认 2 分钟。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;gcTriggerCycle：如果没有开启 GC，则启动 GC。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;手动触发&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在手动触发的场景下，Go 语言中仅有 &lt;code&gt;runtime.GC&lt;/code&gt; 方法可以触发，也就没什么额外的分类的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.14311926605504588&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4gfRBhtlmurGILyzqmfnUXYFvK6uSYyJRewEXuORVqXqks4d0QXR0pckqpvX3Dnk7Yx0KYqdfDic0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2180&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但我们要思考的是，一般我们在什么业务场景中，要涉及到手动干涉 GC，强制触发他呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要手动强制触发的场景极其少见，可能会是在某些业务方法执行完后，因其占用了过多的内存，需要人为释放。又或是 debug 程序所需。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;基本流程&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在了解到 Go 语言会触发 GC 的场景后，我们进一步看看触发 GC 的流程代码是怎么样的，我们可以借助手动触发的 &lt;code&gt;runtime.GC&lt;/code&gt; 方法来作为突破口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;核心代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;GC&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; n := atomic.Load(&amp;amp;work.cycles)&lt;br/&gt; gcWaitOnMark(n)&lt;br/&gt;&lt;br/&gt; gcStart(gcTrigger{kind: gcTriggerCycle, n: n + &lt;span&gt;1&lt;/span&gt;})&lt;br/&gt;  &lt;br/&gt; gcWaitOnMark(n + &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; atomic.Load(&amp;amp;work.cycles) == n+&lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp; sweepone() != ^&lt;span&gt;uintptr&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;  sweep.nbgsweep++&lt;br/&gt;  Gosched()&lt;br/&gt; }&lt;br/&gt;  &lt;br/&gt; &lt;span&gt;for&lt;/span&gt; atomic.Load(&amp;amp;work.cycles) == n+&lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp; atomic.Load(&amp;amp;mheap_.sweepers) != &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;  Gosched()&lt;br/&gt; }&lt;br/&gt;  &lt;br/&gt; mp := acquirem()&lt;br/&gt; cycle := atomic.Load(&amp;amp;work.cycles)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; cycle == n+&lt;span&gt;1&lt;/span&gt; || (gcphase == _GCmark &amp;amp;&amp;amp; cycle == n+&lt;span&gt;2&lt;/span&gt;) {&lt;br/&gt;  mProf_PostSweep()&lt;br/&gt; }&lt;br/&gt; releasem(mp)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在开始新的一轮 GC 周期前，需要调用 &lt;code&gt;gcWaitOnMark&lt;/code&gt; 方法上一轮 GC 的标记结束（含扫描终止、标记、或标记终止等）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;开始新的一轮 GC 周期，调用 &lt;code&gt;gcStart&lt;/code&gt; 方法触发 GC 行为，开始扫描标记阶段。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;需要调用 &lt;code&gt;gcWaitOnMark&lt;/code&gt; 方法等待，直到当前 GC 周期的扫描、标记、标记终止完成。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;需要调用 &lt;code&gt;sweepone&lt;/code&gt; 方法，扫描未扫除的堆跨度，并持续扫除，保证清理完成。在等待扫除完毕前的阻塞时间，会调用 &lt;code&gt;Gosched&lt;/code&gt; 让出。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在本轮 GC 已经基本完成后，会调用 &lt;code&gt;mProf_PostSweep&lt;/code&gt; 方法。以此记录最后一次标记终止时的堆配置文件快照。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;结束，释放 M。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;在哪触发&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看完 GC 的基本流程后，我们有了一个基本的了解。但可能又有小伙伴有疑惑了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文的标题是 “GC 什么时候会触发 GC”，虽然我们前面知道了触发的时机。但是....Go 是哪里实现的触发的机制，似乎在流程中完全没有看到？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;监控线程&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实质上在 Go 运行时（runtime）初始化时，会启动一个 goroutine，用于处理 GC 机制的相关事项。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;go&lt;/span&gt; forcegchelper()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;forcegchelper&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; forcegc.g = getg()&lt;br/&gt; lockInit(&amp;amp;forcegc.lock, lockRankForcegc)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;  lock(&amp;amp;forcegc.lock)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; forcegc.idle != &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;   throw(&lt;span&gt;&quot;forcegc: phase error&quot;&lt;/span&gt;)&lt;br/&gt;  }&lt;br/&gt;  atomic.Store(&amp;amp;forcegc.idle, &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;  goparkunlock(&amp;amp;forcegc.lock, waitReasonForceGCIdle, traceEvGoBlock, &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;// this goroutine is explicitly resumed by sysmon&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; debug.gctrace &amp;gt; &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;println&lt;/span&gt;(&lt;span&gt;&quot;GC forced&quot;&lt;/span&gt;)&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  gcStart(gcTrigger{kind: gcTriggerTime, now: nanotime()})&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这段程序中，需要特别关注的是在 &lt;code&gt;forcegchelper&lt;/code&gt; 方法中，会调用 &lt;code&gt;goparkunlock&lt;/code&gt; 方法让该 goroutine 陷入休眠等待状态，以减少不必要的资源开销。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在休眠后，会由 &lt;code&gt;sysmon&lt;/code&gt; 这一个系统监控线程来进行监控、唤醒等行为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;sysmon&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; ...&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;  ...&lt;br/&gt;  &lt;span&gt;// check if we need to force a GC&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; t := (gcTrigger{kind: gcTriggerTime, now: now}); t.test() &amp;amp;&amp;amp; atomic.Load(&amp;amp;forcegc.idle) != &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;   lock(&amp;amp;forcegc.lock)&lt;br/&gt;   forcegc.idle = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;var&lt;/span&gt; list gList&lt;br/&gt;   list.push(forcegc.g)&lt;br/&gt;   injectglist(&amp;amp;list)&lt;br/&gt;   unlock(&amp;amp;forcegc.lock)&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; debug.schedtrace &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; lasttrace+&lt;span&gt;int64&lt;/span&gt;(debug.schedtrace)*&lt;span&gt;1000000&lt;/span&gt; &amp;lt;= now {&lt;br/&gt;   lasttrace = now&lt;br/&gt;   schedtrace(debug.scheddetail &amp;gt; &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;  }&lt;br/&gt;  unlock(&amp;amp;sched.sysmonlock)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码核心的行为就是不断地在 for 循环中，对 &lt;code&gt;gcTriggerTime&lt;/code&gt; 和 &lt;code&gt;now&lt;/code&gt; 变量进行比较，判断是否达到一定的时间（默认为 2 分钟）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;若达到意味着满足条件，会将 &lt;code&gt;forcegc.g&lt;/code&gt; 放到全局队列中接受新的一轮调度，再进行对上面 &lt;code&gt;forcegchelper&lt;/code&gt; 的唤醒。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;堆内存申请&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在了解定时触发的机制后，另外一个场景就是分配的堆空间的时候，那么我们要看的地方就非常明确了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那就是运行时申请堆内存的 &lt;code&gt;mallocgc&lt;/code&gt; 方法。核心代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;mallocgc&lt;/span&gt;&lt;span&gt;(size &lt;span&gt;uintptr&lt;/span&gt;, typ *_type, needzero &lt;span&gt;bool&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;unsafe&lt;/span&gt;.&lt;span&gt;Pointer&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; shouldhelpgc := &lt;span&gt;false&lt;/span&gt;&lt;br/&gt; ...&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; size &amp;lt;= maxSmallSize {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; noscan &amp;amp;&amp;amp; size &amp;lt; maxTinySize {&lt;br/&gt;   ...&lt;br/&gt;   &lt;span&gt;// Allocate a new maxTinySize block.&lt;/span&gt;&lt;br/&gt;   span = c.alloc[tinySpanClass]&lt;br/&gt;   v := nextFreeFast(span)&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; v == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;    v, span, shouldhelpgc = c.nextFree(tinySpanClass)&lt;br/&gt;   }&lt;br/&gt;   ...&lt;br/&gt;   spc := makeSpanClass(sizeclass, noscan)&lt;br/&gt;   span = c.alloc[spc]&lt;br/&gt;   v := nextFreeFast(span)&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; v == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;    v, span, shouldhelpgc = c.nextFree(spc)&lt;br/&gt;   }&lt;br/&gt;   ...&lt;br/&gt;  }&lt;br/&gt; } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  shouldhelpgc = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;  span = c.allocLarge(size, needzero, noscan)&lt;br/&gt;  ...&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; shouldhelpgc {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; t := (gcTrigger{kind: gcTriggerHeap}); t.test() {&lt;br/&gt;   gcStart(t)&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; x&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;小对象：如果申请小对象时，发现当前内存空间不存在空闲跨度时，将会需要调用 &lt;code&gt;nextFree&lt;/code&gt; 方法获取新的可用的对象，可能会触发 GC 行为。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;大对象：如果申请大于 32k 以上的大对象时，可能会触发 GC 行为。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这篇文章中，我们介绍了 Go 语言触发 GC 的两大类场景，并分别基于大类中的细分场景进行了一一说明。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般来讲，我们对其了解大概就可以了。若小伙伴们对其内部具体实现感兴趣，也可以以文章中的代码具体再打开看。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但需要注意，很有可能 Go 版本一升级，可能又变了，学思想要紧！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;你对 Go 语言的 GC 有什么想法呢，欢迎在评论区留言交流 ：）&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>13bdd87dbb4eb947074d03a4b4371577</guid>
<title>一顿操作，我把 Table 组件性能提升了十倍</title>
<link>https://toutiao.io/k/tm5eo26</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-hnrfcf&quot; options=&quot;[object Object]&quot;&gt;&lt;h2&gt;背景&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Table&lt;/code&gt; 表格组件在 Web 开发中的应用随处可见，不过当表格数据量大后，伴随而来的是性能问题：渲染的 DOM 太多，渲染和交互都会有一定程度的卡顿。&lt;/p&gt;&lt;p&gt;通常，我们有两种优化表格的方式：一种是分页，另一种是虚拟滚动。这两种方式的优化思路都是减少 DOM 渲染的数量。在我们公司的项目中，会选择分页的方式，因为虚拟滚动不能正确的读出行的数量，会有 Accessibility 的问题。&lt;/p&gt;&lt;p&gt;记得 19 年的时候，我在 Zoom 已经推行了基于 Vue.js 的前后端分离的优化方案，并且基于 ElementUI 组件库开发了 ZoomUI。其中我们在重构用户管理页面的时候使用了 ZoomUI 的 &lt;code&gt;Table&lt;/code&gt; 组件替换了之前老的用 jQuery 开发的 &lt;code&gt;Table&lt;/code&gt; 组件。&lt;/p&gt;&lt;p&gt;因为绝大部分场景 &lt;code&gt;Table&lt;/code&gt; 组件都是分页的，所以并不会有性能问题。但是在某个特殊场景下：基于关键词的搜索，可能会出现 200 * 20 条结果且不分页的情况，且表格是有一列是带有 &lt;code&gt;checkbox&lt;/code&gt; 的，也就是可以选中某些行进行操作。&lt;/p&gt;&lt;p&gt;当我们去点选其中一行时，发现过了好久才选中，有明显的卡顿感，而之前的 jQuery 版本却没有这类问题，这一比较令人大跌眼镜。难道好好的技术重构，却要牺牲用户体验吗？&lt;/p&gt;&lt;h2&gt;Table 组件第一次优化尝试&lt;/h2&gt;&lt;p&gt;既然有性能问题，那么我们的第一时间的思路应该是要找出产生性能问题的原因。&lt;/p&gt;&lt;h3&gt;列展示优化&lt;/h3&gt;&lt;p&gt;首先，ZoomUI 渲染的 DOM 数量是要多于 jQuery 渲染的 &lt;code&gt;Table&lt;/code&gt; 的，因此第一个思考方向是让 &lt;code&gt;Table&lt;/code&gt; 组件&lt;b&gt;尽可能地减少 DOM 的渲染数量&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;20 列数据通常在屏幕下是展示不全的，老的 jQuery Table 实现很简单，底部有滚动条，而 ZoomUI 在这种列可滚动的场景下，支持了左右列的固定，这样在左右滑动过程中，可以固定某些列一直展示，用户体验更好，但这样的实现是有一定代价的。&lt;/p&gt;&lt;p&gt;想要实现这种固定列的布局，ElementUI 用了 6 个 &lt;code&gt;table&lt;/code&gt; 标签来实现，那么为什么需要 6 个 &lt;code&gt;table&lt;/code&gt; 标签呢？&lt;/p&gt;&lt;p&gt;首先，为了让 &lt;code&gt;Table&lt;/code&gt; 组件支持丰富的表头功能，表头和表体都是各自用一个 &lt;code&gt;table&lt;/code&gt; 标签来实现。因此对于一个表格来说，就会有 2 个 &lt;code&gt;table&lt;/code&gt; 标签，那么再加上左侧 &lt;code&gt;fixed&lt;/code&gt; 的表格，和右侧 &lt;code&gt;fixed&lt;/code&gt; 的表格，总共有 6 个 &lt;code&gt;table&lt;/code&gt; 标签。&lt;/p&gt;&lt;p&gt;在 ElementUI 实现中，左侧 &lt;code&gt;fixed&lt;/code&gt; 表格和右侧 &lt;code&gt;fixed&lt;/code&gt; 表格从 DOM 上都渲染了完整的列，然后从样式上控制它们的显隐：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-472b8cb204377b120f07e19b6c6933ce_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1528&quot; data-rawheight=&quot;974&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-472b8cb204377b120f07e19b6c6933ce_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1528&quot; data-rawheight=&quot;974&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-472b8cb204377b120f07e19b6c6933ce_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-472b8cb204377b120f07e19b6c6933ce_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-394b1dbcb7fdf3c5b8d53f514c7d8889_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1546&quot; data-rawheight=&quot;834&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-394b1dbcb7fdf3c5b8d53f514c7d8889_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1546&quot; data-rawheight=&quot;834&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-394b1dbcb7fdf3c5b8d53f514c7d8889_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-394b1dbcb7fdf3c5b8d53f514c7d8889_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;但这么实现是有性能浪费的，因为完全不需要渲染这么多列，实际上只需要渲染固定展示的列的 DOM，然后做好高度同步即可。ZoomUI 就是这么实现的，效果如下：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9f438772d7d2fce3b4ada403739da210_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1570&quot; data-rawheight=&quot;746&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-9f438772d7d2fce3b4ada403739da210_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1570&quot; data-rawheight=&quot;746&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-9f438772d7d2fce3b4ada403739da210_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-9f438772d7d2fce3b4ada403739da210_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;当然，仅仅减少 &lt;code&gt;fixed&lt;/code&gt; 表格渲染的列，性能的提升还不够明显，有没有办法在列的渲染这个维度继续优化呢？&lt;/p&gt;&lt;p&gt;这就是从业务层面的优化了，对于一个 20 列的表格，往往关键的列并没有多少，那么我们可不可以初次渲染仅仅渲染关键的列，其它列通过配置方式的渲染呢？&lt;/p&gt;&lt;p&gt;根据上述需求，我给 &lt;code&gt;Table&lt;/code&gt; 组件添加了如下功能：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-153d3f80d6015463f0a25319288cb668_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1530&quot; data-rawheight=&quot;674&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-153d3f80d6015463f0a25319288cb668_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1530&quot; data-rawheight=&quot;674&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-153d3f80d6015463f0a25319288cb668_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-153d3f80d6015463f0a25319288cb668_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;Table&lt;/code&gt; 组件新增一个 &lt;code&gt;initDisplayedColumn&lt;/code&gt; 属性，通过它可以配置初次渲染的列，同时当用户修改了初次渲染的列，会在前端存储下来，便于下一次的渲染。&lt;/p&gt;&lt;p&gt;通过这种方式，我们就可以少渲染一些列。显然，列渲染少了，表格整体渲染的 DOM 数就会变少，对性能也会有一定的提升。&lt;/p&gt;&lt;h3&gt;更新渲染的优化&lt;/h3&gt;&lt;p&gt;当然，仅仅通过优化列的渲染还是不够的，我们遇到的问题是当点选某一行引起的渲染卡顿，为什么会引起卡顿呢？&lt;/p&gt;&lt;p&gt;为了定位该问题，我用 &lt;code&gt;Table&lt;/code&gt; 组件创建了一个 1000 * 7 的表格，开启了 Chrome 的 Performance 面板记录 &lt;code&gt;checkbox&lt;/code&gt; 点选前后的性能。&lt;/p&gt;&lt;p&gt;在经过几次 &lt;code&gt;checkbox&lt;/code&gt; 选择框的点选后，可以看到如下火焰图：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-05c3dca110282efedc3cf91db2538603_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;574&quot; data-rawheight=&quot;96&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-05c3dca110282efedc3cf91db2538603_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;574&quot; data-rawheight=&quot;96&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-05c3dca110282efedc3cf91db2538603_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-05c3dca110282efedc3cf91db2538603_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;其中黄色部分是 &lt;code&gt;Scripting&lt;/code&gt; 脚本的执行时间，紫色部分是 &lt;code&gt;Rendering&lt;/code&gt; 所占的时间。我们再截取一次更新的过程：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-64bdb0d4325a88c58becc2903622afab_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;154&quot; data-rawheight=&quot;122&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;154&quot; data-rawheight=&quot;122&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-64bdb0d4325a88c58becc2903622afab_b.png&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;然后观察 JS 脚本执行的 Call Tree，发现时间主要花在了 &lt;b&gt;&lt;code&gt;Table&lt;/code&gt; 组件的更新渲染上&lt;/b&gt;：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d016846b0d6b2692642d67f2f0126b98_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1020&quot; data-rawheight=&quot;172&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-d016846b0d6b2692642d67f2f0126b98_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1020&quot; data-rawheight=&quot;172&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-d016846b0d6b2692642d67f2f0126b98_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-d016846b0d6b2692642d67f2f0126b98_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;我们发现组件的 &lt;code&gt;render to vnode&lt;/code&gt; 花费的时间约 600ms；&lt;code&gt;vnode patch to DOM&lt;/code&gt; 花费的时间约 160ms。&lt;/p&gt;&lt;p&gt;为什么会需要这么长时间呢，因为点选了 &lt;code&gt;checkbox&lt;/code&gt;，在组件内部修改了其维护的选中状态数据，而整个组件的 &lt;code&gt;render&lt;/code&gt; 过程中又访问了这个状态数据，因此当这个数据修改后，会引发整个组件的重新渲染。&lt;/p&gt;&lt;p&gt;而又由于有 1000 * 7 条数据，因此整个表格需要循环 1000 * 7 次去创建最内部的 &lt;code&gt;td&lt;/code&gt;，整个过程就会耗时较长。&lt;/p&gt;&lt;p&gt;那么循环的内部是不是有优化的空间呢？对于 ElementUI 的 &lt;code&gt;Table&lt;/code&gt; 组件，这里有非常大的优化空间。&lt;/p&gt;&lt;p&gt;其实优化思路主要参考我之前写的 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzIxNDc4MjEzNw%3D%3D%26amp%3Bmid%3D2247484346%26amp%3Bidx%3D1%26amp%3Bsn%3Dca9c3c752c96ce99f5370919ac3354bb%26amp%3Bchksm%3D97a31a6ca0d4937abb4c446498c29ab380d486c141cf0a937124c2d5aa2eb54030e9305b5ef9%26token%3D866091504%26lang%3Dzh_CN%23rd&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《揭秘 Vue.js 九个性能优化技巧》&lt;/a&gt; 其中的 &lt;code&gt;Local variables&lt;/code&gt; 技巧。举个例子，在 ElementUI 的 &lt;code&gt;Table&lt;/code&gt; 组件中，在渲染每个 &lt;code&gt;td&lt;/code&gt; 的时候，有这么一段代码：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;_self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;$vnode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;columnData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;$index&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样的代码相信很多小伙伴随手就写了，但却忽视了其内部潜在的性能问题。&lt;/p&gt;&lt;p&gt;由于 Vue.js 响应式系统的设计，在每次访问 &lt;code&gt;this.store&lt;/code&gt; 的时候，都会触发响应式数据内部的 &lt;code&gt;getter&lt;/code&gt; 函数，进而执行它的依赖收集，当这段代码被循环了 1000 * 7 次，就会执行 &lt;code&gt;this.store&lt;/code&gt; 7000 次的依赖收集，这就造成了性能的浪费，而真正的依赖收集只需要执行一次就足够了。&lt;/p&gt;&lt;p&gt;解决这个问题其实也并不难，由于 &lt;code&gt;Table&lt;/code&gt; 组件中的 &lt;code&gt;TableBody&lt;/code&gt; 组件是用 &lt;code&gt;render&lt;/code&gt; 函数写的，我们可以在组件 &lt;code&gt;render&lt;/code&gt; 函数的入口处定义一些局部变量：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;nx&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;store&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/*...*/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;$vnode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;context&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后在渲染整个 &lt;code&gt;render&lt;/code&gt; 的过程中，把局部变量当作内部函数的参数传入，这样在内部渲染 &lt;code&gt;td&lt;/code&gt; 的渲染中再次访问这些变量就不会触发依赖收集了：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;nx&quot;&gt;rowRender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* ...其它变量 */&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;_self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;columnData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;$index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;disableTransition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;isSelectedRow&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过这种方式，我们把类似的代码都做了修改，就实现了 &lt;code&gt;TableBody&lt;/code&gt; 组件渲染函数内部访问这些响应式变量，只触发一次依赖收集的效果，从而优化了 &lt;code&gt;render&lt;/code&gt; 的性能。&lt;/p&gt;&lt;p&gt;来看一下优化后的火焰图：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9b525075005c56628816abd76107e848_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;412&quot; data-rawheight=&quot;90&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;412&quot; data-rawheight=&quot;90&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-9b525075005c56628816abd76107e848_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;从面积上看似乎 &lt;code&gt;Scripting&lt;/code&gt; 的执行时间变少了，我们再来看它一次更新所需要的 JS 执行时间：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-db3bd275c63b19dbbae744db5ff8c34c_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;984&quot; data-rawheight=&quot;156&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-db3bd275c63b19dbbae744db5ff8c34c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;984&quot; data-rawheight=&quot;156&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-db3bd275c63b19dbbae744db5ff8c34c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-db3bd275c63b19dbbae744db5ff8c34c_b.png&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;我们发现组件的 &lt;code&gt;render to vnode&lt;/code&gt; 花费的时间约 240ms；&lt;code&gt;vnode patch to DOM&lt;/code&gt; 花费的时间约 127ms。&lt;/p&gt;&lt;p&gt;可以看到，ZoomUI &lt;code&gt;Table&lt;/code&gt; 组件的 &lt;code&gt;render&lt;/code&gt; 的时间和 &lt;code&gt;update&lt;/code&gt; 的时间都要明显少于 ElementUI 的 &lt;code&gt;Table&lt;/code&gt; 组件。&lt;code&gt;render&lt;/code&gt; 时间减少是由于响应式变量依赖收集的时间大大减少，&lt;code&gt;update&lt;/code&gt; 的时间的减少是因为 &lt;code&gt;fixed&lt;/code&gt; 表格渲染的 DOM 数量减少。&lt;/p&gt;&lt;p&gt;从用户的角度来看，DOM 的更新除了 &lt;code&gt;Scripting&lt;/code&gt; 的时间，还有 &lt;code&gt;Rendering&lt;/code&gt; 的时间，它们是共享一个线程的，当然由于 ZoomUI &lt;code&gt;Table&lt;/code&gt; 组件渲染的 DOM 数量更少，执行 &lt;code&gt;Rendering&lt;/code&gt; 的时间也更短。&lt;/p&gt;&lt;h3&gt;手写 benchmark&lt;/h3&gt;&lt;p&gt;仅仅从 Performance 面板的测试并不是一个特别精确的 benchmark，我们可以针对 &lt;code&gt;Table&lt;/code&gt; 组件手写一个 benchmark。&lt;/p&gt;&lt;p&gt;我们可以先创建一个按钮，去模拟 &lt;code&gt;Table&lt;/code&gt; 组件的选中操作：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;zm-button&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;click&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;toggleSelection(computedData[1])
&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;切换第二行选中状态
  &lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;zm-button&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
  更新所需时间: {{ renderTime }}
&lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后实现这个 &lt;code&gt;toggleSelection&lt;/code&gt; 函数：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;nx&quot;&gt;methods&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;nx&quot;&gt;toggleSelection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;performance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;$refs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;toggleRowSelection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;nx&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;renderTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;performance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;toFixed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#x27;ms&#x27;&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们在点击事件的回调函数中，通过 &lt;code&gt;window.performance.now()&lt;/code&gt; 记录起始时间，然后在 &lt;code&gt;setTimeout&lt;/code&gt; 的回调函数中，再去通过时间差去计算整个更新渲染需要的时间。&lt;/p&gt;&lt;p&gt;由于 JS 的执行和 UI 渲染占用同一线程，因此在一个宏任务执行过程中，会执行这俩任务，而 &lt;code&gt;setTimeout 0&lt;/code&gt; 会把对应的回调函数添加到下一个宏任务中，当该回调函数执行，说明上一个宏任务执行完毕，此时做时间差去计算性能是相对精确的。&lt;/p&gt;&lt;p&gt;基于手写的 benchmark 得到如下测试结果：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c9a65a72fd74a5fc4fbbb1725652a161_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2502&quot; data-rawheight=&quot;552&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-c9a65a72fd74a5fc4fbbb1725652a161_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2502&quot; data-rawheight=&quot;552&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-c9a65a72fd74a5fc4fbbb1725652a161_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-c9a65a72fd74a5fc4fbbb1725652a161_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;ElementUI &lt;code&gt;Table&lt;/code&gt;组件一次更新的时间约为 900ms。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2cb6a7c046836c57d580161a75521572_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2634&quot; data-rawheight=&quot;570&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-2cb6a7c046836c57d580161a75521572_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2634&quot; data-rawheight=&quot;570&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-2cb6a7c046836c57d580161a75521572_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-2cb6a7c046836c57d580161a75521572_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;ZoomUI &lt;code&gt;Table&lt;/code&gt;组件一次更新的时间约为 280ms，相比于 ElementUI 的 &lt;code&gt;Table&lt;/code&gt; 组件，&lt;b&gt;性能提升了约三倍&lt;/b&gt;。&lt;/p&gt;&lt;h2&gt;v-memo 的启发&lt;/h2&gt;&lt;p&gt;经过这一番优化，基本解决了文章开头提到的问题，在 200 * 20 的表格中去选中一列，已经并无明显的卡顿感了，但相比于 jQuery 实现的 Table，效果还是要差了一点。&lt;/p&gt;&lt;p&gt;虽然性能优化了三倍，但我还是有个心结：明明只更新了一行数据的选中状态，却还是重新渲染了整个表格，仍然需要在组件 &lt;code&gt;render&lt;/code&gt; 的过程中执行多次的循环，在 &lt;code&gt;patch&lt;/code&gt; 的过程中通过 &lt;code&gt;diff&lt;/code&gt; 算法来对比更新。&lt;/p&gt;&lt;p&gt;最近我研究了 Vue.js 3.2 &lt;code&gt;v-memo&lt;/code&gt; 的实现，看完源码后，我非常激动，因为发现这个优化技巧似乎可以应用到 ZoomUI 的 Table 组件中，尽管我们的组件库是基于 Vue 2 版本开发的。&lt;/p&gt;&lt;p&gt;我花了一个下午的时间，经过一番尝试，果然成功了，那么具体是怎么做的呢？先不着急，我们从 &lt;code&gt;v-memo&lt;/code&gt; 的实现原理说起。&lt;/p&gt;&lt;h3&gt;v-memo 的实现原理&lt;/h3&gt;&lt;p&gt;&lt;code&gt;v-memo&lt;/code&gt; 是 Vue.js 3.2 版本新增的指令，它可以用于普通标签，也可以用于列表，结合 &lt;code&gt;v-for&lt;/code&gt; 使用，在官网文档中，有这么一段介绍：&lt;/p&gt;&lt;blockquote&gt;&lt;code&gt;v-memo&lt;/code&gt; 仅供性能敏感场景的针对性优化，会用到的场景应该很少。渲染 &lt;code&gt;v-for&lt;/code&gt; 长列表 (长度大于 1000) 可能是它最有用的场景：&lt;br/&gt; &lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;v-for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;item in list&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;:key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;item.id&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;v-memo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[item.id === selected]&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;ID: {{ item.id }} - selected: {{ item.id === selected }}&lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;...more child nodes&lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt; 当组件的 &lt;code&gt;selected&lt;/code&gt; 状态发生变化时，即使绝大多数 &lt;code&gt;item&lt;/code&gt; 都没有发生任何变化，大量的 VNode 仍将被创建。此处使用的 &lt;code&gt;v-memo&lt;/code&gt; 本质上代表着“仅在 item 从未选中变为选中时更新它，反之亦然”。这允许每个未受影响的 &lt;code&gt;item&lt;/code&gt; 重用之前的 VNode，并完全跳过差异比较。注意，我们不需要把 &lt;code&gt;item.id&lt;/code&gt; 包含在记忆依赖数组里面，因为 Vue 可以自动从 &lt;code&gt;item&lt;/code&gt; 的 &lt;code&gt;:key&lt;/code&gt; 中把它推断出来。&lt;br/&gt; &lt;/blockquote&gt;&lt;p&gt;其实说白了 &lt;code&gt;v-memo&lt;/code&gt; 的核心就是复用 &lt;code&gt;vnode&lt;/code&gt;，上述模板借助于&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//vue-next-template-explorer.netlify.app/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;在线模板编译工具&lt;/a&gt;，可以看到其对应的 &lt;code&gt;render&lt;/code&gt; 函数：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;renderList&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_renderList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Fragment&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_Fragment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;openBlock&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_openBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;createElementBlock&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_createElementBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;toDisplayString&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_toDisplayString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;createElementVNode&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_createElementVNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;isMemoSame&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_isMemoSame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;withMemo&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_withMemo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;vue&quot;&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_hoisted_1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/*#__PURE__*/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_createElementVNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;p&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;...more child nodes&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* HOISTED */&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;$props&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;$setup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;$data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;$options&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_openBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_createElementBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_Fragment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_renderList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;___&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_cached&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_memo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;selected&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_cached&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_cached&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_isMemoSame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_cached&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_memo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_cached&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_item&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_openBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_createElementBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;div&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;_createElementVNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;p&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;ID: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_toDisplayString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot; - selected: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_toDisplayString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;selected&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* TEXT */&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;_hoisted_1&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;_item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;memo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_memo&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_item&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;128&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* KEYED_FRAGMENT */&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;基于 &lt;code&gt;v-for&lt;/code&gt; 的列表内部是通过 &lt;code&gt;renderList&lt;/code&gt; 函数来渲染的，来看它的实现：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;renderList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;renderItem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ret&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cached&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;cache&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;isString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;renderItem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;undefined&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cached&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cached&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;source&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#x27;number&#x27;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// source 是数字
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// source 是对象
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ret&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ret&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们只分析 &lt;code&gt;source&lt;/code&gt;，也就是列表 &lt;code&gt;list&lt;/code&gt; 是数组的情况，对于每一个 &lt;code&gt;item&lt;/code&gt;，会执行 &lt;code&gt;renderItem&lt;/code&gt; 函数来渲染。&lt;/p&gt;&lt;p&gt;从生成的 &lt;code&gt;render&lt;/code&gt; 函数中，可以看到 &lt;code&gt;renderItem&lt;/code&gt; 的实现如下：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;___&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_cached&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_memo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;selected&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_cached&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_cached&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_isMemoSame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_cached&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_memo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_cached&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_item&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_openBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_createElementBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;div&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;_createElementVNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;p&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;ID: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_toDisplayString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot; - selected: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_toDisplayString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;selected&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* TEXT */&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;_hoisted_1&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;_item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;memo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_memo&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_item&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 &lt;code&gt;renderItem&lt;/code&gt; 函数内部，维护了一个 &lt;code&gt;_memo&lt;/code&gt; 变量，它就是用来判断是否从缓存里获取 &lt;code&gt;vnode&lt;/code&gt; 的条件数组；而第四个参数 &lt;code&gt;_cached&lt;/code&gt; 对应的就是 &lt;code&gt;item&lt;/code&gt; 对应缓存的 &lt;code&gt;vnode&lt;/code&gt;。接下来通过 &lt;code&gt;isMemoSame&lt;/code&gt; 函数来判断 &lt;code&gt;memo&lt;/code&gt; 是否相同，来看它的实现：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;isMemoSame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;cached&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;memo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;prev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cached&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;memo&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;memo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;memo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;isMemoSame&lt;/code&gt; 函数内部会通过 &lt;code&gt;cached.memo&lt;/code&gt; 拿到缓存的 &lt;code&gt;memo&lt;/code&gt;，然后通过遍历对比每一个条件来判断和当前的 &lt;code&gt;memo&lt;/code&gt; 是否相同。&lt;/p&gt;&lt;p&gt;而在 &lt;code&gt;renderItem&lt;/code&gt; 函数的结尾，就会把 &lt;code&gt;_memo&lt;/code&gt; 缓存到当前 &lt;code&gt;item&lt;/code&gt; 的 &lt;code&gt;vnode&lt;/code&gt; 中，便于下一次通过  &lt;code&gt;isMemoSame&lt;/code&gt; 来判断这个 &lt;code&gt;memo&lt;/code&gt; 是否相同，如果相同，说明该项没有变化，直接返回上一次缓存的 &lt;code&gt;vnode&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;那么这个缓存的 &lt;code&gt;vnode&lt;/code&gt; 具体存储到哪里呢，原来在初始化组件实例的时候，就设计了渲染缓存：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;nx&quot;&gt;renderCache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后在执行 &lt;code&gt;render&lt;/code&gt; 函数的时候，把这个缓存当做第二个参数传入：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;renderCache&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;instance&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;normalizeVNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;proxyToUse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;proxyToUse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;renderCache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;props&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;setupState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;ctx&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后在执行 &lt;code&gt;renderList&lt;/code&gt; 函数的时候，把 &lt;code&gt;_cahce&lt;/code&gt; 作为第三个参数传入：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;kr&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;$props&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;$setup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;$data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;$options&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_openBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_createElementBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_Fragment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_renderList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;___&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_cached&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// renderItem 实现
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;128&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* KEYED_FRAGMENT */&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;所以实际上列表缓存的 &lt;code&gt;vnode&lt;/code&gt; 都保留在 &lt;code&gt;_cache&lt;/code&gt; 中，也就是 &lt;code&gt;instance.renderCache&lt;/code&gt; 中。&lt;/p&gt;&lt;p&gt;那么为啥使用缓存的 &lt;code&gt;vnode&lt;/code&gt; 就能优化 &lt;code&gt;patch&lt;/code&gt; 过程呢，因为在 &lt;code&gt;patch&lt;/code&gt; 函数执行的时候，如果遇到新旧 &lt;code&gt;vnode&lt;/code&gt; 相同，就直接返回，什么也不用做了。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;patch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;n1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;n2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;anchor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;parentComponent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;parentSuspense&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;isSVG&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;slotScopeIds&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;optimized&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;n1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;n2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;显然，由于使用缓存的 &lt;code&gt;vnode&lt;/code&gt;，它们&lt;b&gt;指向同一个对象引用&lt;/b&gt;，直接返回，节约了后续执行 &lt;code&gt;patch&lt;/code&gt; 过程的时间。&lt;/p&gt;&lt;h3&gt;在 Table 组件的应用&lt;/h3&gt;&lt;p&gt;&lt;code&gt;v-memo&lt;/code&gt; 的优化思路很简单，就是复用缓存的 &lt;code&gt;vnode&lt;/code&gt;，这是一种空间换时间的优化思路。&lt;/p&gt;&lt;p&gt;那么，前面我们提到在表格组件中选择状态没有变化的行，是不是也可以从缓存中获取呢？&lt;/p&gt;&lt;p&gt;顺着这思路，我给 &lt;code&gt;Table&lt;/code&gt; 组件设计了 &lt;code&gt;useMemo&lt;/code&gt; 这个 &lt;code&gt;prop&lt;/code&gt;，它其实是专门用于有选择列的场景。&lt;/p&gt;&lt;p&gt;然后在 &lt;code&gt;TableBody&lt;/code&gt; 组件的 &lt;code&gt;created&lt;/code&gt; 钩子函数中，创建了用于缓存的对象：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;nx&quot;&gt;created&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;useMemo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;rowKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#x27;for useMemo, row-key is required.&#x27;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;vnodeCache&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里之所以把 &lt;code&gt;vnodeCache&lt;/code&gt; 定义到 &lt;code&gt;created&lt;/code&gt; 钩子函数中，是因为它并不需要变成响应式对象。&lt;/p&gt;&lt;p&gt;另外注意，我们会根据每一行的 &lt;code&gt;key&lt;/code&gt; 作为缓存的 &lt;code&gt;key&lt;/code&gt;，因此 &lt;code&gt;Table&lt;/code&gt; 组件的 &lt;code&gt;rowKey&lt;/code&gt; 属性是必须的。&lt;/p&gt;&lt;p&gt;然后在渲染每一行的过程中，添加了 &lt;code&gt;useMemo&lt;/code&gt; 相关的逻辑：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;rowRender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* 各种变量参数 */&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;memo&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getKeyOfRow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;rowIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;$index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;rowKey&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cached&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;useMemo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;cached&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;vnodeCache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;currentSelection&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;states&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;selection&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;cached&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isRowSelectionChanged&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cached&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;memo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;currentSelection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cached&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;memo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;currentSelection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;slice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 渲染 row，返回对应的 vnode
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;rowVnode&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;useMemo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;columns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;memo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;memo&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;vnodeCache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ret&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ret&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里的 &lt;code&gt;memo&lt;/code&gt; 变量用于记录已选中的行数据，并且它也会在函数最后存储到 &lt;code&gt;vnode&lt;/code&gt; 的 &lt;code&gt;memo&lt;/code&gt;，便于下一次的比对。&lt;/p&gt;&lt;p&gt;在每次渲染 &lt;code&gt;row&lt;/code&gt; 的 &lt;code&gt;vnode&lt;/code&gt; 前，会根据 &lt;code&gt;row&lt;/code&gt; 对应的 &lt;code&gt;key&lt;/code&gt; 尝试从缓存中取；如果缓存中存在，再通过 &lt;code&gt;isRowSelectionChanged&lt;/code&gt; 来判断行的选中状态是否改变；如果没有改变，则直接返回缓存的 &lt;code&gt;vnode&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;如果没有命中缓存或者是行选择状态改变，则会去重新渲染拿到新的 &lt;code&gt;rowVnode&lt;/code&gt;，然后更新到 &lt;code&gt;vnodeCache&lt;/code&gt; 中。&lt;/p&gt;&lt;p&gt;当然，这种实现相比于 &lt;code&gt;v-memo&lt;/code&gt; 没有那么通用，只去对比行选中的状态而不去对比其它数据的变化。你可能会问，如果这一行某列的数据修改了，但选中状态没变，再走缓存不就不对了吗？&lt;/p&gt;&lt;p&gt;确实存在这个问题，但是在我们的使用场景中，遇到数据修改，是会发送一个异步请求到后端，然获取新的数据再来更新表格数据。因此我只需要观测表格数据的变化清空 &lt;code&gt;vnodeCache&lt;/code&gt; 即可：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;nx&quot;&gt;watch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;s1&quot;&gt;&#x27;store.states.data&#x27;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;useMemo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;vnodeCache&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此外，我们支持列的可选则渲染功能，以及在窗口发生变化时，隐藏列也可能发生变化，于是在这两种场景下，也需要清空 &lt;code&gt;vnodeCache&lt;/code&gt;：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;nx&quot;&gt;watch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;s1&quot;&gt;&#x27;store.states.columns&#x27;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;useMemo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;vnodeCache&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;columnsHidden&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;newVal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;oldVal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;useMemo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;valueEquals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;newVal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;oldVal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;vnodeCache&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以上实现就是基于 &lt;code&gt;v-memo&lt;/code&gt; 的思路实现表格组件的性能优化。我们从火焰图上看一下它的效果：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-271c295ec40d3d9f55639d27b25d4456_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;458&quot; data-rawheight=&quot;90&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-271c295ec40d3d9f55639d27b25d4456_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;458&quot; data-rawheight=&quot;90&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-271c295ec40d3d9f55639d27b25d4456_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-271c295ec40d3d9f55639d27b25d4456_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;我们发现黄色的 &lt;code&gt;Scripting&lt;/code&gt; 时间几乎没有了，再来看它一次更新所需要的 JS 执行时间：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-cf0b4269a029eb66573fba5d0fed36ad_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1256&quot; data-rawheight=&quot;154&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-cf0b4269a029eb66573fba5d0fed36ad_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1256&quot; data-rawheight=&quot;154&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-cf0b4269a029eb66573fba5d0fed36ad_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-cf0b4269a029eb66573fba5d0fed36ad_b.png&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;我们发现组件的 &lt;code&gt;render to vnode&lt;/code&gt; 花费的时间约 20ms；&lt;code&gt;vnode patch to DOM&lt;/code&gt; 花费的时间约 1ms，整个更新渲染过程，JS 的执行时间大幅减少。&lt;/p&gt;&lt;p&gt;另外，我们通过 &lt;code&gt;benchmark&lt;/code&gt; 测试，得到如下结果：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ef4bec729742ec52a24ba560f75d0d95_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2546&quot; data-rawheight=&quot;558&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-ef4bec729742ec52a24ba560f75d0d95_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2546&quot; data-rawheight=&quot;558&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-ef4bec729742ec52a24ba560f75d0d95_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-ef4bec729742ec52a24ba560f75d0d95_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;优化后，ZoomUI &lt;code&gt;Table&lt;/code&gt;组件一次更新的时间约为 80ms，相比于 ElementUI 的 &lt;code&gt;Table&lt;/code&gt; 组件，&lt;b&gt;性能提升了约十倍&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;这个优化效果还是相当惊人的，并且从性能上已经不输 jQuery Table 了，我两年的心结也随之解开了。&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Table&lt;/code&gt; 表格性能提升主要是三个方面：减少 DOM 数量、优化 &lt;code&gt;render&lt;/code&gt; 过程以及复用 &lt;code&gt;vnode&lt;/code&gt;。有些时候，我们还可以从业务角度思考，去做一些优化。&lt;/p&gt;&lt;p&gt;虽然 &lt;code&gt;useMemo&lt;/code&gt; 的实现还比较粗糙，但它目前已满足我们的使用场景了，并且当数据量越大，渲染的行列数越多，这种优化效果就越明显。如果未来有更多的需求，更新迭代就好。&lt;/p&gt;&lt;p&gt;由于一些原因，我们公司仍然在使用 Vue 2，但这并不妨碍我去学习 Vue 3，了解它一些新特性的实现原理以及设计思想，能让我开拓不少思路。&lt;/p&gt;&lt;p&gt;从分析定位问题到最终解决问题，希望这篇文章能给你在组件的性能优化方面提供一些思路，并应用到日常工作中。&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b5bd19e08f8f16c59decd5ccb2a34626</guid>
<title>十一长假干嘛呢？快来吧！</title>
<link>https://toutiao.io/k/8pbs9cx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;码农周刊是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;码农周刊是一份专为广大程序员、编程爱好者们打造的 IT 技术周刊。每周发送。&lt;br/&gt;2013 年 9 月 12 日创刊至今，已发送 300 多期，订阅用户超 20 万。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;专业、简单、有用&lt;/span&gt;&lt;span&gt;，是我们一直坚持的办刊宗旨。一路走来，我们见证了不少订阅用户从编程新手进阶成了高级程序员、架构师、CTO……&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2020 年 4 月，为了给用户提供更优质的服务，我们推出了「&lt;/span&gt;&lt;span&gt;码农周刊VIP会员&lt;/span&gt;&lt;span&gt;」服务。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你与 BAT 技术大牛，只差一份「码农周刊VIP会员」的距离！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;VIP会员特权&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 52 期码农周刊VIP会员&lt;span&gt;专属邮件周报&lt;/span&gt;，让你及时掌握技术动向；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 只限VIP会员加入的&lt;span&gt;交流圈子&lt;/span&gt;，让你与技术大牛切磋学习；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. VIP会员独享的&lt;span&gt;工作机会&lt;/span&gt;，为你介绍好公司的好机会；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 更多会员特权，持续更新……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如何加入「码农周刊VIP会员」？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1. 微信扫描下方二维码，加入码农周刊VIP会员知识星球。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;促销期间，一年仅需 108 元！平均一天花费不到 3 毛！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;34&quot; data-cropselx2=&quot;356&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;425&quot; data-ratio=&quot;1.0857487922705313&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/t8lpVibticjQ6h6x4EnYInRLic6PibFNWw4zSv28rAxcJu9dumVJF03PwHGOWxOzeJKIsydVa7UJuTo4jOjrct9NZw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;828&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 加入码农周刊VIP会员知识星球后，客服会联系您，请留意知识星球内的私信。&lt;br/&gt;3. 客服向您发送码农周刊VIP会员欢迎邮件，开启您的码农周刊VIP会员之旅。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;心动不如心动，赶快订阅吧！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>25033387f5984cb54f62b4e9b4669f22</guid>
<title>如何合理地选型工具</title>
<link>https://toutiao.io/k/bue7e8t</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entry-content&quot; itemprop=&quot;articleBody&quot;&gt;&amp;#13;
&lt;h3&gt;背景&lt;/h3&gt;
&lt;p&gt;在最近的项目上，我有机会和团队完成了几次重要的工具选型。它们分别是在让在建的SaaS 系统具备表单能力；让该SaaS 系统能够为接线员用户提供软电话能力；让用户的不同角色能够看到和自己相关的报表。在这几次选型过程中，有些是在商业软件和商业软件之间做出选择，有些是在商业软件和开源软件间做出选择。回头看来，每次选择的过程都不尽相同，但大致可以总结为以下几个过程。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;为了方便读者理解后面的例子，简单介绍一下项目背景。CD公司是一家为中小型家政服务公司提供ERP软件的公司，在行业内已经积累了20多年。目前该公司正在将其老旧的基于C/S 架构的传统ERP软件0改造为云上SaaS 平台来持续为客户创造价值，并通过其20年积累的行业最佳实践来吸引新的客户群体。&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;清晰定义问题&lt;/h3&gt;
&lt;p&gt;在考虑其他因素之前，最重要的是清晰地理解问题本身。而且当涉及到工具选型这类重大决策时，干系人都期望所采用的方案能解决的不仅是当前的问题，还需要能解决将来可能会遇到的问题。那么如何确定需求的优先级的同时兼顾系统的业务愿景就特别重要。毕竟有人说过 “A Problem Well-Defined is a Problem Half-Solved”。这一步不是本文的重点，但是会直接影响到选型结果的正确性。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;在前面提到的报表的例子中。团队在和客户进行了多轮访谈并对竞争对手产品中报表功能的分析后，最终获得了理解一致的需求 —— “客户希望根据行业最佳实践为最终用户提供预定义的报表功能，并能随着客户反馈提供简单的自定义功能，让用户可以在预设的数据集内通过不同的维度从其业务数据中获得洞见。”&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;确定候选技术&lt;/h3&gt;
&lt;p&gt;接下来你需要想方设法获得一个备选方案的工具清单，那么清单能从哪来呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;从客户那里来&lt;br/&gt;
客户通常会有一些备选方案，可能是已经在其组织内部被采用的技术，或者是客户方的技术人员所了解的技术。这时你只需要询问客户即可，你很可能还可以获得一些商用软件的官方支持，这将为后面的调研工作提供便利。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从竞争对手那里来&lt;br/&gt;
可能你有机会可以窥探到竞争对手在该领域所使用的技术。那么不妨将该技术也放入列表中，特别是在当前领域处于DDD中的通用域时。（在DDD中我们了解到，通用域是那些不需要具备竞争优势的领域，那么和竞争对手打个平手也是可以接受的）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;日常的积累&lt;br/&gt;
如果你曾经解决过（或参与解决过）类似问题，那么可能会了解一些相关技术。如果没有，也不用急，类似的技术选型活动将会是积累相关技术的绝佳机会。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;如果你正开始尝试解决方案架构师，那么可以使用5W1H 在日常工作中不断积累各类工具和技术，这里我将1H strikethrough，是因为成为架构师需要快速扩宽自己的知识范围，将未知的未知问题转换为已知的未知问题，来丰富自己的工具箱。等到需要的时候再进一步深入了解。&lt;/em&gt;&lt;/p&gt;
&lt;div id=&quot;attachment_14818&quot; class=&quot;wp-caption aligncenter&quot;&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/09/1-how-to-choose-tools.png&quot;&gt;&lt;img aria-describedby=&quot;caption-attachment-14818&quot; src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/09/1-how-to-choose-tools-768x686.png&quot; alt=&quot;&quot; class=&quot;size-medium_large wp-image-14818&quot; srcset=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/09/1-how-to-choose-tools-768x686.png 768w, https://insights.thoughtworks.cn/wp-content/uploads/2021/09/1-how-to-choose-tools-300x268.png 300w, https://insights.thoughtworks.cn/wp-content/uploads/2021/09/1-how-to-choose-tools.png 916w&quot; sizes=&quot;(max-width: 700px) 100vw, 700px&quot;/&gt;&lt;/a&gt;&lt;p id=&quot;caption-attachment-14818&quot; class=&quot;wp-caption-text&quot;&gt;图片引自《Fundamentals of Software Architecture》&lt;/p&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;技术雷达&lt;br/&gt;
请参考&lt;a href=&quot;https://www.thoughtworks.com/cn/radar&quot; title=&quot;Thoughtworks技术雷达&quot;&gt;Thoughtworks技术雷达&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;寻求他人帮助&lt;br/&gt;
可以找到有经验的同事，或到相关论坛询问是否有合适的技术能适用于当前的场景。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;借助搜索引擎&lt;br/&gt;
这里分享一个搜索的小技巧。例如，你从其他渠道得知Tableau可能能解决当前场景下的问题，那么你可以尝试搜索：Tableau alternatives或者Tableau free alternatives 又或者 Tableau open source alternatives 你会收获很多。&lt;br/&gt;
相信综合这些选项你已经获得了可以进入到下一步的工具清单。如果到这里你都还没有一个足够你开始调研的清单，那么很可能该领域的解决方案匮乏，团队可能最终会需要自己造轮子。 &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;在我们报表工具的例子中，客户组织内部使用了Tableau作为内部的BI工具；团队之前接触过Jasperreport；项目的云供应商AWS 上的QuickSight 提供了类似的BI 能力；通过询问，我们了解到了Redash；通过搜索，我们了解到了Superset和 Metabase。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;这个时候可能你已经准备好了各种纬度表，然后摩拳擦掌，准备开始针对候选产品进行深度调研和对比了。&lt;/p&gt;
&lt;h3&gt;做出选择&lt;/h3&gt;
&lt;p&gt;通常完成一个工具选型需要考虑的因素很多，但大致可以分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;满足功能性需求&lt;/li&gt;
&lt;li&gt;满足跨功能性需求&lt;/li&gt;
&lt;li&gt;满足成本预算&lt;/li&gt;
&lt;li&gt;对齐技术愿景&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/09/2-how-to-choose-tools.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/09/2-how-to-choose-tools-768x505.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;虽然只包含着四个部分，但是想要通过分析快速做出决策并不简单，就单单从跨功能性需求而言，在《演进式架构》中作者就列举了74项，并还向其中增加了Evolvability （可演进性）。综合这些考量本身就是一个复杂的过程。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/09/3-how-to-choose-tools.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/09/3-how-to-choose-tools-768x568.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;从敏捷项目管理中，我们学到遇到问题时要首先将其分解，再想方法排个优先级，问题通常就能变得清晰。&lt;/p&gt;
&lt;p&gt;在我们的例子中，架构师将整理出的跨功能需求按照其影响程度或架构的关注程度进行了优先级排序，其中处于较高优先级的有：多租户，安全合规，功能性需求，互操作性（集成复杂度），伸缩性，可维护性，技术愿景，收费模式，成本。接着我们再通过信息获取和分析的难易程度进行了简单的排列，例如，有些信息只需要阅读少量文档或者通过问询便可得到，有些信息需要阅读大量文档并进行分析才能判断候选工具间的优劣。这样就能让调研工作缩小到一定范围，同时可以观察到调研活动会分布到下图的四个象限中。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/09/4-how-to-choose-tools.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/09/4-how-to-choose-tools-768x492.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;那么针对不同象限中的因素遍可以采取对应的策略进行调研了。按照从易到难的顺序完成调研工作可以更有效地筛选备选方案。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;开源许可协议 在进行报表工具选型的过程中，由于忽略了JasperReport Server的开源许可协议，导致了在选型过程中的反复和团队精力上的浪费。而开源许可类型是非常容易获得的信息，并且不需要过多的分析就能就可以获得结果，它处于Fast Fail象限。如果可以准确的识别出处于该象限中的因素将极大增加选型的效率。&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;结合技术愿景&lt;/h3&gt;
&lt;p&gt;在作出工具选型时需要结合组织的技术愿景，例如，如果我们希望系统可以具有高度的移植性，可以不被锁定到某个云厂商，那么在技术选型时应该考虑是否由于选择某项技术而增加对云厂商的依赖，在我们的例子中，最终我们选择了Amazon Connect 作为客服电话集成方案，但是并没有采用QuickSight作为报表/BI 方案。同是Amazon所提供的服务，但是BI工具作为数据的下游，可能会导致在存储和数据管道技术上大量依赖于AWS提供的其他服务，使将来可能的迁移更加困难，最终锁定到供应商。而电话系统作为客户触点，则更容易通过API的方式和后台系统解耦而独立存在，供应商锁定的风险更小。&lt;/p&gt;
&lt;h3&gt;关于成本&lt;/h3&gt;
&lt;p&gt;关于成本这里不想展开太多，但是当涉及到商业软件的成本的估算是通常需要客户方的大量介入。 团队则需要根据目前大致方案给出实施，集成和上线所需要的资源配置和时间。工具的提供方则会提供实际价格及后续的维护和支持的报价。&lt;/p&gt;
&lt;p&gt;如果是自建系统，则需要为建设所需的软硬件和人力资源成本以及后续的维护及支持的成本给出大致的估算来为最终的选型提供依据。&lt;/p&gt;
&lt;h3&gt;写在最后&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/09/5-how-to-choose-tools.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/09/5-how-to-choose-tools-768x738.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;工具选型是一个复杂的过程，需要综合很多信息才能做出合适的选择。我们知道任何技术决策都是权衡利弊的结果。将决策上下文和最终选择的Cons &amp;amp; Pros记录下来，即便将来发现这个选择不再合适的时候，也能清楚的追溯到先前决策的细节，会为下一步决策提供更加充分的依据。希望本文能帮助到你，也希望天下没有错误的工具选型。&lt;/p&gt;
&amp;#13;
&lt;/div&gt;&amp;#13;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>