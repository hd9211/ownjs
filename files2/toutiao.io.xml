<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>1f7e8d2ac0645384db7f9323f59b202a</guid>
<title>大吉大利虎年春节猫福盒，点击链接立即领券购买！</title>
<link>https://toutiao.io/k/y5ztper</link>
<content:encoded>&lt;div&gt;&lt;body data-spm=&quot;10720394/n&quot; id=&quot;readabilityBody&quot;&gt;
    
    
    
    
    
    
      
      
    
    
    
    
    
  &lt;/body&gt;
&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9281a42de0566df0d10cc3a0cdc1dded</guid>
<title>[推荐] 从零打造 Instagram</title>
<link>https://toutiao.io/k/hufqvji</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;article&gt;&lt;blockquote&gt;&lt;p&gt;&lt;em&gt;Instagram是全球最大的照片、视频分享社区，如果让我们自己设计一个Instagram这样的服务，应该怎么做呢？这篇文章解析了Instagram的功能和架构，从中我们可以看到设计一个内容分享服务所需要关注的部分。原文：Instagram System Architecture&lt;span&gt;[1]&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkYgmP5bxr4BnkLICz0NUnl4VBFperNf5840Gib4iclwqJlZpJXRvNRhfw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;625&quot;/&gt;&lt;/p&gt;&lt;p&gt;Instagram是一个免费的照片和视频分享社交网络，有很多人每天在上面分享故事，记录生活中的点点滴滴。&lt;/p&gt;&lt;h4&gt;功能性需求&lt;/h4&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;用户可以上传照片和视频&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用户可以查看照片和视频&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用户可以根据照片标题进行搜索&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用户可以关注/取消关注其他用户&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用户可以通过搜索栏搜索用户id&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;为关注的每个用户创建信息流&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;可以把照片存档&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;可以通过聊天窗口分享故事&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;可以拉黑/限制其他用户&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;可以在其他用户的帖子下面点赞和评论&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用户可以发帖&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.3376436781609196&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkxPNuKGbw5bc0hnkw1WX5oOCR00X71lOO90RjicEDX8hkZnwv6p8P1Rg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;696&quot;/&gt;&lt;/p&gt;&lt;h4&gt;非功能性需求&lt;/h4&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;高可扩展性&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;高一致性&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;高可用性&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;高可靠性&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用户数据应该是持久化的（任何上传的照片都不应该丢失）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;生成信息流的最大延迟是150毫秒&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;接下来我们做一下&lt;span&gt;系统容量估算&lt;/span&gt;。&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;假设注册用户 = 5亿&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;30%的活跃用户 = 1.5亿&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;注册名人人数 = 10k&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;读请求数 = 100 *上传(写)请求数&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;高峰时刻，假设平均流量 = X，目标处理上限是6X&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;活跃用户：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;每周发帖3次，每个帖子包含1 MB的图片和文本&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;每个帖子至少收到10个赞和2-3条评论&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;关注100个用户，有50个粉丝&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;每天刷新2次信息流&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;名人：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;每周发帖2次，每个帖子包含大于500K的图片和文本&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;每个帖子至少收到50K个赞和至少1K条评论&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;拥有500万粉丝&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;每天刷新2次信息流&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;每秒请求数（QPS）：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;发帖&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;点赞&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;3&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;评论&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;4&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;关注信息流&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;5&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;数据量&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;64base([‘a-z’,‘A-Z’,‘0–9’,‘-’,‘_’])编码的user_id，需要5 bits ~ 1Byte&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;500 Million + 10K * 5 bits ~ 1 Byte = 1G user&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;容量估计：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;每天上传的活跃用户 = 100万&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;每天上传的照片 = 500万张&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;每天每秒上传的照片 = 57张照片&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;平均照片大小 = 150 KB&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;每天存储开销 = 500万* 150KB = 716GB&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数据保存10年，所需存储容量为716 GB * 365 * 10年 = 2553 TB ≈ 2.6 PB&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;日活跃用户查看 = 1000万&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;每小时的信息流产生量为1000万，即2800 RPS(每秒请求数)。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果用户每天搜索一次，那就是每天1000万次搜索，也就是115个RPS。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;hr/&gt;&lt;h4&gt;系统组件设计&lt;/h4&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5037878787878788&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkRqLeUR9ibkSsicLALrdzWxPibBEwFZpoO3To17RyL8M7xLScsF6z8wYHg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;528&quot;/&gt;&lt;/p&gt;&lt;p&gt;因此，更好的方法是用2个数据库分别处理读写操作。此外，分离照片的读写请求可以帮助我们独立的扩展和优化每个过程。下图显示了读写的过程。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.44567219152854515&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkFZicQrFia4cTpvm6ZdicUPOxBKZoiatFVFLZd8NMpPibUroo4BGaAtyeRicQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;543&quot;/&gt;&lt;/p&gt;&lt;h5&gt;1. 信息流生成服务（News Feed Generation services）&lt;/h5&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;为用户更新所关注的用户的最新帖子&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;每个用户的信息流都是独一无二的，组合非常复杂&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;为了生成新的信息流，系统必须获取这些照片的元数据(喜欢、评论、时间、位置等)，并将其传递给排名算法，以决定哪些照片应该根据元数据安排在信息流中&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;后端需要同时查询大量的表，然后使用预定义的参数对它们进行排序，这种方法将导致更高的延迟，需要大量的时间来生成新的信息流&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;因此，可以采用预生成的信息流。创建专门用于生成每个用户独有信息流的服务器，并将其结果存储在单独的信息流表中。当用户点击更新时，直接从数据库中读取信息流并显示给用户。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5&gt;2. 提供信息流（Serving the News Feed）&lt;/h5&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;推模式（Push）&lt;/span&gt; — 当用户上传了新的照片/视频，他/她的所有粉丝都会获得更新。如果用户关注了很多人或名人，服务器就必须非常频繁的向用户推送更新。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;拉模式（Pull）&lt;/span&gt; — 用户主动刷新他们的信息流(向服务器发出一个拉取请求)。在用户刷新之前，新帖子是不可见的。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;混合模式（Hybrid Approach）&lt;/span&gt; — 对拥有大量粉丝的名人用户应用拉模式，普通用户采用推模式。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5&gt;3. 负载均衡（Load Balancing）&lt;/h5&gt;&lt;hr/&gt;&lt;h4&gt;数据架构&lt;/h4&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4835294117647059&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkicf91n5kVWlM88ia8S5o3a8UMHtlns0h4Bzl1hicJ1E5kns3GSiaatkAZA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;850&quot;/&gt;&lt;/p&gt;&lt;h5&gt;数据库设计&lt;/h5&gt;&lt;p&gt;&lt;span&gt;1. 用户相关数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 照片相关数据（AWS S3）&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;photo id&lt;/span&gt;（主键）：10字节长度的唯一照片id，用于标识每一张照片&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;UserId&lt;/span&gt;：上传照片的用户id&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Path&lt;/span&gt;：存放照片的对象存储路径/URL&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Latitude &amp;amp; Longitude（纬度和经度）&lt;/span&gt;：存储这些信息来找到照片的位置&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Date &amp;amp; time（日期和时间）&lt;/span&gt;：照片上传的日期和时间戳&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.49335548172757476&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkze1bEqtBwAlOkML5cB0ff043F7sNy6x5HeILZZe1XyEFf6sLhKmuKA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;602&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. 用户关注和粉丝相关数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5905882352941176&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkoyXKHeAqXXNK804hsXVGNPBxqiclo1TCS8FJVRkOeL68TMpETSBy6ibw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;425&quot;/&gt;&lt;/p&gt;&lt;p&gt;因此，我们需要两种不同的数据库：&lt;br/&gt;1）关系型数据库（MySQL）&lt;br/&gt;2）NoSQL数据库（Cassandra）&lt;/p&gt;&lt;h5&gt;数据模型&lt;/h5&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24142857142857144&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkDhicUtj3Myl2Lycy0TvLJpVZpanv2ZzcfLGEEwxRicvibqPA6aJsmPhLw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1742857142857143&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkmZgdic3I84RsRnL0gQTbYdAkUlyoaks1whI3K9icb1ME9kzR9zeWr71A/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.82&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkMcVTo5uDlwpPDZIhyj7s8zBHrdyLjKVoqQW2dtmmGKxMuqaziaB2N4Q/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7171428571428572&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkU0pbsqT36wocwcICLeic6miaSmlOExBjcfGTKPHkcMpDicibgIKqvoLyJA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;典型查询&lt;/span&gt;：&lt;/p&gt;&lt;hr/&gt;&lt;h4&gt;接口/API&lt;/h4&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;create_post(user_id, image, text, timestamp) -&amp;gt; success/failure&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;comment_post(user_id, post_id, comment, timestamp) -&amp;gt; success/failure&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;like_post(user_id, post_id, timestamp) -&amp;gt; success/failure&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;get_follow_feed(user_id, timestamp) -&amp;gt; list of newest posts from user follow list, ordered by time, limit 20&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;get_profile_feed(user_id, user2_id, timestamp) -&amp;gt; list of newest posts from user2, ordered by time, limit 20&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;hr/&gt;&lt;h4&gt;系统架构&lt;/h4&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3514285714285714&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkTLTERrvjwxBC5eSCMu0XCRo7D3J5FiccFWJ3Kian8b2qdIUCdXlWVZKA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7114285714285714&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkiaXgIodH7DiaYyjntqn5Q6bWoho6jJ1KjRs0AltnJ75wR28flm4URWGw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;发帖&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5571428571428572&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkBBSUSLfHG9ZhBA9icRM2AH0G5jCmnHpzK9iblo0jUHZuIzL4kydt9IYw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;信息流&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3585714285714286&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkJCnpgt4242jCVAyIVCJr6RPV9Y0zfQrTQrSKW982lP9iaN1ZiaWqMVxw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;进一步细化&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;发帖&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6928571428571428&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkCXZXTTIBtUfVCpbAqdljDZd0HHIp5YVD9K9LLxQjRoRDCl7al1ysMg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;信息流&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4514285714285714&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkOx9dpib3C2kFZXqCeRV9DcoQLc9Fq4ZtDRb2ib3hG9roHDpbNr9zw6hg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8485714285714285&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkp3ic6DbUU4PE5sBfPGYnRzkdEmma1pQgjAm2WBBsrenU8OwHBTbKQ2g/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6728571428571428&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkuKnTFebwY06gicf4z7GcfO117v7LqHVtYJc3yh9ulPPcjOf2nia1ib2HQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9557142857142857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnk1slyVp0NO6ZOwa0yTkU6ibl2EnxYxp41G4TchpKHxA7baDJ02GetxJg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;hr/&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;延伸阅读：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Instagram Engineering: https://medium.com/@InstagramEng&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Instagram System Design: https://youtu.be/da7mdMz0g0g&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Designing Instagram: https://www.educative.io/courses/grokking-the-system-design-interview/m2yDVZnQ8lG&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Design Photo Sharing Platform - Instagram: https://techtakshila.com/system-design-interview/chapter-4/&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Designing Instagram: https://www.codercrunch.com/design/634265/designing-instagram&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Designing Instagram Architecture: https://nlogn.in/designing-instagram-architecture-system-design/&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;System Design Analysis of Instagram: https://towardsdatascience.com/system-design-analysis-of-instagram-51cd25093971&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;References:&lt;/span&gt;&lt;br/&gt;[1] Instagram System Architecture: https://medium.com/interviewnoodle/instagram-system-architecture-fdbec22e48ee&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;你好，我是俞凡，在Motorola做过研发，现在在Mavenir做技术工作，对通信、网络、后端架构、云原生、DevOps、CICD、区块链、AI等技术始终保持着浓厚的兴趣，平时喜欢阅读、思考，相信持续学习、终身成长，欢迎一起交流学习。&lt;br/&gt;微信公众号：DeepNoMind&lt;/p&gt;&lt;/blockquote&gt;&lt;/article&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3a676082c2425e9d5ae55a5f471e09b6</guid>
<title>[推荐] 缓存一致性最佳实践</title>
<link>https://toutiao.io/k/ymscqc1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.4382826&quot; data-w=&quot;559&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74ACnsfKcnFDT8Uf8XcCHKTbbFu7n3GktsBgczeVd0RHngWc5I6Wvf01FzUtDwQibTQEpYeZSM64W8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;背景 &lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;概述&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;最近团队里我们在密集的讨论Redis缓存一致性相关的问题，电商核心的域如商品、营销、库存、订单等实际上在缓存的选择上各有特色，那么在这些差异的业务背后，我们有没有一些最佳实践可供参考呢？&lt;/p&gt;&lt;p&gt;本文尝试着来讨论这个问题，并给出一些建议。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在讨论之前，有两个重点我们需要达成一致：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;分布式场景下无法做到强一致&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不同于CPU硬件缓存体系采用的MESI协议以及硬件的强时钟控制，分布式场景下我们无法做到缓存与底层数据库的强一致，即把缓存和数据库的数据变更做成一个原子操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;硬件工程师设计了内存屏障（Memory Barrier）的概念，提供给软件开发者不同的一致性选项在性能与一致性上进行权衡。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;就算是达到最终一致性也很难&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;分布式场景下，要做到最终一致性，就要求缓存中存储的是最新版本的数据（或者缓存为空），而且是在数据库更新后很迅速的就要达到这个一致性的状态，要做到是极其困难的。&lt;/p&gt;&lt;p&gt;我们会面临硬件、软件、通信等等组件非常多的异常情况。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5409836&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74ACnsfKcnFDT8Uf8XcCHKTbvSxeCUz3xV2YIUErVqjzgbHHKuhWXsU0JyWT3jfkpKJPI1Z14xiatxA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;976&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;CPU的缓存结构&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;缓存的一致性问题&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;一般化来说，我们面临的是这样的一个问题，如下图所示，数据库的数据会有5次更新，产生6个版本，V1~V6，图中每个方框的长度代表这个版本持续的时间。&lt;/p&gt;&lt;p&gt;我们期望，在数据库中的数据变化后，缓存层需要尽快的感知到并作出反应，如下图所示，缓存层方框中的间隔代表这个时间段缓存数据不存在，V2、V3以及V5版本在缓存中不存在并不会破坏我们的最终一致性要求，只要数据库的最终版本和缓存的最终版本是相同的就可以了。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2796296&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74ACnsfKcnFDT8Uf8XcCHKTbpcFMVGBvhuLoH4m6rYIj8yhttcP7lbiaonk7s2MgEjNyQmj9zOCXE1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;缓存是如何写入的&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;缓存写入的代码通常情况下都是和缓存使用的代码放在一起的，包含4个步骤，如下图所示：W1读取缓存，W2判断缓存是否存在，W3组装缓存数据（这通常需要向数据库进行查询），W4写入缓存。&lt;/p&gt;&lt;p&gt;每一个步骤间可能会停顿多久是没有办法控制的，尤其是W3、W4之间的停顿最为要命，它很可能让我们将旧版本的数据写入到缓存中。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;我们可能会想，W4步的写入，带上W2的假设，即使用WriteIfNotExists语义，会不会有所改善？&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3916667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74ACnsfKcnFDT8Uf8XcCHKTb20FjhyT48qhUfho2h4bwblJcIsFVibcSh0dgWLCqB0hicJ8EDgk8VUyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;考虑如下的情形，假设有3个缓存写入的并发执行，由于短时间数据库大量的更新，它们分别组装的是V1、V2、V3版本的数据。&lt;/p&gt;&lt;p&gt;使用WriteIfNotExists语义，其中必然有2个执行会失败，哪一个会成功根本无法保证。&lt;/p&gt;&lt;p&gt;我们无法简单的做决策，需要再次将缓存读取出来，然后判断是否我们即将写入的一样，如果一样那就很简单；如果不一样的话，我们有两种选择：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;将缓存删除，让后续别的请求来处理写入。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;使用缓存提供的原子操作，仅在我们的数据是较新版本时写入。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.27833&quot; data-w=&quot;1006&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74ACnsfKcnFDT8Uf8XcCHKTbxFk3v9PuJ3VBXYmdBKGOcvrMXAyRjrqiaXlId1X7Q849lA9Gbon5dpg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;如何感知数据库的变化&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;数据库的数据发生变化后，我们如何感知到并进行有效的缓存管理呢？&lt;/p&gt;&lt;p&gt;通常情况下有如下的3种做法：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;使用代码执行流&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;通常我们会在数据库操作完成后，执行一些缓存操作的代码。&lt;/p&gt;&lt;p&gt;这种方式最大的问题是可靠性不高，应用重启、机器意外当机等情况都会导致后续的代码无法执行。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;使用事务消息&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;作为使用代码执行流的改进，在数据库操作完成后发出事务消息，然后在消息的消费逻辑里执行缓存的管理操作。&lt;/p&gt;&lt;p&gt;可靠性的问题就解决了，只是业务侧要为此增加事务消息的逻辑，以及运行成本。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;使用数据变更日志&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;数据库产品通常都支持在数据变更后产生变更日志，比如MySQL的binlog。&lt;/p&gt;&lt;p&gt;可以让中间件团队写一款产品，在接收到变更后执行缓存的管理操作，比如阿里的精卫。&lt;/p&gt;&lt;p&gt;可靠性有保证，同时还可以进行某个时间段变更日志的回放，功能就比较强大了。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;最佳实践一：数据库变更后失效缓存&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;这是最常用和简单的方式，应该被作为首选的方案，整体的执行逻辑如下图所示：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5731481&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74ACnsfKcnFDT8Uf8XcCHKTbuFnDYpEbhQKFJQVPGlOAZaJibTSPEQ0ag8mIn1J78yhhBfdYOlLhBibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;W4步使用最基本的put语义，这里的假设是写入较晚的请求往往也是携带的最新的数据，这在大多的情形下都是成立的。&lt;/p&gt;&lt;p&gt;D1步使用监听DB binlog的方式来删除缓存，即前述使用数据变更日志中介绍的方法。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;这个方案的缺点是&lt;/strong&gt;：在数据库数据存在高并发更新且缓存读取流量较大的情况下，会有小概率存在缓存中存储的是旧版本数据的情况。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通常的解法有四种：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;限制缓存有效时间&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;设定缓存的过期时间，比如15分钟。即表示我们最多接受缓存在15分钟的时间范围内是旧的。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;小概率缓存重加载&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;根据流量比设定一定比例的缓存重加载，以保证大流量情况下的缓存数据的一致性。&lt;/p&gt;&lt;p&gt;比如1%的比例，这同时还可以帮助数据库得到充分的预热。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;结合业务特点&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;根据业务的特点做一些设计，比如：&lt;/p&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;针对营销的场景&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;在商品详情页/确认订单页的优惠计算时使用缓存，而在下单时不使用缓存。&lt;/p&gt;&lt;p&gt;这可以让极端情况发生时，不产生过大的业务损失。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;针对库存的场景&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;读取到旧版本的数据只是会在商品已售罄的情况下让多余的流量进入到下单而已，下单时的库存扣减是操作数据库的，所以不会有业务上的损失。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;两次删除&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;D1步删除缓存的操作执行两次，且中间有一定的间隔，比如30秒。&lt;/p&gt;&lt;p&gt;这两次动作的触发都是由“缓存管理组件”发起的，所以可以由它支持。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;最佳实践二：带版本写入&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;针对象商品信息缓存这种更新频率低、数据一致性要求较高且缓存读取流量很高的场景，通常会采用带版本更新的方式，整体的执行逻辑如下图如示：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6055556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74ACnsfKcnFDT8Uf8XcCHKTblN4aNHDMTub6GiboN4tIj5MlIj1sSpEiamGf0A9Pu2VBmPRF9fjxcayA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;和“数据库变更后失效缓存”方案最大的差异在W4步和D1步，需要缓存层提供带版本写入的API，即仅当写入数据版本较新时可以写入成功，否则写入失败。&lt;/p&gt;&lt;p&gt;这同时也要求我们在数据库增加数据版本的信息。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个方案的最终一致性效果比较好，仅在极端情况下（新版本写入后数据丢失了，后续旧版本的写入就会成功）存在缓存中存储的是旧版本数据的可能。&lt;/p&gt;&lt;p&gt;在D1步使用写入而不是使用删除可以极大程度的避免这个极端情况的出现，同时由于该方案适用于缓存读取流量很高的场景，还可以避免缓存被删除后W3步短时间大量请求穿透到DB。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;总结与展望&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;对于缓存与数据库分离的场景，在结合了业界多家公司的实践经验以及ROI权衡之后，前述的两个最佳实践是被应用的最为广泛的，尤其是最佳实践一，应该作为我们日常应用的首选。&lt;/p&gt;&lt;p&gt;同时，为了最大限度的避免每个最佳实践背后可能发生的不一致性问题，我们还需要切合业务的特点，在关键的场景上做一些保障一致性的设计（比如前述的营销在下单时使用数据库读而不是缓存读），这也显得尤为重要（毕竟如“背景”中所述，并不存在完美的技术方案）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;除了缓存与数据库分离的方案，还有两个业界已经应用的方案也值得我们借鉴：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;阿里XKV&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;简单来讲就是在数据库上部署一个Memcache的Server，它直接绕过数据库层直接访问存储引擎层（如：InnoDB），同时使用KV client来进行数据的访问。&lt;/p&gt;&lt;p&gt;它的特点是数据实际上与数据库是强一致的，性能可以比使用SQL访问数据库提升5～10倍。&lt;/p&gt;&lt;p&gt;缺点也很明显，只能通过主键或者唯一键来访问数据（这只是相对SQL来说的，大多数缓存本来也就是KV访问协议）。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;腾讯DCache&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;不用自行维护缓存与数据库两套存储，给开发人员统一的一套数据视图，由DCache在缓存更新后自行持久化数据。&lt;/p&gt;&lt;p&gt;缺点是支持的数据结构有限（ key-value，k-k-row，list，set，zset ），未来也很难支持形如数据库表一样复杂的数据结构。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.004&quot; data-w=&quot;1000&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/n4p7ssmqwmGHOiaBs4TLdiacnZ6Ub3E6Oqia4cJNlwjuvAI6fuDuXvUGb9FX2wTNgvRtdpqlSf4V780atTia0eorag/640?wx_fmt=gif&quot; data-type=&quot;gif&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;*文/苏木&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkxNTE3ODU0NA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74Diclic7XyegA4UmC0SqoT4jDEpdzibjkibmAvz8svbJwfsufiaBqOWx9sskIrickxzGfCwkjuMBiaNLDxNA/0?wx_fmt=png&quot; data-nickname=&quot;得物技术&quot; data-signature=&quot;技术知识分享交流平台，与你一同走向技术的云端。&quot;/&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c818ac75b54a17047499a165f5c3f8ea</guid>
<title>[推荐] 据说看完这篇 JVM 要一小时</title>
<link>https://toutiao.io/k/1dauixx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;JVM 的主要作用是什么？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;J&lt;/span&gt;&lt;span&gt;VM 就是 Java Virtual Machine（Java虚拟机）的缩写，JVM 屏蔽了与具体操作系统平台相关的信息，使 Java 程序只需生成在 Java 虚拟机上运行的目标代码 （字节码），就可以在不同的平台上运行。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;请你描述一下 Java 的内存区域？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JVM 在执行 Java 程序的过程中会把它管理的内存分为若干个不同的区域，这些组成部分有些是线程私有的，有些则是线程共享的，Java 内存区域也叫做运行时数据区，它的具体划分如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7437092264678472&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmH9aGibGUjlxTy3le1caYkicpKl6nB2tvY37G39bUyIGSu4mzoScJZPbQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1073&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;虚拟机栈&lt;/code&gt; : Java 虚拟机栈是线程私有的数据区，Java 虚拟机栈的生命周期与线程相同，虚拟机栈也是局部变量的存储位置。方法在执行过程中，会在虚拟机栈中创建一个 &lt;code&gt;栈帧(stack frame)&lt;/code&gt;。每个方法执行的过程就对应了一个入栈和出栈的过程。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.7777777777777777&quot; data-type=&quot;jpeg&quot; data-w=&quot;315&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYm3dmdg7jW9BViaBNL5Z449GBOuMDwXfPPjiaSfQDnnTVSFiaO7Yvk0k8vQ/640?wx_fmt=jpeg&quot; class=&quot;rich_pages wxw-img&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;本地方法栈&lt;/code&gt;: 本地方法栈也是线程私有的数据区，本地方法栈存储的区域主要是 Java 中使用 &lt;code&gt;native&lt;/code&gt; 关键字修饰的方法所存储的区域。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;程序计数器&lt;/code&gt;：程序计数器也是线程私有的数据区，这部分区域用于存储线程的指令地址，用于判断线程的分支、循环、跳转、异常、线程切换和恢复等功能，这些都通过程序计数器来完成。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;方法区&lt;/code&gt;：方法区是各个线程共享的内存区域，它用于存储虚拟机加载的 类信息、常量、静态变量、即时编译器编译后的代码等数据。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;堆&lt;/code&gt;：堆是线程共享的数据区，堆是 JVM 中最大的一块存储区域，所有的对象实例都会分配在堆上。JDK 1.7后，字符串常量池从永久代中剥离出来，存放在堆中。&lt;/p&gt;&lt;p&gt;堆空间的内存分配（默认情况下）：&lt;/p&gt;&lt;p&gt;命令行上执行如下命令，会查看默认的 JVM 参数。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;java -XX:+PrintFlagsFinal -version&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出的内容非常多，但是只有两行能够反映出上面的内存分配结果&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.026957637997432605&quot; data-type=&quot;jpeg&quot; data-w=&quot;1558&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmTE6mPvUkFS94GmjBPr6O6bibMdpkFjGVUZsNxDUoYwW0mxQMpfIQ8uQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.025348542458808618&quot; data-type=&quot;jpeg&quot; data-w=&quot;1578&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmMbrkQujCzJ36ZRFUIAKxx4zUgksBDFdM0VPxGkG2BnCbY79TLRm1mQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.16066838046272494&quot; data-type=&quot;jpeg&quot; data-w=&quot;1556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmqSu2icmh4TXibVQP9VPw7gxtDoiblbmOBQJWuicnL1RYW0nw848aomFMzw/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;eden 区：8/10 的年轻代空间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;survivor 0 : 1/10 的年轻代空间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;survivor 1 : 1/10 的年轻代空间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;老年代 ：三分之二的堆空间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;年轻代 ：三分之一的堆空间&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;运行时常量池&lt;/code&gt;：运行时常量池又被称为 &lt;code&gt;Runtime Constant Pool&lt;/code&gt;，这块区域是方法区的一部分，它的名字非常有意思，通常被称为 &lt;code&gt;非堆&lt;/code&gt;。它并不要求常量一定只有在编译期才能产生，也就是并非编译期间将常量放在常量池中，运行期间也可以将新的常量放入常量池中，String 的 intern 方法就是一个典型的例子。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;请你描述一下 Java 中的类加载机制？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 虚拟机负责把描述类的数据从 Class 文件加载到系统内存中，并对类的数据进行&lt;strong&gt;校验、转换解析和初始化&lt;/strong&gt;，最终形成可以被虚拟机直接使用的 Java 类型，这个过程被称之为 Java 的&lt;code&gt;类加载机制&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个类从被加载到虚拟机内存开始，到卸载出内存为止，一共会经历下面这些过程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.35430038510911427&quot; data-type=&quot;jpeg&quot; data-w=&quot;779&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmhtUXSic00Bagu6DFhheVwHP2rV3V5FVOJezDXME6sy6ePBVxibFeicuzA/640?wx_fmt=jpeg&quot; class=&quot;rich_pages wxw-img&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类加载机制一共有五个步骤，分别是&lt;strong&gt;加载、链接、初始化、使用和卸载&lt;/strong&gt;阶段，这五个阶段的顺序是确定的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中链接阶段会细分成三个阶段，分别是验证、准备、解析阶段，这三个阶段的顺序是不确定的，这三个阶段通常交互进行。解析阶段通常会在初始化之后再开始，这是为了支持 Java 语言的运行时绑定特性（也被称为&lt;code&gt;动态绑定&lt;/code&gt;）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们就来聊一下这几个过程。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;加载&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于什么时候开始加载这个过程，《Java 虚拟机规范》并没有强制约束，所以这一点我们可以自由实现。加载是整个类加载过程的第一个阶段，在这个阶段，Java 虚拟机需要完成三件事情：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;通过一个类的全限定名来获取定义此类的二进制字节流。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将这个字节流表示的一种存储结构转换为运行时数据区中方法区的数据结构。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在内存中生成一个 Class 对象，这个对象就代表了这个数据结构的访问入口。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;《Java 虚拟机规范》并未规定全限定名是如何获取的，所以现在业界有很多获取全限定名的方式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;从 ZIP 包中读取，最终会改变为 JAR、EAR、WAR 格式。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从网络中获取，最常见的应用就是 Web Applet。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;运行时动态生成，使用最多的就是动态代理技术。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;由其他文件生成，比如 JSP 应用场景，由 JSP 文件生成对应的 Class 文件。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从数据库中读取，这种场景就比较小了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以从加密文件中获取，这是典型的防止 Class 文件被反编译的保护措施。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加载阶段既可以使用虚拟机内置的引导类加载器来完成，也可以使用用户自定义的类加载器来完成。程序员可以通过自己定义类加载器来控制字节流的访问方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数组的加载不需要通过类加载器来创建，它是直接在内存中分配，但是数组的元素类型（数组去掉所有维度的类型）最终还是要靠类加载器来完成加载。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;验证&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加载过后的下一个阶段就是验证，因为我们上一步讲到在内存中生成了一个 Class 对象，这个对象是访问其代表数据结构的入口，所以这一步验证的工作就是确保 Class 文件的字节流中的内容符合《Java 虚拟机规范》中的要求，保证这些信息被当作代码运行后，它不会威胁到虚拟机的安全。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;验证阶段主要分为四个阶段的检验：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;文件格式验证。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;元数据验证。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;字节码验证。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;符号引用验证。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;文件格式验证&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一阶段可能会包含下面这些验证点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;魔数是否以 &lt;code&gt;0xCAFEBABE&lt;/code&gt; 开头。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主、次版本号是否在当前 Java 虚拟机接受范围之内。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;常量池的常量中是否有不支持的常量类型。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CONSTANT_Utf8_info 型的常量中是否有不符合 UTF8 编码的数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Class 文件中各个部分及文件本身是否有被删除的或附加的其他信息。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上验证点远远不止有这些，上面这些只是从 HotSpot 源码中摘抄的一小段内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;元数据验证&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一阶段主要是对字节码描述的信息进行语义分析，以确保描述的信息符合《Java 语言规范》，验证点包括&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;验证的类是否有父类（除了 Object 类之外，所有的类都应该有父类）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;要验证类的父类是否继承了不允许继承的类。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果这个类不是抽象类，那么这个类是否实现了父类或者接口中要求的所有方法。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;是否覆盖了 final 字段，是否出现了不符合规定的重载等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要记住这一阶段只是对《Java 语言规范》的验证。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;字节码验证&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;字节码验证阶段是最复杂的一个阶段，这个阶段主要是确定程序语意是否合法、是否是符合逻辑的。这个阶段主要是对类的方法体（Class 文件中的 Code 属性）进行校验分析。这部分验证包括&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;确保操作数栈的数据类型和实际执行时的数据类型是否一致。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;保证任何跳转指令不会跳出到方法体外的字节码指令上。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;保证方法体中的类型转换是有效的，例如可以把一个子类对象赋值给父类数据类型，但是不能把父类数据类型赋值给子类等诸如此不安全的类型转换。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;其他验证。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果没有通过字节码验证，就说明验证出问题。但是不一定通过了字节码验证，就能保证程序是安全的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;符号引用验证&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后一个阶段的校验行为发生在虚拟机将符号引用转换为直接引用的时候，这个转化将在连接的第三个阶段，即解析阶段中发生。符号引用验证可以看作是对类自身以外的各类信息进行匹配性校验，这个验证主要包括&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;符号引用中的字符串全限定名是否能找到对应的类。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;符号引用的类、字段方法的可访问性是否可被当前类所访问。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;其他验证。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一阶段主要是确保解析行为能否正常执行，如果无法通过符号引用验证，就会出现类似 &lt;code&gt;IllegalAccessError&lt;/code&gt;、&lt;code&gt;NoSuchFieldError&lt;/code&gt;、&lt;code&gt;NoSuchMethodError&lt;/code&gt; 等错误。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;验证阶段对于虚拟机来说非常重要，如果能通过验证，就说明你的程序在运行时不会产生任何影响。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;准备&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;准备阶段是为类中的变量分配内存并设置其初始值的阶段，这些变量所使用的内存都应当在方法区中进行分配，在 JDK 7 之前，HotSpot 使用永久代来实现方法区，是符合这种逻辑概念的。而在 JDK 8 之后，变量则会随着 Class 对象一起存放在 Java 堆中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面通常情况下的基本类型和引用类型的初始值&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4858548585485855&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYm1Ch67QbW54ydQnWYMxRXKPScMyEPg9vgJe5dnyDHS9LUd7E6xLjickA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;813&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了&quot;通常情况&quot;下，还有一些&quot;例外情况&quot;，如果类字段属性中存在 &lt;code&gt;ConstantValue&lt;/code&gt; 属性，那就这个变量值在初始阶段就会初始化为 ConstantValue 属性所指定的初始值，比如&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; value = &lt;span&gt;&quot;666&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译时就会把 value 的值设置为 666。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;解析&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解析阶段是 Java 虚拟机将常量池内的符号引用替换为直接引用的过程。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;符号引用&lt;/code&gt;：符号引用以一组符号来描述所引用的目标。符号引用可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可，符号引用和虚拟机的布局无关。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;直接引用&lt;/code&gt;：直接引用可以直接指向目标的指针、相对便宜量或者一个能间接定位到目标的句柄。直接引用和虚拟机的布局是相关的，不同的虚拟机对于相同的符号引用所翻译出来的直接引用一般是不同的。如果有了直接引用，那么直接引用的目标一定被加载到了内存中。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样说你可能还有点不明白，我再换一种说法：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在编译的时候一个每个 Java 类都会被编译成一个 class 文件，但在编译的时候虚拟机并不知道所引用类的地址，所以就用符号引用来代替，而在这个解析阶段就是为了把这个符号引用转化成为真正的地址的阶段。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;《Java 虚拟机规范》并未规定解析阶段发生的时间，只要求了在 anewarray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invokespecial、invokestatic、invokevirtual、ldc、ldc_w、ldc2_w、multianewarray、new、putfield 和 putstatic 这 17 个用于操作符号引用的字节码指令之前，先对所使用的符号引用进行解析。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解析也分为四个步骤&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;初始化&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初始化是类加载过程的最后一个步骤，在之前的阶段中，都是由 Java 虚拟机占主导作用，但是到了这一步，却把主动权移交给应用程序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于初始化阶段，《Java 虚拟机规范》严格规定了只有下面这六种情况下才会触发类的初始化。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在遇到 new、getstatic、putstatic 或者 invokestatic 这四条字节码指令时，如果没有进行过初始化，那么首先触发初始化。通过这四个字节码的名称可以判断，这四条字节码其实就两个场景，调用 new 关键字的时候进行初始化、读取或者设置一个静态字段的时候、调用静态方法的时候。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在初始化类的时候，如果父类还没有初始化，那么就需要先对父类进行初始化。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在使用 java.lang.reflect 包的方法进行反射调用的时候。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当虚拟机启动时，用户需要指定执行主类的时候，说白了就是虚拟机会先初始化 main 方法这个类。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在使用 JDK 7 新加入的动态语言支持时，如果一个 jafva.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getstatic、REF_putstatic、REF_invokeStatic、REF_newInvokeSpecial 四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，需要先对其进行初始化。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当一个接口中定义了 JDK 8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实上面只有前四个大家需要知道就好了，后面两个比较冷门。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;如果说要回答&lt;/span&gt;&lt;span&gt;类加载的话，其实聊到这里已经可以了，但是为了完整性，我们索性把后面两个过程也来聊一聊。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;使用&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个阶段没什么可说的，就是初始化之后的代码由 JVM 来动态调用执行。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;卸载&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当代表一个类的 Class 对象不再被引用，那么 Class 对象的生命周期就结束了，对应的在方法区中的数据也会被卸载。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;⚠️但是需要注意一点：JVM 自带的类加载器装载的类，是不会卸载的，由用户自定义的类加载器加载的类是可以卸载的。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;在 JVM 中，对象是如何创建的？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果要回答对象是怎么创建的，我们一般想到的回答是直接 &lt;code&gt;new&lt;/code&gt; 出来就行了，这个回答不仅局限于编程中，也融入在我们生活中的方方面面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是遇到面试的时候你只回答一个&quot;new 出来就行了&quot;显然是不行的，因为面试更趋向于让你解释当程序执行到 new 这条指令时，它的背后发生了什么。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以你需要从 JVM 的角度来解释这件事情。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当虚拟机遇到一个 new 指令时（其实就是字节码），首先会去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用所代表的类是否已经被加载、解析和初始化。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;因为此时很可能不知道具体的类是什么，所以这里使用的是符号引用。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果发现这个类没有经过上面类加载的过程，那么就执行相应的类加载过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类检查完成后，接下来虚拟机将会为新生对象&lt;strong&gt;分配内存&lt;/strong&gt;，对象所需的大小在类加载完成后便可确定（我会在下面的面试题中介绍）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分配内存相当于是把一块固定的内存块从堆中划分出来。划分出来之后，虚拟机会将分配到的内存空间都初始化为零值，如果使用了 &lt;code&gt;TLAB&lt;/code&gt;（本地线程分配缓冲），这一项初始化工作可以提前在 TLAB 分配时进行。这一步操作保证了对象实例字段在 Java 代码中可以不赋值就能直接使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，Java 虚拟机还会对对象进行必要的设置，比如确定对象是哪个类的实例、对象的 hashcode、对象的 gc 分代年龄信息。这些信息存放在对象的对象头（Object Header）中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果上面的工作都做完后，从虚拟机的角度来说，一个新的对象就创建完毕了；但是对于程序员来说，对象创建才刚刚开始，因为构造函数，即 Class 文件中的 &lt;code&gt;&amp;lt;init&amp;gt;()&lt;/code&gt; 方法还没有执行，所有字段都为默认的零值。new 指令之后才会执行 &lt;code&gt;&amp;lt;init&amp;gt;()&lt;/code&gt; 方法，然后按照程序员的意愿对对象进行初始化，这样一个对象才可能被完整的构造出来。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;内存分配方式有哪些呢？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在类加载完成后，虚拟机需要为新生对象分配内存，为对象分配内存相当于是把一块确定的区域从堆中划分出来，这就涉及到一个问题，&lt;strong&gt;要划分的堆区是否规整&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设 Java 堆中内存是规整的，所有使用过的内存放在一边，未使用的内存放在一边，中间放着一个指针，这个指针为分界指示器。那么为新对象分配内存空间就相当于是把指针向空闲的空间挪动对象大小相等的距离，这种内存分配方式叫做&lt;code&gt;指针碰撞(Bump The Pointer)&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果 Java 堆中的内存并不是规整的，已经被使用的内存和未被使用的内存相互交错在一起，这种情况下就没有办法使用指针碰撞，这里就要使用另外一种记录内存使用的方式：&lt;code&gt;空闲列表(Free List)&lt;/code&gt;，空闲列表维护了一个列表，这个列表记录了哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，上述两种分配方式选择哪个，取决于 Java 堆是否规整来决定。在一些垃圾收集器的实现中，Serial、ParNew 等带压缩整理过程的收集器，使用的是指针碰撞；而使用 CMS 这种基于清除算法的收集器时，使用的是空闲列表，具体的垃圾收集器我们后面会聊到。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;请你说一下对象的内存布局？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;code&gt;hotspot&lt;/code&gt; 虚拟机中，对象在内存中的布局分为三块区域：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;对象头(Header)&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;实例数据(Instance Data)&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;对齐填充(Padding)&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这三块区域的内存分布如下图所示&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5553892215568862&quot; data-type=&quot;jpeg&quot; data-w=&quot;668&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmwt0GFv70dlvtZVDNGSlN1va4spbg2Jib3RsZibIY59DMSdsRAsIGBFJg/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来详细介绍一下上面对象中的内容。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;对象头 Header&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对象头 Header 主要包含 MarkWord 和对象指针 Klass Pointer，如果是数组的话，还要包含数组的长度。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.16253101736972705&quot; data-type=&quot;jpeg&quot; data-w=&quot;806&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmdSiazv22SSjqa9qTicdtOaqEU6ysPu1aPm0ia5E9DJk5JUY1ibSGaKGwww/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 32 位的虚拟机中 MarkWord ，Klass Pointer 和数组长度分别占用 32 位，也就是 4 字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是 64 位虚拟机的话，MarkWord ，Klass Pointer 和数组长度分别占用 64 位，也就是 8 字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 32 位虚拟机和 64 位虚拟机的 Mark Word 所占用的字节大小不一样，32 位虚拟机的 Mark Word 和 Klass Pointer 分别占用 32 bits 的字节，而 64 位虚拟机的 Mark Word 和 Klass Pointer 占用了64 bits 的字节，下面我们以 32 位虚拟机为例，来看一下其 Mark Word 的字节具体是如何分配的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7952261306532663&quot; data-type=&quot;jpeg&quot; data-w=&quot;796&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmF7oQ1WDXyWnQ2vctT5zLDibH4A11ZOVQb9H7aSbaKVu9WHOLyicRR4YA/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用中文翻译过来就是&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5868102288021534&quot; data-type=&quot;jpeg&quot; data-w=&quot;743&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmFkK8j9Zq4XVUHHKwFaqiarAJmvDobibvjDTjojGFve00zwh3zjso09bQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;无状态也就是&lt;code&gt;无锁&lt;/code&gt;的时候，对象头开辟 25 bit 的空间用来存储对象的 hashcode ，4 bit 用于存放分代年龄，1 bit 用来存放是否偏向锁的标识位，2 bit 用来存放锁标识位为 01。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;偏向锁&lt;/code&gt; 中划分更细，还是开辟 25 bit 的空间，其中 23 bit 用来存放线程ID，2bit 用来存放 epoch，4bit 存放分代年龄，1 bit 存放是否偏向锁标识， 0 表示无锁，1 表示偏向锁，锁的标识位还是 01。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;轻量级锁&lt;/code&gt;中直接开辟 30 bit 的空间存放指向栈中锁记录的指针，2bit 存放锁的标志位，其标志位为 00。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;重量级锁&lt;/code&gt;中和轻量级锁一样，30 bit 的空间用来存放指向重量级锁的指针，2 bit 存放锁的标识位，为 11&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;GC标记&lt;/code&gt;开辟 30 bit 的内存空间却没有占用，2 bit 空间存放锁标志位为 11。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中无锁和偏向锁的锁标志位都是 01，只是在前面的 1 bit 区分了这是无锁状态还是偏向锁状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于为什么这么分配的内存，我们可以从 &lt;code&gt;OpenJDK&lt;/code&gt; 中的markOop.hpp类中的枚举窥出端倪&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.27560050568900124&quot; data-type=&quot;jpeg&quot; data-w=&quot;791&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYm96eGhUyYOWB0aUCSkb4KQZPHEI2gDibq9Pia7nOsNP3jvusH9G9uNDQg/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来解释一下&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;age_bits 就是我们说的分代回收的标识，占用4字节&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;lock_bits 是锁的标志位，占用2个字节&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;biased_lock_bits 是是否偏向锁的标识，占用1个字节。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;max_hash_bits 是针对无锁计算的 hashcode 占用字节数量，如果是 32 位虚拟机，就是 32 - 4 - 2 -1 = 25 byte，如果是 64 位虚拟机，64 - 4 - 2 - 1 = 57 byte，但是会有 25 字节未使用，所以 64 位的 hashcode 占用 31 byte。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;hash_bits 是针对 64 位虚拟机来说，如果最大字节数大于 31，则取 31，否则取真实的字节数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;cms_bits 我觉得应该是不是 64 位虚拟机就占用 0 byte，是 64 位就占用 1byte&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;epoch_bits 就是 epoch 所占用的字节大小，2 字节。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面的虚拟机对象头分配表中，我们可以看到有几种锁的状态：无锁（无状态），偏向锁，轻量级锁，重量级锁，其中轻量级锁和偏向锁是 JDK1.6 中对 synchronized 锁进行优化后新增加的，其目的就是为了大大优化锁的性能，所以在 JDK 1.6 中，使用 synchronized 的开销也没那么大了。其实从锁有无锁定来讲，还是只有无锁和重量级锁，偏向锁和轻量级锁的出现就是增加了锁的获取性能而已，并没有出现新的锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们的重点放在对 synchronized 重量级锁的研究上，当 monitor 被某个线程持有后，它就会处于锁定状态。在 HotSpot 虚拟机中，monitor 的底层代码是由 &lt;code&gt;ObjectMonitor&lt;/code&gt; 实现的，其主要数据结构如下（位于 HotSpot 虚拟机源码 ObjectMonitor.hpp 文件，C++ 实现的）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6672413793103448&quot; data-type=&quot;jpeg&quot; data-w=&quot;580&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmibCm80Ch6SkLdCI5t5WWf9dyyA6ONK72jhw1KVa0M2ZF0ibo76dC29TQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段 C++ 中需要注意几个属性：_WaitSet 、 _EntryList 和 _Owner，每个等待获取锁的线程都会被封装称为 &lt;code&gt;ObjectWaiter&lt;/code&gt; 对象。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.15234375&quot; data-type=&quot;jpeg&quot; data-w=&quot;768&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmk3YshTalB5Hwd6Fiar6GlZcynMNp8jPFTMXAQYL5vOY7EBsuEUcAAQw/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;_Owner 是指向了 ObjectMonitor 对象的线程，而 _WaitSet 和 _EntryList 就是用来保存每个线程的列表。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;那么这两个列表有什么区别呢？这个问题我和你聊一下锁的获取流程你就清楚了。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;锁的两个列表&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当多个线程同时访问某段同步代码时，首先会进入 _EntryList 集合，当线程获取到对象的 monitor 之后，就会进入 _Owner 区域，并把 ObjectMonitor 对象的 _Owner 指向为当前线程，并使 _count + 1，如果调用了释放锁（比如 wait）的操作，就会释放当前持有的 monitor ，owner = null， _count - 1，同时这个线程会进入到 _WaitSet 列表中等待被唤醒。如果当前线程执行完毕后也会释放 monitor 锁，只不过此时不会进入 _WaitSet 列表了，而是直接复位 _count 的值。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5186721991701245&quot; data-type=&quot;jpeg&quot; data-w=&quot;723&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmBkaHmIEibGZQNYvZxKVI44KjHm6f8h97E8lQ5QReUfjGyicIdKDvfqaQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Klass Pointer 表示的是类型指针，也就是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;你可能不是很理解指针是个什么概念，你可以简单理解为指针就是指向某个数据的地址。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24173553719008264&quot; data-type=&quot;jpeg&quot; data-w=&quot;484&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmg07SkwDltzz9neeE2KaZendKZ6fXemgDZkicSJDj0c550jUZsbkmribA/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;实例数据 Instance Data&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实例数据部分是对象真正存储的有效信息，也是代码中定义的各个字段的字节大小，比如一个 byte 占 1 个字节，一个 int 占用 4 个字节。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;对齐 Padding&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对齐不是必须存在的，它只起到了占位符(%d, %c 等)的作用。这就是 JVM 的要求了，因为 HotSpot JVM 要求对象的起始地址必须是 8 字节的整数倍，也就是说对象的字节大小是 8 的整数倍，不够的需要使用 Padding 补全。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;对象访问定位的方式有哪些？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们创建一个对象的目的当然就是为了使用它，但是，一个对象被创建出来之后，在 JVM 中是如何访问这个对象的呢？一般有两种方式：&lt;strong&gt;通过句柄访问&lt;/strong&gt;和 &lt;strong&gt;通过直接指针访问&lt;/strong&gt;。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果使用句柄访问方式的话，Java 堆中可能会划分出一块内存作为句柄池，引用（reference）中存储的是对象的句柄地址，而句柄中包含了对象的实例数据与类型数据各自具体的地址信息。如下图所示。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5897079276773296&quot; data-type=&quot;jpeg&quot; data-w=&quot;719&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmHgibj2NpibuUa5q2waiaW1IBIibGSVCLo0PK24xS5o9JIhvHTJ2av06Vvw/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果使用直接指针访问的话，Java 堆中对象的内存布局就会有所区别，栈区引用指示的是堆中的实例数据的地址，如果只是访问对象本身的话，就不会多一次直接访问的开销，而对象类型数据的指针是存在于方法区中，如果定位的话，需要多一次直接定位开销。如下图所示&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5730180806675939&quot; data-type=&quot;jpeg&quot; data-w=&quot;719&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmBv2RUQEwedibWN6J1au1sNtv7CwytYs7jsgv6McosWQ6ZKkyZzpRohA/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两种对象访问方式各有各的优势，使用句柄最大的好处就是引用中存储的是句柄地址，对象移动时只需改变句柄的地址就可以，而无需改变对象本身。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用直接指针来访问速度更快，它节省了一次指针定位的时间开销，由于对象访问在 Java 中非常频繁，因为这类的开销也是值得优化的地方。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面聊到了对象的两种数据，一种是对象的实例数据，这没什么好说的，就是对象实例字段的数据，一种是对象的类型数据，这个数据说的是对象的类型、父类、实现的接口和方法等。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;如何判断对象已经死亡？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们大家知道，基本上所有的对象都在堆中分布，当我们不再使用对象的时候，垃圾收集器会对无用对象进行回收♻️，那么 JVM 是如何判断哪些对象已经是&quot;无用对象&quot;的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有两种判断方式，首先我们先来说第一种：&lt;strong&gt;引用计数法&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引用计数法的判断标准是这样的：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器的值就会加一；当引用失效时，计数器的值就会减一；只要任何时刻计数器为零的对象就是不会再被使用的对象。虽然这种判断方式非常简单粗暴，但是往往很有用，不过，在 Java 领域，主流的 Hotspot 虚拟机实现并没有采用这种方式，因为引用计数法不能解决对象之间的循环引用问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;循环引用问题简单来讲就是两个对象之间互相依赖着对方，除此之外，再无其他引用，这样虚拟机无法判断引用是否为零从而进行垃圾回收操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一种判断对象无用的方法就是&lt;strong&gt;可达性分析算法&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当前主流的 JVM 都采用了可达性分析算法来进行判断，这个算法的基本思路就是通过一系列被称为&lt;code&gt;GC Roots&lt;/code&gt;的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程走过的路径被称为&lt;code&gt;引用链&lt;/code&gt;（Reference Chain），如果某个对象到 GC Roots 之间没有任何引用链相连接，或者说从 GC Roots 到这个对象不可达时，则证明此这个对象是无用对象，需要被垃圾回收。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种引用方式如下&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6780626780626781&quot; data-type=&quot;jpeg&quot; data-w=&quot;702&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmibo27syf4OQQJTcBLlJd8qGxwuGFhVdBNvfpxiaPZg1Cz6aozFz22hdw/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图所示，从枚举根节点 GC Roots 开始进行遍历，object 1 、2、3、4 是存在引用关系的对象，而 object 5、6、7 之间虽然有关联，但是它们到 GC Roots 之间是不可达的，所以被认为是可以回收的对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Java 技术体系中，可以作为 GC Roots 进行检索的对象主要有&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在虚拟机栈（栈帧中的本地变量表）中引用的对象。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;方法区中类静态属性引用的对象，比如 Java 类的引用类型静态变量。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;方法区中常量引用的对象，比如字符串常量池中的引用。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在本地方法栈中 JNI 引用的对象。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;JVM 内部的引用，比如基本数据类型对应的 Class 对象，一些异常对象比如 NullPointerException、OutOfMemoryError 等，还有系统类加载器。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;所有被 synchronized 持有的对象。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;还有一些 JVM 内部的比如 JMXBean、JVMTI 中注册的回调，本地代码缓存等。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;根据用户所选的垃圾收集器以及当前回收的内存区域的不同，还可能会有一些对象临时加入，共同构成 GC Roots 集合。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然我们上面提到了两种判断对象回收的方法，但无论是引用计数法还是判断 GC Roots 都离不开&lt;code&gt;引用&lt;/code&gt;这一层关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里涉及到到强引用、软引用、弱引用、虚引用的引用关系，你可以阅读作者的这一篇文章&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwMDE1MzkwNQ==&amp;amp;mid=2247495968&amp;amp;idx=1&amp;amp;sn=48de091f4fabdf682a9f8b5ddd8db936&amp;amp;chksm=c04ae67ef73d6f68935382dcaa0bd4d538a9e0b45ee49500ee7e2356cc24dba750b197960477&amp;amp;token=1191632986&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;小心点，别被当成垃圾回收了。&lt;/a&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;如何判断一个不再使用的类？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;判断一个类型属于&quot;不再使用的类&quot;需要满足下面这三个条件&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这个类所有的实例已经被回收，也就是 Java 堆中不存在该类及其任何这个类字类的实例&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;加载这个类的类加载器已经被回收，但是类加载器一般很难会被回收，除非这个类加载器是为了这个目的设计的，比如 OSGI、JSP 的重加载等，否则通常很难达成。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这个类对应的 Class 对象没有任何地方被引用，无法在任何时刻通过反射访问这个类的属性和方法。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虚拟机允许对满足上面这三个条件的无用类进行回收操作。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JVM 分代收集理论有哪些？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般商业的虚拟机，大多数都遵循了&lt;strong&gt;分代收集&lt;/strong&gt;的设计思想，分代收集理论主要有两条假说。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一个是&lt;strong&gt;强分代假说&lt;/strong&gt;，强分代假说指的是 JVM 认为绝大多数对象的生存周期都是朝生夕灭的；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二个是&lt;strong&gt;弱分代假说&lt;/strong&gt;，弱分代假说指的是只要熬过越多次垃圾收集过程的对象就越难以回收（看来对象也会长心眼）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就是基于这两个假说理论，JVM 将&lt;code&gt;堆&lt;/code&gt;区划分为不同的区域，再将需要回收的对象根据其熬过垃圾回收的次数分配到不同的区域中存储。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;JVM 根据这两条分代收集理论，把堆区划分为新生代(Young Generation)和&lt;/span&gt;&lt;span&gt;老年代(Old Generation)这两个区域。&lt;/span&gt;&lt;span&gt;在新生代中，每次垃圾收集时都发现有大批对象死去，剩下没有死去的对象会直接晋升到老年代中。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这两个假说没有考虑对象的引用关系，而事实情况是，对象之间会存在引用关系，基于此又诞生了第三个假说，即&lt;strong&gt;跨代引用假说(Intergeneration Reference Hypothesis)&lt;/strong&gt;，跨代引用相比较同代引用来说仅占少数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正常来说存在相互引用的两个对象应该是同生共死的，不过也会存在特例，如果一个新生代对象跨代引用了一个老年代的对象，那么垃圾回收的时候就不会回收这个新生代对象，更不会回收老年代对象，然后这个新生代对象熬过一次垃圾回收进入到老年代中，这时候跨代引用才会消除。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据跨代引用假说，我们不需要因为老年代中存在少量跨代引用就去直接扫描整个老年代，也不用在老年代中维护一个列表记录有哪些跨代引用，实际上，可以直接在新生代中维护一个&lt;strong&gt;记忆集(Remembered Set)&lt;/strong&gt;，由这个记忆集把老年代划分称为若干小块，标识出老年代的哪一块会存在跨代引用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;记忆集的图示如下&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3736842105263158&quot; data-type=&quot;jpeg&quot; data-w=&quot;760&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmjJ9x4892ccaD2Cks5hjiaHRXH9TrbWR5DibfOPPrcgs1CTjKKX67PWrA/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图中我们可以看到，记忆集中的每个元素分别对应内存中的一块连续区域是否有跨代引用对象，如果有，该区域会被标记为“脏的”（dirty），否则就是“干净的”（clean）。这样在垃圾回收时，只需要扫描记忆集就可以简单地确定跨代引用的位置，是个典型的空间换时间的思路。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;聊一聊 JVM 中的垃圾回收算法？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在聊具体的垃圾回收算法之前，需要明确一点，哪些对象需要被垃圾收集器进行回收？也就是说需要先判断哪些对象是&quot;垃圾&quot;？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;判断的标准我在上面&lt;strong&gt;如何判断对象已经死亡&lt;/strong&gt;的问题中描述了，有两种方式，一种是引用计数法，这种判断标准就是给对象添加一个引用计数器，引用这个对象会使计数器的值 + 1，引用失效后，计数器的值就会 -1。但是这种技术无法解决对象之间的循环引用问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一种方式是 GC Roots，GC Roots 这种方式是以 Root 根节点为核心，逐步向下搜索每个对象的引用，搜索走过的路径被称为引用链，如果搜索过后这个对象不存在引用链，那么这个对象就是无用对象，可以被回收。GC Roots 可以解决循环引用问题，所以一般 JVM 都采用的是这种方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解决循环引用代码描述：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[]args)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        A a = &lt;span&gt;new&lt;/span&gt; A();&lt;br/&gt;        B b = &lt;span&gt;new&lt;/span&gt; B();&lt;br/&gt;        a=&lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        b=&lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;A&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; B b;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;B&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; A a;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于 GC Roots 的这种思想，发展出了很多垃圾回收算法，下面我们就来聊一聊这些算法。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;标记-清除算法&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标记-清除(Mark-Sweep)这个算法可以说是最早最基础的算法了，标记-清除顾名思义分为两个阶段，即标记和清除阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象。当然也可以标记存活的对象，回收未被标记的对象。这个标记的过程就是垃圾判定的过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后续大部分垃圾回收算法都是基于标记-算法思想衍生的，只不过后续的算法弥补了标记-清除算法的缺点，那么它有什么缺点呢？主要有两个&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;执行效率不稳定&lt;/strong&gt;，因为假如说堆中存在大量无用对象，而且大部分需要回收的情况下，这时必须进行大量的标记和清除，导致标记和清除这两个过程的执行效率随对象的数量增长而降低。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;内存碎片化&lt;/strong&gt;，标记-清除算法会在堆区产生大量不连续的内存碎片。碎片太多会导致在分配大对象时没有足够的空间，不得不进行一次垃圾回收操作。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标记算法的示意图如下&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6547277936962751&quot; data-type=&quot;jpeg&quot; data-w=&quot;698&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYm8AemwmWaUPnRysSxqyplddlib4UjMRJiadSqMxK049A1snJyxaBj3GoA/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;标记-复制算法&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于标记-清除算法极易产生内存碎片，研究人员提出了标记-复制算法，标记-复制算法也可以简称为复制算法，复制算法是一种&lt;strong&gt;半区复制&lt;/strong&gt;，它会将内存大小划分为相等的两块，每次只使用其中的一块，用完一块再用另外一块，然后再把用过的一块进行清除。虽然解决了部分内存碎片的问题，但是复制算法也带来了新的问题，即&lt;strong&gt;复制开销&lt;/strong&gt;，不过这种开销是可以降低的，如果内存中大多数对象是无用对象，那么就可以把少数的存活对象进行复制，再回收无用的对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过复制算法的缺陷也是显而易见的，那就是内存空间缩小为原来的一半，空间浪费太明显。标记-复制算法示意图如下&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.598937583001328&quot; data-type=&quot;jpeg&quot; data-w=&quot;753&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYm82CwrSX0SzxshZPJ7XpofasKBOBgicWOkg328AeIKLXn1qOqK8FDIZw/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在 Java 虚拟机大多数都是用了这种算法来回收新生代，因为经过研究表明，新生代对象 98% 都熬不过第一轮收集，因此不需要按照 1 ：1 的比例来划分新生代的内存空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于此，研究人员提出了一种 Appel 式回收，Appel 式回收的具体做法是把新生代分为一块较大的 &lt;em&gt;Eden&lt;/em&gt; 空间和两块 &lt;em&gt;Survivor&lt;/em&gt; 空间，每次分配内存都只使用 Eden 和其中的一块 Survivor 空间，发生垃圾收集时，将 Eden 和 Survivor 中仍然存活的对象一次性复制到另外一块 Survivor 空间上，然后直接清理掉 Eden 和已使用过的 Survivor 空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在主流的 HotSpot 虚拟机中，默认的 Eden 和 Survivor 大小比例是 8：1，也就是每次新生代中可用内存空间为整个新生代容量的 90%，只有一个 Survivor 空间，所以会浪费掉 10% 的空间。这个 8：1 只是一个理论值，也就是说，不能保证每次都有不超过 10% 的对象存活，所以，当进行垃圾回收后如果 Survivor 容纳不了可存活的对象后，就需要其他内存空间来进行&lt;strong&gt;帮助&lt;/strong&gt;，这种方式就叫做&lt;strong&gt;内存担保(Handle Promotion)&lt;/strong&gt; ，通常情况下，作为担保的是老年代。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;标记-整理算法&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标记-复制算法虽然解决了内存碎片问题，但是没有解决复制对象存在大量开销的问题。为了解决复制算法的缺陷，充分利用内存空间，提出了标记-整理算法。该算法标记阶段和标记-清除一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。具体过程如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6557142857142857&quot; data-type=&quot;jpeg&quot; data-w=&quot;700&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmFBJDpzuH8wmQMDM4kVXrSdTQ6fcYVjJpx56uCj7o0mU1WAWsD6H7Aw/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是记忆集，什么是卡表？记忆集和卡表有什么关系？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决跨代引用问题，提出了记忆集这个概念，记忆集是一个在新生代中使用的数据结构，它相当于是记录了一些指针的集合，指向了老年代中哪些对象存在跨代引用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;记忆集的实现有不同的粒度&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;字长精度&lt;/strong&gt;：每个记录精确到一个字长，机器字长就是处理器的寻址位数，比如常见的 32 位或者 64 位处理器，这个精度决定了机器访问物理内存地址的指针长度，字中包含跨代指针。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;对象精度&lt;/strong&gt;：每个记录精确到一个对象，该对象里含有跨代指针。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;卡精度&lt;/strong&gt;：每个记录精确到一块内存区域，区域内含有跨代指针。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中卡精度是使用了卡表作为记忆集的实现，关于记忆集和卡表的关系，大家可以想象成是 HashMap 和 Map 的关系。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是卡页？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;卡表其实就是一个字节数组&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;CARD_TABLE[&lt;span&gt;this&lt;/span&gt; address &amp;gt;&amp;gt; &lt;span&gt;9&lt;/span&gt;] = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;字节数组 CARD_TABLE 的每一个元素都对应着内存区域中一块特定大小的内存块，这个内存块就是&lt;strong&gt;卡页&lt;/strong&gt;，一般来说，卡页都是 2 的 N 次幂字节数，通过上面的代码我们可以知道，卡页一般是 2 的 9 次幂，这也是 HotSpot 中使用的卡页，即 512 字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个卡页的内存通常包含不止一个对象，只要卡页中有一个对象的字段存在跨代指针，那就将对应卡表的数组元素的值设置为 1，称之为这个元素变&lt;code&gt;脏&lt;/code&gt;了，没有标示则为 0 。在垃圾收集时，只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页内存块中包含跨代指针，然后把他们加入 GC Roots 进行扫描。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，卡页和卡表主要用来解决跨代引用问题的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是写屏障？写屏障带来的问题？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果有其他分代区域中对象引用了本区域的对象，那么其对应的卡表元素就会变脏，这个引用说的就是对象赋值，也就是说卡表元素会变脏发生在对象赋值的时候，那么如何在对象赋值的时候更新维护卡表呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 HotSpot 虚拟机中使用的是&lt;strong&gt;写屏障(Write Barrier)&lt;/strong&gt; 来维护卡表状态的，这个写屏障和我们内存屏障完全不同，希望读者不要搞混了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个写屏障其实就是一个 Aop 切面，在引用对象进行赋值时会产生一个&lt;strong&gt;环形通知(Around)&lt;/strong&gt;，环形通知就是切面前后分别产生一个通知，因为这个又是写屏障，所以在赋值前的部分写屏障叫做写前屏障，在赋值后的则叫做写后屏障。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写屏障会带来两个问题&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;无条件写屏障带来的性能开销&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每次对引用的更新，无论是否更新了老年代对新生代对象的引用，都会进行一次写屏障操作。显然，这会增加一些额外的开销。但是，扫描整个老年代相比较，这个开销就低得多了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过，在高并发环境下，写屏障又带来了伪共享（false sharing）问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;高并发下伪共享带来的性能开销&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在高并发情况下，频繁的写屏障很容易发生伪共享（false sharing），从而带来性能开销。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设 CPU 缓存行大小为 64 字节，由于一个卡表项占 1 个字节，这意味着，64 个卡表项将共享同一个缓存行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HotSpot 每个卡页为 512 字节，那么一个缓存行将对应 64 个卡页一共 64*512 = 32K B。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不同线程对对象引用的更新操作，恰好位于同一个 32 KB 区域内，这将导致同时更新卡表的同一个缓存行，从而造成缓存行的写回、无效化或者同步操作，间接影响程序性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个简单的解决方案，就是不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表项未被标记过才将其标记为脏的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是 JDK  7 中引入的解决方法，引入了一个新的 JVM 参数 &lt;em&gt;-XX:+UseCondCardMark&lt;/em&gt;，在执行写屏障之前，先简单的做一下判断。如果卡页已被标识过，则不再进行标识。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单理解如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (CARD_TABLE [this address &amp;gt;&amp;gt; 9] != 0)&lt;br/&gt;  CARD_TABLE [this address &amp;gt;&amp;gt; 9] = 0;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与原来的实现相比，只是简单的增加了一个判断操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然开启 &lt;em&gt;-XX:+UseCondCardMark&lt;/em&gt; 之后多了一些判断开销，但是却可以避免在高并发情况下可能发生的并发写卡表问题。通过减少并发写操作，进而避免出现伪共享问题（false sharing）。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是三色标记法？三色标记法会造成哪些问题？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据可达性算法的分析可知，如果要找出存活对象，需要从 GC Roots 开始遍历，然后搜索每个对象是否可达，如果对象可达则为存活对象，在 GC Roots 的搜索过程中，按照&lt;strong&gt;对象和其引用是否被访问过&lt;/strong&gt;这个条件会分成下面三种颜色：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;白色：白色表示 GC Roots 的遍历过程中没有被访问过的对象，出现白色显然在可达性分析刚刚开始的阶段，这个时候所有对象都是白色的，如果在分析结束的阶段，仍然是白色的对象，那么代表不可达，可以进行回收。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;灰色：灰色表示对象已经被访问过，但是这个对象的引用还没有访问完毕。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;黑色：黑色表示此对象已经被访问过了，而且这个对象的引用也已经被访问了。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注：如果标记结束后对象仍为白色，意味着已经“找不到”该对象在哪了，不可能会再被重新引用。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现代的垃圾回收器几乎都借鉴了三色标记的算法思想，尽管实现的方式不尽相同：比如白色/黑色集合一般都不会出现（但是有其他体现颜色的地方）、灰色集合可以通过栈/队列/缓存日志等方式进行实现、遍历方式可以是广度/深度遍历等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;三色标记法会造成两种问题，这两种问题所出现的环境都是由于&lt;strong&gt;用户环境和收集器并行工作造成的&lt;/strong&gt; 。当用户线程正在修改引用关系，此时收集器在回收引用关系，此时就会造成把原本已经消亡的对象标记为存活，如果出现这种状况的话，问题不大，下次再让收集器重新收集一波就完了，但是还有一种情况是把存活的对象标记为死亡，这种状况就会造成不可预知的后果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对上面这两种对象消失问题，业界有两种处理方式，一种是&lt;strong&gt;增量更新(Incremental Update)&lt;/strong&gt; ，一种是&lt;strong&gt;原是快照(Snapshot At The Beginning, SATB)&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;请你介绍一波垃圾收集器&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;垃圾收集器是面试的常考，也是必考点，只要涉及到 JVM 的相关问题，都会围绕着垃圾收集器来做一波展开，所以，有必要了解一下这些垃圾收集器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;垃圾收集器有很多，不同商家、不同版本的 JVM 所提供的垃圾收集器可能会有很大差别，我们主要介绍 HotSpot 虚拟机中的垃圾收集器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;垃圾收集器是垃圾回收算法的具体实现，我们上面提到过，垃圾回收算法有标记-清除算法、标记-整理、标记-复制，所以对应的垃圾收集器也有不同的实现方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道，HotSpot 虚拟机中的垃圾收集都是分代回收的，所以根据不同的分代，可以把垃圾收集器分为&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新生代收集器：Serial、ParNew、Parallel Scavenge；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;老年代收集器：Serial Old、Parallel Old、CMS；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整堆收集器：G1；&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Serial 收集器&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Serial 收集器是一种新生代的垃圾收集器，它是一个单线程工作的收集器，使用复制算法来进行回收，单线程工作不是说这个垃圾收集器只有一个，而是说这个收集器在工作时，必须暂停其他所有工作线程，这种暴力的暂停方式就是 &lt;strong&gt;Stop The World&lt;/strong&gt;，Serial 就好像是寡头垄断一样，只要它一发话，其他所有的小弟（线程）都得给它让路。Serial 收集器的示意图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5209059233449478&quot; data-type=&quot;jpeg&quot; data-w=&quot;574&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmZ3BbmNV9XmU92S53CoX5j4bSEticcJt77oYXQAqpicLRFmA7cBZVsXMg/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;SefePoint 全局安全点：它就是代码中的一段特殊的位置，在所有用户线程到达 SafePoint 之后，用户线程挂起，GC 线程会进行清理工作。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然 Serial 有 STW 这种显而易见的缺点，不过，从其他角度来看，Serial 还是很讨喜的，它还有着优于其他收集器的地方，那就是简单而高效，对于内存资源首先的环境，它是所有收集器中额外内存消耗最小的，对于单核处理器或者处理器核心较少的环境来说，Serial 收集器由于没有线程交互开销，所以 Serial 专心做垃圾回收效率比较高。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ParNew 收集器&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ParNew 是 Serial 的多线程版本，除了同时使用多条线程外，其他参数和机制（STW、回收策略、对象分配规则）都和 Serial 完全一致，ParNew 收集器的示意图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5993150684931506&quot; data-type=&quot;jpeg&quot; data-w=&quot;584&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmPxHcC0semKUibicnjjuSjSkbo8VXdpcs3yZPBw3IQc71u25f8u54iabIw/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然 ParNew 使用了多条线程进行垃圾回收，但是在单线程环境下它绝对不会比 Serial 收集效率更高，因为多线程存在线程交互的开销，但是随着可用 CPU 核数的增加，ParNew 的处理效率会比 Serial 更高效。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Parallel Scavenge 收集器&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Parallel Scavenge 收集器也是一款新生代收集器，它同样是基于标记-复制算法实现的，而且它也能够并行收集，这么看来，表面上 Parallel Scavenge 与 ParNew 非常相似，那么它们之间有什么区别呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Parallel Scavenge 的关注点主要在&lt;strong&gt;达到一个可控制的吞吐量上面&lt;/strong&gt;。吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比。也就是&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.17894736842105263&quot; data-type=&quot;jpeg&quot; data-w=&quot;665&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmscYdWaDzFkxkO3WPSDB9v2OQSHecPmiauKjCEDZyBhmOCLE40bMVETQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里给大家举一个吞吐量的例子，如果执行用户代码的时间 + 运行垃圾收集的时间总共耗费了 100 分钟，其中垃圾收集耗费掉了 1 分钟，那么吞吐量就是 99%。停顿时间越短就越适合需要与用户交互或需要保证服务响应质量，良好的响应速度可以提升用户体验，而高吞吐量可以最高效率利用处理器资源。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Serial Old 收集器&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面介绍了一下 Serial，我们知道它是一个新生代的垃圾收集，使用了标记-复制算法。而这个 Serial Old 收集器却是 Serial 的老年版本，它同样也是一个单线程收集器，使用的是&lt;strong&gt;标记-整理&lt;/strong&gt;算法，Serial Old 收集器有两种用途：一种是在 JDK 5 和之前的版本与 Parallel Scavenge 收集器搭配使用，另外一种用法就是作为 &lt;code&gt;CMS&lt;/code&gt; 收集器的备选，CMS 垃圾收集器我们下面说，Serial Old 的收集流程如下&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4251207729468599&quot; data-type=&quot;jpeg&quot; data-w=&quot;828&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmsr5qnsJKzjvNXjXNCrib8u5HbWlEUWwNPadXLAib7wYHnDL1QP9Gq7jg/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Parallel Old 收集器&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面我们介绍了 Parallel Scavenge 收集器，现在来介绍一下 Parallel Old 收集器，它是 Parallel Scavenge 的老年版本，支持多线程并发收集，基于标记 - 整理算法实现，JDK 6 之后出现，吞吐量优先可以考虑 Parallel Scavenge + Parallel Old 的搭配&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.43103448275862066&quot; data-type=&quot;jpeg&quot; data-w=&quot;812&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmmumuGg3XajNzH8jGictWpG83p0CcRbfoic3OI0dlEsMqZiawe6Ww2jS4Q/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;CMS 收集器&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;CMS&lt;/code&gt;收集器的主要目标是获取最短的回收停顿时间，它的全称是 &lt;em&gt;Concurrent Mark Sweep&lt;/em&gt;，从这个名字就可以知道，这个收集器是基于标记 - 清除算法实现的，而且支持并发收集，它的运行过程要比上面我们提到的收集器复杂一些，它的工作流程如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;初始标记（CMS initial mark）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;并发标记（CMS concurrent mark）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;重新标记（CMS remark）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;并发清除（CMS concurrent sweep）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于上面这四个步骤，初始标记和并发标记都需要 &lt;em&gt;Stop The World&lt;/em&gt;，初始标记只是标记一下和 GC Roots 直接关联到的对象，速度较快；并发标记阶段就是从 GC Roots 的直接关联对象开始遍历整个对象图的过程。这个过程时间比较长但是不需要停顿用户线程，也就是说与垃圾收集线程一起并发运行。并发标记的过程中，可能会有错标或者漏标的情况，此时就需要在重新标记一下，最后是并发清除阶段，清理掉标记阶段中判断已经死亡的对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CMS 的收集过程如下&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3606936416184971&quot; data-type=&quot;jpeg&quot; data-w=&quot;865&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmfffkneclx5D1bAnFbSukKgEWYScjqsrxYZwmMBkvOy4Nkib9tPEOaGQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CMS 是一款非常优秀的垃圾收集器，但是没有任何收集器能够做到完美的程度，CMS 也是一样，CMS 至少有三个缺点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;CMS 对处理器资源非常敏感，在并发阶段，虽然不会造成用户线程停顿，但是却会因为占用一部分线程而导致应用程序变慢，降低总吞吐量。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;CMS 无法处理&lt;strong&gt;浮动垃圾&lt;/strong&gt;，有可能出现&lt;em&gt;Concurrent Mode Failure&lt;/em&gt;失败进而导致另一次完全 &lt;em&gt;Stop The World&lt;/em&gt;的 &lt;em&gt;Full GC&lt;/em&gt; 产生。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;什么是浮动垃圾呢？由于并发标记和并发清理阶段，用户线程仍在继续运行，所以程序自然而然就会伴随着新的垃圾不断出现，而且这一部分垃圾出现在标记结束之后，CMS 无法处理这些垃圾，所以只能等到下一次垃圾回收时在进行清理。这一部分垃圾就被称为浮动垃圾。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;CMS 最后一个缺点是并发-清除的通病，也就是会有大量的空间碎片出现，这将会给分配大对象带来困难。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Garbage First 收集器&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Garbage First 又被称为 &lt;em&gt;G1 收集器&lt;/em&gt;，它的出现意味着垃圾收集器走过了一个里程碑，为什么说它是里程碑呢？因为 G1 这个收集器是一种面向局部的垃圾收集器，HotSpot 团队开发这个垃圾收集器为了让它替换掉 CMS 收集器，所以到后来，JDK 9 发布后，G1 取代了 Parallel Scavenge + Parallel Old 组合，成为服务端默认的垃圾收集器，而 CMS 则不再推荐使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前的垃圾收集器存在回收区域的局限性，因为之前这些垃圾收集器的目标范围要么是整个新生代、要么是整个老年代，要么是整个 Java 堆（Full GC），而 G1 跳出了这个框架，它可以面向堆内存的任何部分来组成&lt;strong&gt;回收集(Collection Set，CSet)&lt;/strong&gt;，衡量垃圾收集的不再是哪个分代，这就是 G1 的 &lt;em&gt;Mixed GC&lt;/em&gt; 模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;G1 是基于 Region 来进行回收的，Region 就是堆内存中任意的布局，每一块 Region 都可以根据需要扮演 Eden 空间、Survivor 空间或者老年代空间，收集器能够对不同的 Region 角色采用不同的策略来进行处理。Region 中还有一块特殊的区域，这块区域就是 &lt;em&gt;Humongous&lt;/em&gt; 区域，它是专门用来存储大对象的，G1 认为只要大小超过了 Region 容量一半的对象即可判定为大对象。如果超过了 Region 容量的大对象，将会存储在连续的 Humongous Region 中，G1 大多数行为都会把 Humongous Region 作为老年代来看待。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;G1 保留了新生代（Eden Suvivor）和老年代的概念，但是新生代和老年代不再是固定的了。它们都是一系列区域的动态集合。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;G1 收集器的运作过程可以分为以下四步：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;初始标记：这个步骤也仅仅是标记一下 GC Roots 能够直接关联到的对象；并修改 TAMS 指针的值（每一个 Region 都有两个 RAMS 指针），使得下一阶段用户并发运行时，能够在可用的 Region 中分配对象，这个阶段需要暂停用户线程，但是时间很短。这个停顿是借用 Minor GC 的时候完成的，所以可以忽略不计。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;并发标记：从 GC Root 开始对堆中对象进行可达性分析，递归扫描整个堆中的对象图，找出要回收的对象。当对象图扫描完成后，重新处理 SATB 记录下的在并发时有引用的对象；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最终标记：对用户线程做一个短暂的暂停，用于处理并发阶段结束后遗留下来的少量 &lt;em&gt;SATB&lt;/em&gt; 记录（一种原始快照，用来记录并发标记中某些对象）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;筛选回收：负责更新 Region 的统计数据，对各个 Region 的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择多个 Region 构成回收集，然后把决定要回收的那一部分 Region 存活对象复制到空的 Region 中，再清理掉整个旧 Region 的全部空间。这里的操作设计对象的移动，所以必须要暂停用户线程，由多条收集器线程并行收集&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面这几个步骤可以看出，除了并发标记外，其余三个阶段都需要暂停用户线程，所以，这个 G1 收集器并非追求&lt;strong&gt;低延迟&lt;/strong&gt;，官方给出的设计目标是&lt;strong&gt;在延迟可控的情况下尽可能的提高吞吐量&lt;/strong&gt;，担任全功能收集器的重任。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是 G1 回收的示意图&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.375&quot; data-type=&quot;jpeg&quot; data-w=&quot;864&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmOticPic3nnyPXRDCMfc6JIOjbSW9QE1y2KVLicsazGK9CDrlps3MOHAAg/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;G1 收集器同样也有缺点和问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一个问题就是 Region 中存在跨代引用的问题，我们之前知道可以用记忆集来解决跨代引用问题，不过 Region 中的跨代引用要复杂很多；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二个问题就是如何保证收集线程与用户线程互不干扰的运行？CMS 使用的是增量更新算法，G1 使用的是原始快照（SATB），G1 为 Region 分配了两块 TAMS 指针，把 Region 中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须在这两个指针位置以上。如果内存回收速度赶不上内存分配速度，G1 收集器也要冻结用户线程执行，导致 Full GC 而产生长时间的 STW。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第三个问题是无法建立可预测的停顿模型。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JVM 常用命令介绍&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面介绍一下 JVM 中常用的调优、故障处理等工具。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;em&gt;jps&lt;/em&gt; ：虚拟机进程工具，全称是 &lt;em&gt;JVM Process Status Tool&lt;/em&gt;，它的功能和 Linux 中的 &lt;em&gt;ps&lt;/em&gt; 类似，可以列出正在运行的虚拟机进程，并显示虚拟机执行主类 &lt;em&gt;Main Class&lt;/em&gt; 所在的本地虚拟机唯一 ID，虽然功能比较单一，但是这个命令绝对是使用最高频的一个命令。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;em&gt;jstat&lt;/em&gt;：虚拟机统计信息工具，用于监视虚拟机各种运行状态的信息的命令行工具，它可以显示本地或者远程虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;em&gt;jinfo&lt;/em&gt;：Java 配置信息工具，全称是 &lt;em&gt;Configuration Info for Java&lt;/em&gt;，它的作用是可以实时调整虚拟机各项参数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;em&gt;jmap&lt;/em&gt;：Java 内存映像工具，全称是 &lt;em&gt;Memory Map For Java&lt;/em&gt;，它用于生成转储快照，用来排查内存占用情况&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;em&gt;jhat&lt;/em&gt;：虚拟机堆转储快照分析工具，全称是 &lt;em&gt;JVM Heap Analysis Tool&lt;/em&gt;，这个指令通常和 jmap 一起搭配使用，jhat 内置了一个 HTTP/Web 服务器，生成转储快照后可以在浏览器中查看。不过，一般还是 jmap 命令使用的频率比较高。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;em&gt;jstack&lt;/em&gt;：Java 堆栈跟踪工具，全称是 &lt;em&gt;Stack Trace for Java&lt;/em&gt; ，顾名思义，这个命令用来追踪堆栈的使用情况，用于虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条正在执行的方法堆栈的集合。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是双亲委派模型？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JVM 类加载默认使用的是&lt;strong&gt;双亲委派模型&lt;/strong&gt;，那么什么是双亲委派模型呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们需要先介绍一下三种类加载器：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;启动类加载器，&lt;em&gt;Bootstrap Class Loader&lt;/em&gt;，这个类加载器是 C++ 实现的，它是 JVM 的一部分，这个类加载器负责加载存放在 &lt;em&gt;&amp;lt;JAVA_HOME&amp;gt;\lib&lt;/em&gt; 目录，启动类加载器无法被 Java 程序直接引用。这也就是说，JDK 中的常用类的加载都是由启动类加载器来完成的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;扩展类加载器，&lt;em&gt;Extension Class Loader&lt;/em&gt;，这个类加载器是 Java 实现的，它负责加载 &lt;em&gt;&amp;lt;JAVA_HOME&amp;gt;\lib\ext&lt;/em&gt; 目录。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;应用程序类加载器，&lt;em&gt;Application Class Loader&lt;/em&gt;，这个类加载器是由 &lt;em&gt;sum.misc.Launcher$AppClassLoader&lt;/em&gt; 来实现，它负责加载 &lt;em&gt;ClassPath&lt;/em&gt; 上所有的类库，如果应用程序中没有定义自己的类加载器，默认使用就是这个类加载器。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，我们的 Java 应用程序都是由这三种类加载器来相互配合完成的，当然，用户也可以自己定义类加载器，即 &lt;em&gt;User Class Loader&lt;/em&gt;，这几个类加载器的模型如下&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7843137254901961&quot; data-type=&quot;jpeg&quot; data-w=&quot;1377&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmtI4ta2xo6xGOr0kbMvQOcJcibLLYZVxwS0ZOtNtHCJSwaKDhC1eRmgg/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这几类类加载器构成了不同的层次结构，当我们需要加载一个类时，子类加载器并不会马上去加载，而是依次去请求父类加载器加载，一直往上请求到最高类加载器：启动类加载器。当启动类加载器加载不了的时候，依次往下让子类加载器进行加载。这就是双亲委派模型。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;双亲委派模型的缺陷？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在双亲委派模型中，子类加载器可以使用父类加载器已经加载的类，而父类加载器无法使用子类加载器已经加载的。这就导致了双亲委派模型并不能解决所有的类加载器问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 提供了很多外部接口，这些接口统称为 &lt;em&gt;Service Provider Interface, SPI&lt;/em&gt;，允许第三方实现这些接口，而这些接口却是 Java 核心类提供的，由 Bootstrap Class Loader 加载，而一般的扩展接口是由 Application Class Loader 加载的，Bootstrap Class Loader 是无法找到 SPI 的实现类的，因为它只加载 Java 的核心库。它也不能代理给 Application Class Loader，因为它是最顶层的类加载器。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;双亲委派机制的三次破坏&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然双亲委派机制是 Java 强烈推荐给开发者们的类加载器的实现方式，但是并没有强制规定你必须就要这么实现，所以，它一样也存在被破坏的情况，实际上，历史上一共出现三次双亲委派机制被破坏的情况：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;双亲委派机制第一次被破坏发生在双亲委派机制出现之前，由于双亲委派机制 JDK 1.2 之后才引用的，但类加载的概念在 Java 刚出现的时候就有了，所以引用双亲委派机制之前，设计者们必须兼顾开发者们自定义的一些类加载器的代码，所以在 JDK 1.2 之后的 java.lang.ClassLoader 中添加了一个新的 &lt;em&gt;findClass&lt;/em&gt; 方法，引导用户编写类加载器逻辑的时候重写这个 findClass 方法，而不是基于 &lt;em&gt;loadClass&lt;/em&gt;编写。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;双亲委派机制第二次被破坏是由于它自己模型导致的，由于它只能向上（基础）加载，越基础的类越由上层加载器加载，所以如果基础类型又想要调用用户的代码，该怎么办？这也就是我们上面那个问题所说的 SPI 机制。那么 JDK 团队是如何做的呢？它们引用了一个 &lt;strong&gt;线程上下文类加载器(Thread Context ClassLoader)&lt;/strong&gt;，这个类加载器可以通过 java.lang.Thread 类的 &lt;em&gt;setContextClassLoader&lt;/em&gt; 进行设置，如果创建时线程还未设置，它将会从父线程中继承，如果全局没有设置类加载器的话，这个 ClassLoader 就是默认的类加载器。这种行为虽然是一种犯规行为，但是 Java 代码中的 &lt;strong&gt;JNDI、JDBC&lt;/strong&gt; 等都是使用这种方式来完成的。直到 JDK 6 ，引用了 &lt;em&gt;java.util.ServiceLoader&lt;/em&gt;，使用 &lt;strong&gt;META-INF/services&lt;/strong&gt; + 责任链的设计模式，才解决了 SPI 的这种加载机制。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;双亲委派机制第三次被破坏是由于用户对程序的动态需求使热加载、热部署的引入所致。由于时代的变化，我们希望 Java 能像鼠标键盘一样实现热部署，即时加载（load class），引入了 OSGI，OSGI 实现热部署的关键在于它自定义类加载器机制的实现，OSGI 中的每一个 &lt;em&gt;Bundle&lt;/em&gt; 也就是模块都有一个自己的类加载器。当需要更换 Bundle 时，就直接把 Bundle 连同类加载器一起替换掉就能够实现热加载。在 OSGI 环境下，类加载器不再遵从双亲委派机制，而是使用了一种更复杂的加载机制。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;常见的 JVM 调优参数有哪些？&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;-Xms256m：初始化堆大小为 256m；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-Xmx2g：最大内存为 2g；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-Xmn50m：新生代的大小50m；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:+PrintGCDetails 打印 gc 详细信息；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:+HeapDumpOnOutOfMemoryError  在发生OutOfMemoryError错误时，来 dump 出堆快照；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:NewRatio=4    设置年轻的和老年代的内存比例为 1:4；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:SurvivorRatio=8 设置新生代 Eden 和 Survivor 比例为 8:2；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:+UseSerialGC   新生代和老年代都用串行收集器 Serial + Serial Old&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:+UseParNewGC 指定使用 ParNew + Serial Old 垃圾回收器组合；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:+UseParallelGC  新生代使用 Parallel Scavenge，老年代使用 Serial Old&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:+UseParallelOldGC：新生代 ParallelScavenge + 老年代 ParallelOld 组合；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:+UseConcMarkSweepGC：新生代使用 ParNew，老年代使用 CMS；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:NewSize：新生代最小值；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:MaxNewSize：新生代最大值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:MetaspaceSize 元空间初始化大小&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:MaxMetaspaceSize 元空间最大值&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;后记&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章是 JVM 面试题的第二版，新增了很多内容，写的时间也比较长了，如果你觉得文章还不错的话，大家&lt;span&gt;三连&lt;/span&gt;走起！&lt;span&gt;另外，分享到朋友圈是对我莫大的支持，感谢&lt;/span&gt;！不骗你，看完真的需要一小时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651508525&amp;amp;idx=1&amp;amp;sn=7fc6ce143c3a600ea7defa896707d4b2&amp;amp;chksm=bd25a3528a522a448304c6baf7877af993464eb39c839ef30392457677f74fd58b5cdf562b04&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;空降的大厂 CTO，半年内成功把团队带垮了！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;空降的大厂 CTO，半年内成功把团队带垮了！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651508525&amp;amp;idx=2&amp;amp;sn=c11a048bd986b2ac897b74fd9b492c6c&amp;amp;chksm=bd25a3528a522a44118d1065aee8c5cdb2a8299d6b3cf1174ac9a8b1eeaa828dd13c36d3b508&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;如何设计API返回码（错误码）？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;如何设计API返回码（错误码）？&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651508521&amp;amp;idx=2&amp;amp;sn=fd61ee0009a89aff50ab87d60be4b4d8&amp;amp;chksm=bd25a3568a522a40484bf60ef51c01ca8641f91750ebc58f34744677f81199f426471ade4bf6&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;看一遍就理解：零拷贝详解&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;看一遍就理解：零拷贝详解&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关注「ImportNew」，提升Java技能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9166666666666666&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;点赞和在看就是最大的支持&lt;/span&gt;&lt;span&gt;❤️&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d5fbd1e0352f4c6e4f93efa17720d94e</guid>
<title>[推荐] 浅谈缓存最终一致性的解决方案</title>
<link>https://toutiao.io/k/mgym1lv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：clareguo，腾讯 CSIG 后台开发工程师&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;46&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;到底是更新缓存还是删除缓存? 到底是先更新数据库，再删除缓存，还是先删除缓存，再更新数据库?&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1 引言&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于互联网业务来说，传统的直接访问数据库方式，主要通过数据分片、一主多从等方式来扛住读写流量，但随着数据量的积累和流量的激增，仅依赖数据库来承接所有流量，不仅成本高、效率低、而且还伴随着稳定性降低的风险。鉴于大部分业务通常是读多写少（读取频率远远高于更新频率），甚至存在读操作数量高出写操作多个数量级的情况。因此，在架构设计中，常采用增加缓存层来提高系统的响应能力，提升数据读写性能、减少数据库访问压力，从而提升业务的稳定性和访问体验。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据 CAP 原理，分布式系统在可用性、一致性和分区容错性上无法兼得，通常由于分区容错无法避免，所以一致性和可用性难以同时成立。对于缓存系统来说，如何保证其数据一致性是一个在应用缓存的同时不得不解决的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要明确的是，缓存系统的数据一致性通常包括持久化层和缓存层的一致性、以及多级缓存之间的一致性，这里我们仅讨论前者。持久化层和缓存层的一致性问题也通常被称为双写一致性问题，“双写”意为数据既在数据库中保存一份，也在缓存中保存一份。对于一致性来说，包含强一致性和弱一致性，强一致性保证写入后立即可以读取，弱一致性则不保证立即可以读取写入后的值，而是尽可能的保证在经过一定时间后可以读取到，在弱一致性中应用最为广泛的模型则是最终一致性模型，即保证在一定时间之后写入和读取达到一致的状态。对于应用缓存的大部分场景来说，追求的则是最终一致性，少部分对数据一致性要求极高的场景则会追求强一致性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2 保证最终一致性的策略（ Cache Policy ）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了达到最终一致性，针对不同的场景，业界逐步形成了下面这几种应用缓存的策略。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 Cache-Aside&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Cache-Aside 意为旁路缓存模式，是应用最为广泛的一种缓存策略。下面的图示展示了它的读写流程，来看看它是如何保证最终一致性的。在读请求中，首先请求缓存，若缓存命中（ cache hit ），则直接返回缓存中的数据；若缓存未命中（ cache miss ），则查询数据库并将查询结果更新至缓存，然后返回查询出的数据（ demand-filled look-aside ）。在写请求中，先更新数据库，再删除缓存（write-invalidate）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5924050632911393&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaulG1WsztCXujT0qDxALxwEy8knbFcMB7NoiajEYjxo04ww5kmKIOyicbnpbMD0kz3N57EzT4H46xkQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1580&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1.1 为什么删除缓存，而不是更新缓存？&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Cache-Aside 中，对于读请求的处理比较容易理解，但在写请求中，可能会有读者提出疑问，为什么要删除缓存，而不是更新缓存？站在符合直觉的角度来看，更新缓存是一个容易被理解的方案，但站在性能和安全的角度，更新缓存则可能会导致一些不好的后果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先是性能，当该缓存对应的结果需要消耗大量的计算过程才能得到时，比如需要访问多张数据库表并联合计算，那么在写操作中更新缓存的动作将会是一笔不小的开销。同时，当写操作较多时，可能也会存在刚更新的缓存还没有被读取到，又再次被更新的情况（这常被称为缓存扰动），显然，这样的更新是白白消耗机器性能的，会导致缓存利用率不高。而等到读请求未命中缓存时再去更新，也符合懒加载的思路，需要时再进行计算。删除缓存的操作不仅是幂等的，可以在发生异常时重试，而且写-删除和读-更新在语义上更加对称。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其次是安全，在并发场景下，在写请求中更新缓存可能会引发数据的不一致问题。参考下面的图示，若存在两个来自不同线程的写请求，首先来自线程 1 的写请求更新了数据库（ step 1 ），接着来自线程 2 的写请求再次更新了数据库（ step 3 ），但由于网络延迟等原因，线程 1 可能会晚于线程 2 更新缓存（ step 4 晚于 step 3 ），那么这样便会导致最终写入数据库的结果是来自线程 2 的新值，写入缓存的结果是来自线程 1 的旧值，即缓存落后于数据库，此时再有读请求命中缓存（ step 5 ），读取到的便是旧值。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5852130325814536&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaulG1WsztCXujT0qDxALxwErd8vgtqGLMcj2zkhqt4sO4mwic32ZU0wrlRP2reBh4K48X5jEVBooEA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1596&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1.2 为什么先更新数据库，而不是先删除缓存？&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，有读者也会对更新数据库和删除缓存的时序产生疑问，那么为什么不先删除缓存，再更新数据库呢？在单线程下，这种方案看似具有一定合理性，这种合理性体现在删除缓存成功，但更新数据库失败的场景下，尽管缓存被删除了，下次读操作时，仍能将正确的数据写回缓存，相对于 Cache-Aside 中更新数据库成功，删除缓存失败的场景来说，先删除缓存的方案似乎更合理一些。那么，先删除缓存有什么问题呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题仍然出现在并发场景下，首先来自线程 1 的写请求删除了缓存（ step 1 ），接着来自线程 2 的读请求由于缓存的删除导致缓存未命中，根据 Cache-Aside 模式，线程 2 继而查询数据库（ step 2 ），但由于写请求通常慢于读请求，线程 1 更新数据库的操作可能会晚于线程 2 查询数据库后更新缓存的操作（ step 4 晚于 step 3 ），那么这样便会导致最终写入缓存的结果是来自线程 2 中查询到的旧值，而写入数据库的结果是来自线程 1 的新值，即缓存落后于数据库，此时再有读请求命中缓存（ step 5 ），读取到的便是旧值。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3954659949622166&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaulG1WsztCXujT0qDxALxwEgctQjMRGQglE3wyEmDWxGefpPfdZmcsgz1El5qL5icCdroGYcSTrI5Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1588&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，先删除缓存，由于缓存中数据缺失，加剧数据库的请求压力，可能会增大缓存穿透出现的概率。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1.3 如果选择先删除缓存，再更新数据库，那如何解决一致性问题呢？&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了避免“先删除缓存，再更新数据库”这一方案在读写并发时可能带来的缓存脏数据，业界又提出了延时双删的策略，即在更新数据库之后，延迟一段时间再次删除缓存，为了保证第二次删除缓存的时间点在读请求更新缓存之后，这个延迟时间的经验值通常应稍大于业务中读请求的耗时。延迟的实现可以在代码中 &lt;code&gt;sleep&lt;/code&gt; 或采用延迟队列。显而易见的是，无论这个值如何预估，都很难和读请求的完成时间点准确衔接，这也是延时双删被诟病的主要原因。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5082382762991128&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaulG1WsztCXujT0qDxALxwEtpFBnmv9rhKJULmmAIrGjcqnnXSInT1UMTntXVntpZWPuf8Oaicfb4w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1578&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1.4 那么 Cache-Aside 存在数据不一致的可能吗？&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Cache-Aside 中，也存在数据不一致的可能性。在下面的读写并发场景下，首先来自线程 1 的读请求在未命中缓存的情况下查询数据库（ step 1 ），接着来自线程 2 的写请求更新数据库（ step 2 ），但由于一些极端原因，线程 1 中读请求的更新缓存操作晚于线程 2 中写请求的删除缓存的操作（ step 4 晚于 step 3 ），那么这样便会导致最终写入缓存中的是来自线程 1 的旧值，而写入数据库中的是来自线程 2 的新值，即缓存落后于数据库，此时再有读请求命中缓存（ step 5 ），读取到的便是旧值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种场景的出现，不仅需要缓存失效且读写并发执行，而且还需要读请求查询数据库的执行早于写请求更新数据库，同时读请求的执行完成晚于写请求。足以见得，这种不一致场景产生的条件非常严格，在实际的生产中出现的可能性较小。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4068010075566751&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaulG1WsztCXujT0qDxALxwEy1XuQ2xxVFFdNZgibhhSJUnR0sViasGl6xzLgNMcP3wxC1bJJ59CZ0icQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1588&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，在并发环境下，Cache-Aside 中也存在读请求命中缓存的时间点在写请求更新数据库之后，删除缓存之前，这样也会导致读请求查询到的缓存落后于数据库的情况。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.38944723618090454&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaulG1WsztCXujT0qDxALxwEuKSPArRcuQPbIob0MBaBWgKYyrZBZuNUvBR7DYNeNm67EmAbOwsuKA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1592&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然在下一次读请求中，缓存会被更新，但如果业务层面对这种情况的容忍度较低，那么可以采用加锁在写请求中保证“更新数据库&amp;amp;删除缓存”的串行执行为原子性操作（同理也可对读请求中缓存的更新加锁）。加锁势必会导致吞吐量的下降，故采取加锁的方案应该对性能的损耗有所预期。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4292929292929293&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaulG1WsztCXujT0qDxALxwExt0GUt5zySf0MYCib3Wbg3jibkIwvQNicERf8PKC2wFTJfAtLBjiaODpxg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1584&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6914212548015365&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaulG1WsztCXujT0qDxALxwEicojwkV1Uh0nDTWGFTd3ncLQbibB2eZiccTnm4BOjILRvawDvx4qqhsMw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1562&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 补偿机制&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在上面提到了，在 Cache-Aside 中可能存在更新数据库成功，但删除缓存失败的场景，如果发生这种情况，那么便会导致缓存中的数据落后于数据库，产生数据的不一致的问题。其实，不仅 Cache-Aside 存在这样的问题，在延时双删等策略中也存在这样的问题。针对可能出现的删除失败问题，目前业界主要有以下几种补偿机制。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2.1 删除重试机制&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于同步重试删除在性能上会影响吞吐量，所以常通过引入消息队列，将删除失败的缓存对应的 &lt;code&gt;key&lt;/code&gt; 放入消息队列中，在对应的消费者中获取删除失败的 &lt;code&gt;key&lt;/code&gt; ，异步重试删除。这种方法在实现上相对简单，但由于删除失败后的逻辑需要基于业务代码的 trigger 来触发 ，对业务代码具有一定入侵性。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.45132743362831856&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaulG1WsztCXujT0qDxALxwEkNJlDa9w1r2icXT7YGQtpuZq66BIDuFaCe79Whl5gDeOu1EyqEibB03A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1582&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2.2 基于数据库日志（ MySQL binlog ）增量解析、订阅和消费&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;鉴于上述方案对业务代码具有一定入侵性，所以需要一种更加优雅的解决方案，让缓存删除失败的补偿机制运行在背后，尽量少的耦合于业务代码。一个简单的思路是通过后台任务使用更新时间戳或者版本作为对比获取数据库的增量数据更新至缓存中，这种方式在小规模数据的场景可以起到一定作用，但其扩展性、稳定性都有所欠缺。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个相对成熟的方案是基于 MySQL 数据库增量日志进行解析和消费，这里较为流行的是阿里巴巴开源的作为 MySQL binlog 增量获取和解析的组件 canal （类似的开源组件还有 Maxwell、Databus 等）。canal sever 模拟 MySQL slave 的交互协议，伪装为 MySQL slave ，向 MySQL master 发送 dump 协议，MySQL master 收到 dump 请求，开始推送 binary log 给 slave （即 canal sever ），canal sever 解析 binary log 对象（原始为 byte 流），可由 canal client 拉取进行消费，同时 canal server 也默认支持将变更记录投递到 MQ 系统中，主动推送给其他系统进行消费。在 ack 机制的加持下，不管是推送还是拉取，都可以有效的保证数据按照预期被消费。当前版本的 canal 支持的 MQ 有 kafka 或者 RocketMQ 。另外， canal 依赖 zookeeper 作为分布式协调组件来实现 HA ，canal 的 HA 分为两个部分：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;为了减少对 MySQL dump 的请求压力，不同 canal server 上的 instance 要求同一时间只能有一个处于运行状态，其他的 instance 处于 standby 状态；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为了保证有序性，对于一个 instance 在同一时间只能由一个 canal client 进行 get/ack 等动作；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6923076923076923&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaulG1WsztCXujT0qDxALxwEByTHKnOZ2yJDa8ciamnK6GsqkWm8CMcViaPHXdvhtSPV2wunkXcnrP0A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1560&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，针对缓存的删除操作便可以在 canal client 或 consumer 中编写相关业务代码来完成。这样，结合数据库日志增量解析消费的方案以及 Cache-Aside 模型，在读请求中未命中缓存时更新缓存（通常这里会涉及到复杂的业务逻辑），在写请求更新数据库后删除缓存，并基于日志增量解析来补偿数据库更新时可能的缓存删除失败问题，在绝大多数场景下，可以有效的保证缓存的最终一致性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外需要注意的是，还应该隔离事务与缓存，确保数据库入库后再进行缓存的删除操作。比如考虑到数据库的主从架构，主从同步及读从写主的场景下，可能会造成读取到从库的旧数据后便更新了缓存，导致缓存落后于数据库的问题，这就要求对缓存的删除应该确保在数据库操作完成之后。所以，基于 binlog 增量日志进行数据同步的方案，可以通过选择解析从节点的 binlog，来避免主从同步下删除缓存过早的问题。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2.3 数据传输服务 DTS&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据传输服务（ Data Transmission Service，简称 DTS）是云服务商提供的一种支持 RDBMS（关系型数据库）、NoSQL、OLAP 等多种数据源之间进行数据交互的数据流服务。DTS 提供了包括数据迁移、数据订阅、数据同步等在内的多种数据传输能力，常用于不停服数据迁移、数据异地灾备、异地多活(单元化)、跨境数据同步、实时数据仓库、查询报表分流、缓存更新、异步消息通知等多种业务应用场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相对于上述基于 canal 等开源组件自建系统，DTS 的优势体现在对多种数据源的支持、对多种数据传输方式的支持，避免了部署维护的人力成本。目前，各家云服务商的 DTS 服务已 针对云数据库，云缓存等产品进行了适配，解决了 Binlog 日志回收，主备切换等场景下的订阅高可用问题。在大规模的缓存数据一致性场景下，优先推荐使用 DTS 服务。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3 Read-Through&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Read-Through 意为读穿透模式，它的流程和 Cache-Aside 类似，不同点在于 Read-Through 中多了一个访问控制层，读请求只和该访问控制层进行交互，而背后缓存命中与否的逻辑则由访问控制层与数据源进行交互，业务层的实现会更加简洁，并且对于缓存层及持久化层交互的封装程度更高，更易于移植。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7479224376731302&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaulG1WsztCXujT0qDxALxwEMibwZEPeCZE1icibze89CLf9h8aPkgcJ0NUWlvJjd0IcMa6Yib4ziamibic1w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1444&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.4 Write-Through&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Write-Through 意为直写模式，对于 Write-Through 直写模式来说，它也增加了访问控制层来提供更高程度的封装。不同于 Cache-Aside 的是，Write-Through 直写模式在写请求更新数据库之后，并不会删除缓存，而是更新缓存。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.49111675126903553&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaulG1WsztCXujT0qDxALxwEbcBG5HIc4pohTLg9sMgRNDlAR3xPmYHS2HlMbz3Gv57bTeRJsmicKAA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1576&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式的优势在于读请求过程简单，不需要查询数据库更新缓存等操作。但其劣势也非常明显，除了上面我们提到的更新数据库再更新缓存的弊端之外，这种方案还会造成更新效率低，并且两个写操作任何一次写失败都会造成数据不一致。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果要使用这种方案，最好可以将这两个操作作为事务处理，可以同时失败或者同时成功，支持回滚，并且防止并发环境下的不一致。另外，为了防止缓存扰动的频发，也可以给缓存增加 TTL 来缓解。站在可行性的角度，不管是 Write-Through 模式还是 Cache-Aside 模式，理想状况下都可以通过分布式事务保证缓存层数据与持久化层数据的一致性，但在实际项目中，大多都对一致性的要求存在一些宽容度，所以在方案上往往有所折衷。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Write-Through 直写模式适合写操作较多，并且对一致性要求较高的场景，在应用 Write-Through 模式时，也需要通过一定的补偿机制来解决它的问题。首先，在并发环境下，我们前面提到了先更新数据库，再更新缓存会导致缓存和数据库的不一致，那么先更新缓存，再更新数据库呢？这样的操作时序仍然会导致下面这样线程 1 先更新缓存，最后更新数据库的情况，即由于线程 1 和 线程 2 的执行不确定性导致数据库和缓存的不一致。这种由于线程竞争导致的缓存不一致，可以通过分布式锁解决，保证对缓存和数据库的操作仅能由同一个线程完成。对于没有拿到锁的线程，一是通过锁的 &lt;code&gt;timeout&lt;/code&gt; 时间进行控制，二是将请求暂存在消息队列中顺序消费。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.410941475826972&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaulG1WsztCXujT0qDxALxwEB0ibpwSfY0CJJgyibXEVJ6xCKUjvZ72PI39SQWDEUz3bjCYUGrJQhkUg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1572&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在下面这种并发执行场景下，来自线程 1 的写请求更新了数据库，接着来自线程 2 的读请求命中缓存，接着线程 1 才更新缓存，这样便会导致线程 2 读取到的缓存落后于数据库。同理，先更新缓存后更新数据库在写请求和读请求并发时，也会出现类似的问题。面对这种场景，我们也可以加锁解决。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3883984867591425&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaulG1WsztCXujT0qDxALxwEXvn8hXIzibTmpt4R8LEuwMUN0aLDJug0kGtXicPmTgfnNSic7XLbIn5Eg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1586&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另在，在 Write-Through 模式下，不管是先更新缓存还是先更新数据库，都存在更新缓存或者更新数据库失败的情况，上面提到的重试机制和补偿机制在这里也是奏效的。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.5 Write-Behind&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Write behind 意为异步回写模式，它也具有类似 Read-Through/Write-Through 的访问控制层，不同的是，Write behind 在处理写请求时，只更新缓存而不更新数据库，对于数据库的更新，则是通过批量异步更新的方式进行的，批量写入的时间点可以选在数据库负载较低的时间进行。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48984771573604063&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaulG1WsztCXujT0qDxALxwEfl7FaXmIwmgNPoUOwib2tSWykFoZicIpiaxbHPIpLC51VKyFazLkKEaeQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1576&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Write-Behind 模式下，写请求延迟较低，减轻了数据库的压力，具有较好的吞吐性。但数据库和缓存的一致性较弱，比如当更新的数据还未被写入数据库时，直接从数据库中查询数据是落后于缓存的。同时，缓存的负载较大，如果缓存宕机会导致数据丢失，所以需要做好缓存的高可用。显然，Write behind 模式下适合大量写操作的场景，常用于电商秒杀场景中库存的扣减。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.6 Write-Around&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一些非核心业务，对一致性的要求较弱，可以选择在 cache aside 读模式下增加一个缓存过期时间，在写请求中仅仅更新数据库，不做任何删除或更新缓存的操作，这样，缓存仅能通过过期时间失效。这种方案实现简单，但缓存中的数据和数据库数据一致性较差，往往会造成用户的体验较差，应慎重选择。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在解决缓存一致性的过程中，有多种途径可以保证缓存的最终一致性，应该根据场景来设计合适的方案，读多写少的场景下，可以选择采用“ Cache-Aside 结合消费数据库日志做补偿”的方案，写多的场景下，可以选择采用“ Write-Through 结合分布式锁”的方案 ，写多的极端场景下，可以选择采用“ Write-Behind ” 的方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;最近其他好文：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&amp;amp;mid=2649766734&amp;amp;idx=1&amp;amp;sn=b23d539c9daedbf8a6ab8993505e3641&amp;amp;chksm=becca83589bb2123c21a187be11e064ba5e5154ceded1eef0b95d3ba3e4f9e8140adadfff0de&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;最近大火的 NFT 数字藏品是什么？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;最近大火的 NFT 数字藏品是什么？&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&amp;amp;mid=2649766668&amp;amp;idx=1&amp;amp;sn=bc8d55f637fe8b00ce5404cfcfb8b7fc&amp;amp;chksm=becca87789bb216125125fdb6f5d883048a6346937f0c6707ea527df429040b508a759362de9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;2021 腾讯技术十大热门文章&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;2021 腾讯技术十大热门文章&lt;/a&gt;&lt;strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&amp;amp;mid=2649766668&amp;amp;idx=1&amp;amp;sn=bc8d55f637fe8b00ce5404cfcfb8b7fc&amp;amp;chksm=becca87789bb216125125fdb6f5d883048a6346937f0c6707ea527df429040b508a759362de9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;2021 腾讯技术十大热门文章&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;/&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&amp;amp;mid=2649766638&amp;amp;idx=1&amp;amp;sn=031eaf1fdd40222568eb40a9b6a399fb&amp;amp;chksm=becca99589bb2083ae4a361707339fc343bfe2d604c7cbcb6de582e878bc275849e52d0b9f68&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;服务器开发设计之算法宝典&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;服务器开发设计之算法宝典&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;3.72125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvatkTw3ahJGNlXdrVzdl0yxFvsAzUia48cP7KRgP46ZoZHANttHd1ZXKgWia8wm4TdWcNsrib1oSwaiaMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.587962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvatPyBdU42Pibe0fLSj0H232CGFzpFGdr8BenFo7oRWoAaecicibla1KEFW6KPrRStATLSwQ1hGJOUeEg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_live_iframe&quot; data-pluginname=&quot;videosnap&quot; data-headimgurl=&quot;https://wx.qlogo.cn/finderhead/I7awtksbibjQe7RZAy84xESOBAfIZ8xQ9ApXt4uTe8po/0&quot; data-username=&quot;v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder&quot; data-nickname=&quot;腾讯程序员&quot; data-desc=&quot;将在01月12日 19:30 直播&quot; data-intro=&quot;对谈CoDesign程序媛，听听“文艺女青年”的前端旅行&quot; data-noticeid=&quot;finderlivenotice-v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder-1641525666664055-1293066808&quot; data-type=&quot;live&quot;/&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MjM5ODYwMjI2MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasvpPfMrktl2xvC9A325p8Qa9dFeEzxZmZ2O1XuFGsVXyQhG9Dia8J8nTXVtzNcHozr0umH3R4iboXg/0?wx_fmt=png&quot; data-nickname=&quot;腾讯技术工程&quot; data-alias=&quot;Tencent_TEG&quot; data-signature=&quot;腾讯技术官方号。腾讯技术创新、前沿领域发布解读平台。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>