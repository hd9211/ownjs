<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>cfcbb000f0ec1b7047f68bdb3e9557c6</guid>
<title>说透分布式事务</title>
<link>https://toutiao.io/k/kx3ajgy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247483696&amp;amp;idx=1&amp;amp;sn=071cb785dc5f01e53397f3995f88a5d3&amp;amp;chksm=fafdeb9ecd8a628873e20dfd813280e1e3d6bda86907de6772bf8a0a9f7e06250a5073034373&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《分布式事务：从刚性事务到柔性事务》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《分布式事务：从刚性事务到柔性事务》&lt;/a&gt;中，讲过分布式事务。晚上打开微信发现咱们【编程一生】用户群里又讨论起来了。觉得有必要再讲一遍。想加入一起讨论的，可以加我微信&lt;strong&gt;&lt;span&gt; brmayi&lt;/span&gt;&lt;/strong&gt; 注明【入群】。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分布式事务的本质&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;事务起源&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;事务本意就是要处理的事情。计算机中引入了这个词用来表示要处理事情的单元。单元是不可再分的，在数据库中就把这种不可再分给出了明确的特性定义，就是ACID原则。为了和分布式系统中的事务做区分，又叫刚性事务。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;ACID原则&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;原子性&lt;/strong&gt;（Atomicity）&lt;/p&gt;&lt;p&gt;事务必须要么全都执行，要么全都不执行。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;一致性&lt;/strong&gt;（Consistency):&lt;/p&gt;&lt;p&gt;保证数据的完整性。事务必须使数据库从一个一致性状态变换到另外一个一致性状态。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;隔离性&lt;/strong&gt;（Isolation）&lt;/p&gt;&lt;p&gt;一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;持久性&lt;/strong&gt;（Durability）:&lt;br/&gt;一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响,该修改即使出现系统故障也将一直保持。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5796178343949044&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRl9qLxe0sQJapy2UicYLuOMVSMnWqont8opMn4oMOPMf5AYPLHZqQBDEcYWB17qJUfgglP8yGphz3Bg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;471&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;什么事儿都有个程度。人和人之间的认知是不一样的。举个真实的例子：有次我带儿子去参加公司的轰趴。大家在玩三国杀，我不会。我只是象征性的问我儿子会不会。他斩钉截铁的说会。我明知道他的水平还是让他试了试。结果十几个同事和我儿子展开了异常艰难的对决。这个对决让我充分意识到吃饭时我发的200元红包发少了，太对不起大家了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;儿子的会，连我这个不会的人都开出来他分不清敌我。我们同事们高风亮节，让这么一个人在三国沙场上活到了最后。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;回到事务的ACID特性。事务隔离性有四个级别。在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485279&amp;amp;idx=1&amp;amp;sn=49ce5a8c586979388a1828686a6cbd21&amp;amp;chksm=fafdedf1cd8a64e7d95b948cd60135db1618e71c3307d405e9b3c27c5fddedeaf1b1b5f00c4b&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《MySQL常见6个考题在实际工作中的运用》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《MySQL常见6个考题在实际工作中的运用》&lt;/a&gt;中有介绍，这里不赘述。重点讲一致性的三个级别。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;数据一致性三个级别&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;强一致性（Strict Consistency）&lt;/h3&gt;&lt;p&gt;也称为：&lt;strong&gt;原子一致性（Atomic Consistency）&lt;/strong&gt;&lt;strong&gt;线性一致性（Linearizable Consistency）&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;强一致性有两个要求：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;顺序一致性（Sequential Consistency）&lt;/h3&gt;&lt;p&gt;有两个要求：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;弱一致性&lt;/h3&gt;&lt;p&gt;数据更新后，如果能容忍后续的访问只能访问到部分或者全部访问不到，则是弱一致性。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其实每个级别都还可以细分。这里只讲一种和今天主题相关的：最终一致性。它属于弱一致性。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;最终一致性&lt;/h4&gt;&lt;p&gt;不保证在任意时刻任意节点上的同一份数据都是相同的，但是随着时间的迁移，不同节点上的同一份数据总是在向趋同的方向变化。&lt;/p&gt;&lt;p&gt;简单说，就是在一段时间后，节点间的数据会最终达到一致状态。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在数据库事务定义ACID的时候，没有想那么多。其实数据库事务中的一致性是强一致。但是强一致到了分布式系统中就遇到了困难。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;CAP定理&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;CAP定理是由加州大学伯克利分校Eric Brewer教授提出来的，他指出WEB服务无法同时满足下面3个属性：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;一致性(Consistency) ：客户端知道一系列的操作都会同时发生(生效)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;可用性(Availability) ：每个操作都必须以可预期的响应结束&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;分区容错性(Partition tolerance) ：即使出现单个组件无法可用,操作依然可以完成&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8477611940298507&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRl9qLxe0sQJapy2UicYLuOMVSRG7sicAx0ibQf7AMcLdicicH1TD92B7nHI4nCgWcYCgtnITsiakMLe8WFkQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;670&quot;/&gt;&lt;/p&gt;&lt;p&gt;在分布式系统中，一个Web应用至多只能同时支持上面的两个属性。显然，任何横向扩展策略都要依赖于数据分区。因此，设计人员必须在一致性与可用性之间做出选择。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;孔子曾经曰过：没有100分的爱人，只有50分的两个人的共同努力。那聪明的工程师就想了：一个WEB应用至多能支持两个属性达到100分，也就是200分。那我能不能让三个属性都支持到60分。3*60分=180分。200分是上限的话，还可以根据应用自身的需求决定把剩余20分应用到哪方面的提交。这三个60分是什么标准呢？这就是BASE理论。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;BASE理论&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9263322884012539&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRlicrcx7fdx1JicgmHK8H1SSnMJMvDTFl6LfRLny9ZLuZBVOL0o67JFD1m2iae4eXVH3mzcTcbAj6aNDw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;638&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;BASE理论和分布式事务到底有什么关系呢？我搜索了一下，发现没有一篇文章真正把它们的关系说明白。网上的东西给我感觉：它们觉得有关系，又不明白关系到底是啥。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分布式事务与BASE理论的关系&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;既然是事务要遵循的是ACID特性。分布式系统与单机在隔离性和持久性上没有明显的差异。所以重点关注的是原子性和一致性。原子性是说要么全做，要么全都不做，这样数据就是一致的。所以原子性是因，根本要保证的数据一致性。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;所以实际工作中，我很少听到谈论具体问题的时候用分布式事务这个概念，更多的是说数据一致性。我之前写的&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247484990&amp;amp;idx=1&amp;amp;sn=8dc1444160af4be808f8cdbd21e6c28b&amp;amp;chksm=fafdec90cd8a65862023d129a095a286209efefcf699b28351b65128df3aa7e2c2d009ff0aa0&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《数据一致性-对账》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《数据一致性-对账》&lt;/a&gt;这篇文章里提到了好几种分布式事务常用的手段，但是我没有说分布式事务这个词。工作中用这个词，具体解决的问题不明确，不建议用，建议把具体要解决的问题想清楚。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;既然解决的问题是数据一致性问题，web服务不能不考虑可用性，单纯只保证一致性，所以就要考虑BASE理论了。觉得我没讲清楚的扣圆周率小数点后四位。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你真的需要分布式事务吗？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;既然分布式事务根本上解决的是分布式数据一致性问题，在大多数问题上使用seata等框架太重了。咱们平时有很多简单有效的方法一直在用。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;比如支付交易中，有典型的补偿型数据一致性保障：发起一笔支付没有收到响应，可以使用补偿查询作为第一层数据一致性保障；查询半小时还是查不回来，就关单操作，该冲正的冲正(取消交易，已付款退回账户中)，这是第二层数据一致性保障；清结算之前还要对账(做核对校验，对不上人工处理)，这是第三层数据一致性保障。在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247484200&amp;amp;idx=1&amp;amp;sn=4ae0df004f968bb785c15d53270a5800&amp;amp;chksm=fafde986cd8a609057f4d5737ebcfce6b768f263636b9f9faf90bf30164027dd1e1014c7abce&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《程序常用的设计技巧》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《程序常用的设计技巧》&lt;/a&gt;里我也提过其他的补偿性方案。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;看问题还是要从本质问题出发，最好不要引入额外的概念引起歧义。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a038d5438b654cfe9d79eb6e3d3983c4</guid>
<title>使用Gin过程中的一些优化</title>
<link>https://toutiao.io/k/oaxpllk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原文：&lt;span&gt; https://hongker.github.io/2020/04/01/golang-gin/&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文介绍gin的一些知识点,如自定义Response,中间件等。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;gin&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Gin 是一个 go 写的 web 框架，具有高性能的优点。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初级的使用方式不介绍了，具体请查阅官方文档。官方地址：&lt;code&gt;https://github.com/gin-gonic/gin&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下介绍基于gin开发项目的一些常用模块。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;自定义Response&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个公司都会自定义接口的数据结构。故我们需要基于&lt;code&gt;Json()&lt;/code&gt;自定义一个更方便好用的response&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// Response 数据结构体&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Response struct {&lt;br/&gt;    // StatusCode 业务状态码&lt;br/&gt; StatusCode int `json:&lt;span&gt;&quot;status_code&quot;&lt;/span&gt;`&lt;br/&gt;&lt;br/&gt;    // Message 提示信息&lt;br/&gt; Message    string      `json:&lt;span&gt;&quot;message&quot;&lt;/span&gt;`&lt;br/&gt;&lt;br/&gt;    // Data 数据，用interface{}的目的是可以用任意数据&lt;br/&gt; Data       interface{} `json:&lt;span&gt;&quot;data&quot;&lt;/span&gt;`&lt;br/&gt;&lt;br/&gt;    // Meta 源数据,存储如请求ID,分页等信息&lt;br/&gt; Meta       Meta        `json:&lt;span&gt;&quot;meta&quot;&lt;/span&gt;`&lt;br/&gt;&lt;br/&gt;    // Errors 错误提示，如 xx字段不能为空等&lt;br/&gt; Errors     []ErrorItem `json:&lt;span&gt;&quot;errors&quot;&lt;/span&gt;`&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// Meta 元数据&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Meta struct {&lt;br/&gt; RequestId      string                 `json:&lt;span&gt;&quot;request_id&quot;&lt;/span&gt;`&lt;br/&gt; // 还可以集成分页信息等&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;// ErrorItem 错误项&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; ErrorItem struct {&lt;br/&gt; Key   string `json:&lt;span&gt;&quot;key&quot;&lt;/span&gt;`&lt;br/&gt; Value string `json:&lt;span&gt;&quot;error&quot;&lt;/span&gt;`&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// New &lt;span&gt;return&lt;/span&gt; response instance&lt;br/&gt;func New() *Response {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &amp;amp;Response{&lt;br/&gt;  StatusCode: 200,&lt;br/&gt;  Message:    &lt;span&gt;&quot;&quot;&lt;/span&gt;,&lt;br/&gt;  Data:       nil,&lt;br/&gt;  Meta: Meta{&lt;br/&gt;   RequestId: uuid.NewV4().String(),&lt;br/&gt;  },&lt;br/&gt;  Errors: []ErrorItem{},&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;封装gin.Context以自定义一些方便的方法&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// Wrapper include context&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Wrapper struct {&lt;br/&gt; ctx *gin.Context&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// WrapContext&lt;br/&gt;func WrapContext(ctx *gin.Context) *Wrapper {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &amp;amp;Wrapper{ctx:ctx}&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// Json 输出json,支持自定义response结构体&lt;br/&gt;func (wrapper *Wrapper) Json(response *Response) {&lt;br/&gt; wrapper.ctx.JSON(200, response)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// Success 成功的输出&lt;br/&gt;func (wrapper *Wrapper) Success( data interface{}) {&lt;br/&gt; response := New()&lt;br/&gt; response.Data = data&lt;br/&gt; wrapper.Json(response)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// Error 错误输出&lt;br/&gt;func (wrapper *Wrapper) Error( statusCode int, message string) {&lt;br/&gt; response := New()&lt;br/&gt; response.StatusCode = statusCode&lt;br/&gt; response.Message = message&lt;br/&gt; wrapper.Json(response)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt; &lt;span&gt;&quot;github.com/gin-gonic/gin&quot;&lt;/span&gt;&lt;br/&gt; uuid &lt;span&gt;&quot;github.com/satori/go.uuid&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;()  {&lt;br/&gt; router := gin.Default()&lt;br/&gt; router.GET(&lt;span&gt;&quot;/&quot;&lt;/span&gt;, func(ctx *gin.Context) {&lt;br/&gt;  WrapContext(ctx).Success(&lt;span&gt;&quot;hello,world&quot;&lt;/span&gt;)&lt;br/&gt; })&lt;br/&gt;&lt;br/&gt; router.Run(&lt;span&gt;&quot;:8088&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过&lt;code&gt;go run main.go&lt;/code&gt;运行后，浏览器访问&lt;code&gt;localhost:8088&lt;/code&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;中间件&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;介绍一些常用的中间件，如跨域、Jwt校验、请求日志等。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;备注&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引入中间件比如在注册路由之前,谨记!&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;跨域中间件&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package middleware&lt;br/&gt;import (&lt;br/&gt; &lt;span&gt;&quot;github.com/gin-gonic/gin&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;// CORS 跨域中间件&lt;br/&gt;func CORS(ctx *gin.Context) {&lt;br/&gt; method := ctx.Request.Method&lt;br/&gt;&lt;br/&gt; // &lt;span&gt;set&lt;/span&gt; response header&lt;br/&gt; ctx.Header(&lt;span&gt;&quot;Access-Control-Allow-Origin&quot;&lt;/span&gt;, ctx.Request.Header.Get(&lt;span&gt;&quot;Origin&quot;&lt;/span&gt;))&lt;br/&gt; ctx.Header(&lt;span&gt;&quot;Access-Control-Allow-Credentials&quot;&lt;/span&gt;, &lt;span&gt;&quot;true&quot;&lt;/span&gt;)&lt;br/&gt; ctx.Header(&lt;span&gt;&quot;Access-Control-Allow-Headers&quot;&lt;/span&gt;, &lt;span&gt;&quot;Content-Type, Access-Control-Allow-Headers, Authorization, X-Requested-With&quot;&lt;/span&gt;)&lt;br/&gt; ctx.Header(&lt;span&gt;&quot;Access-Control-Allow-Methods&quot;&lt;/span&gt;, &lt;span&gt;&quot;GET,POST,PUT,PATCH,DELETE,OPTIONS&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;    // 默认过滤这两个请求,使用204(No Content)这个特殊的http status code&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; method == &lt;span&gt;&quot;OPTIONS&quot;&lt;/span&gt; || method == &lt;span&gt;&quot;HEAD&quot;&lt;/span&gt; { &lt;br/&gt;  ctx.AbortWithStatus(204)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; ctx.Next()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    router := gin.Default()&lt;br/&gt;    router.Use(CORS)&lt;br/&gt;    router.GET(&lt;span&gt;&quot;/&quot;&lt;/span&gt;, func(ctx *gin.Context) {&lt;br/&gt;     WrapContext(ctx).Success(&lt;span&gt;&quot;hello,world&quot;&lt;/span&gt;)&lt;br/&gt;    })&lt;br/&gt;&lt;br/&gt;    router.Run(&lt;span&gt;&quot;:8088&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Jwt校验&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt; &lt;span&gt;&quot;errors&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;github.com/dgrijalva/jwt-go&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;github.com/gin-gonic/gin&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;strings&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;var (&lt;br/&gt; TokenNotExist       = errors.New(&lt;span&gt;&quot;token not exist&quot;&lt;/span&gt;)&lt;br/&gt; TokenValidateFailed = errors.New(&lt;span&gt;&quot;token validate failed&quot;&lt;/span&gt;)&lt;br/&gt; ClaimsKey = &lt;span&gt;&quot;uniqueClaimsKey&quot;&lt;/span&gt;&lt;br/&gt; SignKey = &lt;span&gt;&quot;test&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;// JwtAuth jwt&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; JwtAuth struct {&lt;br/&gt; SignKey []byte&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// ParseToken parse token&lt;br/&gt;func (jwtAuth JwtAuth) ParseToken(token string) (jwt.Claims, error) {&lt;br/&gt; tokenClaims, err := jwt.Parse(token, func(token *jwt.Token) (interface{}, error) {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; jwtAuth.SignKey, nil&lt;br/&gt; })&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; nil, err&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; tokenClaims.Claims == nil || !tokenClaims.Valid {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; nil, TokenValidateFailed&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; tokenClaims.Claims, nil&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// GenerateToken&lt;br/&gt;func (jwtAuth JwtAuth) GenerateToken(tokenExpireTime int64 /* 过期时间 */, iss string /* key*/) (string, error) {&lt;br/&gt; now := time.Now().Unix()&lt;br/&gt; exp := now + tokenExpireTime&lt;br/&gt; claim := jwt.MapClaims{&lt;br/&gt;  &lt;span&gt;&quot;iss&quot;&lt;/span&gt;: iss,&lt;br/&gt;  &lt;span&gt;&quot;iat&quot;&lt;/span&gt;: now,&lt;br/&gt;  &lt;span&gt;&quot;exp&quot;&lt;/span&gt;: exp,&lt;br/&gt; }&lt;br/&gt; token := jwt.NewWithClaims(jwt.SigningMethodHS256, claim)&lt;br/&gt; tokenStr, err := token.SignedString(jwtAuth.SignKey)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; tokenStr, err&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// JWT gin的jwt中间件&lt;br/&gt;func JWT(ctx *gin.Context) {&lt;br/&gt; // 解析token&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err := validateToken(ctx); err != nil {&lt;br/&gt;  WrapContext(ctx).Error(401, err.Error())&lt;br/&gt;  ctx.Abort()&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; ctx.Next()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// validateToken 验证token&lt;br/&gt;func validateToken(ctx *gin.Context) error {&lt;br/&gt; // 获取token&lt;br/&gt; tokenStr := ctx.GetHeader(&lt;span&gt;&quot;Authorization&quot;&lt;/span&gt;)&lt;br/&gt; kv := strings.Split(tokenStr, &lt;span&gt;&quot; &quot;&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; len(kv) != 2 || kv[0] != &lt;span&gt;&quot;Bearer&quot;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; TokenNotExist&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; jwtAuth := &amp;amp;JwtAuth{SignKey: []byte(SignKey)}&lt;br/&gt; claims, err := jwtAuth.ParseToken(kv[1])&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; // token存入context&lt;br/&gt; ctx.Set(ClaimsKey, claims)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; nil&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;()  {&lt;br/&gt; router := gin.Default()&lt;br/&gt; router.GET(&lt;span&gt;&quot;/&quot;&lt;/span&gt;, func(ctx *gin.Context) {&lt;br/&gt;  WrapContext(ctx).Success(&lt;span&gt;&quot;hello,world&quot;&lt;/span&gt;)&lt;br/&gt; })&lt;br/&gt;&lt;br/&gt;    // 指定user这组路由都需要校验jwt&lt;br/&gt; user := router.Group(&lt;span&gt;&quot;/user&quot;&lt;/span&gt;).Use(JWT)&lt;br/&gt; {&lt;br/&gt;  user.GET(&lt;span&gt;&quot;/info&quot;&lt;/span&gt;, func(ctx *gin.Context) {&lt;br/&gt;   claims, exist := ctx.Get(ClaimsKey)&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; !exist {&lt;br/&gt;    WrapContext(ctx).Error(1001, &lt;span&gt;&quot;获取用户信息失败&quot;&lt;/span&gt;)&lt;br/&gt;   }&lt;br/&gt;   WrapContext(ctx).Success(claims)&lt;br/&gt;  })&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt; router.Run(&lt;span&gt;&quot;:8088&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请求测试：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;curl  &lt;span&gt;&quot;localhost:8088/user/info&quot;&lt;/span&gt;&lt;br/&gt;// 输出:&lt;br/&gt;// {&lt;span&gt;&quot;status_code&quot;&lt;/span&gt;:401,&lt;span&gt;&quot;message&quot;&lt;/span&gt;:&lt;span&gt;&quot;token not exist&quot;&lt;/span&gt;,&lt;span&gt;&quot;data&quot;&lt;/span&gt;:null,&lt;span&gt;&quot;meta&quot;&lt;/span&gt;:{&lt;span&gt;&quot;request_id&quot;&lt;/span&gt;:&lt;span&gt;&quot;e69361cf-1fd4-42e4-8af8-d18fac1e70fb&quot;&lt;/span&gt;},&lt;span&gt;&quot;errors&quot;&lt;/span&gt;:[]}&lt;br/&gt;&lt;br/&gt;// 通过GenerateToken()生成一个token&lt;br/&gt;curl -H &lt;span&gt;&quot;Authorization:Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1ODU4MjQ2NzgsImlhdCI6MTU4NTgyMTA3OCwiaXNzIjoiYWEifQ.Eyo8KptVUgGfnRG8zsjDilAJOBmaXMtjqJxw__a32HY&quot;&lt;/span&gt;  localhost:8088/user/info&lt;br/&gt;// 输出：&lt;br/&gt;{&lt;span&gt;&quot;status_code&quot;&lt;/span&gt;:200,&lt;span&gt;&quot;message&quot;&lt;/span&gt;:&lt;span&gt;&quot;&quot;&lt;/span&gt;,&lt;span&gt;&quot;data&quot;&lt;/span&gt;:{&lt;span&gt;&quot;exp&quot;&lt;/span&gt;:1585824678,&lt;span&gt;&quot;iat&quot;&lt;/span&gt;:1585821078,&lt;span&gt;&quot;iss&quot;&lt;/span&gt;:&lt;span&gt;&quot;aa&quot;&lt;/span&gt;},&lt;span&gt;&quot;meta&quot;&lt;/span&gt;:{&lt;span&gt;&quot;request_id&quot;&lt;/span&gt;:&lt;span&gt;&quot;464743de-1033-4656-96f8-36c1529f13e0&quot;&lt;/span&gt;},&lt;span&gt;&quot;errors&quot;&lt;/span&gt;:[]}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;请求日志&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;记录每个请求的重要信息&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;import (&lt;br/&gt; &lt;span&gt;&quot;bytes&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;github.com/gin-gonic/gin&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;io/ioutil&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;net/http&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;// bodyLogWriter 定义一个存储响应内容的结构体&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; bodyLogWriter struct {&lt;br/&gt; gin.ResponseWriter&lt;br/&gt; body *bytes.Buffer&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// Write 读取响应数据&lt;br/&gt;func (w bodyLogWriter) Write(b []byte) (int, error) {&lt;br/&gt; w.body.Write(b)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; w.ResponseWriter.Write(b)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// RequestLog gin的请求日志中间件&lt;br/&gt;func RequestLog(c *gin.Context) {&lt;br/&gt; // 记录请求开始时间&lt;br/&gt; t := time.Now()&lt;br/&gt; blw := &amp;amp;bodyLogWriter{body: bytes.NewBufferString(&lt;span&gt;&quot;&quot;&lt;/span&gt;), ResponseWriter: c.Writer}&lt;br/&gt; // 必须!&lt;br/&gt; c.Writer = blw&lt;br/&gt;&lt;br/&gt; // 获取请求信息&lt;br/&gt; requestBody := getRequestBody(c)&lt;br/&gt;&lt;br/&gt; c.Next()&lt;br/&gt;&lt;br/&gt; // 记录请求所用时间&lt;br/&gt; latency := time.Since(t)&lt;br/&gt;&lt;br/&gt; // 获取响应内容&lt;br/&gt; responseBody := blw.body.String()&lt;br/&gt;&lt;br/&gt; logContext := make(map[string]interface{})&lt;br/&gt; // 日志格式&lt;br/&gt; logContext[&lt;span&gt;&quot;request_uri&quot;&lt;/span&gt;] = c.Request.RequestURI&lt;br/&gt; logContext[&lt;span&gt;&quot;request_method&quot;&lt;/span&gt;] = c.Request.Method&lt;br/&gt; logContext[&lt;span&gt;&quot;refer_service_name&quot;&lt;/span&gt;] = c.Request.Referer()&lt;br/&gt; logContext[&lt;span&gt;&quot;refer_request_host&quot;&lt;/span&gt;] = c.ClientIP()&lt;br/&gt; logContext[&lt;span&gt;&quot;request_body&quot;&lt;/span&gt;] = requestBody&lt;br/&gt; logContext[&lt;span&gt;&quot;request_time&quot;&lt;/span&gt;] = t.String()&lt;br/&gt; logContext[&lt;span&gt;&quot;response_body&quot;&lt;/span&gt;] = responseBody&lt;br/&gt; logContext[&lt;span&gt;&quot;time_used&quot;&lt;/span&gt;] = fmt.Sprintf(&lt;span&gt;&quot;%v&quot;&lt;/span&gt;, latency)&lt;br/&gt; logContext[&lt;span&gt;&quot;header&quot;&lt;/span&gt;] = c.Request.Header&lt;br/&gt;&lt;br/&gt; log.Println(logContext)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// getRequestBody 获取请求参数&lt;br/&gt;func getRequestBody(c *gin.Context) interface{} {&lt;br/&gt; switch c.Request.Method {&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; http.MethodGet:&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; c.Request.URL.Query()&lt;br/&gt;&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; http.MethodPost:&lt;br/&gt;  fallthrough&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; http.MethodPut:&lt;br/&gt;  fallthrough&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; http.MethodPatch:&lt;br/&gt;  var bodyBytes []byte // 我们需要的body内容&lt;br/&gt;        // 可以用buffer代替ioutil.ReadAll提高性能&lt;br/&gt;  bodyBytes, err := ioutil.ReadAll(c.Request.Body)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; nil&lt;br/&gt;        }&lt;br/&gt;        // 将数据还回去&lt;br/&gt;  c.Request.Body = ioutil.NopCloser(bytes.NewBuffer(bodyBytes))&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; string(bodyBytes)&lt;br/&gt;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; nil&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;router.Use(ReqeustLog)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天就到这儿吧，还有一些比如全局ID中间件，后面来写。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4cd4e1d087a21f44ae30e0a6639ffb52</guid>
<title>开源｜开发者不需要写一行代码，就可以拥有 10 倍生产力！</title>
<link>https://toutiao.io/k/fiqzd4b</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;以下内容选自「码农周刊 VIP 会员」圈子，每日更新，精彩不断。&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Yao 是一个只需使用 JSON 即可创建数据库模型、编写 API 接口、描述管理后台界面的低代码引擎，使用 Yao 构建的应用可运行在云端或物联网设备上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;开发者不需要写一行代码，就可以拥有 10 倍生产力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;1543&quot; data-ratio=&quot;2.096&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/t8lpVibticjQ55uGfMzdlicPXULuWVFIIVlTgsUVGTMD24Ldo6Zq3Zd6oNl0icraCApH2r9UtZxTcBMNCGAlYksy1w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>768903756e8bc3eee6322d34e9c4b053</guid>
<title>深入解读SQL优化中的执行计划</title>
<link>https://toutiao.io/k/dgc70dw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;数据库的执行计划是SQL优化的最重要手段，执行计划怎么来的、包含什么内容、我们应该关注哪些点，这些是需要我们掌握的，基于这些知识再去理解SQL优化将更加容易。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文由腾讯云数据库高级架构师何敏带来TDSQL PostgreSQL执行计划详解，以下为分享实录：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;在了解PostgreSQL执行计划之前，需要先知道执行计划由来。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;TDSQL PostgreSQL版任何查询都会经过语法和语义解析，生成查询表达式树，也就是常用查询数，解析器会去解析语法，分析器会把语法对应对象进行展开，通过重写器对规则进行重写，最后生成查询数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5634390651085142&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/XS2esJew19aHaS87SzZrPVkeevKicdibsrz70XCAMsECQzm3yVvADQDykXRGoELDohgo8aqicD1qvgRPmcib2aPBPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1198&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据查询树执行器经过查询再进行预处理，找出最小代价路径，最终创建出计划树。再把查询计划交由执行器进行执行。最终执行完成会把结果返回给前端应用。这些操作都是在每个连接对应Backend进程去进行处理。执行器在执行时，会去访问共享内存，内存没有数据，则从磁盘读取。最终将查询的结果缓存在数据库中，逐步输出给用户进程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;进程会涉及到例如Work memory、temp buffer等进程级内存，可以通过我们的Explain命令来查看执行计划，对不合理的资源进行调整，提高SQL执行效率。在SQL前面加上Explain，就可以直接看到执行计划。不管是在pgadmin还是其它工具都可以简单进行查看。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;我们的执行计划有几个特点：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;首先查询规划是以规划为节点的树形结构，以查询的一些路径作为树形结构，树最底层节点是扫描节点，去扫描表中原始行数。不同表也有不同扫描类型，比如顺序扫描或索引扫描、位图索引扫描。也有非表列源，比如说Values子句。还有查询，可能需要关联、聚合、排序以便操作，同时也会在扫描节点上增加节点进行操作提示以及消耗。Expain输出总是以每个树节点显示一行，内容是基本节点类型和执行节点的消耗评估。可能会出现同级别节点，从汇总行节点缩进显示其它属性。第一行一般都是我们汇总的消耗，这个值是越小越好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5618729096989966&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/XS2esJew19aHaS87SzZrPVkeevKicdibsrDJYicbbUt2gGoYqzMFCiaNX6qtKicv75yrFe2icFSkXr79HQj8KfVJ1I9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1196&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在看一个执行计划，我们创建一个测试表，插入1万条数据做分析后，可以看到它的执行计划，这个执行计划很简单，全面扫描它只有一行。执行计划我们从左到右去看，先是评估开始的消耗，这里因为没有别的步骤，所以这个步骤是从0开始，然后是一个总消耗评估。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Rows是输出的行数，它是一个评估结果；然后是每一行的平均字节数，这是一个评估结果，这个评估结果依赖于pg_stats和pg_statistic统计信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么我们怎么去看执行计划呢？就是上级节点的消耗，其中包含了其子节点的消耗，这个消耗值反映在规划器评估这个操作需要的代价。一般这个消耗不包括将数据传输到客户端，只是在数据库后台的执行代价。评估的行数不是执行和扫描节点查询的节点数量，而是返回的数量。同时消耗它不是一个秒的，它是我们规划器的一个参数。Cost是描述一个执行计划代价是多少，而不是具体时间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;代价评估的一些基准值一般会关注哪几个参数？&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;seq_page_cost，即扫描一个块需要的消耗，我们默认为是1，而随机扫描random_page我们默认为是4，这个在优化的环节需要进行优化，比如说现在使用SSD，随机页的访问效率肯定比其它的磁盘更快，而这里值就可以改为1。另外就是cpu_tuple_cost，我们CPU去扫描一个块里具体行数，一行大概0.01的消耗。索引是cpu_index_tuple_cost，0.005的消耗。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5654712260216848&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/XS2esJew19aHaS87SzZrPVkeevKicdibsrZxU1toHd4Vg7IqFUYh1VLZvtTib4gDOjrvUge1Ticia443xsDhxYAic6mw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1199&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;举个例子，新建Test表有一万行，它分配了94个页。而根据刚刚执行计划可以大概估算消耗：磁盘页乘顺序扫描的Cost，加上扫描行数。这个值就是94个页乘以1，加上1万行乘以0.01的消耗就是194。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;那什么时候去更新pg_class以及pg_stat_user_tables的统计信息？&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;它分为两个部分，一部分主要还是通过analyze以及部分DDL语句去触发更新统计信息。所以执行计划准确与否和统计信息也很有关联。这里加上条件，比如说Where Id小于1000，会去增加一个筛选条件。这样扫描的同时它会去增加损耗，比如扫描的行数不变，但是增加了CPU的计算比较时间，就变为219。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;执行计划最底层是表的扫描，而扫描又分为两种方式，全表扫描以及索引扫描。全表扫描顾名思义去整个表上扫描。就算是有些表加了索引，它也不一定会走索引扫描，如果说满足条件的数据集比较大，索引扫描代价比全表扫描更大，它就会走全表扫描。如前面所说，扫描全表，这个时候重新扫描，会先走索引，再走对应的块，这个代价会比走全表扫描更慢。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另一个问题是索引扫描Index Scan。在上面的测试表对查询列建一个索引，举例查询条件是小于1000这个值，cost减少还不够直观，如果条件是小于10之类小数据量查询，索引效果更好，直接走Index Scan。但如果查询条件筛选率不够高，查询会先走索引扫描，再重新扫描行，扫描后他会去判断每一个行的条件，Cost可能相应就变更高。在优化的时候，尤其要去关注这一点，一定要关注索引的筛选率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5607321131447587&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/XS2esJew19aHaS87SzZrPVkeevKicdibsr3WXzrtMlkrfPF7JmOibP8Pm2ePETnHUbDLu1giaTW1mMwBiaCPYib6dOxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1202&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;索引扫描里还有一个Index Only Scan，也就是投影列、查询条件都在索引里面，它就会走一个Index Only Scan，不会再去读其它具体的行值，扫描完索引之后就返回，效率非常高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;还有一种扫描方式是位图扫描，在PG里没有位图索引，但是它是有位图扫描的，一般是在on、and或in子句里面去走。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;举个例子，上面查询ID小于1000，同时ID要大于9000，这时候它会先做两次索引扫描。扫描时它不会去读具体数据，会先去做一个Bitmap Scan，之后我们的条件是Or，会先做一个聚集后再去做Check，看一下具体实现方式。它是先去启动时间两个Bitmap Scan总和，因为是具体扫描会有扫描时间，所以这个组合会花费大量时间。同时Index Scan输出的是Tuple，先扫描索引块，得到对应ctid再去扫描具体数据。如果一次只读一条索引项然后去判断行是否满足条件，一个PAGE可以多次访问。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5569409808811305&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/XS2esJew19aHaS87SzZrPVkeevKicdibsrzxlibJsBnXibibkzvyThibAfXiczicjvrqQdlFBo1kx0Qh5xpRl26e4p7e4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1203&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而&lt;/span&gt;&lt;span&gt;Bitmap Scan会去输出所有&lt;/span&gt;&lt;span&gt;满足条件的索引项&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;然后&lt;/span&gt;&lt;span&gt;组合&lt;/span&gt;&lt;span&gt;到一起做or等操作&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;最后才&lt;/span&gt;&lt;span&gt;交给上一个节点Bitmap Heap Scan去扫描具体数据，&lt;/span&gt;&lt;span&gt;由于&lt;/span&gt;&lt;span&gt;会先去根据索引扫描的物理数据进行排序，一次性将&lt;/span&gt;&lt;span&gt;块中&lt;/span&gt;&lt;span&gt;满足条件索引项数据取出来。&lt;/span&gt;&lt;span&gt;这样可以说一个块，一次扫描就扫描完了，可以想象这个效率是非常高的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在底层的数据扫描完之后会去做表连接。连接方式一般在两表关联的时候才有连接可能。一般简单说自然选择、左连接、右连接等等。但具体的到数据库的执行计划里一般主要有hash join、nested loop、merge join。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Hash Join，它是以Hash方式来进行表连接，首先它确定是两个表里的大小，使用小表去建立Hash map，去扫描大表比较Hash值获取最终查询结果。我们示例中建立另外一张表Test1，并建一个索引进行两张表关联查询，当他们的T1的ID小于10，它Info相等，做一个关联查询。首先开始的时候，因为两个表大小一样，一张有索引，一张没有，会优先选择有索引的表去做一个Hash桶，另外一张表进行一个循环比较Hash值。如果说变一下条件把Test1表删除一部分数据，优化器会以Test1去做一个Hash表，Test表在上面去做驱动。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5630743525480367&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/XS2esJew19aHaS87SzZrPVkeevKicdibsrtltMgV0GI91Qns4vmqPDZ1RCHVPZUicQMn8BZeq8BZCnJicU5YTVPeXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1197&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;做一个简单梳理。&lt;strong&gt;Hash连接是在做大数据连接时非常有用的方式，就是在两个大表进行join。&lt;/strong&gt;那么这里也是为什么PG在和MySQL比的时候，说它的分析能力要强一点的原因，因为我们的Hash join支持非常好。另外现在MySQL已经支持Hash了，但是还不是那么完善。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Hash它有个问题，如果Hash的小表也比较大，Hash表的结果非常大，你的内存放不下，这时就可能会写到你的磁盘中去，就会导致性能急剧下降。在这个时候就要提高work_mem。hash join的时间消耗是什么？我们的外层Cost请求，加上内层一个请求就可以了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;另外一个连接方式就是Nested Loop循环扫描&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，在这个扫描上写了两个循环去扫描。一般在优化的时候，特别是用PG数据库，要去重点看Nested Loop是不是合理。那么什么时候用Nested Loop呢？就是小表和大表进行关联的时候，小表作为驱动表，那大表作为下面的内层表会比较合理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先它会确定一个驱动表，另外是一个内层的表，驱动表每一行与它里面那张表进行一个查询，一个嵌套循环查询比较，代价非常高。就比如每次都是外层的表，乘以外面的条件消耗，这一看就比较大了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;像这种情况，每次扫描时，外层的表每次在驱动时它会去扫描层内层的表，这样效率非常低。而如果内层的表它结果集是相对固定的，那么就可以扫描一次把它做一个物化，下次再循环比较的时就不用再去查询里面的表，类似于Hash join。Hash join是做什么的呢？它前面也是一个Loop，只是把内存的表建立一个Hash表，这样去扫描就会快很多。Materialize就是这么一个优化的方向，这个也依赖于我们的work_mem。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;最后一种连接方式叫Merge join，主要针对于数据量不是特别大的情况下，而且两个表如果结构相似，做好排序，这时反而会比散列连接会好一点&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;示例中原来是走了一个Nested Loop，我们把索引删除，它就去走了Merge join。一般对于这种数值比较效率还可以，因为排序数值效率是高一点。如果是字符串一类，走Merge join效率会更低。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5614035087719298&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/XS2esJew19aHaS87SzZrPVkeevKicdibsrS1KQKNFpBwgZIr8dHwcnibDTDc2tC6iamjboAdibMA6YWSGDNOBHRobKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1197&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看一下具体的实现，它是先将两个表进行一个排序。Id 1等于1先比较完后，再去比较Id等于2时，就不会再去比较Id1等于1的位置块，会直接从另外一张表的2开始去比较。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;做一个简单比较，Hash join是将一个小表做为一个内存表做Hash运算，将列数据根据hash值放到Hash行列表中，再从另外一张表去抽取记录做Hash运算找到匹配的值，一般是小表做Hash表。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Nested Loop是一张表读取数据，访问另外一张表做匹配。Nested Loop在关联表比较小的时候效率最高。小表做驱动，比如这个表只有百来行，而大表很大，循环100次查询，大表会进行索引扫描，相对会快很多。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Merge join如果数据做好了排序，而且是数字类型排序，Merge join可能反而比Hash要快。但一般来说如果数据量比较大，Hash基本会比Merge join更快。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外是关联相关参数一般以Enable开头。刚刚那几种连接Nested Loop、Merge join、Hash join、Bitmap Scan都是可以去控制的，参数可以是session级别控制。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.56&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/XS2esJew19aHaS87SzZrPVkeevKicdibsrwAszib2NsdHagRW7hlnl4s8ZSe7LTogLPia7YXib9TYyXurBTP8C7vEkQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1200&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;查看执行计划首先是看扫描方式和连接方式，不论再怎么复杂，都是通过这两个进行组合。一般是看它在扫描和关联是不是合理的。这两个判断之后，再去看它的条件是不是合理，或需不需要改写。有了执行计划之外，在看具体执行时间，就要加上Explain Analyze来看具体执行时间。这里有一个不一样的点，在这里有了一个实际执行时间，这个时间是真实时间。可以很精确知道每一步花费时间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在Analyze之外，还有一些其它参数，可以通过\H Explain的方式去查看详细的语法，有verbos显示具体执行日志，还有Cost消耗、Settings显示特殊设置，buffers内存的一些分配情况。wal、Timing时间，Summary，format输出的格式TXT或者xml、json。如果加上，它的显示信息会多很多。主要是buffers比较有用，显示说你申请了多少，现在多少磁盘块是要命中，多少是进行读取的。在第二次查询的时候，它的磁盘读取会变少，第一次读取是94块，第二次50块块。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了上述内容，还有一个日志参数。我们的log_planner_stats可以输出你的执行计划到日志文件中，Oracle的执行计划是从表里去看，而我们PG是没有的。那么怎么办？可以通过一些参数去控制，导到日志里来。就目前这个日志它是输入到运行日志里的，没有单独去进行记录。当然这个也是我们优化的一个方向。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过设置这些参数，把这里日志打印出来，显示出执行计划，语法分析、语义分析、重写，这几个阶段它会显示出来。如果开启了执行计划状态，会把这些进行打印。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5584307178631052&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/XS2esJew19aHaS87SzZrPVkeevKicdibsrmNMYXDhYm2n93KRTLeTTtDIhfV75Xk0wu7B4aiaHrKB06ibss7U9iaDfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1198&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;最后看执行计划之外，从执行计划去反推SQL优化方向。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;从最底层一个扫描去入手，要尽量走索引扫描。另外索引扫描这里有很多方式，就是看它是否是合理索引，要看类型是不是选择合理的。比如数字类型、字符串类型，我们选用gin索引，还是一些btree索引。PG默认是btree索引，但btree索引不是所有类型和操作符都会适用。另外还需要减少不必要的索引、避免单条SQL插入，要单条变为批量进行插入。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;前面说执行计划表连接类型是不是正确合理，另外要从SQL本身进行入手，我们目的是为了减少它的消耗。如果SQL语句比较复杂，而扫描类型已经无法改动，那这时只能去改写SQL语句，尽量减少嵌套，减少子查询。还可以通过物化视图临时表，去做SQL拆分。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5608333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/XS2esJew19aHaS87SzZrPVkeevKicdibsrGx8USXCRpp026H7VBuAibCLIQcUDib4rtsk0gIqt9r2c0b7jmrkELY3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1200&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;尽量把in语法用Exits方式做连接。另外还要注意一些类型的转换失真，在扫描时，如果它可以走索引扫描，结果走了全面扫描，可能是转换失真了，比如说一个in类型，结果输入是一个字符串类型，它有可能会转换失败，只能走全面扫描，不能索引。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外从数据库参数来入手，就需要精确的统计信息，我们在生成执行计划时，可能autovacuum没有去执行，也可能统计信息落后，那么执行计划就是错误的。这时候就要对应表作为一个analyze。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后就是干涉执行计划，&lt;strong&gt;干涉执行计划有两种方式&lt;/strong&gt;，除了前面的enable几个参数，我们的pg_hint_plan插件也可以做一些Hint控制。还有一些新参数调整，例如调整work_mem、temp_buffers、shared_buffers等参数。还有一些连接池的使用，我们操作系统参数、硬件的性能参数调整等等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实往往数据库优化，除了这些以外，还有我们去看操作系统的一些硬件性能，比如CPU是不是Performance模式，磁盘调度方式是不是最优的，网卡Bond模式等其他参数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools-id=&quot;84317&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;往期精选&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3NzcwNjM0OA==&amp;amp;mid=2247509450&amp;amp;idx=1&amp;amp;sn=5d9e437bb132f2d4840954e2ff18af1e&amp;amp;chksm=9f4f00c9a83889dfacefef7c719490fcdc4225344bfdec6772d7fc3e8c94600b65c22f190232&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;从两个小例子看我们的差距&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;从两个小例子看我们的差距&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3NzcwNjM0OA==&amp;amp;mid=2247509448&amp;amp;idx=1&amp;amp;sn=b5d088500fa477d145269008351a46a4&amp;amp;chksm=9f4f00cba83889dddbb8a6bc7af5e834c95b4b4d0ca648fa1255fe47944569b1c579d2d1b822&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Linux 性能优化的全景指南，可能都在这里了，建议收藏~&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Linux 性能优化的全景指南，可能都在这里了，建议收藏~&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3NzcwNjM0OA==&amp;amp;mid=2247509437&amp;amp;idx=1&amp;amp;sn=24c75c92cf24410a45b77a5ed94e6175&amp;amp;chksm=9f4f00bea83889a87c24cb13aeb8fb2452286003f9aa06c6d88c3849f9ae0bdbbe5346c67533&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;不忘初心，再起航！ 专访Apache RocketMQ创始人&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;不忘初心，再起航！专访Apache RocketMQ创始人&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3NzcwNjM0OA==&amp;amp;mid=2247509435&amp;amp;idx=1&amp;amp;sn=58eb3576088362d415e647704a1bc70c&amp;amp;chksm=9f4f00b8a83889ae1d63cc296bf160b744236e4031e2a68976b99353ae8ae85b077f690f6b61&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;欧盟《数据法案》草案全文公布！看看都有什么亮点&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;欧盟《数据法案》草案全文公布！看看都有什么亮点&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3NzcwNjM0OA==&amp;amp;mid=2247509428&amp;amp;idx=1&amp;amp;sn=c6312281a1ebf055984a4eacbed4c42d&amp;amp;chksm=9f4f00b7a83889a1cd576c40400b51eda8cde98d0fbc760d3cfd848d290a7400279227f5fcfb&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;上点硬菜：聊聊PG数据库的故障修复&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;上点硬菜：聊聊PG数据库的故障修复&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3NzcwNjM0OA==&amp;amp;mid=2247509426&amp;amp;idx=1&amp;amp;sn=e2e17291e35c9d55d1889c4c91ff58d8&amp;amp;chksm=9f4f00b1a83889a773cb35435b5d619fa64a6e5af53e25e1a3bd07f6dffaf39004ad0d8ce282&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;2022年的五个大数据发展趋势&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;2022年的五个大数据发展趋势&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3NzcwNjM0OA==&amp;amp;mid=2247509393&amp;amp;idx=1&amp;amp;sn=12133215b9527ebe21b15b91ba5bcd6a&amp;amp;chksm=9f4f0092a83889840f9b8895dcbe92f8ed11de0a1fed264dcf5a4011ea16a8d7906184a28dc6&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;修 Bug 哪家强？谷歌：Linux，比我都修得好&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;修 Bug 哪家强？谷歌：Linux，比我都修得好&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3NzcwNjM0OA==&amp;amp;mid=2247509378&amp;amp;idx=1&amp;amp;sn=8604c1f17075c48a94235b63661051ad&amp;amp;chksm=9f4f0081a8388997c7ee95f4a6f5340b93f9b8f729b3ef8e6c521e25c7b5166d006995fa719c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;解决了Redis大key问题，同事们都夸他牛皮&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;解决了Redis大key问题，同事们都夸他牛皮&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3NzcwNjM0OA==&amp;amp;mid=2247509373&amp;amp;idx=1&amp;amp;sn=61f1cf59c3277f92c44fabd27ab5d99f&amp;amp;chksm=9f4f007ea8388968e594c1273da962e8a3c958ab30990a1cd916d578cece3f30a0450567d040&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;深入理解Linux端口重用这一特性&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;深入理解Linux端口重用这一特性&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>77b15b2b7fe3a0de0b85f92d7f1f1bfa</guid>
<title>用魔法打败魔法？！俄罗斯解封盗版资源站RuTracker</title>
<link>https://toutiao.io/k/h3ebcl5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;325&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavicYlFLayaPy2jzTib9vGTLrA52jHHKhiahodt7xt7c1icOATWRXXVGQk6ZPLDicKJOSsTQEvVxOVNIfCw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;来源&lt;/strong&gt;：雷锋网&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;头条菌微信号：&lt;/span&gt;&lt;span&gt;toutiaoio007&lt;/span&gt;&lt;span&gt; ，欢迎加我，交个朋友！&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3 月 7 日消息，据俄罗斯媒体报道，俄罗斯曾经最大的资源站 RuTracker.org 已于近日解锁，该网站曾在 2015 年被俄罗斯通信监管机构 Roskomnadzor 永封。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;受到俄乌局势影响，微软、Adobe、Oracle 、英伟达、苹果等软件商纷纷宣布不再支持俄罗斯，不少游戏厂商、音乐和电影流媒体也终止了俄罗斯的服务。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随后俄罗斯当局取消了对盗版网站
 RuTracker.org 的封锁，&lt;strong&gt;用户可以在其中下载破解的 Windows、Microsoft Office、AutoCAD 
等软件&lt;/strong&gt;，还有好莱坞电影、电视节目。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Rutracker注册用户高达1300万，得益于俄罗斯强大的民间黑客团体，Rutracker上也有着大量的盗版和破解资源分享，从专业软件到游戏，从电影到无损音乐，甚至连没有发布的内部音乐CD资源都有。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另据报道，俄罗斯经济发展部草拟的一份文件列出了克林姆林宫正在考虑的一些措施，这份文件题为《在外部制裁压力条件下确保俄罗斯经济发展的优先行动计划》。这份文件的第
 6.7.3 
点所列项目试图解决外国公司撤销或拒绝颁发软件许可证的问题。&lt;br/&gt;根据俄罗斯现行法律，未经许可的软件是非法的，但如果实施上述新措施，在某些情况下，软件盗版在俄国内将不受惩罚。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该提案涵盖了使用盗版软件所引发的民事和刑事责任，其还指出，&lt;strong&gt;在遭受制裁的同时，政府允许盗版没有俄产替代品的软件&lt;/strong&gt;。鉴于这项工作的规模，盗版软件现象很可能成为未来几年俄罗斯国内的常态之一。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（完）&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;加入「码农周刊VIP会员」，成为更好的开发者！&lt;br/&gt;↓↓↓&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5493333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavicibroqCN98y5SNT9NbfA3oHYQiaicFScHFfppgek7ZGicJiaHK45qc2zoccBibfEzIvzTsI4AB2xO2IaOw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>