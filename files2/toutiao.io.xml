<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>83eed925f23bae3547d998c76c48e4be</guid>
<title>有了 RestTemplate 你还在手撕写 HttpClient？</title>
<link>https://toutiao.io/k/zsvnw8f</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;在微服务大行其道的今天，&lt;/span&gt;&lt;code&gt;&lt;span&gt;HTTP&lt;/span&gt;&lt;/code&gt;&lt;span&gt;调用是程序员无法避免的常规操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;RestTemplate&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 是&lt;/span&gt;&lt;code&gt;&lt;span&gt;Spring&lt;/span&gt;&lt;/code&gt;&lt;span&gt;提供的一个，用于发起&lt;/span&gt;&lt;code&gt;&lt;span&gt;HTTP&lt;/span&gt;&lt;/code&gt;&lt;span&gt;调用的客户端。相比于传统的&lt;/span&gt;&lt;code&gt;&lt;span&gt;HttpComponents&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，&lt;/span&gt;&lt;code&gt;&lt;span&gt;RestTemplate&lt;/span&gt;&lt;/code&gt;&lt;span&gt;使用起来更简单，更方便。&lt;/span&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;发起Get请求&lt;/span&gt;&lt;/h5&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;获取&lt;/span&gt;&lt;code&gt;&lt;span&gt;JSON&lt;/span&gt;&lt;/code&gt;&lt;span&gt;类型的返回&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;RestTemplate restTemplate = &lt;span&gt;new&lt;/span&gt; RestTemplate();&lt;br/&gt;String fooResourceUrl = &lt;span&gt;&quot;http://localhost:8080/spring-rest/foos&quot;&lt;/span&gt;;&lt;br/&gt;ResponseEntity&amp;lt;String&amp;gt; response = restTemplate.getForEntity(fooResourceUrl + &lt;span&gt;&quot;/1&quot;&lt;/span&gt;, String&lt;span&gt;.class)&lt;/span&gt;;&lt;br/&gt;assertThat(response.getStatusCode(), equalTo(HttpStatus.OK));&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;获取&lt;/span&gt;&lt;code&gt;&lt;span&gt;POJO&lt;/span&gt;&lt;/code&gt;&lt;span&gt;类型的返回 我们定义一个&lt;/span&gt;&lt;code&gt;&lt;span&gt;Foo&lt;/span&gt;&lt;/code&gt;&lt;span&gt;类&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class Foo implements Serializable &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; id;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String name; &lt;br/&gt;    &lt;span&gt;// standard getters and setters &lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;使用&lt;/span&gt;&lt;code&gt;&lt;span&gt;RestTemplate&lt;/span&gt;&lt;/code&gt;&lt;span&gt;发起&lt;/span&gt;&lt;code&gt;&lt;span&gt;Get&lt;/span&gt;&lt;/code&gt;&lt;span&gt;请求&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;Foo foo = restTemplate .getForObject(fooResourceUrl + &lt;span&gt;&quot;/1&quot;&lt;/span&gt;, Foo&lt;span&gt;.class)&lt;/span&gt;; &lt;br/&gt;assertThat(foo.getName(), notNullValue()); assertThat(foo.getId(), is(&lt;span&gt;1L&lt;/span&gt;));&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5&gt;&lt;span&gt;获取Header信息&lt;/span&gt;&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;HttpHeaders httpHeaders = restTemplate.headForHeaders(fooResourceUrl); &lt;br/&gt;&lt;span&gt;//获取ContentType&lt;/span&gt;&lt;br/&gt;assertTrue(httpHeaders.getContentType().includes(MediaType.APPLICATION_JSON));&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5&gt;&lt;span&gt;发起Post请求&lt;/span&gt;&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;RestTemplate restTemplate = &lt;span&gt;new&lt;/span&gt; RestTemplate();&lt;br/&gt;HttpEntity&amp;lt;Foo&amp;gt; request = &lt;span&gt;new&lt;/span&gt; HttpEntity&amp;lt;&amp;gt;(&lt;span&gt;new&lt;/span&gt; Foo(&lt;span&gt;&quot;bar&quot;&lt;/span&gt;));&lt;br/&gt;Foo foo = restTemplate.postForObject(fooResourceUrl, request, Foo&lt;span&gt;.class)&lt;/span&gt;;&lt;br/&gt;assertThat(foo, notNullValue());&lt;br/&gt;assertThat(foo.getName(), is(&lt;span&gt;&quot;bar&quot;&lt;/span&gt;));&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5&gt;&lt;span&gt;模拟Form表单提交&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;&lt;span&gt;通过&lt;/span&gt;&lt;code&gt;&lt;span&gt;POST&lt;/span&gt;&lt;/code&gt;&lt;span&gt;方式提交表单数据，首先需要设置头部信息，将&lt;/span&gt;&lt;code&gt;&lt;span&gt;Content-Type&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 设置为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;application/x-www-form-urlencoded&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来我们将表单中的数据项封装进&lt;/span&gt;&lt;code&gt;&lt;span&gt;Map&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。最后将&lt;/span&gt;&lt;code&gt;&lt;span&gt;Header&lt;/span&gt;&lt;/code&gt;&lt;span&gt;和表单数据一起封装成&lt;/span&gt;&lt;code&gt;&lt;span&gt;HttpEntity&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;代码示例如下&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;HttpHeaders headers = &lt;span&gt;new&lt;/span&gt; HttpHeaders(); &lt;br/&gt;&lt;span&gt;//设置头部信息&lt;/span&gt;&lt;br/&gt;headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);&lt;br/&gt;&lt;span&gt;//将表单信息封装进Map&lt;/span&gt;&lt;br/&gt;MultiValueMap&amp;lt;String, String&amp;gt; map= &lt;span&gt;new&lt;/span&gt; LinkedMultiValueMap&amp;lt;&amp;gt;(); &lt;br/&gt;map.add(&lt;span&gt;&quot;id&quot;&lt;/span&gt;, &lt;span&gt;&quot;1&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//将表单数据封装进HttpEntity&lt;/span&gt;&lt;br/&gt;HttpEntity&amp;lt;MultiValueMap&amp;lt;String, String&amp;gt;&amp;gt; request = &lt;span&gt;new&lt;/span&gt; HttpEntity&amp;lt;&amp;gt;(map, headers);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//发起POST请求&lt;/span&gt;&lt;br/&gt;ResponseEntity&amp;lt;String&amp;gt; response = restTemplate.postForEntity( fooResourceUrl+&lt;span&gt;&quot;/form&quot;&lt;/span&gt;, request , String&lt;span&gt;.class)&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;assertThat(response.getStatusCode(), is(HttpStatus.CREATED));&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5&gt;&lt;span&gt;通过PUT方式更新资源&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;&lt;span&gt;更新资源既可以通过&lt;/span&gt;&lt;code&gt;&lt;span&gt;PUT&lt;/span&gt;&lt;/code&gt;&lt;span&gt;方法，也可以通过&lt;/span&gt;&lt;code&gt;&lt;span&gt;exchange()&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。示例如下。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;Foo updatedInstance = &lt;span&gt;new&lt;/span&gt; Foo(&lt;span&gt;&quot;newName&quot;&lt;/span&gt;); &lt;br/&gt;&lt;br/&gt;updatedInstance.setId(createResponse.getBody().getId()); &lt;br/&gt;&lt;br/&gt;String resourceUrl = fooResourceUrl + &lt;span&gt;&#x27;/&#x27;&lt;/span&gt; + createResponse.getBody().getId();&lt;br/&gt;HttpEntity&amp;lt;Foo&amp;gt; requestUpdate = &lt;span&gt;new&lt;/span&gt; HttpEntity&amp;lt;&amp;gt;(updatedInstance, headers); &lt;br/&gt;&lt;span&gt;//通过exchange发送PUT类型请求&lt;/span&gt;&lt;br/&gt;template.exchange(resourceUrl, HttpMethod.PUT, requestUpdate, Void&lt;span&gt;.class)&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//直接通过putAPI进行更新&lt;/span&gt;&lt;br/&gt;template.put(resourceUrl,requestUpdate,Void&lt;span&gt;.class)&lt;/span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5&gt;&lt;span&gt;发起DELETE请求&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;&lt;span&gt;通过&lt;/span&gt;&lt;code&gt;&lt;span&gt;delete&lt;/span&gt;&lt;/code&gt;&lt;span&gt;删除资源。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;String entityUrl = fooResourceUrl + &lt;span&gt;&quot;/&quot;&lt;/span&gt; + existingResource.getId();&lt;br/&gt;restTemplate.delete(entityUrl);&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5&gt;&lt;span&gt;通过exchange()发起请求&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;&lt;span&gt;通过&lt;/span&gt;&lt;code&gt;&lt;span&gt;exchange()&lt;/span&gt;&lt;/code&gt;&lt;span&gt;方法可以发起任意类型的&lt;/span&gt;&lt;code&gt;&lt;span&gt;HTTP&lt;/span&gt;&lt;/code&gt;&lt;span&gt;请求。代码示例如下。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;RestTemplate restTemplate = &lt;span&gt;new&lt;/span&gt; RestTemplate();&lt;br/&gt;HttpEntity&amp;lt;Foo&amp;gt; request = &lt;span&gt;new&lt;/span&gt; HttpEntity&amp;lt;&amp;gt;(&lt;span&gt;new&lt;/span&gt; Foo(&lt;span&gt;&quot;bar&quot;&lt;/span&gt;)); &lt;br/&gt;&lt;span&gt;//传递参数为HttpMethod.POST, 发起POST类型参数&lt;/span&gt;&lt;br/&gt;ResponseEntity&amp;lt;Foo&amp;gt; response = restTemplate .exchange(fooResourceUrl, HttpMethod.POST, request, Foo&lt;span&gt;.class)&lt;/span&gt;;&lt;br/&gt;assertThat(response.getStatusCode(), is(HttpStatus.CREATED));&lt;br/&gt;Foo foo = response.getBody();&lt;br/&gt;assertThat(foo, notNullValue());&lt;br/&gt;assertThat(foo.getName(), is(&lt;span&gt;&quot;bar&quot;&lt;/span&gt;));&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5&gt;&lt;span&gt;配置超时时间&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;&lt;span&gt;可以通过&lt;/span&gt;&lt;code&gt;&lt;span&gt;ClientHttpRequestFactory&lt;/span&gt;&lt;/code&gt;&lt;span&gt;配置&lt;/span&gt;&lt;code&gt;&lt;span&gt;RestTemplate&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的超时时间。代码示例如下：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;RestTemplate restTemplate = &lt;span&gt;new&lt;/span&gt; RestTemplate(getClientHttpRequestFactory()); &lt;br/&gt;&lt;br/&gt;&lt;span&gt;private ClientHttpRequestFactory getClientHttpRequestFactory() &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; timeout = &lt;span&gt;5000&lt;/span&gt;;&lt;br/&gt;    HttpComponentsClientHttpRequestFactory clientHttpRequestFactory = &lt;span&gt;new&lt;/span&gt; HttpComponentsClientHttpRequestFactory(); &lt;br/&gt;    clientHttpRequestFactory.setConnectTimeout(timeout);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; clientHttpRequestFactory;&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;RestTemplate&lt;/span&gt;&lt;/code&gt;&lt;span&gt;使用起来即简单又方便，&lt;/span&gt;&lt;code&gt;&lt;span&gt;RestTemplate&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的设计思想和&lt;/span&gt;&lt;code&gt;&lt;span&gt;JDBCTemplate&lt;/span&gt;&lt;/code&gt;&lt;span&gt;如出一辙。相信这也是&lt;/span&gt;&lt;code&gt;&lt;span&gt;Spring&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的哲学。&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;注意：现在&lt;/span&gt;&lt;code&gt;&lt;span&gt;RestTemplate&lt;/span&gt;&lt;/code&gt;&lt;span&gt;已经不被官方推荐使用，官方推荐使用&lt;/span&gt;&lt;code&gt;&lt;span&gt;WebClient&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。下一篇文章将会介绍&lt;/span&gt;&lt;code&gt;&lt;span&gt;WebClient&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的使用。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;本文内容主要翻译自 https://www.baeldung.com/rest-template&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMzE4MDY0Nw==&amp;amp;mid=2247484022&amp;amp;idx=1&amp;amp;sn=d3176ea73e48360b64c3f50e8fd622bf&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;1. Java并发编程那些事儿(十)——最后的总结&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMzE4MDY0Nw==&amp;amp;mid=2247484130&amp;amp;idx=1&amp;amp;sn=eb09dd99d1a8e892a3de73d898c04b0c&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;2. 程序员应该掌握的常用网络问题定位工具&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMzE4MDY0Nw==&amp;amp;mid=2247483893&amp;amp;idx=1&amp;amp;sn=85f6a2063048cc244aedde3172444e32&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;3. Awk这件上古神兵你会用了吗&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMzE4MDY0Nw==&amp;amp;mid=2247483852&amp;amp;idx=1&amp;amp;sn=6efb0db3d5dff639fae2aaec978c2160&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;4. 手把手教你搭建一套ELK日志搜索运维平台&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1ea0e7b6343013d60ea60175c225ac2b</guid>
<title>[译] React 状态管理的前世，今生和未来</title>
<link>https://toutiao.io/k/ttvrzlk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;译者注：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实这篇文章&lt;strong&gt;并没有太多的干货&lt;/strong&gt;，但是它提供了时间维度的视角让我们去观察状态管理是怎么发展；这段简短的历史可以作为我们选择状态管理的参考资料，也可以作为一个技术雷达帮我们发现一些技术广度上的盲点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而我自知翻译仓促和语言能力匮乏，所以留下原文供大家参考；如果有更好的翻译建议和批评可以偷偷告诉我。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;全文最有价值的部分可能就是未来部分“关于状态管理如何选择”的部分，不想看水文的可以直接划到最下面。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原文地址 &lt;/span&gt;&lt;span&gt;https://leerob.io/blog/react-state-management&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;React was introduced in May 2013. Its paradigm shift was that your UI was a function of your state. Given some component state, React can determine what your component will look like. React is built upon the idea of state. However, state has long been one of the most difficult parts of building a React application.&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;自2013年5月面世以来，React 给前端带来了新的编程范式：UI 是状态的函数。给定组件一个状态，React 就能决定这个组件的样子。React 就是基于状态的概念来开发的。但是长久以来状态管理是使用 React 开发应用时最头痛的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Let&#x27;s imagine state management in React as a rugged tool belt. You&#x27;ve used this tool belt for years, slowly adding new tools as needed. Each tool serves a very specific purpose. You don&#x27;t use your hammer to screw in bolts. As a craftsman, you&#x27;ve learned the right time and place to use each tool.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果把 React 中状态管理比喻成一个工具箱，里面有一些你已经使用多年的老工具，而且你也会根据不同需要逐渐添加新的工具。每种工具用来解决一个特定的问题。作为代码匠，你知道在不同情况下使用不同工具来解决问题，绝不会用榔头来拧螺丝。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;State management with React is a rugged tool belt, but not everyone has the prior experience to know which tool to reach for. This post will explain the past, present, and future of state management to help you make the correct decision for your team, project, or organization.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;React的状态管理是一个重要的工具箱，但是并不是每个人都有如何筛选工具的经验。这篇文章就是想和大家厘清状态管理的前世，今生和未来，来帮助大家在团队、项目和组织中选择合适的状态管理工具。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;名词解释 Glossary&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Before we begin, it&#x27;s critical you understand some of the terms commonly used. These aren&#x27;t the canonical names. A few different variations of each float around, but the underlying ideas are the same:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在文章正式开始前，我们先定义下常用的几个名词解释。这些定义并不是专业定义，实际使用的时候也会有些变化，但是背后的概念是一样的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;UI State&lt;/strong&gt; &lt;/span&gt;&lt;span&gt;State used for controlling interactive parts of our application (e.g. dark mode toggle, modals).&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;UI 状态&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; - 用来控制如何应用（如主题设置，模态窗口）如何交互的状态。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Server Cache State&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; – State from the server, which we cache on the client side for quick access (e.g. call an API, store the result, use it in multiple places).&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;远程缓存状态&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; - 将服务端的状态缓存在客户端，以便方便使用。（比如，调用一个 API，然后将结果保存，然后在各个组件中使用）&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;Form State&lt;/strong&gt;&lt;/span&gt; &lt;/span&gt;&lt;span&gt;The many different states of a form (e.g. loading, submitting, disabled, validation, retrying). There&#x27;s also controlled &amp;amp; uncontrolled form state.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;表单状态&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; - 表单的各种状态（例如：加载中，提交中，按键不可用，字段校验失败，重试等等），这些状态也分为受控状态和非受控表单状态。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;URL State &lt;/strong&gt;- &lt;/span&gt;&lt;span&gt;State managed by the browser (e.g. filter products, saving to query parameters, and refreshing the page to see the same products filtered)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;URL 状态 &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;- 由浏览器管理的链接状态（例如：一个过滤功能，将过滤参数存储在 URL 中，这样刷新页面还是能看到相同的列表结果）[译者：其实就是路由状态管理]&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;State Machine&lt;/strong&gt; -&lt;/span&gt; &lt;span&gt;An explicit model of your state over time (e.g. a stoplight goes from green → yellow → red, but never green → red).&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;状态机&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; - 明确定义状态随时间变化的模型，比如红绿灯的状态机：从绿灯-&amp;gt; 黄灯-&amp;gt; 红灯，但是不能直接从绿灯直接变成红灯。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;前世 past&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;React&#x27;s component model helped create reusable, composable applications. Each component had its own local state. As web apps became more complex, new solutions emerged to more easily share logic between components.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;React的组件模型让我们能够构建出可复用、可组合的应用。每个组件都有自己的独立状态。当 Web 应用变得越来越复杂，一些新的管理方案应运而生，来解决组件之间如何方便共享复用逻辑的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;时间线&lt;/h2&gt;&lt;p&gt;&lt;span&gt;To help you understand how state management has evolved over time, here&#x27;s a rough timeline of popular state management solutions in React. This list is heavily focused on UI State. This list is not comprehensive, but is enough to give context.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了帮大家更好地理解状态管理发展的历史，我梳理了React 中状态管理库的流行趋势。这些列表主要是 UI 的状态管理的库，所以不是很全面，但是也足以说明问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2013 状态管理萌芽时期&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2014 Flux时代&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2015 Redux&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2016 MobX&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2018 Context&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2019 Hooks引入（同时诞生了 React Query 和 SWR）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2019 Zustand&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2019 基于状态机的 xState &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2020 Jotai, Recoil, Valtio&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2021 useSelectedContext&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Just because an item is listed on this timeline does not mean you need to learn it. More on this later. Let&#x27;s dive into the history of state management in React.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;只是按照时间顺序罗列了这些状态管理库，并不表示你需要掌握每一个。接下来我一起来深入了解下 React 中的状态管理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;Redux&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;Redux was originally created as an implementation of the &quot;Flux Architecture&quot;, which was a pattern first suggested by Facebook in 2014. Redux came out in 2015 and quickly became the most popular of many Flux-inspired libraries. It&#x27;s ecosystem of tools and libraries encapsulated both UI state and server caching state. Redux is still extremely popular and widely used.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2014年 Facebook 提出了Flux 单向数据流架构，Redux 就是它的一种具体实现。Redux 于2015年面市，随即成为 Flux 架构下最流行的状态管理库。基于 Redux 已经形成了 UI 状态和服务数据缓存管理库的生态。目前 Redux 仍然非常的流行并且广泛使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.586&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dlEwIVcKGs4k0ZrsZSfza971H2TaDicz2xsjUU4FVpIJcLsvEscBZJgTQ35FKrX0HNBD3dgBJQmYaQzczmROr5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;h3&gt;远程缓存状态管理（原文Server Caching State）&lt;/h3&gt;&lt;p&gt;&lt;span&gt;In the early days of React, lots of state management boiled down to fetching data from APIs and caching it for use across the application. The community leaned heavily on libraries like Redux because there wasn&#x27;t an easy, widely used way to manage just the server cache state.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 React 的早期，大部分的状态管理做的事情就是从服务器取数据，然后缓存在本地，供前端应用使用。社区大量地使用类似 Redux 这样的状态管理，但没有出现一个被大众喜爱好用的缓存服务器状态的工具。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;With the release of React Hooks, encapsulating logic into shared hooks became much easier and accessible. Libraries like SWR and React Query emerged to solve this problem specifically.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着 React 推出了 Hooks，可以通过把通用逻辑封装在 hooks 中方便复用。于是类似 SWR 和 React Query 出现，专门用来解决远程状态管理的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;You might think, &quot;Why have a separate library just for server caching state?&quot;. Well, caching is hard. Server caching state solves different problems than UI state. Here&#x27;s a shortlist of some of the things these libraries handle for you:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;你可能会想“为什么需要有一个专门用来做服务器数据缓存状态管理的工具库呢？”。因为：Caching is hard （缓存很难）。远程状态管理相较于 UI 状态管理要解决的是完全不同的问题，比如：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;定时轮询数据 Polling on interval&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;选中时重新验证数据 Revalidation on focus&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;网络恢复后重新验证数据 Revalidation on network recovery&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本地数据操作（用于实现乐观 UI） Local mutation (Optimistic UI)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;错误的智能重试 Smart error retrying&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分页和无限加载模式中的滚动定位 Pagination and scroll position recovery&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Do you want to implement those yourself? Probably not.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;你肯定不会想自己实现上面所有这些功能？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;React Context&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;With v16.3, React Context gave us a first-party solution to share logic between components. This also prevented passing values down as props through multiple levels of nested components (i.e. &quot;prop-drilling&quot;).&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着 16.3 版本的发布， React Context 直接提供组件之间共享逻辑的方案。这样我们就不用通过组件属性一层一层的传递到多层嵌套的组件（也称为：属性钻透 prop-drilling，参考 https://kentcdodds.com/blog/prop-drilling ）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;React Context itself is not state management. It can, however, be paired with hooks like useReducer to become a state management solution. This combination solved UI state for many common use cases.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Context 本身并不是一种状态管理工具，但是通过和 useReducer 这个 hooks 组合就可以成为一种状态管理方案。这种组合的方案解决了很多 UI 状态管理的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.572&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dlEwIVcKGs4k0ZrsZSfza971H2TaDicz2MubaIMYGhEHf3sX75xgVwVib4kzp7FW5ojicyf7nQtTuTMbFxWAQ5Z0A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;今生 present&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;In 2021, there are various ways to handle state management in React. As the community has grown to understand the different types of state, more granular libraries have been created solving very specific use cases.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 2021 年涌现了大量的 React 状态管理库。随着社区对状态管理的理解越来越深入，许多不同颗粒度的库被创造出来解决特定的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;状态机&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Let&#x27;s consider a switch statement. If the value of state matches any case, the corresponding code runs. There&#x27;s a finite set of cases. This is the most simple state machine – an explicit model of your state.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;假设我们有一段 switch 代码，匹配到对应的值就执行对应的代码。这就是一个简单对状态准确定义的状态机。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre data-language=&quot;plain&quot;&gt;// 伪代码&lt;br/&gt;switch (state) { &lt;br/&gt;&lt;br/&gt;Case state === &#x27;loading&#x27;: &lt;br/&gt;// show loading spinner break; &lt;br/&gt;&lt;br/&gt;Case state === &#x27;success&#x27;: &lt;br/&gt;// show success message break; &lt;br/&gt;&lt;br/&gt;Default: &lt;br/&gt;// show error message &lt;br/&gt;}&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Finite State Machines and Statecharts are fundamental Computer Science concepts, so this isn&#x27;t anything React specific. You can turn useReducer into a state machine without any third-party libraries.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有限状态机和状态图是计算机领域中两个基础概念，并不是React中特有的东西。你在不引入任何第三方库的情况下，可把&lt;/span&gt;&lt;code&gt;&lt;span&gt;useRecuder&lt;/span&gt;&lt;/code&gt;&lt;span&gt;转换成等价的状态机实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;State Machines are well-adopted everywhere, including databases, electronics, cars, and more. As state management evolved in the React ecosystem, we realized these old ideas could solve modern state management issues. State Machines are most prevalent for solving form state.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;状态机已经在各个领域广泛地使用，数据库、电子产品，汽车等等。随着状态机在 React 生态中的发展，我们发现这个老工具也能解决状态管理这个新问题。状态机特别适合解决表单状态管理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;With a Finite State Machine, you have a finite number of states your application or component could be in. In practice, State Machines help you uncover bugs as you&#x27;re required to think through and define edge cases. For much more information on this, I&#x27;d recommend checking out the xState docs or watching this course. You can also visualize entire state machines online.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在一个有限状态机的模型里面，你的系统或者组件会归属到不同的状态。在实践中，状态机需要你思考和定义好边界情况，这样非常有助于你提前发现 bug。如果你想更多地了解状态机的话，我建议你看看 xState的文档(https://xstate.js.org/docs/)和 egghead 的这个教程(https://egghead.io/courses/introduction-to-state-machines-using-xstate)，基于 &lt;/span&gt;&lt;code&gt;&lt;span&gt;xstate&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 定义的状态机还能被可视化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.34625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/dlEwIVcKGs4k0ZrsZSfza971H2TaDicz2BBG9lmnnibowQVnmAumOjiab6B6du1BUXCicDtuaia5T36vHTkk4swHQ7A/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;h2&gt;Zustand, Recoil, Jotai, Valtio，学不动了！&lt;/h2&gt;&lt;p&gt;&lt;span&gt;Why do so many different libraries for React state management even exist?&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为什么现在会有如此之多的状态管理库呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Let&#x27;s consider Figma (or any other design tool). You have a toolbar of controls that affect other elements outside of its &quot;local&quot; state, or where the component is rendered.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;假设我们在实现一个类似 Figma 的设计工具。你有一个工具栏，会影响应用中的其他状态，或者应用中组件是如何渲染。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.663&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dlEwIVcKGs4k0ZrsZSfza971H2TaDicz2COqiajdIIOV29m55HsVFDMKxRnVll1QKcdmH4dw0pMaNFkV7ZicHMZdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;As you can imagine, an application of this scale would require a complex state management solution. Performance and frame rate are critical for a good user experience here, so you want control over when &amp;amp; how to re-render. Unique use cases like this have led to lots of exploration in the state management space.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以想象这样大规模地应用肯定需要一个复杂状态管理的解决方案。性能和应用的帧率对用户体验非常的重要，所以你会想控制在UI在何时用各种方式渲染。每种特殊的使用场景都会促进去发明一种新的状态管理的方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;To summarize the differences between these libraries, let&#x27;s hear from Daishi Kato:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;用&lt;span&gt;Daishi Kato的话来总结这些不同库的特点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Valtio uses proxies to provide a mutation-style API&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Valtio：使用 Proxy 提供一个可变数据风格 API 的状态管理工具。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Jotai is optimized for &quot;computed values&quot; and async actions&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Jotai：为优化异步更新和“计算值”而生的状态管理&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Zustand is a very thin library specifically focused on module state&lt;br/&gt;Zustand：一个专注于状态模块化管理的轻量库。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Recoil is an experimental library using a data-flow graph&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Recoil：基于数据流图的实验性质的状态管理库。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Having complex state doesn&#x27;t necessarily mean you have to pull for a third-party library. You can start with React and JavaScript and see how far it takes you. If optimizing requires a state management library, you can track that metric (e.g. frame rate), measure it, and verify it solves a real problem.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有复杂的状态需要管理并不意味着你需要引入一个第三方的状态管理库。你可以试试裸用 React 看看能做到什么程度。如果遇到性能问题，需要引入一个第三方状态管理库，你在定义优化的数值目标（比如：帧率），然后测试下是不是解决了你的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Don&#x27;t choose one of these libraries unless there&#x27;s an obvious need.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除非你真的需要，尽量不要随便引入状态管理库。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;Immutable State&lt;/h2&gt;&lt;p&gt;&lt;span&gt;Another debate is mutable vs. immutable state. There are no right answers, just opinions. If you were doing state management with vanilla JavaScript, you&#x27;ll likely have mutable state. You initialize a variable, and then later set it equal to some new value. There are entire debates on let vs. const.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;状态管理的另外一个争论就是：可变状态和不可变状态。这个争论是没有正确答案的，只是两种不同的观点。如果你是直接用 javascript 来做状态管理的，你肯定会有很多状态：你初始化一个变量，然后再给它赋一个新值。其这种争论的本质就是用 let 还是 const。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Immutable state gained a lot of popularity with React. The immutable crowd argues that allowing your state management solution of choice to mutate state directly results in more bugs. The mutable crowd argues it&#x27;s not worth the complex trade-off. Direct manipulation will always be less safe than indirect manipulation. It&#x27;s a tradeoff between convenience and risk, which is up to you and your team.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不可变状态在 React 生态里面很流行。不可变状态的拥护者认为直接修改状态的数据非常容易引入 bug。可变状态的拥护者则认为，不可变带来的复杂度太高了。直接修改状态数据肯定是没有间接的方式安全。但是风险和便利之间应该如何平衡完全由你和你的团队自己决定。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Solutions like Immer allow you to write mutable code but execute it immutably. Fancy. The basic idea is you apply your changes to a draft state, which is a proxy of the current state. Once the mutations have completed Immer will produce the next state based on the changes to the draft state.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;类似 Immer 让你通过写可变状态的方式实现不可变数据的状态管理。很炫酷。背后的思想就是通过对“草稿”状态直接赋值，“草稿”将这些操作再应用到当前的状态上去。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.389&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dlEwIVcKGs4k0ZrsZSfza971H2TaDicz2iazqsSe7g7FCVzPqyqF3xoOP2zGUX8wBiaRjSGicASJoqdXU0bibhw6R9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;h2&gt;URL State&lt;/h2&gt;&lt;p&gt;&lt;span&gt;Let&#x27;s say you&#x27;re building an e-commerce website like Amazon. You search for React books and filter by 4+ stars. This state is persisted as query parameters and managed by the browser. When you refresh the page, you see the same list of products. You can share this URL with others and they also see the same results.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;假设我们正在开发一个类似亚马逊的电子商务网站。你搜索了 4 星评价以上关于 React 的书，这搜索状态被持久化到URL地址中并被浏览器管理。当你重新刷新浏览器或者把地址分享给其他人，都能看到你的搜索结果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.732&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dlEwIVcKGs4k0ZrsZSfza971H2TaDicz2xa3bNiaYQGib1jUeQuXyA0rHDWGGFnPBQ1XibggpNsEEUh0jOnCIe57gA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Another interesting example of this is Nomad List. We can transform the browser URL state into a function of our data. Plus, we can make human-readable URLs (which Google prefers).&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个有趣的例子就是 Nomad list。我们通过一个函数根据页面数据生成一个URL地址 。这样就可以生成一个对人友好可读（对搜索引擎也友好）的 URL 地址。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.676&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dlEwIVcKGs4k0ZrsZSfza971H2TaDicz2sLIBJmjyClPYLMln4C9XRGK8iaKicB64x3WBJI5AK4qL4DmXysXNxb8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;未来 future&lt;br/&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;For large applications, it&#x27;s possible a naive Context-based state management solutions (e.g. with useReducer) could have issues with excessive re-rendering.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在开发大型应用的时候，如果只用朴素的Reat Context 的方式（搭配 &lt;/span&gt;&lt;code&gt;&lt;span&gt;useReducer&lt;/span&gt;&lt;/code&gt;&lt;span&gt;）来状态管理的话，很容易出现大量的多余的重新渲染。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;When a context value changes, all components that useContext will re-render. This makes UI interactions feel slow and janky. If you can&#x27;t visually notice it, you can use React Dev Tools to investigate re-rendering.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为当一个 context 的值发生了改变，那么所有通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;useContext&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 使用这个 context 的组件都会重新渲染。这样会让我们的 UI 变慢变卡。如果察觉不到这个变化的话，可以试试用 React 的开发者工具更加细腻的观察组件的重渲染。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;The React team has proposed a useSelectedContext hook to prevent performance issues with Context at scale. This RFC was introduced in July 2019 and progress has started as of January 2021 behind a feature flag. This hook allows you to select a &quot;slice&quot; of context and only re-render when that piece changes.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;React团队已经在提议了一个新的 hook ，&lt;/span&gt;&lt;code&gt;&lt;span&gt;useSelectedContext&lt;/span&gt;&lt;/code&gt;&lt;span&gt;用来解决 Context 使用过程中的问题。RFC 在 2019 年7 月提出，2021 年 1月就可以通过特性开关来试用。这个 hook 可以让你选择context 中的值部分改变，从而尽量减少不相关的组件的重渲染（译者注：类似 redux 里面的 map 函数）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;There are ways to work around re-rendering performance already (e.g. useMemo) but a first-party solution for Context is preferred.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虽然有很多方法能解决重渲染的性能问题（比如 useMemo），但是我们还是倾向使用 React 中原生的解决方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;There&#x27;s also a community library use ContextSelector, which takes a similar approach (demo). Jotai and Formik 3 use this under the hood. Having used SelectedContext as part of the React standard library will eliminate complexity and code size in external libraries, as well as provide more performant options by default.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很多社区的状态管理工具也是基于 ContextSelector （比如：这个例子）像Jotai 和 formik3 底层就是用的这个。如果使用 React 自带的&lt;/span&gt;&lt;code&gt;&lt;span&gt;selectedContext&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 不仅仅可降低代码量和复杂度，同时能带来性能提升。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;In the longer-term future, React will automatically figure out which components to re-render (&quot;auto-memoization&quot;).&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在更遥远的未来， React 会自动分析是需要哪些组件需要重渲染（自动useMemo）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;状态管理如何选择&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;This is not a comprehensive list. It&#x27;s also open-source, so please open a PR if you disagree or if something is wrong. In general, lean on whatever empowers your developers and team. Happy with Redux? Stay there!&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个列表并不全面，但是随时接受大家提 PR 来更改和添加新的列表内容。总之一个原则就是，使用那些可以提高你团队效率的工具。如果喜欢用 redux，那就用 redux。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;表单状态&lt;/h3&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;开发者经验&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;学习热情&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;团队/项目规模&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;解决方案&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;初学者&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;低&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;小&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;useState&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;初学者&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;中&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;中小&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;专门的表单状态管理库 (Formik, Final Form)&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;初学者&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;中高&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;大&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;和你的 TL 讨论&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;中级&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;低&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;中小&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;专门的表单状态管理库 (Formik, Final Form)&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;高级工程师&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;中&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;中&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;状态机 例如 xState&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;高级工程师&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;高&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;中&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;状态机 例如 xState&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;高级工程师&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;高&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;大&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;状态机 例如 xState&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;UI 状态管理&lt;/h3&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;开发者经验&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;学习热情&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;团队/项目规模&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;解决方案&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;初学者&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;低&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;小&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;useState&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;初学者&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;高&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;中小&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;useContext + useReducer&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;初学者&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;中高&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;大&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;和你的 TL 讨论&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;中级&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;低&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;中小&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;Redux Toolkit&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;高级工程师&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;中&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;中&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;useContext + useReducer&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;高级工程师&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;高&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;中&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;Jotai, Valtio&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;高级工程师&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;高&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;大&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;Recoil (如果在用GraphQL的话试试 Relay)&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3&gt;远程缓存状态&lt;/h3&gt;&lt;p&gt;&lt;span&gt;Regardless of experience or team size, both SWR and React Query are excellent solutions. You&#x27;ll be happy with either. If you&#x27;re using GraphQL, you probably already know about Apollo.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不用管你的团队规模和经验， SWR 和 React Query 都是很好的选择。你肯定会满意这两个库的；如果你用 Graphql 的话，那你肯定早就知道 Apollo 了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;完&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;State management in React has evolved massively over the past eight years. It&#x27;s one of the most difficult, nuanced parts of building large web applications. Understanding the different types of state and their tradeoffs is crucial for making an informed decision. I hope this post has helped – thanks for reading.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;React 的状态管理在最近的8年时间飞速发展。在构建 web 应用的时候如何选择一个状态管理工具是最头痛的问题。先了解各个类型状态管理工具的优缺点和要解决的问题，是正确选择他们的第一步。希望这篇文章能够帮助到你，谢谢阅读。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1697eca4b12b4046aab65464c7b4859c</guid>
<title>彻底搞懂事件驱动模型：Reactor</title>
<link>https://toutiao.io/k/flosayk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section&gt;&lt;p&gt;&lt;span&gt;在高性能网络技术中，大家应该经常会看到Reactor模型。并且很多开源软件中都使用了这个模型，如：Redis、Nginx、Memcache、Netty等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;刚开始接触时可能一头雾水，这到底是个什么东东？一查英文解释：“反应堆”，感觉更加唬人了。那么，今天我们来一起看看这个Reactor到底是个啥。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实通俗点讲，Reacotr = IO多路复用 + 池化技术。是“大神”们将IO多路复用技术结合池化技术（线程池进程池）结合的一种模式。IO多路复用负责统一监听事件，收到事件后派发给资源池中的某个线程或进程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其中根据Reacotr的数量和资源池中资源的数量和类型，Reactor有以下3种典型实现方案。其中“多Reactor单进程/线程”实现方案相比“单 Reactor 单进程”方案，既复杂又没有性能优势，因此实际没有应用。&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;单Reactor + 单进程/单线程&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;单Reactor + 多线程&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;多Reactor + 多进程/多线程&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;下面我们逐一介绍一下这3个方案，及他们适用的场景。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;单Reactor + 单进程/单线程&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;该方案示意图如下（以进程举例）：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5407166123778502&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/bymGBmLC3zFlWqbJt1oq5LQ8ee7Gy5GRBfuTc2NogMiaJN5yXlHmPDXgZ7kGD06ZMKOGrcQnVPBSEMOiaB1GhebQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1228&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;Reactor 对象通过 select 监控连接事件，收到事件后通过 dispatch 进行分发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果是连接建立的事件，则由 Acceptor 处理，Acceptor 通过 accept 接受连接，并创建一个 Handler 来处理连接后续的各种事件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果不是连接建立事件，则 Reactor 会调用连接对应的 Handler（第 2 步中创建的Handler）来进行响应。Handler 会完成 read-&amp;gt; 处理 -&amp;gt;send 的完整业务流程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种优点很明显，就是简单，不用考虑进程间通信、线程安全、资源竞争等问题。但是也有自身的局限性，就是无法利用多核资源，&lt;strong&gt;只适用于业务处理非常快速的场景&lt;/strong&gt;，Redis就是采用的这种方案。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;单Reactor + 多线程&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;该方案示意图如下：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.8690851735015773&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/bymGBmLC3zFlWqbJt1oq5LQ8ee7Gy5GRroibZO0oibX6BXobO8icQhHFyxm9Icd50fiaflMtYUjwI5Ap7vDic4TbS5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1268&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;与第一种方案相比，不同的是：Handler只负责响应事件，并不负责处理事件，Handler读取数据后会发送给Processor进行处理。Processor在子线程中完成业务处理，然后将结果发送给Handler。由Handler将结果返回给client。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;你可能主要到没有列出单Reactor + 多进程方案，主要因为如果采用多进程，就要考虑进程间通信的问题，比如子进程处理完成后需要通知父进程将结果返回给对应的client，处理比较复杂。但多线程之间数据是共享的，复杂度相对比较低。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，这种方案下，主线程承担了所有的事件监听和响应。瞬间高并发时可能会成为性能瓶颈。这时就需要多Reactor的方案了。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;多Reactor + 多进程/多线程&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;该方案示意图如下（以进程举例）：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.8478260869565217&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/bymGBmLC3zFlWqbJt1oq5LQ8ee7Gy5GRZt6QcMlOiaqhh4U8DbBMfAEWxadia0kjGuGv8qY9wMbicLSSuhFQFNf3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1380&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;父进程中 mainReactor 对象通过 select 监控连接建立事件，收到事件后通过 Acceptor接收，将新的连接分配给某个子进程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;子进程的 subReactor 将 mainReactor 分配的连接加入连接队列进行监听，并创建一个Handler 用于处理连接的各种事件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当有新的事件发生时，subReactor 会调用连接对应的 Handler（即第 2 步中创建的Handler）来进行响应。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Handler 完成 read→处理→send 的完整业务流程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前著名的开源系统 Nginx 采用的是多 Reactor 多进程，采用多 Reactor 多线程的实现有Memcache 和 Netty。不过需要注意的是 Nginx 中与上图中的方案稍有差异，具体表现在主进程中并没有mainReactor来建立连接，而是由子进程中的subReactor建立。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;Proactor模式&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;以上就是Reactor模式中的几种常见方案，另外除了Reactor模式还有Proactor模式。Reactor 是非阻塞同步网络模型，因为真正的 read 和 send 操作都需要用户进程同步操作。这里的“同步”指用户进程在执行 read 和 send 这类 I/O 操作的时候是同步的，如果把 I/O 操作改为异步就能够进一步提升性能，这就是异步网络模型 Proactor。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;理论上 Proactor 比 Reactor 效率要高一些，但在 Linux 系统下的异步并不完善，因此在 Linux 下实现高并发网络编程时都是以 Reactor 模式为主。所以今天就不对 Proactor 模式进行过多介绍了。&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;section&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;https://time.geekbang.org/column/article/8805&lt;/span&gt;&lt;/h2&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU3ODkzMDA2Mw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/sz_mmbiz_png/bymGBmLC3zHHpBOxu9TYZst8Q2qU06ACNyezHIIjiajJxUP2w7ia53saAMfI6xbibEXibTC67w8Xa5vibJ4GoJREICA/0?wx_fmt=png&quot; data-nickname=&quot;码匠赵铁柱&quot; data-alias=&quot;coder_tiezhu&quot; data-signature=&quot;我是赵铁柱，是名程序员，喜欢做做饭、看看书，偶有一些感想，希望和你分享&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;如果以上对你有帮助，欢迎关注铁柱，一起成长。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/bymGBmLC3zFlWqbJt1oq5LQ8ee7Gy5GR07MHWyhQm9bq5nV5E3WkHiaXd5W9J85H6je8IkwibPZz24IabyE3yDGQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d570db8e316ac75e037fd6fc5ee42cc4</guid>
<title>ElasticSearch 双数据中心建设在新网银行的实践</title>
<link>https://toutiao.io/k/yne9bm6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;点击上方&lt;/span&gt;&lt;strong&gt;&lt;span&gt;蓝色字体&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，选择“设为星标”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;回复”&lt;/span&gt;&lt;strong&gt;&lt;span&gt;资源&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;“获取更多惊喜&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.0625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sq2uE6cicHYxoldXibjHyWbvjJfI6ibEm5Kw715uVJTBLdX1gkVpExwlFh22TMnLIpBq96wT1ibdccSSd3LVdSE3LQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU3MzgwNTU2Mg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/UdK9ByfMT2Nuicxbayqd2jh8nOffZ1gWVciago9WkqicYyXicvia8D879a4eha4HTPQwZe1PJibBCSwmtBtPnRHRFEjw/0?wx_fmt=png&quot; data-nickname=&quot;大数据技术与架构&quot; data-alias=&quot;import_bigdata&quot; data-signature=&quot;大数据开发、大数据面试、大数据框架、大数据实时计算、大数据离线计算Flink/Spark/Hadoop/数仓开发，干货，面试，资料下载，源码解读等&quot; data-from=&quot;0&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI0NjU2NDkzMQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/sq2uE6cicHYxHv9nl4IdfpyzCEWLPNetlOzG8BMTayoVzxztntJKAiblWMMRInZQdWx2cZM7iafcffVNZ9y910xww/0?wx_fmt=png&quot; data-nickname=&quot;大数据真好玩&quot; data-alias=&quot;havefun_bigdata&quot; data-signature=&quot;大数据、大数据开发、大数据面试、Flink/Spark/Hadoop/数仓开发、大数据框架、大数据实时计算、大数据离线计算、Java后端、数据仓库、数据科学、数据分析、数据挖掘以及面试经验和职场感悟。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;本文公众号读者飞熊的投稿，本文主要讲述了ElasticSearch 双数据中心建设在新网银行的实践。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;作者简介： &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;飞熊，目前就职于新网银行大数据中心，主要从事大数据实时计算和平台开发相关工作，对Flink ,Spark 以及ElasticSearch等大数据技术有浓厚兴趣和较深入的理解。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;引言&lt;br/&gt;&lt;/h4&gt;&lt;p&gt;新网银行是作为西部首家互联网银行，一直践行依靠数据和技术驱动业务的发展理念。自开业以来，已经积累了大量数据。早期因为数据量不大全部存入在 Hbase 集群，随着数据 量的增多，Hbase 集群的缺点逐渐被暴露，最显著的问题就是查询返回耗时太长。为了更快， 更好的响应业务，引入了 Elastic Search。Elastic Search 作为大数据搜索查询的一把“利剑”， 能够在海量数据下实现多维分析下近实时返回。并逐渐取代 Hbase,嵌入到新网银行核心业 务线条，成为业务必不可少的一环。&lt;/p&gt;&lt;h4&gt;技术方案&lt;/h4&gt;&lt;p&gt;银行作为金融机构，对线上业务的连续性有着近乎苛刻的要求，一旦出现问题必然面临 监管机构的问责。因此，为了保证 ElasticSearch 集群的高可用性和灾难恢复性，需要考虑 针对 Elastic Search 集群的双数据中心建设。目前主流的技术方案如下:&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5902306648575305&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sq2uE6cicHYxqJjcz0fq06ibOgQNtjI09gkYkkkElDCcDWVIdMem8FHj4pFrZpoHRmogPQtoKobvPjw4F6rQiaiaGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1474&quot;/&gt;&lt;/p&gt;&lt;p&gt;表 1. Elastic Search 双数据中心建设方案对比&lt;/p&gt;&lt;p&gt;ElasticSearch 集群是 P2P 模式的分布式系统架构，任意 2 个节点之间的互相通信将会 很频繁。如果考虑单集群跨机房部署，那么可能造成节点之间频繁的通信，那么通信延时会比较高，甚至造成集群运行频繁不正常，且后期维护成本较高。因此采用多集群多机房部署方案。 &lt;/p&gt;&lt;p&gt;针对多集群多机房的部署方案，在实际建设的时候也存在多种选择。如考虑应用双写方法或则考虑利用 ElasticSearch 的白金会员特性 CCR(跨集群复制)。但是这 2 中方案也有缺 点:如双写方法需要额外的操作保障一致性;CCR(跨集群复制)的白金会员会提高建设成本。因此，经过多方对比，决定采用解析 ElasticSearch 的 Translog 文件方案。这种方案的优点在于：保证实时性，对外屏蔽应用对数据的感知和实现读写分离。&lt;/p&gt;&lt;h4&gt;技术建设&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;1.Translog 文件介绍&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Translog 是 Elastic search 的事务日志文件，它记录所有对分片的事务操作 (add/update/delete)，并且每个分片对应一个 translog 文件。Elastic Search 写入数据的时候， 是先写到内存和 translog 文件。因此可以通过对 translog 文件中数据的拦截，实时写入另一 个数据中心。在 Elastic Search 的分片目录下，存在如下 2 种数据文件:&lt;/p&gt;&lt;p&gt;(1) translog-N.tlog: 日志文件，N 表示 generation(代)的意思。每次当 flush 的时 候就会产生一个 generation(代)。&lt;/p&gt;&lt;p&gt;(2) translog-N.ckp: 记录日志信息的元数据文件，N 表示 generation(代)的意思， 记录 3 个信息:偏移量，事务操作数据量和当前代。&lt;/p&gt;&lt;p&gt;对于包含 N 的文件名，意味着没有数据再写入;正在写入的文件，其文件名是不包含 N。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2. Translog 解析&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;对于日志文件的解析，采用的思想是:部分先行，结束补全。即每次跳过上次读取偏 移量后读取数据，同时等待当前日志文件写完后再读取一次全量数据写入。这样做的目的是为了，补全截取正在写入日志文件时丢失的数据，同时保证数据的时效性。整个解析过程如下:&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.3435326842837274&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sq2uE6cicHYxqJjcz0fq06ibOgQNtjI09gUicuAakljtTWpfcLXZsGic4YGvlz5Ly2OWzHRk5kHBTHYBfA5YGdQtcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1438&quot;/&gt;图 1.分片下 Translog 解析方法&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3.线上部署&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;目前部署方式是采用非嵌入式的，即将代码作为一个单独的应用程序，即命名为 X-CCR 工具，部署到 Elastic Search 的节点服务器上。通过 X-CCR 实现双数据中心数据同步， 同时从业务层面实现数据读写分离，冷热查询分离。部署情况见图 2 所示:&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.36920529801324503&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sq2uE6cicHYxqJjcz0fq06ibOgQNtjI09gDybFHjNYOxTFsSiaAgPk52OqQkhaAb4OwqTupnWojxUjT1Ur2GJdnaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1208&quot;/&gt;图 2. Elastic Search 双数据中心部署效果&lt;/p&gt;&lt;h4&gt;性能表现&lt;/h4&gt;&lt;p&gt;目前新网银行有 2 个 Elastic Search 数据中心，每个数据中心各自有 3 台物理机。通过在线上观察和验证测试，X-CCR 工具可以确保在主分片写入 TPS=50000/s 下，75%的数 据在 2s 内，实现数据相互可见。相关的统计数据见图 3:&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4750733137829912&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sq2uE6cicHYxqJjcz0fq06ibOgQNtjI09gE4KQpvZTNL9tTfccL0DXbAkczw4dhzjh29CQe9JID4vuKbR4C3wS2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;682&quot;/&gt;&lt;/p&gt;&lt;p&gt;图 3. Translog解析同步工具X-CCR 工具性能测试&lt;/p&gt;&lt;h4&gt;总结&lt;/h4&gt;&lt;p&gt;本文介绍了新网银行在Elastic Search双数据中心建设上的实践。目前，已经完成了第一个版本的建设，从功能上和性能上满足了业务需求，但还需更加完善；后期打算将其与Elastic Search 插件集成，方便部署和管理。&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.10979228486646884&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/BSBqCXrZtzAicMToibKuIysLrB62M5A5YaLhZg6z86tI7ZeEZqTLLYyNrmlzrkyKUN5kNeUFicVC3bMP1GEqKz1OQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1011&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; data-from=&quot;yb-recommend-list&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; data-from=&quot;yb-recommend-list&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; data-from=&quot;yb-recommend-list&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; data-from=&quot;yb-recommend-list&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; data-from=&quot;yb-recommend-list&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; data-from=&quot;yb-recommend-list&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; data-from=&quot;yb-recommend-list&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; data-from=&quot;yb-recommend-list&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; data-from=&quot;yb-recommend-list&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; data-from=&quot;yb-recommend-list&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; data-from=&quot;yb-recommend-list&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; data-from=&quot;yb-recommend-list&quot;&gt;&lt;section data-role=&quot;outer&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjU2NDkzMQ==&amp;amp;mid=2247491657&amp;amp;idx=1&amp;amp;sn=2a7cdbde09c2f4bc9a5d925f8969e1b4&amp;amp;chksm=e9bff165dec87873991a35e11ed29c35624fd5d6c0d2aec4e8953a6e618b2c30c1549ad14507&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Apache Iceberg技术调研&amp;amp;在各大公司的实践应用大总结&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjU2NDkzMQ==&amp;amp;mid=2247491439&amp;amp;idx=1&amp;amp;sn=9dc71f6ade6ec8084be9330dec9e3d2d&amp;amp;chksm=e9bc0e43decb87558ef4e37b62df53c7fc39c20f654c2c337e9cc0bcf541e14f1ef9c5260dcd&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Apache Spark 3.0 自适应查询优化在网易的深度实践及改进&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjU2NDkzMQ==&amp;amp;mid=2247486893&amp;amp;idx=1&amp;amp;sn=9cfa6d9d696ad04b35eaaba02adc3909&amp;amp;chksm=e9bc1c81decb95979df1c9dfbf6dc5d05fcf023fcf68cd23525d7f138e477d0656ddb87b5ce9&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;触类旁通Elasticsearch之吊打同行系列：管理篇&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjU2NDkzMQ==&amp;amp;mid=2247484302&amp;amp;idx=2&amp;amp;sn=16763d05aee33dbacc405b84c052d50b&amp;amp;chksm=e9bc12a2decb9bb4c338396f15b890dcf52256f54f5b514585eca9700847c7981cc8f9d04acd&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Elasticsearch在日志分析领域应用和运维实践&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a9f3503070bf56a9e86e6f5955bafdd0</guid>
<title>携程平台化常态化数据治理之路</title>
<link>https://toutiao.io/k/t5mzsjg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span title=&quot;&quot; opera-tn-ra-cell=&quot;_$.pages:0.layers:0.comps:0.title1&quot;&gt;&lt;p&gt;&lt;strong&gt;作者简介&lt;/strong&gt;&lt;/p&gt;&lt;/span&gt; &lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;瑞强，携程高级大数据开发工程师，负责集团客户数据平台、数据资产管理平台的开发和数据治理的推进。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;一、背景&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;数据的重要性不言而喻。每个数据工程师每天会产生大量数据，但这些数据占用的成本、带来的价值、质量如何，以及在保证安全的前提下是否能够更高效地使用，是每个公司在大数据发展到一定阶段后都会遇到的问题。而携程由于涉及的业务线多，数仓团队多，数据安全高效地流通也是一个治理难点。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;二、治理思路&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;   &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;何为数据治理？数据治理和众多新兴学科一样，也有很多种定义。IBM认为，数据治理是根据企业的数据管控政策，利用组织人员、流程和技术的相互协作，使企业能够将“数据作为资产”来管理和应用。根据伯森和杜波夫的定义，数据治理是一个关注于管理信息的质量、一致性、可用性、安全性和可得性的过程。这个过程与数据的拥有和管理的职责紧密相关。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;通常认为，数据治理是围绕数据资产展开的一系列工作，以服务组织各层决策为目标，是数据管理技术、过程、标准和政策的集合。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;综上，数据治理离不开数据资产的沉淀，只有对数据有宏观地把控、明细地探究，才能贴合数据特性进行治理。所以要进行集团层面的数据治理，就需要集团层面的数据资产平台。携程数据资产管理平台（大禹）应运而生。携程数据治理体系的目标是可以让每一位数据生产者对各自拥有的数据进行常态化治理。而目前阶段数据治理的核心目标就是提升数据价值、提高数据质量、&lt;/span&gt;&lt;span&gt;促进数据流通&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;数据价值&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：首先要治理的就是低价值甚至无价值的数据，例如长期无访问、生命周期过长的数据。其次计算资源消耗较多的数据要进行归因分析，针对性优化。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;数据质量&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：完善表的元数据信息包括责任人、数仓分层、主题、重要等级和敏感等级，配置数据质量监控，重点治理无人维护的数据。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;数据流通&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：保障安全的前提下，提高权限审批效率，促进数据流转。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;三、方案实施&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;3.1 元数据建设&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;数据治理的首要工作是搭建元数据数仓。元数据一般分为四类：技术元数据、操作元数据、管理元数据和业务元数据，分别描述了数据的物理化、处理过程、管理过程及数据定义。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;技术元数据：存储相关数据，包括表的元数据、字段元数据等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;操作元数据：ETL相关数据，包括调度元数据、执行元数据、调度之间的血缘元数据等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;管理元数据：包括管理者信息、监控日志、管理日志、管理成效等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;业务元数据：包括数据标准、数据质量、数据指标、数据字典、数据代码、数据安全等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;现阶段最为丰富的数据是技术元数据和操作元数据， 有了这些元数据就可以对计算/存储成本、元数据完整度、数据质量监控的覆盖率/通过率、临时表、无人维护表等进行统计分析，进而推进相关专项治理。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;3.2 专项治理&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;3.2.1 成本治理&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;大多数的数据工程师关注的是需求交付，对存储、计算成本认识不足。目前集团大数据集群计算成本和存储成本比例是4：6，通过初步治理，可节约年成本数千万元。在大禹（数据资产管理平台）上可以直观地看到每个员工拥有的Hive表数、日均存储成本、日均计算成本和在完成数据治理后预计节省的年成本。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3.2.1.1 计算成本&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;     &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;计算成本主要来自于CPU资源的消耗，根据每个调度任务对CPU核数和时间的占用情况估算出成本。CPU的运行成本根据集群的运营情况，计为10元/1M VCS（每个CPU核占用的秒数）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;计算资源主要消耗在ETL调度和Adhoc查询，由此我们对典型低效SQL进行了归因分析。选择部分BU作为试点，针对单次消耗大于10元的高消耗调度进行优化。虽然集团内这些高消耗调度占比1%，但是占据了千万量级的年计算成本。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3111111111111111&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/kEeDgfCVf1ea5Dmg4lbCQxoNGSbdvIXjfgtE8DtYBYlf5oEXJI5AkOvEoV0Rn9vOrDdxPGza2UlnjvTsuiap51g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;720&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;表1：&lt;/span&gt;&lt;span&gt;高消耗问题归因及解决方案&lt;/span&gt;&lt;/p&gt;&lt;section&gt; &lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于Adhoc查询而言，1%超过30元/次，13%超过0.3元/次。仅这14%的查询就占据了超一半的算力成本。除了逻辑、业务、分区层面的优化，技术参数优化也进行全面推广。例如常见的几类MR优化：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1）合并小文件：配置Map输入合并、Map/Reduce输出合并。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2）合理控制reducer数量&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;参数1：hive.exec.reducers.bytes.per.reducer（默认1G）&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;参数2：hive.exec.reducers.max（默认为999）&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;reducer的计算公式为：min（参数2，总输入数据量/参数1），&lt;/span&gt;&lt;span&gt;也可以通过设置mapred.reduce.tasks直接控制reducer个数。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3）使用相同的连接键：当对 3 张或更多表进行 join 时，如果 on 条件使用相同字段，会合并为一个 MapReduce Job。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4）SMB（sort merge bucket join）：用于两张大表进行join，但需要预先给每张大表基于join的字段建立桶。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;set hive.enforce.bucketing = true; --启用桶表&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;set hive.optimize.bucketmapjoin = true; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;set hive.optimize.bucketmapjoin.sortedmerge = true; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;set hive.input.format=org.apache.hadoop.hive.ql.io.BucketizedHiveInputFormat; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;还有将数据倾斜的异常值打散或单独处理、启用压缩、矢量化执行等。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3.2.1.2 存储成本&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;存储成本重点治理长期无访问数据和用户行为数据（UBT），其次统一表存储格式为ORC，采用冷热存储、EC存储，最后清理重复的大文件和业务不再需要的数据。通过这些治理手段，新增存储需求缩减50%，占总存储的20%。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1）近30天无访问表的成本占据总存储的20%，其中99%是临时表。这些无访问表由BU内部进行确认清理，一些日志表或者集团的用户行为数据等需要长期保存的会加入白名单，没有加入白名单的表会自动删除。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2）用户行为数据之前全链路保存了三年的历史，通过逐渐缩短整个流程数据的生命周期达到缩减成本的目的。为了做到治理过程中下游无感知，将原表改为备份表再创建一个原表表名的视图，逐渐缩短视图可读的时间范围，待下游使用无异常之后可将备份表的生命周期缩短。这个优化节省了&lt;/span&gt;&lt;span&gt;大量&lt;/span&gt;&lt;span&gt;存储成本。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3）由于历史遗留问题，之前表的数据格式未完全统一。RCFile占比13.46%，Avro占比1.99%，压缩表占比5.4%，非结构化数据占比24.15%。所以将这些表转化为ORC格式，同时提升计算效率和存储能力。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4）将不常用但需要保存的数据进行冷存储。冷存储的成本为热存储的40%，使用EC技术可进一步压缩到20%。但是冷存储会影响查询的性能，需要根据数据的使用场景综合考虑。这个优化也节省&lt;/span&gt;&lt;span&gt;了不小的存储&lt;/span&gt;&lt;span&gt;成本。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;3.2.2 质量规范&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;    &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先完善表的元数据信息，配置数据质量监控（DQC），其次重点治理无人维护的表和临时表。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1）&lt;span&gt;完善元数据信息：&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.1050420168067228&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1ea5Dmg4lbCQxoNGSbdvIXjCO8raFoZyM2zKr4I4qsRQFGcJ30Z6hk2pobJkSsDwY3ASly1kT5FEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;476&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;表的元数据信息&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;目前统计到的表和字段的元数据信息见上图，从中选取了12个重要指标作为完整性维度的统计，如下图。历史表的完整性也会按照设定的截止时间进行批量补充，同时新建正式表严格按照完整性的规范建立，否则无法创建。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7090909090909091&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1ea5Dmg4lbCQxoNGSbdvIXjek90SiczTqCD3tGbzfVag3NLz2ve5EJdaQkH0pmiaBNvbI4VgvFxyUww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;660&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2）配置DQC：原则上每个正式使用的表都需要配置DQC校验，比如保证调度完成后的数据要大于一定数量，今天和昨天的数据波动要在一定的范围，某些情境下需要主键唯一，或者自定义校验规则。校验规则分为强规则、弱规则。强规则会熔断下游，防止错误数据影响到下游的使用，对生产造成不可逆的影响。弱规则会触发邮件警告。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3）无人维护表治理：因为离职转岗等原因，有些表的责任人缺失，给下游使用造成了一些困难。我们首先将无人维护表的明细开放给各BU，推动BU补全责任人信息。后期开发了资源转移系统，离职或转岗前会将责任人名下的资源进行一键转移。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4）临时表治理：临时表数量占总表数量的比例较高，需要进行治理。我们明确了临时表的使用规范，只是作为临时使用，七天后自动删除。可以用来进行探索性分析、排障，但是不可用于报表依赖、调度依赖、数据传输。调度任务中产生的中间表需要在任务结束后删除。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;3.2.3 数据流通&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;数据流通主要关注的是共享数据。有两个来源：跨BU合作的项目，中台提供的服务于全业务的数据比如：统一订单数据等。重点治理的是跨BU合作的项目中由于组织架构的改变、项目组变动、数据源变更等原因产生的权限外溢。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;现阶段的治理考虑两个方面：既要增加BU之间的数据流通性、提高数据价值，又要及时治理权限外溢、敏感数据泄露。易用性与安全性之间的平衡存在一定挑战。为此我们上线级联审批功能。对于设置级联审批的表，其下游表的权限审批需要上游表owner共同参与，进一步加强了数据安全性。同时上线了基于密级的差异化审批流程。对于高密表从严把控，低密表则尽量简化审批流程，方便数据快速流通。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;四、平台化与常态化&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;数据资产管理平台目前有三大功能模块，分别是资产盘点、治理工具、健康分析。三个模块的关系如下图所示：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.46173254835996635&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1ea5Dmg4lbCQxoNGSbdvIXjL26BU5CYzmL5AiaiaT4Zx9r7HGmUxPBCJwqs57RXsocCJQ2J9xIxzKnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1189&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;其中资产盘点主要是资产数据看板，包含集团、BU组织和个人的资产概览，成本分析，质量和数据共享相关指标。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;第二个模块是数据治理。&lt;/span&gt;&lt;span&gt;数据属主可以在“我的工作台”对有问题的数据进行便捷地治&lt;/span&gt;&lt;span&gt;理。&lt;/span&gt;&lt;span&gt;需要治理的数据都会以问题标签的形式进行分类展示。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;第三个模块是数据健康分析。分为资源利用、管理规范、成果交付、数据安全四个维度对数据的健康状态进行统计。BU内部想要提质降本、提高开发效率，健康分会是一个最直观的指标。如果有BU疏于数据治理，那么相应的健康分和BU之间的排名就会下降，以此来促进常态化治理。下图为数据健康分总览。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.20546875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1ea5Dmg4lbCQxoNGSbdvIXjb6h9T9UcWK8EO5MddSlNSTrRQ6p32iahuvlBUeV02ia2YibtOf2z0GSWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;资源利用&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：考察近7天CPU离散系数、高消耗调度成本系数及近45天无访问表成本占比。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3109375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1ea5Dmg4lbCQxoNGSbdvIXjnsBgoxc9ypl6y7EMe9bTmibQuh9Ug0nvHAGblW3xHO937uc3ibjx6aRg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.20625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1ea5Dmg4lbCQxoNGSbdvIXjoS1SxDM1xtlt9EqNceIhF9FURyEuTCVCj1sh1U1ytJjibgmPyaiaRsSg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.21953125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1ea5Dmg4lbCQxoNGSbdvIXjIkLpxc6LR421t1oU611VTljhGOop5v6lTLWGEXazjMdFLGrsyreULg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;资源利用健康分&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;管理规范&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：考察表的元数据（数仓分层、责任人、重要等级、基线、敏感等级和主题等）完整性。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.31875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1ea5Dmg4lbCQxoNGSbdvIXjw63ic7njB8ic6pBNLTbSoPy85mPxYrgHpDZvY5oicGJ82ElpcYm0picXYQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;管理规范健康分&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;成果交付&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：考察失败调度占比和查询时长。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.32109375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1ea5Dmg4lbCQxoNGSbdvIXjicbMg3ljGusnhbOQt3BUib7tiaxsWIu8X7oR9rlB7wVXNI72OhXEdxicJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.23671875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1ea5Dmg4lbCQxoNGSbdvIXjfcNJNAlAakBKOHcP3smWY8V14mUMcpMHlfAOZzX3BwGQnsnERn81bQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;成果交付健康分&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;数据安全&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：重点考察对敏感数据的使用是否存在风险。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;五、总结&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;数据治理是一个比较宽泛的概念，每个公司需要治理的数据不一样，并且同一公司不同的发展阶段治理的内容也不一样。需要决策层根据数据体系发展的阶段确定本阶段治理的核心目标，以此来展开治理。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;现阶段我们针对数据的成本、质量、流通三个维度的重点问题进行了治理。下阶段将会有更高的治理要求。同时由于数据在不断产生，治理也不是一劳永逸的，所以借助平台让每个数据生产者可以便捷地进行常态化治理是必经之路。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;团队招聘信息&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们来自携程集团的大数据应用研发团队，致力于集团的数据价值最大化，潜心打造携程的数据中台及其应用。&lt;/span&gt;&lt;span&gt;在这里，你能参与制定集团的大数据流程规范，沉淀跨业务的集团数据资产，打造服务于所有业务的数据中台产品、服务与应用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果你热爱大数据技术，对数据中台在大型互联网企业的落地实践很感兴趣，携程大数据应用研发团队期待你的加入。&lt;/span&gt;&lt;span&gt;目前我们在数据开发、数据科学等方向上均有职位开放。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;简历投递邮箱：tech@trip.com，邮件标题：【姓名】-【携程大数据】-【投递职位】。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;【推荐阅读】&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/kEeDgfCVf1ea5Dmg4lbCQxoNGSbdvIXj4icWeoV5u77YyicAoUicDQuL76G6mcntgylhMVicNvt4PuxOfRmhtzKibtQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt; “携程技术”公众号&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;  分享，交流，成长&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>