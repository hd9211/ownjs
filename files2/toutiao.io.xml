<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>64eee690f264f68b9682379d8c9cef43</guid>
<title>一文通关苦涩难懂的 Java 泛型</title>
<link>https://toutiao.io/k/xhidp2b</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;前言&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信大家对Java泛型并不陌生，无论是开源框架还是&lt;code&gt;JDK&lt;/code&gt;源码都能看到它，毫不夸张的说，泛型是通用设计上必不可少的元素，所以真正理解与正确使用泛型，是一门必修课，本文将解开大家对泛型的疑惑，并通过大量实践，让你get到泛型正确的使用姿势，下面开始进入正题吧！&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;大纲&lt;/h1&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7120181405895691&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nx4t5DlH6w3mEmibxLicsc9mBd7RGCoN4mWQqqHia8InsMyfza0YuZrRphibJLsicXXTia2RDng7md5QfHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;882&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;基础&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为本文重实践，而且面对的是Java开发人员群体，大家对泛型都有基础，所以泛型基础这块会快速过，帮助大家回忆下即可，后面主要的则重点是通配符&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;编译期与运行期&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;编译期&lt;/strong&gt;是指把源码交给编译器编译成计算机可执行文件的过程，&lt;strong&gt;运行期&lt;/strong&gt;是指把编译后的文件交给计算机执行，直到程序结束。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;Java&lt;/code&gt;中就是把&lt;code&gt;.java&lt;/code&gt;文件编译成&lt;code&gt;.class&lt;/code&gt;文件，再把编译后的文件交给&lt;code&gt;J V M&lt;/code&gt;加载执行，如下图&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6796805678793256&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nx4t5DlH6w3mEmibxLicsc9mB6BpGy0N8RPhG9ib9gcoEicojmRiaREAtTlwiamo3NdoiadTTpO0x1as5AJw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1127&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;泛型&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;泛型又叫“参数化类型”，这么抽象的专业词汇不好理解，阿星就用大白话的形式来解释。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;人是铁，饭是刚，吃饭是刚需，要吃饭自然就少不了碗筷，但是没有规定碗只能盛饭，除了盛饭它还能盛汤、盛菜，制造者只造这个碗，不关心碗盛什么，具体要盛什么由使用者来决定，这就是泛型的概念。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;泛型就是在定义类、接口、方法的时候指定某一种特定类型（&lt;span&gt;碗&lt;/span&gt;），让类、接口、方法的使用者来决定具体用哪一种类型的参数（&lt;span&gt;盛的东西&lt;/span&gt;）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Java&lt;/code&gt;的泛型是在&lt;code&gt;1.5&lt;/code&gt;引入的，只在&lt;strong&gt;编译期&lt;/strong&gt;做泛型检查，&lt;strong&gt;运行期&lt;/strong&gt;泛型就会消失，我们把这称为“泛型擦除”，最终类型都会变成 &lt;code&gt;Object&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在没有泛型之前，从集合中读取到的每一个对象都必须进行类型转换，如果不小心插入了错误的类型对象，在运行时的转换处理就会出错，有了泛型后，你可以告诉编译器每个集合接收的对象类型是什么，编译器在编译期就会做类型检查，告知是否插入了错误类型的对象，使得程序更加安全，也更加清楚。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后插一句，泛型擦除与原生态类型（List就是原生态，List&lt;t&gt;非原生态）是为了照顾&lt;code&gt;1.5&lt;/code&gt;以前设计上的缺陷，为兼容非泛型代码，所作出的折中策略，&lt;span&gt;所以不推荐使用原生态类型，如果使用了原生态类型，就失去了泛型在安全性与描述性方面的优势。&lt;/span&gt;&lt;/t&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;泛型类&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5573770491803278&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nx4t5DlH6w3mEmibxLicsc9mBVf19XNIRGicoI7myibkLaOuwF0vqQQPe3iaqKtk7IaibG0t1YnDopgJtibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;549&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类上定义泛型，作用于类的成员变量与函数，代码实例如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;GenericClass&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//成员变量&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; T t;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(T t)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; T &lt;span&gt;functionTwo&lt;/span&gt;&lt;span&gt;(T t)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//注意，这个不是泛型方法！！！&lt;/span&gt;&lt;br/&gt;       &lt;span&gt;return&lt;/span&gt; t;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;泛型接口&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5008665511265165&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nx4t5DlH6w3mEmibxLicsc9mBH7YHCTEPEk10v5uibXAu4E6zcna57ExYB22pdClibvoib1VwGicwlRiaRQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;577&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接口上定义泛型，作用于函数，代码实例如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;GenericInterface&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; T &lt;span&gt;get&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;(T t)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; T &lt;span&gt;delete&lt;/span&gt;&lt;span&gt;(T t)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;default&lt;/span&gt; T &lt;span&gt;defaultFunction&lt;/span&gt;&lt;span&gt;(T t)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; t;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;泛型函数&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9408369408369408&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nx4t5DlH6w3mEmibxLicsc9mBpIwIfD1pJYyMCAt0Haw9pGlWJ2NhWTib9tKCKF7iarapg4sfRsgc3Ziaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;693&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;函数返回类型旁加上泛型，作用于函数，代码实例如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;GenericFunction&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(T t)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;T &lt;span&gt;functionTwo&lt;/span&gt;&lt;span&gt;(T t)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; t;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;String &lt;span&gt;functionThree&lt;/span&gt;&lt;span&gt;(T t)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;通配符&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通配符是为了让&lt;code&gt;Java&lt;/code&gt;泛型支持范围限定，这样使得泛型的灵活性提升，同时也让通用性设计有了更多的空间。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;code&gt;&amp;lt;?&amp;gt;&lt;/code&gt;：无界通配符，即类型不确定，任意类型&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;code&gt;&amp;lt;? extends T&amp;gt;&lt;/code&gt;：上边界通配符，即&lt;code&gt;?&lt;/code&gt;是继承自&lt;code&gt;T&lt;/code&gt;的任意子类型，遵守只读不写&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;code&gt;&amp;lt;? super T&amp;gt;&lt;/code&gt;：下边界通配符，即&lt;code&gt;?&lt;/code&gt;是&lt;code&gt;T&lt;/code&gt;的任意父类型，遵守只写不读&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信大部分人，都是倒在通配符这块，这里多唠叨点，「&lt;strong&gt;通配符限定的范围是体现在确认“参数化类型”的时候，而不是“参数化类型”填充后&lt;/strong&gt;」，可能这句话不太好理解，来看看下面的代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 1.创建泛型为Number的List类，Integer、Double、Long等都是Number的子类&lt;br/&gt; *   new ArrayList&amp;lt;&amp;gt;() 等价于 new ArrayList&amp;lt;Number&amp;gt;()&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;List&amp;lt;Number&amp;gt; numberList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Number&amp;gt;();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 2.添加不同子类&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;numberList.add(&lt;span&gt;1&lt;/span&gt;);&lt;span&gt;//添加Integer类型&lt;/span&gt;&lt;br/&gt;numberList.add(&lt;span&gt;0.5&lt;/span&gt;);&lt;span&gt;//添加Double类型&lt;/span&gt;&lt;br/&gt;numberList.add(&lt;span&gt;10000L&lt;/span&gt;);&lt;span&gt;//添加Long类型&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 3.创建泛型为Number的List类，Integer、Double、Long等都是Number的子类&lt;br/&gt; *   引用是泛型类别是Number，但具体实现指定的泛型是Integer&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;List&amp;lt;Number&amp;gt; numberListTwo = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;();&lt;span&gt;//err 异常编译不通过&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 4.创建泛型为Integer的List类，把该对象的引用地址指向泛型为Number的List&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;List&amp;lt;Integer&amp;gt; integerList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;();&lt;br/&gt;List&amp;lt;Number&amp;gt; numberListThree = integerList;&lt;span&gt;//err 异常编译不通过&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第一步：我们创建一个泛型为&lt;code&gt;Number&lt;/code&gt;的&lt;code&gt;List&lt;/code&gt;，编译器检查泛型类别是否一致，一致编译通过（确认参数化类型）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第二步：泛型&lt;code&gt;Number&lt;/code&gt;已经填充完毕，调用&lt;code&gt;add&lt;/code&gt;函数，此时&lt;code&gt;add&lt;/code&gt;入参泛型&lt;code&gt;T&lt;/code&gt;已经填充为&lt;code&gt;Number&lt;/code&gt;，&lt;code&gt;add&lt;/code&gt;可入参&lt;code&gt;Number&lt;/code&gt;或其子类&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第三步：我们又创建一个泛型为&lt;code&gt;Number&lt;/code&gt;的&lt;code&gt;List&lt;/code&gt;，编译器检查泛型类别是否一致，不一致编译失败，提示错误（确认参数化类型）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第四步：其实与第三步一样，只是做了一个间接的引用（确认参数化类型）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果要解决上面的编译不通过问题，就需要使用通配符，代码如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 1.上边界通配符，Number与Number子类&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;List&amp;lt;? extends Number&amp;gt; numberListFour = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Number&amp;gt;();&lt;br/&gt;numberListFour = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;();&lt;br/&gt;numberListFour = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Double&amp;gt;();&lt;br/&gt;numberListFour = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Long&amp;gt;();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 2.下边界通配符,Integer与Integer父类&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;List&amp;lt;? &lt;span&gt;super&lt;/span&gt; Integer&amp;gt; integerList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;();&lt;br/&gt;integerList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Number&amp;gt;();&lt;br/&gt;integerList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Object&amp;gt;();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 3. 无界通配符,类型不确定，任意类型&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;List&amp;lt;?&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;();&lt;br/&gt;list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Number&amp;gt;();&lt;br/&gt;list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Object&amp;gt;();&lt;br/&gt;list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;();&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后再来说上边界通配符只读不写，下边界通配符只写不读到底是什么意思，用最简单的话来说&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;code&gt;&amp;lt;? extends T&amp;gt;&lt;/code&gt;上边界通配符不作为函数入参，只作为函数返回类型，比如&lt;code&gt;List&amp;lt;? extends T&amp;gt;&lt;/code&gt;的使用&lt;code&gt;add&lt;/code&gt;函数会编译不通过，&lt;code&gt;get&lt;/code&gt;函数则没问题&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;code&gt;&amp;lt;? super T&amp;gt;&lt;/code&gt;下边界通配符不作为函数返回类型，只作为函数入参，比如&lt;code&gt;List&amp;lt;? super T&amp;gt;&lt;/code&gt;的&lt;code&gt;add&lt;/code&gt;函数正常调用，&lt;code&gt;get&lt;/code&gt;函数也没问题，但只会返回&lt;code&gt;Object&lt;/code&gt;，所以意义不大&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家只需要记住上面的规则即可，如果想知道为什么这样设计，可以去了解下&lt;code&gt;P E C S (producer-extends,consumer-super)&lt;/code&gt;原则&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;最佳实践&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信过完基础理论大家很多东西都回忆起来了，不要着急，现在开始进入正题，后面内容会有大量的代码实践，所以大家要坐稳了，别晕车了，晕车的话多看几遍，或者评论区提出你的疑问~&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/23OQmC1ia8nx4t5DlH6w3mEmibxLicsc9mBJ0TM0ic1RnvTs8TC4RjcsgQC2tzGJNYe1GITOGt1cD5kmOFyFoJV82w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;690&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;无限通配符场景&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用泛型，类型参数不确定并且不关心实际的类型参数，就可以使用&lt;code&gt;&amp;lt;?&amp;gt;&lt;/code&gt;，像下面的代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 获取集合长度&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;size&lt;/span&gt;&lt;span&gt;(Collection&amp;lt;T&amp;gt; list)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; list.size();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 获取集合长度-2&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;sizeTwo&lt;/span&gt;&lt;span&gt;(Collection&amp;lt;?&amp;gt;  list)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; list.size();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 获取任意Set两个集合交集数量&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T,T2&amp;gt; &lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;beMixedSum&lt;/span&gt;&lt;span&gt;(Set&amp;lt;T&amp;gt; s1,Set&amp;lt;T2&amp;gt; s2)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (T t : s1) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (s2.contains(t)) {&lt;br/&gt;            i++;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; i;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 获取任意两个Set集合交集数量-2&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;  &lt;span&gt;int&lt;/span&gt; &lt;span&gt;beMixedSumTwo&lt;/span&gt;&lt;span&gt;(Set&amp;lt;?&amp;gt; s1,Set&amp;lt;?&amp;gt; s2)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (Object o : s1) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (s2.contains(o)) {&lt;br/&gt;            i++;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; i;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;size&lt;/code&gt;与&lt;code&gt;sizeTwo&lt;/code&gt;这两个函数都可以正常使用，但是站在设计的角度，&lt;code&gt;sizeTwo&lt;/code&gt;会更合适，函数的目标是返回任意集合的长度，入参采用&lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt;或&lt;code&gt;&amp;lt;?&amp;gt;&lt;/code&gt;都可以接收，但是函数本身并不关心你是什么类型参数，仅仅只要返回长度即可，所以采用&lt;code&gt;&amp;lt;?&amp;gt;&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;beMixedSum&lt;/code&gt;与&lt;code&gt;beMixedSumTwo&lt;/code&gt;这两个函数比较，道理同上面一样，&lt;code&gt;beMixedSumTwo&lt;/code&gt;会更合适，函数的目标是返回两个任意Set集合的交集数量，&lt;code&gt;beMixedSum&lt;/code&gt;函数虽然内部有使用到&lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt;，但是意义不大，因为&lt;code&gt;contains&lt;/code&gt;入参是&lt;code&gt;Object&lt;/code&gt;，函数本身并不关心你是什么类型参数，所以采用&lt;code&gt;&amp;lt;?&amp;gt;&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;忘了补充另一个场景，就是原生态类型，上述代码使用原生态类型函数使用也没问题，但是强烈不推荐，&lt;span&gt;因为使用原生态就丢失了泛型带来的安全性与描述性！！！&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;上下边界通配符场景&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先泛型是不变的，换句话说&lt;code&gt;List&amp;lt;Object&amp;gt; != List&amp;lt;String&amp;gt;&lt;/code&gt;，有时候需要更多灵活性，就可以通过上下边界通配符来做提升。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 集合工具类&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CollectionUtils&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt;&lt;/span&gt;{&lt;br/&gt;        &lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 复制集合-泛型&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;T&amp;gt;  &lt;span&gt;listCopy&lt;/span&gt;&lt;span&gt;(Collection&amp;lt;T&amp;gt; collection)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        List&amp;lt;T&amp;gt; newCollection = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (T t : collection) {&lt;br/&gt;            newCollection.add(t);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; newCollection;&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面声明了一个&lt;code&gt;CollectionUtils&lt;/code&gt;类，拥有&lt;code&gt;listCopy&lt;/code&gt;方法，传入任意一个集合返回新的集合，看似没有什么问题，也很灵活，那再看看下面这段代码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] agrs)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    CollectionUtils&amp;lt;Number&amp;gt; collectionUtils = &lt;span&gt;new&lt;/span&gt; CollectionUtils&amp;lt;&amp;gt;();&lt;br/&gt;    List&amp;lt;Number&amp;gt;  list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;//list.add....&lt;/span&gt;&lt;br/&gt;    List&amp;lt;Integer&amp;gt;  listTwo = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;//listTwo.add....&lt;/span&gt;&lt;br/&gt;    List&amp;lt;Double&amp;gt;  listThree = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;//listThree.add....&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    List&amp;lt;Number&amp;gt; list1 = collectionUtils.listCopy(list);&lt;br/&gt;    list1 = collectionUtils.listCopy(listTwo);&lt;span&gt;//err 编译异常&lt;/span&gt;&lt;br/&gt;    list1 = collectionUtils.listCopy(listThree);&lt;span&gt;//err 编译异常&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建&lt;code&gt;CollectionUtils&lt;/code&gt;类，泛型的类型参数为&lt;code&gt;Number&lt;/code&gt;，&lt;code&gt;listCopy&lt;/code&gt;函数入参的泛型填充为&lt;code&gt;Number&lt;/code&gt;，此时&lt;code&gt;listCopy&lt;/code&gt;只支持泛型为&lt;code&gt;Number&lt;/code&gt;的&lt;code&gt;List&lt;/code&gt;，如果要让它同时支持泛型为&lt;code&gt;Number&lt;/code&gt;子类的&lt;code&gt;List&lt;/code&gt;，就需要使用上边界通配符，我们再追加一个方法&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 集合工具&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CollectionUtils&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt;&lt;/span&gt;{&lt;br/&gt;        &lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 复制集合-泛型&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;T&amp;gt;  &lt;span&gt;listCopy&lt;/span&gt;&lt;span&gt;(Collection&amp;lt;T&amp;gt; collection)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        List&amp;lt;T&amp;gt; newCollection = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (T t : collection) {&lt;br/&gt;            newCollection.add(t);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; newCollection;&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 复制集合-上边界通配符&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt;  List&amp;lt;T&amp;gt;  &lt;span&gt;listCopyTwo&lt;/span&gt;&lt;span&gt;(Collection&amp;lt;? extends T&amp;gt; collection)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        List&amp;lt;T&amp;gt; newCollection = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (T t : collection) {&lt;br/&gt;            newCollection.add(t);&lt;br/&gt;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; newCollection;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] agrs)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    CollectionUtils&amp;lt;Number&amp;gt; collectionUtils = &lt;span&gt;new&lt;/span&gt; CollectionUtils&amp;lt;&amp;gt;();&lt;br/&gt;    List&amp;lt;Number&amp;gt;  list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;//list.add....&lt;/span&gt;&lt;br/&gt;    List&amp;lt;Integer&amp;gt;  listTwo = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;//listTwo.add....&lt;/span&gt;&lt;br/&gt;    List&amp;lt;Double&amp;gt;  listThree = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;//listThree.add....&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    List&amp;lt;Number&amp;gt; list1 = collectionUtils.listCopyTwo(list);&lt;br/&gt;    list1 = collectionUtils.listCopyTwo(listTwo);&lt;br/&gt;    list1 = collectionUtils.listCopyTwo(listThree);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在使用&lt;code&gt;listCopyTwo&lt;/code&gt;就没有问题，&lt;code&gt;listCopyTwo&lt;/code&gt;对比&lt;code&gt;listCopy&lt;/code&gt;它的适用范围更广泛也更灵活，&lt;code&gt;listCopy&lt;/code&gt;能做的&lt;code&gt;listCopyTwo&lt;/code&gt;能做，&lt;code&gt;listCopyTwo&lt;/code&gt;能做的&lt;code&gt;listCopy&lt;/code&gt;就不一定能做了，除此之外，细心的小伙伴肯定发现了，使用上边界通配符的&lt;code&gt;collection&lt;/code&gt;在函数内只使用到了读操作，遵循了只读不写原则。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看完了上边界通配符，再来看看下边界通配符，依然是复制方法&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 儿子&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Son&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Father&lt;/span&gt;&lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 父亲&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Father&lt;/span&gt;  &lt;span&gt;extends&lt;/span&gt;  &lt;span&gt;Grandpa&lt;/span&gt;&lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 爷爷&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Grandpa&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 集合工具&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CollectionUtils&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt;&lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 复制集合-泛型&lt;br/&gt;     * target目标   src来源&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;copy&lt;/span&gt;&lt;span&gt;(List&amp;lt;T&amp;gt; target,List&amp;lt;T&amp;gt; src)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (src.size() &amp;gt; target.size()){&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; src.size(); i++) {&lt;br/&gt;                target.set(i,src.get(i));&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定义了3个类，分别是&lt;code&gt;Son&lt;/code&gt;儿子、&lt;code&gt;Father&lt;/code&gt;父亲、&lt;code&gt;Grandpa&lt;/code&gt;爷爷，它们是继承关系，作为集合元素，还声明了一个&lt;code&gt;CollectionUtils&lt;/code&gt;类，拥有&lt;code&gt;copy&lt;/code&gt;方法，传入两个集合，目标集合与来源集合，把来源集合元素复制到目标集合中，再看看下面这段代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] agrs)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    CollectionUtils&amp;lt;Father&amp;gt; collectionUtils = &lt;span&gt;new&lt;/span&gt; CollectionUtils&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    List&amp;lt;Father&amp;gt;  fatherTargets = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    List&amp;lt;Father&amp;gt;  fatherSources = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;//fatherSources.add...&lt;/span&gt;&lt;br/&gt;    collectionUtils.copy(fatherTargets,fatherSources);&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;//子类复制到父类&lt;/span&gt;&lt;br/&gt;    List&amp;lt;Son&amp;gt; sonSources = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;//sonSources.add...&lt;/span&gt;&lt;br/&gt;    collectionUtils.copy(fatherTargets,sonSources);&lt;span&gt;//err 编译异常&lt;/span&gt;&lt;br/&gt;    &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建&lt;code&gt;CollectionUtils&lt;/code&gt;类，泛型的类型参数为&lt;code&gt;Father&lt;/code&gt;父亲，&lt;code&gt;copy&lt;/code&gt;函数入参的泛型填充为&lt;code&gt;Father&lt;/code&gt;，此时&lt;code&gt;copy&lt;/code&gt;只支持泛型为&lt;code&gt;Father&lt;/code&gt;的&lt;code&gt;List&lt;/code&gt;，也就说，只支持泛型的类型参数为&lt;code&gt;Father&lt;/code&gt;之间的复制，如果想支持把子类复制到父类要怎么做，先分析下&lt;code&gt;copy&lt;/code&gt;函数，&lt;code&gt;copy&lt;/code&gt;函数的入参&lt;code&gt;src&lt;/code&gt;在函数内部只涉及到了&lt;code&gt;get&lt;/code&gt;函数，即读操作（&lt;span&gt;泛型只作为&lt;code&gt;get&lt;/code&gt;函数返回类型&lt;/span&gt;），符合只读不写原则，可以采用上边界通配符，调整代码如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 集合工具&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CollectionUtils&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt;&lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 复制集合-泛型&lt;br/&gt;     * target目标   src来源&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;copy&lt;/span&gt;&lt;span&gt;(List&amp;lt;T&amp;gt; target,List&amp;lt;? extends T&amp;gt; src)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (src.size() &amp;gt; target.size()){&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; src.size(); i++) {&lt;br/&gt;                target.set(i,src.get(i));&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] agrs)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    CollectionUtils&amp;lt;Father&amp;gt; collectionUtils = &lt;span&gt;new&lt;/span&gt; CollectionUtils&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    List&amp;lt;Father&amp;gt;  fatherTargets = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    List&amp;lt;Father&amp;gt;  fatherSources = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;//fatherSources.add...&lt;/span&gt;&lt;br/&gt;    collectionUtils.copy(fatherTargets,fatherSources);&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;//子类复制到父类&lt;/span&gt;&lt;br/&gt;    List&amp;lt;Son&amp;gt; sonSources = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;//sonSources.add...&lt;/span&gt;&lt;br/&gt;    collectionUtils.copy(fatherTargets,sonSources);&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;//把子类复制到父类的父类&lt;/span&gt;&lt;br/&gt;    List&amp;lt;Grandpa&amp;gt; grandpaTargets = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    collectionUtils.copy(grandpaTargets,sonSources);&lt;span&gt;//err 编译异常&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;src&lt;/code&gt;入参调整为上边界通配符后，&lt;code&gt;copy&lt;/code&gt;函数传入&lt;code&gt;List&amp;lt;Son&amp;gt; sonSources&lt;/code&gt;就没问题了，此时的&lt;code&gt;copy&lt;/code&gt;函数相较之前的更加灵活了，支持同类与父子类复制，接着又发现了一个问题，目前能复制到上一级父类，如果是多级父类，还无法支持，继续分析&lt;code&gt;copy&lt;/code&gt;函数，&lt;code&gt;copy&lt;/code&gt;函数的入参&lt;code&gt;target&lt;/code&gt;在函数内部只涉及到了&lt;code&gt;add&lt;/code&gt;函数，即写操作（泛型&lt;span&gt;只作为&lt;code&gt;add&lt;/code&gt;函数入参&lt;/span&gt;），符合只写不读原则，可以采用下边界通配符，调整代码如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 集合工具&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CollectionUtils&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt;&lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 复制集合-泛型&lt;br/&gt;     * target目标   src来源&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;copy&lt;/span&gt;&lt;span&gt;(List&amp;lt;? &lt;span&gt;super&lt;/span&gt; T&amp;gt;  target,List&amp;lt;? extends T&amp;gt; src)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (src.size() &amp;gt; target.size()){&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; src.size(); i++) {&lt;br/&gt;                target.set(i,src.get(i));&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] agrs)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    CollectionUtils&amp;lt;Father&amp;gt; collectionUtils = &lt;span&gt;new&lt;/span&gt; CollectionUtils&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    List&amp;lt;Father&amp;gt;  fatherTargets = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    List&amp;lt;Father&amp;gt;  fatherSources = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;//fatherSources.add...&lt;/span&gt;&lt;br/&gt;    collectionUtils.copy(fatherTargets,fatherSources);&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;//子类复制到父类&lt;/span&gt;&lt;br/&gt;    List&amp;lt;Son&amp;gt; sonSources = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;//sonSources.add...&lt;/span&gt;&lt;br/&gt;    collectionUtils.copy(fatherTargets,sonSources);&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;//把子类复制到父类的父类&lt;/span&gt;&lt;br/&gt;    List&amp;lt;Grandpa&amp;gt; grandpaTargets = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    collectionUtils.copy(grandpaTargets,sonSources);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;copy&lt;/code&gt;函数终于是完善了，可以说现在是真正支持父子类复制，不难发现&lt;code&gt;copy&lt;/code&gt;函数的设计还是遵循通配符原则的，&lt;code&gt;target&lt;/code&gt;作为目标集合，只做写入，符合只写不读原则，采用了下边界通配符，&lt;code&gt;src&lt;/code&gt;作为来源集合，只做读取，符合只读不写原则，采用了上边界通配符，最后设计出来的&lt;code&gt;copy&lt;/code&gt;函数，它的灵活性与适用范围是远超&lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt;方式设计的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后总结一下，什么时候用通配符，&lt;strong&gt;如果参数泛型类即要读也要写，那么就不推荐使用，使用正常的泛型即可，如果参数泛型类只读或写，就可以根据原则采用对应的上下边界&lt;/strong&gt;，是不是十分简单，最后再说一次读写的含义，这块确实很容易晕&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;读：所谓读是指参数泛型类，泛型只作为该参数类的函数返回类型，那这个函数就是读，&lt;code&gt;List&lt;/code&gt;作为参数泛型类，它的&lt;code&gt;get&lt;/code&gt;函数就是读&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;写：所谓写是指参数泛型类，泛型只作为该参数类的函数入参，那这个函数就是写，&lt;code&gt;List&lt;/code&gt;作为参数泛型类，它的&lt;code&gt;add&lt;/code&gt;函数就是读&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;留给小题，大家可以思考下&lt;code&gt;Stream&lt;/code&gt;的&lt;code&gt;forEach&lt;/code&gt;函数与&lt;code&gt;map&lt;/code&gt;函数的设计，在&lt;code&gt;Java1.8 Stream&lt;/code&gt;中是大量用到了通配符设计&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;-----------------------------------------------------------------&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 下边界通配符&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;forEach&lt;/span&gt;&lt;span&gt;(Consumer&amp;lt;? &lt;span&gt;super&lt;/span&gt; T&amp;gt; action)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Consumer&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//写方法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;accept&lt;/span&gt;&lt;span&gt;(T t)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;-----------------------------------------------------------------&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 上下边界通配符&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&amp;lt;R&amp;gt; &lt;span&gt;Stream&amp;lt;R&amp;gt; &lt;span&gt;map&lt;/span&gt;&lt;span&gt;(Function&amp;lt;? &lt;span&gt;super&lt;/span&gt; T, ? extends R&amp;gt; mapper)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; interface Function&amp;lt;T, R&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;     &lt;span&gt;//读写方法，T只作为入参符合写，R只作为返回值，符合读&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;R &lt;span&gt;apply&lt;/span&gt;&lt;span&gt;(T t)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;-----------------------------------------------------------------&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//代码案例&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] agrs)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;br/&gt;        List&amp;lt;Father&amp;gt; fatherList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;        &lt;br/&gt;        Consumer&amp;lt;? &lt;span&gt;super&lt;/span&gt; Father&amp;gt; action = &lt;span&gt;new&lt;/span&gt; Consumer&amp;lt;Father&amp;gt;() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;accept&lt;/span&gt;&lt;span&gt;(Father father)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;//执行father逻辑&lt;/span&gt;&lt;br/&gt;            }&lt;br/&gt;        };&lt;br/&gt;        &lt;br/&gt;         &lt;span&gt;//下边界通配符向上转型&lt;/span&gt;&lt;br/&gt;        Consumer&amp;lt;? &lt;span&gt;super&lt;/span&gt; Father&amp;gt; actionTwo = &lt;span&gt;new&lt;/span&gt; Consumer&amp;lt;Grandpa&amp;gt;() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;accept&lt;/span&gt;&lt;span&gt;(Grandpa grandpa)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;//执行grandpa逻辑&lt;/span&gt;&lt;br/&gt;            }&lt;br/&gt;        };&lt;br/&gt;        &lt;br/&gt;         Function&amp;lt;? &lt;span&gt;super&lt;/span&gt; Father, ? extends Grandpa&amp;gt; mapper = &lt;span&gt;new&lt;/span&gt; Function&amp;lt;Father, Grandpa&amp;gt;() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Grandpa &lt;span&gt;apply&lt;/span&gt;&lt;span&gt;(Father father)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;//执行father逻辑后返回Grandpa&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Grandpa();&lt;br/&gt;            }&lt;br/&gt;        };&lt;br/&gt;        &lt;br/&gt;        &lt;span&gt;//下边界通配符向上转型，上边界通配符向下转型&lt;/span&gt;&lt;br/&gt;         Function&amp;lt;? &lt;span&gt;super&lt;/span&gt; Father, ? extends Grandpa&amp;gt; mapperTwo = &lt;span&gt;new&lt;/span&gt; Function&amp;lt;Grandpa, Son&amp;gt;() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Son &lt;span&gt;apply&lt;/span&gt;&lt;span&gt;(Grandpa grandpa)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;//执行grandpa逻辑后，返回Son&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Son();&lt;br/&gt;            }&lt;br/&gt;        };&lt;br/&gt;        &lt;br/&gt;        fatherList.stream().forEach(action);&lt;br/&gt;        fatherList.stream().forEach(actionTwo);&lt;br/&gt;        &lt;br/&gt;        fatherList.stream().map(mapper);&lt;br/&gt;        fatherList.stream().map(mapperTwo);&lt;br/&gt;        &lt;br/&gt;    &lt;br/&gt;    }&lt;br/&gt;-----------------------------------------------------------------&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;有限制泛型场景&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有限制泛型很简单了，应用场景就是你需要对泛型的参数类型做限制，就可以使用它，比如下面这段代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;GenericClass&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Grandpa&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;   &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;span&gt;(T t)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//....&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] agrs)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    GenericClass&amp;lt;Grandpa&amp;gt; grandpaGeneric = &lt;span&gt;new&lt;/span&gt; GenericClass&amp;lt;&amp;gt;();&lt;br/&gt;    grandpaGeneric.test(&lt;span&gt;new&lt;/span&gt; Grandpa());&lt;br/&gt;    grandpaGeneric.test(&lt;span&gt;new&lt;/span&gt; Father());&lt;br/&gt;    grandpaGeneric.test(&lt;span&gt;new&lt;/span&gt; Son());&lt;br/&gt;    &lt;br/&gt;    GenericClass&amp;lt;Father&amp;gt; fatherGeneric = &lt;span&gt;new&lt;/span&gt; GenericClass&amp;lt;&amp;gt;();&lt;br/&gt;    fatherGeneric.test(&lt;span&gt;new&lt;/span&gt; Father());&lt;br/&gt;    fatherGeneric.test(&lt;span&gt;new&lt;/span&gt; Son());&lt;br/&gt;&lt;br/&gt;    GenericClass&amp;lt;Son&amp;gt; sonGeneric = &lt;span&gt;new&lt;/span&gt; GenericClass&amp;lt;&amp;gt;();&lt;br/&gt;    sonGeneric.test(&lt;span&gt;new&lt;/span&gt; Son());&lt;br/&gt;    &lt;br/&gt;    GenericClass&amp;lt;Object&amp;gt; ObjectGeneric = &lt;span&gt;new&lt;/span&gt; GenericClass&amp;lt;&amp;gt;();&lt;span&gt;//err 编译异常&lt;/span&gt;&lt;br/&gt;    &lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;GenericClass&lt;/code&gt;泛型参数化类型被限制为&lt;code&gt;Grandpa&lt;/code&gt;或其子类，就这么简单，千万不要把有限制泛型与上边界通配符搞混了，这两个不是同一个东西（&lt;code&gt;&amp;lt;T extends Grandpa&amp;gt; != &amp;lt;? extends Grandpa&amp;gt;&lt;/code&gt;），&lt;code&gt;&amp;lt;T extends Grandpa&amp;gt;&lt;/code&gt;不需要遵循上边界通配符的原则，它就是简单的泛型参数化类型限制，而且没有&lt;code&gt;super&lt;/code&gt;的写法。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;递归泛型场景&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在有限制泛型的基础上，又可以衍生出递归泛型，就是自身需要使用到自身，比如集合进行自定义元素大小比较的时候，通常会配合&lt;code&gt;Comparable&lt;/code&gt;接口来完成，看看下面这段代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Person&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Comparable&lt;/span&gt;&amp;lt;&lt;span&gt;Person&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; age;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Person&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; age)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.age = age;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;getAge&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; age;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;compareTo&lt;/span&gt;&lt;span&gt;(Person o)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 0代表相等 1代表大于  &amp;lt;0代表小于    &lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.age - o.age;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 集合工具&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CollectionUtils&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 获取集合最大值&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;  &amp;lt;E extends Comparable&amp;lt;E&amp;gt;&amp;gt; &lt;span&gt;E &lt;span&gt;max&lt;/span&gt;&lt;span&gt;(List&amp;lt;E&amp;gt; list)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        E result = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (E e : list) {&lt;br/&gt;             &lt;span&gt;if&lt;/span&gt; (result == &lt;span&gt;null&lt;/span&gt; || e.compareTo(result) &amp;gt; &lt;span&gt;0&lt;/span&gt;){&lt;br/&gt;                 result = e;&lt;br/&gt;             }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] agrs)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    List&amp;lt;Person&amp;gt; personList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    personList.add(&lt;span&gt;new&lt;/span&gt; Person(&lt;span&gt;12&lt;/span&gt;));&lt;br/&gt;    personList.add(&lt;span&gt;new&lt;/span&gt; Person(&lt;span&gt;19&lt;/span&gt;));&lt;br/&gt;    personList.add(&lt;span&gt;new&lt;/span&gt; Person(&lt;span&gt;20&lt;/span&gt;));&lt;br/&gt;    personList.add(&lt;span&gt;new&lt;/span&gt; Person(&lt;span&gt;5&lt;/span&gt;));&lt;br/&gt;    personList.add(&lt;span&gt;new&lt;/span&gt; Person(&lt;span&gt;18&lt;/span&gt;));&lt;br/&gt;    &lt;span&gt;//返回年龄最大的Person元素 &lt;/span&gt;&lt;br/&gt;    Person max = CollectionUtils.max(personList);&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重点关注&lt;code&gt;max&lt;/code&gt;泛型函数，&lt;code&gt;max&lt;/code&gt;泛型函数的目标是返回集合最大的元素，内部比较元素大小，取最大值返回，也就说需要和同类型元素做比较，&lt;code&gt;&amp;lt;E extends Comparable&amp;lt;E&amp;gt;&amp;gt;&lt;/code&gt;含义是，泛型&lt;code&gt;E&lt;/code&gt;必须是&lt;code&gt;Comparable&lt;/code&gt;或其子类/实现类，因为比较元素是同类型，所以&lt;code&gt;Comparable&lt;/code&gt;泛型也是&lt;code&gt;E&lt;/code&gt;,最终接收的&lt;code&gt;List&lt;/code&gt;泛型参数化类型必须实现了&lt;code&gt;Comparable&lt;/code&gt;接口，并且&lt;code&gt;Comparable&lt;/code&gt;接口填充的泛型也是该参数化类型，就像上述代码一样。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;关于我&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里是阿星，一个热爱技术的Java程序猿，在公众号  &lt;strong&gt;&lt;span&gt;「程序猿阿星」&lt;/span&gt;&lt;/strong&gt; 里将会定期分享操作系统、计算机网络、Java、分布式、数据库等精品原创文章，2021，与您在 Be Better 的路上共同成长！。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非常感谢各位人才能 看到这里，原创不易，文章有帮助可以「点个赞」或「分享与评论」，都是支持（莫要白嫖）！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;愿你我都能奔赴在各自想去的路上，我们下篇文章见！&lt;/p&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>73284fc8941ed16fcde4a5a0ec7a0586</guid>
<title>跟 Kafka 学技术系列之时间轮</title>
<link>https://toutiao.io/k/77iozz6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;src-views-article-detail-main-module__content--2qOBd markdown-body&quot;&gt;&lt;h1&gt;写在前面&lt;/h1&gt;
&lt;p&gt;kafka是一个分布式消息中间件，其高可用高吞吐的特点是大数据领域首选的消息中间件，Kafka是分布式消息队列的顺序读写文件分段组织串联起来思想的鼻祖，包括RocketMq这些消息队列都是借鉴了Kafka早期的架构和设计思路改造而来，所以在架构设计层面，Kafka有非常多值得借鉴的地方。本文是作者介绍Kafka优秀架构设计文章中的一篇，文中的代码和流程图均是base on 0.10.2.0版本。&lt;/p&gt;
&lt;h1&gt;引出环形队列和延迟队列&lt;/h1&gt;
&lt;p&gt;从2个面试题说起，第1个问题，如果一台机器上有10w个定时任务，如何做到高效触发？&lt;/p&gt;
&lt;p&gt;具体场景是：&lt;/p&gt;
&lt;p&gt;有一个APP实时消息通道系统，对每个用户会维护一个APP到服务器的TCP连接，用来实时收发消息，对这个TCP连接，有这样一个需求：“如果连续30s没有请求包（例如登录，消息，keepalive包），服务端就要将这个用户的状态置为离线”。&lt;/p&gt;
&lt;p&gt;其中，单机TCP同时在线量约在10w级别，keepalive请求包较分散大概30s一次，吞吐量约在3000qps。&lt;/p&gt;
&lt;p&gt;怎么做？&lt;/p&gt;
&lt;p&gt;常用方案使用time定时任务，每秒扫描一次所有连接的集合Map&amp;lt;uid, last_packet_time&amp;gt;，把连接时间（每次有新的请求更新对应连接的连接时间）比当前时间的差值大30s的连接找出来处理。&lt;/p&gt;
&lt;p&gt;另一种方案，使用环形队列法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200308202309477.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1poaVp1aUNodW5GZW5n,size_16,color_FFFFFF,t_70&quot; alt=&quot;小桔车服 &amp;gt; 跟Kafka学技术-时间轮 &amp;gt; image2020-1-17_16-20-37.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;三个重要的数据结构：&lt;/p&gt;
&lt;p&gt;1）30s超时，就创建一个index从0到30的环形队列（本质是个数组）&lt;/p&gt;
&lt;p&gt;2）环上每一个slot是一个Set&amp;lt;uid&amp;gt;，任务集合&lt;/p&gt;
&lt;p&gt;3）同时还有一个Map&amp;lt;uid, index&amp;gt;，记录uid落在环上的哪个slot里&lt;/p&gt;
&lt;p&gt;这样当有某用户uid有请求包到达时：&lt;/p&gt;
&lt;p&gt;1）从Map结构中，查找出这个uid存储在哪一个slot里&lt;/p&gt;
&lt;p&gt;2）从这个slot的Set结构中，删除这个uid&lt;/p&gt;
&lt;p&gt;3）将uid重新加入到新的slot中，具体是哪一个slot呢 =&amp;gt; Current Index指针所指向的上一个slot，因为这个slot，会被timer在30s之后扫描到&lt;/p&gt;
&lt;p&gt;4）更新Map，这个uid对应slot的index值&lt;/p&gt;
&lt;p&gt;哪些元素会被超时掉呢？&lt;/p&gt;
&lt;p&gt;Current Index每秒种移动一个slot，这个slot对应的Set&amp;lt;uid&amp;gt;中所有uid都应该被集体超时！如果最近30s有请求包来到，一定被放到Current Index的前一个slot了，Current Index所在的slot对应Set中所有元素，都是最近30s没有请求包来到的。&lt;/p&gt;
&lt;p&gt;所以，当没有超时时，Current Index扫到的每一个slot的Set中应该都没有元素。&lt;/p&gt;
&lt;p&gt;两种方案对比：&lt;/p&gt;
&lt;p&gt;方案一每次都要轮询所有数据，而方案二使用环形队列只需要轮询这一刻需要过期的数据，如果没有数据过期则没有数据要处理，并且是批量超时，并且由于是环形结构更加节约空间，这很适合高性能场景。&lt;/p&gt;
&lt;p&gt;第二个问题：在开发过程中有延迟一定时间的任务要执行，怎么做？&lt;/p&gt;
&lt;p&gt;如果不重复造轮子的话，我们的选择当然是延迟队列或者Timer。&lt;/p&gt;
&lt;p&gt;延迟队列和在Timer中增 加延时任务采用数组表示的最小堆的数据结构实现，每次放入新元素和移除队首元素时间复杂度为O(nlog(n))。&lt;/p&gt;
&lt;h1&gt;时间轮&lt;/h1&gt;
&lt;p&gt;方案二所采用的环形队列，就是时间轮的底层数据结构，它能够让需要处理的数据（任务的抽象）集中，在Kafka中存在大量的延迟操作，比如延迟生产、延迟拉取以及延迟删除等。Kafka并没有使用JDK自带的Timer或者DelayQueue来实现延迟的功能，而是基于时间轮自定义了一个用于实现延迟功能的定时器（SystemTimer）。JDK的Timer和DelayQueue插入和删除操作的平均时间复杂度为O(nlog(n))，并不能满足Kafka的高性能要求，而基于时间轮可以将插入和删除操作的时间复杂度都降为O(1)。时间轮的应用并非Kafka独有，其应用场景还有很多，在Netty、Akka、Quartz、Zookeeper等组件中都存在时间轮的踪影。&lt;/p&gt;
&lt;h2&gt;时间轮的数据结构&lt;/h2&gt;
&lt;p&gt;参考下图，Kafka中的时间轮（TimingWheel）是一个存储定时任务的环形队列，底层采用数组实现，数组中的每个元素可以存放一个定时任务列表（TimerTaskList）。TimerTaskList是一个环形的双向链表，链表中的每一项表示的都是定时任务项（TimerTaskEntry），其中封装了真正的定时任务TimerTask。在Kafka源码中对这个TimeTaskList是用一个名称为buckets的数组表示的，所以后面介绍中可能TimerTaskList也会被称为bucket。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200308202645122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1poaVp1aUNodW5GZW5n,size_16,color_FFFFFF,t_70&quot; alt=&quot;时间轮组成&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;时间轮相关名词解释&lt;/h2&gt;
&lt;p&gt;tickMs：时间轮由多个时间格组成，每个时间格就是tickMs，它代表当前时间轮的基本时间跨度。&lt;/p&gt;
&lt;p&gt;wheelSize：代表每一层时间轮的格数&lt;/p&gt;
&lt;p&gt;interval：当前时间轮的总体时间跨度，interval=tickMs × wheelSize&lt;/p&gt;
&lt;p&gt;startMs：构造当层时间轮时候的当前时间，第一层的时间轮的startMs是TimeUnit.NANOSECONDS.toMillis(nanoseconds()),上层时间轮的startMs为下层时间轮的currentTime。&lt;/p&gt;
&lt;p&gt;currentTime：表示时间轮当前所处的时间，currentTime是tickMs的整数倍（通过currentTime=startMs - (startMs % tickMs来保正currentTime一定是tickMs的整数倍），这个运算类比钟表中分钟里65秒分针指针指向的还是1分钟）。currentTime可以将整个时间轮划分为到期部分和未到期部分，currentTime当前指向的时间格也属于到期部分，表示刚好到期，需要处理此时间格所对应的TimerTaskList的所有任务。&lt;/p&gt;
&lt;h2&gt;时间轮中的任务存放&lt;/h2&gt;
&lt;p&gt;若时间轮的tickMs=1ms，wheelSize=20，那么可以计算得出interval为20ms。初始情况下表盘指针currentTime指向时间格0，此时有一个定时为2ms的任务插入进来会存放到时间格为2的TimerTaskList中。随着时间的不断推移，指针currentTime不断向前推进，过了2ms之后，当到达时间格2时，就需要将时间格2所对应的TimeTaskList中的任务做相应的到期操作。此时若又有一个定时为8ms的任务插入进来，则会存放到时间格10中，currentTime再过8ms后会指向时间格10。如果同时有一个定时为19ms的任务插入进来怎么办？新来的TimerTaskEntry会复用原来的TimerTaskList，所以它会插入到原本已经到期的时间格1中。总之，整个时间轮的总体跨度是不变的，随着指针currentTime的不断推进，当前时间轮所能处理的时间段也在不断后移，总体时间范围在currentTime和currentTime+interval之间。&lt;/p&gt;
&lt;h2&gt;时间轮的升降级&lt;/h2&gt;
&lt;p&gt;如果此时有个定时为350ms的任务该如何处理？直接扩充wheelSize的大小么？Kafka中不乏几万甚至几十万毫秒的定时任务，这个wheelSize的扩充没有底线，就算将所有的定时任务的到期时间都设定一个上限，比如100万毫秒，那么这个wheelSize为100万毫秒的时间轮不仅占用很大的内存空间，而且效率也会拉低。Kafka为此引入了层级时间轮的概念，当任务的到期时间超过了当前时间轮所表示的时间范围时，就会尝试添加到上层时间轮中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200308202605415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1poaVp1aUNodW5GZW5n,size_16,color_FFFFFF,t_70&quot; alt=&quot;时间轮升降级&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参考上图，复用之前的案例，第一层的时间轮tickMs=1ms, wheelSize=20, interval=20ms。第二层的时间轮的tickMs为第一层时间轮的interval，即为20ms。每一层时间轮的wheelSize是固定的，都是20，那么第二层的时间轮的总体时间跨度interval为400ms。以此类推，这个400ms也是第三层的tickMs的大小，第三层的时间轮的总体时间跨度为8000ms。&lt;br/&gt;
刚才提到的350ms的任务，不会插入到第一层时间轮，会插入到interval=20*20的第二层时间轮中，具体插入到时间轮的哪个bucket呢？先用350/tickMs(20)=virtualId(17)，然后virtualId(17) %wheelSize (20) = 17，所以350会放在第17个bucket。如果此时有一个450ms后执行的任务，那么会放在第三层时间轮中，按照刚才的计算公式，会放在第0个bucket。第0个bucket里会包含&lt;/p&gt;
&lt;p&gt;[400,800)ms的任务。随着时间流逝，当时间过去了400ms，那么450ms后就要执行的任务还剩下50ms的时间才能执行，此时有一个时间轮降级的操作，将50ms任务重新提交到层级时间轮中，那么此时50ms的任务根据公式会放入第二个时间轮的第2个bucket中，此bucket的时间范围为[40,60)ms，然后再经过40ms，这个50ms的任务又会被监控到，此时距离任务执行还有10ms，同样将10ms的任务提交到层级时间轮，此时会加入到第一层时间轮的第10个bucket，所以再经过10ms后，此任务到期，最终执行。&lt;/p&gt;
&lt;p&gt;整个时间轮的升级降级操作是不是很类似于我们的时钟？ 第一层时间轮tickMs=1s, wheelSize=60，interval=1min，此为秒钟；第二层tickMs=1min，wheelSize=60，interval=1hour，此为分钟；第三层tickMs=1hour，wheelSize为12，interval为12hours，此为时钟。而钟表的指针就对应程序中的currentTime，这个后面分析代码时候会讲到（对这个的理解也是时间轮理解的重点和难点）。&lt;/p&gt;
&lt;p&gt;Kafka中任务添加和驱动时间轮滚动的核心流程：&lt;br/&gt;
&lt;img src=&quot;https://img-blog.csdnimg.cn/20200308202809831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1poaVp1aUNodW5GZW5n,size_16,color_FFFFFF,t_70&quot; alt=&quot;任务添加和驱动时间轮滚动核心流程图&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;重点代码介绍&lt;/h2&gt;
&lt;p&gt;这是往SystenTimer中添加一个任务&lt;/p&gt;
&lt;pre class=&quot;hljs&quot;&gt;&lt;code class=&quot;hljs-code-wrap&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;//在Systemtimer中添加一个任务，任务被包装为一个TimerTaskEntry&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; def &lt;span class=&quot;hljs-title&quot;&gt;addTimerTaskEntry&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(timerTaskEntry: TimerTaskEntry)&lt;/span&gt;: Unit &lt;/span&gt;= {
&lt;span class=&quot;hljs-comment&quot;&gt;//先判断是否可以添加进时间轮中，如果不可以添加进去代表任务已经过期或者任务被取消，注意这里的timingWheel持有上一层时间轮的引用，所以可能存在递归调用&lt;/span&gt;
  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (!timingWheel.add(timerTaskEntry)) {
    &lt;span class=&quot;hljs-comment&quot;&gt;// Already expired or cancelled&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (!timerTaskEntry.cancelled)
     &lt;span class=&quot;hljs-comment&quot;&gt;//过期任务直接线程池异步执行掉&lt;/span&gt;
      taskExecutor.submit(timerTaskEntry.timerTask)
  }
}
&lt;/code&gt;&lt;button class=&quot;pre-button&quot;&gt;复制&lt;/button&gt;&lt;/pre&gt;
&lt;p&gt;timingWheel添加任务，递归添加直到添加该任务进合适的时间轮的bucket中&lt;/p&gt;
&lt;pre class=&quot;hljs&quot;&gt;&lt;code class=&quot;hljs-code-wrap&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(timerTaskEntry: TimerTaskEntry)&lt;/span&gt;: Boolean &lt;/span&gt;= {
  val expiration = timerTaskEntry.expirationMs
  &lt;span class=&quot;hljs-comment&quot;&gt;//任务取消&lt;/span&gt;
  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (timerTaskEntry.cancelled) {
    &lt;span class=&quot;hljs-comment&quot;&gt;// Cancelled&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;false&lt;/span&gt;
  } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (expiration &amp;lt; currentTime + tickMs) {
    &lt;span class=&quot;hljs-comment&quot;&gt;// 任务过期后会被执行&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;false&lt;/span&gt;
  } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (expiration &amp;lt; currentTime + interval) {&lt;span class=&quot;hljs-comment&quot;&gt;//任务过期时间比当前时间轮时间加周期小说明任务过期时间在本时间轮周期内&lt;/span&gt;
    val virtualId = expiration / tickMs
    &lt;span class=&quot;hljs-comment&quot;&gt;//找到任务对应本时间轮的bucket&lt;/span&gt;
    val bucket = buckets((virtualId % wheelSize.toLong).toInt)
    bucket.add(timerTaskEntry)
    &lt;span class=&quot;hljs-comment&quot;&gt;// Set the bucket expiration time&lt;/span&gt;
   &lt;span class=&quot;hljs-comment&quot;&gt;//只有本bucket内的任务都过期后才会bucket.setExpiration返回true此时将bucket放入延迟队列&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (bucket.setExpiration(virtualId * tickMs)) {
     &lt;span class=&quot;hljs-comment&quot;&gt;//bucket是一个TimerTaskList，它实现了java.util.concurrent.Delayed接口，里面是一个多任务组成的链表，图2有说明&lt;/span&gt;
      queue.offer(bucket)
    }
    &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;
  } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {
    &lt;span class=&quot;hljs-comment&quot;&gt;// Out of the interval. Put it into the parent timer&lt;/span&gt;
    &lt;span class=&quot;hljs-comment&quot;&gt;//任务的过期时间不在本时间轮周期内说明需要升级时间轮，如果不存在则构造上一层时间轮，继续用上一层时间轮添加任务&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (overflowWheel == &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) addOverflowWheel()
    overflowWheel.add(timerTaskEntry)
  }
}

&lt;/code&gt;&lt;button class=&quot;pre-button&quot;&gt;复制&lt;/button&gt;&lt;/pre&gt;
&lt;p&gt;在本层级时间轮里添加上一层时间轮里的过程，注意的是在下一层时间轮的interval为上一层时间轮的tickMs&lt;/p&gt;
&lt;pre class=&quot;hljs&quot;&gt;&lt;code class=&quot;hljs-code-wrap&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt;[&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;] &lt;span class=&quot;hljs-function&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;addOverflowWheel&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;: Unit &lt;/span&gt;= {
  &lt;span class=&quot;hljs-keyword&quot;&gt;synchronized&lt;/span&gt; {
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (overflowWheel == &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {
      overflowWheel = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; TimingWheel(
        tickMs = interval,
        wheelSize = wheelSize,
        startMs = currentTime,
        taskCounter = taskCounter,
        queue
      )
    }
  }
}
&lt;/code&gt;&lt;button class=&quot;pre-button&quot;&gt;复制&lt;/button&gt;&lt;/pre&gt;
&lt;p&gt;驱动时间轮滚动过程：&lt;/p&gt;
&lt;pre class=&quot;hljs&quot;&gt;&lt;code class=&quot;hljs-code-wrap&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;//注意这里会存在一个递归，一直驱动时间轮的指针滚动直到时间不足于驱动上层的时间轮滚动。&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;advanceClock&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(timeMs: Long)&lt;/span&gt;: Unit &lt;/span&gt;= {
  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (timeMs &amp;gt;= currentTime + tickMs) {
   &lt;span class=&quot;hljs-comment&quot;&gt;//把当前时间打平为时间轮tickMs的整数倍&lt;/span&gt;
    currentTime = timeMs - (timeMs % tickMs)
    &lt;span class=&quot;hljs-comment&quot;&gt;// Try to advance the clock of the overflow wheel if present&lt;/span&gt;
    &lt;span class=&quot;hljs-comment&quot;&gt;//驱动上层时间轮，这里的传给上层的currentTime时间是本层时间轮打平过的，但是在上层时间轮还是会继续打平&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (overflowWheel != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) overflowWheel.advanceClock(currentTime)
  }
}
&lt;/code&gt;&lt;button class=&quot;pre-button&quot;&gt;复制&lt;/button&gt;&lt;/pre&gt;
&lt;p&gt;这里是驱动源代码：&lt;/p&gt;
&lt;pre class=&quot;hljs&quot;&gt;&lt;code class=&quot;hljs-code-wrap&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;//循环bucket里面的任务列表，一个个重新添加进时间轮，对符合条件的时间轮进行升降级或者执行任务&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt;[&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;] val reinsert = (timerTaskEntry: TimerTaskEntry) =&amp;gt; addTimerTaskEntry(timerTaskEntry)
 
&lt;span class=&quot;hljs-comment&quot;&gt;/*
 * Advances the clock if there is an expired bucket. If there isn&#x27;t any expired bucket when called,
 * waits up to timeoutMs before giving up.
 */&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;advanceClock&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(timeoutMs: Long)&lt;/span&gt;: Boolean &lt;/span&gt;= {
  &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; bucket = delayQueue.poll(timeoutMs, TimeUnit.MILLISECONDS)
  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (bucket != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {
    writeLock.lock()
    &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {
      &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (bucket != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {
        &lt;span class=&quot;hljs-comment&quot;&gt;//驱动时间轮&lt;/span&gt;
        timingWheel.advanceClock(bucket.getExpiration())
       &lt;span class=&quot;hljs-comment&quot;&gt;//循环buckek也就是任务列表，任务列表一个个继续添加进时间轮以此来升级或者降级时间轮，把过期任务找出来执行&lt;/span&gt;
        bucket.flush(reinsert)
       &lt;span class=&quot;hljs-comment&quot;&gt;//循环&lt;/span&gt;
        &lt;span class=&quot;hljs-comment&quot;&gt;//这里就是从延迟队列取出bucket，bucket是有延迟时间的，取出代表该bucket过期，我们通过bucket能取到bucket包含的任务列表&lt;/span&gt;
        bucket = delayQueue.poll()
      }
    } &lt;span class=&quot;hljs-keyword&quot;&gt;finally&lt;/span&gt; {
      writeLock.unlock()
    }
    &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;
  } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {
    &lt;span class=&quot;hljs-keyword&quot;&gt;false&lt;/span&gt;
  }
}
&lt;/code&gt;&lt;button class=&quot;pre-button&quot;&gt;复制&lt;/button&gt;&lt;/pre&gt;
&lt;h1&gt;总结&lt;/h1&gt;
&lt;p&gt;kafka的延迟队列使用时间轮实现，能够支持大量任务的高效触发，但是在kafka延迟队列实现方案里还是看到了delayQueue的影子，使用delayQueue是对时间轮里面的bucket放入延迟队列，以此来推动时间轮滚动，但是基于将插入和删除操作则放入时间轮中，将这些操作的时间复杂度都降为O(1)，提升效率。Kafka对性能的极致追求让它把最合适的组件放在最适合的位置。&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1a7042456df2dd7be4f4a3c2fd526ded</guid>
<title>Elasticsearch 架构选型指南：不止是搜索引擎，还有......</title>
<link>https://toutiao.io/k/j0yifcz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近被咨询到“ETC 卡口数据的存储以及车流量分析、车路线分析业务场景是否适合 Elasticsearch 去做”的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题涉及 Elasticsearch 架构选型的问题，而追根究底是：Elasticsearch 适合的业务场景的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;记得我在做内部技术分享的时候，讲解 Elasticsearch 应用场景，就铺了3 页 PPT：搜索服务场景、日志实时分析场景、商业智能 BI 场景。我拿着初稿找同事讨论，我心想：“没毛病啊？！Elastic 官方、阿里云、腾讯云、金山云、京东云、百度云等介绍 Elasticsearch 都是这么说的。”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同事一句话点醒了我：“是不是应该加上 Elasticsearch 不适合做什么？”，“我大呼：搜戴斯乃（原来如此）”。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1、Elasticsearch 不适合做什么？&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.1 不支持事务&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不支持：ACID（在写入或更新数据的过程中，为保证事务（transaction）是正确可靠的，所必须具备的四个特性：原子性（atomicity，或称不可分割性）、一致性（consistency）、隔离性（isolation，又称独立性）、持久性（durability））。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果要有强一致场景，如：银行业务，还得采购 Oracle 等大型商业数据库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;据我不完整了解：银行使用 Elasticsearch 一般和系统日志统一规范、存储和检索、自动化运维相关，而非存储核心金融交易数据。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2 多表关联有限&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为习惯了：Mysql 多表通过外键关联检索，不免会将 Mysql 思维平移到 Elasticsearch。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的实战多表关联问题如下：“
一般大in的场景有好的解决方案么？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;比如：连锁 一个人管理了1000家门店 要去查自己管辖的商品。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;比如：企微 一个人维护了 1000个员工 要去查自己管辖的员工。”&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Elasticsearch 多表关联的解决方案一般概括如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;宽表：适合增加冗余存储、空间换时间场景。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;nested 类型：适合子文档偶尔更新、查询频繁场景。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Join 父子文档类型：适合子文档频繁更新频繁场景。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正如官方文档所说：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“In particular, joins should be avoided. nested can make queries several times slower and parent-child relations can make queries hundreds of times slower.  ”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官方在数据建模部分强调：“应该避免关联。嵌套可以使查询速度慢几倍，父子关系可以使查询速度慢数百倍。因此，若能使用宽表，可以明显加速。”&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.3 不支持准实时&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;refresh_interval 刷新频率决定近实时而非准实时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;腾讯云黄华老师的分享《腾讯Elasticsearch海量规模背后的内核优化剖析》中强调：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“ES 是一个实时的分布式搜索分析引擎，目前很多用户对 ES 的印象还是准实时，实际上在6.8版本之后官方文档已经将 near real-time 改为了 real-time”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们直接看一下6.8版本——7.6版本官方文档的说法，的确如黄老师所说：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&quot;Elasticsearch provides real-time search and analytics for all types of data.&quot;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ES 在写入完毕刷新之前，是可以通过 getById 的方式实时获取文档的，只是在刷新之前 FST 还没有构建，还不能提供搜索的能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，7.7版本——7.13版本（截止：2021-06-17最新版本）又改成：“Elasticsearch provides &lt;span&gt;&lt;strong&gt;&lt;span&gt;near&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; real-time search and analytics for all types of data. ”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再一次改回原来的说法，说明：官方文档严谨性拿捏的很到位！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;近实时而非准实时说法没毛病。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;7.13 版本官方文档地址：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;https://www.elastic.co/guide/en/elasticsearch/reference/7.13/elasticsearch-intro.html#elasticsearch-intro&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.4 高阶功能收费&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如：机器学习、Kerberos 安全认证、JDBC 客户端、ODBC客户端、Graph 探索、威胁猎捕等高阶功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是主流开源上市公司的收费模式，MongoDB、Confluent、Elastic 皆是如此。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开源版、基础版、黄金版、白金版、企业版的区别和差异，查看地址（要做到必知必会）：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;https://www.elastic.co/cn/subscriptions&lt;/span&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2、Elasticsearch 认知升级&lt;/span&gt;&lt;/h1&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1 Elasticsearch 早已不仅是搜索引擎了&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2418230563002681&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9ZcNaUFJicbnBibErEsESYE1DU8Dx0xArHVA7eJNazNror4sLKr8udMbnvXHZQ6M5Tbqj8z5RbuC0UQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1865&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以 Elasticsearch 起家，发展到：集成 Elasticsearch、Logstash、Beats、Kibana 四位一体的“全家桶”。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Elasticsearch：搜索和分析引擎。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Logstash：数据处理管道，能够同时从多个来源采集数据，转换数据，然后将数据发送到诸如 Elasticsearch 等“存储库”中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Beats：一系列轻量型的单一功能数据采集器（包含：Metricbeat、Filebeat等100多种）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Kibana ：使用图形和图表对Elasticsearch数据进行可视化和探索分析。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2 Elasticsearch 早已不单单局限搜索场景&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Elasticsearch 发展战略也在随&lt;span&gt;势&lt;/span&gt;而变。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6293103448275862&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9ZcNaUFJicbnBibErEsESYE1D6icbh5scF8qyNsBgH0n1jDW0KsL3icVNIfa9hs0licYBFQGnCh5jf1hibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1044&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“3 + 1战略”——是指在Elastic Stack 基础上在Elastic 企业搜索、Elastic 全观察、Elastic 安全三个核心业务场景发力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Elastic 已经由原来的 Elasticsearch 检索工具转变为 Elastic Stack 解决方案提供商。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;https://www.elastic.co/cn/products/&lt;/span&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3、Elasticsearch 业务场景&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是建议过一下官方文档关于 “ &lt;span&gt;What is Elasticsearch ? &lt;/span&gt;”的介绍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要强调的点如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;slogon 加了分析：由原来的“You know, for search” 改成 “You know, for search (&lt;span&gt;&lt;strong&gt;&lt;span&gt;and analysis&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;)”。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Elasticsearch 是位于 Elastic Stack 核心的分布式搜索和分析引擎。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Elasticsearch 为所有类型的数据提供高效存储和索引、近乎实时的搜索和分析。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所有都指哪些？主要指：结构化文本、非结构化文本、数值数据、地理空间数据等。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Elasticsearch 的分布式特性、横向扩展能力可以应对数据、查询量的增长。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Elasticsearch 提供了在各种用例中处理数据的速度和灵活性，尽管并非所有问题都是搜索问题。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官方明确点出的几种场景总结如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;（1）支持各类应用、网站等的全文搜索。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;（2）存储和分析日志、指标和安全事件数据。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;（3）使用机器学习实时自动建模数据的行为。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;（4）使用 Elasticsearch 作为存储引擎自动化业务工作流。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;（5）使用 Elasticsearch 作为地理信息系统 (GIS) 管理、集成和分析空间信息。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我也不免俗，将开头提及的：搜索服务场景、日志实时分析 场景、商业智能 BI 场景以截图的形式提供给大家，更直观一些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下三页 PPT 截图是基于腾讯云的分享结合了：官方文档、各大云厂商介绍结合我的理解进行了整合梳理。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1 场景1：搜索服务&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1.1 典型场景&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1.2 主要特性&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;高性能：高并发、低延迟的搜索体验&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;强相关：自定义打分、排序机制&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;高可用：机房、机架感知，异地容灾&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1.3 相关公司&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;腾讯健康码、腾讯文档全文检索、携程、拼多多、蘑菇街、滴滴、今日头条、贝壳找房…….&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5484546883184913&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9ZcNaUFJicbnBibErEsESYE1DA1Qibc3JxrE5TgNoklzfpIRNicuQI5bDmqaEAAicS1NnaxohoAuvIR4qw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1909&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2 场景2：日志实时分析&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2.1 典型场景&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;业务日志：用户行为日志、应用日志&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;状态日志：慢查询、异常探测&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;系统日志：debug、info、warn、error、fatal&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2.2 主要特性&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;实时性：从日志产生到可访问，秒级&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;全文搜索：基于倒排索引，支持灵活的搜索分析&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;交互式分析：万亿级日志，搜索秒级响应&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2.3 相关公司&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;日志易等&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5450755601875977&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9ZcNaUFJicbnBibErEsESYE1Dlp2XofmibFeEfeF0ExspcLD1MNiaNzV4JDiaBTXib0k0PtIh9rd5PjSR3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1919&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3 场景3：商业智能BI&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.3.1 典型场景&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;电子商务、移动应用、广告媒体等业务都需要借助数据分析和数据挖掘来辅助商业决策，而规模庞大的业务数据对数据的统计分析造成了很大的挑战。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.3.2 主要特性&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ES 拥有结构化查询的能力，支持复杂的过滤和聚合统计功能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;帮助客户对海量数据进行高效地个性化统计分析、发现问题与机会、辅助商业决策，让数据产生真正的价值。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.3.3 相关公司&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;睿思BI 等。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5483028720626631&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9ZcNaUFJicbnBibErEsESYE1DkwtiaUcT04SmoO8Mmib8JHhibGCBr0iavcJNsMpWYKQbPP8tGbTJariczsw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1915&quot;/&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4、小结&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我的座右铭之一：“自由不是你想干什么就干什么，而是你不想干什么就有能力不干什么！”。可见：不想干什么较想干什么更为牛逼。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而选型 Elasticsearch 的时候也要注意：它不能干什么或者它不擅长需要优先考虑，而将它擅长的、能干什么的方面发挥到极致是我们架构选型及后续实战方面要多考虑的因素。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你在架构选型方面还考虑哪些因素？欢迎留言交流分享实战心得。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>104d450b8279d6693d005611b075df60</guid>
<title>Unicode、UTF-8、UTF-16，终于懂了</title>
<link>https://toutiao.io/k/0lc2auk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-source-line=&quot;1&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;计算机起源于美国，上个世纪，他们对英语字符与二进制位之间的关系做了统一规定，并制定了一套字符编码规则，这套编码规则被称为ASCII编码&lt;/p&gt;&lt;p data-source-line=&quot;5&quot;&gt;ASCII 编码一共定义了128个字符的编码规则，用七位二进制表示 ( 0x00 - 0x7F ), 这些字符组成的集合就叫做 ASCII 字符集&lt;/p&gt;&lt;p data-source-line=&quot;8&quot;&gt;随着计算机的普及，在不同的地区和国家又出现了很多字符编码，比如: 大陆的 GB2312、港台的 BIG5, 日本的 Shift JIS等等&lt;/p&gt;&lt;p data-source-line=&quot;11&quot;&gt;由于字符编码不同，计算机在不同国家之间的交流变得很困难，经常会出现乱码的问题，比如：对于同一个二进制数据，不同的编码会解析出不同的字符&lt;/p&gt;&lt;p data-source-line=&quot;14&quot;&gt;当互联网迅猛发展，地域限制打破之后，人们迫切的希望有一种统一的规则, 对所有国家和地区的字符进行编码，于是 Unicode 就出现了&lt;/p&gt;&lt;h3 data-source-line=&quot;18&quot;&gt;&lt;span&gt;Unicode 简介&lt;/span&gt;&lt;/h3&gt;&lt;p data-source-line=&quot;20&quot;&gt;Unicode 是国际标准字符集，它将世界各种语言的每个字符定义一个唯一的编码，以满足跨语言、跨平台的文本信息转换&lt;/p&gt;&lt;p data-source-line=&quot;23&quot;&gt;Unicode 字符集的编码范围是 &lt;span&gt;&lt;span&gt;0x0000 - 0x10FFFF&lt;/span&gt;&lt;/span&gt; , 可以容纳一百多万个字符， 每个字符都有一个独一无二的编码，也即每个字符都有一个二进制数值和它对应，这里的二进制数值也叫 &lt;span&gt;&lt;span&gt;码点&lt;/span&gt;&lt;/span&gt; , 比如：汉字 &lt;span&gt;&lt;span&gt;&quot;中&quot;&lt;/span&gt;&lt;/span&gt; 的 码点是 &lt;span&gt;&lt;span&gt;0x4E2D&lt;/span&gt;&lt;/span&gt;, 大写字母 &lt;span&gt;&lt;span&gt;A&lt;/span&gt;&lt;/span&gt; 的码点是 &lt;span&gt;&lt;span&gt;0x41&lt;/span&gt;&lt;/span&gt;, 具体字符对应的 Unicode 编码可以查询 Unicode字符编码表&lt;/p&gt;&lt;h3 data-source-line=&quot;27&quot;&gt;&lt;span&gt;字符集和字符编码&lt;/span&gt;&lt;/h3&gt;&lt;p data-source-line=&quot;29&quot;&gt;字符集是很多个字符的集合，例如 GB2312 是简体中文的字符集，它收录了六千多个常用的简体汉字及一些符号，数字，拼音等字符&lt;/p&gt;&lt;p data-source-line=&quot;31&quot;&gt;字符编码是 字符集的一种实现方式，把字符集中的字符映射为特定的字节或字节序列，它是一种规则&lt;/p&gt;&lt;p data-source-line=&quot;33&quot;&gt;比如：Unicode 只是字符集，UTF-8、UTF-16、UTF-32 才是真正的字符编码规则&lt;/p&gt;&lt;h3 data-source-line=&quot;36&quot;&gt;&lt;span&gt;Unicode 字符存储&lt;/span&gt;&lt;/h3&gt;&lt;p data-source-line=&quot;38&quot;&gt;Unicode 是一个符号集， 它只规定了每个符号的二进制值，但是符号具体如何存储它并没有规定&lt;/p&gt;&lt;p data-source-line=&quot;40&quot;&gt;前面提到, Unicode 字符集的编码范围是 &lt;span&gt;&lt;span&gt;0x0000 - 0x10FFFF&lt;/span&gt;&lt;/span&gt;，因此需要 1 到 3 个字节来表示&lt;/p&gt;&lt;p data-source-line=&quot;42&quot;&gt;那么，对于三个字节的 Unicode字符，计算机怎么知道它表示的是一个字符而不是三个字符呢 ？&lt;/p&gt;&lt;p data-source-line=&quot;44&quot;&gt;如果所有字符都用三个字节表示，那么对于那些一个字节就能表示的字符来说，有两个字节是无意义的，对于存储来说，这是极大的浪费，假如 , 一个普通的文本, 大部分字符都只需一个字节就能表示，现在如果需要三个字节才能表示，文本的大小会大出三倍左右&lt;/p&gt;&lt;p data-source-line=&quot;47&quot;&gt;因此，Unicode 出现了多种存储方式，常见的有 UTF-8、UTF-16、UTF-32，它们分别用不同的二进制格式来表示 Unicode 字符&lt;/p&gt;&lt;p data-source-line=&quot;49&quot;&gt;UTF-8、UTF-16、UTF-32 中的 &quot;UTF&quot; 是 &quot;Unicode Transformation Format&quot; 的缩写，意思是&quot;Unicode 转换格式&quot;，后面的数 字表明至少使用多少个比特位来存储字符, 比如：UTF-8 最少需要8个比特位也就是一个字节来存储，对应的， UTF-16 和 UTF-32 分别需要最少 2 个字节 和 4 个字节来存储&lt;/p&gt;&lt;h3 data-source-line=&quot;54&quot;&gt;&lt;span&gt;UTF-8 编码&lt;/span&gt;&lt;/h3&gt;&lt;p data-source-line=&quot;56&quot;&gt;UTF-8: 是一种变长字符编码，被定义为将码点编码为 1 至 4 个字节，具体取决于码点数值中有效二进制位的数量&lt;/p&gt;&lt;p data-source-line=&quot;58&quot;&gt;UTF-8 的编码规则:&lt;/p&gt;&lt;ol start=&quot;0&quot; data-source-line=&quot;60&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;对于单字节的符号，字节的第一位设为 &lt;span&gt;&lt;span&gt;0&lt;/span&gt;&lt;/span&gt;，后面 7 位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的, 所以 UTF-8 能兼容 ASCII 编码，这也是互联网普遍采用 UTF-8 的原因之一&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;2&quot; data-source-line=&quot;63&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;对于 &lt;span&gt;&lt;span&gt;n&lt;/span&gt;&lt;/span&gt; 字节的符号（ &lt;span&gt;&lt;span&gt;n &amp;gt; 1&lt;/span&gt;&lt;/span&gt;），第一个字节的前 &lt;span&gt;&lt;span&gt;n&lt;/span&gt;&lt;/span&gt; 位都设为 &lt;span&gt;&lt;span&gt;1&lt;/span&gt;&lt;/span&gt;，第 &lt;span&gt;&lt;span&gt;n + 1&lt;/span&gt;&lt;/span&gt; 位设为 &lt;span&gt;&lt;span&gt;0&lt;/span&gt;&lt;/span&gt;，后面字节的前两位一律设为 &lt;span&gt;&lt;span&gt;10&lt;/span&gt;&lt;/span&gt; 。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-source-line=&quot;66&quot;&gt;下表是Unicode编码对应UTF-8需要的字节数量以及编码格式&lt;/p&gt;&lt;table data-source-line=&quot;69&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Unicode编码范围(16进制)&lt;/th&gt;&lt;th&gt;UTF-8编码方式(二进制)&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;000000 - 00007F&lt;/td&gt;&lt;td&gt;&lt;span&gt;&lt;span&gt;0&lt;/span&gt;&lt;/span&gt;xxxxxxx &lt;span&gt;ASCII码&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;000080 - 0007FF&lt;/td&gt;&lt;td&gt;&lt;span&gt;&lt;span&gt;110&lt;/span&gt;&lt;/span&gt;xxxxx &lt;span&gt;&lt;span&gt;10&lt;/span&gt;&lt;/span&gt;xxxxxx&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;000800 - 00FFFF&lt;/td&gt;&lt;td&gt;&lt;span&gt;&lt;span&gt;1110&lt;/span&gt;&lt;/span&gt;xxxx &lt;span&gt;&lt;span&gt;10&lt;/span&gt;&lt;/span&gt;xxxxxx &lt;span&gt;&lt;span&gt;10&lt;/span&gt;&lt;/span&gt;xxxxxx&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;01 0000 - 10 FFFF&lt;/td&gt;&lt;td&gt;&lt;span&gt;&lt;span&gt;11110&lt;/span&gt;&lt;/span&gt;xxx &lt;span&gt;&lt;span&gt;10&lt;/span&gt;&lt;/span&gt;xxxxxx &lt;span&gt;&lt;span&gt;10&lt;/span&gt;&lt;/span&gt;xxxxxx &lt;span&gt;&lt;span&gt;10&lt;/span&gt;&lt;/span&gt;xxxxxx&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p data-source-line=&quot;77&quot;&gt;表格中第一列是Unicode编码的范围，第二列是对应UTF-8编码方式，其中红色的二进制 &lt;span&gt;&lt;span&gt;&quot;1&quot;&lt;/span&gt;&lt;/span&gt; 和 &lt;span&gt;&lt;span&gt;&quot;0&quot;&lt;/span&gt;&lt;/span&gt; 是固定的前缀, 字母 &lt;span&gt;&lt;span&gt;x&lt;/span&gt;&lt;/span&gt; 表示可用编码的二进制位&lt;/p&gt;&lt;p data-source-line=&quot;79&quot;&gt;根据上面表格，要解析 UTF-8 编码就很简单了，如果一个字节第一位是 &lt;span&gt;&lt;span&gt;0&lt;/span&gt;&lt;/span&gt; ，则这个字节就是一个单独的字符，如果第一位是 &lt;span&gt;&lt;span&gt;1&lt;/span&gt;&lt;/span&gt; ，则连续有多少个 &lt;span&gt;&lt;span&gt;1&lt;/span&gt;&lt;/span&gt; ，就表示当前字符占用多少个字节&lt;/p&gt;&lt;p data-source-line=&quot;82&quot;&gt;下面以 &lt;span&gt;&lt;span&gt;&quot;中&quot;&lt;/span&gt;&lt;/span&gt; 字 为例来说明 UTF-8 的编码，具体的步骤如下图， 为了便于说明，图中左边加了 &lt;code&gt;1，2，3，4&lt;/code&gt; 的步骤编号&lt;/p&gt;&lt;p data-source-line=&quot;85&quot;&gt;&lt;img data-ratio=&quot;1.0956937799043063&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a2ibvjLwErmkErWEOtFlvP4ABPVvBhrNGYknEUy5xtyEZneBdn8hibGu6BsrIj6ncqRP3bJNAZhicyvWCqV16vxfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;836&quot;/&gt;&lt;/p&gt;&lt;p data-source-line=&quot;88&quot;&gt;首先查询 &lt;span&gt;&lt;span&gt;&quot;中&quot;&lt;/span&gt;&lt;/span&gt; 字的 Unicode 码 &lt;span&gt;&lt;span&gt;0x4E2D&lt;/span&gt;&lt;/span&gt;, 转成二进制, 总共有 16 个二进制位， 具体如上图 步骤1 所示&lt;/p&gt;&lt;p data-source-line=&quot;90&quot;&gt;通过前面的 Unicode 编码和 UTF-8 编码的表格知道，Unicode 码 &lt;span&gt;&lt;span&gt;0x4E2D&lt;/span&gt;&lt;/span&gt; 对应 &lt;span&gt;&lt;span&gt;000800 - 00FFFF&lt;/span&gt;&lt;/span&gt; 的范围，所以, &lt;span&gt;&lt;span&gt;&quot;中&quot;&lt;/span&gt;&lt;/span&gt; 字的 UTF-8 编码 需要 &lt;span&gt;&lt;span&gt;3&lt;/span&gt;&lt;/span&gt; 个字节，即格式是 &lt;span&gt;&lt;span&gt;1110&lt;/span&gt;&lt;/span&gt;xxxx &lt;span&gt;&lt;span&gt;10&lt;/span&gt;&lt;/span&gt;xxxxxx &lt;span&gt;&lt;span&gt;10&lt;/span&gt;&lt;/span&gt;xxxxxx&lt;/p&gt;&lt;p data-source-line=&quot;92&quot;&gt;然后从 &lt;span&gt;&lt;span&gt;&quot;中&quot;&lt;/span&gt;&lt;/span&gt; 字的最后一个二进制位开始，按照从后向前的顺序依次填入格式中的 &lt;span&gt;&lt;span&gt;x&lt;/span&gt;&lt;/span&gt; 字符，多出的二进制补为 &lt;span&gt;&lt;span&gt;0&lt;/span&gt;&lt;/span&gt;， 具体如上图 步骤2、步骤3 所示&lt;/p&gt;&lt;p data-source-line=&quot;94&quot;&gt;于是，就得到了 &lt;span&gt;&lt;span&gt;&quot;中&quot;&lt;/span&gt;&lt;/span&gt; 的 UTF-8 编码是 &lt;span&gt;&lt;span&gt;1110&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;0100&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;10&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;111000&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;10&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;101101&lt;/span&gt;&lt;/span&gt;, 转换成十六进制就是 &lt;span&gt;&lt;span&gt;0xE4B8AD&lt;/span&gt;&lt;/span&gt;， 具体如上图 步骤4 所示&lt;/p&gt;&lt;h3 data-source-line=&quot;98&quot;&gt;&lt;span&gt;UTF-16 编码&lt;/span&gt;&lt;/h3&gt;&lt;p data-source-line=&quot;100&quot;&gt;UTF-16 也是一种变长字符编码, 这种编码方式比较特殊, 它将字符编码成 2 字节 或者 4 字节&lt;/p&gt;&lt;p data-source-line=&quot;102&quot;&gt;具体的编码规则如下:&lt;/p&gt;&lt;ol start=&quot;0&quot; data-source-line=&quot;104&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;对于 Unicode 码小于 &lt;span&gt;&lt;span&gt;0x10000&lt;/span&gt;&lt;/span&gt; 的字符， 使用 &lt;span&gt;&lt;span&gt;2&lt;/span&gt;&lt;/span&gt; 个字节存储，并且是直接存储 Unicode 码，不用进行编码转换&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;2&quot; data-source-line=&quot;107&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;对于 Unicode 码在 &lt;span&gt;&lt;span&gt;0x10000&lt;/span&gt;&lt;/span&gt; 和 &lt;span&gt;&lt;span&gt;0x10FFFF&lt;/span&gt;&lt;/span&gt; 之间的字符，使用 &lt;span&gt;&lt;span&gt;4&lt;/span&gt;&lt;/span&gt; 个字节存储，这 &lt;span&gt;&lt;span&gt;4&lt;/span&gt;&lt;/span&gt; 个字节分成前后两部分，每个部分各两个字节，其中，前面两个字节的前 &lt;span&gt;&lt;span&gt;6&lt;/span&gt;&lt;/span&gt; 位二进制固定为 &lt;span&gt;&lt;span&gt;110110&lt;/span&gt;&lt;/span&gt;，后面两个字节的前 6 位二进制固定为 &lt;span&gt;&lt;span&gt;110111&lt;/span&gt;&lt;/span&gt;, 前后部分各剩余 10 位二进制表示符号的 Unicode 码 减去 &lt;span&gt;&lt;span&gt;0x10000&lt;/span&gt;&lt;/span&gt; 的结果&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;3&quot; data-source-line=&quot;110&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;大于 &lt;span&gt;&lt;span&gt;0x10FFFF&lt;/span&gt;&lt;/span&gt; 的 Unicode 码无法用 UTF-16 编码&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-source-line=&quot;113&quot;&gt;下表是Unicode编码对应UTF-16编码格式&lt;/p&gt;&lt;table data-source-line=&quot;116&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Unicode编码范围(16进制)&lt;/th&gt;&lt;th&gt;具体Unicode码(二进制)&lt;/th&gt;&lt;th&gt;UTF-16编码方式(二进制)&lt;/th&gt;&lt;th&gt;字节&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;0000 0000 - 0000 FFFF&lt;/td&gt;&lt;td&gt;xxxxxxxx xxxxxxxx&lt;/td&gt;&lt;td&gt;xxxxxxxx xxxxxxxx&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0001 0000 - 0010 FFFF&lt;/td&gt;&lt;td&gt;yy yyyyyyyy xx xxxxxxxx&lt;/td&gt;&lt;td&gt;&lt;span&gt;&lt;span&gt;110110&lt;/span&gt;&lt;/span&gt;yy yyyyyyyy &lt;span&gt;&lt;span&gt;110111&lt;/span&gt;&lt;/span&gt;xx xxxxxxxx&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p data-source-line=&quot;122&quot;&gt;表格中第一列是Unicode编码的范围，第二列是 具体Unicode码的二进制 ( 第二行的第二列表示的是 Unicode 码 减去 &lt;span&gt;&lt;span&gt;0x10000&lt;/span&gt;&lt;/span&gt; 后的二进制 ) , 第三列是对应UTF-16编码方式，其中红色的二进制 &lt;span&gt;&lt;span&gt;&quot;1&quot;&lt;/span&gt;&lt;/span&gt; 和 &lt;span&gt;&lt;span&gt;&quot;0&quot;&lt;/span&gt;&lt;/span&gt; 是固定的前缀, 字母 &lt;span&gt;&lt;span&gt;x&lt;/span&gt;&lt;/span&gt; 和 &lt;span&gt;&lt;span&gt;y&lt;/span&gt;&lt;/span&gt; 表示可用编码的二进制位， 第四列表示 编码占用的字节数&lt;/p&gt;&lt;p data-source-line=&quot;124&quot;&gt;前面提到过，&lt;span&gt;&lt;span&gt;&quot;中&quot;&lt;/span&gt;&lt;/span&gt; 字的 Unicode 码是 &lt;span&gt;&lt;span&gt;4E2D&lt;/span&gt;&lt;/span&gt;, 它小于 &lt;span&gt;&lt;span&gt;0x10000&lt;/span&gt;&lt;/span&gt;，根据表格可知，它的 UTF-16 编码占两个字节，并且和 Unicode 码相同，所以 &lt;span&gt;&lt;span&gt;&quot;中&quot;&lt;/span&gt;&lt;/span&gt; 字的 UTF-16 编码为 &lt;span&gt;&lt;span&gt;4E2D&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-source-line=&quot;126&quot;&gt;我从 Unicode字符表网站 找了一个老的南阿拉伯字母, 它的 Unicode 码是: &lt;span&gt;&lt;span&gt;0x10A6F&lt;/span&gt;&lt;/span&gt; , 可以访问 https://unicode-table.com/cn/10A6F/ 查看字符的说明, Unicode 码对应的字符如下图所示&lt;/p&gt;&lt;p data-source-line=&quot;128&quot;&gt;&lt;img data-ratio=&quot;0.4365781710914454&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a2ibvjLwErmkErWEOtFlvP4ABPVvBhrNGbGnG7HtFuZSWfhG1iauGWr1icVq2UuWPJEIDKaBOWscqiayf91FFQ6CfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;678&quot;/&gt;&lt;/p&gt;&lt;p data-source-line=&quot;131&quot;&gt;下面以这个 老的南阿拉伯字母的 Unicode 码 &lt;span&gt;&lt;span&gt;0x10A6F&lt;/span&gt;&lt;/span&gt; 为例来说明 UTF-16 &lt;span&gt;&lt;span&gt;4&lt;/span&gt;&lt;/span&gt; 字节的编码，具体步骤如下，为了便于说明，图中左边加了 &lt;code&gt;1，2，3，4 、5&lt;/code&gt;的步骤编号&lt;/p&gt;&lt;p data-source-line=&quot;133&quot;&gt;&lt;img data-ratio=&quot;0.9486921529175051&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/a2ibvjLwErmkErWEOtFlvP4ABPVvBhrNG7DxqFrCmfpmDnadC5kAWsbcDHSWQhkNtOJ3Vicxicq2TWuGPMl7O5Zibw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;994&quot;/&gt;&lt;/p&gt;&lt;p data-source-line=&quot;136&quot;&gt;首先把 Unicode 码 &lt;span&gt;&lt;span&gt;0x10A6F&lt;/span&gt;&lt;/span&gt; 转成二进制, 对应上图的 步骤 1&lt;/p&gt;&lt;p data-source-line=&quot;138&quot;&gt;然后把 Unicode 码 &lt;span&gt;&lt;span&gt;0x10A6F&lt;/span&gt;&lt;/span&gt; 减去 &lt;span&gt;&lt;span&gt;0x10000&lt;/span&gt;&lt;/span&gt;, 结果为 &lt;span&gt;&lt;span&gt;0xA6F&lt;/span&gt;&lt;/span&gt; 并把这个值转成二进制 &lt;span&gt;&lt;span&gt;00 00000010&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;10 01101111&lt;/span&gt;&lt;/span&gt;，对应上图的 步骤 2&lt;/p&gt;&lt;p data-source-line=&quot;140&quot;&gt;然后 从二进制 &lt;span&gt;&lt;span&gt;00 00000010&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;10 01101111&lt;/span&gt;&lt;/span&gt; 的最后一个二进制为开始，按照从后向前的顺序依次填入格式中的 &lt;span&gt;&lt;span&gt;x&lt;/span&gt;&lt;/span&gt; 和 &lt;span&gt;&lt;span&gt;y&lt;/span&gt;&lt;/span&gt; 字符，多出的二进制补为 &lt;span&gt;&lt;span&gt;0&lt;/span&gt;&lt;/span&gt;， 对应上图的 步骤 3、 步骤 4&lt;/p&gt;&lt;p data-source-line=&quot;143&quot;&gt;于是，就计算出了 Unicode 码 &lt;span&gt;&lt;span&gt;0x10A6F&lt;/span&gt;&lt;/span&gt; 的 UTF-16 编码是 &lt;span&gt;&lt;span&gt;110110&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;00 00000010&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;110111&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;10 01101111&lt;/span&gt;&lt;/span&gt; , 转换成十六进制就是 &lt;span&gt;&lt;span&gt;0xD802DE6F&lt;/span&gt;&lt;/span&gt;， 对应上图的 步骤 5&lt;/p&gt;&lt;h3 data-source-line=&quot;146&quot;&gt;&lt;span&gt;UTF-32 编码&lt;/span&gt;&lt;/h3&gt;&lt;p data-source-line=&quot;148&quot;&gt;UTF-32 是固定长度的编码，始终占用 4 个字节，足以容纳所有的 Unicode 字符，所以直接存储 Unicode 码即可，不需要任何编码转换。虽然浪费了空间，但提高了效率。&lt;/p&gt;&lt;h3 data-source-line=&quot;151&quot;&gt;&lt;span&gt;UTF-8、UTF-16、UTF-32 之间如何转换&lt;/span&gt;&lt;/h3&gt;&lt;p data-source-line=&quot;154&quot;&gt;前面介绍过，UTF-8、UTF-16、UTF-32 是 Unicode 码表示成不同的二进制格式的编码规则，同样，通过这三种编码的二进制表示，也能获得对应的 Unicode 码，有了字符的 Unicode 码，按照上面介绍的 UTF-8、UTF-16、UTF-32 的编码方法 就能转换成任一种编码了&lt;/p&gt;&lt;h3 data-source-line=&quot;157&quot;&gt;&lt;span&gt;UTF 字节序&lt;/span&gt;&lt;/h3&gt;&lt;p data-source-line=&quot;160&quot;&gt;最小编码单元是多字节才会有字节序的问题存在，UTF-8 最小编码单元是一字节，所以 它是没有字节序的问题，UTF-16 最小编码单元是 2 个字节，在解析一个 UTF-16 字符之前，需要知道每个编码单元的字节序&lt;/p&gt;&lt;p data-source-line=&quot;162&quot;&gt;比如：前面提到过，&lt;span&gt;&lt;span&gt;&quot;中&quot;&lt;/span&gt;&lt;/span&gt; 字的 Unicode 码是 &lt;span&gt;&lt;span&gt;4E2D&lt;/span&gt;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;&quot;ⵎ&quot;&lt;/span&gt;&lt;/span&gt; 字符的 Unicode 码是 &lt;span&gt;&lt;span&gt;2D4E&lt;/span&gt;&lt;/span&gt;， 当我们收到一个 UTF-16 字节流 &lt;span&gt;&lt;span&gt;4E2D&lt;/span&gt;&lt;/span&gt; 时，计算机如何识别它表示的是字符 &lt;span&gt;&lt;span&gt;&quot;中&quot;&lt;/span&gt;&lt;/span&gt; 还是 字符 &lt;span&gt;&lt;span&gt;&quot;ⵎ&quot;&lt;/span&gt;&lt;/span&gt; 呢 ?&lt;/p&gt;&lt;p data-source-line=&quot;165&quot;&gt;所以，对于多字节的编码单元，需要有一个标记显式的告诉计算机，按照什么样的顺序解析字符，也就是字节序，字节序分为 大端字节序 和 小端字节序&lt;/p&gt;&lt;p data-source-line=&quot;168&quot;&gt;小端字节序简写为 LE( Little-Endian ), 表示 低位字节在前，高位字节在后, 高位字节保存在内存的高地址端，而低位字节保存在内存的低地址端&lt;/p&gt;&lt;p data-source-line=&quot;171&quot;&gt;大端字节序简写为 BE( Big-Endian ), 表示 高位字节在前，低位字节在后，高位字节保存在内存的低地址端，低位字节保存在在内存的高地址端&lt;/p&gt;&lt;p data-source-line=&quot;173&quot;&gt;下面以 &lt;span&gt;&lt;span&gt;0x4E2D&lt;/span&gt;&lt;/span&gt; 为例来说明大端和小端，具体参见下图:&lt;/p&gt;&lt;p data-source-line=&quot;175&quot;&gt;&lt;img data-ratio=&quot;0.4934210526315789&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a2ibvjLwErmkErWEOtFlvP4ABPVvBhrNGs5cnWSD9YjP1ic2GiaEbAlFJbQudqM60jyOSMRKmYXbeG2UPS1PXBB8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;912&quot;/&gt;&lt;/p&gt;&lt;p data-source-line=&quot;177&quot;&gt;数据是从高位字节到低位字节显示的，这也更符合人们阅读数据的习惯，而内存地址是从低地址向高地址增加&lt;/p&gt;&lt;p data-source-line=&quot;179&quot;&gt;所以，字符&lt;span&gt;&lt;span&gt;0x4E2D&lt;/span&gt;&lt;/span&gt; 数据的高位字节是 &lt;span&gt;&lt;span&gt;4E&lt;/span&gt;&lt;/span&gt;，低位字节是 &lt;span&gt;&lt;span&gt;2D&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-source-line=&quot;181&quot;&gt;按照大端字节序的高位字节保存内存低地址端的规则，&lt;span&gt;&lt;span&gt;4E&lt;/span&gt;&lt;/span&gt; 保存到低内存地址 &lt;span&gt;&lt;span&gt;0x10001&lt;/span&gt;&lt;/span&gt; 上，&lt;span&gt;&lt;span&gt;2D&lt;/span&gt;&lt;/span&gt; 则保存到高内存地址 &lt;span&gt;&lt;span&gt;0x10002&lt;/span&gt;&lt;/span&gt; 上&lt;/p&gt;&lt;p data-source-line=&quot;183&quot;&gt;对于小端字节序，则正好相反，数据的高位字节保存到内存的高地址端，低位字节保存到内存低地址端的，所以 &lt;span&gt;&lt;span&gt;4E&lt;/span&gt;&lt;/span&gt; 保存到高内存地址 &lt;span&gt;&lt;span&gt;0x10002&lt;/span&gt;&lt;/span&gt; 上，&lt;span&gt;&lt;span&gt;2D&lt;/span&gt;&lt;/span&gt; 则保存到低内存地址 &lt;span&gt;&lt;span&gt;0x10001&lt;/span&gt;&lt;/span&gt; 上&lt;/p&gt;&lt;h3 data-source-line=&quot;185&quot;&gt;&lt;span&gt;BOM&lt;/span&gt;&lt;/h3&gt;&lt;p data-source-line=&quot;187&quot;&gt;BOM 是 byte-order mark 的缩写，是 &quot;字节序标记&quot; 的意思, 它常被用来当做标识文件是以 UTF-8、UTF-16 或 UTF-32 编码的标记&lt;/p&gt;&lt;p data-source-line=&quot;189&quot;&gt;在 Unicode 编码中有一个叫做 &quot;零宽度非换行空格&quot; 的字符 ( ZERO WIDTH NO-BREAK SPACE ), 用字符 &lt;span&gt;&lt;span&gt;FEFF&lt;/span&gt;&lt;/span&gt; 来表示&lt;/p&gt;&lt;p data-source-line=&quot;191&quot;&gt;对于 UTF-16 ，如果接收到以 &lt;span&gt;&lt;span&gt;FE&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;FF&lt;/span&gt;&lt;/span&gt; 开头的字节流， 就表明是大端字节序，如果接收到 &lt;span&gt;&lt;span&gt;FF&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;FE&lt;/span&gt;&lt;/span&gt;， 就表明字节流 是小端字节序&lt;/p&gt;&lt;p data-source-line=&quot;193&quot;&gt;UTF-8 没有字节序问题，上述字符只是用来标识它是 UTF-8 文件，而不是用来说明字节顺序的。&quot;零宽度非换行空格&quot; 字符 的 UTF-8 编码是 &lt;span&gt;&lt;span&gt;EF BB BF&lt;/span&gt;&lt;/span&gt;, 所以如果接收到以 &lt;span&gt;&lt;span&gt;EF BB BF&lt;/span&gt;&lt;/span&gt; 开头的字节流，就知道这是UTF-8 文件&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-source-line=&quot;197&quot;&gt;下面的表格列出了不同 UTF 格式的固定文件头&lt;/p&gt;&lt;table data-source-line=&quot;199&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;UTF编码&lt;/th&gt;&lt;th&gt;固定文件头&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;UTF-8&lt;/td&gt;&lt;td&gt;EF BB BF&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;UTF-16LE&lt;/td&gt;&lt;td&gt;FF FE&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;UTF-16BE&lt;/td&gt;&lt;td&gt;FE FF&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;UTF-32LE&lt;/td&gt;&lt;td&gt;FF FE 00 00&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;UTF-32BE&lt;/td&gt;&lt;td&gt;00 00 FE FF&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-source-line=&quot;209&quot;&gt;根据上面的 固定文件头，下面列出了 &lt;span&gt;&lt;span&gt;&quot;中&quot;&lt;/span&gt;&lt;/span&gt; 字在文件中的存储 ( 包含文件头 )&lt;/p&gt;&lt;table data-source-line=&quot;213&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;编码&lt;/th&gt;&lt;th&gt;固定文件头&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;Unicode 编码&lt;/span&gt;&lt;/td&gt;&lt;td&gt;0X004E2D&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;&lt;span&gt;EF BB BF&lt;/span&gt;&lt;/span&gt; 4E 2D&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;UTF-16BE&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;&lt;span&gt;FE FF&lt;/span&gt;&lt;/span&gt; 4E 2D&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;UTF-16LE&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;&lt;span&gt;FF FE&lt;/span&gt;&lt;/span&gt; 2D 4E&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;UTF-32BE&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;&lt;span&gt;00 00 FE FF&lt;/span&gt;&lt;/span&gt; 00 00 4E 2D&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;UTF-32LE&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;&lt;span&gt;FF FE 00 00&lt;/span&gt;&lt;/span&gt; 2D 4E 00 00&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 data-source-line=&quot;223&quot;&gt;&lt;span&gt;常见的字符编码的问题&lt;/span&gt;&lt;/h3&gt;&lt;p data-source-line=&quot;228&quot;&gt;有时候我们需要向redis中写入含有中文的数据，然后在查看数据，但是会看到一些其他的字符，而不是我们写入的中文&lt;/p&gt;&lt;p data-source-line=&quot;230&quot;&gt;&lt;img data-ratio=&quot;0.24173027989821882&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a2ibvjLwErmkErWEOtFlvP4ABPVvBhrNG2VoHpfMog6Lq5q2CJ7NTaPD9iaP4hYANmSdtgC9VuBltFBN3UHAd0AA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;393&quot;/&gt;&lt;/p&gt;&lt;p data-source-line=&quot;233&quot;&gt;上图中，我们向redis 写入了一个 &quot;中&quot; 字，通过 get 命令查看的时候无法显示我们写入的 &quot;中&quot; 字&lt;/p&gt;&lt;p data-source-line=&quot;236&quot;&gt;这时候加一个 --raw 参数，重新启动 redis-cli 即可，也即 执行 redis-cli --raw 命令启动redis客户端，具体的如下图所示&lt;/p&gt;&lt;p data-source-line=&quot;238&quot;&gt;&lt;img data-ratio=&quot;0.2945054945054945&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a2ibvjLwErmkErWEOtFlvP4ABPVvBhrNGTlf9CGHbBXycOp5H6eqjlibUAayjzAMTiceRSyMjtI5b9nqSmHXwW8cA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;455&quot;/&gt;&lt;/p&gt;&lt;p data-source-line=&quot;244&quot;&gt;MySQL 中的 &quot;utf8&quot; 实际上不是真正的 UTF-8， &quot;utf8&quot; 只支持每个字符最多 3 个字节, 对于超过 3 个字节的字符就会出错, 而真正的 UTF-8 至少要支持 4 个字节&lt;/p&gt;&lt;p data-source-line=&quot;246&quot;&gt;MySQL 中的 &quot;utf8mb4&quot; 才是真正的 UTF-8&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;下面以 test 表为例来说明, 表结构如下:&lt;/span&gt;&lt;/p&gt;&lt;pre data-source-line=&quot;251&quot;&gt;&lt;code&gt;mysql&amp;gt; show create table test\G&lt;br/&gt;*************************** 1. row ***************************&lt;br/&gt;       Table: test&lt;br/&gt;Create Table: CREATE TABLE `test` (&lt;br/&gt;  `name` char(32) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;br/&gt;) &lt;span&gt;ENGINE&lt;/span&gt;=InnoDB&lt;span&gt; DEFAULT &lt;/span&gt;&lt;span&gt;CHARSET&lt;/span&gt;=utf8&lt;br/&gt;1 row &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (0.00 sec)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-source-line=&quot;261&quot;&gt;向 &lt;code&gt;test&lt;/code&gt; 表分别插入 &lt;span&gt;&lt;span&gt;&quot;中&quot;&lt;/span&gt;&lt;/span&gt; 字 和 Unicode 码为 &lt;span&gt;&lt;span&gt;0x10A6F&lt;/span&gt;&lt;/span&gt; 的字符，这个字符需要从 https://unicode-table.com/cn/10A6F/ 直接复制到 MySQL 控制台上，手工输入会无效，具体的执行结果如下图:&lt;/p&gt;&lt;p data-source-line=&quot;263&quot;&gt;&lt;img data-ratio=&quot;0.11929170549860205&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a2ibvjLwErmkErWEOtFlvP4ABPVvBhrNGSZoaIwDZrzs8WllZibfC7OJgoa8bpZsXaNloQMgUPBRPH1sok3sa3MA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1073&quot;/&gt;&lt;/p&gt;&lt;p data-source-line=&quot;266&quot;&gt;从上图可以看出，插入 &lt;span&gt;&lt;span&gt;&quot;中&quot;&lt;/span&gt;&lt;/span&gt; 字 成功，插入 &lt;span&gt;&lt;span&gt;0x10A6F&lt;/span&gt;&lt;/span&gt; 字符失败，错误提示无效的字符串，&lt;span&gt;&lt;span&gt;\xF0\X90\XA9\xAF&lt;/span&gt;&lt;/span&gt; 正是 &lt;span&gt;&lt;span&gt;0x10A6F&lt;/span&gt;&lt;/span&gt; 字符的 UTF-8 编码，占用 &lt;span&gt;&lt;span&gt;4&lt;/span&gt;&lt;/span&gt; 个字节, 因为 MySQL 的 utf8 编码最多只支持 &lt;span&gt;&lt;span&gt;3&lt;/span&gt;&lt;/span&gt; 个字节，所以插入会失败&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-source-line=&quot;270&quot;&gt;把 &lt;code&gt;test&lt;/code&gt; 表的字符集改成 &lt;code&gt;utf8mb4&lt;/code&gt; , 排序规则 改成 &lt;code&gt;utf8bm4_unicode_ci&lt;/code&gt;, 具体如下图所示：&lt;/p&gt;&lt;p data-source-line=&quot;272&quot;&gt;&lt;img data-ratio=&quot;0.245697896749522&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a2ibvjLwErmkErWEOtFlvP4ABPVvBhrNGndFwD1A441vhc8vyxgXJObiat3ueda7LcniaAxegjnLZTJF3l9vibicRdg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1046&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-source-line=&quot;276&quot;&gt;字符集和排序方式修改之后，再次插入 &lt;span&gt;&lt;span&gt;0x10A6F&lt;/span&gt;&lt;/span&gt; 字符， 结果是成功的，具体执行结果如下图所示&lt;/p&gt;&lt;p data-source-line=&quot;279&quot;&gt;&lt;img data-ratio=&quot;0.2177293934681182&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a2ibvjLwErmkErWEOtFlvP4ABPVvBhrNGQrAqzshHPric9F3wqHmxGKskwF99ClscjkmgNmAiahWr1iaia2UznLz5MA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;643&quot;/&gt;&lt;/p&gt;&lt;p data-source-line=&quot;281&quot;&gt;上图中，&lt;code&gt;set names utf8mb4&lt;/code&gt; 是为了测试方便，临时修改当前会话的字符集，以便保持和 服务器一致，实际解决这个问题需要修改 &lt;code&gt;my.cnf&lt;/code&gt; 配置中 服务器和客户端的字符集&lt;/p&gt;&lt;h3 data-source-line=&quot;285&quot;&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/h3&gt;&lt;p data-source-line=&quot;287&quot;&gt;本文从字符编码的历史介绍了 Unicode 出现的原因，接着介绍了 Unicode 字符集中 三种不同的编码方式：UTF-8、UTF-16、UTF-32 以及它们的的编码方法，紧接着介绍了 字节序、BOM ，最后讲到了字符集在 MySQL 和 Redis 应用中常见的问题以及解决方案 ，更多关于 Unicode 的介绍请参考 Unicode 的 RFC 文档。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;1、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4MjEyNTA5Mw==&amp;amp;mid=2652578336&amp;amp;idx=1&amp;amp;sn=d162ea976f912dfc7d3e036715731b69&amp;amp;chksm=84650a6ab312837c7c50268cdfe6c19c7f4c2fe7c590f8f2cfa548bde543ccb8bd34d7d2e476&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;工程师在工作电脑存 64G 不雅文件，被公司开除后索赔 41 万，结果…&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4MjEyNTA5Mw==&amp;amp;mid=2652578331&amp;amp;idx=1&amp;amp;sn=78d9095af3f05256e31d6a678887245a&amp;amp;chksm=84650a51b312834767e5eda3bba3c798c61dff3ef388ce48fed15730c895bc018f9a0eee2364&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;腾讯最大股东收购了 Stack Overflow，以后“抄代码”都要付费了么？&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4MjEyNTA5Mw==&amp;amp;mid=2652578284&amp;amp;idx=1&amp;amp;sn=59a5df31be4dd5cec0e795e7ee7dfd5b&amp;amp;chksm=846509a6b31280b08e9bd8621db60f4afabb1cc033c6491efb1cdb28f201be4c9922bee910ef&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;2.3 万 Star！直追微软 Visio，这个简洁实用的在线绘图工具必须推荐给你&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;觉得本文对你有帮助？请分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;推荐关注「Python开发者」，提升Python技能&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA4MjEyNTA5Mw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/fhujzoQe7TpvdeLibiaAmU69kV0SyJIicdHKNjs7Cj55MMnHdNdX7mLRzmODUgfYTIb6pQXe10QcibSsPpHib7Ap7rw/0?wx_fmt=png&quot; data-nickname=&quot;Python开发者&quot; data-alias=&quot;PythonCoder&quot; data-signature=&quot;点击获取精选Python开发资源。「Python开发者」日常分享 Python 相关的技术文章、实用案例、工具资源、精选课程、热点资讯等。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;点赞和在看就是最大的支持&lt;/span&gt;&lt;span&gt;❤️&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>96a02fab303d0aa998da802df19a42ec</guid>
<title>假如让我来设计 “腾讯视频” 的推荐系统</title>
<link>https://toutiao.io/k/8m5ybgh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-width=&quot;100%&quot; data-opacity=&quot;1&quot; data-rotate=&quot;0&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;作者·黄崇远&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;『数据虫巢』&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;全文共&lt;strong&gt;4966&lt;/strong&gt;字&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;题图ssyer.com&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;375&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;441&quot; data-ratio=&quot;1.25&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBquKJr2v84mvozwoHosR1ajN8kMiaiaQic0ILbGtGNr2ohh1P9SSXJhtx7cxznJlDmO9iaHtTiboWA00ZVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;“&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 虽然我一向警惕被推荐系统带着走，但我也讨厌低效。&lt;strong&gt;&lt;span&gt;”&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是一个带着故事背景的技术话题，轻松愉快但又不乏对于技术深度的思考。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7627118644067796&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqvMexxWOopOqLBDkK4OcleOe4f1s3S39xWsicbxtSq1O8sylvTAh0F7Dw1eBiaPAvLLWvHQ7COTvia3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;59&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.0769230769230769&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqvMexxWOopOqLBDkK4OcleOj6rvROR3uPaBiaqickoY94Qh9tGA9vG7aWAiamgBOiag7cnialLkuvxk9Hw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;52&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;01&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;故事背景&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;作为一个拥有二娃的三十多岁中年老男人，岁月早已磨光了我对游戏的激情，想当年我也是天梯1800分的选手，DOTA玩的老溜了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但岁月无情，残废了我的手，消退了我的意志，竟然沦落到简单AI电脑都打不过了，所以，偶尔的闲暇时光，看看电影竟成了我唯一的娱乐消遣方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;笔者作为腾讯视频多年的VIP付费会员，不得不说一句，腾讯视频真的太难用了。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首页都是什么鬼，一票的什么热门视频，什么原创，什么娱乐综艺，总之，90%都可能是我一辈子都不会打开的类型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;于是乎，片库和检索成了我的主要获取影片的方式，但是...人的认知是有限的，片库的片源看着也是有限的，但对于我来说就是无限的，看不过来也不知道到底讲啥的（反正有点名头的应该都看过了，剩下都是未知项）。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不可否认的是，通过这种摸索探索的方式，确实被我找到不少之前不知道但是确实还可以的影片，但这个过程太痛苦，试错成本蛮高的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;他就不能搞个推荐系统吗？如果让我来设计这么一个推荐系统...&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7627118644067796&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqvMexxWOopOqLBDkK4OcleOe4f1s3S39xWsicbxtSq1O8sylvTAh0F7Dw1eBiaPAvLLWvHQ7COTvia3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;59&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.0769230769230769&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqvMexxWOopOqLBDkK4OcleOj6rvROR3uPaBiaqickoY94Qh9tGA9vG7aWAiamgBOiag7cnialLkuvxk9Hw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;52&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;02&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;先吐槽几个点再说&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;笔者不确认腾讯视频是否有推荐逻辑。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先首页的跑马灯中“猜你会追”应该多少是个性化的，但观测下来大部分是根据之前的播放记录（没看完的之类的），甚至是已经看过的还一个劲儿放上去，反正挺辣眼睛的，这个模块还不如放个播放历史记录呢，没劲。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;剩下首页满满的各频道，各类别放了一些所谓的精挑细选的，大概率是非个性化的，如果有，我只能说做的太一言难尽了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;播放页，下面有个为你推荐栏目，目测是个性化的。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5312270389419544&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBquKJr2v84mvozwoHosR1ajNwsg8pTgfdfzyLBIhZj0nqzU0JNphKqjADW72eITg0dzE1icicwHe6vVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1361&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;不清楚具体的推荐逻辑，但目测在内容相关上做了不少事情，这些都不是重点，重点是以上面截图为例，上面总共推了14个，其中11个我都看过了，你还推个毛啊。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;长视频领域是属于典型的短时间内不会重刷剧的场景，你这样搞让我很为难呀。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实现这种去重很难吗，我不是专业搞工程的，但想来不是很困难的，无非就是维护一个用户的已播放队列，甚至是播放进度都可以缓存下来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再再再做的差一点，好吧，没有服务器资源，你把有登录状态的播放历史记录在本地都行了吧，我不指望你跨设备能识别我已经看过的，最起码同个设备启动应用的时候加载播放过的记录，避免这种二货行为很难吗？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;他难不难不知道，反正我是感觉我太难了，要不是看重他片源版权多，我早就放弃抵抗了，用的实在太辛苦了。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7627118644067796&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqvMexxWOopOqLBDkK4OcleOe4f1s3S39xWsicbxtSq1O8sylvTAh0F7Dw1eBiaPAvLLWvHQ7COTvia3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;59&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.0769230769230769&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqvMexxWOopOqLBDkK4OcleOj6rvROR3uPaBiaqickoY94Qh9tGA9vG7aWAiamgBOiag7cnialLkuvxk9Hw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;52&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;03&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;推荐的产品必要性&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从上面的吐槽部分来看，腾讯视频不是一个偏推荐系统逻辑的产品逻辑（至于为什么，感觉更多是基因吧，或者做产品的核心方法论，跟头条是另外一条路子，虽然我很不认同这个路子）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所谓推荐系统逻辑的产品逻辑，听着有点绕，笔者说个产品形态就容易理解了，今日头条。或者其下面的相关产品，都是典型重度依赖于推荐来做内容与流量的分发的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本质上推荐逻辑形态和重产品逻辑的形态其实是两种打法，但笔者认为本质上是对人的理解。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;产品思路的打法，核心&lt;/span&gt;&lt;span&gt;是识别主动型和被动型主体，或者说再加上时间因素，什么人什么时候是主动型需求，什么时候是被动型诉求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主动型的选手，其在产品逻辑上，可能更多期望的是一种固定的逻辑，给予其更多的自我空间，去探索和自己寻找需要的东西。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而被动型的选手，更多在于其获取信息的能力是有差的，又或者说人力终归有时尽，比如笔者个人，从某种程度上说获取信息的能力应该比95%的人都强，但很多时候一样非常无奈，毕竟人的认知是有限的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而为什么说要加上时间因素，依然如笔者，可能很多时候我自己通过检索，通过其他工具我已经明确知道我需要看什么剧看什么电影，但很多时候我也希望能够找到我所不知道但又是恰巧我所喜欢的电影，只是不希望这个找的过程太过于闹心。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，当主动型占据权重过大的时候，整个形态重产品逻辑，当被动型的时候重推荐逻辑，不冲突，各取所需而已。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;笔者自身，对于推荐类的产品有天然的抵触心理，并且常常违背推荐逻辑进行产品逻辑体验，属于推荐模型中的典型脏数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总结下来就是，看菜下饭，各取所需，平台需要尽量做到千人前面，这里所谓的千人千面就不单纯指推荐系统中的千人千面，还包括上述所说的可能有些人就是喜欢这种严谨风，非个性化风，那么你给他呈现的就是这种非个性化的内容并且罗列整齐的内容，这也是一种个性化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;给喜欢或者有需求的人个性化的内容，给不喜欢个性化的人也是“个性化”的内容。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7627118644067796&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqvMexxWOopOqLBDkK4OcleOe4f1s3S39xWsicbxtSq1O8sylvTAh0F7Dw1eBiaPAvLLWvHQ7COTvia3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;59&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.0769230769230769&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqvMexxWOopOqLBDkK4OcleOj6rvROR3uPaBiaqickoY94Qh9tGA9vG7aWAiamgBOiag7cnialLkuvxk9Hw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;52&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;04&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;推荐的策略&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;说完了潜在的必要性，现在来聊聊怎么做策略，甚至深入到怎么做模型，毕竟咱们是做数据做算法的嘛，看个视频也得看出花来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实整个视频领域，特别是长视频领域，还是非常有迹可循的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所有的产品形态记住一个推荐逻辑，越是需要决策成本的场景，其中长期的兴趣捕获就越重要，比如长视频领域，你看一个电影需要“浪费”你2个小时，这意味着一旦你选错了，可能你看了30分钟之后，终于发现你丫的一点都不喜欢这个影片，这意味着你真的浪费了30分钟。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这就是决策错误的成本，因此，大部分时候这种决策不会是一时兴趣，而是中长期的行为习惯的最终决策，毕竟浪费30分钟够你刷多少个抖音视频了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，回到中长期兴趣的话题，重点是挖掘中长期兴趣点，这个先放放。我们来看下，长视频还有哪些特点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;列一下电影的几大要素，导演、主演、类型、话题等，这些都是中长期形成的兴趣认知。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但又有所不同，导演主演是长期认同，是有前置认知的，比如我喜欢看黄渤的电影，是因为之前看过他的电影，形成了“这个演员演的电影应该靠谱”这种中长期的认知。导演维度同样。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而类型则不同，他是一个大的概念，是一种界限分明的兴趣点，一定是有规律的，没有人所有类型通吃的。比如笔者，对于科幻、超级英雄、动漫、纪录片、动作片、灾难片之类的有一定的认知度，虽然不是说这些类型的电影都喜欢，但起码喜欢的电影大部分都在这些类型里。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除此之外，比如什么爱情片、恐怖片、文艺片就不是我的菜了，虽然也看一些，但整体上是非常少的。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于类型，其实衍生下去就是话题，这是比类型更细的兴趣聚合点，比如三国题材，他可能是大型战争，也可能是历史，也可能是剧情等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再衍生下去就是系列，比如漫威系列，钢铁侠系列等等，太多了，这种是有天然的强联系的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如上都是非常明显的挖掘点，再说下不明显的挖掘点，那就是很多时候要素之间是互斥的，典型如笔者的操作逻辑，对于我所喜欢的主演，我大部分是不挑题材和话题的；对于没有名主演或者我所不熟悉的导演主演，我对于剧情的细节会更加扣，又或者是热度等驱动因素在里头起着很大的作用；对于同题材或者同系列，在体验良好之后，挖掘持续的内容是一个常态；时间是一个典型的类型，具有明显的分界线。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，在选择内容的时候，其实很多时候做决策的是其中一个因素，但是这种因素之间是有先后顺序的，甚至很多时候是互斥的，但难点在于系统需要知道什么内容对于目标来说，其哪个核心因素在起作用，抓住这个核心因素进行有效内容的呈现。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实不用说太多，上面这些做好了，已经能解决很大一部分问题了，大部分把常规兴趣就能捕获住了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么，那些策略可验证吗？我觉得太好验证了，例如系列的问题，分析一下历史数据就知道这种系列的追溯程度了。对于主演和导演的因素，追溯一下检索的记录就知道了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这些逻辑都是可以验证的，提出假设，在历史数据中寻找答案。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7627118644067796&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqvMexxWOopOqLBDkK4OcleOe4f1s3S39xWsicbxtSq1O8sylvTAh0F7Dw1eBiaPAvLLWvHQ7COTvia3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;59&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.0769230769230769&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqvMexxWOopOqLBDkK4OcleOj6rvROR3uPaBiaqickoY94Qh9tGA9vG7aWAiamgBOiag7cnialLkuvxk9Hw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;52&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;05&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;关于推荐的模型&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面说了一些常见的策略，这里聊一些偏模型的东西。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于目标的兴趣预测，大部分常规逻辑是挖掘用户的特征，然后构建预测模型，然后对用户进行兴趣预测，然后在对应场景推荐合适的ITEM，然后打完收工。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是，长视频平台是一个比较特别的场景，回到上面章节，有提到过，长视频平台是有决策成本的，特别是在各大平台争相变相让你付费VIP之后（不VIP就让你看广告看到吐），这种成本变得更高了。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这就导致了，目标主体其实是一个多目标，即家庭成员共享账号。典型如笔者，自己和梓尘兄共享账号，我看我的大电影，他看他的动画片和火车视频。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但这俨然就是两个完全不同的兴趣列表，两个完全不同的目标群体，对于预测来说是个挑战。方式一就是分开建模，有没有办法将行为区分开来，然后再分开建模？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;还是回到上个章节中的决策成本的问题，这意味着长视频平台注定就是一个低频，但是单次时长较长的场景，这就意味着不同目标主体之间的活动时间一定是有规律的。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;依然回到笔者自身，例如笔者平时是没有时间看的，最多中午时间偶尔，周末时间偶尔，对于梓尘兄只要是白天非周末时间基本上不太可能是他在使用，除此之外就是观看的内容本身关联度是非常小的。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于上面，一个是拆分行为分开建模，另一种就是把能够典型区分的行为作为典型特征加入训练，例如上面说到的观看时间，甚至是星期几。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;需要注意的是，在模型中，需要尽可能的让这种显著特征不要泯灭于茫茫特征之海中，是不是想到了什么？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对的wide&amp;amp;deep，一定要把这种显著逻辑放到离目标近的地方，万万不要把他丢到成千上万的深度参数中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第二个典型问题，正负样本的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;依然是决策成本的问题，由于长视频观看一次成本还挺高的，所以其任何观看过程中的行为对于目标预测都是有意义的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;例如播放过程中是否看完，是否快进，对于系列是否持续追踪，这些都是对正样本有加权作用的，反过来看到一半看不下去的，后面没有续上的，典型就是负例了。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但负例的情况有点特殊，那就是他为什么会点开这个视频，他为什么又会放弃掉这个视频。这就需要我们从点开的动作中捕获到其触发的兴趣点，然后从已播放的内容中挖掘中放弃的核心触动因素。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;还是以笔者举例，我曾放弃对于导演主演的追求，尝试去看一些看着感兴趣主题的自制网络大电影，但最终却让我养成了对于自制网络大电影持长期怀疑态度。这就是我已经形成了对于网络大电影这个要素持反对的态度了，对于任何类似的内容都持有非常谨慎的选择态度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;是否可以验证？也是可以的，将这种节点获取出来，然后统计其后的行为即可，可以验证这个逻辑。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;回到策略这个逻辑中，我们知道我们选择一个电影，很多时候其实就是一个触动点，导演？演员？主题？系列？热度？等等，所以本质上对于不同的特征其决策权重是不同的。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;想到了什么？是的，注意力，如何能够精准的把握住不同特征之间的注意力非常主要，至于是不是用attention，这个就是实现方式的问题了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7627118644067796&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqvMexxWOopOqLBDkK4OcleOe4f1s3S39xWsicbxtSq1O8sylvTAh0F7Dw1eBiaPAvLLWvHQ7COTvia3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;59&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.0769230769230769&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqvMexxWOopOqLBDkK4OcleOj6rvROR3uPaBiaqickoY94Qh9tGA9vG7aWAiamgBOiag7cnialLkuvxk9Hw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;52&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;06&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;商业行为的考量&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;这个部分，我们回到商业问题的讨论，任何所谓的推荐系统也好，非推荐系统的产品形态也好，本质上都逃离不了商业变现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一切一切“罪恶”的根源在于平台想搞钱，谁都不是搞慈善的，所以可以理解，只是最好将这个事情做的更加平滑一些，让人更容易接受一些。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从目前长视频的各大平台的“尿性”来说，打怪升级的路径为普通会员（没啥鸟用），VIP会员（以前很有鸟用，现在很多时候也没啥鸟用），VVIP会员（传说中的荣耀级，可以各种抢先看），甚至还有付费片源（这个更吊，看一个收费一个）。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实推荐系统在这种升级打怪逻辑中是有帮助的，从普通到VIP，到VVIP，再到说服别人为单个片付费，这个难度是依次递增的。而笔者一直停留在第二级，始终上不去。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种内容追求的递增性，需要在产品逻辑的设计上，铺垫好节奏，前戏要做足，上来就让人各种付费，凭啥？&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，依赖推荐逻辑，将这种付费的诱导性融入到推荐的内容层级上，先逐步的挖掘用户的兴趣，先用免费资源不断的探测用户的兴趣边界，然后通过推荐不断的深化这种偏好，并且往逐步付费的道路上引导。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通俗点说就是，先用免费的把你养熟了，加大依赖性了，逐步的把兴趣点上较新更好的付费资源逐步逐层去推进，用户就不知不觉去为更好的内容付费了。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上来就让你整个VVIP，谁乐意呀（现在我都不乐意为VVIP付费，简直太侮辱人了，鬼知道过两天会不会搞出个VVVIP，不惯着），是吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不知不觉聊了5000字，内容有点散，不是体系化的内容，只是体验别人家产品的时候结合自身的一些专业性的一些零散思考而已。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从笔者个人的从业经验来说，推荐领域本身就是一个强业务的场景，其实单纯从模型网络角度上说，其实目前已经被挖的很多很多了，各种变形的模型，各种骚操作，都有迹可循，不会独创，总能抄上一抄。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;需要自己多思考的是自身业务场景的特殊性，比如上面说的一账号多个实际主体的问题，时间维度的问题，特性互斥的问题，如何潜入商业化内容夹带私货的问题，这些才是业务场景的独有特性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;围绕观测到的独有特性，去做特殊的处理和优化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总而言之，言而总之，对于生活，多观测多思考，形成自己的决策思路，和产品价值观，哪怕不是自己操刀做一个东西，想想也是极有意思的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.9465648854961832&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqvMexxWOopOqLBDkK4OcleOkgZGq1Nam2wx8KHreT6gcGaEAOHDaREvvGbFfYficNNNkpHKMxiaYRIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;131&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;文章都看完了，还不点个赞来个赏~&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-id=&quot;2255&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;226&quot; data-backw=&quot;578&quot; data-before-oversubscription-url=&quot;https://mmbiz.qlogo.cn/mmbiz_jpg/icr5FVCSvBqvKestzBFLnfCjCM3dqHibqiaNpeU4tUjKw5ehb6Pdumns43uNwbr8VWHE2qJMh1WlSZtibU81nHUdXg/0?wx_fmt=jpeg&quot; data-oversubscription-url=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/icr5FVCSvBqvKestzBFLnfCjCM3dqHibqiadMpRoNxpDgggQFw15AdfibagOvQNbiakdzy3icmLsyTl5G1icl3O1rB3SQ/0?wx_fmt=jpeg&quot; data-ratio=&quot;0.390625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/icr5FVCSvBqvKestzBFLnfCjCM3dqHibqiaNpeU4tUjKw5ehb6Pdumns43uNwbr8VWHE2qJMh1WlSZtibU81nHUdXg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>