<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>810b220539785ee2355a4df72e1c341c</guid>
<title>华为鸿蒙 2.0，让我遇见未来 | 码农周刊第 318 期</title>
<link>https://toutiao.io/k/6rprzrd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;issue&quot; id=&quot;readabilityBody&quot;&gt;
        &lt;h1&gt;华为鸿蒙 2.0，让我遇见未来 | 码农周刊第 318 期&lt;/h1&gt;
        &lt;h2&gt;码农周刊第318期（2020-09-16）&lt;/h2&gt;
        &lt;p&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=318&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3180&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_316.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&amp;#13;
☞ &lt;a href=&quot;https://weekly.manong.io/bounce?nid=318&amp;amp;aid=19803&amp;amp;url=https%3A%2F%2Fwww.sheca.com%2Fassets%2Fwwx%2Fpage1.html%3Fsite%3Dkaifazhe02&quot; target=&quot;_blank&quot;&gt;SHECA 提供 SSL 证书一站式服务，为你的网络安全保驾护航，上海 CA 权威认证&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;small&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=318&amp;amp;aid=19185&amp;amp;url=https%3A%2F%2Fjinshuju.net%2Ff%2FV7DxN9&quot; target=&quot;_blank&quot;&gt;商务合作&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
        
        &lt;h3 id=&quot;程序设计&quot;&gt;程序设计&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;深入讲解&lt;/p&gt;
        
        &lt;p&gt;业界实战&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        &lt;h3 id=&quot;VIP会员专区&quot;&gt;VIP会员专区&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;工作地点：成都 | 薪资：15-30K | 简历投递邮箱：xiexiaofang@huobi.com&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;持续更新&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;帮助大家有针对性地准备面试&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;用于播放特效动画的实现方案。具有高压缩率、硬件解码等优点。同时支持 iOS, Android, Web 平台。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;工具资料&quot;&gt;工具资料&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;各有千秋&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;附 demo&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;收藏吧&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;经验分享&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;深入研究&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;教你用 Deployment 全搞定&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程语言&quot;&gt;编程语言&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;程序员进阶系列&lt;/p&gt;
        
        &lt;p&gt;编程体系结构系列&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;看完这个视频你转头也写了一吨&lt;/p&gt;
        
        &lt;p&gt;类似微信的小程序&lt;/p&gt;
        
        &lt;p&gt;代码示例&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;代码示例&lt;/p&gt;
        &lt;h3 id=&quot;每周独家号推荐&quot;&gt;每周独家号推荐&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;死磕Elasticsearch！&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 272620 即可&lt;/p&gt;
        
        &lt;p&gt;前端 Or NodeJs。喜欢造轮子的懒人&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 95159 即可&lt;/p&gt;
        
        &lt;p&gt;关于计算机很多很多好玩的，一些常见的使用技巧和案例，还有技术方面的&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 72425 即可&lt;/p&gt;
        
        &lt;p&gt;顺势而为; 在技术人的后场; 分享前沿「技术」和「思想」。&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 56624 即可&lt;/p&gt;
        
        &lt;p&gt;五分钟不刷心里发慌&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 378 即可&lt;/p&gt;
        &lt;h3 id=&quot;每周一书&quot;&gt;每周一书&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=318&amp;amp;aid=19870&amp;amp;url=https%3A%2F%2Fu.jd.com%2FDpNS3m&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/book_318.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程之外&quot;&gt;编程之外&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;采访实录&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;p&gt;
        &lt;/p&gt;
        
        
        
        
        &lt;div class=&quot;qrcode&quot;&gt;
  &lt;img src=&quot;https://img.toutiao.io/ads/vip_qrcode.png&quot; alt=&quot;Qrcode 258&quot;/&gt;&lt;span&gt;加入码农周刊VIP会员&lt;/span&gt;
&lt;/div&gt;
    &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8ddf7f48ba84a8c9310c862b46082111</guid>
<title>解密 Go 协程的栈内存管理</title>
<link>https://toutiao.io/k/fkrobd3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应用程序的内存会分成堆区（Heap）和栈区（Stack）两个部分，&lt;strong&gt;程序在运行期间可以主动从堆区申请内存空间，这些内存由内存分配器分配并由垃圾收集器负责回收&lt;/strong&gt;。&lt;strong&gt;栈区的内存由编译器自动进行分配和释放，栈区中存储着函数的参数以及局部变量，它们会随着函数的创建而创建，函数的返回而销毁&lt;/strong&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;网管碎碎念：&lt;/strong&gt;堆和栈都是编程语言里的虚拟概念，并不是说在物理内存上有堆和栈之分，两者的主要区别是栈是每个线程或者协程独立拥有的，从栈上分配内存时不需要加锁。而整个程序在运行时只有一个堆，从堆中分配内存时需要加锁防止多个线程造成冲突，同时回收堆上的内存块时还需要运行可达性分析、引用计数等算法来决定内存块是否能被回收，所以从分配和回收内存的方面来看栈内存效率更高。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;Go&lt;/code&gt;应用程序运行时，每个&lt;code&gt;goroutine&lt;/code&gt;都维护着一个自己的栈区，这个栈区只能自己使用不能被其他&lt;code&gt;goroutine&lt;/code&gt;使用。&lt;strong&gt;栈区的初始大小是2KB&lt;/strong&gt;（比x86_64架构下线程的默认栈2M要小很多），在&lt;code&gt;goroutine&lt;/code&gt;运行的时候栈区会按照需要增长和收缩，占用的内存最大限制的默认值在64位系统上是1GB。栈大小的初始值和上限这部分的设置都可以在&lt;code&gt;Go&lt;/code&gt;的源码&lt;code&gt;runtime/stack.go&lt;/code&gt;里找到：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// rumtime.stack.go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// The minimum size of stack used by Go code&lt;/span&gt;&lt;br/&gt;_StackMin = &lt;span&gt;2048&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; maxstacksize &lt;span&gt;uintptr&lt;/span&gt; = &lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;20&lt;/span&gt; &lt;span&gt;// enough until runtime.main sets it for real&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实栈内存空间、结构和初始大小在最开始并不是2KB，也是经过了几个版本的更迭&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;v1.0 ~ v1.1 — 最小栈内存空间为 4KB；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;v1.2 — 将最小栈内存提升到了 8KB；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;v1.3 — 使用&lt;strong&gt;连续栈&lt;/strong&gt;替换之前版本的分段栈；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;v1.4 — 将最小栈内存降低到了 2KB；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;分段栈和连续栈&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;分段栈&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 1.3 版本前使用的栈结构是分段栈，随着&lt;code&gt;goroutine&lt;/code&gt; 调用的函数层级的深入或者局部变量需要的越来越多时，运行时会调用 &lt;code&gt;runtime.morestack&lt;/code&gt; 和 &lt;code&gt;runtime.newstack&lt;/code&gt;创建一个新的栈空间，这些栈空间是不连续的，但是当前 &lt;code&gt;goroutine&lt;/code&gt; 的多个栈空间会以双向链表的形式串联起来，运行时会通过指针找到连续的栈片段：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9885931558935361&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f4FKriblLnWa6aXcpXyuysvWWo5VhvVBial7Ticl7855OhSCD9dgMp1qzyibJ1DWs0QicRR97icAU7I134w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1052&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分段栈虽然能够按需为当前 &lt;code&gt;goroutine&lt;/code&gt; 分配内存并且及时减少内存的占用，但是它也存在一个比较大的问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果当前 &lt;code&gt;goroutine&lt;/code&gt; 的栈几乎充满，那么任意的函数调用都会触发栈的扩容，当函数返回后又会触发栈的收缩，如果在一个循环中调用函数，栈的分配和释放就会造成巨大的额外开销，这被称为热分裂问题（Hot split）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决这个问题，Go在1.2版本的时候不得不将栈的初始化内存从4KB增大到了8KB。后来把采用连续栈结构后，又把初始栈大小减小到了2KB。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;连续栈&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;连续栈可以解决分段栈中存在的两个问题，其核心原理就是每当程序的栈空间不足时，初始化一片比旧栈大两倍的新栈并将原栈中的所有值都迁移到新的栈中，新的局部变量或者函数调用就有了充足的内存空间。使用连续栈机制时，栈空间不足导致的扩容会经历以下几个步骤：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;调用用&lt;code&gt;runtime.newstack&lt;/code&gt;在内存空间中分配更大的栈内存空间；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用&lt;code&gt;runtime.copystack&lt;/code&gt;将旧栈中的所有内容复制到新的栈中；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;将指向旧栈对应变量的指针重新指向新栈&lt;/strong&gt;；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用&lt;code&gt;runtime.stackfree&lt;/code&gt;销毁并回收旧栈的内存空间；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6382730455075846&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f4FKriblLnWa6aXcpXyuysvWbfJaj1C2qAyjuLXK51PkV6PPIRWuyRFUgL60Pb6c9a18MsrhmEs6wg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1714&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;copystack&lt;/code&gt;会把旧栈里的所有内容拷贝到新栈里然后调整所有指向旧栈的变量的指针指向到新栈， 我们可以用下面这个程序验证下，栈扩容后同一个变量的内存地址会发生变化。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; x [&lt;span&gt;10&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;&lt;br/&gt; &lt;span&gt;println&lt;/span&gt;(&amp;amp;x)&lt;br/&gt; a(x)&lt;br/&gt; &lt;span&gt;println&lt;/span&gt;(&amp;amp;x)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//go:noinline&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;a&lt;/span&gt;&lt;span&gt;(x [10]&lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;println&lt;/span&gt;(&lt;span&gt;`func a`&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; y [&lt;span&gt;100&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;&lt;br/&gt; b(y)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//go:noinline&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;b&lt;/span&gt;&lt;span&gt;(x [100]&lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;println&lt;/span&gt;(&lt;span&gt;`func b`&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; y [&lt;span&gt;1000&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;&lt;br/&gt; c(y)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//go:noinline&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;c&lt;/span&gt;&lt;span&gt;(x [1000]&lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;println&lt;/span&gt;(&lt;span&gt;`func c`&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序的输出可以看到在栈扩容前后，变量&lt;code&gt;x&lt;/code&gt;的内存地址的变化：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;0xc000030738&lt;br/&gt;...&lt;br/&gt;...&lt;br/&gt;0xc000081f38&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;栈区的内存管理&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面说了每个&lt;code&gt;goroutine&lt;/code&gt;都维护着自己的栈区，栈结构是连续栈，是一块连续的内存，在&lt;code&gt;goroutine&lt;/code&gt;的类型定义的源码里我们可以找到标记着栈区边界的&lt;code&gt;stack&lt;/code&gt;信息，&lt;code&gt;stack&lt;/code&gt;里记录着栈区边界的高位内存地址和低位内存地址：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; g &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; stack       stack&lt;br/&gt;  ...&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; stack &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; lo &lt;span&gt;uintptr&lt;/span&gt;&lt;br/&gt; hi &lt;span&gt;uintptr&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;全局栈缓存&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;栈空间在运行时中包含两个重要的全局变量，分别是 &lt;code&gt;runtime.stackpool&lt;/code&gt; 和&lt;code&gt;runtime.stackLarge&lt;/code&gt;，这两个变量分别表示全局的栈缓存和大栈缓存，前者可以分配小于 32KB 的内存，后者用来分配大于 32KB 的栈空间：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;// Number of orders that get caching. Order 0 is FixedStack&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// and each successive order is twice as large.&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// We want to cache 2KB, 4KB, 8KB, and 16KB stacks. Larger stacks&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// will be allocated directly.&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// Since FixedStack is different on different systems, we&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// must vary NumStackOrders to keep the same maximum cached size.&lt;/span&gt;&lt;br/&gt; &lt;span&gt;//   OS               | FixedStack | NumStackOrders&lt;/span&gt;&lt;br/&gt; &lt;span&gt;//   -----------------+------------+---------------&lt;/span&gt;&lt;br/&gt; &lt;span&gt;//   linux/darwin/bsd | 2KB        | 4&lt;/span&gt;&lt;br/&gt; &lt;span&gt;//   windows/32       | 4KB        | 3&lt;/span&gt;&lt;br/&gt; &lt;span&gt;//   windows/64       | 8KB        | 2&lt;/span&gt;&lt;br/&gt; &lt;span&gt;//   plan9            | 4KB        | 3&lt;/span&gt;&lt;br/&gt;_NumStackOrders = &lt;span&gt;4&lt;/span&gt; - sys.PtrSize/&lt;span&gt;4&lt;/span&gt;*sys.GoosWindows - &lt;span&gt;1&lt;/span&gt;*sys.GoosPlan9&lt;br/&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; stackpool [_NumStackOrders]mSpanList&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; stackpoolItem &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; mu   mutex&lt;br/&gt; span mSpanList&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; stackLarge &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; lock mutex&lt;br/&gt; free [heapAddrBits - pageShift]mSpanList&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//go:notinheap&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; mSpanList &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; first *mspan &lt;span&gt;// first span in list, or nil if none&lt;/span&gt;&lt;br/&gt; last  *mspan &lt;span&gt;// last span in list, or nil if none&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到这两个用于分配空间的全局变量都与内存管理单元 &lt;code&gt;runtime.mspan&lt;/code&gt; 有关，所以我们栈内容的申请也是跟前面文章里的一样，先去当前线程的对应尺寸的&lt;code&gt;mcache&lt;/code&gt;里去申请，不够的时候&lt;code&gt;mache&lt;/code&gt;会从全局的&lt;code&gt;mcental&lt;/code&gt;里取内存等等，想了解这部分具体细节的同学可以参考前面的文章&lt;strong&gt;《&lt;/strong&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&amp;amp;mid=2247485736&amp;amp;idx=1&amp;amp;sn=921a9dfe3d638074b68a4fd072ea3cb9&amp;amp;chksm=fa80d8bfcdf751a948ea49ee620ca9d88ff0a62b4ad4e3a53321fee6813b8f90098fd72f7b11&amp;amp;token=401640573&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;图解Go内存管理器的内存分配策略&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;》&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实从调度器和内存分配的角度来看，如果运行时只使用全局变量来分配内存的话，势必会造成线程之间的锁竞争进而影响程序的执行效率，栈内存由于与线程关系比较密切，所以在每一个线程缓存 &lt;code&gt;runtime.mcache&lt;/code&gt; 中都加入了栈缓存减少锁竞争影响。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; mcache &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;  ...&lt;br/&gt;  alloc [numSpanClasses]*mspan&lt;br/&gt;  &lt;br/&gt; stackcache [_NumStackOrders]stackfreelist&lt;br/&gt;  ...&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; stackfreelist &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; list gclinkptr&lt;br/&gt; size &lt;span&gt;uintptr&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;栈扩容&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译器会为函数调用插入运行时检查&lt;code&gt;runtime.morestack&lt;/code&gt;，它会在几乎所有的函数调用之前检查当前&lt;code&gt;goroutine&lt;/code&gt; 的栈内存是否充足，如果当前栈需要扩容，会调用&lt;code&gt;runtime.newstack&lt;/code&gt; 创建新的栈：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;newstack&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   ......&lt;br/&gt;   &lt;span&gt;// Allocate a bigger segment and move the stack.&lt;/span&gt;&lt;br/&gt;   oldsize := gp.stack.hi - gp.stack.lo&lt;br/&gt;   newsize := oldsize * &lt;span&gt;2&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; newsize &amp;gt; maxstacksize {&lt;br/&gt;       &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;runtime: goroutine stack exceeds &quot;&lt;/span&gt;, maxstacksize, &lt;span&gt;&quot;-byte limit\n&quot;&lt;/span&gt;)&lt;br/&gt;      throw(&lt;span&gt;&quot;stack overflow&quot;&lt;/span&gt;)&lt;br/&gt;   }&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;// The goroutine must be executing in order to call newstack,&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;// so it must be Grunning (or Gscanrunning).&lt;/span&gt;&lt;br/&gt;   casgstatus(gp, _Grunning, _Gcopystack)&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;// The concurrent GC will not scan the stack while we are doing the copy since&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;// the gp is in a Gcopystack status.&lt;/span&gt;&lt;br/&gt;   copystack(gp, newsize, &lt;span&gt;true&lt;/span&gt;)&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; stackDebug &amp;gt;= &lt;span&gt;1&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;stack grow done\n&quot;&lt;/span&gt;)&lt;br/&gt;   }&lt;br/&gt;   casgstatus(gp, _Gcopystack, _Grunning)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;旧栈的大小是通过我们上面说的保存在&lt;code&gt;goroutine&lt;/code&gt;中的&lt;code&gt;stack&lt;/code&gt;信息里记录的栈区内存边界计算出来的，然后用旧栈两倍的大小创建新栈，创建前会检查是新栈的大小是否超过了单个栈的内存上限。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;   oldsize := gp.stack.hi - gp.stack.lo&lt;br/&gt;   newsize := oldsize * &lt;span&gt;2&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; newsize &amp;gt; maxstacksize {&lt;br/&gt;       &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;runtime: goroutine stack exceeds &quot;&lt;/span&gt;, maxstacksize, &lt;span&gt;&quot;-byte limit\n&quot;&lt;/span&gt;)&lt;br/&gt;      throw(&lt;span&gt;&quot;stack overflow&quot;&lt;/span&gt;)&lt;br/&gt;   }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果目标栈的大小没有超出程序的限制，会将 &lt;code&gt;goroutine&lt;/code&gt; 切换至 &lt;code&gt;_Gcopystack&lt;/code&gt; 状态并调用 &lt;code&gt;runtime.copystack&lt;/code&gt; 开始栈的拷贝，在拷贝栈的内存之前，运行时会先通过&lt;code&gt;runtime.stackalloc&lt;/code&gt; 函数分配新的栈空间：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;copystack&lt;/span&gt;&lt;span&gt;(gp *g, newsize &lt;span&gt;uintptr&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; old := gp.stack&lt;br/&gt; used := old.hi - gp.sched.sp&lt;br/&gt;  &lt;span&gt;// 创建新栈&lt;/span&gt;&lt;br/&gt; &lt;span&gt;new&lt;/span&gt; := stackalloc(&lt;span&gt;uint32&lt;/span&gt;(newsize))&lt;br/&gt; ...&lt;br/&gt;  &lt;span&gt;// 把旧栈的内容拷贝至新栈&lt;/span&gt;&lt;br/&gt; memmove(unsafe.Pointer(&lt;span&gt;new&lt;/span&gt;.hi-ncopy), unsafe.Pointer(old.hi-ncopy), ncopy)&lt;br/&gt;  ...&lt;br/&gt;  &lt;span&gt;// 调整指针&lt;/span&gt;&lt;br/&gt;  adjustctxt(gp, &amp;amp;adjinfo)&lt;br/&gt;  &lt;span&gt;// groutine里记录新栈的边界&lt;/span&gt;&lt;br/&gt;  gp.stack = &lt;span&gt;new&lt;/span&gt;&lt;br/&gt;  ...&lt;br/&gt;  &lt;span&gt;// 释放旧栈&lt;/span&gt;&lt;br/&gt;  stackfree(old)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新栈的初始化和数据的复制是一个比较简单的过程，整个过程中最复杂的地方是将指向源栈中内存的指针调整为指向新的栈，这一步完成后就会释放掉旧栈的内存空间了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以通过修改一下源码文件&lt;code&gt;runtime.stack.go&lt;/code&gt;，把常量&lt;code&gt;stackDebug&lt;/code&gt;的值修改为1，使用命令&lt;strong&gt;go build -gcflags -S main.go&lt;/strong&gt; 运行文章最开始的那个例子，观察栈的初始化和扩容过程：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;stackalloc 2048&lt;br/&gt;stackcacherefill order=0&lt;br/&gt;  allocated 0xc000030000&lt;br/&gt;...&lt;br/&gt;copystack gp=0xc000000180 [0xc000030000 0xc0000306e0 0xc000030800] -&amp;gt; [0xc00005c000 0xc00005cee0 0xc00005d000]/4096&lt;br/&gt;stackfree 0xc000030000 2048&lt;br/&gt;stack grow done&lt;br/&gt;...&lt;br/&gt;copystack gp=0xc000000180 [0xc00005c000 0xc00005c890 0xc00005d000] -&amp;gt; [0xc000064000 0xc000065890 0xc000066000]/8192&lt;br/&gt;stackfree 0xc00005c000 4096&lt;br/&gt;stack grow done&lt;br/&gt;...&lt;br/&gt;copystack gp=0xc000000180 [0xc000064000 0xc000065890 0xc000066000] -&amp;gt; [0xc00006c000 0xc00006f890 0xc000070000]/16384&lt;br/&gt;stackfree 0xc000064000 8192&lt;br/&gt;stack grow done&lt;br/&gt;...&lt;br/&gt;copystack gp=0xc000000180 [0xc00006c000 0xc00006f890 0xc000070000] -&amp;gt; [0xc000070000 0xc000077890 0xc000078000]/32768&lt;br/&gt;stackfree 0xc00006c000 16384&lt;br/&gt;stack grow done&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;栈缩容&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;goroutine&lt;/code&gt;运行的过程中，如果栈区的空间使用率不超过1/4，那么在垃圾回收的时候使用&lt;code&gt;runtime.shrinkstack&lt;/code&gt;进行栈缩容，当然进行缩容前会执行一堆前置检查，都通过了才会进行缩容&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;shrinkstack&lt;/span&gt;&lt;span&gt;(gp *g)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; ...&lt;br/&gt; oldsize := gp.stack.hi - gp.stack.lo&lt;br/&gt; newsize := oldsize / &lt;span&gt;2&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; newsize &amp;lt; _FixedStack {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; avail := gp.stack.hi - gp.stack.lo&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; used := gp.stack.hi - gp.sched.sp + _StackLimit; used &amp;gt;= avail/&lt;span&gt;4&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; copystack(gp, newsize)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果要触发栈的缩容，新栈的大小会是原始栈的一半，不过如果新栈的大小低于程序的最低限制 2KB，那么缩容的过程就会停止。缩容也会调用扩容时使用的 &lt;code&gt;runtime.copystack&lt;/code&gt; 函数开辟新的栈空间，将旧栈的数据拷贝到新栈以及调整原来指针的指向。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们上面的那个例子里，当&lt;code&gt;main&lt;/code&gt;函数里的其他函数执行完后，只有&lt;code&gt;main&lt;/code&gt;函数还在栈区的空间里，如果这个时候系统进行垃圾回收就会对这个&lt;code&gt;goroutine&lt;/code&gt;的栈区进行缩容。在这里我们可以在程序里通过调用&lt;code&gt;runtime.GC&lt;/code&gt;，强制系统进行垃圾回收，来试验看一下栈缩容的过程和效果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;var&lt;/span&gt; x [&lt;span&gt;10&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;println&lt;/span&gt;(&amp;amp;x)&lt;br/&gt;   a(x)&lt;br/&gt;   runtime.GC()&lt;br/&gt;   &lt;span&gt;println&lt;/span&gt;(&amp;amp;x)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行命令&lt;strong&gt;go build -gcflags -S main.go&lt;/strong&gt;后会看到类似下面的输出。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;...&lt;br/&gt;shrinking stack 32768-&amp;gt;16384&lt;br/&gt;stackalloc 16384&lt;br/&gt;  allocated 0xc000076000&lt;br/&gt;copystack gp=0xc000000180 [0xc00007a000 0xc000081e60 0xc000082000] -&amp;gt; [0xc000076000 0xc000079e60 0xc00007a000]/16384&lt;br/&gt;...&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;栈内存是应用程序中重要的内存空间，它能够支持本地的局部变量和函数调用，栈空间中的变量会与栈一同创建和销毁，这部分内存空间不需要工程师过多的干预和管理，现代的编程语言通过逃逸分析减少了我们的工作量，理解栈内存空间的分配对于理解 Go 语言的运行时有很大的帮助。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;看到这里了，如果喜欢我的文章可以帮我点个赞和在看把分享给更多小伙伴，我会每周通过技术文章分享我的所学所见，感谢你的支持。微信搜索关注公众号「网管叨bi叨」第一时间获取我的文章推送。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5aaaa176096ebb7ef2f554d7c9d391d5</guid>
<title>伪造图像的对抗攻击，从天池大赛说起</title>
<link>https://toutiao.io/k/zsqz9o0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6246819338422391&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BJbRvwibeSTusicGZ66FeJjhsE4eqMeClrvqgAgCNNycO3POCtUibA6FxvKibIicekhewn8qoFLpGnGUsh5BHibG7jJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;786&quot;/&gt;&lt;/p&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3674767&quot; data-style-type=&quot;&quot;/&gt;&lt;p&gt;每张图像限定五个区域进行篡改如下图所示四个红框位置加上盖章：&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.68125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BJbRvwibeSTusicGZ66FeJjhsE4eqMeClreL4vHgrWcGPaT9TD7oA8licPicUzYstBKZoEDZy4xHl2ePXyRQxZBbxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;p&gt;参赛者从10个类别中各任意选择2张进行伪造篡改，最终需要提交20张篡改图像即可。给定参赛者的数据时，同一张图像额外给定一张标定篡改位置信息的图像。篡改操作不限定（如splicing、copy-move、object removal等任意操作），允许进行后处理（如高斯模糊，JPEG压缩等）。并且不需要考虑图像的元数据。&lt;/p&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3588346&quot; data-style-type=&quot;&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;    04    &lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Error Level Analysis&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;模型&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;本次比赛的检测模型有两个黑盒模型和一个ELA模型。其中ELA的英文全称是Error Level Analysis ，汉译为“错误级别分析”或者叫“误差分析”。它是通过检测特定压缩比率重新绘制图片后造成的误差分布，可用于识别JPEG图片的压缩。&lt;/p&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3762213&quot; data-style-type=&quot;&quot;&gt;&lt;p&gt;&lt;span&gt;►ELA原理&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;它把图片分割成很多个正方形中的1像素点，对每一个小块进行单独的色彩空间转换。每次对JPG图片的修改，都会进行第二次转换。两次转换自然会存在差异，ELA就是靠对比这种差异来判断图片的哪部分被修改过。ELA检测可以分为以下三部分：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;点，指画面中的重复纹理或者类似数据，重复纹理在ELA分析的时候应该表现出近似的颜色，细节较多的区域数据差异也应该大。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;线，是不同颜色大面之间的交界线，相同反差边缘应该表现出近似的ELA结果。反差越大，ELA值越高，线条越清晰&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;面，纯色面不存在差异，也就不存在ELA，黑色或黑色着色。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;如下图所示为ELA模型检测图像的效果示意图，左图和右图比对可以发现，图中嘴唇，衬衫，眼睛人脸和形体轮廓区域是高亮的，说明这些区域被修改过。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.3441822620016273&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BJbRvwibeSTusicGZ66FeJjhsE4eqMeClrc4bEMuTvNz3DohvAQkVa2AGNsUYxaXRicUj6LweROMmshxYMORwhzOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1229&quot;/&gt;&lt;/p&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3762213&quot; data-style-type=&quot;&quot;&gt;&lt;p&gt;&lt;span&gt;►模型获取&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;在github中挑选出比较好的ELA模型摘选自于文章《A Picture’s Worth 》 该程序是用keras编写的，环境配置容易而且程序简洁易懂很好实现，如下图所示核心代码短小精悍。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.32265625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BJbRvwibeSTusicGZ66FeJjhsE4eqMeClrCT6l7VrX91I1G91FVw630YW4Z46CSmqzxBa2fQLB1rCxkbticibPeqOA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3674767&quot; data-style-type=&quot;&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;除此之外&lt;/span&gt;&lt;span&gt;，还有两个demo可以尝试用一下，在比赛中也有起到一定的帮助。&lt;/span&gt;&lt;span&gt;一个是FotoForensics ，另一个是Forensically ，这两个demo的界面如下图所示：&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.29296875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BJbRvwibeSTusicGZ66FeJjhsE4eqMeClrg7f4oupNZ5KzB5t8qrmmRmG6Jicet2kBSqJwkB8sx330UE55NkYCeZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4453125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BJbRvwibeSTusicGZ66FeJjhsE4eqMeClrUxXLEFWX2BuYgchkxoicUoXoqRtno5GmxSnrXqCp2rlmFibUCFicq2bGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3674767&quot; data-style-type=&quot;&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3588346&quot; data-style-type=&quot;&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;    05    &lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;指标介绍&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;参赛选手在每个提供的图像上都可以对选择图像的候选5个区域进行伪造篡改。&lt;/span&gt;&lt;span&gt;其中对P图的方式和后处理方式没有任何限制，但是会要求篡改痕迹尽量肉眼不可见。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;选手得分由四部分构成：&lt;span&gt;未检出篡改的比例、候选区域内篡改像素比例、候选区域外像素变化的比例、篡改区域背景一致性&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;为了保证比赛的难度，主办方选取了4种经典图像取证算法作为攻击目标，包括1个白盒模型—Error Level Analysis (ELA)和另外3个未知的黑盒模型。&lt;/p&gt;&lt;p&gt;在进行评估时，需要使用原始图像减去修改后的图像，得到修改量，然后分别计算候选区域外未修改得分和区域内的修改得分，同时计算篡改区域背景一致性得分，图像在4个检测模型的检测得分。&lt;/p&gt;&lt;p&gt;候选区域外像素变化越小，得分越高；候选区域内，改动的差异越大，的得分越高；篡改区域背景一致性越高，的得分越高；候选区域内修改内容越难被检测，得分越高。为了保证篡改符合场景语义，主办方对图像伪造篡改进行如下限制：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.16538461538461538&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BJbRvwibeSTusicGZ66FeJjhsE4eqMeClrv8Ua9ILNQcB0DzLq9Af3w3qZPtcCEJrmLDtIHyibYqZZbAvLaySoFibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;780&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cbce16035db7affeee9f5fb7c5ff34d9</guid>
<title>使用 Docker 快速上手鸿蒙</title>
<link>https://toutiao.io/k/4enrvyp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-content&quot; id=&quot;post-content&quot; itemprop=&quot;postContent&quot;&gt;
            &lt;h3 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;/&gt;准备&lt;/h3&gt;
&lt;h3 id=&quot;编译鸿蒙系统镜像&quot;&gt;&lt;a href=&quot;#编译鸿蒙系统镜像&quot; class=&quot;headerlink&quot; title=&quot;编译鸿蒙系统镜像&quot;/&gt;编译鸿蒙系统镜像&lt;/h3&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mkdir ~/OpenHarmony&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;cd ~/OpenHarmony&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;docker run --rm -ti -v ${PWD}/out:/OpenHarmony/out ystyle/open-harmony&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;编译成功后各镜像在out目录下面, 默认编译的是&lt;code&gt;Hi3861&lt;/code&gt;开发板的系统镜像, 可自行烧录到固定测试&lt;/li&gt;
&lt;li&gt;如果要编译其它板子可以设置dokcer镜像的环境变量&lt;code&gt;HARDWARE&lt;/code&gt; 目前支持: &lt;code&gt;wifiiot&lt;/code&gt;、&lt;code&gt;ipcamera_hi3516dv300&lt;/code&gt;、&lt;code&gt;ipcamera_hi3518ev300&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;编写应用程序&quot;&gt;&lt;a href=&quot;#编写应用程序&quot; class=&quot;headerlink&quot; title=&quot;编写应用程序&quot;/&gt;编写应用程序&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;示例在这&lt;a href=&quot;https://openharmony.gitee.com/openharmony/docs/blob/master/quick-start/Hi3861%E5%BC%80%E5%8F%91%E6%9D%BF%E7%AC%AC%E4%BA%8C%E4%B8%AA%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hi3861开发板第二个示例程序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;创建一个代码目录: &lt;code&gt;my_first_app&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;新建文件&lt;code&gt;hello_world.c&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&quot;ohos_init.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&quot;ohos_types.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HelloWorld&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;/&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;[DEMO] Hello world.\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;SYS_RUN(HelloWorld);&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;新建文件&lt;code&gt;BUILD.gn&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;static_library(&lt;span class=&quot;string&quot;&gt;&quot;myapp&quot;&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  sources = [&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;string&quot;&gt;&quot;hello_world.c&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  ]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  include_dirs = [&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;string&quot;&gt;&quot;//utils/native/liteos/include&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  ]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;新建文件&lt;code&gt;APP_BUILD.gn&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;//build/lite/config/component/lite_component.gni&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;lite_component(&lt;span class=&quot;string&quot;&gt;&quot;app&quot;&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    features = [&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&quot;my_first_app:myapp&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    ]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;现在的目录结构为&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;.&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;├── APP_BUILD.gn&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;├── BUILD.gn&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;└── hello_world.c&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;编译代码&quot;&gt;&lt;a href=&quot;#编译代码&quot; class=&quot;headerlink&quot; title=&quot;编译代码&quot;/&gt;编译代码&lt;/h3&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker run --rm \&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  -e HARDWARE=wifiiot \&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  -v ${PWD}/out:/OpenHarmony/out \&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  -v ${PWD}/APP_BUILD.gn:/OpenHarmony/applications/sample/wifi-iot/app/APP_BUILD.gn \&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  -v ${PWD}:/OpenHarmony/applications/sample/wifi-iot/app/my_first_app \&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  ystyle/open-harmony&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;编译后的文件在out目录&lt;br/&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;.&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;├── APP_BUILD.gn&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;├── BUILD.gn&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;├── hello_world.c&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;└── out&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    └── wifiiot&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;其它问题&quot;&gt;&lt;a href=&quot;#其它问题&quot; class=&quot;headerlink&quot; title=&quot;其它问题&quot;/&gt;其它问题&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;如果实际开发，建议直接替换掉 整个&lt;code&gt;/OpenHarmony/applications/sample/wifi-iot/app/&lt;/code&gt; 目录, 目录里边的都是示例代码.&lt;/li&gt;
&lt;li&gt;如果要修改启动编译的命令的话，可以写好shell 脚本， run时指定cmd命令&lt;ul&gt;
&lt;li&gt;构建命令为: &lt;code&gt;python build.py ${HARDWARE} -b debug&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker run --rm -v ${PWD}/mybuild.sh:/OpenHarmony/mybuild.sh ystyle/open-harmony /OpenHarmony/mybuild.sh&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;更新鸿蒙代码: 用修改镜像启动命令的方法，在&lt;code&gt;/OpenHarmony&lt;/code&gt;目录执行&lt;code&gt;repo sync -c&lt;/code&gt; 命令&lt;/li&gt;
&lt;li&gt;其它驱动开发或系统组件开发也可以用挂载的方式把工程目录映射到容器，开发并编译&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;本文所使用Docker镜像的dockerfile文件&quot;&gt;&lt;a href=&quot;#本文所使用Docker镜像的dockerfile文件&quot; class=&quot;headerlink&quot; title=&quot;本文所使用Docker镜像的dockerfile文件&quot;/&gt;本文所使用Docker镜像的dockerfile文件&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;参考&lt;code&gt;@keithyau&lt;/code&gt;&lt;a href=&quot;https://openharmony.gitee.com/keithyau/build_lite/blob/master/Dockerfile20.04&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;所写的Dockerfile&lt;/a&gt;修改而来&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight dockerfile&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;85&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;FROM&lt;/span&gt; ubuntu:&lt;span class=&quot;number&quot;&gt;20.04&lt;/span&gt; AS build-&lt;span class=&quot;keyword&quot;&gt;env&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;LABEL&lt;/span&gt; version=2020-09-10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Set your hardware&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;ENV&lt;/span&gt; HARDWARE=wifiiot&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Prevent interactive&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;ENV&lt;/span&gt; DEBIAN_FRONTEND=noninteractive&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Setting up the build environment&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;RUN&lt;/span&gt; sed -i &#x27;s/archive.ubuntu.com/mirrors.tuna.tsinghua.edu.cn/g&#x27; /etc/apt/sources.list &amp;amp;&amp;amp; \&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    sed -i &#x27;s/security.ubuntu.com/mirrors.tuna.tsinghua.edu.cn/g&#x27; /etc/apt/sources.list &amp;amp;&amp;amp; \&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    apt-get clean -y &amp;amp;&amp;amp; \&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    apt-get -y update &amp;amp;&amp;amp; \&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    apt-get remove python* -y &amp;amp;&amp;amp; \&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    apt-get install git curl build-essential libdbus-glib-1-dev libgirepository1.0-dev -y &amp;amp;&amp;amp; \&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    apt-get install zip libncurses5-dev pkg-config -y &amp;amp;&amp;amp; \&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    apt-get install python3-pip -y &amp;amp;&amp;amp; \&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    apt-get install scons dosfstools mtools -y &amp;amp;&amp;amp; \&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    rm -rf /var/lib/apt/lists/*&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Setup python&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Make sure python install on the right python version path&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;RUN&lt;/span&gt; update-alternatives --install /usr/bin/python python /usr/bin/python3.8 1 &amp;amp;&amp;amp; \&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    pip3 install --upgrade pip -i https://mirrors.aliyun.com/pypi/simple &amp;amp;&amp;amp; \&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    pip3 install ninja kconfiglib pycryptodome ecdsa -i https://mirrors.aliyun.com/pypi/simple &amp;amp;&amp;amp; \&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    pip3 install six --upgrade --ignore-installed six -i https://pypi.tuna.tsinghua.edu.cn/simple &amp;amp;&amp;amp; \&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    rm -rf /var/cache/apt/archives&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#Fix Dash&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;RUN&lt;/span&gt; rm -rf /bin/sh &amp;amp;&amp;amp; \&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    ln -s /bin/bash /bin/sh&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#Setup gn&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;ENV&lt;/span&gt; PATH /tools/gn:$PATH&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;RUN&lt;/span&gt; mkdir /tools &amp;amp;&amp;amp; \&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    cd /tools &amp;amp;&amp;amp; \&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    curl -LO http://tools.harmonyos.com/mirrors/gn/1523/linux/gn.1523.tar &amp;amp;&amp;amp; \&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    tar xvf /tools/gn.1523.tar &amp;amp;&amp;amp; \&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    rm -rf /tools/gn.1523.tar&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#Setup LLVM&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#ADD ./llvm-linux-9.0.0-34042.tar /tools&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;ENV&lt;/span&gt; PATH /tools/llvm/bin:$PATH&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;RUN&lt;/span&gt; cd /tools &amp;amp;&amp;amp; \&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    curl -LO http://tools.harmonyos.com/mirrors/clang/9.0.0-34042/linux/llvm-linux-9.0.0-34042.tar &amp;amp;&amp;amp; \&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    tar xvf /tools/llvm-linux-9.0.0-34042.tar &amp;amp;&amp;amp; \&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    rm -rf /tools/llvm-linux-9.0.0-34042.tar&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#Setup hc-gen&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;ENV&lt;/span&gt; PATH /tools/hc-gen:$PATH&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;RUN&lt;/span&gt; cd /tools &amp;amp;&amp;amp; \&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    curl -LO http://tools.harmonyos.com/mirrors/hc-gen/0.64/linux/hc-gen-0.64-linux.tar &amp;amp;&amp;amp; \&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    tar xvf /tools/hc-gen-0.64-linux.tar &amp;amp;&amp;amp; \&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    rm -rf /tools/hc-gen-0.64-linux.tar&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#Setup gcc_riscv32&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;ENV&lt;/span&gt; PATH /tools/gcc_riscv32/bin:$PATH&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;RUN&lt;/span&gt; cd /tools &amp;amp;&amp;amp; \&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    curl -LO http://tools.harmonyos.com/mirrors/gcc_riscv32/7.3.0/linux/gcc_riscv32-linux-7.3.0.tar.gz &amp;amp;&amp;amp; \&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    tar xvf /tools/gcc_riscv32-linux-7.3.0.tar.gz &amp;amp;&amp;amp; \&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    rm -rf /tools/gcc_riscv32-linux-7.3.0.tar.gz&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#Create work dir&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;RUN&lt;/span&gt; mkdir /OpenHarmony&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;WORKDIR&lt;/span&gt; /OpenHarmony&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Gitee Repo tool and download&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Make sure requests install at the right location&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;RUN&lt;/span&gt; curl https://gitee.com/oschina/repo/raw/fork_flow/repo-py3 &amp;gt; /usr/bin/repo &amp;amp;&amp;amp; \&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    chmod a+x /usr/bin/repo &amp;amp;&amp;amp; \&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple requests&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#Download source, update to your info&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;RUN&lt;/span&gt; git config --global user.email &quot;lxy5266@live.com&quot; &amp;amp;&amp;amp; \&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    git config --global user.name &quot;ystyle&quot; &amp;amp;&amp;amp; \&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    git config --global color.ui false &amp;amp;&amp;amp; \&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    git config --global credential.helper store &amp;amp;&amp;amp; \&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    repo init -u https://gitee.com/openharmony/manifest.git -b master --repo-branch=stable --no-repo-verify &amp;amp;&amp;amp; \&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    repo sync -c&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# compile&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;ENV&lt;/span&gt; LANGUAGE en&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;ENV&lt;/span&gt; LANG en_US.utf-&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;RUN&lt;/span&gt; export|grep LANG&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;CMD&lt;/span&gt; [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;python build.py ${HARDWARE} -b debug&quot;]&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

        &lt;/div&gt;

        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d17eed5811466a71dd1f0a0c1bba9f79</guid>
<title>[译] ASP.NET Core 性能优化最佳实践</title>
<link>https://toutiao.io/k/zg5jilb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-body&quot; itemprop=&quot;articleBody&quot;&gt;&lt;p&gt;本文提供了 ASP.NET Core 的性能最佳实践指南。&lt;/p&gt;&lt;p&gt;译文原文地址：&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/performance/performance-best-practices?view=aspnetcore-3.1&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;https://docs.microsoft.com/en-us/aspnet/core/performance/performance-best-practices?view=aspnetcore-3.1&lt;/a&gt;&lt;/p&gt;&lt;a id=&quot;more&quot;/&gt;&lt;h2 id=&quot;积极利用缓存&quot;&gt;&lt;a href=&quot;#积极利用缓存&quot; class=&quot;headerlink&quot; title=&quot;积极利用缓存&quot;/&gt;积极利用缓存&lt;/h2&gt;&lt;p&gt;这里有一篇文档在多个部分中讨论了如何积极利用缓存。 有关详细信息，请参阅︰ &lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/performance/caching/response?view=aspnetcore-3.1&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;https://docs.microsoft.com/en-us/aspnet/core/performance/caching/response?view=aspnetcore-3.1&lt;/a&gt;.&lt;/p&gt;&lt;h2 id=&quot;了解代码中的热点路径&quot;&gt;&lt;a href=&quot;#了解代码中的热点路径&quot; class=&quot;headerlink&quot; title=&quot;了解代码中的热点路径&quot;/&gt;了解代码中的热点路径&lt;/h2&gt;&lt;p&gt;在本文档中， &lt;em&gt;代码热点路径&lt;/em&gt; 定义为频繁调用的代码路径以及执行时间的大部分时间。 代码热点路径通常限制应用程序的扩展和性能，并在本文档的多个部分中进行讨论。&lt;/p&gt;&lt;h2 id=&quot;避免阻塞式调用&quot;&gt;&lt;a href=&quot;#避免阻塞式调用&quot; class=&quot;headerlink&quot; title=&quot;避免阻塞式调用&quot;/&gt;避免阻塞式调用&lt;/h2&gt;&lt;p&gt;ASP.NET Core 应用程序应设计为同时处理许多请求。 异步 API 可以使用一个小池线程通过非阻塞式调用来处理数以千计的并发请求。 线程可以处理另一个请求，而不是等待长时间运行的同步任务完成。&lt;/p&gt;&lt;p&gt;ASP.NET Core 应用程序中的常见性能问题通常是由于那些本可以异步调用但却采用阻塞时调用而导致的。 同步阻塞会调用导致 &lt;a href=&quot;https://blogs.msdn.microsoft.com/vancem/2018/10/16/diagnosing-net-core-threadpool-starvation-with-perfview-why-my-service-is-not-saturating-all-cores-or-seems-to-stall/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;线程池饥饿&lt;/a&gt; 和响应时间降级。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;不要&lt;/strong&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;通过调用 &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.task.wait&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;Task.Wait&lt;/a&gt; 或 &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.task-1.result&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;Task.Result&lt;/a&gt; 来阻止异步执行。&lt;/li&gt;&lt;li&gt;在公共代码路径中加锁。 ASP.NET Core 应用程序应设计为并行运行代码，如此才能使得性能最佳。&lt;/li&gt;&lt;li&gt;调用 &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.task.run&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;Task.Run&lt;/a&gt; 并立即 await 。 ASP.NET Core 本身已经是在线程池线程上运行应用程序代码了，因此这样调用 Task.Run 只会导致额外的不必要的线程池调度。 而且即使被调度的代码会阻止线程， Task.Run 也并不能避免这种情况，这样做没有意义。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;要&lt;/strong&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;确保 &lt;a href=&quot;#understand-hot-code-paths&quot;&gt;代码热点路径&lt;/a&gt; 全部异步化。&lt;/li&gt;&lt;li&gt;如在进行调用数据读写、I/O 处理和长时间操作的 API 时，存在可用的异步 API。那么务必选择异步 API 。 但是，&lt;strong&gt;不要&lt;/strong&gt; 使用 &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.task.run&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;Task.Run&lt;/a&gt; 来包装同步 API 使其异步化。&lt;/li&gt;&lt;li&gt;确保 controller/Razor Page actions 异步化。 整个调用堆栈是异步的，就可以利用 &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;async/await&lt;/a&gt; 模式的性能优势。&lt;br/&gt;使用性能分析程序 ( 例如 &lt;a href=&quot;https://github.com/Microsoft/perfview&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;PerfView&lt;/a&gt;) 可用于查找频繁添加到 &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/procthread/thread-pools&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;线程池&lt;/a&gt; 的线程。 &lt;code&gt;Microsoft-Windows-DotNETRuntime/ThreadPoolWorkerThread/Start&lt;/code&gt; 事件表示新线程被添加到线程池。&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&quot;使用-IEumerable-lt-T-gt-或-IAsyncEnumerable-lt-T-gt-作为返回值&quot;&gt;&lt;a href=&quot;#使用-IEumerable-lt-T-gt-或-IAsyncEnumerable-lt-T-gt-作为返回值&quot; class=&quot;headerlink&quot; title=&quot;使用 IEumerable&amp;lt;T&amp;gt; 或 IAsyncEnumerable&amp;lt;T&amp;gt; 作为返回值&quot;/&gt;使用 IEumerable&amp;lt;T&amp;gt;&lt;t&gt;或 IAsyncEnumerable&amp;lt;T&amp;gt; 作为返回值&lt;t/&gt;&lt;/t&gt;&lt;/h2&gt;&lt;p&gt;在 Action 中返回&lt;code&gt;IEumerable&amp;lt;T&amp;gt;&lt;/code&gt;将会被序列化器中进行同步迭代 。 结果是可能导致阻塞或者线程池饥饿。 想要要避免同步迭代集合，可以在返回迭代集合之前使用 &lt;code&gt;ToListAsync&lt;/code&gt;使其异步化。&lt;/p&gt;&lt;p&gt;从 ASP.NET Core 3.0 开始， &lt;code&gt;IAsyncEnumerable&amp;lt;T&amp;gt;&lt;/code&gt; 可以用作为 &lt;code&gt;IEumerable&amp;lt;T&amp;gt;&lt;/code&gt; 的替代方法，以异步方式进行迭代。 有关更多信息，请参阅 &lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/web-api/action-return-types#return-ienumerablet-or-iasyncenumerablet?view=aspnetcore-3.1&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;Controller Action 的返回值类型&lt;/a&gt;。&lt;/p&gt;&lt;h2 id=&quot;尽可能少的使用大对象&quot;&gt;&lt;a href=&quot;#尽可能少的使用大对象&quot; class=&quot;headerlink&quot; title=&quot;尽可能少的使用大对象&quot;/&gt;尽可能少的使用大对象&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;.NET Core 垃圾收集器&lt;/a&gt; 在 ASP.NET Core 应用程序中起到自动管理内存的分配和释放的作用。 自动垃圾回收通常意味着开发者不需要担心如何或何时释放内存。 但是，清除未引用的对象将会占用 CPU 时间，因此开发者应最小化 &lt;a href=&quot;#understand-hot-code-paths&quot;&gt;代码热点路径&lt;/a&gt; 中的分配的对象。 垃圾回收在大对象上代价特大 (&amp;gt; 85 K 字节 ) 。 大对象存储在 &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/large-object-heap&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;large object heap&lt;/a&gt; 上，需要 full (generation 2) garbage collection 来清理。 与 generation 0 和 generation 1 不同，generation 2 需要临时暂挂应用程序。 故而频繁分配和取消分配大型对象会导致性能耗损。&lt;/p&gt;&lt;p&gt;建议 :&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;要&lt;/strong&gt; 考虑缓存频繁使用的大对象。 缓存大对象可防止昂贵的分配开销。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;要&lt;/strong&gt;使用 &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.buffers.arraypool-1&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;ArrayPool&amp;lt;T&amp;gt;&lt;/a&gt; 作为池化缓冲区以保存大型数组。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;不要&lt;/strong&gt; 在&lt;a href=&quot;#understand-hot-code-paths&quot;&gt;代码热点路径&lt;/a&gt; 上分配许多短生命周期的大对象。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;可以通过查看 &lt;a href=&quot;https://github.com/Microsoft/perfview&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;PerfView&lt;/a&gt; 中的垃圾回收 (GC) 统计信息来诊断并检查内存问题，其中包括:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;垃圾回收挂起时间。&lt;/li&gt;&lt;li&gt;垃圾回收中耗用的处理器时间百分比。&lt;/li&gt;&lt;li&gt;有多少垃圾回收发生在 generation 0, 1, 和 2.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;有关更多信息，请参阅 &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/performance&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;垃圾回收和性能&lt;/a&gt;。&lt;/p&gt;&lt;h2 id=&quot;优化数据操作和-I-O&quot;&gt;&lt;a href=&quot;#优化数据操作和-I-O&quot; class=&quot;headerlink&quot; title=&quot;优化数据操作和 I/O&quot;/&gt;优化数据操作和 I/O&lt;/h2&gt;&lt;p&gt;与数据存储器和其他远程服务的交互通常是 ASP.NET Core 应用程序最慢的部分。 高效读取和写入数据对于良好的性能至关重要。&lt;/p&gt;&lt;p&gt;建议 :&lt;/p&gt;&lt;p&gt;请参阅 &lt;a href=&quot;https://docs.microsoft.com/en-us/ef/core/what-is-new/ef-core-2.0#explicitly-compiled-queries&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;EF 高性能专题&lt;/a&gt; 以了解可能提高应用性能的方法:&lt;/p&gt;&lt;p&gt;在代码提交之前，我们建议评估上述高性能方法的影响。 编译查询的额外复杂性可能无法一定确保性能提高。&lt;/p&gt;&lt;p&gt;可以通过使用 &lt;a href=&quot;https://docs.microsoft.com/en-us/azure/application-insights/app-insights-overview&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;Application Insights&lt;/a&gt; 或使用分析工具查看访问数据所花费的时间来检测查询问题。 大多数数据库还提供有关频繁执行的查询的统计信息，这也可以作为重要参考。&lt;/p&gt;&lt;h2 id=&quot;通过-HttpClientFactory-建立-HTTP-连接池&quot;&gt;&lt;a href=&quot;#通过-HttpClientFactory-建立-HTTP-连接池&quot; class=&quot;headerlink&quot; title=&quot;通过 HttpClientFactory 建立 HTTP 连接池&quot;/&gt;通过 HttpClientFactory 建立 HTTP 连接池&lt;/h2&gt;&lt;p&gt;虽然 &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;HttpClient&lt;/a&gt; 实现了 &lt;code&gt;IDisposable&lt;/code&gt; 接口，但它其实被设计为可以重复使用单个实例。 关闭 &lt;code&gt;HttpClient&lt;/code&gt; 实例会使套接字在短时间内以 &lt;code&gt;TIME_WAIT&lt;/code&gt; 状态打开。 如果经常创建和释放 &lt;code&gt;HttpClient&lt;/code&gt; 对象，那么应用程序可能会耗尽可用套接字。 在 ASP.NET Core 2.1 中，引入了&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/standard/microservices-architecture/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;HttpClientFactory&lt;/a&gt; 作为解决这个问题的办法。 它以池化 HTTP 连接的方式从而优化性能和可靠性。&lt;/p&gt;&lt;p&gt;建议 :&lt;/p&gt;&lt;h2 id=&quot;确保公共代码路径快若鹰隼&quot;&gt;&lt;a href=&quot;#确保公共代码路径快若鹰隼&quot; class=&quot;headerlink&quot; title=&quot;确保公共代码路径快若鹰隼&quot;/&gt;确保公共代码路径快若鹰隼&lt;/h2&gt;&lt;p&gt;如果你想要所有的代码都保持高速， 高频调用的代码路径就是优化的最关键路径。 优化措施包括:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;考虑优化应用程序请求处理管道中的 Middleware ，尤其是在管道中排在更前面运行的 Middleware 。 这些组件对性能有很大影响。&lt;/li&gt;&lt;li&gt;考虑优化那些每个请求都要执行或每个请求多次执行的代码。 例如，自定义日志，身份认证与授权或 transient 服务的创建等等。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;建议 :&lt;/p&gt;&lt;h2 id=&quot;在-HTTP-请求之外运行长时任务&quot;&gt;&lt;a href=&quot;#在-HTTP-请求之外运行长时任务&quot; class=&quot;headerlink&quot; title=&quot;在 HTTP 请求之外运行长时任务&quot;/&gt;在 HTTP 请求之外运行长时任务&lt;/h2&gt;&lt;p&gt;对 ASP.NET Core 应用程序的大多数请求可以由调用服务的 controller 或页面模型处理，并返回 HTTP 响应。 对于涉及长时间运行的任务的某些请求，最好使整个请求-响应进程异步。&lt;/p&gt;&lt;p&gt;建议 :&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;不要&lt;/strong&gt;把等待长时间运行的任务完成，作为普通 HTTP 请求处理的一部分。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;要&lt;/strong&gt; 考虑使用 &lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/hosted-services?view=aspnetcore-3.1&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;后台服务&lt;/a&gt; 或 &lt;a href=&quot;https://docs.microsoft.com/en-us/azure/azure-functions/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;Azure Function&lt;/a&gt; 处理长时间运行的任务。 在应用外执行任务特别有利于 CPU 密集型任务的性能。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;要&lt;/strong&gt; 使用实时通信，如 &lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/signalr/introduction?view=aspnetcore-3.1&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;SignalR&lt;/a&gt;，以异步方式与客户端通信。&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&quot;缩小客户端资源&quot;&gt;&lt;a href=&quot;#缩小客户端资源&quot; class=&quot;headerlink&quot; title=&quot;缩小客户端资源&quot;/&gt;缩小客户端资源&lt;/h2&gt;&lt;p&gt;复杂的 ASP.NET Core 应用程序经常包含很有前端文件例如 JavaScript， CSS 或图片文件。 可以通过以下方法优化初始请求的性能:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;打包，将多个文件合并为一个文件。&lt;/li&gt;&lt;li&gt;压缩，通过除去空格和注释来缩小文件大小。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;建议 :&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;要&lt;/strong&gt; 使用 ASP.NET Core 的 &lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/client-side/bundling-and-minification?view=aspnetcore-3.1&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;内置支持&lt;/a&gt; 用于打包和压缩客户端资源文件的组件。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;要&lt;/strong&gt; 考虑其他第三方工具，如 &lt;a href=&quot;https://webpack.js.org/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;Webpack&lt;/a&gt;，用于复杂客户资产管理。&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&quot;压缩-Http-响应&quot;&gt;&lt;a href=&quot;#压缩-Http-响应&quot; class=&quot;headerlink&quot; title=&quot;压缩 Http 响应&quot;/&gt;压缩 Http 响应&lt;/h2&gt;&lt;p&gt;减少响应的大小通常会显着提高应用程序的响应性。 而减小内容大小的一种方法是压缩应用程序的响应。 有关更多信息，请参阅 &lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/performance/response-compression?view=aspnetcore-3.1&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;响应压缩&lt;/a&gt;。&lt;/p&gt;&lt;h2 id=&quot;使用最新的-ASP-NET-Core-发行版&quot;&gt;&lt;a href=&quot;#使用最新的-ASP-NET-Core-发行版&quot; class=&quot;headerlink&quot; title=&quot;使用最新的 ASP.NET Core 发行版&quot;/&gt;使用最新的 ASP.NET Core 发行版&lt;/h2&gt;&lt;p&gt;ASP.NET Core 的每个新发行版都包含性能改进。 .NET Core 和 ASP.NET Core 中的优化意味着较新的版本通常优于较旧版本。 例如， .NET Core 2.1 添加了对预编译的正则表达式的支持，并从使用 &lt;a href=&quot;https://docs.microsoft.com/en-us/archive/msdn-magazine/2018/january/csharp-all-about-span-exploring-a-new-net-mainstay&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;Span&amp;lt;T&amp;gt;&lt;/a&gt; 改进性能。 ASP.NET Core 2.2 添加了对 HTTP/2 的支持。 &lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/release-notes/aspnetcore-3.0&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;ASP.NET Core 3.0 增加了许多改进&lt;/a&gt; ，以减少内存使用量并提高吞吐量。 如果性能是优先考虑的事情，那么请升级到 ASP.NET Core 的当前版本。&lt;/p&gt;&lt;h2 id=&quot;最小化异常&quot;&gt;&lt;a href=&quot;#最小化异常&quot; class=&quot;headerlink&quot; title=&quot;最小化异常&quot;/&gt;最小化异常&lt;/h2&gt;&lt;p&gt;异常应该竟可能少。 相对于正常代码流程来说，抛出和捕获异常是缓慢的。 因此，不应使用异常来控制正常程序流。&lt;/p&gt;&lt;p&gt;建议 :&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;不要&lt;/strong&gt; 使用抛出或捕获异常作为正常程序流的手段，特别是在 &lt;a href=&quot;#understand-hot-code-paths&quot;&gt;代码热点路径&lt;/a&gt; 中。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;要&lt;/strong&gt; 在应用程序中包含用于检测和处理导致异常的逻辑。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;要&lt;/strong&gt; 对意外的执行情况抛出或捕获异常。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;应用程序诊断工具( 如 Application Insights ) 可以帮助识别应用程序中可能影响性能的常见异常。&lt;/p&gt;&lt;h2 id=&quot;性能和可靠性&quot;&gt;&lt;a href=&quot;#性能和可靠性&quot; class=&quot;headerlink&quot; title=&quot;性能和可靠性&quot;/&gt;性能和可靠性&lt;/h2&gt;&lt;p&gt;下文将提供常见性能提示和已知可靠性问题的解决方案。&lt;/p&gt;&lt;h2 id=&quot;避免在-HttpRequest-HttpResponse-body-上同步读取或写入&quot;&gt;&lt;a href=&quot;#避免在-HttpRequest-HttpResponse-body-上同步读取或写入&quot; class=&quot;headerlink&quot; title=&quot;避免在 HttpRequest/HttpResponse body 上同步读取或写入&quot;/&gt;避免在 HttpRequest/HttpResponse body 上同步读取或写入&lt;/h2&gt;&lt;p&gt;ASP.NET Core 中的所有 I/O 都是异步的。 服务器实现了 &lt;code&gt;Stream&lt;/code&gt; 接口，它同时具有同步和异步的方法重载。 应该首选异步方式以避免阻塞线程池线程。 阻塞线程会导致线程池饥饿。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;不要使用如下操作:&lt;/strong&gt; &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/System.IO.StreamReader.ReadToEnd&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;https://docs.microsoft.com/en-us/dotnet/api/System.IO.StreamReader.ReadToEnd&lt;/a&gt;。 它会阻止当前线程等待结果。 这是 &lt;a href=&quot;https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#warning-sync-over-async&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;sync over async&lt;/a&gt; 的示例。&lt;/p&gt;&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;BadStreamReaderController&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;Controller&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;meta&quot;&gt;HttpGet(&lt;span class=&quot;meta-string&quot;&gt;&quot;/contoso&quot;&lt;/span&gt;)&lt;/span&gt;]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; ActionResult&amp;lt;ContosoData&amp;gt; &lt;span class=&quot;title&quot;&gt;Get&lt;/span&gt;(&lt;span class=&quot;params&quot;/&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;/&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; json = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; StreamReader(Request.Body).ReadToEnd();&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; JsonSerializer.Deserialize&amp;lt;ContosoData&amp;gt;(json);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;在上述代码中， &lt;code&gt;Get&lt;/code&gt; 采用同步的方式将整个 HTTP 请求主体读取到内存中。 如果客户端上载数据很慢，那么应用程序就会出现看似异步实际同步的操作。 应用程序看似异步实际同步，因为 Kestrel &lt;strong&gt;不&lt;/strong&gt; 支持同步读取。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;应该采用如下操作:&lt;/strong&gt; &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/System.IO.StreamReader.ReadToEndAsync&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;https://docs.microsoft.com/en-us/dotnet/api/System.IO.StreamReader.ReadToEndAsync&lt;/a&gt; ，在读取时不阻塞线程。&lt;/p&gt;&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;GoodStreamReaderController&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;Controller&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;meta&quot;&gt;HttpGet(&lt;span class=&quot;meta-string&quot;&gt;&quot;/contoso&quot;&lt;/span&gt;)&lt;/span&gt;]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;async&lt;/span&gt; Task&amp;lt;ActionResult&amp;lt;ContosoData&amp;gt;&amp;gt; Get()&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; json = &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; StreamReader(Request.Body).ReadToEndAsync();&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; JsonSerializer.Deserialize&amp;lt;ContosoData&amp;gt;(json);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;上述代码异步将整个 HTTP request body 读取到内存中。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;[!WARNING] 如果请求很大，那么将整个 HTTP request body 读取到内存中可能会导致内存不足 (OOM) 。 OOM 可导致应用奔溃。 有关更多信息，请参阅 &lt;a href=&quot;#arlb&quot;&gt;避免将大型请求主体或响应主体读取到内存中&lt;/a&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;应该采用如下操作:&lt;/strong&gt; 使用不缓冲的方式完成 request body 操作:&lt;/p&gt;&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;GoodStreamReaderController&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;Controller&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;meta&quot;&gt;HttpGet(&lt;span class=&quot;meta-string&quot;&gt;&quot;/contoso&quot;&lt;/span&gt;)&lt;/span&gt;]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;async&lt;/span&gt; Task&amp;lt;ActionResult&amp;lt;ContosoData&amp;gt;&amp;gt; Get()&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; JsonSerializer.DeserializeAsync&amp;lt;ContosoData&amp;gt;(Request.Body);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;上述代码采用异步方式将 request body 序列化为 C# 对象。&lt;/p&gt;&lt;h2 id=&quot;优先选用-Request-Form-的-ReadFormAsync&quot;&gt;&lt;a href=&quot;#优先选用-Request-Form-的-ReadFormAsync&quot; class=&quot;headerlink&quot; title=&quot;优先选用 Request.Form 的 ReadFormAsync&quot;/&gt;优先选用 Request.Form 的 ReadFormAsync&lt;/h2&gt;&lt;p&gt;应该使用 &lt;code&gt;HttpContext.Request.ReadFormAsync&lt;/code&gt; 而不是 &lt;code&gt;HttpContext.Request.Form&lt;/code&gt;。 &lt;code&gt;HttpContext.Request.Form&lt;/code&gt; 只能在以下场景用安全使用。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;该表单已被 &lt;code&gt;ReadFormAsync&lt;/code&gt;调用，并且&lt;/li&gt;&lt;li&gt;数据已经被从 &lt;code&gt;HttpContext.Request.Form&lt;/code&gt; 读取并缓存&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;不要使用如下操作:&lt;/strong&gt; 例如以下方式使用 &lt;code&gt;HttpContext.Request.Form&lt;/code&gt;。 &lt;code&gt;HttpContext.Request.Form&lt;/code&gt; 使用了&lt;a href=&quot;https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#warning-sync-over-async&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;sync over async&lt;/a&gt; ，这将导致线程饥饿.&lt;/p&gt;&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;BadReadController&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;Controller&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;meta&quot;&gt;HttpPost(&lt;span class=&quot;meta-string&quot;&gt;&quot;/form-body&quot;&lt;/span&gt;)&lt;/span&gt;]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; IActionResult &lt;span class=&quot;title&quot;&gt;Post&lt;/span&gt;(&lt;span class=&quot;params&quot;/&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;/&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; form =  HttpContext.Request.Form;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        Process(form[&lt;span class=&quot;string&quot;&gt;&quot;id&quot;&lt;/span&gt;], form[&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;]);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; Accepted();&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;应该使用如下操作:&lt;/strong&gt; 使用&lt;code&gt;HttpContext.Request.ReadFormAsync&lt;/code&gt; 异步读取表单正文。&lt;/p&gt;&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;GoodReadController&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;Controller&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;meta&quot;&gt;HttpPost(&lt;span class=&quot;meta-string&quot;&gt;&quot;/form-body&quot;&lt;/span&gt;)&lt;/span&gt;]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;async&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt; &lt;span class=&quot;title&quot;&gt;Post&lt;/span&gt;(&lt;span class=&quot;params&quot;/&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;/&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; form = &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; HttpContext.Request.ReadFormAsync();&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        Process(form[&lt;span class=&quot;string&quot;&gt;&quot;id&quot;&lt;/span&gt;], form[&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;]);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; Accepted();&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;a name=&quot;arlb&quot;/&gt;&lt;/p&gt;&lt;h2 id=&quot;避免将大型-request-body-或-response-body-读取到内存中&quot;&gt;&lt;a href=&quot;#避免将大型-request-body-或-response-body-读取到内存中&quot; class=&quot;headerlink&quot; title=&quot;避免将大型 request body 或 response body 读取到内存中&quot;/&gt;避免将大型 request body 或 response body 读取到内存中&lt;/h2&gt;&lt;p&gt;在 .NET 中，大于 85 KB 的对象会被分配在大对象堆 (&lt;a href=&quot;https://blogs.msdn.microsoft.com/maoni/2006/04/19/large-object-heap/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;LOH&lt;/a&gt; )。 大型对象的开销较大，包含两方面:&lt;/p&gt;&lt;p&gt;此 &lt;a href=&quot;https://adamsitnik.com/Array-Pool/#the-problem&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;博文&lt;/a&gt; 很好描述了该问题:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;当分配大对象时，它会被标记为 Gen 2 对象。 而不像是 Gen 0 那样的小对象。 这样的后果是，如果你在使用 LOH 时耗尽内存， GC 会清除整个托管堆，而不仅仅是 LOH 部分。 因此，它将清理 Gen 0, Gen 1 and Gen 2 ( 包括 LOH ) 。 这称为 full garbage collection，是最耗时的垃圾回收。 对于很多应用，这是可以接受的。 但绝对不适用于高性能 Web 服务器，因为高性能 Web 服务器需要更多的内存用于处理常规 Web 请求 ( 从套接字读取，解压缩，解码 JSON 等等 )。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;天真地将一个大型 request 或者 response body 存储到单个 &lt;code&gt;byte[]&lt;/code&gt; 或 &lt;code&gt;string&lt;/code&gt;中:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;这可能导致 LOH 的剩余空间快速耗尽。&lt;/li&gt;&lt;li&gt;因此产生的 full GC 可能会导致应用程序的性能问题。&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&quot;使用同步-API-处理数据&quot;&gt;&lt;a href=&quot;#使用同步-API-处理数据&quot; class=&quot;headerlink&quot; title=&quot;使用同步 API 处理数据&quot;/&gt;使用同步 API 处理数据&lt;/h2&gt;&lt;p&gt;例如使用仅支持同步读取和写入的序列化器/反序列化器时 ( 例如， &lt;a href=&quot;https://www.newtonsoft.com/json/help/html/Introduction.htm&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;JSON.NET&lt;/a&gt;):&lt;/p&gt;&lt;ul&gt;&lt;li&gt;将数据异步缓冲到内存中，然后将其传递到序列化器/反序列化器。&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;&lt;p&gt;[!WARNING] 如果请求较大，那么可能导致内存不足 (OOM) 。 OOM 可导致应用奔溃。 有关更多信息，请参阅 &lt;a href=&quot;#arlb&quot;&gt;避免将大型请求主体或响应主体读取到内存&lt;/a&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;ASP.NET Core 3.0 默认情况下使用 &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.text.json&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;https://docs.microsoft.com/en-us/dotnet/api/system.text.json&lt;/a&gt;进行 JSON 序列化，这将带来如下好处。 &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.text.json&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;https://docs.microsoft.com/en-us/dotnet/api/system.text.json&lt;/a&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;异步读取和写入 JSON 。&lt;/li&gt;&lt;li&gt;针对 UTF-8 文本进行了优化。&lt;/li&gt;&lt;li&gt;通常比 &lt;code&gt;Newtonsoft.Json&lt;/code&gt; 更高的性能。&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&quot;不要将-IHttpContextAccessor-HttpContext-存储在字段中&quot;&gt;&lt;a href=&quot;#不要将-IHttpContextAccessor-HttpContext-存储在字段中&quot; class=&quot;headerlink&quot; title=&quot;不要将 IHttpContextAccessor.HttpContext 存储在字段中&quot;/&gt;不要将 IHttpContextAccessor.HttpContext 存储在字段中&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.ihttpcontextaccessor.httpcontext?view=aspnetcore-3.1#Microsoft_AspNetCore_Http_IHttpContextAccessor_HttpContext&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;IHttpContextAccessor.HttpContext&lt;/a&gt; 返回当前请求线程中的 &lt;code&gt;HttpContext&lt;/code&gt;. &lt;code&gt;IHttpContextAccessor.HttpContext&lt;/code&gt;** 不应该 ** 被存储在一个字段或变量中。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;不要使用如下操作:&lt;/strong&gt; 例如将&lt;code&gt;HttpContext&lt;/code&gt; 存储在字段中，然后在后续使用该字段。&lt;/p&gt;&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyBadType&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt; HttpContext _context;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyBadType&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;IHttpContextAccessor accessor&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;/&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        _context = accessor.HttpContext;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CheckAdmin&lt;/span&gt;(&lt;span class=&quot;params&quot;/&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;/&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!_context.User.IsInRole(&lt;span class=&quot;string&quot;&gt;&quot;admin&quot;&lt;/span&gt;))&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; UnauthorizedAccessException(&lt;span class=&quot;string&quot;&gt;&quot;The current user isn&#x27;t an admin&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        }&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;以上代码在构造函数中经常得到 Null 或不正确的 &lt;code&gt;HttpContext&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;应该采用如下操作:&lt;/strong&gt;&lt;/p&gt;&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyGoodType&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt; IHttpContextAccessor _accessor;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyGoodType&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;IHttpContextAccessor accessor&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;/&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        _accessor = accessor;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CheckAdmin&lt;/span&gt;(&lt;span class=&quot;params&quot;/&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;/&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; context = _accessor.HttpContext;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (context != &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !context.User.IsInRole(&lt;span class=&quot;string&quot;&gt;&quot;admin&quot;&lt;/span&gt;))&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; UnauthorizedAccessException(&lt;span class=&quot;string&quot;&gt;&quot;The current user isn&#x27;t an admin&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        }&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h2 id=&quot;不要尝试在多线程下使用-HttpContext&quot;&gt;&lt;a href=&quot;#不要尝试在多线程下使用-HttpContext&quot; class=&quot;headerlink&quot; title=&quot;不要尝试在多线程下使用 HttpContext&quot;/&gt;不要尝试在多线程下使用 HttpContext&lt;/h2&gt;&lt;p&gt;&lt;code&gt;HttpContext&lt;/code&gt; &lt;em&gt;不是&lt;/em&gt; 线程安全的。 从多个线程并行访问 &lt;code&gt;HttpContext&lt;/code&gt; 可能会导致不符预期的行为，例如线程挂起，崩溃和数据损坏。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;不要使用如下操作:&lt;/strong&gt; 以下示例将发出三个并行请求，并在 HTTP 请求之前和之后记录传入的请求路径。 请求路径将被多个线程 ( 可能并行 ) 访问。&lt;/p&gt;&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AsyncBadSearchController&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;Controller&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;meta&quot;&gt;HttpGet(&lt;span class=&quot;meta-string&quot;&gt;&quot;/search&quot;&lt;/span&gt;)&lt;/span&gt;]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;async&lt;/span&gt; Task&amp;lt;SearchResults&amp;gt; &lt;span class=&quot;title&quot;&gt;Get&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt; query&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;/&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; query1 = SearchAsync(SearchEngine.Google, query);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; query2 = SearchAsync(SearchEngine.Bing, query);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; query3 = SearchAsync(SearchEngine.DuckDuckGo, query);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; Task.WhenAll(query1, query2, query3);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; results1 = &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; query1;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; results2 = &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; query2;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; results3 = &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; query3;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; SearchResults.Combine(results1, results2, results3);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;async&lt;/span&gt; Task&amp;lt;SearchResults&amp;gt; &lt;span class=&quot;title&quot;&gt;SearchAsync&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;SearchEngine engine, &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt; query&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;/&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; searchResults = _searchService.Empty();&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;            _logger.LogInformation(&lt;span class=&quot;string&quot;&gt;&quot;Starting search query from {path}.&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;                                    HttpContext.Request.Path);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;            searchResults = _searchService.Search(engine, query);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;            _logger.LogInformation(&lt;span class=&quot;string&quot;&gt;&quot;Finishing search query from {path}.&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;                                    HttpContext.Request.Path);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        }&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Exception ex)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;            _logger.LogError(ex, &lt;span class=&quot;string&quot;&gt;&quot;Failed query from {path}&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;                             HttpContext.Request.Path);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        }&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; searchResults;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;应该这样操作:&lt;/strong&gt; 以下示例在发出三个并行请求之前，从传入请求复制下文需要使用的数据。&lt;/p&gt;&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AsyncGoodSearchController&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;Controller&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;meta&quot;&gt;HttpGet(&lt;span class=&quot;meta-string&quot;&gt;&quot;/search&quot;&lt;/span&gt;)&lt;/span&gt;]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;async&lt;/span&gt; Task&amp;lt;SearchResults&amp;gt; &lt;span class=&quot;title&quot;&gt;Get&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt; query&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;/&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt; path = HttpContext.Request.Path;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; query1 = SearchAsync(SearchEngine.Google, query,&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;                                 path);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; query2 = SearchAsync(SearchEngine.Bing, query, path);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; query3 = SearchAsync(SearchEngine.DuckDuckGo, query, path);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; Task.WhenAll(query1, query2, query3);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; results1 = &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; query1;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; results2 = &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; query2;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; results3 = &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; query3;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; SearchResults.Combine(results1, results2, results3);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;async&lt;/span&gt; Task&amp;lt;SearchResults&amp;gt; &lt;span class=&quot;title&quot;&gt;SearchAsync&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;SearchEngine engine, &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt; query,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                                                  &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt; path&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;/&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; searchResults = _searchService.Empty();&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;            _logger.LogInformation(&lt;span class=&quot;string&quot;&gt;&quot;Starting search query from {path}.&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;                                   path);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;            searchResults = &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; _searchService.SearchAsync(engine, query);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;            _logger.LogInformation(&lt;span class=&quot;string&quot;&gt;&quot;Finishing search query from {path}.&quot;&lt;/span&gt;, path);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        }&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Exception ex)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;            _logger.LogError(ex, &lt;span class=&quot;string&quot;&gt;&quot;Failed query from {path}&quot;&lt;/span&gt;, path);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        }&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; searchResults;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h2 id=&quot;请求处理完成后不要使用-HttpContext&quot;&gt;&lt;a href=&quot;#请求处理完成后不要使用-HttpContext&quot; class=&quot;headerlink&quot; title=&quot;请求处理完成后不要使用 HttpContext&quot;/&gt;请求处理完成后不要使用 HttpContext&lt;/h2&gt;&lt;p&gt;&lt;code&gt;HttpContext&lt;/code&gt; 只有在 ASP.NET Core 管道处理活跃的 HTTP 请求时才可用。 整个 ASP.NET Core 管道是由异步代理组成的调用链，用于处理每个请求。 当 &lt;code&gt;Task&lt;/code&gt; 从调用链完成并返回时,&lt;code&gt;HttpContext&lt;/code&gt; 就会被回收。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;不要进行如下操作:&lt;/strong&gt; 以下示例使用 &lt;code&gt;async void&lt;/code&gt; ，这将使得 HTTP 请求在第一个 &lt;code&gt;await&lt;/code&gt; 时处理完成，进而就会导致:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;在 ASP.NET Core 应用程序中， 这是一个&lt;strong&gt;完全错误&lt;/strong&gt; 的做法&lt;/li&gt;&lt;li&gt;在 HTTP 请求完成后访问 &lt;code&gt;HttpResponse&lt;/code&gt;。&lt;/li&gt;&lt;li&gt;进程崩溃。&lt;/li&gt;&lt;/ul&gt;&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AsyncBadVoidController&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;Controller&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;meta&quot;&gt;HttpGet(&lt;span class=&quot;meta-string&quot;&gt;&quot;/async&quot;&lt;/span&gt;)&lt;/span&gt;]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Get&lt;/span&gt;(&lt;span class=&quot;params&quot;/&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;/&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; Task.Delay(&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// The following line will crash the process because of writing after the&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// response has completed on a background thread. Notice async void Get()&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; Response.WriteAsync(&lt;span class=&quot;string&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;应该进行如下操作:&lt;/strong&gt; 以下示例将 &lt;code&gt;Task&lt;/code&gt; 返回给框架，因此，在操作完成之前， HTTP 请求不会完成。&lt;/p&gt;&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AsyncGoodTaskController&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;Controller&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;meta&quot;&gt;HttpGet(&lt;span class=&quot;meta-string&quot;&gt;&quot;/async&quot;&lt;/span&gt;)&lt;/span&gt;]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;async&lt;/span&gt; Task &lt;span class=&quot;title&quot;&gt;Get&lt;/span&gt;(&lt;span class=&quot;params&quot;/&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;/&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; Task.Delay(&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; Response.WriteAsync(&lt;span class=&quot;string&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h2 id=&quot;不要在后台线程中使用-HttpContext&quot;&gt;&lt;a href=&quot;#不要在后台线程中使用-HttpContext&quot; class=&quot;headerlink&quot; title=&quot;不要在后台线程中使用 HttpContext&quot;/&gt;不要在后台线程中使用 HttpContext&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;不要使用如下操作:&lt;/strong&gt; 以下示例使用一个闭包从 &lt;code&gt;Controller&lt;/code&gt; 属性读取 &lt;code&gt;HttpContext&lt;/code&gt;。 这是一种错误做法，因为这将导致:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;代码运行在 Http 请求作用域之外。&lt;/li&gt;&lt;li&gt;尝试读取错误的 &lt;code&gt;HttpContext&lt;/code&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;meta&quot;&gt;HttpGet(&lt;span class=&quot;meta-string&quot;&gt;&quot;/fire-and-forget-1&quot;&lt;/span&gt;)&lt;/span&gt;]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; IActionResult &lt;span class=&quot;title&quot;&gt;BadFireAndForget&lt;/span&gt;(&lt;span class=&quot;params&quot;/&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;/&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    _ = Task.Run(&lt;span class=&quot;keyword&quot;&gt;async&lt;/span&gt; () =&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; Task.Delay(&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; path = HttpContext.Request.Path;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        Log(path);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    });&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; Accepted();&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;应该采用如下操作:&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;在请求处理阶段将后台线程需要的数据全部进行复制。&lt;/li&gt;&lt;li&gt;不要使用 controller 的所有引用&lt;/li&gt;&lt;/ul&gt;&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;meta&quot;&gt;HttpGet(&lt;span class=&quot;meta-string&quot;&gt;&quot;/fire-and-forget-3&quot;&lt;/span&gt;)&lt;/span&gt;]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; IActionResult &lt;span class=&quot;title&quot;&gt;GoodFireAndForget&lt;/span&gt;(&lt;span class=&quot;params&quot;/&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;/&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt; path = HttpContext.Request.Path;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    _ = Task.Run(&lt;span class=&quot;keyword&quot;&gt;async&lt;/span&gt; () =&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; Task.Delay(&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        Log(path);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    });&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; Accepted();&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;后台任务最好采用托管服务进行操作。 有关更多信息，请参阅 &lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/hosted-services?view=aspnetcore-3.1&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;采用托管服务运行后台任务&lt;/a&gt; 。&lt;/p&gt;&lt;h2 id=&quot;不要在后台线程获取注入到-controller-中的服务&quot;&gt;&lt;a href=&quot;#不要在后台线程获取注入到-controller-中的服务&quot; class=&quot;headerlink&quot; title=&quot;不要在后台线程获取注入到 controller 中的服务&quot;/&gt;不要在后台线程获取注入到 controller 中的服务&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;不要采用如下做法:&lt;/strong&gt; 以下示例使用闭包从 &lt;code&gt;controller&lt;/code&gt; 获取 &lt;code&gt;DbContext&lt;/code&gt;进行操作。 这是一个错误的做法。 这将导致代码云在请求的作用域之外。 而 &lt;code&gt;ContocoDbContext&lt;/code&gt; 是基于请求作用域的，因此这样将引发 &lt;code&gt;ObjectDisposedException&lt;/code&gt;。&lt;/p&gt;&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;meta&quot;&gt;HttpGet(&lt;span class=&quot;meta-string&quot;&gt;&quot;/fire-and-forget-1&quot;&lt;/span&gt;)&lt;/span&gt;]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; IActionResult &lt;span class=&quot;title&quot;&gt;FireAndForget1&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;[FromServices]ContosoDbContext context&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;/&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    _ = Task.Run(&lt;span class=&quot;keyword&quot;&gt;async&lt;/span&gt; () =&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; Task.Delay(&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        context.Contoso.Add(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Contoso());&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; context.SaveChangesAsync();&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    });&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; Accepted();&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;应该采用如下操作:&lt;/strong&gt;&lt;/p&gt;&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;meta&quot;&gt;HttpGet(&lt;span class=&quot;meta-string&quot;&gt;&quot;/fire-and-forget-3&quot;&lt;/span&gt;)&lt;/span&gt;]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; IActionResult &lt;span class=&quot;title&quot;&gt;FireAndForget3&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;[FromServices]IServiceScopeFactory&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                                    serviceScopeFactory&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;/&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    _ = Task.Run(&lt;span class=&quot;keyword&quot;&gt;async&lt;/span&gt; () =&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; Task.Delay(&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; scope = serviceScopeFactory.CreateScope())&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; context = scope.ServiceProvider.GetRequiredService&amp;lt;ContosoDbContext&amp;gt;();&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;            context.Contoso.Add(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Contoso());&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; context.SaveChangesAsync();&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        }&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    });&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; Accepted();&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;以下高亮的的代码说明:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;为后台操作创建新的作用域，并且从中获取需要的服务。&lt;/li&gt;&lt;li&gt;在正确的作用域中使用 &lt;code&gt;ContocoDbContext&lt;/code&gt;，即只能在请求作用域中使用该对象。&lt;/li&gt;&lt;/ul&gt;&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;meta&quot;&gt;HttpGet(&lt;span class=&quot;meta-string&quot;&gt;&quot;/fire-and-forget-3&quot;&lt;/span&gt;)&lt;/span&gt;]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; IActionResult &lt;span class=&quot;title&quot;&gt;FireAndForget3&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;[FromServices]IServiceScopeFactory&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                                    serviceScopeFactory&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;/&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    _ = Task.Run(&lt;span class=&quot;keyword&quot;&gt;async&lt;/span&gt; () =&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; Task.Delay(&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; scope = serviceScopeFactory.CreateScope())&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; context = scope.ServiceProvider.GetRequiredService&amp;lt;ContosoDbContext&amp;gt;();&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;            context.Contoso.Add(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Contoso());&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; context.SaveChangesAsync();&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        }&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    });&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; Accepted();&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h2 id=&quot;不要在响应正文已经开始发送时尝试修改-status-code-或者-header&quot;&gt;&lt;a href=&quot;#不要在响应正文已经开始发送时尝试修改-status-code-或者-header&quot; class=&quot;headerlink&quot; title=&quot;不要在响应正文已经开始发送时尝试修改 status code 或者 header&quot;/&gt;不要在响应正文已经开始发送时尝试修改 status code 或者 header&lt;/h2&gt;&lt;p&gt;ASP.NET Core 不会缓冲 HTTP 响应正文。 当正文一旦开始发送:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Header 就会与正文的数据包一起发送到客户端。&lt;/li&gt;&lt;li&gt;此时就无法修改 header 了。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;不要使用如下操作:&lt;/strong&gt; 以下代码尝试在响应启动后添加响应头:&lt;/p&gt;&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;app.Use(&lt;span class=&quot;keyword&quot;&gt;async&lt;/span&gt; (context, next) =&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; next();&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    context.Response.Headers[&lt;span class=&quot;string&quot;&gt;&quot;test&quot;&lt;/span&gt;] = &lt;span class=&quot;string&quot;&gt;&quot;test value&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;});&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;在上述的代码中，如果 &lt;code&gt;next()&lt;/code&gt;已经开始写入响应，则&lt;code&gt;context.Response.Headers[&quot;test&quot;] = &quot;test value&quot;;&lt;/code&gt;将会抛出异常。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;应该采用如下操作:&lt;/strong&gt; 以下示例检查 HTTP 响应在修改 Header 之前是否已启动。&lt;/p&gt;&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;app.Use(&lt;span class=&quot;keyword&quot;&gt;async&lt;/span&gt; (context, next) =&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; next();&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!context.Response.HasStarted)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        context.Response.Headers[&lt;span class=&quot;string&quot;&gt;&quot;test&quot;&lt;/span&gt;] = &lt;span class=&quot;string&quot;&gt;&quot;test value&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;});&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;应该采用如下操作:&lt;/strong&gt; 以下示例使用 &lt;code&gt;HttpResponse.OnStarting&lt;/code&gt; 来设置 Header，这样便可以在响应启动时将 Header 一次性写入到客户端。&lt;/p&gt;&lt;p&gt;通过这种方式，响应头将在响应开始时调用已注册的回调进行一次性写入。 如此这般便可以:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;在恰当的时候进行响应头的修改或者覆盖。&lt;/li&gt;&lt;li&gt;不需要了解管道中的下一个 middleware 的行为。&lt;/li&gt;&lt;/ul&gt;&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;app.Use(&lt;span class=&quot;keyword&quot;&gt;async&lt;/span&gt; (context, next) =&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    context.Response.OnStarting(() =&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        context.Response.Headers[&lt;span class=&quot;string&quot;&gt;&quot;someheader&quot;&lt;/span&gt;] = &lt;span class=&quot;string&quot;&gt;&quot;somevalue&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; Task.CompletedTask;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    });&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; next();&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;});&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h2 id=&quot;如果已开始写入响应主体，则请不要调用-next&quot;&gt;&lt;a href=&quot;#如果已开始写入响应主体，则请不要调用-next&quot; class=&quot;headerlink&quot; title=&quot;如果已开始写入响应主体，则请不要调用 next()&quot;/&gt;如果已开始写入响应主体，则请不要调用 next()&lt;/h2&gt;&lt;p&gt;仅当后续组件能够处理响应或时才调用它们，因此如果当前已经开始写入响应主体，后续操作就已经不再需要，并有可能引发异常情况。&lt;/p&gt;&lt;h2 id=&quot;托管于-IIS-应该使用-In-process-模式&quot;&gt;&lt;a href=&quot;#托管于-IIS-应该使用-In-process-模式&quot; class=&quot;headerlink&quot; title=&quot;托管于 IIS 应该使用 In-process 模式&quot;/&gt;托管于 IIS 应该使用 In-process 模式&lt;/h2&gt;&lt;p&gt;使用 in-process 模式托管， ASP.NET Core 应用程序将与 IIS 工作进程在同一进程中运行。 In-process 模式拥有比 out-of-process 更加优秀的性能表现，因为这样不需要将请求通过回环网络适配器进行代理中转。 回环网络适配器是将本机发送的网络流量重新转回本机的的网络适配器。 IIS 进程管理由 &lt;a href=&quot;https://docs.microsoft.com/en-us/iis/manage/provisioning-and-managing-iis/features-of-the-windows-process-activation-service-was&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;Windows Process Activation Service (WAS)&lt;/a&gt;来完成。&lt;/p&gt;&lt;p&gt;在 ASP.NET Core 3.0 和更高版本中的默认将采用 in-process 模式进行托管。&lt;/p&gt;&lt;p&gt;有关更多信息，请参阅 &lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/iis/index?view=aspnetcore-3.1&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;在 Windows 上使用 IIS 托管 ASP.NET Core&lt;/a&gt;&lt;/p&gt;&lt;hr/&gt;&lt;h2 id=&quot;Newbe-Translations&quot;&gt;&lt;a href=&quot;#Newbe-Translations&quot; class=&quot;headerlink&quot; title=&quot;Newbe.Translations&quot;/&gt;Newbe.Translations&lt;/h2&gt;&lt;p&gt;您所阅读的当前文章源自于 Newbe.Translations 项目参与的翻译贡献，您可以通过右侧链接一同参与该项目：&lt;a href=&quot;https://www.newbe.pro/Newbe.Translations/Newbe.Translations/&quot;&gt;https://www.newbe.pro/Newbe.Translations/Newbe.Translations/&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;翻译内容具有一定的时效性，不会随着原文内容实时更新，如果内容存在一定过时，您也可以联系我们。&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>