<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>9273932874fc786e9ac675d3ab0f6936</guid>
<title>浅谈如何搭建知识体系 | 码农周刊第 319 期</title>
<link>https://toutiao.io/k/dufazik</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;issue&quot; id=&quot;readabilityBody&quot;&gt;
        &lt;h1&gt;浅谈如何搭建知识体系 | 码农周刊第 319 期&lt;/h1&gt;
        &lt;h2&gt;码农周刊第319期（2020-09-23）&lt;/h2&gt;
        &lt;p&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=319&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3190&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_316.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&amp;#13;
☞ &lt;a href=&quot;https://weekly.manong.io/bounce?nid=319&amp;amp;aid=19803&amp;amp;url=https%3A%2F%2Fwww.sheca.com%2Fassets%2Fwwx%2Fpage1.html%3Fsite%3Dkaifazhe02&quot; target=&quot;_blank&quot;&gt;SHECA 提供 SSL 证书一站式服务，为你的网络安全保驾护航，上海 CA 权威认证&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;small&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=319&amp;amp;aid=19185&amp;amp;url=https%3A%2F%2Fjinshuju.net%2Ff%2FV7DxN9&quot; target=&quot;_blank&quot;&gt;商务合作&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
        
        &lt;h3 id=&quot;程序设计&quot;&gt;程序设计&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;业界实战&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;HDFS + Clickhouse + Spark&lt;/p&gt;
        &lt;h3 id=&quot;VIP会员专区&quot;&gt;VIP会员专区&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;工作地点：成都 | 薪资：15-30K | 简历投递邮箱：xiexiaofang@huobi.com&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;致力于提供一套简单方便、专业可靠、无限可能的 H5 落地页最佳实践。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;9NFL 是京东自研的联邦学习平台。整个平台的内核基于 TensorFlow，并根据业务进行了性能优化，调度则基于 k8s。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;ChatUI 是由达摩院阿里小蜜孵化的对话式界面组件，目前支持阿里经济体 80 多个事业部，数千个 Chatbot，承载着达摩院前沿技术，专注于智能对话领域的设计和技术研发体系，应用至消费者可体验的对话式界面。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;工具资料&quot;&gt;工具资料&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;图文并茂&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;适合新手&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;模型性能杀器解读&lt;/p&gt;
        
        &lt;p&gt;代码示例&lt;/p&gt;
        
        &lt;p&gt;有用&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;详细介绍&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;深入讲解&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;第二弹&lt;/p&gt;
        
        &lt;p&gt;customize personal network&lt;/p&gt;
        
        &lt;p&gt;&lt;a href=&quot;https://github.com/aweiu/scroll-switch&quot; target=&quot;_blank&quot;&gt;GitHub 地址&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程语言&quot;&gt;编程语言&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;代码示例&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;业界实战&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;两种不错的思路&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;&lt;a href=&quot;https://golang.design/history/&quot; target=&quot;_blank&quot;&gt;文档地址&lt;/a&gt;&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        &lt;h3 id=&quot;每周独家号推荐&quot;&gt;每周独家号推荐&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;一枚有趣的程序员&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 436138 即可&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;致力于为企业提供性能优化领域的全方位解决方案&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 423497 即可&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;分享一些信息安全相关的文章&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 393298 即可&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;编程、成长、正能量！&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 381811 即可&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;分享Go语言相关内容&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 133906 即可&lt;/p&gt;
        &lt;h3 id=&quot;每周一书&quot;&gt;每周一书&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=319&amp;amp;aid=19892&amp;amp;url=http%3A%2F%2Fstore.dangdang.com%2Fgys_04001_3tk3&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/book_319.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程之外&quot;&gt;编程之外&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;擦亮慧眼&lt;/p&gt;
        
        &lt;p&gt;个人经历&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;p&gt;
        &lt;/p&gt;
        
        
        
        
        &lt;div class=&quot;qrcode&quot;&gt;
  &lt;img src=&quot;https://img.toutiao.io/ads/vip_qrcode.png&quot; alt=&quot;Qrcode 258&quot;/&gt;&lt;span&gt;加入码农周刊VIP会员&lt;/span&gt;
&lt;/div&gt;
    &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>015dd179ed5d19618d9f6fbc2569ddc3</guid>
<title>Spring Boot 启动原理</title>
<link>https://toutiao.io/k/itvkvui</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;strong&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;1&amp;gt; 大家都知道SpringBoot是通过main函数启动的，这里面跟踪代码到处都没有找到while(true)，为什么启动后可以一直跑？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2&amp;gt; SpringBoot默认使用tomcat作为web容器。大家也可以通过在pom文件中exclusion掉tomcat，denpendency jetty 的方法来使用jetty。那SpringBoot是怎么做到在不同web容器之间切换的呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2&amp;gt; 传统的web容器比如jetty本质上是直接通过java start.jar 来启动，之后来加载spring上下文的，SpringBoot通过main函数是怎么来启动web容器的呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;本文就这三个问题展开论述。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;问题1分析&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;问题1很简单，启动后一直跑是因为启动了线程池。原理就是有非deamon的线程在跑。Java虚拟机规范定义要等所有用户线程都运行完才会退出。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;所以这个原理就和下面启动线程池一样&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7517875383043923&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicZABgRrbBAG33MvWnr6W1icyeBluAHR6lFIGx0XRCZRSN9qZHnjYnyWXHHmEqJQM44G4tnaUX5kJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;979&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;程序员修炼之道教我们：不要假定，要证明。虽然jetty使用线程池是常识，我们也来跟踪下源码，看看线程池是在哪里初始化的：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;org.springframework.boot.web.embedded.jetty.JettyServletWebServerFactory类里，创建Server的使用使用线程池作为初始化参数。然后创建了socket连接来监听端口。（对于socket连接有之前没接触过的，可以自己查一下。建议动手实践。&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485101&amp;amp;idx=1&amp;amp;sn=c95f1a3fa03af199c78d59bb29ea411c&amp;amp;chksm=fafdec03cd8a6515f61cf42d3ce94ee7bc465f445cb61d4644d259c55a661cce4ab1a6dc4738&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《Java异常处理总结》&lt;/a&gt;这篇文章里有不错的简单小例子可以实操下。）&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5701219512195121&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicZABgRrbBAG33MvWnr6W1icUaFAlvSC5f8P9NuvBj7ajGvHDMvdibH7sC16YIjOoCzP2GvkqlGecSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;984&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;到这里，大家应该都明白了为什么启动后一直不停。但是又有疑问了：JettyServletWebServerFactory是个什么东东？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;问题2分析&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;关于问题2，我们写个最简单的类来debug一下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.17950963222416813&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicZABgRrbBAG33MvWnr6W1icQzRDtiaYapYwGiaPzTLeq7cCbVIqxmfWMwdPb2wCUTJEFYWWJV0Yc0vw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1142&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;进入SpringAppication.run的源码可以看到，里面创建了一个context，默认是AnnotationConfigServletWebServerApplicationContext。一初始化，在Bean定义里就加载了spring开天辟地的5个Bean。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7903494176372712&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicZABgRrbBAG33MvWnr6W1icfmBmUbAmFZyZrV8JVjuQA5z8BsuaDOIAg6pVgJ11Fk3020D6icxvVtA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1202&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;继续向下执行走到AbstractApplicationContext的refresh方法，执行到onRefresh时，你进入方法里发现实际上执行的是&lt;/p&gt;&lt;p&gt;ServletWebServerApplicationContext的onFresh&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6649746192893401&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicZABgRrbBAG33MvWnr6W1icz6Zic8dlFIeYHLPPNI8f8STg0mXPZn9iaXSx768bbLdGmHEP4EHE40XA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;985&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这里面实际只做了一件事：创建web服务。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.31267345050878814&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicZABgRrbBAG33MvWnr6W1icNH46T5npWwQhQJqSPDg4tib60Q4yB24LhetuDxfdngLdQia3m6WgdRPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1081&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;进入这个方法，debug到getWebServerFactory&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.504225352112676&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicZABgRrbBAG33MvWnr6W1icqn8LnMmFPCYFJGoAYm3cz1KokTpXabOWVKYzoaTLRM6vBia9zK5RJhw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1065&quot;/&gt;&lt;/p&gt;&lt;p&gt;来看一下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4768480909829407&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicZABgRrbBAG33MvWnr6W1icibjRmZN3tCG5Fib5lVUH9xbGtVE19evG0R58z6Jolib9mMhuYicpJpHqNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1231&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;获取的正式JettyServletWebServerFactory。为啥不是TomcatServlet呢？ServletWebServerFactoryAutoConfiguration的源码很好的说明了这个问题。源码的大意是当tomcat依赖存在就用tomcat，不然就按顺序找jetty存不存在，不存在再找Undertow存不存在。找到了就返回这个bean作为Servlet的工厂类。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre&gt;@Configuration&lt;br/&gt;@AutoConfigureOrder(-&lt;span&gt;2147483648&lt;/span&gt;)&lt;br/&gt;@ConditionalOnClass({ServletRequest.&lt;span&gt;class&lt;/span&gt;})&lt;br/&gt;@ConditionalOnWebApplication(&lt;br/&gt;    type = Type.SERVLET&lt;br/&gt;)&lt;br/&gt;@EnableConfigurationProperties({ServerProperties.&lt;span&gt;class&lt;/span&gt;})&lt;br/&gt;@Import({ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.&lt;span&gt;class, &lt;/span&gt;EmbeddedTomcat.&lt;span&gt;class, &lt;/span&gt;EmbeddedJetty.&lt;span&gt;class, &lt;/span&gt;EmbeddedUndertow.&lt;span&gt;class&lt;/span&gt;})&lt;br/&gt;&lt;span&gt;public class &lt;/span&gt;ServletWebServerFactoryAutoConfiguration {&lt;br/&gt;    &lt;span&gt;public &lt;/span&gt;ServletWebServerFactoryAutoConfiguration() {&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    @Bean&lt;br/&gt;    &lt;span&gt;public &lt;/span&gt;ServletWebServerFactoryCustomizer servletWebServerFactoryCustomizer(ServerProperties serverProperties) {&lt;br/&gt;        &lt;span&gt;return new &lt;/span&gt;ServletWebServerFactoryCustomizer(serverProperties)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;}&lt;br/&gt;&lt;br/&gt;    @Bean&lt;br/&gt;    @ConditionalOnClass(&lt;br/&gt;        name = {&lt;span&gt;&quot;org.apache.catalina.startup.Tomcat&quot;&lt;/span&gt;}&lt;br/&gt;    )&lt;br/&gt;    &lt;span&gt;public &lt;/span&gt;TomcatServletWebServerFactoryCustomizer tomcatServletWebServerFactoryCustomizer(ServerProperties serverProperties) {&lt;br/&gt;        &lt;span&gt;return new &lt;/span&gt;TomcatServletWebServerFactoryCustomizer(serverProperties)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;}&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public static class &lt;/span&gt;BeanPostProcessorsRegistrar &lt;span&gt;implements &lt;/span&gt;ImportBeanDefinitionRegistrar&lt;span&gt;, &lt;/span&gt;BeanFactoryAware {&lt;br/&gt;        &lt;span&gt;private &lt;/span&gt;ConfigurableListableBeanFactory beanFactory&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        public &lt;/span&gt;BeanPostProcessorsRegistrar() {&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;public void &lt;/span&gt;setBeanFactory(BeanFactory beanFactory) &lt;span&gt;throws &lt;/span&gt;BeansException {&lt;br/&gt;            &lt;span&gt;if &lt;/span&gt;(beanFactory &lt;span&gt;instanceof &lt;/span&gt;ConfigurableListableBeanFactory) {&lt;br/&gt;                &lt;span&gt;this&lt;/span&gt;.beanFactory = (ConfigurableListableBeanFactory)beanFactory&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;}&lt;br/&gt;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;public void &lt;/span&gt;registerBeanDefinitions(AnnotationMetadata importingClassMetadata&lt;span&gt;, &lt;/span&gt;BeanDefinitionRegistry registry) {&lt;br/&gt;            &lt;span&gt;if &lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.beanFactory != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;this&lt;/span&gt;.registerSyntheticBeanIfMissing(registry&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;webServerFactoryCustomizerBeanPostProcessor&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;WebServerFactoryCustomizerBeanPostProcessor.&lt;span&gt;class&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;                this&lt;/span&gt;.registerSyntheticBeanIfMissing(registry&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;errorPageRegistrarBeanPostProcessor&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;ErrorPageRegistrarBeanPostProcessor.&lt;span&gt;class&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;}&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;private void &lt;/span&gt;registerSyntheticBeanIfMissing(BeanDefinitionRegistry registry&lt;span&gt;, &lt;/span&gt;String name&lt;span&gt;, &lt;/span&gt;Class&amp;lt;?&amp;gt; beanClass) {&lt;br/&gt;            &lt;span&gt;if &lt;/span&gt;(ObjectUtils.isEmpty(&lt;span&gt;this&lt;/span&gt;.beanFactory.getBeanNamesForType(beanClass&lt;span&gt;, true, false&lt;/span&gt;))) {&lt;br/&gt;                RootBeanDefinition beanDefinition = &lt;span&gt;new &lt;/span&gt;RootBeanDefinition(beanClass)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;                &lt;/span&gt;beanDefinition.setSynthetic(&lt;span&gt;true&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;                &lt;/span&gt;registry.registerBeanDefinition(name&lt;span&gt;, &lt;/span&gt;beanDefinition)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;}&lt;br/&gt;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;至此第二个问题也真相大白。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;问题3分析&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第三个问题是传统的web容器比如jetty本质上是直接通过java start.jar 来启动，之后来加载spring上下文的，SpringBoot通过main函数是怎么来启动web容器。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个问题在前面问题分析过程中也给了很多线索。我们来回顾下：SpringApplication.run里会创建Spring的应用上下文，默认是AnnotationConfigServletWebServerApplicationContext。首先会加载Spring开天辟地的5个Bean。然后它初始化各种Bean工厂。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;SpringBoot在ServletWebServerApplicationContext中重载了onRefresh方法，除了以前Spring默认的onRefresh方法外还增加了createWebServer方法，在这个方法中对Web容器进行了初始化工作。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre&gt;&lt;span&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &amp;lt;version&amp;gt;&lt;/span&gt;${spring.boot.version}&lt;span&gt;&amp;lt;/version&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &amp;lt;exclusions&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &amp;lt;exclusion&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-logging&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &amp;lt;/exclusion&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &amp;lt;exclusion&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-tomcat&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &amp;lt;/exclusion&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &amp;lt;exclusion&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &amp;lt;groupId&amp;gt;&lt;/span&gt;com.fasterxml.jackson.core&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &amp;lt;artifactId&amp;gt;&lt;/span&gt;jackson-databind&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &amp;lt;/exclusion&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &amp;lt;/exclusions&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-jetty&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &amp;lt;version&amp;gt;&lt;/span&gt;${spring.boot.version}&lt;span&gt;&amp;lt;/version&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &amp;lt;exclusions&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &amp;lt;exclusion&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &amp;lt;groupId&amp;gt;&lt;/span&gt;org.eclipse.jetty.aggregate&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &amp;lt;artifactId&amp;gt;&lt;/span&gt;jetty-all&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &amp;lt;/exclusion&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &amp;lt;/exclusions&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因为选择servlet容器是类似于使用基于条件的注解方式。因为当exclusion掉tomcat后，只有jetty满足条件，所以会加载JettyServletWebServerFactory。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过getWebServer方法会new一个WebServer对象，new对象的方法会调用initialize方法，在这个方法中会对容器进行初始化并启动。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而容器启动的基本原理就是创建个线程池和网络套接字。用线程去处理套接字读写的内容。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;文本用带有少许说明的三个问题开场展开论述，实际是使用了麦肯锡大法中的SCQA架构。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;SCQA架构是金字塔模型里面突出的一个论述方法，即“情境（Situation）、冲突（Complication）、问题（Question）、答案（Answer）”。可以帮助我们在陈述事实时条理更为清晰、有效。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;SCQA其实只是麦肯锡做了总结。这个方法李清照都在用：&lt;/p&gt;&lt;p&gt;昨夜雨疏风骤，浓睡不消残酒 （情境）&lt;/p&gt;&lt;p&gt;试问卷帘人，渠道海棠依旧（冲突）&lt;/p&gt;&lt;p&gt;知否，知否（问题）&lt;/p&gt;&lt;p&gt;应是绿肥红瘦（答案）&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;文章正文看似一步步回答问题，实际上在讲述怎样去看spring源码，了解spring原理的一个过程。即：带着问题去看，debug跟踪源码验证 的方法。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7a53ecb04a542e322e1c2909f157e613</guid>
<title>漏桶、令牌桶限流算法的 Go 语言实现</title>
<link>https://toutiao.io/k/ur64xby</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;限流&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;限流又称为流量控制（流控），通常是指限制到达系统的并发请求数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们生活中也会经常遇到限流的场景，比如：某景区限制每日进入景区的游客数量为 8 万人；沙河地铁站早高峰通过站外排队逐一放行的方式限制同一时间进入车站的旅客数量等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;限流虽然会影响部分用户的使用体验，但是却能在一定程度上保障系统的稳定性，不至于崩溃（大家都没了用户体验）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而互联网上类似需要限流的业务场景也有很多，比如电商系统的秒杀、微博上突发热点新闻、双十一购物节、12306 抢票等等。这些场景下的用户请求量通常会激增，远远超过平时正常的请求量，此时如果不加任何限制很容易就会将后端服务打垮，影响服务的稳定性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，一些厂商公开的 API 服务通常也会限制用户的请求次数，比如百度地图开放平台等会根据用户的付费情况来限制用户的请求数等。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.47890625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iavQtPTYuxWXAqzXeib7Axngdby4TPzn2ibV2x23WxiaDP0yLxanjWm1zWicSG7uibHogZq712GoUtib0D8IkRRmkOg3w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;常用的限流策略&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;漏桶&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;漏桶法限流很好理解，假设我们有一个水桶按固定的速率向下方滴落一滴水，无论有多少请求，请求的速率有多大，都按照固定的速率流出，对应到系统中就是按照固定的速率处理请求。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.88828125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iavQtPTYuxWXAqzXeib7Axngdby4TPzn2ibicHJYjLg9JtMndbibvFwgnjKVLzmGMRBSn50AAMiasGEl9FP6jTrHOmQw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;漏桶算法原理&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;漏桶法的关键点在于漏桶始终按照固定的速率运行，但是它并不能很好的处理有大量突发请求的场景，毕竟在某些场景下我们可能需要提高系统的处理效率，而不是一味的按照固定速率处理请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于漏桶的实现，uber 团队有一个开源的https://github.com/uber-go/ratelimit实现。使用方法也比较简单，&lt;code&gt;Take()&lt;/code&gt; 方法会返回漏桶下一次滴水的时间。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&quot;go.uber.org/ratelimit&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    rl := ratelimit.New(&lt;span&gt;100&lt;/span&gt;) &lt;span&gt;// per second&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    prev := time.Now()&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++ {&lt;br/&gt;        now := rl.Take()&lt;br/&gt;        fmt.Println(i, now.Sub(prev))&lt;br/&gt;        prev = now&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Output:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 0 0&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 1 10ms&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 2 10ms&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 3 10ms&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 4 10ms&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 5 10ms&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 6 10ms&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 7 10ms&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 8 10ms&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 9 10ms&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的源码实现也比较简单，这里大致说一下关键的地方，有兴趣的同学可以自己去看一下完整的源码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;限制器是一个接口类型，其要求实现一个&lt;code&gt;Take()&lt;/code&gt;方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Limiter &lt;span&gt;interface&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// Take方法应该阻塞已确保满足 RPS&lt;/span&gt;&lt;br/&gt; Take() time.Time&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现限制器接口的结构体定义如下，这里可以重点留意下&lt;code&gt;maxSlack&lt;/code&gt;字段，它在后面的&lt;code&gt;Take()&lt;/code&gt;方法中的处理。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; limiter &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; sync.Mutex                &lt;span&gt;// 锁&lt;/span&gt;&lt;br/&gt; last       time.Time      &lt;span&gt;// 上一次的时刻&lt;/span&gt;&lt;br/&gt; sleepFor   time.Duration  &lt;span&gt;// 需要等待的时间&lt;/span&gt;&lt;br/&gt; perRequest time.Duration  &lt;span&gt;// 每次的时间间隔&lt;/span&gt;&lt;br/&gt; maxSlack   time.Duration  &lt;span&gt;// 最大的富余量&lt;/span&gt;&lt;br/&gt; clock      Clock          &lt;span&gt;// 时钟&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;limiter&lt;/code&gt;结构体实现&lt;code&gt;Limiter&lt;/code&gt;接口的&lt;code&gt;Take()&lt;/code&gt;方法内容如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Take 会阻塞确保两次请求之间的时间走完&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Take 调用平均数为 time.Second/rate.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(t *limiter)&lt;/span&gt; &lt;span&gt;Take&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;time&lt;/span&gt;.&lt;span&gt;Time&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; t.Lock()&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; t.Unlock()&lt;br/&gt;&lt;br/&gt; now := t.clock.Now()&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 如果是第一次请求就直接放行&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; t.last.IsZero() {&lt;br/&gt;  t.last = now&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; t.last&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// sleepFor 根据 perRequest 和上一次请求的时刻计算应该sleep的时间&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// 由于每次请求间隔的时间可能会超过perRequest, 所以这个数字可能为负数，并在多个请求之间累加&lt;/span&gt;&lt;br/&gt; t.sleepFor += t.perRequest - now.Sub(t.last)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 我们不应该让sleepFor负的太多，因为这意味着一个服务在短时间内慢了很多随后会得到更高的RPS。&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; t.sleepFor &amp;lt; t.maxSlack {&lt;br/&gt;  t.sleepFor = t.maxSlack&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 如果 sleepFor 是正值那么就 sleep&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; t.sleepFor &amp;gt; &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;  t.clock.Sleep(t.sleepFor)&lt;br/&gt;  t.last = now.Add(t.sleepFor)&lt;br/&gt;  t.sleepFor = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt; } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  t.last = now&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; t.last&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的代码根据记录每次请求的间隔时间和上一次请求的时刻来计算当次请求需要阻塞的时间——&lt;code&gt;sleepFor&lt;/code&gt;，这里需要留意的是&lt;code&gt;sleepFor&lt;/code&gt;的值可能为负，在经过间隔时间长的两次访问之后会导致随后大量的请求被放行，所以代码中针对这个场景有专门的优化处理。&lt;code&gt;maxSlack&lt;/code&gt;默认值可以通过创建限制器的&lt;code&gt;New&lt;/code&gt;函数看到。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;New&lt;/span&gt;&lt;span&gt;(rate &lt;span&gt;int&lt;/span&gt;, opts ...Option)&lt;/span&gt; &lt;span&gt;Limiter&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; l := &amp;amp;limiter{&lt;br/&gt;  perRequest: time.Second / time.Duration(rate),&lt;br/&gt;  maxSlack:   &lt;span&gt;-10&lt;/span&gt; * time.Second / time.Duration(rate),&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; _, opt := &lt;span&gt;range&lt;/span&gt; opts {&lt;br/&gt;  opt(l)&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; l.clock == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  l.clock = clock.New()&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; l&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;令牌桶&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;令牌桶其实和漏桶的原理类似，令牌桶按固定的速率往桶里放入令牌，并且只要能从桶里取出令牌就能通过，令牌桶支持突发流量的快速处理。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.88828125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iavQtPTYuxWXAqzXeib7Axngdby4TPzn2ibl4oJRhUGtuA8lC8nlRPWItQPAH0h6CFhrFgRFNUqcOgBJ2VGEFqTlw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;令牌桶原理&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于从桶里取不到令牌的场景，我们可以选择等待也可以直接拒绝并返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于令牌桶的 Go 语言实现，大家可以参照https://github.com/juju/ratelimit。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个库支持多种令牌桶模式，并且使用起来也比较简单。 &lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建令牌桶的方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 创建指定填充速率和容量大小的令牌桶&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NewBucket&lt;/span&gt;&lt;span&gt;(fillInterval time.Duration, capacity &lt;span&gt;int64&lt;/span&gt;)&lt;/span&gt; *&lt;span&gt;Bucket&lt;/span&gt;&lt;br/&gt;// 创建指定填充速率、容量大小和每次填充的令牌数的令牌桶&lt;br/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NewBucketWithQuantum&lt;/span&gt;&lt;span&gt;(fillInterval time.Duration, capacity, quantum &lt;span&gt;int64&lt;/span&gt;)&lt;/span&gt; *&lt;span&gt;Bucket&lt;/span&gt;&lt;br/&gt;// 创建填充速度为指定速率和容量大小的令牌桶&lt;br/&gt;// &lt;span&gt;NewBucketWithRate&lt;/span&gt;&lt;span&gt;(0.1, 200)&lt;/span&gt; 表示每秒填充20个令牌&lt;br/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NewBucketWithRate&lt;/span&gt;&lt;span&gt;(rate &lt;span&gt;float64&lt;/span&gt;, capacity &lt;span&gt;int64&lt;/span&gt;)&lt;/span&gt; *&lt;span&gt;Bucket&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;取出令牌的方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 非阻塞的取token&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(tb *Bucket)&lt;/span&gt; &lt;span&gt;Take&lt;/span&gt;&lt;span&gt;(count &lt;span&gt;int64&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;time&lt;/span&gt;.&lt;span&gt;Duration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(tb *Bucket)&lt;/span&gt; &lt;span&gt;TakeAvailable&lt;/span&gt;&lt;span&gt;(count &lt;span&gt;int64&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;int64&lt;/span&gt;&lt;br/&gt;// 最多等&lt;span&gt;maxWait&lt;/span&gt;时间取&lt;span&gt;token&lt;/span&gt;&lt;br/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(tb *Bucket)&lt;/span&gt; &lt;span&gt;TakeMaxDuration&lt;/span&gt;&lt;span&gt;(count &lt;span&gt;int64&lt;/span&gt;, maxWait time.Duration)&lt;/span&gt; &lt;span&gt;(time.Duration, &lt;span&gt;bool&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;// 阻塞的取&lt;span&gt;token&lt;/span&gt;&lt;br/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(tb *Bucket)&lt;/span&gt; &lt;span&gt;Wait&lt;/span&gt;&lt;span&gt;(count &lt;span&gt;int64&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(tb *Bucket)&lt;/span&gt; &lt;span&gt;WaitMaxDuration&lt;/span&gt;&lt;span&gt;(count &lt;span&gt;int64&lt;/span&gt;, maxWait time.Duration)&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽说是令牌桶，但是我们没有必要真的去生成令牌放到桶里，我们只需要每次来取令牌的时候计算一下，当前是否有足够的令牌可以使用就可以了，具体的计算公式如下。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;当前令牌数 = 上一次剩余的令牌数 + (本次取令牌的时刻-上一次取令牌的时刻)/放置令牌的时间间隔 * 每次放置的令牌数&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;github.com/juju/ratelimit这个库中关于令牌数计算的具体实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(tb *Bucket)&lt;/span&gt; &lt;span&gt;adjustavailableTokens&lt;/span&gt;&lt;span&gt;(tick &lt;span&gt;int64&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; tb.availableTokens &amp;gt;= tb.capacity {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; tb.availableTokens += (tick - tb.latestTick) * tb.quantum&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; tb.availableTokens &amp;gt; tb.capacity {&lt;br/&gt;  tb.availableTokens = tb.capacity&lt;br/&gt; }&lt;br/&gt; tb.latestTick = tick&lt;br/&gt; &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;获取令牌的&lt;code&gt;TakeAvailable&lt;/code&gt;函数关键部分的源码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(tb *Bucket)&lt;/span&gt; &lt;span&gt;takeAvailable&lt;/span&gt;&lt;span&gt;(now time.Time, count &lt;span&gt;int64&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;int64&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; count &amp;lt;= &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; tb.adjustavailableTokens(tb.currentTick(now))&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; tb.availableTokens &amp;lt;= &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; count &amp;gt; tb.availableTokens {&lt;br/&gt;  count = tb.availableTokens&lt;br/&gt; }&lt;br/&gt; tb.availableTokens -= count&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; count&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家从代码中也可以看到其实令牌桶的实现并没有很复杂。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;gin 框架中使用限流中间件&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 gin 框架构建的项目中，我们可以将限流组件定义成中间件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里使用令牌桶作为限流策略，编写一个限流中间件如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;RateLimitMiddleware&lt;/span&gt;&lt;span&gt;(fillInterval time.Duration, &lt;span&gt;cap&lt;/span&gt; &lt;span&gt;int64&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;&lt;span&gt;(c *gin.Context)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; bucket := ratelimit.NewBucket(fillInterval, &lt;span&gt;cap&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(c *gin.Context)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// 如果取不到令牌就返回响应&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; bucket.TakeAvailable(&lt;span&gt;1&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;   c.String(http.StatusOK, &lt;span&gt;&quot;rate limit...&quot;&lt;/span&gt;)&lt;br/&gt;   c.Abort()&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  c.Next()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于该限流中间件的注册位置，我们可以按照不同的限流策略将其添加到不同的地方，例如：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果要对全站限流就可以添加成全局的中间件。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果是某一组路由需要限流，那么就只需添加到对应的路由组即可。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>863cc57bd94a3a59ba397acbe2cc9950</guid>
<title>闲鱼 Serverless 架构实践</title>
<link>https://toutiao.io/k/0o2emfp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                                    


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section&gt;&lt;strong&gt;造梦者 | 王树彬（国有），阿里巴巴闲鱼架构负责人&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2014年6月28日，阿里即将赴美上市的这一年，西溪园区的一个茶水间里，28个人日夜赶工了三个月后，上线了一个闲置交易平台——闲鱼。今年5月份，在阿里巴巴的年报中对外公布了闲鱼的数据：GMV2000亿元，同比增长100%，每天在线卖家数超过3000万人。 闲鱼已经从一个茶水间创业的内部小产品，变成了在C2C领域的领先平台。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;据艾媒数据估计，2020年全年的二手物品交易市场的规模将达到万亿以上。线上交易的繁荣亟需技术架构做相应的调整、演进才能支撑业务的快速发展。闲鱼对于阿里而言，有比营收更重要的意义，那就是创新。创新不只体现在业务模式上，闲鱼的技术架构也在探索最新的方向——向Flutter化、云原生/Serverless化发展。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;2009年，从浙江大学毕业的王树彬，在UT斯康达工作了三年后，加入阿里巴巴。2017年，王树彬和闲鱼团队首次将Flutter引入到闲鱼，从2018年开始，王树彬带领团队在下一盘更大的棋：布局Serverless。&lt;span&gt;颠覆性创新往往是从边缘性的地方出现，而&lt;/span&gt;向云原生化/Serverless化升级，对于闲鱼是一条全新的路，但趟出了这条路，对于很多做线上交易的公司有着巨大的借鉴意义。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;今天，我们就一起聊聊闲鱼的云原生故事。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2 data-lake-id=&quot;e146a5004d9ca070ed9eb0e176bcf7e3&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;01 为什么要做Serverless？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;闲鱼是依托阿里电商体系的前台型业务，有非常独特的业务特点和用户诉求，在底层依托阿里系统的同时，在表现层和业务层需要探索适合闲鱼的、并且更加快速灵活的研发体系。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;按照传统的开发方式，闲鱼原有的 IT 系统会面临很多痛点，比如：&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ol data-lake-id=&quot;584d3b2dee7de6003647fbd7e7b880aa&quot; start=&quot;1&quot; lake-indent=&quot;0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;客户端交互层、服务端业务胶水层、领域层边界划分不清晰，这就导致很小的业务需求就需要整条链路的同学参与，协同成本高，开发调试周期长。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ol data-lake-id=&quot;b477a844f35e6bfdf1eff9f8f738c518&quot; start=&quot;2&quot; lake-indent=&quot;0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;服务端存在巨型应用，研发耦合、发布耦合、运维耦合严重，甚至系统稳定性也受到很大挑战，单个业务问题往往会影响整个应用。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ol data-lake-id=&quot;ebb4073ec96cc0412cb83a51047ef102&quot; start=&quot;3&quot; lake-indent=&quot;0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;运维成本极高。&lt;span&gt;为了保障业务的稳定性和可用性，阿里对每一个应用上线都有相应的规范和规则。哪怕是一个很小的内部应用，一天可能只有一两个访问量，上线也需要遵守既有的规范，这势必会消耗一些固定资源。单个应用消耗的资源可能很有限，但所有应用消耗的资源累积起来也是一个不小的数字。而&lt;/span&gt;对于巨型应用，由于影响面巨大，发布时要有更加严格的流程和步骤，一次发布至少要耗时6小时，导致运维成本极高。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt; &lt;/section&gt;&lt;section&gt;Serverless 的出现，一方面使云端一体化研发成为可能，很多小业务需求的协同成本可以大大降低。另一方面，Serverless 使业务胶水层的巨型应用，有了比微服务更加合理的拆分方式。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;传统巨型应用的成本（速度）、稳定、质量相互制约的瓶颈，可以用下面这个三角形来直观的表示。&lt;/p&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.6196943972835314&quot; data-type=&quot;png&quot; data-w=&quot;1178&quot; title=&quot;1233.png&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWspRlRsZMoNflDSfhMhqI94QhUDsibdTuNNPeibXd0AgjwHNuQDV3KLeW7M5aQiaJ94JW5iayW8tsUufw/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;云原生/Serverless 这些新技术的出现，可以使应用运维能力下沉，传统巨型应用的成本（速度）、稳定、质量相互制约的瓶颈才有可能被打破。闲鱼在落地新技术的过程中，先围绕 Flutter 重点攻坚了 Flutter 混合工程体系、高性能组件库。然后围绕Serverless 重点攻坚云端一体化研发体系、服务端业务组装层架构体系。&lt;/section&gt;&lt;section&gt; &lt;/section&gt;&lt;section&gt;闲鱼客户端基于 Flutter 进行架构演进与创新，通过 Flutter 统一 Android 和 iOS 双端提升研发效能之后，希望通过 Flutter+Serverless 解决各角色间存在的大量的协同问题，正是这些问题导致整体研发效率低，移动端离业务越来越远，服务端没有时间做底层领域沉淀。通过 Serverless 的引入，闲鱼会明显看到整体研发效率的提升。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2 data-lake-id=&quot;a8e0a4053750711c78cd633beb706ec9&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;02 一边探索，一边实践&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;2018年，闲鱼技术团队开始探索 Serverless，整体分为四个阶段：自建Dart Server、依托FaaS平台、云端一体化、传统巨型应用Serverless化。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;2018年5月，以 Serverless 思路构建了2s内冷启动的 Dart Server 应用框架，用于服务端业务胶水层的轻量化开发。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;2018年底到2019年初，闲鱼启动与Gaia团队协同共建基于Gaia平台的Dart 运行时，并上线了部分业务。&lt;span&gt;注：Gaia是基于阿里云的面向淘宝业务特点封装的、用于淘宝业务的FaaS平台。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;2019年，闲鱼基于Gaia的Dart Runtime标准化，探索 Flutter+FaaS 云端编程一体化，领域接口元数据化，最终诞生了 Nexus 等胶水层业务框架，并在闲鱼20多个业务落地。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;2020年，闲鱼开始进行云端的工程&amp;amp;工具一体化，目标是实现一个工程、多端部署。现在，王树彬正带着技术团队攻坚业务胶水层的传统巨型应用治理，使传统应用向Serverless化迁移，“最快3个月，最晚6个月，我们就会交出一份漂亮的答卷。”&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;具体来看过去这两年的时间里，闲鱼在Serverless上的实践成果，主要分为5个方面：&lt;/section&gt;&lt;section&gt; &lt;/section&gt;&lt;ol data-lake-id=&quot;d48518b8448b757811e1b10539c46013&quot; start=&quot;1&quot; lake-indent=&quot;0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;云端编程模型一体化框架（Nexus API）&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;这个框架的目标是使Flutter、FaaS的编程模型统一，打通UI、交互、数据、逻辑。王树彬提到，一开始说要做Flutter + FaaS一体化的时候，我们对“一体化“这三个字的认知相对比较模糊，只是知道端侧的同学可以用 Dart 这门语言来写FaaS函数，这其实还停留在语言上的一体化。对于FaaS所能做的事，也仅仅停留在前端实施已久的BFF层面。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们花了很长时间来讨论，&lt;span&gt;基于Dart生态下，前端的 FaaS 在研发交付其实并不高效，研发阶段主要面临的问题是：&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span/&gt;&lt;br/&gt;&lt;strong&gt;编程语言不统一：&lt;/strong&gt;&lt;span&gt;编程语言本身虽然不是最大的障碍，但这也确实给前端开发者增加不少门槛，而且更重要的是语言背后的生态、环境与体系更是一道高高的墙。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span/&gt;&lt;br/&gt;&lt;strong&gt;开发模式与架构割裂，环境复杂：&lt;/strong&gt;&lt;span&gt;端侧一个工程，FaaS侧也有一个独立的工程，它们背后有自己的一套构建、调试、集成/发布的工具链；除此之外，FaaS 还有自己配套的环境、Runtime、框架作为支撑。开发者面对这样复杂的 FaaS 研发环境与双重的研发工作流是无法做到高效交付的。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最终，我们对一体化有了一个比较清晰的共识，那就是要实现两个核心的一体化：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;编程语言的一体化可以为开发者提供一种熟悉的技术栈，开发模式与架构一体化能帮助开发者解决工程割裂以及背后复杂的 FaaS 本地运行环境问题，带来与原研发模式基本一致的研发体验。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;通过这两个层面的一体化，最终达到开发 Flutter 页面和开发 FaaS 无明显Gap。例如，闲鱼客户端Flutter以往是用Redux框架开发，在Nexus API框架下，可以使Redux与FaaS调用无缝集成。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7373211963589077&quot; data-type=&quot;png&quot; data-w=&quot;1538&quot; title=&quot;56.png&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWspRlRsZMoNflDSfhMhqI94pG8SKOic9q1188c81mPpSxh0Zm92JR2IPCFqU257bgeGklicqhW8WalQ/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ol data-lake-id=&quot;f0761c586d7a1497196a8067f0914560&quot; start=&quot;2&quot; lake-indent=&quot;0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;CLI 开发工具标准化&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;云端一体化开发时，通过 CLI（命令行工具）屏蔽 FaaS 开发的一些细节，使客户端开发 FaaS 时的开发体验标准化，符合客户端同学的本地开发习惯。&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.42962962962962964&quot; data-type=&quot;png&quot; data-w=&quot;810&quot; title=&quot;6778.png&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWspRlRsZMoNflDSfhMhqI94DRKxskuhP2XP2NSnDN5EDlt4YicibAe2Ps6xJWwAHRUa3ic57n0iadRmPw/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ol data-lake-id=&quot;190d2c277810c62427938c19942fea6a&quot; start=&quot;3&quot; lake-indent=&quot;0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;基础服务 BaaS 化&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;过去两年，我们在逐渐简化基础服务能力，如对象存储、消息、搜索。同时，建设业务领域层服务的元数据中心，这些简化的基础服务能力，再加上已有的业务领域层服务，使客户端同学可以快速组装业务。&lt;/section&gt;&lt;section&gt; &lt;/section&gt;&lt;ol data-lake-id=&quot;0ef24172f0bc08005611c6ab7b90c790&quot; start=&quot;4&quot; lake-indent=&quot;0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;云端工程一体化&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;闲鱼在成功引入 Flutter 后，在端侧形成了以 Flutter 为主、H5为辅的跨端研发体系，使传统的 Android 和 iOS 的两端研发，合并成一端。在端上的生产力得到释放时，我们发现端的同学有机会向下层走一点，使服务端面向简单的数据组装逻辑，由端的同学一人闭环完成，这套模式尤其适用于一些小业务的需求。类似的尝试业界其实早就有了，例如 GraphQL 框架的流行，前端的BFF层的形成。但有了Serverless，服务端轻量代码的开发可以极大地简化，所以闲鱼选择这个时机推进云端一体化。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;云端一体化涉及到云端编程框架、工具链、工程体系、基础服务BaaS化、领域服务下沉，同时，也涉及人员上的组织保障、分工重塑、安全生产培训等。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ol data-lake-id=&quot;e45070d283431cb71a6fbde35f6a985e&quot; start=&quot;5&quot; lake-indent=&quot;0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;传统巨型应用的Serverless化改造&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;Serverless不是银弹，但与业务胶水层的特点很匹配，非常适用于解决胶水层的传统巨型应用的拆分，这也是闲鱼正在攻坚的下一个难题。&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.34740545294635006&quot; data-type=&quot;png&quot; data-w=&quot;2274&quot; title=&quot;888.png&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWspRlRsZMoNflDSfhMhqI94Iq8QhYIBxKCfwqBHDbUWbZuxuia8bWfuQLZTg3KgVS2pON5yiamZ6iaPg/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2 data-lake-id=&quot;c235570e832672ec368263eee8af20f1&quot;&gt;&lt;span&gt;&lt;strong&gt;03 难题与破局&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;闲鱼落地 Serverless 的过程中并非一帆风顺。王树彬提到，在Serverless云端一体化过程中，遇到了一些技术难题，比如Java富客户端的异构语言访问、开放环境如何统一以及客户端同学对领域接口不熟悉等问题。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;在闲鱼的Java系统中，存在大量的Java富客户端应用。针对Java富客户端的异构语言访问，闲鱼以Sidecar的模式，建立Java的Proxy来解决这类问题。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;紧接着，为了让开发环境统一，闲鱼开发了自己的CLI工具（GCLI）。&lt;span&gt;GCLI是一个基于支撑 FaaS 研发生命周期的命令行工具，它定义了闲鱼 FaaS 开发闭环，统一了 FaaS 的研发环境，是提升FaaS研发效率的利器。GCLI 将研发闭环拆解成适合Serverless 研发习惯的开发指令。为了让用户继承其研发习惯和工具，闲鱼优先选择了基于本地的开发方案；使用Docker技术统一开发环境，在 Dcoker 内声明Dart FaaS技术栈依赖的运行环境(软件+配置)。借助容器技术，FaaS 的软件环境可以移植到任何支持Linux运行的操作系统，从而解决了环境统一的问题；GCLI 通过 FaaS  Open API 实现本地和函数平台实现互操作，形成完整的研发闭环。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最后，针对客户端同学对领域接口不熟悉的&lt;span&gt;问题，闲鱼开发了领域层的元数据中心。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;云端一体化重塑了传统的云、端边界，减少了协同，也给人员的分工带来了更大的灵活性，技术上的研发效率、研发质量也明显提升。而这些改变对于业务带来的直接好处，就是可以让业务有更快的迭代速度、更快地适应市场和用户需求的变化。&lt;/section&gt;&lt;section&gt; &lt;/section&gt;&lt;p&gt;云端一体化目前应用在闲鱼的重交互场景以及轻量业务场景中，其带来的技术效率、质量提升更容易以量化的数据形式呈现。例如，以典型的中大型业务需求抽样统计，开发人日降低了30%，千行代码Bug率降低了20%。如果以零散需求统计，数据提升会更加明显。以往的小需求由于多个同学参与，往往排期需要几周，而云端一体化后，资源的灵活性明显提高，使需求响应速度大大提升。&lt;/p&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.6735632183908046&quot; data-type=&quot;png&quot; data-w=&quot;1740&quot; title=&quot;099.png&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWspRlRsZMoNflDSfhMhqI94hErpicFjYD0xZE4797LzkTjXEmrRdW5GErFywHGveHTVib0icV9JFC3yg/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;“但是，还有一些问题没有解决”，王树彬说，在 Serverless 的巨型应用拆分方面，闲鱼遇到的问题更加严峻，比如：&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;微服务和 Serverless 的选型&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在 Functions 之间代码复用&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;对函数的依赖做统一升级&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这几个问题的方案，闲鱼还在逐步验证中，待经验成熟后再向大家详细分享，欢迎持续关注。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2 data-lake-id=&quot;090aa214d5a499b7039c23e9e10f6e77&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;04 借鉴与思考&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;什么样的公司、应用或场景应该选用 Serverless 的架构模式？目前没有具体的定义，关键在于想清楚。&lt;span&gt;想清楚，就需要平衡好收益、成本、效率和应对市场的能力。其中，&lt;/span&gt;成本是企业更为关注的因素，这其中包括基础设施搭建的成本、运维成本、扩容成本、安全成本等。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Netflix&lt;/span&gt;&lt;span&gt;是落地 Serverless 的一个成功的典型，Netflix 在产品设计上一直都有创新的基因，除了不间断的 A/B 测试之外，每周都会发布很多新功能。为了确保这样高强度的工作成果，就需要一个 API 服务平台来帮助客户端工程师快速而有效地将更改的需求部署到服务层。FaaS 通过把那些与服务相关的所有平台组件抽象为业务逻辑本身来实现这一目标，而 Serverless 模式能够为Netflix提供一个平台，即使没有服务器和运营经验的工程师也可以开发高可用的服务。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;采用 FaaS 模式，本质上是对交易速度和可能性的定制化。有些应用程序的 FaaS 服务表现得很好——Netflix API 的情况就是如此，Netflix 运行的是相对统一的微服务，只需要访问和改变下游服务的数据。然而，如果服务需要定制化，例如需要改变服务平台的各个组成部分，像 RPC、数据访问、缓存、认证等，那么 FaaS 模式可能无法为这些服务提供足够的灵活性。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;自建 Serverless 平台对企业IT人员的要求比较高，同时建设成本也很高。另外，实施Serverless 需要一个成熟的生态。绝大多数情况下，已经上云的企业应该优先考虑云厂商的Serverless产品，而没有上云的企业，需要考虑现有系统的生态情况是否能与云厂商的Serverless产品兼容。&lt;/section&gt;&lt;section&gt; &lt;/section&gt;&lt;section&gt;&lt;span&gt;对于 Serverless 产品的选型，应该综合几个方面来看：生态的成熟度，支持的开发语言，功能丰富度，收费标准等，关键是结合企业自身业务发展的需求。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2 data-lake-id=&quot;9ffba8a6446241197fc1dbdc626a9c66&quot;&gt;&lt;span&gt;&lt;strong&gt;05 关于未来&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;O&#x27;Reilly 曾对 Serverless 的应用情况进行了过一次&lt;/span&gt;调查，发现&lt;span&gt;软件行业的开发者关注和应用 Serverless 非常多，这在意料之中，但是金融和银行业也在高度关注Serverless，原因之一是越来越多的金融科技&lt;/span&gt;&lt;span&gt;初创企业的诞生，它们承担了传统基础架构的责任，并且以更开放的心态，接纳和拥抱 Serverless 。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;3de66851bf2e64b4b4446444b3d78557&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于拒绝 Serverless 的理由，60% 的受访者表示是安全问题。因为很多行业对于 IT 环境的安全性要求很高，而采用任何新技术都可能会带来安全风险。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;此外，开发者另外一层顾虑主要是担心被厂商绑定，这就导致具备一定规模的组织会基于开源方案，如 Knative，搭建自己的 Serverless 平台。而一旦某个开源方案成为主流，云厂商就会主动去兼容开源标准并增大社区投入。&lt;/span&gt;&lt;/section&gt;&lt;p data-lake-id=&quot;988ce2dc767d2514a388cf7a77b03ae1&quot;&gt;&lt;/p&gt;&lt;p&gt;Serverless 除了对技术和业务产生影响外，对于企业组织架构和技术人员也提出了新的要求。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;首先，Serverless 改变了沟通结构。按照康威定律，组织架构需要适应新的沟通结构，才是最好的匹配。闲鱼以前负责客户端和服务端的同学是分开的，在全新的 Flutter+Serverless 的背景下，组织结构也需要适应。闲鱼技术按照业务线划分，将客户端、服务端的同学按业务线重新组合到一起，正是Serverless+Flutter的组织保障。&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;其次，Serverless 使客户端的同学有机会更多的了解业务，这就要求客户端同学更加具有业务敏感度。&lt;span&gt;Serverless 促使客户端同学扩大了技术边界，也需要了解一定的服务端开发概念。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;最后，Serverless 要求原有的服务端同学有更好的数据建模、领域建模能力，从而有助于底层接口复用度更好。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从最开始不被外界看好，甚至被调侃为“咸鱼”，到如今实现了&lt;span&gt;千&lt;/span&gt;&lt;span&gt;&lt;span&gt;万DAU&lt;/span&gt;&lt;/span&gt;，&lt;/span&gt;&lt;span&gt;盘活了一个万亿级市场，闲鱼的出现，无论是对前端的电商生态，还是用户在互联网上的生活形式，都产生了重要的影响&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了支撑起闲鱼万亿的交易规模，王树彬和技术团队&lt;span&gt;正在紧锣密鼓地进行&lt;/span&gt;传统巨型应用的 Serverless 化改造，“闯过了 Serverless 的这一关，才是我比较满意的状态。”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;火热直播中：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;王树彬带来的「Serverless分论坛 — 2020 Serverless 新浪潮」分享《闲鱼Serverless架构实践》的话题，正在云栖大会火热直播中，&lt;/span&gt;&lt;span&gt;&lt;span&gt;点击下方&lt;/span&gt;&lt;span&gt;“阅读原文”&lt;/span&gt;&lt;span&gt;即可直达！&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7994981fa4c5839f4282122de6b17fe8</guid>
<title>如何学习 FPGA</title>
<link>https://toutiao.io/k/3tro911</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entry-content&quot;&gt;&amp;#13;

&lt;p&gt;首先给大家推荐一下我老师大神的人工智能教学网站。教学不仅零基础，通俗易懂，而且非常风趣幽默，还时不时有内涵黄段子！&lt;a href=&quot;https://www.captainbed.net/lhyd&quot;&gt;点这里可以跳转到网站&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;PS：笔者强烈建议诸位注册一个EETOP的账号，每天签到或者发贴、回贴就有积分了，里面的资源非常丰富，各种软件、资料都能找到。&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;一、入门首先要掌握HDL（HDL=verilog+VHDL）。&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;       第一句话是：还没学数电的先学&lt;a href=&quot;http://bbs.eetop.cn/thread-157244-1-1.html&quot;&gt;&lt;strong&gt;数电&lt;/strong&gt;&lt;/a&gt;。然后你可以选择verilog或者VHDL，有C语言基础的，建议选择VHDL。因为verilog太像C了，很容易混淆，最后你会发现，你花了大量时间去区分这两种语言，而不是在学习如何使用它。当然，你思维能转得过来，也可以选verilog，毕竟在国内verilog用得比较多。&lt;/p&gt;



&lt;p&gt;       接下来，首先找本实例抄代码。抄代码的意义在于熟悉语法规则和编译器（这里的编译器是硅编译器又叫综合器，常用的编译器有：&lt;a href=&quot;http://blog.csdn.net/k331922164/article/details/46275247&quot;&gt;&lt;strong&gt;Quartus&lt;/strong&gt;&lt;/a&gt;、&lt;a href=&quot;http://bbs.eetop.cn/thread-451518-1-1.html&quot;&gt;&lt;strong&gt;ISE&lt;/strong&gt;&lt;/a&gt;、&lt;a href=&quot;http://bbs.eetop.cn/thread-598057-1-1.html&quot;&gt;&lt;strong&gt;Vivado&lt;/strong&gt;&lt;/a&gt;、&lt;a href=&quot;http://bbs.eetop.cn/thread-558981-1-1.html&quot;&gt;&lt;strong&gt;Design Compiler&lt;/strong&gt;&lt;/a&gt; 、&lt;a href=&quot;http://www.synopsys.com/Tools/Implementation/FPGAImplementation/Pages/default.aspx&quot;&gt;&lt;strong&gt;Synopsys&lt;/strong&gt;&lt;/a&gt;的&lt;a href=&quot;http://bbs.eetop.cn/thread-412008-1-1.html&quot;&gt;&lt;strong&gt;VCS&lt;/strong&gt;&lt;/a&gt;、iverilog、&lt;strong&gt;&lt;a href=&quot;http://www.latticesemi.com/Products.aspx&quot;&gt;Lattice&lt;/a&gt;&lt;/strong&gt;的&lt;a href=&quot;http://blog.csdn.net/k331922164/article/details/51379364&quot;&gt;&lt;strong&gt;Diamond&lt;/strong&gt;&lt;/a&gt;、Microsemi/Actel的&lt;a href=&quot;https://www.microsemi.com/products/fpga-soc/design-support/fpga-soc-design&quot;&gt;&lt;strong&gt;Libero&lt;/strong&gt;&lt;/a&gt;、&lt;a href=&quot;http://bbs.eetop.cn/thread-578576-1-1.html&quot;&gt;&lt;strong&gt;Synplify pro&lt;/strong&gt;&lt;/a&gt;），然后再模仿着写，最后不看书也能写出来。编译完代码，就打开RTL图，看一下综合出来是什么样的电路&lt;strong&gt;。&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;       HDL是硬件描述语言，突出硬件这一特点，所以要&lt;strong&gt;用数电的思维去思考HDL，而不是用C语言或者其它高级语言&lt;/strong&gt;，如果不能理解这句话的，可以看《&lt;a href=&quot;http://blog.csdn.net/k331922164/article/details/46730523&quot;&gt;&lt;strong&gt;什么是硬件以及什么是软件&lt;/strong&gt;&lt;/a&gt;》。在这一阶段，推荐的教材是&lt;strong&gt;《&lt;a href=&quot;http://product.dangdang.com/24036476.html&quot;&gt;Verilog传奇&lt;/a&gt;》、《&lt;a href=&quot;http://bbs.eetop.cn/thread-281674-1-1.html&quot;&gt;Verilog HDL高级数字设计&lt;/a&gt;》&lt;/strong&gt;或者是《&lt;a href=&quot;http://search.dangdang.com/?key=%20%D3%C3%D3%DA%C2%DF%BC%AD%D7%DB%BA%CF%B5%C4VHDL&amp;amp;act=input&quot;&gt;&lt;strong&gt;用于逻辑综合的VHDL&lt;/strong&gt;&lt;/a&gt;》。不看书也能写出个三段式状态机就可以进入下一阶段了。&lt;/p&gt;



&lt;p&gt;       此外，你手上必须准备Verilog或者VHDL的官方文档，《&lt;a href=&quot;http://bbs.eetop.cn/thread-556080-1-1.html&quot;&gt;&lt;strong&gt;verilog_IEEE官方标准手册-2005_IEEE_P1364&lt;/strong&gt;&lt;/a&gt;》、《&lt;a href=&quot;http://bbs.eetop.cn/thread-436703-1-1.html&quot;&gt;&lt;strong&gt;IEEE Standard VHDL Language_2008&lt;/strong&gt;&lt;/a&gt;》，以便遇到一些语法问题的时候能查一下。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;二、独立完成中小规模的数字电路设计。&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;       现在，你可以设计一些数字电路了，像交通灯、电子琴、DDS等等，推荐的教材是《&lt;a href=&quot;http://bbs.eetop.cn/viewthread.php?tid=587313&quot;&gt;&lt;strong&gt;Verilog HDL应用程序设计实例精讲&lt;/strong&gt;&lt;/a&gt;》。在这一阶段，你要做到的是：给你一个指标要求或者时序图，你能用HDL设计电路去实现它。这里你需要一块开发板，可以选&lt;a href=&quot;https://www.altera.com/support/literature/lit-index.smartphone.html&quot;&gt;&lt;strong&gt;Altera&lt;/strong&gt;&lt;/a&gt;的cyclone IV系列，或者&lt;a href=&quot;http://china.xilinx.com/support.html&quot;&gt;&lt;strong&gt;Xilinx&lt;/strong&gt;&lt;/a&gt;的Spantan 6。&lt;strong&gt;还没掌握HDL之前千万不要买开发板，因为你买回来也没用&lt;/strong&gt;。这里你没必要每次编译通过就下载代码，咱们用&lt;a href=&quot;http://blog.csdn.net/k331922164/article/details/47988847&quot;&gt;&lt;strong&gt;modelsim仿真&lt;/strong&gt;&lt;/a&gt;（此外还有&lt;a href=&quot;http://bbs.eetop.cn/thread-452999-1-1.html&quot;&gt;&lt;strong&gt;QuestaSim&lt;/strong&gt;&lt;/a&gt;、&lt;a href=&quot;http://bbs.eetop.cn/thread-471086-1-1.html&quot;&gt;&lt;strong&gt;NC verilog&lt;/strong&gt;&lt;/a&gt;、Diamond的Active-HDL、VCS、Debussy/&lt;a href=&quot;http://wenku.baidu.com/link?url=1cMQfcz0XQVXzvk2bOj_hLCfy6EAZR8KmlmRl-7pMnq-BCz8bLzYhfmQXcV9aqxVO0EB9rfV0X1nXgEpUUmUOQFv682BHIUB8HFUwOGfNoO&quot;&gt;&lt;strong&gt;Verdi&lt;/strong&gt;&lt;/a&gt;等仿真工具），如果仿真都不能通过那就不用下载了，肯定不行的。在这里先掌握简单的testbench就可以了。推荐的教材是《&lt;a href=&quot;http://bbs.eetop.cn/thread-413725-1-1.html&quot;&gt;&lt;strong&gt;WRITING TESTBENCHES Functional Verification of HDL Models&lt;/strong&gt;&lt;/a&gt;》。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;三、掌握设计方法和设计原则。&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;       你可能发现你综合出来的电路尽管没错，但有很多警告。这个时候，你得学会同步设计原则、优化电路，是速度优先还是面积优先，时钟树应该怎样设计，怎样同步两个异频时钟等等。推荐的教材是《&lt;a href=&quot;http://bbs.eetop.cn/thread-335134-1-1.html&quot;&gt;&lt;strong&gt;FPGA权威指南&lt;/strong&gt;&lt;/a&gt;》、《&lt;a href=&quot;https://www.amazon.cn/IP%E6%A0%B8%E8%8A%AF%E5%BF%97-%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E5%90%B4%E6%B6%9B/dp/B0153NAS28/ref=sr_1_1?ie=UTF8&amp;amp;qid=1460103068&amp;amp;sr=8-1&amp;amp;keywords=IP%E6%A0%B8%E8%8A%AF%E5%BF%97-%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3&quot;&gt;&lt;strong&gt;IP核芯志-数字逻辑设计思想&lt;/strong&gt;&lt;/a&gt;》、《Altera FPGA/CPLD设计》第二版的&lt;a href=&quot;http://bbs.eetop.cn/thread-236729-1-1.html?tid=236729&amp;amp;extra=page%3D1&amp;amp;page=1&quot;&gt;&lt;strong&gt;基础篇&lt;/strong&gt;&lt;/a&gt;和&lt;a href=&quot;http://bbs.eetop.cn/thread-429297-1-1.html&quot;&gt;&lt;strong&gt;高级篇&lt;/strong&gt;&lt;/a&gt;两本。学会加快编译速度（增量式编译、LogicLock），静态&lt;a href=&quot;http://blog.csdn.net/k331922164/article/details/48687161&quot;&gt;&lt;strong&gt;时序分析&lt;/strong&gt;&lt;/a&gt;（&lt;a href=&quot;http://wenku.baidu.com/link?url=f55u1aL6d5XKysDuD4keltciKNk46aUXn39IF0hINNjaTqHxOeh34PfZDkudvU3JuI1RuwT9DPsow_kRFe9qhWYZbG7uWVo-AoAAylvlLP3&quot;&gt;&lt;strong&gt;timequest&lt;/strong&gt;&lt;/a&gt;），嵌入式逻辑分析仪（&lt;a href=&quot;http://blog.csdn.net/k331922164/article/details/47623501&quot;&gt;&lt;strong&gt;signaltap&lt;/strong&gt;&lt;/a&gt;）就算是通关了。如果有不懂的地方可以暂时跳过，因为这部分还需要足量的实践，才能有较深刻的理解。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;四、学会提高开发效率。&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;        因为Quartus和ISE的编辑器功能太弱，影响了开发效率。所以建议使用&lt;strong&gt;&lt;a href=&quot;http://blog.csdn.net/k331922164/article/details/48092291&quot;&gt;Sublime text编辑器&lt;/a&gt;&lt;/strong&gt;中代码片段的功能，以减少重复性劳动。Modelsim也是常用的仿真工具，学会TCL/TK以编写适合自己的&lt;strong&gt;&lt;a href=&quot;http://blog.csdn.net/k331922164/article/details/50001035&quot;&gt;DO文件&lt;/a&gt;&lt;/strong&gt;，使得仿真变得自动化，推荐的教材是《&lt;a href=&quot;http://www.jb51.net/books/304937.html&quot;&gt;&lt;strong&gt;TCL/TK入门经典&lt;/strong&gt;&lt;/a&gt;》。你可能会手动备份代码，但是专业人士都是用版本控制器&lt;strong&gt;&lt;a href=&quot;https://www.runoob.com/git/git-tutorial.html&quot;&gt;Git&lt;/a&gt;&lt;/strong&gt;的，可以提高工作效率。文件比较器&lt;a href=&quot;http://www.beyondcompare.cc/xiazai.html&quot;&gt;&lt;strong&gt;Beyond Compare&lt;/strong&gt;&lt;/a&gt;也是个比较常用的工具，Git也有比较功能。此外，你也可以使用&lt;a href=&quot;http://bbs.eetop.cn/thread-387263-1-4.html&quot;&gt;&lt;strong&gt;System Verilog&lt;/strong&gt;&lt;/a&gt;来替代testbench，这样效率会更高一些。如果你是做IC验证的，就必须掌握System Verilog和验证方法学（UVM）。推荐的教材是《&lt;a href=&quot;http://bbs.eetop.cn/thread-587167-1-1.html&quot;&gt;&lt;strong&gt;Writing Testbenches using SystemVerilog&lt;/strong&gt;&lt;/a&gt;》、《&lt;a href=&quot;http://bbs.eetop.cn/thread-479340-1-1.html&quot;&gt;&lt;strong&gt;The UVM Primer&lt;/strong&gt;&lt;/a&gt;》、《&lt;a href=&quot;http://bbs.eetop.cn/thread-387263-1-1.html&quot;&gt;&lt;strong&gt;System Verilog1800-2012语法手册&lt;/strong&gt;&lt;/a&gt;》。&lt;/p&gt;



&lt;p&gt;         掌握了TCL/TK之后，可以学习&lt;a href=&quot;http://blog.csdn.net/k331922164/article/details/52093292&quot;&gt;&lt;strong&gt;虚拟Jtag&lt;/strong&gt;&lt;/a&gt;（ISE也有类似的工具）制作属于自己的调试工具，此外，有时间的话，最好再学个python。脚本，意味着一劳永逸。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;五、增强理论基础。&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;        这个时候，你已经会使用FPGA了，但是还有很多事情做不了（比如，FIR滤波器、&lt;a href=&quot;http://blog.csdn.net/k331922164/article/details/51146507&quot;&gt;&lt;strong&gt;PID算法&lt;/strong&gt;&lt;/a&gt;、OFDM等），因为理论没学好。我大概地分几个方向供大家参考，后面跟的是要掌握的理论课。&lt;/p&gt;



&lt;p&gt;1、信号处理——&lt;strong&gt;&lt;a href=&quot;https://blog.csdn.net/k331922164/article/details/55006763&quot;&gt;信号与系统&lt;/a&gt;&lt;/strong&gt;、数字信号处理、数字图像处理、现代数字信号处理、盲信号处理、自适应滤波器原理、雷达信号处理&lt;/p&gt;



&lt;p&gt;2、接口应用——如：&lt;a href=&quot;http://blog.csdn.net/k331922164/article/details/51429544&quot;&gt;&lt;strong&gt;UART&lt;/strong&gt;&lt;/a&gt;、&lt;strong&gt;&lt;a href=&quot;https://wenku.baidu.com/view/1d162f7187c24028915fc3da.html?from=search&quot;&gt;SPI&lt;/a&gt;&lt;/strong&gt;、&lt;a href=&quot;https://wenku.baidu.com/view/8f9df95f804d2b160b4ec0b3.html?from=search&quot;&gt;&lt;strong&gt;IIC&lt;/strong&gt;&lt;/a&gt;、&lt;a href=&quot;http://blog.csdn.net/k331922164/article/details/53349360&quot;&gt;&lt;strong&gt;USB&lt;/strong&gt;&lt;/a&gt;、&lt;a href=&quot;https://wenku.baidu.com/view/f6cf8081d4d8d15abe234ecb.html&quot;&gt;&lt;strong&gt;CAN&lt;/strong&gt;&lt;/a&gt;、&lt;a href=&quot;http://bbs.eetop.cn/thread-600329-1-1.html&quot;&gt;&lt;strong&gt;PCIE&lt;/strong&gt;&lt;/a&gt;、&lt;a href=&quot;http://www.rapidio.org/&quot;&gt;&lt;strong&gt;Rapid IO&lt;/strong&gt;&lt;/a&gt;、&lt;a href=&quot;https://wenku.baidu.com/view/c1609388d4d8d15abe234e6f.html&quot;&gt;&lt;strong&gt;DDR&lt;/strong&gt;&lt;/a&gt;、&lt;a href=&quot;http://www.jb51.net/books/66960.html&quot;&gt;&lt;strong&gt;TCP/IP&lt;/strong&gt;&lt;/a&gt;、&lt;strong&gt;&lt;a href=&quot;https://wenku.baidu.com/view/8093e3edf8c75fbfc77db296.html&quot;&gt;SPI4.2&lt;/a&gt;&lt;/strong&gt;(10G以太网接口)、&lt;a href=&quot;http://bbs.eetop.cn/thread-594135-1-1.html&quot;&gt;&lt;strong&gt;SATA&lt;/strong&gt;&lt;/a&gt;、光纤、&lt;strong&gt;&lt;a href=&quot;http://bbs.eetop.cn/thread-315534-1-1.html&quot;&gt;DisplayPort&lt;/a&gt;&lt;/strong&gt;、HDMI&lt;/p&gt;



&lt;p&gt;3、无线通信——信号与系统、数字信号处理、通信原理、移动通信基础、随机过程、信息论与编码&lt;/p&gt;



&lt;p&gt;4、CPU设计——计算机组成原理、&lt;strong&gt;&lt;a href=&quot;http://blog.csdn.net/k331922164/article/details/44681093&quot;&gt;单片机&lt;/a&gt;&lt;/strong&gt;、计算机体系结构、编译原理、&lt;strong&gt;&lt;a href=&quot;https://riscv.org/risc-v-cores/&quot;&gt;RISC-V&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;5、仪器仪表——模拟电子技术、高频电子线路、电子测量技术、智能仪器原理及应用&lt;/p&gt;



&lt;p&gt;6、控制系统——自动控制原理、现代控制理论、过程控制工程、模糊控制器理论与应用&lt;/p&gt;



&lt;p&gt;7、压缩、编码、加密——数论、抽象代数、现代编码技术、信息论与编码、数据压缩导论、应用密码学、音频信息处理技术、数字视频编码技术原理&lt;/p&gt;



&lt;p&gt;       现在你发现，原来FPGA会涉及到那么多知识，你可以选一个感兴趣的方向，但是工作中很有可能用到其中几个方向的知识，所以理论还是学得越多越好。如果你要更上一层，数学和英语是不可避免的。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;六、学会使用MATLAB仿真。&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;        设计FPGA算法的时候，多多少少都会用到MATLAB，比如&lt;a href=&quot;http://blog.csdn.net/k331922164/article/details/51648707&quot;&gt;&lt;strong&gt;CRC&lt;/strong&gt;&lt;/a&gt;的系数矩阵、数字滤波器系数、各种表格和文本处理等。此外，MATLAB还能用于调试HDL（用MATLAB的计算结果跟用HDL算出来的一步步对照，可以知道哪里出问题）。推荐的教材是《&lt;a href=&quot;http://www.jb51.net/books/104042.html&quot;&gt;&lt;strong&gt;MATLAB宝典&lt;/strong&gt;&lt;/a&gt;》和杜勇的《&lt;a href=&quot;http://search.dangdang.com/?key=%CA%FD%D7%D6%C2%CB%B2%A8%C6%F7%B5%C4MATLAB%D3%EBFPGA%CA%B5%CF%D6&amp;amp;act=input&quot;&gt;&lt;strong&gt;数字滤波器的MATLAB与FPGA实现&lt;/strong&gt;&lt;/a&gt;》。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;七、足量的实践。&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;       这个时候你至少读过几遍芯片手册（&lt;strong&gt;&lt;a href=&quot;https://www.altera.com/support/literature/lit-index.html&quot;&gt;官网&lt;/a&gt;&lt;/strong&gt;有），然后可以针对自己的方向，做一定量的实践了（期间要保持良好的&lt;a href=&quot;http://blog.csdn.net/k331922164/article/details/52166038&quot;&gt;&lt;strong&gt;代码风格&lt;/strong&gt;&lt;/a&gt;，&lt;a href=&quot;http://blog.csdn.net/k331922164?viewmode=list&quot;&gt;&lt;strong&gt;增加元件例化语句的可读性&lt;/strong&gt;&lt;/a&gt;，绘制&lt;a href=&quot;http://blog.csdn.net/k331922164/article/details/50541541&quot;&gt;&lt;strong&gt;流程图/时序图&lt;/strong&gt;&lt;/a&gt;，&lt;a href=&quot;http://blog.csdn.net/k331922164/article/details/50539863&quot;&gt;&lt;strong&gt;撰写文档&lt;/strong&gt;&lt;/a&gt;的习惯）。比如：通信类的可以做调制解调算法，仪表类的可以做总线分析仪等等。不过这些算法，在书上只是给了个公式、框图而已，跟实际的差距很大，你甚至会觉得书上的东西都很肤浅。那么，你可以在&lt;a href=&quot;http://www.cnki.net/&quot;&gt;&lt;strong&gt;知网&lt;/strong&gt;&lt;/a&gt;、&lt;strong&gt;&lt;a href=&quot;http://wenku.baidu.com/&quot;&gt;百度文库&lt;/a&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;a href=&quot;http://bbs.eetop.cn/&quot;&gt;EETOP论坛&lt;/a&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;a href=&quot;http://opencores.org/projects&quot;&gt;opencores&lt;/a&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;a href=&quot;http://blog.chinaaet.com/&quot;&gt;ChinaAET&lt;/a&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;a href=&quot;http://tool.yovisun.com/scihub/&quot;&gt;SCI-HUB&lt;/a&gt;&lt;/strong&gt;、Q群共享、博客上面找些相关资料（校外的朋友可以在淘宝买个知网账号）。其实，当你到了这个阶段，你已经达到了职业级水平，有空就多了解一些前沿技术，这将有助于你的职业规划。&lt;/p&gt;



&lt;p&gt;        在工作当中，或许你需要关注很多协议和行业标准，协议可以在EETOP上面找到，而标准（如：国家标准GB和GB/T，国际标准ISO）就推荐《&lt;a href=&quot;http://www.biaozhuns.com/&quot;&gt;&lt;strong&gt;标准网&lt;/strong&gt;&lt;/a&gt;》和《&lt;a href=&quot;http://www.bzfxw.com/&quot;&gt;&lt;strong&gt;标准分享网&lt;/strong&gt;&lt;/a&gt;》。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;八、图像处理。&lt;/strong&gt;（这部分只写给想学图像处理的朋友，也是由浅入深的路线）&lt;/p&gt;



&lt;p&gt;1、Photoshop。花一、两周的时间学习PS，对图像处理有个大概的了解，知道各种图片格式、直方图、色相、通道、滤镜、拼接等基本概念，并能使用它。这部分是0基础，目的让大家对图像处理有个感性的认识，而不是一上来就各种各样的公式推导。推荐《&lt;strong&gt;&lt;a href=&quot;http://www.jb51.net/books/100972.html&quot;&gt;Photoshop CS6完全自学教程&lt;/a&gt;&lt;/strong&gt;》。&lt;/p&gt;



&lt;p&gt;2、基于MATLAB或OpenCV的图像处理。有C/C++基础的可以学习OpenCV，否则的话，建议学MATLAB。这个阶段下，只要学会简单的调用函数即可，暂时不用深究实现的细节。推荐《&lt;strong&gt;&lt;a href=&quot;http://bbs.eetop.cn/thread-305112-1-1.html&quot;&gt;数字图像处理matlab版&lt;/a&gt;&lt;/strong&gt;》、《&lt;strong&gt;&lt;a href=&quot;http://www.jb51.net/books/86684.html&quot;&gt;学习OpenCV&lt;/a&gt;&lt;/strong&gt;》。&lt;/p&gt;



&lt;p&gt;3、图像处理的基础理论。这部分的理论是需要高数、复变、线性代数、信号与系统、数字信号处理等基础，基础不好的话，建议先补补基础再来。看不懂的理论也可以暂时先放下，或许学到后面就自然而然地开窍了。推荐《&lt;strong&gt;&lt;a href=&quot;http://bbs.eetop.cn/thread-252932-1-1.html&quot;&gt;数字图像处理&lt;/a&gt;&lt;/strong&gt;》。&lt;/p&gt;



&lt;p&gt;4、基于FPGA的图像处理。把前面学到的理论运用到FPGA上面，如果这时你有前面第七个阶段的水平，你将轻松地独立完成图像算法设计（图像处理是离不开接口的，上面第五个阶段有讲）。推荐《&lt;strong&gt;&lt;a href=&quot;https://www.amazon.cn/dp/B00BPXFUVK/ref=wl_it_dp_o_pd_nS_ttl?_encoding=UTF8&amp;amp;colid=1KD25DEC6Q598&amp;amp;coliid=I1BCWMH1TX87Q5&quot;&gt;基于FPGA的嵌入式图像处理系统设计&lt;/a&gt;&lt;/strong&gt;》、《&lt;a href=&quot;http://product.dangdang.com/24171633.html#preface&quot;&gt;&lt;strong&gt;基于FPGA的数字图像处理原理及应用&lt;/strong&gt;&lt;/a&gt;》。&lt;/p&gt;



&lt;p&gt;5、进一步钻研数学。要在算法上更上一层，必然需要更多的数学，所以这里建议学习&lt;a href=&quot;http://blog.csdn.net/k331922164/article/details/52842206&quot;&gt;&lt;strong&gt;实分析&lt;/strong&gt;&lt;/a&gt;、&lt;strong&gt;&lt;a href=&quot;http://wenku.baidu.com/link?url=Fk0k8pCAe8PlvAk35gVwQgYUbMaQ8FILvJXINDJA-1jyB1bDaMvRi-D-e3zl4-CUdHwdpEqasojlnPeA2_cW5UbbF1l0Ig2OM1bTd_6pn_q&quot;&gt;泛涵分析&lt;/a&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;a href=&quot;http://wenku.baidu.com/link?url=sIxDcV7Aju1bNj0eqZj1-1zJrs0P1ZCg558bXfyO5NDNo6oRWz5QHl3fcAoe41yxi_oH9k0DuPy_7qznsF7QLEMNUh8ELJR-cFuzpZavrve&quot;&gt;小波分析&lt;/a&gt;&lt;/strong&gt;等。&lt;/p&gt;



&lt;p&gt;下面这两个阶段是给感兴趣的朋友介绍的。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;九、数电的尽头是模电。&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;       现在FPGA内部的事情是难不到你的，但是信号出了FPGA，你就没法控制了。这个时候必须学好模电。比如：电路分析、模拟电子技术、高频电子线路、PCB设计、EMC、SI、PI等等，能设计出一块带两片DDR3的FPGA开发板，就算通关了。具体的学习路线可以参考本博客的《&lt;strong&gt;&lt;a href=&quot;http://blog.csdn.net/k331922164/article/details/45102489&quot;&gt;如何学习硬件设计——理论篇&lt;/a&gt;&lt;/strong&gt;》和《&lt;strong&gt;&lt;a href=&quot;http://blog.csdn.net/k331922164/article/details/46844339&quot;&gt;如何学习硬件设计——实践篇&lt;/a&gt;&lt;/strong&gt;》。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;十、学无止境。&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;       能到这个境界，说明你已经很厉害了，但是还有很多东西要学的，因为FPGA常常要跟CPU交互，也就是说你得经常跟软件工程师交流，所以也得懂点软件方面的知识。比如ARM（Xilinx的ZYNQ和Altera的SOC会用到ARM的硬核，请参考本博客的《&lt;strong&gt;&lt;a href=&quot;http://blog.csdn.net/k331922164/article/details/50629131&quot;&gt;如何学习嵌入式软件&lt;/a&gt;&lt;/strong&gt;》）、&lt;strong&gt;&lt;a href=&quot;http://blog.csdn.net/k331922164/article/details/78734859&quot;&gt;DSP&lt;/a&gt;&lt;/strong&gt;、Linux、安卓、上位机（&lt;a href=&quot;http://blog.csdn.net/k331922164/article/details/52729675&quot;&gt;&lt;strong&gt;QT&lt;/strong&gt;&lt;/a&gt;、C#、JAVA）都可以学一下，反正学无止境的。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;十一、其它问题。&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;a、为什么不推荐学习NIOS II和MicroBlaze等软核？&lt;/p&gt;



&lt;p&gt;      1、性价比不高，一般的软核性能大概跟Cortex M3或M4差不多，用FPGA那么贵的东西去做一个性能一般的CPU，在工程上是非常不划算的。不如另外加一块M3。&lt;/p&gt;



&lt;p&gt;      2、加上软核，可能会影响到其它的逻辑的功能。这是在资源并不十分充足的情况下，再加上软核，导致布局布线变得相当困难。&lt;/p&gt;



&lt;p&gt;      3、软核不开源，出现Bug的时候，不容易调试。&lt;/p&gt;



&lt;p&gt;      4、工程上很少使用，极有可能派不上用场。&lt;/p&gt;



&lt;p&gt;b、为什么不推荐0基础学习ZYNQ或SOC？&lt;/p&gt;



&lt;p&gt;      1、容易让人有傍同心理。傍同心理是指一个人通过渲染与自己有亲近关系的人的杰出，来掩盖和弥补自己在这方面的不足，从而获得心理上的平衡。自己在学习很厉害的东西，然后也感觉自己很厉害，但这只是错觉而已。&lt;/p&gt;



&lt;p&gt;      2、入门应该学习尽量简单的东西，要么专心学习ARM，要么专心学习FPGA。这样更容易有成就感，增强信心。&lt;/p&gt;



&lt;p&gt;      3、ZYNQ和SOC的应用领域并不广，还有很多人没听过这种东西，导致求职的不利。&lt;/p&gt;



&lt;p&gt;      4、开发工具编译时间长，浪费较多时间。&lt;/p&gt;



&lt;p&gt;      5、绝大多数工作，都只是负责一方面，也就是说另一方面，很有可能派不上用场。&lt;/p&gt;



&lt;p&gt;c、为什么已经存在那么多IP核，仍然需要写HDL？&lt;/p&gt;



&lt;p&gt;      1、问这种问题的，一般是学生，他们没有做过产品，没有遇到过工程上的问题。&lt;/p&gt;



&lt;p&gt;      2、IP核并非万能，不能满足所有需求。&lt;/p&gt;



&lt;p&gt;      3、尽量少用闭源IP核，一旦出问题，这种黑匣子很可能让产品难产。&lt;/p&gt;



&lt;p&gt;      4、深入理解底一层次，可以更好地使用高一层次。该法则可以适用于所有编程语言。&lt;/p&gt;



&lt;p&gt;d、推荐一些微电子的教学视频。&lt;/p&gt;



&lt;p&gt;      可以参考本博客的《&lt;strong&gt;&lt;a href=&quot;https://blog.csdn.net/k331922164/article/details/85047746&quot;&gt;微电子教学视频–Silicon Run等&lt;/a&gt;&lt;/strong&gt;》。&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;https://www.captainbed.net/lhyd&quot;&gt;点这里可以跳转到人工智能网站&lt;/a&gt;&lt;/p&gt;
&amp;#13;
&lt;/div&gt;&amp;#13;
&amp;#13;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>