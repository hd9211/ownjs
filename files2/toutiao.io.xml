<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>c754b5e331946e9eced256584b3ac950</guid>
<title>推荐 7 个牛哄哄 Spring Cloud 实战项目</title>
<link>https://toutiao.io/k/016vv4f</link>
<content:encoded>&lt;div&gt;&lt;div&gt;

                

                
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>81a426122bacfc3c908f02b1c37a1ad7</guid>
<title>字节跳动前端日常实习一二三面面经（Offer 还愿）</title>
<link>https://toutiao.io/k/lu4qgp2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-topic-des nc-post-content&quot;&gt;
&lt;h1&gt; 时间线 &lt;/h1&gt; 
&lt;p&gt;
  5.19投递简历 
&lt;/p&gt; 
&lt;p&gt;
  5.20hr约一面 
&lt;/p&gt; 
&lt;p&gt;
  5.24一面 
&lt;/p&gt; 
&lt;p&gt;
  5.25中午一面通过，hr约二面时间。本来约的是6月1号，但面试官临时请假，改到了3号 
&lt;/p&gt; 
&lt;p&gt;
  6.3二面 
&lt;/p&gt; 
&lt;p&gt;
  6.4下午二面通过，hr约三面时间 
&lt;/p&gt; 
&lt;p&gt;
  6.8三面 
&lt;/p&gt; 
&lt;p&gt;
  6.9中午三面通过，hr约10号三面 
&lt;/p&gt; 
&lt;p&gt;
  有些问题可能不是面试官的本意，还有一些问题没听懂，从场景题提取问题出来还是挺难的 
&lt;/p&gt; 
&lt;div&gt;
 &lt;span&gt; 其实15号中午的时候就offer了，现在来添加&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%9D%A2%E7%BB%8F&quot; target=&quot;_blank&quot;&gt;面经&lt;/a&gt;答案，答案只是我的见解哈，有些部分也没给出来，如果有错误欢迎指出 &lt;/span&gt;
&lt;/div&gt; 
 
&lt;h1&gt; &lt;span&gt;&lt;span&gt;一面（&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%89%9B%E5%AE%A2&quot; target=&quot;_blank&quot;&gt;牛客&lt;/a&gt;50mins）&lt;/span&gt;&lt;/span&gt; &lt;/h1&gt; 
&lt;div&gt; 
 &lt;span&gt; 
  &lt;ol&gt; 
   &lt;li&gt; &lt;p&gt; &lt;span&gt;怎么判断两个网站是否同域&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;浏览器从一个域向另一个域的服务器发送请求来访问其资源。 浏览器的同源策略：协议、域名、端口号一致。&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;保持登录状态能够使用什么实现&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;cookie,token&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;externals是怎么实现的&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span/&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;你这些外部的资源是存在公共的CDN上，还是有现成可以直接用的托管CDN&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;回答了公共的CDN&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;是哪种类型的CDN呢，具体是哪些域名&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;为什么CDN能够加速用户访问一个网站，它的原理是什么&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;最简单的CDN网络由一个DNS服务器和几台缓存服务器组成：&lt;/span&gt; &lt;/p&gt; 
     &lt;ol&gt; 
      &lt;li&gt; &lt;p&gt; &lt;span&gt;当用户点击网站页面上的内容URL，经过本地DNS系统解析，DNS系统会最终将域名的解析权交给CNAME指向的CDN专用DNS服务器。&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
      &lt;li&gt; &lt;p&gt; &lt;span&gt;CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回给用户&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
      &lt;li&gt; &lt;p&gt; &lt;span&gt;用户向CDN的全局负载均衡设备发起内容URL访问请求&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
      &lt;li&gt; &lt;p&gt; &lt;span&gt;CDN全局负载均衡设备根据用户IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
      &lt;li&gt; &lt;p&gt; &lt;span&gt;区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：根据用户IP地址，判断哪一台服务器距用户最近；根据用户所请求的URL中携带的内容名称，判断哪一台服务器上有用户所需内容；查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。基于以上这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
      &lt;li&gt; &lt;p&gt; &lt;span&gt;全局负载均衡设备把服务器的IP地址返回给用户&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
      &lt;li&gt; &lt;p&gt; &lt;span&gt;用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
     &lt;/ol&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;怎么确定哪个CDN节点离用户最近呢&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;上个问题答案的第4.5点&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;假设同样的资源，我用域名去访问，访问到哪个服务器取决于什么？&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;DNS &lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;DNS解析过程&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/yanshuanche3765/article/details/82589210&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;参考文章&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;简单的来说，浏览器先检查自身有没有缓存，如果没有就检查操作系统有没有缓存，如果还是没有就会向本地域名服务器发起一个请求来解析这个域名；如果本地域名服务器还是没有，则会从根域名服务器开始递归查找域名，直到找到为止。&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;DNS解析过程中，某个DNS服务器的记录被篡改过，指向一个恶意网站，这种情况会对用户的访问造成安全风险，这么防范。怎么防范DNS污染（应该是这个问题）&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;感觉这个问题不是很重要&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;DNS使用什么网络协议&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_41563161/article/details/106069473?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&amp;amp;spm=1001.2101.3001.4242&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;参考文章&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;&lt;strong&gt;DNS区域传输的时候使用TCP协议：&lt;/strong&gt;&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;1.辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;2.TCP是一种可靠连接，保证了数据的准确性。&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;&lt;strong&gt;域名解析时使用UDP协议：&lt;/strong&gt;&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;除了打包体积减小，还有哪些手段可以提升用户的访问速度&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;缓存，懒加载，代码优化，SSR...&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;HTTP缓存怎么设置&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/jiang_yonghui/article/details/100569565&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;参考这个&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;通过设置Cache-Control/Pragma、Expires(过期时间)、Last-Modified/Etag。&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;确定协商缓存有效性的协商过程是怎么样的&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;在第一次请求服务器时，服务器会返回资源，并且返回一个资源的缓存标识，一起存到浏览器的缓存数据库。当第二次请求资源时，浏览器会首先将缓存标识发送给服务器，服务器拿到标识后判断标识是否匹配，如果不匹配，表示资源有更新，服务器会将新数据和新的缓存标识一起返回到浏览器；如果缓存标识匹配，表示资源没有更新，并且返回 &lt;/span&gt;&lt;span&gt;304&lt;/span&gt;&lt;span&gt; 状态码，浏览器就读取本地缓存服务器中的数据。&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;有些资源打开页面的时候不需要，需要的时候在加载&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/bury_/article/details/79516223&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;懒加载原理&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;懒加载&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;不同类型的东西处理方式不一样，例如图片，js代码，他们分别怎么懒加载&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;js通过设置defer和async&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;建议图片懒加载多去看看实现方法&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/w1418899532/article/details/90515969?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-4.control&amp;amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-4.control&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;图片懒加载&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;有没有更简单的方式去判断图片离浏览器顶部距离的方法&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;阮一峰老师的文章&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;面试官建议：intersectionObserver?这个API，可以监控一个元素即将进入到窗口的范围&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;说一下Vue的工作原理（响应式原理）&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;Vue响应式底层实现方法是 Object.defineProperty() 方法，该方法中存在一个getter和setter的可选项，可以对属性值的获取和设置造成影响&lt;/span&gt; &lt;/p&gt; 
     &lt;ul&gt; 
      &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;当你把一个普通的 &lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=JavaScript&quot; target=&quot;_blank&quot;&gt;JavaScript&lt;/a&gt; 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的 property，并使用 Object.defineProperty 把这些 property 全部转为 getter/setter。&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
      &lt;li&gt; &lt;p&gt; &lt;span&gt;这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
      &lt;li&gt; &lt;p&gt; &lt;span&gt;每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
     &lt;/ul&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;我改变了一个Data中数据后，他怎么更新到实际页面的DOM，这个过程是怎样的&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;模板里面，对于一个字段的引用是怎么收集的&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;对于这个字段的依赖是在什么时候建立的呢，是怎么建立的呢&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;假设有A，B两个请求，希望在A请求完后拿到一个结果，之后将A的结果作为参数给B，B发起请求，这样的过程要怎么实现&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;异步操作&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;如果A，B没有依赖关系，希望两个都拿到结果之后，在执行一些操作，要怎么实现&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;Promise.all&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;你提到Promise.all，那假设浏览器没有这个东西，你给我整一个&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;div&gt; 
      &lt;span&gt;接下来是20分钟的修改代码过程...&lt;/span&gt;
      &lt;span&gt; &lt;pre class=&quot;prettyprint lang-js&quot; from-niu=&quot;default&quot;&gt;function myPromiseAll(promises) {
  let results = [];
  let promiseCount = 0;
  let promisesLength = promises.length;
  return new Promise(function(resolve, reject) {
    for(let i = 0; i &amp;lt; promises.length; i++){
      Promise.resolve(promises[i]).then(function(res) {
        promiseCount++;
        results[i] = res;
        // 当所有函数都正确执行了，resolve输出所有返回结果。
        if (promiseCount === promisesLength) {
          return resolve(results);
        }
      }, function(err) {
        return reject(err);
      });
    }
  });
};
&lt;/pre&gt; &lt;br/&gt; &lt;span/&gt;&lt;/span&gt; 
     &lt;/div&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;反问&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;部门：交叉面试&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;建议：多实践&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
  &lt;/ol&gt; &lt;br/&gt; &lt;/span&gt; 
&lt;/div&gt; 
&lt;h1&gt; &lt;span&gt;&lt;span&gt;二面（&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%89%9B%E5%AE%A2&quot; target=&quot;_blank&quot;&gt;牛客&lt;/a&gt;38mins）&lt;/span&gt;&lt;/span&gt; &lt;/h1&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;简单问了下&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;的东西&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
 &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;里有订单管理的功能，一般来说订单要考虑什么状态呢&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
 &lt;li&gt; &lt;p&gt; &lt;span&gt;如何实时拿到这些状态呢&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
 &lt;li&gt; &lt;p&gt; &lt;span&gt;最近在学什么呢&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
 &lt;li&gt; &lt;span&gt; &lt;p&gt; &lt;span&gt;vue框架有什么特点&lt;/span&gt; &lt;/p&gt; 
   &lt;blockquote&gt; 
    &lt;p&gt; &lt;span&gt;数据驱动、组件化&lt;/span&gt; &lt;/p&gt; 
   &lt;/blockquote&gt; &lt;/span&gt; &lt;/li&gt;
 &lt;li&gt; &lt;p&gt; &lt;span&gt;手撕代码（写完说思路&lt;/span&gt; &lt;/p&gt; 
  &lt;blockquote&gt; 
   &lt;div&gt; 
    &lt;span&gt;&lt;span&gt;冒泡，快速&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt; &lt;/span&gt;&lt;pre class=&quot;prettyprint lang-js&quot; from-niu=&quot;default&quot;&gt;function bubbleSort(array){
    let length = array.length;
    for(let i = 0; i &amp;lt; length - 1; i++){
        for(let j = 0; j &amp;lt; length - i -1; j++){
            if(array[j] &amp;lt; array[j+1]){
                [array[j],array[j+1]] = [array[j+1],array[j]];
            }
        }
    }
}

let test = [6,8,4,5,1];
bubbleSort(test);
console.log(test);

function quickSort(array){
    if(array.length &amp;lt; 2) return array;
    let leftArray = [];
    let rightArray = [];
    let base = array[0];
    array.forEach((element) =&amp;gt; {
        if(element &amp;gt; base){
            leftArray.push(element);
        } else if(element &amp;lt; base){
            rightArray.push(element);
        }
    });
    return quickSort(leftArray).concat(base,quickSort(rightArray));
};

let test2 = [5,3,2,1,4];
let res = quickSort(test2);

console.log(res);&lt;/pre&gt; &lt;br/&gt; &lt;span/&gt;&lt;/span&gt; 
   &lt;/div&gt; 
  &lt;/blockquote&gt; 
  &lt;blockquote&gt; 
   &lt;p&gt; &lt;span&gt;实现一个函数，把一个字符串数组（[&#x27;zm&#x27;, &#x27;za&#x27;, &#x27;b&#x27;, &#x27;lm&#x27;, &#x27;ln&#x27;, &#x27;k&#x27;]）格式化成一个对象 { &#x27;b&#x27;: [&#x27;b&#x27;], &#x27;k&#x27;: [&#x27;k&#x27;], &#x27;l&#x27;: [&#x27;lm&#x27;, &#x27;ln&#x27;], &#x27;z&#x27;: [&#x27;za&#x27;, &#x27;zm&#x27;] }&lt;/span&gt; &lt;/p&gt; 
  &lt;/blockquote&gt; &lt;p&gt; &lt;span&gt;这道题没写完整，说了下思路用伪代码写了下。&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
 &lt;li&gt; &lt;p&gt; &lt;span&gt;近一两年的规划&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
 &lt;li&gt; &lt;p&gt; &lt;span&gt;为什么选择字节&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt; &lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
&lt;/ol&gt; 
&lt;h1&gt; &lt;span&gt;&lt;span&gt;三面6.8（&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%89%9B%E5%AE%A2&quot; target=&quot;_blank&quot;&gt;牛客&lt;/a&gt;38mins）&lt;/span&gt;&lt;span/&gt;&lt;/span&gt; &lt;/h1&gt; 
&lt;div&gt; 
 &lt;span&gt; 
  &lt;ol&gt; 
   &lt;li&gt; &lt;p&gt; &lt;span&gt;聊了下之前的笔试&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;参与之前的面试下来，有什么感受，有没有总结出自己的长处与短板&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;&lt;span&gt;提到了要深入学原理&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%BA%90%E7%A0%81&quot; target=&quot;_blank&quot;&gt;源码&lt;/a&gt;啥的&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;你打算怎么看&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%BA%90%E7%A0%81&quot; target=&quot;_blank&quot;&gt;源码&lt;/a&gt;&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;聊一下&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;为什么做这个&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;有没有你自己想的一些功能&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;怎样从零搭建&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/baidu_41690072/article/details/88820400&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;感觉就是看你是不是真的自己做了一遍&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;使用vue-cli初始化的步骤&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;vue-cli主要帮你完成了哪些事情&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;1.ES6代码转换成ES5代码 2. scss/sass/less/stylus转css 3. .vue文件转换成js文件 4. 使用 jpg、png，font等资源文件 4. 自动添加css各浏览器产商的前缀 5. 代码热更新 6. 资源预加载 7. 每次构建代码清除之前生成的代码 8. 定义环境变量 9. 区分开发环境打包跟生产环境打包 ......&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;其中生成的那些文件，分别是干什么的&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;packjson文件里有一些key，value。其中一个key叫dependencies和devDependencies，能说说作用吗&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;package.json:&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;&lt;span&gt;主要用来定义&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;中需要依赖的包&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;package-lock.json：&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;在 &lt;/span&gt;&lt;span&gt;npm install&lt;/span&gt;&lt;span&gt;时候生成一份文件，用以记录当前状态下实际安装的各个npm package的具体来源和版本号。&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;&#x27;^&#x27; :&lt;/span&gt;放在版本号之前，表示向后兼容依赖，说白了就是在大版本号不变的情况下，下载最新版的包 &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;中引入的包版本号之前经常会加^号，每次在执行npm install之后，下载的包都会发生变化，为了系统的稳定性考虑，每次执行完npm install之后会对应生成package-lock文件，该文件记录了上一次安装的具体的版本号，相当于是提供了一个参考，在出现版本兼容性问题的时候，就可以参考这个文件来修改版本号即可。&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; 
    &lt;blockquote&gt; 
     &lt;ol&gt; 
      &lt;li&gt; &lt;p&gt; &lt;span&gt;“dependencies”&lt;/span&gt;&lt;span&gt; 运行依赖，需引入页面使用&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
      &lt;li&gt; &lt;p&gt; &lt;span&gt;“devDependencies”&lt;/span&gt;&lt;span&gt; 开发依赖(生产环境使用)，只是开发阶段需要&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
     &lt;/ol&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;babel.config.js的作用&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;Babel是一个JS编译器，主要作用是将ECMAScript 2015+ 版本的代码，转换为向后兼容的JS语法，以便能够运行在当前和旧版本的浏览器或其它环境中。&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;&lt;span&gt;Vue&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;中普遍使用ES6语法，若要求兼容低版本浏览器，就需要引入Babel，将ES6转换为ES5。&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;babel怎么把es6转成es5&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;es6哪些特性你觉得比较常用或者好用&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;let const var区别&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;&lt;strong&gt;变量提升方面&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：var声明的变量存在变量提升，即变量可以在声明之前调用，值为undefined。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;let和const不存在变量提升问题(&lt;/span&gt;&lt;span&gt;注意这个‘问题’后缀，其实是有提升的，只不过是let和const具有一个暂时性死区的概念，即没有到其赋值时，之前就不能用&lt;/span&gt;&lt;span&gt;)，即它们所声明的变量一定要在声明后使用，否则报错。&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;&lt;strong&gt;块级作用域方面&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：var不存在块级作用域,let和const存在块级作用域&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;&lt;strong&gt;声明方面&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：var允许重复声明变量,let和const在同一作用域不允许重复声明变量。其中const声明一个只读的常量(因为如此，其声明时就一定要赋值，不然报错)。一旦声明，常量的值就不能改变。&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;回到&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;，登录功能怎么实现的&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;token怎么保持登录状态&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/u014322206/article/details/85089481&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;&lt;span&gt;当用户请求页面，输入用户信息，服务端经过验证后，会生成一个token安全令牌（随机字符串），并返回给&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;，当&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;发送下一次请求的时候，直接携带这个token，服务端识别后，就可以直接访问页面，不需要再次登录了&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;sessionStorage有什么优势，token应该放在哪&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/fejerry/p/10898530.html&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;sessionStorage的特点&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;+各个标签页的sessionStorage 是独立的 。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;+在a标签页写入修改删除sessionStorage ，不会影响到已经打开的标签页中的sessionStorage 。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;+通过a标签，window.open,window.location,windows.history ，右键复制 等方式在新标签页，本页，iframe ，新窗口中打开新页面，当前标签页的 sessionStorage 会传递到新页面。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;+通过按住 ctrl键打开新标签页，或者右键菜单打开新标签页，新窗口 ，当前标签页的 sessionStorage 是不会传递到新页面的 。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;+关闭某个标签页，该标签页的sessionStorage 会被销毁。不影响其他标签页或者窗口 。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;+在某个标签页即使跳出了当前站点，返回来的时候，sessionStorage 也还在的 。&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;鉴于它有以上特点 ：&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;1，可以用来做多账户登录 ， sessionid 不用cookie存储，用 sessionStorage 来存储。spa应用比较适合 。&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;p&gt; &lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/qq_43618136/article/details/114656505&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;token存放位置参考&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;Cookie 的作用是与服务器进行交互，作为 HTTP 规范的一部分而存在 ，而 Web Storage 仅仅是为了在本地“存储”数据而生。而token的安全和性能都是中肯的，唯一的问题就是cookie的存储性能和提取安全性太低，而localstorage更安全而且能够跨会话实现身份鉴别，很明显token应该存在localstorage里。&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;localStorage里可以存图片吗，怎么存&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/cockroach02/article/details/49926595&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;参考文章&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;我们的想法是做到将已经当前页面中已缓存的图片保存到本地存储中。不过就像我们之前已经确定的，本地存储只支持字符串的存取，那么我们要做的就是将图片转换成 &lt;/span&gt;&lt;span&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Data_URI_scheme&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;Data URI&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;span&gt; 。其中一种实现方式就是用canvas元素来加载图片。然后你可以以Data URI的形式从canvas中读取出当前展示的内容。&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;token能放在cookie里吗&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;可以&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;xss能不能取到sessionStorage里的数据&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;可以&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;hash路由和history路由&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;除了这个&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;还有别的&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;吗&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;翻页功能怎么实现&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;数据是&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%89%8D%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;前端&lt;/a&gt;来分页还是后端来分页&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;能实现&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%89%8D%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;前端&lt;/a&gt;分页吗&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;怎么实现&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;数据存哪&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;vuex有用过吗&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;vuex的目的是什么&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;已经有sessionStorage这类的放数据的地方，为什么还要有vuex，有什么特别的价值吗&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;聊了下笔试&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;问了下是不是还没有开始复习&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;和数据结构&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;说一个最近在复习的&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;再说说对应的例题&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;说了道最大无重复子串，双指针&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;复杂度&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92&quot; target=&quot;_blank&quot;&gt;动态规划&lt;/a&gt;一般解决什么样类型的问题&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92&quot; target=&quot;_blank&quot;&gt;动态规划&lt;/a&gt;相比于回溯，有什么优势&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;异步组件的懒加载是你自己想的还是教程有的&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;怎么实现懒加载&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;优化效果有看过吗&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;看到面评，问实习是想积累经验还是想转正&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;反问&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;部门：技术中台&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;看重实习生哪些方面&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
  &lt;/ol&gt; &lt;br/&gt; &lt;/span&gt; 
&lt;/div&gt; 
&lt;h1&gt; 碎碎念 &lt;/h1&gt; 
&lt;div&gt;&lt;p&gt;
  字节的面试官是能够看到你之前投递的简历，参加过的笔试和面试结果，所以如果要投的话一定要认真对待面试和笔试吧。
 &lt;/p&gt;&lt;span&gt;&lt;span&gt;另外我看到&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%89%9B%E5%AE%A2&quot; target=&quot;_blank&quot;&gt;牛客&lt;/a&gt;网也有&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%89%8D%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;前端&lt;/a&gt;的课程，笔试面试会涉及到的知识点里边基本都会涵盖，如果大家不知道从哪里开始学起的话可以报名这种课程~&lt;/span&gt;&lt;img data-card-emoji=&quot;[考得全会]&quot; src=&quot;https://uploadfiles.nowcoder.com/images/20191018/63_1571399956257_2484A7DF36877A14689574EEBDA6DD7C&quot;/&gt;&lt;/span&gt; 
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1757b3cc46b3d3b2af00b2772f344ca9</guid>
<title>Java 类加载器：坑爹是我的特色</title>
<link>https://toutiao.io/k/gnxxx4b</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是头发还很多的阿星&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0480769230769231&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzynmJ9bWzU7WbaTHAUb6lKfwPh7MfJsd4ZGiaKxs8KCBnUlaLzoNLgRMzPROpl4HzqDianVCkQulpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;312&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天的主角是「在日常开发中，存在感非常低的&lt;strong&gt;类加载器&lt;/strong&gt;」，众所周知大佬除了头发比较少，还非常低调，如果想和大佬交朋友，那一定要先认识大佬，下面阿星来带大家认识一下&lt;strong&gt;类加载器&lt;/strong&gt;（本文不涉及源码）。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是类加载器&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们平时写了那么多的&lt;code&gt;Java&lt;/code&gt;代码，却不知&lt;code&gt;Java&lt;/code&gt;类的加载过程，岂不是很尴尬，为了打破尴尬，阿星得从&lt;code&gt;Java&lt;/code&gt;类说起。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们编写的&lt;code&gt;Java&lt;/code&gt;类也就是&lt;code&gt;.java&lt;/code&gt;文件，通过&lt;code&gt;Java&lt;/code&gt;编译器编译成&lt;code&gt;.class&lt;/code&gt;文件，&lt;code&gt;.class&lt;/code&gt;文件中保存着&lt;code&gt;Java&lt;/code&gt;代码转换后的虚拟机指令。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7701317715959004&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzynmJ9bWzU7WbaTHAUb6lKhoWWRy3r114ib0lppyMJiaUhMVibeyA00qvb78sYy7o56VOKWwmiaII8Aw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;683&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当程序使用某个&lt;code&gt;Java&lt;/code&gt;类时，&lt;code&gt;JVM&lt;/code&gt;虚拟机会加载它的&lt;code&gt;.class&lt;/code&gt;文件到虚拟机的内存中，负责加载工作的就是&lt;strong&gt;类加载器&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;类加载过程&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实类加载器和日常生活中坐地铁过安检是一样的道理，不信你看下面的图&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.33208676140613314&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzynmJ9bWzU7WbaTHAUb6lKqO7QkKWDkBV72tfLMtwmicd2L8A11EoFrepK2rAqM37Yrnjx3nnnWsw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1337&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安检要经过一系列的检查过程，目的是让进入地铁站的人群符合乘坐标准，比如你不能感冒，不能带威胁人生安全的物品等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样&lt;strong&gt;类加载&lt;/strong&gt;也要经过一系列检查过程，这个过程称为&lt;strong&gt;类加载过程&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类加载过程分为&lt;strong&gt;加载、验证、准备、解析、初始化&lt;/strong&gt;，下图是对&lt;strong&gt;类加载过程&lt;/strong&gt;简单的介绍。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.34366925064599485&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzynmJ9bWzU7WbaTHAUb6lKy9LBicibYXM8STEJQoTJbzLGv2NKyIl592uqC2NKnQfI2vGjxBR41H7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1161&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类加载过程不是本文的重点，如果对这块有兴趣深入研究的伙伴可以去自行百度或google。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面要说说本文的重点，双亲委派模式&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;实力坑爹&lt;/span&gt;&lt;/h1&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0238095238095237&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/23OQmC1ia8nzynmJ9bWzU7WbaTHAUb6lKK0lTx8iaseiaBGGSljqicTxg2Ilcw2yy69W8cX2w3tC8zicz3d3QXQksKw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;252&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双亲委派机制有点像实力坑爹，出了什么事情都让爹去擦屁股，爹解决不了，自己才承担。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;JVM&lt;/code&gt;虚拟机提供了&lt;code&gt;3&lt;/code&gt;种类加载器，它们分别是启动类加载器（&lt;code&gt;Bootstrap&lt;/code&gt;）、扩展类加载器（&lt;code&gt;Extension&lt;/code&gt;）、系统类加载器（&lt;code&gt;System&lt;/code&gt;）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个类加载器都有明确的加载范围：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;启动类加载器（&lt;code&gt;Bootstrap&lt;/code&gt;）：加载&lt;code&gt;&amp;lt;JAVA_HOME&amp;gt;/lib&lt;/code&gt;路径下的核心类库&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;扩展类加载器（&lt;code&gt;Extension&lt;/code&gt;）：加载&lt;code&gt;&amp;lt;JAVA_HOME&amp;gt;/lib/ext&lt;/code&gt;l路径下的&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;系统类加载器（&lt;code&gt;System&lt;/code&gt;）：加载系统类路径&lt;code&gt;classpath&lt;/code&gt;，也就是我们经常用到的&lt;code&gt;classpath&lt;/code&gt;路径，一般情况该类加载器是程序中默认的类加载器&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzynmJ9bWzU7WbaTHAUb6lKSk4JpD8ibwFLC9OAFdwXZFhzqvE9okrsaU1ASJO1uKN1ibSib0pAFibNjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;652&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双亲委派模式的原理也十分简单，类加载器收到类加载请求，会委托给父类加载器去执行，父类加载器还存在其父类加载器，则进一步向上委托，依次递归，直到顶层类加载器，如果顶层类加载器加载到该类，就成功返回&lt;code&gt;class&lt;/code&gt;对象，否则委托给下级类加载器去执行，依次递归（&lt;strong&gt;此处的父子关系并非通常所说的继承关系，而是采用组合关系来实现&lt;/strong&gt;）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9266666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/23OQmC1ia8nzynmJ9bWzU7WbaTHAUb6lKrKvNzRpO9LdkXPKsIbg1vlZXZDDqKY01A57q1ahPtAwHQrxsHYT90A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;300&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用大白话来说就是，每个儿子都很懒，有事就丢给爹去干，直到爹说这件事我也干不了，儿子自己再想办法完成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双亲委派模式是为了避免重复加载和核心类篡改。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;特殊需求&lt;/span&gt;&lt;/h1&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9246376811594202&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/23OQmC1ia8nzynmJ9bWzU7WbaTHAUb6lKqDfmzeNeTDhl4f3N5LD06yKlXdD7YKeazBaK9v6hick53MMqqDOhJlA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;345&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在日常开发中，我们可能会有特殊的业务需求，可能就需要使用到&lt;strong&gt;自定义类加载器&lt;/strong&gt;，该加载器的上级一定是&lt;strong&gt;系统类加载器&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;你们想要的特殊需求&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;资源隔离&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;web&lt;/code&gt;容器可能需要部署两个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，因此要保证每个应用程序的类库都是独立的，相互隔离&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;web&lt;/code&gt;容器有自己依赖的类库，不能与应用程序的类库混淆，基于安全考虑，应该让容器的类库和程序的类库隔离&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;加密保护&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;公司的一些核心类库，可能会把字节码加密，这样加载类的时候就必须对字节码进行解密&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;其他来源加载类&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;类重新加载&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;JVM&lt;/code&gt;中类对象的唯一性：类加载器实例+完整类名&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;程序运行中，类内容发生变化，创建自定义加载器实例重新加载类，达到的热部署效果。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6775&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/23OQmC1ia8nzynmJ9bWzU7WbaTHAUb6lKfJAWTpJjRwzYL58nPnurgUG7KFuRcDsz5K1afdNhye6Xgh0PMp3wLQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;400&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里大家有个概念，理解下就够了，想深入探索就需要涉及源码分析，如果大伙有兴趣，评论区留言，阿星后续单独补一篇源码分析~&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;强大的父亲&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些爹的实力恐怖如斯，为了啥事都能帮后代处理好，直接破坏双亲委派模式，深受孩儿们的喜爱。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7671232876712328&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/23OQmC1ia8nzynmJ9bWzU7WbaTHAUb6lKGrj1sME5fw2kwdPSYLaFhuU8X9N5kmo4lic7YYfQhhF1YlZH7fOqqqA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;292&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Java&lt;/code&gt;应用中存在着很多服务提供者接口（&lt;code&gt;Service Provider Interface，SPI&lt;/code&gt;），这些接口允许第三方为它们提供实现，如常见的&lt;code&gt;SPI&lt;/code&gt;有&lt;code&gt;JDBC、JNDI&lt;/code&gt;等，这些&lt;code&gt;SPI&lt;/code&gt;的接口属于&lt;code&gt;Java&lt;/code&gt;核心库，一般存在&lt;code&gt;rt.jar&lt;/code&gt;包中，由启动类加载器（&lt;code&gt;Bootstrap&lt;/code&gt;）加载，而&lt;code&gt;SPI&lt;/code&gt;的第三方实现代码则是作为&lt;code&gt;Java&lt;/code&gt;应用所依赖的&lt;code&gt;jar&lt;/code&gt;包被存放在&lt;code&gt;classpath&lt;/code&gt;路径下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于&lt;code&gt;SPI&lt;/code&gt;接口中的代码需要加载第三方实现类并调用其相关函数，但&lt;code&gt;SPI&lt;/code&gt;的核心接口类是由启动类加载器（&lt;code&gt;Bootstrap&lt;/code&gt;）加载的，&lt;code&gt;Bootstrap&lt;/code&gt;加载器无法直接加载&lt;code&gt;SPI&lt;/code&gt;的实现类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这种情况下，我们就需要一种特殊的类加载器来加载第三方的类库，它就是线程上下文类加载器，线程的上下文类加载器默认设置的就是系统类加载器（&lt;code&gt;System&lt;/code&gt;）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.549636803874092&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzynmJ9bWzU7WbaTHAUb6lKGNxzlzvtfIhiaCdkbZ3lDz3w2ZTO6URxUr0Nt6t44HGV5GEPnhnQWEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;826&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;后面的计划安排&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给各位读者们汇报下后续的安排，嗯....，不出意外的话，基本都是周更了，然后期间转载一些精品的文章，大伙们看完了，记得一键三连啊，报告完毕！&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;关于我&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里是阿星，一个热爱技术的Java程序猿，公众号  &lt;strong&gt;「程序猿阿星」&lt;/strong&gt; 里将会定期分享操作系统、计算机网络、Java、分布式、数据库等精品原创文章，2021，与您在 Be Better 的路上共同成长！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非常感谢各位小哥哥小姐姐们能看到这里，原创不易，文章有帮助可以关注、点个赞、分享与评论，都是支持（莫要白嫖）！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/23OQmC1ia8nzynmJ9bWzU7WbaTHAUb6lKvVzTH2TeVfISvjO0ULLgUOF7AGSWIbYc6wPURjbHuF2yB5DmRqyo2Q/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;240&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;愿你我都能奔赴在各自想去的路上，我们下篇文章见&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0048991b6334114dddde320226e8ca10</guid>
<title>把 Redis 当作队列来用，真的合适吗？</title>
<link>https://toutiao.io/k/3r6oq79</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;阅读本文大约需要 15 分钟。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我经常听到很多人讨论，关于「把 Redis 当作队列来用是否合适」的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些人表示赞成，他们认为 Redis 很轻量，用作队列很方便。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也些人则反对，认为 Redis 会「丢」数据，最好还是用「专业」的队列中间件更稳妥。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;究竟哪种方案更好呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章，我就和你聊一聊把 Redis 当作队列，究竟是否合适这个问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我会从简单到复杂，一步步带你梳理其中的细节，把这个问题真正的讲清楚。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看完这篇文章后，我希望你对这个问题你会有全新的认识。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在文章的最后，我还会告诉你关于「技术选型」的思路，文章有点长，希望你可以耐心读完。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4188861985472155&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gB9Yvac5K3PnYugKyFT6iaYiaXnHG02HFWmGodwpNsE4KsZ4XLRU2u9AmStUn9AIv3bHiarGSI8JtS2He3Irj5pZg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;826&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从最简单的开始：List 队列&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，我们先从最简单的场景开始讲起。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你的业务需求足够简单，想把 Redis 当作队列来使用，肯定最先想到的就是使用 List 这个数据类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为 List 底层的实现就是一个「链表」，在头部和尾部操作元素，时间复杂度都是 O(1)，这意味着它非常符合消息队列的模型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果把 List 当作队列，你可以这么来用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生产者使用 LPUSH 发布消息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; LPUSH queue msg1&lt;br/&gt;(integer) 1&lt;br/&gt;127.0.0.1:6379&amp;gt; LPUSH queue msg2&lt;br/&gt;(integer) 2&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消费者这一侧，使用 RPOP 拉取消息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; RPOP queue&lt;br/&gt;&quot;msg1&quot;&lt;br/&gt;127.0.0.1:6379&amp;gt; RPOP queue&lt;br/&gt;&quot;msg2&quot;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个模型非常简单，也很容易理解。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.29515418502202645&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3PnYugKyFT6iaYiaXnHG02HFWu8QC6wleS3iaKtD1iaHBCicxiapia7DfYWH1qzum9iaiaaf2MAxoE3dR4xicSA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;681&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这里有个小问题，当队列中已经没有消息了，消费者在执行 RPOP 时，会返回 NULL。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; RPOP queue&lt;br/&gt;(nil)   // 没消息了&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而我们在编写消费者逻辑时，一般是一个「死循环」，这个逻辑需要不断地从队列中拉取消息进行处理，伪代码一般会这么写：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;while&lt;/span&gt; true:&lt;br/&gt;    msg = redis.rpop(&lt;span&gt;&quot;queue&quot;&lt;/span&gt;)&lt;br/&gt;    // 没有消息，继续循环&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; msg == null:&lt;br/&gt;        &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;    // 处理消息&lt;br/&gt;    handle(msg)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果此时队列为空，那消费者依旧会频繁拉取消息，这会造成「CPU 空转」，不仅浪费 CPU 资源，还会对 Redis 造成压力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;怎么解决这个问题呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也很简单，当队列为空时，我们可以「休眠」一会，再去尝试拉取消息。代码可以修改成这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;while&lt;/span&gt; true:&lt;br/&gt;    msg = redis.rpop(&lt;span&gt;&quot;queue&quot;&lt;/span&gt;)&lt;br/&gt;    // 没有消息，休眠&lt;span&gt;2&lt;/span&gt;s&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; msg == null:&lt;br/&gt;        sleep(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;    // 处理消息        &lt;br/&gt;    handle(msg)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就解决了 CPU 空转问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题虽然解决了，但又带来另外一个问题：当消费者在休眠等待时，有新消息来了，那消费者处理新消息就会存在「延迟」。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设设置的休眠时间是 2s，那新消息最多存在 2s 的延迟。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要想缩短这个延迟，只能减小休眠的时间。但休眠时间越小，又有可能引发 CPU 空转问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;鱼和熊掌不可兼得。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那如何做，既能及时处理新消息，还能避免 CPU 空转呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 是否存在这样一种机制：如果队列为空，消费者在拉取消息时就「阻塞等待」，一旦有新消息过来，就通知我的消费者立即处理新消息呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;幸运的是，Redis 确实提供了「阻塞式」拉取消息的命令：BRPOP / BLPOP，这里的 B 指的是阻塞（Block）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.23641703377386197&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3PnYugKyFT6iaYiaXnHG02HFWptBP43IUaOX9WHSibbIDMj4IIntO47FnUOCz94RQl6icCiaXlEaicxq7DQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;681&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在，你可以这样来拉取消息了：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;while&lt;/span&gt; true:&lt;br/&gt;    // 没消息阻塞等待，&lt;span&gt;0&lt;/span&gt;表示不设置超时时间&lt;br/&gt;    msg = redis.brpop(&lt;span&gt;&quot;queue&quot;&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; msg == null:&lt;br/&gt;        &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;    // 处理消息&lt;br/&gt;    handle(msg)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 BRPOP 这种阻塞式方式拉取消息时，还支持传入一个「超时时间」，如果设置为 0，则表示不设置超时，直到有新消息才返回，否则会在指定的超时时间后返回 NULL。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方案不错，既兼顾了效率，还避免了 CPU 空转问题，一举两得。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意：如果设置的超时时间太长，这个连接太久没有活跃过，可能会被 Redis Server 判定为无效连接，之后 Redis Server 会强制把这个客户端踢下线。所以，采用这种方案，客户端要有重连机制。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解决了消息处理不及时的问题，你可以再思考一下，这种队列模型，有什么缺点？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们一起来分析一下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;不支持重复消费&lt;/strong&gt;：消费者拉取消息后，这条消息就从 List 中删除了，无法被其它消费者再次消费，即不支持多个消费者消费同一批数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;消息丢失&lt;/strong&gt;：消费者拉取到消息后，如果发生异常宕机，那这条消息就丢失了&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一个问题是功能上的，使用 List 做消息队列，它仅仅支持最简单的，一组生产者对应一组消费者，不能满足多组生产者和消费者的业务场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二个问题就比较棘手了，因为从 List 中 POP 一条消息出来后，这条消息就会立即从链表中删除了。也就是说，无论消费者是否处理成功，这条消息都没办法再次消费了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也意味着，如果消费者在处理消息时异常宕机，那这条消息就相当于丢失了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对这 2 个问题怎么解决呢？我们一个个来看。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;发布/订阅模型：Pub/Sub&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从名字就能看出来，这个模块是 Redis 专门是针对「发布/订阅」这种队列模型设计的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它正好可以解决前面提到的第一个问题：重复消费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即多组生产者、消费者的场景，我们来看它是如何做的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 提供了 PUBLISH / SUBSCRIBE 命令，来完成发布、订阅的操作。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.40360610263522884&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3PnYugKyFT6iaYiaXnHG02HFWcVxxQr6pxO6UfDwAFgwicPNMFXicEOvBokFAsGbEMXUibzZNUAedQSnow/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;721&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设你想开启 2 个消费者，同时消费同一批数据，就可以按照以下方式来实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，使用 SUBSCRIBE 命令，启动 2 个消费者，并「订阅」同一个队列。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;// 2个消费者 都订阅一个队列&lt;br/&gt;127.0.0.1:6379&amp;gt; SUBSCRIBE queue&lt;br/&gt;Reading messages... (press Ctrl-C to quit)&lt;br/&gt;1) &quot;subscribe&quot;&lt;br/&gt;2) &quot;queue&quot;&lt;br/&gt;3) (integer) 1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，2 个消费者都会被阻塞住，等待新消息的到来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后，再启动一个生产者，发布一条消息。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; PUBLISH queue msg1&lt;br/&gt;(integer) 1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时，2 个消费者就会解除阻塞，收到生产者发来的新消息。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; SUBSCRIBE queue&lt;br/&gt;// 收到新消息&lt;br/&gt;1) &quot;message&quot;&lt;br/&gt;2) &quot;queue&quot;&lt;br/&gt;3) &quot;msg1&quot;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到了么，使用 Pub/Sub 这种方案，既支持阻塞式拉取消息，还很好地满足了多组消费者，消费同一批数据的业务需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，Pub/Sub 还提供了「匹配订阅」模式，允许消费者根据一定规则，订阅「多个」自己感兴趣的队列。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;// 订阅符合规则的队列&lt;br/&gt;127.0.0.1:6379&amp;gt; PSUBSCRIBE queue.*&lt;br/&gt;Reading messages... (press Ctrl-C to quit)&lt;br/&gt;1) &quot;psubscribe&quot;&lt;br/&gt;2) &quot;queue.*&quot;&lt;br/&gt;3) (integer) 1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的消费者，订阅了 queue.* 相关的队列消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后，生产者分别向 queue.p1 和 queue.p2 发布消息。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; PUBLISH queue.p1 msg1&lt;br/&gt;(integer) 1&lt;br/&gt;127.0.0.1:6379&amp;gt; PUBLISH queue.p2 msg2&lt;br/&gt;(integer) 1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时再看消费者，它就可以接收到这 2 个生产者的消息了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; PSUBSCRIBE queue.*&lt;br/&gt;Reading messages... (press Ctrl-C to quit)&lt;br/&gt;...&lt;br/&gt;// 来自queue.p1的消息&lt;br/&gt;1) &quot;pmessage&quot;&lt;br/&gt;2) &quot;queue.*&quot;&lt;br/&gt;3) &quot;queue.p1&quot;&lt;br/&gt;4) &quot;msg1&quot;&lt;br/&gt;&lt;br/&gt;// 来自queue.p2的消息&lt;br/&gt;1) &quot;pmessage&quot;&lt;br/&gt;2) &quot;queue.*&quot;&lt;br/&gt;3) &quot;queue.p2&quot;&lt;br/&gt;4) &quot;msg2&quot;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3792172739541161&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3PnYugKyFT6iaYiaXnHG02HFWEgHBBbv2VxurLPcgDd9CJnzueRPuqLS6hugowGMlKvdzsvoYIDd0ibQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;741&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以看到，Pub/Sub 最大的优势就是，支持多组生产者、消费者处理消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;讲完了它的优点，那它有什么缺点呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，Pub/Sub 最大问题是：&lt;strong&gt;丢数据&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果发生以下场景，就有可能导致数据丢失：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;消费者下线&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Redis 宕机&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息堆积&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;究竟是怎么回事？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这其实与 Pub/Sub 的实现方式有很大关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pub/Sub 在实现时非常简单，它没有基于任何数据类型，也没有做任何的数据存储，它只是单纯地为生产者、消费者建立「数据转发通道」，把符合规则的数据，从一端转发到另一端。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个完整的发布、订阅消息处理流程是这样的：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;消费者订阅指定队列，Redis 就会记录一个映射关系：队列-&amp;gt;消费者&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;生产者向这个队列发布消息，那 Redis 就从映射关系中找出对应的消费者，把消息转发给它&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.34876989869753977&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3PnYugKyFT6iaYiaXnHG02HFWmvU2w2M5re8p6Dq5uPtHa0Ws9RJ6cGZd6oRhibia9cveicrrqcu5A36LA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;691&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到了么，整个过程中，没有任何的数据存储，一切都是实时转发的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种设计方案，就导致了上面提到的那些问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，如果一个消费者异常挂掉了，它再重新上线后，只能接收新的消息，在下线期间生产者发布的消息，因为找不到消费者，都会被丢弃掉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果所有消费者都下线了，那生产者发布的消息，因为找不到任何一个消费者，也会全部「丢弃」。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，当你在使用 Pub/Sub 时，一定要注意：&lt;strong&gt;消费者必须先订阅队列，生产者才能发布消息，否则消息会丢失。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也是前面讲例子时，我们让消费者先订阅队列，之后才让生产者发布消息的原因。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，因为 Pub/Sub 没有基于任何数据类型实现，所以它也不具备「数据持久化」的能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，Pub/Sub 的相关操作，不会写入到 RDB 和 AOF 中，当 Redis 宕机重启，Pub/Sub 的数据也会全部丢失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，我们来看 Pub/Sub 在处理「消息积压」时，为什么也会丢数据？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当消费者的速度，跟不上生产者时，就会导致数据积压的情况发生。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果采用 List 当作队列，消息积压时，会导致这个链表很长，最直接的影响就是，Redis 内存会持续增长，直到消费者把所有数据都从链表中取出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但 Pub/Sub 的处理方式却不一样，当消息积压时，有可能会导致&lt;strong&gt;消费失败和消息丢失&lt;/strong&gt;！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是怎么回事？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是回到 Pub/Sub 的实现细节上来说。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个消费者订阅一个队列时，Redis 都会在 Server 上给这个消费者在分配一个「缓冲区」，这个缓冲区其实就是一块内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当生产者发布消息时，Redis 先把消息写到对应消费者的缓冲区中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后，消费者不断地从缓冲区读取消息，处理消息。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.34876989869753977&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3PnYugKyFT6iaYiaXnHG02HFW6z62WCJjDASE4WaQ2Th4CkMnZlshf59DiakB84vTnHDkG24xmPGsPuw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;691&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，问题就出在这个缓冲区上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为这个缓冲区其实是有「上限」的（可配置），如果消费者拉取消息很慢，就会造成生产者发布到缓冲区的消息开始积压，缓冲区内存持续增长。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果超过了缓冲区配置的上限，此时，Redis 就会「强制」把这个消费者踢下线。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时消费者就会消费失败，也会丢失数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你有看过 Redis 的配置文件，可以看到这个缓冲区的默认配置：client-output-buffer-limit pubsub 32mb 8mb 60。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的参数含义如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;32mb：缓冲区一旦超过 32MB，Redis 直接强制把消费者踢下线&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;8mb + 60：缓冲区超过 8MB，并且持续 60 秒，Redis 也会把消费者踢下线&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pub/Sub 的这一点特点，是与 List 作队列差异比较大的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从这里你应该可以看出，&lt;strong&gt;List 其实是属于「拉」模型，而 Pub/Sub 其实属于「推」模型&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;List 中的数据可以一直积压在内存中，消费者什么时候来「拉」都可以。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但 Pub/Sub 是把消息先「推」到消费者在 Redis Server 上的缓冲区中，然后等消费者再来取。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当生产、消费速度不匹配时，就会导致缓冲区的内存开始膨胀，Redis 为了控制缓冲区的上限，所以就有了上面讲到的，强制把消费者踢下线的机制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，现在我们总结一下 Pub/Sub 的优缺点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;支持发布 / 订阅，支持多组生产者、消费者处理消息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消费者下线，数据会丢失&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不支持数据持久化，Redis 宕机，数据也会丢失&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息堆积，缓冲区溢出，消费者会被强制踢下线，数据也会丢失&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有没有发现，除了第一个是优点之外，剩下的都是缺点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，很多人看到 Pub/Sub 的特点后，觉得这个功能很「鸡肋」。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也正是以上原因，Pub/Sub 在实际的应用场景中用得并不多。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;目前只有哨兵集群和 Redis 实例通信时，采用了 Pub/Sub 的方案，因为哨兵正好符合即时通讯的业务场景。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再来看一下，Pub/Sub 有没有解决，消息处理时异常宕机，无法再次消费的问题呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实也不行，Pub/Sub 从缓冲区取走数据之后，数据就从 Redis 缓冲区删除了，消费者发生异常，自然也无法再次重新消费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好，现在我们重新梳理一下，我们在使用消息队列时的需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们在使用一个消息队列时，希望它的功能如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;支持阻塞等待拉取消息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持发布 / 订阅模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消费失败，可重新消费，消息不丢失&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实例宕机，消息不丢失，数据可持久化&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息可堆积&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 除了 List 和 Pub/Sub 之外，还有符合这些要求的数据类型吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，Redis 的作者也看到了以上这些问题，也一直在朝着这些方向努力着。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 作者在开发 Redis 期间，还另外开发了一个开源项目 disque。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个项目的定位，就是一个基于内存的分布式消息队列中间件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但由于种种原因，这个项目一直不温不火。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;终于，在 Redis 5.0 版本，作者把 disque 功能移植到了 Redis 中，并给它定义了一个新的数据类型：&lt;strong&gt;Stream&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们就来看看，它能符合上面提到的这些要求吗？&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;趋于成熟的队列：Stream&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看 Stream 是如何解决上面这些问题的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们依旧从简单到复杂，依次来看 Stream 在做消息队列时，是如何处理的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，Stream 通过 XADD 和 XREAD 完成最简单的生产、消费模型：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生产者发布 2 条消息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;// *表示让Redis自动生成消息ID&lt;br/&gt;127.0.0.1:6379&amp;gt; XADD queue * name zhangsan&lt;br/&gt;&quot;1618469123380-0&quot;&lt;br/&gt;127.0.0.1:6379&amp;gt; XADD queue * name lisi&lt;br/&gt;&quot;1618469127777-0&quot;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 XADD 命令发布消息，其中的「*」表示让 Redis 自动生成唯一的消息 ID。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个消息 ID 的格式是「时间戳-自增序号」。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消费者拉取消息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;// 从开头读取5条消息，0-0表示从开头读取&lt;br/&gt;127.0.0.1:6379&amp;gt; XREAD COUNT 5 STREAMS queue 0-0&lt;br/&gt;1) 1) &quot;queue&quot;&lt;br/&gt;   2) 1) 1) &quot;1618469123380-0&quot;&lt;br/&gt;         2) 1) &quot;name&quot;&lt;br/&gt;            2) &quot;zhangsan&quot;&lt;br/&gt;      2) 1) &quot;1618469127777-0&quot;&lt;br/&gt;         2) 1) &quot;name&quot;&lt;br/&gt;            2) &quot;lisi&quot;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想继续拉取消息，需要传入上一条消息的 ID：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; XREAD COUNT 5 STREAMS queue 1618469127777-0&lt;br/&gt;(nil)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没有消息，Redis 会返回 NULL。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.23641703377386197&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3PnYugKyFT6iaYiaXnHG02HFWTGjnYoFly2IbkMAqaicicVhtgFsPlBW9kibBzmbFJDHVzDRWFbmgSTd7A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;681&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是 Stream 最简单的生产、消费。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里不再重点介绍 Stream 命令的各种参数，我在例子中演示时，凡是大写的单词都是「固定」参数，凡是小写的单词，都是可以自己定义的，例如队列名、消息长度等等，下面的例子规则也是一样，为了方便你理解，这里有必要提醒一下。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看，针对前面提到的消息队列要求，Stream 都是如何解决的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;1) Stream 是否支持「阻塞式」拉取消息？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以的，在读取消息时，只需要增加 BLOCK 参数即可。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;// BLOCK 0 表示阻塞等待，不设置超时时间&lt;br/&gt;127.0.0.1:6379&amp;gt; XREAD COUNT 5 BLOCK 0 STREAMS queue 1618469127777-0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时，消费者就会阻塞等待，直到生产者发布新的消息才会返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;2) Stream 是否支持发布 / 订阅模式？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也没问题，Stream 通过以下命令完成发布订阅：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;XGROUP：创建消费者组&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;XREADGROUP：在指定消费组下，开启消费者拉取消息&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看具体如何做？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，生产者依旧发布 2 条消息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; XADD queue * name zhangsan&lt;br/&gt;&quot;1618470740565-0&quot;&lt;br/&gt;127.0.0.1:6379&amp;gt; XADD queue * name lisi&lt;br/&gt;&quot;1618470743793-0&quot;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后，我们想要开启 2 组消费者处理同一批数据，就需要创建 2 个消费者组：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;// 创建消费者组1，0-0表示从头拉取消息&lt;br/&gt;127.0.0.1:6379&amp;gt; XGROUP CREATE queue group1 0-0&lt;br/&gt;OK&lt;br/&gt;// 创建消费者组2，0-0表示从头拉取消息&lt;br/&gt;127.0.0.1:6379&amp;gt; XGROUP CREATE queue group2 0-0&lt;br/&gt;OK&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消费者组创建好之后，我们可以给每个「消费者组」下面挂一个「消费者」，让它们分别处理同一批数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一个消费组开始消费：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;// group1的consumer开始消费，&amp;gt;表示拉取最新数据&lt;br/&gt;127.0.0.1:6379&amp;gt; XREADGROUP GROUP group1 consumer COUNT 5 STREAMS queue &amp;gt;&lt;br/&gt;1) 1) &quot;queue&quot;&lt;br/&gt;   2) 1) 1) &quot;1618470740565-0&quot;&lt;br/&gt;         2) 1) &quot;name&quot;&lt;br/&gt;            2) &quot;zhangsan&quot;&lt;br/&gt;      2) 1) &quot;1618470743793-0&quot;&lt;br/&gt;         2) 1) &quot;name&quot;&lt;br/&gt;            2) &quot;lisi&quot;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样地，第二个消费组开始消费：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;// group2的consumer开始消费，&amp;gt;表示拉取最新数据&lt;br/&gt;127.0.0.1:6379&amp;gt; XREADGROUP GROUP group2 consumer COUNT 5 STREAMS queue &amp;gt;&lt;br/&gt;1) 1) &quot;queue&quot;&lt;br/&gt;   2) 1) 1) &quot;1618470740565-0&quot;&lt;br/&gt;         2) 1) &quot;name&quot;&lt;br/&gt;            2) &quot;zhangsan&quot;&lt;br/&gt;      2) 1) &quot;1618470743793-0&quot;&lt;br/&gt;         2) 1) &quot;name&quot;&lt;br/&gt;            2) &quot;lisi&quot;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以看到，这 2 组消费者，都可以获取同一批数据进行处理了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样一来，就达到了多组消费者「订阅」消费的目的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4008559201141227&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3PnYugKyFT6iaYiaXnHG02HFWeoaD3ZnP3xHV4tazwd7AZvom0Cyjf5ZoibEBhnjlpKETib9ypLrhoyIg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;701&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;3) 消息处理时异常，Stream 能否保证消息不丢失，重新消费？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了上面拉取消息时用到了消息 ID，这里为了保证重新消费，也要用到这个消息 ID。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一组消费者处理完消息后，需要执行 XACK 命令告知 Redis，这时 Redis 就会把这条消息标记为「处理完成」。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;// group1下的 1618472043089-0 消息已处理完成&lt;br/&gt;127.0.0.1:6379&amp;gt; XACK queue group1 1618472043089-0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.42368045649072755&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3PnYugKyFT6iaYiaXnHG02HFWnqicNAVrYEghyoiaZqwtSlphRJ5FX3lhPGYr6XANByxxk1PwfuW2k3jQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;701&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果消费者异常宕机，肯定不会发送 XACK，那么 Redis 就会依旧保留这条消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;待这组消费者重新上线后，Redis 就会把之前没有处理成功的数据，重新发给这个消费者。这样一来，即使消费者异常，也不会丢失数据了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;// 消费者重新上线，0-0表示重新拉取未ACK的消息&lt;br/&gt;127.0.0.1:6379&amp;gt; XREADGROUP GROUP group1 consumer1 COUNT 5 STREAMS queue 0-0&lt;br/&gt;// 之前没消费成功的数据，依旧可以重新消费&lt;br/&gt;1) 1) &quot;queue&quot;&lt;br/&gt;   2) 1) 1) &quot;1618472043089-0&quot;&lt;br/&gt;         2) 1) &quot;name&quot;&lt;br/&gt;            2) &quot;zhangsan&quot;&lt;br/&gt;      2) 1) &quot;1618472045158-0&quot;&lt;br/&gt;         2) 1) &quot;name&quot;&lt;br/&gt;            2) &quot;lisi&quot;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;4) Stream 数据会写入到 RDB 和 AOF 做持久化吗？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Stream 是新增加的数据类型，它与其它数据类型一样，每个写操作，也都会写入到 RDB 和 AOF 中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们只需要配置好持久化策略，这样的话，就算 Redis 宕机重启，Stream 中的数据也可以从 RDB 或 AOF 中恢复回来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;5) 消息堆积时，Stream 是怎么处理的？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，当消息队列发生消息堆积时，一般只有 2 个解决方案：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;生产者限流：避免消费者处理不及时，导致持续积压&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;丢弃消息：中间件丢弃旧消息，只保留固定长度的新消息&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而 Redis 在实现 Stream 时，采用了第 2 个方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在发布消息时，你可以指定队列的最大长度，防止队列积压导致内存爆炸。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;// 队列长度最大10000&lt;br/&gt;127.0.0.1:6379&amp;gt; XADD queue MAXLEN 10000 * name zhangsan&lt;br/&gt;&quot;1618473015018-0&quot;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当队列长度超过上限后，旧消息会被删除，只保留固定长度的新消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这么来看，Stream 在消息积压时，如果指定了最大长度，还是有可能丢失消息的。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;除了以上介绍到的命令，Stream 还支持查看消息长度（XLEN）、查看消费者状态（XINFO）等命令，使用也比较简单，你可以查询官方文档了解一下，这里就不过多介绍了。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，通过以上介绍，我们可以看到，Redis 的 Stream 几乎覆盖到了消息队列的各种场景，是不是觉得很完美？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;既然它的功能这么强大，这是不是意味着，Redis 真的可以作为专业的消息队列中间件来使用呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是还「差一点」，就算 Redis 能做到以上这些，也只是「趋近于」专业的消息队列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原因在于 Redis 本身的一些问题，如果把其定位成消息队列，还是有些欠缺的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里，就不得不把 Redis 与专业的队列中间件做对比了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们就来看一下，Redis 在作队列时，到底还有哪些欠缺？&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;与专业的消息队列对比&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，一个专业的消息队列，必须要做到两大块：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;消息不丢&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息可堆积&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面我们讨论的重点，很大篇幅围绕的是第一点展开的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们换个角度，从一个消息队列的「使用模型」来分析一下，怎么做，才能保证数据不丢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用一个消息队列，其实就分为三大块：&lt;strong&gt;生产者、队列中间件、消费者&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.26265389876880985&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3PnYugKyFT6iaYiaXnHG02HFWcMh2Wso6LtJIzqfk87O0LwLsyOgGvBwJKiamJjrwALKUE47dqhBicdKw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;731&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息是否会发生丢失，其重点也就在于以下 3 个环节：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;生产者会不会丢消息？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消费者会不会丢消息？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;队列中间件会不会丢消息？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;1) 生产者会不会丢消息？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当生产者在发布消息时，可能发生以下异常情况：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;消息没发出去：网络故障或其它问题导致发布失败，中间件直接返回失败&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不确定是否发布成功：网络问题导致发布超时，可能数据已发送成功，但读取响应结果超时了&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是情况 1，消息根本没发出去，那么重新发一次就好了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是情况 2，生产者没办法知道消息到底有没有发成功？所以，为了避免消息丢失，它也只能继续重试，直到发布成功为止。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;生产者一般会设定一个最大重试次数，超过上限依旧失败，需要记录日志报警处理。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，生产者为了避免消息丢失，只能采用失败重试的方式来处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但发现没有？这也意味着消息可能会重复发送。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是的，在使用消息队列时，要保证消息不丢，宁可重发，也不能丢弃。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那消费者这边，就需要多做一些逻辑了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于敏感业务，当消费者收到重复数据数据时，要设计幂等逻辑，保证业务的正确性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从这个角度来看，生产者会不会丢消息，取决于生产者对于异常情况的处理是否合理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，无论是 Redis 还是专业的队列中间件，生产者在这一点上都是可以保证消息不丢的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;2) 消费者会不会丢消息？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种情况就是我们前面提到的，消费者拿到消息后，还没处理完成，就异常宕机了，那消费者还能否重新消费失败的消息？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要解决这个问题，消费者在处理完消息后，必须「告知」队列中间件，队列中间件才会把标记已处理，否则仍旧把这些数据发给消费者。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方案需要消费者和中间件互相配合，才能保证消费者这一侧的消息不丢。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论是 Redis 的 Stream，还是专业的队列中间件，例如 RabbitMQ、Kafka，其实都是这么做的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，从这个角度来看，Redis 也是合格的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;3) 队列中间件会不会丢消息？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面 2 个问题都比较好处理，只要客户端和服务端配合好，就能保证生产端、消费端都不丢消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，如果队列中间件本身就不可靠呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;毕竟生产者和消费者都依赖它，如果它不可靠，那么生产者和消费者无论怎么做，都无法保证数据不丢。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个方面，Redis 其实没有达到要求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 在以下 2 个场景下，都会导致数据丢失。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;AOF 持久化配置为每秒写盘，但这个写盘过程是异步的，Redis 宕机时会存在数据丢失的可能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主从复制也是异步的，主从切换时，也存在丢失数据的可能（从库还未同步完成主库发来的数据，就被提成主库）&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于以上原因我们可以看到，&lt;strong&gt;Redis 本身的无法保证严格的数据完整性&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，如果把 Redis 当做消息队列，在这方面是有可能导致数据丢失的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再来看那些专业的消息队列中间件是如何解决这个问题的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像 RabbitMQ 或 Kafka 这类专业的队列中间件，在使用时，一般是部署一个集群，生产者在发布消息时，队列中间件通常会写「多个节点」，以此保证消息的完整性。这样一来，即便其中一个节点挂了，也能保证集群的数据不丢失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也正因为如此，RabbitMQ、Kafka在设计时也更复杂。毕竟，它们是专门针对队列场景设计的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但 Redis 的定位则不同，它的定位更多是当作缓存来用，它们两者在这个方面肯定是存在差异的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，我们来看消息积压怎么办？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;4) 消息积压怎么办？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为 Redis 的数据都存储在内存中，这就意味着一旦发生消息积压，则会导致 Redis 的内存持续增长，如果超过机器内存上限，就会面临被 OOM 的风险。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，Redis 的 Stream 提供了可以指定队列最大长度的功能，就是为了避免这种情况发生。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但 Kafka、RabbitMQ 这类消息队列就不一样了，它们的数据都会存储在磁盘上，磁盘的成本要比内存小得多，当消息积压时，无非就是多占用一些磁盘空间，相比于内存，在面对积压时也会更加「坦然」。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;综上，我们可以看到，把 Redis 当作队列来使用时，始终面临的 2 个问题：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Redis 本身可能会丢数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;面对消息积压，Redis 内存资源紧张&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里，Redis 是否可以用作队列，我想这个答案你应该会比较清晰了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你的业务场景足够简单，对于数据丢失不敏感，而且消息积压概率比较小的情况下，把 Redis 当作队列是完全可以的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且，Redis 相比于 Kafka、RabbitMQ，部署和运维也更加轻量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你的业务场景对于数据丢失非常敏感，而且写入量非常大，消息积压时会占用很多的机器资源，那么我建议你使用专业的消息队列中间件。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，总结一下。这篇文章我们从「Redis 能否用作队列」这个角度出发，介绍了 List、Pub/Sub、Stream 在做队列的使用方式，以及它们各自的优劣。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后又把 Redis 和专业的消息队列中间件做对比，发现 Redis 的不足之处。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，我们得出 Redis 做队列的合适场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我也列了一个表格，总结了它们各自的优缺点。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.48043184885290147&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3PnYugKyFT6iaYiaXnHG02HFWjjanXypYOraDsDSBTYkXHXLD2gribiamm2GYvPmciaia3ziaN8ZeU0cEdibA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;741&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;后记&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，我想和你再聊一聊关于「&lt;strong&gt;技术方案选型&lt;/strong&gt;」的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你应该也看到了，这篇文章虽然始于 Redis，但并不止于 Redis。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在分析 Redis 细节时，一直在提出问题，然后寻找更好的解决方案，在文章最后，又聊到一个专业的消息队列应该怎么做。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，我们在讨论技术选型时，就是一个关于如何取舍的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而这里我想传达给你的信息是，&lt;strong&gt;在面对技术选型时，不要不经过思考就觉得哪个方案好，哪个方案不好&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你需要根据具体场景具体分析，这里我把这个分析过程分为 2 个层面：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;业务功能角度&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;技术资源角度&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章所讲到的内容，都是以业务功能角度出发做决策的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这里的第二点，从技术资源角度出发，其实也很重要。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;技术资源的角度是说，&lt;strong&gt;你所处的公司环境、技术资源能否匹配这些技术方案&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个怎么解释呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单来讲，就是你所在的公司、团队，是否有匹配的资源能 hold 住这些技术方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道 Kafka、RabbitMQ 是非常专业的消息中间件，但它们的部署和运维，相比于 Redis 来说，也会更复杂一些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你在一个大公司，公司本身就有优秀的运维团队，那么使用这些中间件肯定没问题，因为有足够优秀的人能 hold 住这些中间件，公司也会投入人力和时间在这个方向上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果你是在一个初创公司，业务正处在快速发展期，暂时没有能 hold 住这些中间件的团队和人，如果贸然使用这些组件，当发生故障时，排查问题也会变得很困难，甚至会阻碍业务的发展。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而这种情形下，如果公司的技术人员对于 Redis 都很熟，综合评估来看，Redis 也基本可以满足业务 90% 的需求，那当下选择 Redis 未必不是一个好的决策。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，&lt;strong&gt;做技术选型不只是技术问题，还与人、团队、管理、组织结构有关&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也正是因为这些原因，当你在和别人讨论技术选型问题时，你会发现每个公司的做法都不相同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;毕竟每个公司所处的环境和文化不一样，做出的决策当然就会各有差异。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你不了解这其中的逻辑，那在做技术选型时，只会趋于表面现象，无法深入到问题根源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而一旦你理解了这个逻辑，那么你在看待这个问题时，不仅对于技术会有更加深刻认识，对技术资源和人的把握，也会更加清晰。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;希望你以后在做技术选型时，能够把这些因素也考虑在内，这对你的技术成长之路也是非常有帮助的。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5d5e612b89c3c5a0fbc122a77f79291c</guid>
<title>Java 原生线程池源码解析及使用建议</title>
<link>https://toutiao.io/k/gq4b7nx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;97617&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;线程池概念&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;线程池的基本概念&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;90%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;线程池（Thread pool）是一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。（来源：维基百科）&lt;/p&gt;&lt;p&gt;Java线程池相关类是在1.5新增的，所属包是rt.jar，包路径是java.util.concurrent，作者是：Doug Lea，从属JSR-166。&lt;/p&gt;&lt;p&gt;Java线程池也遵循线程池的核心设计思路，复用线程，降低线程创建销毁的资源消耗，提供了多种线程池的实现模型，同时也允许开发者定制化开发其他特色线程池。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;span data-num=&quot;2&quot;&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;java线程池优势&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;90%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;A） 降低资源消耗，提升效率 ：通过重复利用已创建的线程，降低线程创建和销毁造成的消耗，从而提高整体的执行效率。&lt;/p&gt;&lt;p&gt;B） 提高线程的管理性：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。&lt;/p&gt;&lt;p&gt;C） 可扩展的开发模式：除JVM提供的三种线程池，可以通过实现AbstractExecutorService类定制自己的线程池而支持不同的业务场景。&lt;/p&gt;&lt;p&gt;（这里很多资料都会有额外一条：提高响应速度，即通过复用以创建好的线程，而无需等待新线程的创建，这里个人认为严格讲这一条不完全符合线程池的使用情况，而且复用线程和第一条优势基本吻合，所以合并到一起，至于特殊场景后面学习的过程中会详细讲解。）&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;span data-num=&quot;3&quot;&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;java原生线程池简介&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;90%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;首先介绍下java原生的三个线程池，ForkJoinPool，ThreadPoolExecutor，ScheduledThreadPoolExecutor。三个线程池的UML类图如下（version：1.8.0_131，后面的源码都是基于这个版本）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6218274111675127&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFic7dDdDdODHibR3DRemLfcxfsRzk6ukLJYPfg8ZS34UCs8KxWHibiauDTveomJMz0GdQjdbmZhHnjibwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1576&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;A） ForkJoinPool是Java 1.7 引入的一种新的并发框架，核心思想是将大的任务拆分成多个小任务（fork），然后在将多个小任务处理汇总到一个结果上（join），充分利用多cpu，多核CPU的优势，引入了“work-stealing”机制，更有效的利用线程。&lt;/p&gt;&lt;p&gt;B） ThreadPoolExecutor是 java常用的线程池，提供基础的线程池功能。初始化传入不同类型的工作队列和拒绝策略参数，可以定制不同类型和功能的线程池，应用最为广泛。&lt;/p&gt;&lt;p&gt;C） ScheduledThreadPoolExecutor 从类图上可以看出，它继承了ThreadPoolExecutor，并实现了ScheduledExecutorService，是对ThreadPoolExecutor做的功能扩展，本质上是一个使用线程池执行定时任务的类，可以用来在给定延时后执行异步任务或者周期性执行任务，较任务调度的Timer来说，其功能更加强大。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;97617&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;线程池的实现原理&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;接下来以java的基础线程池ThreadPoolExecutor为主介绍下线程池的工作原理和实现方式。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;ThreadPoolExector类&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;90%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.1.1 ThreadPoolExector介绍&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;A） ThreadPoolExecutor实现的顶层接口是Executor，内部只有一个方法execute(Runable)，标识出执行任务这个核心方法。限制了任务类型为：Runable，即线程的接口类。&lt;/p&gt;&lt;p&gt;B）ExecutorService接口扩展了很多能力，比如对线程池的管理。以及扩展了执行任务的能力，支持多个任务批量执行。&lt;/p&gt;&lt;p&gt;C）AbstractExecutorService是对ExecutorService抽象类，这里对任务的执行和调用做了基础的实现，可以看出目前都是在对任务的执行做层层抽象，也规范了任务的基础类型。&lt;/p&gt;&lt;p&gt;D）ThreadPoolExecutor是java原生线程池的一个基础实现类，完成了线程池的各种功能，内部维护了存储任务的阻塞队列，以及执行任务的worker线程，还有线程池的相关状态管理及任务管理。同时提供了一些扩展方法。供开发者定制特色能力。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.147196261682243&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFic7dDdDdODHibR3DRemLfcxfRUViax05X4GSZMS5jGZCFfFMLfZ7tMy9zQDeUYOrISxRzaNic7jcNu8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;856&quot;/&gt;&lt;/p&gt;&lt;p&gt;    &lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.1.2 线程池的基础参数&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;接下来说一下创建ThreadPoolExecutor比较重要的参数。&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;corePoolSize：线程池核心线程个数。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;queue：用于保存等待执行的任务的阻塞队列；如基于数组的有界 ArrayBlockingQueue，基于链表的无界 LinkedBlockingQueue，优先级队列 PriorityBlockingQueue 等。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;maximunPoolSize：线程池最大线程数量。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;ThreadFactory：创建线程的工厂。可以自定义工工厂，控制产生的线程名称辅助排查问题。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;RejectedExecutionHandler：饱和策略，当队列满了且线程个数到 达maximunPoolSize 后采取的策略，如AbortPolicy 抛出拒绝执行；DiscardPolicy 丢弃该任务。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;keeyAliveTime：存活时间。如果当前线程池中的线程数量比核心线程数量要多，并且是闲置状态的话，这些闲置的线程能存活的最大时间。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;TimeUnit，存活时间的时间单位。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.2594810379241517&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFic7dDdDdODHibR3DRemLfcxfRuiakNTuEld0afj3t6LnPWmUWotqqLr2dh3NEH4nib2BzPQpQ1lJ3dkw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1002&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.1.3 ThreadPoolExecutor.Worker内部类&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;ThreadPoolExecutor.Worker这个工作线程，实现了Runnable接口，同时继承AQS类，并持有一个线程thread，一个初始化的任务firstTask。负责处理任务，同时维护工作线程的状态。&lt;/p&gt;&lt;p&gt;thread是在调用构造方法时通过ThreadFactory来创建的线程，用来执行任务。&lt;/p&gt;&lt;p&gt;firstTask是传入的第一个任务，如果非空，那么线程在启动初期立即执行这个任务，也就对应核心线程创建时的情况；如果这个值是null，那么就需要创建一个线程去执行workQueue中的任务，也就是非核心线程的创建。单个任务执行完毕后，worker会继续在workQueue中获取下一个任务继续执行。&lt;/p&gt;&lt;p&gt;    &lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;span data-num=&quot;2&quot;&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;ThreadPoolExecutor 工作流程&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;90%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.2.1 总体介绍&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4358322744599746&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFic7dDdDdODHibR3DRemLfcxf0Dh2MPaokCVZgBULn0CBcNvkyDYxZdWibL76kujmVWgHicjXQMicczJ5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1574&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;线程池在内部实际上构建了一个生产者消费者模型，将线程和任务两者解耦，不直接关联，从而良好的缓冲任务，复用线程。线程池的运行主要分成两部分: 任务管理、线程管理。任务管理部分充当生产者的角色，当任务提交后，线程池会判断该任务后续的执行策略。主要有以下几种：&lt;/p&gt;&lt;p&gt;(1)直接申请线程执行该任务;&lt;/p&gt;&lt;p&gt;(2)缓冲到队列中等待线程执行;&lt;/p&gt;&lt;p&gt;(3)拒绝该任务，执行拒绝策略。&lt;/p&gt;&lt;p&gt;线程管理部分是消费者，它们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务的时候，线程就会被回收。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.2.2 状态变化&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.262532981530343&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFic7dDdDdODHibR3DRemLfcxffVXVq8Hksllc8or1jrqot8UrpfaOaCy0L7ibc6NOLPib7zbXIWL0vNiaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1516&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;ThreadPoolExector内部使用AtomicInteger类型的变量ctl来维护线程池的状态和线程池中的线程数量，即高三位为状态位，其余表示线程数目。&lt;/p&gt;&lt;p&gt;每种状态均可以通过调用不同的方法完成相应的状态转化。&lt;/p&gt;&lt;p&gt;1.  RUNNING(-1 : 111)：可以接受新的任务，也可以处理阻塞队列里的任务。&lt;/p&gt;&lt;p&gt;2.  SHUTDOWN(0 : 000) ：不接受新的任务，但是可以处理阻塞队列里的任务。&lt;/p&gt;&lt;p&gt;3.  STOP(1 : 001)：不接受新的任务，不处理阻塞队列里的任务，中断正在处理的任务。&lt;/p&gt;&lt;p&gt;4.  TIDYING(2 : 010)：过渡状态，也就是说所有的任务都执行完了，当前线程池已经没有有效的线程，这个时候线程池的状态将会TIDYING，并且将要调用terminated方法。&lt;/p&gt;&lt;p&gt;5.  TERMINATED(3: 011) ：终止状态。terminated方法调用完成以后的状态。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.2.3 源码解析-execute&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Execute是提交任务的方法入口方法，根据核心线程池的数量、线程池的状态，任务队列大小、最大数量、分成不同情况，创建不同线程，存储到不同位置，或执行拒绝策略。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6205583756345178&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFic7dDdDdODHibR3DRemLfcxfCCdiaevlpmF7iao9mT08J9RjlIRibiaMQKcdgFgzG8xxGHjEfALYLBgWFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1576&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.2.4 源码解析-addWorker&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;addWorker是添加工作线程的方法，通过Worker内部类封装一个Thread实例维护工作线程的执行，同时根据线程池的状态来判断是否增加相应的任务。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7325728770595691&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFic7dDdDdODHibR3DRemLfcxfkGRA0ZnM9BGAaBjI5e4VicWToYmFFldGGdC7Yp1Viad9vRBN8sQqpsWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1578&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.2.5 源码解析-runWorker&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;runWorker真正执行任务的地方，先执行第一个任务，再源源不断从任务队列中取任务来执行；如果线程池调用了shutDownNow，这里也会收到影响。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.752851711026616&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFic7dDdDdODHibR3DRemLfcxfUmYM9Qls3cAven863SHpSLJqRRwnrbfY6WibTD15IC1EAsj9uo0aicmw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1578&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.2.6 源码解析-getTask&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;从队列取任务的地方，默认情况下，根据工作线程数量与核心数量的关系判断使用队列的poll()还是take()方法，keepAliveTime参数也是在这里使用的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7825537294563844&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFic7dDdDdODHibR3DRemLfcxfCDnqsCI8Zqfxltkia7BTsOjEMibRC4EzUxfUSXPPI6JwR6B2SOdV7bzA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1582&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.2.7任务队列&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;阻塞队列BlockingQueue是用来存放任务的。当线程池中有空闲线程时就回去任务队列中拿任务并处理。&lt;/p&gt;&lt;p&gt;多线程环境中，通过队列可以很容易实现数据共享，比如经典的“生产者”和“消费者”模型中，通过队列可以很便利地实现两者之间的数据共享。&lt;/p&gt;&lt;p&gt;常见的集中队列有：&lt;/p&gt;&lt;p&gt;无界队列: 使用无界队列（如 LinkedBlockingQueue）将所有的任务都存储到阻塞队列中。这样，创建的线程就不会超过 corePoolSize。&lt;/p&gt;&lt;p&gt;有界队列: 当使用有限的 maximumPoolSizes 时，有界队列（如 ArrayBlockingQueue， PriorityBlockingQueue）有助于防止资源耗尽， PriorityBlockingQueue还可以定制任务的优先级。但是需要开发人员根据实际任务情况调整队列大小和线程池大小。&lt;/p&gt;&lt;p&gt;同步移交队列，如果不希望任务在队列中等待而是希望将任务直接移交给工作线程，可使用SynchronousQueue作为等待队列。SynchronousQueue不是一个真正的队列，而是一种线程之间移交的机制。要将一个元素放入SynchronousQueue中，必须有另一个线程正在等待接收这个元素。只有在使用无界线程池或者有饱和策略时才建议使用该队列。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.2.8 拒绝策略&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.19796954314720813&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFic7dDdDdODHibR3DRemLfcxfn56Ie3aGIFypYt1samkvDWuLIVVRlbZkVibHDCkFRQk52x43mraWkdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1576&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;1. CallerRunsPolicy 由调用线程执行该任务，不抛弃任务，会影响效率和性能。&lt;/p&gt;&lt;p&gt;2.  AbortPolicy 抛出拒绝执行的异常，java线程池的默认拒绝策略，保证线程池整体的执行效率。&lt;/p&gt;&lt;p&gt;3.  DiscardPolicy 丢弃该任务，不做任何处理，同时也不抛异常。使用中不太友好。&lt;/p&gt;&lt;p&gt;4.  DiscardOldestPolicy  如果线程池未关闭，则弹出任务队列的第一个，然后运行。&lt;/p&gt;&lt;p&gt;以上是默认提供的四种拒绝策略。除此之外还有一些其他框架中的值得参考的处理。&lt;/p&gt;&lt;p&gt;AbortPolicyWithReport 这是dubbo 中的拒绝策略，继承了AbortPolicy拒绝策略。但是在抛出异常前，打印了当前线程池的重要参数信息，以及运行状态，同时定制输出了此时的堆栈信息。方便后续排查问题处理。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;97617&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;线程池的应用场景&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;Tomcat中的线程池&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;90%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Tomcat作为一款优秀的web服务器，为了保证其性能，其内部也有自己的线程池对象：org.apache.tomcat.util.threads.ThreadPoolExecutor 继承自java.util.concurrent.ThreadPoolExecutor。&lt;/p&gt;&lt;p&gt;不同于原生ThreadPoolExecute达到最大线程后，对新增任务立即执行拒绝策略。Tomcat线程池会在此时再次尝试向队列中添加任务，失败后再执行拒绝策略。最大限度保证任务执行。&lt;/p&gt;&lt;p&gt;同时Tomcat内置了TaskQueue作为任务的缓存队列。继承了LinkedBlockingQueue但是重写了offer方法，即当前线程大于核心线程，且提交的任务数大于当前线程数，表示有线程空闲的情况下，返回false，也就是创建线程。主要是为了控制在线程队列无限增长时，无法创建更多的线程而达到最大线程数的问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;span data-num=&quot;2&quot;&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;Sirector 中的线程池&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;90%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Sirector是JD内一个事件处理编排框架，内置ExecutorService对象，负责对任务的分配处理。&lt;/p&gt;&lt;p&gt;初始化的对象是WorkerExecutor， WorkerExecutor继承自ThreadPoolExecutor，扩展了submit方法用于执行通过sirector编排的具体任务。&lt;/p&gt;&lt;p&gt;WorkerExecutor内置了工厂WorkerThreadFactory主要记录了当前线程池的名称、工厂创建的线程数目等。&lt;/p&gt;&lt;p&gt;使用的拒绝策略为RejectedTaskController，继承自RejectedExecutionHandler，处理方法类似于AbortPolicy策略，丢弃任务抛出异常，抛出异常前也打印了一些异常信息，辅助排查问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;span data-num=&quot;3&quot;&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;个人开发中的线程池&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;90%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;参考上面几种框架的线程池，可以得出大概几点结论。&lt;/p&gt;&lt;p&gt;如果个人开发中涉及线程池，要先确认任务场景，是I/O密集还是CPU密集任务，从而确定线程池类型。&lt;/p&gt;&lt;p&gt;再通过使用场景，是最大限度保证任务执行，还是为了保证服务性能，来定制自己的执行策略，并且确定选择任务队列以及拒绝策略。拒绝策略可以参考Dubbo中，同时打印线程信息，辅助排查问题。&lt;/p&gt;&lt;p&gt;然后确定是否需要自定义线程工厂，这里建议自定义线程工厂，在创建线程的时候打上标识，和系统线程加以区分。&lt;/p&gt;&lt;p&gt;在根据任务类型，配置上合理的线程池参数。一个属于你的线程池就搭好了！&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;97617&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;线程池参数设置&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这里个人认为，没有一种万能的参数一定适合所有的线程池使用场景。&lt;/p&gt;&lt;p&gt;但是有通用的思路来寻找适合当前线程池的最佳参数。&lt;/p&gt;&lt;p&gt;1、确定当前任务类型，是CPU密集还是I/O密集型任务。这两者差别很大。CPU密集和CPU核数以及CPU超线程有关。而I/O密集则和服务处理的任务有很大关联。&lt;/p&gt;&lt;p&gt;2、如果使用一些已有的技术框架中的线程池。初期建议以默认参数为佳，如Tomcat默认范围25-200，JSF默认cached线程池20-200。&lt;/p&gt;&lt;p&gt;3、在服务稳定之后的性能调优。需要对服务进行多次高保真压测，期间不断控制、调整线程池参数，这样尽可能得到当前服务最优的线程池参数。&lt;/p&gt;&lt;p&gt;4、只有最合适的、没有一定不变的，随着业务不断迭代，每隔一段时间对服务进行压测，通过结果调整相应的参数。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;97617&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;线程池使用过程中的建议&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;1 、当提交一个任务到线程池时,若线程数量 &amp;lt; corePoolSize,线程池会创建一个新线程放入workers(一个HashSet)中执行任务, 即使其他空闲的基本线程能够执行新任务也还是会创建新线程，直至达到corePoolSize。&lt;/p&gt;&lt;p&gt;2 、默认最初的线程池启动的时候是不初始化线程的，通过调用 prestartAllCoreThreads 方法，可以初始化所有核心线程。&lt;/p&gt;&lt;p&gt;3 、Worker中处理task如果抛出异常，这个work thread不会继续执行任务，但是会创建新的线程, 新线程可以运行其他task。&lt;/p&gt;&lt;p&gt;4 、最好不要使用Executors创建新线程池，因为Executors提供的很多方法，没有指定实际核心及最大线程池参数，容易发生OOM，推荐自己创建相应的线程池，适合自己的才是最好的，同时线程池中有很多钩子方法可以用来定制特色功能。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>