<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>95fccac0dc04b52d7f00c6ecf6a281b2</guid>
<title>14W 行代码量的前端页面长什么样</title>
<link>https://toutiao.io/k/2urs5ua</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：sigmaliu，腾讯文档 AlloyTeam 开发工程师&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;0. 前言&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;腾讯文档列表页在不久前经历了一次完全重构后，首屏速度其实已经是不错。但是我们仍然可以引入 SSR 来进一步加快速度。这篇文章就是用来记录和整理我最近实现 SSR 遇到的一些问题和思考。虽然其中有一些基础设施可能和腾讯或文档强相关，但是作为一篇涉及 &lt;code&gt;Node&lt;/code&gt;、&lt;code&gt;React 组件&lt;/code&gt;、&lt;code&gt;性能&lt;/code&gt;、&lt;code&gt;网络&lt;/code&gt;、&lt;code&gt;docker 镜像&lt;/code&gt; 、&lt;code&gt;云上部署&lt;/code&gt;、&lt;code&gt;灰度和发布&lt;/code&gt;等内容的文章，仍然可以小小地作为参考或者相似需求的 Checklist。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6586387434554973&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvaukJ07t3E8jUK2u2EfibSibZAiaDVPSSibBAuHHGmEHcV8VdV9uBOFXmFNPdJiaBc1PwlOcUWuLCzKW9Fg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1910&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就是这样一个页面，内部逻辑复杂，优秀的重构同学做到了组件尽可能地复用，未压缩的编译后开发代码仍然有 14W 行，因此也不算标题党了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.055944055944056&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvaukJ07t3E8jUK2u2EfibSibZA7G7vlWUeTRYJ8yr3QvJaE3QDXprfdicq9gttloXnOFtDEutNcXicPFLg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;286&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 整体流程&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.1 CSR&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们回顾 CSR（客户端渲染）的流程&lt;/p&gt;&lt;img data-ratio=&quot;0.761501210653753&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvaukJ07t3E8jUK2u2EfibSibZA3D4Jjqu6EJ4AjQKVKsibzrq4bbhEFG45vrxu4MZoHNdAnBB5M1Pz5icA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1652&quot;/&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一个 React 应用，通常我们把 CSS 放在 head，有个 React 应用挂载的根节点空标签，以及 React 应用编译后的主体文件。浏览器在加载 HTML 后，加载 CSS 和 JS，到这时候为止，浏览器呈现给用户的仍然是个空白的页面。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&amp;lt;红色箭头部分&amp;gt;&lt;/strong&gt; JS 开始执行，状态管理会初始化个 store，会先拿这个 store 去渲染页面，这时候页面开始渲染元素（白屏时间结束）。但是还没有列表的详细信息，也没有头像、用户名那些信息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;初始化 store 后会发起异步的 CGI 请求，在请求回来后会更新 store，触发 React 重新渲染页面，绑定事件，整个页面完全呈现（首屏时间结束）。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2 SSR&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5918762088974855&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvaukJ07t3E8jUK2u2EfibSibZAAAhsEYk9XWGqHl73A3a5TydItQanfnqluc34cKevOBQNJIdxnNaCjA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3102&quot;/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&amp;lt;绿色箭头部分&amp;gt;&lt;/strong&gt; 首先我们复用原来的 React 组件编译出可以在 Node 环境下运行的文件，并且部署一个 Node 服务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&amp;lt;蓝色箭头部分&amp;gt;&lt;/strong&gt; 在浏览器发起 HTML 请求时，我们的 Node 服务会接收到请求。可以从请求里取出 HTTP 头部，Cookie 等信息。运行对应的 JS 文件，初始化 store，发起 CGI 请求填充数据，调用 React 渲染 DOM 节点（这里和 CSR 的差异在于我们得等 CGI 请求回来数据改变后再渲染，也就是需要的数据都准备好了再渲染）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将渲染的 DOM 节点插入到原 React 应用根节点的内部，同时将 store 以全局变量的形式注入到文档里，返回最终的页面给浏览器。浏览器在拿到页面后，加上原来的 CSS，在 JS 下载下来之前，就已经能够渲染出完整的页面了（白屏时间结束、首屏时间结束）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&amp;lt;红色箭头部分&amp;gt;&lt;/strong&gt; JS 开始执行，拿服务端注入的数据初始化 store，渲染页面，绑定事件（可交互时间结束）（这里其实后面可能还有一些 CGI，因为有一些 CGI 是不适合放在服务端的，且不影响首页直出的页面，会放在客户端上加快首屏速度。这里的一个优化点在于我们将尽量避免在服务端有串行的 CGI 存在，比如需要先发起一个 CGI，等结果返回后才发起另外一个 CGI，因为这会将 SSR 完全拖垮一个 CGI 的速度）。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 入口文件&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1 服务端入口文件&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要把代码在 Node 下跑起来，首先要编译出文件来。除了原来的 CSR 代码外，我们创建一个 Node 端的入口文件，引入 CSR 的 React 组件。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;(async () =&amp;gt; {&lt;br/&gt;    const store = useStore();&lt;br/&gt;&lt;br/&gt;    await Promise.all([&lt;br/&gt;        store.dispatch.user.requestGetUserInfo(),&lt;br/&gt;        store.dispatch.list.refreshRecentOpenList(),&lt;br/&gt;    ]);&lt;br/&gt;&lt;br/&gt;    const initialState = store.getState();&lt;br/&gt;    const initPropsDataHtml = getStateScriptTag(initialState);&lt;br/&gt;&lt;br/&gt;    const bodyHtml = ReactDOMServer.renderToString(&lt;br/&gt;        &amp;lt;Provider store={store}&amp;gt;&lt;br/&gt;            &amp;lt;ServerIndex /&amp;gt;&lt;br/&gt;        &amp;lt;/Provider&amp;gt;&lt;br/&gt;    );&lt;br/&gt;// 回调函数，将结果返回的&lt;br/&gt;    TSRCALL.tsrRenderCallback(false, bodyHtml + initPropsDataHtml);&lt;br/&gt;})();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务端的 store，Provider, reducer，ServerIndex 等都是复用的客户端的，这里的结构和以下客户端渲染的一致，只不过多了 &lt;code&gt;renderToString&lt;/code&gt; 以及将结果返回的两部分。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2 客户端入口文件&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相应的，客户端的入口文件做一点改动：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;export default function App() {&lt;br/&gt;    const initialState = window.__initial_state__ || undefined;&lt;br/&gt;&lt;br/&gt;    const store = useStore(initialState);&lt;br/&gt;    // 额外判断数据是否完整的&lt;br/&gt;    const { getUserInfo, recentList } = isNeedToDispatchCGI(store);&lt;br/&gt;&lt;br/&gt;    useEffect(() =&amp;gt; {&lt;br/&gt;        Promise.race([&lt;br/&gt;            getUserInfo &amp;amp;&amp;amp; store.dispatch.user.requestGetUserInfo(),&lt;br/&gt;            store.dispatch.notification.requestGetNotifyNum(),&lt;br/&gt;        ]).finally(async () =&amp;gt; {&lt;br/&gt;            store.dispatch.banner.requestGetUserGrowthBanner();&lt;br/&gt;            recentList &amp;amp;&amp;amp; store.dispatch.list.requestRecentOpenList();&lt;br/&gt;        });&lt;br/&gt;    }, []);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要是复用服务端注入到全局变量的数据以及 CGI 是否需要重发的判断。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.3 代码编译&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将服务端的代码编译成 Node 下运行的文件，最主要的就是设置 webpack 的 &lt;code&gt;target: &#x27;node&#x27;&lt;/code&gt; ，以及为了在复用的代码里区分服务端还是客户端，会注入编译变量。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;new&lt;/span&gt; webpack.DefinePlugin({&lt;br/&gt;    &lt;span&gt;__SERVER__&lt;/span&gt;: (process.env.RENDER_ENV === &lt;span&gt;&#x27;server&#x27;&lt;/span&gt;),&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其他的大部分保持和客户端的编译配置一样就 OK 了，一些细微的调整后面会说到。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 代码改造&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将代码编译出来，但是先不管跑起来能否结果一致，能不报错大致跑出个 DOM 节点来又是另外一回事。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1 运行时差异&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先摆在我们前面的问题在于浏览器端和 Node 端运行环境的差异。就最基本的，&lt;code&gt;window&lt;/code&gt;，&lt;code&gt;document&lt;/code&gt; 在 Node 端是没有的，相应的，它们以下的好多方法就不能使用。我们当然可以选择使用 &lt;code&gt;jsdom&lt;/code&gt; 来模拟浏览器环境，以下是一个 demo：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; jsdom = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&quot;jsdom&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; { JSDOM } = jsdom;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; { &lt;span&gt;window&lt;/span&gt; } = &lt;span&gt;new&lt;/span&gt; JSDOM(&lt;span&gt;``&lt;/span&gt;, {&lt;br/&gt;    &lt;span&gt;url&lt;/span&gt;: &lt;span&gt;&#x27;http://localhost&#x27;&lt;/span&gt;,&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;global.localStorage = &lt;span&gt;window&lt;/span&gt;.localStorage;&lt;br/&gt;&lt;br/&gt;localStorage.setItem(&lt;span&gt;&#x27;AlloyTeam&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;NB&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(localStorage.getItem(&lt;span&gt;&#x27;AlloyTeam&#x27;&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// NB&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是当我使用的时候，有遇到不支持的 API，就需要去补 API。且在 Node 端跑预期之外的代码，生成的是否是预期的结果也是存疑，工作量也会较大，因此我选择用编译变量来屏蔽不支持的代码，以及在全局环境下注入很有限的变量（vm + context）。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2 非必需依赖&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于不支持 Node 环境的依赖模块来说，比如浏览器端的上报库，统一的打开窗口的库，模块动态加载库等，对首页直出是不需要的，可以选择配置 &lt;code&gt;alias&lt;/code&gt; 并使用空函数代替防止调用报错或 ts 检查报错。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;alias: {&lt;br/&gt;    &lt;span&gt;src&lt;/span&gt;: path.resolve(projectDir, &lt;span&gt;&#x27;src&#x27;&lt;/span&gt;),&lt;br/&gt;    &lt;span&gt;&#x27;@tencent/tencent-doc-report&#x27;&lt;/span&gt;: getRewriteModule(&lt;span&gt;&#x27;./tencent-doc-report.ts&#x27;&lt;/span&gt;),&lt;br/&gt;    &lt;span&gt;&#x27;@tencent/tencent_doc_open_url&#x27;&lt;/span&gt;: getRewriteModule(&lt;span&gt;&#x27;./tencent-doc-open-url.ts&#x27;&lt;/span&gt;),&lt;br/&gt;    &lt;span&gt;&#x27;script-loader&#x27;&lt;/span&gt;: getRewriteModule(&lt;span&gt;&#x27;./script-loader.ts&#x27;&lt;/span&gt;),&lt;br/&gt;    &lt;span&gt;&#x27;@tencent/docs-scenario-components-message-center&#x27;&lt;/span&gt;: getRewriteModule(&lt;span&gt;&#x27;./message-center.ts&#x27;&lt;/span&gt;),&lt;br/&gt;    &lt;span&gt;&#x27;@tencent/toggle-client-js&#x27;&lt;/span&gt;: getRewriteModule(&lt;span&gt;&#x27;./tencent-client-js.ts&#x27;&lt;/span&gt;),&lt;br/&gt;},&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如里面的 script-loader（模块加载器，用来动态创建 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标签注入 JS 模块的），整个模块屏蔽掉。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; anyFunc = &lt;span&gt;(&lt;span&gt;...args: &lt;span&gt;any&lt;/span&gt;[]&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; ScriptLoader = {&lt;br/&gt;    init: anyFunc,&lt;br/&gt;    load: anyFunc,&lt;br/&gt;    listen: anyFunc,&lt;br/&gt;    dispatch: anyFunc,&lt;br/&gt;    loadRemote: anyFunc,&lt;br/&gt;    loadModule: anyFunc,&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.3 必需依赖&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于必需的依赖但是又不支持 Node 环境的，也只能是推动兼容一下。整个过程来说只有遇到两个内部模块是不支持的，兼容工作很小。对于社区成熟的库，很多都是支持 Node 下环境的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如组件库里默认的挂载点，在默认导出里使用 &lt;code&gt;document.body&lt;/code&gt; ，只要多一下判断就可以了。&lt;/p&gt;&lt;img data-ratio=&quot;0.5637755102040817&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvaukJ07t3E8jUK2u2EfibSibZAwRYqbD1Gde7icIicsBpQPE763ULtsOXI8qtDp3hzUfCSzJ46DRGD5rWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1568&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.4 不支持的方法&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举一些不支持方法的案例：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像这种在组件渲染完成后注册可见性事件的，明显在服务端是不需要的，直接屏蔽就可以了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; registerOnceVisibilityChange = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (__SERVER__) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (onVisibilityChange) {&lt;br/&gt;        removeVisibilityChange(onVisibilityChange);&lt;br/&gt;    }&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;useLayoutEffect&lt;/code&gt; 在服务端不支持，也应该屏蔽。但是需要看一下是否需要会有影响的逻辑。比如有个组件是 Slide，它的功能就像是页签，在子组件挂载后，切换子组件的显示。在服务端上明显是没有 DOM 挂载后的回调的，因此在服务端就需要改成直接渲染要显示的子组件就可以了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;TransitionView&lt;/span&gt;(&lt;span&gt;{ visible = &lt;span&gt;false&lt;/span&gt;, ...props }: TransitionViewProps&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!__SERVER__) {&lt;br/&gt;        useLayoutEffect(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;        }, [visible, props.duration]);&lt;br/&gt;&lt;br/&gt;        useLayoutEffect(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;        }, [_visible]);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;useMemo&lt;/code&gt; 方法在服务端也不支持。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;useStore&lt;/span&gt;(&lt;span&gt;initialState?: RootStore&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (__SERVER__) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; initializeStore(initialState);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; useMemo(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; initializeStore(initialState), [initialState]);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总的来说使用屏蔽的方法，加上注入的有限的全局变量，其实屏蔽的逻辑不多。对于引入 jsdom 来说，结果可控，工作量又小。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.5 基础组件库 DUI&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于要直出一个 React 应用，基础组件库的支持是至关重要的。腾讯文档里使用自己开发的 &lt;code&gt;DUI&lt;/code&gt; 组件库，因为之前没有 SSR 的需求，所以虽然代码里有一些支持 Node 环境的逻辑，但是还不完善。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.5.1 后渲染组件&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一些组件需要在鼠标动作或者函数式调用才渲染的，比如 &lt;code&gt;Tooltip&lt;/code&gt;，&lt;code&gt;Dropdown&lt;/code&gt;，&lt;code&gt;Menu&lt;/code&gt;，&lt;code&gt;Modal&lt;/code&gt;组件等。在特定动作后才渲染子组件。在服务端上，并不会触发这些动作，就可以用空组件代替。（理想情况当然是组件里原生支持 Node 环境，但是有五六个组件需要支持，就先在业务里去兼容，也算给组件库提供个思路）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以 Tooltip 为例，这样可以支持组件同时运行在服务端和客户端，这里还补充了 &lt;code&gt;className&lt;/code&gt;，是因为发现这个组件的根节点设置的样式会影响子组件的显示，因此加上。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;import { Tooltip as BrowserTooltip } from &#x27;@tencent/dui/lib/components/Tooltip&#x27;;&lt;br/&gt;import { ITooltipProps } from &#x27;./interface&#x27;;&lt;br/&gt;&lt;br/&gt;function ServerTooltip(props: ITooltipProps) {&lt;br/&gt;    // 目前知道这个 tooltip 的样式会影响，因此加上 dui 的样式&lt;br/&gt;    return (&lt;br/&gt;        &amp;lt;div className=&quot;dui-trigger dui-tooltip dui-tooltip-wrapper&quot;&amp;gt;&lt;br/&gt;            {props.children}&lt;br/&gt;        &amp;lt;/div&amp;gt;&lt;br/&gt;    );&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;const Tooltip = __SERVER__ ? ServerTooltip : BrowserTooltip;&lt;br/&gt;&lt;br/&gt;export default Tooltip;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.5.2 动态插入样式&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;DUI&lt;/code&gt; 组件会在第一次运行的时候会将对应组件的样式使用 &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; 标签动态插入。但是当我们在服务端渲染，是没有节点让它插入样式的。因此是在 vm 里提供了一些全局方法，供运行代码可以在文档的指定位置插入内容。需要注意的是我们首屏可能只用到了几个组件，但是如果把所有的组件样式都插到文档里，文档将会变大不少，因此还需要过滤一下。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (isBrowser) {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; styleElement = &lt;span&gt;document&lt;/span&gt;.createElement(&lt;span&gt;&#x27;style&#x27;&lt;/span&gt;);&lt;br/&gt;    styleElement.setAttribute(&lt;span&gt;&#x27;type&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;text/css&#x27;&lt;/span&gt;);&lt;br/&gt;    styleElement.setAttribute(&lt;span&gt;&#x27;data-dui-key&#x27;&lt;/span&gt;, key);&lt;br/&gt;&lt;br/&gt;    styleElement.innerText = css;&lt;br/&gt;    &lt;span&gt;document&lt;/span&gt;.head.appendChild(styleElement);&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; injectContentBeforeRoot === &lt;span&gt;&#x27;function&#x27;&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; styleElement = &lt;span&gt;`&amp;lt;style type=&quot;text/css&quot; data-dui-key=&quot;&lt;span&gt;${key}&lt;/span&gt;&quot;&amp;gt;&lt;span&gt;${css}&lt;/span&gt;&amp;lt;/style&amp;gt;`&lt;/span&gt;;&lt;br/&gt;    injectContentBeforeRoot(styleElement);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时组件用来在全局环境下管理版本号的方法，也需要抹平浏览器端和 Node 端的差异（这里其实还可以实现将 &lt;code&gt;window.__dui_style_registry__&lt;/code&gt; 注入到文档里，客户端从全局变量取出，实现复用）。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; StyleRegistryManage {&lt;br/&gt;    nodeRegistry: Record&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;[]&amp;gt; = {};&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;constructor&lt;/span&gt;(&lt;span/&gt;) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (isBrowser &amp;amp;&amp;amp; !&lt;span&gt;window&lt;/span&gt;.__dui_style_registry__) {&lt;br/&gt;            &lt;span&gt;window&lt;/span&gt;.__dui_style_registry__ = {};&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 这里才是重点，在不同的端存储的地方不一样&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;get&lt;/span&gt; registry() {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (isBrowser) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;window&lt;/span&gt;.__dui_style_registry__;&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.nodeRegistry;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;get&lt;/span&gt; length() {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;Object&lt;/span&gt;.keys(&lt;span&gt;this&lt;/span&gt;.registry).length;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;(key: &lt;span&gt;string&lt;/span&gt;, bundledsBy: &lt;span&gt;string&lt;/span&gt;[]) {&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.registry[key] = bundledsBy;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;get&lt;/span&gt;(key: &lt;span&gt;string&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.registry[key];&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; add(key: &lt;span&gt;string&lt;/span&gt;, bundledBy: &lt;span&gt;string&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;.registry[key]) {&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.registry[key] = [];&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.registry[key].push(bundledBy);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.6 公用组件库 UserAgent&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;腾讯文档里封装了公用的判断代码运行环境的组件库 &lt;code&gt;UserAgent&lt;/code&gt;。虽然自执行的模块在架构设计上会带来混乱，因为很有可能随着调用地方的增多，你完全不知道模块在什么样的时机被以什么样的值初始化。对于 SSR 来说就很怕这种自执行的逻辑，因为如果模块里有不支持 Node 环境的代码，意味着你要么得改模块，要么不用，而不能只是屏蔽初始化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这个库仍然得支持自执行，因为这个被引用得如此广泛，而且假设你要 &lt;code&gt;ua.isMobile&lt;/code&gt; 这样使用，难道得每个文件内都 &lt;code&gt;const ua = new UserAgent()&lt;/code&gt; 吗？这个库原来读取了 &lt;code&gt;window.navigator.userAgent&lt;/code&gt;，为了里面的函数仍然能准确地判断运行环境，在 vm 虚拟机里通过读取 HTTP 头，提供了 &lt;code&gt;global.navigator.userAgent&lt;/code&gt; ，在模块内兼容了这种情况。&lt;/p&gt;&lt;img data-ratio=&quot;0.36663124335812963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvaukJ07t3E8jUK2u2EfibSibZAjGiaiaTPU6ebb33XJv6baXCmQu2CxbvdU1GZVhpVFu1jSuvBKgAoBqRA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1882&quot;/&gt;&lt;img data-ratio=&quot;0.47023809523809523&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvaukJ07t3E8jUK2u2EfibSibZA33FOrWcJHfqyKhkBArk6MzskxQ3yt7YWY7AfX2oe9TnLRXDTJMXibOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2016&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.7 客户端存储&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有个场景是列表头有个筛选器，当用户筛选了后，会将筛选选项存在 &lt;code&gt;localStorage&lt;/code&gt;，刷新页面后，仍然保留筛选项。对于这个场景，在服务端直出的页面当然也是需要筛选项这个信息的，否则就会出现直出的页面已经呈现给用户后。但是我们在服务端如何知道 &lt;code&gt;localStorage&lt;/code&gt; 的值呢？换个方式想，如果我们在设置 &lt;code&gt;localStorage&lt;/code&gt; 的时候，同步设置 &lt;code&gt;localStorage&lt;/code&gt; 和 &lt;code&gt;cookie&lt;/code&gt;，服务端从 cookie 取值是否就可以了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; ServerStorage {&lt;br/&gt;    getItem(key: &lt;span&gt;string&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (__SERVER__) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; getCookie(key);&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; localStorage.getItem(key);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    setItem(key: &lt;span&gt;string&lt;/span&gt;, value: &lt;span&gt;string&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (__SERVER__) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        localStorage.setItem(key, value);&lt;br/&gt;        setCookie(key, value, &lt;span&gt;365&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有个场景是基于文件夹来存储的，即用户当前处于哪个文件夹下，就存储当前文件夹下的筛选器。如果像客户端一样每个文件夹都存的话，势必会在 &lt;code&gt;cookie&lt;/code&gt; 里制造很多不必要的信息。为什么说不必要？因为其实服务端只关心上一次文件夹的筛选器，而不关心其他文件夹的，因为它只需要直出上次文件夹的内容就可以了。因此这种逻辑我们就可以特殊处理，用同一个 &lt;code&gt;key&lt;/code&gt; 来存储上次文件夹的信息。在切换文件夹的时候，设置当前文件夹的筛选器到 cookie 里。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.8 虚拟列表&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.8.1 react-virtualized&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;腾讯文档列表页为了提高滚动性能，使用 &lt;code&gt;react-virtualized&lt;/code&gt; 组件。而且为了支持动态高度，还使用了 &lt;code&gt;AutoSizer&lt;/code&gt;, &lt;code&gt;CellMeasurer&lt;/code&gt; 等组件。这些组件需要浏览器宽高等信息来动态计算列表项的高度。但是在服务端上，我们是无法知道浏览器的宽高的，导致渲染的列表高度是 0。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.48450244698205547&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvaukJ07t3E8jUK2u2EfibSibZApeiaiaZiaeNqSiadBiaGAhiaGq1ib0zTQLzPYqGODEpxqMAtrU90IbeR8wA4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1226&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.8.2 Client Hints&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然有项新技术 &lt;code&gt;Client Hints&lt;/code&gt;可以让服务端知道屏幕宽度，视口宽度和设备像素比(DPR)，但是浏览器的支持度并不好。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3345836459114779&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvaukJ07t3E8jUK2u2EfibSibZAHf5C4jR3CnvBuEjo8AI6NxEXPsWg4ib7XIy03J0p3MSFwz4YQLZvcDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2666&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即使有 polyfill，用 JS 读取这些信息，存在 cookie 里。但是我们想如果用户第一次访问呢？势必会没有这些信息。再者即使是移动端宽高固定的情况，如果是旋转屏幕呢？更不用说 PC 端可以随意调节浏览器宽高了。因此这完全不是完美的解决方案。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.8.3 使用 CSS 自适应&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们将虚拟列表渲染的项单独渲染而不通过虚拟列表，用 CSS 自适应宽高呢？反正首屏直出的情况下是没有交互能力的，也就没有滚动加载列表的情况。甚至因为首屏不可滚动，我们在移动端还可以减少首屏列表项的数目以此来减少 CGI 数据。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;function VirtualListServer&amp;lt;T&amp;gt;(props: VirtualListProps&amp;lt;T&amp;gt;) {&lt;br/&gt;    return (&lt;br/&gt;        &amp;lt;div className=&quot;pc-virtual-list&quot;&amp;gt;&lt;br/&gt;            {&lt;br/&gt;                props.list.map((item, index) =&amp;gt; (props.itemRenderer &amp;amp;&amp;amp; props.itemRenderer(props.list[index], index)))&lt;br/&gt;            }&lt;br/&gt;            {!props.bottomText&lt;br/&gt;                ? null&lt;br/&gt;                : &amp;lt;div className=&quot;pc-virtual-list-loading&quot; style={{ height: 60 }}&amp;gt;&lt;br/&gt;                    {props.bottomText}&lt;br/&gt;                &amp;lt;/div&amp;gt;&lt;br/&gt;            }&lt;br/&gt;        &amp;lt;/div&amp;gt;&lt;br/&gt;    );&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;const VirtualList = __SERVER__ ? VirtualListServer : VirtualListClient;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.9 不可序列化对象&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本来这个小章节算是原 CSR 代码里实现的问题，但是涉及的逻辑较多，因此也只是在运用数据前来做转换。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面说过我们会往文档里以全局变量的方式注入 state，怎么注入？其实就是用 &lt;code&gt;JSON.stringify&lt;/code&gt; 将 state 序列化成字符串，如果这时候 state 里包含了函数呢？那么函数就会丢失。（不过看到下一小章节你会发现 &lt;code&gt;serialize-javascript&lt;/code&gt; 是有保留函数的选项的，只是我觉得 state 应该是纯数据，正确的做法应该是将函数从 state 里移除，两种方式自由取舍吧）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如这里的 pageRange，里面包含了 &lt;code&gt;add&lt;/code&gt;，&lt;code&gt;getNext&lt;/code&gt; 等方法，在数据注入到客户端后，就只剩下纯数据：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; getDefaultList = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; ({&lt;br/&gt;    list: [],&lt;br/&gt;    loading: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;    section: &lt;span&gt;false&lt;/span&gt;,&lt;br/&gt;    allObtained: &lt;span&gt;false&lt;/span&gt;,&lt;br/&gt;    pageRange: &lt;span&gt;new&lt;/span&gt; PageRange({ start: -listLimit, limit: listLimit }),&lt;br/&gt;    scrollTop: &lt;span&gt;0&lt;/span&gt;,&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在客户端使用的时候，还需要将 pageRange 转成新的实例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;pageRangeTransform&lt;/span&gt;(&lt;span&gt;opt: PageRange&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; opt.add === &lt;span&gt;&#x27;function&#x27;&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; opt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; PageRange(opt);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.10 引用类型的 state&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还遇到一个比较有趣的问题如下图：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;db 是一个内存上的数据对象，用来存储列表等相关的数据的，而 state 里的列表其实只是 db 里的一个引用；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在更新列表数据的时候，发送了 CGI，其实是更新了 db 里的列表数据；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在更新列表项是否可编辑的数据的时候，其实也是更改的 db 里的数据，然后通过一个 forceTime 来强制 state 更新视图；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7579425113464447&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvaukJ07t3E8jUK2u2EfibSibZAPia1Xibd16E74Kmbmvhe3VXpwulGRPw55WqBm4OeQ7Y2MX06dw4oJCMQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1322&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这对于加入了 SSR 的 CSR 来说会有几点问题：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;因为我们复用了服务端注入的数据，省去了 CGI 的步骤，在客户端上也就没有往 db 里添加列表数据；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;state 里的列表数据不再是引用的 db 里的数据，因此更新 forceTime，是强制不了 state 更新视图的；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两个典型的 Bug（代码里写了注释，应该不用再解释了）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/*&lt;br/&gt;* 如果有 preloadState，需要调用 db 来设置一下数据。有一个问题是：&lt;br/&gt;* 1. CSR 列表的 0-30 的数据是通过 API 拉取的，在 API 里通过 db 设置了 0-30 的数据&lt;br/&gt;* 2. SSR 0-30 的数据是通过 preloadedState 注入到客户端的，没有通过 db 设置 0-30 的数据&lt;br/&gt;* 3. 列表往下拉的时候，通过 CGI 拉取 30-60 的数据，这时候通过 db 合并，会丢失 0-30 的数据&lt;br/&gt;*/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (preloadedState) {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; db = getDBSingleton();&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (preloadedState.list &amp;amp;&amp;amp; preloadedState.list.recent) {&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; transedList = transformForInitialState(preloadedState.list.recent.list);&lt;br/&gt;        preloadedState.list.recent.list = db.register(ListTypeInStore.recent, transedList);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (preloadedState.folderUI &amp;amp;&amp;amp; preloadedState.folderUI.viewStack.length) {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; folderData = preloadedState.folderUI.viewStack[&lt;span&gt;0&lt;/span&gt;];&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; { folderID, list } = folderData;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (list &amp;amp;&amp;amp; list.length) {&lt;br/&gt;        &lt;span&gt;/*&lt;br/&gt;        * 为什么要用 db.register 返回的 list 重新赋值？因为客户端上的 state 引用的是 db 里的数据，在调用&lt;br/&gt;        * forceUpdate 的时候只是更新了个时间，如果这里不保持一致，在调用 forceUpdate 的时候就不会更新了。&lt;br/&gt;        * 典型的 Bug，按了右键重命名无效&lt;br/&gt;        */&lt;/span&gt;&lt;br/&gt;        folderData.list = registerDBForInitialState(folderID, transformForInitialState(list));&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.11 安全&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用字符串拼接的方式插入初始化的 state，需要转义而避免 xss 攻击。我们可以使用 &lt;code&gt;serialize-javascript&lt;/code&gt; 库来转义数据。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; serialize &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;serialize-javascript&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;injectDataToClient&lt;/span&gt;(&lt;span&gt;key: &lt;span&gt;string&lt;/span&gt;, data: &lt;span&gt;any&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; serializedData = serialize(data, {&lt;br/&gt;        isJSON: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;        ignoreFunction: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;`&amp;lt;script&amp;gt;window[&quot;&lt;span&gt;${key}&lt;/span&gt;&quot;] = &lt;span&gt;${serializedData}&lt;/span&gt;&amp;lt;/script&amp;gt;`&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;getStateScriptTag&lt;/span&gt;(&lt;span&gt;initialState: &lt;span&gt;any&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; injectDataToClient(&lt;span&gt;&#x27;__initial_state__&#x27;&lt;/span&gt;, initialState);&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8810289389067524&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvaukJ07t3E8jUK2u2EfibSibZAkAvglIoQcibNrQH6EhC2kOCbYtH57upduiaRsOvNfZKbUwM1ylutg1pg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1244&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.12 服务端路由&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于单页面来说，使用 &lt;code&gt;react-router&lt;/code&gt; 来管理路由，服务端也需要直出相对于的组件。需要做的只是将路由组件换成 &lt;code&gt;StaticRouter&lt;/code&gt; ，通过 &lt;code&gt;localtion&lt;/code&gt;提供页面地址和 &lt;code&gt;context&lt;/code&gt; 存储上下文 。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;import { StaticRouter as Router } from &#x27;react-router-dom&#x27;;&lt;br/&gt;&lt;br/&gt;(async () =&amp;gt; {&lt;br/&gt;    const routerContext = {};&lt;br/&gt;&lt;br/&gt;    const bodyHtml = ReactDOMServer.renderToString(&lt;br/&gt;        &amp;lt;Router basename={&#x27;/desktop&#x27;} location={TSRENV.href} context={routerContext} &amp;gt;&lt;br/&gt;            &amp;lt;Provider store={store}&amp;gt;&lt;br/&gt;                &amp;lt;ServerIndex /&amp;gt;&lt;br/&gt;            &amp;lt;/Provider&amp;gt;&lt;br/&gt;        &amp;lt;/Router&amp;gt;&lt;br/&gt;    );&lt;br/&gt;})();&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. 运行环境&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.1 网络&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.1.1 网络请求&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当浏览器发起 CGI 请求，形如 https://docs.qq.com/cgi-bin/xxx，不仅需要解析 DNS，还需要建立 HTTPS 链接，还要再经过公司的统一网关接入层。如果我们的 SSR 服务同部署在腾讯云上，是否有请求出去绕一圈再绕回来的感觉？因为我们的服务都接入了 L5（服务发现和负载均衡），那么我们可以通过解析 L5 获得 IP 和端口，以 HTTP 发起请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以兼容 L5 的北极星 SDK 来解析（cl5 需要依赖环境，在我使用的基础镜像 tlinux-mini 上会有错误）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PS: Axios 发送 HTTPS 请求会报错，因此在 Node 端换成了 Got，方便本地开发。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; { Consumer } = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;@tencent/polaris&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; consumer = &lt;span&gt;new&lt;/span&gt; Consumer();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;async&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;resolve&lt;/span&gt;(&lt;span&gt;namespace, service&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; response = &lt;span&gt;await&lt;/span&gt; consumer.select(namespace, service);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (response) {&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;instance&lt;/span&gt;: { host, port },&lt;br/&gt;        } = response;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;`&lt;span&gt;${host}&lt;/span&gt;:&lt;span&gt;${port}&lt;/span&gt;`&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是，北极星的第一次解析比较耗时，大概 &lt;code&gt;200ms&lt;/code&gt; 的样子，因此应该在应用启动的时候就调用解析一次，后续再解析就会是 &lt;code&gt;1~3ms&lt;/code&gt; 了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里还有个点是我们应该请求哪个 L5？假设有两个 CGI，doclist 和 userInfo，我们是解析它们各自的 L5，通过 OIDB 的协议请求吗？考虑三个方面：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这里询问了文档后台，通过 OIDB 并没有比通过 HTTP 协议快多少；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我们需要一直维护 CGI 和 L5 的对应关系，如果后台重构，信息同步不到位，换了新的 L5，服务将会挂掉；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;没有更新 xsrf 的逻辑；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好在文档还有个统一的接入层 tsw，因此我们其实只需要解析接入层 tsw 的 L5，将请求都发往它就可以了。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.1.2 cookie&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 SSR 代发起 CGI 请求，不仅需要从请求取出客户端传递过来的 cookie 来使用，在我们的 tsw 服务上，还会验证 csrf，因此 SSR 发出 CGI 请求后，可能 tsw 会更新 csrf，因此还需要将 CGI 请求返回的 &lt;code&gt;set-cookie&lt;/code&gt; 再设置回客户端。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; setCookie = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;set-cookie-parser&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;setCookies&lt;/span&gt;(&lt;span&gt;cookis&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; parsedCookies = setCookie.parse(cookis || []) || [];&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (ctx.headerSent) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    parsedCookies.map(&lt;span&gt;(&lt;span&gt;cookieInfo&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; { name, value, path, domain, expires, secure, httpOnly, sameSite } = cookieInfo;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            ctx.cookies.set(name, value, {&lt;br/&gt;                &lt;span&gt;overwrite&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;                path,&lt;br/&gt;                domain,&lt;br/&gt;                expires,&lt;br/&gt;                secure,&lt;br/&gt;                httpOnly,&lt;br/&gt;                sameSite,&lt;br/&gt;            });&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (err) {&lt;br/&gt;            logger.error(err);&lt;br/&gt;        }&lt;br/&gt;    });&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;overwrite&lt;/code&gt; 设置为 true 是因为当我们有多个 CGI 请求，所返回的同名 &lt;code&gt;set-cookie&lt;/code&gt;如果不覆盖的话，会使得 SSR 返回的 HTTP 头很大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还要说说 &lt;code&gt;secure&lt;/code&gt; 参数。这个参数表示 cookie 是否只能是 HTTPS 下传输。我们的应用是在 tsw 服务之后的，一般来讲也都会在 nginx 之后以 http 提供服务。那么我们就设置不了这个 &lt;code&gt;secure&lt;/code&gt; 参数。如果要设置的话，需要有两步：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;初始化 koa 的时候，设置 proxy；&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; app = &lt;span&gt;new&lt;/span&gt; Koa({ &lt;span&gt;proxy&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt; })&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;koa 前面的代理设置 &lt;code&gt;X-Forwarded-Proto&lt;/code&gt; 头部，表明是工作在 HTTPS 模式下；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是实际上在我的服务里没有收到这个头部，因此仍然会报错，由于我们没法去改 tsw，也很清楚地知道我们是工作在代理之后，有个解决方案：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;this&lt;/span&gt;.app.use(&lt;span&gt;async&lt;/span&gt; (ctx, next) =&amp;gt; {&lt;br/&gt;    ctx.cookies.secure = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;await&lt;/span&gt; next();&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.2 并发和上下文隔离&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来考虑这样一种情况：&lt;/p&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvaukJ07t3E8jUK2u2EfibSibZA8DcUcF33Pumgibe3wnlXAf3yH05o2pa70069vEF6bGCt3cl0BSFtVKQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1120&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当有两个请求 A 和 B 一前一后到达 Server，在经过一大串的异步逻辑之后。到达后面的那个处理逻辑的时候，它怎么知道它在处理哪个请求？方法当然是有：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;把 koa 的 &lt;code&gt;ctx&lt;/code&gt; 一层一层传递，只要有涉及到具体请求的函数，都传递一下 &lt;code&gt;ctx&lt;/code&gt;（是不是疯狂？）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;或者把 ctx 存在 state 里，需要 &lt;code&gt;ctx&lt;/code&gt; 的话从 state 里取（先不说这违反了 state 里应该放纯数据的原则，如果是一些工具函数呢？比如 &lt;code&gt;getCookie&lt;/code&gt; 这样的函数，让它的 cookie 从哪里取？想想是不是头大？）；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此我们需要想个办法，将 A 和 B 的请求隔离开来。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.2.1 cluster 和 worker&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果说要隔离请求，我们可以有 &lt;code&gt;cluster&lt;/code&gt; 模块提供进程粒度的隔离，也可以通过 &lt;code&gt;worker_threads&lt;/code&gt; 模块提供线程粒度的隔离。但是难道我们一个进程和一个线程同时只能处理一个请求，只有一个请求完全返回结果后才能处理下一个吗？这显然是不可能的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是为了下面的错误捕获问题，我确实用 &lt;code&gt;worker_threads&lt;/code&gt; + &lt;code&gt;vm&lt;/code&gt; 尝试了好几种方法，虽然最后都放弃了。并且因为使用 &lt;code&gt;worker_threads&lt;/code&gt; 可以共享线程数据的优点在这个场景下并没有多大的应用场景，反而是 &lt;code&gt;cluster&lt;/code&gt; 可以共享 TCP 端口，最后是用 &lt;code&gt;cluster&lt;/code&gt; + &lt;code&gt;vm&lt;/code&gt; ，不过这是后话了。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.2.2 domain&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上下文隔离的技术，从 QQ 空间团队 tsw 那里学了个比较骚的方法，主要有两个关键点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;process.domain 总是指向当前异步流程的上下文，因此可以将需要的数据挂载到 process.domian 上；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用 &lt;code&gt;Object.defineProperty&lt;/code&gt; 设置数据的 getter 和 setter 函数，保证操作到的是 process.domain 上的对应数据；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用简短的代码演示就是这样的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; domain = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;domain&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;Object&lt;/span&gt;.defineProperty(global, &lt;span&gt;&#x27;myVar&#x27;&lt;/span&gt;, {&lt;br/&gt;    &lt;span&gt;get&lt;/span&gt;: &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; process.domain.myVar,&lt;br/&gt;    &lt;span&gt;set&lt;/span&gt;: &lt;span&gt;(&lt;span&gt;value&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        process.domain.myVar = value;&lt;br/&gt;    },&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; handler = &lt;span&gt;(&lt;span&gt;label&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`&lt;span&gt;${label}&lt;/span&gt;: &lt;span&gt;${global.myVar}&lt;/span&gt;`&lt;/span&gt;);&lt;br/&gt;    }, (&lt;span&gt;1&lt;/span&gt; + &lt;span&gt;Math&lt;/span&gt;.random() * &lt;span&gt;4&lt;/span&gt;) * &lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;3&lt;/span&gt;; i++) {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; d = domain.create();&lt;br/&gt;    d.run(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        global.myVar = i;&lt;br/&gt;        handler(&lt;span&gt;`test-&lt;span&gt;${i}&lt;/span&gt;`&lt;/span&gt;);&lt;br/&gt;    });&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// test-1: 1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// test-0: 0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// test-2: 2&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这个方案存在什么样的问题？&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;domain 没法保证虽然对象在它 run 函数里初始化，process.domain 一定有值，也可能是 &lt;code&gt;undefined&lt;/code&gt;；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;requre 过的文件，被 cache 了，需要执行清除缓存的操作，重新 require。虽然可以用 defineProperty 来定义值，但是如果有的模块是 &lt;code&gt;const moduleVar = global.myVar; module.exports = moduleVar;&lt;/code&gt; 没有重新执行的话，导出的值将是错误的；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.3 vm&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上下文隔离，我们还可以用 vm 来做。（然后我们的挑战就变成了怎么把十几万行的代码放在 vm 里跑，为什么需要把十几万行代码都放进去？因为后面会说到被 require 的模块里访问 global 的问题，虽然后面的后面解决了这个问题）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;vm 的一个基本使用姿势是这样的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; vm = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;vm&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; code = &lt;span&gt;&#x27;console.log(myVar)&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;vm.runInNewContext(code, {&lt;br/&gt;    &lt;span&gt;myVar&lt;/span&gt;: &lt;span&gt;&#x27;AlloyTeam&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;,&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// AlloyTeam&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;功能是不是很像 eval?，使用 eval 的话：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; num = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;eval&lt;/span&gt;(&lt;span&gt;&#x27;num ++&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(num);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 2&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 Function 的话：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@file &lt;/span&gt;function.js&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;global.num = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Function&lt;/span&gt;(&lt;span&gt;&#x27;step&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;num += step&#x27;&lt;/span&gt;))(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(num);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// node function.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// &amp;gt;2&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;细心的读者可能会发现，&lt;code&gt;Function&lt;/code&gt; 的例子里，我写的是 &lt;code&gt;global.num = 1&lt;/code&gt; 而不是 &lt;code&gt;let num = 1&lt;/code&gt;，这是为什么？&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;由 &lt;code&gt;Function&lt;/code&gt; 构造器创建的函数不会创建当前环境的闭包，而是被创建在全局环境里；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我这里的代码写在 &lt;code&gt;function.js&lt;/code&gt; 文件里，是当做一个模块被运行的，是在模块的作用域里；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;基于以上 2 点，&lt;code&gt;Function&lt;/code&gt; 里的代码能访问到的变量就是 &lt;code&gt;global&lt;/code&gt; 和它的局部变量 &lt;code&gt;step&lt;/code&gt; ，如果写成 &lt;code&gt;let num = 1&lt;/code&gt; 将会报错；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 evel 和 Function 可以做到吗？感觉理论上像是可以的，假设我们给每个请求分配 ID，使用 Object.defineProperty 来定义数据的存取。但是我没有试过，而是使用成熟的 vm 模块，好奇的读者可以试一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外因为我们并没有运行外部的代码，要在 vm 里跑的都是业务代码，因此不关心 vm 的进程逃逸问题，如果有这方面担忧的可以用 vm2。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.3.1 global&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在 Node 环境下访问全局变量，有两种方式：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    a = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    global.b = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;})();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(a);&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(b);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 2&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在 vm 里，是没有 global 的，考察以下代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; vm = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;vm&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;global.a = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; code = &lt;span&gt;`&lt;br/&gt;    console.log(typeof global);&lt;br/&gt;    console.log(typeof a);&lt;br/&gt;`&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;vm.runInNewContext(code, {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;,&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// undefined&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// undefined&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此假设我们要支持代码里能够以 &lt;code&gt;global.myVar&lt;/code&gt; 和 &lt;code&gt;myVar&lt;/code&gt; 两种方式来访问上下文里的全局变量的话，就要构造出一个 global 变量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上下文的全局变量默认是空的，不仅 global 没有，还有一些函数也没有，我们来看看最终构造出的上下文是都有什么：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;async&lt;/span&gt; getVMContext(renderJSFile) {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; pathInfo = path.parse(renderJSFile);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 模块系统的变量&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; moduleGlobal = {&lt;br/&gt;        &lt;span&gt;__filename&lt;/span&gt;: renderJSFile,&lt;br/&gt;        &lt;span&gt;__dirname&lt;/span&gt;: pathInfo.dir,&lt;br/&gt;    };&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; commonContext = {&lt;br/&gt;        Buffer,&lt;br/&gt;        process,&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;require&lt;/span&gt;,&lt;br/&gt;        exports,&lt;br/&gt;        &lt;span&gt;module&lt;/span&gt;,&lt;br/&gt;    };&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/* 业务上定义的的全局对象，运行的时候会重新赋值&lt;br/&gt;    * {&lt;br/&gt;    *     window: undefined,&lt;br/&gt;    *     navigator: {&lt;br/&gt;    *         userAgent: &#x27;&#x27;,&lt;br/&gt;    *     },&lt;br/&gt;    *     location: {&lt;br/&gt;    *         search: &#x27;&#x27;,&lt;br/&gt;    *     },&lt;br/&gt;    * }&lt;br/&gt;    */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; browserGlobal = renderConfig.vmGlobal(renderJSFile);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; vm.createContext({&lt;br/&gt;        ...commonContext,&lt;br/&gt;        ...moduleGlobal,&lt;br/&gt;        ...global,&lt;br/&gt;        ...browserGlobal,&lt;br/&gt;        &lt;span&gt;// 重写 global 循环变量&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;global&lt;/span&gt;: {&lt;br/&gt;            ...browserGlobal,&lt;br/&gt;        },&lt;br/&gt;    });&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.3.2 require&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面说到 vm 的上下文默认是空的，然后我们给它传递了 module，exports，require，那么它能 require 外部模块了，但是被 require 的模块如果访问 global，会是 vm 里我们创建的 global，还是宿主环境下的 global 呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们有个文件 &lt;code&gt;vm-global-required.js&lt;/code&gt; 是要被 require 的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; myVar = global.myVar;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;[required-file]:&#x27;&lt;/span&gt;, myVar);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还有个文件是宿主环境：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; vm = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;vm&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;global.myVar = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; code = &lt;span&gt;`&lt;br/&gt;    console.log(&quot;[vm-host]:&quot;, global.myVar);&lt;br/&gt;    require(&#x27;./vm-global-required&#x27;);&lt;br/&gt;`&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;vm.runInNewContext(code, {&lt;br/&gt;    &lt;span&gt;global&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;myVar&lt;/span&gt;: &lt;span&gt;2&lt;/span&gt;,&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;require&lt;/span&gt;,&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行代码，结果是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// [vm-host]: 2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// [required-file]: 1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到被 require 的模块所访问的 global 并不是 vm 定义的上下文，而是宿主环境的 global。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.3.3 代码编译缓存&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以 vm 创建的代码沙箱是需要编译的，我们不可能每个请求过来都重复编译，因此可以在启动的时候就提前编译缓存：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;compilerVMByFile(renderJSFile) {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; scriptContent = fileManage.getJSContent(renderJSFile);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!scriptContent) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; scriptInstance = &lt;span&gt;new&lt;/span&gt; vm.Script(scriptContent, {&lt;br/&gt;        &lt;span&gt;filename&lt;/span&gt;: renderJSFile,&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; scriptInstance;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;getVMInstance(renderJSFile) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;.vmInstanceCache[renderJSFile]) {&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; vmInstance = &lt;span&gt;this&lt;/span&gt;.compilerVMByFile(renderJSFile);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.vmInstanceCache[renderJSFile] = vmInstance;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.vmInstanceCache[renderJSFile];&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是其实 v8 编译是不编译函数体的，好在可以设置一下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; v8 = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;v8&#x27;&lt;/span&gt;);&lt;br/&gt;v8.setFlagsFromString(&lt;span&gt;&#x27;--no-lazy&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（编译部分还尝试过 &lt;code&gt;createCachedData&lt;/code&gt;，可以详见以下错误捕获的使用 filename 章节）&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.3.4 超时&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;vm 运行的时候可以设置 &lt;code&gt;timeout&lt;/code&gt; 参数控制超时，当超过时间后会报错：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; vm = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;vm&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; vmFunc = &lt;span&gt;new&lt;/span&gt; vm.Script(&lt;span&gt;`&lt;br/&gt;    while(1) {}&lt;br/&gt;`&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    vmFunc.runInNewContext({&lt;br/&gt;        http,&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;,&lt;br/&gt;    }, {&lt;br/&gt;        &lt;span&gt;timeout&lt;/span&gt;: &lt;span&gt;100&lt;/span&gt;,&lt;br/&gt;    })&lt;br/&gt;} &lt;span&gt;catch&lt;/span&gt; (err) {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;vm-timeout&#x27;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// vm-timeout&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是它的超时真的有效吗？我们来做个试验。如以下代码：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;设置了 &lt;code&gt;timeout&lt;/code&gt; 是 100；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用 process 监听了错误，如果超时触发了错误，process 就会捕获到错误输出出来；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;/timeout-get&lt;/code&gt; 在 2000ms 后才返回结果；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; Koa = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;koa&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; Router = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;koa-router&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; vm = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;vm&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; http = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;http&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; app = &lt;span&gt;new&lt;/span&gt; Koa();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; router = &lt;span&gt;new&lt;/span&gt; Router();&lt;br/&gt;&lt;br/&gt;router.get(&lt;span&gt;&#x27;/timeout-get&#x27;&lt;/span&gt;, &lt;span&gt;async&lt;/span&gt; (ctx) =&amp;gt; {&lt;br/&gt;    &lt;span&gt;await&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;            ctx.body = &lt;span&gt;&#x27;OK&#x27;&lt;/span&gt;;&lt;br/&gt;            resolve();&lt;br/&gt;        }, &lt;span&gt;2000&lt;/span&gt;);&lt;br/&gt;    });&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;app.use(router.routes()).use(router.allowedMethods());&lt;br/&gt;&lt;br/&gt;app.listen(&lt;span&gt;3000&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;process.on(&lt;span&gt;&#x27;unhandledRejection&#x27;&lt;/span&gt;, (err) =&amp;gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;unhandledRejection&#x27;&lt;/span&gt;, err);&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;process.on(&lt;span&gt;&#x27;uncaughtException&#x27;&lt;/span&gt;, (err) =&amp;gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;uncaughtException&#x27;&lt;/span&gt;, err);&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.time(&lt;span&gt;&#x27;http-cost&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; vmFunc = &lt;span&gt;new&lt;/span&gt; vm.Script(&lt;span&gt;`&lt;br/&gt;    http.get(&#x27;http://127.0.0.1:3000/timeout-get&#x27;, (res) =&amp;gt; {&lt;br/&gt;        const { statusCode } = res;&lt;br/&gt;&lt;br/&gt;        console.log(&#x27;statusCode:&#x27;, statusCode);&lt;br/&gt;        console.timeEnd(&#x27;http-cost&#x27;);&lt;br/&gt;        process.exit(0);&lt;br/&gt;    })`&lt;/span&gt;&lt;br/&gt;);&lt;br/&gt;&lt;br/&gt;vmFunc.runInNewContext({&lt;br/&gt;    http,&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;,&lt;br/&gt;    process,&lt;br/&gt;}, {&lt;br/&gt;    &lt;span&gt;timeout&lt;/span&gt;: &lt;span&gt;100&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;microtaskMode&lt;/span&gt;: &lt;span&gt;&#x27;afterEvaluate&#x27;&lt;/span&gt;,&lt;br/&gt;})&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;vm-executed&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果是什么呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;vm-executed&lt;br/&gt;statusCode: 200&lt;br/&gt;http-cost: 2016.098ms&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说明 vm 的这个 timeout 参数在我们的场景下是不一定有效的，因此我们还需要在宿主环境额外设置超时返回。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.4 错误捕获&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的 SSR 和普通的后台服务最大的区别在于什么？我想是在于我们不允许返回空内容。后台的 CGI 服务在错误的时候，返回个错误码，有前端来以更友好的方式展示错误信息。但是 SSR 的服务，即使错误了，也需要返回内容给用户，否则就是白屏。因此错误的捕获显得尤为重要。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结一下背景的话：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;vm 所执行的代码可能来自于第三方，但是整个项目是提供基础镜像，第三方基于镜像自行部署的，因此不关心 vm 里的代码安全问题，不用用到 vm2&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;vm 里的代码是有可能出错的，错误可能来自于同步代码、异步代码或者未处理的 Promise 错误&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;vm 代码是异步并行的，假设每次执行 vm 代码都有一个 id&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;vm 里的代码即使出错，也必须要知道是哪个 id 的 vm 代码执行出错了，来执行兜底的策略&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.4.1 process 捕获&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 node 里，如果要捕获未知的错误，我们当然可以用 process 来捕获&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;process.on(&lt;span&gt;&#x27;unhandledRejection&#x27;&lt;/span&gt;, (err) =&amp;gt; {&lt;br/&gt;    &lt;span&gt;// do something&lt;/span&gt;&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;process.on(&lt;span&gt;&#x27;uncaughtException&#x27;&lt;/span&gt;, (err) =&amp;gt; {&lt;br/&gt;    &lt;span&gt;// do something&lt;/span&gt;&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这代码不仅可以捕获同步、异步错误，也能捕获 Promise 错误。但同时，我们从 err 对象上也获取不了出错时候的上下文信息。像背景里的要求，就不知道是哪个 id 的 vm 出错了&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.4.2 try...catch&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果以 vm 来执行代码的话，我们大可以在代码的外部包裹 try...catch 来捕获异常。看下面的例子，try...catch 捕获到了错误，错误就没再冒泡到 process。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; vm = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;vm&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;process.on(&lt;span&gt;&#x27;uncaughtException&#x27;&lt;/span&gt;, (err) =&amp;gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;[uncaughtException]:&#x27;&lt;/span&gt;, err);&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; script = &lt;span&gt;new&lt;/span&gt; vm.Script(&lt;span&gt;`&lt;br/&gt;    try {&lt;br/&gt;        throw new Error(&#x27;from vm&#x27;)&lt;br/&gt;    } catch (err) {&lt;br/&gt;        console.log(err)&lt;br/&gt;    }&lt;br/&gt;`&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;script.runInNewContext({ &lt;span&gt;Error&lt;/span&gt;, &lt;span&gt;console&lt;/span&gt; });&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Error: from vm&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//     at evalmachine.&amp;lt;anonymous&amp;gt;:3:15&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.4.3 异步错误&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;改写上面的例子，将错误在异步函数里抛出，try...catch 捕获不到错误，错误冒泡到 process，被 uncaughtException 事件捕获到&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; vm = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;vm&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;process.on(&lt;span&gt;&#x27;uncaughtException&#x27;&lt;/span&gt;, (err) =&amp;gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;[uncaughtException]:&#x27;&lt;/span&gt;, err);&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;process.on(&lt;span&gt;&#x27;unhandledRejection&#x27;&lt;/span&gt;, (err) =&amp;gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;[unhandledRejection]:&#x27;&lt;/span&gt;, err);&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; script = &lt;span&gt;new&lt;/span&gt; vm.Script(&lt;span&gt;`&lt;br/&gt;    try {&lt;br/&gt;        setTimeout(() =&amp;gt; {&lt;br/&gt;            throw new Error(&#x27;from vm&#x27;)&lt;br/&gt;        })&lt;br/&gt;    } catch (err) {&lt;br/&gt;        console.log(err)&lt;br/&gt;    }&lt;br/&gt;`&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;script.runInNewContext({ &lt;span&gt;Error&lt;/span&gt;, &lt;span&gt;console&lt;/span&gt;, setTimeout });&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// [uncaughtException]: Error: from vm&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//     at Timeout._onTimeout (evalmachine.&amp;lt;anonymous&amp;gt;:4:19)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那有什么办法捕获异步错误吗？办法还是有的，node 里有个 domain 模块，可以用来捕获异步错误。（虽然已经标记为废弃状态，但是已经用 async_hooks 重写了，意味着即使真的被废弃，也能自己实现一个）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;继续改写上面的例子，将 vm 放在 domain 里执行，可以看到错误被 domain 捕获到了&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; vm = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;vm&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; domain = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;domain&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;process.on(&lt;span&gt;&#x27;uncaughtException&#x27;&lt;/span&gt;, (err) =&amp;gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;[uncaughtException]:&#x27;&lt;/span&gt;, err);&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;process.on(&lt;span&gt;&#x27;unhandledRejection&#x27;&lt;/span&gt;, (err) =&amp;gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;[unhandledRejection]:&#x27;&lt;/span&gt;, err);&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; script = &lt;span&gt;new&lt;/span&gt; vm.Script(&lt;span&gt;`&lt;br/&gt;    try {&lt;br/&gt;        setTimeout(() =&amp;gt; {&lt;br/&gt;            throw new Error(&#x27;from vm&#x27;)&lt;br/&gt;        })&lt;br/&gt;    } catch (err) {&lt;br/&gt;        console.log(err)&lt;br/&gt;    }&lt;br/&gt;`&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; d = domain.create();&lt;br/&gt;&lt;br/&gt;d.on(&lt;span&gt;&#x27;error&#x27;&lt;/span&gt;, (err) =&amp;gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;[domain-error]:&#x27;&lt;/span&gt;, err);&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;d.run(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    script.runInNewContext({ &lt;span&gt;Error&lt;/span&gt;, &lt;span&gt;console&lt;/span&gt;, setTimeout });&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// [domain-error]: Error: from vm&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//     at Timeout._onTimeout (evalmachine.&amp;lt;anonymous&amp;gt;:4:19)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.4.4 Promise 错误&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是假如将上一个例子的 vm 代码改成 Promise 执行呢？domain 捕获不到错误，错误冒泡到 process 上&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; vm = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;vm&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; domain = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;domain&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;process.on(&lt;span&gt;&#x27;uncaughtException&#x27;&lt;/span&gt;, (err) =&amp;gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;[uncaughtException]:&#x27;&lt;/span&gt;, err);&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;process.on(&lt;span&gt;&#x27;unhandledRejection&#x27;&lt;/span&gt;, (err) =&amp;gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;[unhandledRejection]:&#x27;&lt;/span&gt;, err);&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; script = &lt;span&gt;new&lt;/span&gt; vm.Script(&lt;span&gt;`&lt;br/&gt;    Promise.resolve().then(() =&amp;gt; {&lt;br/&gt;        throw new Error(&#x27;notExistPromiseFunc&#x27;)&lt;br/&gt;    })&lt;br/&gt;`&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; d = domain.create();&lt;br/&gt;&lt;br/&gt;d.on(&lt;span&gt;&#x27;error&#x27;&lt;/span&gt;, (err) =&amp;gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;[domain-error]:&#x27;&lt;/span&gt;, err);&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;d.run(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    script.runInNewContext({ &lt;span&gt;Error&lt;/span&gt;, &lt;span&gt;console&lt;/span&gt;, setTimeout });&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// [unhandledRejection]: Error: notExistPromiseFunc&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//     at evalmachine.&amp;lt;anonymous&amp;gt;:3:15&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么？node 文档里是这么说的&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Domains will not interfere with the error handling mechanisms for promises. In other words, no &lt;code&gt;&#x27;error&#x27;&lt;/code&gt; event will be emitted for unhandled &lt;code&gt;Promise&lt;/code&gt; rejections.&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那有什么办法吗？这里想了两个比较骚的写法。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.4.4.1 使用 filename&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道 vm 在执行的时候，是可以提供一个 &lt;code&gt;filename&lt;/code&gt; 属性，在错误的时候，会被添加到错误堆栈内。默认值是 &lt;code&gt;&#x27;evalmachine.&amp;lt;anonymous&amp;gt;&#x27;&lt;/code&gt; 也就是我们上面的错误经常看到的第二行代码错误的位置。这就带来了操作的空间。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; vm = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;vm&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; markStart = &lt;span&gt;&#x27;&amp;lt;vm-error&amp;gt;&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; markEnd = &lt;span&gt;&#x27;&amp;lt;/vm-error&amp;gt;&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; getContext = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt;&lt;br/&gt;    vm.createContext({&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;,&lt;br/&gt;        process,&lt;br/&gt;        setTimeout,&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; parseErrorStack = &lt;span&gt;(&lt;span&gt;err&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; errorStr = err.stack;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; valueStart = errorStr.indexOf(markStart);&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; valueEnd = errorStr.lastIndexOf(markEnd);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (valueStart !== &lt;span&gt;-1&lt;/span&gt; &amp;amp;&amp;amp; valueEnd !== &lt;span&gt;-1&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; errorStr.slice(valueStart + markStart.length, valueEnd);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;[parse-error]&#x27;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;process.on(&lt;span&gt;&#x27;unhandledRejection&#x27;&lt;/span&gt;, (err) =&amp;gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;[unhandledRejection]:&#x27;&lt;/span&gt;, parseErrorStack(err));&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;process.on(&lt;span&gt;&#x27;uncaughtException&#x27;&lt;/span&gt;, (err) =&amp;gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;[uncaughtException]:&#x27;&lt;/span&gt;, parseErrorStack(err));&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; getScript = &lt;span&gt;(&lt;span&gt;flag&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; filename = &lt;span&gt;`&lt;span&gt;${markStart}&lt;/span&gt;&lt;span&gt;${flag}&lt;/span&gt;&lt;span&gt;${markEnd}&lt;/span&gt;`&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; vm.Script(&lt;br/&gt;        &lt;span&gt;`&lt;br/&gt;        (() =&amp;gt; {&lt;br/&gt;            new Promise((resolve, reject) =&amp;gt; {&lt;br/&gt;                setTimeout(() =&amp;gt; {&lt;br/&gt;                    reject(new Error(&#x27;&lt;span&gt;${flag}&lt;/span&gt;&#x27;));&lt;br/&gt;                }, 100)&lt;br/&gt;            })&lt;br/&gt;        })()&lt;br/&gt;    `&lt;/span&gt;,&lt;br/&gt;        { filename }&lt;br/&gt;    );&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;(&lt;span&gt;&lt;span&gt;async&lt;/span&gt; (&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;3&lt;/span&gt;; i++) {&lt;br/&gt;        &lt;span&gt;await&lt;/span&gt; getScript(i).runInContext(getContext());&lt;br/&gt;    }&lt;br/&gt;})();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// [unhandledRejection]: 0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// [unhandledRejection]: 1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// [unhandledRejection]: 2&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看下上面的代码结构，我们做了几件事：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在 vm 代码编译的时候，以 &lt;code&gt;vm-error&lt;/code&gt; 标识符标记了我们要传递到错误堆栈的值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在 process 捕获 Promise 错误&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在 process 捕获到 Promise 错误的时候，从错误堆栈上根据标识符解析出我们要的值&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这样的代码存在什么问题？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最主要的问题在于 filename 是编译进去的，即使生成 v8 代码缓存的 Buffer，后面用这个 Buffer 来编译一个新的 script 实例，传递进新的 filename，仍然改变不了之前的值。所以会带来代码每次都需要编译的成本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以来实践以下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; vm = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;vm&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;v8&#x27;&lt;/span&gt;).setFlagsFromString(&lt;span&gt;&#x27;--no-lazy&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; markStart = &lt;span&gt;&#x27;&amp;lt;vm-error&amp;gt;&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; markEnd = &lt;span&gt;&#x27;&amp;lt;/vm-error&amp;gt;&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; getContext = &lt;span&gt;&lt;span&gt;myVar&lt;/span&gt; =&amp;gt;&lt;/span&gt; vm.createContext({&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;,&lt;br/&gt;    process,&lt;br/&gt;    setTimeout,&lt;br/&gt;    myVar,&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; parseErrorStack = &lt;span&gt;(&lt;span&gt;err&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; errorStr = err.stack;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; valueStart = errorStr.indexOf(markStart);&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; valueEnd = errorStr.lastIndexOf(markEnd);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (valueStart !== &lt;span&gt;-1&lt;/span&gt; &amp;amp;&amp;amp; valueEnd !== &lt;span&gt;-1&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; errorStr.slice(valueStart + markStart.length, valueEnd);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;[parse-error]&#x27;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;process.on(&lt;span&gt;&#x27;unhandledRejection&#x27;&lt;/span&gt;, (err) =&amp;gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;[unhandledRejection]:&#x27;&lt;/span&gt;, parseErrorStack(err));&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;process.on(&lt;span&gt;&#x27;uncaughtException&#x27;&lt;/span&gt;, (err) =&amp;gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;[uncaughtException]:&#x27;&lt;/span&gt;, parseErrorStack(err));&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; getFileName = &lt;span&gt;&lt;span&gt;flag&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;`&lt;span&gt;${markStart}&lt;/span&gt;&lt;span&gt;${flag}&lt;/span&gt;&lt;span&gt;${markEnd}&lt;/span&gt;`&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; code = &lt;span&gt;`&lt;br/&gt;(() =&amp;gt; {&lt;br/&gt;    new Promise((resolve, reject) =&amp;gt; {&lt;br/&gt;        setTimeout(() =&amp;gt; {&lt;br/&gt;            reject(new Error(myVar));&lt;br/&gt;        }, 100)&lt;br/&gt;    })&lt;br/&gt;})()&lt;br/&gt;`&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; scriptCache = &lt;span&gt;new&lt;/span&gt; vm.Script(code, {&lt;br/&gt;    &lt;span&gt;filename&lt;/span&gt;: getFileName(&lt;span&gt;-1&lt;/span&gt;),&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; scriptCachedData = scriptCache.createCachedData();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; getScript = &lt;span&gt;&lt;span&gt;flag&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; vm.Script(&lt;span&gt;&#x27; &#x27;&lt;/span&gt;.repeat(code.length), {&lt;br/&gt;    &lt;span&gt;filename&lt;/span&gt;: getFileName(flag),&lt;br/&gt;    &lt;span&gt;cachedData&lt;/span&gt;: scriptCachedData,&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;(&lt;span&gt;&lt;span&gt;async&lt;/span&gt; (&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;3&lt;/span&gt;; i++) {&lt;br/&gt;        &lt;span&gt;await&lt;/span&gt; getScript(i).runInContext(getContext(i));&lt;br/&gt;    }&lt;br/&gt;})();&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看上面的代码，对比上一个例子，主要有这几个改动：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;缓存了 vm 代码编译后的实例，filename 设置的 -1&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;循环内的 flag 标志是通过 myVar 注入到 vm 的全局变量，在 vm 里 throw 这个 flag 错误值的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;循环内的 vm 执行，filename 设置的 0 - 3&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结果：编译后的代码实例并不会因为使用 cachedData 重新编译后，filename 就会被改变，因此就无法使用 cacheData + filename 的方式来既要减少编译时间又想要自定义错误堆栈。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.4.4.2 重写 Promise&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们想同步和异步代码都能捕获得到，那么只剩下 Promise 错误了。什么情况会报 Promise 未处理的错误呢？也就是没有写 catch 的情况。那么如果我们改写 Promise ，将每个 Promise 都加上一个默认的 catch 函数，是否能达到期望呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; vm = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;vm&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; processFlag;&lt;br/&gt;&lt;br/&gt;process.on(&lt;span&gt;&#x27;unhandledRejection&#x27;&lt;/span&gt;, (err) =&amp;gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;[unhandledRejection-processFlag]:&#x27;&lt;/span&gt;, processFlag);&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; getVMPromise = &lt;span&gt;(&lt;span&gt;flag&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; vmPromise = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;...args&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; p = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(...args);&lt;br/&gt;&lt;br/&gt;        p.then(&lt;br/&gt;            &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {},&lt;br/&gt;            (err) =&amp;gt; {&lt;br/&gt;                processFlag = flag;&lt;br/&gt;                &lt;span&gt;throw&lt;/span&gt; err;&lt;br/&gt;            }&lt;br/&gt;        );&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; p;&lt;br/&gt;    };&lt;br/&gt;    [&lt;span&gt;&#x27;then&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;catch&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;finally&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;all&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;race&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;allSettled&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;any&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;resolve&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;reject&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;try&#x27;&lt;/span&gt;].map(&lt;span&gt;(&lt;span&gt;key&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;Promise&lt;/span&gt;[key]) {&lt;br/&gt;            vmPromise[key] = &lt;span&gt;Promise&lt;/span&gt;[key];&lt;br/&gt;        }&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; vmPromise;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; getContext = &lt;span&gt;(&lt;span&gt;flag&lt;/span&gt;) =&amp;gt;&lt;/span&gt;&lt;br/&gt;    vm.createContext({&lt;br/&gt;        &lt;span&gt;Promise&lt;/span&gt;: getVMPromise(flag),&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;,&lt;br/&gt;        setTimeout,&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; getScript = &lt;span&gt;(&lt;span&gt;flag&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; vm.Script(&lt;span&gt;`&lt;br/&gt;        new Promise((resolve, reject) =&amp;gt; {&lt;br/&gt;            setTimeout(() =&amp;gt; {&lt;br/&gt;                console.log(&quot;[vm-current-task]:&quot;, &quot;&lt;span&gt;${flag}&lt;/span&gt;&quot;);&lt;br/&gt;                reject()&lt;br/&gt;            }, (1 + Math.random() * 4) * 1000);&lt;br/&gt;        })&lt;br/&gt;    `&lt;/span&gt;);&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;3&lt;/span&gt;; i++) {&lt;br/&gt;    getScript(i).runInContext(getContext(i));&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// [vm-current-task]: 0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// [unhandledRejection-processFlag]: 0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// [vm-current-task]: 2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// [unhandledRejection-processFlag]: 2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// [vm-current-task]: 1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// [unhandledRejection-processFlag]: 1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;考察以上的代码，我们做了这些事：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;改写了 Promise，在 Promise 添加了第一个 then 方法来处理错误&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在自定义的 Promise 的第一个 then 方法里存储了当前异步任务的上下文&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将自定义的 Promise 当做全局变量传递给 vm&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结果：在一个随机的任务 ID 上，成功在 process 上捕获到了上下文的信息。(但是 Promise 实现的精华在于 then 之后的链式调用，这在上面的代码是没有体现的。)&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.4.5 必要性思考&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重写 Promise 的方案可行吗？看起来是可行的，但其实最后也没有用这个方案（其实是我还没实施。。。）。因为假设我一个 32 核的 Pod，fork 出 32 个进程处理请求，平均分到每个进程的请求同一时间也不会很多。而出错是应该在编码和系统测试就应该避免的，或者自动化测试，或者生成骨架屏时避免。如果要同时捕获这三个错误，需要在异步代码都使用 domain 捕获（可能会有性能问题）和 Promise 记录上下文。其实我们可以在出错的时候将当前进程所处理的所有请求直接返回原文档，回退到无 SSR 的状态。（不过 Promise 的方案仍然值得研究尝试一下，会发大篇幅也是因为之前陷进去了这个问题，研究了好一段时间）&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.5 重定向&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;登录态的问题和文档强相关，但是仍然想要抛出来和大家探讨一下重定向的这个问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;腾讯文档的登录态在前端是无法完全判断的，只有两种最基本的情况前端是知道没有登录态：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;没有 cookie；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;cookie 里没有 uid 和 uid_key；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是登录态过期，那么只能是在发起 CGI 请求，后台返回具体的错误码之后才知道。所以 CSR 的登录是在列表页显示，并且正常渲染的情况下，发现 CGI 有具体的登录态错误码了，就动态加载登录模块来提醒用户登录。整个的效果就是这样的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8320388349514564&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvaukJ07t3E8jUK2u2EfibSibZAh0r1bPflHqAFOMibUFJILBqfPFmkibb8x54WhLMCic0l5PiaYu75RztFtQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;2060&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.5.1 rewrite&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们引入了 SSR 后，发送 CGI 请求遇到特定的登录态错误码我们是知道的。那么我们为什么不直接返回登录页就可以了呢？很简单，直接 &lt;code&gt;ctx.redirect 302&lt;/code&gt; 重定向到登录页就可以了，但是问题来了：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;我们的 PC 端没有独立的登录页，是用动态加载模块的方式来在当前页面展示登录框的；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;需要处理 URL 跳转的问题，不仅是从外部跳转过来的带有登录态的 URL，还要处理登陆完后的 URL 跳转问题；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;登录的模块在其他的库，就需要去改到那个库发布才可以；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有没有更好的方法呢？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5205479452054794&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvaukJ07t3E8jUK2u2EfibSibZA4Dk6fsPS1pwU4UBNTRz0hYKs3IRQsgM5xBtpr7Gv9YeqQy5Wp1x6Qg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1460&quot;/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;我们另外做一个很简单的 login 页面，这个页面只用来做一件事，复用原来的代码在这个页面动态加载登录模块；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果用户登录态有效，返回请求的页面，如果登录态失效，就读取 login 页面的内容返回；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就做到了不用更改登录模块逻辑，也不会更改到链接地址，也就不用处理 URL 跳转的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是需要注意的是，因为以下会提到同时接入 SSR 服务和原 Nginx 服务，因此如果要不改变现网表现的话，login 页面不应该被发到 Nginx 机器上。类似的还有独立密码的登录页。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样实现的效果就是：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8320388349514564&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvaukJ07t3E8jUK2u2EfibSibZAib38cOBb34ntI12jfsGItf4AQGN6pDZrJerH5FiaR1fs3mQzD3EwcHhw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;2060&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.5.2 redirect&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像上面的登录态问题，在移动端上有独立的登录页，那么我们就只需要用 &lt;code&gt;ctx.redirect&lt;/code&gt; 使用 302 跳转到对应的页面就 OK 了。相似的应用场景还有如果是 PC 端访问了移动端的 URL 地址，或者移动端访问了 PC 端的地址，需要读取 UA 来判断访问端和 URL 地址，跳转到对应的页面。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.5.3 小程序登录态&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要额外提到的小程序登录态是因为，小程序是通过小程序壳登录，再将登录态附加在 &lt;code&gt;webviewer&lt;/code&gt; 里的 URL 地址上，由前端解析 URL 地址来种登录态的。这意味着小程序登录后，SSR 的 cookie 里是没有登录态的，发起 CGI 请求就会报错。所以我们就需要做两件事：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;从 URL 上解析登录态，将登录态信息附加到当次请求的 cookie 里，保证当次请求不会出错，也不会因为没有登录态重复跳到登录页；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设置新的具有登录态的 cookie 到客户端；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; appendAndSetCookie = &lt;span&gt;(&lt;span&gt;ctx, key, value&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; oldCookie = ctx.header.cookie || &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;    ctx.header.cookie = &lt;span&gt;`&lt;span&gt;${oldCookie}&lt;/span&gt;&lt;span&gt;${oldCookie.endsWith(&lt;span&gt;&#x27;;&#x27;&lt;/span&gt;) ? &lt;span&gt;&#x27;&#x27;&lt;/span&gt; : &lt;span&gt;&#x27;;&#x27;&lt;/span&gt;}&lt;/span&gt;&lt;span&gt;${key}&lt;/span&gt;=&lt;span&gt;${value}&lt;/span&gt;;`&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    ctx.cookies.set(key, value);&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. 骨架屏&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.1 基本实现&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回顾整个生成首屏页面的流程：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;创建 redux 的 store；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;发送 CGI 填充 store 数据；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;以 store 的数据为基础渲染 react 应用；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了发送 CGI 这一步需要在线上环境，在用户浏览器发起请求时由 SSR Server 代理请求外，空的 store 和以空的 store 渲染出 React 应用，是我们在编译期间就可以确定的。那么我们就可以很方便地获得一个骨架屏，而所需要做的在原来 SSR 的基础上只有几步：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;创建一个空的 ctx，以复用原来的 SSR 逻辑：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; generateCTX = &lt;span&gt;(&lt;span&gt;renderJSFile, renderHtmlFile&lt;/span&gt;) =&amp;gt;&lt;/span&gt; ({&lt;br/&gt;    &lt;span&gt;headers&lt;/span&gt;: [],&lt;br/&gt;    &lt;span&gt;url&lt;/span&gt;: &lt;span&gt;&#x27;&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;body&lt;/span&gt;: &lt;span&gt;&#x27;&#x27;&lt;/span&gt;,&lt;br/&gt;    renderJSFile,&lt;br/&gt;    renderHtmlFile,&lt;br/&gt;    &lt;span&gt;originalUrl&lt;/span&gt;: &lt;span&gt;&#x27;&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;request&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;href&lt;/span&gt;: &lt;span&gt;&#x27;&#x27;&lt;/span&gt;,&lt;br/&gt;    },&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;传递给应用标识当前是生成骨架屏逻辑，应用里不发送 CGI：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (!TSRENV.isSkeleton) {&lt;br/&gt;    &lt;span&gt;await&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;.all([&lt;br/&gt;        store.dispatch.user.requestGetUserInfo(),&lt;br/&gt;        store.dispatch.list.refreshRecentOpenList(),&lt;br/&gt;    ]);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;将生成的 HTML 写入原文档：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (renderConfig.skeleton.writeToFile) {&lt;br/&gt;    fileManage.writeHtmlFile(renderHtmlFile);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是这里我们考虑应该以怎样的方式来写入。假设原来是将 &lt;code&gt;&amp;lt;div id=&quot;root&quot;&amp;gt;&amp;lt;div id=&quot;server-render&quot;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt; 里的 &lt;code&gt;server-render&lt;/code&gt; 整个标签（包括 div）替换成渲染后的文档（为什么原来不也是用注释的方式？因为很可能编译后会被去掉注释）。那么我们生成的骨架屏也将这个替换掉的话，后续 SSR 找不到这个标签。如果插入在这个标签里面的话，显然骨架屏生成的 DOM 在层级上和 SSR 生成的 DOM 是不一样的。这里我们可以借助注释。&lt;/p&gt;&lt;p&gt;原来的文档：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;root&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;server-render&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;骨架屏文档（编译完 CSR 后再生成）：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;root&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;!--SKELETON-START--&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;ssr-root&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--SKELETON-END--&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;SSR 后文档:&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;root&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;ssr-root&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们能获得的将是具有页面框架的静态文档。传统的 React 应用需要在 React 加载下来后渲染才有页面元素，而骨架屏将在 DOM 直接返回页面的时候就已经有内容。这在我们假设 SSR 错误后，返回未直出文档的情况下，也比原来的返回空白页面观感上好很多。或者我们将类似的逻辑迁移到其他的页面上，即使不做 SSR，也可以在静态编译的时候生成骨架屏，在几十毫秒内就能结束白屏时间。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5046189376443418&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvaukJ07t3E8jUK2u2EfibSibZAzFX9gmz9wKumWZQicTx0jNicB5PjPzDEuic83uadCB36pYoJ3ib0aGB9qQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1732&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.2 白屏时间思考&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们引入了 SSR，好处当然是首屏时间会大大降低，但是同时白屏时间会增加。有办法解决吗？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7364864864864865&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvaukJ07t3E8jUK2u2EfibSibZArBiceQSMeYgEcibOraVgLb7CCJK8XBO6LG7dHiaA2bRI1oAkMrhEXc4aw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1480&quot;/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&amp;lt;红色箭头部分&amp;gt;&lt;/strong&gt; 浏览器请求前端 HTML 页面，Server 返回骨架屏，同时在骨架屏内注入 CGI 请求的 JS。这样我们可以以近乎静态资源请求的速度获得极低的白屏时间；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&amp;lt;蓝色箭头部分&amp;gt;&lt;/strong&gt; Server 在返回骨架屏的同时，开始 SSR 的渲染；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&amp;lt;绿色箭头部分&amp;gt;&lt;/strong&gt; 注入到骨架屏的 JS 开始发起 CGI 请求，这个请求不是到后端的 Go Server，而是到我们的 SSR Server，SSR 返回渲染后的 DOM 节点字符串，前端直接注入到页面渲染；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方案能给我们带来什么？&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;极低的白屏时间；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;相对于 SSR 更短的响应耗时（但是总的首屏时间会稍微长一点点），因为 SSR 的响应耗时将会减少 Server 返回骨架屏到浏览器再次发起 SSR CGI 的时间；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有采用吗？没有。因为在重定向部分说到我们有一个比较严重的登录体验问题，如果使用了这个方案，那么又会变成先访问了列表页才出现登录的问题。而考察现网的数据，访问了列表页的大概有 20% 用户是未登录状态，那么我们就不能采用这个方案。但也算是一个研究，供参考。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. 性能测速&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们做了 SSR，当然关心能够给我们的业务带来多少的性能提升，这里我主要关注这几点：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7672413793103449&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvaukJ07t3E8jUK2u2EfibSibZAcoZ8GKsXUpvvoPfjfvficRJ2XWAutOVIGxZJIbVLYCUcGFmAdXeoVzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;464&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.1 首屏时间&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引入 SSR 我们最主要的目的就是为了降低首屏时间。这里因为我们知道列表是最慢也是最主要的页面资源，因此以列表加载的时间为准。假设没有引入 SSR，我们的首屏时间是这么算的。以列表第一次渲染的时间为准：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// speed.ts&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; hasReport = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; openSpeedReport = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (hasReport) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    hasReport = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log((&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;()).getTime() - performance.timing.navigationStart);&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// list.tsx&lt;/span&gt;&lt;br/&gt;useEffect(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 因为一开始可能是没有数据渲染的，所以要判断列表有数据才计算&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (list.length) {&lt;br/&gt;        openSpeedReport();&lt;br/&gt;    }&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果引入了 SSR，可认为文档加载完后，首屏时间结束：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; firstScreenCost = performance.timing.responseEnd - performance.timing.navigationStart;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.2 白屏时间&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;白屏时间用来表征浏览器开始显示内容的时间。按上节所说，我们用空的 state 渲染了静态的页面生成骨架屏。那么可以认为文档加载下来就结束了白屏时间&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; cost = timing.responseEnd - timing.navigationStart;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么作为对比，如果没有接入骨架屏，白屏时间以 performance 的 paint 时间为准&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; paintTimings = performance.getEntriesByType(&lt;span&gt;&#x27;paint&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (paintTimings &amp;amp;&amp;amp; paintTimings.length) {&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; paintTiming = paintTimings[&lt;span&gt;0&lt;/span&gt;] &lt;span&gt;as&lt;/span&gt; PerformanceEntry;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; paintTiming.startTime;&lt;br/&gt;    }&lt;br/&gt;} &lt;span&gt;catch&lt;/span&gt; (err) {}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不支持 &lt;code&gt;getEntriesByType&lt;/code&gt; 方法的浏览器，可以在 JS 开始执行时记录时间，会有一点偏差，但是偏差很小。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;window&lt;/span&gt;.performanceData.jsStartRun - timing.navigationStart;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.3 交互时间&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.3.1 主体可交互时间&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于我们的业务来说，列表是交互的主体，我们更关心的其实是列表可交互的时间。那么这个时间就是列表第一次被渲染后，注册了事件的时间。这个时间可以认为和没有引入直出的首屏时间相同，见上方首屏时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们考虑在引入了 SSR 后，这个时间会变长或变短？虽然文档相应时间变长，导致 JS 加载时间延后，但是文档加载后，是带了初始化数据的，这个数据是会比客户端发起 CGI 请求取回数据来得快的。因此也就意味着列表的渲染时间提前，主体可交互时间变短。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.3.2 整体可交互时间&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在浏览器资源加载都完成后，说明达到整体可交互的状态。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; loadEventAndReport = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; timing = performance.timing;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (timing.loadEventEnd &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; cost = timing.loadEventEnd - timing.navigationStart;&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;.log(cost);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;document&lt;/span&gt;.readyState === &lt;span&gt;&#x27;complete&#x27;&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;// 为了避免调用测速函数的时候，已经加装完成，不会有 load 事件&lt;/span&gt;&lt;br/&gt;    loadEventAndReport();&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// window的onload事件结束之后 performance 才有 loadEventEnd 数据&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;window&lt;/span&gt;.addEventListener(&lt;span&gt;&#x27;load&#x27;&lt;/span&gt;, loadEventAndReport);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.4 HTML 请求耗时&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.4.1 响应耗时&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;响应耗时也就是 SSR 渲染的耗时，表示从浏览器发起请求开始，到开始接收请求结束。这是我们用来观察 SSR 性能的重要指标。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; htmlResponseCost = performance.timing.responseStart - performance.timing.requestStart;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.4.2 文档大小&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SSR 因为在文档里加了渲染后的节点和初始化数据，因此文档大小会变大。对于文档大小的变化，那么我们就会关心两个指标：文档大小和下载耗时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;计算文档大小：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; navigationTimings = performance.getEntriesByType(&lt;span&gt;&#x27;navigation&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (navigationTimings &amp;amp;&amp;amp; navigationTimings.length) {&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; navigationTiming = navigationTimings[&lt;span&gt;0&lt;/span&gt;] &lt;span&gt;as&lt;/span&gt; PerformanceNavigationTiming;&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; size = navigationTiming.encodedBodySize; &lt;span&gt;// 因为开始了 gzip 压缩，所以关注的是编码后的大小&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`&lt;span&gt;${(size &lt;span&gt;/ 1000).toFixed(2)}KB`);&lt;br/&gt;    }&lt;br/&gt;} catch (err) {}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.4.3 下载耗时&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; htmlDownlaodCost = performance.timing.responseEnd - performance.timing.responseStart;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.5 Node 节点测速&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;console.time&lt;/code&gt;、&lt;code&gt;console.timeEnd&lt;/code&gt; 是我们很经常用来测速某个节点耗时的工具。但是在异步场景下，考察以下的代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; calculate = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.time(&lt;span&gt;&#x27;async-time&#x27;&lt;/span&gt;);&lt;br/&gt;    setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;.timeEnd(&lt;span&gt;&#x27;async-time&#x27;&lt;/span&gt;);&lt;br/&gt;    }, (&lt;span&gt;1&lt;/span&gt; + &lt;span&gt;Math&lt;/span&gt;.random() * &lt;span&gt;10&lt;/span&gt;) * &lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;3&lt;/span&gt;; i++) {&lt;br/&gt;    calculate();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// (node:67898) Warning: Label &#x27;async-time&#x27; already exists for console.time()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// (node:67898) Warning: Label &#x27;async-time&#x27; already exists for console.time()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// async-time: 5894.537ms&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// (node:67898) Warning: No such label &#x27;async-time&#x27; for console.timeEnd()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// (node:67898) Warning: No such label &#x27;async-time&#x27; for console.timeEnd()&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们考虑 koa 将每个请求都封装在 ctx 对象上，我们的测速也是基于每个请求下的测速，那么我们可以生成个 ID，对每个请求下的测速都以 ID 来隔离。传递到 vm 里的业务代码，也以封装好 ID 的函数传进去。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; { performance } = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;perf_hooks&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; speed = &lt;span&gt;new&lt;/span&gt; (&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Speed&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    idMarks = {};&lt;br/&gt;&lt;br/&gt;    timeAsync = &lt;span&gt;(&lt;span&gt;mark, id&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;.idMarks[id]) {&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.idMarks[id] = {};&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.idMarks[id][mark] = performance.now();&lt;br/&gt;    };&lt;br/&gt;&lt;br/&gt;    timeEndAsync = &lt;span&gt;(&lt;span&gt;mark, id&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; cost = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.idMarks[id] &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;.idMarks[id][mark]) {&lt;br/&gt;            cost = performance.now() - &lt;span&gt;this&lt;/span&gt;.idMarks[id][mark];&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;delete&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.idMarks[id][mark];&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`&lt;span&gt;${mark}&lt;/span&gt;: &lt;span&gt;${cost.toFixed(&lt;span&gt;2&lt;/span&gt;)}&lt;/span&gt;ms`&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; cost;&lt;br/&gt;    };&lt;br/&gt;&lt;br/&gt;    timeDestAsync = &lt;span&gt;(&lt;span&gt;id&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;delete&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.idMarks[id];&lt;br/&gt;    };&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; calculate = &lt;span&gt;(&lt;span&gt;id&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    speed.timeAsync(&lt;span&gt;&#x27;async-time&#x27;&lt;/span&gt;, id);&lt;br/&gt;    setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        speed.timeEndAsync(&lt;span&gt;&#x27;async-time&#x27;&lt;/span&gt;, id);&lt;br/&gt;        speed.timeDestAsync(id);&lt;br/&gt;    }, (&lt;span&gt;1&lt;/span&gt; + &lt;span&gt;Math&lt;/span&gt;.random() * &lt;span&gt;10&lt;/span&gt;) * &lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;3&lt;/span&gt;; i++) {&lt;br/&gt;    calculate(i);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// async-time: 6131.87ms&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// async-time: 6972.74ms&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// async-time: 8890.43ms&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7. 部署&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.1 能否共用？&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们做了这么多工作后，尤其是开发环境，运行环境的搭建，我们在想是否可以抽出公共的逻辑，如果有业务有类似的需求的时候，不仅可以针对 SSR 提供基础功能，还可以具有拓展性，给业务多一个选择。（也就是抽出了一个叫 tsr 的库，后面如果提到这个名字就是指的这个）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7209612817089452&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvaukJ07t3E8jUK2u2EfibSibZAfQ0yol5NibfEa689bAVYE5elqb7Yq7AvM0fyUufjKSNMbvBbuT8kMtw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1498&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上我们只需要实现这几大模块，以及一些额外的功能就可以了。其余的就可以让业务拓展。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.2 配置化&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们去除一些细节和重复的，来看一下业务大概的一个配置情况：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;module&lt;/span&gt;.exports = {&lt;br/&gt;    &lt;span&gt;mode&lt;/span&gt;: isProduction ? &lt;span&gt;&#x27;production&#x27;&lt;/span&gt; : &lt;span&gt;&#x27;development&#x27;&lt;/span&gt;, &lt;span&gt;// 标识正式环境还是开发环境&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;port&lt;/span&gt;: &lt;span&gt;80&lt;/span&gt;, &lt;span&gt;// 正式环境下的端口&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;aegisId&lt;/span&gt;: &lt;span&gt;&#x27;6602&#x27;&lt;/span&gt;, &lt;span&gt;// 上报的项目 ID&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;isTestEnv&lt;/span&gt;: !!(process.env.TEST_ENV), &lt;span&gt;// 如果是运行在 80 端口的正式环境，是否是用来系统测试的&lt;/span&gt;&lt;br/&gt;    renderRoot, &lt;span&gt;// 渲染的 JS 和 HTML 文件的主目录&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;preCache&lt;/span&gt;: { &lt;span&gt;// 因为 html 和 js 文件需要读取，js 文件还需要预编译，因此这里列出一些路径，预读取和编译&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;preCacheDir&lt;/span&gt;: [&lt;br/&gt;            &lt;span&gt;&#x27;&#x27;&lt;/span&gt;,&lt;br/&gt;        ],&lt;br/&gt;        &lt;span&gt;preCacheFiles&lt;/span&gt;: [{&lt;br/&gt;            &lt;span&gt;js&lt;/span&gt;: &lt;span&gt;&#x27;mobile-index.js&#x27;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;html&lt;/span&gt;: &lt;span&gt;&#x27;mobile-index.html&#x27;&lt;/span&gt;,&lt;br/&gt;        }],&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;skeleton&lt;/span&gt;: { &lt;span&gt;// 生成骨架屏的配置&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;resolveL5&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;//生成骨架屏时是否需要解析 L5 // 猫咪写的代码：--------55&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;writeToFile&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;// 是否写入文件，路径是 preCacheDir 加 preCacheFiles&lt;/span&gt;&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;devOptions&lt;/span&gt;: { &lt;span&gt;// 本地开发路径&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;staticDir&lt;/span&gt;: path.resolve(__dirname, &lt;span&gt;&#x27;../dist&#x27;&lt;/span&gt;), &lt;span&gt;// 本地开发静态资源的路径&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;resolveL5&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;// 本地是否需要解析 L5，要装了 IOA 2020 客户端才可以解析&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;port&lt;/span&gt;: &lt;span&gt;3000&lt;/span&gt;, &lt;span&gt;// 本地开发端口&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;watchDir&lt;/span&gt;: [ &lt;span&gt;// 要额外监听变动的本地开发路径&lt;/span&gt;&lt;br/&gt;            path.resolve(__dirname, &lt;span&gt;&#x27;./&#x27;&lt;/span&gt;),&lt;br/&gt;        ],&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;middlewares&lt;/span&gt;: { &lt;span&gt;// 中间件&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;beforeRouter&lt;/span&gt;: [&lt;br/&gt;            redirect, &lt;span&gt;// pc 和移动端互转的重定向&lt;/span&gt;&lt;br/&gt;            setCookieFromMiniProgram, &lt;span&gt;// 小程序登录的中间件&lt;/span&gt;&lt;br/&gt;        ],&lt;br/&gt;        &lt;span&gt;afterRouter&lt;/span&gt;: [],&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;routers&lt;/span&gt;: { &lt;span&gt;// 路由，返回 JS + HTML 对&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&#x27;/desktop&#x27;&lt;/span&gt;: pcIndexHandler,&lt;br/&gt;        &lt;span&gt;&#x27;/desktop/m&#x27;&lt;/span&gt;: mobileIndexHandler,&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;l5Resolves&lt;/span&gt;: [{ &lt;span&gt;// l5 配置&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;namespace&lt;/span&gt;: &lt;span&gt;&#x27;Production&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;service&lt;/span&gt;: &lt;span&gt;&#x27;969089:65536&#x27;&lt;/span&gt;, &lt;span&gt;// tsw 的 l5&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;cgi&lt;/span&gt;: [ &lt;span&gt;// 有用到 l5 的 cgi 路径&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&#x27;//docs.qq.com/cgi-bin/online_docs/user_info&#x27;&lt;/span&gt;,&lt;br/&gt;        ],&lt;br/&gt;    }],&lt;br/&gt;    &lt;span&gt;vmGlobal&lt;/span&gt;: &lt;span&gt;(&lt;span&gt;&lt;span&gt;/* renderJSFile */&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; ({ &lt;span&gt;// 要注入到 vm 的全局变量&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;window&lt;/span&gt;: &lt;span&gt;undefined&lt;/span&gt;,&lt;br/&gt;    }),&lt;br/&gt;    &lt;span&gt;hooks&lt;/span&gt;: { &lt;span&gt;// 一些钩子函数&lt;/span&gt;&lt;br/&gt;        beforeinjectContent,&lt;br/&gt;    },&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.3 依赖排除&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面有提到两个问题：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;全部编译成一个文件的话，代码量很大，有十几万行，这么大的代码量都要放到 vm 里跑，意味着有不少代码是需要重复运行的。但是其实只有某些模块才有上下文隔离的需求；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;被 require 的模块里访问全局变量，是 node 上的 globa，并不是 vm 里的上下文；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于以上两点，我们在想是否可以将 &lt;code&gt;node_modules&lt;/code&gt; 里的模块排除开，但是一些模块又有隔离上下文需求的，就一起编译。这样可以减少重复代码的执行，加快执行速度。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; nodeExternals = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;webpack-node-externals&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;module&lt;/span&gt;.exports = {&lt;br/&gt;    &lt;span&gt;externals&lt;/span&gt;: [nodeExternals({&lt;br/&gt;        &lt;span&gt;whitelist&lt;/span&gt;: [&lt;br/&gt;            &lt;span&gt;/@tencent\//&lt;/span&gt;,&lt;br/&gt;        ],&lt;br/&gt;    })],&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 &lt;code&gt;webpack-node-externals&lt;/code&gt; 来排除 &lt;code&gt;node_modules&lt;/code&gt; 模块，并且我们自己的模块不排除。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是我们将 vm 的运行环境抽离出单独的包 tsr，那么业务的 &lt;code&gt;node_moduels&lt;/code&gt; 和 tsr 的 &lt;code&gt;node_modules&lt;/code&gt; 是隔离的，要想在 tsr 里 require 到业务的 &lt;code&gt;node_modules&lt;/code&gt; ，我们需要对 require 的路径查找做处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;require 查找模块的路径依赖 &lt;code&gt;module.paths&lt;/code&gt;，那么我们只需要将业务 &lt;code&gt;node_modules&lt;/code&gt; 的路径添加到 &lt;code&gt;module.paths&lt;/code&gt; 里，就能够正确找到依赖：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; setRequirePaths = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; NODE_MODULES = &lt;span&gt;&#x27;node_modules&#x27;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; requirePath = renderConfig.renderRoot; &lt;span&gt;// 这是业务存放代码的根目录配置&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; paths = [path.resolve(requirePath, NODE_MODULES)];&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; pathInfo = path.parse(requirePath);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!pathInfo || pathInfo.dir === &lt;span&gt;&#x27;/&#x27;&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        requirePath = pathInfo.dir;&lt;br/&gt;        paths.unshift(path.resolve(requirePath, NODE_MODULES));&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    paths.reverse();&lt;br/&gt;    &lt;span&gt;module&lt;/span&gt;.paths.unshift(...paths);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有个问题是，假设我们的 Server 有个入口文件是 &lt;code&gt;index.js&lt;/code&gt; ，vm 执行的文件是 &lt;code&gt;vm.js&lt;/code&gt; ，那么我们在 &lt;code&gt;index.js&lt;/code&gt; 文件里运行这个 &lt;code&gt;setRequirePaths&lt;/code&gt; 是否有效？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是无效的，因为这两个文件的 module 对象是不一样的，我们传递到 vm 的全局变量里的 module 是 vm 文件里的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时，为了我们的 React 应用编译出的代码能正常 require node_modules 下的模块，我们还需要对 babel 做更改：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// https://stackoverflow.com/questions/57361439/how-to-exclude-core-js-using-usebuiltins-usage/59647913#59647913&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; babelLoader = {&lt;br/&gt;    &lt;span&gt;loader&lt;/span&gt;: &lt;span&gt;&#x27;babel-loader&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;options&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;babelrc&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;plugins&lt;/span&gt;: [&lt;br/&gt;            &lt;span&gt;&#x27;@babel/plugin-transform-runtime&#x27;&lt;/span&gt;,&lt;br/&gt;        ],&lt;br/&gt;        &lt;span&gt;presets&lt;/span&gt;: [&lt;br/&gt;            &lt;span&gt;&#x27;@babel/preset-react&#x27;&lt;/span&gt;,&lt;br/&gt;            [&lt;br/&gt;                &lt;span&gt;&#x27;@babel/preset-env&#x27;&lt;/span&gt;,&lt;br/&gt;                {&lt;br/&gt;                    &lt;span&gt;modules&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;,&lt;br/&gt;                    &lt;span&gt;useBuiltIns&lt;/span&gt;: &lt;span&gt;&#x27;usage&#x27;&lt;/span&gt;,&lt;br/&gt;                    &lt;span&gt;corejs&lt;/span&gt;: &lt;span&gt;3.6&lt;/span&gt;,&lt;br/&gt;                },&lt;br/&gt;            ],&lt;br/&gt;        ],&lt;br/&gt;        &lt;span&gt;sourceType&lt;/span&gt;: &lt;span&gt;&#x27;unambiguous&#x27;&lt;/span&gt;, &lt;span&gt;// 优先识别 commonjs 模块&lt;/span&gt;&lt;br/&gt;    },&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.4 云函数 OR 镜像部署？&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们要部署 SSR 服务的时候，可以选择使用云函数 （SCF）或者镜像部署（司内习惯用 STKE）（当然是不会选择传统的 IDC 机器部署服务了，除了申请机器，安装各种环境，加机器还要再走一遍流程，然后还要担心莫名被裁撤）。云函数的概念火一点，但是符合我们的需求吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们后续要做 ABTest 或者是系统环境的分支路径隔离，就需要同时运行多个分支的代码，这如果使用云函数的话，有两个方案：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;创建 NFS，并且挂载到云函数里，每次发布更新到 NFS 里，在云函数里做判断：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6941391941391941&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvaukJ07t3E8jUK2u2EfibSibZA5q2OoibNYWDBmJLVBprUzml5P5GxyhvJE4lcRribwekxTbzCsoSEQqFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1092&quot;/&gt;&lt;/figure&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;创建多个版本的云函数，但是需要在前面再创建个云函数用来判断请求哪个版本的云函数：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4313984168865435&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvaukJ07t3E8jUK2u2EfibSibZAicTJMLJJWd0geYZ72IphOZz0xz86bicVKES8GwMGYjGhbtwy1XYj9Ufw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1516&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么我们考虑使用云函数能给我们带来什么：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;弹性伸缩，负载均衡，按需运行&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好吧，弹性伸缩我用 STKE 也可以，负载均衡有 L5，STKE 还可以创建负载均衡器。不说 SCF 创建 NFS 还有网络的要求，在 SCF 里我们仍然需要处理上下文隔离的问题，只会将问题变得更复杂。（原谅我原来先使用的 STKE 的，不过 SCF 也确实去申请平台子用户，申请权限，创建到一半了，也确实考察过）&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.5 基础镜像&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;选择了使用镜像部署的方式来提供服务，那么我们就需要有 docker 镜像。我们可以提供 tnpm 包，让业务自己启动起 tsr 服务。但是提供 docker 基础镜像，隐藏启动的细节，让业务只设置个配置路径，是更加合理而有效的方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以基于 Node:12，设置启动命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;FROM&lt;/span&gt; node:&lt;span&gt;12&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;COPY&lt;/span&gt;&lt;span&gt; ./ /tsr/&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;CMD&lt;/span&gt;&lt;span&gt; [&lt;span&gt;&quot;node&quot;&lt;/span&gt;, &lt;span&gt;&quot;/tsr/scripts/cli.js&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是 node:12，或者 node:12-alpine 镜像在公司环境下，发起请求到接收请求都要 200-300ms，原因未知，待研究。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;司内环境更推荐使用 tlinux-mini （tlinux 镜像大），安装 node，拷贝代码，并且拷贝启动脚本到 &lt;code&gt;/etc/kickStart.d&lt;/code&gt; 下。（tlinux 为什么不能设置 CMD 启动命令？因为 tlinux 有自己的初始化进程，进程 pid = 1）启动后 log 会输出到 &lt;code&gt;/etc/kickstart.d/startApp.log&lt;/code&gt; 。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;FROM&lt;/span&gt; csighub.tencentyun.com/tlinux/tlinux-mini:&lt;span&gt;2.2&lt;/span&gt;-stke&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 安装 node&lt;/span&gt;&lt;br/&gt;&lt;span&gt;RUN&lt;/span&gt;&lt;span&gt; &lt;span&gt;cd&lt;/span&gt; /usr/&lt;span&gt;local&lt;/span&gt;/ &amp;amp;&amp;amp; \&lt;br/&gt;    wget https://npm.taobao.org/mirrors/node/v12.13.0/node-v12.13.0-linux-x64.tar.xz &amp;amp;&amp;amp; \&lt;br/&gt;    tar -xvf node-v12.13.0-linux-x64.tar.xz &amp;amp;&amp;amp; \&lt;br/&gt;    rm -rf node-v12.13.0-linux-x64.tar.xz &amp;amp;&amp;amp; \&lt;br/&gt;    mv node-v12.13.0-linux-x64/ node &amp;amp;&amp;amp; \&lt;br/&gt;    ln -s /usr/&lt;span&gt;local&lt;/span&gt;/node/bin/node /usr/&lt;span&gt;local&lt;/span&gt;/bin/node &amp;amp;&amp;amp; \&lt;br/&gt;    ln -s /usr/&lt;span&gt;local&lt;/span&gt;/node/bin/npm /usr/&lt;span&gt;local&lt;/span&gt;/bin/npm &amp;amp;&amp;amp; \&lt;br/&gt;    ln -s /usr/&lt;span&gt;local&lt;/span&gt;/node/bin/npx /usr/&lt;span&gt;local&lt;/span&gt;/bin/npx&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;COPY&lt;/span&gt;&lt;span&gt; ./ /tsr/&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;COPY&lt;/span&gt;&lt;span&gt; ./scripts/start.sh ./scripts/stop.sh /etc/kickStart.d/&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;RUN&lt;/span&gt;&lt;span&gt; chmod +x /etc/kickStart.d/start.sh /etc/kickStart.d/stop.sh&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对业务来说只需要依赖 tsr 的镜像，拷贝一下代码，设置一下配置路径就可以了：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;FROM&lt;/span&gt; csighub.tencentyun.com/tsr/tsr:v1.&lt;span&gt;0.38&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 编译的变量，多分支支持&lt;/span&gt;&lt;br/&gt;&lt;span&gt;ARG&lt;/span&gt; hookBranch&lt;br/&gt;&lt;br/&gt;&lt;span&gt;COPY&lt;/span&gt;&lt;span&gt; ./ /tsr-renders/&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 为了启动时同步代码到 pvc 硬盘的&lt;/span&gt;&lt;br/&gt;&lt;span&gt;ENV&lt;/span&gt; TSR_START_SCRIPT /tsr-renders/start.js&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 因为代码被 start.js 拷贝到 pvc 硬盘，因此配置的路径在 pvc 硬盘的路径下&lt;/span&gt;&lt;br/&gt;&lt;span&gt;ENV&lt;/span&gt; TSR_CONFIG_PATH /tsr-renders/renders-pvc/${hookBranch}/config.js&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.6 开发和调试&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们在本地开发的时候，可以用 whistle 来代理请求：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/^https?:\/\/docs\.qq\.com\/desktop(\/m)?(\/index.html|\/)?(\?.*)?$/ http://127.0.0.1:3000/desktop$1&lt;br/&gt;&lt;br/&gt;/^https?:\/\/docs\.qq\.com\/desktop(\/m)?(\/(stared|mydoc|trash|folder))(\/.*)?$/ http://127.0.0.1:3000/desktop$1/$3$4&lt;br/&gt;&lt;br/&gt;/^https?:\/\/docs.qq.com\/desktop\/(m\/)?(.*)\.(.*)/ http://127.0.0.1:3000/$2.$3&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是开发 Node 应用，修改后频繁地去重启会大大降低我们的效率，更不用说我们还有不同仓库的代码变更需要监听，那么我们可以借助 nodemon，但是这里我们有两个难题：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;我们需要 &lt;code&gt;watch&lt;/code&gt; 其他仓库的改动;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我们每次改动之后需要将 &lt;code&gt;tsx&lt;/code&gt; 项目编译成 js 项目;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; path = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;path&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; nodemon = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;nodemon&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; { renderConfig, appMain } = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;../constants&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; logger = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;../src/utils/logger&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; isStartedByNodemon = !!process.env.NODEMON_PROCESS;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; watches = [renderConfig.renderRoot];&lt;br/&gt;watches.push(path.resolve(__dirname, &lt;span&gt;&#x27;../&#x27;&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;watches.push(...(renderConfig.devOptions.watchDir || []));&lt;br/&gt;&lt;br/&gt;!isStartedByNodemon&lt;br/&gt;    &amp;amp;&amp;amp; nodemon({&lt;br/&gt;        &lt;span&gt;ext&lt;/span&gt;: &lt;span&gt;&#x27;js html json&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;watch&lt;/span&gt;: watches,&lt;br/&gt;        &lt;span&gt;exec&lt;/span&gt;: process.argv.join(&lt;span&gt;&#x27; &#x27;&lt;/span&gt;),&lt;br/&gt;        &lt;span&gt;runOnChangeOnly&lt;/span&gt;: isStartedByNodemon,&lt;br/&gt;        &lt;span&gt;delay&lt;/span&gt;: &lt;span&gt;500&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;env&lt;/span&gt;: {&lt;br/&gt;            &lt;span&gt;NODEMON_PROCESS&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;        },&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;nodemon&lt;br/&gt;    .on(&lt;span&gt;&#x27;quit&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;        logger.info(&lt;span&gt;&#x27;Exit!&#x27;&lt;/span&gt;);&lt;br/&gt;        process.exit();&lt;br/&gt;    })&lt;br/&gt;    .on(&lt;span&gt;&#x27;restart&#x27;&lt;/span&gt;, (files) =&amp;gt; {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (files) {&lt;br/&gt;            logger.info(&lt;span&gt;&#x27;Restart! Change list:\n&#x27;&lt;/span&gt;, files);&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            logger.info(&lt;span&gt;&#x27;Start And Watching!&#x27;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (isStartedByNodemon) {&lt;br/&gt;    &lt;span&gt;require&lt;/span&gt;(appMain);&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    nodemon.emit(&lt;span&gt;&#x27;restart&#x27;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而如果我们要在本地跑起 docker 镜像呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/bin/bash&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;docker pull csighub.tencentyun.com/tsr/tsr&lt;br/&gt;&lt;br/&gt;docker build -t desktop-ssr ./tsr-renders&lt;br/&gt;&lt;br/&gt;container=`docker run -d --privileged -p 80:80 desktop-ssr`&lt;br/&gt;&lt;br/&gt;docker exec -it ${container} /bin/sh&lt;br/&gt;&lt;br/&gt;docker container stop ${container}&lt;br/&gt;&lt;br/&gt;docker container rm ${container}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有两个点需要注意：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;因为依赖的 latest 标签的镜像，需要重新 pull，要不然如果本地有，远程有更新，还是会用本地的；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;需要后台运行后再进入容器，其实就是上面说的 tlinux PID=1 的那个问题；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.7 CI / CD&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译 &lt;code&gt;tsr&lt;/code&gt; 我使用的 &lt;code&gt;orange-ci&lt;/code&gt;，最主要的就是三步，登录，编译，推送。这在本地也可以运行相应的命令跑起来。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 正式环境的镜像 tag，和测试环境不一样，如 v1.0.3 这样，仓库也不一样&lt;/span&gt;&lt;br/&gt;&lt;span&gt;.getProdImageTag:&lt;/span&gt; &lt;span&gt;&amp;amp;getProdImageTag&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;获取正式环境镜像&lt;/span&gt; &lt;span&gt;Tag&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;script:&lt;/span&gt; &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;-n&lt;/span&gt; &lt;span&gt;csighub.tencentyun.com/tsr/tsr:$ORANGE_BRANCH&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;envExport:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;info:&lt;/span&gt; &lt;span&gt;DOCKER_TIME_TAG&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 编译和推送镜像&lt;/span&gt;&lt;br/&gt;&lt;span&gt;.buildAndPush:&lt;/span&gt; &lt;span&gt;&amp;amp;buildAndPush&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;镜像仓库登录&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;script:&lt;/span&gt; &lt;span&gt;docker&lt;/span&gt; &lt;span&gt;login&lt;/span&gt; &lt;span&gt;-u&lt;/span&gt; &lt;span&gt;$CSIGHUB_USER&lt;/span&gt; &lt;span&gt;-p&lt;/span&gt; &lt;span&gt;$CSIGHUB_PWD&lt;/span&gt; &lt;span&gt;csighub.tencentyun.com&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;构建镜像&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;script:&lt;/span&gt; &lt;span&gt;docker&lt;/span&gt; &lt;span&gt;build&lt;/span&gt; &lt;span&gt;--network=host&lt;/span&gt; &lt;span&gt;-t&lt;/span&gt; &lt;span&gt;${DOCKER_TIME_TAG}&lt;/span&gt; &lt;span&gt;-f&lt;/span&gt; &lt;span&gt;dockerfile&lt;/span&gt; &lt;span&gt;./&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;推送镜像&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;script:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;docker&lt;/span&gt; &lt;span&gt;push&lt;/span&gt; &lt;span&gt;${DOCKER_TIME_TAG}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而如果使用蓝盾，最主要的就是构建和推送镜像和 STKE 操作两个插件：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7158730158730159&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvaukJ07t3E8jUK2u2EfibSibZALfodNzwD2c4J7u9jZypsbRzjm5GEeicQQgACRUfhXDOmXPDLUfYtrHQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1260&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至于一些其他方面的问题，包括：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;STKE 里怎么解决持久化存储，怎么同步业务代码？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;怎么处理日志和上报？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;怎么不间断服务更新镜像？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;怎么做就绪检查和容器健康检查？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;怎么做监控和告警？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些其实是属于 STKE 的内容了，可以查找相关的资料看。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.8 接入和灰度&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们部署了 SSR 的服务后，没有人会这么虎将原来的 Nginx 服务一次性切到 SSR 的服务吧？我们会先在内部灰度试用，且我们要同步对比两边的数据。所以怎么接入就成了我们要考虑的问题。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.8.1 路由转发和机器灰度&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;腾讯文档里有个 tsw 服务用来转发请求，并且有个 routeproxy 可以设置转发规则。routeproxy 由两个参数组成，ID（指定转发到机器 IP 的规则），FD（指定机器的开发目录路径）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的 SSR 服务能处理的就是列表页的 PC + 移动端，但是其实像 /desktop/ 目录下还有其他很多页面和资源，我们需要将这部分独立开来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在开发阶段，我们可以自己写规则来验证：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.18322981366459629&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvaukJ07t3E8jUK2u2EfibSibZAZT9TfcibBJ2Pn99OcuCjejjYDMSwia7I6gZnAwrHC5MzRBlNhqzRnp0Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1288&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们准备接入了，就需要创建一个新的 L5，新的 L5 的机器仍然是现网的机器，将上诉规则的流量转到新的 L5。这样到目前为止，对现网就没有影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们需要在现网上线 SSR 服务的时候，只需要将 SSR 的机器 IP 添加到 L5 里，并逐步调整权重，这样就能够按机器来灰度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按图例来说就是这样的：（当然了，浏览器并不会直接和 tsw 交互，前面还有公司的统一接入层）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7098214285714286&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvaukJ07t3E8jUK2u2EfibSibZAVO3tCJnGIDGfVfGoqvlpPvwaldM1H7NTTNerxIjrNdTsmahkxahzwA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2240&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.8.2 多分支灰度&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面说到在测试环境或者未来的 ABTest，我们需要同时灰度多个分支。以测试环境为例，如果我们要让 SSR 分支和非 SSR 分支同时工作，除了在一开始部署的时候将代码拷贝到不同分支的目录下，如分支为 feature/test，就将代码拷贝到 /tsr-renders/feature/test 下。在用户访问的时候，cookie 是带有特定的值来标识目前要访问开发环境下的哪个文件夹的，以很简单的代码表示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;/* 设置了开发分支 */&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;/* 待渲染的 JS 文件存在 */&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;// 直出服务&lt;/span&gt;&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;/* JS 文件不存在，回退到 SSR 分支，如果 SSR 分支的 JS 文件存在，就用直出 */&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;// 直出服务&lt;/span&gt;&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;// 直接输出 HTML&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（这里其实是为了上线前的验证，才会回退到 SSR 分支的）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面说到我们在编译的时候会排除 &lt;code&gt;node_modules&lt;/code&gt; ，那么在我们做多分支灰度的时候，&lt;code&gt;node_moduels&lt;/code&gt; 是如何处理的呢？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.341046277665996&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvaukJ07t3E8jUK2u2EfibSibZA3tNPIwVwQcicoeNdjwUhGnwS9UmR9XWpW9ArWmNmvZhg7EibWB3hAHPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1988&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设我们现在有一个分支，但是我们的某次发布是按 3 个批次来灰度的（实际上我们是按 5 个批次的）：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一批次发布我们需要拷贝 &lt;code&gt;node_modules1&lt;/code&gt; 在 Gray1 文件夹，Gray2 和 Gray3 文件夹的用户访问到的仍然是旧的版本，里面用的分别是 &lt;code&gt;node_modules2&lt;/code&gt; 和 &lt;code&gt;node_modules3&lt;/code&gt; ；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二批次发布我们需要更新 Gray2，第三批次我们需要更新 Gray3；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样会带来什么问题？这意味着我们第二次，第三次发布的时候，每次都得拷贝 &lt;code&gt;node_moduels&lt;/code&gt; 文件夹，假设我们要直接全量，需要同时更新这三个文件夹，就需要拷贝三次 &lt;code&gt;node_modules&lt;/code&gt; 。在这个文件夹动辄五六百兆的情况下，即使可以排除开发依赖，在编译和推送镜像的时候，时间将会非常长。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实我们可以通过软连接来解决这个问题：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;我们第一批次发布的时候，拷贝 &lt;code&gt;node_modules&lt;/code&gt;，并且将这个文件夹放在特定于分支的目录下，拷贝到 pvc 硬盘做持久化存储；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二批次发布的时候，将原来 Gray2 文件夹内的 &lt;code&gt;node_modules&lt;/code&gt; 通过软连接指向新分支的 &lt;code&gt;node_moduels&lt;/code&gt;，第三批次发布的时候也是一样的；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;需要添加 &lt;code&gt;-l&lt;/code&gt; 参数以拷贝软连接；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (isDocker) {&lt;br/&gt;        execSync(&lt;span&gt;&#x27;rsync -l -r -t -W --force /tsr-renders/renders/ /tsr-renders/renders-pvc&#x27;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;})();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4573170731707317&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvaukJ07t3E8jUK2u2EfibSibZAPscvOL0M9745mVlqSGeOShPhl2iaUKtu2Cor92YXL7V11kAc54eAHew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1968&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.8.3 用户灰度&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;腾讯文档的用户灰度机制在于不同的用户访问页面，请求经过 tsw 后，会在 head 带上用户属于哪个灰度批次的值。不同批次访问的文件夹的代码是不一样的。那么我们服务从 head 里取出这个值，就可以从不同的文件夹下取出要运行的渲染 JS 和 HTML。假设只有两个文件夹 A 和 B，对于某次发布来说：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一次发布更新文件夹 A，灰度批次为 A 的已经被灰度到，B 批次的仍然保留旧的代码；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二次发布更新文件夹 B，所有的用户访问的代码就都是最新的了；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8 后记&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说了这么多，是否还有什么没说到的？感觉还有几点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如何做自动化测试，不仅保障 SSR 代码不出错，并且还需要直出的页面和客户端差异不大？是用图片像素比对法，还是 DOM 节点 Diff ？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SSR 直出的 DOM 节点是否可以让 CSR 复用？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;是否有更合理的错误捕获方式？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;以及 SSR 够快了吗？我觉得没有，它实际上运行耗时都在 40-100ms 以内，React Render 在 20-35ms 左右，CGI 耗时和网络传输才是大头。像里面严重依赖的 doclist CGI 平均耗时 220ms，所以还有优化空间。但是有意义吗？有，因为这个 CGI 在现网的耗时为 400ms，且还存在并行的 CGI 请求。所以现网的首屏耗时在 1500 - 2200ms 之间。SSR 不仅能够提升司内环境访问页面的首屏速度，更能够极大提升弱网区域用户的首屏体验 。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些也是我需要继续研究和实践的一些点。以两张对比图结束文章：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9209401709401709&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvaukJ07t3E8jUK2u2EfibSibZAVFicJfUfCuaq6ciav7WQwrjbLKPmo8rYjoZumSX1JXNjvS9A6rjgiaMfw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1872&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9209401709401709&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvaukJ07t3E8jUK2u2EfibSibZAgl9X8GlnDOxdsNKibLse9MzMtfRwbCibLMNQ6pQJobVCYAVjYG0V4Tmg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1872&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;罗里吧嗦说了很多，当然还有很多细节没有讲到，如果有错误的地方欢迎指正。或者有什么好方法好建议也强烈欢迎私聊交流一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们是在做&lt;strong&gt;腾讯文档的 AlloyTeam 团队&lt;/strong&gt;，腾讯文档大量招人，如果你也想来研究这么有趣的技术，或者加入开放的腾讯大家庭，无论是应聘还是内推，都欢迎联系 &lt;strong&gt;sigmaliu@tencent.com&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;腾讯 Tapd 第三期新鲜 Show 主题直播&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;今晚19:30 不见不散&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;2.732&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvas0v6srZetNzwvzr99nRmULRXvqkajEX6iaLCscs3hpwzicXwjlxpSe9OQLePEdVtCvTj7iaibhJdwfTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.729264475743349&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvatricjRxhpM1x45aB6doaVg7WMhINPwOiaqpskia1kH7hgibO0dicW2HLcW8HRGMzESQwehIcyckLXtwsA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;639&quot;/&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7564c3aa8f3a9aa303fdaa5225d4d164</guid>
<title>程序员培养之道</title>
<link>https://toutiao.io/k/s263y3a</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p data-source-line=&quot;1&quot;&gt;&lt;span&gt;让一个职场新人快速上手，独立完成任务是所有组织都想追求的目标。可是，很多军工单位的人才培养还是依靠“传帮带”，新人过了半年能接任务已经算是快的，过了1年、2年也拿不下任务的也大有人在。&lt;/span&gt;&lt;/p&gt;&lt;p data-source-line=&quot;3&quot;&gt;&lt;span&gt;下面介绍的程序员培养之道，虽然是面对软件开发人员的，但对于某些军工单位来说，即使是其他专业的人才培养也可参考一二。&lt;/span&gt;&lt;/p&gt;&lt;p data-source-line=&quot;5&quot;&gt;&lt;span&gt;我们应该怎样来快速培养出一位合格的程序员呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-source-line=&quot;7&quot;&gt;&lt;span&gt;程序员的培养可以包括以下几个方面：精神、能力、理论基础、工作方法、工作习惯。&lt;/span&gt;&lt;/p&gt;&lt;p data-source-line=&quot;9&quot;&gt;&lt;span&gt;1．精神&lt;/span&gt;&lt;/p&gt;&lt;p data-source-line=&quot;11&quot;&gt;&lt;span&gt;程序员的培养首先是要培养对软件开发工作的热情和专注投入的精神。软件开发虽然是一项智力劳动，但它需要长时间地专注地工作，没有工作热情和投入的精神，是很难长期坚持下来的。&lt;/span&gt;&lt;/p&gt;&lt;p data-source-line=&quot;13&quot;&gt;&lt;span&gt;而要培养程序员的工作热情，需要组织营造和谐的工作环境和软件技术的应用环境；培养程序员的专注投入，需要推广蕃茄工作法，结合组织的纪律考核来进行。&lt;/span&gt;&lt;/p&gt;&lt;p data-source-line=&quot;15&quot;&gt;&lt;span&gt;2．能力&lt;/span&gt;&lt;/p&gt;&lt;p data-source-line=&quot;17&quot;&gt;&lt;span&gt;程序员要培养的能力包括：逻辑思维能力、沟通能力和学习能力。&lt;/span&gt;&lt;/p&gt;&lt;p data-source-line=&quot;21&quot;&gt;&lt;span&gt;软件开发过程是解决业务逻辑的过程，是把现实中的问题映射到软件世界的过程，所以，需要程序员具有良好的逻辑思维能力。&lt;/span&gt;&lt;/p&gt;&lt;p data-source-line=&quot;23&quot;&gt;&lt;span&gt;代码中的很多逻辑错误是很难用常规的测试手段发现，最有效的排队逻辑错误的方法是人工走查，如果程序员没有良好的逻辑思想能力，怎么能发现代码中的逻辑错误？&lt;/span&gt;&lt;/p&gt;&lt;p data-source-line=&quot;25&quot;&gt;&lt;span&gt;人的逻辑思维能力可以通过一些方法进行培养。比如进行专题的培训，看推理小说，玩些游戏。&lt;/span&gt;&lt;/p&gt;&lt;p data-source-line=&quot;29&quot;&gt;&lt;span&gt;沟通是项目管理10大知识领域之一，其实你从事任何一项工作都离不开沟通。程序员在和其他人进行沟通的时候，如果不能直接了当，简洁清楚地阐述问题，会非常影响效率。&lt;/span&gt;&lt;/p&gt;&lt;p data-source-line=&quot;31&quot;&gt;&lt;span&gt;培养程序员的沟通能力，就是要给他创造更多讲话的机会，并引导他准确地表达自己。&lt;/span&gt;&lt;/p&gt;&lt;p data-source-line=&quot;35&quot;&gt;&lt;span&gt;软件技术发展很快，程序员必须具备良好的学习能力，才能够不断地跟踪和学习新技术，保持自己的业务能力。&lt;/span&gt;&lt;/p&gt;&lt;p data-source-line=&quot;37&quot;&gt;&lt;span&gt;培养程序员的学习能力，不妨给他布置学习任务，并且定期进行交流、总结。&lt;/span&gt;&lt;/p&gt;&lt;p data-source-line=&quot;39&quot;&gt;&lt;span&gt;3．理论基础&lt;/span&gt;&lt;/p&gt;&lt;p data-source-line=&quot;41&quot;&gt;&lt;span&gt;无论程序员开发的软件是哪个业务领域，他都需要掌握软件开发的理论基础知识，包括：操作系统原理、实体关系理论、SQL语句、OO基本理论、数据结构、VC++/JAVA、ASP/HTML、PSP/TSP/ISO 9000/CMM、专业英语、程序设计风格等。&lt;/span&gt;&lt;/p&gt;&lt;p data-source-line=&quot;43&quot;&gt;&lt;span&gt;培养的方法可以是专业的培训，也可以是自学。&lt;/span&gt;&lt;/p&gt;&lt;p data-source-line=&quot;45&quot;&gt;&lt;span&gt;4．工作方法&lt;/span&gt;&lt;/p&gt;&lt;p data-source-line=&quot;47&quot;&gt;&lt;span&gt;程序员高效率地编写程序，不仅需要熟练地使用相关的开发/调试工具，还要掌握一些基本的工作方法，如程序的设计方法、程序的调试方法、新工具的学习方法等。&lt;/span&gt;&lt;/p&gt;&lt;p data-source-line=&quot;49&quot;&gt;&lt;span&gt;通常的学习方法有：&lt;/span&gt;&lt;/p&gt;&lt;p data-source-line=&quot;56&quot;&gt;&lt;span&gt;当然，你也可以找专业的老师做培训。&lt;/span&gt;&lt;/p&gt;&lt;p data-source-line=&quot;58&quot;&gt;&lt;span&gt;5．工作习惯&lt;/span&gt;&lt;/p&gt;&lt;p data-source-line=&quot;60&quot;&gt;&lt;span&gt;一个好的程序员，必须养成一些好的工作习惯，比如：&lt;/span&gt;&lt;/p&gt;&lt;ul data-source-line=&quot;61&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;遵循编码规范&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;编码之前先做设计，遵循设计进行编码&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;维护好自己的开发环境&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-source-line=&quot;65&quot;&gt;&lt;span&gt;培养程序员良好的工作习惯，可以由高水平的程序员交流经验，让新人学习。&lt;/span&gt;&lt;/p&gt;&lt;p data-source-line=&quot;67&quot;&gt;&lt;span&gt;这正是：&lt;/span&gt;&lt;/p&gt;&lt;p data-source-line=&quot;69&quot;&gt;&lt;strong&gt;&lt;span&gt;培养新人也有道，精神能力很重要&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-source-line=&quot;71&quot;&gt;&lt;strong&gt;&lt;span&gt;掌握基础会方法，好的习惯也重要&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-source-line=&quot;73&quot;&gt;&lt;span&gt;参考书目：术以载道：软件过程改进实践指南，作者：任甲林，出版社：人民邮电出版社&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;h6 data-source-line=&quot;78&quot;&gt;&lt;span&gt;作者简介：王小双，长期从事GJB5000推广、实施、评价、改进的工作，创建《软件工程之思》微信公众号，一直在《软件工程之思》分享GJB5000、CMMI、软件工程的知识和感悟。现致力于GJB5000咨询以及软件过程改进、软件工程能力提升的研究工作。&lt;/span&gt;&lt;/h6&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>220076e5c7fa61e531b09408d42964bc</guid>
<title>项目用 GoModules 管理依赖的方法和经验总结</title>
<link>https://toutiao.io/k/5jnw6gc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Go&lt;/code&gt;语言官方提供的依赖包管理工具已经发布很久了，有很多大佬的文章对Go Modules做了非常详尽的介绍，比如煎鱼大佬的: &lt;strong&gt;Go Modules终极入门&lt;/strong&gt;(文章链接：https://juejin.cn/post/6844903433846145038)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天的文章我想跟大家聊一下我们项目在从&lt;code&gt;govendor&lt;/code&gt;迁移到Go Modules这个过程中总结的几点经验，如果你平时负责的项目早已开始使用Go Modules，这些内容可能对你来说有点小儿科。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;环境变量设置&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;GO111MODULE&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个环境变量是Go Modules功能的开关，目前的默认值是&lt;strong&gt;auto&lt;/strong&gt;，代表只要项目包含了&lt;code&gt;go.mod&lt;/code&gt;文件的话就自动开启Go Modules。如果之前没有设置过这个变量，这一步可以直接忽略，从其他包依赖管理工具向Go Modules迁移的时候，我们需要确认一下是不是以前在环境变量中设置过&lt;code&gt;GO111MODULE=off&lt;/code&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;GOPROXY&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go Modules拉取依赖软件包的默认镜像源站点是&lt;code&gt;https://proxy.golang.org&lt;/code&gt;，由于众所周知的问题这个域名在国内访问受限，因此需要使用&lt;code&gt;GOPROXY&lt;/code&gt;环境变量设置国内的镜像站点。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;GOPROXY=https://goproxy.cn&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;GOPRIVATE&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个环境变量主要是为项目依赖的一些公司内部的公共软件包准备的，一般是设置成代码仓库站点的域名。假如我公司所有项目都放在用&lt;code&gt;GitLab&lt;/code&gt;搭建的内部代码仓库站点，这个站点的域名是&lt;code&gt;code.lazycorp.com&lt;/code&gt;，那么我们就把这个环境变量设置成&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;GOPRIVATE=code.lazycorp.com&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样设置的话，所有路径前缀为&lt;code&gt;code.lazycorp.com&lt;/code&gt;的模块都不会再经过&lt;code&gt;GOPROXY&lt;/code&gt;指定的镜像站点拉取模块对应的软件包，转而去&lt;code&gt;code.lazycorp.com&lt;/code&gt;拉取软件包。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里提一个小技巧，假如你自己开发的时候不想污染电脑系统里的全局环境变量，可以选择在&lt;code&gt;GoLand&lt;/code&gt;里开启Go Modules支持和设置环境变量，这样在&lt;code&gt;GoLand&lt;/code&gt;内编译运行程序时也能正常使用Go Modules。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7357142857142858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f6cWfJ9mBRJJ9djdHn9upUWOPhMcVvKfGE85u10icv7ibaluMVlbTj8fbZ6dIIMM5ZbkkrwPY0zLXjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1680&quot;/&gt;&lt;figcaption&gt;GoLand配置截图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Replace完成版本替换&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;replace&lt;/code&gt;指令的本意是在&lt;code&gt;go.mod&lt;/code&gt;文件里完成用一个模块版本替换已经&lt;code&gt;require&lt;/code&gt;的模块版本的功能，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;module code.lazycorp.com/buzz/practice &lt;span&gt;// 这名是我瞎起的&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;go&lt;/span&gt; &lt;span&gt;1.13&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;replace(&lt;br/&gt;  google.golang.org/grpc v1&lt;span&gt;.33&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt; =&amp;gt; google.golang.org/grpc v1&lt;span&gt;.26&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;require (&lt;br/&gt; google.golang.org/grpc v1&lt;span&gt;.33&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的&lt;code&gt;replace&lt;/code&gt;指令标识了，使用&lt;code&gt;grpc&lt;/code&gt;的&lt;code&gt;v1.26.0&lt;/code&gt;版本，替换&lt;code&gt;require&lt;/code&gt;里声明的&lt;code&gt;v1.33.0&lt;/code&gt;版本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过也正好有&lt;code&gt;replace&lt;/code&gt;命令，才能解决好几个软件包版本兼容的问题，我遇到的软件包兼容问题主要出在&lt;code&gt;Etcd&lt;/code&gt;和&lt;code&gt;gRPC&lt;/code&gt;上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Etcd&lt;/code&gt;比较诡异，它里面的&lt;code&gt;bbolt&lt;/code&gt;子库的模块名叫&lt;code&gt;go.etcd.io/bbolt&lt;/code&gt;但是自己的源码使用这个库时在代码里使用的&lt;code&gt;import&lt;/code&gt;路径却是&lt;code&gt;github.com/coreos/bbolt&lt;/code&gt;。再加上&lt;code&gt;Etcd&lt;/code&gt;提供的软件包与&lt;code&gt;v1.30&lt;/code&gt;版本以上的&lt;code&gt;gRPC&lt;/code&gt;相互之间不兼容，所以如果&lt;code&gt;gRPC&lt;/code&gt;使用了&lt;code&gt;Etcd Naming&lt;/code&gt;做服务发现和负载均衡，目前只能通过&lt;code&gt;replace&lt;/code&gt;指令对这两个模块进行版本替换。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;replace (&lt;br/&gt; github.com/coreos/bbolt =&amp;gt; &lt;span&gt;go&lt;/span&gt;.etcd.io/bbolt v1&lt;span&gt;.3&lt;/span&gt;&lt;span&gt;.5&lt;/span&gt;&lt;br/&gt; google.golang.org/grpc v1&lt;span&gt;.33&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt; =&amp;gt; google.golang.org/grpc v1&lt;span&gt;.26&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;模块的版本控制&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;模块的版本号会与软件包的&lt;code&gt;tag&lt;/code&gt;相对应，比如上面的模块引用&lt;code&gt;google.golang.org/grpc v1.26.0&lt;/code&gt;对应于&lt;code&gt;grpc&lt;/code&gt;在&lt;code&gt;GitHub&lt;/code&gt;上代码仓库的名叫&lt;code&gt;v.1.26.0&lt;/code&gt;的标签。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意标签的名字不能随便命名，比如类似&lt;code&gt;v2020....&lt;/code&gt;的标签，Go Modules是没法识别的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go Modules模块的版本格式为“主版本号.次版本号.修订号”，版本号的递增规则如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;v1.26.0&lt;br/&gt; | |  |_ _  修订号&lt;br/&gt; | | &lt;br/&gt; | |_ _ _ _ 次版本号&lt;br/&gt; |&lt;br/&gt; |_ _ _ _ _ 主版本号&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;主版本号：当你做了不兼容的更新时变更主版本号。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;次版本号：当你做了向下兼容的功能性更新时更改次版本号。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;修订号：   当你做了向下兼容的问题补丁修正时更改修订号。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;测试和生产阶段的模块版本管理&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如我们对公司的公共包做了修改，那么怎么对公共包打标签呢？不能说在测试、仿真和生产阶段给都要给软件包打上不同版本的标签吧，这样代码仓库的标签管理起来容易混乱。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对这种情况可以将版本信息追加到“主版本号.次版本号.修订号”的后面，作为延伸，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 在测试分支上打标签&lt;br/&gt;v1.2.30-test&lt;br/&gt;// 在仿真分支上打标签&lt;br/&gt;v1.2.30-pre&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样等测试通过，引用公共软件包的项目需要上线的时候，就可以在公共软件包的&lt;code&gt;master&lt;/code&gt;分支打出&lt;code&gt;v1.2.30&lt;/code&gt;标签，将待发布项目中&lt;code&gt;go.mod&lt;/code&gt;文件里的引用更改成正式版本即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外如果公共包的代码仓库上不存在任何标签，&lt;code&gt;go get&lt;/code&gt;默认拉取的是主干分支最新一次commit对应版本的代码，并且在&lt;code&gt;go.mod&lt;/code&gt;文件里为模块分配格式为 &lt;strong&gt;v0.0.0-主干分支最新一次commit的时间-commit哈希&lt;/strong&gt; 这样的一个虚拟版本。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;常用的命令&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;go mod init&lt;/strong&gt;  初始化&lt;code&gt;go.mod&lt;/code&gt;文件，一般建新项目时才会用这个命令。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;go mod tidy&lt;/strong&gt; 整理现有依赖，修改&lt;code&gt;go.mod&lt;/code&gt;文件后执行会更新依赖。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;go mod graph&lt;/strong&gt; 查看现有的依赖结构。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;go mod vendor&lt;/strong&gt; 导出项目所有依赖到&lt;code&gt;vendor&lt;/code&gt;目录 （&lt;strong&gt;不建议使用&lt;/strong&gt;）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里列出&lt;strong&gt;go mod vendor&lt;/strong&gt;命令是提醒大家，如果使用&lt;code&gt;go mod vendor&lt;/code&gt;， 会在项目里生成一个&lt;code&gt;vendor&lt;/code&gt;目录把所有依赖导出放到这里面。此后Go Modules在项目里会去&lt;code&gt;vendor&lt;/code&gt;里查找引用的依赖包而不是默认的&lt;code&gt;$GOPATH/pkg/mod&lt;/code&gt;目录。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如我们主动更新了依赖包，还需要再次执行&lt;code&gt;go mod vendor&lt;/code&gt;把更新导出到&lt;code&gt;vendor&lt;/code&gt;目录，项目才能真正引用到更新后的依赖包。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以既然开始使用Go Modules了，就应该尽量忘记&lt;code&gt;vendor&lt;/code&gt; ，&lt;strong&gt;另外旧项目从&lt;code&gt;govendor&lt;/code&gt;改用Go Modules时的第一步也是先把项目里的&lt;code&gt;vendor&lt;/code&gt;目录删掉，再按照文章里的步骤进行操作&lt;/strong&gt; 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后推广一下我自己写的Kubernetes教程，上次的文章《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&amp;amp;mid=2247486737&amp;amp;idx=1&amp;amp;sn=e7d0689fa74b108bae734515837c68e1&amp;amp;chksm=fa80dc86cdf755909f2f29ee8cb9dce930b95a837cb045be5c9700a9000743c9cb7f8eed6731&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;深入理解StatefulSet，用Kubernetes编排有状态应用&lt;/strong&gt;&lt;/a&gt;》花了两个周末结果阅读惨淡。我写的Kubernetes文章都非常适合研发入门学习的啊&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f6cWfJ9mBRJJ9djdHn9upUWYtAk5ocLrFEWicOeh5qZKibA4hQ7Zqalpib0VeFHQbOk8s5XsX9icPvf7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;20&quot;/&gt;，大家有兴趣的话都去看看哈。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5c6ad3957370c0d0174c9095249df8d0</guid>
<title>漫话 Docker 的衰落与 Kubernetes 的兴起</title>
<link>https://toutiao.io/k/h3ooyse</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section powered-by=&quot;xiumi.us&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section label=&quot;Copyright Reserved by PLAYHUDONG.&quot; donone=&quot;shifuMouseDownCard(&#x27;shifu_c_008&#x27;)&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section label=&quot;Copyright Reserved by PLAYHUDONG.&quot; donone=&quot;shifuMouseDownCard(&#x27;shifu_c_008&#x27;)&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section label=&quot;Copyright Reserved by PLAYHUDONG.&quot; donone=&quot;shifuMouseDownCard(&#x27;shifu_c_008&#x27;)&quot;&gt;&lt;p&gt;&lt;span&gt;本文来自OPPO云平台团队高级工程师徐工，他自2014年开始从事容器化相关工作，目前负责OPPO云平台的编排与调度方向的工作，主要关注技术领域为超大规模的集群管理与调度，混合云平台建设与融合计算。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;伴随着kubernetes 1.20中对于docker的弃用，关于docker的灭亡与kubernetes的兴起的话题再度热了起来。讨论中关于docker灭亡的观点我不敢苟同。docker还远未到达灭亡的程度。相较而言，我觉得更恰当的说法应该是docker的衰落。本文我也就我个人的角度，聊聊我所经历的docker的衰落与kubernetes的兴起。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;横空出世——docker的兴起&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第一次接触docker，是2014年。当时OpenStack的主要负载还是kvm。而我们也尝试过了更为轻量的lxc，但是以失败而告终了。docker这个集装箱的小图标配上docker container的理念，一下子就吸引住了大家的目光。经历过制作lxc镜像的痛苦，你就会更体会到docker的可贵。繁琐的lxc镜像制作与精简的Dockerfile相比，孰高孰低、孰优孰劣可谓是一目了然。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;docker成功的将cgroup、union filesystem、namespace这些较为稳定和成熟的技术结合了起来，辅以docker image的制作工艺，实现了集装箱式的标准交付。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这时候的docker，颇有种“举天下之豪杰而莫能与之争”的气势。虽然在生产环节还是或多或少，还有这样那样的问题，但是docker已经跨过了POC（Proof of concept）阶段，进入了pre-product的行列了。在对docker深度定制后，最终我们团队也将OpenStack + docker的组合成功推向了生产。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.8541666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ECThdibSVDxhkCauOb7ayWWgVBfqyfJ6QkfrOWHYE6U8AhpOOAm8opkXqibFgbicvicSMHFGIV9LJjeUviaFELRicY9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;336&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那两年，知不知道docker、会不会做镜像、懂不懂docker原理成为基础架构领域面试的常见话题。虽然只有少数几个公司敢为天下先，将docker搬上了生产，但是已经没有人可以忽略这颗冉冉升起的新星了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那时活跃在各个会议、论坛上的都是docker的话题。大家热衷于讨论生产上docker遇到的坑。大家各出奇招，修修补补，跌跌撞撞，docker总算也是被搬上了生产。而在这时，即使是技术保守、持徘徊观望态度的公司，也都会安排一些人力着手跟进docker的发展与各个公司的实践经验了，这时候的docker真的是风头无两。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;生来巨人——kubernetes&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;时间到了2015年，此时我转而负责进行CaaS（Container as a Service）服务的调研。这时候大家都在说CaaS，但是每个人说的都不一样，其实大家都是摸着石头过河。在此期间，以研究OpenStack的magnum为契机，我接触到了swarm和kubernetes。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5546875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ECThdibSVDxhkCauOb7ayWWgVBfqyfJ6QIKA8HfETozhVIpzIeicv8X2G5dwK40R4pWlZXGRr4rAKuL266IzoL1w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;swarm是docker公司力推的集群管理方案。docker、swarm和compose组成的三剑客完整覆盖了运行时、集群管理与编排，构成了一个看起来牢不可摧的生态系统。特别是别出心裁的将swarm的api与docker的api进行了拉齐，将集群的管理复杂度与单节点的管理复杂度向用户进行屏蔽，倒是有一种如臂使指的快感。这个设计直到现在我都还觉得立意真的很精巧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5328767123287671&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ECThdibSVDxhkCauOb7ayWWgVBfqyfJ6QWySDVwI1OImX82IhTlPibt4jtfbIq4HedWj3It6zAboNCUPYSC5TcicQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;730&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而初出茅庐的kubernetes也来势汹汹。背靠Google的大旗，有Borg的背书，kubernetes在气势上一点不输swarm + compose的组合。伴随着kubernetes 1.0的发布，kubernetes也从幕后走向了台前，开始大规模接受来自全世界的PR提交，在功能、性能和稳定性上快速提升。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;到kubernetes 1.2版本，经过我们内部评估，已经具备生产级的品质。而声明式API、简洁的架构、灵活的标签等优秀的设计，在做选型时已经让我们完全没有理由拒绝。而后经过数月紧张的开发，kubernetes + docker的组合被搬上了舞台，并且以极快的速度侵蚀OpenStack + docker的份额。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此时的docker已经开始被限制为了容器的运行时和镜像制作工具。捆住了docker的手脚，kubernetes已经没有了可以掰手腕的对手，一统江湖的路上kubernetes再无障碍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;美人迟暮——docker的衰落&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;时至今日，docker的衰落已经成为了不争的事实，而造成这个结果的原因，我觉得是多方面的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一部分是docker自身的封闭和固执己见。我曾经记得在当时参与了当时社区多个PR的讨论。新增一个feature的超长的周期，已经可以磨掉多数人的耐心。docker社区在多个观点上略显保守的方式，让大家逐渐失去了参与的热情。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另一方面，也是更为重要的一点，是容器技术本身的门槛已经被突破，已经无法形成技术上的护城河。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;而容器技术之争，已经转化为标准之争，&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;而对于标准上更有发言权的一方，无疑是具有更多用户、更庞大社区和更强大的平台的一方。在短短两三年的时间内，天平就快速地向kubernetes倾斜，其主导的CRI、CNI、CSI标准已经成为了事实上的通行标准。而相较之下，docker力推的CNM等标准则显得曲高和寡。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5612722170252572&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ECThdibSVDxhkCauOb7ayWWgVBfqyfJ6Q2QDpj6TxEt6uzUKLEia9Mgx61lxYS57UtzoWMdVNftBH7m73aVHfOPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1069&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;与此同时，kubernetes并没有放弃主动的进攻。kubernetes的强势和扶植其他容器运行时加速了docker的衰落。在1.6版本弃用docker manager直连docker，转向CRI + dockershim的组合时，就注定了kubernetes会走到完全解耦docker，也就是今天这一步。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，其他容器运行时也开始了瓜分市场份额。如果说gVisor、Kata只是尝试挑战docker在部分场景中的地位，那么红帽的Podman则已经吹响了全面进攻的号角。再结合前两年docker的一些融资和收购传闻，平添了一种英雄末路、美人迟暮的伤感。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;回顾&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;世间多少英雄戏，每到收场总伤神。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;六年回望，其实无论是在当时还是现在来看，docker都是一个革命性的产品。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;docker的衰落并不是意味着容器运行时不重要了，而是大家越来越习以为常了。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;时至今日，容器运行时作为一个大部已经被解决的问题，一个相对成熟的模块，已经成为了整个基础架构体系的一部分。而作为上层的平台和更为上层的用户来说，对此将会给予越来越少的关注，这就像现在大多数用户并不会去关心内核了一样。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;甚至在未来，我预测运行时都有可能会成为一个内核级别的附属模块，会预装到许多的发行版上，其运行也逐渐对大多数用户变得更加透明（实际红帽已经开始向这个方向做了）。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;而越来越多的用户则会将更多的注意力集中在上层的交付、管理、编排上。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;至于kubernetes会不会衰落，我觉得在中短期内（五年内）不会。kubernetes已经成为了一个平台级的项目。在这点上，kubernetes作为平台将比工具性质的docker具有更强的生命力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;☆ &lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;END&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt; ☆&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;招聘信息&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section label=&quot;Copyright Reserved by PLAYHUDONG.&quot; donone=&quot;shifuMouseDownCard(&#x27;shifu_c_008&#x27;)&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section label=&quot;Copyright Reserved by PLAYHUDONG.&quot; donone=&quot;shifuMouseDownCard(&#x27;shifu_c_008&#x27;)&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section label=&quot;Copyright Reserved by PLAYHUDONG.&quot; donone=&quot;shifuMouseDownCard(&#x27;shifu_c_008&#x27;)&quot;&gt;&lt;p&gt;&lt;span&gt;OPPO&lt;/span&gt;&lt;span&gt;互联网云平台团队招聘一大波岗位，涵盖&lt;/span&gt;&lt;strong&gt;Java、容器、Linux内核开发、产品经理、项目经理&lt;/strong&gt;&lt;span&gt;等多个方向，请在公众号后台回复关键词&lt;/span&gt;&lt;strong&gt;“云招聘”&lt;/strong&gt;&lt;span&gt;查看查详&lt;/span&gt;&lt;span&gt;细信息。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你可能还喜欢&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section label=&quot;Copyright Reserved by PLAYHUDONG.&quot; donone=&quot;shifuMouseDownCard(&#x27;shifu_c_008&#x27;)&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section label=&quot;Copyright Reserved by PLAYHUDONG.&quot; donone=&quot;shifuMouseDownCard(&#x27;shifu_c_008&#x27;)&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section label=&quot;Copyright Reserved by PLAYHUDONG.&quot; donone=&quot;shifuMouseDownCard(&#x27;shifu_c_008&#x27;)&quot;&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4MzE2MzY1OA==&amp;amp;mid=2247485405&amp;amp;idx=1&amp;amp;sn=ecb6377ae88f12d28a261e61363ed056&amp;amp;chksm=cf4ad0b8f83d59aecaaa8ca3a5c9a837598f18e4fa5a632d17a80f3e569c333dc076104acd9b&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;如何用 CI (持续集成) 保证研发质量&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4MzE2MzY1OA==&amp;amp;mid=2247485183&amp;amp;idx=1&amp;amp;sn=510f6b563027e5dda6271d40201b4548&amp;amp;chksm=cf4ad19af83d588c604252670be1e4d7403343018e0a4b6fe96b77f5fce490a32a1a64d60e45&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;如何设计并实现存储QoS？&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4MzE2MzY1OA==&amp;amp;mid=2247485017&amp;amp;idx=1&amp;amp;sn=921779f4260acb993e8a6c27c22b00a3&amp;amp;chksm=cf4ad13cf83d582adb9c00de521ce19685de430b773b96f4f05962e605d8a7de51b95905450a&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;云原生Service Mesh探索与实践&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4MzE2MzY1OA==&amp;amp;mid=2247484381&amp;amp;idx=1&amp;amp;sn=b6b1e25c6f4e03aa21d0a2ac37a3239b&amp;amp;chksm=cf4ad4b8f83d5daea096ce1fbd2057470ac2ec0d908f66e8f270c08ab324cd6c5072c8a3d30c&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;如何进行 kubernetes 问题的排障&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4MzE2MzY1OA==&amp;amp;mid=2247484254&amp;amp;idx=1&amp;amp;sn=758ce50bf266cd560235f87ca5e5b82a&amp;amp;chksm=cf4ad43bf83d5d2d385a3324b806efba8138ad71c93268eb958ccaa364de4ac2ad94d2b9dd79&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;OPPO自研ESA DataFlow架构与实践&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;更多技术干货&lt;/span&gt;&lt;/p&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;扫码关注&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;OPPO互联网技术&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;120&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;120&quot; data-ratio=&quot;1&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ECThdibSVDxjYDM1fnDY1N9LLUp4gJV8ulKxP20jO66gHdE8q9DgFIB5hvxfBxEERyWeSxpc6nor8SPgiadWNVsQ/640?wx_fmt=jpeg&quot;/&gt; &lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;95172&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-brushtype=&quot;text&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;我就知道你“在看”&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;__bg_gif&quot; data-ratio=&quot;1.0377358490566038&quot; data-type=&quot;gif&quot; data-w=&quot;53&quot; data-width=&quot;100%&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/ECThdibSVDxjYDM1fnDY1N9LLUp4gJV8uk9kQ2Hw3Ucae5fnjEfVb2noBlx2NuTgMwzuiceEL19F9prbiaKnZZd3A/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>dcfa1011404c57138a3400ae11a32325</guid>
<title>基于 qiankun 的微前端最佳实践</title>
<link>https://toutiao.io/k/5kg314l</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;编者按：本文转载 前端日志周刊 微信公号的 晒兜斯 的文章；来一起学习吧！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;引言&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文是基于 &lt;code&gt;qiankun&lt;/code&gt; 的微前端最佳实践系列文章之 &lt;code&gt;从 0 到 1 篇&lt;/code&gt;，本文将分享如何使用 &lt;code&gt;qiankun&lt;/code&gt; 如何搭建主应用基座，然后接入不同技术栈的微应用，完成微前端架构的从 0 到 1。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本教程采用 &lt;code&gt;Vue&lt;/code&gt; 作为主应用基座，接入不同技术栈的微应用。如果你不懂 &lt;code&gt;Vue&lt;/code&gt; 也没关系，我们在搭建主应用基座的教程尽量不涉及 &lt;code&gt;Vue&lt;/code&gt; 的 &lt;code&gt;API&lt;/code&gt;，涉及到 &lt;code&gt;API&lt;/code&gt; 的地方都会给出解释。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意：&lt;code&gt;qiankun&lt;/code&gt; 属于无侵入性的微前端框架，对主应用基座和微应用的技术栈都没有要求。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在本教程中，接入了多技术栈 &lt;code&gt;微应用&lt;/code&gt; 的 &lt;code&gt;主应用&lt;/code&gt; 最终效果图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7769461077844312&quot; data-type=&quot;png&quot; data-w=&quot;1336&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ygUAW1Il7aS8BSBksFIEPz9IB2UicG4CtC7yGBVnXhkxCnwFojHKE4kkdPMUC3c7hhXay6BsDSJxTT4xDkNsg6Q/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;micro-app&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;构建主应用基座&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们以 实战案例 - feature-inject-sub-apps 分支 （案例是以 &lt;code&gt;Vue&lt;/code&gt; 为基座的主应用，接入多个微应用） 为例，来介绍一下如何在 &lt;code&gt;qiankun&lt;/code&gt; 中如何接入不同技术栈的微应用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先使用 &lt;code&gt;vue-cli&lt;/code&gt; 生成一个 &lt;code&gt;Vue&lt;/code&gt; 的项目，初始化主应用。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;vue-cli 是 &lt;code&gt;Vue&lt;/code&gt; 官方提供的脚手架工具，用于快速搭建一个 &lt;code&gt;Vue&lt;/code&gt; 项目。如果你想跳过这一步，可以直接 &lt;code&gt;clone&lt;/code&gt; 实战案例 - feature-inject-sub-apps 分支 的代码。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将普通的项目改造成 &lt;code&gt;qiankun&lt;/code&gt; 主应用基座，需要进行三步操作：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;创建微应用容器 - 用于承载微应用，渲染显示微应用；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;注册微应用 - 设置微应用激活条件，微应用地址等等；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;启动 &lt;code&gt;qiankun&lt;/code&gt;；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;创建微应用容器&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先在主应用中创建微应用的承载容器，这个容器规定了微应用的显示区域，微应用将在该容器内渲染并显示。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先设置路由，路由文件规定了主应用自身的路由匹配规则，代码实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// micro-app-main/src/routes/index.ts&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; Home &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;@/pages/home/index.vue&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; routes = [&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * path: 路径为 / 时触发该路由规则&lt;br/&gt;     * name: 路由的 name 为 Home&lt;br/&gt;     * component: 触发路由时加载 `Home` 组件&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    path: &lt;span&gt;&quot;/&quot;&lt;/span&gt;,&lt;br/&gt;    name: &lt;span&gt;&quot;Home&quot;&lt;/span&gt;,&lt;br/&gt;    component: Home,&lt;br/&gt;  },&lt;br/&gt;];&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; routes;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// micro-app-main/src/main.ts&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; Vue &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;vue&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; VueRouter &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;vue-router&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; routes &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;./routes&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 注册路由实例&lt;br/&gt; * 即将开始监听 location 变化，触发路由规则&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; router = &lt;span&gt;new&lt;/span&gt; VueRouter({&lt;br/&gt;  mode: &lt;span&gt;&quot;history&quot;&lt;/span&gt;,&lt;br/&gt;  routes,&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 创建 Vue 实例&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 该实例将挂载/渲染在 id 为 main-app 的节点上&lt;/span&gt;&lt;br/&gt;&lt;span&gt;new&lt;/span&gt; Vue({&lt;br/&gt;  router,&lt;br/&gt;  render: &lt;span&gt;(&lt;span&gt;h&lt;/span&gt;) =&amp;gt;&lt;/span&gt; h(App),&lt;br/&gt;}).$mount(&lt;span&gt;&quot;#main-app&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面代码可以看出，我们设置了主应用的路由规则，设置了 &lt;code&gt;Home&lt;/code&gt; 主页的路由匹配规则。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们现在来设置主应用的布局，我们会有一个菜单和显示区域，代码实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// micro-app-main/src/App.vue&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; App &lt;span&gt;extends&lt;/span&gt; Vue {&lt;br/&gt;  &lt;span&gt;/**&lt;br/&gt;   * 菜单列表&lt;br/&gt;   * key: 唯一 Key 值&lt;br/&gt;   * title: 菜单标题&lt;br/&gt;   * path: 菜单对应的路径&lt;br/&gt;   */&lt;/span&gt;&lt;br/&gt;  menus = [&lt;br/&gt;    {&lt;br/&gt;      key: &lt;span&gt;&quot;Home&quot;&lt;/span&gt;,&lt;br/&gt;      title: &lt;span&gt;&quot;主页&quot;&lt;/span&gt;,&lt;br/&gt;      path: &lt;span&gt;&quot;/&quot;&lt;/span&gt;,&lt;br/&gt;    },&lt;br/&gt;  ];&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的代码是我们对菜单配置的实现，我们还需要实现基座和微应用的显示区域（如下图）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5782945736434109&quot; data-type=&quot;png&quot; data-w=&quot;1290&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ygUAW1Il7aS8BSBksFIEPz9IB2UicG4CtLBCmuWyRfBngg13Kbtz17f74MlynC9g5F1Nx4keW14uwjeoib2h5p2w/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;micro-app&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来分析一下上面的代码：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;第 5 行&lt;/code&gt;：主应用菜单，用于渲染菜单；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;第 9 行&lt;/code&gt;：主应用渲染区。在触发主应用路由规则时（由路由配置表的 &lt;code&gt;$route.name&lt;/code&gt; 判断），将渲染主应用的组件；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;第 10 行&lt;/code&gt;：微应用渲染区。在未触发主应用路由规则时（由路由配置表的 &lt;code&gt;$route.name&lt;/code&gt;判断），将渲染微应用节点；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的分析可以看出，我们使用了在路由表配置的 &lt;code&gt;name&lt;/code&gt; 字段进行判断，判断当前路由是否为主应用路由，最后决定渲染主应用组件或是微应用节点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于篇幅原因，样式实现代码就不贴出来了，最后主应用的实现效果如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8701517706576728&quot; data-type=&quot;png&quot; data-w=&quot;1186&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ygUAW1Il7aS8BSBksFIEPz9IB2UicG4CtraRNOCriabouf0M8kDFakrwRhricfo9DpichRUnialwLKINvNAFL8wiabOA/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;micro-app&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上图可以看出，我们主应用的组件和微应用是显示在同一片内容区域，根据路由规则决定渲染规则。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;注册微应用&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在构建好了主框架后，我们需要使用 &lt;code&gt;qiankun&lt;/code&gt; 的 &lt;code&gt;registerMicroApps&lt;/code&gt; 方法注册微应用，代码实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// micro-app-main/src/micro/apps.ts&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 此时我们还没有微应用，所以 apps 为空&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; apps = [];&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; apps;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// micro-app-main/src/micro/index.ts&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 一个进度条插件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; NProgress &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;nprogress&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;&quot;nprogress/nprogress.css&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { message } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;ant-design-vue&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; {&lt;br/&gt;  registerMicroApps,&lt;br/&gt;  addGlobalUncaughtErrorHandler,&lt;br/&gt;  start,&lt;br/&gt;} &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;qiankun&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 微应用注册信息&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; apps &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;./apps&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 注册微应用&lt;br/&gt; * 第一个参数 - 微应用的注册信息&lt;br/&gt; * 第二个参数 - 全局生命周期钩子&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;registerMicroApps(apps, {&lt;br/&gt;  &lt;span&gt;// qiankun 生命周期钩子 - 微应用加载前&lt;/span&gt;&lt;br/&gt;  beforeLoad: &lt;span&gt;(&lt;span&gt;app: &lt;span&gt;any&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 加载微应用前，加载进度条&lt;/span&gt;&lt;br/&gt;    NProgress.start();&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;before load&quot;&lt;/span&gt;, app.name);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;.resolve();&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;// qiankun 生命周期钩子 - 微应用挂载后&lt;/span&gt;&lt;br/&gt;  afterMount: &lt;span&gt;(&lt;span&gt;app: &lt;span&gt;any&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 加载微应用前，进度条加载完成&lt;/span&gt;&lt;br/&gt;    NProgress.done();&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;after mount&quot;&lt;/span&gt;, app.name);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;.resolve();&lt;br/&gt;  },&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 添加全局的未捕获异常处理器&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;addGlobalUncaughtErrorHandler(&lt;span&gt;(&lt;span&gt;event: Event | &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.error(event);&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; { message: msg } = event &lt;span&gt;as&lt;/span&gt; &lt;span&gt;any&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;// 加载失败时提示&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (msg &amp;amp;&amp;amp; msg.includes(&lt;span&gt;&quot;died in status LOADING_SOURCE_CODE&quot;&lt;/span&gt;)) {&lt;br/&gt;    message.error(&lt;span&gt;&quot;微应用加载失败，请检查应用是否可运行&quot;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 导出 qiankun 的启动函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; start;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面可以看出，我们的微应用注册信息在 &lt;code&gt;apps&lt;/code&gt; 数组中（此时为空，我们在后面接入微应用时会添加微应用注册信息），然后使用 &lt;code&gt;qiankun&lt;/code&gt; 的 &lt;code&gt;registerMicroApps&lt;/code&gt; 方法注册微应用，最后导出了 &lt;code&gt;start&lt;/code&gt; 函数，注册微应用的工作就完成啦！&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;启动主应用&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在注册好了微应用，导出 &lt;code&gt;start&lt;/code&gt; 函数后，我们需要在合适的地方调用 &lt;code&gt;start&lt;/code&gt; 启动主应用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们一般是在入口文件启动 &lt;code&gt;qiankun&lt;/code&gt; 主应用，代码实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// micro-app-main/src/main.ts&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; startQiankun &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;./micro&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;startQiankun();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，启动我们的主应用，效果图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8701517706576728&quot; data-type=&quot;png&quot; data-w=&quot;1186&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ygUAW1Il7aS8BSBksFIEPz9IB2UicG4CtraRNOCriabouf0M8kDFakrwRhricfo9DpichRUnialwLKINvNAFL8wiabOA/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;micro-app&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为我们还没有注册任何微应用，所以这里的效果图和上面的效果图是一样的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这一步，我们的主应用基座就创建好啦！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接入微应用&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们现在的主应用基座只有一个主页，现在我们需要接入微应用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;qiankun&lt;/code&gt; 内部通过 &lt;code&gt;import-entry-html&lt;/code&gt; 加载微应用，要求微应用需要导出生命周期钩子函数（见下图）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.17716535433070865&quot; data-type=&quot;png&quot; data-w=&quot;1524&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ygUAW1Il7aS8BSBksFIEPz9IB2UicG4Cte3g02DBPLUpcO0HHbJDwQDbC005E1VbTIOvfKhERIQOxRu6RMS8Dpw/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;micro-app&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上图可以看出，&lt;code&gt;qiankun&lt;/code&gt; 内部会校验微应用的生命周期钩子函数，如果微应用没有导出这三个生命周期钩子函数，则微应用会加载失败。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们使用了脚手架搭建微应用的话，我们可以通过 &lt;code&gt;webpack&lt;/code&gt; 配置在入口文件处导出这三个生命周期钩子函数。如果没有使用脚手架的话，也可以直接在微应用的 &lt;code&gt;window&lt;/code&gt; 上挂载这三个生命周期钩子函数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在我们来接入我们的各个技术栈微应用吧！&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意，下面的内容对相关技术栈 &lt;code&gt;API&lt;/code&gt; 不会再有过多介绍啦，如果你要接入不同技术栈的微应用，最好要对该技术栈有一些基础了解。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接入 &lt;code&gt;Vue&lt;/code&gt; 微应用&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们以 实战案例 - feature-inject-sub-apps 分支 为例，我们在主应用的同级目录（&lt;code&gt;micro-app-main&lt;/code&gt; 同级目录），使用 &lt;code&gt;vue-cli&lt;/code&gt; 先创建一个 &lt;code&gt;Vue&lt;/code&gt; 的项目，在命令行运行如下命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;vue create micro-app-vue&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文的 &lt;code&gt;vue-cli&lt;/code&gt; 选项如下图所示，你也可以根据自己的喜好选择配置。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3502824858757062&quot; data-type=&quot;png&quot; data-w=&quot;2124&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ygUAW1Il7aS8BSBksFIEPz9IB2UicG4CtIPl8ic3vUluYjnibQWibrG3fqPwtyk8WcKYysOQSZm48pXRiaFIlbB1ndQ/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;micro-app&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在新建项目完成后，我们创建几个路由页面再加上一些样式，最后效果如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.46102150537634407&quot; data-type=&quot;png&quot; data-w=&quot;744&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ygUAW1Il7aS8BSBksFIEPz9IB2UicG4CtuoUHEwWIG1fFHIBPtAhFH1DaY5Jb0SUzPLAp0IlnszxHkkdamD7kNA/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;micro-app&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4429778247096093&quot; data-type=&quot;png&quot; data-w=&quot;1894&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ygUAW1Il7aS8BSBksFIEPz9IB2UicG4Ct2bwBkoibr7j9MsWgL5ljYIibYg6Tq8g6ExjFCGFibcx3ArM2PwUCplQSA/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;micro-app&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;注册微应用&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在创建好了 &lt;code&gt;Vue&lt;/code&gt; 微应用后，我们可以开始我们的接入工作了。首先我们需要在主应用中注册该微应用的信息，代码实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// micro-app-main/src/micro/apps.ts&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; apps = [&lt;br/&gt;  &lt;span&gt;/**&lt;br/&gt;   * name: 微应用名称 - 具有唯一性&lt;br/&gt;   * entry: 微应用入口 - 通过该地址加载微应用&lt;br/&gt;   * container: 微应用挂载节点 - 微应用加载完成后将挂载在该节点上&lt;br/&gt;   * activeRule: 微应用触发的路由规则 - 触发路由规则后将加载该微应用&lt;br/&gt;   */&lt;/span&gt;&lt;br/&gt;  {&lt;br/&gt;    name: &lt;span&gt;&quot;VueMicroApp&quot;&lt;/span&gt;,&lt;br/&gt;    entry: &lt;span&gt;&quot;//localhost:10200&quot;&lt;/span&gt;,&lt;br/&gt;    container: &lt;span&gt;&quot;#frame&quot;&lt;/span&gt;,&lt;br/&gt;    activeRule: &lt;span&gt;&quot;/vue&quot;&lt;/span&gt;,&lt;br/&gt;  },&lt;br/&gt;];&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; apps;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面的代码，我们就在主应用中注册了我们的 &lt;code&gt;Vue&lt;/code&gt; 微应用，进入 &lt;code&gt;/vue&lt;/code&gt; 路由时将加载我们的 &lt;code&gt;Vue&lt;/code&gt; 微应用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在菜单配置处也加入 &lt;code&gt;Vue&lt;/code&gt; 微应用的快捷入口，代码实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// micro-app-main/src/App.vue&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; App &lt;span&gt;extends&lt;/span&gt; Vue {&lt;br/&gt;  &lt;span&gt;/**&lt;br/&gt;   * 菜单列表&lt;br/&gt;   * key: 唯一 Key 值&lt;br/&gt;   * title: 菜单标题&lt;br/&gt;   * path: 菜单对应的路径&lt;br/&gt;   */&lt;/span&gt;&lt;br/&gt;  menus = [&lt;br/&gt;    {&lt;br/&gt;      key: &lt;span&gt;&quot;Home&quot;&lt;/span&gt;,&lt;br/&gt;      title: &lt;span&gt;&quot;主页&quot;&lt;/span&gt;,&lt;br/&gt;      path: &lt;span&gt;&quot;/&quot;&lt;/span&gt;,&lt;br/&gt;    },&lt;br/&gt;    {&lt;br/&gt;      key: &lt;span&gt;&quot;VueMicroApp&quot;&lt;/span&gt;,&lt;br/&gt;      title: &lt;span&gt;&quot;Vue 主页&quot;&lt;/span&gt;,&lt;br/&gt;      path: &lt;span&gt;&quot;/vue&quot;&lt;/span&gt;,&lt;br/&gt;    },&lt;br/&gt;    {&lt;br/&gt;      key: &lt;span&gt;&quot;VueMicroAppList&quot;&lt;/span&gt;,&lt;br/&gt;      title: &lt;span&gt;&quot;Vue 列表页&quot;&lt;/span&gt;,&lt;br/&gt;      path: &lt;span&gt;&quot;/vue/list&quot;&lt;/span&gt;,&lt;br/&gt;    },&lt;br/&gt;  ];&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;菜单配置完成后，我们的主应用基座效果图如下&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6067146282973621&quot; data-type=&quot;png&quot; data-w=&quot;1251&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ygUAW1Il7aS8BSBksFIEPz9IB2UicG4Ct1TJPVM9icBlIVaHt6SkKMyicdYIO4mmwPmUJ1Fl0I5ggtgyzU1OOu6qg/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;micro-app&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;配置微应用&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在主应用注册好了微应用后，我们还需要对微应用进行一系列的配置。首先，我们在 &lt;code&gt;Vue&lt;/code&gt; 的入口文件 &lt;code&gt;main.js&lt;/code&gt; 中，导出 &lt;code&gt;qiankun&lt;/code&gt; 主应用所需要的三个生命周期钩子函数，代码实现如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8622641509433963&quot; data-type=&quot;png&quot; data-w=&quot;2120&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ygUAW1Il7aS8BSBksFIEPz9IB2UicG4CtSOEapuibjDJsRsEYZlzlmEmrDATZVhfJMury5pWJHviaibzoXcmQRuXSQ/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;micro-app&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上图来分析：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;第 6 行&lt;/code&gt;：&lt;code&gt;webpack&lt;/code&gt; 默认的 &lt;code&gt;publicPath&lt;/code&gt; 为 &lt;code&gt;&quot;&quot;&lt;/code&gt; 空字符串，会基于当前路径来加载资源。我们在主应用中加载微应用时需要重新设置 &lt;code&gt;publicPath&lt;/code&gt;，这样才能正确加载微应用的相关资源。（&lt;code&gt;public-path.js&lt;/code&gt; 具体实现在后面）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;第 21 行&lt;/code&gt;：微应用的挂载函数，在主应用中运行时将在 &lt;code&gt;mount&lt;/code&gt; 生命周期钩子函数中调用，可以保证在沙箱内运行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;第 38 行&lt;/code&gt;：微应用独立运行时，直接执行 &lt;code&gt;render&lt;/code&gt; 函数挂载微应用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;第 46 行&lt;/code&gt;：微应用导出的生命周期钩子函数 - &lt;code&gt;bootstrap&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;第 53 行&lt;/code&gt;：微应用导出的生命周期钩子函数 - &lt;code&gt;mount&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;第 61 行&lt;/code&gt;：微应用导出的生命周期钩子函数 - &lt;code&gt;unmount&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完整代码实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// micro-app-vue/src/public-path.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;window&lt;/span&gt;.__POWERED_BY_QIANKUN__) {&lt;br/&gt;  &lt;span&gt;// 动态设置 webpack publicPath，防止资源加载出错&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// eslint-disable-next-line no-undef&lt;/span&gt;&lt;br/&gt;  __webpack_public_path__ = &lt;span&gt;window&lt;/span&gt;.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// micro-app-vue/src/main.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; Vue &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;vue&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; VueRouter &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;vue-router&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; Antd &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;ant-design-vue&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;&quot;ant-design-vue/dist/antd.css&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;&quot;./public-path&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; App &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;./App.vue&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; routes &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;./routes&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;Vue.use(VueRouter);&lt;br/&gt;Vue.use(Antd);&lt;br/&gt;Vue.config.productionTip = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; instance = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; router = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 渲染函数&lt;br/&gt; * 两种情况：主应用生命周期钩子中运行 / 微应用单独启动时运行&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;render&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 在 render 中创建 VueRouter，可以保证在卸载微应用时，移除 location 事件监听，防止事件污染&lt;/span&gt;&lt;br/&gt;  router = &lt;span&gt;new&lt;/span&gt; VueRouter({&lt;br/&gt;    &lt;span&gt;// 运行在主应用中时，添加路由命名空间 /vue&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;base&lt;/span&gt;: &lt;span&gt;window&lt;/span&gt;.__POWERED_BY_QIANKUN__ ? &lt;span&gt;&quot;/vue&quot;&lt;/span&gt; : &lt;span&gt;&quot;/&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;mode&lt;/span&gt;: &lt;span&gt;&quot;history&quot;&lt;/span&gt;,&lt;br/&gt;    routes,&lt;br/&gt;  });&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 挂载应用&lt;/span&gt;&lt;br/&gt;  instance = &lt;span&gt;new&lt;/span&gt; Vue({&lt;br/&gt;    router,&lt;br/&gt;    &lt;span&gt;render&lt;/span&gt;: &lt;span&gt;(&lt;span&gt;h&lt;/span&gt;) =&amp;gt;&lt;/span&gt; h(App),&lt;br/&gt;  }).$mount(&lt;span&gt;&quot;#app&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 独立运行时，直接挂载应用&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;window&lt;/span&gt;.__POWERED_BY_QIANKUN__) {&lt;br/&gt;  render();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * bootstrap 只会在微应用初始化的时候调用一次，下次微应用重新进入时会直接调用 mount 钩子，不会再重复触发 bootstrap。&lt;br/&gt; * 通常我们可以在这里做一些全局变量的初始化，比如不会在 unmount 阶段被销毁的应用级别的缓存等。&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;bootstrap&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;VueMicroApp bootstraped&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 应用每次进入都会调用 mount 方法，通常我们在这里触发应用的渲染方法&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;mount&lt;/span&gt;(&lt;span&gt;props&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;VueMicroApp mount&quot;&lt;/span&gt;, props);&lt;br/&gt;  render(props);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 应用每次 切出/卸载 会调用的方法，通常在这里我们会卸载微应用的应用实例&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;unmount&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;VueMicroApp unmount&quot;&lt;/span&gt;);&lt;br/&gt;  instance.$destroy();&lt;br/&gt;  instance = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;  router = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在配置好了入口文件 &lt;code&gt;main.js&lt;/code&gt; 后，我们还需要配置 &lt;code&gt;webpack&lt;/code&gt;，使 &lt;code&gt;main.js&lt;/code&gt; 导出的生命周期钩子函数可以被 &lt;code&gt;qiankun&lt;/code&gt; 识别获取。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们直接配置 &lt;code&gt;vue.config.js&lt;/code&gt; 即可，代码实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// micro-app-vue/vue.config.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; path = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&quot;path&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;module&lt;/span&gt;.exports = {&lt;br/&gt;  &lt;span&gt;devServer&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;// 监听端口&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;port&lt;/span&gt;: &lt;span&gt;10200&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;// 关闭主机检查，使微应用可以被 fetch&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;disableHostCheck&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;// 配置跨域请求头，解决开发环境的跨域问题&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;headers&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;Access-Control-Allow-Origin&quot;&lt;/span&gt;: &lt;span&gt;&quot;*&quot;&lt;/span&gt;,&lt;br/&gt;    },&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;configureWebpack&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;resolve&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;alias&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;&quot;@&quot;&lt;/span&gt;: path.resolve(__dirname, &lt;span&gt;&quot;src&quot;&lt;/span&gt;),&lt;br/&gt;      },&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;output&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;// 微应用的包名，这里与主应用中注册的微应用名称一致&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;library&lt;/span&gt;: &lt;span&gt;&quot;VueMicroApp&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;// 将你的 library 暴露为所有的模块定义下都可运行的方式&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;libraryTarget&lt;/span&gt;: &lt;span&gt;&quot;umd&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;// 按需加载相关，设置为 webpackJsonp_VueMicroApp 即可&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;jsonpFunction&lt;/span&gt;: &lt;span&gt;`webpackJsonp_VueMicroApp`&lt;/span&gt;,&lt;br/&gt;    },&lt;br/&gt;  },&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们需要重点关注一下 &lt;code&gt;output&lt;/code&gt; 选项，当我们把 &lt;code&gt;libraryTarget&lt;/code&gt; 设置为 &lt;code&gt;umd&lt;/code&gt; 后，我们的 &lt;code&gt;library&lt;/code&gt; 就暴露为所有的模块定义下都可运行的方式了，主应用就可以获取到微应用的生命周期钩子函数了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;code&gt;vue.config.js&lt;/code&gt; 修改完成后，我们重新启动 &lt;code&gt;Vue&lt;/code&gt; 微应用，然后打开主应用基座 &lt;code&gt;http://localhost:9999&lt;/code&gt;。我们点击左侧菜单切换到微应用，此时我们的 &lt;code&gt;Vue&lt;/code&gt; 微应用被正确加载啦！（见下图）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8305084745762712&quot; data-type=&quot;png&quot; data-w=&quot;1180&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ygUAW1Il7aS8BSBksFIEPz9IB2UicG4CtUHPzKCruHvx2821Jfm7Dpv79VeiaibEQ3icZMPd12xF9dYiagfZNqNuypA/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;micro-app&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时我们打开控制台，可以看到我们所执行的生命周期钩子函数（见下图）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3652094717668488&quot; data-type=&quot;png&quot; data-w=&quot;1098&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ygUAW1Il7aS8BSBksFIEPz9IB2UicG4CtXSsBvckpbYljppIav707xoBuYicehZueUdjL5AyHXFdDPFkb4B0L7Tg/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;micro-app&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里，&lt;code&gt;Vue&lt;/code&gt; 微应用就接入成功了！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接入 &lt;code&gt;React&lt;/code&gt; 微应用&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们以 实战案例 - feature-inject-sub-apps 分支 为例，我们在主应用的同级目录（&lt;code&gt;micro-app-main&lt;/code&gt; 同级目录），使用 &lt;code&gt;react-create-app&lt;/code&gt; 先创建一个 &lt;code&gt;React&lt;/code&gt; 的项目，在命令行运行如下命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npx create-react-app micro-app-react&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在项目创建完成后，我们在根目录下添加 &lt;code&gt;.env&lt;/code&gt; 文件，设置项目监听的端口，代码实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# micro-app-react/.env&lt;/span&gt;&lt;br/&gt;PORT=10100&lt;br/&gt;BROWSER=none&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后，我们创建几个路由页面再加上一些样式，最后效果如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5404277516953573&quot; data-type=&quot;png&quot; data-w=&quot;1917&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ygUAW1Il7aS8BSBksFIEPz9IB2UicG4CtYhxqGmpVxDl9NNsxANsXlI4iaHqcWXeJNhaYJcdqSET1ZarmwdmOymQ/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;micro-app&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5405122843700993&quot; data-type=&quot;png&quot; data-w=&quot;1913&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ygUAW1Il7aS8BSBksFIEPz9IB2UicG4Ct9xQMPKuALwzITOeudd9hFnT4VCQNeE9dznkJQC9LTwSeJia6xX5hNSw/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;micro-app&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;注册微应用&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在创建好了 &lt;code&gt;React&lt;/code&gt; 微应用后，我们可以开始我们的接入工作了。首先我们需要在主应用中注册该微应用的信息，代码实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// micro-app-main/src/micro/apps.ts&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; apps = [&lt;br/&gt;  &lt;span&gt;/**&lt;br/&gt;   * name: 微应用名称 - 具有唯一性&lt;br/&gt;   * entry: 微应用入口 - 通过该地址加载微应用&lt;br/&gt;   * container: 微应用挂载节点 - 微应用加载完成后将挂载在该节点上&lt;br/&gt;   * activeRule: 微应用触发的路由规则 - 触发路由规则后将加载该微应用&lt;br/&gt;   */&lt;/span&gt;&lt;br/&gt;  {&lt;br/&gt;    name: &lt;span&gt;&quot;ReactMicroApp&quot;&lt;/span&gt;,&lt;br/&gt;    entry: &lt;span&gt;&quot;//localhost:10100&quot;&lt;/span&gt;,&lt;br/&gt;    container: &lt;span&gt;&quot;#frame&quot;&lt;/span&gt;,&lt;br/&gt;    activeRule: &lt;span&gt;&quot;/react&quot;&lt;/span&gt;,&lt;br/&gt;  },&lt;br/&gt;];&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; apps;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面的代码，我们就在主应用中注册了我们的 &lt;code&gt;React&lt;/code&gt; 微应用，进入 &lt;code&gt;/react&lt;/code&gt; 路由时将加载我们的 &lt;code&gt;React&lt;/code&gt; 微应用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在菜单配置处也加入 &lt;code&gt;React&lt;/code&gt; 微应用的快捷入口，代码实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// micro-app-main/src/App.vue&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; App &lt;span&gt;extends&lt;/span&gt; Vue {&lt;br/&gt;  &lt;span&gt;/**&lt;br/&gt;   * 菜单列表&lt;br/&gt;   * key: 唯一 Key 值&lt;br/&gt;   * title: 菜单标题&lt;br/&gt;   * path: 菜单对应的路径&lt;br/&gt;   */&lt;/span&gt;&lt;br/&gt;  menus = [&lt;br/&gt;    {&lt;br/&gt;      key: &lt;span&gt;&quot;Home&quot;&lt;/span&gt;,&lt;br/&gt;      title: &lt;span&gt;&quot;主页&quot;&lt;/span&gt;,&lt;br/&gt;      path: &lt;span&gt;&quot;/&quot;&lt;/span&gt;,&lt;br/&gt;    },&lt;br/&gt;    {&lt;br/&gt;      key: &lt;span&gt;&quot;ReactMicroApp&quot;&lt;/span&gt;,&lt;br/&gt;      title: &lt;span&gt;&quot;React 主页&quot;&lt;/span&gt;,&lt;br/&gt;      path: &lt;span&gt;&quot;/react&quot;&lt;/span&gt;,&lt;br/&gt;    },&lt;br/&gt;    {&lt;br/&gt;      key: &lt;span&gt;&quot;ReactMicroAppList&quot;&lt;/span&gt;,&lt;br/&gt;      title: &lt;span&gt;&quot;React 列表页&quot;&lt;/span&gt;,&lt;br/&gt;      path: &lt;span&gt;&quot;/react/list&quot;&lt;/span&gt;,&lt;br/&gt;    },&lt;br/&gt;  ];&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;菜单配置完成后，我们的主应用基座效果图如下&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7394084732214229&quot; data-type=&quot;png&quot; data-w=&quot;1251&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ygUAW1Il7aS8BSBksFIEPz9IB2UicG4CtWyRsBlEMCdks0iavYBicl2TBQSpYscwkUibugJ1ax1d01JsbJnKf5KQLw/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;micro-app&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;配置微应用&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在主应用注册好了微应用后，我们还需要对微应用进行一系列的配置。首先，我们在 &lt;code&gt;React&lt;/code&gt;的入口文件 &lt;code&gt;index.js&lt;/code&gt; 中，导出 &lt;code&gt;qiankun&lt;/code&gt; 主应用所需要的三个生命周期钩子函数，代码实现如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7803468208092486&quot; data-type=&quot;png&quot; data-w=&quot;1730&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ygUAW1Il7aS8BSBksFIEPz9IB2UicG4Ctyv5ddLWdS0d9AzfXy6sibNXiaM7joe6o8AdCFKDDAoIA0NQHLhlgSyGw/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;micro-app&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上图来分析：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;第 5 行&lt;/code&gt;：&lt;code&gt;webpack&lt;/code&gt; 默认的 &lt;code&gt;publicPath&lt;/code&gt; 为 &lt;code&gt;&quot;&quot;&lt;/code&gt; 空字符串，会基于当前路径来加载资源。我们在主应用中加载微应用时需要重新设置 &lt;code&gt;publicPath&lt;/code&gt;，这样才能正确加载微应用的相关资源。（&lt;code&gt;public-path.js&lt;/code&gt; 具体实现在后面）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;第 12 行&lt;/code&gt;：微应用的挂载函数，在主应用中运行时将在 &lt;code&gt;mount&lt;/code&gt; 生命周期钩子函数中调用，可以保证在沙箱内运行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;第 17 行&lt;/code&gt;：微应用独立运行时，直接执行 &lt;code&gt;render&lt;/code&gt; 函数挂载微应用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;第 25 行&lt;/code&gt;：微应用导出的生命周期钩子函数 - &lt;code&gt;bootstrap&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;第 32 行&lt;/code&gt;：微应用导出的生命周期钩子函数 - &lt;code&gt;mount&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;第 40 行&lt;/code&gt;：微应用导出的生命周期钩子函数 - &lt;code&gt;unmount&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完整代码实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// micro-app-react/src/public-path.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;window&lt;/span&gt;.__POWERED_BY_QIANKUN__) {&lt;br/&gt;  &lt;span&gt;// 动态设置 webpack publicPath，防止资源加载出错&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// eslint-disable-next-line no-undef&lt;/span&gt;&lt;br/&gt;  __webpack_public_path__ = &lt;span&gt;window&lt;/span&gt;.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// micro-app-react/src/index.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; React &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;react&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; ReactDOM &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;react-dom&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;&quot;antd/dist/antd.css&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;&quot;./public-path&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; App &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;./App.jsx&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 渲染函数&lt;br/&gt; * 两种情况：主应用生命周期钩子中运行 / 微应用单独启动时运行&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;render&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  ReactDOM.render(&lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;App&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/span&gt;, &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&quot;root&quot;&lt;/span&gt;));&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 独立运行时，直接挂载应用&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;window&lt;/span&gt;.__POWERED_BY_QIANKUN__) {&lt;br/&gt;  render();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * bootstrap 只会在微应用初始化的时候调用一次，下次微应用重新进入时会直接调用 mount 钩子，不会再重复触发 bootstrap。&lt;br/&gt; * 通常我们可以在这里做一些全局变量的初始化，比如不会在 unmount 阶段被销毁的应用级别的缓存等。&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;bootstrap&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;ReactMicroApp bootstraped&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 应用每次进入都会调用 mount 方法，通常我们在这里触发应用的渲染方法&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;mount&lt;/span&gt;(&lt;span&gt;props&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;ReactMicroApp mount&quot;&lt;/span&gt;, props);&lt;br/&gt;  render(props);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 应用每次 切出/卸载 会调用的方法，通常在这里我们会卸载微应用的应用实例&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;unmount&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;ReactMicroApp unmount&quot;&lt;/span&gt;);&lt;br/&gt;  ReactDOM.unmountComponentAtNode(&lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&quot;root&quot;&lt;/span&gt;));&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在配置好了入口文件 &lt;code&gt;index.js&lt;/code&gt; 后，我们还需要配置路由命名空间，以确保主应用可以正确加载微应用，代码实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// micro-app-react/src/App.jsx&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; BASE_NAME = &lt;span&gt;window&lt;/span&gt;.__POWERED_BY_QIANKUN__ ? &lt;span&gt;&quot;/react&quot;&lt;/span&gt; : &lt;span&gt;&quot;&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; App = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;    &lt;span&gt;// 设置路由命名空间&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;Router&lt;/span&gt; &lt;span&gt;basename&lt;/span&gt;=&lt;span&gt;{BASE_NAME}&lt;/span&gt;&amp;gt;&lt;/span&gt;{/* ... */}&lt;span&gt;&amp;lt;/&lt;span&gt;Router&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;  );&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，我们还需要配置 &lt;code&gt;webpack&lt;/code&gt;，使 &lt;code&gt;index.js&lt;/code&gt; 导出的生命周期钩子函数可以被 &lt;code&gt;qiankun&lt;/code&gt; 识别获取。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们需要借助 &lt;code&gt;react-app-rewired&lt;/code&gt; 来帮助我们修改 &lt;code&gt;webpack&lt;/code&gt; 的配置，我们直接安装该插件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npm install react-app-rewired -D&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;code&gt;react-app-rewired&lt;/code&gt; 安装完成后，我们还需要修改 &lt;code&gt;package.json&lt;/code&gt; 的 &lt;code&gt;scripts&lt;/code&gt; 选项，修改为由 &lt;code&gt;react-app-rewired&lt;/code&gt; 启动应用，就像下面这样&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// micro-app-react/package.json&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&quot;scripts&quot;&lt;/span&gt;: {&lt;br/&gt;  &lt;span&gt;&quot;start&quot;&lt;/span&gt;: &lt;span&gt;&quot;react-app-rewired start&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;build&quot;&lt;/span&gt;: &lt;span&gt;&quot;react-app-rewired build&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;test&quot;&lt;/span&gt;: &lt;span&gt;&quot;react-app-rewired test&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;eject&quot;&lt;/span&gt;: &lt;span&gt;&quot;react-app-rewired eject&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;code&gt;react-app-rewired&lt;/code&gt; 配置完成后，我们新建 &lt;code&gt;config-overrides.js&lt;/code&gt; 文件来配置 &lt;code&gt;webpack&lt;/code&gt;，代码实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; path = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&quot;path&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;module&lt;/span&gt;.exports = {&lt;br/&gt;  &lt;span&gt;webpack&lt;/span&gt;: &lt;span&gt;(&lt;span&gt;config&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 微应用的包名，这里与主应用中注册的微应用名称一致&lt;/span&gt;&lt;br/&gt;    config.output.library = &lt;span&gt;`ReactMicroApp`&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;// 将你的 library 暴露为所有的模块定义下都可运行的方式&lt;/span&gt;&lt;br/&gt;    config.output.libraryTarget = &lt;span&gt;&quot;umd&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;// 按需加载相关，设置为 webpackJsonp_VueMicroApp 即可&lt;/span&gt;&lt;br/&gt;    config.output.jsonpFunction = &lt;span&gt;`webpackJsonp_ReactMicroApp`&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    config.resolve.alias = {&lt;br/&gt;      ...config.resolve.alias,&lt;br/&gt;      &lt;span&gt;&quot;@&quot;&lt;/span&gt;: path.resolve(__dirname, &lt;span&gt;&quot;src&quot;&lt;/span&gt;),&lt;br/&gt;    };&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; config;&lt;br/&gt;  },&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;devServer&lt;/span&gt;: &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;configFunction&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;proxy, allowedHost&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; config = configFunction(proxy, allowedHost);&lt;br/&gt;      &lt;span&gt;// 关闭主机检查，使微应用可以被 fetch&lt;/span&gt;&lt;br/&gt;      config.disableHostCheck = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;// 配置跨域请求头，解决开发环境的跨域问题&lt;/span&gt;&lt;br/&gt;      config.headers = {&lt;br/&gt;        &lt;span&gt;&quot;Access-Control-Allow-Origin&quot;&lt;/span&gt;: &lt;span&gt;&quot;*&quot;&lt;/span&gt;,&lt;br/&gt;      };&lt;br/&gt;      &lt;span&gt;// 配置 history 模式&lt;/span&gt;&lt;br/&gt;      config.historyApiFallback = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; config;&lt;br/&gt;    };&lt;br/&gt;  },&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们需要重点关注一下 &lt;code&gt;output&lt;/code&gt; 选项，当我们把 &lt;code&gt;libraryTarget&lt;/code&gt; 设置为 &lt;code&gt;umd&lt;/code&gt; 后，我们的 &lt;code&gt;library&lt;/code&gt; 就暴露为所有的模块定义下都可运行的方式了，主应用就可以获取到微应用的生命周期钩子函数了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;code&gt;config-overrides.js&lt;/code&gt; 修改完成后，我们重新启动 &lt;code&gt;React&lt;/code&gt; 微应用，然后打开主应用基座 &lt;code&gt;http://localhost:9999&lt;/code&gt;。我们点击左侧菜单切换到微应用，此时我们的 &lt;code&gt;React&lt;/code&gt; 微应用被正确加载啦！（见下图）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5255741127348643&quot; data-type=&quot;png&quot; data-w=&quot;1916&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ygUAW1Il7aS8BSBksFIEPz9IB2UicG4CtpbjPDhng2Kp3012ZRNz60kK5Ac2wFgErK6rUicjfhiaD86BqFZQpxyiaw/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;micro-app&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时我们打开控制台，可以看到我们所执行的生命周期钩子函数（见下图）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3880597014925373&quot; data-type=&quot;png&quot; data-w=&quot;1072&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ygUAW1Il7aS8BSBksFIEPz9IB2UicG4Ct7Ew8lTicXWE2DibppD1PnZyLZ0DKiae5boheb7eYDlrVZ3moppBr6VISA/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;micro-app&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里，&lt;code&gt;React&lt;/code&gt; 微应用就接入成功了！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接入 &lt;code&gt;Angular&lt;/code&gt; 微应用&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Angular&lt;/code&gt; 与 &lt;code&gt;qiankun&lt;/code&gt; 目前的兼容性并不太好，接入 &lt;code&gt;Angular&lt;/code&gt; 微应用需要一定的耐心与技巧。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;对于选择 &lt;code&gt;Angular&lt;/code&gt; 技术栈的前端开发来说，对这类情况应该驾轻就熟（没有办法）。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们以 实战案例 - feature-inject-sub-apps 分支 为例，我们在主应用的同级目录（&lt;code&gt;micro-app-main&lt;/code&gt; 同级目录），使用 &lt;code&gt;@angular/cli&lt;/code&gt; 先创建一个 &lt;code&gt;Angular&lt;/code&gt; 的项目，在命令行运行如下命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ng new micro-app-angular&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文的 &lt;code&gt;@angular/cli&lt;/code&gt; 选项如下图所示，你也可以根据自己的喜好选择配置。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.38513513513513514&quot; data-type=&quot;png&quot; data-w=&quot;1480&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ygUAW1Il7aS8BSBksFIEPz9IB2UicG4CtbuEyyDfuJCOhFXibricibkic9Pfl18ClKAS5IKmojstJ5dxghU0bL3wkCw/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;micro-app&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后，我们创建几个路由页面再加上一些样式，最后效果如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6272&quot; data-type=&quot;png&quot; data-w=&quot;1250&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ygUAW1Il7aS8BSBksFIEPz9IB2UicG4CtHKtLpFhPRuxuXlzNhtQXhEr1uRW4ibkGibyVtJu6EL60rV0vr3HzibM3g/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;micro-app&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8253588516746412&quot; data-type=&quot;png&quot; data-w=&quot;1254&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ygUAW1Il7aS8BSBksFIEPz9IB2UicG4CtbGzh2oz9xpKqrXsyWicRdtpbUANawP6zKXzrmibjG50aqib6fj6JdfUCg/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;micro-app&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;注册微应用&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在创建好了 &lt;code&gt;Angular&lt;/code&gt; 微应用后，我们可以开始我们的接入工作了。首先我们需要在主应用中注册该微应用的信息，代码实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// micro-app-main/src/micro/apps.ts&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; apps = [&lt;br/&gt;  &lt;span&gt;/**&lt;br/&gt;   * name: 微应用名称 - 具有唯一性&lt;br/&gt;   * entry: 微应用入口 - 通过该地址加载微应用&lt;br/&gt;   * container: 微应用挂载节点 - 微应用加载完成后将挂载在该节点上&lt;br/&gt;   * activeRule: 微应用触发的路由规则 - 触发路由规则后将加载该微应用&lt;br/&gt;   */&lt;/span&gt;&lt;br/&gt;  {&lt;br/&gt;    name: &lt;span&gt;&quot;AngularMicroApp&quot;&lt;/span&gt;,&lt;br/&gt;    entry: &lt;span&gt;&quot;//localhost:10300&quot;&lt;/span&gt;,&lt;br/&gt;    container: &lt;span&gt;&quot;#frame&quot;&lt;/span&gt;,&lt;br/&gt;    activeRule: &lt;span&gt;&quot;/angular&quot;&lt;/span&gt;,&lt;br/&gt;  },&lt;br/&gt;];&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; apps;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面的代码，我们就在主应用中注册了我们的 &lt;code&gt;Angular&lt;/code&gt; 微应用，进入 &lt;code&gt;/angular&lt;/code&gt; 路由时将加载我们的 &lt;code&gt;Angular&lt;/code&gt; 微应用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在菜单配置处也加入 &lt;code&gt;Angular&lt;/code&gt; 微应用的快捷入口，代码实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// micro-app-main/src/App.vue&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; App &lt;span&gt;extends&lt;/span&gt; Vue {&lt;br/&gt;  &lt;span&gt;/**&lt;br/&gt;   * 菜单列表&lt;br/&gt;   * key: 唯一 Key 值&lt;br/&gt;   * title: 菜单标题&lt;br/&gt;   * path: 菜单对应的路径&lt;br/&gt;   */&lt;/span&gt;&lt;br/&gt;  menus = [&lt;br/&gt;    {&lt;br/&gt;      key: &lt;span&gt;&quot;Home&quot;&lt;/span&gt;,&lt;br/&gt;      title: &lt;span&gt;&quot;主页&quot;&lt;/span&gt;,&lt;br/&gt;      path: &lt;span&gt;&quot;/&quot;&lt;/span&gt;,&lt;br/&gt;    },&lt;br/&gt;    {&lt;br/&gt;      key: &lt;span&gt;&quot;AngularMicroApp&quot;&lt;/span&gt;,&lt;br/&gt;      title: &lt;span&gt;&quot;Angular 主页&quot;&lt;/span&gt;,&lt;br/&gt;      path: &lt;span&gt;&quot;/angular&quot;&lt;/span&gt;,&lt;br/&gt;    },&lt;br/&gt;    {&lt;br/&gt;      key: &lt;span&gt;&quot;AngularMicroAppList&quot;&lt;/span&gt;,&lt;br/&gt;      title: &lt;span&gt;&quot;Angular 列表页&quot;&lt;/span&gt;,&lt;br/&gt;      path: &lt;span&gt;&quot;/angular/list&quot;&lt;/span&gt;,&lt;br/&gt;    },&lt;br/&gt;  ];&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;菜单配置完成后，我们的主应用基座效果图如下&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6508828250401284&quot; data-type=&quot;png&quot; data-w=&quot;1246&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ygUAW1Il7aS8BSBksFIEPz9IB2UicG4CtDX3sCibUG2nzCCt2U8P5VF33afk1icA7FyIYdiayLgHic4ibVgekLbo2Xzg/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;micro-app&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后我们在主应用的入口文件，引入 &lt;code&gt;zone.js&lt;/code&gt;，代码实现如下：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;Angular&lt;/code&gt; 运行依赖于 &lt;code&gt;zone.js&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;code&gt;qiankun&lt;/code&gt; 基于 &lt;code&gt;single-spa&lt;/code&gt; 实现，&lt;code&gt;single-spa&lt;/code&gt; 明确指出一个项目的 &lt;code&gt;zone.js&lt;/code&gt; 只能存在一份实例，所以我们在主应用注入 &lt;code&gt;zone.js&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// micro-app-main/src/main.js&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 为 Angular 微应用所做的 zone 包注入&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;&quot;zone.js/dist/zone&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;配置微应用&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在主应用的工作完成后，我们还需要对微应用进行一系列的配置。首先，我们使用 &lt;code&gt;single-spa-angular&lt;/code&gt; 生成一套配置，在命令行运行以下命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 安装 single-spa&lt;/span&gt;&lt;br/&gt;yarn add single-spa -S&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 添加 single-spa-angular&lt;/span&gt;&lt;br/&gt;ng add single-spa-angular&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行命令时，根据自己的需求选择配置即可，本文配置如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6071428571428571&quot; data-type=&quot;png&quot; data-w=&quot;1008&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ygUAW1Il7aS8BSBksFIEPz9IB2UicG4CtCskNS9bXZAIY5A4hCC9DZNbhKOecibVPEtsa7bEuco5nAYBFArIaAXQ/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;micro-app&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在生成 &lt;code&gt;single-spa&lt;/code&gt; 配置后，我们需要进行一些 &lt;code&gt;qiankun&lt;/code&gt; 的接入配置。我们在 &lt;code&gt;Angular&lt;/code&gt;微应用的入口文件 &lt;code&gt;main.single-spa.ts&lt;/code&gt; 中，导出 &lt;code&gt;qiankun&lt;/code&gt; 主应用所需要的三个生命周期钩子函数，代码实现如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8360302049622438&quot; data-type=&quot;png&quot; data-w=&quot;1854&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ygUAW1Il7aS8BSBksFIEPz9IB2UicG4CttybHkxGAskDD8KnRSS25ScHFk845PjWaiaqN3QyydoZtoMdYOcHe7gg/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;micro-app&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上图来分析：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;第 21 行&lt;/code&gt;：微应用独立运行时，直接执行挂载函数挂载微应用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;第 46 行&lt;/code&gt;：微应用导出的生命周期钩子函数 - &lt;code&gt;bootstrap&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;第 50 行&lt;/code&gt;：微应用导出的生命周期钩子函数 - &lt;code&gt;mount&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;第 54 行&lt;/code&gt;：微应用导出的生命周期钩子函数 - &lt;code&gt;unmount&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完整代码实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// micro-app-angular/src/main.single-spa.ts&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { enableProdMode, NgZone } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;@angular/core&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { platformBrowserDynamic } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;@angular/platform-browser-dynamic&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { Router } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;@angular/router&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { ɵAnimationEngine &lt;span&gt;as&lt;/span&gt; AnimationEngine } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;@angular/animations/browser&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; {&lt;br/&gt;  singleSpaAngular,&lt;br/&gt;  getSingleSpaExtraProviders,&lt;br/&gt;} &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;single-spa-angular&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { AppModule } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;./app/app.module&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { environment } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;./environments/environment&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { singleSpaPropsSubject } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;./single-spa/single-spa-props&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (environment.production) {&lt;br/&gt;  enableProdMode();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 微应用单独启动时运行&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (!(&lt;span&gt;window&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; &lt;span&gt;any&lt;/span&gt;).__POWERED_BY_QIANKUN__) {&lt;br/&gt;  platformBrowserDynamic()&lt;br/&gt;    .bootstrapModule(AppModule)&lt;br/&gt;    .catch(&lt;span&gt;(&lt;span&gt;err&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;console&lt;/span&gt;.error(err));&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; { bootstrap, mount, unmount } = singleSpaAngular({&lt;br/&gt;  bootstrapFunction: &lt;span&gt;(&lt;span&gt;singleSpaProps&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    singleSpaPropsSubject.next(singleSpaProps);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; platformBrowserDynamic(getSingleSpaExtraProviders()).bootstrapModule(&lt;br/&gt;      AppModule&lt;br/&gt;    );&lt;br/&gt;  },&lt;br/&gt;  template: &lt;span&gt;&quot;&amp;lt;app-root /&amp;gt;&quot;&lt;/span&gt;,&lt;br/&gt;  Router,&lt;br/&gt;  NgZone,&lt;br/&gt;  AnimationEngine,&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/** 主应用生命周期钩子中运行 */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;/**&lt;br/&gt;   * bootstrap 只会在微应用初始化的时候调用一次，下次微应用重新进入时会直接调用 mount 钩子，不会再重复触发 bootstrap。&lt;br/&gt;   * 通常我们可以在这里做一些全局变量的初始化，比如不会在 unmount 阶段被销毁的应用级别的缓存等。&lt;br/&gt;   */&lt;/span&gt;&lt;br/&gt;  bootstrap,&lt;br/&gt;  &lt;span&gt;/**&lt;br/&gt;   * 应用每次进入都会调用 mount 方法，通常我们在这里触发应用的渲染方法&lt;br/&gt;   */&lt;/span&gt;&lt;br/&gt;  mount,&lt;br/&gt;  &lt;span&gt;/**&lt;br/&gt;   * 应用每次 切出/卸载 会调用的方法，通常在这里我们会卸载微应用的应用实例&lt;br/&gt;   */&lt;/span&gt;&lt;br/&gt;  unmount,&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在配置好了入口文件 &lt;code&gt;main.single-spa.ts&lt;/code&gt; 后，我们还需要配置 &lt;code&gt;webpack&lt;/code&gt;，使 &lt;code&gt;main.single-spa.ts&lt;/code&gt; 导出的生命周期钩子函数可以被 &lt;code&gt;qiankun&lt;/code&gt; 识别获取。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们直接配置 &lt;code&gt;extra-webpack.config.js&lt;/code&gt; 即可，代码实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// micro-app-angular/extra-webpack.config.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; singleSpaAngularWebpack = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&quot;single-spa-angular/lib/webpack&quot;&lt;/span&gt;)&lt;br/&gt;  .default;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; webpackMerge = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&quot;webpack-merge&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;module&lt;/span&gt;.exports = &lt;span&gt;(&lt;span&gt;angularWebpackConfig, options&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; singleSpaWebpackConfig = singleSpaAngularWebpack(&lt;br/&gt;    angularWebpackConfig,&lt;br/&gt;    options&lt;br/&gt;  );&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; singleSpaConfig = {&lt;br/&gt;    &lt;span&gt;output&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;// 微应用的包名，这里与主应用中注册的微应用名称一致&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;library&lt;/span&gt;: &lt;span&gt;&quot;AngularMicroApp&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;// 将你的 library 暴露为所有的模块定义下都可运行的方式&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;libraryTarget&lt;/span&gt;: &lt;span&gt;&quot;umd&quot;&lt;/span&gt;,&lt;br/&gt;    },&lt;br/&gt;  };&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; mergedConfig = webpackMerge.smart(&lt;br/&gt;    singleSpaWebpackConfig,&lt;br/&gt;    singleSpaConfig&lt;br/&gt;  );&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; mergedConfig;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们需要重点关注一下 &lt;code&gt;output&lt;/code&gt; 选项，当我们把 &lt;code&gt;libraryTarget&lt;/code&gt; 设置为 &lt;code&gt;umd&lt;/code&gt; 后，我们的 &lt;code&gt;library&lt;/code&gt; 就暴露为所有的模块定义下都可运行的方式了，主应用就可以获取到微应用的生命周期钩子函数了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;code&gt;extra-webpack.config.js&lt;/code&gt; 修改完成后，我们还需要修改一下 &lt;code&gt;package.json&lt;/code&gt; 中的启动命令，修改如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// micro-app-angular/package.json&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&quot;script&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// --disable-host-check: 关闭主机检查，使微应用可以被 fetch&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// --port: 监听端口&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// --base-href: 站点的起始路径，与主应用中配置的一致&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;start&quot;&lt;/span&gt;: &lt;span&gt;&quot;ng serve --disable-host-check --port 10300 --base-href /angular&quot;&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;修改完成后，我们重新启动 &lt;code&gt;Angular&lt;/code&gt; 微应用，然后打开主应用基座 &lt;code&gt;http://localhost:9999&lt;/code&gt;。我们点击左侧菜单切换到微应用，此时我们的 &lt;code&gt;Angular&lt;/code&gt; 微应用被正确加载啦！（见下图）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8119122257053292&quot; data-type=&quot;png&quot; data-w=&quot;1276&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ygUAW1Il7aS8BSBksFIEPz9IB2UicG4CtgKTEmwuTpk1UGadtRwK6gklMNdXHyJMQECnvRXlyc7jZTNia3HAOIlQ/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;micro-app&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里，&lt;code&gt;Angular&lt;/code&gt; 微应用就接入成功了！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接入 &lt;code&gt;Jquery、xxx...&lt;/code&gt; 微应用&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里的 &lt;code&gt;Jquery、xxx...&lt;/code&gt; 微应用指的是没有使用脚手架，直接采用 &lt;code&gt;html + css + js&lt;/code&gt;三剑客开发的应用。&lt;/p&gt;&lt;p&gt;本案例使用了一些高级 &lt;code&gt;ES&lt;/code&gt; 语法，请使用谷歌浏览器运行查看效果。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们以 实战案例 - feature-inject-sub-apps 分支 为例，我们在主应用的同级目录（&lt;code&gt;micro-app-main&lt;/code&gt; 同级目录），手动创建目录 &lt;code&gt;micro-app-static&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们使用 &lt;code&gt;express&lt;/code&gt; 作为服务器加载静态 &lt;code&gt;html&lt;/code&gt;，我们先编辑 &lt;code&gt;package.json&lt;/code&gt;，设置启动命令和相关依赖。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// micro-app-static/package.json&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;name&quot;&lt;/span&gt;: &lt;span&gt;&quot;micro-app-jquery&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;version&quot;&lt;/span&gt;: &lt;span&gt;&quot;1.0.0&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;description&quot;&lt;/span&gt;: &lt;span&gt;&quot;&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;main&quot;&lt;/span&gt;: &lt;span&gt;&quot;index.js&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;scripts&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;start&quot;&lt;/span&gt;: &lt;span&gt;&quot;nodemon index.js&quot;&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;&quot;author&quot;&lt;/span&gt;: &lt;span&gt;&quot;&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;license&quot;&lt;/span&gt;: &lt;span&gt;&quot;ISC&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;dependencies&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;express&quot;&lt;/span&gt;: &lt;span&gt;&quot;^4.17.1&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;cors&quot;&lt;/span&gt;: &lt;span&gt;&quot;^2.8.5&quot;&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;&quot;devDependencies&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;nodemon&quot;&lt;/span&gt;: &lt;span&gt;&quot;^2.0.2&quot;&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后添加入口文件 &lt;code&gt;index.js&lt;/code&gt;，代码实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// micro-app-static/index.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; express = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&quot;express&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; cors = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&quot;cors&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; app = express();&lt;br/&gt;&lt;span&gt;// 解决跨域问题&lt;/span&gt;&lt;br/&gt;app.use(cors());&lt;br/&gt;app.use(&lt;span&gt;&#x27;/&#x27;&lt;/span&gt;, express.static(&lt;span&gt;&#x27;static&#x27;&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 监听端口&lt;/span&gt;&lt;br/&gt;app.listen(&lt;span&gt;10400&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;server is listening in http://localhost:10400&quot;&lt;/span&gt;)&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 &lt;code&gt;npm install&lt;/code&gt; 安装相关依赖后，我们使用 &lt;code&gt;npm start&lt;/code&gt; 启动应用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们新建 &lt;code&gt;static&lt;/code&gt; 文件夹，在文件夹内新增一个静态页面 &lt;code&gt;index.html&lt;/code&gt;（代码在后面会贴出），加上一些样式后，打开浏览器，最后效果如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.783661119515885&quot; data-type=&quot;png&quot; data-w=&quot;1322&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ygUAW1Il7aS8BSBksFIEPz9IB2UicG4CtJmRay93icAOHWJUUtKhpWQedBg971YLllTSQ2JU3CWbZ7pdm9NZ6cHg/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;micro-app&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;注册微应用&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在创建好了 &lt;code&gt;Static&lt;/code&gt; 微应用后，我们可以开始我们的接入工作了。首先我们需要在主应用中注册该微应用的信息，代码实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// micro-app-main/src/micro/apps.ts&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; apps = [&lt;br/&gt;  &lt;span&gt;/**&lt;br/&gt;   * name: 微应用名称 - 具有唯一性&lt;br/&gt;   * entry: 微应用入口 - 通过该地址加载微应用&lt;br/&gt;   * container: 微应用挂载节点 - 微应用加载完成后将挂载在该节点上&lt;br/&gt;   * activeRule: 微应用触发的路由规则 - 触发路由规则后将加载该微应用&lt;br/&gt;   */&lt;/span&gt;&lt;br/&gt;  {&lt;br/&gt;    name: &lt;span&gt;&quot;StaticMicroApp&quot;&lt;/span&gt;,&lt;br/&gt;    entry: &lt;span&gt;&quot;//localhost:10400&quot;&lt;/span&gt;,&lt;br/&gt;    container: &lt;span&gt;&quot;#frame&quot;&lt;/span&gt;,&lt;br/&gt;    activeRule: &lt;span&gt;&quot;/static&quot;&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;];&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; apps;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面的代码，我们就在主应用中注册了我们的 &lt;code&gt;Static&lt;/code&gt; 微应用，进入 &lt;code&gt;/static&lt;/code&gt; 路由时将加载我们的 &lt;code&gt;Static&lt;/code&gt; 微应用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在菜单配置处也加入 &lt;code&gt;Static&lt;/code&gt; 微应用的快捷入口，代码实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// micro-app-main/src/App.vue&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; App &lt;span&gt;extends&lt;/span&gt; Vue {&lt;br/&gt;  &lt;span&gt;/**&lt;br/&gt;   * 菜单列表&lt;br/&gt;   * key: 唯一 Key 值&lt;br/&gt;   * title: 菜单标题&lt;br/&gt;   * path: 菜单对应的路径&lt;br/&gt;   */&lt;/span&gt;&lt;br/&gt;  menus = [&lt;br/&gt;    {&lt;br/&gt;      key: &lt;span&gt;&quot;Home&quot;&lt;/span&gt;,&lt;br/&gt;      title: &lt;span&gt;&quot;主页&quot;&lt;/span&gt;,&lt;br/&gt;      path: &lt;span&gt;&quot;/&quot;&lt;/span&gt;&lt;br/&gt;    },&lt;br/&gt;    {&lt;br/&gt;      key: &lt;span&gt;&quot;StaticMicroApp&quot;&lt;/span&gt;,&lt;br/&gt;      title: &lt;span&gt;&quot;Static 微应用&quot;&lt;/span&gt;,&lt;br/&gt;      path: &lt;span&gt;&quot;/static&quot;&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  ];&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;菜单配置完成后，我们的主应用基座效果图如下&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5567890691716482&quot; data-type=&quot;png&quot; data-w=&quot;1171&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ygUAW1Il7aS8BSBksFIEPz9IB2UicG4CtFI254tpNEuJAQZfQkaYfTicjt7hgARPHuy5ntZnroGls7qwkq6ib2C0Q/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;micro-app&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;配置微应用&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在主应用注册好了微应用后，我们还需要直接写微应用 &lt;code&gt;index.html&lt;/code&gt; 的代码即可，代码实现如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8083333333333333&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ygUAW1Il7aS8BSBksFIEPz9IB2UicG4CtXwlUpYOXtZYKqOEtWwtIJs1hnscjo6ic3Via9jIM2YX4ibLXTvpLpxBvQ/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;micro-app&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上图来分析：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;第 70 行&lt;/code&gt;：微应用的挂载函数，在主应用中运行时将在 &lt;code&gt;mount&lt;/code&gt; 生命周期钩子函数中调用，可以保证在沙箱内运行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;第 77 行&lt;/code&gt;：微应用独立运行时，直接执行 &lt;code&gt;render&lt;/code&gt; 函数挂载微应用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;第 88 行&lt;/code&gt;：微应用注册的生命周期钩子函数 - &lt;code&gt;bootstrap&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;第 95 行&lt;/code&gt;：微应用注册的生命周期钩子函数 - &lt;code&gt;mount&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;第 102 行&lt;/code&gt;：微应用注册的生命周期钩子函数 - &lt;code&gt;unmount&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完整代码实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;!-- micro-app-static/static/index.html --&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;!DOCTYPE &lt;span&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;html&lt;/span&gt; &lt;span&gt;lang&lt;/span&gt;=&lt;span&gt;&quot;en&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;head&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;meta&lt;/span&gt; &lt;span&gt;charset&lt;/span&gt;=&lt;span&gt;&quot;UTF-8&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;meta&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;viewport&quot;&lt;/span&gt; &lt;span&gt;content&lt;/span&gt;=&lt;span&gt;&quot;width=device-width, initial-scale=1.0&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;meta&lt;/span&gt; &lt;span&gt;http-equiv&lt;/span&gt;=&lt;span&gt;&quot;X-UA-Compatible&quot;&lt;/span&gt; &lt;span&gt;content&lt;/span&gt;=&lt;span&gt;&quot;ie=edge&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;!-- 引入 bootstrap --&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;link&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;href&lt;/span&gt;=&lt;span&gt;&quot;https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/4.4.1/css/bootstrap.min.css&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;rel&lt;/span&gt;=&lt;span&gt;&quot;stylesheet&quot;&lt;/span&gt;&lt;br/&gt;    /&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;title&lt;/span&gt;&amp;gt;&lt;/span&gt;Jquery App&lt;span&gt;&amp;lt;/&lt;span&gt;title&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;head&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;section&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;jquery-app-container&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;style&lt;/span&gt;=&lt;span&gt;&quot;padding: 20px; color: blue;&quot;&lt;/span&gt;&lt;br/&gt;    &amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;section&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;!-- 引入 jquery --&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;script&lt;/span&gt; &lt;span&gt;src&lt;/span&gt;=&lt;span&gt;&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.min.js&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 请求接口数据，构建 HTML&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;async&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;buildHTML&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; result = &lt;span&gt;await&lt;/span&gt; fetch(&lt;span&gt;&quot;http://dev-api.jt-gmall.com/mall&quot;&lt;/span&gt;, {&lt;br/&gt;        &lt;span&gt;method&lt;/span&gt;: &lt;span&gt;&quot;POST&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;headers&lt;/span&gt;: {&lt;br/&gt;          &lt;span&gt;&quot;Content-Type&quot;&lt;/span&gt;: &lt;span&gt;&quot;application/json&quot;&lt;/span&gt;,&lt;br/&gt;        },&lt;br/&gt;        &lt;span&gt;// graphql 的查询风格&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;body&lt;/span&gt;: &lt;span&gt;JSON&lt;/span&gt;.stringify({&lt;br/&gt;          &lt;span&gt;query&lt;/span&gt;: &lt;span&gt;`{ vegetableList (page: 1, pageSize: 20) { page, pageSize, total, items { _id, name, poster, price } } }`&lt;/span&gt;,&lt;br/&gt;        }),&lt;br/&gt;      }).then(&lt;span&gt;(&lt;span&gt;res&lt;/span&gt;) =&amp;gt;&lt;/span&gt; res.json());&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; list = result.data.vegetableList.items;&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; html = &lt;span&gt;`&amp;lt;table class=&quot;table&quot;&amp;gt;&lt;br/&gt;  &amp;lt;thead&amp;gt;&lt;br/&gt;    &amp;lt;tr&amp;gt;&lt;br/&gt;      &amp;lt;th scope=&quot;col&quot;&amp;gt;菜名&amp;lt;/th&amp;gt;&lt;br/&gt;      &amp;lt;th scope=&quot;col&quot;&amp;gt;图片&amp;lt;/th&amp;gt;&lt;br/&gt;      &amp;lt;th scope=&quot;col&quot;&amp;gt;报价&amp;lt;/th&amp;gt;&lt;br/&gt;    &amp;lt;/tr&amp;gt;&lt;br/&gt;  &amp;lt;/thead&amp;gt;&lt;br/&gt;  &amp;lt;tbody&amp;gt;&lt;br/&gt;    &lt;span&gt;${list&lt;br/&gt;      .map(&lt;br/&gt;        (item) =&amp;gt; &lt;span&gt;`&lt;br/&gt;    &amp;lt;tr&amp;gt;&lt;br/&gt;      &amp;lt;td&amp;gt;&lt;br/&gt;        &amp;lt;img style=&quot;width: 40px; height: 40px; border-radius: 100%;&quot; src=&quot;&lt;span&gt;${item.poster}&lt;/span&gt;&quot;&amp;gt;&amp;lt;/img&amp;gt;&lt;br/&gt;      &amp;lt;/td&amp;gt;&lt;br/&gt;      &amp;lt;td&amp;gt;&lt;span&gt;${item.name}&lt;/span&gt;&amp;lt;/td&amp;gt;&lt;br/&gt;      &amp;lt;td&amp;gt;￥ &lt;span&gt;${item.price}&lt;/span&gt;&amp;lt;/td&amp;gt;&lt;br/&gt;    &amp;lt;/tr&amp;gt;&lt;br/&gt;      `&lt;/span&gt;&lt;br/&gt;      )&lt;br/&gt;      .join(&lt;span&gt;&quot;&quot;&lt;/span&gt;)}&lt;/span&gt;&lt;br/&gt;  &amp;lt;/tbody&amp;gt;&lt;br/&gt;&amp;lt;/table&amp;gt;`&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; html;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 渲染函数&lt;br/&gt;     * 两种情况：主应用生命周期钩子中运行 / 微应用单独启动时运行&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; render = &lt;span&gt;async&lt;/span&gt; ($) =&amp;gt; {&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; html = &lt;span&gt;await&lt;/span&gt; buildHTML();&lt;br/&gt;      $(&lt;span&gt;&quot;#jquery-app-container&quot;&lt;/span&gt;).html(html);&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;.resolve();&lt;br/&gt;    };&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 独立运行时，直接挂载应用&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;window&lt;/span&gt;.__POWERED_BY_QIANKUN__) {&lt;br/&gt;      render($);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    (&lt;span&gt;(&lt;span&gt;global&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;/**&lt;br/&gt;       * 注册微应用生命周期钩子函数&lt;br/&gt;       * global[appName] 中的 appName 与主应用中注册的微应用名称一致&lt;br/&gt;       */&lt;/span&gt;&lt;br/&gt;      global[&lt;span&gt;&quot;StaticMicroApp&quot;&lt;/span&gt;] = {&lt;br/&gt;        &lt;span&gt;/**&lt;br/&gt;         * bootstrap 只会在微应用初始化的时候调用一次，下次微应用重新进入时会直接调用 mount 钩子，不会再重复触发 bootstrap。&lt;br/&gt;         * 通常我们可以在这里做一些全局变量的初始化，比如不会在 unmount 阶段被销毁的应用级别的缓存等。&lt;br/&gt;         */&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;bootstrap&lt;/span&gt;: &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;          &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;MicroJqueryApp bootstraped&quot;&lt;/span&gt;);&lt;br/&gt;          &lt;span&gt;return&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;.resolve();&lt;br/&gt;        },&lt;br/&gt;        &lt;span&gt;/**&lt;br/&gt;         * 应用每次进入都会调用 mount 方法，通常我们在这里触发应用的渲染方法&lt;br/&gt;         */&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;mount&lt;/span&gt;: &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;          &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;MicroJqueryApp mount&quot;&lt;/span&gt;);&lt;br/&gt;          &lt;span&gt;return&lt;/span&gt; render($);&lt;br/&gt;        },&lt;br/&gt;        &lt;span&gt;/**&lt;br/&gt;         * 应用每次 切出/卸载 会调用的方法，通常在这里我们会卸载微应用的应用实例&lt;br/&gt;         */&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;unmount&lt;/span&gt;: &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;          &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;MicroJqueryApp unmount&quot;&lt;/span&gt;);&lt;br/&gt;          &lt;span&gt;return&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;.resolve();&lt;br/&gt;        },&lt;br/&gt;      };&lt;br/&gt;    })(&lt;span&gt;window&lt;/span&gt;);&lt;br/&gt;  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在构建好了 &lt;code&gt;Static&lt;/code&gt; 微应用后，我们打开主应用基座 &lt;code&gt;http://localhost:9999&lt;/code&gt;。我们点击左侧菜单切换到微应用，此时可以看到，我们的 &lt;code&gt;Static&lt;/code&gt; 微应用被正确加载啦！（见下图）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7795216741405082&quot; data-type=&quot;png&quot; data-w=&quot;1338&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ygUAW1Il7aS8BSBksFIEPz9IB2UicG4CtgPYfQsHgInERRp79El7CdCiagzbddu56we1dicP0MLD1IM1KGuD6uAibg/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;micro-app&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时我们打开控制台，可以看到我们所执行的生命周期钩子函数（见下图）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.37125&quot; data-type=&quot;png&quot; data-w=&quot;800&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ygUAW1Il7aS8BSBksFIEPz9IB2UicG4CtbCI8LWUicxtz1vl4ffOHFx3Qyibou7MMVN7q34Oo7kiaVWSryWysboicWA/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;micro-app&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里，&lt;code&gt;Static&lt;/code&gt; 微应用就接入成功了！&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;扩展阅读&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果在 &lt;code&gt;Static&lt;/code&gt; 微应用的 &lt;code&gt;html&lt;/code&gt; 中注入 &lt;code&gt;SPA&lt;/code&gt; 路由功能的话，将演变成单页应用，只需要在主应用中注册一次。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是多个 &lt;code&gt;html&lt;/code&gt; 的多页应用 - &lt;code&gt;MPA&lt;/code&gt;，则需要在服务器（或反向代理服务器）中通过 &lt;code&gt;referer&lt;/code&gt; 头返回对应的 &lt;code&gt;html&lt;/code&gt; 文件，或者在主应用中注册多个微应用（不推荐）。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;小结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，我们所有微应用都注册在主应用和主应用的菜单中，效果图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7769461077844312&quot; data-type=&quot;png&quot; data-w=&quot;1336&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ygUAW1Il7aS8BSBksFIEPz9IB2UicG4CtC7yGBVnXhkxCnwFojHKE4kkdPMUC3c7hhXay6BsDSJxTT4xDkNsg6Q/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;micro-app&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上图可以看出，我们把不同技术栈 &lt;code&gt;Vue、React、Angular、Jquery...&lt;/code&gt; 的微应用都已经接入到主应用基座中啦！&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;关于奇舞周刊&lt;/h2&gt;&lt;p&gt;《奇舞周刊》是360公司专业前端团队「&lt;span&gt;奇舞团&lt;/span&gt;」运营的前端技术社区。关注公众号后，直接发送链接到后台即可给我们投稿。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.34490238611713664&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MpGQUHiaib4ib6j9X9s2kibfaicBLmIm6dUBqymVmiaKqGFEPn0G3VyVnqQjvognHq4cMibayW2400j4OyEtdz5fkMbmA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;922&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>