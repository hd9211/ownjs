<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f4db535f03a31c3e5cbcd0d9e0bc90c0</guid>
<title>[推荐] 试用了 2000 多个拓展，最后只留下了这 50 个</title>
<link>https://toutiao.io/k/1yhz4eh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6255555555555555&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5VykXMQgTjaJlxg3FU30XsKZSrhDFWbh6ZccVB7rbIxzSicNQ85FZf1tqFm5uMD4YoNyR8dDkFnYPmdDLmZQPAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;阅读指引：&lt;/strong&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;1、阅读本文预计需要&lt;/span&gt;&lt;span&gt;&lt;strong&gt;10&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;分钟，并提供资源下载。&lt;/span&gt;&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;2、本文是&lt;strong&gt;「&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;网上冲浪指南&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;」&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;Internet&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 专题中的&lt;/span&gt;&lt;span&gt;&lt;strong&gt; i03&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 篇&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;更新版本&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，回复关键字 “&lt;span&gt;&lt;strong&gt;i&lt;/strong&gt;&lt;/span&gt;” 查看本专题所有内容。&lt;/span&gt;&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;3、第一时间获取更新，欢迎关注「&lt;/span&gt;&lt;span&gt;&lt;strong&gt;奔跑中的奶酪&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;」。&lt;/span&gt;&lt;/span&gt;&lt;span/&gt;&lt;span&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section class=&quot;&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;导读&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;拓展之于浏览器，就像 APP 之于智能手机。&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;拓展的数量成千上万，但能够被用户知道的通常在100个左右，能被用户选择使用的也就50个左右，而大多数人安装的拓展也不会超过10个。&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;浏览器拓展的数量庞大，但真正好用的并不多。&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;我们经常能看到很多拓展推荐的文章，好的推荐文章各有不同，但&quot;&lt;strong&gt;没什么卵用&lt;/strong&gt;&quot;的推荐文章大多很相似。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;一是喜欢标题党。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;动不动就这个神器，那个黑科技，诸如此类的词汇被滥用。&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;二是喜欢推荐 Adblock Plus&lt;/strong&gt;。不是说 Adblock Plus 不好，而是实在太入门了，把你当做小白用户来看待。&lt;br/&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;三是喜欢把拓展（或扩展）说成是插件。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;这是对拓展认识不足的表现，就好像是一个给你推荐电脑的人，他总是把硬盘说成内存。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section class=&quot;&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;01&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2 class=&quot;&quot;&gt;&lt;span&gt;&lt;strong&gt;我们需要什么样的拓展？&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;作为一个有着5年开发经验的用户，我很能感受到“&lt;strong&gt;好东西无人问津&lt;/strong&gt;”是一种什么样的体验。&lt;br/&gt;&lt;br/&gt;我试用了&lt;strong&gt;超过2000多款&lt;/strong&gt;浏览器拓展，这让我对浏览器拓展的选择有了新的理解。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;这第一个理解就是：很多拓展没有必要安装。&lt;br/&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;真正必备的拓展属于那些&lt;strong&gt;基础辅助的、使用率高的、大多数人都适用&lt;/strong&gt;的拓展，很多拓展其实没有必要安装。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;1、一些拓展包含了多个拓展的功能。&lt;br/&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一些非常小的功能，比如以图搜图、二维码、网页缓存查询、站内搜索、相似网页查询等，我们没有必要为了这些功能都安装一个相应的拓展，有一款叫 &lt;/span&gt;&lt;span&gt;Selection Context Search&lt;/span&gt;&lt;span&gt; 的拓展就可以搞定以上所有功能。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;2、一些拓展可以用脚本代替。&lt;br/&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;相对于脚本来说，拓展显得更加重型，如果一个功能可以用脚本代替，那么就不要使用拓展了。&lt;br/&gt;&lt;br/&gt;比如悬浮查看大图的拓展 &lt;/span&gt;&lt;span&gt;Imagus&lt;/span&gt;&lt;span&gt;，我们能感觉得到&lt;span&gt;安装后&lt;/span&gt;，网页加载速度受到的影响，而类似的脚本 &lt;/span&gt;&lt;span&gt;PicViewer&lt;/span&gt;&lt;span&gt; 则几乎没有影响。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;3、一些拓展应该选择使用软件版。&lt;br/&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;由于浏览器应用层面的限制，拓展的功能范围，无论再怎么强大也无法穿透浏览器，拓展的功能都是带着“&lt;strong&gt;镣铐&lt;/strong&gt;”的，一些拓展可以选择相关的软件来代替。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;比如截图拓展 &lt;/span&gt;&lt;span&gt;Nimbus Screen Capture&lt;/span&gt;&lt;span&gt;、文字识别拓展 &lt;/span&gt;&lt;span&gt;Copyfish&lt;/span&gt;&lt;span&gt;、录屏拓展 &lt;/span&gt;&lt;span&gt;Loom&lt;/span&gt;&lt;span&gt;、下载拓展 &lt;/span&gt;&lt;span&gt;Video 
DownloadHelper&lt;/span&gt;&lt;span&gt;，它们都已经是同类拓展中的佼佼者了，但他们还是没有软件版来得更加强大、而且万能。&lt;br/&gt;&lt;br/&gt;比如截图软件用 &lt;/span&gt;&lt;span&gt;FastStone
 Capture&lt;/span&gt;&lt;span&gt;，文字识别软件用 &lt;/span&gt;&lt;span&gt;天若ORC&lt;/span&gt;&lt;span&gt;，录屏软件用 &lt;/span&gt;&lt;span&gt;Camtasia&lt;/span&gt;&lt;span&gt;，下载软件用 &lt;/span&gt;&lt;span&gt;IDM&lt;/span&gt;&lt;span&gt;。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;4、忽略行业领域之外的拓展。&lt;br/&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一些拓展只有在特定的领域才用得上，比如&lt;strong&gt;开发类拓展、设计类拓展、英语类拓展、娱乐类拓展&lt;/strong&gt;等，如果它们已经超出了我们所在的行业领域，人生苦短，我们就应该直接略过它们。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;5、同类拓展中选择最为简洁的。&lt;br/&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;同样的功能，如果有多款拓展可以选择，&lt;strong&gt;那么旗帜鲜明地选择最为简洁的那一款，&lt;/strong&gt;简洁更具普适性，也更加符合高效的理念。&lt;br/&gt;&lt;br/&gt;比如脚本管理工具有 
GreaseMonkey、TamperMonkey、ViolentMonkey 可选，但 &lt;/span&gt;&lt;span&gt;ViolentMonkey&lt;/span&gt;&lt;span&gt; 更为简洁，管理也更加方便，那么选 ViolentMonkey。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section class=&quot;&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;02&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2 class=&quot;&quot;&gt;&lt;span&gt;&lt;strong&gt;年度最喜欢浏览器拓展推荐&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;br/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;我的第二个理解是：有很多的拓展都是伪需求的。&lt;br/&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们总是喜欢尝试试用各种拓展，觉得像是在挖掘宝藏，但它满足的&lt;span&gt;可能&lt;/span&gt;仅仅是我们的猎奇心而已。&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;用户其实并不知道自己需要什么，&lt;/strong&gt;用户是想要一匹更快的马吗？不是，用户是想更快地到达目的地。&lt;br/&gt;&lt;br/&gt;我们想要的是各种各样的拓展吗？不是，我们是想要的更快地得到想要的结果。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;很多五花八门看似强大的拓展，&lt;strong&gt;对于很多用户来说其实是一种伪需求&lt;/strong&gt;。比如聊天是一种需求，但某款拓展提供可以为任意网页开启聊天室的功能，则是一种伪需求。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在拓展的选择上，我的推荐原则是：&lt;strong&gt;从需要出发，然后倒推浏览器拓展&lt;/strong&gt;。&lt;br/&gt;&lt;br/&gt;下面是我总结的年度最喜欢浏览器拓展列表，支持 Chrome 和 Firefox。&lt;br/&gt;&lt;br/&gt;由于 Chrome 应用商店无法访问，推荐到 &lt;/span&gt;&lt;span&gt;https://crxdl.com&lt;/span&gt;&lt;span&gt; 下载。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;table class=&quot;tablepress tablepress-id-62&quot;&gt;&lt;tbody class=&quot;row-hover&quot;&gt;&lt;tr class=&quot;row-2 even&quot;&gt;&lt;td colspan=&quot;2&quot; class=&quot;column-1&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;常用拓展&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-3 odd&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;span&gt;&lt;strong&gt;功能&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;strong&gt;功能介绍&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-4 even&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;脚本管理&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;ViolentMonkey&lt;/span&gt;，相比 Tampermonkey、GreaseMonkey 更为简洁、方便。&lt;/span&gt;&lt;span&gt;❤&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-5 odd&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;样式管理&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;xStyle&lt;/span&gt;，相比 Stylish、Stylus 更为简洁，管理也更加方便。&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-6 even&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;拨号页&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;InfinityTab&lt;/span&gt;，可能是目前最好用的新标签页，但自带的图标有购物返利尾巴。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-7 odd&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;翻译工具&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;沙拉查词&lt;/span&gt;，多功能自定义强大的聚合翻译拓展，翻译和学习英语的利器。&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-8 even&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;代理工具&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;Proxy SwitchyOmega&lt;/span&gt; ，操作简单，可以轻松管理和切换多个代理设置。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-9 odd&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;截图工具&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;Nimbus Screen Capture&lt;/span&gt;，全能截图拓展，但推荐使用软件 FastStone Capture。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-10 even&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;稍候阅读&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;In My Pocket&lt;/span&gt;，标记一时没来得急读完的网页，支持多平台同步。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-11 odd&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;视频下载&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;Video DownloadHelper&lt;/span&gt;，支持大多数网站，但推荐使用软件 IDM。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-12 even&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;广告过滤&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;广告净化器&lt;/span&gt;，同时支持网页广告和视频广告过滤，规则更新快，适合国内用户。&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-13 odd&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;密码管理&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;BitWardens&lt;/span&gt;，简单易用，多平台同步，且免费的密码管理工具。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-14 even&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;鼠标拖拽&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;GlitterDrag&lt;/span&gt;，提供文字、图片和链接的拖拽功能，Chrome 用 crxMouse。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-15 odd&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;浏览器&lt;/span&gt;&lt;span&gt;&lt;br/&gt;请求&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;Header Editor&lt;/span&gt;，一款同时拥有重定向，反盗链，用户代理修改等功能的拓展。&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-16 even&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;右键搜索&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;Context Search&lt;/span&gt;，功能最全的右键搜索拓展，支持诸多自定义选项搜索。&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-17 odd&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;RSS&lt;/span&gt;&lt;span&gt;&lt;br/&gt;阅读器&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;Feeder&lt;/span&gt;，虽然 Feedy，Inoreader 都很好，但 Feeder 的使用体验更加友好。&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-18 even&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;网页剪藏&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;Evernote Web Clipper&lt;/span&gt;，一键标注和保存完整的网页内容到 Evernote 笔记上。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-19 odd&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;恢复&lt;/span&gt;&lt;span&gt;&lt;br/&gt;关闭标签&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;Undo Close Tab&lt;/span&gt;，简单且高效的标签恢复拓展。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;table class=&quot;tablepress tablepress-id-62&quot;&gt;&lt;tbody class=&quot;row-hover&quot;&gt;&lt;tr class=&quot;row-21 odd&quot;&gt;&lt;td colspan=&quot;2&quot; class=&quot;column-1&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;功能增强&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-22 even&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;书签检测&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;Bookmarks Organizer&lt;/span&gt;，一键查找失效、重复的书签，并支持重定向链接修复。&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-23 odd&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Cookie&lt;br/&gt;编辑&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;EditThisCookie&lt;/span&gt;，Cookie管理器，可以用于编辑Cookie，比如设置最大有效期。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-24 even&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;Aria2下载&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;Aria2 manager&lt;/span&gt;，用于手动导出和自动拦截下载到Aria2下载器。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-25 odd&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;邮件提醒&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;Email Notifier&lt;/span&gt;，界面简洁，支持绝大多数邮箱网站。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-26 even&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;网页监测&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;Distill Web Monitor&lt;/span&gt;，用于跟踪监测网页更新。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-27 odd&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;云盘钥匙&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;云盘万能钥匙&lt;/span&gt;，自动填写网盘提取密码和检测链接否有效。&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-28 even&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;二维码&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;二维码&lt;/span&gt;，将文本、链接、图片等生成二维码，也可识别二维码图片。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-29 odd&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;OCR识别&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;Copyfish&lt;/span&gt;，支持图片、截图等方式进行认别，但推荐使用软件“天若OCR”。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-30 even&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;填表工具&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;Informenter&lt;/span&gt;，密码管理拓展一般都会填表功能，如果你不用，这是个不错的选择。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-31 odd&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;链接多选&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;Snap Links Plus&lt;/span&gt;，使用鼠标右键可框选多个链接，也可以框选多个复选框。&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-32 even&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;浏览器&lt;br/&gt;调用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;Open With&lt;/span&gt;，用于调用其他浏览器打开当前网页，还可以用于运行多个浏览器配置。&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-33 odd&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;浏览&lt;br/&gt;记录分析&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;History Master&lt;/span&gt;，更加友好的可视化历史记录分析工具。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-34 even&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;自动化&lt;br/&gt;工具&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;Wildfire&lt;/span&gt;，让工作实现操作自动化，可以用于替代 &lt;/span&gt;&lt;span&gt;iMacros&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-35 odd&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;取消&lt;br/&gt;右键限制&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;Enable Right Click and Copy&lt;/span&gt;，解除包括选择，复制，右键菜单等限制，支持白名单。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-36 even&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;限制访问&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;Block Site&lt;/span&gt;，限制自己访问一些指定网站，还有上网时间，适合工作的时候使用。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-37 odd&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;网页&lt;br/&gt;内容替换&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;FoxReplace&lt;/span&gt;，可以替换页面的文字内容，用于编辑时非常好用。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-38 even&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;输入内容&lt;br/&gt;保存&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;Textarea Cache&lt;/span&gt;，自动保存输入框里的内容，做文字编辑时很有用。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-39 odd&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;快捷键&lt;br/&gt;拓展&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;Surfingkeys&lt;/span&gt;，让你像 VIM 一样通过键盘来操控浏览器，键盘流必备，按F键显示快捷键。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;table class=&quot;tablepress tablepress-id-62&quot;&gt;&lt;tbody class=&quot;row-hover&quot;&gt;&lt;tr class=&quot;row-41 odd&quot;&gt;&lt;td colspan=&quot;2&quot; class=&quot;column-1&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;标签页管理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-42 even&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;新标签页&lt;br/&gt;覆盖&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;New Tab Override&lt;/span&gt;，使修改新标签页显示的内容成为可能。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-43 odd&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;标签页&lt;br/&gt;切换&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;Astrolabe&lt;/span&gt;，使用页面缩略图的方式来切换标签页。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-44 even&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;标签页&lt;br/&gt;查看&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;Tree Style Tab&lt;/span&gt;，以树的形式显示当前打开的标签页，Chrome 用 Aerys。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-45 odd&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;会话管理&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;Tab Session Manager&lt;/span&gt;，每隔15分钟自动保存用户的浏览会话。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-46 even&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;小号管理&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;SessionBox&lt;/span&gt;，方便快捷的小号管理拓展，让你在同一网站同时登录多个账户。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-47 odd&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;节省内存&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;The Great Suspender&lt;/span&gt;，自动或手动冻结不用的标签页来节省内存占用，适合内存较小时。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-48 even&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;限制&lt;br/&gt;标签数量&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;Limit Tabs&lt;/span&gt;，限制浏览器打开标签页的数量，超过时只能先关闭原有的标签页。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-49 odd&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;正文内容&lt;br/&gt;索引&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;Falcon&lt;/span&gt;，地址栏输入 f ，可以搜索历史记录里的正文内容。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;table class=&quot;tablepress tablepress-id-62&quot;&gt;&lt;tbody class=&quot;row-hover&quot;&gt;&lt;tr class=&quot;row-51 odd&quot;&gt;&lt;td colspan=&quot;2&quot; class=&quot;column-1&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;网页浏览&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-52 even&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;阅读模式&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;简悦&lt;/span&gt;，更加优雅的阅读模式扩展。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-53 odd&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;雅黑字体&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;替换字体的中文部分为雅黑&lt;/span&gt;，同时避免影响英文部分。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-54 even&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;手形工具&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;ScrollAnywhere&lt;/span&gt;，按住鼠标左键，像手机屏幕一样地滑动网页。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-55 odd&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;维基阅读&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;Wikiwand&lt;/span&gt;，让排版老旧的Wikipedia有一个全新的界面。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-56 even&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;亮度调整&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;Adjust Screen Brightness&lt;/span&gt;，修改屏幕亮度。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-57 odd&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;黑夜模式&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;Dark Mode &lt;/span&gt;，将网页变成黑夜阅读模式。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-58 even&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;网页缩放&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;Zoom Page WE&lt;/span&gt;，网页缩放拓展，能记住网站的设置。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-59 odd&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;分屏浏览&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;Tile Tabs WE&lt;/span&gt;，标签页分割同屏显示，适合于同时进行多项任务的情况。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-60 even&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;MD 浏览&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;Markdown Viewer&lt;/span&gt;，在浏览器中直接查看 MarkDown 文件。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-61 odd&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;EPUB浏览&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;EPUB Reader&lt;/span&gt;，在浏览器中直接查看 EPUB 文件。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-62 even&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;MOBI浏览&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;MOBI Reader&lt;/span&gt;，在浏览器中直接查看 MOBI 文件。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;table class=&quot;tablepress tablepress-id-62&quot;&gt;&lt;tbody class=&quot;row-hover&quot;&gt;&lt;tr class=&quot;row-64 even&quot;&gt;&lt;td colspan=&quot;2&quot; class=&quot;column-1&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;图片浏览&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-65 odd&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;图片&lt;br/&gt;查看助手&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;Hover Zoom+&lt;/span&gt;，鼠标移动到图片上自动显示高清大图，但推荐使用脚本：&lt;/span&gt;&lt;span&gt;PicViewer&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-66 even&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;图片&lt;br/&gt;一键保存&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;SAVE IN... &lt;/span&gt;，一键将图片保存到指定位置，下载图片的同时又做好图片管理。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-67 odd&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;图片&lt;br/&gt;批量下载&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;ImageAssistant&lt;/span&gt;，可以嗅探、分析网页图片、图片筛选、批量下载等功能。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-68 even&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;图床工具&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;微博图床&lt;/span&gt;，使用前需要登录微博网页版，而且还支持批量上传。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-69 odd&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Google&lt;br/&gt;GIF&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;GoogleGIFs&lt;/span&gt;，解决谷歌图片搜索结果缩略图不支持播放 GIF 的问题。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;table class=&quot;tablepress tablepress-id-62&quot;&gt;&lt;tbody class=&quot;row-hover&quot;&gt;&lt;tr class=&quot;row-71 odd&quot;&gt;&lt;td colspan=&quot;2&quot; class=&quot;column-1&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;音乐收听&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-72 even&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;音乐收听&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;Listen 1&lt;/span&gt;，可以搜索和播放来自网易云音乐，虾米，QQ音乐等网站的歌曲。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-73 odd&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;歌词展示&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;Lyrics Here&lt;/span&gt;，在 Youtube，Spotify 等音乐网站上显示当前播放音乐的歌词。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-74 even&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;广播收听&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;Search to Play the Song&lt;/span&gt;，Listen 1的简洁版，不但能听歌，还能听广播。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-75 odd&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;歌曲识别&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;AHA Music&lt;/span&gt;，识别当前浏览器播放中的歌曲，也支持本地音乐。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;table class=&quot;tablepress tablepress-id-62&quot;&gt;&lt;tbody class=&quot;row-hover&quot;&gt;&lt;tr class=&quot;row-77 odd&quot;&gt;&lt;td colspan=&quot;2&quot; class=&quot;column-1&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;视频观看&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-78 even&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;视频放大&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;Maximize Video&lt;/span&gt;，将视频放大填充到网页全屏，但推荐类似的脚本 &lt;/span&gt;&lt;span&gt;视频网页全屏&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-79 odd&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;视频弹窗&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;Popup Tool&lt;/span&gt;，可将当前视频弹出到小窗播放，Chrome 用 Separate Window。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-80 even&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;视频&lt;br/&gt;倍数播放&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;Video Speed Controller&lt;/span&gt;，Z、X为后退、前进，SD减慢加快，R恢复默认。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-81 odd&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;弹幕&lt;br/&gt;过滤器&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;pakku&lt;/span&gt;，哔哩哔哩弹幕过滤器，屏蔽相似弹幕。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-82 even&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;哔哩哔哩&lt;br/&gt;助手&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;哔哩哔哩助手&lt;/span&gt;，可以下载视频，查询弹幕发送人以及一些十分实用的直播区功能。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-83 odd&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;U2B增强&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;Enhancer for YouTube&lt;/span&gt;，为Youtube增加各种实用功能。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-84 even&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;U2B&lt;br/&gt;地区解锁&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;YouTube Unblocker&lt;/span&gt;，解锁 Youtube 国家地区限制的。&lt;/span&gt;&lt;span&gt;测试视频&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-85 odd&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;U2B&lt;br/&gt;双语字幕&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;Dualsub&lt;/span&gt;，让 YouTube 显示双语字幕，英语学习者必备。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-86 even&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;U2B&lt;br/&gt;频道屏蔽&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;BlockTube&lt;/span&gt;，屏蔽不想看的视频频道，包括首页推荐和搜索页面。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;table class=&quot;tablepress tablepress-id-62&quot;&gt;&lt;tbody class=&quot;row-hover&quot;&gt;&lt;tr class=&quot;row-88 even&quot;&gt;&lt;td colspan=&quot;2&quot; class=&quot;column-1&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Firefox 特有拓展&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-89 odd&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;笔记本&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;Sidebar Note&lt;/span&gt;，自动保存，支持快捷键，支持选中文字一键发送至笔记本。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-90 even&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;侧边栏&lt;br/&gt;浏览&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;Side View&lt;/span&gt;，Firefox 官方出品的侧边栏拓展，并支持以手机端查看。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-91 odd&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;添加&lt;br/&gt;搜索引擎&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;Add custom search engine&lt;/span&gt;，增加一个类似于Chrome的搜索引擎添加模式。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-92 even&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;书签图标&lt;br/&gt;刷新&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;Checkmarks&lt;/span&gt;，在侧边栏中打开，设置进程后依次打开刷新图标。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-93 odd&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;搜索引擎&lt;br/&gt;编辑&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;mozlz4-edit&lt;/span&gt;，可手动修改火狐的加密配置文件，比如搜索引擎的 search.json.mozlz4。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-94 even&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;书签&lt;br/&gt;快速添加&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;Bookmark Tab Here&lt;/span&gt;，添加一个”添加到此“的选项，用于快速添加书签到指定书签文件夹。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;table class=&quot;tablepress tablepress-id-62&quot;&gt;&lt;tbody class=&quot;row-hover&quot;&gt;&lt;tr class=&quot;row-96 even&quot;&gt;&lt;td colspan=&quot;2&quot; class=&quot;column-1&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Chrome 特有拓展&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-97 odd&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;拓展管理&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;SimpleExtManager&lt;/span&gt;，简洁实用，一键管理所有扩展。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-98 even&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;字体渲染&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;Font Rendering Enhancer&lt;/span&gt;，解决Chrome字体发虚的问题，让字体渲染和Firefox一样。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-99 odd&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;下载管理&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;下载管理&lt;/span&gt;，简洁实用，没有冗余的功能，专注于下载管理。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-100 even&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;strong&gt;&lt;span&gt;书签管理&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;书签侧边栏&lt;/span&gt;，在浏览器视图区左侧添加固定式的, 管理所有书签的侧边栏。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;row-101 odd&quot;&gt;&lt;td class=&quot;column-1&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;拓展下载&lt;br/&gt;助手&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;column-2&quot;&gt;&lt;span&gt;&lt;span&gt;谷歌访问助手&lt;/span&gt;，用于访问 Chrome Web Store 等网站，但使用需要修改主页。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section class=&quot;&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;结尾&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2 class=&quot;&quot;&gt;&lt;br/&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h2 class=&quot;&quot;&gt;&lt;span&gt;打造最值得收藏的浏览器拓展列表，&lt;/span&gt;&lt;/h2&gt;&lt;h2 class=&quot;&quot;&gt;&lt;span&gt;以上拓展的下载链接、后续更新，以及其他领域的拓展推荐，&lt;/span&gt;&lt;/h2&gt;&lt;h2 class=&quot;&quot;&gt;&lt;span&gt;都会在奶酪的 Github 上集中更新，&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;欢迎点 ★Star，帮助更多的朋友发现这个项目。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;链接1：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://github.com/runningcheese/RunningCheese-Firefox/tree/master/Extensions&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;链接2：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 class=&quot;&quot;&gt;&lt;span&gt;https://www.runningcheese.com/extensions&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;回复关键字&lt;br/&gt;“&lt;span&gt;&lt;strong&gt;1227&lt;/strong&gt;&lt;/span&gt;”或者“&lt;span&gt;&lt;strong&gt;i03&lt;/strong&gt;&lt;/span&gt;”&lt;br/&gt;获取文中提到的所有资源。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;相关文章：&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwMjUyNzYxMw==&amp;amp;mid=2247485116&amp;amp;idx=1&amp;amp;sn=854cf96f6e893471604a85e8ea646949&amp;amp;chksm=9ac85eaeadbfd7b84643db862b431c7796cae3e6ea504192f5de11695ff2cc61cd21407e9083&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;1&quot;&gt;&lt;span&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.175&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/5VykXMQgTjYoaqbnicX38mXD85iauibcIBy60F9bIhDMyAt16IiapSBHsUQxv2ePvecibBKtKOcd19RmI9htW9WSgwA/640?wx_fmt=jpeg&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwMjUyNzYxMw==&amp;amp;mid=2247485097&amp;amp;idx=1&amp;amp;sn=fe31a703f6c72341cd263a3e7387985f&amp;amp;chksm=9ac85ebbadbfd7ad44a291046901932a4750d42ba1ea92c4f04292fe41093dc4f25f9d2ecbd6&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;1&quot;&gt;&lt;span&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.175&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/5VykXMQgTjYoaqbnicX38mXD85iauibcIByfgCM7Hst8Uibh1tJdFUHP9IddBOp34FAqWjztibNw8alPoJGY3Ix6hIQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwMjUyNzYxMw==&amp;amp;mid=2247485131&amp;amp;idx=1&amp;amp;sn=defc76293e52ed52694c70421eefa32b&amp;amp;chksm=9ac85ed9adbfd7cfb9b5666646fdde77071710ea362bc1031a57a03b462a5403ce2efd323324&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;542&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;95&quot; data-ratio=&quot;0.175&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5VykXMQgTjaJlxg3FU30XsKZSrhDFWbhLjLyej5BWSfYlic7GcvOtGicyxzic2l0ZomgB6s6ZvpVHeUmPHCUn6uVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;看完文章：&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;喜欢本文，或者这篇文章对你有帮助的话，那么：&lt;br/&gt;&lt;br/&gt;1、&lt;/span&gt;&lt;span&gt;&lt;strong&gt;点再看&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，帮助更多的人看到这篇文章。&lt;br/&gt;2、&lt;/span&gt;&lt;span&gt;&lt;strong&gt;写留言&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，对文章进行评论，我会尽可能回复。&lt;br/&gt;3、&lt;/span&gt;&lt;span&gt;&lt;strong&gt;点关注&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，关注我并星标，第一时间获取更新。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages &quot; data-ratio=&quot;0.4697986577181208&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;596&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5VykXMQgTjYu09QNUT7TH5050lvafFFjTAk6bRibHt2OHyTZsg2cVuqpHRXOmFekZ7WW6NbibAH7Xib3lX3mK55uA/640?wx_fmt=png&quot;/&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;&gt;赞赏／在看二选一&lt;/p&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on WeChat for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a2f6ba9277b228f11d589c4ec8f9e1ec</guid>
<title>[推荐] 分享一个作为面试官的面试思路</title>
<link>https://toutiao.io/k/dvtlxd4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6389850057670127&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8wj3hUrm4CzAZAm62AuZiafOxhdj1icCzdxfWKSEA4GibfoNLINA1jLo6OkO9Tiac1wLqpJxrSO9vNcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;867&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;做面试官也是一个需要持续完善和改进的技能，避免面试官和面试者都没有收获或者面试感觉不舒服，间接影响公司的形象。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;作为面试官的核心要点&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;1. 不要透露公司内未官方宣传的数据和信息。&lt;br/&gt;2. 面试官代表公司的形象，要尊重面试者。信息的传达注意对公司的影响。&lt;br/&gt;3. 要明确招人的标准，找：能做事、会做事、做成事  的人。&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;面试步骤&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;面试前准备&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;和HR约好面试时间，定日程提醒。有变化提前通知。&lt;br/&gt;拿到面试者的简历，先浏览一遍，根据面试者情况定制面试提纲。&lt;br/&gt;举个例子，本周面试一人。名校硕士，工作7年时间，共经历2家公司，都是技术上靠前面的大厂。工作经验和目前职位匹配。总体是不错的。但是从简历可看出缺少一些这边必需的技术栈。&lt;br/&gt;针对他的情况我首先制定了一个面试大纲：&lt;/p&gt;&lt;p&gt;1.自我介绍&lt;/p&gt;&lt;p&gt;2.过往经历项目考察&lt;/p&gt;&lt;p&gt;在此过程中遇到了什么问题，采取了什么措施，取得了什么成果。总结了什么经验和方法。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;3.基础题&lt;/p&gt;&lt;p&gt;3.1 稳定性方面所做的工作&lt;/p&gt;&lt;p&gt;3.2 因为简历里写明对基础算法有了解。所以让他谈谈什么是归并排序，什么是快速排序，两者的区别和联系。&lt;/p&gt;&lt;p&gt;怎么用原地算法做归并排序(故意带坑题，我了解到的是归并排序不能用原地算法)&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;4.场景题：怎么设计一个自动化回归平台&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;5.软素质考察&lt;/p&gt;&lt;p&gt;5.1 平时怎么自我提升&lt;/p&gt;&lt;p&gt;5.2 为什么会考虑我司&lt;/p&gt;&lt;p&gt;5.3 你有什么要问的吗&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;面试过程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;自我介绍和过往经历&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;面试者总共经历了四个项目，都做了稍微详细些的介绍。中间有问他一些涉及的技术。回答和简历上标注能力程度在我的角度看是匹配的。&lt;/p&gt;&lt;p&gt;举例来说他项目中有提到做数据删除。我就问他删除数据有没有风险。他提到有反作弊风险。我提示说提到风险一般会从两方面来阐述。一个是业务上的，一个是系统上的。反作弊风险是业务上的，在系统上有没有遇到什么问题。比如删除数据可能会涉及磁盘IO，这个怎么来规避。&lt;/p&gt;&lt;p&gt;他提到数据库采用的高性能SSD盘，在操作时也会限制并发度。&lt;/p&gt;&lt;p&gt;回答不是很深入，但是对于他在项目中的角色来说，这个回答是可以接受的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;基础题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;有请他介绍一些分布式一致性的相关技术。他提到了两阶段提交、分布式锁和他在区块链项目中用到的独有的基于类似全局唯一ID的技术。总体不是特别全面和成体系。但是对于这个技术我这边判断他是了解的。&lt;/p&gt;&lt;p&gt;谈谈什么是归并排序，什么是快速排序，两者的区别和联系。这个他的回答没有什么问题，谈到了快速排序之所以叫快速是因为时间复杂度的系数小。&lt;/p&gt;&lt;p&gt;然后我就让他谈谈怎么用原地算法做归并排序。他说了一个方法，我没有听太懂，我明确告诉他我理解归并排序是不能用原地算法来实现的,请他在面试结束后把代码发给我,算做交流学习。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;场景题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;场景题中，他的回答可以看到他到他平时工作重心的一些缩影。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;软素质考察&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;总体是我司有一定的了解，沟通流畅，没有什么问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;面试结束&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;虽然没有明确表态，但是根据我的一贯风格，从沟通中面试者也是可以了解到一面在我这里是通过的。面试结束他将自己面试时介绍的使用插入实现归并的博客和另外一种使用旋转实现O(1)空间复杂度的方法博客发给我&lt;/p&gt;&lt;p&gt;到此一面流程真正结束,我按照&lt;/p&gt;&lt;p&gt;1&amp;gt;综合评价&lt;/p&gt;&lt;p&gt;2&amp;gt;优势&lt;/p&gt;&lt;p&gt;3&amp;gt;劣势&lt;/p&gt;&lt;p&gt;4&amp;gt;具体点描述&lt;/p&gt;&lt;p&gt;的模板给HR发了面试反馈。评价建议尽可以具体，让下一位面试官了解情况，不用每次面试对面试者某一方面重复考察。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结思考&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;面试是一个交流碰撞的过程,对于面试者和面试官都是一个学习交流的机会.最好是双方都花些时间做些准备,这样面试过程轻松愉快,通过面试提升了自己的自信,过程中也都有收获.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;PS: 有对金融方向、高并发、高可用感兴趣的朋友可发简历到98749055@qq.com。加入我们，你将直面这个领域全球最大日单量和并发量，无上限对稳定性的要求(一般的业务团队对稳定性会设置SLA指标，稳定性高于一定程度，业务的拓展更加重要，对稳定性问题深度的提升有一定限制)。挑战无限，机会多多。&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b649055f11710fdc724cbbffb17be1a3</guid>
<title>[推荐] Golang 汇编入门知识总结</title>
<link>https://toutiao.io/k/hol28ow</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;作者：ivansli，腾讯 IEG 运营开发工程师&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在深入学习 Golang 的 runtime 和标准库实现的时候发现，如果对 Golang 汇编没有一定了解的话，很难深入了解其底层实现机制。在这里整理总结了一份基础的 Golang 汇编入门知识，通过学习之后能够对其底层实现有一定的认识。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;0. 为什么写本文&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;平时业务中一直使用 PHP 编写代码，但是一直对 Golang 比较感兴趣，闲暇、周末之余会看一些 Go 底层源码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;近日在分析 go 的某些特性底层功能实现时发现：有些又跟 runtime 运行时有关，而要掌握这一部分的话，有一道坎是绕不过去的，那就是 Go 汇编。索性就查阅了很多大佬们写的资料，在阅读之余整理总结了一下，并在这里分享给大家。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;本文使用 Go 版本为 go1.14.1&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1. 为什么需要汇编&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;众所周知，在计算机的世界里，只有 2 种类型。那就是：0 和 1。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;计算机工作是由一系列的机器指令进行驱动的，这些指令又是一组二进制数字，其对应计算机的高低电平。而这些机器指令的集合就是机器语言，这些机器语言在最底层是与硬件一一对应的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显而易见，这样的机器指令有一个致命的缺点：&lt;code&gt;可阅读性太差&lt;/code&gt;（恐怕也只有天才和疯子才有能力把控得了）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决可读性的问题以及代码编辑的需求，于是就诞生了最接近机器的语言：汇编语言（在我看来，汇编语言更像一种助记符，这些人们容易记住的每一条助记符都映射着一条不容易记住的由 0、1 组成的机器指令。你觉得像不像域名与 IP 地址的关系呢？）。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.1 程序的编译过程&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以 C 语言为例来说，从 hello.c 的源码文件到 hello 可执行文件，经过编译器处理，大致分为几个阶段：&lt;img data-ratio=&quot;0.14285714285714285&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvav8IgyML3khHFMKbUficlbDVm0ueFrYvOFo8p3XbBfRvWL1gJibZS47eOsLQwv2wHTo5jez2WWAFuFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2107&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译器在不同的阶段会做不同的事情，但是有一步是可以确定的，那就是：源码会被编译成汇编，最后才是二进制。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2. 程序与进程&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源码经过编译之后，得到一个二进制的可执行&lt;code&gt;文件&lt;/code&gt;。&lt;code&gt;文件&lt;/code&gt;这两个字也就表明，目前得到的这个文件跟其他文件对比，除了是具有一定的格式（Linux 中是 ELF 格式，即：可运行可链接。executable linkable formate）的二进制组成，并没什么区别。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Linux 中文件类型大致分为 7 种：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;b: 块设备文件&lt;br/&gt;c：字符设备文件&lt;br/&gt;d：目录&lt;br/&gt;-：普通文件&lt;br/&gt;l：链接&lt;br/&gt;s：socket&lt;br/&gt;p：管道&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.17134697762970014&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvav8IgyML3khHFMKbUficlbDVVc3Z9mkhqwHSma8N3nJyu9uCm4w2U7cib79jhQianydq6apDjkcdKDqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2101&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面可以看到，可执行文件 main 与源码文件 main.go，都是同一种类型，属于普通文件。（当然了，在 Unix 中有一句很经典的话：&lt;code&gt;一切皆文件&lt;/code&gt;）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，问题来了：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;什么是程序？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是进程？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.1 程序&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;维基百科告诉我们：&lt;code&gt;程序&lt;/code&gt;是指一组指示计算机或其他具有消息处理能力设备每一步动作的指令，通常用某种程序设计语言编写，运行于某种目标体系结构上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从某个层面来看，可以把程序分为静态程序、动态程序：静态程序：单纯的指具有一定格式的可执行二进制文件。动态程序：则是静态可执行程序文件被加载到内存之后的一种运行时模型（又称为进程）。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.2 进程&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，要知道的是，&lt;code&gt;进程&lt;/code&gt;是分配系统资源的最小单位，&lt;code&gt;线程&lt;/code&gt;(带有时间片的函数)是系统调度的最小单位。进程包含线程，线程所属于进程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建进程一般使用 fork 方法(通常会有个拉起程序，先 fork 自身生成一个子进程。然后，在该子进程中通过 exec 函数把对应程序加载进来，进而启动目标进程。当然，实际上要复杂得多)，而创建线程则是使用 pthread 线程库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以 32 位 Linux 操作系统为例，进程经典的虚拟内存结构模型如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.010221465076661&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvav8IgyML3khHFMKbUficlbDVZ45hhUeYzMkOr6YgLBRJ0p2z8TF3rfCNiaLfibr9MY2voOmo2ebLI9lw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1174&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中，有两处结构是静态程序所不具有的，那就是&lt;code&gt;运行时堆(heap)&lt;/code&gt;与&lt;code&gt;运行时栈(stack)&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;运行时堆&lt;/code&gt;从低地址向高地址增长，申请的内存空间需要程序员自己或者由 GC 释放。&lt;code&gt;运行时栈&lt;/code&gt;从高地址向低地址增长，内存空间在当前栈桢调用结束之后自动释放(并不是清除其所占用内存中数据，而是通过栈顶指针 SP 的移动，来标识哪些内存是正在使用的)。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3. Go 汇编&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 Go 编译器而言，其输出的结果是一种抽象可移植的汇编代码，这种汇编（Go 的汇编是基于 Plan9 的汇编）并不对应某种真实的硬件架构。Go 的汇编器会使用这种伪汇编，再为目标硬件生成具体的机器指令。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;伪汇编&lt;/code&gt;这一个额外层可以带来很多好处，最主要的一点是方便将 Go 移植到新的架构上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相关的信息可以参考 &lt;code&gt;Rob Pike&lt;/code&gt; 的 &lt;code&gt;The Design of the Go Assembler&lt;/code&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;要了解 Go 的汇编器最重要的是要知道 Go 的汇编器不是对底层机器的直接表示，即 Go 的汇编器没有直接使用目标机器的汇编指令。Go 汇编器所用的指令，一部分与目标机器的指令一一对应，而另外一部分则不是。这是因为编译器套件不需要汇编器直接参与常规的编译过程。&lt;/p&gt;&lt;p&gt;相反，编译器使用了一种半抽象的指令集，并且部分指令是在代码生成后才被选择的。汇编器基于这种半抽象的形式工作，所以虽然你看到的是一条 MOV 指令，但是工具链针对对这条指令实际生成可能完全不是一个移动指令，也许会是清除或者加载。也有可能精确的对应目标平台上同名的指令。概括来说，特定于机器的指令会以他们的本尊出现， 然而对于一些通用的操作，如内存的移动以及子程序的调用以及返回通常都做了抽象。细节因架构不同而不一样，我们对这样的不精确性表示歉意，情况并不明确。&lt;/p&gt;&lt;p&gt;汇编器程序的工作是对这样半抽象指令集进行解析并将其转变为可以输入到链接器的指令。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;The most important thing to know about Go’s assembler is that it is not a direct representation of the underlying machine. Some of the details map precisely to the machine, but some do not. This is because the compiler suite needs no assembler pass in the usual pipeline. Instead, the compiler operates on a kind of semi-abstract instruction set, and instruction selection occurs partly after code generation. The assembler works on the semi-abstract form, so when you see an instruction like MOV what the toolchain actually generates for that operation might not be a move instruction at all, perhaps a clear or load.&lt;/p&gt;&lt;p&gt;Or it might correspond exactly to the machine instruction with that name. In general, machine-specific operations tend to appear as themselves, while more general concepts like memory move and subroutine call and return are more abstract. The details vary with architecture, and we apologize for the imprecision; the situation is not well-defined.&lt;/p&gt;&lt;p&gt;The assembler program is a way to parse a description of that semi-abstract instruction set and turn it into instructions to be input to the linker.&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 汇编使用的是&lt;code&gt;caller-save&lt;/code&gt;模式，被调用函数的入参参数、返回值都由调用者维护、准备。因此，当需要调用一个函数时，需要先将这些工作准备好，才调用下一个函数，另外这些都需要进行内存对齐，对齐的大小是 sizeof(uintptr)。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1 几个概念&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在深入了解 Go 汇编之前，需要知道的几个概念：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;栈：进程、线程、goroutine 都有自己的调用栈，先进后出（FILO）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;栈帧：可以理解是函数调用时，在栈上为函数所分配的内存区域&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用者：caller，比如：A 函数调用了 B 函数，那么 A 就是调用者&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;被调者：callee，比如：A 函数调用了 B 函数，那么 B 就是被调者&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2 Go 的核心寄存器&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;go 汇编中有 4 个核心的伪寄存器，这 4 个寄存器是编译器用来维护上下文、特殊标识等作用的：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;寄存器&lt;/th&gt;&lt;th&gt;说明&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;SB(Static base pointer)&lt;/td&gt;&lt;td&gt;global symbols&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;FP(Frame pointer)&lt;/td&gt;&lt;td&gt;arguments and locals&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;PC(Program counter)&lt;/td&gt;&lt;td&gt;jumps and branches&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SP(Stack pointer)&lt;/td&gt;&lt;td&gt;top of stack&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;FP: 使用如 &lt;code&gt;symbol+offset(FP)&lt;/code&gt;的方式，引用 callee 函数的入参参数。例如 &lt;code&gt;arg0+0(FP)，arg1+8(FP)&lt;/code&gt;，使用 FP 必须加 symbol ，否则无法通过编译(从汇编层面来看，symbol 没有什么用，加 symbol 主要是为了提升代码可读性)。另外，需要注意的是：往往在编写 go 汇编代码时，要站在 callee 的角度来看(FP)，在 callee 看来，(FP)指向的是 caller 调用 callee 时传递的第一个参数的位置。假如当前的 callee 函数是 add，在 add 的代码中引用 FP，该 FP 指向的位置不在 callee 的 stack frame 之内。而是在 caller 的 stack frame 上，指向调用 add 函数时传递的第一个参数的位置，经常在 callee 中用&lt;code&gt;symbol+offset(FP)&lt;/code&gt;来获取入参的参数值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SB: 全局静态基指针，一般用在声明函数、全局变量中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SP: 该寄存器也是最具有迷惑性的寄存器，因为会有伪 SP 寄存器和硬件 SP 寄存器之分。plan9 的这个伪 SP 寄存器指向当前栈帧第一个局部变量的结束位置(为什么说是结束位置，可以看下面寄存器内存布局图)，使用形如 symbol+offset(SP) 的方式，引用函数的局部变量。offset 的合法取值是 [-framesize, 0)，注意是个左闭右开的区间。假如局部变量都是 8 字节，那么第一个局部变量就可以用 localvar0-8(SP) 来表示。与硬件寄存器 SP 是两个不同的东西，在栈帧 size 为 0 的情况下，伪寄存器 SP 和硬件寄存器 SP 指向同一位置。手写汇编代码时，如果是 symbol+offset(SP)形式，则表示伪寄存器 SP。如果是 offset(SP)则表示硬件寄存器 SP。&lt;code&gt;务必注意&lt;/code&gt;：对于编译输出(go tool compile -S / go tool objdump)的代码来讲，所有的 SP 都是硬件 SP 寄存器，无论是否带 symbol（这一点非常具有迷惑性，需要慢慢理解。往往在分析编译输出的汇编时，看到的就是硬件 SP 寄存器）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;PC: 实际上就是在体系结构的知识中常见的 pc 寄存器，在 x86 平台下对应 ip 寄存器，amd64 上则是 rip。除了个别跳转之外，手写 plan9 汇编代码时，很少用到 PC 寄存器。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面的讲解，想必已经对 4 个核心寄存器的区别有了一定的认识（或者是更加的迷惑、一头雾水）。那么，需要留意的是：如果是在分析编译输出的汇编代码时，要重点看 SP、SB 寄存器（FP 寄存器在这里是看不到的）。如果是，在手写汇编代码，那么要重点看 FP、SP 寄存器。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2.1 伪寄存器的内存模型&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下图描述了栈桢与各个寄存器的内存关系模型，值得注意的是要站在 callee 的角度来看。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.1822916666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvav8IgyML3khHFMKbUficlbDVm5m71Fs2muo4UibOAlt0NoibPBt7YQgUKicTpd8K8mtS1rFYuibugLaaNQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1152&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一点需要注意的是，return addr 也是在 caller 的栈上的，不过往栈上插 return addr 的过程是由 CALL 指令完成的（在分析汇编时，是看不到关于 addr 相关空间信息的。在分配栈空间时，addr 所占用空间大小不包含在栈帧大小内）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 AMD64 环境，伪 PC 寄存器其实是 IP 指令计数器寄存器的别名。伪 FP 寄存器对应的是 caller 函数的帧指针，一般用来访问 callee 函数的入参参数和返回值。伪 SP 栈指针对应的是当前 callee 函数栈帧的底部（不包括参数和返回值部分），一般用于定位局部变量。伪 SP 是一个比较特殊的寄存器，因为还存在一个同名的 SP 真寄存器，真 SP 寄存器对应的是栈的顶部。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在编写 Go 汇编时，当需要区分伪寄存器和真寄存器的时候只需要记住一点：伪寄存器一般需要一个标识符和偏移量为前缀，如果没有标识符前缀则是真寄存器。比如(SP)、+8(SP)没有标识符前缀为真 SP 寄存器，而 a(SP)、b+8(SP)有标识符为前缀表示伪寄存器。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2.2 几点说明&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们这里对容易混淆的几点简单进行说明：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;伪 SP 和硬件 SP 不是一回事，在手写汇编代码时，伪 SP 和硬件 SP 的区分方法是看该 SP 前是否有 symbol。如果有 symbol，那么即为伪寄存器，如果没有，那么说明是硬件 SP 寄存器。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;伪 SP 和 FP 的相对位置是会变的，所以不应该尝试用伪 SP 寄存器去找那些用 FP+offset 来引用的值，例如函数的入参和返回值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;官方文档中说的伪 SP 指向 stack 的 top，可能是有问题的。其指向的局部变量位置实际上是整个栈的栈底（除 caller BP 之外），所以说 bottom 更合适一些。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在 go tool objdump/go tool compile -S 输出的代码中，是没有伪 SP 和 FP 寄存器的，我们上面说的区分伪 SP 和硬件 SP 寄存器的方法，对于上述两个命令的输出结果是没法使用的。在编译和反汇编的结果中，只有真实的 SP 寄存器。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2.3 IA64 和 plan9 的对应关系&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 plan9 汇编里还可以直接使用的 amd64 的通用寄存器，应用代码层面会用到的通用寄存器主要是: rax, rbx, rcx, rdx, rdi, rsi, r8~r15 这些寄存器，虽然 rbp 和 rsp 也可以用，不过 bp 和 sp 会被用来管理栈顶和栈底，最好不要拿来进行运算。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;plan9 中使用寄存器不需要带 r 或 e 的前缀，例如 rax，只要写 AX 即可:
MOVQ $101, AX = mov rax, 101&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是通用通用寄存器的名字在 IA64 和 plan9 中的对应关系:&lt;img data-ratio=&quot;0.11962224554039874&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvav8IgyML3khHFMKbUficlbDV58Tr1WagJOib5DVG9NzW6XyxBR8txlVY9Bkrd7qyVbbEmHCjllicnpzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1906&quot;/&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3 常用操作指令&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面列出了常用的几个汇编指令（指令后缀&lt;code&gt;Q&lt;/code&gt; 说明是 64 位上的汇编指令）&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;助记符&lt;/th&gt;&lt;th&gt;指令种类&lt;/th&gt;&lt;th&gt;用途&lt;/th&gt;&lt;th&gt;示例&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;MOVQ&lt;/code&gt;&lt;/td&gt;&lt;td&gt;传送&lt;/td&gt;&lt;td&gt;数据传送&lt;/td&gt;&lt;td&gt;MOVQ 48, AX // 把 48 传送到 AX&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;LEAQ&lt;/code&gt;&lt;/td&gt;&lt;td&gt;传送&lt;/td&gt;&lt;td&gt;地址传送&lt;/td&gt;&lt;td&gt;LEAQ AX, BX // 把 AX 有效地址传送到 BX&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;PUSHQ&lt;/code&gt;&lt;/td&gt;&lt;td&gt;传送&lt;/td&gt;&lt;td&gt;栈压入&lt;/td&gt;&lt;td&gt;PUSHQ AX // 将 AX 内容送入栈顶位置&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;POPQ&lt;/code&gt;&lt;/td&gt;&lt;td&gt;传送&lt;/td&gt;&lt;td&gt;栈弹出&lt;/td&gt;&lt;td&gt;POPQ AX // 弹出栈顶数据后修改栈顶指针&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;ADDQ&lt;/code&gt;&lt;/td&gt;&lt;td&gt;运算&lt;/td&gt;&lt;td&gt;相加并赋值&lt;/td&gt;&lt;td&gt;ADDQ BX, AX // 等价于 AX+=BX&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;SUBQ&lt;/code&gt;&lt;/td&gt;&lt;td&gt;运算&lt;/td&gt;&lt;td&gt;相减并赋值&lt;/td&gt;&lt;td&gt;SUBQ BX, AX // 等价于 AX-=BX&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;CMPQ&lt;/code&gt;&lt;/td&gt;&lt;td&gt;运算&lt;/td&gt;&lt;td&gt;比较大小&lt;/td&gt;&lt;td&gt;CMPQ SI CX // 比较 SI 和 CX 的大小&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;CALL&lt;/code&gt;&lt;/td&gt;&lt;td&gt;转移&lt;/td&gt;&lt;td&gt;调用函数&lt;/td&gt;&lt;td&gt;CALL runtime.printnl(SB) // 发起调用&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;JMP&lt;/code&gt;&lt;/td&gt;&lt;td&gt;转移&lt;/td&gt;&lt;td&gt;无条件转移指令&lt;/td&gt;&lt;td&gt;JMP 0x0185 //无条件转至 0x0185 地址处&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;JLS&lt;/code&gt;&lt;/td&gt;&lt;td&gt;转移&lt;/td&gt;&lt;td&gt;条件转移指令&lt;/td&gt;&lt;td&gt;JLS 0x0185 //左边小于右边，则跳到 0x0185&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4. 汇编分析&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说了那么多，it is code show time。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.1 如何输出 Go 汇编&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于写好的 go 源码，生成对应的 Go 汇编，大概有下面几种&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;方法 1
先使用 &lt;code&gt;go build -gcflags &quot;-N -l&quot; main.go&lt;/code&gt; 生成对应的可执行二进制文件
再使用 &lt;code&gt;go tool objdump -s &quot;main\.&quot; main&lt;/code&gt; 反编译获取对应的汇编&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反编译时&lt;code&gt;&quot;main\.&quot;&lt;/code&gt; 表示只输出 main 包中相关的汇编&lt;code&gt;&quot;main\.main&quot;&lt;/code&gt; 则表示只输出 main 包中 main 方法相关的汇编&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;方法 2
使用 &lt;code&gt;go tool compile -S -N -l main.go&lt;/code&gt; 这种方式直接输出汇编&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;方法 3
使用&lt;code&gt;go build -gcflags=&quot;-N -l -S&quot; main.go&lt;/code&gt; 直接输出汇编&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：在使用这些命令时，加上对应的 flag，否则某些逻辑会被编译器优化掉，而看不到对应完整的汇编代码&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;-l 禁止内联
-N 编译时，禁止优化
-S 输出汇编代码&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.2 Go 汇编示例&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;go 示例代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(a, b &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        sum := &lt;span&gt;0&lt;/span&gt; &lt;span&gt;// 不设置该局部变量sum，add栈空间大小会是0&lt;/span&gt;&lt;br/&gt;        sum = a+b&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; sum&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;println&lt;/span&gt;(add(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;))&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译 go 源代码，输出汇编&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;go tool compile -N -l -S main.go&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;截取主要汇编如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&quot;&quot;.add STEXT nosplit size=60 args=0x18 locals=0x10&lt;br/&gt;        0x0000 00000 (main.go:3)        TEXT    &quot;&quot;.add(SB), NOSPLIT, $16-24&lt;br/&gt;        0x0000 00000 (main.go:3)        SUBQ    $16, SP  ;;生成add栈空间&lt;br/&gt;        0x0004 00004 (main.go:3)        MOVQ    BP, 8(SP)&lt;br/&gt;        0x0009 00009 (main.go:3)        LEAQ    8(SP), BP&lt;br/&gt;    ;; ...omitted FUNCDATA stuff...&lt;br/&gt;        0x000e 00014 (main.go:3)        MOVQ    $0, &quot;&quot;.~r2+40(SP) ;;初始化返回值&lt;br/&gt;        0x0017 00023 (main.go:4)        MOVQ    $0, &quot;&quot;.sum(SP) ;;局部变量sum赋为0&lt;br/&gt;        0x001f 00031 (main.go:5)        MOVQ    &quot;&quot;.a+24(SP), AX  ;;取参数a&lt;br/&gt;        0x0024 00036 (main.go:5)        ADDQ    &quot;&quot;.b+32(SP), AX ;;等价于AX=a+b&lt;br/&gt;        0x0029 00041 (main.go:5)        MOVQ    AX, &quot;&quot;.sum(SP)  ;;赋值局部变量sum&lt;br/&gt;        0x002d 00045 (main.go:6)        MOVQ    AX, &quot;&quot;.~r2+40(SP) ;;设置返回值&lt;br/&gt;        0x0032 00050 (main.go:6)        MOVQ    8(SP), BP&lt;br/&gt;        0x0037 00055 (main.go:6)        ADDQ    $16, SP ;;清除add栈空间&lt;br/&gt;        0x003b 00059 (main.go:6)        RET&lt;br/&gt;    ......&lt;br/&gt;&lt;br/&gt;&quot;&quot;.main STEXT size=107 args=0x0 locals=0x28&lt;br/&gt;        0x0000 00000 (main.go:9)        TEXT    &quot;&quot;.main(SB), $40-0&lt;br/&gt;    ......&lt;br/&gt;        0x000f 00015 (main.go:9)        SUBQ    $40, SP ;; 生成main栈空间&lt;br/&gt;        0x0013 00019 (main.go:9)        MOVQ    BP, 32(SP)&lt;br/&gt;        0x0018 00024 (main.go:9)        LEAQ    32(SP), BP&lt;br/&gt;    ;; ...omitted FUNCDATA stuff...&lt;br/&gt;        0x001d 00029 (main.go:10)       MOVQ    $1, (SP) ;;add入参：1&lt;br/&gt;        0x0025 00037 (main.go:10)       MOVQ    $2, 8(SP) ;;add入参：2&lt;br/&gt;        0x002e 00046 (main.go:10)       CALL    &quot;&quot;.add(SB) ;;调用add函数&lt;br/&gt;        0x0033 00051 (main.go:10)       MOVQ    16(SP), AX&lt;br/&gt;        0x0038 00056 (main.go:10)       MOVQ    AX, &quot;&quot;..autotmp_0+24(SP)&lt;br/&gt;        0x003d 00061 (main.go:10)       CALL    runtime.printlock(SB)&lt;br/&gt;        0x0042 00066 (main.go:10)       MOVQ    &quot;&quot;..autotmp_0+24(SP), AX&lt;br/&gt;        0x0047 00071 (main.go:10)       MOVQ    AX, (SP)&lt;br/&gt;        0x004b 00075 (main.go:10)       CALL    runtime.printint(SB)&lt;br/&gt;        0x0050 00080 (main.go:10)       CALL    runtime.printnl(SB)&lt;br/&gt;        0x0055 00085 (main.go:10)       CALL    runtime.printunlock(SB)&lt;br/&gt;        0x005a 00090 (main.go:11)       MOVQ    32(SP), BP&lt;br/&gt;        0x005f 00095 (main.go:11)       ADDQ    $40, SP ;;清除main栈空间&lt;br/&gt;        0x0063 00099 (main.go:11)       RET&lt;br/&gt;    ......&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里列举了一个简单的 int 类型&lt;code&gt;加法&lt;/code&gt;示例，实际开发中会遇到各种参数类型，要复杂的多，这里只是抛砖引玉 :)&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.3 Go 汇编解析&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对 4.2 输出汇编，对重要核心代码进行分析。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.3.1 add 函数汇编解析&lt;/span&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;TEXT &quot;&quot;.add(SB), NOSPLIT|ABIInternal, $16-24&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;TEXT &quot;&quot;.add&lt;/code&gt; TEXT 指令声明了 &lt;code&gt;&quot;&quot;.add&lt;/code&gt; 是 .text 代码段的一部分，并表明跟在这个声明后的是函数的函数体。在链接期，&lt;code&gt;&quot;&quot;&lt;/code&gt;这个空字符会被替换为当前的包名: 也就是说，&lt;code&gt;&quot;&quot;.add&lt;/code&gt; 在链接到二进制文件后会变成 main.add&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;(SB)&lt;/code&gt; SB 是一个虚拟的伪寄存器，保存静态基地址(static-base) 指针，即我们程序地址空间的开始地址。&lt;code&gt;&quot;&quot;.add(SB)&lt;/code&gt; 表明我们的符号位于某个固定的相对地址空间起始处的偏移位置 (最终是由链接器计算得到的)。换句话来讲，它有一个直接的绝对地址: 是一个全局的函数符号。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;NOSPLIT:&lt;/code&gt; 向编译器表明不应该插入 stack-split 的用来检查栈需要扩张的前导指令。在我们 add 函数的这种情况下，编译器自己帮我们插入了这个标记: 它足够聪明地意识到，由于 add 没有任何局部变量且没有它自己的栈帧，所以一定不会超出当前的栈。不然，每次调用函数时，在这里执行栈检查就是完全浪费 CPU 时间了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$0-16&lt;/code&gt;&lt;/p&gt;&lt;section role=&quot;presentation&quot; data-formula=&quot;16 代表即将分配的栈帧大小（16字节=caller BP地址大小8字节+局部变量sum大小8字节）&amp;#10;- 只是个分隔符（固定格式）&amp;#10;&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;embed src=&quot;https://mmbiz.qlogo.cn/mmbiz_svg/Iic9WLWEQMg1XYRcGSzPSxXfBKjdWVzkOHhEtFqRUO0I8uZIWMuPw1icSy7eic07uhStibvwnD4EkicUMpKOmEJicFGEoNhlvRNwB1/0?wx_fmt=svg&quot; data-type=&quot;svg+xml&quot;/&gt;&lt;/section&gt;24 指定了调用方传入的参数+返回值大小（24 字节=入参 a、b 大小&lt;code&gt;8字节*2&lt;/code&gt;+&lt;code&gt;返回值8字节&lt;/code&gt;）&lt;p&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;通常来讲，帧大小后一般都跟随着一个参数大小，用减号分隔。(这不是一个减法操作，只是一种特殊的语法) 帧大小 $24-8 意味着这个函数有 24 个字节的帧以及 8 个字节的参数，位于调用者的帧上。如果 NOSPLIT 没有在 TEXT 中指定，则必须提供参数大小。对于 Go 原型的汇编函数，go vet 会检查参数大小是否正确。&lt;/p&gt;&lt;p&gt;In the general case, the frame size is followed by an argument size, separated by a minus sign. (It’s not a subtraction, just idiosyncratic syntax.) The frame size $24-8 states that the function has a 24-byte frame and is called with 8 bytes of argument, which live on the caller’s frame. If NOSPLIT is not specified for the TEXT, the argument size must be provided. For assembly functions with Go prototypes, go vet will check that the argument size is correct.&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;SUBQ $16, SP&lt;/code&gt;SP 为栈顶指针，该语句等价于 SP-=16（由于栈空间是向下增长的，所以开辟栈空间时为减操作），表示生成 16 字节大小的栈空间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;MOVQ $0, &quot;&quot;.~r2+40(SP)&lt;/code&gt;此时的 SP 为 add 函数栈的栈顶指针，40(SP)的位置则是 add 返回值的位置，该位置位于 main 函数栈空间内。该语句设置返回值类型的 0 值，即初始化返回值，防止得到脏数据（返回值类型为 int，int 的 0 值为 0）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;MOVQ &quot;&quot;.a+24(SP), AX&lt;/code&gt;从 main 函数栈空间获取入参 a 的值，存到寄存器 AX&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ADDQ &quot;&quot;.b+32(SP), AX&lt;/code&gt;从 main 函数栈空间获取入参 b 的值，与寄存器 AX 中存储的 a 值相加，结果存到 AX。相当于 AX=a+b&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;MOVQ AX, &quot;&quot;.~r2+40(SP)&lt;/code&gt;把 a+b 的结果放到 main 函数栈中, add(a+b)返回值所在的位置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ADDQ $16, SP&lt;/code&gt;归还 add 函数占用的栈空间&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.3.2 函数栈桢结构模型&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据 4.2 对应汇编绘制的函数栈桢结构模型&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5108459869848156&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvav8IgyML3khHFMKbUficlbDVZk4mO1aY5at6o8Bn2jrxMpL5v9xDfxWthibIq28icRibzznFIq2btKzDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1844&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还记得前面提到的，Go 汇编使用的是&lt;code&gt;caller-save&lt;/code&gt;模式，被调用函数的参数、返回值、栈位置都需要由调用者维护、准备吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在函数栈桢结构中可以看到，add()函数的入参以及返回值都由调用者 main()函数维护。也正是因为如此，GO 有了其他语言不具有的，支持多个返回值的特性。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.4 Go 汇编语法&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里重点讲一下函数声明、变量声明。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.4.1 函数声明&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来看一个典型的 Go 汇编函数定义&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;// func add(a, b int) int&lt;br/&gt;// 该add函数声明定义在同一个 package name 下的任意 .go文件中&lt;br/&gt;// 只有函数头，没有实现&lt;br/&gt;&lt;br/&gt;// add函数的Go汇编实现&lt;br/&gt;// pkgname 默认是  &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt;TEXT pkgname·add(SB), NOSPLIT, $&lt;span&gt;16-24&lt;/span&gt;&lt;br/&gt;    MOVQ a+&lt;span&gt;0&lt;/span&gt;(FP), AX&lt;br/&gt;    ADDQ b+&lt;span&gt;8&lt;/span&gt;(FP), AX&lt;br/&gt;    MOVQ AX, ret+&lt;span&gt;16&lt;/span&gt;(FP)&lt;br/&gt;    RET&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 汇编实现为什么是 &lt;code&gt;TEXT&lt;/code&gt; 开头？仔细观察上面的进程内存布局图就会发现，我们的代码在是存储在.text 段中的，这里也就是一种约定俗成的起名方式。实际上在 plan9 中 TEXT 是一个指令，用来定义一个函数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定义中的 pkgname 是可以省略的，(非想写也可以写上，不过写上 pkgname 的话，在重命名 package 之后还需要改代码，默认为&lt;code&gt;&quot;&quot;&lt;/code&gt;) 编译器会在链接期自动加上所属的包名称。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;中点 &lt;code&gt;·&lt;/code&gt; 比较特殊，是一个 unicode 的中点，该点在 mac 下的输入方法是 option+shift+9。在程序被链接之后，所有的中点&lt;code&gt;·&lt;/code&gt;都会被替换为句号&lt;code&gt;.&lt;/code&gt;，比如你的方法是&lt;code&gt;runtime·main&lt;/code&gt;，在编译之后的程序里的符号则是&lt;code&gt;runtime.main&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单总结一下, Go 汇编实现函数声明，格式为:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt; 静态基地址(static-base) 指针&lt;br/&gt;    |&lt;br/&gt;                  |         add函数入参+返回值总大小&lt;br/&gt;                  |               |&lt;br/&gt;TEXT pkgname·add(SB),NOSPLIT,$&lt;span&gt;16-24&lt;/span&gt;&lt;br/&gt;      |      |                |&lt;br/&gt;函数所属包名  函数名          add函数栈帧大小&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;函数栈帧大小：局部变量+可能需要的额外调用函数的参数空间的总大小，不包括调用其它函数时的 ret address 的大小。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;(SB): SB 是一个虚拟寄存器，保存了静态基地址(static-base) 指针，即我们程序地址空间的开始地址。&lt;code&gt;&quot;&quot;.add(SB)&lt;/code&gt; 表明我们的符号位于某个固定的相对地址空间起始处的偏移位置 (最终是由链接器计算得到的)。换句话来讲，它有一个直接的绝对地址: 是一个全局的函数符号。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;NOSPLIT: 向编译器表明，不应该插入 stack-split 的用来检查栈需要扩张的前导指令。在我们 add 函数的这种情况下，编译器自己帮我们插入了这个标记: 它足够聪明地意识到，add 不会超出当前的栈，因此没必要调用函数时在这里执行栈检查。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.4.2 变量声明&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;汇编里的全局变量，一般是存储在&lt;code&gt;.rodata&lt;/code&gt;或者&lt;code&gt;.data&lt;/code&gt;段中。对应到 Go 代码，就是已初始化过的全局的 const、var 变量/常量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 DATA 结合 GLOBL 来定义一个变量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DATA 的用法为:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;DATA symbol+offset(SB)/width, value&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大多数参数都是字面意思，不过这个 offset 需要注意：其含义是该值相对于符号 symbol 的偏移，而不是相对于全局某个地址的偏移。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GLOBL 汇编指令用于定义名为 symbol 的全局变量，变量对应的内存宽度为 width，内存宽度部分必须用常量初始化。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;GLOBL ·symbol(SB), width&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是定义了多个变量的例子:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;DATA ·age+&lt;span&gt;0&lt;/span&gt;(SB)/&lt;span&gt;4&lt;/span&gt;, $&lt;span&gt;8&lt;/span&gt;  ;; 数值&lt;span&gt;8&lt;/span&gt;为 &lt;span&gt;4&lt;/span&gt;字节&lt;br/&gt;GLOBL ·age(SB), RODATA, $&lt;span&gt;4&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;DATA ·pi+&lt;span&gt;0&lt;/span&gt;(SB)/&lt;span&gt;8&lt;/span&gt;, $&lt;span&gt;3.1415926&lt;/span&gt; ;; 数值&lt;span&gt;3.1415926&lt;/span&gt;为float64, &lt;span&gt;8&lt;/span&gt;字节&lt;br/&gt;GLOBL ·pi(SB), RODATA, $&lt;span&gt;8&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;DATA ·year+&lt;span&gt;0&lt;/span&gt;(SB)/&lt;span&gt;4&lt;/span&gt;, $&lt;span&gt;2020&lt;/span&gt; ;; 数值&lt;span&gt;2020&lt;/span&gt;为 &lt;span&gt;4&lt;/span&gt;字节&lt;br/&gt;GLOBL ·year(SB), RODATA, $&lt;span&gt;4&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;;; 变量hello 使用&lt;span&gt;2&lt;/span&gt;个DATA来定义&lt;br/&gt;DATA ·hello+&lt;span&gt;0&lt;/span&gt;(SB)/&lt;span&gt;8&lt;/span&gt;, $&lt;span&gt;&quot;hello my&quot;&lt;/span&gt; ;; `hello my` 共&lt;span&gt;8&lt;/span&gt;个字节&lt;br/&gt;DATA ·hello+&lt;span&gt;8&lt;/span&gt;(SB)/&lt;span&gt;8&lt;/span&gt;, $&lt;span&gt;&quot;   world&quot;&lt;/span&gt; ;; `   world` 共&lt;span&gt;8&lt;/span&gt;个字节(&lt;span&gt;3&lt;/span&gt;个空格)&lt;br/&gt;GLOBL ·hello(SB), RODATA, $&lt;span&gt;16&lt;/span&gt; ;; `hello my   world`  共&lt;span&gt;16&lt;/span&gt;个字节&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;DATA ·hello&amp;lt;&amp;gt;+&lt;span&gt;0&lt;/span&gt;(SB)/&lt;span&gt;8&lt;/span&gt;, $&lt;span&gt;&quot;hello my&quot;&lt;/span&gt; ;; `hello my` 共&lt;span&gt;8&lt;/span&gt;个字节&lt;br/&gt;DATA ·hello&amp;lt;&amp;gt;+&lt;span&gt;8&lt;/span&gt;(SB)/&lt;span&gt;8&lt;/span&gt;, $&lt;span&gt;&quot;   world&quot;&lt;/span&gt; ;; `   world` 共&lt;span&gt;8&lt;/span&gt;个字节(&lt;span&gt;3&lt;/span&gt;个空格)&lt;br/&gt;GLOBL ·hello&amp;lt;&amp;gt;(SB), RODATA, $&lt;span&gt;16&lt;/span&gt; ;; `hello my   world`  共&lt;span&gt;16&lt;/span&gt;个字节&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大部分都比较好理解，不过这里引入了新的标记&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;，这个跟在符号名之后，表示该全局变量只在当前文件中生效，类似于 C 语言中的 static。如果在另外文件中引用该变量的话，会报 relocation target not found 的错误。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5. 手写汇编实现功能&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Go 源码中会看到一些汇编写的代码，这些代码跟其他 go 代码一起组成了整个 go 的底层功能实现。下面，我们通过一个简单的 Go 汇编代码示例来实现两数相加功能。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.1 使用 Go 汇编实现 add 函数&lt;/span&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.20647002854424357&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvav8IgyML3khHFMKbUficlbDVQIh0BLUg6c9H8WMZEtWaFsQwWgXfAHBOp5UibFNQmMZ36yc01ia9ibQdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2102&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(a, b &lt;span&gt;int64&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;int64&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;println&lt;/span&gt;(add(&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;))&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 源码中 add()函数只有函数签名，没有具体的实现（使用 GO 汇编实现）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 Go 汇编实现的 add()函数&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;TEXT ·add(SB), $&lt;span&gt;0-24&lt;/span&gt; ;; add栈空间为&lt;span&gt;0&lt;/span&gt;，入参+返回值大小=&lt;span&gt;24&lt;/span&gt;字节&lt;br/&gt;        MOVQ x+&lt;span&gt;0&lt;/span&gt;(FP), AX ;; 从main中取参数：&lt;span&gt;2&lt;/span&gt;&lt;br/&gt;        ADDQ y+&lt;span&gt;8&lt;/span&gt;(FP), AX ;; 从main中取参数：&lt;span&gt;3&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        MOVQ AX, ret+&lt;span&gt;16&lt;/span&gt;(FP) ;; 保存结果到返回值&lt;br/&gt;&lt;br/&gt;        RET&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把 Go 源码与 Go 汇编编译到一起(我这里，这两个文件在同一个目录)&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;go build -gcflags &lt;span&gt;&quot;-N -l&quot;&lt;/span&gt; .&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我这里目录为 demo1，所以得到可执行程序 demo1，运行得到结果：5&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.2 反编译可执行程序&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对 5.1 中得到的可执行程序 demo1 使用 objdump 进行反编译，获取汇编代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;go tool objdump -s &lt;span&gt;&quot;main\.&quot;&lt;/span&gt; demo1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;得到汇编&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;......&lt;br/&gt;TEXT main.main(SB) /root/go/src/demo1/main.go&lt;br/&gt;  main.go:&lt;span&gt;5&lt;/span&gt;   &lt;span&gt;0x4581d0&lt;/span&gt;     &lt;span&gt;64488&lt;/span&gt;b0c25f8ffffff      MOVQ FS:&lt;span&gt;0xfffffff8&lt;/span&gt;, CX&lt;br/&gt;  main.go:&lt;span&gt;5&lt;/span&gt;   &lt;span&gt;0x4581d9&lt;/span&gt;     &lt;span&gt;483&lt;/span&gt;b6110                CMPQ &lt;span&gt;0x10&lt;/span&gt;(CX), SP&lt;br/&gt;  main.go:&lt;span&gt;5&lt;/span&gt;   &lt;span&gt;0x4581dd&lt;/span&gt;     &lt;span&gt;7655&lt;/span&gt;                    JBE &lt;span&gt;0x458234&lt;/span&gt;&lt;br/&gt;  main.go:&lt;span&gt;5&lt;/span&gt;   &lt;span&gt;0x4581df&lt;/span&gt;     &lt;span&gt;4883&lt;/span&gt;ec28                SUBQ $&lt;span&gt;0x28&lt;/span&gt;, SP ;;生成main栈桢&lt;br/&gt;  main.go:&lt;span&gt;5&lt;/span&gt;   &lt;span&gt;0x4581e3&lt;/span&gt;     &lt;span&gt;48896&lt;/span&gt;c2420              MOVQ BP, &lt;span&gt;0x20&lt;/span&gt;(SP)&lt;br/&gt;  main.go:&lt;span&gt;5&lt;/span&gt;   &lt;span&gt;0x4581e8&lt;/span&gt;     &lt;span&gt;488&lt;/span&gt;d6c2420              LEAQ &lt;span&gt;0x20&lt;/span&gt;(SP), BP&lt;br/&gt;  main.go:&lt;span&gt;6&lt;/span&gt;   &lt;span&gt;0x4581ed&lt;/span&gt;     &lt;span&gt;48&lt;/span&gt;c7042402000000        MOVQ $&lt;span&gt;0x2&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;(SP) ;;参数值 &lt;span&gt;2&lt;/span&gt;&lt;br/&gt;  main.go:&lt;span&gt;6&lt;/span&gt;   &lt;span&gt;0x4581f5&lt;/span&gt;     &lt;span&gt;48&lt;/span&gt;c744240803000000      MOVQ $&lt;span&gt;0x3&lt;/span&gt;, &lt;span&gt;0x8&lt;/span&gt;(SP) ;;参数值 &lt;span&gt;3&lt;/span&gt;&lt;br/&gt;  main.go:&lt;span&gt;6&lt;/span&gt;   &lt;span&gt;0x4581fe&lt;/span&gt;     e83d000000              CALL main.add(SB);;call add&lt;br/&gt;  main.go:&lt;span&gt;6&lt;/span&gt;   &lt;span&gt;0x458203&lt;/span&gt;     &lt;span&gt;488&lt;/span&gt;b442410              MOVQ &lt;span&gt;0x10&lt;/span&gt;(SP), AX&lt;br/&gt;  main.go:&lt;span&gt;6&lt;/span&gt;   &lt;span&gt;0x458208&lt;/span&gt;     &lt;span&gt;4889442418&lt;/span&gt;              MOVQ AX, &lt;span&gt;0x18&lt;/span&gt;(SP)&lt;br/&gt;  main.go:&lt;span&gt;6&lt;/span&gt;   &lt;span&gt;0x45820d&lt;/span&gt;     e8fe2dfdff              CALL runtime.printlock(SB)&lt;br/&gt;  main.go:&lt;span&gt;6&lt;/span&gt;   &lt;span&gt;0x458212&lt;/span&gt;     &lt;span&gt;488&lt;/span&gt;b442418              MOVQ &lt;span&gt;0x18&lt;/span&gt;(SP), AX&lt;br/&gt;  main.go:&lt;span&gt;6&lt;/span&gt;   &lt;span&gt;0x458217&lt;/span&gt;     &lt;span&gt;48890424&lt;/span&gt;                MOVQ AX, &lt;span&gt;0&lt;/span&gt;(SP)&lt;br/&gt;  main.go:&lt;span&gt;6&lt;/span&gt;   &lt;span&gt;0x45821b&lt;/span&gt;     e87035fdff              CALL runtime.printint(SB)&lt;br/&gt;  main.go:&lt;span&gt;6&lt;/span&gt;   &lt;span&gt;0x458220&lt;/span&gt;     e87b30fdff              CALL runtime.printnl(SB)&lt;br/&gt;  main.go:&lt;span&gt;6&lt;/span&gt;   &lt;span&gt;0x458225&lt;/span&gt;     e8662efdff              CALL runtime.printunlock(SB)&lt;br/&gt;  main.go:&lt;span&gt;7&lt;/span&gt;   &lt;span&gt;0x45822a&lt;/span&gt;     &lt;span&gt;488&lt;/span&gt;b6c2420              MOVQ &lt;span&gt;0x20&lt;/span&gt;(SP), BP&lt;br/&gt;  main.go:&lt;span&gt;7&lt;/span&gt;   &lt;span&gt;0x45822f&lt;/span&gt;     &lt;span&gt;4883&lt;/span&gt;c428                ADDQ $&lt;span&gt;0x28&lt;/span&gt;, SP&lt;br/&gt;  main.go:&lt;span&gt;7&lt;/span&gt;   &lt;span&gt;0x458233&lt;/span&gt;     c3                      RET&lt;br/&gt;  main.go:&lt;span&gt;5&lt;/span&gt;   &lt;span&gt;0x458234&lt;/span&gt;     e89797ffff              CALL runtime.morestack_noctxt(SB)&lt;br/&gt;  main.go:&lt;span&gt;5&lt;/span&gt;   &lt;span&gt;0x458239&lt;/span&gt;     eb95                    JMP main.main(SB)&lt;br/&gt;&lt;br/&gt;;; 反编译得到的汇编与add_amd64.s文件中的汇编大致操作一致&lt;br/&gt;TEXT main.add(SB) /root/go/src/demo1/add_amd64.s&lt;br/&gt;  add_amd64.s:&lt;span&gt;2&lt;/span&gt;   &lt;span&gt;0x458240&lt;/span&gt;    &lt;span&gt;488&lt;/span&gt;b442408    MOVQ &lt;span&gt;0x8&lt;/span&gt;(SP), AX ;; 获取第一个参数&lt;br/&gt;  add_amd64.s:&lt;span&gt;3&lt;/span&gt;   &lt;span&gt;0x458245&lt;/span&gt;    &lt;span&gt;4803442410&lt;/span&gt;    ADDQ &lt;span&gt;0x10&lt;/span&gt;(SP), AX ;;参数a+参数b&lt;br/&gt;  add_amd64.s:&lt;span&gt;5&lt;/span&gt;   &lt;span&gt;0x45824a&lt;/span&gt;    &lt;span&gt;4889442418&lt;/span&gt;    MOVQ AX, &lt;span&gt;0x18&lt;/span&gt;(SP) ;;保存计算结果&lt;br/&gt;  add_amd64.s:&lt;span&gt;7&lt;/span&gt;   &lt;span&gt;0x45824f&lt;/span&gt;    c3            RET&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面操作，可知：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;(FP)伪寄存器，只有在编写 Go 汇编代码时使用。FP 伪寄存器指向 caller 传递给 callee 的第一个参数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用 go tool compile / go tool objdump 得到的汇编中看不到(FP)寄存器的踪影&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6. Go 调试工具&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里推荐 2 个 Go 代码调试工具。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6.1 gdb 调试 Go 代码&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Ier &lt;span&gt;interface&lt;/span&gt;{&lt;br/&gt;        add(a, b &lt;span&gt;int&lt;/span&gt;) &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;        sub(a, b &lt;span&gt;int&lt;/span&gt;) &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; data &lt;span&gt;struct&lt;/span&gt;{&lt;br/&gt;        a, b &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(*data)&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(a, b &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; a+b&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(*data)&lt;/span&gt; &lt;span&gt;sub&lt;/span&gt;&lt;span&gt;(a, b &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; a-b&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;var&lt;/span&gt; t Ier = &amp;amp;data{&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;}&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;println&lt;/span&gt;(t.add(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;))&lt;br/&gt;        &lt;span&gt;println&lt;/span&gt;(t.sub(&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;))&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译 &lt;code&gt;go build -gcflags &quot;-N -l&quot; -o main&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 GDB 调试&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&amp;gt; gdb main&lt;br/&gt;&lt;br/&gt;GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-80.el7&lt;br/&gt;Copyright (C) 2013 Free Software Foundation, Inc.&lt;br/&gt;License GPLv3+: GNU GPL version 3 or later http://gnu.org/licenses/gpl.html&lt;br/&gt;This is free software: you are free to change and redistribute it.&lt;br/&gt;There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;&lt;br/&gt;and &quot;show warranty&quot; for details.&lt;br/&gt;This GDB was configured as &quot;x86_64-redhat-linux-gnu&quot;.&lt;br/&gt;For bug reporting instructions, please see:&lt;br/&gt;&amp;lt;http://www.gnu.org/software/gdb/bugs/&amp;gt;...&lt;br/&gt;Reading symbols from /root/go/src/interface/main...done.&lt;br/&gt;Loading Go Runtime support.&lt;br/&gt;(gdb) list   // 显示源码&lt;br/&gt;14      func (*data) add(a, b int) int{&lt;br/&gt;15              return a+b&lt;br/&gt;16      }&lt;br/&gt;17&lt;br/&gt;18      func (*data) sub(a, b int) int{&lt;br/&gt;19              return a-b&lt;br/&gt;20      }&lt;br/&gt;21&lt;br/&gt;22&lt;br/&gt;23      func main(){&lt;br/&gt;(gdb) list&lt;br/&gt;24              var t Ier = &amp;amp;data{3,4}&lt;br/&gt;25&lt;br/&gt;26              println(t.add(1,2))&lt;br/&gt;27              println(t.sub(3,2))&lt;br/&gt;28      }&lt;br/&gt;29&lt;br/&gt;(gdb) b 26  // 在源码26行处设置断点&lt;br/&gt;Breakpoint 1 at 0x45827c: file /root/go/src/interface/main.go, line 26.&lt;br/&gt;(gdb) r&lt;br/&gt;Starting program: /root/go/src/interface/main&lt;br/&gt;&lt;br/&gt;Breakpoint 1, main.main () at /root/go/src/interface/main.go:26&lt;br/&gt;26              println(t.add(1,2))&lt;br/&gt;(gdb) info locals  // 显示变量&lt;br/&gt;t = {tab = 0x487020 &amp;lt;data,main.Ier&amp;gt;, data = 0xc000096000}&lt;br/&gt;(gdb) ptype t  // 打印t的结构&lt;br/&gt;type = struct runtime.iface {&lt;br/&gt;    runtime.itab *tab;&lt;br/&gt;    void *data;&lt;br/&gt;}&lt;br/&gt;(gdb) p *t.tab.inter  // 打印t.tab.inter指针指向的数据&lt;br/&gt;$2 = {typ = {size = 16, ptrdata = 16, hash = 2491815843, tflag = 7 &#x27;\a&#x27;, align = 8 &#x27;\b&#x27;, fieldAlign = 8 &#x27;\b&#x27;,&lt;br/&gt;    kind = 20 &#x27;\024&#x27;, equal = {void (void *, void *, bool *)} 0x466ec0,&lt;br/&gt;    gcdata = 0x484351 &quot;\002\003\004\005\006\a\b\t\n\f\r\016\017\020\022\025\026\030\033\034\036\037\&quot;&amp;amp;(,-5&amp;lt;BUXx\216\231\330\335\377&quot;, str = 6568, ptrToThis = 23808}, pkgpath = {bytes = 0x4592b4 &quot;&quot;}, mhdr =  []runtime.imethod = {{name = 277,&lt;br/&gt;      ityp = 48608}, {name = 649, ityp = 48608}}}&lt;br/&gt;(gdb) disass  // 显示汇编&lt;br/&gt;Dump of assembler code for function main.main:&lt;br/&gt;   0x0000000000458210 &amp;lt;+0&amp;gt;:     mov    %fs:0xfffffffffffffff8,%rcx&lt;br/&gt;   0x0000000000458219 &amp;lt;+9&amp;gt;:     cmp    0x10(%rcx),%rsp&lt;br/&gt;   0x000000000045821d &amp;lt;+13&amp;gt;:    jbe    0x458324 &amp;lt;main.main+276&amp;gt;&lt;br/&gt;   0x0000000000458223 &amp;lt;+19&amp;gt;:    sub    $0x50,%rsp&lt;br/&gt;   0x0000000000458227 &amp;lt;+23&amp;gt;:    mov    %rbp,0x48(%rsp)&lt;br/&gt;   0x000000000045822c &amp;lt;+28&amp;gt;:    lea    0x48(%rsp),%rbp&lt;br/&gt;   0x0000000000458231 &amp;lt;+33&amp;gt;:    lea    0x10dc8(%rip),%rax        # 0x469000&lt;br/&gt;   0x0000000000458238 &amp;lt;+40&amp;gt;:    mov    %rax,(%rsp)&lt;br/&gt;   0x000000000045823c &amp;lt;+44&amp;gt;:    callq  0x40a5c0 &amp;lt;runtime.newobject&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常用的 gdb 调试命令&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;run&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;continue&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;break&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;backtrace 与 frame&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;info break、locals&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;list 命令&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;print 和 ptype 命令&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;disass&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了 gdb，另外推荐一款 gdb 的增强版调试工具 cgdb&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;https://cgdb.github.io/&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;效果如下图所示，分两个窗口：上面显示源代码，下面是具体的命令行调试界面(跟 gdb 一样)：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.875140607424072&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvav8IgyML3khHFMKbUficlbDVSNJy3YejMRlt7tMga9lAMuvicSPcf0cug4PGpEibaQiacoryJAJDdVPuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1778&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6.2 delve 调试代码&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;delve 项目地址&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;https://github.com/go-delve/delve&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;带图形化界面的 dlv 项目地址&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;https://github.com/aarzilli/gdlv&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;dlv 的安装使用，这里不再做过多讲解，感兴趣的可以尝试一下。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;gdb 作为调试工具自是不用多说，比较老牌、强大，可以支持多种语言。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;delve 则是使用 go 语言开发的，用来调试 go 的工具，功能也是十分强大，打印结果可以显示 gdb 支持不了的东西，这里不再做过多讲解，有兴趣的可以查阅相关资料。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;7. 总结&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 Go 汇编基础大致需要熟悉下面几个方面：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.2884283246977548&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvav8IgyML3khHFMKbUficlbDVToDDz2VsRZibdv8gJibYw0icUYNJQmZzmdcMTsbNHKtjTYSibUIQuVxZRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1158&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面的例子相信已经让你对 Go 的汇编有了一定的理解。当然，对于大部分业务开发人员来说，只要看的懂即可。如果想进一步的了解，可以阅读相关的资料或者书籍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后想说的是：鉴于个人能力有限，在阅读过程中你可能会发现存在的一些问题或者缺陷，欢迎各位大佬指正。如果感兴趣的话，也可以一起私下交流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;8. 参考资料&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在整理的过程中，部分参考、引用下面链接地址内容。有一些写的还是不错的，感兴趣的同学可以阅读。&lt;/p&gt;&lt;section&gt;&lt;span&gt;[1] https://github.com/cch123/golang-notes/blob/master/assembly.md plan9 assembly &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[2] https://segmentfault.com/a/1190000019753885 汇编入门 &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[3] https://www.davidwong.fr/goasm/ Go Assembly by Example &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[4] https://juejin.im/post/6844904005630443533#heading-3 &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[5] https://github.com/go-internals-cn/go-internals/blob/master/chapter1_assembly_primer/README.md &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[6] https://lrita.github.io/2017/12/12/golang-asm/ &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[7] https://chai2010.cn/advanced-go-programming-book/ch3-asm/ch3-01-basic.html&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.729264475743349&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvatricjRxhpM1x45aB6doaVg7WMhINPwOiaqpskia1kH7hgibO0dicW2HLcW8HRGMzESQwehIcyckLXtwsA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;639&quot;/&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fc3c9368bce46176ba93ffe78d42d444</guid>
<title>[推荐] 23 个问题 TCP 疑难杂症全解析</title>
<link>https://toutiao.io/k/yktjpks</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;每个时代，都不会亏待会学习的人。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是 yes。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在进入今天主题之前我先抛几个问题，这篇文章一共提出 23 个问题。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;TCP 握手一定是三次？TCP 挥手一定是四次？&lt;/p&gt;&lt;p&gt;为什么要有快速重传，超时重传不够用？为什么要有 SACK，为什么要有 D-SACK？&lt;/p&gt;&lt;p&gt;都知道有滑动窗口，那由于接收方的太忙了滑动窗口降为了 0 怎么办？发送方就永远等着了？&lt;/p&gt;&lt;p&gt;Silly Window 又是什么？&lt;/p&gt;&lt;p&gt;为什么有滑动窗口流控还需要拥塞控制？&lt;/p&gt;&lt;p&gt;快速重传一定要依赖三次重复 ACK ？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章我想&lt;span&gt;由浅到深地过一遍 TCP，不是生硬的搬出各个知识点，从问题入手，然后从发展、演进的角度来看 TCP&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;起初我在学计算机网络的时候就有非常非常多的疑问，脑子里简直充满了十万个为什么，而网络又非常的复杂，发展了这么多年东西真的太多了，今天我就&lt;span&gt;大致的浅显地说一说我对 TCP 这些要点的理解&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，废话不多说，开始上正菜。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;TCP 是用来解决什么问题？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCP 即 Transmission Control Protocol，可以看到是一个传输控制协议，重点就在这个&lt;span&gt;控制&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;控制什么？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;控制可靠、按序地传输以及端与端之间的流量控制。够了么？还不够，它需要更加智能，因此还需要加个拥塞控制，需要为整体网络的情况考虑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是&lt;span&gt;出行你我他，安全靠大家&lt;/span&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;为什么要 TCP，IP 层实现控制不行么？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道网络是分层实现的，网络协议的设计就是为了通信，从链路层到 IP 层其实就已经可以完成通信了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你看链路层不可或缺毕竟咱们电脑都是通过链路相互连接的，然后 IP 充当了地址的功能，所以通过 IP 咱们找到了对方就可以进行通信了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那加个 TCP 层干啥？IP 层实现控制不就完事了嘛？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之所以要&lt;span&gt;提取出一个 TCP 层来实现控制是因为 IP 层涉及到的设备更多&lt;/span&gt;，一条数据在网络上传输需要经过很多设备，而设备之间需要靠 IP 来寻址。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设 IP 层实现了控制，那是不是涉及到的设备都需要关心很多事情？整体传输的效率是不是大打折扣了？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0527426160337552&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3WoFibEeUXMM8oghHkbjedwjAo4zlzm5ymHSWRm3WE9w5rp9YicoQa0keJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;474&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我举个例子，假如 A 要传输给 F 一个积木，但是无法直接传输到，需要经过 B、C、D、E 这几个中转站之手。这里有两种情况：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;假设 BCDE 都需要关心这个积木搭错了没，都拆开包裹仔细的看看，没问题了再装回去，最终到了 F 的手中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;假设 BCDE 都不关心积木的情况，来啥包裹只管转发就完事了，由最终的 F 自己来检查这个积木答错了没。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你觉得哪种效率高？明显是第二种，转发的设备不需要关心这些事，只管转发就完事！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以把控制的逻辑独立出来成 TCP 层，让真正的接收端来处理，这样网络整体的传输效率就高了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;连接到底是什么？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们已经知道了为什么需要独立出 TCP 这一层，并且这一层主要是用来干嘛的，接下来就来看看它到底是怎么干的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道 TCP 是面向连接的，那这个连接到底是个什么东西？真的是拉了一条线让端与端之间连起来了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所谓的连接其实只是双方都维护了一个状态，通过每一次通信来维护状态的变更&lt;/span&gt;，使得看起来好像有一条线关联了对方。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;TCP 协议头&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在具体深入之前我们需要先来看看一些 TCP 头的格式，这很基础也很重要。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8130081300813008&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3WotC8rJxducKgmovDgJBcDDgsGRf0WiabU0eTEDJmz9mRv47QYa23nvUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;369&quot;/&gt;&lt;figcaption&gt;图来自网络&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我就不一一解释了，挑重点的说。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先可以看到 TCP 包只有端口，没有 IP。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Seq 就是 Sequence Number 即序号，它是用来解决乱序问题的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ACK 就是 Acknowledgement Numer 即确认号，它是用来解决丢包情况的，告诉发送方这个包我收到啦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标志位就是 TCP flags 用来标记这个包是什么类型的，用来控制 TPC 的状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;窗口就是滑动窗口，Sliding Window，用来流控。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三次握手&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;明确了协议头的要点之后，我们再来看三次握手。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;三次握手真是个老生常谈的问题了，但是真的懂了么？不是浮在表面？能不能延伸出一些点别的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来看一下熟悉的流程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5629032258064516&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3WoBAbxNgZSCpE74PyCgckpGyKLaFpUgrvpaAFyN4QRy8OSsHMHTa3VyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;图来自网络&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先为什么要握手，&lt;span&gt;其实主要就是为了初始化Seq Numer&lt;/span&gt;，SYN 的全称是 Synchronize Sequence Numbers，这个序号是用来保证之后传输数据的顺序性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你要说是为了测试保证双方发送接收功能都正常，我觉得也没毛病，&lt;span&gt;不过我认为重点在于同步序号&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那为什么要三次，就拿我和你这两个角色来说，首先我告诉你我的初始化序号，你听到了和我说你收到了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后你告诉我你的初始序号，然后我对你说我收到了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这好像四次了？如果真的按一来一回就是四次，但是中间一步可以合在一起，就是你和我说你知道了我的初始序号的时候同时将你的初始序号告诉我。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此四次握手就可以减到三次了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过你没有想过这么一种情形，我和你同时开口，一起告诉对方各自的初始序号，然后分别回应收到了，这不就是四次握手了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我来画个图，清晰一点。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6103646833013435&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3Wo60ILBhTZiaqDAx6GlA8iaAZBn5fscygTmCtXFw8jAD3tj8RaGcicqia7qw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;521&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看看是不是四次握手了? 不过具体还是得看实现，有些实现可能不允许这种情况出现，但是这不影响我们思考，因为&lt;span&gt;握手的重点就是同步初始序列号&lt;/span&gt;，这种情况也完成了同步的目标。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;初始序列号 ISN 的取值&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道大家有没有想过 ISN 的值要设成什么？代码写死从零开始？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想象一下如果写死一个值，比如 0 ，那么假设已经建立好连接了，client 也发了很多包比如已经第 20 个包了，然后网络断了之后 client 重新，端口号还是之前那个，然后序列号又从 0 开始，此时服务端返回第 20 个包的ack，客户端是不是傻了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以 RFC793 中认为 ISN 要和一个假的时钟绑定在一起&lt;span&gt;ISN 每四微秒加一，当超过 2 的 32 次方之后又从 0 开始，要四个半小时左右发生 ISN 回绕&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以 ISN 变成一个递增值，真实的实现还需要加一些随机值在里面，防止被不法份子猜到 ISN。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;SYN 超时了怎么处理？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是 client 发送 SYN 至 server 然后就挂了，此时 server 发送 SYN+ACK 就一直得不到回复，怎么办？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我脑海中一想到的就是重试，但是不能连续快速重试多次，你想一下，假设 client 掉线了，你总得给它点时间恢复吧，所以呢需要&lt;span&gt;慢慢重试，阶梯性重试&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Linux 中就是默认重试 5 次，并且就是阶梯性的重试，间隔就是1s、2s、4s、8s、16s，再第五次发出之后还得等 32s 才能知道这次重试的结果，所以说总共等63s 才能断开连接。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;SYN Flood 攻击&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你看到没 SYN 超时需要耗费服务端 63s 的时间断开连接，也就说 63s 内服务端需要保持这个资源，所以不法分子就可以构造出大量的 client 向 server 发 SYN 但就是不回 server。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6983122362869199&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3WomI7iao6PlT5NwRpJIicRH95kEaK5XgnrgnmpY9gMJvNE8TTLvtMdMhnw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;474&quot;/&gt;&lt;figcaption&gt;图来自网络&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使得 server 的 SYN 队列耗尽，无法处理正常的建连请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以怎么办？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以开启 tcp_syncookies，那就用不到 SYN 队列了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SYN 队列满了之后 TCP 根据自己的 ip、端口、然后对方的 ip、端口，对方 SYN 的序号，时间戳等一波操作生成一个特殊的序号（即 cookie）发回去，如果对方是正常的 client 会把这个序号发回来，然后 server 根据这个序号建连。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;或者调整 tcp_synack_retries 减少重试的次数，设置 tcp_max_syn_backlog 增加 SYN 队列数，设置 tcp_abort_on_overflow SYN 队列满了直接拒绝连接。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;为什么要四次挥手？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;四次挥手和三次握手成双成对，同样也是 TCP 中的一线明星，让我们重温一下熟悉的图。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.43902439024390244&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3Woh6ia91zo0kAoKKm8grBVQeBD78d98g9w4b4oa6HWTCRKK4CMxs6gicrg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;615&quot;/&gt;&lt;figcaption&gt;图来自网络&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么挥手需要四次？&lt;span&gt;因为 TCP 是全双工协议&lt;/span&gt;，也就是说双方都要关闭，每一方都向对方发送 FIN 和回应 ACK。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就像我对你说我数据发完了，然后你回复好的你收到了。然后你对我说你数据发完了，然后我向你回复我收到了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以看起来就是四次。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图中可以看到主动关闭方的状态是 FIN_WAIT_1 到 FIN_WAIT_2 然后再到 TIME_WAIT，而被动关闭方是 CLOSE_WAIT 到 LAST_ACK。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;四次挥手状态一定是这样变迁的吗&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;状态一定是这样变迁的吗？让我们再来看个图。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7897897897897898&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3WoFjVCKRI3KYFb0KPUReW1l8MZ2msibxYRIub9YTyX4KU3c73ibAPW6ibsA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;666&quot;/&gt;&lt;figcaption&gt;图来自网络&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到双方都主动发起断开请求所以各自都是主动发起方，状态会从 FIN_WAIT_1 都进入到 CLOSING 这个过度状态然后再到 TIME_WAIT。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;挥手一定需要四次吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设 client 已经没有数据发送给 server 了，所以它发送 FIN 给 server 表明自己数据发完了，不再发了，如果这时候 server 还是有数据要发送给 client 那么它就是先回复 ack ，然后继续发送数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;等 server 数据发送完了之后再向 client 发送 FIN 表明它也发完了，然后等 client 的 ACK 这种情况下就会有四次挥手。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么假设 client 发送 FIN 给 server 的时候 server 也没数据给 client，那么 server 就可以将 ACK 和它的 FIN 一起发给client ，然后等待 client 的 ACK，这样不就三次挥手了？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;为什么要有 TIME_WAIT?&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;断开连接发起方在接受到接受方的 FIN 并回复 ACK 之后并没有直接进入 CLOSED 状态，而是进行了一波等待，等待时间为 2MSL。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MSL 是 Maximum Segment Lifetime，即报文最长生存时间，RFC 793 定义的 MSL 时间是 2 分钟，Linux 实际实现是 30s，那么 2MSL 是一分钟。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么为什么要等 2MSL 呢？&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;就是怕被动关闭方没有收到最后的 ACK，如果被动方由于网络原因没有到，那么它会再次发送 FIN， 此时如果主动关闭方已经 CLOSED 那就傻了，因此等一会儿。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;假设立马断开连接，但是又重用了这个连接，就是五元组完全一致，并且序号还在合适的范围内，虽然概率很低但理论上也有可能，那么新的连接会被已关闭连接链路上的一些残留数据干扰，因此给予一定的时间来处理一些残留数据。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;等待 2MSL 会产生什么问题？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果服务器主动关闭大量的连接，那么会出现大量的资源占用，需要等到 2MSL 才会释放资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是客户端主动关闭大量的连接，那么在 2MSL 里面那些端口都是被占用的，端口只有 65535 个，如果端口耗尽了就无法发起送的连接了，不过我觉得这个概率很低，这么多端口你这是要建立多少个连接？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;如何解决 2MSL 产生的问题？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;快速回收&lt;/span&gt;，即不等 2MSL 就回收， Linux 的参数是 tcp_tw_recycle，还有 tcp_timestamps 不过默认是打开的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实上面我们已经分析过为什么需要等 2MSL，所以如果等待时间果断就是出现上面说的那些问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以不建议开启，而且 Linux 4.12 版本后已经咔擦了这个参数了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前不久刚有位朋友在群里就提到了这玩意。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.48007414272474513&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3WoVbOVyBfowGJZSoHI3mwtzcxbmuBkj3jIoCR5l9gv4l9IQXzPQm7ugA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1079&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一问果然有 NAT 的身影。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现象就是请求端请求服务器的静态资源偶尔会出现 20-60 秒左右才会有响应的情况，从抓包看请求端连续三个 SYN 都没有回应。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如你在学校，对外可能就一个公网 IP，然后开启了 tcp_tw_recycle（tcp_timestamps 也是打开的情况下），在 60 秒内对于同源 IP 的连接请求中 timestamp 必须是递增的，不然认为其是过期的数据包就会丢弃。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;学校这么多机器，你无法保证时间戳是一致的，因此就会出问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以这玩意不推荐使用。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3WoE8V7lW2ynFgEnibX5IvFBSsTuY5UKXqe7TcfT2hsiaDaC2XLngAOBxfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;720&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;重用&lt;/span&gt;，即开启 tcp_tw_reuse 当然也是需要 tcp_timestamps 的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有个重点，&lt;span&gt;tcp_tw_reuse 是用在连接发起方的，而我们的服务端基本上是连接被动接收方&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;tcp_tw_reuse 是发起新连接的时候，可以复用超过 1s 的处于 TIME_WAIT 状态的连接，所以它压根没有减少我们服务端的压力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;它重用的是发起方处于 TIME_WAIT 的连接&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里还有一个 SO_REUSEADDR ，这玩意有人会和 tcp_tw_reuse 混为一谈，首先 tcp_tw_reuse 是内核选项而 SO_REUSEADDR 是用户态选项。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后 SO_REUSEADDR 主要用在你启动服务的时候，如果此时的端口被占用了并且这个连接处于 TIME_WAIT 状态，那么你可以重用这个端口，如果不是 TIME_WAIT，那就是给你个 Address already in use。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以这两个玩意好像都不行，而且 tcp_tw_reuse 和tcp_tw_recycle，其实是违反 TCP 协议的，说好的等我到天荒地老，你却偷偷放了手？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.1333333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3WoJ3Fkmian3UwwacQhqwKQLR1xVf2WSu9g0cDjWCK6G7stc3XSL4bqodQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;240&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要么就是调小 MSL 的时间，不过也不太安全，要么调整 tcp_max_tw_buckets 控制 TIME_WAIT 的数量，不过默认值已经很大了 180000，这玩意应该是用来对抗 DDos 攻击的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我给出的建议是&lt;span&gt;服务端不要主动关闭，把主动关闭方放到客户端&lt;/span&gt;。毕竟咱们服务器是一对很多很多服务，我们的资源比较宝贵。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;自己攻击自己&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一个很骚的解决方案，我自己瞎想的，就是自己攻击自己。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Socket 有一个选项叫 IP_TRANSPARENT ，可以绑定一个非本地的地址，然后服务端把建连的 ip 和端口都记下来，比如写入本地某个地方。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后启动一个服务，假如现在服务端资源很紧俏，那么你就定个时间，过了多久之后就将处于 TIME_WAIT 状态的对方 ip 和端口告诉这个服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后这个服务就利用 IP_TRANSPARENT 伪装成之前的那个 client 向服务端发起一个请求，然后服务端收到会给真的 client 一个 ACK， 那 client 都关了已经，说你在搞啥子，于是回了一个 RST，然后服务端就中止了这个连接。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3WoNP85d4y3CP2ZcJumABnBIXCaCuzgDb0aia6icUDPj3668XcY5mf89djA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;超时重传机制是为了解决什么问题？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面我们提到 TCP 要提供可靠的传输，那么网络又是不稳定的如果传输的包对方没收到却又得保证可靠那么就必须重传。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCP 的可靠性是靠确认号的，比如我发给你1、2、3、4这4个包，你告诉我你现在要 5 那说明前面四个包你都收到了，就是这么回事儿。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过这里要注意，SeqNum 和 ACK 都是&lt;span&gt;以字节数为单位的&lt;/span&gt;，也就是说假设你收到了1、2、4 但是 3 没有收到你不能 ACK 5，如果你回了 5 那么发送方就以为你5之前的都收到了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以&lt;span&gt;只能回复确认最大连续收到包&lt;/span&gt;，也就是 3。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而发送方不清楚 3、4 这两个包到底是还没到呢还是已经丢了，于是发送方需要等待，这等待的时间就比较讲究了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果太心急可能 ACK 已经在路上了，你这重传就是浪费资源了，如果太散漫，那么接收方急死了，这死鬼怎么还不发包来，我等的花儿都谢了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以这个等待超时重传的时间很关键，怎么搞？聪明的小伙伴可能一下就想到了，你估摸着正常来回一趟时间是多少不就好了，我就等这么长。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就来回一趟的时间就叫 RTT，即 Round Trip Time，然后根据这个时间制定超时重传的时间 RTO，即 Retransmission Timeout。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过这里大概只好了 RTO 要参考下 RTT ，但是具体要怎么算？首先肯定是采样，然后一波加权平均得到 RTO。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RFC793 定义的公式如下：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;1、先采样 RTT
2、SRTT = ( ALPHA * SRTT ) + ((1-ALPHA) * RTT)
3、RTO = min[UBOUND,max[LBOUND,(BETA*SRTT)]]&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ALPHA 是一个平滑因子取值在 0.8~0.9之间，UBOUND 就是超时时间上界-1分钟，LBOUND 是下界-1秒钟，BETA 是一个延迟方差因子，取值在 1.3~2.0。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是还有个问题，RTT 采样的时间用一开始发送数据的时间到收到 ACK 的时间作为样本值还是重传的时间到 ACK 的时间作为样本值？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.44563758389261743&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3WoOSQzGrAHoqsPG5YoTDslkIDZ67icC174z0Y4ic3CUER052OWedseHEEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;745&quot;/&gt;&lt;figcaption&gt;图来自网络&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图中就可以看到，一个时间算长了，一个时间算短了，这有点难，因为你不知道这个  ACK 到底是回复谁的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以怎么办？&lt;span&gt;发生重传的来回我不采样不就好了&lt;/span&gt;，我不知道这次 ACK 到底是回复谁的，我就不管他，我就采样正常的来回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是 Karn / Partridge 算法，不采样重传的RTT。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是不采样重传会有问题，比如某一时刻网络突然就是很差，你要是不管重传，那么还是按照正常的 RTT 来算 RTO， 那么超时的时间就过短了，于是在网络很差的情况下还疯狂重传加重了网络的负载。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此 Karn 算法就很粗暴的搞了个发生重传我就将现在的 RTO 翻倍，哼！就是这么简单粗暴。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3WoicyHpaEcpicmvwcD3h21d9jRpNB3v3MhsBibhWOOERwTrW4mnib4Zpx1xA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;255&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这种平均的计算很容易把一个突然间的大波动，平滑掉，所以又搞了个算法，叫 Jacobson / Karels Algorithm。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它把最新的 RTT 和平滑过的 SRTT 做了波计算得到合适的 RTO，公式我就不贴了，反正我不懂，不懂就不哔哔了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;为什么还需要快速重传机制？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;超时重传是按时间来驱动的，如果是网络状况真的不好的情况，超时重传没问题，但是如果网络状况好的时候，只是恰巧丢包了，那等这么长时间就没必要。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是又引入了数据驱动的重传叫快速重传，什么意思呢？就是发送方如果连续三次收到对方相同的确认号，那么马上重传数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为连续收到三次相同 ACK 证明当前网络状况是 ok 的，那么确认是丢包了，于是立马重发，没必要等这么久。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6466666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3WoSmvbyBEQJcO4b3zaTl71PZA1nxK30DppqZvYdYzEwZe1w5waku43hg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;450&quot;/&gt;&lt;figcaption&gt;图来自网络&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看起来好像挺完美的，但是你有没有想过我发送1、2、3、4这4个包，就 2 对方没收到，1、3、4都收到了，然后不管是超时重传还是快速重传反正对方就回 ACK 2。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候要重传 2、3、4 呢还是就 2 呢？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;SACK 的引入是为了解决什么问题？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SACK 即 Selective Acknowledgment，它的引入就是为了解决发送方不知道该重传哪些数据的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看一下下面的图就知道了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3Woaa9JU7r5iaUH5bLXq2s2JhBkjrEic1RZCDAibCEaDqB7MU1tO7t4ekJrg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;figcaption&gt;图来自网络&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SACK 就是接收方会回传它已经接受到的数据，这样发送方就知道哪一些数据对方已经收到了，所以就可以选择性的发送丢失的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图，通过 ACK 告知我接下来要 5500 开始的数据，并一直更新 SACK，6000-6500 我收到了，6000-7000的数据我收到了，6000-7500的数据我收到了，发送方很明确的知道，5500-5999 的那一波数据应该是丢了，于是重传。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且如果数据是多段不连续的， SACK 也可以发送，比如 SACK 0-500,1000-1500，2000-2500。就表明这几段已经收到了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;D-SACK 又是什么东西？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;D-SACK 其实是 SACK 的扩展，它利用 SACK 的第一段来描述重复接受的不连续的数据序号，如果第一段描述的范围被 ACK 覆盖，说明重复了，比如我都 ACK 到6000了你还给我回 SACK 5000-5500 呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说白了就是从第一段的反馈来和已经接受到的 ACK 比一比，参数是 tcp_dsack，Linux 2.4 之后默认开启。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那知道重复了有什么用呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、知道重复了说明对方收到刚才那个包了，所以是回来的 ACK 包丢了。2、是不是包乱序的，先发的包后到？3、是不是自己太着急了，RTO 太小了？4、是不是被数据复制了，抢先一步呢？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;滑动窗口干嘛用？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们已经知道了 TCP 有序号，并且还有重传，但是这还不够，因为我们不是愣头青，还需要根据情况来控制一下发送速率，因为网络是复杂多变的，有时候就会阻塞住，而有时候又很通畅。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以发送方需要知道接收方的情况，好控制一下发送的速率，不至于蒙着头一个劲儿的发然后接受方都接受不过来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此 TCP 就有个叫滑动窗口的东西来做流量控制，也就是接收方告诉发送方我还能接受多少数据，然后发送方就可以根据这个信息来进行数据的发送。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下是&lt;span&gt;发送方维护的窗口&lt;/span&gt;，就是黑色圈起来的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4090909090909091&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3WoNSsZclruxoCbllRg8lMKRkr3Lmc5CtzDcuKjicv2U81ibicuFS5KL3eGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;660&quot;/&gt;&lt;figcaption&gt;图来自网络&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图中的 #1 是已收到 ACK 的数据，#2 是已经发出去但是还没收到 ACK 的数据，#3 就是在窗口内可以发送但是还没发送的数据。#4 就是还不能发送的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后此时收到了 36 的 ACK，并且发出了 46-51 的字节，于是窗口向右滑动了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3181818181818182&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3WodrthnVRfouI4U8ViaCL9lqBwiboIQI5f9jC9Rf6PgswPCBjasJITgMCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;660&quot;/&gt;&lt;figcaption&gt;图片来自网络&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCP/IP Guide 上还有一张完整的图，画的十分清晰，大家看一下。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.2552552552552552&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3WoNAWqUEzJl8z8tVhJELibN8k5ic6gc2E7Uzaqeh51t6W9jCr6NsqgAbfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;666&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;如果接收方回复的窗口一直是 0 怎么办？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上文已经说了发送方式根据接收方回应的 window 来控制能发多少数据，如果接收方一直回应 0，那发送方就杵着？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你想一下，发送方发的数据都得到 ACK 了，但是呢回应的窗口都是 0 ，这发送方此时不敢发了啊，那也不能一直等着啊，这 Window 啥时候不变 0 啊？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是 TCP 有一个 Zero Window Probe 技术，发送方得知窗口是 0 之后，会去探测探测这个接收方到底行不行，也就是发送 ZWP 包给接收方。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体看实现了，可以发送多次，然后还有间隔时间，多次之后都不行可以直接 RST。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;假设接收方每次回应窗口都很小怎么办？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你想象一下，如果每次接收方都说我还能收 1 个字节，发送方该不该发？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCP + IP 头部就 40 个字节了，这传输不划算啊，如果傻傻的一直发这就叫 Silly Window。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那咋办，一想就是发送端等着，等养肥了再发，要么接收端自己自觉点，数据小于一个阈值就告诉发送端窗口此时是 0 算了，也等养肥了再告诉发送端。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发送端等着的方案就是纳格算法，这个算法相信看一下代码就知道了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3745019920318725&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3WoFcVQjDWNXZhB3PQdYZRz76Lp3pjicFAjXhSOBNgLiaWQwPcViaPHU4DrA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;753&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单的说就是当前能发送的数据和窗口大于等于 MSS 就立即发送，否则再判断一下之前发送的包 ACK 回来没，回来再发，不然就攒数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接收端自觉点的方案是 David D Clark’s 方案，如果窗口数据小于某个阈值就告诉发送方窗口 0 别发，等缓过来数据大于等于 MSS 或者接受 buffer 腾出一半空间了再设置正常的 window 值给发送方。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对了提到纳格算法不得不再提一下延迟确认，纳格算法在等待接收方的确认，而开启延迟确认则会延迟发送确认，会等之后的包收到了再一起确认或者等待一段时候真的没了再回复确认。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就相互等待了，然后延迟就很大了，两个不可同时开启。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;已经有滑动窗口了为什么还要拥塞控制？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面我已经提到了，加了拥塞控制是因为 TCP 不仅仅就管两端之间的情况，还需要知晓一下整体的网络情形，毕竟只有大家都守规矩了道路才会通畅。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面我们提到了重传，如果不管网络整体的情况，肯定就是对方没给 ACK ，那我就无脑重传。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果此时网络状况很差，所有的连接都这样无脑重传，是不是网络情况就更差了，更加拥堵了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后越拥堵越重传，一直冲冲冲！然后就 GG 了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.74&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3WoPG6iaCX4gdzfRcfqqgfVX2aR9bvrTOK1oWMe0VkOOiaLUkt1RxS0NMLQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;400&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以需要个拥塞控制，来避免这种情况的发送。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;拥塞控制怎么搞？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要有以下几个步骤来搞：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、慢启动，探探路。2、拥塞避免，感觉差不多了减速看看
3、拥塞发生快速重传/恢复&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5316642120765832&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3WoMnoDxDMyia49rX7kt1D3BM267MG3qXSqxHFGy9MfMcQMdYmhd5Z5Dtg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;679&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;慢启动，就是新司机上路慢慢来，初始化 cwnd（Congestion Window）为 1，然后每收到一个 ACK 就 cwnd++ 并且每过一个 RTT ，cwnd = 2*cwnd 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线性中带着指数，指数中又夹杂着线性增。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后到了一个阈值，也就是 ssthresh（slow start threshold）的时候就进入了拥塞避免阶段。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个阶段是每收到一个 ACK 就 cwnd = cwnd + 1/cwnd并且每一个 RTT 就 cwnd++。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到都是线性增。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后就是一直增，直到开始丢包的情况发生，前面已经分析到重传有两种，一种是超时重传，一种是快速重传。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果发生超时重传的时候，那说明情况有点糟糕，于是直接把 ssthresh 置为当前 cwnd 的一半，然后 cwnd 直接变为 1，进入慢启动阶段。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3Wom2icNGibxk7Fria6KJyWEaSNibgKIASFIhnxqqK6OhJIpV7xxhfeVwugicQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;225&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是快速重传，那么这里有两种实现，一种是 TCP Tahoe ，和超时重传一样的处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一种是 TCP Reno，这个实现是把 cwnd = cwnd/2 ，然后把 ssthresh 设置为当前的 cwnd 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后进入快速恢复阶段，将 cwnd = cwnd + 3（因为快速重传有三次），&lt;span&gt;重传 DACK 指定的包&lt;/span&gt;，如果再收到一个DACK则 cwnd++，如果收到是正常的 ACK 那么就将 cwnd 设为 ssthresh 大小，进入拥塞避免阶段。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到快速恢复就重传了指定的一个包，那有可能是很多包都丢了，然后其他的包只能等待超时重传，超时重传就会导致 cwnd 减半，多次触发就指数级下降。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以又搞了个 New Reno，多加了个 New，它是在没有SACK 的情况下改进快速恢复，它会观察重传 DACK 指定的包的响应 ACK 是否是已经发送的最大 ACK，比如你发了1、2、3、4，对方没收到 2，但是 3、4都收到了，于是你重传 2 之后 ACK 肯定是 5，说明就丢了这一个包。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不然就是还有其他包丢了，如果就丢了一个包就是之前的过程一样，如果还有其他包丢了就继续重传，直到 ACK 是全部的之后再退出快速恢复阶段。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单的说就是一直探测到全部包都收到了再结束这个环节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有个 FACK，它是基于 SACK 用来作为重传过程中的拥塞控制，相对于上面的 New Reno 我们就知道它有 SACK 所以不需要一个一个试过去，具体我不展开了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;还有哪些拥塞控制算法？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从维基上看有这么多。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9972451790633609&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3Wo3OYibLU4Qj5Lj8QSOx3bkDScGaxKzW1M7pQ8UUfcfpNdxBl5Yj8gN6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;363&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本来我还想哔哔几句了，哔哔了之后又删了，感觉说了和没说一样，&lt;span&gt;想深入但是实力不允许&lt;/span&gt;，有点惆怅啊。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;各位看官自个儿查查吧，或者等我日后修炼有成再来哔哔。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说了这么多来总结一下吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCP 是面向连接的，提供可靠、有序的传输并且还提供流控和拥塞控制，单独提取出 TCP 层而不是在 IP层实现是因为 IP 层有更多的设备需要使用，加了复杂的逻辑不划算。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;三次握手主要是为了定义初始序列号为了之后的传输打下基础，四次挥手是因为 TCP 是全双工协议，因此双方都得说拜拜。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SYN 超时了就阶梯性重试，如果有 SYN攻击，可以加大半队列数，或减少重试次数，或直接拒绝。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TIME_WAIT 是怕对方没收到最后一个 ACK，然后又发了 FIN 过来，并且也是等待处理网络上残留的数据，怕影响新连接。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3WoKnL07ym9A1ribRGibMhZxiazzwvrU1IJ93KLQjxA8YhXMibAmCr9fnfV1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TIME_WAIT 不建议设小，或者破坏 TIME_WAIT 机制，如果真想那么可以开启快速回收，或者重用，不过注意受益的对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;超时重传是为了保证对端一定能收到包，快速重传是为了避免在偶尔丢包的时候需要等待超时这么长时间，SACK 是为了让发送方知道重传哪些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;D-SACK 是为了让发送方知道这次重传的原因是对方真的没收到还是自己太心急了 RTO 整小了，不至于两眼一抹黑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;滑动窗口是为了平衡发送方的发送速率和接收方的接受数率，不至于瞎发，当然还需要注意 Silly Window 的情况，同时还要注意纳格算法和延迟确认不能一起搭配。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而滑动窗口还不够，还得有个拥塞控制，因为&lt;span&gt;出行你我他，安全靠大家&lt;/span&gt;，TCP 还得跳出来看看关心下当前大局势。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最后&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此就差不多了，不过还是有很多很多细节的，TCP 协议太复杂了，这可能是我文章里面图画的最少的一篇了，你看复杂到我图都画不来了哈哈哈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天我就说了个皮毛，如有纰漏请赶紧后台联系鞭挞我。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8OxKoZp2WX3FqUGWqPC3WoSuzOZut05TVKS71AaKl5N4jSBI21MFFKKPlt9JrsPMQzSwE77zic3Og/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;240&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;巨人的肩膀&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;http://www.tcpipguide.com/&lt;/em&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;https://www.ionos.com/digitalguide/server/know-how/introduction-to-tcp/&lt;/em&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;https://www.ibm.com/developerworks/cn/linux/l-tcp-sack/&lt;/em&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;https://coolshell.cn/articles/11564.html/&lt;/em&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;https://tools.ietf.org/html/rfc793&lt;/em&gt;&lt;em&gt;https://nmap.org/book/tcpip-ref.html&lt;/em&gt;&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我是 yes，从一点点到亿点点，我们下篇见&lt;/span&gt;。&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5575f83a780fc61346036fff952e5a72</guid>
<title>[推荐] Go 如何实现热重启</title>
<link>https://toutiao.io/k/cxttrqv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：zhijiezhang，腾讯 PCG 后台开发工程师&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近在优化公司框架 trpc 时发现了一个热重启相关的问题，优化之余也总结沉淀下，对 go 如何实现热重启这方面的内容做一个简单的梳理。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.什么是热重启？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;热重启（Hot Restart），是一项保证服务可用性的手段。它允许服务重启期间，不中断已经建立的连接，老服务进程不再接受新连接请求，新连接请求将在新服务进程中受理。对于原服务进程中已经建立的连接，也可以将其设为读关闭，等待平滑处理完连接上的请求及连接空闲后再行退出。通过这种方式，可以保证已建立的连接不中断，连接上的事务（请求、处理、响应）可以正常完成，新的服务进程也可以正常接受连接、处理连接上的请求。当然，热重启期间进程平滑退出涉及到的不止是连接上的事务，也有消息服务、自定义事务需要关注。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是我理解的热重启的一个大致描述。热重启现在还有没有存在的必要？我的理解是看场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以后台开发为例，假如运维平台有能力在服务升级、重启时自动踢掉流量，服务就绪后又自动加回流量，假如能够合理预估服务 QPS、请求处理时长，那么只要配置一个合理的停止前等待时间，是可以达到类似热重启的效果的。这样的话，在后台服务里面支持热重启就显得没什么必要。但是，如果我们开发一个微服务框架，不能对将来的部署平台、环境做这种假设，也有可能使用方只是部署在一两台物理机上，也没有其他的负载均衡设施，但不希望因为重启受干扰，热重启就很有必要。当然还有一些更复杂、要求更苛刻的场景，也需要热重启的能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;热重启是比较重要的一项保证服务质量的手段，还是值得了解下的，这也是本文介绍的初衷。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.如何实现热重启？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何实现热重启，这里其实不能一概而论，要结合实际的场景来看（比如服务编程模型、对可用性要求的高低等）。大致的实现思路，可以先抛一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般要实现热重启，大致要包括如下步骤：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先，要让老进程，这里称之为父进程了，先要 fork 出一个子进程来代替它工作；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;然后，子进程就绪之后，通知父进程，正常接受新连接请求、处理连接上收到的请求；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;再然后，父进程处理完已建立连接上的请求后、连接空闲后，平滑退出。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;听上去是挺简单的...&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1.认识 fork&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家都知道&lt;code&gt;fork()&lt;/code&gt; 系统调用，父进程调用 fork 会创建一个进程副本，代码中还可以通过 fork 返回值是否为 0 来区分是子进程还是父进程。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;span&gt;char&lt;/span&gt; **argv, &lt;span&gt;int&lt;/span&gt; argc)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;pid_t&lt;/span&gt; pid = fork();&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (pid == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;i am child process&quot;&lt;/span&gt;);&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;i am parent process, i have a child process named %d&quot;&lt;/span&gt;, pid);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能有些开发人员不知道 fork 的实现原理，或者不知道 fork 返回值为什么在父子进程中不同，或者不知道如何做到父子进程中返回值不同……了解这些是要有点知识积累的。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2.返回值&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单概括下，ABI 定义了进行函数调用时的一些规范，如何传递参数，如何返回值等等，以 x86 为例，如果返回值是 rax 寄存器能够容的一般都是通过 rax 寄存器返回的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果 rax 寄存器位宽无法容纳下的返回值呢？也简单，编译器会安插些指令来完成这些神秘的操作，具体是什么指令，就跟语言编译器实现相关了。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;c 语言，可能会将返回值的地址，传递到 rdi 或其他寄存器，被调函数内部呢，通过多条指令将返回值写入 rdi 代指的内存区；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;c 语言，也可能在被调函数内部，用多个寄存器 rax,rdx...一起暂存返回结果，函数返回时再将多个寄存器的值赋值到变量中；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;也可能会像 golang 这样，通过栈内存来返回；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.3.fork 返回值&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;fork 系统调用的返回值，有点特殊，在父进程和子进程中，这个函数返回的值是不同的，如何做到的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;联想下父进程调用 fork 的时候，操作系统内核需要干些什么呢？分配进程控制块、分配 pid、分配内存空间……肯定有很多东西啦，这里注意下进程的硬件上下文信息，这些是非常重要的，在进程被调度算法选中进行调度时，是需要还原硬件上下文信息的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Linux fork 的时候，会对子进程的硬件上下文进行一定的修改，我就是让你 fork 之后拿到的 pid 是 0，怎么办呢？前面 2.2 节提过了，对于那些小整数，rax 寄存器存下绰绰有余，fork 返回时就是将操作系统分配的 pid 放到 rax 寄存器的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那，对于子进程而言，我只要在 fork 的时候将它的硬件上下文 rax 寄存器清 0，然后等其他设置全 ok 后，再将其状态从不可中断等待状态修改为可运行状态，等其被调度器调度时，会先还原其硬件上下文信息，包括 PC、rax 等等，这样 fork 返回后，rax 中值为 0，最终赋值给 pid 的值就是 0。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，也就可以通过这种判断 “pid 是否等于 0” 的方式来区分当前进程是父进程还是子进程了。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.4.局限性&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多人清楚 fork 可以创建一个进程的副本并继续往下执行，可以根据 fork 返回值来执行不同的分支逻辑。如果进程是多线程的，在一个线程中调用 fork 会复制整个进程吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;fork 只能创建调用该函数的线程的副本，进程中其他运行的线程，fork 不予处理。这就意味着，对于多线程程序而言，寄希望于通过 fork 来创建一个完整进程副本是不可行的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面我们也提到了，fork 是实现热重启的重要一环，fork 这里的这个局限性，就制约着不同服务编程模型下的热重启实现方式。所以我们说具体问题具体分析，不同编程模型下实际上可以采用不同的实现方式。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.单进程单线程模型&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单进程单线程模型，可能很多人一听觉得它已经被淘汰了，生产环境中不能用，真的么？强如 redis，不就是单线程。强调下并非单线程模型没用，ok，收回来，现在关注下单进程单线程模型如何实现热重启。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单进程单线程，实现热重启会比较简单些:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;fork 一下就可以创建出子进程，&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;子进程可以继承父进程中的资源，如已经打开的文件描述符，包括父进程的 listenfd、connfd，&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;父进程，可以选择关闭 listenfd，后续接受连接的任务就交给子进程来完成了，&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;父进程，甚至也可以关闭 connfd，让子进程处理连接上的请求、回包等，也可以自身处理完已建立的连接上的请求；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;父进程，在合适的时间点选择退出，子进程开始变成顶梁柱。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;核心思想就是这些，但是具体到实现，就有多种方法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;可以选择 fork 的方式让子进程拿到原来的 listenfd、connfd，&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;也可以选择 unixdomain socket 的方式父进程将 listenfd、connfd 发送给子进程。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有同学可能会想，我不传递这些 fd 行吗？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;比如我开启了 reuseport，父进程直接处理完已建立连接 connfd 上的请求之后关闭，子进程里 reuseport.Listen 直接创建新的 listenfd。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也可以！但是有些问题必须要提前考虑到：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;reuseport 虽然允许多个进程在同一个端口上多次 listen，似乎满足了要求，但是要知道只要 euid 相同，都可以在这个端口上 listen！是不安全的！&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;reuseport 实现和平台有关系，在 Linux 平台上在同一个 address+port 上 listen 多次，多个 listenfd 底层可以共享同一个连接队列，内核可以实现负载均衡，但是在 darwin 平台上却不会！&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然这里提到的这些问题，在多线程模型下肯定也存在。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.单进程多线程模型&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面提到的问题，在多线程模型中也会出现：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;fork 只能复制 calling thread，not whole process！&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;reuseport 多次在相同地址+端口 listen 得到的多个 fd，不同平台有不同的表现，可能无法做到接受连接时的 load banlance！&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;非 reuseport 情况下，多次 listen 会失败！&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不传递 fd，直接通过 reuseport 来重新 listen 得到 listenfd，不安全，不同服务进程实例可能会在同一个端口上监听，gg！&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;父进程平滑退出的逻辑，关闭 listenfd，等待 connfd 上请求处理结束，关闭 connfd，一切妥当后，父进程退出，子进程挑大梁！&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. 其他线程模型&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其他线程都基本上避不开上述 3、4 的实现或者组合，对应问题相仿，不再赘述。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. go 实现热重启：触发时机&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要选择一个时机来触发热重启，什么时候触发呢？操作系统提供了信号机制，允许进程做出一些自定义的信号处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;杀死一个进程，一般会通过&lt;code&gt;kill -9&lt;/code&gt;发送 SIGKILL 信号给进程，这个信号不允许捕获，SIGABORT 也不允许捕获，这样可以允许进程所有者或者高权限用户控制进程生死，达到更好的管理效果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;kill 也可以用来发送其他信号给进程，如发送 SIGUSR1、SIGUSR2、SIGINT 等等，进程中可以接收这些信号，并针对性的做出处理。这里可以选择 SIGUSR1 或者 SIGUSR2 来通知进程热重启。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    ch := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; os.Signal, &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;    signal.Notify(ch, os.SIGUSR2)&lt;br/&gt;    &amp;lt;- ch&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//接下来就可以做热重启相关的逻辑了&lt;/span&gt;&lt;br/&gt;    ...&lt;br/&gt;}()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7. 如何判断热重启&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那一个 go 程序重新启动之后，所有运行时状态信息都是新的，那如何区分自己是否是子进程呢，或者说我是否要执行热重启逻辑呢？父进程可以通过设置子进程初始化时的环境变量，比如加个 HOT_RESTART=1。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就要求代码中在合适的地方要先检测环境变量 HOT_RESTART 是否为 1，如果成立，那就执行热重启逻辑，否则就执行全新的启动逻辑。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8. ForkExec&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如当前进程收到 SIGUSR2 信号之后，希望执行热重启逻辑，那么好，需要先执行 syscall.ForkExec(...)来创建一个子进程，注意 go 不同于 cc++，它本身就是依赖多线程来调度协程的，天然就是多线程程序，只不过是他没有使用 NPTL 线程库来创建，而是通过 clone 系统调用来创建。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面提过了，如果单纯 fork 的话，只能复制调用 fork 函数的线程，对于进程中的其他线程无能为力，所以对于 go 这种天然的多线程程序，必须从头来一遍，再 exec 一下。所以 go 标准库提供的函数是 syscall.ForkExec 而不是 syscall.Fork。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9. go 实现热重启: 传递 listenfd&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;go 里面传递 fd 的方式，有这么几种，父进程 fork 子进程的时候传递 fd，或者后面通过 unix domain socket 传递。需要注意的是，我们传递的实际上是 file description，而非 file descriptor。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;附上一张类 unix 系统下 file descriptor、file description、inode 三者之间的关系图：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8111111111111111&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvav1C1dASM293M0xYPjgzlJTqia7g6alczy5rR05QBicvutuEvDWYgQJvdibglO0lx4CmibCbXbZeb28Ow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;fd 分配都是从小到大分配的，父进程中的 fd 为 10，传递到子进程中之后有可能就不是 10。那么传递到子进程的 fd 是否是可以预测的呢？可以预测，但是不建议。所以我提供了两种实现方式。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9.1 ForkExec+ProcAttr{Files: []uintptr{}}&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要传递一个 listenfd 很简单，假如是类型 net.Listener，那就通过&lt;code&gt;tcpln := ln.(*net.TCPListener); file, _ := tcpln.File(); fd := file.FD()&lt;/code&gt; 来拿到 listener 底层 file description 对应的 fd。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是，这里的 fd 并非底层的 file description 对应的初始 fd，而是被 dup2 复制出来的一个 fd（调用 tcpln.File()的时候就已经分配了），这样底层 file description 引用计数就会+1。如果后面想通过 ln.Close()关闭监听套接字的话，sorry，关不掉。这里需要显示的执行 file.Close() 将新创建的 fd 关掉，使对应的 file description 引用计数-1，保证 Close 的时候引用计数为 0，才可以正常关闭。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;试想下，我们想实现热重启，是一定要等连接上接收的请求处理完才可以退出进程的，但是这期间父进程不能再接收新的连接请求，如果这里不能正常关闭 listener，那我们这个目标就无法实现。所以这里对 dup 出来的 fd 的处理要慎重些，不要遗忘。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;OK，接下来说下 syscall.ProcAttr{Files: []uintptr{}}，这里就是要传递的父进程中的 fd，比如要传递 stdin、stdout、stderr 给子进程，就需要将这几个对应的 fd 塞进去 os.Stdin.FD(), os.Stdout.FD(), os.Stderr.FD()，如果要想传递刚才的 listenfd，就需要将上面的&lt;code&gt;file.FD()&lt;/code&gt;返回的 fd 塞进去。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;子进程中接收到这些 fd 之后，在类 unix 系统下一般会按照从 0、1、2、3 这样递增的顺序来分配 fd，那么传递过去的 fd 是可以预测的，假如除了 stdin, stdout, stderr 再传两个 listenfd，那么可以预测这两个的 fd 应该是 3，4。在类 unix 系统下一般都是这么处理的，子进程中就可以根据传递 fd 的数量（比如通过环境变量传递给子进程 FD_NUM=2），来从 3 开始计算，哦，这两个 fd 应该是 3，4。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;父子进程可以通过一个约定的顺序，来组织传递的 listenfd 的顺序，以方便子进程中按相同的约定进行处理，当然也可以通过 fd 重建 listener 之后来判断对应的监听 network+address，以区分该 listener 对应的是哪一个逻辑 service。都是可以的！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是，file.FD()返回的 fd 是非阻塞的，会影响到底层的 file description，在重建 listener 先将其设为 nonblock, syscall.SetNonBlock(fd)，然后&lt;code&gt;file, _ := os.NewFile(fd); tcplistener := net.FileListener(file)&lt;/code&gt;，或者是 &lt;code&gt;udpconn := net.PacketConn(file)&lt;/code&gt;，然后可以获取 tcplistener、udpconn 的监听地址，来关联其对应的逻辑 service。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;前面提到 file.FD()会将底层的 file description 设置为阻塞模式，这里再补充下，net.FileListener(f), net.PacketConn(f)内部会调用 newFileFd()-&amp;gt;dupSocket()，这几个函数内部会将 fd 对应的 file description 重新设置为非阻塞。父子进程中共享了 listener 对应的 file description，所以不需要显示设置为非阻塞。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些微服务框架是支持对服务进行逻辑 service 分组的，google pb 规范中也支持多 service 定义，这个在腾讯的 goneat、trpc 框架中也是有支持的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然了，这里我不会写一个完整的包含上述所有描述的 demo 给大家，这有点占篇幅，这里只贴一个精简版的实例，其他的读者感兴趣可以自己编码测试。须知纸上得来终觉浅，还是要多实践。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;io/ioutil&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;net&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;strconv&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;sync&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;syscall&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; envRestart = &lt;span&gt;&quot;RESTART&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; envListenFD = &lt;span&gt;&quot;LISTENFD&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt; v := os.Getenv(envRestart)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; v != &lt;span&gt;&quot;1&quot;&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;  ln, err := net.Listen(&lt;span&gt;&quot;tcp&quot;&lt;/span&gt;, &lt;span&gt;&quot;localhost:8888&quot;&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;panic&lt;/span&gt;(err)&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  wg := sync.WaitGroup{}&lt;br/&gt;  wg.Add(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; wg.Done()&lt;br/&gt;   &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;    ln.Accept()&lt;br/&gt;   }&lt;br/&gt;  }()&lt;br/&gt;&lt;br/&gt;  tcpln := ln.(*net.TCPListener)&lt;br/&gt;  f, err := tcpln.File()&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;panic&lt;/span&gt;(err)&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  os.Setenv(envRestart, &lt;span&gt;&quot;1&quot;&lt;/span&gt;)&lt;br/&gt;  os.Setenv(envListenFD, fmt.Sprintf(&lt;span&gt;&quot;%d&quot;&lt;/span&gt;, f.Fd()))&lt;br/&gt;&lt;br/&gt;  _, err = syscall.ForkExec(os.Args[&lt;span&gt;0&lt;/span&gt;], os.Args, &amp;amp;syscall.ProcAttr{&lt;br/&gt;   Env:   os.Environ(),&lt;br/&gt;   Files: []&lt;span&gt;uintptr&lt;/span&gt;{os.Stdin.Fd(), os.Stdout.Fd(), os.Stderr.Fd(), f.Fd()},&lt;br/&gt;   Sys:   &lt;span&gt;nil&lt;/span&gt;,&lt;br/&gt;  })&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;panic&lt;/span&gt;(err)&lt;br/&gt;  }&lt;br/&gt;  log.Print(&lt;span&gt;&quot;parent pid:&quot;&lt;/span&gt;, os.Getpid(), &lt;span&gt;&quot;, pass fd:&quot;&lt;/span&gt;, f.Fd())&lt;br/&gt;  f.Close()&lt;br/&gt;  wg.Wait()&lt;br/&gt;&lt;br/&gt; } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;  v := os.Getenv(envListenFD)&lt;br/&gt;  fd, err := strconv.ParseInt(v, &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;64&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;panic&lt;/span&gt;(err)&lt;br/&gt;  }&lt;br/&gt;  log.Print(&lt;span&gt;&quot;child pid:&quot;&lt;/span&gt;, os.Getpid(), &lt;span&gt;&quot;, recv fd:&quot;&lt;/span&gt;, fd)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// case1: 理解上面提及的file descriptor、file description的关系&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 这里子进程继承了父进程中传递过来的一些fd，但是fd数值与父进程中可能是不同的&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 取消注释来测试...&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//ff := os.NewFile(uintptr(fd), &quot;&quot;)&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//if ff != nil {&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// _, err := ff.Stat()&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// if err != nil {&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//  log.Println(err)&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// }&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// case2: 假定父进程中共享了fd 0\1\2\listenfd给子进程，那再子进程中可以预测到listenfd=3&lt;/span&gt;&lt;br/&gt;  ff := os.NewFile(&lt;span&gt;uintptr&lt;/span&gt;(&lt;span&gt;3&lt;/span&gt;), &lt;span&gt;&quot;&quot;&lt;/span&gt;)&lt;br/&gt;  fmt.Println(&lt;span&gt;&quot;fd:&quot;&lt;/span&gt;, ff.Fd())&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; ff != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   _, err := ff.Stat()&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;panic&lt;/span&gt;(err)&lt;br/&gt;   }&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;// 这里pause, 运行命令lsof -P -p $pid，检查下有没有listenfd传过来，除了0，1，2，应该有看到3&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;// ctrl+d to continue&lt;/span&gt;&lt;br/&gt;   ioutil.ReadAll(os.Stdin)&lt;br/&gt;&lt;br/&gt;   fmt.Println(&lt;span&gt;&quot;....&quot;&lt;/span&gt;)&lt;br/&gt;   _, err = net.FileListener(ff)&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;panic&lt;/span&gt;(err)&lt;br/&gt;   }&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;// 这里pause, 运行命令lsof -P -p $pid, 会发现有两个listenfd,&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;// 因为前面调用了ff.FD() dup2了一个，如果这里不显示关闭，listener将无法关闭&lt;/span&gt;&lt;br/&gt;   ff.Close()&lt;br/&gt;&lt;br/&gt;   time.Sleep(time.Minute)&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  time.Sleep(time.Minute)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里用简单的代码大致解释了如何用 ProcAttr 来传递 listenfd。这里有个问题，假如后续父进程中传递的 fd 修改了呢，比如不传 stdin, stdout, stderr 的 fd 了，怎么办？服务端是不是要开始预测应该从 0 开始编号了？我们可以通过环境变量通知子进程，比如传递的 fd 从哪个编号开始是 listenfd，一共有几个 listenfd，这样也是可以实现的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种实现方式可以跨平台。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;感兴趣的话，可以看下 facebook 提供的这个实现&lt;a href=&quot;https://github.com/facebookarchive/grace&quot; data-linktype=&quot;2&quot;&gt;grace&lt;/a&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9.2 unix domain socket + cmsg&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一种，思路就是通过 unix domain socket + cmsg 来传递，父进程启动的时候依然是通过 ForkExec 来创建子进程，但是并不通过 ProcAttr 来传递 listenfd。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;父进程在创建子进程之前，创建一个 unix domain socket 并监听，等子进程启动之后，建立到这个 unix domain socket 的连接，父进程此时开始将 listenfd 通过 cmsg 发送给子进程，获取 fd 的方式与 9.1 相同，该注意的 fd 关闭问题也是一样的处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;子进程连接上 unix domain socket，开始接收 cmsg，内核帮子进程收消息的时候，发现里面有一个父进程的 fd，内核找到对应的 file description，并为子进程分配一个 fd，将两者建立起映射关系。然后回到子进程中的时候，子进程拿到的就是对应该 file description 的 fd 了。通过 os.NewFile(fd)就可以拿到 file，然后再通过 net.FileListener 或者 net.PacketConn 就可以拿到 tcplistener 或者 udpconn。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;剩下的获取监听地址，关联逻辑 service 的动作，就与 9.1 小结描述的一致了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我也提供一个可运行的精简版的 demo，供大家了解、测试用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span/&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;io/ioutil&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;net&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;strconv&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;sync&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;syscall&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; passfd &lt;span&gt;&quot;github.com/ftrvxmtrx/fd&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; envRestart = &lt;span&gt;&quot;RESTART&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; envListenFD = &lt;span&gt;&quot;LISTENFD&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; unixsockname = &lt;span&gt;&quot;/tmp/xxxxxxxxxxxxxxxxx.sock&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt; v := os.Getenv(envRestart)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; v != &lt;span&gt;&quot;1&quot;&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;  ln, err := net.Listen(&lt;span&gt;&quot;tcp&quot;&lt;/span&gt;, &lt;span&gt;&quot;localhost:8888&quot;&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;panic&lt;/span&gt;(err)&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  wg := sync.WaitGroup{}&lt;br/&gt;  wg.Add(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; wg.Done()&lt;br/&gt;   &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;    ln.Accept()&lt;br/&gt;   }&lt;br/&gt;  }()&lt;br/&gt;&lt;br/&gt;  tcpln := ln.(*net.TCPListener)&lt;br/&gt;  f, err := tcpln.File()&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;panic&lt;/span&gt;(err)&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  os.Setenv(envRestart, &lt;span&gt;&quot;1&quot;&lt;/span&gt;)&lt;br/&gt;  os.Setenv(envListenFD, fmt.Sprintf(&lt;span&gt;&quot;%d&quot;&lt;/span&gt;, f.Fd()))&lt;br/&gt;&lt;br/&gt;  _, err = syscall.ForkExec(os.Args[&lt;span&gt;0&lt;/span&gt;], os.Args, &amp;amp;syscall.ProcAttr{&lt;br/&gt;   Env:   os.Environ(),&lt;br/&gt;   Files: []&lt;span&gt;uintptr&lt;/span&gt;{os.Stdin.Fd(), os.Stdout.Fd(), os.Stderr.Fd(), &lt;span&gt;/*f.Fd()*/&lt;/span&gt;}, &lt;span&gt;// comment this when test unixsock&lt;/span&gt;&lt;br/&gt;   Sys:   &lt;span&gt;nil&lt;/span&gt;,&lt;br/&gt;  })&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;panic&lt;/span&gt;(err)&lt;br/&gt;  }&lt;br/&gt;  log.Print(&lt;span&gt;&quot;parent pid:&quot;&lt;/span&gt;, os.Getpid(), &lt;span&gt;&quot;, pass fd:&quot;&lt;/span&gt;, f.Fd())&lt;br/&gt;&lt;br/&gt;  os.Remove(unixsockname)&lt;br/&gt;  unix, err := net.Listen(&lt;span&gt;&quot;unix&quot;&lt;/span&gt;, unixsockname)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;panic&lt;/span&gt;(err)&lt;br/&gt;  }&lt;br/&gt;  unixconn, err := unix.Accept()&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;panic&lt;/span&gt;(err)&lt;br/&gt;  }&lt;br/&gt;  err = passfd.Put(unixconn.(*net.UnixConn), f)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;panic&lt;/span&gt;(err)&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  f.Close()&lt;br/&gt;  wg.Wait()&lt;br/&gt;&lt;br/&gt; } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;  v := os.Getenv(envListenFD)&lt;br/&gt;  fd, err := strconv.ParseInt(v, &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;64&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;panic&lt;/span&gt;(err)&lt;br/&gt;  }&lt;br/&gt;  log.Print(&lt;span&gt;&quot;child pid:&quot;&lt;/span&gt;, os.Getpid(), &lt;span&gt;&quot;, recv fd:&quot;&lt;/span&gt;, fd)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// case1: 有同学认为以通过环境变量传fd，通过环境变量肯定是不行的，fd根本不对应子进程中的fd&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//ff := os.NewFile(uintptr(fd), &quot;&quot;)&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//if ff != nil {&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// _, err := ff.Stat()&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// if err != nil {&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//  log.Println(err)&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// }&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// case2: 如果只有一个listenfd的情况下，那如果fork子进程时保证只传0\1\2\listenfd，那子进程中listenfd一定是3&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//ff := os.NewFile(uintptr(3), &quot;&quot;)&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//if ff != nil {&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// _, err := ff.Stat()&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// if err != nil {&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//  panic(err)&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// }&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// // pause, ctrl+d to continue&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// ioutil.ReadAll(os.Stdin)&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// fmt.Println(&quot;....&quot;)&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// _, err = net.FileListener(ff) //会dup一个fd出来，有多个listener&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// if err != nil {&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//  panic(err)&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// }&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// // lsof -P -p $pid, 会发现有两个listenfd&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// time.Sleep(time.Minute)&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//}&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 这里我们暂停下，方便运行系统命令来查看进程当前的一些状态&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// run: lsof -P -p $pid，检查下listenfd情况&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  ioutil.ReadAll(os.Stdin)&lt;br/&gt;  fmt.Println(&lt;span&gt;&quot;.....&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;  unixconn, err := net.Dial(&lt;span&gt;&quot;unix&quot;&lt;/span&gt;, unixsockname)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;panic&lt;/span&gt;(err)&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  files, err := passfd.Get(unixconn.(*net.UnixConn), &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;panic&lt;/span&gt;(err)&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 这里再运行命令：lsof -P -p $pid再检查下listenfd情况&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  f := files[&lt;span&gt;0&lt;/span&gt;]&lt;br/&gt;  f.Stat()&lt;br/&gt;&lt;br/&gt;  time.Sleep(time.Minute)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种实现方式，仅限类 unix 系统。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果有服务混布的情况存在，需要考虑下使用的 unix domain socket 的文件名，避免因为重名所引起的问题，可以考虑通过”进程名.pid“来作为 unix domain socket 的名字，并通过环境变量将其传递给子进程。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10. go 实现热重启: 子进程如何通过 listenfd 重建 listener&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面已经提过了，当拿到 fd 之后还不知道它对应的是 tcp 的 listener，还是 udpconn，那怎么办？都试下呗。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;file, err := os.NewFile(fd)&lt;br/&gt;&lt;span&gt;// check error&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;tcpln, err := net.FileListener(file)&lt;br/&gt;&lt;span&gt;// check error&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;udpconn, err := net.PacketConn(file)&lt;br/&gt;&lt;span&gt;// check error&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;11. go 实现热重启：父进程平滑退出&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;父进程如何平滑退出呢，这个要看父进程中都有哪些逻辑要平滑停止了。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;11.1. 处理已建立连接上请求&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以从这两个方面入手：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;shutdown read，不再接受新的请求，对端继续写数据的时候会感知到失败；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;继续处理连接上已经正常接收的请求，处理完成后，回包，close 连接；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也可以考虑，不进行读端关闭，而是等连接空闲一段时间后再 close，是否尽快关闭更符合要求就要结合场景、要求来看。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果对可用性要求比较苛刻，可能也会需要考虑将 connfd、connfd 上已经读取写入的 buffer 数据也一并传递给子进程处理。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;11.2. 消息服务&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;确认下自己服务的消息消费、确认机制是否合理&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不再收新消息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;处理完已收到的消息后，再退出&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;11.3. 自定义 AtExit 清理任务&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些任务会有些自定义任务，希望进程在退出之前，能够执行到，这种可以提供一个类似 AtExit 的注册函数，让进程退出之前能够执行业务自定义的清理逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不管是平滑重启，还是其他正常退出，对该支持都是有一定需求的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;12. 其他&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些场景下也希望传递 connfd，包括 connfd 上对应的读写的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如连接复用的场景，客户端可能会通过同一个连接发送多个请求，假如在中间某个时刻服务端执行热重启操作，服务端如果直接连接读关闭会导致后续客户端的数据发送失败，客户端关闭连接则可能导致之前已经接收的请求也无法正常响应。这种情况下，可以考虑服务端继续处理连接上请求，等连接空闲再关闭。会不会一直不空闲呢？有可能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实服务端不能预测客户端是否会采用连接复用模式，选择一个更可靠的处理方式会更好些，如果场景要求比较苛刻，并不希望通过上层重试来解决的话。这种可以考虑将 connfd 以及 connfd 上读写的 buffer 数据一并传递给子进程，交由子进程来处理，这个时候需要关注的点更多，处理起来更复杂，感兴趣的可以参考下 mosn 的实现。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;13. 总结&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;热重启作为一种保证服务平滑重启、升级的实现方式，在今天看来依然非常有价值。本文描述了实现热重启的一些大致思路，并且通过 demo 循序渐进地描述了在 go 服务中如何予以实现。虽然没有提供一个完整的热重启实例给大家，但是相信大家读完之后应该已经可以亲手实现了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于作者本人水平有限，难免会有描述疏漏之处，欢迎大家指正。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;参考文章&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Unix 高级编程：进程间通信，Steven Richards&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;mosn 启动流程: https://mosn.io/blog/code/mosn-startup/&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.729264475743349&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvatricjRxhpM1x45aB6doaVg7WMhINPwOiaqpskia1kH7hgibO0dicW2HLcW8HRGMzESQwehIcyckLXtwsA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;639&quot;/&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>