<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>490fdc6563cac9985155f301d09eee6f</guid>
<title>设计模式大冒险第四关：单例模式，如何成为你的 “唯一”</title>
<link>https://toutiao.io/k/gkagy84</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一篇文章是关于&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzAwMDIzODY5MA==&amp;amp;action=getalbum&amp;amp;album_id=1557269952766771201&amp;amp;scene=173&amp;amp;subscene=0&amp;amp;sessionid=0&amp;amp;enterid=1607352063&amp;amp;from_msgid=2247484057&amp;amp;from_itemidx=1&amp;amp;count=3#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;设计模式大冒险系列&lt;/a&gt;的第四篇文章，&lt;strong&gt;这一系列的每一篇文章我都希望能够通过通俗易懂的语言描述或者日常生活中的小例子来帮助大家理解好每一种设计模式&lt;/strong&gt;。今天这篇文章来跟大家一起学习一下单例模式。相信读完这篇文章之后，你肯定会有所收获的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于单例模式，这应该是设计模式中最简单的一种了。大家如果学习过设计模式，可能很多设计模式长时间不用就忘记了，但是对于单例模式来说，你肯定不会忘记。&lt;strong&gt;因为它的理论知识比较简单，实践起来也很方便&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;但是，你真的会正确的使用单例模式吗&lt;/strong&gt;？你知道单例模式在什么情况下使用是合适的，什么情况下使用会造成很多麻烦吗？还是你只是把它当做一个全局变量去使用，只是因为这样开发很方便，不用写很多的代码。今天这篇文章我们就来一起好好学习一下单例模式。让我们开始吧。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;单例模式的介绍&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们先来看一下单例模式的定义是什么。&lt;strong&gt;所谓的单例模式，就是指对于一个具体的类来说，它有且只有一个实例，这个类负责创建唯一的实例，并且对外提供一个全局的访问接口&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单例模式的UML类图可以用下图表示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5049833887043189&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fj9xyC53hPXibNcYhEicMm39E1bePApoD5v9ibKcBVEUJLp5RicibjyGVe9FZcxzDZmzuLGviag96icWjJ5G6s6qic36wA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3010&quot;/&gt;&lt;figcaption&gt;UML&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么我们为什么要使用单例模式呢？&lt;strong&gt;举一个生活中的场景，在平时你过马路的时候，给你信号提示你能不能穿过马路的交通信号灯是不是只有一个？因为在这种情况下，如果同时有两个信号灯的话，你是不知道该不该在此时穿过马路的&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以类比到我们的软件开发中，也是这么一个道理。&lt;strong&gt;在一个系统中，某种用途的实例会存在唯一的一个。这个实例可能用来保存应用中的一些状态，或者执行某些任务&lt;/strong&gt;。比如在前端开发中，我们常常会使用一些应用的状态管理库，比如Vuex或者Redux。那么在我们的应用中，对于管理状态的实例也只能有一个，如果有多个的话就会让应用的状态出现问题，从而导致应用发生一些错误。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;单例模式的实现&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们来看一下单例模式是如何实现的。通过上面的UML类图，我们可以知道，&lt;strong&gt;对于一个类来说，我们需要一个静态变量来保存实例的引用，还需要对外提供一个获取实例的静态方法&lt;/strong&gt;。如果使用 &lt;strong&gt;ES6&lt;/strong&gt; 的类的语法来实现的话，可以简单的用下面的代码来表示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Singleton&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;// 类的静态属性&lt;/span&gt;&lt;br/&gt; &lt;span&gt;static&lt;/span&gt; instance = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 类的静态方法&lt;/span&gt;&lt;br/&gt; &lt;span&gt;static&lt;/span&gt; getInstance() {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.instance === &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;   &lt;span&gt;this&lt;/span&gt;.instance = &lt;span&gt;new&lt;/span&gt; Singleton();&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.instance;&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; a = Singleton.getInstance();&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; b = Singleton.getInstance();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(a === b); &lt;span&gt;// true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的代码还是比较简单的，相信大家看一下就知道怎么实现了。&lt;strong&gt;需要注意的一点是，在类的静态方法中，this指的是类，而不是实例&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们再使用函数的方式来实现一次：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; Singleton = (&lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;let&lt;/span&gt; instance;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 初始化单例对象的方法&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;initInstance&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; {};&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;  getInstance() {&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (instance === &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;    instance = initInstance();&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; instance;&lt;br/&gt;  },&lt;br/&gt; };&lt;br/&gt;})();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; a = Singleton.getInstance();&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; b = Singleton.getInstance();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(a === b);   &lt;span&gt;// true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这两种方法的实现都是差不多的，你可以根据自己的喜好选择不同的实现方式。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;多线程环境中的单例模式&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为Web前端开发者来说，因为我们使用的开发语言基本上是&lt;strong&gt;JavaScript&lt;/strong&gt;，又因为&lt;strong&gt;JavaScript&lt;/strong&gt;是一种单线程语言，所以我们一般不会遇到在多线程环境中使用单例模式会遇到的一些问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么我们如果在多线程的环境中使用单例模式需要注意什么呢？&lt;strong&gt;首先在单例还没有初始化的时候，如果有多个线程访问创建单例模式的代码，在没有做额外处理的情况下，就有可能会创建多个单例&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然也有解决的方法，&lt;strong&gt;一种方法就是我们在类初始化的时候就把单例生成了，这样以后通过获取单例的接口获取到的都是最开始生成的那个单例。但是这样就失去了延时初始化单例的好处&lt;/strong&gt;。如果单例的初始化需要花费的资源或者时间比较少，这种方法是可以的。反之，这样做有就有一些浪费了。&lt;strong&gt;因为可能在整个应用的运行过程中，这个单例一次也没有被使用过&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一种方式就是&lt;strong&gt;在创建单例的时候需要加锁，保证同时只能有一个线程在创建单例&lt;/strong&gt;。这样的话我们就保证了创建的单例是唯一的。当然具体的操作还跟实现单例模式选择的语言有关系，这里就不在深入讨论了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;单例模式的适用场景和优势&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单例模式适合用在这样的场景中：&lt;strong&gt;系统中需要一个唯一的对象去控制、管理和分享系统的状态，或者执行某一个特定的任务又或是实现某一个具体的功能&lt;/strong&gt;。在我们的前端开发中，最常见的就是应用的状态管理对象，比如 &lt;strong&gt;Vuex&lt;/strong&gt; 和 &lt;strong&gt;Redux&lt;/strong&gt;。又或者是打印日志的对象，或者是某一个功能插件等等。总之单例模式在我们平时的开发中还是比较常见的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么单例模式的优势有哪些呢？下面简单列举了一些：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;全局只有一个实例，提供统一的访问与修改，保证状态功能的一致性&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;简单、方便，容易实现&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;延迟的初始化，只有在需要的时候才去初始化对象&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;单例模式的劣势&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然单例模式的优势很突出，但是它的缺点可是一点都不少，甚至有些开发者觉得它是反模式的。所以我们使用单例模式的时候一定要好好思考一下，确定是不是必须要使用单例模式。因为单例模式的不恰当使用会给整个应用的测试，开发和维护带来很大的困难。我们接下来就来看看单例模式有哪些缺点。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;单例模式的滥用会造成跟全局变量一样的一些问题&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如会增加代码的耦合性，因为单例模式全局都是可以访问到的，那么我们就很有可能在很多个地方使用这个唯一的对象，这样也就造成了代码的耦合。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为程序中使用到这个单例对象的地方都可以对全局的状态进行修改，所以一旦程序在这里出现了问题，你可能要在很多个地方进行排查，这就增加了调试和排查问题的难度。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;单例模式给测试带来了很多麻烦&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么说单例模式对测试来说是一个灾难呢？因为如果代码中使用了单例，那么我们需要在进行代码测试的时候，提前把单例初始化好。这导致了我们不能够在单例没有初始化好的时候对代码进行单元测试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且因为单例模式产生的实例只有一个，这就导致了对相同代码进行多次测试的时候容易出现问题，因为实例的状态很可能在上一次测试的时候发生了改变，从而导致了下一次测试的失败或者异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以说单例模式增加了测试的难度与复杂度，增加了测试代码的工作量。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;单例模式违背了软件设计的单一职责原则&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个比较容易理解，因为一般情况下，对于一个类来说它只负责这个类的实例具有什么功能；但是对于单例模式来说，单例模式的类还需要负责只能够产生一个实例。这违背了软件设计的单一职责原则，类应该只负责其实例的具体功能，而不应该对类产生的实例个数负责。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是对于这个缺点来说，大家可能会有不同的看法。显而易见的是这样做确实更加方便，设计实现上也相对简单一些。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;单例模式隐藏了它所需要的依赖&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于一般的类来说，如果我们的类依赖了其它的类，一般情况下，我们可以通过类的构造函数将依赖的类显式的表示出来。这样我们在初始化具体的类的实例的时候就知道这个类需要那些依赖。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是对于单例模式来说，它把它的依赖封装在内部，对于外部的使用者来说它是一个黑盒。使用者并不知道初始化这个单例需要那些依赖，所以很容易在初始化单例的时候把单例所需要的依赖忘记掉，进而导致单例初始化失败。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时就算我们知道了初始化单例需要那些依赖，但是这些依赖也许是有先后的顺序的。我们也很容易在导入和使用依赖的时候把顺序搞错了，从而导致单例的初始化出现问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;单例模式的总结&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;从上面的内容我们已经知道单例模式是一把双刃剑，所以你在使用的时候一定要考虑清楚&lt;/strong&gt;。先从场景的需求上考虑，是不是一定要使用单例模式才能够解决当前的问题，有没有其它的方案。&lt;strong&gt;如果一定要使用单例模式的话，如何规范单例模式的使用，如何在程序的开发，可维护性，可拓展性以及测试的简易性上做好平衡，是一个值得考虑的问题&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文章到这里就结束了，如果大家有什么问题和疑问欢迎大家在文章下面留言，或者在这里提出来。也欢迎大家关注我的公众号关山不难越，获取更多关于设计模式讲解的内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是这一系列的其它的文章，也欢迎大家阅读，希望大家都能够掌握好这些设计模式的使用场景和解决的方法。&lt;strong&gt;如果这篇文章对你有所帮助，那就点个赞，分享一下吧~&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考链接：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Use your singletons wisely&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Singleton&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Singleton Pattern Pitfalls&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;单例模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;单例模式&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>aa2799af0621d5b4fad6af96e58cb831</guid>
<title>工具 | 字节跳动开源的一款通用内存快照裁剪压缩工具</title>
<link>https://toutiao.io/k/3nnro7z</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                              &lt;strong class=&quot;profile_nickname&quot;&gt;开发者头条&lt;/strong&gt;
                              &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;kaifazhetoutiao&lt;/span&gt;
                              &lt;/p&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;程序员分享平台 | 官方应用下载地址：http://toutiao.io/download&lt;/span&gt;
                              &lt;/p&gt;
                              
                          &lt;/div&gt;
                          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7bbccd38bad066519bca20cbb57928e4</guid>
<title>爱奇艺数据仓库平台和服务建设实践</title>
<link>https://toutiao.io/k/tfi2z9t</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;统一数仓建模是业务层建模的基础，需要涵盖尽可能多的业务过程和维度，包括业务建模、数据建模和物理建模三个阶段。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;业务建模是基于业务已有信息，结合建模同学对业务的理解，对业务进行梳理，此时不会面向具体的分析细节，确认范围主要是业务域、业务过程和实体之间的关系，输出业务总线矩阵。业务建模的目的是为了对业务需求进行分解，转化为数据理解，包括的具体流程有：划分业务域、确认业务过程、设计事件事实，确认相关实体、关联事件、构建业务总线矩阵&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;▇  &lt;span&gt;业务域划分，业务域是业务过程的集合，是对业务各个环节的粗粒度划分，将相关的业务过程聚集到一个业务域下，例如播放域。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;▇  确认业务过程，业务过程是业务中的原子行为，不能再进行拆解，我们需要在业务建模过程中，确认有哪些业务过程，并明确业务过程所属的业务域，一个业务过程只能属于一个业务域。&lt;/p&gt;&lt;p&gt;▇  设计事件事实。&lt;/p&gt;&lt;p&gt;▇  确认相关实体，从较粗的粒度确认一个业务过程涉及到的实体范围，防止遗漏分析角度，同时为关联事件实体提供联接节点。&lt;/p&gt;&lt;p&gt;▇  关联事件事实，统一数仓建模需要将已有的事件事实字段都涵盖到，并通过实体进行更多维度的关联。&lt;/p&gt;&lt;p&gt;▇  构建业务总线矩阵，横纵坐标分别为描述事实本身的业务域、业务过程，以及描述事实环境的维度和实体。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;数据建模阶段主要是为了将业务总线矩阵进行细化，完成业务关系到数据关系逻辑转换，并补充相关的维度，输出星型（雪花）模型。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;▇  确认业务，一般不跨业务，针对单个业务进行建模。&lt;/p&gt;&lt;p&gt;▇  确认业务过程，可以面向单个或者多个业务过程。&lt;/p&gt;&lt;p&gt;▇  确认维度，业务过程中包含的维度。&lt;/p&gt;&lt;p&gt;▇  确认度量，业务过程中涉及到的度量。&lt;/p&gt;&lt;p&gt;▇  退化维度属性，为了下游使用更加高效，把一些通用的维度属性退化到明细层模型，尽量减少与维表之间的join操作，提高效率。&lt;/p&gt;&lt;p&gt;▇  构建星型模型，指导后续开发操作。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;物理建模实际上是对数据模型的物化过程，物化过程会根据不同引擎在流程上有细微差别，最终将数据模型物化成Hive的物理表/视图，甚至是带有Schema结构的Kafka Topic，下面以Hive物理表为例描述整个过程。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;▇  确认数据模型，选择需要物化的数据模型。&lt;/p&gt;&lt;p&gt;▇  确认表名，根据数仓规范补充完善表名信息，例如计算周期、表类型、业务信息等。&lt;/p&gt;&lt;p&gt;▇  确认描述/使用说明，补充对表信息的中文描述以及使用注意事项。&lt;/p&gt;&lt;p&gt;▇  确认分区字段，例如天级、小时级。&lt;/p&gt;&lt;p&gt;▇  确认生命周期，根据数据重要性，设置数据保留的时间范围，例如30天、1年等。&lt;/p&gt;&lt;p&gt;▇  生成物理表，同时将表的业务元数据信息录入到元数据中心，与模型完全对应，表名、字段名、字段类型等信息标准化、统一化。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;如之前所述，统一数仓作为底层模型和数据的基础来源，业务集市/主题数仓基于已有的底层模型进行建模，主要包括数据建模，物理建模（当然，可以通过统一数仓业务建模阶段输出的业务总线矩阵更加了解业务）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;业务层数据建模的目标是输出主题的数据星型模型，根据不同的主题和分析场景，选取相关的业务过程，使用合理的建模手段进行数据建模，主要流程包括：确认主题、选取业务过程、确认粒度、确认维度、确认统计指标，最终输出星型模型。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;▇  根据具体的分析需求确认主题。&lt;/p&gt;&lt;p&gt;▇  确认需要分析的业务以及业务过程。&lt;/p&gt;&lt;p&gt;▇  确认统一数仓模型，系统自动推荐相关的模型，选择满足条件的模型，并在此基础上进行后续建模工作。&lt;/p&gt;&lt;p&gt;▇  确认粒度，相同粒度模型可以进行指标的合并。&lt;/p&gt;&lt;p&gt;▇  确认维度，选取后续需要下钻分析的维度，选取过程是在业务过程的范围内进行，不能超出维度能够关联的范围。&lt;/p&gt;&lt;p&gt;▇  确认统计指标，选取业务过程相关的度量（原子指标元数据）派生的统计指标。&lt;/p&gt;&lt;p&gt;▇  构建星型模型。&lt;/p&gt;&lt;p&gt;物理建模流程与之前所述相同，不再重复介绍。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下图是数据建模阶段产出的星型模型实例，在模型图中，将关联的业务信息和数据逻辑进行清晰的表达，辅助后续数据开发工作。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>eec27f804530d02eed5bb2c7c1273de7</guid>
<title>我看技术人的成长路径</title>
<link>https://toutiao.io/k/qnlw4ck</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f33864428fd6da399b25acdd5704e5f1</guid>
<title>Golang 实现 Paxos 分布式共识算法</title>
<link>https://toutiao.io/k/54diic2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;strong data-darkmode-bgcolor-16068282692859=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16068282692859=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16068282692859=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16068282692859=&quot;rgb(0, 0, 0)&quot; data-style=&quot;text-align: left; max-width: 100%; letter-spacing: 0.544px; color: rgb(0, 0, 0); box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__1&quot;&gt;&lt;span data-darkmode-bgcolor-16068282692859=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16068282692859=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16068282692859=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16068282692859=&quot;rgb(136, 136, 136)&quot;&gt;&lt;span data-darkmode-bgcolor-16068282692859=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16068282692859=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16068282692859=&quot;rgb(217, 33, 66)&quot; data-darkmode-original-color-16068282692859=&quot;rgb(217, 33, 66)&quot;&gt;▲ &lt;/span&gt;&lt;span data-darkmode-bgcolor-16068282692859=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16068282692859=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16068282692859=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16068282692859=&quot;rgb(2, 30, 170)&quot; data-style=&quot;max-width: 100%; text-align: center; font-size: 11px; letter-spacing: 1px; color: rgb(2, 30, 170);&quot; class=&quot;js_darkmode__2&quot;&gt;点击上方&quot;多颗糖&quot;&lt;/span&gt;&lt;span data-darkmode-bgcolor-16068282692859=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16068282692859=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16068282692859=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16068282692859=&quot;rgb(62, 62, 62)&quot; data-style=&quot;max-width: 100%; text-align: center; font-size: 11px; letter-spacing: 1px; color: rgb(62, 62, 62);&quot; class=&quot;js_darkmode__3&quot;&gt;关注公众号&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;前文&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIwODA2NjIxOA==&amp;amp;mid=2247483889&amp;amp;idx=1&amp;amp;sn=45f929ef634ee55cbec235dee9c347a5&amp;amp;chksm=97098234a07e0b226c9aa2d3a8c4e2eded8795be0b6c68f299ac8ba1546a626052e33efa295f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《理解 Paxos》&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《理解 Paxos》&lt;/a&gt;只包含伪代码，帮助了理解但又不够爽，既然现在都讲究 &lt;strong&gt;Talk is cheap. Show me the code.&lt;/strong&gt; 这次就把文章中的伪代码用 Go 语言实现出来，希望能帮助各位朋友更直观的感受 Paxos 论文中的细节。&lt;/p&gt;&lt;p&gt;但我们需要对算法做一些简化，有多简单呢？&lt;strong&gt;我们不持久化存储任何变量，并且用 &lt;code&gt;chan&lt;/code&gt; 直接代替 RPC 调用。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;代码地址：https://github.com/tangwz/paxos/tree/naive&lt;/p&gt;&lt;p&gt;&lt;strong&gt;记得切换到 naive 分支。&lt;/strong&gt;&lt;/p&gt;&lt;h2&gt;定义相关结构体&lt;/h2&gt;&lt;p&gt;我们定义 Proposer 如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; proposer &lt;span&gt;struct&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// server id&lt;/span&gt;&lt;br/&gt;    id int&lt;br/&gt;    &lt;span&gt;// the largest round number the server has seen&lt;/span&gt;&lt;br/&gt;    round int&lt;br/&gt;    &lt;span&gt;// proposal number = (round number, serverID)&lt;/span&gt;&lt;br/&gt;    number int&lt;br/&gt;    &lt;span&gt;// proposal value&lt;/span&gt;&lt;br/&gt;    value     string&lt;br/&gt;    acceptors &lt;span&gt;map&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;int&lt;span&gt;]&lt;/span&gt;bool&lt;br/&gt;    net       network&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这些结构体成员都很容易理解，其中 &lt;code&gt;acceptors&lt;/code&gt; 我们主要用来存储 Acceptors 的地址，以及记录我们收到 Acceptor 的成功/失败响应。&lt;/p&gt;&lt;p&gt;Acceptor 的结构体：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; acceptor &lt;span&gt;struct&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// server id&lt;/span&gt;&lt;br/&gt;    id int&lt;br/&gt;    &lt;span&gt;// the number of the proposal this server will accept, or 0 if it has never received a Prepare request&lt;/span&gt;&lt;br/&gt;    promiseNumber int&lt;br/&gt;    &lt;span&gt;// the number of the last proposal the server has accepted, or 0 if it never accepted any.&lt;/span&gt;&lt;br/&gt;    acceptedNumber int&lt;br/&gt;    &lt;span&gt;// the value from the most recent proposal the server has accepted, or null if it has never accepted a proposal&lt;/span&gt;&lt;br/&gt;    acceptedValue string&lt;br/&gt;&lt;br/&gt;    learners &lt;span&gt;[]&lt;/span&gt;int&lt;br/&gt;    net      network&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;主要成员解释都有注释，简单来说我们需要记录三个信息：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;promiseNumber&lt;/code&gt;：承诺的提案编号&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;acceptedNumber&lt;/code&gt;：接受的提案编号&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;acceptedValue&lt;/code&gt;：接受的提案值&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;定义消息结构体&lt;/h2&gt;&lt;p&gt;消息结构体定义了 Proposer 和 Acceptor 之间、Acceptor 和 Leaner 之间的通讯协议。最主要的还是 Paxos 的两阶段的四个消息。&lt;/p&gt;&lt;p&gt;这样看，我们的消息结构体只需要提案编号和提案值，加上一个消息类型，用来区分是哪个阶段的消息。消息结构体定义在 message.go 文件，具体如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// MsgType represents the type of a paxos phase.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; MsgType uint8&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;br/&gt;    Prepare MsgType &lt;span&gt;=&lt;/span&gt; &lt;span&gt;iota&lt;/span&gt;&lt;br/&gt;    Promise&lt;br/&gt;    Propose&lt;br/&gt;    Accept&lt;br/&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; message &lt;span&gt;struct&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    tp     MsgType&lt;br/&gt;    from   int&lt;br/&gt;    to     int&lt;br/&gt;    number int    &lt;span&gt;// proposal number&lt;/span&gt;&lt;br/&gt;    value  string &lt;span&gt;// proposal value&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;实现网络&lt;/h2&gt;&lt;p&gt;网络上可以做的选择和优化很多，但这里为了保持简单的原则，我们将网络定义成 &lt;code&gt;interface&lt;/code&gt;。后面完全可以改成 RPC 或 API 等其它通信方式来实现（没错，我已经实现了一个 Go RPC 的版本了）。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; network &lt;span&gt;interface&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;send&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;m message&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;recv&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;timeout time&lt;span&gt;.&lt;/span&gt;Duration&lt;span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;message&lt;span&gt;,&lt;/span&gt; bool&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下里我们去实现 network 接口：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Network &lt;span&gt;struct&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    queue &lt;span&gt;map&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;int&lt;span&gt;]&lt;/span&gt;&lt;span&gt;chan&lt;/span&gt; message&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;newNetwork&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;nodes &lt;span&gt;...&lt;/span&gt;int&lt;span&gt;)&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;Network &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    pn &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;&amp;amp;&lt;/span&gt;Network&lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        queue&lt;span&gt;:&lt;/span&gt; &lt;span&gt;make&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;map&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;int&lt;span&gt;]&lt;/span&gt;&lt;span&gt;chan&lt;/span&gt; message&lt;span&gt;,&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;),&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; &lt;span&gt;_&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; a &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;range&lt;/span&gt; nodes &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        pn&lt;span&gt;.&lt;/span&gt;queue&lt;span&gt;[&lt;/span&gt;a&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;make&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;chan&lt;/span&gt; message&lt;span&gt;,&lt;/span&gt; &lt;span&gt;1024&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; pn&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;net &lt;span&gt;*&lt;/span&gt;Network&lt;span&gt;)&lt;/span&gt; &lt;span&gt;send&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;m message&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    log&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Printf&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;net: send %+v&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; m&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    net&lt;span&gt;.&lt;/span&gt;queue&lt;span&gt;[&lt;/span&gt;m&lt;span&gt;.&lt;/span&gt;to&lt;span&gt;]&lt;/span&gt; &lt;span&gt;&amp;lt;-&lt;/span&gt; m&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;net &lt;span&gt;*&lt;/span&gt;Network&lt;span&gt;)&lt;/span&gt; &lt;span&gt;recvFrom&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;from int&lt;span&gt;,&lt;/span&gt; timeout time&lt;span&gt;.&lt;/span&gt;Duration&lt;span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;message&lt;span&gt;,&lt;/span&gt; bool&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;select&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; m &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;&amp;lt;-&lt;/span&gt;net&lt;span&gt;.&lt;/span&gt;queue&lt;span&gt;[&lt;/span&gt;from&lt;span&gt;]:&lt;/span&gt;&lt;br/&gt;        log&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Printf&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;net: recv %+v&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; m&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; m&lt;span&gt;,&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&amp;lt;-&lt;/span&gt;time&lt;span&gt;.&lt;/span&gt;&lt;span&gt;After&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;timeout&lt;span&gt;):&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; message&lt;span&gt;{},&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;就是用 &lt;code&gt;queue&lt;/code&gt; 来记录每个节点的 &lt;code&gt;chan&lt;/code&gt;，key 则是节点的 server id。&lt;/p&gt;&lt;p&gt;发送消息则将 &lt;code&gt;Message&lt;/code&gt; 发送到目标节点的 &lt;code&gt;chan&lt;/code&gt; 中，接受消息直接从 &lt;code&gt;chan&lt;/code&gt; 中读取数据，并等待对应的超时时间。&lt;/p&gt;&lt;p&gt;不需要做其它网络地址、包相关的东西，所以非常简单。具体在 &lt;code&gt;network.go&lt;/code&gt; 文件。&lt;/p&gt;&lt;h2&gt;实现单元测试&lt;/h2&gt;&lt;p&gt;这个项目主要使用 go 单元测试来检验正确性，我们主要测试两种场景：&lt;/p&gt;&lt;p&gt;测试代码通过运行 Paxos 后检查 Chosen 返回的提案值是否符合预期。&lt;/p&gt;&lt;h2&gt;实现算法流程&lt;/h2&gt;&lt;p&gt;按照角色将文件分为 proposer.go, acceptor.go 和 learner.go，每个文件都有一个 &lt;code&gt;run()&lt;/code&gt; 函数来运行程序，&lt;code&gt;run()&lt;/code&gt; 函数执行条件判断，并在对应的阶段执行对应的函数。&lt;/p&gt;&lt;p&gt;按照伪代码描述，我们很容易实现 Phase 1 和 Phase 2，把每个阶段的请求响应都作为一个函数，我们一步步来看。&lt;/p&gt;&lt;h3&gt;第一轮 Prepare RPCs 请求阶段：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// Phase 1. (a) A proposer selects a proposal number n&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;// and sends a prepare request with number n to &lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;// a majority of acceptors.&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;code&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;p &lt;span&gt;*&lt;/span&gt;proposer&lt;span&gt;)&lt;/span&gt; &lt;span&gt;prepare&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;[]&lt;/span&gt;message &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    p&lt;span&gt;.&lt;/span&gt;round&lt;span&gt;++&lt;/span&gt;&lt;br/&gt;    p&lt;span&gt;.&lt;/span&gt;number &lt;span&gt;=&lt;/span&gt; p&lt;span&gt;.&lt;/span&gt;&lt;span&gt;proposalNumber&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;    msg &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;make&lt;/span&gt;&lt;span&gt;([]&lt;/span&gt;message&lt;span&gt;,&lt;/span&gt; p&lt;span&gt;.&lt;/span&gt;&lt;span&gt;majority&lt;/span&gt;&lt;span&gt;())&lt;/span&gt;&lt;br/&gt;    i &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; to &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;range&lt;/span&gt; p&lt;span&gt;.&lt;/span&gt;acceptors &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        msg&lt;span&gt;[&lt;/span&gt;i&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; message&lt;span&gt;{&lt;/span&gt;&lt;br/&gt;            tp&lt;span&gt;:&lt;/span&gt;     Prepare&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;            from&lt;span&gt;:&lt;/span&gt;   p&lt;span&gt;.&lt;/span&gt;id&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;            to&lt;span&gt;:&lt;/span&gt;     to&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;            number&lt;span&gt;:&lt;/span&gt; p&lt;span&gt;.&lt;/span&gt;number&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;        i&lt;span&gt;++&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; i &lt;span&gt;==&lt;/span&gt; p&lt;span&gt;.&lt;/span&gt;&lt;span&gt;majority&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; msg&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// proposal number = (round number, serverID)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;p &lt;span&gt;*&lt;/span&gt;proposer&lt;span&gt;)&lt;/span&gt; &lt;span&gt;proposalNumber&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; int &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; p&lt;span&gt;.&lt;/span&gt;round&lt;span&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span&gt;16&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; p&lt;span&gt;.&lt;/span&gt;id&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Prepare 请求阶段我们将 round+1 然后发送给多数派 Acceptors。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;注：这里很多博客和教程都会将 Prepare RPC 发给&lt;strong&gt;所有的&lt;/strong&gt; Acceptors，6.824 的 paxos 实验就将 RPC 发送给所有 Acceptors。这里保持和论文一致，只发送给 a majority of acceptors。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;第一轮 Prepare RPCs 响应阶段：&lt;/h3&gt;&lt;p&gt;接下来在 &lt;code&gt;acceptor.go&lt;/code&gt; 文件中处理请求：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;a &lt;span&gt;*&lt;/span&gt;acceptor&lt;span&gt;)&lt;/span&gt; &lt;span&gt;handlePrepare&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;args message&lt;span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;message&lt;span&gt;,&lt;/span&gt; bool&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; a&lt;span&gt;.&lt;/span&gt;promiseNumber &lt;span&gt;&amp;gt;=&lt;/span&gt; args&lt;span&gt;.&lt;/span&gt;number &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; message&lt;span&gt;{},&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    a&lt;span&gt;.&lt;/span&gt;promiseNumber &lt;span&gt;=&lt;/span&gt; args&lt;span&gt;.&lt;/span&gt;number&lt;br/&gt;    msg &lt;span&gt;:=&lt;/span&gt; message&lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        tp&lt;span&gt;:&lt;/span&gt;     Promise&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;        from&lt;span&gt;:&lt;/span&gt;   a&lt;span&gt;.&lt;/span&gt;id&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;        to&lt;span&gt;:&lt;/span&gt;     args&lt;span&gt;.&lt;/span&gt;from&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;        number&lt;span&gt;:&lt;/span&gt; a&lt;span&gt;.&lt;/span&gt;acceptedNumber&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;        value&lt;span&gt;:&lt;/span&gt;  a&lt;span&gt;.&lt;/span&gt;acceptedValue&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; msg&lt;span&gt;,&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;第二轮 Accept RPCs 请求阶段：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;p &lt;span&gt;*&lt;/span&gt;proposer&lt;span&gt;)&lt;/span&gt; &lt;span&gt;accept&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;[]&lt;/span&gt;message &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    msg &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;make&lt;/span&gt;&lt;span&gt;([]&lt;/span&gt;message&lt;span&gt;,&lt;/span&gt; p&lt;span&gt;.&lt;/span&gt;&lt;span&gt;majority&lt;/span&gt;&lt;span&gt;())&lt;/span&gt;&lt;br/&gt;    i &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; to&lt;span&gt;,&lt;/span&gt; ok &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;range&lt;/span&gt; p&lt;span&gt;.&lt;/span&gt;acceptors &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; ok &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;            msg&lt;span&gt;[&lt;/span&gt;i&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; message&lt;span&gt;{&lt;/span&gt;&lt;br/&gt;                tp&lt;span&gt;:&lt;/span&gt;     Propose&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;                from&lt;span&gt;:&lt;/span&gt;   p&lt;span&gt;.&lt;/span&gt;id&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;                to&lt;span&gt;:&lt;/span&gt;     to&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;                number&lt;span&gt;:&lt;/span&gt; p&lt;span&gt;.&lt;/span&gt;number&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;                value&lt;span&gt;:&lt;/span&gt;  p&lt;span&gt;.&lt;/span&gt;value&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;            i&lt;span&gt;++&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; i &lt;span&gt;==&lt;/span&gt; p&lt;span&gt;.&lt;/span&gt;&lt;span&gt;majority&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; msg&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当 Proposer 收到超过半数 Acceptor 的响应后，Proposer 向多数派的 Acceptor 发起请求并带上提案编号和提案值。&lt;/p&gt;&lt;h3&gt;第二轮 Accept RPCs 响应阶段：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;a &lt;span&gt;*&lt;/span&gt;acceptor&lt;span&gt;)&lt;/span&gt; &lt;span&gt;handleAccept&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;args message&lt;span&gt;)&lt;/span&gt; bool &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    number &lt;span&gt;:=&lt;/span&gt; args&lt;span&gt;.&lt;/span&gt;number&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; number &lt;span&gt;&amp;gt;=&lt;/span&gt; a&lt;span&gt;.&lt;/span&gt;promiseNumber &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        a&lt;span&gt;.&lt;/span&gt;acceptedNumber &lt;span&gt;=&lt;/span&gt; number&lt;br/&gt;        a&lt;span&gt;.&lt;/span&gt;acceptedValue &lt;span&gt;=&lt;/span&gt; args&lt;span&gt;.&lt;/span&gt;value&lt;br/&gt;        a&lt;span&gt;.&lt;/span&gt;promiseNumber &lt;span&gt;=&lt;/span&gt; number&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Acceptor 收到 &lt;code&gt;Accept()&lt;/code&gt; 请求，在这期间如果 Acceptor 没有对比 a.promiseNumber 更大的编号另行 Promise，则接受该提案。&lt;/p&gt;&lt;h3&gt;别忘了：Learning a Chosen Value&lt;/h3&gt;&lt;p&gt;在 Paxos 中有一个十分容易混淆的概念：Chosen Value 和 Accepted Value，但如果你看过论文，其实已经说得非常直接了。论文的 2.3 节 Learning a Chosen Value 开头就说：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;To learn that a value has been chosen, a learner must find out that a proposal has been accepted by a majority of acceptors. &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;所以 Acceptor 接受提案后，会将接受的提案广播 Leaners，一旦 Leaners 收到超过半数的 Acceptors 的 Accepted 提案，我们就知道这个提案被 Chosen 了。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;l &lt;span&gt;*&lt;/span&gt;learner&lt;span&gt;)&lt;/span&gt; &lt;span&gt;chosen&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;message&lt;span&gt;,&lt;/span&gt; bool&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    acceptCounts &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;make&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;map&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;int&lt;span&gt;]&lt;/span&gt;int&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    acceptMsg &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;make&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;map&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;int&lt;span&gt;]&lt;/span&gt;message&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; &lt;span&gt;_&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; accepted &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;range&lt;/span&gt; l&lt;span&gt;.&lt;/span&gt;acceptors &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; accepted&lt;span&gt;.&lt;/span&gt;number &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;            acceptCounts&lt;span&gt;[&lt;/span&gt;accepted&lt;span&gt;.&lt;/span&gt;number&lt;span&gt;]&lt;/span&gt;&lt;span&gt;++&lt;/span&gt;&lt;br/&gt;            acceptMsg&lt;span&gt;[&lt;/span&gt;accepted&lt;span&gt;.&lt;/span&gt;number&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; accepted&lt;br/&gt;        &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; n&lt;span&gt;,&lt;/span&gt; count &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;range&lt;/span&gt; acceptCounts &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; count &lt;span&gt;&amp;gt;=&lt;/span&gt; l&lt;span&gt;.&lt;/span&gt;&lt;span&gt;majority&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; acceptMsg&lt;span&gt;[&lt;/span&gt;n&lt;span&gt;],&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; message&lt;span&gt;{},&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;运行和测试&lt;/h2&gt;&lt;p&gt;代码拉下来后，直接运行：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;go test&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;写在后面&lt;/h2&gt;&lt;h3&gt;为什么不用 mit 6.824 的课程代码？&lt;/h3&gt;&lt;p&gt;之前我曾把 mit 6.824 的 Raft 答案推到自己的 Github，直到 2020 开课的时候 mit 的助教发邮件让我将我的代码转为 private，因为这样会导致学习课程的人直接搜到代码，而无法保证作业独立完成。&lt;/p&gt;&lt;p&gt;确实，实验是计算机最不可或缺的环节，用 mit 6.824 2015 的 paxos 代码会导致很多学习者不去自己解决困难，直接上网搜代码，从而导致学习效果不好，违背了 mit 的初衷。&lt;/p&gt;&lt;p&gt;当然，你也可以说现在网上以及很容易搜到 6.824 的各种代码了，但出于之前 mit 助教的邮件，我不会将作业代码直接发出来。&lt;/p&gt;&lt;p&gt;感兴趣的同学可以到 2015 版本学习：http://nil.csail.mit.edu/6.824/2015/&lt;/p&gt;&lt;h3&gt;未来计划&lt;/h3&gt;&lt;p&gt;欢迎各位朋友催更……&lt;/p&gt;&lt;h2&gt;结语&lt;/h2&gt;&lt;p&gt;本文代码在 Github 上，如本文有什么遗漏或者不对之处，或者各位朋友有什么新的想法，欢迎提 issue 讨论。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;em&gt;推荐阅读&lt;/em&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIwODA2NjIxOA==&amp;amp;mid=2247483974&amp;amp;idx=1&amp;amp;sn=8d3603dee35ee817d7909dc2052f86e3&amp;amp;chksm=97098183a07e0895c4d3177e79d565b97ddd0a59bbc889a3a2a0b2e1c297ba7c634206f54a42&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;系统设计那些事儿：硬盘 I/O&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;/&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIwODA2NjIxOA==&amp;amp;mid=2247483855&amp;amp;idx=1&amp;amp;sn=55a9c2c1eb28310e678c35df91d33818&amp;amp;chksm=9709820aa07e0b1c2c82f94bbbd530d6a60fdd78b3a3171b93aff3e755b8f501dc7f243e78ac&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;漫谈分布式共识问题&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;em&gt;漫谈分布式共识问题&lt;/em&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIwODA2NjIxOA==&amp;amp;mid=2247483961&amp;amp;idx=1&amp;amp;sn=e6da234774be281f84de1532a41805e9&amp;amp;chksm=970981fca07e08ea4df471aaa7dd4691853225164726acd57966c8f62741a7f236d4eb365c80&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;每个程序员都应该知道的延迟数字&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;em&gt;&lt;strong/&gt;&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIwODA2NjIxOA==&amp;amp;mid=2247483889&amp;amp;idx=1&amp;amp;sn=45f929ef634ee55cbec235dee9c347a5&amp;amp;chksm=97098234a07e0b226c9aa2d3a8c4e2eded8795be0b6c68f299ac8ba1546a626052e33efa295f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;理解 Paxos（含伪代码）&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;em&gt;理解 Paxos（含伪代码）&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIwODA2NjIxOA==&amp;amp;mid=2247483903&amp;amp;idx=1&amp;amp;sn=e8d0bee17bb227771aaf59815674267f&amp;amp;chksm=9709823aa07e0b2c256d6bc69b110701c77a17cf7f99cb768d7f06a6a9e31e60233d8883cb08&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Paxos 的变种（一）：Multi-Paxos 是如何劝退大家去选择 Raft 的&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;em&gt;Paxos 的变种（一）：Multi-Paxos 是如何劝退大家去选择 Raft 的&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIwODA2NjIxOA==&amp;amp;mid=2247483942&amp;amp;idx=1&amp;amp;sn=b25b54f13bbe36c39aeb9f6a73e03b9a&amp;amp;chksm=970981e3a07e08f52ea42b107b225a1eb390e9fabe45c24e97280ca0f8f845e5b480d85b875c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;用 Raft 的方式理解 Multi-Paxos&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;em&gt;用 Raft 的方式理解 Multi-Paxos&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIwODA2NjIxOA==&amp;amp;mid=2247483915&amp;amp;idx=1&amp;amp;sn=13b6c8bcb62ee16d1cde51b47ec6722e&amp;amp;chksm=970981cea07e08d842ca7227bb4646f92fda6f662e12ea0df0eabc8c8ef6e01824e18be31fa1&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Raft 作者出的 Paxos 的试题，看看你能得多少分？&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;em&gt;Raft 作者出的 Paxos 的试题，看看你能得多少分？&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;欢迎关注我的公众号：&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.36484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hBL5R2neMA2qgPwzomIicebbmoOGzU1IsUWQMb3xr4nLcjtfIy5Zwyia3HTKnIJ8xc9NFkkPBkL8MEAfh3YdNuaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>