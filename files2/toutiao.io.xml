<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>23cb0c93be60becef56f6a63505ffdc2</guid>
<title>Redis 教程：Redis 知识体系详解</title>
<link>https://toutiao.io/k/av396i0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;theme-default-content content__default&quot;&gt;&lt;h1 id=&quot;♥redis教程---redis知识体系详解♥&quot;&gt;&lt;a href=&quot;#♥redis教程---redis知识体系详解♥&quot; class=&quot;header-anchor&quot;&gt;¶&lt;/a&gt; ♥Redis教程 - Redis知识体系详解♥&lt;/h1&gt; &lt;blockquote&gt;&lt;p&gt;本系列主要对Redis知识体系进行详解。@pdai&lt;/p&gt;&lt;/blockquote&gt;  &lt;h2 id=&quot;知识体系&quot;&gt;&lt;a href=&quot;#知识体系&quot; class=&quot;header-anchor&quot;&gt;¶&lt;/a&gt; 知识体系&lt;/h2&gt; &lt;p&gt;&lt;em&gt;知识体系&lt;/em&gt;&lt;/p&gt; &lt;p&gt;&lt;img alt=&quot;&quot; data-src=&quot;/_images/db/redis/db-redis-overview.png&quot; loading=&quot;lazy&quot; class=&quot;lazy&quot;/&gt;&lt;/p&gt; &lt;p&gt;&lt;em&gt;相关文章&lt;/em&gt;&lt;/p&gt; &lt;blockquote&gt;&lt;p&gt;首先，我们通过学习Redis的概念基础，了解它适用的场景。&lt;/p&gt;&lt;/blockquote&gt; &lt;ul&gt;&lt;li&gt;&lt;a href=&quot;/md/db/nosql-redis/db-redis-introduce.html&quot;&gt;Redis入门 - Redis概念和基础&lt;/a&gt; &lt;ul&gt;&lt;li&gt;Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt; &lt;blockquote&gt;&lt;p&gt;其次，这些适用场景都是基于Redis支持的数据类型的，所以我们需要学习它支持的数据类型；同时在redis优化中还需要对底层数据结构了解，所以也需要了解一些底层数据结构的设计和实现。&lt;/p&gt;&lt;/blockquote&gt; &lt;p&gt;&lt;img alt=&quot;&quot; data-src=&quot;/_images/db/redis/db-redis-object-2-2.png&quot; loading=&quot;lazy&quot; class=&quot;lazy&quot;/&gt;&lt;/p&gt;  &lt;blockquote&gt;&lt;p&gt;再者，需要学习Redis支持的核心功能，包括持久化，消息，事务，高可用；高可用方面包括，主从，哨兵等；高可拓展方面，比如 分片机制等。&lt;/p&gt;&lt;/blockquote&gt; &lt;ul&gt;&lt;li&gt;&lt;a href=&quot;/md/db/nosql-redis/db-redis-x-rdb-aof.html&quot;&gt;Redis进阶 - 持久化：RDB和AOF机制详解&lt;/a&gt; &lt;ul&gt;&lt;li&gt;为了防止数据丢失以及服务重启时能够恢复数据，Redis支持数据的持久化，主要分为两种方式，分别是RDB和AOF; 当然实际场景下还会使用这两种的混合模式。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/db/nosql-redis/db-redis-x-pub-sub.html&quot;&gt;Redis进阶 - 消息传递：发布订阅模式详解&lt;/a&gt; &lt;ul&gt;&lt;li&gt;Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/db/nosql-redis/db-redis-x-event.html&quot;&gt;Redis进阶 - 事件：Redis事件机制详解&lt;/a&gt; &lt;ul&gt;&lt;li&gt;Redis 采用事件驱动机制来处理大量的网络IO。它并没有使用 libevent 或者 libev 这样的成熟开源方案，而是自己实现一个非常简洁的事件驱动库 ae_event。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/db/nosql-redis/db-redis-x-trans.html&quot;&gt;Redis进阶 - 事务：Redis事务详解&lt;/a&gt; &lt;ul&gt;&lt;li&gt;Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/db/nosql-redis/db-redis-x-copy.html&quot;&gt;Redis进阶 - 高可用：主从复制详解&lt;/a&gt; &lt;ul&gt;&lt;li&gt;我们知道要避免单点故障，即保证高可用，便需要冗余（副本）方式提供集群服务。而Redis 提供了主从库模式，以保证数据副本的一致，主从库之间采用的是读写分离的方式。本文主要阐述Redis的主从复制。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/db/nosql-redis/db-redis-x-sentinel.html&quot;&gt;Redis进阶 - 高可用：哨兵机制（Redis Sentinel）详解&lt;/a&gt; &lt;ul&gt;&lt;li&gt;在上文主从复制的基础上，如果注节点出现故障该怎么办呢？ 在 Redis 主从集群中，哨兵机制是实现主从库自动切换的关键机制，它有效地解决了主从复制模式下故障转移的问题。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/db/nosql-redis/db-redis-x-cluster.html&quot;&gt;Redis进阶 - 高可拓展：分片技术（Redis Cluster）详解&lt;/a&gt; &lt;ul&gt;&lt;li&gt;前面两篇文章，主从复制和哨兵机制保障了高可用，就读写分离而言虽然slave节点来扩展主从的读并发能力，但是写能力和存储能力是无法进行扩展的，就只能是master节点能够承载的上限。如果面对海量数据那么必然需要构建master（主节点分片)之间的集群，同时必然需要吸收高可用（主从复制和哨兵机制）能力，即每个master分片节点还需要有slave节点，这是分布式系统中典型的纵向扩展（集群的分片技术）的体现；所以在Redis 3.0版本中对应的设计就是Redis Cluster。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt; &lt;blockquote&gt;&lt;p&gt;最后，就是具体的实践以及实践中遇到的问题和解决方法了：在不同版本中有不同特性，所以还需要了解版本；以及性能优化，大厂实践等。&lt;/p&gt;&lt;/blockquote&gt;  &lt;h2 id=&quot;学习资料&quot;&gt;&lt;a href=&quot;#学习资料&quot; class=&quot;header-anchor&quot;&gt;¶&lt;/a&gt; 学习资料&lt;/h2&gt; &lt;ul&gt;&lt;li&gt;&lt;p&gt;Redis官网:http://redis.io/&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;Redis官方文档:http://redis.io/documentation&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;Redis教程:http://www.w3cschool.cn/redis/redis-intro.html&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;Redis下载:http://redis.io/download&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;redis英文文档 https://redis.io/topics/data-types&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;redis中文文档 http://www.redis.cn/documentation.html&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;《redis设计与实现 3.0版本》 http://redisbook.com/index.html&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;redis菜鸟教程 https://www.runoob.com/redis/redis-tutorial.html&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;redis源码解读 3.2.8版本 https://blog.csdn.net/men_wen/article/details/75668345&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt; &lt;p&gt;除此之外，我还推荐你看下 极客时间 《Redis核心技术与实战》（作者：蒋德钧）的相关内容，它是我看到的为数不多的含有实战经验比较多的专栏，部分文章中图片也来源于这个系列。&lt;/p&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>573f76f1e77eddaf7bee370a78e048fc</guid>
<title>以模型为中心，携程契约系统的演进</title>
<link>https://toutiao.io/k/mlv82jf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8f9646e69c434071a1e118c15de502c0</guid>
<title>醒一醒，讲到 ZooKeeper 的选举机制了</title>
<link>https://toutiao.io/k/ft1r1q4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMNODI3zmERvmnRrthyMYRBjiaGXTfcIPriaxUMZb6jZP32vibu49ou0TicibZypAUuUt1K7nPea5fia3oQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.425531914893617&quot; data-w=&quot;940&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文作者：HelloGitHub-&lt;strong&gt;老荀&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Hi，这里是 HelloGitHub 推出的 HelloZooKeeper 系列，&lt;strong&gt;免费开源、有趣、入门级的 ZooKeeper 教程&lt;/strong&gt;，面向有编程基础的新手。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;项目地址：https://github.com/HelloGitHub-Team/HelloZooKeeper&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天开始我们将继续深入 ZK 选举相关的知识&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMNODI3zmERvmnRrthyMYRB06UXpO8zLrN3EDU1gY5wicAlofx1jZdcCrfHEM3v17myBic1tJibpu8oA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.5885650224215246&quot; data-w=&quot;892&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一、选举的基本规则&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ZKr～这次我决定一反常态，先不讲故事了～先得聊聊在 ZK 选举中非常重要的一些东西。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1 zxid&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;zxid 就是我们&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5MzYyNzQ0MQ==&amp;amp;mid=2247499173&amp;amp;idx=1&amp;amp;sn=8d09888533c4a75d2915720c1242ee13&amp;amp;chksm=905848fba72fc1ed38659069914313885499d89bd3259fcc95ef0604c8bbc1851f2cc31e85f7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;之前&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;之前&lt;/a&gt;提到的事务编号，是一个 8 字节的整型数字，但是 ZK 设计的时候把这一个数字拆成了两部分使用，一鱼两吃！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;8 个字节的整数一共有 64 位长度，前 32 位用来记录 epoch，后 32 位就是用来计数。你可能要问了？epoch？是啥？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMNODI3zmERvmnRrthyMYRBT4B5ckWxBLpRwWZgibfzXtqYRgFpdFfNgKISIs2vkvdiaQhAMkVAJPYQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;1.0623188405797102&quot; data-w=&quot;690&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;zxid 初始化是 0，也就是这样&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;00000000000000000000000000000000 00000000000000000000000000000000&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每一次写请求都会增加后 32 位，假设现在进行了 10 次写请求（无论该请求有没有真的修改到数据），zxid 就会变成这样&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;00000000000000000000000000000000 00000000000000000000000000001010&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当进行一次选举的时候，前 32 位就会增加 1，并且清零后 32 位&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;00000000000000000000000000000001 00000000000000000000000000000000&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了选举以外，当后 32 位彻底用完（变成全 1，也就是 ZK 正常执行了 2^32 - 1 次写请求都没进行过一次选举，牛逼！）也会让前 32 位增加 1，相当于进位&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;# 进位前&lt;/span&gt;&lt;br/&gt;00000000000000000000000000000000 11111111111111111111111111111111&lt;br/&gt;&lt;span&gt;# 进位后&lt;/span&gt;&lt;br/&gt;00000000000000000000000000000001 00000000000000000000000000000000&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里我就可以回答大家前面的问题了，epoch 就是 zxid 前 32 位的这个数字，epoch 本身的翻译是“纪元，时代”的意思，意味着更新换代，而 zxid 的后 32 位数字仅仅是写请求的计数罢了&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2 myid&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在之前的小故事里，我给 ZK 的集群中的各个节点都起了一个好记的名字（神特么好记！）。但是 ZK 官方自己是如何给每一个集群中的节点起名字的呢？用的就是 myid！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ZK 的启动配置 &lt;code&gt;zoo.cfg&lt;/code&gt; 中有一项 &lt;code&gt;dataDir&lt;/code&gt; 指定了数据存放的路径（默认是 &lt;code&gt;/tmp/zookeeper&lt;/code&gt;)，在此路径下新建一个文本文件，命名为 &lt;code&gt;myid&lt;/code&gt;， 文本内容就是一个数字，这个数字就是当前节点的 myid&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;/tmp&lt;br/&gt;└── zookeeper&lt;br/&gt;    ├── myid&lt;br/&gt;    └── ...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后在 &lt;code&gt;zoo.cfg&lt;/code&gt; 是这样配置集群信息&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;server.1=zoo1:2888:3888&lt;br/&gt;server.2=zoo2:2888:3888&lt;br/&gt;server.3=zoo3:2888:3888&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个 &lt;code&gt;server.&lt;/code&gt; 之后的数字就是 myid，这个 myid 在整个集群中，各个节点之间是不能重复的。我忘记之前在哪儿看到的了，说是 myid 只能是 1 到 255 的数字，我一直信以为真，直到这次，我本着严谨的态度去做了实践，一切以事实为主，并且我的实验覆盖了 3.4、3.5、3.6 三大版本（都是三台机器的简单集群），结论是：myid 只要是不等于 -1 就行（-1 是一个固定的值会导致当前节点启动报错），不能大于 &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; 或者小于 &lt;code&gt;Long.MIN_VALUE&lt;/code&gt;，但是如果在当前的节点中配置了 &lt;code&gt;zookeeper.extendedTypesEnabled=true&lt;/code&gt; 那当前节点的最大 myid 是 254（负数不影响，我也不知道这个 254 的用意，但是代码中的确有判断） 是不是奇怪的知识又增加了呢～&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于配置更多的信息，之后单独再整理，今天就点到为止&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMNODI3zmERvmnRrthyMYRBmWobvpnHFRnicibuIwp4uDe0X0jPfcHHR2rcKMwxjgWf9QxGeVnTLK5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;1.141025641025641&quot; data-w=&quot;156&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.3 选举规则&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;知道了上面这些有什么用呢？非常重要！因为选举 Leader 完全看的就是这几个值&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优先级从上到下逐级比较，谁大谁就更有资格成为 Leader，当前级一样就比较下一级，直到分出胜负为止！因为 myid 是不能重复的，所以最终是一定能分出胜负的！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，现在大家知道了最基本的选举规则了～让我们进入下一节吧&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二、三马之争&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;马果果&lt;/strong&gt;一定想不到，这辈子自己可以和两位鼎鼎大名的明星企业家相提并论，让我们一起去看看发生了什么吧～&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 准备开工&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前&lt;strong&gt;马果果&lt;/strong&gt;规定了三个办事处在对外开张前必须选出一个 Leader，在正式开始选之前，每一个办事处也有一些准备工作需要做：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;每一个办事处必须得知道一共有多少个办事处&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;额外聘请一些专门负责和其他办事处沟通的话务员&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;准备好一个票箱用来对投票统计和归票&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为每一个办事处设置一个固定的 myid&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以现在办公室的布置变成了这样（我省略了之前章节的其他要素）：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMNODI3zmERvmnRrthyMYRBwibejLVaFo8FpmGwGga6l6kT3LIibkicUWKcGHkicibAszWElefxKBoq1zQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6291469194312796&quot; data-w=&quot;844&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了这些准备工作以后所有办事处都可以进入选举的阶段了，并且村委会规定了几种状态用于表示当前办事处正处在的阶段：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;LOOKING，正在寻找 Leader，处于此阶段的办事处不能对外提供服务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LEADING，当前办事处就是 Leader，可以对外提供服务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;FOLLOWING，当前办事处正在跟随 Leader，可以对外提供服务&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很明显刚刚准备好的各个办事处现在都处于 LOOKING 状态，下面让我们正式进入选举流程吧&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 开始选举&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于各个办事处刚准备好，所以彼此之间还没有通过信，又加上大家都是姓马的，心里面都是想当老大的，所以每一个办事都会率先拟一张写着自己的选票发给其他办事处。主要有这些信息：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;sid：我是谁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;leader：我选谁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;state：我当前的状态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;epoch：我当前的 epoch&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;zxid：我选择的 leader 的最大的事务编号&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以&lt;strong&gt;马果果&lt;/strong&gt;举例：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMNODI3zmERvmnRrthyMYRBAr9VvtBjeMwuyxRcll5R2C8u4nJduPNIZiaolUgN56NNV7T4BwIsWNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.7513368983957219&quot; data-w=&quot;374&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;马小云&lt;/strong&gt;和&lt;strong&gt;马小腾&lt;/strong&gt;也一样，一开始都选了自己做 Leader 候选人，并且都把自己认为的候选人（当前场景下就是自己）的票分别发送给了其他两位（以及自己）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMNODI3zmERvmnRrthyMYRBEqXS6jBkstmyoa1pbkGic0c2zcq5AQjXt1GicekhuzSJ1By0cy9gZRicw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6572700296735905&quot; data-w=&quot;674&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2.1 马果果视角&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个办事处各自也会收到来自其他办事处的选票（也有可能是自己的），每拿到一张选票，都需要和当前自己认为的 Leader 候选人做比较，理论上自己投给自己的选票会先一步达到自己的票箱，因为不需要经过通讯减少了传输的路径，自己的选票和自己的候选人是一致的所以不需要比较，只需要在票箱中记上一笔，我们还是以&lt;strong&gt;马果果&lt;/strong&gt;举例：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMNODI3zmERvmnRrthyMYRBbx5LKkddhb1KVWvGpQ0kWy1HjIJHg352IOQ9icvTapibria730YIFFd1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;1.1829787234042553&quot; data-w=&quot;470&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;=》&lt;/code&gt;的左边是办事处的名字，右边是该办事处选的 Leader。当前投票统计是指，当前节点所选的 Leader 获得的选票统计。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设他再收到了&lt;strong&gt;马小云&lt;/strong&gt;的选票：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;马果果&lt;/strong&gt;首先看到的是&lt;strong&gt;马小云&lt;/strong&gt;也处在 LOOKING 状态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;接着就会比较自己候选人和&lt;strong&gt;马小云&lt;/strong&gt;的选票（左边代表当前办事处的候选人，右边代表收到的选票信息，下同）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;e:0      ==  e:0&lt;br/&gt;z:0      ==  z:0&lt;br/&gt;l: 马果果(69) &amp;gt;   l: 马小云(56)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终因为&lt;strong&gt;马果果&lt;/strong&gt;的 myid 69 要比&lt;strong&gt;马小云&lt;/strong&gt;的 myid 56 要大，所以&lt;strong&gt;马果果&lt;/strong&gt;最终胜出！虽然&lt;strong&gt;马小云&lt;/strong&gt;胜出了，但是当前投票统计是不能修改的，因为&lt;strong&gt;马小云&lt;/strong&gt;这一轮的选票就是选的&lt;strong&gt;马小云&lt;/strong&gt;，需要等待他重新改票后再投才能修改投票统计。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后会往投票箱记录：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMNODI3zmERvmnRrthyMYRBt45jKInnsQ1u2XTyNymQF7uyRiciblv5Zlpn8ic2iaPMDx3g1pkZOlD23g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;1.2273730684326711&quot; data-w=&quot;453&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;紧接着是&lt;strong&gt;马小腾&lt;/strong&gt;的投票：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;e:0      ==  e:0&lt;br/&gt;z:0      ==  z:0&lt;br/&gt;l: 马果果(69) &amp;gt;   l: 马小腾(49)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;马果果&lt;/strong&gt;还是胜出！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;记录投票箱：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMNODI3zmERvmnRrthyMYRBOkiamv6bTHUbbAVZmd152BSg8wiaUoQ9B3yoZSngpQGdjwXzic8MC3exQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;1.2108695652173913&quot; data-w=&quot;460&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每次收到投票的时候，&lt;strong&gt;马果果&lt;/strong&gt;都会依据当前的投票统计进行归票，但是很遗憾选举仍然无法结束，因为结束的规则必须有某一个办事处获得半数以上的选票，现在只有一个&lt;strong&gt;马果果&lt;/strong&gt;自己的选票，不满足半数以上，所以马果果只能再等等了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在&lt;strong&gt;马果果&lt;/strong&gt;这边忙的热火朝天的同时，&lt;strong&gt;马小云&lt;/strong&gt;和&lt;strong&gt;马小腾&lt;/strong&gt;也在进行着同样的动作。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2.2 马小云视角&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们这省略描述&lt;strong&gt;马小云&lt;/strong&gt;记录自己选票的过程，假设他这边是先收到&lt;strong&gt;马果果&lt;/strong&gt;的选票，是怎么处理的呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;e:0      ==  e:0&lt;br/&gt;z:0      ==  z:0&lt;br/&gt;l: 马小云(56) &amp;lt;   l: 马果果(69)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;马小云&lt;/strong&gt;看到自己认为的 Leader 候选人被&lt;strong&gt;马果果&lt;/strong&gt;的选票击败了，所以将自己的候选人改为&lt;strong&gt;马果果&lt;/strong&gt;，并将新的选票重新广播出去&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMNODI3zmERvmnRrthyMYRBzibXDrF8fnWibaDwA8WyozRHEAvmSdTLyfebK9ibvII98bdm8Ln0V8spw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.511744966442953&quot; data-w=&quot;596&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后在自己的投票箱中记录：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMNODI3zmERvmnRrthyMYRBu8lht826PU4vVicD0TBQ5hiaeK4yOAbbxLaiaF8EDISWOEFgT0IaH5R9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;1.193058568329718&quot; data-w=&quot;461&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了叙述的完整性，我们还是把&lt;strong&gt;马小腾&lt;/strong&gt;的票也看完&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;e:0      ==  e:0&lt;br/&gt;z:0      ==  z:0&lt;br/&gt;l: 马果果(69) &amp;gt;   l: 马小腾(49)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;马果果&lt;/strong&gt;还是胜出了，所以&lt;strong&gt;马小云&lt;/strong&gt;的投票箱最终变成这样：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMNODI3zmERvmnRrthyMYRBCEuYSAqzdmkbl7ZGLKxe5SiasvOvOa7EAoUAFxDoIBicvKPshmrUWKiaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;1.2077922077922079&quot; data-w=&quot;462&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;讲道理接下来应该以&lt;strong&gt;马小腾&lt;/strong&gt;为主视角，再讲一遍刚才的过程，但是可以认为几乎和&lt;strong&gt;马小云&lt;/strong&gt;是一样的，为了故事的顺畅，我们需要回到&lt;strong&gt;马果果&lt;/strong&gt;的视角，因为&lt;strong&gt;马小云&lt;/strong&gt;输给&lt;strong&gt;马果果&lt;/strong&gt;之后改票了，又发了一轮选票&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2.3 马果果视角（再）&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;马果果&lt;/strong&gt;又再一次收到了&lt;strong&gt;马小云&lt;/strong&gt;的选票（改票后），投票箱就会改成这样：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMNODI3zmERvmnRrthyMYRBraDmicdFhuZHWiazS4LU50yEgbB18Roiazjzzhicb0YxEZ5KFaO12x2sicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;1.2350332594235034&quot; data-w=&quot;902&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;收到这个投票后，当前投票统计就会增加&lt;strong&gt;马小云&lt;/strong&gt;的记录，然后&lt;strong&gt;马果果&lt;/strong&gt;进行归票就发现了这次自己的选票超过半数了，然后会进行二次确认，会等待一会看看还能不能收到更新的选票，这里假设没有收到更新的投票，就会进行判断，当前过半数的候选人是不是自己？如果是的话，那自己就是 Leader，不是的话，自己就是 Follower。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很明显，&lt;strong&gt;马果果&lt;/strong&gt;就是 Leader，然后会把自己的状态修改为 LEADING。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与此同时，&lt;strong&gt;马小云&lt;/strong&gt;、&lt;strong&gt;马小腾&lt;/strong&gt;也进行归票，归票结果自己为 Follower，把自己状态修改为 FOLLOWING，然后各自都会和 Leader 进行数据的同步，同步完成之后整个办事处就都可以对外提供服务了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMNODI3zmERvmnRrthyMYRBpC4ZYAmutNc2rCsXiaxOib0rlHZFyhwAVLmiblITH2ZiaLzIglgFPliaBKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6472222222222223&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3 马小腾停电啦&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;选举本身涉及到集群间的通信、节点自身的状态管理和状态变更，本身就是一个比较复杂的过程，刚才只是举例了一个最简单的启动选举流程，下面会举更多的例子帮助大家能理解整个选举的逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在假设办事处安然无恙得对外提供了一段时间服务后，&lt;strong&gt;马小腾&lt;/strong&gt;的办事处突然停电了，就不能和另外两马进行通讯了，而另外两马在一段时间内都没有收到过&lt;strong&gt;马小腾&lt;/strong&gt;的信息的时候就知道，出事了！但是各自盘点了下目前仍然还有两个办事处可以对外提供服务，是达到整个集群总数的半数以上的，是可以继续让村民们来办理业务的，所以现在整个集群变成了这样：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMNODI3zmERvmnRrthyMYRBlCYsatibODUwBu3VVu9ZpOV5HKLFrxiaLsefnB6ibOvh2YMRo8np5h9MA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.7166666666666667&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没过一会，因为电力公司的积极抢修，&lt;strong&gt;马小腾&lt;/strong&gt;的办事处恢复供电了，重新开张了，但是每一个办事处在开张前都是处在 LOOKING 状态的，还是会优先投票给自己，并会通过复盘本地的存档来得到自己办事处最新的数据，假设&lt;strong&gt;马小腾&lt;/strong&gt;停电前是这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;e:0     &lt;br/&gt;z:21      &lt;br/&gt;l: 马小腾(49)&lt;br/&gt;LOOKING&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;他和之前一样会给另外两个办事处发自己的选票&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMNODI3zmERvmnRrthyMYRBLbze9kWR4ouRq6njiao0EEUqzVueeqRqgQJ1mFXqPJNQaSLIDDGlxYg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6472222222222223&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但和之前的情况不同，无论是&lt;strong&gt;马果果&lt;/strong&gt;还是&lt;strong&gt;马小云&lt;/strong&gt;他们现在都处在工作的状态，收到了&lt;strong&gt;马小腾&lt;/strong&gt;的选票后就会把当前的 Leader 也就是&lt;strong&gt;马果果&lt;/strong&gt;的选票信息以及自己当前的状态发送给他。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;马果果&lt;/strong&gt;发送的选票信息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;e:0     &lt;br/&gt;z:30      &lt;br/&gt;l: 马果果(69)&lt;br/&gt;LEADING&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;马小云&lt;/strong&gt;发送的选票信息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;e:0     &lt;br/&gt;z:30      &lt;br/&gt;l: 马果果(69)&lt;br/&gt;FOLLOWING&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;马小腾&lt;/strong&gt;收到两位的选票信息后，知道了当前的 Leader 是&lt;strong&gt;马果果&lt;/strong&gt;，并且&lt;strong&gt;马果果&lt;/strong&gt;本人也确认了是 LEADING 状态，就马上把自己的状态修改为了 FOLLOWING 状态，并且会和之前一样与 Leader 进行数据的同步，关于具体怎么同步的，我打算留到之后再进行讲解～&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同步之后，&lt;strong&gt;马小腾&lt;/strong&gt;的状态变成了和&lt;strong&gt;马小云&lt;/strong&gt;一样的了。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我再假设这里有一个平行世界，回到&lt;strong&gt;马小腾&lt;/strong&gt;刚恢复完供电准备开张上线的时候，此时的&lt;strong&gt;马小腾&lt;/strong&gt;的状态假设是这样的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;e:1     &lt;br/&gt;z:7      &lt;br/&gt;l: 马小腾(49)&lt;br/&gt;LOOKING&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哪怕 epoch 比目前的 Leader 还要大，其实照道理是更有资格当 Leader，但是由于当前集群中的其他办事处已经有了一个明确的 Leader，&lt;strong&gt;马小腾&lt;/strong&gt;也只能忍辱负重（谁让你停电了呢）还是以 Follower 的身份加入到集群中来，并且仍然以当前 Leader 的信息来同步，你也可以理解为降级（把自己的 epoch 降级回 0 ）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;职场就是这么残忍，你稍微请个长假再回来可能已经是物是人非了～&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xBgIbW1vdNMNODI3zmERvmnRrthyMYRB7Xo8yk4MeL0ic4VOyYgrQrMW7ySK4F32qnh0A9HPm2q90xd2o0NhGRw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-ratio=&quot;1&quot; data-w=&quot;145&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.4 马果果又病啦&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;马果果&lt;/strong&gt;毕竟年事已高，又又又生病了，办事处只能含泪关门，但是和上一次&lt;strong&gt;马小腾&lt;/strong&gt;停电不同，这次是作为 Leader 的&lt;strong&gt;马果果&lt;/strong&gt;停止服务了，因为之前定下的规定，整个办事处集群必须得有一个 Leader。现在&lt;strong&gt;马小云&lt;/strong&gt;和&lt;strong&gt;马小腾&lt;/strong&gt;发现 Leader 联系不上了，说明 Leader 无法服务了，他们就知道必须选出一个新的 Leader。于是纷纷将自己的状态都修改为 LOOKING 状态，并且再次把候选人选为自己，重新向其他仍然可以提供服务的办事处广播自己的选票（当前这个场景就是互相发选票了）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMNODI3zmERvmnRrthyMYRB4aYZWZQPtd2VH87Cmsg5ypSmr8uKO8HbfwzytEmVFO3gLesicDk0wHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.4718934911242604&quot; data-w=&quot;676&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论谁收到选票后经过比较后都会知道是&lt;strong&gt;马小腾&lt;/strong&gt;胜出&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;e:1      ==  e:1&lt;br/&gt;z:77      &amp;lt;   z:80&lt;br/&gt;l: 马小云(56)     l: 马小腾(49)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;马小云&lt;/strong&gt;会把自己的候选人修改为&lt;strong&gt;马小腾&lt;/strong&gt;之后重新再把自己的选票发出去，现在&lt;strong&gt;马小腾&lt;/strong&gt;就获得了 2 票通过，同时也满足大于整个办事处集群半数以上，所以&lt;strong&gt;马小腾&lt;/strong&gt;和&lt;strong&gt;马小云&lt;/strong&gt;各自修改状态为 LEADING 和 FOLLOWING 后，并且会和之前说的一样，把 epoch 加 1 同时清空计数部分，最后重新恢复对村民提供服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而&lt;strong&gt;马果果&lt;/strong&gt;这边病好以后，会重新开张和之前的例子一样也是先从 LOOKING 状态开始，最后会从其他两马那里得知目前的 Leader 是&lt;strong&gt;马小腾&lt;/strong&gt;之后，就会主动和&lt;strong&gt;马小腾&lt;/strong&gt;同步数据并以 Follower 的身份加入到办事处集群中对外提供服务。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.5 招商引资&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;办事处的热火朝天被村委会看在了眼里，心想只有三个办事处就能达到这样的效果，如果有更多的办事处呢？于是和三马商量了下，决定对外招商引入社会资本，让他们自己按照现有模式建立新的办事处，这样村委会不用出一分钱，村民还能获得实在的好处，秒啊！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMNODI3zmERvmnRrthyMYRB7Gvkb6ibwdgkbyaFibg0aibNttNgYMYvP9ZUPHycA9ZbqZI5D3T9mscWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;1&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此举一度引来社会资本的大量关注，但是商量过后，三马又觉得如果过多的引入外部力量势必会削弱自己手中的权力，所以又出了一个规定，三马自封为 Participant 只有他们三个才有资格进行 Leader 的竞选，而引入的社会资本所创建的办事处只能作为 Observer 加入办事处的集群中对外提供只读服务，没有资格竞争 Leader，这样就可以在不增加选举复杂程度的同时，提升整个办事处集群对读请求的吞吐量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要声明当前节点是 Observer，需要在 &lt;code&gt;zoo.cfg&lt;/code&gt; 中先配置 &lt;code&gt;peerType=observer&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时声明的集群信息最后要多加一个 &lt;code&gt;:observer&lt;/code&gt; 用来标识，这样其他节点也会知道当前 myid 为 1 和 2 都是 Observer&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;server.69=maguoguo:2888:3888&lt;br/&gt;server.56=maxiaoyun:2888:3888&lt;br/&gt;server.49=maxiaoteng:2888:3888&lt;br/&gt;server.1=dongdong:2888:3888:observer&lt;br/&gt;server.2=jitaimei:2888:3888:observer&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在 LOOKING 状态的 Observer 一开始的 Leader 候选人也会选自己，但是选票信息被设置成了这样，以&lt;strong&gt;东东&lt;/strong&gt;举例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;e:Long.MIN_VALUE     &lt;br/&gt;z:Long.MIN_VALUE      &lt;br/&gt;l: 东东(1)&lt;br/&gt;LOOKING&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为 epoch 被设置成了最小值所以这个选票等同于形同虚设，可以被直接忽略，并且在三马那里会维护一个 Participant 的列表，如果他们收到了来自 Participant 以外的办事处的选票会直接选择忽略，所以可以说 Observer 的选票对选举结果是完全没有影响的。最终是等待 Participant 之间的选举结果通知，Observer 自身修改状态为 OBSERVING，开始和 Leader 进行同步数据，这点和 Follower 没区别，之后 Observer 和 Follower 会统称为 Learner&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.6 小结&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;竞选 Leader 看的是 epoch、写请求操作数、myid 三个字段，依次比较谁大谁就更有资格成为 Leader&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;获选超过半数以上的办事处正式成为 Leader，修改自己状态为 LEADING&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;其他 Participant 修改为 FOLLOWING，Observer 则修改为 OBSERVING&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果集群中已经存在一个 Leader，其他办事处如果中途加入的话，直接跟随该 Leader 即可&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;还得提一句，如果当前可提供服务的节点已经不足半数以上了，那么这个选举就永远无法选出结果，每个节点都会一直处在 LOOKING 状态，整个办事处集群也就无法对外提供服务了&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三、猿话一下&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;扯蛋扯完了，现在用咱的行话对有一些概念再深入一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我必须要说的是，故事里的三马，为了一定的节目效果，我描述成了三个角色，但是实际中 ZK 服务端是不会做这样的区分的，都是相同的代码，根据不同的配置启动，才有了运行时期 Leader、Follower、Observer 的角色之分，所以更贴近于实际的应该类似于火影里的影分身或者龙珠里的残像拳之类的（好像混入了什么奇怪的东西）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMNODI3zmERvmnRrthyMYRB8ibiaDmRc8oQ8MCY8Df3xeUGYL4Z8VcGCJzqB9xwjpicLZ9cW17cdy10w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6574074074074074&quot; data-w=&quot;540&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我画了下选举的简单流程图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMNODI3zmERvmnRrthyMYRB06UXpO8zLrN3EDU1gY5wicAlofx1jZdcCrfHEM3v17myBic1tJibpu8oA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.5885650224215246&quot; data-w=&quot;892&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其他地方我基本上都讲过了，这里再讲下红色部分，因为可能一些网络因素，发出去的选票对方却没收到，这个发起重新广播投票就是为了能让对方再重新发一次刚刚的选票。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同监听客户端 2181 端口不同的是，服务端集群之间相互通信，直接使用的是原生的 Socket 并没有使用 NIO 或者是 Netty，因为服务端节点一共就这么几个而且针对每一个其他节点都会启动一个线程去监听，所以直接采用了这种比较原始的并且是阻塞的方式通信，更简单直接，而且假设对方服务不可用了的话， Socket 会直接报错退出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;收发选票也是采用了 ZK 中非常常见的生产者-消费者模式，分别维护了两个阻塞队列，一个对应发送出去的选票，一个对应收到的选票，各自使用一个子线程去轮询该阻塞队列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前的 ZK 是拥有 3 种选举策略的，虽然另外两种之前都是被废弃的状态，不建议使用，但是通过配置文件还是可以强行使用的。不过在最新的 3.6.2 中另两种策略直接从源码中删除了，现在只有一种选举的策略，源码中对应 &lt;code&gt;FastLeaderElection&lt;/code&gt;，另外两个我也没研究过，就不展开了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于服务端之间的心跳检测：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;服务端之间的心跳检测（PING）是由 Leader 发起的，发向所有集群中的其他节点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Follower 收到 PING 后会回一个PING 给 Leader 并带上自己这边的客户端会话数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;而 Leader 收到 Follower 的 PING 后，就会对这些客户端进行会话连接&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于会话相关的知识点留到之后再说～&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;四、总结&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天我们介绍了选举的规则，以及举例了一些选举的场景并加以说明。为了介绍 Follower 或者 Observer 是如何在选举完成之后和 Leader 同步数据的，下一篇我们会先介绍 ZK 是如何进行持久化的，期待一下吧，ZKr～&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMNODI3zmERvmnRrthyMYRBSaBicibF5pNSiaaf1KccGLsV264b3s9FiaJ9ofGcicDwFj1N7WmAaPap4JA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;1&quot; data-w=&quot;450&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;老规矩，如果你有任何对文章中的疑问也可以是建议或者是对 ZK 原理部分的疑问，欢迎来仓库中提问，或者&lt;strong&gt;&lt;span&gt;阅读原文&lt;/span&gt;&lt;/strong&gt;来语雀话题讨论。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;地址：&lt;span&gt;https://github.com/HelloGitHub-Team/HelloZooKeeper&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>128da69cb42848cc7d1617b450b171a6</guid>
<title>TCP/IP 常见攻击手段</title>
<link>https://toutiao.io/k/gqpcukq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;blockquote&gt;&lt;p&gt;这一篇主要和大家一起学习回顾关于 &lt;strong&gt;TCP/IP&lt;/strong&gt; 的常见攻击，至少有一个基本的认识。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.8035470668485676&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WUrZckMPh54ibk9Dxib1ZNwvvdnEWbHsIw6BQa4k59ZoKHN1qVzfCj37eMgk30wJoI9gYHicALeBJEr2Xvf3xsgEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1466&quot; title=&quot;在这里插入图片描述&quot;/&gt;&lt;figcaption&gt;前言&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;&lt;span&gt;1 IP欺骗&lt;/span&gt;&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;IP是什么？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;在网络中，所有的设备都会分配一个地址。这个地址就仿佛小蓝的家地址「&lt;strong&gt;多少号多少室&lt;/strong&gt;」，这个号就是分配给整个子网的，「&lt;strong&gt;室&lt;/strong&gt;」对应的号码即分配给子网中计算机的，这就是网络中的地址。「号」对应的号码为网络号，「&lt;strong&gt;室&lt;/strong&gt;」对应的号码为主机号，这个地址的整体就是&lt;strong&gt;IP地址&lt;/strong&gt;。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;通过IP地址我们能知道什么？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;通过 IP 地址，我们就可以判断访问对象服务器的位置，从而将消息发送到服务器。一般发送者发出的消息首先经过子网的集线器，转发到最近的路由器，然后根据路由位置访问下一个路由器的位置，直到终点。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;IP头部格式&lt;/p&gt;&lt;/blockquote&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3762993762993763&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WUrZckMPh54ibk9Dxib1ZNwvvdnEWbHsIwoRsXoRq5q3nxJO0epRTGbFWfzjurvqJfECS0QugIHs6AYFkn3DJkbw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;962&quot; title=&quot;IP头部格式&quot;/&gt;&lt;figcaption&gt;IP头部格式&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote&gt;&lt;p&gt;IP欺骗技术&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;骗呗，拐骗，诱骗！&lt;/p&gt;&lt;p&gt;IP 欺骗技术就是&lt;strong&gt;伪造&lt;/strong&gt;某台主机的 IP 地址的技术。通过 IP 地址的伪装使得某台主机能够&lt;strong&gt;伪装&lt;/strong&gt;另外的一台主机，而这台主机往往具有某种特权或者被另外的主机所信任。&lt;/p&gt;&lt;p&gt;假设现在有一个合法用户 &lt;strong&gt;(1.1.1.1)&lt;/strong&gt; 已经同服务器建立正常的连接，攻击者构造攻击的 TCP 数据，伪装自己的 IP 为 &lt;strong&gt;1.1.1.1&lt;/strong&gt;，并向服务器发送一个带有 RSI 位的 TCP 数据段。服务器接收到这样的数据后，认为从 &lt;strong&gt;1.1.1.1&lt;/strong&gt; 发送的连接有错误，就会清空缓冲区中建立好的连接。&lt;/p&gt;&lt;p&gt;这时，如果合法用户 &lt;strong&gt;1.1.1.1&lt;/strong&gt; 再发送合法数据，服务器就已经没有这样的连接了，该用户就必须重新开始建立连接。攻击时，伪造大量的IP地址，向目标发送 RST 数据，使服务器不对合法用户服务。虽然IP地址欺骗攻击有着相当难度，但我们应该清醒地意识到，这种攻击非常广泛，入侵往往从这种攻击开始。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2 SYN Flooding&lt;/span&gt;&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;SYN Flooding 简介&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;拒绝服务攻击（DDoS）从 1970 年出现直到今天都依然在作祟，并给全球范围内的各大组织带来了不可估量的损失。&lt;strong&gt;SYN Flood &lt;/strong&gt;是互联网上最经典的 DDoS 攻击方式之一，最早出现于 1999 年左右，雅虎是当时最著名的受害者。&lt;strong&gt;SYN Flood &lt;/strong&gt;攻击利用了 &lt;strong&gt;TCP&lt;/strong&gt; 三次握手的缺陷，能够以较小代价使目标服务器无法响应，且难以追查。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;SYN  flood&lt;/strong&gt; 是一种常见的 &lt;strong&gt;DOS&lt;/strong&gt;（denial of service拒绝服务）和 &lt;strong&gt;DDos&lt;/strong&gt; (distributed denial of serivce 分布式拒绝服务）攻击方式。这是一种使用 TCP 协议缺陷，发送大量的&lt;strong&gt;伪造的 TCP 连接请求&lt;/strong&gt;，使得被攻击方 CPU 或内存资源耗尽，最终导致被攻击方无法提供正常的服务。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;TCP SYN Flood 攻击原理&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;TCP  SYN Flood&lt;/strong&gt; 攻击利用的是 &lt;strong&gt;TCP&lt;/strong&gt; 的三次握手（&lt;strong&gt;SYN -&amp;gt; SYN/ACK -&amp;gt; ACK&lt;/strong&gt;），假设连接发起方是A，连接接受方是 B，即 B 在某个端口（&lt;strong&gt;Port&lt;/strong&gt;）上监听 A 发出的连接请求，过程如下图所示，左边是 A，右边是 B。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4382062146892655&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WUrZckMPh54ibk9Dxib1ZNwvvdnEWbHsIwgqYz9sHCvK9I6K6dfyibJfRdauAMpvHoDl0vM3RsvsXNOtnnXABrFuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;5664&quot; title=&quot;在这里插入图片描述&quot;/&gt;&lt;/figure&gt;&lt;p&gt;A 首先发送 &lt;strong&gt;SYN&lt;/strong&gt;（Synchronization）消息给 B，要求 B 做好接收数据的准备；B 收到后反馈 &lt;strong&gt;SYN-ACK&lt;/strong&gt;（Synchronization-Acknowledgement） 消息给 A，这个消息的目的有两个：&lt;/p&gt;&lt;p&gt;大家注意到没有，最关键的一点在于双方是否都按对方的要求进入了&lt;strong&gt;可以接收消息&lt;/strong&gt;的状态。而这个状态的确认主要是双方将要使用的&lt;strong&gt;消息序号(&lt;/strong&gt;SquenceNum)，&lt;strong&gt;TCP&lt;/strong&gt; 为保证消息按发送顺序抵达接收方的上层应用，需要用&lt;strong&gt;消息序号&lt;/strong&gt;来标记消息的发送先后顺序的。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;TCP &lt;/strong&gt;是「&lt;strong&gt;双工&lt;/strong&gt;」(Duplex)连接，同时支持双向通信，也就是双方同时可向对方发送消息，其中 &lt;strong&gt;SYN&lt;/strong&gt; 和 &lt;strong&gt;SYN-ACK&lt;/strong&gt; 消息开启了 A→B 的单向通信通道（B 获知了 A 的消息序号）；&lt;strong&gt;SYN-ACK&lt;/strong&gt; 和 &lt;strong&gt;ACK&lt;/strong&gt; 消息开启了 B→A 单向通信通道（A 获知了 B 的消息序号）。&lt;/p&gt;&lt;p&gt;上面讨论的是双方在诚实守信，正常情况下的通信。&lt;/p&gt;&lt;p&gt;但实际情况是，网络可能不稳定会丢包，使握手消息不能抵达对方，也可能是对方故意不按规矩来，故意延迟或不发送握手确认消息。&lt;/p&gt;&lt;p&gt;假设  B 通过某 &lt;strong&gt;TCP&lt;/strong&gt; 端口提供服务，B 在收到 A 的 &lt;strong&gt;SYN&lt;/strong&gt; 消息时，积极地反馈了 &lt;strong&gt;SYN-ACK&lt;/strong&gt; 消息，使连接进入&lt;strong&gt;半开状态&lt;/strong&gt;，因为 B 不确定自己发给 A 的 &lt;strong&gt;SYN-ACK&lt;/strong&gt; 消息或 A 反馈的 ACK 消息是否会丢在半路，所以会给每个待完成的半开连接都设一个 &lt;strong&gt;Timer&lt;/strong&gt;，如果超过时间还没有收到 A 的 &lt;strong&gt;ACK&lt;/strong&gt; 消息，则重新发送一次 &lt;strong&gt;SYN-ACK&lt;/strong&gt; 消息给 A，直到重试超过一定次数时才会放弃。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4822631342613381&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WUrZckMPh54ibk9Dxib1ZNwvvdnEWbHsIwX7L1SmkpPysDtuHJFGwTfS2zHzs3iaTnf8oI8AmW41j5YyaXPs7VzcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;4454&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;B 为帮助 A 能顺利连接，需要&lt;strong&gt;分配内核资源&lt;/strong&gt;维护半开连接，那么当 B 面临海量的连接 A 时，如上图所示，&lt;strong&gt;SYN Flood&lt;/strong&gt; 攻击就形成了。攻击方 A 可以控制肉鸡向 B 发送大量 SYN 消息但不响应 ACK 消息，或者干脆伪造 SYN 消息中的 &lt;strong&gt;Source IP&lt;/strong&gt;，使 B 反馈的 &lt;strong&gt;SYN-ACK&lt;/strong&gt; 消息石沉大海，导致 B 被大量注定不能完成的半开连接占据，直到资源耗尽，停止响应正常的连接请求。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;3 UDP Flooding&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;UDP&lt;/strong&gt; 洪泛也是一种拒绝服务攻击，将大量的用户数据报协议（&lt;strong&gt;UDP&lt;/strong&gt;）数据包发送到目标服务器，目的是压倒该设备的处理和响应能力。防火墙保护目标服务器也可能因 &lt;strong&gt;UDP&lt;/strong&gt; 泛滥而耗尽，从而导致对合法流量的拒绝服务。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;UDP Flood 攻击如何工作？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;UDP Flood&lt;/strong&gt; 主要通过利用服务器响应发送到其中一个端口的 &lt;strong&gt;UDP&lt;/strong&gt; 数据包所采取的步骤。在正常情况下，当服务器在特定端口接收到 &lt;strong&gt;UDP&lt;/strong&gt; 数据包时，会经过两个步骤：&lt;/p&gt;&lt;p&gt;举个例子。假设今天要联系酒店的小蓝，酒店客服接到电话后先查看房间的列表来确保小蓝在客房内，随后转接给小蓝。&lt;/p&gt;&lt;p&gt;首先，接待员接收到呼叫者要求连接到特定房间的电话。接待员然后需要查看所有房间的清单，以确保客人在房间中可用，并愿意接听电话。碰巧的是，此时如果突然间所有的电话线同时亮起来，那么他们就会很快变得不堪重负了。&lt;/p&gt;&lt;p&gt;当服务器接收到每个新的 &lt;strong&gt;UDP&lt;/strong&gt; 数据包时，它将通过步骤来处理请求，并利用该过程中的服务器资源。发送 &lt;strong&gt;UDP&lt;/strong&gt; 报文时，每个报文将包含源设备的 &lt;strong&gt;IP&lt;/strong&gt; 地址。在这种类型的 &lt;strong&gt;DDoS&lt;/strong&gt; 攻击期间，攻击者通常不会使用自己的真实 &lt;strong&gt;IP&lt;/strong&gt; 地址，而是会欺骗 &lt;strong&gt;UDP&lt;/strong&gt; 数据包的源 &lt;strong&gt;IP&lt;/strong&gt; 地址，从而阻止攻击者的真实位置被暴露并潜在地饱和来自目标的响应数据包服务器。&lt;/p&gt;&lt;p&gt;由于目标服务器利用资源检查并响应每个接收到的 &lt;strong&gt;UDP&lt;/strong&gt; 数据包的结果，当接收到大量 &lt;strong&gt;UDP&lt;/strong&gt; 数据包时，目标的资源可能会迅速耗尽，导致对正常流量的拒绝服务。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5101032779524023&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WUrZckMPh54ibk9Dxib1ZNwvvdnEWbHsIwyIosXYguAxw5ibDk0icbFqRfJpVPvjMEZ9GTNcTqicTVtEcEicUPS5SKPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;4454&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;blockquote&gt;&lt;p&gt;如何缓解 &lt;strong&gt;UDP &lt;/strong&gt;洪水攻击？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;大多数操作系统部分限制了 &lt;strong&gt;ICMP&lt;/strong&gt; 报文的响应速率，以中断需要 ICMP 响应的 &lt;strong&gt;DDoS&lt;/strong&gt; 攻击。这种缓解的一个缺点是在攻击过程中，合法的数据包也可能被过滤。如果 &lt;strong&gt;UDP Flood&lt;/strong&gt; 的容量足够高以使目标服务器的防火墙的状态表饱和，则在服务器级别发生的任何缓解都将不足以应对目标设备上游的瓶颈。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;4 TCP 重置攻击&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;在 &lt;strong&gt;TCP&lt;/strong&gt; 重置攻击中，攻击者通过向通信的一方或双方发送伪造的消息，告诉它们立即断开连接，从而使通信双方连接中断。正常情况下，如果客户端发现到达的报文段对于相关连接而言是不正确的，&lt;strong&gt;TCP&lt;/strong&gt; 就会发送一个重置报文段，从而导致 &lt;strong&gt;TCP&lt;/strong&gt; 连接的快速拆卸。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;TCP&lt;/strong&gt; 重置攻击利用这一机制，通过向通信方发送伪造的重置报文段，欺骗通信双方提前关闭 TCP 连接。如果伪造的重置报文段完全逼真，接收者就会认为它有效，并关闭 &lt;strong&gt;TCP&lt;/strong&gt; 连接，防止连接被用来进一步交换信息。服务端可以创建一个新的 &lt;strong&gt;TCP&lt;/strong&gt; 连接来恢复通信，但仍然可能会被攻击者重置连接。万幸的是，攻击者需要一定的时间来组装和发送伪造的报文，所以一般情况下这种攻击只对长连接有杀伤力，对于短连接而言，你还没攻击呢，人家已经完成了信息交换。&lt;/p&gt;&lt;p&gt;从某种意义上来说，伪造 &lt;strong&gt;TCP&lt;/strong&gt; 报文段是很容易的，因为 &lt;strong&gt;TCP/IP&lt;/strong&gt; 都没有任何内置的方法来验证服务端的身份。有些特殊的 IP 扩展协议（例如 &lt;code&gt;IPSec&lt;/code&gt;）确实可以验证身份，但并没有被广泛使用。客户端只能接收报文段，并在可能的情况下使用更高级别的协议（如 &lt;code&gt;TLS&lt;/code&gt;）来验证服务端的身份。但这个方法对 &lt;strong&gt;TCP&lt;/strong&gt; 重置包并不适用，因为 &lt;strong&gt;TCP&lt;/strong&gt; 重置包是 &lt;strong&gt;TCP&lt;/strong&gt; 协议本身的一部分，无法使用更高级别的协议进行验证。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;5. 模拟攻击&lt;/span&gt;&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;以下实验是在 &lt;code&gt;OSX&lt;/code&gt; 系统中完成的，其他系统请自行测试。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;现在来总结一下伪造一个 &lt;strong&gt;TCP&lt;/strong&gt; 重置报文要做哪些事情：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;嗅探通信双方的交换信息。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;截获一个 &lt;code&gt;ACK&lt;/code&gt; 标志位置为 1 的报文段，并读取其 &lt;code&gt;ACK&lt;/code&gt; 号。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;伪造一个 TCP 重置报文段（&lt;code&gt;RST&lt;/code&gt; 标志位置为 1），其序列号等于上面截获的报文的 &lt;code&gt;ACK&lt;/code&gt; 号。这只是理想情况下的方案，假设信息交换的速度不是很快。大多数情况下为了增加成功率，可以连续发送序列号不同的重置报文。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;将伪造的重置报文发送给通信的一方或双方，使其中断连接。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;为了实验简单，我们可以使用本地计算机通过 &lt;code&gt;localhost&lt;/code&gt; 与自己通信，然后对自己进行 TCP 重置攻击。需要以下几个步骤：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;在两个终端之间建立一个 TCP 连接。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;编写一个能嗅探通信双方数据的攻击程序。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;修改攻击程序，伪造并发送重置报文。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;下面正式开始实验。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;建立 TCP 连接&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;可以使用 netcat 工具来建立 TCP 连接，这个工具很多操作系统都预装了。打开第一个终端窗口，运行以下命令：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; nc -nvl 8000&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个命令会启动一个 TCP 服务，监听端口为 &lt;code&gt;8000&lt;/code&gt;。接着再打开第二个终端窗口，运行以下命令：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; nc 127.0.0.1 8000&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该命令会尝试与上面的服务建立连接，在其中一个窗口输入一些字符，就会通过 TCP 连接发送给另一个窗口并打印出来。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.46083788706739526&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/WUrZckMPh54ibk9Dxib1ZNwvvdnEWbHsIwofraoxJ9CpicTG5yBHVN3IcvW1TuP5Mte5yr8Ng3msVaBNnic1e9YkJA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;549&quot; title=&quot;img&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote&gt;&lt;p&gt;嗅探流量&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;编写一个攻击程序，使用 Python 网络库 &lt;code&gt;scapy&lt;/code&gt; 来读取两个终端窗口之间交换的数据，并将其打印到终端上。代码的核心是调用 &lt;code&gt;scapy&lt;/code&gt; 的嗅探方法：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.9457013574660633&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WUrZckMPh54ibk9Dxib1ZNwvvdnEWbHsIw9bofnrQ1sSSV1kBDy0Fxibofx9cMdGvhmMaWptdGuSj0zibQREjrvFxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;663&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这段代码告诉 &lt;code&gt;scapy&lt;/code&gt; 在 &lt;code&gt;lo0&lt;/code&gt; 网络接口上嗅探数据包，并记录所有 TCP 连接的详细信息。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;iface&lt;/strong&gt; : 告诉 scapy 在 &lt;code&gt;lo0&lt;/code&gt;（localhost）网络接口上进行监听。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;lfilter&lt;/strong&gt; : 这是个过滤器，告诉 scapy 忽略所有不属于指定的 TCP 连接（通信双方皆为 &lt;code&gt;localhost&lt;/code&gt;，且端口号为 &lt;code&gt;8000&lt;/code&gt;）的数据包。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;prn&lt;/strong&gt; : scapy 通过这个函数来操作所有符合 &lt;code&gt;lfilter&lt;/code&gt; 规则的数据包。上面的例子只是将数据包打印到终端，下文将会修改函数来伪造重置报文。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;count&lt;/strong&gt; : scapy 函数返回之前需要嗅探的数据包数量。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;&lt;p&gt;发送伪造的重置报文&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;下面开始修改程序，发送伪造的 TCP 重置报文来进行 TCP 重置攻击。根据上面的解读，只需要修改 prn 函数就行了，让其检查数据包，提取必要参数，并利用这些参数来伪造 TCP 重置报文并发送。&lt;/p&gt;&lt;p&gt;例如，假设该程序截获了一个从（&lt;code&gt;src_ip&lt;/code&gt;, &lt;code&gt;src_port&lt;/code&gt;）发往 （&lt;code&gt;dst_ip&lt;/code&gt;, &lt;code&gt;dst_port&lt;/code&gt;）的报文段，该报文段的 ACK 标志位已置为 1，ACK 号为 &lt;code&gt;100,000&lt;/code&gt;。攻击程序接下来要做的是：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;由于伪造的数据包是对截获的数据包的响应，所以伪造数据包的源 &lt;code&gt;IP/Port&lt;/code&gt; 应该是截获数据包的目的 &lt;code&gt;IP/Port&lt;/code&gt;，反之亦然。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;将伪造数据包的 &lt;code&gt;RST&lt;/code&gt; 标志位置为 1，以表示这是一个重置报文。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;将伪造数据包的序列号设置为截获数据包的 ACK 号，因为这是发送方期望收到的下一个序列号。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;调用 &lt;code&gt;scapy&lt;/code&gt; 的 &lt;code&gt;send&lt;/code&gt; 方法，将伪造的数据包发送给截获数据包的发送方。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;对于我的程序而言，只需将这一行取消注释，并注释这一行的上面一行，就可以全面攻击了。按照步骤 1 的方法设置 TCP 连接，打开第三个窗口运行攻击程序，然后在 TCP 连接的其中一个终端输入一些字符串，你会发现 TCP 连接被中断了！&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;进一步实验&lt;/p&gt;&lt;/blockquote&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;可以继续使用攻击程序进行实验，将伪造数据包的序列号加减 1 看看会发生什么，是不是确实需要和截获数据包的 &lt;code&gt;ACK&lt;/code&gt; 号完全相同。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;打开 &lt;code&gt;Wireshark&lt;/code&gt;，监听 lo0 网络接口，并使用过滤器 &lt;code&gt;ip.src == 127.0.0.1 &amp;amp;amp;&amp;amp;amp; ip.dst == 127.0.0.1 &amp;amp;amp;&amp;amp;amp; tcp.port == 8000&lt;/code&gt; 来过滤无关数据。你可以看到 TCP 连接的所有细节。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在连接上更快速地发送数据流，使攻击更难执行。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;&lt;span&gt;6 中间人攻击&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;猪八戒要向小蓝表白，于是写了一封信给小蓝，结果第三者小黑拦截到了这封信，把这封信进行了篡改，于是乎在他们之间进行搞破坏行动。这个马文才就是中间人，实施的就是中间人攻击。好我们继续聊聊什么是中间人攻击。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;什么是中间人&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;中间人攻击英文名叫 Man-in-the-MiddleAttack，简称「MITM攻击」。指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。我们画一张图：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.48881932021466906&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WUrZckMPh54ibk9Dxib1ZNwvvdnEWbHsIwiaZADBplJPnIicicsEHmbdx9TQe3HT7LTxW4FibfN7aWiaHUr5bv1IHAx9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2236&quot; title=&quot;中间人&quot;/&gt;&lt;figcaption&gt;中间人&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;从这张图可以看到，中间人其实就是攻击者。通过这种原理，有很多实现的用途，比如说，你在手机上浏览不健康网站的时候，手机就会提示你，此网站可能含有病毒，是否继续访问还是做其他的操作等等。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;中间人攻击的原理&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;举个例子，我和公司签了一份劳动合同，双方各执一份合同。不晓得哪个可能改了合同内容，不知道真假了，怎么搞？只好找专业的机构来鉴定，自然就要花钱。&lt;/p&gt;&lt;p&gt;在安全领域有句话：&lt;strong&gt;我们没有办法杜绝网络犯罪，只好想办法提高网络犯罪的成本&lt;/strong&gt;。既然没法杜绝这种情况，那我们就想办法提高作案的成本，今天我们就简单了解下基本的网络安全知识，也是面试中的高频面试题了。&lt;/p&gt;&lt;p&gt;为了避免双方说活不算数的情况，双方引入第三家机构，将合同原文给可信任的第三方机构，只要这个机构不监守自盗，合同就相对安全。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;如果第三方机构内部不严格或容易出现纰漏&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;虽然我们将合同原文给第三方机构了，为了防止内部人员的更改，需要采取什么措施呢？&lt;/p&gt;&lt;p&gt;一种可行的办法是引入摘要算法，即合同和摘要一起。为了简单地理解摘要。大家可以想象这个摘要为一个函数，这个函数对原文进行了加密，会产生一个唯一的散列值，一旦原文发生一点点变化，那么这个散列值将会变化。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;有哪些常用的摘要算法呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;目前比较常用的加密算法有消息摘要算法和安全散列算法(&lt;strong&gt;SHA&lt;/strong&gt;)。&lt;strong&gt;MD5&lt;/strong&gt; 是将任意长度的文章转化为一个 128 位的散列值，可是在 2004 年，&lt;strong&gt;MD5&lt;/strong&gt; 被证实了容易发生碰撞，即两篇原文产生相同的摘要。这样的话相当于直接给黑客一个后门，轻松伪造摘要。&lt;/p&gt;&lt;p&gt;所以在大部分的情况下都会选择 SHA 算法。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;出现内鬼了怎么办？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;看似很安全的场面了，理论上来说杜绝了篡改合同的做法。主要某个员工同时具有修改合同和摘要的权利，那搞事儿就是时间的问题了，毕竟没哪个系统可以完全地杜绝员工接触敏感信息，除非敏感信息都不存在。所以能不能考虑将合同和摘要分开存储呢？&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;那如何确保员工不会修改合同呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;这确实蛮难的，不过办法总比困难多。我们将合同放在双方手中，摘要放在第三方机构，篡改难度进一步加大。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;那么员工万一和某个用户串通好了呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;看来放在第三方的机构还是不好使，同样存在不小风险。所以还需要寻找新的方案，这就出现了数字签名和证书。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;数字证书和签名&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;同样的，举个例子。Sum 和 Mike 两个人签合同。Sum 首先用 &lt;strong&gt;SHA&lt;/strong&gt; 算法计算合同的摘要，然后用自己私钥将摘要加密，得到数字签名。Sum 将合同原文、签名，以及公钥三者都交给 Mike。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.9778434268833087&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WUrZckMPh54ibk9Dxib1ZNwvvdnEWbHsIw37aPMmCib42lddMz5nwnpCiadEFZOkukX9smhJANMLc4UFPHfbu5xOSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;677&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;如果 Sum 想要证明合同是 Mike 的，那么就要使用 Mike 的公钥，将这个签名解密得到摘要 x，然后 Mike 计算原文的 sha 摘要 Y，随后对比 x 和 y，如果两者相等，就认为数据没有被篡改。&lt;/p&gt;&lt;p&gt;在这样的过程中，Mike 是不能更改 Sum 的合同，因为要修改合同不仅仅要修改原文还要修改摘要，修改摘要需要提供 Mike 的私钥，私钥即 Sum 独有的密码，公钥即 Sum 公布给他人使用的密码。&lt;/p&gt;&lt;p&gt;总之，公钥加密的数据只能私钥可以解密。私钥加密的数据只有公钥可以解密，这就是非对称加密。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;对称与非对称加密&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;隐私保护？不是吓唬大家，信息是透明的兄die，不过尽量去维护个人的隐私吧，今天学习对称加密和非对称加密。&lt;/p&gt;&lt;p&gt;大家先读读这个字&quot;钥&quot;，是读&quot;yao&quot;，我以前也是，其实读&quot;yue&quot;。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;对称加密&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;对称加密，顾名思义，加密方与解密方使用同一钥匙(秘钥)。具体一些就是，发送方通过使用相应的加密算法和秘钥，对将要发送的信息进行加密；对于接收方而言，使用解密算法和相同的秘钥解锁信息，从而有能力阅读信息。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3890020366598778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WUrZckMPh54ibk9Dxib1ZNwvvdnEWbHsIwgmbibusKuJ7XyqoHPhbniaz2G38fn15Y8sXdkfPhr0npLMb4Feibt51LA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1473&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;blockquote&gt;&lt;p&gt;常见的对称加密算法&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;DES 使用的密钥表面上是 64 位的，然而只有其中的 56 位被实际用于算法，其余 8 位可以被用于奇偶校验，并在算法中被丢弃。因此，&lt;strong&gt;DES&lt;/strong&gt; 的有效密钥长度为 56 位，通常称 &lt;strong&gt;DES&lt;/strong&gt; 的密钥长度为 56 位。假设秘钥为 56 位，采用暴力破Jie的方式，其秘钥个数为 2 的 56 次方，那么每纳秒执行一次解密所需要的时间差不多1年的样子。当然，没人这么干。&lt;strong&gt;DES&lt;/strong&gt; 现在已经不是一种安全的加密方法，主要因为它使用的 56 位密钥过短。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.22962962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/WUrZckMPh54ibk9Dxib1ZNwvvdnEWbHsIwGGXlCdAg38r5aibpsv3cCNqGHiava5PQf0nWZkVPFTyctWicbfIOJqrlg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;blockquote&gt;&lt;p&gt;国际数据加密算法(International Data Encryption Algorithm)。秘钥长度 128 位，优点没有专利的限制。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;当 DES 被破解以后，没过多久推出了 &lt;strong&gt;AES&lt;/strong&gt; 算法，提供了三种长度供选择，128 位、192 位和 256，为了保证性能不受太大的影响，选择 128 即可。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;之前几种都是国外的，我们国内自行研究了国密 **SM1 **和 &lt;strong&gt;SM4&lt;/strong&gt;。其中 S 都属于国家标准，算法公开。优点就是国家的大力支持和认可。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;总结下：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4730238393977415&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WUrZckMPh54ibk9Dxib1ZNwvvdnEWbHsIwSKJUqrAIKX3GZyvDR9CbeIJKSRrqLBczRAZwfZugAVWzs6ZE9bwMuw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;797&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;blockquote&gt;&lt;p&gt;非对称算法&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;在对称加密中，发送方与接收方使用相同的秘钥。那么在非对称加密中则是发送方与接收方使用的不同的秘钥。其主要解决的问题是防止在秘钥协商的过程中发生泄漏。比如在对称加密中，小蓝将需要发送的消息加密，然后告诉你密码是 123balala，ok，对于其他人而言，很容易就能劫持到密码是 123balala。那么在非对称的情况下，小蓝告诉所有人密码是 123balala，对于中间人而言，拿到也没用，因为没有私钥。所以，非对称密钥其实主要解决了密钥分发的难题。如下图：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3890020366598778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WUrZckMPh54ibk9Dxib1ZNwvvdnEWbHsIwqrXFic9Gggt8s2ibebQljzB1oXKR2VPfZ73Jrk6wtPnPbPlvmYc8b3GA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1473&quot; title=&quot;非对称算法&quot;/&gt;&lt;figcaption&gt;非对称算法&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote&gt;&lt;p&gt;其实我们经常都在使用非对称加密，比如使用多台服务器搭建大数据平台 hadoop，为了方便多台机器设置免密登录，是不是就会涉及到秘钥分发。再比如搭建 docker 集群也会使用相关非对称加密算法。&lt;/p&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;strong&gt;常见的非对称加密&lt;/strong&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;p&gt;优势是性能比较快，如果想要较高的加密难度，需要很长的秘钥。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;基于椭圆曲线提出。是目前加密强度最高的非对称加密算法。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;同样基于椭圆曲线问题设计。最大优势就是国家认可和大力支持。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;三种对比：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4730238393977415&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WUrZckMPh54ibk9Dxib1ZNwvvdnEWbHsIwhdEO0kXeZwDnJhK2jltZw8J3kVeJcslpdfqf0g7deSBvvAwuObpx7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;797&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;blockquote&gt;&lt;p&gt;散列算法&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;这个大家应该更加熟悉了，比如我们平常使用的 MD5 校验，在很多时候，我并不是拿来进行加密，而是用来获得唯一性 ID。在做系统的过程中，存储用户的各种密码信息，通常都会通过散列算法，最终存储其散列值。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;常见的散列&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;MD5 可以用来生成一个 128 位的消息摘要，它是目前应用比较普遍的散列算法。虽然，因为算法的缺陷，它的唯一性已经被破解了，但是大部分场景下，这并不会构成安全问题。但是，如果不是长度受限（32 个字符），我还是不推荐你继续使用 &lt;strong&gt;MD5&lt;/strong&gt; 的。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;安全散列算法。**SHA **分为 &lt;strong&gt;SHA1&lt;/strong&gt; 和 &lt;strong&gt;SH2&lt;/strong&gt; 两个版本。该算法的思想是接收一段明文，然后以一种不可逆的方式将它转换成一段（通常更小）密文，也可以简单地理解为取一串输入码（称为预映射或信息），并把它们转化为长度较短、位数固定的输出序列即散列值（也称为信息摘要或信息认证代码）的过程。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;国密算法 &lt;strong&gt;SM3&lt;/strong&gt;。加密强度和 SHA-256 差不多。主要是受到国家的支持。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;总结：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4730238393977415&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WUrZckMPh54ibk9Dxib1ZNwvvdnEWbHsIwl4HLPPrRXALx8EREuoMy7xjJiauy5y2DRdI8VV20ffiboIU7nHKCZGQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;797&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;至此，总结下，大部分情况下使用对称加密，具有比较不错的安全性。如果需要分布式进行秘钥分发，考虑非对称。如果不需要可逆计算则散列算法。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;问题还有，此时如果 Sum 否认给过 Mike 的公钥和合同，不久 gg 了。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;所以需要 Sum 说过的话做过的事儿有足够的信誉，这就引入了第三方机构和证书机制。&lt;/p&gt;&lt;p&gt;证书之所以会有信用，是因为证书的签发方拥有信用。所以如果 Sum 想让 Mike 承认自己的公钥，Sum 不会直接将公钥给 Mike ，而是由第三方机构提供含有公钥的证书。如果 Mike 也信任这个机构，法律都认可，那 ok，信任关系成立。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6674057649667405&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WUrZckMPh54ibk9Dxib1ZNwvvdnEWbHsIwmvNGeFcfzeGAlLMyN6cqBCXpRYGrZibFEWFv6ibqYbSIZgIgmuhU08Zg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;902&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;如上图所示，Sum 将自己的申请提交给机构，产生证书的原文。机构用自己的私钥签名 Sum 的申请原文（先根据原文内容计算摘要，再用私钥加密），得到带有签名信息的证书。Mike 拿到带签名信息的证书，通过第三方机构的公钥进行解密，获得 Sum 证书的摘要、证书的原文。有了 Sum 证书的摘要和原文，Mike 就可以进行验签。验签通过，Mike 就可以确认 Sum 的证书的确是第三方机构签发的。&lt;/p&gt;&lt;p&gt;用上面这样一个机制，合同的双方都无法否认合同。这个解决方案的核心在于需要第三方信用服务机构提供信用背书。这里产生了一个最基础的信任链，如果第三方机构的信任崩溃，比如被黑客攻破，那整条信任链条也就断裂了。&lt;/p&gt;&lt;p&gt;为了让这个信任条更加稳固，就需要环环相扣，打造更长的信任链，避免单点信任风险。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4778481012658228&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WUrZckMPh54ibk9Dxib1ZNwvvdnEWbHsIwl9XhNVOOLQhKzkG8hMQklGjqOFlC7P87vmbnzEmtpRUgCWcPJaBiaEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;948&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;上图中，由信誉最好的根证书机构提供根证书，然后根证书机构去签发二级机构的证书；二级机构去签发三级机构的证书；最后由三级机构去签发 Sum 证书。&lt;/p&gt;&lt;p&gt;如果要验证 Sum 证书的合法性，就需要用三级机构证书中的公钥去解密 Sum 证书的数字签名。&lt;/p&gt;&lt;p&gt;如果要验证三级机构证书的合法性，就需要用二级机构的证书去解密三级机构证书的数字签名。&lt;/p&gt;&lt;p&gt;如果要验证二级结构证书的合法性，就需要用根证书去解密。&lt;/p&gt;&lt;p&gt;以上，就构成了一个相对长一些的信任链。如果其中一方想要作弊是非常困难的，除非链条中的所有机构同时联合起来，进行欺诈。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;中间人攻击如何避免?&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;既然知道了中间人攻击的原理也知道了他的危险，现在我们看看如何避免。相信我们都遇到过下面这种状况：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WUrZckMPh54ibk9Dxib1ZNwvvdnEWbHsIw39VibH175nzicsjnImlVDttGjoUfXybibibvrs7JTTSp7ckdtwq8d9DwQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;372&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;出现这个界面的很多情况下，都是遇到了中间人攻击的现象，需要对安全证书进行及时地监测。而且大名鼎鼎的 github 网站，也曾遭遇过中间人攻击：&lt;/p&gt;&lt;p&gt;想要避免中间人攻击的方法目前主要有两个：&lt;/p&gt;&lt;h2&gt;&lt;span&gt;7 DDOS&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;通过上面的描述，好多种攻击都是 &lt;strong&gt;DDOS&lt;/strong&gt; 攻击，所以简单总结下这个攻击相关内容。&lt;/p&gt;&lt;p&gt;其实，像全球互联网各大公司，均遭受过大量的 &lt;strong&gt;DDoS &lt;/strong&gt;攻击。&lt;/p&gt;&lt;p&gt;2018 年，GitHub 在一瞬间遭到高达 1.35Tbps 的带宽攻击。这次 DDoS 攻击几乎可以堪称是互联网有史以来规模最大、威力最大的 DDoS 攻击了。在 GitHub 遭到攻击后，仅仅一周后，DDoS 攻击又开始对 Google、亚马逊甚至 Pornhub 等网站进行了 DDoS 攻击。后续的 DDoS 攻击带宽最高也达到了 1Tbps。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;那 DDoS 攻击究竟是什么？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;DDos 全名 Distributed Denial of Service，翻译成中文就是&lt;strong&gt;分布式拒绝服务&lt;/strong&gt;。指的是处于不同位置的多个攻击者同时向一个或数个目标发动攻击，是一种分布的、协同的大规模攻击方式。单一的 DoS 攻击一般是采用一对一方式的，它利用网络协议和操作系统的一些缺陷，采用&lt;strong&gt;欺骗和伪装&lt;/strong&gt;的策略来进行网络攻击，使网站服务器充斥大量要求回复的信息，消耗网络带宽或系统资源，导致网络或系统不胜负荷以至于瘫痪而停止提供正常的网络服务。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;举个例子&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;我开了一家有五十个座位的重庆火锅店，由于用料上等，童叟无欺。平时门庭若市，生意特别红火，而对面二狗家的火锅店却无人问津。二狗为了对付我，想了一个办法，叫了五十个人来我的火锅店坐着却不点菜，让别的客人无法吃饭。&lt;/p&gt;&lt;p&gt;上面这个例子讲的就是典型的 DDoS 攻击，一般来说是指攻击者利用“肉鸡”对目标网站在较短的时间内发起大量请求，大规模消耗目标网站的主机资源，让它无法正常服务。在线游戏、互联网金融等领域是 DDoS 攻击的高发行业。&lt;/p&gt;&lt;p&gt;攻击方式很多，比如 &lt;strong&gt;ICMP Flood&lt;/strong&gt;、&lt;strong&gt;UDP Flood&lt;/strong&gt;、&lt;strong&gt;NTP Flood&lt;/strong&gt;、&lt;strong&gt;SYN Flood&lt;/strong&gt;、&lt;strong&gt;CC 攻击&lt;/strong&gt;、&lt;strong&gt;DNS Query Flood &lt;/strong&gt;等等。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;SYN Flood 进行 DDoS 攻击的实现原理**&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;SYN Flood&lt;/strong&gt; 是一种利用 &lt;strong&gt;TCP&lt;/strong&gt; 协议缺陷，发送大量伪造的 &lt;strong&gt;TCP&lt;/strong&gt; 连接请求，从而使得被攻击方资源耗尽（CPU 满负荷或内存不足）的攻击方式。&lt;/p&gt;&lt;p&gt;一次正常的建立 &lt;strong&gt;TCP&lt;/strong&gt; 连接，需要三次握手：客户端发送 &lt;strong&gt;SYN&lt;/strong&gt; 报文，服务端收到请求并返回报文表示接受，客户端也返回确认，完成连接。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;SYN Flood&lt;/strong&gt; 就是用户向服务器发送报文后突然死机或掉线，那么服务器在发出应答报文后就无法收到客户端的确认报文（第三次握手无法完成），这时服务器端一般会重试并等待一段时间后再丢弃这个未完成的连接。&lt;/p&gt;&lt;p&gt;一个用户出现异常导致服务器的一个线程等待一会儿并不是大问题，但恶意攻击者大量模拟这种情况，服务器端为了维护数以万计的半连接而消耗非常多的资源，结果往往是无暇理睬客户的正常请求，甚至崩溃。从正常客户的角度看来，网站失去了响应，无法访问。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;如何应对 DDoS 攻击？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;还是拿开的重庆火锅店举例，高防服务器就是我给重庆火锅店增加了两名保安，这两名保安可以保护店铺不受流氓骚扰，并且还会定期在店铺周围巡逻防止流氓骚扰。&lt;/p&gt;&lt;p&gt;高防服务器主要是指能独立硬防御 50Gbps 以上的服务器，能够帮助网站拒绝服务攻击，定期扫描网络主节点等，这东西是不错，就是贵~&lt;/p&gt;&lt;p&gt;面对火锅店里面的流氓，我一怒之下将他们拍照入档，并禁止他们踏入店铺，但是有的时候遇到长得像的人也会禁止他进入店铺。这个就是设置黑名单，此方法秉承的就是“错杀一千，也不放一百”的原则，会封锁正常流量，影响到正常业务。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;DDos&lt;/strong&gt; 清洗，就是我发现客人进店几分钟以后，但是一直不点餐，我就把他踢出店里。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;DDoS&lt;/strong&gt; 清洗会对用户请求数据进行实时监控，及时发现 **DOS **攻击等异常流量，在不影响正常业务开展的情况下清洗掉这些异常流量。&lt;/p&gt;&lt;p&gt;CDN 加速，我们可以这么理解：为了减少流氓骚扰，我干脆将火锅店开到了线上，承接外卖服务，这样流氓找不到店在哪里，也耍不来流氓了。&lt;/p&gt;&lt;p&gt;在现实中，CDN 服务将网站访问流量分配到了各个节点中，这样一方面隐藏网站的真实 IP，另一方面即使遭遇 &lt;strong&gt;DDoS&lt;/strong&gt; 攻击，也可以将流量分散到各个节点中，防止源站崩溃。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;计算机网络涉及的知识点较多，文中也就算是提了一下，更深层次的理解还需要大家去看相应的书籍，感觉看了这一篇，当面试官问 DDOS 或者 TCP 涉及哪些攻击技术知识点的时候，能够回答出来就好了。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a66ea449bececd5f92276cbd98dbf42d</guid>
<title>设计模式：基于容器的分布式系统</title>
<link>https://toutiao.io/k/f9tkx8s</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;20 世纪 80 年代末至 90 年代初，面向对象编程思想给软件开发带来了一轮技术革新，就像润物细无声的春雨那般，向全世界的程序员们快速普及了模块化构建应用程序的方法，一直流行至今。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当下，我们可以看到类似的革新出现在了分布式系统开发，具体特点如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;基于容器的微服务架构体系日益流行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;容器天然隔离的属性非常适合作为分布式系统中的&lt;strong&gt;基本对象&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于面向对象，&lt;strong&gt;四人帮&lt;/strong&gt;基于经验提出和总结了对于一些常见软件设计问题的标准解决方案，其描述了一系列基于接口的模式，可以在各种环境中重用，这被称之为软件设计模式。历史一定程度上来说是重复的，随着这种架构模式的成熟，基于容器的分布式系统的设计模式也就自然而然地浮现了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本篇主要阐述的是&lt;code&gt;Brendan Burns&lt;/code&gt;在基于容器的分布式系统中发现的三种设计模式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;single-container patterns for container management：容器管理之单容器模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;single-node patterns of closely cooperating containers：容器协调之单节点（多容器）模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;multi-node patterns for distributed algorithms：分布式算法之多节点模式&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于容器分布式系统的设计模式会给分布式计算编码带来以下优势：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;最佳实践，给没有经验的程序员带来相对正确的使用方式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;简化开发&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提升系统可靠性&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;模式的价值&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;模式的目的是提供一般建议或结构来指导设计，这样做的好处有以下三点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;站在巨人的肩膀上，对于经验不怎么丰富的开发者，可以通过模式来指引走在正确的道路上，从而少踩坑，提升项目质量&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提供通用的名称和定义，有共同的领域语言进行交流是一件很重要的事情&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;方便识别并构建共享的通用组件&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;单容器模式&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就像对象会定义边界一样，容器为定义接口提供了天然的边界；它不仅可以暴露特定应用的功能，还可以通过钩子函数来管理系统。传统的容器管理接口是极其有限的，如：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些接口只能说满足基础的使用需求，但是就目前的现状来看，更丰富的接口可以为系统开发者与操作者提供更多的功能。鉴于&lt;code&gt;HTTP&lt;/code&gt;和&lt;code&gt;JSON&lt;/code&gt;的普及程度，可以考虑通过容器在特定的节点托管一个&lt;code&gt;Web&lt;/code&gt;服务来实现。这样做的目的是什么，可以从下面两个角度来看待：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;upward：容器可以暴露丰富的应用信息，比如：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;各类监控指标（QPS、应用健康等）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一些开发人员感兴趣的信息如（线程、堆栈、锁、网络消息统计等）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;组件配置、日志等&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;downward：任何开发者在编写软件组件的时候，都可以使用容器原生支持的生命周期接口来进行管控。比如一个集群管理系统通常会给任务分配对应的&lt;strong&gt;优先级&lt;/strong&gt;，高优先级的任务即使在集群被超额订阅的情况下也能保证运行，这种保证是通过逐出已经运行的低优先级任务来实现的，然后这些低优先级任务能否运行取决于后面是否还有资源分配过来；但是这样有个问题就是开发者需要承担一些没必要的复返，比如处理一些优先级比较低的任务被&lt;em&gt;抛弃&lt;/em&gt;的情况。相反，如果在应用程序和管理系统之间定义了正式的生命周期，那么应用程序组件将变得更易于管理，比如&lt;code&gt;k8s&lt;/code&gt;使用&lt;code&gt;Docker&lt;/code&gt; 的&lt;code&gt;graceful deletion&lt;/code&gt;功能，这就允许应用程序通过完成当前任务，把状态写入磁盘等等操作之后再终止，将这个功能扩展一下就可以使使有状态的分布式系统的状态管理更加容易。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;单节点（多容器）模式&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面提到了单容器的接口，我们稍稍延伸一下，对于一个多容器组成的应用，会有怎样的设计模式呢？当然，此时我们仍旧有些限制条件需要讲清楚：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;容器都处于&lt;strong&gt;单节点&lt;/strong&gt;下&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;容器管理系统需要支持将多容器作为原子单元协调编排，这也侧面印证为什么&lt;code&gt;k8s&lt;/code&gt;需要有&lt;code&gt;Pod&lt;/code&gt;这个逻辑概念&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;边车模式（Sidecar pattern）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;扩展和增强现有的应用容器&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前最常见的多容器部署模式就是边车模式，边车模式就是由两个容器组成的单节点模式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;核心是应用程序容器，这个就是应用程序的轴心&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;其次就是边车容器，作用就是改进和增强应用程序容器&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.21986754966887417&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YRBRJvZXcIWrbqGllvorA6OeKorJLEnE04ZW5tCgkNCZibr7GL6lR983Wg8XA8oDe2oAHLP4redpFGjaicgLUicCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;755&quot;/&gt;&lt;figcaption&gt;边车模式&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;边车模式的一般方式如上图所示，可以看到应用程序容器和边车容器共享了许多资源：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们通过下面的例子来看一下边车容器存在的必要性以及好处，图示如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.478515625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YRBRJvZXcIWrbqGllvorA6OeKorJLEnEaXUfH9TkAQVbaRFok1W9bjnnmvicsrQVqUhq7Bk4pMONNsrYvttic48g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;512&quot;/&gt;&lt;figcaption&gt;边车-示例&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中主容器是一个&lt;code&gt;web&lt;/code&gt;服务，而&lt;code&gt;日志处理&lt;/code&gt;边车容器的工作就是收集本地磁盘的服务器日志，并将其流式传输至存储集群，这样做的好处有：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;容器是资源计算和调度的基本单位，所以可以优先配置主&lt;code&gt;Web&lt;/code&gt;服务器的&lt;code&gt;cgroup&lt;/code&gt;使得其处理延时降低，而日志处理容器则在&lt;code&gt;web&lt;/code&gt;服务器空闲时使用&lt;code&gt;cpu&lt;/code&gt;时间片进行日志处理&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将模块化和可重用的组件封装成边车，可达到功能内聚，应用可被划分明确的边界进行解耦（方便接入、测试调试、状态处理等），最重要的是可以被不同主容器作为边车容器复用&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;大使模式（Ambassadors pattern）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;改变和管理应用容器与外部世界的通信方式&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一次看大使模式，很可能会想这不就是另一种形式的边车模式吗？其实不然，首先第一点，大使模式下所有的请求响应信息交换全部是大使容器来完成的，应用程序容器只能和大使容器进行&lt;em&gt;交流&lt;/em&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3556280587275693&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YRBRJvZXcIWrbqGllvorA6OeKorJLEnEFNzSuFne4cp5FIiavepeVskTDibRg0ma21opNN4h7ia8NE6hZiatGLCcxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1226&quot;/&gt;&lt;figcaption&gt;大使模式&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种模式主要利用的特性是&lt;strong&gt;同一&lt;code&gt;Pod&lt;/code&gt;中的容器可以共享相同的&lt;code&gt;localhost&lt;/code&gt;网络接口&lt;/strong&gt;，而且可以从两个角度看大使容器：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;内到外：让我们以访问一个存储区域为例，假设该存储区域的大小不断增长，必须分成更多的子系统。在这种情况下，为了不干预主容器并且必须对所有受影响的服务实施相同的新访问逻辑，创建一个大使容器来调解对存储区域的访问是个不错的选择&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;外到内：让我们设想一下，我们要测试微服务的新版本，可以通过大使容器控制请求量到相关部署&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YRBRJvZXcIWrbqGllvorA6OeKorJLEnEb0qD9cVe3LBEiaxt0bPgszZkSN0xic7FibmQok2UQO3y6OiciapY5Chdj4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;适配器模式（Adapter pattern）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;确保应用程序实现统一的监控接口&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;真实世界的应用程序大概率会有出现下面列出的几种情况：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一部分服务自行开发（可能有新老标准差异），一部分使用开源项目&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务的编写语言多样，日志记录、监控也多样&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设我们需要有效地监控和运维应用程序，这就要求应用程序可以提供统一的通用接口来进行指标收集。这就是适配器发挥作用的场景了，对于不同应用容器提供的不同接口，可以使用适配器适配这种异构性并转化为一致的接口且原有服务代码不需要做任何改动。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2344931921331316&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YRBRJvZXcIWrbqGllvorA6OeKorJLEnEGoFoJLnQkJrpAg5YEoRjhnUsFmX3ZickXJS8SpocbvrKHz6P9QNUWIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1322&quot;/&gt;&lt;figcaption&gt;适配器模式&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主应用程序通过&lt;code&gt;localhost&lt;/code&gt;或者&lt;code&gt;volume&lt;/code&gt;与适配器容器通信，适配器经过一层处理提供统一的输出给外部使用者，一些常用的使用场景如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;监控：适配器将应用程序容器公开的监控接口转换为通用监控系统所期望的接口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;日志：适配器提供统一的日志记录输出&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;多节点模式&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不要将模块化容器局限于单机容器协调上，其实模块化容器还可以使构建协调的多节点分布式应用程序变得更加容易。接下来将描述其中的三种分布式系统模，与前一节中的模式一样，这些模式也需要对 &lt;code&gt;Pod&lt;/code&gt; 这个逻辑概念的支持。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;领导选举模式&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分布式系统中最常见的问题就是领导选举（Leader election）问题，副本被普遍使用在一个组件的多个相同的实例之间共享负载，副本的另一个更加复杂的作用就是使得某一特定副本作为整个部署集的&lt;strong&gt;leader&lt;/strong&gt;，其他副本作为热备（这个区分过程比较复杂），当原本 Leader 宕机时可以快速被选举为新的 Leader，以恢复系统功能。系统甚至可以并行地进行领导者选举，例如多个分片均需要确定领导者。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8437086092715231&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YRBRJvZXcIWrbqGllvorA6OeKorJLEnEGpAtIXFMRAXmzXsXrq5EGpzianpiagEYDCfML3Ef1gF9jWGSvicAZPpvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;755&quot;/&gt;&lt;figcaption&gt;领导选举模式&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图介绍了一个简单的分布式选举的例子：图中三个副本，任何一个副本都有可能成为主副本，首先第一个副本为主，若其不巧发生故障，第二阶段就会通过选举将第三个副本变成主副本，最后，第一个副本回复，重新加入集群，第三副本依旧作为主节点运行调度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在确实有许多类库可以进行领导者选举，但它们通常比较复杂并且难以被正确理解和使用，此外，它们还受到特定编程语言实现的限制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以本部分探讨的就是将领导者选举机制从应用程序中剥离至领导者选举专属容器中，我们可以考虑提供一组领导者选举容器，每个容器都与需要进行领导者选举的应用程序共同调度，这样就可以在这些领导者选举容器之间执行选举。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时，它们可以在&lt;code&gt;localhost&lt;/code&gt;上为需要进行领导者选举的应用程序容器提供一个简化的&lt;code&gt;HTTP API&lt;/code&gt; (例如&lt;code&gt;becomeLeader&lt;/code&gt;、&lt;code&gt;renewLeadership&lt;/code&gt; 等)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些领导者选举容器只需要由这个复杂领域的专家进行一次性构建即可，然后不管应用程序开发人员选择何种编程语言，都可以复用其简化的接口。这种方式代表了软件工程中最好的抽象和封装过程。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;工作队列模式（Work queue pattern）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个简单通用的容器化工作队列图示如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3103975535168196&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YRBRJvZXcIWrbqGllvorA6OeKorJLEnENlSc7R9SazLPRJdSG6EAiaiabPn1xa8ZKS1H1lXDlw7LFeAzaqop5GVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1308&quot;/&gt;&lt;figcaption&gt;工作队列&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最左侧提供了一组需要被执行的工作项，然后工作队列管理容器接受输入工作项，将其分发给多个执行器进行消费，并且多个执行器中间没有任何交互，这样的好处是可以根据实际运行情况增加执行器数量来赢取时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然工作队列和领导者选举一样，是一个研究得很透彻的课题并且有很多框架对它们进行了很好的实现，但这些分布式系统设计模式仍然是可以在面向容器的架构中获益。在以前的系统中，框架将程序限制在单一的语言环境中（如&lt;code&gt;Python&lt;/code&gt;中的&lt;code&gt;Celery&lt;/code&gt;）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于一个容器，由于&lt;code&gt;run()&amp;amp;mount()&lt;/code&gt;接口的实现，使得实现一个通用的工作队列框架变得简单直接，可以将任意的处理代码打包成一个容器，再结合任意数据就构建成了一个完整的工作队列系统。开发完整工作队列所涉及的所有其他工作都可以由通用工作队列框架处理，并且可以被任何有相同需求的系统复用，用户代码集成等细节让我们看看下面的图示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6104129263913824&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YRBRJvZXcIWrbqGllvorA6OeKorJLEnEjdJoicYY6z7y8YAHHJDvfpVicV2A0DibxoFjeR5NqomPNk1Ih1YyaHASw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1114&quot;/&gt;&lt;figcaption&gt;工作队列&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;通用工作队列的图示，可重用框架容器以深灰色显示，而开发人员容器以浅灰色显示。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让我们结合上面的两张图一起看看，在我看来这就是一个从第一张图抽象出用户自定义代码从而形成第二张图的过程，且看我详细列出关键点。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;源容器接口&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户定义的工作项由工作队列管理容器接收，此时涉及到一个论文中没有描述的点就是队列管理容器对于接收的工作项是默认进行了标准定义的，也就是说工作项都是定义好的标准输入。但实际情况并不可能让所有的输入项都有相同的输入标准，必须由一段用户自定义的处理代码来将输入标准化，不知机智的你是否想到了&lt;strong&gt;大使模式&lt;/strong&gt;：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2894333843797856&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YRBRJvZXcIWrbqGllvorA6OeKorJLEnEjAz1a9BTYS9LIh9ibIicZ33cibRTK0V7ib3OicCpvsNy1wR9UasjQicOmUZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1306&quot;/&gt;&lt;figcaption&gt;源容器接口&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;执行器容器接口&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当工作队列管理容器获取了对应的工作项，接下来的工作就是下发给执行器进行处理，具体做法是调用一次性&lt;code&gt;API&lt;/code&gt;触发工作流，并且在工作容器的整个生命周期是不会有其他调用产生的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.28483920367534454&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YRBRJvZXcIWrbqGllvorA6OeKorJLEnEGI5xvyJGdP7DSLyDjBlYxC20behwM4EPibHcXtzUpqxia2mcGVtO6rAw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1306&quot;/&gt;&lt;figcaption&gt;执行器容器接口&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;分散/聚集模式&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后一个我们要着重介绍的设计模式是&lt;strong&gt;分散/收集模式&lt;/strong&gt;（Scatter/gather pattern），首先简单介绍一下这个模式：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;分散/收集模式是一个树形模式，当外部客户端向根节点发送一个初始请求，根节点会将这个请求分发给大量服务器，每个服务器分片均返回部分数据，然后跟节点将这些部分结果组合起来形成一个针对原始请求的完整响应。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于上面这样一个流程，实际上可以抽象出以下几个标准出来：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;分散请求（fanning out the requests）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;收集响应（gathering the responses）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;与客户端交互（interacting with the client）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;...&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述流程的大部分代码都是通用的，就像面向对象编程中一样，我们可以将这个一个个拆分实现并进行容器化。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6944444444444444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YRBRJvZXcIWrbqGllvorA6OeKorJLEnEoibanvr1E5ibVV7iaY4jLeFkawr60fEiaTCM73xW6W3cqoXqicPWSWceb8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1008&quot;/&gt;&lt;figcaption&gt;分散/收集&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;值得一提的是要实现一个分散/收集系统，需要一个用户提供两个容器：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一种容器实现叶子节点计算，该容器执行部分计算并返回相应的结果&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二种容器是合并容器，该容器需要汇总所有叶子容器的计算结果，并组织成一个单一的响应后输出给用户&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;说明&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主体内容来自：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;论文《&lt;span&gt;Design patterns for container-based distributed systems&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;》&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;书籍《&lt;span&gt;Designing Distributed Systems&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;》&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不错的资料：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近一直在了解低代码开发平台相关知识，就是前面提到的&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU4MTA0NDQ0Ng==&amp;amp;mid=2247484213&amp;amp;idx=1&amp;amp;sn=5ba40d14e72342c7db8d96fa8fe34838&amp;amp;chksm=fd4cd284ca3b5b9225907368874ec034f6834ec9ec65af88c30a159438b916e50271cd2959a0&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;一站式机器学习云研发平台&lt;/a&gt;&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;，其中关于资源管理这块离不开&lt;code&gt;k8s&lt;/code&gt;的使用，因此花了不少精力在这上面，不出意外会出一个系列的学习笔记：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且在学习分布式设计模式的同时也对分布式系统产生了一些兴趣，这一块后续会一起好好研究研究。&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU4MTA0NDQ0Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/YRBRJvZXcIXRN22CZKL79AIdgD0dURDpRdEcCAyVqaIszWvibrr0qJ59XRMPXV2tibHa7CoVt5zuHlaYxiajNgEFg/0?wx_fmt=png&quot; data-nickname=&quot;老胡的储物柜&quot; data-alias=&quot;howie_locker&quot; data-signature=&quot;编程、兴趣、生活&quot;/&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;Design patterns for container-based distributed systems: &lt;span&gt;https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/45406.pdf&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;Designing Distributed Systems: &lt;span&gt;https://book.douban.com/subject/34844678/&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;[译] 基于容器的分布式系统设计模式: &lt;span&gt;https://www.cnblogs.com/gaochundong/p/design-patterns-for-container-based-distributed-systems.html&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;一站式机器学习云研发平台: &lt;span&gt;https://www.howie6879.cn/p/%E4%B8%80%E7%AB%99%E5%BC%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%BA%91%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>