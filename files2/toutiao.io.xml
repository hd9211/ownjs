<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>486cd3714c1f3740a96b5486ecdda05f</guid>
<title>Go中fuzzing系统的原理分析</title>
<link>https://toutiao.io/k/24y6zey</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信模糊测试大家已经很熟悉了，还没开始使用的同学可以看看官方的教程 &lt;span&gt;https://go.dev/doc/tutorial/fuzz&lt;/span&gt; 和煎架写的这篇&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUxMDI4MDc1NA==&amp;amp;mid=2247489683&amp;amp;idx=1&amp;amp;sn=487560a95cf325aebc7e9e136513ca56&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;我要提高 Go 程序健壮性，Fuzzing 来了！&lt;/a&gt;。今天小土给大家带来一篇关于模糊测试原理的文章。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文由小土翻译自 &lt;span&gt;Internals of Go&#x27;s new fuzzing system&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;，翻译不当之处，烦请指出。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 1.18很快就要发布了，希望在几周后。这是一个巨大的版本，有很多值得期待的东西，但原生模糊测试在我心中有一个特殊的位置。(当然我是超级偏心的：在我离开谷歌之前，我和Katie Hockman和Roland Shoemaker一起工作，建立了&lt;code&gt;fuzzing&lt;/code&gt;系统）。我想，泛型也很酷，但将模糊测试集成到&lt;code&gt;testing&lt;/code&gt;包和&lt;code&gt;go test&lt;/code&gt;中，将使模糊测试更容易被大家接受，这使得在Go中编写安全、正确的代码更加容易。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于Go的模糊测试系统究竟是如何工作的，目前还没有太多的文章，所以我将在这里谈一谈这个问题。如果你想尝试一下，&lt;span&gt;Getting started with fuzzing&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;是一个不错的教程。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是模糊测试？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Fuzzing是一种测试技术，测试基础设施用随机生成的输入调用你的代码，以检查它是否产生正确的结果或合理的错误。&lt;/strong&gt;模糊测试是对单元测试的补充，在单元测试中，你要测试你的代码在一组静态输入的情况下是否产生了正确的输出。单元测试的局限性在于，你只能用预期的输入进行测试；模糊测试在发现暴露出奇怪行为的意外输入方面非常出色。一个好的模糊测试系统也会对被测试的代码进行分析，因此它可以有效地产生输入，从而扩大代码覆盖面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;模糊测试通常用于检查解析器(parsers)和验证器(validators)&lt;/strong&gt;，特别是用于安全上下文中的任何东西。模糊测试非常善于发现导致安全问题的错误，如二进制编码中的无效长度、被截断的输入、整数溢出、无效的&lt;code&gt;unicode&lt;/code&gt;等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也有其他方法可以使用模糊测试。例如，差分模糊法通过向两个实现提供相同的随机输入并检查输出是否匹配，来验证同一事物的两个实现是否具有相同的行为。你也可以将模糊测试用于UI的 &lt;code&gt;monkey&lt;/code&gt;测试：模糊引擎可以产生随机的敲击、击键和点击，而测试则验证应用程序是否不会crash。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Go中的模糊测试发生了什么&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;模糊测试对Go来说并不陌生。&lt;span&gt;go-fuzz&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;可能是目前使用最广泛的工具，我们在开发原生模糊测试时当然也借鉴了其设计。Go 1.18中的新东西是，模糊处理被直接整合到&lt;code&gt;go test&lt;/code&gt;和&lt;code&gt;testing&lt;/code&gt;包中。其&lt;code&gt;interface&lt;/code&gt;与测试&lt;code&gt;testing.T&lt;/code&gt;的&lt;code&gt;interface&lt;/code&gt;非常相似。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，如果你有一个名为&lt;code&gt;ParseSomething&lt;/code&gt;的函数，你可以写一个像下面这样的模糊测试。这将会对于任何随机输入进行检查，&lt;code&gt;ParseSomething&lt;/code&gt;要么成功，要么返回一个 &lt;code&gt;ParseError&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; parser&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;errors&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;testing&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; seeds = [][]&lt;span&gt;byte&lt;/span&gt;{&lt;br/&gt; &lt;span&gt;nil&lt;/span&gt;,&lt;br/&gt; []&lt;span&gt;byte&lt;/span&gt;(&lt;span&gt;&quot;123&quot;&lt;/span&gt;),&lt;br/&gt; []&lt;span&gt;byte&lt;/span&gt;(&lt;span&gt;&quot;(12)&quot;&lt;/span&gt;),&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;FuzzParseSomething&lt;/span&gt;&lt;span&gt;(f *testing.F)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; _, seed := &lt;span&gt;range&lt;/span&gt; seeds {&lt;br/&gt;  f.Add(seed)&lt;br/&gt; }&lt;br/&gt; f.Fuzz(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(t *testing.T, input []&lt;span&gt;byte&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  err := ParseSomething(input)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; parseErr := (*ParseError)(&lt;span&gt;nil&lt;/span&gt;); !errors.As(err, &amp;amp;parseErr) {&lt;br/&gt;   t.Fatal(err)&lt;br/&gt;  }&lt;br/&gt; })&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当&lt;code&gt;go test&lt;/code&gt;正常运行时（没有&lt;code&gt;-fuzz&lt;/code&gt;参数），&lt;code&gt;FuzzParseSomething&lt;/code&gt;会被当作一个单元测试。提供给&lt;span&gt;`F.Fuzz`&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;的模糊函数被调用，其输入来自种子语料库：用&lt;code&gt;F.Add&lt;/code&gt;注册的输入和从&lt;code&gt;testdata/corpus/FuzzParseSomething&lt;/code&gt;的文件中读取的输入。如果模糊函数&lt;code&gt;panic&lt;/code&gt;或调用&lt;code&gt;T.Fail&lt;/code&gt;，测试就会失败，并且&lt;code&gt;go test&lt;/code&gt;以非零状态退出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过运行带有&lt;code&gt;-fuzz&lt;/code&gt;参数的&lt;code&gt;go test&lt;/code&gt;来启用模糊测试，比如这样。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go &lt;span&gt;test&lt;/span&gt; -fuzz=FuzzParseSomething&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这种模式下，模糊测试系统将以随机生成的输入调用模糊函数，使用种子语料库和缓存语料库的输入作为起点。扩大覆盖范围的输入被最小化并添加到缓存语料库中。产生的导致错误的输入被最小化并添加到种子语料库中，有效地成为新的回归测试用例。以后的&lt;code&gt;go test&lt;/code&gt;运行将失败，直到问题被修复，即使没有启用模糊测试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样，与其他系统相比，这里也没有什么真正的创新。它的优势在于&lt;code&gt;interface&lt;/code&gt;的熟悉度和使用的方便性。编写你的第一个模糊测试很容易，因为模糊测试遵循测试包的惯例。无需让团队中的每个人都去安装和学习一个新工具。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;模糊测试系统是如何工作的？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可能已经知道，&lt;code&gt;go test&lt;/code&gt;为每个被测试的软件包构建一个测试可执行文件，然后运行这些可执行文件可以获得测试和基准结果。模糊测试也遵循这一模式，尽管有一些不同之处。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当&lt;code&gt;go test&lt;/code&gt;以&lt;code&gt;-fuzz&lt;/code&gt;参数调用时，&lt;code&gt;go test&lt;/code&gt;在编译测试可执行文件时增加了覆盖率工具。Go编译器已经有对&lt;span&gt;libFuzzer&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;的检测支持，所以我们复用了它。编译器为每个&lt;span&gt;基本块&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt;添加了一个8位计数器。这个计数器是快速和近似的：它在溢出时被包裹，而且没有跨线程的同步。(我们不得不告诉&lt;code&gt;race&lt;/code&gt;检测器不要抱怨对这些计数器的写入）。计数器数据在运行时被&lt;span&gt;internal/fuzz&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;包使用，大部分模糊逻辑都在这里。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;go test&lt;/code&gt;构建了一个工具化的可执行文件后，它像往常一样运行它。这就是所谓的coordinator过程。这个进程是以大多数传递给&lt;code&gt;go test&lt;/code&gt;的参数启动的，包括&lt;code&gt;-fuzz=pattern&lt;/code&gt;，它用来识别要模糊测试的目标；目前，每个&lt;code&gt;go test&lt;/code&gt;调用只能模糊测试一个目标（ &lt;span&gt;#46312&lt;/span&gt;&lt;sup&gt;[8]&lt;/sup&gt;）。当该目标调用&lt;code&gt;F.Fuzz&lt;/code&gt;时，控制权被传递给&lt;code&gt;fuzz.CoordinateFuzzing&lt;/code&gt;，它初始化了模糊测试系统并开始coordinator事件循环。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;coordinator启动几个woker进程，它们运行相同的测试可执行文件并执行实际的模糊处理。woker是用一个没有记录的命令行标志启动的，并告诉它们是worker。模糊测试必须在不同的进程中进行，这样，如果一个worker进程完全crash，coordinator仍然可以找到并记录导致crash的输入。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7464503042596349&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkYNiaZsfpqZot0LsUiciajNtVFYv0ibdUBXxIhYoDaEs0pUND0lCfxDmC8iaggScvbZCwYE4FlhibWrsQxQAPYawlUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;986&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;coordinator通过一对管道使用临时的基于&lt;code&gt;JSON&lt;/code&gt;的&lt;code&gt;RPC&lt;/code&gt;协议与每个worker进行通信。该协议是非常基础的，因为我们不需要像&lt;code&gt;gRPC&lt;/code&gt;那样复杂的东西，而且我们也不想在标准库中引入任何新东西。每个worker还在一个内存映射的临时文件中保留一些状态，与coordinator共享。大多数情况下，这只是一个迭代计数和随机数生成器的状态。如果worker完全crash，coordinator可以从共享内存中恢复其状态，而无需worker先礼貌地通过管道发送消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在coordinator启动worker之后，它通过向worker发送来自种子语料库和模糊缓存语料库（在 $GOCACHE的一个子目录中）的输入来收集基线覆盖率。每个worker运行其给定的输入，然后报告其覆盖率计数器的快照。coordinator对这些计数器进行粗化，并将其合并为一个综合覆盖率数组中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，coordinator从种子语料库和缓存语料库中发送输入，进行模糊处理：每个worker都得到一个输入和一个基线覆盖率数组的副本。然后，每个worker随机地改变其输入（flipping bits, deleting or inserting bytes,等），并调用模糊函数。为了减少通信开销，每个worker可以在100毫秒内不断变化和调用，而无需coordinator的进一步输入。每次调用后，worker检查是否报告了错误（用&lt;code&gt;T.Fail&lt;/code&gt;）或与基线覆盖率数组相比是否发现了新的覆盖率。如果是这样，worker会立即将 &quot;有趣的 &quot;输入报告给coordinator。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当coordinator收到一个产生新覆盖率的输入时，它将worker的覆盖率与当前的组合覆盖率数组进行比较：有可能另一个worker已经发现了一个提供相同覆盖率的输入。如果是这样，新的输入将被丢弃。如果新的输入确实提供了新的覆盖率，coordinator会将其给一个worker（可能是另一个worker）发送回去进行最小化。最小化就像模糊处理一样，但worker会进行随机变化，以创建一个较小的输入，至少能提供一些新的覆盖范围。较小的输入往往更快，所以值得花时间在前面进行最小化，以使以后的模糊处理过程更快。worker进程在完成最小化后会报告回来，即使它未能找到任何更小的东西。coordinator将最小化的输入添加到缓存的语料库中并继续。稍后，coordinator可能会将最小化的输入发送给worker，以便进一步进行模糊测试。这就是模糊处理系统如何适应寻找新的覆盖范围。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当coordinator收到一个导致错误的输入时，它再次将输入送回给worker进行最小化。在这种情况下，worker尝试找到仍然会导致错误的较小输入，尽管不一定是相同的错误。在输入被最小化后，coordinator将其保存到&lt;code&gt;testdata/corpus/$FuzzTarget&lt;/code&gt;中，优雅地关闭worker进程，然后以非零状态退出。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.076470588235294&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkYNiaZsfpqZot0LsUiciajNtVFYv0ibdUBXahvIqic0zdgA6PgwhtZTCMIKSGhDZMnzmRLWYmTQ8nscoAwytFCaETQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1020&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果worker进程在模糊测试过程中crash，coordinator可以使用发送到worker的输入以及worker的&lt;code&gt;RNG&lt;/code&gt;状态和迭代次数（都留在共享内存中）恢复导致crash的输入。crash的输入通常不会被最小化，因为最小化是一个高度有状态的过程，而每次crash都会破坏这个状态。这在&lt;span&gt;理论上&lt;/span&gt;&lt;sup&gt;[9]&lt;/sup&gt;是可能的，但目前还没有人做到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;模糊处理通常会持续到发现错误，或者用户按Ctrl-C中断进程，或者通过&lt;code&gt;-fuzztime&lt;/code&gt;设置的最后期限。无论中断是传递给coordinator还是worker进程，模糊处理引擎都会优雅地处理它们。例如，如果一个worker在最小化一个导致错误的输入时被打断，coordinator将保存未最小化的输入。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;fuzzing的未来&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我对这个版本感到非常兴奋，尽管我不得不承认，Go的新模糊引擎离达到与其他模糊系统同等的功能和性能还有一段距离。许多改进是可能的，但它已经处于一个可用的状态，而且API很稳定。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以在issue追踪器上找到带有&lt;code&gt;fuzz&lt;/code&gt;标签的 &lt;span&gt;open issues&lt;/span&gt;&lt;sup&gt;[10]&lt;/sup&gt;列表。那些具有 &lt;span&gt;Go1.19&lt;/span&gt;&lt;sup&gt;[11]&lt;/sup&gt;里程碑的问题被认为是最高优先级的，尽管问题可能会根据用户反馈和开发人员带宽重新排序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总之，去试试吧！如果你在自己的代码中发现任何好的bug（或别人的），请将它们添加到Go wiki上的 &lt;span&gt;Fuzzing trophy case&lt;/span&gt;&lt;sup&gt;[12]&lt;/sup&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;Internals of Go&#x27;s new fuzzing system: &lt;span&gt;https://jayconrod.com/posts/123/internals-of-go-s-new-fuzzing-system&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;Getting started with fuzzing: &lt;span&gt;https://go.dev/doc/tutorial/fuzz&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;go-fuzz: &lt;span&gt;https://github.com/dvyukov/go-fuzz&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;&lt;code&gt;F.Fuzz&lt;/code&gt;: &lt;span&gt;https://pkg.go.dev/testing@go1.18beta2#F.Fuzz&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;libFuzzer: &lt;span&gt;https://llvm.org/docs/LibFuzzer.html&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;基本块: &lt;span&gt;https://zh.wikipedia.org/wiki/%E5%9F%BA%E6%9C%AC%E5%A1%8A&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[7]&lt;/span&gt;&lt;p&gt;internal/fuzz: &lt;span&gt;https://pkg.go.dev/internal/fuzz&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[8]&lt;/span&gt;&lt;p&gt;#46312: &lt;span&gt;https://github.com/golang/go/issues/46312&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[9]&lt;/span&gt;&lt;p&gt;理论上: &lt;span&gt;https://github.com/golang/go/issues/48163&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[10]&lt;/span&gt;&lt;p&gt;open issues: &lt;span&gt;https://github.com/golang/go/issues?q=is%3Aissue+is%3Aopen+label%3Afuzz&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[11]&lt;/span&gt;&lt;p&gt;Go1.19: &lt;span&gt;https://github.com/golang/go/issues?q=is%3Aissue+is%3Aopen+label%3Afuzz+milestone%3AGo1.19&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[12]&lt;/span&gt;&lt;p&gt;Fuzzing trophy case: &lt;span&gt;https://github.com/golang/go/wiki/Fuzzing-trophy-case&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d584d1a5acef070f004625fdc74a5bb4</guid>
<title>快手大数据统一安全平台</title>
<link>https://toutiao.io/k/s3vru8f</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/uBQWkS76AOtUrff6ZvT2WmpT9me5ciaOOialxREW672lB6fawqgwP8SNQsIwgqmC97h4Uer3bl0IROvKkyLQ2tSw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;300&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;关注快手大数据&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt; 获取大数据资讯&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4259259&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uBQWkS76AOtUrff6ZvT2WmpT9me5ciaOOXKgkKTk1qovWZiaqxAbCXIS8KPxTbCvRsQyQIgicE7z2gY4y8KmUHPFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;导 读&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;本文主要介绍&lt;strong&gt;快手大数据统一安全平台&lt;/strong&gt;。本文源自马玲玲老师在『&lt;span&gt;&lt;strong&gt;快手大数据｜数据中台技术交流会&lt;/strong&gt;&lt;/span&gt;』上的演讲，相关视频回放可用&lt;strong&gt;快手APP搜索“快手大数据”&lt;/strong&gt;观看。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;本文会分四个部分展开介绍。首先，对相关的背景进行介绍，包括快手大数据安全解决的问题、比较经典的数据安全理论和快手大数据安全遇到的挑战；其次，会重点介绍我们的解决方案，包括具体的落地路径、平台的发展历程和架构；再次，会重点介绍我们平台的一些核心技术；最后，会介绍我们当前取得的进展和未来的规划。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4398148&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uBQWkS76AOtUrff6ZvT2WmpT9me5ciaOOe4TpEqtHxicNgmuJ8c9icKddiblnBmXCtvQx1PxvwpibMoiaSP4OGX7iccxA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;一、背景介绍&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;随着大数据时代的来临，数据是公司的核心竞争力，数据的泄露会给公司带来严重的损害。因此，大数据安全的建设尤为重要和关键。大数据安全其实就是保障大数据资产全生命周期处理的安全性和合规性。那什么是大数据资产呢？在大数据场景下，任何的数据实体都可以叫做大数据资产。比如，大家比较熟悉的HIVE表，以及应用系统的数据集、报表等。数据的生命周期包括从数据采集、数据传输、数据存储、数据处理、数据应用到数据销毁的全过程。大数据安全就是要保证全生命周期的各个过程数据处理的安全性。合规性是需要满足国家的法律法规的要求和公司法务的合规要求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4462963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uBQWkS76AOtUrff6ZvT2WmpT9me5ciaOOhFzdknlAlrNlJwI9WNxbO9wMrfw0UiaPyZsEqFd9iaviaLw8vefrqIibgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;下面我来重点介绍下数据安全的两个经典理论。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第一个经典理论就是&lt;strong&gt;数据安全能力成熟度模型&lt;/strong&gt;，简称DSMM。2019年8月30日，该模型正式成为国标对外发布，并于2020年3月起正式实施。该标准从三个维度全方位介绍了数据安全能力该如何进行建设，适用于作为组织数据安全能力的评估依据或者建设依据。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3842593&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uBQWkS76AOtUrff6ZvT2WmpT9me5ciaOO7TZvVBYsqribBWkg0oKMcUbfNnwftrAUvpSwGUD4xwWlqFz5nG3lU3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;第二个经典理论就是&lt;strong&gt;安全架构5A方法论&lt;/strong&gt;。其中5A包括：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;认证（Authentication）：判断访问主体是谁，解决身份问题；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;授权（Authorization）：授予访问主体允许或者拒绝访问客体的权限；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;访问控制（Access Control）：判断是否有权限的执行者；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;资产保护（Asset Protection）：资产的保密性、完整性和可用性保障；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;可审计（Auditable）：形成可供追溯的操作日志。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4398148&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uBQWkS76AOtUrff6ZvT2WmpT9me5ciaOOq8pLV78cDmKzqvKKVYwETQVWW0qiaOlecdmQjRK6GX5GsMgpVkiaIRZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;以上两个理论对快手大数据安全的体系化建设提供了很大的指导意义。下面我来介绍快手大数据安全建设遇到的挑战：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;系统覆盖度广：快手大数据安全需要对底层的大数据引擎、数据中台工具和数据应用类平台等全链路系统进行安全管控。因此，我们需要提供一个通用的数据安全平台，满足通用的数据安全要求，保证系统的通用性。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数据精细化管控：我们需要支持报表、数据集、指标、维度等应用类资产和库、表、行、列、文件等底层引擎类资产的权限控制；同时还要对资产的读、写等操作进行细粒度的权限控制；还需要与快手特有的多租户体系相结合，实现数据的多级隔离。因此，就要求我们的权限模型足够灵活，满足数据精细化的管控需求。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;业务灵活多变：我们需要满足多种业务线的权限管控需求，也需要满足数据应用类平台灵活多变的业务需求，这就要求我们平台需要具有良好的扩展性。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;性能要求高：我们需要支撑千级的用户、百万资源的亿级规模的权限矩阵，同时还需要满足鉴权毫秒级的延时；还需要支持OLAP每天亿级的查询和HDFS百万级QPS等。因此，要求我们的平台具备高可用和高性能的保障机制。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3796296&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uBQWkS76AOtUrff6ZvT2WmpT9me5ciaOOXdicqOaPL5YNawNfKicnia8UtEpkhL958o3JA0DgXC3QiaeWJaCRbfv9Mw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;二、解决方案&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;下面重点介绍快手大数据安全建设过程中的解决方案。我们通过参考数据安全能力成熟度模型，从组织保障、流程规范和平台工具三个方面进行体系化的建设。概括来说就是组织制定安全战略和方向，沉淀为统一的流程规范，然后由平台提供工具化支撑并落地。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4231481&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uBQWkS76AOtUrff6ZvT2WmpT9me5ciaOOJej5yyVGhxoPpN0mAQQiaOSFlsPkQFrH9vkv99ffoMgqGFunuibM8yBQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;快手大数据到目前为止经历了四个阶段：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;初始阶段：在2018年，平台还处于原始阶段，权限粒度比较粗糙，平台能力方面只提供了简单的申请和授权的能力，而且功能比较难用，接入系统只覆盖了数据平台部门的部分应用类系统。因此，我们开始考虑衍化。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;V1.0（一站式）：在2019年，我们迭代了V1.0版本，引入了全新的权限模型，提供了一站式权限管理的能力，包括申请、审批、授权、清查、回收，同时接入了第一个大数据引擎HIVE。在2019年下半年我们开始与公司安全组共建，成立数据安全工作小组，沉淀了数据权限申请规范、数据分类分级规范等。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;V2.0（精细化）：在2020年，我们迭代了V2.0版本，提供精细化权限管控能力，包括行级权限、多租户数据隔离等，同时提供了认证和全链路审计的能力，也逐步接入了数据中台类的平台。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;V3.0（数据合规）：在2021年，随着快手上市，公司对数据保护的能力要求越来越高，因此我们迭代了V3.0版本，以满足数据合规为目标，提供了字段加解密/脱敏等能力，同时全部覆盖底层的大数据存储引擎。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3990741&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uBQWkS76AOtUrff6ZvT2WmpT9me5ciaOOYgvq50KCmg0BR9mlvLeAFSfS6shgknPVxGutbHmHXETGkdicYAD4q6g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;下面我来介绍下大数据统一安全平台的整体架构。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;应用层：覆盖了数据应用、数据中台和大数据引擎全链路系统/组件；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;接口层：提供了统一的REST和RPC API；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;服务层：可以归纳为四个统一、一个Plugin和一个系统保障。四个统一分别为：统一服务层提供通用的认证、鉴权、查询、审计等服务；统一计算层提供模型和规则的计算；统一存储层提供缓存管理、缓存数据加载及版本管理等；统一接入层负责平台管控资源的接入、账号信息的同步等。一个Plugin是指每个大数据引擎都会引入大数据安全的plugin组件，满足各个引擎自身的特点，比如高QPS、低延时等；一个系统保障是指通过采用监控告警、降级容错、预案演练、限流等一系列措施保障系统的高可用，采用多级缓存等保障系统的高性能等。在服务层，我们还会依赖公司的外部系统，比如依赖流程中心提供审批的能力、与安全组共建审计、与生产管理和组织架构同步账号信息等。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;存储引擎层：我们使用了三个存储引擎。我们的数据主要存储在MYSQL中，热点数据存储在REDIS中，MYSQL中的数据会定期同步至HIVE，以作冷备份和构建我们平台的离线数仓。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4527778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uBQWkS76AOtUrff6ZvT2WmpT9me5ciaOOWfq1GO0GbHGgInznXqZa3hrZAib5lHsSATvHFGaJ6SnqKZq3siaz5OSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;三、核心技术&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;下面对平台的核心技术做详细介绍，主要包括权限模型抽象、认证服务、鉴权服务、全链路审计和敏感数据保护。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;首先，先介绍我们平台的基石权限模型。经典的权限模型包括ACL模型、RBAC模型、PBAC/ABAC模型。ACL模型是指用户和资源直接建立权限关系；RBAC模型是角色和资源直接建立权限关系，用户通过加入角色获得相应的权限；PBAC/ABAC模型是基于主体、环境或者客体的属性进行权限控制。ACL和RBAC在传统的功能权限场景使用的较多，但是对于数据权限场景，无法表达资源之间复杂的关系。而PBAC/ABAC模型虽然比较灵活，但只有在运行时才知道是否有权限，所以很难进行管理。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;综上，我们通过参考已有的权限模型，并根据快手大数据的场景和需求，自研了一套组合RBAC和PBAC的PRBAC权限模型。该模型以策略为中心，整合了角色、资源、动作和条件四个核心要素。角色支持组合自定义两种类型。大数据场景的资源比较复杂，比如一个报表可以依赖多个数据集，数据集又依赖不同的指标维度，指标维度又可能来自于不同的库、表、行或列。因此大数据资源我们使用URN来进行表示，由公司域、资源域和唯一ID组成，而且资源之间支持继承和虚拟分组的关系。动作支持洞察、生产、读、写等类型。我们使用条件和规则语言来对大数据场景的行列权限进行抽象。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uBQWkS76AOtUrff6ZvT2WmpT9me5ciaOOShhUywo0CHKqwp0sXnjlF9mj2dFH75pm1f1Ngew6Uib2CzXsM06EEOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;认证解决身份的问题，就是证明“我”就是“我”。我们的认证方案在选型的时候，遇到了一些挑战：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;轻量级：快手当前大数据集群的规模比较大，而且已经比较成熟。我们的认证体系需要对当前系统/大数据组件入侵最小，对性能和稳定性影响比较小，原理简单且容易解释；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;本地化：需要与快手大数据的生产组织管理体系相结合，相辅相成；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;易衍化：能够较好的满足快手快速发展的需求，尤其是国际化、大集群等。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们在探索快手大数据认证方案的时候，也对开源的框架做了调研。Kerberos是大数据经典的认证协议，内部实现比较复杂。当集群规模比较大时，Kerberos kdc会面临单点的风险，因此一些公司也逐步的走向了自研。综合来看，我们参考kerberos和业界的情况，自研了一套基于三方的无秘钥传输的统一大数据认证框架。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;完成一次认证操作，需要进行三次网络通信。首先，客户端先与DSC KDC进行通信，完成客户端身份的认证；其次，客户端与DSC KDC进行第二次网络通信获取访问令牌；最后，客户端携带访问令牌访问大数据资源，hadoop server需要与DSC KDC进行通信完成令牌的验证，验证通过之后客户端才可以访问大数据的资源。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;总结下来，我们的认证体系提供了2大能力。第一个能力是账号体系，我们支持三种账号类型，分别为个人、项目组和代理账号，统一使用principal进行表示，使用principal_name/type@realm格式。第二个能力是令牌种类，支持Access Token、Delegate Token和Degrade Token三种。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4175926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uBQWkS76AOtUrff6ZvT2WmpT9me5ciaOOvUxW1XYt1I6BjaCpqC4icsvdW3GHu07GIyKiaNrvkw8myEogZuSSafUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;下面我们再来看看鉴权服务。左图是我们鉴权服务的全景图，可分为两大类：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;应用类&lt;/strong&gt;：每次鉴权会与远程DSC Server进行通信实时完成鉴权操作；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;引擎类&lt;/strong&gt;：我们会给每个引擎组件提供一个plugin，我们会根据引擎的特点在plugin内部选择不同的鉴权方式。比如对于低QPS的引擎，plugin会实时与远程DSC Server进行通信完成鉴权操作，若同时对延时要求比较高，plugin会对鉴权结果增加缓存以做加速。而对于QPS非常高的引擎，比如HDFS，会在plugin本地完成鉴权，而鉴权所需要的数据会定期从远端进行拉取。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;概括下来的话，我们支持两种鉴权模式：本地模式，是指在plugin本地完成鉴权；远程模式，是指请求远端服务完成鉴权。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下图展示了鉴权服务的核心架构。一共分为两个核心模块：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3740741&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uBQWkS76AOtUrff6ZvT2WmpT9me5ciaOOfV3C2Uy9hRunv3RicnejlS64Cy5Zic8G8YmgoQg48rBQbUg3GgfB95Cw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;下面介绍快手大数据全链路审计的建设思路和方案。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;采集层：覆盖了数据应用类平台、数据工具类平台和大数据引擎全链路的系统和组件。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;接入层：通过对全链路系统的操作进行梳理，需要上报的日志可以分为三类：基本元信息的数据上报给元数据服务；鉴权类日志上报给鉴权服务；其它操作类日志直接上报给日志标准化服务。日志标准化服务会对不同类型的操作日志进行统一计算和整合，以统一的标准发送到审计总线。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;存储层：通过消费审计总线，把审计数据存储到ES和OLAP中。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;服务层：提供了策略分析、特征支持和异常审计等能力。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;应用层：给数据安全相关人员提供WEB管理入口。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.412037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uBQWkS76AOtUrff6ZvT2WmpT9me5ciaOOaeGCf2Sf1kCWTlQDYlRqkYclT3qrqib0fqs6MI8w3LNUtS3O3BHMXicQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;敏感数据保护是全链路的能力，需要从数据的采集、加工到应用，全链路的系统进行联动，有些能力还需要嵌入到全链路的系统中。比如打标中台需要具备敏感数据识别能力；数据同步作为数仓的入口，需要具备敏感数据分类及定级的能力；执行引擎需要具备加解密、动态脱敏等；数据开发平台需要对ETL任务做敏感数据使用合规检测；元数据系统负责维护敏感数据的安全元信息等；安全中心提供严格的权限管控能力，并且联动全链路系统进行安全能力的落地。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;概括来说，敏感数据保护支持四大能力：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.412037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uBQWkS76AOtUrff6ZvT2WmpT9me5ciaOOVOibT63ibk5YNTBfL39JUPhzU9ibJUkRDlTQ6JMlACNCYdzFKr3ibWjz0A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;四、成果与规划&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;最后，介绍下快手统一安全平台目前取得的一些成果。平台当前接入30+系统，资源数在千万级，授权数在百万级，日均申请量在千级。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4092593&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uBQWkS76AOtUrff6ZvT2WmpT9me5ciaOOAcrHFeJRicLOfQPriac4gJrXcN2AxbibF638ibmTEXnh902B67rob4fAOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;由于快手大部分的数据资产都是存储在HIVE中。所以，对于HIVE我们做了很多工作，整体可以分为四个关键里程碑：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;关键里程碑1：在2019年12月，HIVE临时查询场景全部开启了权限控制，实现了HIVE权限控制从无到有的过渡；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;关键里程碑2：在2020年7月，为了提升HIVE数据获取的效率，我们做了精简审批流、自动化审批等一系列措施；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;关键里程碑3：在2020年12月，HIVE支持了认证能力，并推动使用方接入；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;关键里程碑4：在2021年6月，我们开始推动HIVE生产场景开启权限控制。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;HIVE支持的关键能力包括行/列/多租户等细粒度权限管控、统一认证、全链路审计、加解密/脱敏等敏感数据保护能力。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3648148&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uBQWkS76AOtUrff6ZvT2WmpT9me5ciaOOHuib0M9SkD4iaYdicogKEyPlJ569XeYViaL49TbkJtXzE4W8XkQpyrTuGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;下面介绍快手大数据安全的未来规划。未来重点会从以下四个方面进行建设：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;大数据引擎安全全覆盖：推动底层引擎的使用方100%接入认证鉴权等安全能力；提供细粒度管控能力；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;增强安全态势感知能力：对数据资产的分布、敏感数据访问行为进行多维度全方位分析，对异常行为进行检测；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;探索隐私增强技术：探索前沿的隐私保护技术，比如联邦学习、安全多方计算等，增强隐私数据保护，真正做到”数据的可用不可见“；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;数据分类分级智能化：通过机器学习算法实现数据的智能化分类，持续提升数据分类分级的准确性。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uBQWkS76AOtUrff6ZvT2WmpT9me5ciaOOpW0feO0huDDjdiccpeYzuQsFkyHUEGGsHBeIfwiaGicnK4Hicib3H9ibricyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;作者简介：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;马玲玲，快手大数据安全方向负责人，具有大数据应用平台建设和服务化平台建设经验，专注于大数据平台架构和大数据安全领域。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9924528&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uBQWkS76AOtUrff6ZvT2WmpT9me5ciaOOBoWSclAjvBhibRfljvhbSwaZicdUZhorAFhVZDCyxQ2sibibddNLqz8dCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;530&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;长按识别二维码关注『快手大数据』&lt;/p&gt;&lt;p&gt;查看交流会回放视频&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;分享、收藏、点赞，给个3连击吧！&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b099ff082b756b5a8bcd8d4708647adc</guid>
<title>闲鱼策略中枢业务扩展模块实现</title>
<link>https://toutiao.io/k/fdv54qp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h2 data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;扩展能力是我们在做平台、中台时都会面临的技术思考。&lt;/span&gt;&lt;span&gt;为了平台能尽可能覆盖更多的业务场景，我们需要设计可扩展，可复用的扩展模块，不断拓宽平台能力的边界。&lt;/span&gt;&lt;span&gt;本文介绍闲鱼策略中枢平台Luxury做业务扩展模块时遇到的问题以及解决思路，希望能为同样做平台扩展模块的读者提供一些启发。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;闲鱼策略中枢Luxury是面向闲鱼全域业务的用户精细化策略运营平台，旨在引导用户认识、参与闲鱼的各业务场景、精准的传递平台价值。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;以下面的红包投放为例，它就是Luxury的一条投放策略投放到客户端上之后的展现形式。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8886925795053003&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1FnlMHA4nLMXowWHest5q0c9uwKrNKIvdDXgYZGKmacclDiaPeB7QUeuJQDw0fEnicOz0LBmicSvd65A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1132&quot;/&gt;&lt;span/&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;一条投放策略包含了：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;规则(策略触发时机)。对应红包例子，触发时机就是用户打开客户端首页时识别有未使用红包&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;触点(投放的素材样式)。对应红包例子，素材样式就是整个Pop大卡片样式&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;钩子(填充触点的动态数据)。对应红包例子，钩子就负责填充pop卡片中的红包金额，和标题文案&lt;/span&gt;&lt;span/&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;其中，钩子的定位是负责对接二三方的接口与服务，为素材投放提供动态数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;现状&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;614&quot; data-backw=&quot;578&quot; data-ratio=&quot;1.0624&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1FnlMHA4nLMXowWHest5q0clG7b2avcVkNkeA1iaew1rJVyucp8iaXr1rM46ylib76aNXwQEH4Bb5skg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1250&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;目标&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;技术方案&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;钩子模块的总体思路是采用适配器模式，抽象出钩子接口层，二三方服务可以通过实现接口来接入Luxury平台。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;适配器模式是可扩展性的经典解决方案。例如：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;适配器模式做统一抽象的解决方案一般是对出入参做数据映射，适配到统一的接口模型，对上层屏蔽底层实现差异。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;钩子模块架构图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5244040862656073&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1FnlMHA4nLMXowWHest5q0crTiahibPFszFUjEumoEbayquUk41ZKia5AOq7AWhX9CwuSjryTPicL39zQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;881&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;钩子模块链路图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8696596669080376&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1FnlMHA4nLMXowWHest5q0c5fQHW6dY4IJGcRppFjzrPVk6tibULtd3p3LPBChwQWvXwrs0JoZkexg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1381&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;入参构造&lt;/span&gt;&lt;/h3&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;问题：钩子是策略链路上独立可复用的模块，因此钩子不与某个具体策略耦合，也不与某个具体的客户端调用耦合。这意味着客户端的每次调用不知道要传哪些参数给钩子。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;解决方案：该类问题的常规解决思路是把入参的结构信息传递到调用方，让调用方感知每次调用的入参格式。但这意味着需要拆分成两次调用，一次获取入参结构，一次发起调用。但在我们在横向分析了自己的业务场景，发现策略的入参往往是精简，有限，可枚举的，比如用户id、商品id、页面id等等。因此我们转变方案，通过每次调用时客户端传递尽可能全的上下文，而钩子从调用上下文里取需要的字段。通过冗余的参数换取更简单的设计，更少的调用次数。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;静态配置可视化&lt;/span&gt;&lt;/h3&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;问题：运营需要在后台配置钩子的静态配置，但问题是每个钩子的静态配置结构都不一样，服务端的静态配置结构需要透传到后台生成表单让运营感知并且理解。传统解决前后端参数传递的方式是前后端约定接口协议并且开发页面表单，但这种方式对钩子不太适用。每次变更都涉及到前后端联调，发布，不能满足钩子敏捷扩展的需求。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;解决方案：要解决表单多变且可持续拓展的问题，用schema动态生成表单是一个好的解决方案。该方案需要前后端约定schema协议，前端提供schema生成表单的引擎，后端提供类生成schema的工具。这样后端的类能直接映射为前端的表单样式，前端表单的一份配置就对应一个后端类实例。整个开发流程能大幅度缩短，支撑钩子敏捷迭代。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.197724039829303&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1FnlMHA4nLMXowWHest5q0cHoLEJZD3JoFia5nibgdq5kXbKAa0bSsx5GDMfumM95qyxtyT6ibunicu3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1406&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一份生成的表单与对应的schema例子如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8382165605095542&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1FnlMHA4nLMXowWHest5q0cgS4o1gM6E8fh898rzPSyS9kFLVyFaUmIFGKf1AJ1kV6hhgAbFMjCfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1570&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;json&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;type&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;object&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;properties&quot;&lt;/span&gt;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;appId&quot;&lt;/span&gt;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;type&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;integer&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;title&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;app id&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;required&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;callSource&quot;&lt;/span&gt;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;type&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;string&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;default&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;fleamarket&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;title&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;call source&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;required&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;tppParam&quot;&lt;/span&gt;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;type&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;array&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;items&quot;&lt;/span&gt;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;type&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;object&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;properties&quot;&lt;/span&gt;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;key&quot;&lt;/span&gt;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;type&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;string&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;title&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;tpp入参&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;required&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;value&quot;&lt;/span&gt;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;type&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;string&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;default&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;${input.}&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;description&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;支持从input或config从动态获取参数&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;title&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;解析表达式&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;required&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;description&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;从input或config中根据mvel表达式获取参数，最后组装为kv结构的tppParam&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;title&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;tpp请求param&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;出参标准化&lt;/span&gt;&lt;/h3&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;问题：钩子作为业务扩展模块，出参结构是不可穷举的，难以约束和进一步抽象。但矛盾在于如果不做统一的抽象，就会把出参的复杂度暴露给外部，外部就需要感知钩子各种case下的数据结构，如何对出参做统一与抽象，屏蔽出参的复杂性？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;分析：我们配置触点与数据的映射时。触点用一个一个占位符挖出来动态数据的“坑”，“坑”是有限且是单一层级的，不会出现一个“坑”里填了个大对象或者大列表的场景。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;解决方案：制定规范，要求将钩子的出参映射为平铺的结构，每份平铺的出参都是一份字典(KVKV结构)，每个KV语义清晰，运营同学配置策略时，从字典里挑选需要的动态数据字段填入触点，“将有限的数据填入有限的坑”。平铺经验证是满足扩展性需求的，就算是嵌套的List结构，例如K[0:[0,1], 1:[0,1]]也能平铺为K_0_0，K_0_1，K_1_0，K_1_1这种结构。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;一个通过字典配置触点的例子如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7357798165137615&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1FnlMHA4nLMXowWHest5q0cZQHD7jxXQkBGEEXXdtNicELFFviaJG2kMj4Z2RahX5vZN8e4XQIPYxYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2180&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;数据映射可配置化&lt;/span&gt;&lt;/h3&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;问题：在做红包权益钩子的时候，我们发现红包权益钩子的可复用性不强，因为它仅是TPP算法中台上的一种业务场景，我们一旦需要接TPP算法中台的另一个算法业务场景，就需要重新扩展实现一遍钩子。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; 分析：可复用性不强的原因在于对接中台类钩子时，中台本身有很强的拓展能力，而我们的出入参的数据映射针对中台上的一种业务场景写死的，导致不能复用到中台上的其他业务场景。因此，我们需要做到数据映射的可配置化。&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;354&quot; data-backw=&quot;557&quot; data-ratio=&quot;0.6356073211314476&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1FnlMHA4nLMXowWHest5q0cbLg9kItELicOPpZ6bxjwIG9VCoNdHgdrHCgvVulIIibeDps1NJqdU7ibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1202&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;解决方案：当发现数据映射成为扩展性的瓶颈时，就要着手解决数据映射灵活性的问题。因此需要实现数据映射的可配置化，钩子实现可配置的数据映射引擎，将入参出参的数据映射配置关系抽出放到静态参数里。这样中台钩子就不与任意一个场景耦合，变更场景时只需要修改数据映射配置，不需要重新开发。当钩子实现不与具体场景耦合时，也就实现了最大化灵活性。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;367&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.6356073211314476&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1FnlMHA4nLMXowWHest5q0chLZOmkwRHI4iavNzHO4VibEeGN30aPGhSbDf8De6avQuyvPIjNk46ZicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1202&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;效果&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;运营同学可以独立配置钩子到触点的映射关系，钩子成为了可以灵活替换的数据字典，可以按需挑选自己需要的动态数据。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;沉淀了常见中台钩子，能够覆盖大部分场景需求，服务接入仅需0.5day配置成本。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;覆盖促买入、促发布、促浏览、活动互动等多个业务场景。 &lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8608458390177354&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1FnlMHA4nLMXowWHest5q0cMMqQI0Jkj4hc6OoV0fGksbVOlCWPTKC9KbDFkia7vkCuO2ia6vtibpZlA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;733&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;扩展模块的设计都很“难”，难的原因在于为了保证可扩展性，在方案设计阶段就不能预设接入服务的结构。接入服务可以是任意一个接口，任意一个服务。对于这样没有边界的服务要做统一和抽象是很困难的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关键的地方在于统一接口层的定义，也是“规范”和“协议“定义。需要我们从业务特点出发，在保证可扩展性的前提下，保证接口层的语义清晰，在可扩展性和易用性之间找到最佳的平衡点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;2390&quot; data-backw=&quot;578&quot; data-ratio=&quot;4.13570487483531&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1GLZDqvPfwuIUEJjtdPx4lYwPx0p9E4T3D1f164CCr18n4ms26HtWsUVrsLf8Szwb4Us8MuhOCe3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;759&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0e328e632f29af083176507485262bba</guid>
<title>[推荐] MySQL 团队开发规范</title>
<link>https://toutiao.io/k/qjooigy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;&lt;strong&gt;数据库对象命名规范&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;数据库对象&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;数据库对象是数据库的组成部分，常见的有以下几种：表（Table ）、索引（Index）、视图（View）、图表（Diagram）、缺省值（Default）、规则（Rule）、触发器（Trigger）、存储过程（Stored Procedure）、 用户（User）等。命名规范是指数据库对象如数据库（SCHEMA）、表（TABLE）、索引（INDEX）、约束（CONSTRAINTS）等的命名约定。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;数据库对象全局命名规范&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;1、命名使用具有意义的英文词汇，词汇中间以下划线分隔&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、命名只能使用英文字母、数字、下划线，以英文字母开头&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、避免用MySQL的保留字如：backup、call、group等&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、所有数据库对象使用小写字母，实际上MySQL中是可以设置大小写是否敏感的，为了保证统一性，我们这边规范全部小写表示。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;数据库命名规范&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;1、数据库命名尽量不超过30个字符。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、数据库命名一般为项目名称+代表库含义的简写，比如IM项目的工作流数据库，可以是 im_flow。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、数据库创建时必须添加默认字符集和校对规则子句。默认字符集为UTF8（已迁移dumbo的使用utf8mb4）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、命名应使用小写。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;表命名规范&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;1、常规表表名以t_开头，t代表table的意思，命名规则即 t + 模块（包含模块含义的简写）+ 表（包含表含义的简写），比如用户模块的教育信息表：t_user_eduinfo。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、临时表（RD、QA或DBA同学用于数据临时处理的表），命名规则：temp前缀+模块+表+日期后缀：temp_user_eduinfo_20210719&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、备份表（用于保存和归档历史数据或者作为灾备恢复的数据）命名规则，bak前缀+模块+表+日期后缀：bak_user_eduinfo_20210719&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、同一个模块的表尽可能使用相同的前缀，表名称尽可能表达含义&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5、多个单词以下划线 _ 分隔&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;6、常规表表名尽量不超过30个字符，temp表和bak表视情况而定，也尽量简短为宜，命名应使用小写&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;字段命名规范&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;1、字段命名需要表示其实际含义的英文单词或简写，单词之间用下划线 _ 进行连接，如 service_ip、service_port。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、各表之间相同意义的字段必须同名，比如a表和b表都有创建时间，应该统一为create_time，不一致会很混乱。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、多个单词以下划线 _ 分隔&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、字段名尽量不超过30个字符，命名应该使用小写&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;索引命名规范&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;1、唯一索引使用uni + 字段名 来命名：create unique index uni_uid on t_user_basic(uid) 。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、非唯一索引使用idx + 字段名 来命名：create index idx_uname_mobile on t_user_basic(uname,mobile) 。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、多个单词以下划线 _ 分隔。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、索引名尽量不超过50个字符，命名应该使用小写，组合索引的字段不宜太多，不然也不利于查询效率的提升。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5、多单词组成的列名，取尽可能代表意义的缩写，如 test_contact表member_id和friend_id上的组合索引：idx_mid_fid。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;6、理解组合索引最左前缀原则，避免重复建设索引，如果建立了(a,b,c)，相当于建立了(a), (a,b), (a,b,c)。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;视图命名规范&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;1、视图名以v开头，表示view，完整结构是v+视图内容含义缩写。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、如果视图只来源单个表，则为v+表名。如果视图由几个表关联产生就用v+下划线（_）连接几个表名，视图名尽量不超过30个字符。如超过30个字符则取简写。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、如无特殊需要，严禁开发人员创建视图。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、命名应使用小写。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;存储过程命名规范&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;1、存储过程名以sp开头，表示存储过程（storage procedure）。之后多个单词以下划线（_）进行连接。存储过程命名中应体现其功能。存储过程名尽量不能超过30个字符。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、存储过程中的输入参数以i_开头，输出参数以o_开头。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、命名应使用小写。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;create&lt;/span&gt; &lt;span&gt;procedure&lt;/span&gt; sp_multi_param(&lt;span&gt;in&lt;/span&gt; i_id &lt;span&gt;bigint&lt;/span&gt;,&lt;span&gt;in&lt;/span&gt; i_name &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;32&lt;/span&gt;),&lt;span&gt;out&lt;/span&gt; o_memo &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;100&lt;/span&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;函数命名规范&lt;/span&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;1、函数名以func开始，表示function。之后多个单词以下划线（_）进行连接，函数命名中应体现其功能。函数名尽量不超过30个字符。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、命名应使用小写。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;create&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; func_format_date(ctime datetime)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;触发器命名规范&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;1、触发器以trig开头，表示trigger 触发器。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、基本部分，描述触发器所加的表，触发器名尽量不超过30个字符。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、后缀（_i,_u,_d）,表示触发条件的触发方式（insert,update或delete）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、命名应使用小写。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;DROP&lt;/span&gt; &lt;span&gt;TRIGGER&lt;/span&gt; &lt;span&gt;IF&lt;/span&gt; &lt;span&gt;EXISTS&lt;/span&gt; trig_attach_log_d;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TRIGGER&lt;/span&gt; trig_attach_log_d &lt;span&gt;AFTER&lt;/span&gt; &lt;span&gt;DELETE&lt;/span&gt; &lt;span&gt;ON&lt;/span&gt; t_dept &lt;span&gt;FOR&lt;/span&gt; &lt;span&gt;EACH&lt;/span&gt; &lt;span&gt;ROW&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;约束命名规范&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;1、唯一约束：uk_表名称_字段名。uk是UNIQUE KEY的缩写。比如给一个部门的部门名称加上唯一约束，来保证不重名，如下：ALTER TABLE t_dept ADD CONSTRAINT un_name UNIQUE(name);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、外键约束：fk_表名，后面紧跟该外键所在的表名和对应的主表名（不含t_）。子表名和父表名用下划线(_)分隔。如下：ALTER TABLE t_user ADD CONSTRAINT fk_user_dept FOREIGN KEY(depno) REFERENCES t_dept (id);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、非空约束：如无特殊需要，建议所有字段默认非空(not null)，不同数据类型必须给出默认值(default)。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;`id` int(&lt;span&gt;11&lt;/span&gt;) NOT &lt;span&gt;NULL&lt;/span&gt;,&lt;br mpa-from-tpl=&quot;t&quot;/&gt;`name` varchar(&lt;span&gt;30&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;&#x27;&#x27;&lt;/span&gt;,&lt;br mpa-from-tpl=&quot;t&quot;/&gt;`deptId` int(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;,&lt;br mpa-from-tpl=&quot;t&quot;/&gt;`salary` float &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;4、出于性能考虑，如无特殊需要，建议不使用外键。参照完整性由代码控制。这个也是我们普遍的做法，从程序角度进行完整性控制，但是如果不注意，也会产生脏数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5、命名应使用小写。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;用户命名规范&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;1、 生产使用的用户命名格式为 code_应用&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、 只读用户命名规则为 read_应用&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;数据库对象设计规范&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;存储引擎的选择&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;1、如无特殊需求，必须使用innodb存储引擎。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以通过 show variables like &#x27;default_storage_engine&#x27; 来查看当前默认引擎。主要有MyISAM 和 InnoDB，从5.5版本开始默认使用 InnoDB 引擎。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基本的差别为：MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持。MyISAM类型的表强调的是性能，其执行速度比InnoDB类型更快，但是不提供事务支持，而InnoDB提供事务支持以及外部键等高级数据库功能。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;字符集的选择&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;1、如无特殊要求，必须使用utf8或utf8mb4。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在国内，选择对中文和各语言支持都非常完善的&lt;/span&gt;&lt;code&gt;&lt;span&gt;utf8&lt;/span&gt;&lt;/code&gt;&lt;span&gt;格式是最好的方式，MySQL在5.5之后增加utf8mb4编码，mb4就是most bytes 4的意思，专门用来兼容四字节的unicode。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以utf8mb4是utf8的超集，除了将编码改为utf8mb4外不需要做其他转换。当然，为了节省空间，一般情况下使用utf8也就够了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以使用如下脚本来查看数据库的编码格式&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;SHOW&lt;/span&gt; &lt;span&gt;VARIABLES&lt;/span&gt; &lt;span&gt;WHERE&lt;/span&gt; Variable_name &lt;span&gt;LIKE&lt;/span&gt; &lt;span&gt;&#x27;character_set_%&#x27;&lt;/span&gt; &lt;span&gt;OR&lt;/span&gt; Variable_name &lt;span&gt;LIKE&lt;/span&gt; &lt;span&gt;&#x27;collation%&#x27;&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;-- 或&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;SHOW&lt;/span&gt; &lt;span&gt;VARIABLES&lt;/span&gt; &lt;span&gt;Like&lt;/span&gt; &lt;span&gt;&#x27;%char%&#x27;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;表设计规范&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;1、不同应用间所对应的数据库表之间的关联应尽可能减少，不允许使用外键对表之间进行关联，确保组件对应的表之间的独立性，为系统或表结构的重构提供可能性。目前业内的做法一般 由程序控制参照完整性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、表设计的角度不应该针对整个系统进行数据库设计，而应该根据系统架构中组件划分，针对每个组件所处理的业务进行数据库设计。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、表必须要有PK，主键的优势是唯一标识、有效引用、高效检索，所以一般情况下尽量有主键字段。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、一个字段只表示一个含义。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5、表不应该有重复列。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;6、禁止使用复杂数据类型(数组,自定义等)，Json类型的使用视情况而定。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;7、需要join的字段(连接键)，数据类型必须保持绝对一致，避免隐式转换。比如关联的字段都是int类型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;8、设计应至少满足第三范式,尽量减少数据冗余。一些特殊场景允许反范式化设计，但在项目评审时需要对冗余字段的设计给出解释。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;9、TEXT字段作为大体量文本存储，必须放在独立的表中 , 用PK与主表关联。如无特殊需要，禁止使用TEXT、BLOB字段。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;10、需要定期删除(或者转移)过期数据的表，通过分表解决，我们的做法是按照2/8法则将操作频率较低的历史数据迁移到历史表中，按照时间或者则曾Id做切割点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;11、单表字段数不要太多，建议最多不要大于50个。过度的宽表对性能也是很大的影响。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;12、MySQL在处理大表时，性能就开始明显降低，所以建议单表物理大小限制在16GB，表中数据行数控制在2000W内。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;业内的规则是超过2000W性能开始明显降低。但是这个值是灵活的，你可以根据实际情况进行测试来判断，比如阿里的标准就是500W，百度的确是2000W。实际上是否宽表，单行数据所占用的空间都有起到作用的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;13、如果数据量或数据增长在前期规划时就较大，那么在设计评审时就应加入分表策略，后续会有专门的文章来分析数据拆分的做法：垂直拆分（垂直分库和垂直分表）、水平拆分（分库分表和库内分表）；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;14、无特殊需求，严禁使用分区表&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;字段设计规范&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;1、INT：如无特殊需要，存放整型数字使用UNSIGNED INT型，整型字段后的数字代表显示长度。比如 &lt;/span&gt;&lt;code&gt;&lt;span&gt;id&lt;/span&gt;&lt;/code&gt;&lt;span&gt; int(11) NOT NULL&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、DATETIME：所有需要精确到时间(时分秒)的字段均使用DATETIME,不要使用TIMESTAMP类型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于TIMESTAMP，它把写入的时间从当前时区转化为UTC（世界标准时间）进行存储。查询时，将其又转化为客户端当前时区进行返回。而对于DATETIME，不做任何改变，基本上是原样输入和输出。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外DATETIME存储的范围也比较大：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;timestamp所能存储的时间范围为：&#x27;1970-01-01 00:00:01.000000&#x27; 到 &#x27;2038-01-19 03:14:07.999999&#x27;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;datetime所能存储的时间范围为：&#x27;1000-01-01 00:00:00.000000&#x27; 到 &#x27;9999-12-31 23:59:59.999999&#x27;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是特殊情况，对于跨时区的业务，TIMESTAMP更为合适。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、VARCHAR：所有动态长度字符串 全部使用VARCHAR类型,类似于状态等有限类别的字段,也使用可以比较明显表示出实际意义的字符串,而不应该使用INT之类的数字来代替；VARCHAR(N)，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;N表示的是字符数而不是字节数。比如VARCHAR(255)，可以最大可存储255个字符（字符包括英文字母，汉字，特殊字符等）。但N应尽可能小，因为MySQL一个表中所有的VARCHAR字段最大长度是65535个字节，且存储字符个数由所选字符集决定。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如UTF8存储一个字符最大要3个字节，那么varchar在存放占用3个字节长度的字符时不应超过21845个字符。同时，在进行排序和创建临时表一类的内存操作时，会使用N的长度申请内存。(如无特殊需要，原则上单个varchar型字段不允许超过255个字符)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、TEXT：仅仅当字符数量可能超过20000个的时候,才可以使用TEXT类型来存放字符类数据,因为所有MySQL数据库都会使用UTF8字符集。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所有使用TEXT类型的字段必须和原表进行分拆，与原表主键单独组成另外一个表进行存放，与大文本字段的隔离，目的是。如无特殊需要，不使用MEDIUMTEXT、TEXT、LONGTEXT类型&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5、对于精确浮点型数据存储，需要使用DECIMAL，严禁使用FLOAT和DOUBLE。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;6、如无特殊需要，尽量不使用BLOB类型&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;7、如无特殊需要，字段建议使用NOT NULL属性，可用默认值代替NULL&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;8、自增字段类型必须是整型且必须为UNSIGNED，推荐类型为INT或BIGINT，并且自增字段必须是主键或者主键的一部分。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;索引设计规范&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;1、索引区分度&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;索引必须创建在索引选择性（区分度）较高的列上，选择性的计算方式为:  selecttivity = count(distinct c_name)/count(*) ; 如果区分度结果小于0.2，则不建议在此列上创建索引，否则大概率会拖慢SQL执行&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、遵循最左前缀&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于确定需要组成组合索引的多个字段，设计时建议将选择性高的字段靠前放。使用时，组合索引的首字段，必须在where条件中，且需要按照最左前缀规则去匹配。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、禁止使用外键，可以在程序级别来约束完整性&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、Text类型字段如果需要创建索引，必须使用前缀索引&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5、单张表的索引数量理论上应控制在5个以内。经常有大批量插入、更新操作表，应尽量少建索引，索引建立的原则理论上是多读少写的场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;6、ORDER BY，GROUP BY，DISTINCT的字段需要添加在索引的后面，形成覆盖索引&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;7、正确理解和计算索引字段的区分度，文中有计算规则，区分度高的索引，可以快速得定位数据，区分度太低，无法有效的利用索引，可能需要扫描大量数据页，和不使用索引没什么差别。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;8、正确理解和计算前缀索引的字段长度，文中有判断规则，合适的长度要保证高的区分度和最恰当的索引存储容量，只有达到最佳状态，才是保证高效率的索引。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;9、联合索引注意最左匹配原则：必须按照从左到右的顺序匹配，MySQL会一直向右匹配索引直到遇到范围查询(&amp;gt;、&amp;lt;、between、like)然后停止匹配。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如：depno=1 and empname&amp;gt;&#x27;&#x27; and job=1 如果建立(depno,empname,job)顺序的索引，job是用不到索引的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;10、应需而取策略，查询记录的时候，不要一上来就使用*，只取需要的数据，可能的话尽量只利用索引覆盖，可以减少回表操作，提升效率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;11、正确判断是否使用联合索引（上面联合索引的使用那一小节有说明判断规则），也可以进一步分析到索引下推（IPC），减少回表操作，提升效率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;12、避免索引失效的原则：禁止对索引字段使用函数、运算符操作，会使索引失效。这是实际上就是需要保证索引所对应字段的”干净度“。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;13、避免非必要的类型转换，字符串字段使用数值进行比较的时候会导致索引无效。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;14、模糊查询&#x27;%value%&#x27;会使索引无效，变为全表扫描，因为无法判断扫描的区间，但是&#x27;value%&#x27;是可以有效利用索引。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;15、索引覆盖排序字段，这样可以减少排序步骤，提升查询效率&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;16、尽量的扩展索引，非必要不新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;举例子：比如一个品牌表，建立的的索引如下，一个主键索引，一个唯一索引&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt; (&lt;span&gt;`id`&lt;/span&gt;),&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;UNIQUE&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt; `&lt;span&gt;uni_brand_define&lt;/span&gt;` (&lt;span&gt;`app_id`&lt;/span&gt;,&lt;span&gt;`define_id`&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;当你同事业务代码中的检索语句如下的时候，应该立即警告了，即没有覆盖索引，也没按照最左前缀原则：&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; brand_id,brand_name &lt;span&gt;&lt;span&gt;from&lt;/span&gt;  ds_brand_system &lt;span&gt;where&lt;/span&gt; &lt;span&gt;status&lt;/span&gt;=? &lt;span&gt;and&lt;/span&gt; define_id=? &lt;span&gt;and&lt;/span&gt; app_id=?&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;建议改成如下：&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;select&lt;/span&gt; brand_id,brand_name &lt;span&gt;from&lt;/span&gt;  ds_brand_system &lt;span&gt;where&lt;/span&gt; app_id=? &lt;span&gt;and&lt;/span&gt; define_id=? &lt;span&gt;and&lt;/span&gt;  &lt;span&gt;status&lt;/span&gt;=?&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;约束设计规范&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;1、PK应该是有序并且无意义的，由开发人员自定义，尽可能简短，并且是自增序列。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、表中除PK以外,还存在唯一性约束的,可以在数据库中创建以“uk_”作为前缀的唯一约束索引。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、PK字段不允许更新。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、禁止创建外键约束，外键约束由程序控制。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5、如无特殊需要，所有字段必须添加非空约束，即not null。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;6、如无特殊需要，所有字段必须有默认值。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;SQL使用规范&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;select 检索的规范性&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;1、尽量避免使用&lt;/span&gt;&lt;code&gt;&lt;span&gt;select *&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，join语句使用&lt;/span&gt;&lt;code&gt;&lt;span&gt;select *&lt;/span&gt;&lt;/code&gt;&lt;span&gt;可能导致只需要访问索引即可完成的查询需要回表取数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一种是可能取出很多不需要的数据，对于宽表来说，这是灾难；一种是尽可能避免回表，因为取一些根本不需要的数据而回表导致性能低下，是很不合算。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、严禁使用 select * from t_name ，而不加任何where条件，道理一样，这样会变成全表全字段扫描。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、MySQL中的text类型字段存储：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.1、不与其他普通字段存放在一起,因为读取效率低，也会影响其他轻量字段存取效率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.2、如果不需要text类型字段，又使用了select *，会让该执行消耗大量io，效率也很低下&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、在取出字段上可以使用相关函数，但应尽可能避免出现 now() , rand() , sysdate() 等不确定结果的函数，在Where条件中的过滤条件字段上严禁使用任何函数，包括数据类型转换函数。大量的计算和转换会造成效率低下，这个在索引那边也描述过了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5、分页查询语句全部都需要带有排序条件 , 否则很容易引起乱序&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;6、用in()/union替换or，效率会好一些，并注意in的个数小于300&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;7、严禁使用%前缀进行模糊前缀查询:如：select a,b,c from t_name where a like ‘%name’; 可以使用%模糊后缀查询如：select a,b from t_name where a like ‘name%’;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;8、避免使用子查询，可以把子查询优化为join操作&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通常子查询在in子句中，且子查询中为简单SQL(不包含union、group by、order by、limit从句)时，才可以把子查询转化为关联查询进行优化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;子查询性能差的原因：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;·&lt;/strong&gt; 子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能 会受到一定的影响；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;·&lt;/strong&gt; 特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;·&lt;/strong&gt; 由于子查询会产生大量的临时表也没有索引，所以会消耗过多的CPU和IO资源，产生大量的慢查询。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;操作的规范性&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;1、禁止使用不含字段列表的INSERT语句&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如：insert into values (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;);  应使用  insert into t_name(c1,c2,c3) values (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;); 。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、大批量写操作（UPDATE、DELETE、INSERT），需要分批多次进行操作&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;·&lt;/strong&gt; 大批量操作可能会造成严重的主从延迟，特别是主从模式下，大批量操作可能会造成严重的主从延迟，因为需要slave从master的binlog中读取日志来进行数据同步。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;·&lt;/strong&gt; binlog日志为row格式时会产生大量的日志&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;程序上的约束&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;后续我们团队的目标是研发评审工具对开发同学提交的建库、建表、刷数据、查询的语句进行分析，看看是否符合应有的规范。如果不符合，驳回修改。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;来源：https://www.cnblogs.com/wzh2010&lt;/span&gt;&lt;/h3&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;99942&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.6&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zQr1zmjQOjKeYHS56vMOy7sD2UyibuNc657J66LeNIzF7hoEL2bIbOHYLmiaia04VSPCTv1jhqiaSFDfqZxQgZZgfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;43&quot; data-width=&quot;100%&quot; class=&quot;rich_pages wxw-img&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;333:340&quot;&gt;END&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>087a74be9326534cbcb9c84add0ed05c</guid>
<title>[推荐] 微服务如何划分</title>
<link>https://toutiao.io/k/f4vabj7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h2&gt;摘要&lt;/h2&gt;&lt;p&gt;作为团队架构师/技术负责人你该如何进行微服务的划分呢?在以前的文章中讨论过这个话题，&lt;span&gt;可落地的DDD(4)-如何利用DDD进行微服务的划分(2)&lt;sup&gt;[1]&lt;/sup&gt;&lt;/span&gt;，最近结合在不同的开发团队实践，又有了新的思考，相比较之前的基于DDD会更加全面可落地，也欢迎大家留言讨论。&lt;/p&gt;&lt;h2&gt;为何要划分微服务&lt;/h2&gt;&lt;p&gt;微服务架构被广泛用于互联网公司，其优势在于每个服务足够小，相互之间具备隔离性。配合一些基础设施，能够使得需求快速迭代上线。但是每个服务的粒度应该多大呢，服务之间的关系应该是怎样的呢?&lt;/p&gt;&lt;p&gt;首先我们来探讨一下微服务划分的目标。微服务划分涉及到两个对象，一个是微服务，一个是开发人员。所以目标是&lt;strong&gt;高效有序&lt;/strong&gt;将微服务及开发人员组织起来。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;如何衡量有序呢?&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.职责清晰2.相互间的依赖关系清晰 一个无序的微服务调用，会陷入混乱地狱。&lt;img data-ratio=&quot;0.8351893095768375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/to5t8icQhBHp6zHicKATj4u0mpLO5SZNGk7rEGicKpVBdaDDib0IHJN4fnJ1XJkwMhxm2FBzBDdZ5s83RibEWn4Sk8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;449&quot; title=&quot;null&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;因此制定一些&lt;strong&gt;标准&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;横向&lt;/strong&gt;：按照业务流程拆，业务流程反映的是数据流程，数据从上游流下下游。上游需要和下游解耦，上游不可通过服务间调用下游。下游可以。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;纵向&lt;/strong&gt;：按照技术拆分，由上到下分为4层，上层可以调用下层，同级可以相互调用，下层强制不能调用上层。&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;应用系统 面向各个端，比如pc端，面向用户的，面向小二的。app端。属于前端应用。&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;核心领域 整个系统的核心业务，与&lt;strong&gt;业务&lt;/strong&gt;紧密相连。支撑业务发展。&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;基础能力 从核心领域中下沉抽象出来的更通用的服务，不只是服务当前业务。也服务于公司其他业务。&lt;/p&gt;&lt;p&gt;4.&lt;/p&gt;&lt;p&gt;依赖系统 一些通用的公共模块以及与其他兄弟部门的服务依赖。&lt;/p&gt;&lt;p/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如此调用关系比较清晰了。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8625482625482626&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/to5t8icQhBHp6zHicKATj4u0mpLO5SZNGk077RAgTTA913ULRp7ZjZ8SIrFvDeVvXnTzQWtHoia78nKhgLRs3Ah9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1295&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;如何衡量高效呢？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于服务是性能高且稳定 对于开发人员是效率高且有技术成长空间&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;业务量上来一个，后端的很多工作就是围绕着性能和稳定，微服务的划分也深深影响着。因此服务划分还会按照&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.基于迭代频次 &lt;/span&gt;&lt;span&gt;     变更是引发故障的主要原因，因此如果一个服务是稳定的，我们可以把他单独拆分为一个微服务，这样在项目快速迭代时，不会影响已有功能。不需要投入太多回归测试时间。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    2. &lt;span&gt;基于可靠性     核心服务需要重点保障，流量高的应用和流量低的应用稳定性要求也不一样。可以将核心服务，流量高的应用单独拆出来，这样使得核心服务功能逻辑简单，依赖减少，存储独立。稳定性得到极大保障。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    3.基于开发人员     架构活动不仅要关心机器，还要关心人。开发人员的工作效率极大影响了业务的交付速度和质量。一个微服务需要一个唯一owner和2-3个开发人员(owner也参与开发)。owner是第一责任人，负责整个应用的代码质量，服务稳定性。2-3个人负责开发一个系统，不会有单点，在人员流动的情况能够进行相互补位，同时相互之间可以进行技术方案深度讨论，能够应对一定级别的复杂需求。人数不宜超过4个人，人太多，在同一个应用中开发不同的需求，可能每天都要处理不同的分支之间冲突，多套环境进行测试，效率比较低。同时人数太多，讨论效率也比较低。此外需要尽量保证每个中高级别的开发者都是一个微服务的owner，有自己的一块自留地，在需求承接之外，能够在做一些技术相关的开发工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当然高效和有序并不总是统一的，有时候我们需要去做架构取舍。&lt;/p&gt;&lt;h2&gt;如何划分&lt;/h2&gt;&lt;p&gt;举个例子，比如你公司是做在线教育的，你入职负责开发公司的客户管理系统(CRM,下面统一用CRM代替)业务。首先你需要从全局分析CRM这块业务。&lt;/p&gt;&lt;h3&gt;流程&lt;/h3&gt;&lt;p&gt;CRM按照流程划分主要是获客-跟进-转化-签约-服务。按照领域进行抽象，可以分为售前，售中，售后。&lt;/p&gt;&lt;h3&gt;服务&lt;/h3&gt;&lt;p&gt;按照服务来划分，主要有投放服务、营销活动服务、呼叫服务、客户管理、日程管理、消息提醒、订单、合同、工单、销售效果分析。&lt;/p&gt;&lt;h3&gt;功能&lt;/h3&gt;&lt;p&gt;每个服务有更细粒度的功能。比如 投放服务：提供多渠道投放方式，百度，头条，微信等，投放分析。营销活动服务：营销落地页，开学季优惠活动，抽奖活动，优惠券活动。客户管理服务：客户档案，销售机会，销售看板。其他不再赘述。&lt;/p&gt;&lt;h3&gt;人员&lt;/h3&gt;&lt;p&gt;目前业务还是在初级阶段，负责这块的开发总共有6人，3个后端，2个前端，一个测试。&lt;/p&gt;&lt;h3&gt;服务划分&lt;/h3&gt;&lt;p&gt;基于以上考虑，服务划分为以下6个服务。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8048595292331056&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/to5t8icQhBHp6zHicKATj4u0mpLO5SZNGkn0PYTlPzo4J0NfbpXyeeibt1jobibPAnuWaDPcjS3cWYibCHLicYgOuxVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1317&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;考虑到只需要一个pc工作台，市场人员、销售人员都用同一个工作台，应用系统这一层不需要。然后核心领域分为售前（市场人员）、售中（客服，销售）、售后（客服，财务）三个服务，每个开发负责一个服务。同时抽象出3个通用基础能力服务，每个开发负责一个。&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 公司内部的账号系统 提供统一的账号管理能力，组织架构能力，权限管理能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;     2. &lt;span&gt;服务系统        通用的一些工具能力，比如隐私号、坐席呼叫、待办、消息提醒等能力。这些并不属于同一个领域，但是考虑到当前阶段，服务不宜拆分的过细。所以都放在同一个服务中。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    3.数据分析        各个模块都需要数据分析，所以抽象出一个单独能力，统一处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;演进&lt;/h2&gt;&lt;p&gt;经过半年的发展，业务蒸蒸日上，需求越来越多。人员也在逐步扩展。后端人员扩大到了10人。原有的微服务架构逐渐不太适应。因此需要进行适当调整。经过分析，当前业务重点是&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;售前 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;两个核心指标一个是有效线索量，一个是单个线索成本&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;       2. &lt;span&gt;售中     &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;         售中决定了线索能否转化为订单。目前对应的运营人员最多，客服100人，销售300人。提高运营人员效率是重点。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      3. 售后            &lt;/span&gt;&lt;span&gt;          工单响应时长&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;售前这块基本系统功能已搭建完毕，通用的营销工具已经有了，市场人员可以进行组件组合，搭建不同营销页，然后根据投放效果进行适当调整。服务比较稳定了，所以这块有2个开发即可。主要负责营销工具开发。&lt;/p&gt;&lt;p&gt;售后相对也比较稳定了，2个开发。售中是重点，需求迭代也比较多，6个开发。之前只有一个微服务，开发效率比较低了。需要进行适当拆分。增加3个服务&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.应用系统增加一个移动工作台 因为销售人员经常在外部，所以需要移动端，而移动端通常是销售管理活动中的操作类功能。pc端则是查看分析。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;     2.&lt;span&gt;核心领域层增加一个售中服务域&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;售中拆成2个服务，一个是线索域，主要围绕着公海、私海，线索推荐。另外一个是服务域，是面向销售日常活动的。如活动，拜访，小记，客户标签等。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;3 .&lt;/span&gt;基础能力层增加一个流程引擎服务 各个角色人员需要经常发起审批，流程编排，所以新构建一个基础能力，流程引擎。能够服务于整个crm业务，同时如果公司其他业务需要，可以提供给其他业务使用。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8290094339622641&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/to5t8icQhBHp6zHicKATj4u0mpLO5SZNGkRbguklib1vcCH8z1oH4NPwzEnZKN0w61Oj38Iec6rXiaT5DhY3sPxHHg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1696&quot; title=&quot;null&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;参考文章&lt;/h2&gt;&lt;p&gt;&lt;span&gt;    http://www.woshipm.com/pd/3983693.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;[1]&lt;/code&gt; 可落地的DDD(4)-如何利用DDD进行微服务的划分(2): &lt;em&gt;https://blog.csdn.net/FS1360472174/article/details/90738148?spm=1001.2014.3001.5501&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>