<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>0f806976509760f6913d641fe3f4a29c</guid>
<title>开工第一天，看看你可能错过的好分享！</title>
<link>https://toutiao.io/k/szdkhka</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c5f37c7ef76c3f3ce4f79d20966907ee</guid>
<title>一秒钟打开在线 VS Code 阅读 GitHub 代码！真的只需 +1s</title>
<link>https://toutiao.io/k/wz04au9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot;&gt;&lt;p&gt;GitHub Codespaces 的到来，把 VS Code 带入了浏览器。&lt;/p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://zhuanlan.zhihu.com/p/219818227&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://zhstatic.zhihu.com/assets/zhihu/editor/zhihu-card-default.svg&quot; class=&quot;LinkCard LinkCard--hasImage&quot;&gt;&lt;span class=&quot;LinkCard-backdrop&quot;/&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;微软宣布 Visual Studio Codespaces 将停用，其功能将被整合到 GitHub Codespaces 中&lt;/span&gt;&lt;span class=&quot;LinkCard-meta&quot;&gt;&lt;span&gt;​&lt;svg class=&quot;Zi Zi--InsertLink&quot; fill=&quot;currentColor&quot; viewbox=&quot;0 0 24 24&quot;&gt;&lt;path d=&quot;M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;zhuanlan.zhihu.com&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-imageCell&quot;&gt;&lt;img class=&quot;LinkCard-image LinkCard-image--square&quot; alt=&quot;图标&quot; src=&quot;https://zhstatic.zhihu.com/assets/zhihu/editor/zhihu-card-default.svg&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;p&gt;可惜的是，目前 GitHub Codespaces 还处于有限的 beta 版，并不是所有人都能使用到。&lt;/p&gt;&lt;p&gt;那么，有没有其他方法，直接能在 VS Code 上查看 GitHub Repo 的代码呢？&lt;/p&gt;&lt;p&gt;近日，GitHub 上出现了这样一个项目，可以使用户直接&lt;b&gt;在 VS Code 界面读取 GitHub 项目的代码&lt;/b&gt;，实现了 GitHub 项目与 VS Code 的无缝衔接。&lt;/p&gt;&lt;p&gt;这个项目名为 &lt;b&gt;github1s&lt;/b&gt;，只需要在浏览器地址栏 GitHub 网址链接中的「github 」后面添加 1s ，然后 Enter 键，即可在 VS Code 界面访问该项目的 Repo 代码。据项目主页显示，项目开发者来自百度。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-30249b213e01b61fa26b12d24f385729_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;155&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-30249b213e01b61fa26b12d24f385729_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;155&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-30249b213e01b61fa26b12d24f385729_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-30249b213e01b61fa26b12d24f385729_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;项目地址：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/conwnet/github1s&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/conwnet/gith&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;ub1s&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt; &lt;/p&gt;&lt;p&gt;据作者介绍，这个项目的用法很简单，比如你现在正在看 facebook/react 这个代码库的代码，觉得页面切来切去很麻烦，直接在浏览器地址栏 &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//github.com&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com&lt;/span&gt;&lt;span class=&quot;invisible&quot;/&gt;&lt;/a&gt; 中的 github 后面，加上个 1s，然后回车就行了，所有的公开代码库都可以。&lt;/p&gt;&lt;p&gt;URL 从 &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/facebook/react&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/facebook/rea&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;ct&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt; &lt;/p&gt;&lt;p&gt;变成了 &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github1s.com/facebook/react&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github1s.com/facebook/r&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;eact&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt; &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-7b9deb584c3009f8ee8cc9b93b916124_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;683&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-7b9deb584c3009f8ee8cc9b93b916124_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;683&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-7b9deb584c3009f8ee8cc9b93b916124_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-7b9deb584c3009f8ee8cc9b93b916124_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这就是加「1s」的神奇力量！&lt;/p&gt;&lt;h2&gt;&lt;b&gt;实现原理&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;github1s 是一个纯前端的项目，使用了 GitHub REST API 实现一个带 FileSystemProvider 的 VS Code extension。网站直接用的 gh-pages 托管，如果遇到了 Rate Limiting 设置个 OAuth Token 就好了，没有自己的服务部署，所以这网站服务理论上不会挂。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;自行开发&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;github1s 完全开源，我们也可以基于源代码自行构建进行二次开发！&lt;/p&gt;&lt;p&gt;&lt;b&gt;首先需要准备以下先决条件&lt;/b&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ git clone git@github.com:conwnet/github1s.git
$ &lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; github1s
$ yarn
$ yarn watch
$ yarn serve &lt;span class=&quot;c1&quot;&gt;# in another shell&lt;/span&gt;
$ &lt;span class=&quot;c1&quot;&gt;# Then visit http://localhost:5000 or http://localhost:5000/conwnet/github1s once the build is completed.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;构建&lt;/b&gt;&lt;/p&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c428c60b9e391cf3cc798ce308fa6403</guid>
<title>前端如何进行日志驱动开发</title>
<link>https://toutiao.io/k/4d1b17k</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;日志在开发过程中的作用自不必说，一旦程序出现问题，我们首先想到的是通过日志监控去追查。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好的日志可以通过应用程序执行的历史记录模拟出用户在使用程序的时候操作的完整过程。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;想知道发生了什么&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了便于我们分析程序哪里出现问题，我们将采用&lt;code&gt;logrock&lt;/code&gt;模块并将其链接到ElasticSearch，LogStash和Kibana进行进一步分析。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;LogRock&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;logrock模块源于研究Cleverbrush时候的创新。它是一个用于处理矢量图形的软件。使用图形编辑器意味着大量的应用程序用例。为了控制成本，不得不优化整个开发测试流程。减少每个环节使用测试用例带来的额外的付出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该模块可以为您的应用程序组织现代化的日志记录方法。根据日志，我们测试了我们的应用程序。在本文中，我将向您介绍如何组织日志系统以搜索错误。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;ElasticStack&lt;/span&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.31215469613259667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wokNJRf0ytrkoL1bJ9ia7icWFRo0d12TVjPM747ibd95Tc0sseWjyYoFB7IMgtvBFtibH8an8ibIDlpcXE05lM7G0RQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;724&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ElasticSearch是一个功能强大的全文搜索引擎。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LogStash是一个用于从各种来源收集日志的系统，该系统也可以将日志发送到ElasticSearch。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Kibana是ElasticSearch的Web界面版，其中包含许多插件。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;它是如何工作的&lt;/span&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5613636363636364&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wokNJRf0ytrkoL1bJ9ia7icWFRo0d12TVjMMoDhBLlpe5XfsK2ibw9NsAnkNDXoFsES0ib85NEy5dop3oPsjLQRHow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;880&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一旦程序出现错误（或者用于特殊模拟），则应用程序会将日志发送到服务器，然后将日志保存到文件中。Logstash将数据增量保存到ElasticSearch数据库。用户登录到Kibana并查看保存的日志。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5897727272727272&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wokNJRf0ytrkoL1bJ9ia7icWFRo0d12TVjJibEwfUFezY2SVs4e4EoISvpejgcyTfxBWbuEDXHYEXg3akrrVMX8ug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;880&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是一个配置好的Kibana的界面，显示了来自ElasticSearch的数据。它可以帮助您分析数据并从中了解程序发生了什么故障。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里就不一一将如何去设置ElasticStack。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;创建日志系统&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们将一个日志记录系统集成到基于React开发的单页应用程序中。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;Step 1：安装&lt;/span&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npm install logrock --save&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;Step 2：集成到React应用程序中&lt;/span&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;import { LoggerContainer } from &lt;span&gt;&quot;logrock&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&amp;lt;LoggerContainer&amp;gt;&lt;br/&gt;  &amp;lt;App /&amp;gt;&lt;br/&gt;&amp;lt;/LoggerContainer&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;LoggerContainer&lt;/code&gt;是一个捕捉应用程序中的错误并将它们形成堆栈的组件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;堆栈是一个对象，其中包含有关用户的操作系统，浏览器，按下的鼠标或键盘按钮的信息，当然还有操作相关的子数组，其中记录了用户在系统中执行的所有的操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;LoggerContainer&lt;/code&gt;含有配置项，可适当考虑更改其中的一些设置。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;LoggerContainer&lt;br/&gt;  active={&lt;span&gt;true&lt;/span&gt;|&lt;span&gt;false&lt;/span&gt;}&lt;br/&gt;  &lt;span&gt;limit&lt;/span&gt;={20}&lt;br/&gt;  onError={stack =&amp;gt; {&lt;br/&gt;    sendToServer(stack);&lt;br/&gt;  }}&lt;br/&gt;&amp;gt;&lt;br/&gt;  &amp;lt;App /&amp;gt;&lt;br/&gt;&amp;lt;/LoggerContainer&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「active」&lt;/strong&gt; 开启关闭日志功能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「limit」&lt;/strong&gt; 设置最近用户操作的最大阙值。如果超过这个值，那么数组中的第一个值将会被删除。数组中始终保持最近的20个操作信息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「onError」&lt;/strong&gt; 当错误出发时的一个回调。返回参数stack对象包含环境，用户操作等信息。在回调中我们需要将这些信息上传到ElasticSearch，云端，或者保存到本地文件中，为后面进行数据分析和监控做准备。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;打印日志&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了生产高质量的用户操作日志，我们将日志代码覆盖到所有需要打印日志的地方&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;logrock&lt;/code&gt;模块附带一个与 &lt;code&gt;LoggerContainer&lt;/code&gt; 连接的记录器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，我们有以下这样一个组件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;import React, { useState } from &lt;span&gt;&quot;react&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; default &lt;span&gt;function&lt;/span&gt; Toggle(props) {&lt;br/&gt;  const [toggleState, setToggleState] = useState(&lt;span&gt;&quot;off&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;function&lt;/span&gt; &lt;span&gt;&lt;span&gt;toggle&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    setToggleState(toggleState === &lt;span&gt;&quot;off&quot;&lt;/span&gt; ? &lt;span&gt;&quot;on&quot;&lt;/span&gt; : &lt;span&gt;&quot;off&quot;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &amp;lt;div className={`switch &lt;span&gt;${toggleState}&lt;/span&gt;`} onClick={toggle} /&amp;gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了能让日志正确覆盖到，我们需要修改toggle方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;import React, { useState } from &lt;span&gt;&quot;react&quot;&lt;/span&gt;;&lt;br/&gt;import logger from &lt;span&gt;&quot;logrock&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; default &lt;span&gt;function&lt;/span&gt; Toggle(props) {&lt;br/&gt;  const [toggleState, setToggleState] = useState(&lt;span&gt;&quot;off&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;function&lt;/span&gt; &lt;span&gt;&lt;span&gt;toggle&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; state = toggleState === &lt;span&gt;&quot;off&quot;&lt;/span&gt; ? &lt;span&gt;&quot;on&quot;&lt;/span&gt; : &lt;span&gt;&quot;off&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    logger.info(`React.Toggle|Toggle component changed state &lt;span&gt;${state}&lt;/span&gt;`);&lt;br/&gt;&lt;br/&gt;    setToggleState(state);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &amp;lt;div className={`switch &lt;span&gt;${toggleState}&lt;/span&gt;`} onClick={toggle} /&amp;gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们添加了一个logger方法，其中的信息分为两部分。‘React.Toggle’用于显示该动作发生在React的Toggle组件级别。后面是对该动作和发生所在组件的一些描述信息。日志级别划分不是必须的，但是这样有助于我们快速定位错误发生的有关代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还可以使用 React 16 中引入的“componentDidCatch”方法来捕获异常。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;日志上传&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设我们有一个从后端收集用户数据的方法。该方法是异步的，部分逻辑隐藏在后端中。看看如何将日志添加到代码中？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，由于我们有一个客户端应用程序，所有发送到服务器的请求都将在一个用户会话内传递，而无需重新加载页面。为了将客户端上的操作与服务器上的操作相关联，我们必须创建一个全局SessionID并将其添加到针对服务器的每个请求头的标记中。在服务器上，我们可以使用任何记录器来记录我们的逻辑，如前端示例所示，如果发生错误，请将带有附加sessionID的数据发送到ElasticSearch，发送到后端。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;Step 1：客户端生成SessionID&lt;/span&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;window.SESSION_ID = `sessionid-&lt;span&gt;${Math.random().toString(36).substr(3, 9)}&lt;/span&gt;`;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;Step 2：封装请求&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们需要将&lt;code&gt;SessionID&lt;/code&gt;添加到请求头中。如果我们使用以及封装好的请求库，很容易将声明好的SessionID添加到所有的请求中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; fetch = axios.create({...});&lt;br/&gt;&lt;br/&gt;fetch.defaults.headers.common.sessionId = window.SESSION_ID;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;Step 3：将SessionID和日志堆栈绑定&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;LoggerContainer&lt;/code&gt;有专门的sessionID字段&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;LoggerContainer&lt;br/&gt;  active={&lt;span&gt;true&lt;/span&gt; | &lt;span&gt;false&lt;/span&gt;}&lt;br/&gt;  sessionID={window.SESSION_ID}&lt;br/&gt;  &lt;span&gt;limit&lt;/span&gt;={20}&lt;br/&gt;  onError={stack =&amp;gt; {&lt;br/&gt;    sendToServer(stack);&lt;br/&gt;  }}&lt;br/&gt;&amp;gt;&lt;br/&gt;  &amp;lt;App /&amp;gt;&lt;br/&gt;&amp;lt;/LoggerContainer&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;Step 4：请求后端接口&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前端请求类似下面：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;logger.info(`store.getData|User is ready &lt;span&gt;for&lt;/span&gt; loading... User ID is &lt;span&gt;${id}&lt;/span&gt;`);&lt;br/&gt;&lt;br/&gt;getData(&lt;span&gt;&#x27;/api/v1/user&#x27;&lt;/span&gt;, { id })&lt;br/&gt;  .&lt;span&gt;then&lt;/span&gt;(userData =&amp;gt; {&lt;br/&gt;    logger.info(`store.getData|User have already loaded. User count is &lt;span&gt;${JSON.stringify(userData)}&lt;/span&gt;`);&lt;br/&gt;  })&lt;br/&gt;  .catch(err =&amp;gt; {&lt;br/&gt;    logger.error(`store.getData|User loaded fail &lt;span&gt;${err.message}&lt;/span&gt;`);&lt;br/&gt;  });&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它是怎么运行的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在客户端请求之前写一个日志。从我们的代码中，我们可以看到现在开始从服务器下载数据。我们已将SessionID附加到请求。如果我们的后端日志包含此SessionID的添加而请求失败，那么我们可以看到后端发生了什么。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，我们不仅在客户端而且还在服务器上监视应用程序的整个周期。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;用户交互&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些日志对用户是有帮助的。向用户输出必要的信息可以采用 &lt;code&gt;stdout&lt;/code&gt; 方法&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;LoggerContainer&lt;br/&gt;  active={&lt;span&gt;true&lt;/span&gt; | &lt;span&gt;false&lt;/span&gt;}&lt;br/&gt;  &lt;span&gt;limit&lt;/span&gt;={20}&lt;br/&gt;  bsodActive={&lt;span&gt;true&lt;/span&gt;}&lt;br/&gt;  bsod={BSOD}&lt;br/&gt;  onError={stack =&amp;gt; {&lt;br/&gt;    sendToServer(stack);&lt;br/&gt;  }}&lt;br/&gt;  stdout={(level, message, important) =&amp;gt; {&lt;br/&gt;    console[level](message);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (important) {&lt;br/&gt;      alert(message);&lt;br/&gt;    }&lt;br/&gt;  }}&lt;br/&gt;&amp;gt;&lt;br/&gt;  &amp;lt;App /&amp;gt;&lt;br/&gt;&amp;lt;/LoggerContainer&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们通过logger传递的第二个参数的值为true来声明这是一个重要的信息，需要通过pop-up窗口显示给用户看，比如在数据加载的时候失败了，我们将输出以下错误信息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;logger.log(&lt;span&gt;&#x27;Something was wrong&#x27;&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;一些注意项&lt;/span&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;日志监控（包括生产环境），因为测试人员永远无法覆盖所有的测试用例，完全模拟到用户操作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不要忘记在许可协议中提及日志收集。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不要在日志中记录用户密码，银行详情地址等敏感的个人信息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;避免在日志中添加冗余信息，尽量保证简洁有用&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;总结&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们完成编码对外发布应用程序的时候，如果把程序比作一个生命，那么这个生命才刚刚开始。收集并监视日志可以获得产品的反馈帮助更好的改善。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e0119f992e1369411c88060c786d6b1e</guid>
<title>初探毕昇 JDK 8 AppCDS 特性对 Hadoop 的性能提升</title>
<link>https://toutiao.io/k/4llmmtx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0387b40e264cdd8ee852e9a696ea098e</guid>
<title>非暴力沟通让我学会了接纳</title>
<link>https://toutiao.io/k/qzftxiv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-body&quot; itemprop=&quot;articleBody&quot;&gt;
&lt;p&gt;2016年，在一个提升沟通能力的培训中，我第一次接触到了非暴力沟通。那时工作刚有起色，和别人打交道的机会多了，同时也暴露了自身沟通上的短板。那次培训中，我依稀记得学到了一些技巧。后来边琢磨边成长，2020遇见了《非暴力沟通》这本书，这次，它教会了我两个字：接纳。&lt;/p&gt;
&lt;p&gt;为什么当时记下的只有一些技巧，而现在体会到了接纳？我想这和人的成长是有关系的，同一个人，不同的人生阶段读一本书，会读出来不同的感受，正像《如何阅读一本书》中说的，一本真正的好书，是一本超越了你理解能力很多的书，你每次读的时候，都会有新的发现，因为你离作者的水平越来越近了。&lt;/p&gt;
&lt;p&gt;要想学会用爱的语言进行非暴力沟通，就得先知道是什么导致的暴力沟通？我找到的答案是排斥。一个人因为不满足一个情况，就会生气，生气的时候，就想指责别人。受到指责的人，感觉到自己没错，受了冤枉，就开始反驳。生气的人，排斥了他眼下看到的情况，因为他不想这种情况发生。受指责的人，排斥了别人的指责，因为他觉得他并没错。&lt;/p&gt;
&lt;p&gt;人为什么会排斥呢？因为排斥是最容易的第一反应。你说我不对，你就伤害了我的自尊，让我感觉我是一个很没用的人，我当然不能让别人看成是一个没用的人，所以我排斥你说的话，我要反驳，我要争论。做出这样的反应，不需要大脑的思考，一个人的情绪很容被点燃，特别是当对方不友善的时候。所以，避免暴力沟通的手段是什么？接纳。&lt;/p&gt;
&lt;p&gt;接纳，是一个人不让情绪牵着鼻子走的第一步，也是最重要的一步。所谓的接纳，就是不管事情怎么样，别人说的话待有多少情绪，我都接纳它，一旦你接住了，你就有了发现它，认识它的机会，就不会急着去反驳，去争辩，反而是你更加愿意去了解它，挖掘它，看看它背后到底是什么支撑的。&lt;/p&gt;
&lt;p&gt;比如说，你看到一段代码，写的不如你的意。你这时如果排斥这段代码，你肯定会开骂，如果嘴上你忍住，你心里肯定也想，这什么玩意，写的太菜了吧。如果你接纳了它，你首先会想，他为什么会这么写呢，他当时心里是怎么想的？这种接纳的思维模式，是一个重大的转折，你会用问题去替代评价。同样的例子，如果一个看了你代码的同事对你说，你的代码写的有问题啊。如果你排斥，你肯定说，你写的代码才有问题呢，我这样写有什么不好？谁说的变量的名字就一定得你那样起？如果你接纳了对方所说的话，你心里会想，他为什么会这么说呢？他的指导原则是什么？他这么说是的目的是想保证代码的质量吗？还是想保证代码的统一标准？&lt;/p&gt;
&lt;p&gt;接纳的过程，是自我意识觉醒的过程，你开始知道你自己在做什么，你不再单一的话赶话，而是开始琢磨事情或者话语背后隐藏的东西。在《非暴力沟通》中，作者把这些隐藏起来的东西，称之为需求。你生气，是因为你的需求没有得到满足，别人生气，也是因为他的需求没有得到满足。你一旦接纳了你不愿意看到的情况，或不想听到的话，就是打开了认识人们深层次需求的大门。一旦你开始从需求的层面上看待彼此，你就会发现，彼此的心灵都是美好的。就拿代码审查举例子，你看到不好的代码而生气，是因为你对代码的质量有要求，你渴望干净整齐的代码。&lt;/p&gt;
&lt;p&gt;更加神奇的事情还在后面，一旦双方搞清楚了彼此的需求，他们会愿意伸出援助的手，因为从内心深处，我们人类是一种喜欢帮助别人的物种，帮助了别人，能实现自己的价值，会发现自己是一个有用的人，会是一个人变得非常开心。&lt;/p&gt;
&lt;p&gt;非暴力沟通教会了我接纳，接纳的东西越多，你会发现自己的心田被浇灌的就越多，那里会慢慢的结出爱的花朵。&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>