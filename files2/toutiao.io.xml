<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>843632b534ca79d6c33758d6b6484653</guid>
<title>[推荐] 怎么排查 CPU 飙升</title>
<link>https://toutiao.io/k/rq3wyhs</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;h1&gt;&lt;span&gt;怎么排查CPU飙升&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;线上有些系统，本来跑的好好的，突然有一天就会出现报警，CPU使用率飙升，然后重启之后就好了。例如，多线程操作一个线程不安全的list往往就会出现这种现象。那么怎么定位到具体的代码范围呢？今天笔者就教大家一个小技巧&lt;/p&gt;&lt;h2&gt;&lt;span/&gt;&lt;span&gt;代码准备&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;这次，笔者准备了一个demo代码，大致线程模型是这样的:&lt;img data-ratio=&quot;0.44745222929936307&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7ICuYI5fFbIIaXAlQFQ9tVtn0k5kS3CUIY0mEMwqGaAI4CUEyl68pEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1256&quot;/&gt;&lt;/p&gt;&lt;p&gt;代码下所示:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;public class CpuHighExample {&lt;br/&gt;&lt;br/&gt;    public static void &lt;span&gt;&lt;span&gt;cpuHigh&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        final List&amp;lt;String&amp;gt; list = new LinkedList&amp;lt;&amp;gt;();&lt;br/&gt;        Thread thread1 = new Thread(new &lt;span&gt;&lt;span&gt;Runnable&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;            @Override&lt;br/&gt;            public void &lt;span&gt;&lt;span&gt;run&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;                int count = 1;&lt;br/&gt;                &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;                    // 构造thread1为消耗很高cpu的线程&lt;br/&gt;                    count = count + 1;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        thread1.setName(&lt;span&gt;&quot;thread1&quot;&lt;/span&gt;);&lt;br/&gt;        Thread thread2 = new Thread(new &lt;span&gt;&lt;span&gt;Runnable&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;            @Override&lt;br/&gt;            public void &lt;span&gt;&lt;span&gt;run&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;                &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;                    try {&lt;br/&gt;                        // 构造thread2为消耗很低cpu的线程&lt;br/&gt;                        Thread.sleep(1000);&lt;br/&gt;                    } catch (InterruptedException e) {&lt;br/&gt;                        e.printStackTrace();&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        thread2.setName(&lt;span&gt;&quot;thread2&quot;&lt;/span&gt;);&lt;br/&gt;        thread1.start();&lt;br/&gt;        thread2.start();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span/&gt;&lt;span&gt;案例运行&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;这个案例一运行，就听见笔者的电脑风扇起飞了，呼呼作响。直接top一下&lt;img data-ratio=&quot;0.27223230490018147&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7FtpGMeoqxWeUe09Hiaupmk6AB12ux7T8RUsiclic762iaQV8zU1u3789rw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1102&quot;/&gt;&lt;/p&gt;&lt;p&gt;果然是java进程，占用最高，CPU 100%了(占用了一个核),而其PID是2717，正是我们跑的例子。那么下一步，我们就需要定位到底是那一个线程在耗CPU&lt;/p&gt;&lt;pre&gt;&lt;code&gt;top -H&lt;br/&gt;Threads toggle&lt;br/&gt;            Starts top with the last remembered ’H’ state reversed.  When this&lt;br/&gt;            toggle  is  On,  all individual threads will be displayed.  Other-&lt;br/&gt;            wise, top displays a summation of all threads &lt;span&gt;in&lt;/span&gt; a process.&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如man文档所描述,top -H可以打印出线程信息，我们就top -H一下。&lt;img data-ratio=&quot;0.3611111111111111&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7gVWF29FYqvsdgCp0SxRbAHsuYlcGib6Ow25t2iaqoZqSaoKFSNEuIQUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;图中可以看到，占用最高的线程PID是2727,同时线程名是thread1。&lt;/p&gt;&lt;h2&gt;&lt;span/&gt;&lt;span&gt;继续jstack&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;我们知道jstack可以dump出jvm所有线程运行的快照，然后我们就可以通过刚才获取的PID去定位到jstack那个进程。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 注意，这边用top出来的进程号2717,而不是top -H出来的2727&lt;br/&gt;jstack 2717 &amp;gt; 1.txt&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于jstack打印出的线程号是以16进制的形式表现的，所以我们对2727的线程号做一次转换,得到aa7。&lt;br/&gt;&lt;img data-ratio=&quot;0.3513203214695752&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7Z1MYNZ7AngNmNOmfdOia7SGcP0W6zPLy29iaibDJjZTX1tp2qTJRibCf1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1742&quot;/&gt;&lt;/p&gt;&lt;p&gt;然后我们在1.txt中搜索2727,这里用的是less然后进去后搜索，而不是用grep。因为这样比较直观的能看出之前和之后的信息。less下&lt;img data-ratio=&quot;0.06093189964157706&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7k1icZP2z0uBTfeOhUUcV1YGL8dRA0XFNNqUaWTy4WrqN8dJJOK9Q2tg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1116&quot;/&gt;&lt;img data-ratio=&quot;0.27797202797202797&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7qGiaETjUfibeysR1DjicW6Hu1ib8Gbicy0IBD090xFA9eHoLjsd2OFM2UuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1144&quot;/&gt;&lt;/p&gt;&lt;p&gt;我们找到aa7后，就直接能发现代码一直跑在CpuHighExample.java第19行上面。&lt;img data-ratio=&quot;0.35304990757855825&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7icibozct5NMOfl5X1b5Q9pEYfEF1VCKJfstRQLEEr3m4sum5ntxdeozg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1082&quot;/&gt;&lt;/p&gt;&lt;p&gt;当然了，我们需要多jstack几次，如果每次jstack出来都刚好在这段代码左右，那么基本可以证明，是这段代码导致CPU飙升了。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;CPU突然飙升这个问题，我们很容易通过top -H和jstack找到对应的代码范围，这无疑极大的缩小了我们的定位范围。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.359781121751026&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7x75CliawsSwbWnz6VZu2PrSTxAfA1Bl6MN5VdbWG06xzJzllCqZWPBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1462&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ff90e84074ef2c18ad850fb0c96f2635</guid>
<title>[推荐] 腾讯 T4 一年的心血成就 17W 字操作系统、网络协议教程（附导图 + 笔记）</title>
<link>https://toutiao.io/k/kzxohh6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div id=&quot;article_content&quot; class=&quot;article_content clearfix&quot;&gt;
        
                &lt;div id=&quot;content_views&quot; class=&quot;htmledit_views&quot;&gt;
                    &lt;ul&gt;&lt;li&gt;《Java 核心技术总结》&lt;/li&gt;&lt;li&gt;《HTTP 总结》&lt;/li&gt;&lt;li&gt;《程序员必知的基础知识》&lt;/li&gt;&lt;li&gt;《操作系统总结》&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;这四本 PDF 可以说是一个比一个硬核。&lt;/p&gt; 
&lt;p&gt;先来说说 Java 核心技术总结&lt;/p&gt; 
&lt;h1&gt;Java 核心技术总结&lt;/h1&gt; 
&lt;p&gt;先来看一下本篇文章的思维导图吧，文章围绕下面这些内容进行讲解。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/972c835008f1bb8f20c1e539d4824b2a.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;这本 PDF 可以作为你的 Java 入门开发手册，也可以作为查漏补缺的利器&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/9c5dfcc1c3a06c599c3f3ae91c5a8d60.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/43de11080035e70fdda879e75b82ae1c.png&quot;/&gt;&lt;/p&gt; 
&lt;h1&gt;HTTP 核心总结&lt;/h1&gt; 
&lt;p&gt;第二本 PDF 的思维导图&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/5d44480ca1932b56955dd2da5c05257f.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;可以看看里面的绘图，真的是非常下功夫的。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/b85c0354729eadabd740e30dce2d7a90.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/6d26200b2b55f223a958978963dc7313.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;这个 PDF 几乎涵盖了关于 HTTP 99% 的知识点了&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/7501c9df42fd1ef0df9417cd9eeb4add.png&quot;/&gt;&lt;/p&gt; 
&lt;h1&gt;程序员必知的硬核知识&lt;/h1&gt; 
&lt;p&gt;在技术不断更新迭代的今天，你学习的速度已经跟不上框架迭代的速度了，当你还在学 Spring 3 的时候，Spring 5 就已经出来了。而且，现在会使用 Spring 的人简直太多了，大家都在研究新技术怎么用，框架怎么好，却忘了为什么要这么设计，构造原理是怎么样？所以，基础是重中之重，若干年前计算机只认识 0 和 1，现在仍然只能认识 0 和 1，所以你要把有限的时间放在不会改变的技术上。基础知识是亘古不变的，改变也只是会调优，而不会推翻。所以，我自己写了一本 PDF，是程序员必知的基础知识，来为你讲述这些不变的根本。&lt;/p&gt; 
&lt;p&gt;我带你重新认识了一下 CPU 是什么，CPU 寄存器有哪些&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/f70b396fea5f56c0354ccecce1e418e8.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/0025ed1955567d019250a22624f59444.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;我和你聊聊内存是什么&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/db0e4f15538f6a2cc5cabfede4ba78c2.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;我非常认真的为你总结了计算机中二进制的计算原则&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/0f54bcf40ebbed84f4fc0310892a3b50.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;我和你聊聊磁盘是如何出现的，以及它的发展历程，为什么磁盘能够存储数据？&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/b5a3f9d51081b75b6388f97568186d2c.png&quot;/&gt;&lt;/p&gt; 
&lt;h1&gt;操作系统总结&lt;/h1&gt; 
&lt;p&gt;这是我最硬核的一本 PDF 了&lt;/p&gt; 
&lt;p&gt;目录&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/415abd2a43a6fc140d85c789db46c88e.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;操作系统确实 太重要了，可以说没有操作系统，也就没有人给你扯这么多。所以非常有必要认识一下操作系统。&lt;/p&gt; 
&lt;p&gt;这本 PDF 带你认识了一下操作系统的一些核心概念，能够让你有个全局认识。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/0070a00b56c0a216840d5455ab48711e.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;这本 PDF 带你从入门到深入理解操作系统最核心的抽象：&lt;/p&gt; 
&lt;h1&gt;进程、文件、地址&lt;/h1&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/d804f8efe96fc6acd28a60bc13589bfd.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/cb551521aae107442484ef1d5c98328d.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/97b7a8356577d3eb5b92a9fde769219c.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;还为你汇总了操作系统核心面试题，助你一臂之力&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/82b097e87d093dfe2aca9b887b64d01d.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;这本 PDF 一共是 306 页，17w 字，我想这应该是全网第一份操作系统 PDF 了吧，希望大家能够珍藏。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/ee4acf87ee3b2a82c380cb9a7d946c2b.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;《Java 核心技术总结》《HTTP 总结》《程序员必知的基础知识》《操作系统总结》四本实战且实用的好教程你值得拥有，转发+评论，关注我添加VX：MXW5308 即可免费获取《Java 核心技术总结》《HTTP 总结》《程序员必知的基础知识》《操作系统总结》学习教程.pdf&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/20201006145432207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTEzMjIzOA==,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt;
                &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>42db61d130a472bc9e9997bf6256a91e</guid>
<title>[推荐] 技术方案设计的方法</title>
<link>https://toutiao.io/k/jc76sul</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;strong&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;前段时间接手了一个还处于方案设计阶段的工作，我重新做了设计。觉得新方案比旧方案业务清晰明朗、解决了旧方案的缺陷。我就很高兴，跟同事聊这个事情。同事就问我是怎么想到这些的呢。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我说了一些细节的，但是没有把核心本质讲出来。我觉得这是个很难回答的问题。因为一个方案怎么更合适，主要因素包含业务理解、个人经验、思维逻辑。这3个要素一般都是靠经年累月的积累才获得的。从这些中提取出别人可以学习和使用的方法确实不是一会儿就能想出来的事情。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;市面上可以看到的关于技术方案设计的经典的书都没有仔细的去讲这个问题。比如《人月神话》讲的是项目大了怎么办、《架构即未来》讲的是架构扩展性的问题。那对于最普通的CURD(创建更新读取删除)系统究竟怎么去设计。都是做CURD的，架构师和普通开发区别在哪里。本文就来探讨一下这个问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;CURD系统怎么做出技术含量&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;我前几年在面试别人的时候，遇到过一些面试者，已经带领别人做过项目了。可能人家的管理能力是不错的。项目管理是个博大精深的学问，可能一个项目在不同的阶段，更上层会找不同的管理者来做。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;比如初创团队，会找些善于创业、擅长打造敏捷团队的管理者。这样的管理者可能会比较善于鼓舞团队士气。而到了一定阶段，项目业务量起来之后，不再求快，而是求稳。这时候管理者可能会换人，新的管理者做事并不那么快，但是做决策的路很正。路很正怎么理解，打个比方说：别人提了需求，前一个领导人很好，人家来需求他就接。这个领导不是，他会分析利弊和领域、业务是否合适放在这里。再比如更一层领导提了一个需求，要求什么什么时间做完。这个领导会去分析上层领导更本质的需求，宁可延期，要做稳做好。而项目稳定之后，继续稳定下去已经没有什么业绩了。这时候可能会再换领导，这个领导会带来一些原来积累的规划、方法。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;总之，这个面试者可能有这些能力，但是我们要招聘一个技术人员，先考察硬实力，所以很自然的先请他介绍之前的项目做了什么和怎么做的。他自己也很没底气的说就是CURD嘛。给人感觉就是没有想法，在工作过程中思考的少。&lt;br/&gt;&lt;/p&gt;&lt;p&gt;拿一个后台管理系统来说，要对重要数据进行添加修改删除，一般需要审核、审计，敏感数据脱敏，甚至需要数据灰度。将这整套流程串联起来，需要一个工作流系统，可能会用到工作流引擎。目前有些数据脱敏已经用上了NLP(自然语言处理)技术。这里面每一步都涉及知识点。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;数据模型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;有限状态机设计&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;刚才提到后台管理系统里用到审核、审计、灰度。这三个可以与业务流程分离，做成三个工具组件。审核有审核状态：审核中、审核成功，审核失败。灰度也有待灰度、灰度中、灰度成功、灰度失败四种状态。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;假如有一条数据，目前它的状态可以分成数据状态：有效数据和无效数据。另外还有审核状态和灰度状态。这时候数据模型(可以简单理解成数据库的数据表设计)应该设计成三个状态用三个数据字段表示呢，还是用一个数据字段来表示这三种状态呢。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这要看情况，一般来说，如果三种状态之前是相互独立的，比如：审核中是否可以待灰度，也可能是灰度中？对于一个工作流系统来说，一般要先审核通过才会进行灰度流程。就是说各个状态是互斥的。所以设计成三个字段，程序的判断逻辑会很复杂，因为有些组合是不成立的。这时候更合理的一个设计是用一个状态字段表示，通过状态机流转来控制。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;设计方案中可以通过类似下面的流转图来体现：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.70917225950783&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8l6wfnRA330O2MsEGAdjo4UXbicbGAk4J6D65icIQOBXJHgzEu9uhZLpcia7DfTnApRXk5qLS2YvWQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;894&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;实际方案设计过程中我改造了一下，状态正常从左到右流转，将终态用不同的形状(这里用椭圆)来表示。这样表示秩序感强些，更好理解。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4270531400966184&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8l6wfnRA330O2MsEGAdjo4CT9KTLDLRCsUYWDb9vHQDW5BhUdnbzQFOpfxcKD33ncHb7KlC14L3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1035&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;数据表设计&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在数据表设计时，要至少考虑数据类型、是否默认、是否为空和索引设计。比如对于钱什么的，需要用decimal(10,2)，具体精确到多少位，要根据业务理解来定。对于加密字符什么的，加密如果是md5的，可以用char，而不用varchar来提高效率。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这里面就好像《红楼梦》里的台词一样，每条都很有学问。所以面试时的场景题也经常爱让进行一个数据表设计。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3135646687697161&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8l6wfnRA330O2MsEGAdjo4d6qxbIx3879enMZOOw4MR9HkqIz1geR7iaPxib0txhKKr0qe10WSMW4g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1585&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;流程设计&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我比较建议在一个设计方案开始时先把设计流程图先给出来，便于对方案有个整体认知。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;流程图也很有学问，【亿图】软件上把流程图分成了下面的子类。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.23336006415396954&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8l6wfnRA330O2MsEGAdjo41opFVQ2AJ6KMmQb4o7ic9OehJjEI5jM7e97SAYAXxZPK5nJTzzdMIIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1247&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我个人最常用的是泳道图和BPMN。BPMN可以简单理解为业务流程图和泳道图差别不大。就是在普通流程图基础上增加一个分类，这个分类可以是阶段、也可以是执行者这些。就是给流程图多增加一个维度的信息，理解起来更清晰。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7156511350059738&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8l6wfnRA330O2MsEGAdjo4iagBDgFFPI4dhnUWbtLACSc9Kibofoict49HzaKVv6t97M5m5hnibNc61Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;837&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在设计方案里还必须要有里程碑和未来规划。有句废话叫只怕有心人。在工作中，往往工作出色的并不是最聪明的，也不是花时间最长的。而是真正用心做的人。特别是设计方案，建议多用前人和大家总结的设计模板。模板最能代表一种设计思路。自己想到的、设计模板想到的都要考虑清楚，把方案做细。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;遇到具体的问题，要做业界调研。之前听过一个实习生做的方案，他说业界调研的时候并没有查到特别相关的方案资料。当时我的领导就说了一句特别值得思考的话：如果没有查到，肯定是你的检索关键词不对。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我后来反复斟酌这句话，发现能想到的检索关键词才是真正体现自己对业务理解的。同时，业界调研的时候不仅要对业务相关做调研，需求可以分解，具体到每个步骤也需要调研。调研过程是个极好的学习机会。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下功夫和不下功夫的区别，想想《红楼梦》，之所以这么多红学者。人家红楼梦的作者设计每句话都是剧透，人物说出的话，都会被啪啪打脸。里面的每道菜谱都是值得专业厨师来研究的。这都是心用到了。优秀架构师也是这样炼成的。之所以说这个废话，因为我就被diss过方案做的不够细，我也看过别人的方案不够细的。时常回想被diss不够细的那句话，觉得真的是金玉良言。心怀感激。&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f47b7c80e36fed8f236cd03688b31519</guid>
<title>[推荐] 《我想进大厂》之 Redis 夺命连环 11 问</title>
<link>https://toutiao.io/k/lko6b3m</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;（给&lt;/span&gt;&lt;span&gt;数据分析与开发&lt;/span&gt;&lt;span&gt;加星标，提升数据技能&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;来源：科技缪缪 （本文来自作者投稿）&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;说说Redis基本数据类型有哪些吧&lt;/span&gt;&lt;/span&gt;&lt;/h1&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;字符串：redis没有直接使用C语言传统的字符串表示，而是自己实现的叫做简单动态字符串SDS的抽象类型。C语言的字符串不记录自身的长度信息，而SDS则保存了长度信息，这样将获取字符串长度的时间由O(N)降低到了O(1)，同时可以避免缓冲区溢出和减少修改字符串长度时所需的内存重分配次数。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;链表linkedlist：redis链表是一个双向无环链表结构，很多发布订阅、慢查询、监视器功能都是使用到了链表来实现，每个链表的节点由一个listNode结构来表示，每个节点都有指向前置节点和后置节点的指针，同时表头节点的前置和后置节点都指向NULL。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;字典hashtable：用于保存键值对的抽象数据结构。redis使用hash表作为底层实现，每个字典带有两个hash表，供平时使用和rehash时使用，hash表使用链地址法来解决键冲突，被分配到同一个索引位置的多个键值对会形成一个单向链表，在对hash表进行扩容或者缩容的时候，为了服务的可用性，rehash的过程不是一次性完成的，而是渐进式的。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;跳跃表skiplist：跳跃表是有序集合的底层实现之一，redis中在实现有序集合键和集群节点的内部结构中都是用到了跳跃表。redis跳跃表由zskiplist和zskiplistNode组成，zskiplist用于保存跳跃表信息（表头、表尾节点、长度等），zskiplistNode用于表示表跳跃节点，每个跳跃表的层高都是1-32的随机数，在同一个跳跃表中，多个节点可以包含相同的分值，但是每个节点的成员对象必须是唯一的，节点按照分值大小排序，如果分值相同，则按照成员对象的大小排序。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;整数集合intset：用于保存整数值的集合抽象数据结构，不会出现重复元素，底层实现为数组。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;压缩列表ziplist：压缩列表是为节约内存而开发的顺序性数据结构，他可以包含多个节点，每个节点可以保存一个字节数组或者整数值。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;基于这些基础的数据结构，redis封装了自己的对象系统，包含字符串对象string、列表对象list、哈希对象hash、集合对象set、有序集合对象zset，每种对象都用到了至少一种基础的数据结构。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;redis通过encoding属性设置对象的编码形式来提升灵活性和效率，基于不同的场景redis会自动做出优化。不同对象的编码如下：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;字符串对象string：int整数、embstr编码的简单动态字符串、raw简单动态字符串&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;列表对象list：ziplist、linkedlist&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;哈希对象hash：ziplist、hashtable&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;集合对象set：intset、hashtable&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;有序集合对象zset：ziplist、skiplist&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis为什么快呢？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;redis的速度非常的快，单机的redis就可以支撑每秒10几万的并发，相对于mysql来说，性能是mysql的几十倍。速度快的原因主要有几点：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;完全基于内存操作&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;C语言实现，优化过的数据结构，基于几种基础的数据结构，redis做了大量的优化，性能极高&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;使用单线程，无上下文的切换成本&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;基于非阻塞的IO多路复用机制&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那为什么Redis6.0之后又改用多线程呢?&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;redis使用多线程并非是完全摒弃单线程，redis还是使用单线程模型来处理客户端的请求，只是使用多线程来处理数据的读写和协议解析，执行命令还是使用单线程。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这样做的目的是因为redis的性能瓶颈在于网络IO而非CPU，使用多线程能提升IO读写的效率，从而整体提高redis的性能。&lt;/span&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;知道什么是热key吗？热key问题怎么解决？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所谓热key问题就是，突然有几十万的请求去访问redis上的某个特定key，那么这样会造成流量过于集中，达到物理网卡上限，从而导致这台redis的服务器宕机引发雪崩。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.41714285714285715&quot; data-type=&quot;jpeg&quot; data-w=&quot;1050&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUmIwmSMLlrCHEj66HjJlAot2hSYkmxjb2lppicYuBMrmRia0jLg8zCMveicIHwbnFZ3dm7xo0xzyNOuA/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;针对热key的解决方案：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;提前把热key打散到不同的服务器，降低压力&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;加入二级缓存，提前加载热key数据到内存中，如果redis宕机，走内存查询&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;什么是缓存击穿、缓存穿透、缓存雪崩？&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;缓存击穿&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;缓存击穿的概念就是单个key并发访问过高，过期时导致所有请求直接打到db上，这个和热key的问题比较类似，只是说的点在于过期导致请求全部打到DB上而已。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;解决方案：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;加锁更新，比如请求查询A，发现缓存中没有，对A这个key加锁，同时去数据库查询数据，写入缓存，再返回给用户，这样后面的请求就可以从缓存中拿到数据了。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将过期时间组合写在value中，通过异步的方式不断的刷新过期时间，防止此类现象。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5056947608200456&quot; data-type=&quot;jpeg&quot; data-w=&quot;878&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUmIwmSMLlrCHEj66HjJlAot15ia9NJVxN1r9QDltntLmqC5MxBBlIOOBDvnvNBiciaYXFcOut4ZD5p1g/640?wx_fmt=jpeg&quot;/&gt;&lt;span&gt;https://tva&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;缓存穿透&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;缓存穿透是指查询不存在缓存中的数据，每次请求都会打到DB，就像缓存不存在一样。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5034802784222738&quot; data-type=&quot;jpeg&quot; data-w=&quot;862&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUmIwmSMLlrCHEj66HjJlAotfyfg1VfmxRiaxwqyukuox5QNiazUlicn7FJ9Anicbl8bPGf25VMYNYhKuQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;针对这个问题，加一层布隆过滤器。布隆过滤器的原理是在你存入数据的时候，会通过散列函数将它映射为一个位数组中的K个点，同时把他们置为1。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这样当用户再次来查询A，而A在布隆过滤器值为0，直接返回，就不会产生击穿请求打到DB了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;显然，使用布隆过滤器之后会有一个问题就是误判，因为它本身是一个数组，可能会有多个值落到同一个位置，那么理论上来说只要我们的数组长度够长，误判的概率就会越低，这种问题就根据实际情况来就好了。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.43381180223285487&quot; data-type=&quot;jpeg&quot; data-w=&quot;1254&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUmIwmSMLlrCHEj66HjJlAotwmfeKnHQeeQqYdkcqnYV61WpN3SKnJCxqpAZ1XauEAz6WyooC542KA/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;缓存雪崩&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当某一时刻发生大规模的缓存失效的情况，比如你的缓存服务宕机了，会有大量的请求进来直接打到DB上，这样可能导致整个系统的崩溃，称为雪崩。雪崩和击穿、热key的问题不太一样的是，他是指大规模的缓存都过期失效了。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.45010183299389&quot; data-type=&quot;jpeg&quot; data-w=&quot;982&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUmIwmSMLlrCHEj66HjJlAot0TVVVSI3kCN5mQIUwIU0jZeaZylKHeFRibbf473TNs9fF1Ut0Gg3rAg/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;针对雪崩几个解决方案：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;针对不同key设置不同的过期时间，避免同时过期&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;限流，如果redis宕机，可以限流，避免同时刻大量请求打崩DB&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;二级缓存，同热key的方案。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis的过期策略有哪些？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;redis主要有2种过期删除策略&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;惰性删除&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;惰性删除指的是当我们查询key的时候才对key进行检测，如果已经达到过期时间，则删除。显然，他有一个缺点就是如果这些过期的key没有被访问，那么他就一直无法被删除，而且一直占用内存。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.28149300155520995&quot; data-type=&quot;jpeg&quot; data-w=&quot;1286&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUmIwmSMLlrCHEj66HjJlAotTUJJNic94cee1OKFlibBEJpiazwQu2YRicbyicicpYiboFYicnDETibNddYdO7A/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;定期删除&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;定期删除指的是redis每隔一段时间对数据库做一次检查，删除里面的过期key。由于不可能对所有key去做轮询来删除，所以redis会每次随机取一些key去做检查和删除。&lt;/span&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么定期+惰性都没有删除过期的key怎么办？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;假设redis每次定期随机查询key的时候没有删掉，这些key也没有做查询的话，就会导致这些key一直保存在redis里面无法被删除，这时候就会走到redis的内存淘汰机制。&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;volatile-lru：从已设置过期时间的key中，移出最近最少使用的key进行淘汰&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;volatile-ttl：从已设置过期时间的key中，移出将要过期的key&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;volatile-random：从已设置过期时间的key中随机选择key淘汰&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;allkeys-lru：从key中选择最近最少使用的进行淘汰&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;allkeys-random：从key中随机选择key进行淘汰&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;noeviction：当内存达到阈值的时候，新写入操作报错&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;持久化方式有哪些？有什么区别？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;redis持久化方案分为RDB和AOF两种。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;RDB&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;RDB持久化可以手动执行也可以根据配置定期执行，它的作用是将某个时间点上的数据库状态保存到RDB文件中，RDB文件是一个压缩的二进制文件，通过它可以还原某个时刻数据库的状态。由于RDB文件是保存在硬盘上的，所以即使redis崩溃或者退出，只要RDB文件存在，就可以用它来恢复还原数据库的状态。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可以通过SAVE或者BGSAVE来生成RDB文件。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;SAVE命令会阻塞redis进程，直到RDB文件生成完毕，在进程阻塞期间，redis不能处理任何命令请求，这显然是不合适的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;BGSAVE则是会fork出一个子进程，然后由子进程去负责生成RDB文件，父进程还可以继续处理命令请求，不会阻塞进程。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;AOF&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;AOF和RDB不同，AOF是通过保存redis服务器所执行的写命令来记录数据库状态的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;AOF通过追加、写入、同步三个步骤来实现持久化机制。&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;当AOF持久化处于激活状态，服务器执行完写命令之后，写命令将会被追加append到aof_buf缓冲区的末尾&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在服务器每结束一个事件循环之前，将会调用flushAppendOnlyFile函数决定是否要将aof_buf的内容保存到AOF文件中，可以通过配置appendfsync来决定。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;always &lt;span&gt;##aof_buf内容写入并同步到AOF文件&lt;/span&gt;&lt;br/&gt;everysec &lt;span&gt;##将aof_buf中内容写入到AOF文件，如果上次同步AOF文件时间距离现在超过1秒，则再次对AOF文件进行同步&lt;/span&gt;&lt;br/&gt;no &lt;span&gt;##将aof_buf内容写入AOF文件，但是并不对AOF文件进行同步，同步时间由操作系统决定&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果不设置，默认选项将会是everysec，因为always来说虽然最安全（只会丢失一次事件循环的写命令），但是性能较差，而everysec模式只不过会可能丢失1秒钟的数据，而no模式的效率和everysec相仿，但是会丢失上次同步AOF文件之后的所有写命令数据。&lt;/span&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;怎么实现Redis的高可用？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;要想实现高可用，一台机器肯定是不够的，而redis要保证高可用，有2个可选方案。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;主从架构&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;主从模式是最简单的实现高可用的方案，核心就是主从同步。主从同步的原理如下：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;slave发送sync命令到master&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;master收到sync之后，执行bgsave，生成RDB全量文件&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;master把slave的写命令记录到缓存&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;bgsave执行完毕之后，发送RDB文件到slave，slave执行&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;master发送缓存中的写命令到slave，slave执行&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6389548693586699&quot; data-type=&quot;jpeg&quot; data-w=&quot;842&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUmIwmSMLlrCHEj66HjJlAotdopLgAB9KKiah8qqA71ZkztXrn885zDVCyFSnricEAPyWdo9w9lxG6icg/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里我写的这个命令是sync，但是在redis2.8版本之后已经使用psync来替代sync了，原因是sync命令非常消耗系统资源，而psync的效率更高。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;哨兵&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;基于主从方案的缺点还是很明显的，假设master宕机，那么就不能写入数据，那么slave也就失去了作用，整个架构就不可用了，除非你手动切换，主要原因就是因为没有自动故障转移机制。而哨兵(sentinel)的功能比单纯的主从架构全面的多了，它具备自动故障转移、集群监控、消息通知等功能。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7674943566591422&quot; data-type=&quot;jpeg&quot; data-w=&quot;886&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUmIwmSMLlrCHEj66HjJlAotgVjlOy0uURyKRueXhar16F3ndHj2sQOme4tLbAGwg4Pia5dzcucWhXA/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;哨兵可以同时监视多个主从服务器，并且在被监视的master下线时，自动将某个slave提升为master，然后由新的master继续接收命令。整个过程如下：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;初始化sentinel，将普通的redis代码替换成sentinel专用代码&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;初始化masters字典和服务器信息，服务器信息主要保存ip:port，并记录实例的地址和ID&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;创建和master的两个连接，命令连接和订阅连接，并且订阅sentinel:hello频道&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;每隔10秒向master发送info命令，获取master和它下面所有slave的当前信息&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;当发现master有新的slave之后，sentinel和新的slave同样建立两个连接，同时每个10秒发送info命令，更新master信息&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;sentinel每隔1秒向所有服务器发送ping命令，如果某台服务器在配置的响应时间内连续返回无效回复，将会被标记为下线状态&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;选举出领头sentinel，领头sentinel需要半数以上的sentinel同意&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;领头sentinel从已下线的的master所有slave中挑选一个，将其转换为master&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;让所有的slave改为从新的master复制数据&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将原来的master设置为新的master的从服务器，当原来master重新回复连接时，就变成了新master的从服务器&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;sentinel会每隔1秒向所有实例（包括主从服务器和其他sentinel）发送ping命令，并且根据回复判断是否已经下线，这种方式叫做主观下线。当判断为主观下线时，就会向其他监视的sentinel询问，如果超过半数的投票认为已经是下线状态，则会标记为客观下线状态，同时触发故障转移。&lt;/span&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;能说说redis集群的原理吗？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果说依靠哨兵可以实现redis的高可用，如果还想在支持高并发同时容纳海量的数据，那就需要redis集群。redis集群是redis提供的分布式数据存储方案，集群通过数据分片sharding来进行数据的共享，同时提供复制和故障转移的功能。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;节点&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一个redis集群由多个节点node组成，而多个node之间通过cluster meet命令来进行连接，节点的握手过程：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;节点A收到客户端的cluster meet命令&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;A根据收到的IP地址和端口号，向B发送一条meet消息&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;节点B收到meet消息返回pong&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;A知道B收到了meet消息，返回一条ping消息，握手成功&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;最后，节点A将会通过gossip协议把节点B的信息传播给集群中的其他节点，其他节点也将和B进行握手&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2459605026929982&quot; data-type=&quot;jpeg&quot; data-w=&quot;1114&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUmIwmSMLlrCHEj66HjJlAot333fTiaaCA3ibxfwpnZ8VbzLkaM4cxHs23REHZVCibGUF4GdZmLNviaPYQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;槽slot&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;redis通过集群分片的形式来保存数据，整个集群数据库被分为16384个slot，集群中的每个节点可以处理0-16384个slot，当数据库16384个slot都有节点在处理时，集群处于上线状态，反之只要有一个slot没有得到处理都会处理下线状态。通过cluster addslots命令可以将slot指派给对应节点处理。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;slot是一个位数组，数组的长度是16384/8=2048，而数组的每一位用1表示被节点处理，0表示不处理，如图所示的话表示A节点处理0-7的slot。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.20159680638722555&quot; data-type=&quot;jpeg&quot; data-w=&quot;1002&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUmIwmSMLlrCHEj66HjJlAot9WNKa3CWnMYFY4JK5MKCOdcUZYmsYtpa7RNofu11gamgcRibyU14y0g/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当客户端向节点发送命令，如果刚好找到slot属于当前节点，那么节点就执行命令，反之，则会返回一个MOVED命令到客户端指引客户端转向正确的节点。（MOVED过程是自动的）&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3784135240572172&quot; data-type=&quot;jpeg&quot; data-w=&quot;1538&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUmIwmSMLlrCHEj66HjJlAotRea7czTYia2kyQric4rkZOdnbfD7U4WHLErfu6BjU4jvTGicGZFLVTaicA/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果增加或者移出节点，对于slot的重新分配也是非常方便的，redis提供了工具帮助实现slot的迁移，整个过程是完全在线的，不需要停止服务。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;故障转移&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果节点A向节点B发送ping消息，节点B没有在规定的时间内响应pong，那么节点A会标记节点B为pfail疑似下线状态，同时把B的状态通过消息的形式发送给其他节点，如果超过半数以上的节点都标记B为pfail状态，B就会被标记为fail下线状态，此时将会发生故障转移，优先从复制数据较多的从节点选择一个成为主节点，并且接管下线节点的slot，整个过程和哨兵非常类似，都是基于Raft协议做选举。&lt;/span&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;了解Redis事务机制吗？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;redis通过MULTI、EXEC、WATCH等命令来实现事务机制，事务执行过程将一系列多个命令按照顺序一次性执行，并且在执行期间，事务不会被中断，也不会去执行客户端的其他请求，直到所有命令执行完毕。事务的执行过程如下：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;服务端收到客户端请求，事务以MULTI开始&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果客户端正处于事务状态，则会把事务放入队列同时返回给客户端QUEUED，反之则直接执行这个命令&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;当收到客户端EXEC命令时，WATCH命令监视整个事务中的key是否有被修改，如果有则返回空回复到客户端表示失败，否则redis会遍历整个事务队列，执行队列中保存的所有命令，最后返回结果给客户端&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;WATCH的机制本身是一个CAS的机制，被监视的key会被保存到一个链表中，如果某个key被修改，那么REDIS_DIRTY_CAS标志将会被打开，这时服务器会拒绝执行事务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a class=&quot;weapp_image_link&quot; data-miniprogram-appid=&quot;wx4b74228baa15489a&quot; data-miniprogram-path=&quot;lib/item/dist/pages/index/index?itemId=3715169443&amp;amp;vrk=&amp;amp;wfr=&amp;amp;feeSource=&quot; data-miniprogram-nickname=&quot;微店+&quot; href=&quot;&quot; data-miniprogram-type=&quot;image&quot; data-miniprogram-servicetype=&quot;&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/75TZzMDzrHibtibjlZicku5iavkCvWy2y2V8iaEeuYIWVUEzbjictJzAUILetyZQlxIMXk4ghnTBsTWvQPnMwd4vnjPA/640?wx_fmt=jpeg&quot;/&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5ODM5MDU3MA==&amp;amp;mid=2650868182&amp;amp;idx=2&amp;amp;sn=81c5789013e17ddb73fb1f81d33d09ac&amp;amp;chksm=8b67ee93bc106785c02b589e0c4302ebac580a30729512053a80577e9afbce8ca48d3102c442&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;1、一文把 Redis 主从复制、哨兵、Cluster 三种模式摸透&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;1、一文把 Redis 主从复制、哨兵、Cluster 三种模式摸透&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5ODM5MDU3MA==&amp;amp;mid=2650868079&amp;amp;idx=1&amp;amp;sn=0e579b8c26b32234cbfc4f3b44e785fd&amp;amp;chksm=8b67ee2abc10673c00be104be10dd41602ec783cc0ff432670e2f6d0f0bfcf5fd7a531f6f8a5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;2、还不懂 Redis？看完这个故事就明白了&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;2、还不懂 Redis？看完这个故事就明白了&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5ODM5MDU3MA==&amp;amp;mid=2650868046&amp;amp;idx=1&amp;amp;sn=e8a2519905475776b061f98d12815e5e&amp;amp;chksm=8b67ee0bbc10671dbec55063670fc4a500bd12f992c6095edbcd7aa0ce9796850fd523a4616e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;3、Redis 秒杀实战&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;3、Redis 秒杀实战&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;关注「数据分析与开发」加星标，提升数据技能&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-copyright=&quot;0&quot; data-ratio=&quot;0.9166666666666666&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DmibiaFiaAI4B3YpcZYPicgc9JTMiaACNXE5A9FePsKgBic7LNlibx2fwVycTN4Wq47TzYXTNnP2PCKCVAGibNmzDnD0zg/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;好文章，我&lt;/span&gt;&lt;span&gt;在看&lt;/span&gt;&lt;span&gt;❤️&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>753832b670f73e24ae288346501aeff3</guid>
<title>[推荐] 建设微服务 API 网关的一些实践</title>
<link>https://toutiao.io/k/4li9ai2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-body post-body--article vditor-reset&quot;&gt;
                    &lt;p&gt;随着这些年微服务的流行，API网关已经成为微服务架构中不可或缺的一环。一方面它承担着服务对外的唯一门户，一方面它提取了许多应用的共性功能。&lt;/p&gt;
&lt;h2 id=&quot;toc_h2_0&quot;&gt;整体架构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2020-10-07-082018.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们的Api网关目前的架构如上所示，可以看到Api网关处于一个什么位置，往上承接所有的南北流量，往下会分发流量到微服务应用或者BFF聚合应用，在BFF规范化之前我们仍然将其视为一个普通微服务应用。&lt;/p&gt;
&lt;p&gt;目前Api网关实现的功能包括请求分发、条件路由、Api管理、限流隔离、熔断降级、安全策略、监控报警以及调用链追踪等。&lt;br/&gt;
&lt;img src=&quot;https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2020-10-09-074430.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们的Api网关基于RxNetty开发，整个流程是异步响应式的，可以达到较高的单机并发。基于少造轮子的理念，Api网关的大部分功能都是结合现有平台实现。包括请求分发、条件路由基于微服务框架，限流隔离、熔断降级基于稳定性平台，监控报警基于监控平台等，安全策略基于大数据分析平台等。注册中心与配置中心则分别负责服务注册核心信息与第三方配置信息的下发。&lt;/p&gt;
&lt;h2 id=&quot;toc_h2_1&quot;&gt;请求分发&lt;/h2&gt;
&lt;p&gt;请求的分发路由应该是一个网关最基本的功能，在绝大多数基于nginx开发的网关上，这部分功能通常基于动态更新代理的upstream。而在我们的实现中，认为网关是一个只订阅不注册的微服务而已，区别是微服务应用发起rpc调用指定了调用服务，而网关接收请求分发只有url信息。这可以通过简单的改造来复用已有微服务框架的服务发现功能。&lt;/p&gt;
&lt;p&gt;经过一系列url规范化行动后，我们的url目前不同的应用都会采取不同的前缀，同时这个前缀信息会随着应用注册到注册中心。这样网关进行服务发现时会给不同的url前缀以及微服务应用构建不同的namespace对象，在进行请求匹配时候只需根据url前缀选取到对应的namespace即可匹配到对应微服务应用，后续就是现有微服务框架sdk的功能：路由、负载均衡直至完成整个调用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2020-10-08-075648.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里还涉及到另一个问题，网关选择服务发现的应用是哪些？即我需要拉取哪些应用信息以构建namespace?我们这里对服务发现对象进行了管理，用户可在管控平台上控制微服务应用在网关层的上下线，这会通过我们的配置中心推送到网关并进行一次热更新，刷新内存缓存，这样就做到了请求分发服务的动态增减。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2020-10-08-090717.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;toc_h2_2&quot;&gt;条件路由&lt;/h2&gt;
&lt;p&gt;条件路由意味着可以对具有特定内容(或者一定流量比例)的请求进行筛选并分发到特定实例组上，是实现灰度发布、蓝绿发布、ABTest等功能的基础。&lt;/p&gt;
&lt;p&gt;同样的，在基于nginx开发的网关中，一般是维护多套upstream列表，然后通过某种策略将不同请求代理到不同upstream。&lt;/p&gt;
&lt;p&gt;在我们的实现中，条件路由依然是复用现有的微服务框架，避免重复造轮子。每个应用都可以根据一些规则创建一些分组，分组中有若干实例。在网关进行服务发现初始化时会给每个应用创建Invoker代理对象，Invoker内会根据不同的分组创建不同的Space空间，请求调用时会对这些Space空间进行规则匹配，从而决定是否路由到特定分组上。整个过程都是微服务框架完成的，没有额外的开发工作。&lt;/p&gt;
&lt;p&gt;目前我们支持按照特定内容或者流量比例两种方式进行请求来源规则的匹配，特定内容包括http请求的header、attribute等等。我们目前的实例分组主要是根据&quot;版本&quot;这个标来区分的，所以分配规则主要是支持&quot;版本&quot;维度，未来考虑支持到k8s的pod label。&lt;/p&gt;
&lt;h2 id=&quot;toc_h2_3&quot;&gt;Api管理&lt;/h2&gt;
&lt;p&gt;Api网关为什么前面要有Api几个字，我觉得其中一个很重要的原因就是具有Api管理功能。当我们的大部分应用还是裸连网关，而不是经过BFF聚合时，我们有必要对每个api接口都进行管理，以区分哪些是微服务间内部调用，哪些是暴露给前端/客户端调用。&lt;/p&gt;
&lt;p&gt;实现上和之前的应用上下线类似，额外依赖了DB存储，用户在管控平台进行api发布等操作会先存储在DB中，随后通过配置中心pub/sub通知到网关。我们在namespace匹配前加入了一层filter以过滤删除/未上线的api，所以热更新该filter对象即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2020-10-08-095004.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用户体验方面我们也做了一些工作，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从微服务管控平台直接同步新增的api接口到网关管控平台，而无需手动添加。此外也支持多种格式的文件导入。(我们的微服务注册模型会包括api信息等元数据)&lt;/li&gt;
&lt;li&gt;各个环境之间通过流转功能发布api，而无需重复添加&lt;/li&gt;
&lt;li&gt;对各个状态的筛选展示&lt;/li&gt;
&lt;li&gt;与devops平台配合，在应用发布流转时同步提醒进行api管理的发布流转。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2020-10-09-032340.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;toc_h2_4&quot;&gt;限流隔离/熔断降级&lt;/h2&gt;
&lt;p&gt;Api网关作为南北流量的唯一入口，一般具有较高并发度，以及流量复杂性。所以对入口流量进行整治管理是很有必要的。&lt;/p&gt;
&lt;p&gt;我们的限流隔离/熔断降级均基于稳定性平台与配置中心实现，稳定性平台是我们基于Sentinel二次开发的。整个结构如下图所示：&lt;br/&gt;
&lt;img src=&quot;https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2020-10-09-074122.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;稳定性相关的功能主要包括限流隔离以及熔断降级。限流隔离主要是作用在流入方向服务端测的流量控制，其中限流主要是控制qps，隔离主要是控制并发数。熔断降级则是作用在流出方向客户端测的流量控制，可以配置在一定错误率情况下进行熔断，并配合降级数据快速返回。&lt;/p&gt;
&lt;p&gt;以上规则均可以通过稳定性平台配置，然后由配置中心分发到api网关，再进行热更新刷新内存缓存。每次请求时sentinel sdk都会帮我们做好数据统计并判断是否符合规则，同时被限流隔离、熔断降级的流量都会通过相关sdk(基于prometheus)暴露metrics数据给监控平台，以便我们随时观察到流量控制水平。&lt;/p&gt;
&lt;h2 id=&quot;toc_h2_5&quot;&gt;安全策略&lt;/h2&gt;
&lt;p&gt;时常我们会遇见一些异常流量，典型的就是恶意爬虫，所以完善一些基础的安全策略是必要的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2020-10-09-081340.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;整个安全策略的结构如上所示。用户可以在网关管控平台手动进行规则配置，经由配置中心下发到api网关的securityControl进行热更新。在请求来临时由securityControl判断是否符合规则，被封禁的流量同样暴露metrics数据给监控平台供我们随时查看。&lt;/p&gt;
&lt;p&gt;此外，手动配置封禁规则在某些场景可能比较低效。我们同时还会将网关日志实时采集至大数据分析平台，经分析后如果判断某个ip或者用户存在异常情况，会自动配置安全策略规则至网关管控平台，同时触发一个报警提醒业务owner。&lt;/p&gt;
&lt;p&gt;在安全策略目标方面，我们目前支持包括根据客户端IP、用户ID、其余http header/attribute等。策略行为方面目前支持快速失败以及验证码，后者用户会在前端被跳转到一个人机验证码的页面。&lt;/p&gt;
&lt;h2 id=&quot;toc_h2_6&quot;&gt;监控报警/调用链追踪&lt;/h2&gt;
&lt;p&gt;与其他微服务应用一样，我们的api网关也有完善的监控报警、调用链追踪、日志查询等功能。这里监控主要指的是查询metrics信息，调用链主要指查询tracing信息，日志顾名思义就是logging，三者是监控领域很典型的信息了：&lt;br/&gt;
&lt;img src=&quot;https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2020-10-09-084657.jpg&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;
报警这块除了针对metrics信息/错误日志的报警，还可以支持主机层面的报警。&lt;/p&gt;
&lt;p&gt;得益于监控平台以及调用链埋点sdk，api网关几乎不需要改造成本即可接入。整体结构如下所示，api网关内嵌了metrics sdk暴露metrics信息到endpoint供监控中心拉取，tracing sdk负责埋点打印tracing日志，tracing日志和业务日志均会通过日志采集器输入监控中心处理。在监控平台上，用户可以查询调用链、监控、日志信息，api网关发生的主机异常或者业务异常也会报警给owner。&lt;br/&gt;
&lt;img src=&quot;https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2020-10-09-122040.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里值得一提的是，当网关调用后端微服务应用发生异常时，例如超时、连接池耗尽等，这些错误发生在客户端即api网关，所以触发的报警只会报给api网关的owner。但是api网关仅仅作为一个转发服务，其超时很大程度是因为后端微服务rt过高，所以报警应该同时报给后端微服务owner，为此我们开发了双端告警，一份告警会同时发送给客户端和服务端双方。&lt;/p&gt;
&lt;h2 id=&quot;toc_h2_7&quot;&gt;一些总结&lt;/h2&gt;
&lt;p&gt;当然api网关还有许多没有展开说的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们还支持websocket协议，本次没有详细说&lt;/li&gt;
&lt;li&gt;在多云部署环境下，网关承载了一个多云流量调度服务的角色。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以及未来可以优化的地方&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先是我们的高并发能力并未怎么经过实际验证，由于tob商业模式公司没有太多高并发的场景。&lt;/li&gt;
&lt;li&gt;考虑引入规则引擎来应付各种下发的规则，包括安全策略、稳定性、路由规则等。&lt;/li&gt;
&lt;li&gt;安全策略考虑会支持更多一些，例如IP网段，及支持各种逻辑与或非&lt;/li&gt;
&lt;/ul&gt;
                        
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>