<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>8645772802041cebc925b043a382909e</guid>
<title>程序员系列之软技能</title>
<link>https://toutiao.io/k/xxf6n5x</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;img data-w=&quot;584&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4DaJ7DGCek7dc0NCUwMGadNCLLm8fFfDo2WKX72gFO21gTBC1sjNSf3pn1bR8gQTpBa55bFr6MUrM8uT9miawCw/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;《软技能-代码之外得生存指南》译版在2016.8就有了，有幸拜读了，收获不少，结合书籍内容和自己的总结，梳理了一下。&lt;/p&gt;&lt;h1&gt;&lt;strong&gt;心态&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;作为“打工人”，大部分程序员对于自己的定位是非常狭隘的，所谓的“螺丝钉”是对自己的标榜，往往是背了“八股文”，包装了项目经历，再加上那么一点点运气进入了厂子里，然后就真的变成了一个“工人”，自己只是任务执行者，完全不会想着在公司上班也是需要有经营思维的。&lt;br/&gt;程序员本质上是“匠人”，而在心态上，需要将自己作为“铁匠铺”进行经营。作为店铺的经营者，除了提供专业的服务，待人接物，影响力等等都需要下功夫。&lt;/p&gt;&lt;h1&gt;&lt;strong&gt;目标&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;想成为什么样的人，想取得什么样的成就，想过什么样的生活……&lt;br/&gt;&lt;strong&gt;目标&lt;/strong&gt;——无论对于个人还是团队都是一切行动之根本。没有目标就跟在大海里航行没有目的地一样，有了目标，一切的行动才是有效的动作，否则就是在浪费资源。&lt;br/&gt;俗话说“人无远虑，必有近忧”，制定符合自身情况的短期目标、长期目标对于自身发展和成长是必不可少的。&lt;br/&gt;就拿“&lt;strong&gt;早起&lt;/strong&gt;”这件事来说，很多人都热衷于参加早起计划、早起打卡等，每天都在坚持着，但是往往坚持一段时间之后就不了了之，该晚睡还是晚睡，该晚起还是晚起。&lt;br/&gt;这是为什么呢？&lt;br/&gt;在我看来，这部分人就是没有确立自己的目标造成的。早起只是实现目标，到达目的地的一种实现方式。比如，我想&lt;strong&gt;减掉脂肪肝&lt;/strong&gt;，那么晚睡熬夜这样的行为就必须要制止，每天晚上进行5公里的慢跑，减少碳水的摄入，自然而然，在10点左右，身体自己就提醒你需要休息了，10点半入睡，休息6、7个小时，5点左右醒来就是非常容易的事情了。&lt;/p&gt;&lt;h1&gt;&lt;strong&gt;人际交往&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;谈软技能，一定会说到人际交往，或者是高情商。对于一名程序员，好像说话、表达是永远过不去的坎儿，从我自身的经历来说，任何技能的掌握和熟练使用都需要无数次的重复练习。&lt;br/&gt;就拿沟通这件事来说，不会说话，不敢说话，不敢当众表达等等都是自我限定。想要有良好的沟通能力，没有速成的方法，只能有意识的进行大量的沟通练习，包括寻找机会与人说话，学习话术，事后反思总结等。&lt;br/&gt;“&lt;strong&gt;以自己为核心，每个人都希望自己很重要&lt;/strong&gt;”——这是人性的弱点，具有共性，所以一切沟通交流把握这一规律，无论你说什么，大概率人们是喜欢跟你聊天沟通的。&lt;br/&gt;具体沟通方式包括：&lt;/p&gt;&lt;h1&gt;&lt;strong&gt;影响力&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;大部分的程序员，对于影响力对自身发展的重要性没有清楚的认知。更多人标榜的是“我只想安安静静码代码”。&lt;br/&gt;然而事实是，作为社会的一员，无论从事什么工作，社会属性都是人们绕不过去的内容。想要有所成就，让自己具有话语权，提升自己对他人的影响力是必须要走的道路。&lt;br/&gt;作为程序员，如何能提升自身的影响力呢？&lt;br/&gt;那就是“&lt;strong&gt;为他人增加价值&lt;/strong&gt;”，具体形式包括：&lt;/p&gt;&lt;h1&gt;&lt;strong&gt;自学&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;作为技术工种，程序员与传统的技术工种一大重要不同点是，作为铁匠，只要你掌握了打铁的技术，靠着这项技术可以养活自己，而程序员从事的编码工作就需要不断的补充学习新的技术栈，所以自我驱动学习的能力是必备的技能之一。&lt;br/&gt;每个程序员都有自己的学习方式方法，这里介绍一种通用的方法，“十步学习法”。该方法分为两个阶段，其中，①-⑥为第一阶段，⑦-⑩为第二阶段。&lt;/p&gt;&lt;ul class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;①扫全局&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;②划范围&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;③定目标&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;④找资源&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;⑤列计划&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;⑥筛资源&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;⑦学习&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;⑧操作&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;⑨掌握&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;⑩为人师&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;对于一门新的技术或者语言，如何进行自学呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第一阶段（只做一次）&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;第一阶段是准备阶段，只需要做一次。目标是让自己理清楚需要学习的内容、目标以及能够获取足够学习的资源。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;扫全局&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;第一个步骤就是对要学习的内容有一个全局性的了解，比如学习java语言，找到一本java语言的书籍，花少量的时间读下其中介绍性的章节，粗略浏览下内容即可。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;划范围&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;经过第一个步骤，对要学的东西有个基本的了解了，下一步就是集中精力去明确自己到底要学什么。&lt;br/&gt;还是以学习java语言为例，此时，你需要理解的是“这个题目到底有多大”，以及“如何将其分解为更小的范围”。在一定时间内，你不可能掌握关于java的一切知识，所以需要决定学习的重点和范围。如果你想了解java的基本语法规范，那么这就是你的学习范围。&lt;br/&gt;其中，在这一步中需要注意的点是：明确学习范围的时候要考虑&lt;strong&gt;时间因素&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;定目标&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;目标即评价&lt;/strong&gt;。在全力以赴启动之前，明确“成功”的含义极为重要。有了学习目标，就可以使用倒推的方式，明确实现目标需要的步骤。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;找资源&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;要尝试收集到多种多样的资源以帮助自己学习。包括但不限于，书籍、视频教程、公众号文章、开源项目、博客、在线文档或者培训机构等。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;列计划&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;创建学习计划，按图索骥，即创建学习路径，给自己一个大纲。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;筛资源&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;按照学习计划，筛选出对于目标有帮助的资源。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第二阶段（循环往复）&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;这是一个不断迭代的过程，想要掌握一门语言或者技术，就需要不断的重复再重复。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;学习&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;开始学习的第一步是：&lt;strong&gt;慢&lt;/strong&gt;，需要浅尝辄止。类似玩儿游戏，一开始都要有导学部分，让自己熟悉操作，熟悉技能等。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;操作&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;边玩边学。兴趣是最好的老师。先亲自操作和亲身体验，通过探索和实践进行学习。好处是你的大脑会自然产生各种问题，这些问题会引导自己走向答案，也更容易记忆，因为这些答案对你自己是重要的。模仿是一种好的学习手段。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;掌握&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;好奇心是学习特别是自学的重要组成部分。让问题和好奇，结合自己整理的资源，尽可能地汲取知识。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;为人师&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;乐为人师，方可融会贯通。走出自己的舒适区，给自己反思、补缺的机会。&lt;/p&gt;&lt;h1&gt;&lt;strong&gt;拜师&amp;amp;收徒&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;传道授业，三人行必有我师，认老师同时做老师，保持谦逊而有自信的状态。共勉。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1e5330a728dde7fe4d84f3fe026c6d5c</guid>
<title>庖丁解 InnoDB 之 REDO LOG</title>
<link>https://toutiao.io/k/bpcscxg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p id=&quot;js_tags&quot; class=&quot;article-tag__list single-tag__wrp js_single&quot; data-len=&quot;1&quot; role=&quot;link&quot; aria-labelledby=&quot;js_article-tag-card__left&quot; aria-describedby=&quot;js_article-tag-card__right&quot;&gt;
                                            
                                                                                    &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__left&quot; class=&quot;article-tag-card__left&quot;&gt;
                                    &lt;span class=&quot;article-tag-card__title&quot;&gt;收录于话题&lt;/span&gt;
                                    &lt;span class=&quot;article-tag__item-wrp no-active js_tag&quot; data-url=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzIzOTU0NTQ0MA==&amp;amp;action=getalbum&amp;amp;album_id=1530994292440301570#wechat_redirect&quot; data-tag_id=&quot;&quot; data-album_id=&quot;1530994292440301570&quot; data-tag_source=&quot;3&quot;&gt;
                                        &lt;span class=&quot;article-tag__item&quot;&gt;#数据库&lt;/span&gt;
                                    &lt;/span&gt;
                                &lt;/span&gt;
                                &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__right&quot; class=&quot;article-tag-card__right&quot;&gt;18个&lt;span class=&quot;weui-hidden_abs&quot;&gt;内容&lt;/span&gt;&lt;/span&gt;
                                                                                        &lt;/p&gt;

                
                                
                
                

                
                                                                

                
                                


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100019184&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6240234375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naJlWnrTeROJt0xVJOoHoPC10DdMhibajeafWE1p64IojlE2HcVEvHicTWbqFNJw6xLuY90Tcc5afExA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1024&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;数据库故障恢复机制的前世今生一文&lt;/span&gt;&lt;span&gt;中&lt;/span&gt;&lt;span&gt;提到，今生&lt;/span&gt;&lt;span&gt;磁盘数据库为了在保证数据库的原子性(A, Atomic) 和持久性(D, Durability)的同时，还能以灵活的刷盘策略来充分利用磁盘顺序写的性能，会记录REDO和UNDO日志，即ARIES方法。本文将重点介绍REDO LOG的作用，记录的内容，组织结构，写入方式等内容，希望读者能够更全面准确的理解REDO LOG在InnoDB中的位置。本文基于MySQL 8.0代码。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;一  为什么需要记录REDO&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;为了取得更好的读写性能，InnoDB会将数据缓存在内存中（InnoDB Buffer Pool），对磁盘数据的修改也会落后于内存，这时如果进程或机器崩溃，会导致内存数据丢失，为了保证数据库本身的一致性和持久性，InnoDB维护了REDO LOG。修改Page之前需要先将修改的内容记录到REDO中，并保证REDO LOG早于对应的Page落盘，也就是常说的WAL，Write Ahead Log。当故障发生导致内存数据丢失后，InnoDB会在重启时，通过重放REDO，将Page恢复到崩溃前的状态。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;二  需要什么样的REDO&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;那么我们需要什么样的REDO呢？首先，REDO的维护增加了一份写盘数据，同时为了保证数据正确，事务只有在他的REDO全部落盘才能返回用户成功，REDO的写盘时间会直接影响系统吞吐，显而易见，REDO的数据量要尽量少。其次，系统崩溃总是发生在始料未及的时候，当重启重放REDO时，系统并不知道哪些REDO对应的Page已经落盘，因此REDO的重放必须可重入，即REDO操作要保证幂等。最后，为了便于通过并发重放的方式加快重启恢复速度，REDO应该是基于Page的，即一个REDO只涉及一个Page的修改。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;熟悉的读者会发现，数据量小是Logical Logging的优点，而幂等以及基于Page正是Physical Logging的优点，因此InnoDB采取了一种称为Physiological Logging的方式，来兼得二者的优势。所谓Physiological Logging，就是以Page为单位，但在Page内以逻辑的方式记录。举个例子，MLOG_REC_UPDATE_IN_PLACE类型的REDO中记录了对Page中一个Record的修改，方法如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;（Page ID，Record Offset，(Filed 1, Value 1) ... (Filed i, Value i) ... )&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其中，PageID指定要操作的Page页，Record Offset记录了Record在Page内的偏移位置，后面的Field数组，记录了需要修改的Field以及修改后的Value。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;由于Physiological Logging的方式采用了物理Page中的逻辑记法，导致两个问题：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1、需要基于正确的Page状态上重放REDO&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;由于在一个Page内，REDO是以逻辑的方式记录了前后两次的修改，因此重放REDO必须基于正确的Page状态。然而InnoDB默认的Page大小是16KB，是大于文件系统能保证原子的4KB大小的，因此可能出现Page内容成功一半的情况。InnoDB中采用了Double Write Buffer的方式来通过写两次的方式保证恢复的时候找到一个正确的Page状态。这部分会在之后介绍Buffer Pool的时候详细介绍。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2、需要保证REDO重放的幂等&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Double Write Buffer能够保证找到一个正确的Page状态，我们还需要知道这个状态对应REDO上的哪个记录，来避免对Page的重复修改。为此，InnoDB给每个REDO记录一个全局唯一递增的标号LSN(Log Sequence Number)。Page在修改时，会将对应的REDO记录的LSN记录在Page上（FIL_PAGE_LSN字段），这样恢复重放REDO时，就可以来判断跳过已经应用的REDO，从而实现重放的幂等。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;三  REDO中记录了什么内容&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;知道了InnoDB中记录REDO的方式，那么REDO里具体会记录哪些内容呢？为了应对InnoDB各种各样不同的需求，到MySQL 8.0为止，已经有多达65种的REDO记录。用来记录这不同的信息，恢复时需要判断不同的REDO类型，来做对应的解析。根据REDO记录不同的作用对象，可以将这65中REDO划分为三个大类：作用于Page，作用于Space以及提供额外信息的Logic类型。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1、作用于Page的REDO&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这类REDO占所有REDO类型的绝大多数，根据作用的Page的不同类型又可以细分为，Index Page REDO，Undo Page REDO，Rtree PageREDO等。比如MLOG_REC_INSERT，MLOG_REC_UPDATE_IN_PLACE，MLOG_REC_DELETE三种类型分别对应于Page中记录的插入，修改以及删除。这里还是以MLOG_REC_UPDATE_IN_PLACE为例来看看其中具体的内容：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100022430&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7106598984771574&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLFn4TAypL51subJv6Nibvxmb54Flx7aiaAe8G6yIZ8wMLrr9v30nvMOHQOctzsBLtYJZcGmQFr12Ow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;788&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其中，Type就是MLOG_REC_UPDATE_IN_PLACE类型，Space ID和Page Number唯一标识一个Page页，这三项是所有REDO记录都需要有的头信息，后面的是MLOG_REC_UPDATE_IN_PLACE类型独有的，其中Record Offset用给出要修改的记录在Page中的位置偏移，Update Field Count说明记录里有几个Field要修改，紧接着对每个Field给出了Field编号(Field Number)，数据长度（Field Data Length）以及数据（Filed Data）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2、作用于Space的REDO&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这类REDO针对一个Space文件的修改，如MLOG_FILE_CREATE，MLOG_FILE_DELETE，MLOG_FILE_RENAME分别对应对一个Space的创建，删除以及重命名。由于文件操作的REDO是在文件操作结束后才记录的，因此在恢复的过程中看到这类日志时，说明文件操作已经成功，因此在恢复过程中大多只是做对文件状态的检查，以MLOG_FILE_CREATE来看看其中记录的内容：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100022431&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.34760705289672544&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLFn4TAypL51subJv6Nibvxm7P8DfO33hjueB8iagupJbAcaiaTo00iayXK1KE1HCrmCbolagrTL367XQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;794&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;同样的前三个字段还是Type，Space ID和Page Number，由于是针对Page的操作，这里的Page Number永远是0。在此之后记录了创建的文件flag以及文件名，用作重启恢复时的检查。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3、提供额外信息的Logic REDO&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;除了上述类型外，还有少数的几个REDO类型不涉及具体的数据修改，只是为了记录一些需要的信息，比如最常见的MLOG_MULTI_REC_END就是为了标识一个REDO组，也就是一个完整的原子操作的结束。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h1&gt;&lt;span&gt;4、REDO是如何组织的&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;所谓REDO的组织方式，就是如何把需要的REDO内容记录到磁盘文件中，以方便高效的REDO写入，读取，恢复以及清理。我们这里把REDO从上到下分为三层：逻辑REDO层、物理REDO层和文件层。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;1  逻辑REDO层&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;这一层是真正的REDO内容，REDO由多个不同Type的多个REDO记录收尾相连组成，有全局唯一的递增的偏移sn，InnoDB会在全局log_sys中维护当前sn的最大值，并在每次写入数据时将sn增加REDO内容长度。如下图所示：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100022425&quot; data-ratio=&quot;0.18425925925925926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLFn4TAypL51subJv6NibvxmFtWonN4yym5meCM7jx4zpMhkugubApmMz8a121HwOic5yYrql3iaSKhA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h4&gt;&lt;br/&gt;&lt;/h4&gt;&lt;h4&gt;&lt;span&gt;2  物理REDO层&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;磁盘是块设备，InnoDB中也用Block的概念来读写数据，一个Block的长度OS_FILE_LOG_BLOCK_SIZE等于磁盘扇区的大小512B，每次IO读写的最小单位都是一个Block。除了REDO数据以外，Block中还需要一些额外的信息，下图所示一个Log Block的的组成，包括12字节的Block Header：前4字节中Flush Flag占用最高位bit，标识一次IO的第一个Block，剩下的31个个bit是Block编号；之后是2字节的数据长度，取值在[12，508]；紧接着2字节的First Record Offset用来指向Block中第一个REDO组的开始，这个值的存在使得我们对任何一个Block都可以找到一个合法的的REDO开始位置；最后的4字节Checkpoint Number记录写Block时的next_checkpoint_number，用来发现文件的循环使用，这个会在文件层详细讲解。Block末尾是4字节的Block Tailer，记录当前Block的Checksum，通过这个值，读取Log时可以明确Block数据有没有被完整写完。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100022432&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.755359394703657&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLFn4TAypL51subJv6Nibvxm55e5h7VLWY5zsic5DbbjEDOBmqxXAyvAfH3rPHf1gzyD5hTGD5ngDYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;793&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Block中剩余的中间498个字节就是REDO真正内容的存放位置，也就是我们上面说的逻辑REDO。我们现在将逻辑REDO放到物理REDO空间中，由于Block内的空间固定，而REDO长度不定，因此可能一个Block中有多个REDO，也可能一个REDO被拆分到多个Block中，如下图所示，棕色和红色分别代表Block Header和Tailer，中间的REDO记录由于前一个Block剩余空间不足，而被拆分在连续的两个Block中。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100022433&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3241042345276873&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLFn4TAypL51subJv6Nibvxmibna4Q4X02S5E4NEdH7uw3EKV3fS8x3kHtevAFmJCiboKoTccWIpDzSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1228&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;由于增加了Block Header和Tailer的字节开销，在物理REDO空间中用LSN来标识偏移，可以看出LSN和SN之间有简单的换算关系：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;inline&lt;/span&gt; lsn_t &lt;span class=&quot;code-snippet__title&quot;&gt;log_translate_sn_to_lsn&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;lsn_t&lt;/span&gt; sn)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; (sn / LOG_BLOCK_DATA_SIZE * OS_FILE_LOG_BLOCK_SIZE +&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          sn % LOG_BLOCK_DATA_SIZE + LOG_BLOCK_HDR_SIZE);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;SN加上之前所有的Block的Header以及Tailer的长度就可以换算到对应的LSN，反之亦然。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;3  文件层&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;最终REDO会被写入到REDO日志文件中，以ib_logfile0、ib_logfile1...命名，为了避免创建文件及初始化空间带来的开销，InooDB的REDO文件会循环使用，通过参数innodb_log_files_in_group可以指定REDO文件的个数。多个文件收尾相连顺序写入REDO内容。每个文件以Block为单位划分，每个文件的开头固定预留4个Block来记录一些额外的信息，其中第一个Block称为Header Block，之后的3个Block在0号文件上用来存储Checkpoint信息，而在其他文件上留空：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100022434&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.38461538461538464&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLFn4TAypL51subJv6NibvxmTAzy0aAEFk4M1vG724Ud0G5xMZBovt9HfXSD4qtSlzKiaC3cozHBcVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1248&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其中第一个Header Block的数据区域记录了一些文件信息，如下图所示，4字节的Formate字段记录Log的版本，不同版本的LOG，会有REDO类型的增减，这个信息是8.0开始才加入的；8字节的Start LSN标识当前文件开始LSN，通过这个信息可以将文件的offset与对应的lsn对应起来；最后是最长32位的Creator信息，正常情况下会记录MySQL的版本。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100022435&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.26136363636363635&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLFn4TAypL51subJv6NibvxmdchndRO3ehzuNibbYRX3rXnu6GOus51Fo4CpVeGRUdMtSydqibGNb3Aw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;792&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;现在我们将REDO放到文件空间中，如下图所示，逻辑REDO是真正需要的数据，用sn索引，逻辑REDO按固定大小的Block组织，并添加Block的头尾信息形成物理REDO，以lsn索引，这些Block又会放到循环使用的文件空间中的某一位置，文件中用offset索引：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100022436&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6162215628090999&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLFn4TAypL51subJv6Nibvxm6pMuoowVzEXaqFNNVutzRpmrX3UpMEDvR2icPYlibz16tqIHib8qxfFNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1011&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;虽然通过LSN可以唯一标识一个REDO位置，但最终对REDO的读写还需要转换到对文件的读写IO，这个时候就需要表示文件空间的offset，他们之间的换算方式如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;auto&lt;/span&gt; real_offset =&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__built_in&quot;&gt;log&lt;/span&gt;.current_file_real_offset + (lsn - &lt;span class=&quot;code-snippet__built_in&quot;&gt;log&lt;/span&gt;.current_file_lsn);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;切换文件时会在内存中更新当前文件开头的文件offset，current_file_real_offset，以及对应的LSN，current_file_lsn，通过这两个值可以方便地用上面的方式将LSN转化为文件offset。注意这里的offset是相当于整个REDO文件空间而言的，由于InnoDB中读写文件的space层实现支持多个文件，因此，可以将首位相连的多个REDO文件看成一个大文件，那么这里的offset就是这个大文件中的偏移。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;五  如何高效地写REDO&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;作为维护数据库正确性的重要信息，REDO日志必须在事务提交前保证落盘，否则一旦断电将会有数据丢失的可能，因此从REDO生成到最终落盘的完整过程成为数据库写入的关键路径，其效率也直接决定了数据库的写入性能。这个过程包括REDO内容的产生，REDO写入InnoDB Log Buffer，从InnoDB Log Buffer写入操作系统Page Cache，以及REDO刷盘，之后还需要唤醒等待的用户线程完成Commit。下面就通过这几个阶段来看看InnoDB如何在高并发的情况下还能高效地完成写REDO。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;1  REDO产生&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;我们知道事务在写入数据的时候会产生REDO，一次原子的操作可能会包含多条REDO记录，这些REDO可能是访问同一Page的不同位置，也可能是访问不同的Page（如Btree节点分裂）。InnoDB有一套完整的机制来保证涉及一次原子操作的多条REDO记录原子，即恢复的时候要么全部重放，要不全部不重放，这部分将在之后介绍恢复逻辑的时候详细介绍，本文只涉及其中最基本的要求，就是这些REDO必须连续。InnoDB中通过min-transaction实现，简称mtr，需要原子操作时，调用mtr_start生成一个mtr，mtr中会维护一个动态增长的m_log，这是一个动态分配的内存空间，将这个原子操作需要写的所有REDO先写到这个m_log中，当原子操作结束后，调用mtr_commit将m_log中的数据拷贝到InnoDB的Log Buffer。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;2  写入InnoDB Log Buffer&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;高并发的环境中，会同时有非常多的min-transaction(mtr)需要拷贝数据到Log Buffer，如果通过锁互斥，那么毫无疑问这里将成为明显的性能瓶颈。为此，从MySQL 8.0开始，设计了一套无锁的写log机制，其核心思路是允许不同的mtr，同时并发地写Log Buffer的不同位置。不同的mtr会首先调用log_buffer_reserve函数，这个函数里会用自己的REDO长度，原子地对全局偏移log.sn做fetch_add，得到自己在Log Buffer中独享的空间。之后不同mtr并行的将自己的m_log中的数据拷贝到各自独享的空间内。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;sn_t&lt;/span&gt; start_sn = &lt;span class=&quot;code-snippet__built_in&quot;&gt;log&lt;/span&gt;.sn.fetch_add(len);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3  &lt;/span&gt;&lt;span&gt;写入Page Cache&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;写入到Log Buffer中的REDO数据需要进一步写入操作系统的Page Cache，InnoDB中有单独的log_writer来做这件事情。这里有个问题，由于Log Buffer中的数据是不同mtr并发写入的，这个过程中Log Buffer中是有空洞的，因此log_writer需要感知当前Log Buffer中连续日志的末尾，将连续日志通过pwrite系统调用写入操作系统Page Cache。整个过程中应尽可能不影响后续mtr进行数据拷贝，InnoDB在这里引入一个叫做link_buf的数据结构，如下图所示：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qlogo.cn/mmbiz_png/Z6bicxIx5naLFn4TAypL51subJv6NibvxmekgdbE25GqMdzrvOMRMf66ySsWEMV4OHUTHpSU81y5ia2Bq7tL54Mnw/0?wx_fmt=png&quot; data-cropx1=&quot;14.225454545454546&quot; data-cropx2=&quot;625.9200000000001&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;517.5922999048065&quot; data-fileid=&quot;100022437&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8461538461538461&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naLFn4TAypL51subJv6NibvxmCLKUjgQcbiaeWUnaP9PMUvicKGKUls2jcLkEekrb1lN0M15F23a8GMvA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;611&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;link_buf是一个循环使用的数组，对每个lsn取模可以得到其在link_buf上的一个槽位，在这个槽位中记录REDO长度。另外一个线程从开始遍历这个link_buf，通过槽位中的长度可以找到这条REDO的结尾位置，一直遍历到下一位置为0的位置，可以认为之后的REDO有空洞，而之前已经连续，这个位置叫做link_buf的tail。下面看看log_writer和众多mtr是如何利用这个link_buf数据结构的。这里的这个link_buf为log.recent_written，如下图所示：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qlogo.cn/mmbiz_png/Z6bicxIx5naLFn4TAypL51subJv6NibvxmUbZrpMfD5H3QKtzdjd2wow5wUibGt0bDMgZMQXHkic5oaL1LuUPjic4Ug/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;819&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;272.0553633217993&quot; data-fileid=&quot;100022440&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3321123321123321&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naLFn4TAypL51subJv6NibvxmpN8mn0ZCgx4pRl7BFsicHzZzTjkdC4HmucGBibI1iaxztTPuibvx7F5CrQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;819&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;图中上半部分是REDO日志示意图，write_lsn是当前log_writer已经写入到Page Cache中日志末尾，current_lsn是当前已经分配给mtr的的最大lsn位置，而buf_ready_for_write_lsn是当前log_writer找到的Log Buffer中已经连续的日志结尾，从write_lsn到buf_ready_for_write_lsn是下一次log_writer可以连续调用pwrite写入Page Cache的范围，而从buf_ready_for_write_lsn到current_lsn是当前mtr正在并发写Log Buffer的范围。下面的连续方格便是log.recent_written的数据结构，可以看出由于中间的两个全零的空洞导致buf_ready_for_write_lsn无法继续推进，接下来，假如reserve到中间第一个空洞的mtr也完成了写Log Buffer，并更新了log.recent_written*，如下图：&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100022439&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.31873479318734793&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLFn4TAypL51subJv6Nibvxm9KBiamc9iaicWymasKrTrvUFREuA8IJy9jpjqBoTE4v2UXeLfKJiaht0xQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;822&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这时，log_writer从当前的buf_ready_for_write_lsn向后遍历log.recent_written，发现这段已经连续：&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100022428&quot; data-ratio=&quot;0.30833333333333335&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLFn4TAypL51subJv6NibvxmzLPquoBOzVCsO4HxJHrHtvUFgDcXecOAATARf8ibiaPQU1olyEWCMdZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因此提升当前的buf_ready_for_write_lsn，并将log.recent_written的tail位置向前滑动，之后的位置清零，供之后循环复用：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100022427&quot; data-ratio=&quot;0.32222222222222224&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLFn4TAypL51subJv6NibvxmTKmRj1pqtKiaT6ehGkic743U0rXgMXS3UDBbcxmVs5MKTLMt5MB7NTQA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;紧接log_writer将连续的内容刷盘并提升write_lsn。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;4  刷盘&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;log_writer提升write_lsn之后会通知log_flusher线程，log_flusher线程会调用fsync将REDO刷盘，至此完成了REDO完整的写入过程。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;5  唤醒用户线程&lt;/span&gt;&lt;br/&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;为了保证数据正确，只有REDO写完后事务才可以commit，因此在REDO写入的过程中，大量的用户线程会block等待，直到自己的最后一条日志结束写入。默认情况下innodb_flush_log_at_trx_commit = 1，需要等REDO完成刷盘，这也是最安全的方式。当然，也可以通过设置innodb_flush_log_at_trx_commit = 2，这样，只要REDO写入Page Cache就认为完成了写入，极端情况下，掉电可能导致数据丢失。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;大量的用户线程调用log_write_up_to等待在自己的lsn位置，为了避免大量无效的唤醒，InnoDB将阻塞的条件变量拆分为多个，log_write_up_to根据自己需要等待的lsn所在的block取模对应到不同的条件变量上去。同时，为了避免大量的唤醒工作影响log_writer或log_flusher线程，InnoDB中引入了两个专门负责唤醒用户的线程：log_wirte_notifier和log_flush_notifier，当超过一个条件变量需要被唤醒时，log_writer和log_flusher会通知这两个线程完成唤醒工作。下图是整个过程的示意图：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100022441&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5029337803855826&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLFn4TAypL51subJv6NibvxmEgQd2vvkjCzyI1o2ZIk4CMFXk4kibSUJd4CGEia081zGngofK5bko4tQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1193&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;多个线程通过一些内部数据结构的辅助，完成了高效的从REDO产生，到REDO写盘，再到唤醒用户线程的流程，下面是整个这个过程的时序图：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100022442&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6065573770491803&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLFn4TAypL51subJv6NibvxmepJ9QDOuibgiaq4wtgiaeV7SsVL4myZyQlb1nXzLoKq2vGrKnn7Qy2FFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1098&quot;/&gt;&lt;/p&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;六  如何安全地清除REDO&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;由于REDO文件空间有限，同时为了尽量减少恢复时需要重放的REDO，InnoDB引入log_checkpointer线程周期性的打Checkpoint。重启恢复的时候，只需要从最新的Checkpoint开始回放后边的REDO，因此Checkpoint之前的REDO就可以删除或被复用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们知道REDO的作用是避免只写了内存的数据由于故障丢失，那么打Checkpiont的位置就必须保证之前所有REDO所产生的内存脏页都已经刷盘。最直接的，可以从Buffer Pool中获得当前所有脏页对应的最小REDO LSN：lwm_lsn。但光有这个还不够，因为有一部分min-transaction的REDO对应的Page还没有来的及加入到Buffer Pool的脏页中去，如果checkpoint打到这些REDO的后边，一旦这时发生故障恢复，这部分数据将丢失，因此还需要知道当前已经加入到Buffer Pool的REDO lsn位置：dpa_lsn。取二者的较小值作为最终checkpoint的位置，其核心逻辑如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;lsn_t&lt;/span&gt; lwm_lsn = buf_pool_get_oldest_modification_lwm();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;lsn_t&lt;/span&gt; dpa_lsn = log_buffer_dirty_pages_added_up_to_lsn(&lt;span class=&quot;code-snippet__built_in&quot;&gt;log&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;lsn_t&lt;/span&gt; checkpoint_lsn = &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::min(lwm_lsn, dpa_lsn);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;MySQL 8.0中为了能够让mtr之间更大程度的并发，允许并发地给Buffer Pool注册脏页。类似与log.recent_written和log_writer，&lt;/span&gt;&lt;span&gt;这里引入一个叫做recent_closed的link_buf来处理并发带来的空洞，由单独的线程log_closer来提升recent_closed的tail，也就是当前连续加入Buffer Pool脏页的最大LSN，这个值也就是上面提到的dpa_lsn。需要注意的是，由于这种乱序的存在，lwm_lsn的值并不能简&lt;/span&gt;&lt;span&gt;单的获取当前Buffer Pool中的最老的脏页的LSN，保守起见，&lt;/span&gt;&lt;span&gt;还需要减掉一个recent_closed的容量大小，也就是&lt;/span&gt;&lt;span&gt;最大的乱序范围，简化后的代码如下：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/pre&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;lsn_t&lt;/span&gt; lsn = buf_pool_get_oldest_modification_approx();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;lsn_t&lt;/span&gt; lag = &lt;span class=&quot;code-snippet__built_in&quot;&gt;log&lt;/span&gt;.recent_closed.capacity();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;lsn_t&lt;/span&gt; lwm_lsn = lsn - lag;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;lsn_t&lt;/span&gt; dpa_lsn = log_buffer_dirty_pages_added_up_to_lsn(&lt;span class=&quot;code-snippet__built_in&quot;&gt;log&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;lsn_t&lt;/span&gt; checkpoint_lsn = &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::min(lwm_lsn, dpa_lsn);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;这里有一个问题，由于lwm_lsn已经减去了recent_closed的capacity，因此理论上这个值一定是小于dpa_lsn的。那么再去比较lwm_lsn和dpa_lsn来获取Checkpoint位置或许是没有意义的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上面已经提到，ib_logfile0文件的前三个Block有两个被预留作为Checkpoint Block，这两个Block会在打Checkpiont的时候交替使用，这样来避免写Checkpoint过程中的崩溃导致没有可用的Checkpoint。Checkpoint Block中的内容如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100022443&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.29539641943734013&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLFn4TAypL51subJv6NibvxmNJp7FHWy7gcVWa5ib5DBYicHIY0v0O2k9CyjYazthepLIrAKmk1vxU7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;782&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先8个字节的Checkpoint Number，通过比较这个值可以判断哪个是最新的Checkpiont记录，之后8字节的Checkpoint LSN为打Checkpoint的REDO位置，恢复时会从这个位置开始重放后边的REDO。之后8个字节的Checkpoint Offset，将Checkpoint LSN与文件空间的偏移对应起来。最后8字节是前面提到的Log Buffer的长度，这个值目前在恢复过程并没有使用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;七  总结&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;本文系统的介绍了InnoDB中REDO的作用、特性、组织结构、写入方式已经清理时机，基本覆盖了REDO的大多数内容。关于重启恢复时如何使用REDO将数据库恢复到正确的状态，将在之后介绍InnoDB故障恢复机制的时候详细介绍。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;[1] &lt;/span&gt;&lt;span&gt;MySQL 8.0.11Source Code Documentation: Format of redo log&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;https://dev.mysql.com/doc/dev/mysql-server/8.0.11/PAGE_INNODB_REDO_LOG_FORMAT.html?spm=ata.21736010.0.0.600e6f95JcmTlA&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[2] &lt;/span&gt;&lt;span&gt;MySQL 8.0: New Lock free, scalable WAL design&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;https://mysqlserverteam.com/mysql-8-0-new-lock-free-scalable-wal-design/?spm=ata.21736010.0.0.600e6f95JcmTlA&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[3] &lt;/span&gt;&lt;span&gt;How InnoDB handles REDO logging&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;https://www.percona.com/blog/2011/02/03/how-innodb-handles-redo-logging/?spm=ata.21736010.0.0.600e6f95JcmTlA&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[4] &lt;/span&gt;&lt;span&gt;MySQL Source Code&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;https://github.com/mysql/mysql-server?spm=ata.21736010.0.0.600e6f95JcmTlA&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[5] &lt;/span&gt;&lt;span&gt;数据库故障恢复机制的前世今生&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;http://catkang.github.io/2019/01/16/crash-recovery.html?spm=ata.21736010.0.0.600e6f95JcmTlA&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;hr/&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;博客园&amp;amp;阿里云联合征文活动——我修复的印象最深的一个bug&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;点击阅读原文来分享你的故事吧！&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100022449&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5263888888888889&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLFn4TAypL51subJv6NibvxmPmwfCISkRJRFRsgGIZX95gYD1CVfkugZ56icLPehoJRNwPDSS4c77Aw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;720&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d9cd5deae673b41f6bd24de66b268e69</guid>
<title>CDP 客户数据管理平台体系化搭建</title>
<link>https://toutiao.io/k/a2qq9lj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p id=&quot;js_tags&quot; class=&quot;article-tag__list single-tag__wrp js_single&quot; data-len=&quot;1&quot; role=&quot;link&quot; aria-labelledby=&quot;js_article-tag-card__left&quot; aria-describedby=&quot;js_article-tag-card__right&quot;&gt;
                                            
                                                                                    &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__left&quot; class=&quot;article-tag-card__left&quot;&gt;
                                    &lt;span class=&quot;article-tag-card__title&quot;&gt;收录于话题&lt;/span&gt;
                                    &lt;span class=&quot;article-tag__item-wrp no-active js_tag&quot; data-url=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4Njg0MzYwNw==&amp;amp;action=getalbum&amp;amp;album_id=1695231212027428866#wechat_redirect&quot; data-tag_id=&quot;&quot; data-album_id=&quot;1695231212027428866&quot; data-tag_source=&quot;4&quot;&gt;
                                        &lt;span class=&quot;article-tag__item&quot;&gt;#数据洞察与分析&lt;/span&gt;
                                    &lt;/span&gt;
                                &lt;/span&gt;
                                &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__right&quot; class=&quot;article-tag-card__right&quot;&gt;10个&lt;span class=&quot;weui-hidden_abs&quot;&gt;内容&lt;/span&gt;&lt;/span&gt;
                                                                                        &lt;/p&gt;

                
                                
                
                

                
                                                                

                
                                


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h1&gt;&lt;span&gt;一、Cdp系统简介&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、基本概念&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;客户数据平台(Customer-Data-Platform)，简称CDP；通过采集多方客户数据(主体与线索)等，从而进行精准的客户分析和人群细分，进而实现高效的客户维系和发掘以及日常营销运营。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100001828&quot; data-ratio=&quot;0.3078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvAVvxzhIdNUpGeicL75dAsFlLlic5jBydzAEgCgRXDFwSZ252DReIGyic9ZqQBBv28ZnffiakA9Xn3cLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;业务面上看Cdp是客户管理流程上的一个节点，技术面上看是重度偏向数据分析的一个平台。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;数据构成&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;主体资料：多方客户（一方、三方、线下）数据汇集，基于唯一ID标识进行客户主体构建与行为数据映射，实现结构化的模型数据管理；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;行为线索：通过SDK埋点的方式，采集客户多种事件类型的行为数据，例如注册、登录、点击、浏览、购买等，作为客户跟进的核心线索；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;不断的完善客户主体的数据，完善相关画像分析，然后通过相关行为采集，进行精准实时的跟进，例如新客的浏览行为，老客户的点击等，都有潜在需求的可能，在Cdp系统采集到这类线索之后，迅速对客户进行沟通跟进，进行精准高效的服务。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;基础流程&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;数据采集：客户主体即多端(Web、APP、小程序等)注册用户的汇集或者渠道拓展的录入，线索多来自埋点手段的采集；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;客户模型：基于唯一客户ID标识，构建客户的主体结构，业务模型等，收集与整合多个业务场景下的需求数据；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据分析：对于客户数据的基本分析能力，常见的分层细化，标签化管理，画像与报表分析等，以此精准的识别客户；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;营销运营：上述的一系列操作，皆是为了能够对客户进行精细化的运营，以此提高客户价值降低维护的时间和营销成本；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;核心价值&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;流量背景下获取客户的成本是非常高的，所以获客之后的精细运营，避免大量流失就尤为重要，建立一批忠诚度高的客户是成本最低但价值最高的运营手段，而CDP系统就是为了支撑该策略的实现。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2、对比Crm系统&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;与客户管理概念相关联的系统有不少，例如常说的CRM、CDP、DMP等等，可以不过度纠结这些系统的概念，只需要整体上有认识即可，在大多数场景中可能都是高度聚合在一个系统中，只是通过权限进行划分控制。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100001829&quot; data-ratio=&quot;0.28359375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvAVvxzhIdNUpGeicL75dAsFlLLibUZzdMBMFchcgEm2pkeqfic3zibmibpNUXV7ZEfkqYgXqYibW7c9FYfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;CDP：核心围绕客户数据的获取、管理、精细运营、营销等，促进客户产生交易行为；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CRM：核心围绕客户交易环节，数据层面相对静态，主要在于交易流程的管理、记录、服务等；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DMP：核心围绕标签化的数据管理平台，与CDP有部分牵扯和联系，基于标签透视客户群体；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;系统平台的划分其本质是对业务流程节点的拆解，当业务复杂度较高时，这样有利于单个业务系统的快速迭代与扩展；在初期可能就一个管理系统，划分很多模块，以此降低开发和运维的成本；不同时期有不同的处理策略，对整个流程环节有清晰的认知才是应对业务多变的核心能力。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;二、业务周期&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、核心模块&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;客户主体&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;客户的基本档案信息，这类数据的最大特点就是变化的频率相对低，不易获取但是容易维护，除此之外相对完善的客户主体还包括：客户联系人、系统跟进人等模块；这样构成一个完整的客户主体档案。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;线索事件&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;通过多个产品端和业务线，进行埋点采集数据，作为跟进客户的核心线索，可以精准触达用户的需求，例如新客注册、浏览点击、其背后都是需求的驱动，通过线索事件捕捉用户需求，进而进行跟进销售推广。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;客户跟进&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;通过线索获取客户的潜在需求，进而进行快速跟进，明确客户的需求，不断维护客户的跟进记录，持续提供精准服务的能力，这里的跟进方式可以是多样的，例如电话、拜访、短信等。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;维度分析&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;对于客户的分析是多个方面的，常用的手段中，人群细分、标签化管理、业务报表、综合维度评分、流失预警、周期模型等，细致化的客群分析是数据识别的核心手段，这样从技术层面对客户有一次价值评估，在不同业务场景下跟进相应的重点客群。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;营销推广&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;通过对客群数据的分析，以及标签化体系的建立，这样就可以对客群进行精准式的推广和营销，例如：基于标签的智能营销，基于种子人群的客户获取，数据越精准，营销的成本就越低，回馈的价值就越高。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2、客户周期&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;Cdp平台背后的业务本质，即对客户生命周期的识别和管理，不同阶段下有相应策略与手段，例如常见的客户周期划分：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100001830&quot; data-ratio=&quot;0.340625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvAVvxzhIdNUpGeicL75dAsFlGjhBFHBLUcNLqib2k5tTGPn5D8sOhH5h1KaLEauFB7a9q3Wib9mM8aXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;新客：新注册的用户，需求不明朗；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;普通客户：有特定的需求，但是具备一些不确定性；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;会员：需求明确，同时具备确定性；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;超级客户：提供专人跟进，差异化服务；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;流失客户：持续跟进没有效果，多次唤醒失败；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;不管是什么类型的客户，都存在一定流失的风险，当客户流失情况出现时，从业务侧提供流失原因分析，也要从技术侧反思，是不是流程周期上不够细致，流失风险识别不及时等。&lt;/p&gt;&lt;p&gt;围绕客户数据采集和业务模型的搭建，从而明确客户的周期，建设已有客群的精细化运营能力。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;三、架构设计&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;对于任何业务平台的建设，首先都是明确其背后需要解决的业务逻辑，然后对业务流程进行拆解，模块化管理和落地实现，当基本结构完善后，就是不断的迭代和优化：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100001831&quot; data-ratio=&quot;0.70234375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvAVvxzhIdNUpGeicL75dAsFlnr0eziabdTEel16fpDHEoY1KgEdS3Wpv1GON0l443JRPYYASumvg5oQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;客户增长&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;数据采集：主要针对两个方面数据，主体资料持续完善，新数据与线索不断积累；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;渠道管理：数据采集来源的管理，不单是线上，还有线下，商务自拓等多个渠道；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;场景分析：不同场景下数据特点分析，识别高质量的采集环境，数据优先处理；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;质量监测：通过数据采集的维度，或者信息质量的识别，进行初始化过滤或者清洗；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;客户档案&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;主体数据：客户主体信息的完善，进而在各个业务环节使用，在结构上需要相对独立；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线索事件：在不同业务节点采集到的线索数据，不同线索事件的背后是需求的挖掘；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;跟进管理：跟进人员分配，跟进结果反馈，基于结果分析客户的需求是否明确，价值高低；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;客户分析&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;细化分层：数据分层是基础能力，例如基于：客单价、交易次数、区域划分、业务价值等；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;标签识别：基于标签体系的客群管理，画像透视，在客户精准搜索和营销中十分关键；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;维度评分：综合评估客户的价值，例如常说的：活跃度、需求、购买力、数据完善度；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;周期模型：基于历史数据分析，阶段性评估客户所在的周期节点，进行策略化管理；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;流失预警：不同周期或者级别下的客户提供静默度分析，并提供预警信息，避免流失；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;客户营销&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;运营活动：在运营体系中，针对客群的特征，提供不同特点的活动，进行差异化的产品推广；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;营销策略：不同标签类别下的客户，进行差异化营销，或基于优质客群的共同特征营销；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;结果反馈：不管采用何种营销手段，对结果的反馈是至关重要的，以此验证优化营销策略；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;基础能力&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;数据存储：不同特点的数据采用相应的存储组件，在数据库选型上视野要开阔；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;搜索引擎：高度依赖数据的平台，对于搜索引擎建设极其重要，支撑多维度的数据查询；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;业务对接：例如Crm、DMP等系统对接，通常核心在数据层面，以及应用中的交互；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;上述是针对Cdp平台业务流转去分析的，像一些系统基础功能，例如：权限控制、操作日志等没有多余的描述，实际上当数据体量不断膨胀时，会逐步引入大数据相关组件、规则引擎等技术来处理。&lt;/p&gt;&lt;p&gt;很多能力都是在遇到问题情况下，找方案、学习、试错、处理、反思总结，然后就这样积累下来了。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;同系列&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU4Njg0MzYwNw==&amp;amp;mid=2247485392&amp;amp;idx=1&amp;amp;sn=6895452da3e827128f4b2ef6c9de46ca&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;业务数据清洗&lt;/a&gt;&lt;span&gt; ┃ &lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU4Njg0MzYwNw==&amp;amp;mid=2247485218&amp;amp;idx=1&amp;amp;sn=fdce6722b571c35298f9d999b7df2395&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;数据服务设计&lt;/a&gt;&lt;span&gt; ┃ &lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU4Njg0MzYwNw==&amp;amp;mid=2247485474&amp;amp;idx=1&amp;amp;sn=fe13e72fa60b103b4603d6567312c2f7&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;元数据管理&lt;/a&gt;&lt;span&gt; ┃ &lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU4Njg0MzYwNw==&amp;amp;mid=2247485178&amp;amp;idx=1&amp;amp;sn=e7f42c9d54f6852556abfd01478f8d0b&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;数字营销概念&lt;/a&gt;&lt;span&gt; ┃ &lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU4Njg0MzYwNw==&amp;amp;mid=2247485157&amp;amp;idx=1&amp;amp;sn=37b30d99a6d8f3a78cdc79b81b552416&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;标签业务应用&lt;/a&gt;&lt;span&gt; ┃&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;四、源代码地址&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;GitEE·地址&lt;br/&gt;https://gitee.com/cicadasmile&lt;br/&gt;Wiki·地址&lt;br/&gt;https://gitee.com/cicadasmile/butte-java-note/wikis&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU4Njg0MzYwNw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBCuF3zfJnqPKpUia4wfn1FUtTHpxxkR5HvbicPgOjibPicX0goMOkny1NdkLAJvBaqrYh3UdwMjiaDQMA/0?wx_fmt=png&quot; data-nickname=&quot;知了一笑&quot; data-alias=&quot;cicada_smile&quot; data-signature=&quot;积累是一个孤独且枯燥的过程&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fdf4de4b6832af6e71d19671fcad6c78</guid>
<title>美团知识图谱问答技术实践与探索</title>
<link>https://toutiao.io/k/4g23ryg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a62c44915ff9c61471627b4e5cfc09c7</guid>
<title>[译] Flutter 2021 中的按钮</title>
<link>https://toutiao.io/k/zwlao7b</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;529014079&quot; data-ratio=&quot;0.5856&quot; data-type=&quot;png&quot; data-w=&quot;1250&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AMnfFUcSKxpyLYHxJaRH1bEh0h1sRicQia7n0m14LVMxqLRRFpAxFibQTLjUaicicrsDm9LlOytQvvEbCQ/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本文中，我们将介绍令人惊叹的 Flutter 按钮，它们可以帮助所有初学者或专业人士为现代应用程序设计漂亮的 UI。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先让我告诉你关于 Flutter 中按钮的一件重要事情，在flutter最新版本中以下Buttons在fluter中被废弃了：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;废弃的&lt;/th&gt;&lt;th&gt;推荐的替代&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;RaisedButton&lt;/td&gt;&lt;td&gt;ElevatedButton&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;OutlineButton&lt;/td&gt;&lt;td&gt;OutlinedButton&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;FlatButton&lt;/td&gt;&lt;td&gt;TextButton&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么让我们来探索一下 Flutter 中的按钮。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Elevated Button&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;StadiumBorder&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;529014078&quot; data-ratio=&quot;0.7482517482517482&quot; data-type=&quot;png&quot; data-w=&quot;143&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AMnfFUcSKxpyLYHxJaRH1bECYHcdibmUad4wpicqSvdrNB9YicibwG0Q0mTn2zNuVqLeghsSWb2jvKchA/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ElevatedButton(&lt;br/&gt;  onPressed: (){},&lt;br/&gt;  child: Text(&lt;span&gt;&#x27;Button&#x27;&lt;/span&gt;),&lt;br/&gt;  style: ElevatedButton.styleFrom(&lt;br/&gt;  shadowColor: Colors.green,&lt;br/&gt;  shape: StadiumBorder(),&lt;br/&gt;  padding: EdgeInsets.symmetric(horizontal: &lt;span&gt;35&lt;/span&gt;,vertical: &lt;span&gt;20&lt;/span&gt;)),&lt;br/&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;529014077&quot; data-ratio=&quot;0.47368421052631576&quot; data-type=&quot;png&quot; data-w=&quot;190&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AMnfFUcSKxpyLYHxJaRH1bEQUxNQ9WoDhmicVDtficq1MucKJA6iaHjTIcgCvemfRJRBwvnKFN6lq75w/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;RoundedRectangleBorder&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ElevatedButton(&lt;br/&gt;  onPressed: (){},&lt;br/&gt;  child: Text(&lt;span&gt;&#x27;Button&#x27;&lt;/span&gt;),&lt;br/&gt;  style: ElevatedButton.styleFrom(&lt;br/&gt;  shadowColor: Colors.green,&lt;br/&gt;  shape: RoundedRectangleBorder(&lt;br/&gt;  borderRadius: BorderRadius.circular(&lt;span&gt;12&lt;/span&gt;),&lt;br/&gt;      ),&lt;br/&gt;   ),&lt;br/&gt;),&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;CircleBorder&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;529014075&quot; data-ratio=&quot;0.8865248226950354&quot; data-type=&quot;png&quot; data-w=&quot;141&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AMnfFUcSKxpyLYHxJaRH1bE7tWI8zU1Bne5voFoIIIiapPJ3gwWibX0ubicJ5sVcQSAM8le7ZuIERGicA/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ElevatedButton(&lt;br/&gt;  onPressed: () {},&lt;br/&gt;  child: Text(&lt;span&gt;&#x27;Button&#x27;&lt;/span&gt;),&lt;br/&gt;  style: ElevatedButton.styleFrom(&lt;br/&gt;    shape: CircleBorder(),&lt;br/&gt;    padding: EdgeInsets.all(&lt;span&gt;24&lt;/span&gt;),&lt;br/&gt;  ),&lt;br/&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;BeveledRectangleBorder&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;529014076&quot; data-ratio=&quot;0.5235294117647059&quot; data-type=&quot;png&quot; data-w=&quot;170&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AMnfFUcSKxpyLYHxJaRH1bEKUiblYtOkwyYffHFKKROWiaqrdibUXkBEAicgRTosd3RmFEtzzVcQfibKQQ/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ElevatedButton(&lt;br/&gt;  onPressed: () {},&lt;br/&gt;  child: Text(&lt;span&gt;&#x27;Button&#x27;&lt;/span&gt;),&lt;br/&gt;  style: ElevatedButton.styleFrom(&lt;br/&gt;    shape: BeveledRectangleBorder(&lt;br/&gt;      borderRadius: BorderRadius.circular(&lt;span&gt;12&lt;/span&gt;)&lt;br/&gt;    ),&lt;br/&gt;  ),&lt;br/&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Outlined Button&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;StadiumBorder&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;529014083&quot; data-ratio=&quot;0.5869565217391305&quot; data-type=&quot;png&quot; data-w=&quot;138&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AMnfFUcSKxpyLYHxJaRH1bEcoL5pQYoe7RgweA6HVDTiaric6JHK2mkPraDIumqxTqrYjGiaf1T3GPfw/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;OutlinedButton(&lt;br/&gt;  onPressed: () {},&lt;br/&gt;  child: Text(&lt;span&gt;&#x27;Button&#x27;&lt;/span&gt;),&lt;br/&gt;  style: OutlinedButton.styleFrom(&lt;br/&gt;    shape: StadiumBorder(),&lt;br/&gt;  ),&lt;br/&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;RoundedRectangleBorder&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;529014080&quot; data-ratio=&quot;0.5401459854014599&quot; data-type=&quot;png&quot; data-w=&quot;137&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AMnfFUcSKxpyLYHxJaRH1bE3or1ib0pJia5ibGJz2ISL1daEAfa3SQcbxew9lT8eHTPwkXgMzyyCpkyg/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;OutlinedButton(&lt;br/&gt;  onPressed: () {},&lt;br/&gt;  child: Text(&lt;span&gt;&#x27;Button&#x27;&lt;/span&gt;),&lt;br/&gt;  style: OutlinedButton.styleFrom(&lt;br/&gt;    shape: BeveledRectangleBorder(&lt;br/&gt;      borderRadius: BorderRadius.circular(&lt;span&gt;12&lt;/span&gt;),&lt;br/&gt;    ),&lt;br/&gt;  ),&lt;br/&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;CircleBorder&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;529014081&quot; data-ratio=&quot;0.9173553719008265&quot; data-type=&quot;png&quot; data-w=&quot;121&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AMnfFUcSKxpyLYHxJaRH1bEPqmhrgtug3yPJYiaTupqsWyodEOfQJuTrmUiauuZgMIGNywG9ibiaibBm1g/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;OutlinedButton(&lt;br/&gt;  onPressed: () {},&lt;br/&gt;  child: Text(&lt;span&gt;&#x27;Button&#x27;&lt;/span&gt;),&lt;br/&gt;  style: OutlinedButton.styleFrom(&lt;br/&gt;    shape: CircleBorder(),&lt;br/&gt;    padding: EdgeInsets.all(&lt;span&gt;24&lt;/span&gt;),&lt;br/&gt;  ),&lt;br/&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;BeveledRectangleBorder&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;529014082&quot; data-ratio=&quot;0.5955882352941176&quot; data-type=&quot;png&quot; data-w=&quot;136&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AMnfFUcSKxpyLYHxJaRH1bEeuuDx7y5XIJM3iaIrbavvG8fSQBhEkyYvThR975sUb9Ee5HXF819p0A/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;OutlinedButton(&lt;br/&gt;  onPressed: () {},&lt;br/&gt;  child: Text(&lt;span&gt;&#x27;Button&#x27;&lt;/span&gt;),&lt;br/&gt;  style: OutlinedButton.styleFrom(&lt;br/&gt;    shape: BeveledRectangleBorder(&lt;br/&gt;      borderRadius: BorderRadius.circular(&lt;span&gt;12&lt;/span&gt;),&lt;br/&gt;    ),&lt;br/&gt;  ),&lt;br/&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;section&gt;&lt;span&gt;原文：https://medium.com/@waseemakram.jpb/button-cheat-sheet-in-flutter-2021-1db38501d5f2&lt;/span&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;猜你喜欢&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>