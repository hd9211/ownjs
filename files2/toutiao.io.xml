<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>052d123394e0a057146d06b6c0306c59</guid>
<title>Redis：我是如何与客户端进行通信的</title>
<link>https://toutiao.io/k/dr4u4yt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;江湖上说，&lt;strong&gt;天下武功，无坚不摧，唯快不破&lt;/strong&gt;，这句话简直是为我量身定制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我是一个Redis服务，最引以为傲的就是我的速度，我的 QPS 能达到10万级别。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我的手下有数不清的小弟，他们会时不时到我这来存放或者取走一些数据，我管他们叫做客户端，还给他们起了英文名叫 Redis-client。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候一个小弟会来的非常频繁，有时候一堆小弟会同时过来，但是，即使再多的小弟我也能管理的井井有条。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一天，小弟们问我。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8333333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZ08KPRWFa6JlBqaskXvoyfoy2icYqicT72JftlHDibibSES2rlIOOYyFGNpDvc9lEy5Je4pkIpwpYjdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;552&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想当年，为了不让小弟们拖垮我傲人的速度，在设计和他们的通信协议时，我绞尽脑汁，制定了下面的三条原则：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;实现简单&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;针对计算机来说，解析速度快&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;针对人类来说，可读性强&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么这么设计呢？先来看看一条指令发出的过程，首先在客户端需要对指令操作进行封装，使用网络进行传输，最后在服务端进行相应的解析、执行。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.463768115942029&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/zpom4BeZSicaLtJLCXG77p4PNzYoiaRAw5KYTmIWibRvsmxTp149neUMtI3gWFTiageu3ic5KFHm9HlmPkGxkCbZIMA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;690&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一过程如果设计成一种非常复杂的协议，那么封装、解析、传输的过程都将非常耗时，无疑会降低我的速度。什么，你问我为什么要遵循最后一条规则？算是对于程序员们的馈赠吧，我真是太善良了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我把创造出来的这种协议称为 RESP (&lt;code&gt;REdis Serialization Protocol&lt;/code&gt;)协议，它工作在 TCP 协议的上层，作为我和客户端之间进行通讯的标准形式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说到这，我已经有点迫不及待想让你们看看我设计出来的杰作了，但我好歹也是个大哥，得摆点架子，不能我主动拿来给你们看。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我建议你直接使用客户端发出一条向服务器的命令，然后取出这条命令对应的报文来直观的看一下。话虽如此，不过我已经被封装的很严实了，正常情况下你是看不到我内部进行通讯的具体报文的，所以，你可以&lt;strong&gt;伪装&lt;/strong&gt;成一个Redis的服务端，来截获小弟们发给我的消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现起来也很简单，我和小弟之间是基于 Socket 进行通讯，所以在本地先启动一个&lt;code&gt;ServerSocket&lt;/code&gt;，用来监听Redis服务的6379端口：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;server&lt;/span&gt;() &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;    ServerSocket serverSocket = &lt;span&gt;new&lt;/span&gt; ServerSocket(&lt;span&gt;6379&lt;/span&gt;);&lt;br/&gt;    Socket socket = serverSocket.accept();&lt;br/&gt;    &lt;span&gt;byte&lt;/span&gt;[] bytes = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;1024&lt;/span&gt;];&lt;br/&gt;    InputStream input = socket.getInputStream();&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(input.read(bytes)!=&lt;span&gt;0&lt;/span&gt;){&lt;br/&gt;        System.out.println(&lt;span&gt;new&lt;/span&gt; String(bytes));&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后启动&lt;code&gt;redis-cli&lt;/code&gt;客户端，发送一条命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;set key1 value1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时，伪装的服务端就会收到报文了，在控制台打印了：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;*3&lt;br/&gt;$3&lt;br/&gt;set&lt;br/&gt;$4&lt;br/&gt;key1&lt;br/&gt;$6&lt;br/&gt;value1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这里，隐隐约约看到了刚才输入的几个关键字，但是还有一些其他的字符，要怎么解释呢，是时候让我对协议报文中的格式进行一下揭秘了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我对小弟们说了，对大哥说话的时候得按规矩来，这样吧，你们在请求的时候要遵循下面的规则：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;*&amp;lt;参数数量&amp;gt; CRLF&lt;br/&gt;$&amp;lt;参数1的字节长度&amp;gt; CRLF&lt;br/&gt;&amp;lt;参数1的数据&amp;gt; CRLF&lt;br/&gt;$&amp;lt;参数2的字节长度&amp;gt; CRLF&lt;br/&gt;&amp;lt;参数2的数据&amp;gt; CRLF&lt;br/&gt;...&lt;br/&gt;$&amp;lt;参数N的字节长度&amp;gt; CRLF&lt;br/&gt;&amp;lt;参数N的数据&amp;gt; CRLF&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先解释一下每行末尾的&lt;code&gt;CRLF&lt;/code&gt;，转换成程序语言就是&lt;code&gt;\r\n&lt;/code&gt;，也就是回车加换行。看到这里，你也就能够明白为什么控制台打印出的指令是竖向排列了吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在命令的解析过程中，&lt;code&gt;set&lt;/code&gt;、&lt;code&gt;key1&lt;/code&gt;、&lt;code&gt;value1&lt;/code&gt;会被认为是3个参数，因此参数数量为3，对应第一行的&lt;code&gt;*3&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一个参数&lt;code&gt;set&lt;/code&gt;，长度为3对应&lt;code&gt;$3&lt;/code&gt;；第二个参数&lt;code&gt;key1&lt;/code&gt;，长度为4对应&lt;code&gt;$4&lt;/code&gt;；第三个参数&lt;code&gt;value1&lt;/code&gt;，长度为6对应&lt;code&gt;$6&lt;/code&gt;。在每个参数长度的下一行对应真正的参数数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这，一条指令被转换为协议报文的过程是不是就很好理解了？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4444444444444444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/zpom4BeZSicZ08KPRWFa6JlBqaskXvoyf1BJ8xSic8HRQJKdbo0xVqK3ZpxPW5jFxibEcGeajCuxuoqg8PFDkINEg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;900&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当小弟对我发送完请求后，作为大哥，我就要对小弟的请求进行&lt;strong&gt;指令回复&lt;/strong&gt;了，而且我得根据回复内容进行一下分类，要不然小弟该搞不清我的指示了。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;简单字符串&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单字符串回复只有一行回复，回复的内容以&lt;code&gt;+&lt;/code&gt;作为开头，不允许换行，并以&lt;code&gt;\r\n&lt;/code&gt;结束。有很多指令在执行成功后只会回复一个&lt;code&gt;OK&lt;/code&gt;，使用的就是这种格式，能够有效的将传输、解析的开销降到最低。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.084033613445378&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZ08KPRWFa6JlBqaskXvoyfqlJaHViaKC8OqiaoUCnUSleGjticb8hukVjQAVyzfiboxYDvhdCjbBLkgA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;476&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;错误回复&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在RESP协议中，错误回复可以当做简单字符串回复的变种形式，它们之间的格式也非常类似，区别只有第一个字符是以&lt;code&gt;-&lt;/code&gt;作为开头，错误回复的内容通常是错误类型及对错误描述的字符串。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;错误回复出现在一些异常的场景，例如当发送了错误的指令、操作数的数量不对时，都会进行错误回复。在客户端收到错误回复后，会将它与简单字符串回复进行区分，视为异常。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.184873949579832&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZ08KPRWFa6JlBqaskXvoyfg3vfSI3FdGySPRlPuGDajnFfmNmqoEyDfwzDzMo1u9fWKw01Qb8PgQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;476&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;整数回复&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整数回复的应用也非常广泛，它以&lt;code&gt;:&lt;/code&gt;作为开头，以&lt;code&gt;\r\n&lt;/code&gt;结束，用于返回一个整数。例如当执行&lt;code&gt;incr&lt;/code&gt;后返回自增后的值，执行&lt;code&gt;llen&lt;/code&gt;返回数组的长度，或者使用&lt;code&gt;exists&lt;/code&gt;命令返回的0或1作为判断一个&lt;code&gt;key&lt;/code&gt;是否存在的依据，这些都使用了整数回复。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9537815126050421&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZ08KPRWFa6JlBqaskXvoyfa4LiaqVYk1TOahicuRq4E2ib6nxDLEyzQsLiaRXzBtoiaKWeYzlETzhDia8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;476&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;批量回复&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;批量回复，就是多行字符串的回复。它以&lt;code&gt;$&lt;/code&gt;作为开头，后面是发送的字节长度，然后是&lt;code&gt;\r\n&lt;/code&gt;，然后发送实际的数据，最终以&lt;code&gt;\r\n&lt;/code&gt;结束。如果要回复的数据不存在，那么回复长度为-1。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.5126050420168067&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZ08KPRWFa6JlBqaskXvoyfBnACFwLBXNNhggIcPH9K5JXQjXeJna8zEqicQBA30rYW7ZnyzfDkic5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;476&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;多条批量回复&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当服务端要返回多个值时，例如返回一些元素的集合时，就会使用多条批量回复。它以&lt;code&gt;*&lt;/code&gt;作为开头，后面是返回元素的个数，之后再跟随多个上面讲到过的批量回复。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.3907563025210083&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZ08KPRWFa6JlBqaskXvoyfq3s6vL0Ud67Ivib4UE6BRUibInIkmiaOUf2OX8ibWpJ4ThDSwGQ4JJZwcw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;476&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里，基本上我和小弟之间的通讯协议就介绍完了。刚才你尝试了伪装成一个服务端，这会再来试一试直接写一个客户端来直接和我进行交互吧。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;client&lt;/span&gt;() &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;    String CRLF=&lt;span&gt;&quot;\r\n&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    Socket socket=&lt;span&gt;new&lt;/span&gt; Socket(&lt;span&gt;&quot;localhost&quot;&lt;/span&gt;, &lt;span&gt;6379&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; (OutputStream out = socket.getOutputStream()) {&lt;br/&gt;        StringBuffer sb=&lt;span&gt;new&lt;/span&gt; StringBuffer();&lt;br/&gt;        sb.append(&lt;span&gt;&quot;*3&quot;&lt;/span&gt;).append(CRLF)&lt;br/&gt;                .append(&lt;span&gt;&quot;$3&quot;&lt;/span&gt;).append(CRLF).append(&lt;span&gt;&quot;set&quot;&lt;/span&gt;).append(CRLF)&lt;br/&gt;                .append(&lt;span&gt;&quot;$4&quot;&lt;/span&gt;).append(CRLF).append(&lt;span&gt;&quot;key1&quot;&lt;/span&gt;).append(CRLF)&lt;br/&gt;                .append(&lt;span&gt;&quot;$6&quot;&lt;/span&gt;).append(CRLF).append(&lt;span&gt;&quot;value1&quot;&lt;/span&gt;).append(CRLF);&lt;br/&gt;        out.write(sb.toString().getBytes());&lt;br/&gt;        out.flush();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; (InputStream inputStream = socket.getInputStream()) {&lt;br/&gt;            &lt;span&gt;byte&lt;/span&gt;[] buff = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;1024&lt;/span&gt;];&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; len = inputStream.read(buff);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (len &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                String ret = &lt;span&gt;new&lt;/span&gt; String(buff, &lt;span&gt;0&lt;/span&gt;, len);&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;Recv:&quot;&lt;/span&gt; + ret);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行上面的代码，控制台输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Recv:+OK&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面模仿了客户端发出&lt;code&gt;set&lt;/code&gt;命令的过程，并收到了回复。依此类推，你也可以自己封装其他的命令，来实现一个自己的Redis客户端，作为小弟，来和我进行通信。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过记住，要叫我大哥。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>178e515fa4c31590c16c6cdb32a56986</guid>
<title>Redis 最佳实践：7 个维度 + 43 条使用规范，带你彻底玩转 Redis（附实践清单）</title>
<link>https://toutiao.io/k/kkvemjf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;span&gt;这篇文&lt;/span&gt;&lt;span&gt;章我想和你聊一聊 Redis 的最佳实践。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你的项目或许已经使用 Redis 很长时间了，但在使用过程中，你可能还会或多或少地遇到以下问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;我的 Redis 内存为什么增长这么快？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么我的 Redis 操作延迟变大了？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何降低 Redis 故障发生的频率？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;日常运维 Redis 需要注意什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;部署 Redis 时，如何做好资源规划？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Redis 监控重点要关注哪些指标？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尤其是当你的项目越来越依赖 Redis 时，这些问题就变得尤为重要。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，你迫切需要一份&lt;strong&gt;「最佳实践指南」&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章，我将从以下七个维度，带你「全面」分析 Redis 的最佳实践优化：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在文章的最后，我还会给你一个完整的最佳实践清单，不管你是业务开发人员，还是 DBA 运维人员，这个清单将会帮助你更加「优雅」地用好 Redis。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;这篇文章干货很多，希望你可以耐心读完。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5761589403973509&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gB9Yvac5K3OSCEIQBtroLfFiaMMWzJpyx7AWsPEBcwibhCgk78ibcYPOJrBMEjvclD1wYHibyjNg0OsKnKFapTBbyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;453&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如何使用 Redis 更节省内存？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，我们来看一下 Redis 内存方面的优化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;众所周知，Redis 的性能之所以如此之高，原因就在于它的数据都存储在「内存」中，所以访问 Redis 中的数据速度极快。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但从资源利用率层面来说，机器的内存资源相比于磁盘，还是比较昂贵的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当你的业务应用在 Redis 中存储数据很少时，你可能并不太关心内存资源的使用情况。但随着业务的发展，你的业务存储在 Redis 中的数据就会越来越多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果没有提前制定好内存优化策略，那么等业务开始增长时，Redis 占用的内存也会开始膨胀。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，提前制定合理的内存优化策略，对于资源利用率的提升是很有必要的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那在使用 Redis 时，怎样做才能更节省内存呢？这里我给你总结了 6 点建议，我们依次来看：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;1) 控制 key 的长度&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最简单直接的内存优化，就是控制 key 的长度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在开发业务时，你需要提前预估整个 Redis 中写入 key 的数量，如果 key 数量达到了百万级别，那么，过长的 key 名也会占用过多的内存空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，你需要保证 key 在简单、清晰的前提下，尽可能把 key 定义得短一些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，原有的 key 为 user:book:123，则可以优化为 u:bk:123。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样一来，你的 Redis 就可以节省大量的内存，这个方案对内存的优化非常直接和高效。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;2) 避免存储 bigkey&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了控制 key 的长度之外，你同样需要关注 value 的大小，如果大量存储 bigkey，也会导致 Redis 内存增长过快。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，客户端在读写 bigkey 时，还有产生性能问题（下文会具体详述）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，你要避免在 Redis 中存储 bigkey，我给你的建议是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;String：大小控制在 10KB 以下&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;List/Hash/Set/ZSet：元素数量控制在 1 万以下&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;3) 选择合适的数据类型&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 提供了丰富的数据类型，这些数据类型在实现上，也对内存使用做了优化。具体来说就是，一种数据类型对应多种数据结构来实现：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7314974182444062&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gB9Yvac5K3OSCEIQBtroLfFiaMMWzJpyxDPJAlJj31DWQxBtUc4qCyqPt5SEWNpY1JpDyibcJxo1rhVBmqMjIw9g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;581&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，String、Set 在存储 int 数据时，会采用整数编码存储。Hash、ZSet 在元素数量比较少时（可配置），会采用压缩列表（ziplist）存储，在存储比较多的数据时，才会转换为哈希表和跳表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者这么设计的原因，就是为了进一步节约内存资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么你在存储数据时，就可以利用这些特性来优化 Redis 的内存。这里我给你的建议如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;String、Set：尽可能存储 int 类型数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Hash、ZSet：存储的元素数量控制在转换阈值之下，以压缩列表存储，节约内存&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;4) 把 Redis 当作缓存使用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 数据存储在内存中，这也意味着其资源是有限的。你在使用 Redis 时，要把它当做缓存来使用，而不是数据库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，你的应用写入到  Redis 中的数据，尽可能地都设置「过期时间」。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业务应用在 Redis 中查不到数据时，再从后端数据库中加载到 Redis 中。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5591647331786543&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3OSCEIQBtroLfFiaMMWzJpyx4t8UZ34WMpePuN9IFbicJlvRyuZFrXTAZSemoQV44KSmZLvt8AYqE7A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;431&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;采用这种方案，可以让 Redis 中只保留经常访问的「热数据」，内存利用率也会比较高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;5) 实例设置 maxmemory + 淘汰策略&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然你的 Redis key 都设置了过期时间，但如果你的业务应用写入量很大，并且过期时间设置得比较久，那么短期间内 Redis 的内存依旧会快速增长。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不控制 Redis 的内存上限，也会导致使用过多的内存资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于这种场景，你需要提前预估业务数据量，然后给这个实例设置 maxmemory 控制实例的内存上限，这样可以避免 Redis 的内存持续膨胀。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置了 maxmemory，此时你还要设置数据淘汰策略，而淘汰策略如何选择，你需要结合你的业务特点来决定：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;volatile-lru / allkeys-lru：优先保留最近访问过的数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;volatile-lfu / allkeys-lfu：优先保留访问次数最频繁的数据（4.0+版本支持）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;volatile-ttl ：优先淘汰即将过期的数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;volatile-random / allkeys-random：随机淘汰数据&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;6) 数据压缩后写入 Redis&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上方案基本涵盖了 Redis 内存优化的各个方面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你还想进一步优化 Redis 内存，你还可以在业务应用中先将数据压缩，再写入到 Redis 中（例如采用 snappy、gzip 等压缩算法）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，压缩存储的数据，客户端在读取时还需要解压缩，在这期间会消耗更多 CPU 资源，你需要根据实际情况进行权衡。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是「节省内存资源」方面的实践优化，是不是都比较简单？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看「性能」方面的优化。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如何持续发挥 Redis 的高性能？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当你的系统决定引入 Redis 时，想必看中它最关键的一点就是：&lt;strong&gt;性能&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道，一个单机版 Redis 就可以达到 10W QPS，这么高的性能，也意味着如果在使用过程中发生延迟情况，就会与我们的预期不符。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，在使用 Redis 时，如何持续发挥它的高性能，避免操作延迟的情况发生，也是我们的关注焦点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这方面，我给你总结了 13 条建议：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;1) 避免存储 bigkey&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;存储 bigkey 除了前面讲到的使用过多内存之外，对 Redis 性能也会有很大影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于 Redis 处理请求是单线程的，当你的应用在写入一个 bigkey 时，更多时间将消耗在「内存分配」上，这时操作延迟就会增加。同样地，删除一个 bigkey 在「释放内存」时，也会发生耗时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且，当你在读取这个 bigkey 时，也会在「网络数据传输」上花费更多时间，此时后面待执行的请求就会发生排队，Redis 性能下降。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3168469860896445&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3OSCEIQBtroLfFiaMMWzJpyx7J5WTib2UYFNWSPaP7UMOulkISC5KQ0syDoibcouL0iaiay0vzLPbNQSJg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;647&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，你的业务应用尽量不要存储 bigkey，避免操作延迟发生。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如果你确实有存储 bigkey 的需求，你可以把 bigkey 拆分为多个小 key 存储。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;2) 开启 lazy-free 机制&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你无法避免存储 bigkey，那么我建议你开启 Redis 的 lazy-free 机制。（4.0+版本支持）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当开启这个机制后，Redis 在删除一个 bigkey 时，释放内存的耗时操作，将会放到后台线程中去执行，这样可以在最大程度上，避免对主线程的影响。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4406196213425129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3OSCEIQBtroLfFiaMMWzJpyxhrumCSKsfLUgVaAWxicFawP6ZbMrCyGSAL6Tas29Wue76gNLSHEIesA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;581&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;3) 不使用复杂度过高的命令&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 是单线程模型处理请求，除了操作 bigkey 会导致后面请求发生排队之外，在执行复杂度过高的命令时，也会发生这种情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为执行复杂度过高的命令，会消耗更多的 CPU 资源，主线程中的其它请求只能等待，这时也会发生排队延迟。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，你需要避免执行例如 SORT、SINTER、SINTERSTORE、ZUNIONSTORE、ZINTERSTORE 等聚合类命令。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于这种聚合类操作，我建议你把它放到客户端来执行，不要让 Redis 承担太多的计算工作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;4) 执行 O(N) 命令时，关注 N 的大小&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;规避使用复杂度过高的命令，就可以高枕无忧了么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是否定的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当你在执行 O(N) 命令时，同样需要注意 N 的大小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一次性查询过多的数据，也会在网络传输过程中耗时过长，操作延迟变大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，对于容器类型（List/Hash/Set/ZSet），在元素数量未知的情况下，一定不要无脑执行 LRANGE key 0 -1 / HGETALL / SMEMBERS / ZRANGE key 0 -1。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在查询数据时，你要遵循以下原则：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;先查询数据元素的数量（LLEN/HLEN/SCARD/ZCARD）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;元素数量较少，可一次性查询全量数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;元素数量非常多，分批查询数据（LRANGE/HASCAN/SSCAN/ZSCAN）&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;5) 关注 DEL 时间复杂度&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你没看错，在删除一个 key 时，如果姿势不对，也有可能影响到 Redis 性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;删除一个 key，我们通常使用的是 DEL 命令，回想一下，你觉得 DEL 的时间复杂度是多少？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;O(1) ？其实不一定。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当你删除的是一个 String 类型 key 时，时间复杂度确实是 O(1)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但当你要删除的 key 是 List/Hash/Set/ZSet 类型，它的复杂度其实为 O(N)，N 代表元素个数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;也就是说，删除一个 key，其元素数量越多，执行 DEL 也就越慢！&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原因在于，删除大量元素时，需要依次回收每个元素的内存，元素越多，花费的时间也就越久！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且，这个过程默认是在主线程中执行的，这势必会阻塞主线程，产生性能问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那删除这种元素比较多的 key，如何处理呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我给你的建议是，分批删除：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;List类型：执行多次 LPOP/RPOP，直到所有元素都删除完成&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Hash/Set/ZSet类型：先执行 HSCAN/SSCAN/SCAN 查询元素，再执行 HDEL/SREM/ZREM 依次删除每个元素&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没想到吧？一个小小的删除操作，稍微不小心，也有可能引发性能问题，你在操作时需要格外注意。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;6) 批量命令代替单个命令&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当你需要一次性操作多个 key 时，你应该使用批量命令来处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;批量操作相比于多次单个操作的优势在于，可以显著减少客户端、服务端的来回网络 IO 次数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我给你的建议是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;String / Hash 使用 MGET/MSET 替代 GET/SET，HMGET/HMSET 替代 HGET/HSET&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;其它数据类型使用 Pipeline，打包一次性发送多个命令到服务端执行&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8656429942418427&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3OSCEIQBtroLfFiaMMWzJpyxjWasaOIYSbt5M6jhuURC6qRiabvsCQa5UwNZL8uk06ulNicxrXVkCNNA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;521&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;7) 避免集中过期 key&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 清理过期 key 是采用定时 + 懒惰的方式来做的，而且这个过程都是在主线程中执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你的业务存在大量 key 集中过期的情况，那么 Redis 在清理过期 key 时，也会有阻塞主线程的风险。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.22901849217638692&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3OSCEIQBtroLfFiaMMWzJpyxZicHACvFNPU8gXS3VK2mDhfVJVnuTD5FSo5fTQdOABSrpYVrndge37A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;703&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想要避免这种情况发生，你可以在设置过期时间时，增加一个随机时间，把这些 key 的过期时间打散，从而降低集中过期对主线程的影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;8) 使用长连接操作 Redis，合理配置连接池&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你的业务应该使用长连接操作 Redis，避免短连接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当使用短连接操作 Redis 时，每次都需要经过 TCP 三次握手、四次挥手，这个过程也会增加操作耗时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时，你的客户端应该使用连接池的方式访问 Redis，并设置合理的参数，长时间不操作 Redis 时，需及时释放连接资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;9) 只使用 db0&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽管 Redis 提供了 16 个 db，但我只建议你使用 db0。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么呢？我总结了以下 3 点原因：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在一个连接上操作多个 db 数据时，每次都需要先执行 SELECT，这会给 Redis 带来额外的压力&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用多个 db 的目的是，按不同业务线存储数据，那为何不拆分多个实例存储呢？拆分多个实例部署，多个业务线不会互相影响，还能提高 Redis 的访问性能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Redis Cluster 只支持 db0，如果后期你想要迁移到 Redis Cluster，迁移成本高&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;10) 使用读写分离 + 分片集群&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你的业务读请求量很大，那么可以采用部署多个从库的方式，实现读写分离，让 Redis 的从库分担读压力，进而提升性能。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6519721577726219&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3OSCEIQBtroLfFiaMMWzJpyxjLxTKDdPHc6GLHiaKF4iaialXGwoicYRCjUSLibnqR4GTaGO3yTMMotawng/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;431&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你的业务写请求量很大，单个 Redis 实例已无法支撑这么大的写流量，那么此时你需要使用分片集群，分担写压力。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.501466275659824&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3OSCEIQBtroLfFiaMMWzJpyxw0H7LsTOpeAUpREmuyZQBAelbaMGY6oOHzvyf1jKMTyxiagkYYZqCkw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;682&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;11) 不开启 AOF 或 AOF 配置为每秒刷盘&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果对于丢失数据不敏感的业务，我建议你不开启 AOF，避免 AOF 写磁盘拖慢 Redis 的性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果确实需要开启 AOF，那么我建议你配置为 appendfsync everysec，把数据持久化的刷盘操作，放到后台线程中去执行，尽量降低 Redis 写磁盘对性能的影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;12) 使用物理机部署 Redis&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 在做数据持久化时，采用创建子进程的方式进行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而创建子进程会调用操作系统的 fork 系统调用，这个系统调用的执行耗时，与系统环境有关。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虚拟机环境执行 fork 的耗时，要比物理机慢得多，所以你的 Redis 应该尽可能部署在物理机上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;13) 关闭操作系统内存大页机制&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Linux 操作系统提供了内存大页机制，其特点在于，每次应用程序向操作系统申请内存时，申请单位由之前的 4KB 变为了 2MB。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这会导致什么问题呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 Redis 在做数据持久化时，会先 fork 一个子进程，此时主进程和子进程共享相同的内存地址空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当主进程需要修改现有数据时，会采用写时复制（Copy On Write）的方式进行操作，在这个过程中，需要重新申请内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果申请内存单位变为了 2MB，那么势必会增加内存申请的耗时，如果此时主进程有大量写操作，需要修改原有的数据，那么在此期间，操作延迟就会变大。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9879663056558363&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3OSCEIQBtroLfFiaMMWzJpyxNz0n0fpaMdYViaibYjWb0Kjx1PZ7Cdu651ib4LSHm1TAJGX5UEQLEOMfA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;831&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，为了避免出现这种问题，你需要在操作系统上关闭内存大页机制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，以上这些就是 Redis 「高性能」方面的实践优化。如果你非常关心 Redis 的性能问题，可以结合这些方面针对性优化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再来看 Redis 「可靠性」如何保证。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如何保证 Redis 的可靠性？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我想提醒你的是，保证 Redis 可靠性其实并不难，但难的是如何做到「持续稳定」。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我会从「资源隔离」、「多副本」、「故障恢复」这三大维度，带你分析保障 Redis 可靠性的最佳实践。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;1) 按业务线部署实例&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提升可靠性的第一步，就是「资源隔离」。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你最好按不同的业务线来部署 Redis 实例，这样当其中一个实例发生故障时，不会影响到其它业务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种资源隔离的方案，实施成本是最低的，但成效却是非常大的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;2) 部署主从集群&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你只使用单机版 Redis，那么就会存在机器宕机服务不可用的风险。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，你需要部署「多副本」实例，即主从集群，这样当主库宕机后，依旧有从库可以使用，避免了数据丢失的风险，也降低了服务不可用的时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在部署主从集群时，你还需要注意，主从库需要分布在不同机器上，避免交叉部署。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这么做的原因在于，通常情况下，Redis 的主库会承担所有的读写流量，所以我们一定要优先保证主库的稳定性，即使从库机器异常，也不要对主库造成影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且，有时我们需要对 Redis 做日常维护，例如数据定时备份等操作，这时你就可以只在从库上进行，这只会消耗从库机器的资源，也避免了对主库的影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;3) 合理配置主从复制参数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在部署主从集群时，如果参数配置不合理，也有可能导致主从复制发生问题：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这方面我给你的建议有以下 2 点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;设置合理的 repl-backlog 参数：过小的 repl-backlog 在写流量比较大的场景下，主从复制中断会引发全量复制数据的风险&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设置合理的 slave client-output-buffer-limit：当从库复制发生问题时，过小的 buffer 会导致从库缓冲区溢出，从而导致复制中断&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;4) 部署哨兵集群，实现故障自动切换&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只部署了主从节点，但故障发生时是无法自动切换的，所以，你还需要部署哨兵集群，实现故障的「自动切换」。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且，多个哨兵节点需要分布在不同机器上，实例为奇数个，防止哨兵选举失败，影响切换时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上这些就是保障 Redis「高可靠」实践优化，你应该也发现了，这些都是部署和运维层的优化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，你可能还会对 Redis 做一些「日常运维」工作，这时你要注意哪些问题呢？&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;日常运维 Redis 需要注意什么？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果你是 DBA 运维人员，在平时运维 Redis 时，也需要注意以下 6 个方面。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;1) 禁止使用 KEYS/FLUSHALL/FLUSHDB 命令&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行这些命令，会长时间阻塞 Redis 主线程，危害极大，所以你必须禁止使用它。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果确实想使用这些命令，我给你的建议是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;SCAN 替换 KEYS&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;4.0+版本可使用 FLUSHALL/FLUSHDB ASYNC，清空数据的操作放在后台线程执行&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;2) 扫描线上实例时，设置休眠时间&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不管你是使用 SCAN 扫描线上实例，还是对实例做 bigkey 统计分析，我建议你在扫描时一定记得设置休眠时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;防止在扫描过程中，实例 OPS 过高对 Redis 产生性能抖动。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;3) 慎用 MONITOR 命令&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时在排查 Redis 问题时，你会使用 MONITOR 查看 Redis 正在执行的命令。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果你的 Redis OPS 比较高，那么在执行 MONITOR 会导致 Redis 输出缓冲区的内存持续增长，这会严重消耗 Redis 的内存资源，甚至会导致实例内存超过 maxmemory，引发数据淘汰，这种情况你需要格外注意。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3315972222222222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3OSCEIQBtroLfFiaMMWzJpyxmZvibuS8oeZibfl9TDvwmAx5mleOmpUtYcprib55awsF3Dh8vTBen7teg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;576&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以你在执行 MONITOR 命令时，一定要谨慎，尽量少用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;4) 从库必须设置为 slave-read-only&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你的从库必须设置为 slave-read-only 状态，避免从库写入数据，导致主从数据不一致。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，从库如果是非 read-only 状态，如果你使用的是 4.0 以下的 Redis，它存在这样的 Bug：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;从库写入了有过期时间的数据，不会做定时清理和释放内存。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这会造成从库的内存泄露！这个问题直到 4.0 版本才修复，你在配置从库时需要格外注意。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;5) 合理配置 timeout 和 tcp-keepalive 参数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果因为网络原因，导致你的大量客户端连接与 Redis 意外中断，恰好你的 Redis 配置的 maxclients 参数比较小，此时有可能导致客户端无法与服务端建立新的连接（服务端认为超过了 maxclients）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;造成这个问题原因在于，客户端与服务端每建立一个连接，Redis 都会给这个客户端分配了一个 client fd。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;当客户端与服务端网络发生问题时，服务端并不会立即释放这个 client fd。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;什么时候释放呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 内部有一个定时任务，会定时检测所有 client 的空闲时间是否超过配置的 timeout 值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果 Redis 没有开启 tcp-keepalive 的话，服务端直到配置的 timeout 时间后，才会清理释放这个 client fd。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在没有清理之前，如果还有大量新连接进来，就有可能导致 Redis 服务端内部持有的 client fd 超过了 maxclients，这时新连接就会被拒绝。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对这种情况，我给你的优化建议是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;不要配置过高的 timeout：让服务端尽快把无效的 client fd 清理掉&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Redis 开启 tcp-keepalive：这样服务端会定时给客户端发送 TCP 心跳包，检测连接连通性，当网络异常时，可以尽快清理僵尸 client fd&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;6) 调整 maxmemory 时，注意主从库的调整顺序&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 5.0 以下版本存在这样一个问题：&lt;strong&gt;从库内存如果超过了 maxmemory，也会触发数据淘汰。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在某些场景下，从库是可能优先主库达到 maxmemory 的（例如在从库执行 MONITOR 命令，输出缓冲区占用大量内存），那么此时从库开始淘汰数据，主从库就会产生不一致。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要想避免此问题，在调整 maxmemory 时，一定要注意主从库的修改顺序：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;调大 maxmemory：先修改从库，再修改主库&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调小 maxmemory：先修改主库，再修改从库&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直到 Redis 5.0，Redis 才增加了一个配置 replica-ignore-maxmemory，默认从库超过 maxmemory 不会淘汰数据，才解决了此问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，以上这些就是「日常运维」Redis 需要注意的，你可以对各个配置项查漏补缺，看有哪些是需要优化的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，我们来看一下，保障 Redis「安全」都需要注意哪些问题。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 安全如何保证？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论如何，在互联网时代，安全问题一定是我们需要随时警戒的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可能听说过 Redis 被注入可执行脚本，然后拿到机器 root 权限的安全问题，都是因为在部署 Redis 时，没有把安全风险注意起来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对这方面，我给你的建议是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;不要把 Redis 部署在公网可访问的服务器上&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;部署时不使用默认端口 6379&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;以普通用户启动 Redis 进程，禁止 root 用户启动&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;限制 Redis 配置文件的目录访问权限&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;推荐开启密码认证&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;禁用/重命名危险命令（KEYS/FLUSHALL/FLUSHDB/CONFIG/EVAL）&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只要你把这些做到位，基本上就可以保证 Redis 的安全风险在可控范围内。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此，我们分析了 Redis 在内存、性能、可靠性、日常运维方面的最佳实践优化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了以上这些，你还需要做到提前「预防」。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如何预防 Redis 问题？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要想提前预防 Redis 问题，你需要做好以下两个方面：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;合理的资源规划&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;完善的监控预警&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先来说资源规划。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在部署 Redis 时，如果你可以提前做好资源规划，可以避免很多因为资源不足产生的问题。这方面我给你的建议有以下 3 点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;保证机器有足够的 CPU、内存、带宽、磁盘资源&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提前做好容量规划，主库机器预留一半内存资源，防止主从机器网络故障，引发大面积全量同步，导致主库机器内存不足的问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;单个实例内存建议控制在 10G 以下，大实例在主从全量同步、RDB 备份时有阻塞风险&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再来看监控如何做。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;监控预警是提高稳定性的重要环节，完善的监控预警，可以把问题提前暴露出来，这样我们才可以快速反应，把问题最小化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这方面我给你的建议是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;做好机器 CPU、内存、带宽、磁盘监控，资源不足时及时报警，任意资源不足都会影响 Redis 性能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设置合理的 slowlog 阈值，并对其进行监控，slowlog 过多及时报警&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;监控组件采集 Redis INFO 信息时，采用长连接，避免频繁的短连接&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;做好实例运行时监控，重点关注 expired_keys、evicted_keys、latest_fork_usec 指标，这些指标短时突增可能会有阻塞风险&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，总结一下，这篇文章我带你全面分析了 Redis 最佳实践的优化路径，其中包括内存资源、高性能、高可靠、日常运维、资源规划、监控、安全 7 个维度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我画成了思维导图，方便你在实践时做参考。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;491&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.8651419558359621&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gB9Yvac5K3OSCEIQBtroLfFiaMMWzJpyxoZ9Qog3MIZmVibbhozjUdiaAvXZzBQwecWskzfluZ0FWQoiaPDI69NGNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2536&quot;/&gt;&lt;span&gt;我还&lt;/span&gt;&lt;span&gt;把这些实践优化，按照「业务开发」和「运维」两个维度，进一步做了划分。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;并且以「强制」、「推荐」、「参考」3 个级别做了标注，这样你在实践优化时，就会更明确哪些该做，哪些需要结合实际的业务场景进一步分析。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这些级&lt;/span&gt;&lt;span&gt;别的实施规则如下：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;强制：需严格遵守，否则危害极大&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;推荐：推荐遵守，可提升性能、降低内存、便于运维&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;参考：根据业务特点参考实施&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你是业务开发人员，你需要了解 Redis 的运行机制，例如各个命令的执行时间复杂度、数据过期策略、数据淘汰策略等，使用合理的命令，并结合业务场景进行优化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;568&quot; data-backw=&quot;568&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gB9Yvac5K3OSCEIQBtroLfFiaMMWzJpyx4KzYB53twzEqX99WuDzqTEZcTB2ZPAib4iayicx6woZDKGYF6wtd4DHPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1490&quot;/&gt;&lt;span&gt;如果你是 DBA 运&lt;/span&gt;&lt;span&gt;维人员，你需要在资源规划、运维、监控、安全层面做到位，&lt;span&gt;做到未雨绸缪。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;img data-backh=&quot;656&quot; data-backw=&quot;568&quot; data-ratio=&quot;1.1548582995951417&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gB9Yvac5K3OSCEIQBtroLfFiaMMWzJpyxvHiaHzsZjBhn2KS2Eq2xSrfYZiaCiaGhicruGN6ENHrEpxcmcmlZalGia3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1976&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;后记&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你能耐心地读到这里，应该对如何「用好」Redis 有了新的认识。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章我们主要讲的是 Redis 最佳实践，对于「最佳实践」这个话题，我想再和你多聊几句。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如果你面对的不是 Redis，而是其它中间件，例如 MySQL、Kafka，你在使用这些组件时，会有什么优化思路吗？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你也可以沿用这篇文章的这几个维度来分析：&lt;/p&gt;&lt;section&gt;你可以思考一下，MySQL 和 Kafka 在这几个维度，需要注意哪些问题。&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，从学习技能的角度来讲，我们在软件开发过程中，要尽可能地去思考和探索「最佳实践」的方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;因为只有这样，我们才会不断督促自己去思考，对自己提出更高的要求，做到持续进步。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p&gt;往期推荐&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3ODkzMDA2Mw==&amp;amp;mid=2247483874&amp;amp;idx=1&amp;amp;sn=2fc108a4495ebea67e72ba01f2ea4fea&amp;amp;chksm=fd6c9502ca1b1c14985958ca223ef7d4031a7041464c8131a76499a541da1c92f397790d3902&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;彻底搞懂事件驱动模型 - Reactor&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3ODkzMDA2Mw==&amp;amp;mid=2247483865&amp;amp;idx=1&amp;amp;sn=7f758aa084e30195d32d51f67dacc5d8&amp;amp;chksm=fd6c9539ca1b1c2f322fd00bd683e0ecfdb084b082a632a1011c98790e3a04081298a6417f81&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;如何科学破解慢SQL?&lt;/a&gt;&lt;/p&gt;&lt;p&gt;最后，欢迎大家关注Kaito和铁柱，一起成长。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/bymGBmLC3zGuqeeB9CXfeY68KDuHKbP2e0tu0b3IdRH4xAT5FwcUNoVIIFibkQr1LSahlnw08SCLia9zN6QMVTyw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1fd9ea13a730ec39d15d34482d339681</guid>
<title>有了 WebClient 还在用 RestTemplate？</title>
<link>https://toutiao.io/k/z9fx1fc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;Spring&lt;/code&gt;官方推荐使用&lt;code&gt;WebClient&lt;/code&gt;替代&lt;code&gt;RestTemplate&lt;/code&gt;完成&lt;code&gt;HTTP&lt;/code&gt;调用。因为&lt;code&gt;WebClient&lt;/code&gt;是基于&lt;code&gt;Reactor&lt;/code&gt;实现的，所以既可以支持阻塞调用也可以支持非阻塞调用，在高并发的场景下资源利用率更高。这也是官方推荐使用的重要原因之一。&lt;/p&gt;&lt;p&gt;如果大家不了解响应式编程，强烈建议可以先看一下我&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMzE4MDY0Nw==&amp;amp;mid=2247484146&amp;amp;idx=1&amp;amp;sn=5ed35fdc5df7f451e76385abf0bf8890&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;这篇文章&lt;/a&gt;，这样对本篇文章中的样例代码也会有些帮助。&lt;/p&gt;&lt;p&gt;如果在工程中想要用&lt;code&gt;WebClient&lt;/code&gt;，在&lt;code&gt;Pom&lt;/code&gt;文件中加入如下依赖&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-webflux&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果使用的是&lt;code&gt;Gradle&lt;/code&gt;，则加入如下依赖&lt;/p&gt;&lt;pre&gt;&lt;code&gt;dependencies {&lt;br/&gt;    compile &lt;span&gt;&#x27;org.springframework.boot:spring-boot-starter-webflux&#x27;&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5&gt;&lt;span&gt;初始化WebClient&lt;/span&gt;&lt;/h5&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;直接初始化，不加任何参数。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;    WebClient client = WebClient.create();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;初始化时，提供一个默认的调用地址。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;WebClient client = WebClient.create(&lt;span&gt;&quot;http://localhost:8080&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;自定义参数初始化。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;WebClient client = WebClient.builder()&lt;br/&gt;    .baseUrl(&lt;span&gt;&quot;http://localhost:8080&quot;&lt;/span&gt;)&lt;br/&gt;    .defaultCookie(&lt;span&gt;&quot;cookieKey&quot;&lt;/span&gt;, &lt;span&gt;&quot;cookieValue&quot;&lt;/span&gt;)&lt;br/&gt;    .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)&lt;br/&gt;    .defaultUriVariables(Collections.singletonMap(&lt;span&gt;&quot;url&quot;&lt;/span&gt;, &lt;span&gt;&quot;http://localhost:8080&quot;&lt;/span&gt;))&lt;br/&gt;    .build();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;4&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;修改默认的超时时间。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;//通过HttpClient设置超时时间&lt;/span&gt;&lt;br/&gt;HttpClient httpClient = HttpClient.create()&lt;br/&gt;    &lt;span&gt;//设置连接超时时间&lt;/span&gt;&lt;br/&gt;    .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, &lt;span&gt;5000&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;//设置响应超时时间&lt;/span&gt;&lt;br/&gt;    .responseTimeout(Duration.ofMillis(&lt;span&gt;5000&lt;/span&gt;))&lt;br/&gt;    &lt;span&gt;//分别设置读写超时时间&lt;/span&gt;&lt;br/&gt;    .doOnConnected(conn -&amp;gt; conn.addHandlerLast(&lt;span&gt;new&lt;/span&gt;          ReadTimeoutHandler(&lt;span&gt;5000&lt;/span&gt;, TimeUnit.MILLISECONDS))     .addHandlerLast(&lt;span&gt;new&lt;/span&gt; WriteTimeoutHandler(&lt;span&gt;5000&lt;/span&gt;,TimeUnit.MILLISECONDS))); &lt;br/&gt;    &lt;br/&gt;WebClient client = WebClient.builder()&lt;br/&gt;.clientConnector(&lt;span&gt;new&lt;/span&gt; ReactorClientHttpConnector(httpClient))&lt;br/&gt;.build();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5&gt;&lt;span&gt;发起Get请求&lt;/span&gt;&lt;/h5&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;以阻塞的方式获取0或者1个返回结果,用&lt;code&gt;Mono&lt;/code&gt;表示&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;//通过builder的方式初始化&lt;/span&gt;&lt;br/&gt;WebClientWebClient webClient = WebClient.builder()        &lt;span&gt;//配置头部信息  &lt;/span&gt;&lt;br/&gt;.defaultHeader(HttpHeaders.ACCEPT_CHARSET, &lt;span&gt;&quot;UTF-8&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;//定义过滤器        &lt;/span&gt;&lt;br/&gt;.filter(ExchangeFilterFunctions.basicAuthentication(&lt;span&gt;&quot;user&quot;&lt;/span&gt;,&lt;span&gt;&quot;password&quot;&lt;/span&gt;))&lt;br/&gt;.filter((clientRequest, next) -&amp;gt; {           &lt;br/&gt;        logger.info(&lt;span&gt;&quot;Request: {} {}&quot;&lt;/span&gt;,clientRequest.method(),clientRequest.url());&lt;br/&gt;clientRequest.headers()&lt;br/&gt;        .forEach((name, values) -&amp;gt; values.forEach(value &lt;br/&gt;-&amp;gt; logger.info(&lt;span&gt;&quot;{}={}&quot;&lt;/span&gt;, name, value)));&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; next.exchange(clientRequest);&lt;br/&gt;})&lt;br/&gt;.build();&lt;br/&gt;&lt;span&gt;//发起GET请求&lt;/span&gt;&lt;br/&gt;Mono&amp;lt;String&amp;gt; resp = webClient.get()&lt;br/&gt;.uri(&lt;span&gt;&quot;https://localhost:8080&quot;&lt;/span&gt;) &lt;br/&gt;&lt;span&gt;//获取结果 &lt;/span&gt;&lt;br/&gt;.retrieve()&lt;br/&gt;&lt;span&gt;//将结果转化为指定类型 &lt;/span&gt;&lt;br/&gt;.bodyToMono(String&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//以阻塞的方式将结果打印出来&lt;/span&gt;&lt;br/&gt;logger.info(&lt;span&gt;&quot;result:{}&quot;&lt;/span&gt;,resp.block());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;以阻塞方式获取多个返回结果，用&lt;code&gt;Flux&lt;/code&gt;表示&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;Flux&amp;lt;Book&amp;gt; bookFlux = WebClient.create()&lt;br/&gt;                          .method(HttpMethod.GET)&lt;br/&gt;                         .uri(&lt;span&gt;&quot;http://localhost:8080/books&quot;&lt;/span&gt;)&lt;br/&gt;                         .retrieve()&lt;br/&gt;                         .bodyToFlux(Book&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt; &lt;span&gt;//通过阻塞的方式获取响应结果&lt;/span&gt;&lt;br/&gt; List&amp;lt;Book&amp;gt; books = bookFlux.collectList().block();&lt;br/&gt; &lt;span&gt;//通过非阻塞的方式获取响应结果&lt;/span&gt;&lt;br/&gt; bookFlux.subscribe(book -&amp;gt;{System.out.print(book.getName());});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;通过非阻塞方式获取响应结果&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;Flux&amp;lt;Book&amp;gt; bookFlux = WebClient.create()&lt;br/&gt;                          .method(HttpMethod.GET)&lt;br/&gt;                         .uri(&lt;span&gt;&quot;http://localhost:8080/books&quot;&lt;/span&gt;)&lt;br/&gt;                         .retrieve()&lt;br/&gt;                         .bodyToFlux(Book&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;//通过非阻塞的方式获取响应结果&lt;/span&gt;&lt;br/&gt; bookFlux.subscribe(book -&amp;gt;{System.out.print(book.getName());});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;4&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;通过占位符传参&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;Mono&amp;lt;String&amp;gt; mono = WebClient.create()&lt;br/&gt;                    .method(HttpMethod.POST)&lt;br/&gt;                  .uri(&lt;span&gt;&quot;http://localhost:8080/book/{id}/{name}&quot;&lt;/span&gt;, &lt;span&gt;&quot;1&quot;&lt;/span&gt;, &lt;span&gt;&quot;java&quot;&lt;/span&gt;)&lt;br/&gt;                  .retrieve()&lt;br/&gt;                  .bodyToMono(String&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;                  String result = mono.block();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;除了占位符传参，还可以通过map形式传参等等，这里不一一举例介绍了。&lt;/p&gt;&lt;h5&gt;&lt;span&gt;发起POST请求&lt;/span&gt;&lt;/h5&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;发起&lt;code&gt;POST&lt;/code&gt;请求，提交&lt;code&gt;Form&lt;/code&gt;表单&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;MultiValueMap&amp;lt;String, String&amp;gt; formData = &lt;span&gt;new&lt;/span&gt; &lt;br/&gt;LinkedMultiValueMap&amp;lt;&amp;gt;();&lt;br/&gt;formData.add(&lt;span&gt;&quot;name1&quot;&lt;/span&gt;,&lt;span&gt;&quot;value1&quot;&lt;/span&gt;);&lt;br/&gt;formData.add(&lt;span&gt;&quot;name2&quot;&lt;/span&gt;,&lt;span&gt;&quot;value2&quot;&lt;/span&gt;);&lt;br/&gt;Mono&amp;lt;String&amp;gt; resp = WebClient.create().post()&lt;br/&gt;                    .uri(&lt;span&gt;&quot;http://localhost:8080/submit&quot;&lt;/span&gt;)            .contentType(MediaType.APPLICATION_FORM_URLENCODED)&lt;br/&gt;                    .body(BodyInserters.fromFormData(formData))        .retrieve().bodyToMono(String&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;                    logger.info(&lt;span&gt;&quot;result:{}&quot;&lt;/span&gt;,resp.block());&lt;br/&gt; &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;使用&lt;code&gt;Raw Json&lt;/code&gt;的方式发起&lt;code&gt;POST&lt;/code&gt;请求。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;Mono&amp;lt;String&amp;gt; resp = WebClient.create().post()&lt;br/&gt;                    .uri(&lt;span&gt;&quot;http://localhost:8080/book/json&quot;&lt;/span&gt;)&lt;br/&gt;                                                                    .contentType(MediaType.APPLICATION_JSON)&lt;br/&gt;                                                                    .body(BodyInserters.fromValue(&lt;span&gt;&quot;{\n&quot;&lt;/span&gt; +                &lt;span&gt;&quot;    \&quot;name\&quot; : \&quot;java\&quot;,\n&quot;&lt;/span&gt; +                &lt;span&gt;&quot;    \&quot;price\&quot; : \&quot;32.5\&quot; \n&quot;&lt;/span&gt; +                &lt;span&gt;&quot; }&quot;&lt;/span&gt;))        .retrieve().bodyToMono(String&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;logger.info(&lt;span&gt;&quot;result:{}&quot;&lt;/span&gt;,resp.block());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5&gt;&lt;span&gt;错误和异常处理&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;WebClient可以更优雅的处理错误和异常。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;//创建WebClient&lt;/span&gt;&lt;br/&gt;        WebClient webClient = WebClient.builder()&lt;br/&gt;                .baseUrl(&lt;span&gt;&quot;http://localhost:8080&quot;&lt;/span&gt;)&lt;br/&gt;                .defaultHeader(HttpHeaders.CONTENT_TYPE, &lt;span&gt;&quot;application/json&quot;&lt;/span&gt;)&lt;br/&gt;                .defaultHeader(HttpHeaders.ACCEPT_CHARSET, &lt;span&gt;&quot;UTF-8&quot;&lt;/span&gt;)&lt;br/&gt;                .build();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;//发起Get请求&lt;/span&gt;&lt;br/&gt;        WebClient.ResponseSpec responseSpec = webClient.method(HttpMethod.GET)&lt;br/&gt;                .uri(&lt;span&gt;&quot;/book/remark/{id}&quot;&lt;/span&gt;, &lt;span&gt;&quot;1&quot;&lt;/span&gt;)&lt;br/&gt;                .retrieve();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;//根据状态码进行响应&lt;/span&gt;&lt;br/&gt;        Mono&amp;lt;String&amp;gt; mono = responseSpec&lt;br/&gt;                .onStatus(e -&amp;gt; e.is4xxClientError(),resp -&amp;gt; {&lt;br/&gt;                    logger.error(&lt;span&gt;&quot;error:{},msg:{}&quot;&lt;/span&gt;,resp.statusCode().value(),resp.statusCode().getReasonPhrase());&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt; Mono.error(&lt;span&gt;new&lt;/span&gt; RuntimeException(resp.statusCode().value() + &lt;span&gt;&quot; : &quot;&lt;/span&gt; + resp.statusCode().getReasonPhrase()));&lt;br/&gt;                })&lt;br/&gt;                .bodyToMono(String&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;                .&lt;span&gt;doOnError&lt;/span&gt;(&lt;span&gt;WebClientResponseException&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt; -&amp;gt; &lt;/span&gt;{&lt;br/&gt;                    logger.info(&lt;span&gt;&quot;ERROR status:{},msg:{}&quot;&lt;/span&gt;,err.getRawStatusCode(),err.getResponseBodyAsString());&lt;br/&gt;                    &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(err.getMessage());&lt;br/&gt;                })&lt;br/&gt;                .onErrorReturn(&lt;span&gt;&quot;fallback&quot;&lt;/span&gt;);&lt;br/&gt;        String result = mono.block();&lt;br/&gt;        logger.info(&lt;span&gt;&quot;result:{}&quot;&lt;/span&gt;,result);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;以上是一些&lt;code&gt;WebClient&lt;/code&gt;使用的小&lt;code&gt;Demo&lt;/code&gt;，希望对那些想了解&lt;code&gt;WebClient&lt;/code&gt;的同学有一些帮助。如果想深入了解，建议还是多看看官方文档。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMzE4MDY0Nw==&amp;amp;mid=2247484022&amp;amp;idx=1&amp;amp;sn=d3176ea73e48360b64c3f50e8fd622bf&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;1. Java并发编程那些事儿(十)——最后的总结&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMzE4MDY0Nw==&amp;amp;mid=2247484130&amp;amp;idx=1&amp;amp;sn=eb09dd99d1a8e892a3de73d898c04b0c&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;2. 程序员应该掌握的常用网络问题定位工具&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMzE4MDY0Nw==&amp;amp;mid=2247483893&amp;amp;idx=1&amp;amp;sn=85f6a2063048cc244aedde3172444e32&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;3. Awk这件上古神兵你会用了吗&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>19e1c5e226e0f3216ee86518d52d7b2a</guid>
<title>你有做 Code Review 吗？</title>
<link>https://toutiao.io/k/yyrg9dw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.467&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/eqcwh4cqlibF8KRB1hb3MM77LibcU0SYY6Kqp1xAqiaK7JicmoO4byozA8fib3zbDCI4XK4Y8YO0AJViaLHyQoBWXsWg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在代码的编写中有一个很重要的环节，经常会被忽视，那就是 Code Review ,据说在 Facebook、Google 这种互联网大公司，要求每一个提交都必须通过审查，对于每个工程师来说 Code Review 是一项十分重要的工作，甚至比写代码本身更重要。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里所说的 Code Review 是指人工的方式进行代码的检查，通常会给我们带来下面的一些好处：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;编码风格可以保持一致，目前团队中虽然有编码规范的指引，但在代码抽查时，还是会看到很多「个性」的代码；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将明显问题扼杀在摇篮里，有时候存在设计上的一些错误，在后期要调整起来非常麻烦，改动大容易引发新的问题，还需要修复历史数据等；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;新人能够快速融入团队，知道团队的编码风格，能学习到一些优秀代码的写法，也能知道哪些是禁区，不能触碰；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;团队成员之间能够互相学习，构建良好的团队氛围。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不做 Code Review 也能完成功能的实现，只不过慢慢会带来下面的问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;从每天写功能慢慢变成每天写 Bug；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;代码的坏味道越来越浓，代码变得难以维护；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;修改一行代码，测试没有覆盖到，往往就会带来很严重的后果；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可能过一段时间，就需要进行大规模的重构；&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;新人的技能得不到快速提升。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实我们都知道 Code Review 的重要性，敏捷开发中的结对编程就包含了 Code Review ，但为什么却难以执行呢，我认为有下面一些原因：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;项目急，时间紧，完成功能都需要加班加点，哪还有时间做 Code Review；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对 Code Review 的认知不足，不够重视；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;没有相关的流程和制度进行约束，很难坚持执行下去。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们团队的代码采用私有 GitLab 服务器，自然也使用了 GitLab 中的 MR 模式，不清楚 MR 是什么的同学可以看看我之前写的《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU0NjgzNzQyMw==&amp;amp;mid=2247483697&amp;amp;idx=1&amp;amp;sn=5bb54ebc35bac60b141c8c982159cfdb&amp;amp;chksm=fb56c7f1cc214ee7c671f5a8ddfe50887803dd4a3c62f50f011fa009931622a9fe20ff69cd1b&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;在团队中使用 GtiLab 中的 Merge Request 工作模式&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;在团队中使用 GtiLab 中的 Merge Request 工作模式&lt;/a&gt;》。曾经有一个美好的设想就是利用 Merge Request ，让每个人都能参与进来，在 GitLab 中进行代码的讨论，但非常遗憾，最终没能执行起来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Code Review 的工具和方式方法非常多，我们如果能挑一两种方式，落地执行下去，就是非常好的一个开始。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面说到 Merge Request  在团队中没有推行起来，但我个人还是在经常使用，我是代码合并的管理员之一，当合并代码时，我会重点关注两个方面：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、核心代码的改动&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当前功能的提交是否有必要修改到这些地方，理由是什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这些代码的改动有没有可能引发一些严重问题？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、MR 是谁提交的&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果是资深开发人员提交的代码，Review 的粒度会比较粗；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果是新人提交的代码，则会重点关注，包括规范以及逻辑的合理性。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，我们领导推荐的一种做法，目前在团队中一直在执行，就是写代码前先写空方法。将任何的需求转化成代码，中间的思考过程是复杂的，需要考虑很多东西：性能、扩展、是否优雅等，反倒是最终的编码实现相对是简单的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而写空方法的过程就是思考的过程，涉及到了类的创建、抽象、组合；方法的职责，事先没有思考清楚，是写不出来的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;快速出一版空方法后，再进行沟通和讨论，找出其中有遗漏和有问题的点，进行修改，最终的版本在大方向上基本是没什么问题的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 Code Review ，我自己也还在不断地探索和实践，找到适合团队的方法，执行下去，然后再持续进行改进和完善。&lt;/p&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU0NjgzNzQyMw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/eqcwh4cqlibGAxU49ibZaYia66bfKLgaibRJoJ3GmKtKlZGmVc4zibsYv9OMwm5zOZSqEteuglxHZE9oJ1XUmMQsHRg/0?wx_fmt=png&quot; data-nickname=&quot;不止dotNET&quot; data-alias=&quot;moredotnet&quot; data-signature=&quot;持续关注dotNET，同时对软件架构、微服务、docker、分布式、团队管理有浓厚兴趣。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e7716c4e4c95addb6dbe9594cfa486cb</guid>
<title>鸿蒙系统研究第一步：从源码构建系统镜像</title>
<link>https://toutiao.io/k/mobj8bo</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;周末下载了 OpenHarmony OS 2.0 的源码，并 build 成功。虽然大部分的步骤都是来自官方文档，但还是碰到了一些问题，所以决定还是写下来，当作一个备忘录。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我平常使用的开发环境是 Ubuntu Linux 系统，但这次切换到了 Windows 系统，原因是鸿蒙的开发工具 DevEcoStudio 和烧写工具 HiTool 只有 Windows 版本和 Mac 版本。好在 Windows 10 对 Linux 的支持非常好，其中 WSL (Windows Subsystem for Linux) 可以像 Windows 应用程序那样安装与运行，比使用虚拟机高效。WSL 已经进化到第二代，简称为 WSL2。关于 WSL2 的安装与配置，请参考相关文档。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我从 Microsoft Store 安装的 Linux 发行版本为 Ubuntu 18.04 LTS 版本。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5416666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibQ4mtgHYXv5LolY9aBs4MUak2C4crWvT8j0tNFuX6o0NicWriaibZbgwsEiahgFGmGD1PkSibbictUJC9zwicMY297f3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是，WSL2 Linux 的系统镜像文件默认放置在 C 盘，如果 C 盘空间预留不是很足够的话，建议移动到其它空间比较足的盘上。具体方法如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先找到 WSL2 Linux 的系统镜像文件位置，默认为 &lt;em&gt;C:\Users&amp;lt;用户&amp;gt;\AppData\Local\Packages\CanonicalGroupLimited.Ubuntu18.04onWindows_79rhkp1fndgsc\LocalState&lt;/em&gt; ，将其中的 &lt;strong&gt;&amp;lt;用户&amp;gt;&lt;/strong&gt; 替换为你的用户名。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将 &lt;em&gt;C:\Users&amp;lt;用户&amp;gt;\AppData\Local\Packages\CanonicalGroupLimited.Ubuntu18.04onWindows_79rhkp1fndgsc\LocalState&lt;/em&gt; 移动到其它盘，比如 &lt;em&gt;D:\VirtualMachines\WSL2\Ubuntu18.04\LocalState&lt;/em&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;建立符号链接（类似 Linux 下的软链接）。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;mklink /j C:\Users\chenz\AppData\Local\Packages\CanonicalGroupLimited.Ubuntu18.04onWindows_79rhkp1fndgsc\LocalState D:\VirtualMachines\WSL2\Ubuntu18.04\LocalState&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;做好上述准备后，就不会担心 C 盘被撑爆了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;言归正传，下面就说说在 Ubuntu 18.04 LTS 下如何下载和编译 OpenHarmony OS 2.0 的源码。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;安装依赖工具&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安装命令如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;sudo apt-get update&lt;br/&gt;sudo apt-get install binutils git-core git-lfs gnupg flex bison gperf build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev ccache libgl1-mesa-dev libxml2-utils xsltproc unzip m4 python2.7 python-minimal&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;获取标准系统源码&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官方文档给了三种获取系统源码的方式，如果是研究鸿蒙系统，最好直接从软件仓库下载，这样有比较完善的提交信息。所以这里只介绍如何从软件仓库克隆系统源码。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;配置 git 用户信息&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;git config --global user.name &lt;span&gt;&quot;yourname&quot;&lt;/span&gt;&lt;br/&gt;git config --global user.email &lt;span&gt;&quot;your-email-address&quot;&lt;/span&gt;&lt;br/&gt;git config --global credential.helper store&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;安装 repo 工具，可以执行如下命令。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ curl https://gitee.com/oschina/repo/raw/fork_flow/repo-py3 &amp;gt; repo&lt;br/&gt;$ chmod a+x repo&lt;br/&gt;$ sudo mv repo /usr/&lt;span&gt;local&lt;/span&gt;/bin/repo&lt;br/&gt;$ sudo apt install python3-pip&lt;br/&gt;$ pip3 install -i https://repo.huaweicloud.com/repository/pypi/simple requests&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;获取标准系统源码&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ mkdir OpenHarmony&lt;br/&gt;$ &lt;span&gt;cd&lt;/span&gt; OpenHarmony&lt;br/&gt;&lt;br/&gt;$ repo init -u https://gitee.com/openharmony/manifest.git -b master --no-repo-verify&lt;br/&gt;&lt;br/&gt;$ repo sync -c&lt;br/&gt;&lt;br/&gt;$ repo forall -c &lt;span&gt;&#x27;git lfs pull&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：&lt;strong&gt;repo sync&lt;/strong&gt; 命令后面的 &lt;strong&gt;-c&lt;/strong&gt; 参数表示只获取当前分支的源码，也就是说并不是所有分支的代码。我尝试不加这个 &lt;strong&gt;-c&lt;/strong&gt; 参数，可能是 gitee 的配置问题，超过 1G 的软件仓库，比如 linux kernel 就出现如下错误，网上搜索了很多方法也未能解决。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;error: RPC failed; curl 56 GnuTLS recv error (-110): The TLS connection was non-properly terminated.&lt;br/&gt;fatal: The remote end hung up unexpectedly&lt;br/&gt;fatal: early EOF&lt;br/&gt;fatal: index-pack failed&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;获取预编译工具&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ curl https://gitee.com/landwind/script-tools/raw/master/Shell/OpenHarmony/OpenHarmony_2.0_canary_prebuilts_download.sh &amp;gt;./prebuilts_download.sh&lt;br/&gt;$ bash ./prebuilts_download.sh&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;配置NodeJS环境和获取Node_modules依赖包&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;下载Nodejs。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ mkdir -p prebuilts/build-tools/common/nodejs&lt;br/&gt;$ &lt;span&gt;cd&lt;/span&gt; prebuilts/build-tools/common/nodejs&lt;br/&gt;$ wget --no-check-certificate https://nodejs.org/download/release/v12.18.4/node-v12.18.4-linux-x64.tar.gz&lt;br/&gt;$ tar -zxvf node-v12.18.4-linux-x64.tar.gz&lt;br/&gt;$ &lt;span&gt;cd&lt;/span&gt; -&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;下载node_modules包。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ &lt;span&gt;cd&lt;/span&gt; third_party/jsframework&lt;br/&gt;$ &lt;span&gt;export&lt;/span&gt; PATH=../../prebuilts/build-tools/common/nodejs/node-v12.18.4-linux-x64/bin:&lt;span&gt;${PATH}&lt;/span&gt;&lt;br/&gt;$ npm install&lt;br/&gt;$ &lt;span&gt;cd&lt;/span&gt; -&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;把下载的node_modules包放入OpenHarmony代码的prebuilts/build-tools/common/js-framework目录下。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ mkdir -p prebuilts/build-tools/common/js-framework&lt;br/&gt;$ cp -rp third_party/jsframework/node_modules prebuilts/build-tools/common/js-framework/&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;安装hc-gen工具&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;hc-gen用于进行驱动编译，具体安装步骤如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;下载 hc-gen 工具。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;$ wget https://repo.huaweicloud.com/harmonyos/compiler/hc-gen/0.65/linux/hc-gen-0.65-linux.tar&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;解压 hc-gen 安装包到 ~/hc-gen 路径下。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;tar -xvf hc-gen-0.65-linux.tar -C ~/&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;设置环境变量。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;vim ~/.bashrc&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将以下命令拷贝到.bashrc文件的最后一行，保存并退出。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; PATH=~/hc-gen:&lt;span&gt;$PATH&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;生效环境变量。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;source&lt;/span&gt; ~/.bashrc&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;编译系统&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行脚本 build.sh 即可，后面必须加上 &lt;strong&gt;--product-name Hi3516DV300&lt;/strong&gt; 参数，目前只支持这一种产品形态的构建。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ ./build.sh --product-name Hi3516DV300 --ccache&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;构建成功以后，输出如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5416666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibQ4mtgHYXv5LolY9aBs4MUak2C4crWvTgmLia0tg0Kx94g5r4PSMnn9Vuq9CyzC8MI1aibj6rTSYDicA2asINTv6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;手头还没有 Hi3516DV300 的板子，所以无法烧写体验鸿蒙系统。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非常意外的是，OpenHarmony OS 2.0 没有提供模拟器的 build 选择，这对开发者相当不友好。后面我会研究一下 QEMU 模拟器，看能否在 QEMU 上把 OpenHarmony OS 2.0 运行起来，敬请关注。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibQ4mtgHYXv50C2zJtfH5icNbOicm63Mwia4EaZdIJtQDz9rJLxS6LBsVgWJXtbJIFBaAH2nzu7tBEic76fFUEphPjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>