<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>1d747fd1c9546c0ec9c26923840fb06b</guid>
<title>JVM 源码分析之一个 Java 进程究竟能创建多少线程</title>
<link>https://toutiao.io/k/bshy7j1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;src-views-article-detail-main-module__content--2qOBd markdown-body&quot;&gt;&lt;h1&gt;概述&lt;/h1&gt;
&lt;p&gt;虽然这篇文章的标题打着JVM源码分析的旗号，不过本文不仅仅从 JVM 源码角度来分析，更多的来自于 Linux Kernel 的源码分析，今天要说的是 JVM 里比较常见的一个问题。&lt;/p&gt;
&lt;p&gt;这个问题可能有几种表述&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个Java进程到底能创建多少线程？&lt;/li&gt;
&lt;li&gt;到底有哪些因素决定了能创建多少线程？&lt;/li&gt;
&lt;li&gt;&lt;code&gt;java.lang.OutOfMemoryError: unable to create new native thread&lt;/code&gt;的异常究竟是怎么回事&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不过我这里先声明下可能不能完全百分百将各种因素都理出来，因为毕竟我不是做 Linux Kernel 开发的，还有不少细节没有注意到的，我将我能分析到的因素和大家分享一下，如果大家在平时工作中还碰到别的因素，欢迎在文章下面留言，让更多人参与进来讨论&lt;/p&gt;
&lt;h1&gt;从 JVM 说起&lt;/h1&gt;
&lt;p&gt;线程大家都熟悉，&lt;code&gt;new Thread().start()&lt;/code&gt;即会创建一个线程，这里我首先指出一点&lt;code&gt;new Thread()&lt;/code&gt;其实并不会创建一个真正的线程，只有在调用了 start 方法之后才会创建一个线程，这个大家分析下 Java 代码就知道了，Thread 的构造函数是纯 Java 代码，start 方法会调到一个 native 方法 start0 里，而 start0 其实就是&lt;code&gt;JVM_StartThread&lt;/code&gt;这个方法。&lt;br/&gt;
&lt;img src=&quot;https://a.perfma.net/img/243773&quot; alt=&quot;1.jpg&quot;/&gt;&lt;br/&gt;
从上面代码里首先要大家关注下最后的那个 if 判断 &lt;code&gt;if (native_thread-&amp;gt;osthread() == NULL)&lt;/code&gt;，如果 osthread 为空，那将会抛出大家比较熟悉的 &lt;code&gt;unable to create new native thread OOM &lt;/code&gt;异常，因此 osthread 为空非常关键，后面会看到什么情况下osthread会为空。&lt;/p&gt;
&lt;p&gt;另外大家应该注意到了&lt;code&gt;native_thread = new JavaThread(&amp;amp;thread_entry, sz)&lt;/code&gt;，在这里才会真正创建一个线程。&lt;br/&gt;
&lt;img src=&quot;https://a.perfma.net/img/243801&quot; alt=&quot;2.jpg&quot;/&gt;&lt;br/&gt;
上面代码里的&lt;code&gt;os::create_thread(this, thr_type, stack_sz)&lt;/code&gt;会通过&lt;code&gt;pthread_create&lt;/code&gt;来创建线程，而 Linux 下对应的实现如下：&lt;br/&gt;
&lt;img src=&quot;https://a.perfma.net/img/243804&quot; alt=&quot;3.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/243811&quot; alt=&quot;4.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/243842&quot; alt=&quot;5.jpg&quot;/&gt;&lt;br/&gt;
如果在 &lt;code&gt;new OSThread &lt;/code&gt;的过程中就失败了，那显然 osthread 为 NULL，那再回到上面第一段代码，此时会抛出&lt;code&gt;java.lang.OutOfMemoryError: unable to create new native thread&lt;/code&gt;的异常，而什么情况下&lt;code&gt;new OSThread&lt;/code&gt;会失败，比如说内存不够了，而这里的内存其实是 C Heap，而非 Java Heap，由此可见从 JVM 的角度来说，影响线程创建的因素包括了 Xmx，MaxPermSize，MaxDirectMemorySize，ReservedCodeCacheSize 等，因为这些参数会影响剩余的内存&lt;/p&gt;
&lt;p&gt;另外注意到如果&lt;code&gt;pthread_create&lt;/code&gt;执行失败，那通过&lt;code&gt;thread-&amp;gt;set_osthread(NULL)&lt;/code&gt;会设置空值，这个时候 osthread 也为 NULL，因此也会抛出上面的 OOM 异常，导致创建线程失败，因此接下来要分析下 pthread_create 失败的因素。&lt;/p&gt;
&lt;h1&gt;glibc 中的 pthread_create&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;stack_size&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;pthread_create 的实现在 glibc 里，&lt;br/&gt;
&lt;img src=&quot;https://a.perfma.net/img/243849&quot; alt=&quot;6.jpg&quot;/&gt;&lt;br/&gt;
上面我主要想说的一段代码是&lt;code&gt;int err = ALLOCATE_STACK (iattr, &amp;amp;pd)&lt;/code&gt;，顾名思义就是分配线程栈，简单来说就是根据 iattr 里指定的 stackSize，通过 mmap 分配一块内存出来给线程作为栈使。&lt;/p&gt;
&lt;p&gt;那我们来说说 stackSize，这个大家应该都明白，线程要执行，要有一些栈空间，试想一下，如果分配栈的时候内存不够了，是不是创建肯定失败？而 stackSize 在 JVM 下是可以通过 -Xss 指定的，当然如果没有指定也有默认的值，下面是 JDK6 之后(含)默认值的情况。&lt;/p&gt;
&lt;h1&gt;Linux Kernel 里的 clone&lt;/h1&gt;
&lt;p&gt;如果栈分配成功，那接下来就要创建线程了，大概逻辑如下&lt;br/&gt;
&lt;img src=&quot;https://a.perfma.net/img/243864&quot; alt=&quot;7.jpg&quot;/&gt;&lt;br/&gt;
而create_thread其实是调用的系统调用clone&lt;br/&gt;
&lt;img src=&quot;https://a.perfma.net/img/243887&quot; alt=&quot;8.jpg&quot;/&gt;&lt;br/&gt;
系统调用这块就切入到了 Linux Kernel 里&lt;/p&gt;
&lt;p&gt;clone 系统调用最终会调用&lt;code&gt;do_fork&lt;/code&gt;方法，接下来通过剖解这个方法来分析 Kernel 里还存在哪些因素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;max_user_processes&lt;/strong&gt;&lt;br/&gt;
&lt;img src=&quot;https://a.perfma.net/img/243898&quot; alt=&quot;9.jpg&quot;/&gt;&lt;br/&gt;
先看这么一段，这里其实就是判断用户的进程数有多少，大家知道在linux下，进程和线程其数据结构都是一样的，因此这里说的进程数可以理解为轻量级线程数，而这个最大值是可以通过&lt;code&gt;ulimit -u&lt;/code&gt;可以查到的，所以如果当前用户起的线程数超过了这个限制，那肯定是不会创建线程成功的，可以通过&lt;code&gt;ulimit -u value&lt;/code&gt;来修改这个值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;max_map_count&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在这个过程中不乏有 mallo c的操作，底层是通过系统调用 brk 来实现的，或者上面提到的栈是通过 mmap 来分配的，不管是 malloc 还是 mmap，在底层都会有类似的判断。&lt;br/&gt;
&lt;img src=&quot;https://a.perfma.net/img/243916&quot; alt=&quot;10.jpg&quot;/&gt;&lt;br/&gt;
如果进程被分配的内存段超过&lt;code&gt;sysctl_max_map_count&lt;/code&gt;就会失败，而这个值在 linux 下对应&lt;code&gt;/proc/sys/vm/max_map_count&lt;/code&gt;，默认值是 65530，可以通过修改上面的文件来改变这个阈值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;max_threads&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;还存在&lt;code&gt;max_threads&lt;/code&gt;的限制，代码如下：&lt;br/&gt;
&lt;img src=&quot;https://a.perfma.net/img/243944&quot; alt=&quot;11.jpg&quot;/&gt;&lt;br/&gt;
如果要修改或者查看可以通过&lt;code&gt;/proc/sys/kernel/threads-max&lt;/code&gt;来操作， 这个值是受到物理内存的限制，在&lt;code&gt;fork_init&lt;/code&gt;的时候就计算好了。&lt;br/&gt;
&lt;img src=&quot;https://a.perfma.net/img/243967&quot; alt=&quot;12.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;pid_max&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;pid 也存在限制&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/243986&quot; alt=&quot;13.jpg&quot;/&gt;&lt;br/&gt;
而&lt;code&gt;alloc_pid&lt;/code&gt;的定义如下&lt;br/&gt;
&lt;img src=&quot;https://a.perfma.net/img/244014&quot; alt=&quot;14.jpg&quot;/&gt;&lt;br/&gt;
在&lt;code&gt;alloc_pidmap&lt;/code&gt;中会判断&lt;code&gt;pid_max&lt;/code&gt;,而这个值的定义如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/244036&quot; alt=&quot;15.jpg&quot;/&gt;&lt;br/&gt;
这个值可以通过 &lt;code&gt;/proc/sys/kernel/pid_max&lt;/code&gt; 来查看或者修改&lt;/p&gt;
&lt;h1&gt;总结&lt;/h1&gt;
&lt;p&gt;通过对 JVM，glibc，Linux kernel 的源码分析，我们暂时得出了一些影响线程创建的因素，包括&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JVM：Xmx，Xss，MaxPermSize，MaxDirectMemorySize，ReservedCodeCacheSize 等&lt;/li&gt;
&lt;li&gt;Kernel：max_user_processes，max_map_count，max_threads，pid_max 等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于对 kernel 的源码研读时间有限，不一定总结完整，大家可以补充。&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>73917c38e91915d25a8474cc1de38754</guid>
<title>[推荐] Spring Boot 在 K8s 下实现优雅停机</title>
<link>https://toutiao.io/k/6tcdyp9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6671875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FBPFm28kpSwRuCcX7myzfYhVevLQPOdFPR0NOQuAHoLCm46CvYb25ic3ibzupbbl7ib6YMqqjyXVTm4YzXWAY4bpg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在K8s中，当我们实现滚动升级之前，务必要实现应用级别的优雅停机。否则滚动升级时，还是会影响到业务。本文介绍SpringBoot应用实现优雅停机。此次教程基于SpringBoot 2.5.0。&lt;/p&gt;&lt;h3&gt;1. 加入必要依赖&lt;/h3&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-actuator&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3&gt;2. 配置SpringBoot应用&lt;/h3&gt;&lt;p&gt;默认情况下，SpringBoot是直接关机的，所以，需要将优雅停机配置打开。在applicatoin.yaml中配置：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;yaml&quot;&gt;&lt;code&gt;&lt;span&gt;spring:&lt;/span&gt;&lt;br/&gt;  application:&lt;br/&gt;    &lt;span&gt;name&lt;/span&gt;: demo&lt;br/&gt;  &lt;span&gt;# 停机过程超时时长设置了20s，超过20s，直接停机&lt;/span&gt;&lt;br/&gt;  lifecycle:&lt;br/&gt;    &lt;span&gt;timeout-per-shutdown-phase&lt;/span&gt;: 20s&lt;br/&gt;&lt;br/&gt;&lt;span&gt;server:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;port&lt;/span&gt;: 8080&lt;br/&gt;  &lt;span&gt;#  默认为IMMEDIATE，表示立即关机；GRACEFUL表示优雅关机&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;shutdown&lt;/span&gt;: graceful&lt;br/&gt;&lt;br/&gt;&lt;span&gt;management:&lt;/span&gt;&lt;br/&gt;  server:&lt;br/&gt;    &lt;span&gt;address&lt;/span&gt;: 127&lt;span&gt;.0&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;port&lt;/span&gt;: 50000&lt;br/&gt;  &lt;span&gt;# 开启shutdown endpoint&lt;/span&gt;&lt;br/&gt;  endpoint:&lt;br/&gt;    &lt;span&gt;shutdown&lt;/span&gt;:&lt;br/&gt;      enabled: &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;  endpoints:&lt;br/&gt;    web:&lt;br/&gt;      &lt;span&gt;base&lt;/span&gt;-path: /&lt;span&gt;private&lt;/span&gt;-url&lt;br/&gt;      exposure:&lt;br/&gt;        &lt;span&gt;# 暴露shutdown endpoint&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;include&lt;/span&gt;: health,shutdown&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;这时我们只需要在发送停机请求告诉应用，即可优雅停机。发送指令为：&lt;code&gt;curl -XPOST 127.0.0.1:50000/private-url/shutdown&lt;/code&gt;。&lt;/p&gt;&lt;h3&gt;3. 集成到Pod中&lt;/h3&gt;&lt;p&gt;生产环境中当然不会直接使用Pod部署应用，而是使用Deployment部署应用。以下只是样例：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;yaml&quot;&gt;&lt;code&gt;&lt;span&gt;apiVersion&lt;/span&gt;: v1 &lt;br/&gt;&lt;span&gt;kind&lt;/span&gt;: Pod &lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name&lt;/span&gt;: demopod&lt;br/&gt;&lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;  containers:&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;image&lt;/span&gt;: &lt;span&gt;springboot-demo&lt;/span&gt;&lt;span&gt;:v1.10&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;name&lt;/span&gt;: demo-container&lt;br/&gt;    ports:&lt;br/&gt;    - containerPort: 8080&lt;br/&gt;    lifecycle:&lt;br/&gt;      preStop:&lt;br/&gt;        &lt;span&gt;exec&lt;/span&gt;:&lt;br/&gt;          &lt;span&gt;command&lt;/span&gt;: [&lt;span&gt;&quot;curl&quot;&lt;/span&gt;, &lt;span&gt;&quot;-XPOST&quot;&lt;/span&gt;, &lt;span&gt;&quot;127.0.0.1:50000/private-url/shutdown&quot;&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;注意：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;前提是你的应用镜像中必须包含&lt;code&gt;curl&lt;/code&gt;命令。&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;50000是应用管理端口，不能暴露给公网。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;4. 实验效果&lt;/h3&gt;&lt;p&gt;在命令行里执行：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;bash&quot;&gt;&lt;code&gt;% curl -X POST &lt;span&gt;127.0&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;:&lt;span&gt;50000&lt;/span&gt;/&lt;span&gt;private&lt;/span&gt;-url/shutdown&lt;br/&gt;{&lt;span&gt;&quot;message&quot;&lt;/span&gt;:&lt;span&gt;&quot;Shutting down, bye...&quot;&lt;/span&gt;}%&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;应用日志：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;bash&quot;&gt;&lt;code&gt;... &lt;span&gt;o&lt;/span&gt;&lt;span&gt;.s&lt;/span&gt;&lt;span&gt;.b&lt;/span&gt;&lt;span&gt;.w&lt;/span&gt;&lt;span&gt;.e&lt;/span&gt;&lt;span&gt;.tomcat&lt;/span&gt;&lt;span&gt;.GracefulShutdown&lt;/span&gt;  : &lt;span&gt;Commencing&lt;/span&gt; &lt;span&gt;graceful&lt;/span&gt; &lt;span&gt;shutdown&lt;/span&gt;. &lt;span&gt;Waiting&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; &lt;span&gt;active&lt;/span&gt; &lt;span&gt;requests&lt;/span&gt; &lt;span&gt;to&lt;/span&gt; &lt;span&gt;complete&lt;/span&gt;&lt;br/&gt;... &lt;span&gt;o&lt;/span&gt;&lt;span&gt;.s&lt;/span&gt;&lt;span&gt;.b&lt;/span&gt;&lt;span&gt;.w&lt;/span&gt;&lt;span&gt;.e&lt;/span&gt;&lt;span&gt;.tomcat&lt;/span&gt;&lt;span&gt;.GracefulShutdown&lt;/span&gt;  : &lt;span&gt;Gracefsul&lt;/span&gt; &lt;span&gt;shutdown&lt;/span&gt; &lt;span&gt;complete&lt;/span&gt;&lt;br/&gt;... &lt;span&gt;o&lt;/span&gt;&lt;span&gt;.s&lt;/span&gt;&lt;span&gt;.b&lt;/span&gt;&lt;span&gt;.w&lt;/span&gt;&lt;span&gt;.e&lt;/span&gt;&lt;span&gt;.tomcat&lt;/span&gt;&lt;span&gt;.GracefulShutdown&lt;/span&gt;  : &lt;span&gt;Commencing&lt;/span&gt; &lt;span&gt;graceful&lt;/span&gt; &lt;span&gt;shutdown&lt;/span&gt;. &lt;span&gt;Waiting&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; &lt;span&gt;active&lt;/span&gt; &lt;span&gt;requests&lt;/span&gt; &lt;span&gt;to&lt;/span&gt; &lt;span&gt;complete&lt;/span&gt;&lt;br/&gt;... &lt;span&gt;o&lt;/span&gt;&lt;span&gt;.s&lt;/span&gt;&lt;span&gt;.b&lt;/span&gt;&lt;span&gt;.w&lt;/span&gt;&lt;span&gt;.e&lt;/span&gt;&lt;span&gt;.tomcat&lt;/span&gt;&lt;span&gt;.GracefulShutdown&lt;/span&gt;  : &lt;span&gt;Graceful&lt;/span&gt; &lt;span&gt;shutdown&lt;/span&gt; &lt;span&gt;complete&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;最后，关注本公众号，后台发消息：springboot优雅停机，即可拿到源码。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;首图来自：https://pixabay.com/photos/woman-model-flowers-chrysanthemums-6059236/&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8611c28ec86f3e7d7744721ceee9617c</guid>
<title>[推荐] Redis 存储对象信息是用 Hash 还是 String</title>
<link>https://toutiao.io/k/2rcud9q</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot;&gt;&lt;p&gt;Redis 内部使用一个 RedisObject 对象来表示所有的 key 和 value，RedisObject 中的 type，则是代表一个 value 对象具体是何种数据类型，它包含字符串（String）、链表（List）、哈希结构（Hash）、集合（Set）、有序集合（Sorted set）。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b188fc9df3bb28ffbbc456f00ee63233_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1240&quot; data-rawheight=&quot;671&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-b188fc9df3bb28ffbbc456f00ee63233_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1240&quot; data-rawheight=&quot;671&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-b188fc9df3bb28ffbbc456f00ee63233_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-b188fc9df3bb28ffbbc456f00ee63233_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;日常工作中我们存储对象信息的时候，一般有两种做法，一种是用 Hash 存储，另一种是 String 存储。但好像并没有所谓的最佳实践，那么实际上到底用什么数据结构存储更好呢？&lt;/p&gt;&lt;p&gt;首先简单回顾下，Redis 的 Hash 和 String 结构。&lt;/p&gt;&lt;h2&gt;String&lt;/h2&gt;&lt;p&gt;String 数据结构是简单的 key-value 类型，value 其实不仅是 String，也可以是数字。Redis 中的 String 可以表示很多语义：&lt;/p&gt;&lt;p&gt;这三种类型，Redis 会根据具体的场景完成自动转换，并且根据需要选取底层的承载方式。String 在Redis 内部存储默认就是一个字符串，被 RedisObject 所引用，当遇到 incr、decr 等操作时会转成数值型进行计算，此时 RedisObject 的 encoding 字段为int。&lt;/p&gt;&lt;p&gt;在存储过程中，我们可以将用户信息使用 Json 序列化成字符串，然后将序列化后的字符串存入 Redis 进行缓存。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-27f8be534bfc97f96460328e94a72c8e_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;964&quot; data-rawheight=&quot;402&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-27f8be534bfc97f96460328e94a72c8e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;964&quot; data-rawheight=&quot;402&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-27f8be534bfc97f96460328e94a72c8e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-27f8be534bfc97f96460328e94a72c8e_b.jpg&quot;/&gt;&lt;figcaption&gt;String 数据结构&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;由于 Redis 的字符串是动态字符串，可以修改，内部结构类似于 Java 的 ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配。如上图所示，内部为当前字符串实际分配的空间 capacity，一般高于实际字符串长度 len。&lt;/p&gt;&lt;p&gt;假设我们要存储的结构是：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;1 {
2   &quot;name&quot;: &quot;xiaowang&quot;,
3   &quot;age&quot;: &quot;35&quot;
4 }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果此时将此用户信息的 name 改为“xiaoli”，再存到 Redis 中，Redis 是不需要重新分配空间的。而且我们在读取和存储数据的时候只需要对做 Json 序列化与反序列化，比较方便。&lt;/p&gt;&lt;h2&gt;Hash&lt;/h2&gt;&lt;p&gt;Hash 在很多编程语言中都有着很广泛的应用，而在 Redis 中也是如此。在 Redis 中，Hash 常常用来缓存一些对象信息，如用户信息、商品信息、配置信息等，因此也被称为字典（dictionary），Redis 的字典使用 Hash table 作为底层实现， 一个 Hash table 里面可以有多个哈希表节点，而每个哈希表节点保存了字典中的一个键值对。实际上，Redis 数据库底层也是采用 Hash table 来存储键值对的。&lt;/p&gt;&lt;p&gt;Redis 的 Hash 相当于 Java 的 HashMap，内部结构实现与 HashMap 一致，即数组+链表结构。只是 reHash 方式不一样。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b4bc1aa71667b1b437671aad442daf0d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;370&quot; data-rawheight=&quot;244&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;370&quot; data-rawheight=&quot;244&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-b4bc1aa71667b1b437671aad442daf0d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;前面说到 String 适合存储用户信息，而 Hash 结构也可以存储用户信息，不过是对每个字段单独存储，因此可以在查询时获取部分字段的信息，节省网络流量。不过 Redis 的 Hash 的值只能是字符串，存储上面的那个例子还好，如果存储的用户信息变为：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;1 {
2   &quot;name&quot;: &quot;xiaowang&quot;,
3   &quot;age&quot;: 25,
4   &quot;clothes&quot;: {
5     &quot;shirt&quot;: &quot;gray&quot;,
6     &quot;pants&quot;: &quot;read&quot;
7   }
8 }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;那么该如何存储&quot;clothes&quot;属性又变成了该用 String 还是 Hash 的问题。&lt;/p&gt;&lt;h2&gt;String 和 Hash 占用内存的比较&lt;/h2&gt;&lt;p&gt;既然两种数据结构都可以存储结构体信息。到底哪种更加合适呢？&lt;/p&gt;&lt;p&gt;首先我们用代码先插入 10000 条数据，然后用可视化工具来看看内存的占用情况。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;1  const Redis = require(&quot;ioRedis&quot;);
2  const Redis0 = new Redis({port: 6370});
3  const Redis1 = new Redis({port: 6371});
4
5
6  const user = {
7   name: &#x27;name12345&#x27;,
8   age: 16,
9   avatar: &#x27;https://dss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=256767015,24101428&amp;amp;fm=26&amp;amp;gp=0.jpg&#x27;,
10  phone: &#x27;13111111111&#x27;,
11  email: &#x27;1111111@11.email&#x27;,
12  lastLogon: &#x27;2021-04-28 10:00:00&#x27;,
13 }
14
15
16 async function main() {
17  for (let i = 0; i &amp;lt; 10000; i++) {
18     await Redis0.set(`String:user:${i}`, Json.Stringify(user));
19     await Redis1.hmset(`Hash:user:${i}`, user);
20   }
21 }
22
23 main().then(process.exit);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;先看 Redis0：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-bb939848be9abcf4bd68095d4940f139_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;630&quot; data-rawheight=&quot;534&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-bb939848be9abcf4bd68095d4940f139_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;630&quot; data-rawheight=&quot;534&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-bb939848be9abcf4bd68095d4940f139_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-bb939848be9abcf4bd68095d4940f139_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;再来看看 Redis1：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-32e8929036b707955e9337668c57eaf3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;652&quot; data-rawheight=&quot;554&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-32e8929036b707955e9337668c57eaf3_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;652&quot; data-rawheight=&quot;554&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-32e8929036b707955e9337668c57eaf3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-32e8929036b707955e9337668c57eaf3_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;可以看到还是有点差距的，但是差距并不明显。&lt;/p&gt;&lt;h2&gt;网友讨论&lt;/h2&gt;&lt;p&gt;网上的用户也有同样的疑问， 因为值的长度是不确定的，所以不知道采用 String 还是 Hash 存储更有效率。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2ec5a5fc745eecba2893edb5a6572f9d_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;765&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-2ec5a5fc745eecba2893edb5a6572f9d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;765&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-2ec5a5fc745eecba2893edb5a6572f9d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-2ec5a5fc745eecba2893edb5a6572f9d_b.jpg&quot;/&gt;&lt;figcaption&gt;△ 截图来源于 StackOverflow（Redis Strings vs Redis Hashes to represent Json: efficiency?）&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;这里我主要给大家翻译下该问题下优质的答案：&lt;/p&gt;&lt;p&gt;&lt;b&gt;适合用 String 存储的情况：&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;每次需要访问大量的字段&lt;/li&gt;&lt;li&gt;存储的结构具有多层嵌套的时候&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;适合用 Hash 存储的情况：&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;在大多数情况中只需要访问少量字段&lt;/li&gt;&lt;li&gt;自己始终知道哪些字段可用，防止使用 mget 时获取不到想要的数据&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;本文主要介绍了Redis 存储对象信息是用 Hash 还是 String，我的建议是大部分情况下使用 String 存储就好，毕竟在存储具有多层嵌套的对象时方便很多，占用的空间也比 Hash 小。当我们需要存储一个特别大的对象时，而且在大多数情况中只需要访问该对象少量的字段时，可以考虑使用 Hash。&lt;/p&gt;&lt;p&gt;&lt;b&gt;推荐阅读：&lt;/b&gt;&lt;/p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.upyun.com/tech/article/563/%25E4%25B8%2589%25E5%2588%2586%25E9%2592%259F%25E4%25BA%2586%25E8%25A7%25A3%2520Python3%2520%25E7%259A%2584%25E5%25BC%2582%25E6%25AD%25A5%2520Web%2520%25E6%25A1%2586%25E6%259E%25B6%2520FastAPI.html&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic4.zhimg.com/v2-32db835da87060ffdd805ef17d07aec3_180x120.jpg&quot; data-image-width=&quot;957&quot; data-image-height=&quot;620&quot; class=&quot;LinkCard old LinkCard--hasImage&quot;&gt;&lt;span class=&quot;LinkCard-backdrop&quot;/&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;三分钟了解 Python3 的异步 Web 框架 FastAPI&lt;/span&gt;&lt;span class=&quot;LinkCard-meta&quot;&gt;&lt;span&gt;​&lt;svg class=&quot;Zi Zi--InsertLink&quot; fill=&quot;currentColor&quot; viewbox=&quot;0 0 24 24&quot;&gt;&lt;path d=&quot;M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;www.upyun.com&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-imageCell&quot;&gt;&lt;img class=&quot;LinkCard-image LinkCard-image--horizontal&quot; alt=&quot;图标&quot; src=&quot;https://pic4.zhimg.com/v2-32db835da87060ffdd805ef17d07aec3_180x120.jpg&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.upyun.com/tech/article/558/QUIC%252FHTTP3%2520%25E5%258D%258F%25E8%25AE%25AE%25E7%25AE%2580%25E6%259E%2590.html&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic1.zhimg.com/v2-7a88939758f822892186586001fb0d2c_180x120.jpg&quot; data-image-width=&quot;1080&quot; data-image-height=&quot;608&quot; class=&quot;LinkCard old LinkCard--hasImage&quot;&gt;&lt;span class=&quot;LinkCard-backdrop&quot;/&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;QUIC/HTTP3 协议简析&lt;/span&gt;&lt;span class=&quot;LinkCard-meta&quot;&gt;&lt;span&gt;​&lt;svg class=&quot;Zi Zi--InsertLink&quot; fill=&quot;currentColor&quot; viewbox=&quot;0 0 24 24&quot;&gt;&lt;path d=&quot;M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;www.upyun.com&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-imageCell&quot;&gt;&lt;img class=&quot;LinkCard-image LinkCard-image--horizontal&quot; alt=&quot;图标&quot; src=&quot;https://pic1.zhimg.com/v2-7a88939758f822892186586001fb0d2c_180x120.jpg&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ad2b662782ab67a64aab21899528b7cb</guid>
<title>[推荐] 微服务拆分之道</title>
<link>https://toutiao.io/k/mr1knwm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d46ce76e16e0d9530dbed664b3bfc079</guid>
<title>[推荐] 一文理解 Java 中的 SPI 机制</title>
<link>https://toutiao.io/k/3xscqep</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h2 data-source-line=&quot;1&quot;&gt;SPI机制简介&lt;/h2&gt;&lt;p data-source-line=&quot;2&quot;&gt;服务提供者接口（Service Provider Interface，简写为SPI）是JDK内置的一种服务提供发现机制。可以用来加载框架扩展和替换组件，主要是被框架的开发人员使用。在java.util.ServiceLoader的文档里有比较详细的介绍。&lt;/p&gt;&lt;p data-source-line=&quot;4&quot;&gt;系统里抽象的各个模块，往往有很多不同的实现方案，比如日志模块的方案、xml解析模块、jdbc模块的方案等。面向对象的设计推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则：如果需要替换组建的一种实现，就需要修改框架的代码。SPI机制正是解决这个问题。&lt;/p&gt;&lt;p data-source-line=&quot;6&quot;&gt;Java中SPI机制主要思想是将装配的控制权移到程序之外，是“基于接口的编程＋策略模式＋配置文件”组合实现的动态加载机制，有点类似Spring的IOC机制。在模块化设计中这个机制尤其重要，其核心思想就是解耦。&lt;/p&gt;&lt;p data-source-line=&quot;8&quot;&gt;&lt;img data-ratio=&quot;0.3325102880658436&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OqTAl3WTC7FCcQCUsqaSExkBFHia0CdTFYjzqMgxlkGkLulWnWyZc05RVNgGhXADDtUqEOHnYexXgBPtYm53oLg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1215&quot;/&gt;&lt;/p&gt;&lt;p data-source-line=&quot;10&quot;&gt;SPI的接口是Java核心库的一部分，是由引导类加载器(Bootstrap Classloader)来加载的。SPI的实现类是由系统类加载器(System ClassLoader)来加载的。&lt;/p&gt;&lt;p data-source-line=&quot;12&quot;&gt;引导类加载器在加载时是无法找到SPI的实现类的，因为双亲委派模型中规定，引导类加载器BootstrapClassloader无法委派系统类加载器AppClassLoader来加载。该如何解决此问题？&lt;/p&gt;&lt;p data-source-line=&quot;14&quot;&gt;线程上下文类加载由此诞生，它的出现也破坏了类加载器的双亲委派模型，使得程序可以进行逆向类加载。有关这部分知识在最后补充说明。&lt;/p&gt;&lt;h2 data-source-line=&quot;16&quot;&gt;应用场景&lt;/h2&gt;&lt;p data-source-line=&quot;18&quot;&gt;Java提供了很多SPI，允许第三方为这些接口提供实现。&lt;/p&gt;&lt;p data-source-line=&quot;20&quot;&gt;常见的SPI使用场景：&lt;/p&gt;&lt;ol data-source-line=&quot;21&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;JDBC加载不同类型的数据库驱动。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;日志门面接口实现类加载，SLF4J加载不同提供商的日志实现类。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Spring中大量使用了SPI。可以在spring.factories中加上我们自定义的自动配置类，事件监听器或初始化器等。&lt;br/&gt;3.1 对servlet3.0规范。&lt;br/&gt;3.2 对ServletContainerInitializer的实现。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Dubbo里面有很多个组件，每个组件在框架中都是以接口的形成抽象出来。具体的实现又分很多种，在程序执行时根据用户的配置来按需取接口的实现。如果Dubbo的某个内置实现不符合业务需求，那么只需要利用其SPI机制将新的业务实现替换掉Dubbo的实现即可。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-source-line=&quot;28&quot;&gt;这些SPI的接口是由Java核心库来提供，而SPI的实现则是作为Java应用所依赖的jar包被包含进类路径（CLASSPATH）中。例如：JDBC的实现mysql就是通过Maven被依赖进来。&lt;/p&gt;&lt;h2 data-source-line=&quot;30&quot;&gt;SPI具体约定&lt;/h2&gt;&lt;p data-source-line=&quot;32&quot;&gt;Java SPI的具体约定：当服务的提供者，提供了服务接口的某种实现之后，在jar包的META-INF/services/目录里同时创建一个以服务接口命名的文件。该文件里就是实现该服务接口的具体实现类。而当外部程序装配这个模块的时候，就能通过该jar包META-INF/services/里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入。基于这样一个约定就能实现服务接口与实现的解耦。&lt;/p&gt;&lt;h2 data-source-line=&quot;34&quot;&gt;Java SPI机制的缺点&lt;/h2&gt;&lt;ol data-source-line=&quot;36&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;不能按需加载，需要遍历所有的实现，并实例化，然后在循环中才能找到我们需要的实现。如果不想用某些实现类，或者某些类实例化很耗时，它也被载入并实例化了，这就造成了浪费。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;多个并发多线程使用ServiceLoader类的实例是不安全的。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;扩展如果依赖其他的扩展，做不到自动注入和装配。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;不提供类似于Spring的IOC和AOP功能。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;扩展很难和其他的框架集成，比如扩展里面依赖了一个Spring bean，原生的Java SPI不支持。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-source-line=&quot;42&quot;&gt;针对以上的不足点，在生产环境的SPI机制选择时，可以考虑使用dubbo实现的SPI机制。感兴趣的同学可以自行查看，或等博客的后续更新。&lt;/p&gt;&lt;h3 data-source-line=&quot;44&quot;&gt;SPI实例&lt;/h3&gt;&lt;p data-source-line=&quot;46&quot;&gt;下面用一个简单的代码实例，演示SPI的使用方法。&lt;/p&gt;&lt;ol data-source-line=&quot;48&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;代码编写&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-source-line=&quot;50&quot;&gt;定义需要的接口，然后编码接口的实现类。&lt;/p&gt;&lt;p data-source-line=&quot;52&quot;&gt;&lt;img data-ratio=&quot;0.4209714726291442&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OqTAl3WTC7FCcQCUsqaSExkBFHia0CdTFyTgqQkEkeJc8TfUg3qS4RPYLRQjvDunfvgkxpzoREvoaAM9rWPQeyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1297&quot;/&gt;&lt;/p&gt;&lt;p data-source-line=&quot;54&quot;&gt;&lt;img data-ratio=&quot;0.39067854694996573&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OqTAl3WTC7FCcQCUsqaSExkBFHia0CdTFJ3uGYFpY8I4bvoepPX0OmJFwE10GV7liaYCdSia7xIoWgedANTtMwv5w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1459&quot;/&gt;&lt;/p&gt;&lt;p data-source-line=&quot;56&quot;&gt;&lt;img data-ratio=&quot;0.326875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OqTAl3WTC7FCcQCUsqaSExkBFHia0CdTFJUSprdkOANhHvM6GHxIyxZNbWAhGX1vzeWydHfFVJS8U7XEPniba3Rw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;/p&gt;&lt;ol start=&quot;2&quot; data-source-line=&quot;58&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;增加配置文件&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-source-line=&quot;60&quot;&gt;在项目的\src\main\resources\下创建\META-INF\services目录，并增加一个配置文件，这个文件必须以接口的全限定类名保持一致，例如：com.xiaohui.spi.HelloService。然后在配置文件中写入具体实现类的全限定类名，如有多个则换行写入。&lt;/p&gt;&lt;p data-source-line=&quot;62&quot;&gt;&lt;img data-ratio=&quot;0.45432497978981407&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OqTAl3WTC7FCcQCUsqaSExkBFHia0CdTF4krriaTicibRCKZLk0CC88zAsbTeiaxwtXla2avwgPJw7KDCXK8PXplpww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1237&quot;/&gt;&lt;/p&gt;&lt;ol start=&quot;3&quot; data-source-line=&quot;64&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;使用JDK来载入&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-source-line=&quot;66&quot;&gt;使用JDK提供的ServiceLoader.load()来加载配置文件中的描述信息，完成类加载操作。&lt;/p&gt;&lt;p data-source-line=&quot;68&quot;&gt;&lt;img data-ratio=&quot;0.5680044593088072&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OqTAl3WTC7FCcQCUsqaSExkBFHia0CdTFwwbTtRiaQOoH74icoe6Q0P4XE1NiaUjiaVT0Wkkcb4VawoyFMkr0UZZCdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1794&quot;/&gt;&lt;/p&gt;&lt;h2 data-source-line=&quot;70&quot;&gt;补充说明SPI加载&lt;/h2&gt;&lt;p data-source-line=&quot;72&quot;&gt;有关双亲委派的讲解，请查看博客《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyNzgyNzAwNg==&amp;amp;mid=2247483853&amp;amp;idx=1&amp;amp;sn=e3c145cde37b4e08348a10de39682089&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;Java类加载及对象创建过程详解&lt;/a&gt;》&lt;/p&gt;&lt;h3 data-source-line=&quot;74&quot;&gt;为什么需要破坏双亲委派？&lt;/h3&gt;&lt;p data-source-line=&quot;76&quot;&gt;在某些情况下父类加载器需要委托子类加载器去加载class文件。受到双亲委派加载范围的限制，父类加载器无法加载到需要的文件。&lt;/p&gt;&lt;h3 data-source-line=&quot;78&quot;&gt;如何破坏双亲委派？&lt;/h3&gt;&lt;p data-source-line=&quot;80&quot;&gt;双亲委派模型并不是一个强制性的约束模型，而是java设计者推荐给开发者的类加载器实现方式，在java项目中大部分的类加载器都遵循这个模型，但也有例外，到目前为止，双亲委派模型主要出现过三次较大规模的“被破坏”情况。&lt;/p&gt;&lt;p data-source-line=&quot;82&quot;&gt;双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK1.2发布之前。由于双亲委派模型是在JDK1.2之后才被引入的，而类加载器和抽象类java.lang.ClassLoader则是JDK1.0时候就已经存在，面对已经存在 的用户自定义类加载器的实现代码，Java设计者引入双亲委派模型时不得不做出一些妥协。为了向前兼容，JDK1.2之后的java.lang.ClassLoader添加了一个新的proceted方法findClass()，在此之前，用户去继承java.lang.ClassLoader的唯一目的就是重写loadClass()方法，因为虚拟在进行类加载的时候会调用加载器的私有方法loadClassInternal()，而这个方法的唯一逻辑就是去调用自己的loadClass()。JDK1.2之后已不再提倡用户再去覆盖loadClass()方法，应当把自己的类加载逻辑写到findClass()方法中，在loadClass()方法的逻辑里，如果父类加载器加载失败，则会调用自己的findClass()方法来完成加载，这样就可以保证新写出来的类加载器是符合双亲委派模型的。&lt;/p&gt;&lt;p data-source-line=&quot;84&quot;&gt;双亲委派模型的第二次“被破坏”是这个模型自身的缺陷所导致的，双亲委派模型很好地解决了各个类加载器的基础类统一问题(越基础的类由越上层的加载器进行加载)，基础类之所以被称为“基础”，是因为它们总是作为被调用代码调用的API。但是，如果基础类又要调用用户的代码，那该怎么办呢。&lt;/p&gt;&lt;p data-source-line=&quot;86&quot;&gt;为了解决这个困境，Java设计团队只好引入了一个不太优雅的设计：线程上下文件类加载器(Thread Context ClassLoader)。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个；如果在应用程序的全局范围内都没有设置过，那么这个类加载器默认就是应用程序类加载器。使用这个线程上下文类加载器去加载所需要的代码，也就是父类加载器请求子类加载器去完成类加载动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型，但这也是无可奈何的事情。Java中所有涉及SPI的加载动作基本上都采用这种方式，例如JNDI,JDBC,JCE,JAXB和JBI等。&lt;/p&gt;&lt;p data-source-line=&quot;88&quot;&gt;双亲委派模型的第三次“被破坏”是由于用户对程序的动态性的追求导致的，例如OSGi的出现。在OSGi环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为网状结构。&lt;/p&gt;&lt;h3 data-source-line=&quot;90&quot;&gt;破坏双亲委派的举例&lt;/h3&gt;&lt;p data-source-line=&quot;92&quot;&gt;以tomcat为例，讲解如何破坏双亲委派，属于上述讲解的第二次破坏。&lt;/p&gt;&lt;p data-source-line=&quot;94&quot;&gt;&lt;img data-ratio=&quot;1.764525993883792&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OqTAl3WTC7FCcQCUsqaSExkBFHia0CdTF9iaYgpiaMZlyVbdicSaWGwycbDkCXzXTdibNLPWIRb0hjPCcFLFxkeOiaLQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;327&quot;/&gt;&lt;/p&gt;&lt;p data-source-line=&quot;96&quot;&gt;如果有10个Web应用程序都用到了spring的话，可以把Spring的jar包放到common或shared目录下让这些程序共享。Spring的作用是管理每个web应用程序的bean，getBean时自然要能访问到应用程序的类，而用户的程序是放在/WebApp/WEB-INF目录中的（由WebAppClassLoader加载），那么在CommonClassLoader或SharedClassLoader中的Spring容器如何去加载并不在其加载范围的用户程序（/WebApp/WEB-INF/）中的Class呢？&lt;/p&gt;&lt;p data-source-line=&quot;98&quot;&gt;Spring统统使用线程上下文加载器(ContextClassLoade)来加载类，无需理会被放在哪里。ContextClassLoader默认存放了WebAppClassLoader的引用，由于它是在运行时被放在了线程中，所以不管当前程序处于何处（BootstrapClassLoader或是ExtClassLoader等），在任何需要的时候都可以用Thread.currentThread().getContextClassLoader()取出应用程序类加载器来完成需要的操作。&lt;/p&gt;&lt;p data-source-line=&quot;100&quot;&gt;参考：&lt;/p&gt;&lt;ol data-source-line=&quot;101&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;《深入理解java虚拟机》&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>