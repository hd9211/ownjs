<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>50006ed97e7ed5d10c4d313724fb737f</guid>
<title>阿里 Sentinel 框架的一些小扩展</title>
<link>https://toutiao.io/k/z99zluq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 是面向分布式服务架构的流量控制组件，主要以流量为切入点，从流量控制、熔断降级、系统自适应保护等多个维度来帮助您保障微服务的稳定性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天给大家介绍一些在使用过程中会遇到的一些问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;SentinelResource 埋点监控&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;@SentinelResource 可以作用于方法上的熔断降级保护，跟 Hystrix 的@HystrixCommand 注解作用是一样的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;做监控的目的是为了在业务方法触发了熔断降级规则后，在对应的监控视图中可以看到这个操作触发了对应的规则。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;@SentinelResource 的工作依赖于 SentinelResourceAspect 这个切面，需要监控的话对 SentinelResourceAspect 这个类进行改造就可以了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;流控熔断预警&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在流量突然上升的时候，也就意味着随时都可能迎来请求量的高峰，就会触发限流。我们也需要有一定的监控手段来提前告警，这种场景可以扩展 Slot 来实现提前告警的方案，具体方式可以查询这篇文章：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwMDY0Nzk2Mw==&amp;amp;mid=2650321134&amp;amp;idx=1&amp;amp;sn=5b18e25bba5d2113f0f0fcbd4b6f261a&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;https://mp.weixin.qq.com/s/qhep2f9HgK7sZFcdKMAMVg&lt;/a&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;RestFul API 处理&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Sentinel 中，以资源的概念来进行对应的限流熔断操作。如果你们的 API 是 RestFul 风格，就会出现同一个接口变成 N 个资源的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以用@SentinelResource 为每个接口固定好资源名，这样比较繁琐。所以需要对这类的 API 进行格式化，变成一个资源。相关实现参考：https://blog.csdn.net/luanlouis/article/details/91633042还挺全的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;核心原理就是重写 UrlCleaner 的实现逻辑，利用正则进行匹配处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这类操作不仅仅是在 Sentinel 中会遇到，在其他的框架中也经常会遇到这种情况。比如在 Cat 中也会有类似场景，对 API 进行监控，如果不处理同样会出现 N 个监控项。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Origin 来源限制&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果需要对某个调用方进行限流，我们可以利用 Origin 方式来实现。建议做成动态配置方式，比如支持 IP, 支持请求头中的参数等方式进行限制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内部服务之间调用还可以将本服务的应用名存放在请求头中传递过去，这样就可以在 Sentinel 中基于 Origin 来实现内部服务调用的流量控制。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6689466484268126&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WRLYshvT39wJ8jrAVewuO1fz59L1aPjfraFseNguxQCiblnoHlnmc23YcImXONRibjfEpXOGYUiaAbjM1ToeHaQPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1462&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;热点参数动态流控&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于热点参数的流控，也可以做成动态配置的方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如当前是商品 ID 为热点参数，后面是订单 ID 为热点参数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如当前是商品接口，后面是订单接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以从 url 参数中获取热点参数，可以从 header 中获取热点参数，可以从 path 路径中获取热点参数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;增加一个配置信息，然后扩展 Sentinel 的 Filter 进行限流控制，根据配置获取对应的热点参数进行限流。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8812785388127854&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WRLYshvT39wJ8jrAVewuO1fz59L1aPjfOa6RyYxLz8mniafIHkOiasI6qXVCKRUKuibboV5o9MjoCmKXJVX7j6Cjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1314&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;限流规则持久化&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;限流规则持久化是肯定要做的，默认规则是存储在内存中，这样一起动规则就丢失了，所以必须持久化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;持久化分为两种，首先是客户端，客户端持久化意思是说客户端需要加载对应的规则，这些规则会从一个地方进行获取，比如我们用 Apollo 配置中心来存储的话，客户端在启动时就会从 Apollo 中去拉取对应的规则信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对应的操作步骤和详细介绍可以查看下面这篇文章，虽然写了很久了，但是总体思路什么的都没变化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Sentinel Client: 整合 Apollo 规则持久化：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwMDY0Nzk2Mw==&amp;amp;mid=2650320129&amp;amp;idx=1&amp;amp;sn=ed46a21c9b3656fc10395840a2e45f50&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;https://mp.weixin.qq.com/s/K9JtdGoLD1XALq5D67slPQ&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后是服务端也就是控制台的持久化，我们可以在控制台进行规则的添加和编辑，然后会把对应的配置信息推送给所有的客户端，这样规则就生效了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样存储重启即丢失的情况，所以控制台也需要进行持久化规则。如果客户端对接了 Apollo,那么控制也需要对接 Apollo 将规则信息存储到 Apollo 中，这样整个流程就连起来了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以参考这篇文章：阿里 Sentinel 控制台:-整合 Apollo 规则持久化：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwMDY0Nzk2Mw==&amp;amp;mid=2650320158&amp;amp;idx=1&amp;amp;sn=5c5522f49fb99504818883a9f12104ac&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;https://mp.weixin.qq.com/s/deigVXhEd9HycuLLm-oJzA&lt;/a&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;监控数据持久化&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.17760416666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WRLYshvT39wJ8jrAVewuO1fz59L1aPjfnTd13Bu5hdF4eaJN1ZCXz7LVicZDDUgWn3bicibJmz7ibvlgibyPdc8ibjmQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;figcaption&gt;官方说明&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Sentinel 控制台的实时监控数据，默认仅存储 5 分钟以内的数据。如果需要持久化，需要实现框架提供的相关接口进行改造。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5 分钟确实很短，最起码要存储最近 3 天的数据，这样方便查看流量的趋势。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于相关实现大家可以去看文档，比较简单，主要就是实现 MetricsRepository，将监控的数据存储到对应的数据库中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相关改造源码可以参考：https://github.com/yinjihuan/kitty/tree/master/kitty-distributed/kitty-distributed-sentinel&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;关于作者&lt;/strong&gt;：尹吉欢，简单的技术爱好者，《Spring Cloud 微服务-全栈技术与案例解析》, 《Spring Cloud 微服务 入门 实战与进阶》作者, 公众号&lt;strong&gt;猿天地&lt;/strong&gt;发起人。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我整理了一份很全的学习资料，感兴趣的可以微信搜索「&lt;strong&gt;猿天地&lt;/strong&gt;」，回复关键字 「&lt;strong&gt;学习资料&lt;/strong&gt;」获取我整理好了的 Spring Cloud，Spring Cloud Alibaba，Sharding-JDBC 分库分表，任务调度框架 XXL-JOB，MongoDB，爬虫等相关资料。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ce1e13791883ffc7ea7f0f05fa6eb309</guid>
<title>Flutter-Android-Embedder 启动流程</title>
<link>https://toutiao.io/k/6pwut9v</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;概述&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Flutter的启动包括Embedder、Engine、Framework三部分，本文仅描述Android平台的Embdder模块的启动流程。Flutter通常通过启动一个FlutterActivity启动，纯Flutter App则通过FlutterApplication启动。本文以后一种情况为例分析。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;FlutterApplication#onCreate&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// io/flutter/app/FlutterApplication.java&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;@CallSuper&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onCreate&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;super&lt;/span&gt;.onCreate();&lt;br/&gt;    FlutterInjector.instance().flutterLoader().startInitialization(&lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际是调用&lt;code&gt;FlutterLoader#startInitialization&lt;/code&gt;进行初始化。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;FlutterLoader#startInitialization&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;startInitialization&lt;/span&gt;&lt;span&gt;(@NonNull Context applicationContext)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    startInitialization(applicationContext, &lt;span&gt;new&lt;/span&gt; Settings());&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;startInitialization&lt;/span&gt;&lt;span&gt;(@NonNull Context applicationContext, @NonNull Settings settings)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.settings != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (Looper.myLooper() != Looper.getMainLooper()) {&lt;br/&gt;      &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&lt;span&gt;&quot;startInitialization must be called on the main thread&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; Context appContext = applicationContext.getApplicationContext();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.settings = settings;&lt;br/&gt;&lt;br/&gt;    initStartTimestampMillis = SystemClock.uptimeMillis();&lt;br/&gt;    flutterApplicationInfo = ApplicationInfoLoader.load(appContext);&lt;br/&gt;    VsyncWaiter.getInstance((WindowManager) appContext.getSystemService(Context.WINDOW_SERVICE))&lt;br/&gt;        .init();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Use a background thread for initialization tasks that require disk access.&lt;/span&gt;&lt;br/&gt;    Callable&amp;lt;InitResult&amp;gt; initTask =&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; Callable&amp;lt;InitResult&amp;gt;() {&lt;br/&gt;          &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;&lt;span&gt;public&lt;/span&gt; InitResult &lt;span&gt;call&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            ResourceExtractor resourceExtractor = initResources(appContext);&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (FlutterInjector.instance().shouldLoadNative()) {&lt;br/&gt;              System.loadLibrary(&lt;span&gt;&quot;flutter&quot;&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;// Prefetch the default font manager as soon as possible on a background thread.&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;// It helps to reduce time cost of engine setup that blocks the platform thread.&lt;/span&gt;&lt;br/&gt;            Executors.newSingleThreadExecutor()&lt;br/&gt;                .execute(&lt;br/&gt;                    &lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;                      &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;                      &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                        FlutterJNI.nativePrefetchDefaultFontManager();&lt;br/&gt;                      }&lt;br/&gt;                    });&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (resourceExtractor != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;              resourceExtractor.waitForCompletion();&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; InitResult(&lt;br/&gt;                PathUtils.getFilesDir(appContext),&lt;br/&gt;                PathUtils.getCacheDirectory(appContext),&lt;br/&gt;                PathUtils.getDataDirectory(appContext));&lt;br/&gt;          }&lt;br/&gt;        };&lt;br/&gt;    initResultFuture = Executors.newSingleThreadExecutor().submit(initTask);&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要做了以下几件事：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;检查是否在主线程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;注册Vsync信号监听&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;启动一个异步任务，执行以下操作：&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;加载flutter engine&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;异步初始化字体管理器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;加载asset目录下的资源&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上是Application会执行的操作，接着一般会进入一个FlutterActivity，那么依次查看其回调。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;FlutterActivity#onCreate&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// io/flutter/embedding/android/FlutterActivity.java&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onCreate&lt;/span&gt;&lt;span&gt;(@Nullable Bundle savedInstanceState)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    switchLaunchThemeForNormalTheme();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;super&lt;/span&gt;.onCreate(savedInstanceState);&lt;br/&gt;&lt;br/&gt;    lifecycle.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);&lt;br/&gt;&lt;br/&gt;    delegate = &lt;span&gt;new&lt;/span&gt; FlutterActivityAndFragmentDelegate(&lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;    delegate.onAttach(&lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;    delegate.onActivityCreated(savedInstanceState);&lt;br/&gt;&lt;br/&gt;    configureWindowForTransparency();&lt;br/&gt;    setContentView(createFlutterView());&lt;br/&gt;    configureStatusBarForFullscreenFlutterExperience();&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要做了以下几件事：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;从Splash切换成真正要显示的View&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;创建一个delegate，并触发对应回调&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;配置相关的窗口属性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;创建一个新的FlutterView，作为Activity的ContentView&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;FlutterActivityAndFragmentDelegate#onAttach&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;onAttach&lt;/span&gt;&lt;span&gt;(@NonNull Context context)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ensureAlive();&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (flutterEngine == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      setupFlutterEngine();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (host.shouldAttachEngineToActivity()) {&lt;br/&gt;      Log.v(TAG, &lt;span&gt;&quot;Attaching FlutterEngine to the Activity that owns this delegate.&quot;&lt;/span&gt;);&lt;br/&gt;      flutterEngine.getActivityControlSurface().attachToActivity(&lt;span&gt;this&lt;/span&gt;, host.getLifecycle());&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    platformPlugin = host.providePlatformPlugin(host.getActivity(), flutterEngine);&lt;br/&gt;&lt;br/&gt;    host.configureFlutterEngine(flutterEngine);&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要做了以下几件事：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;设置FlutterEngine，一般是新建一个&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;把Engine和容器Activity关联&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;新建一个PlatformPlugin&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;engine初始化完毕，触发对应回调&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中，&lt;code&gt;FlutterActivityAndFragmentDelegate#setupFlutterEngine&lt;/code&gt;行为比较复杂&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &lt;span&gt;/* package */&lt;/span&gt; &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;setupFlutterEngine&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Log.v(TAG, &lt;span&gt;&quot;Setting up FlutterEngine.&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// First, check if the host wants to use a cached FlutterEngine.&lt;/span&gt;&lt;br/&gt;    String cachedEngineId = host.getCachedEngineId();&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (cachedEngineId != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      flutterEngine = FlutterEngineCache.getInstance().get(cachedEngineId);&lt;br/&gt;      isFlutterEngineFromHost = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (flutterEngine == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&lt;br/&gt;            &lt;span&gt;&quot;The requested cached FlutterEngine did not exist in the FlutterEngineCache: &#x27;&quot;&lt;/span&gt;&lt;br/&gt;                + cachedEngineId&lt;br/&gt;                + &lt;span&gt;&quot;&#x27;&quot;&lt;/span&gt;);&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Second, defer to subclasses for a custom FlutterEngine.&lt;/span&gt;&lt;br/&gt;    flutterEngine = host.provideFlutterEngine(host.getContext());&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (flutterEngine != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      isFlutterEngineFromHost = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    Log.v(&lt;br/&gt;        TAG,&lt;br/&gt;        &lt;span&gt;&quot;No preferred FlutterEngine was provided. Creating a new FlutterEngine for&quot;&lt;/span&gt;&lt;br/&gt;            + &lt;span&gt;&quot; this FlutterFragment.&quot;&lt;/span&gt;);&lt;br/&gt;    flutterEngine =&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; FlutterEngine(&lt;br/&gt;            host.getContext(),&lt;br/&gt;            host.getFlutterShellArgs().toArray(),&lt;br/&gt;            &lt;span&gt;/*automaticallyRegisterPlugins=*/&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;/*willProvideRestorationData=*/&lt;/span&gt; host.shouldRestoreAndSaveState());&lt;br/&gt;    isFlutterEngineFromHost = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里一般是第三种情况，直接新建一个Engine：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;FlutterEngine&lt;/span&gt;&lt;span&gt;(&lt;br/&gt;      @NonNull Context context,&lt;br/&gt;      @Nullable FlutterLoader flutterLoader,&lt;br/&gt;      @NonNull FlutterJNI flutterJNI,&lt;br/&gt;      @NonNull PlatformViewsController platformViewsController,&lt;br/&gt;      @Nullable String[] dartVmArgs,&lt;br/&gt;      &lt;span&gt;boolean&lt;/span&gt; automaticallyRegisterPlugins,&lt;br/&gt;      &lt;span&gt;boolean&lt;/span&gt; waitForRestorationData)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    AssetManager assetManager;&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;      assetManager = context.createPackageContext(context.getPackageName(), &lt;span&gt;0&lt;/span&gt;).getAssets();&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (NameNotFoundException e) {&lt;br/&gt;      assetManager = context.getAssets();&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.dartExecutor = &lt;span&gt;new&lt;/span&gt; DartExecutor(flutterJNI, assetManager);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.dartExecutor.onAttachedToJNI();&lt;br/&gt;&lt;br/&gt;    accessibilityChannel = &lt;span&gt;new&lt;/span&gt; AccessibilityChannel(dartExecutor, flutterJNI);&lt;br/&gt;    keyEventChannel = &lt;span&gt;new&lt;/span&gt; KeyEventChannel(dartExecutor);&lt;br/&gt;    lifecycleChannel = &lt;span&gt;new&lt;/span&gt; LifecycleChannel(dartExecutor);&lt;br/&gt;    localizationChannel = &lt;span&gt;new&lt;/span&gt; LocalizationChannel(dartExecutor);&lt;br/&gt;    mouseCursorChannel = &lt;span&gt;new&lt;/span&gt; MouseCursorChannel(dartExecutor);&lt;br/&gt;    navigationChannel = &lt;span&gt;new&lt;/span&gt; NavigationChannel(dartExecutor);&lt;br/&gt;    platformChannel = &lt;span&gt;new&lt;/span&gt; PlatformChannel(dartExecutor);&lt;br/&gt;    restorationChannel = &lt;span&gt;new&lt;/span&gt; RestorationChannel(dartExecutor, waitForRestorationData);&lt;br/&gt;    settingsChannel = &lt;span&gt;new&lt;/span&gt; SettingsChannel(dartExecutor);&lt;br/&gt;    systemChannel = &lt;span&gt;new&lt;/span&gt; SystemChannel(dartExecutor);&lt;br/&gt;    textInputChannel = &lt;span&gt;new&lt;/span&gt; TextInputChannel(dartExecutor);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.localizationPlugin = &lt;span&gt;new&lt;/span&gt; LocalizationPlugin(context, localizationChannel);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.flutterJNI = flutterJNI;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (flutterLoader == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      flutterLoader = FlutterInjector.instance().flutterLoader();&lt;br/&gt;    }&lt;br/&gt;    flutterLoader.startInitialization(context.getApplicationContext());&lt;br/&gt;    flutterLoader.ensureInitializationComplete(context, dartVmArgs);&lt;br/&gt;&lt;br/&gt;    flutterJNI.addEngineLifecycleListener(engineLifecycleListener);&lt;br/&gt;    flutterJNI.setPlatformViewsController(platformViewsController);&lt;br/&gt;    flutterJNI.setLocalizationPlugin(localizationPlugin);&lt;br/&gt;    attachToJni();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// TODO(mattcarroll): FlutterRenderer is temporally coupled to attach(). Remove that coupling if&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// possible.&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.renderer = &lt;span&gt;new&lt;/span&gt; FlutterRenderer(flutterJNI);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.platformViewsController = platformViewsController;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.platformViewsController.onAttachedToJNI();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.pluginRegistry =&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; FlutterEngineConnectionRegistry(context.getApplicationContext(), &lt;span&gt;this&lt;/span&gt;, flutterLoader);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (automaticallyRegisterPlugins) {&lt;br/&gt;      registerPlugins();&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要做了以下几件事：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;新建Dart运行环境DartExecutor&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;创建各种用于Flutter和Android通信的channel对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;确认engine初始化完成（调用Native侧的初始化方法，执行Flutter engine的启动逻辑）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;插件注册&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;flutterLoader.startInitialization&lt;/code&gt;由于之前调用过，这里会直接返回。&lt;code&gt;FlutterLoader#ensureInitializationComplete&lt;/code&gt;则负责engine最后的准备工作：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;ensureInitializationComplete&lt;/span&gt;&lt;span&gt;(&lt;br/&gt;      @NonNull Context applicationContext, @Nullable String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (initialized) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (Looper.myLooper() != Looper.getMainLooper()) {&lt;br/&gt;      &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&lt;br/&gt;          &lt;span&gt;&quot;ensureInitializationComplete must be called on the main thread&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (settings == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&lt;br/&gt;          &lt;span&gt;&quot;ensureInitializationComplete must be called after startInitialization&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;      InitResult result = initResultFuture.get();&lt;br/&gt;&lt;br/&gt;      List&amp;lt;String&amp;gt; shellArgs = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;      shellArgs.add(&lt;span&gt;&quot;--icu-symbol-prefix=_binary_icudtl_dat&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;      shellArgs.add(&lt;br/&gt;          &lt;span&gt;&quot;--icu-native-lib-path=&quot;&lt;/span&gt;&lt;br/&gt;              + flutterApplicationInfo.nativeLibraryDir&lt;br/&gt;              + File.separator&lt;br/&gt;              + DEFAULT_LIBRARY);&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (args != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        Collections.addAll(shellArgs, args);&lt;br/&gt;      }&lt;br/&gt;&lt;br/&gt;      String kernelPath = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (BuildConfig.DEBUG || BuildConfig.JIT_RELEASE) {&lt;br/&gt;        String snapshotAssetPath =&lt;br/&gt;            result.dataDirPath + File.separator + flutterApplicationInfo.flutterAssetsDir;&lt;br/&gt;        kernelPath = snapshotAssetPath + File.separator + DEFAULT_KERNEL_BLOB;&lt;br/&gt;        shellArgs.add(&lt;span&gt;&quot;--&quot;&lt;/span&gt; + SNAPSHOT_ASSET_PATH_KEY + &lt;span&gt;&quot;=&quot;&lt;/span&gt; + snapshotAssetPath);&lt;br/&gt;        shellArgs.add(&lt;span&gt;&quot;--&quot;&lt;/span&gt; + VM_SNAPSHOT_DATA_KEY + &lt;span&gt;&quot;=&quot;&lt;/span&gt; + flutterApplicationInfo.vmSnapshotData);&lt;br/&gt;        shellArgs.add(&lt;br/&gt;            &lt;span&gt;&quot;--&quot;&lt;/span&gt; + ISOLATE_SNAPSHOT_DATA_KEY + &lt;span&gt;&quot;=&quot;&lt;/span&gt; + flutterApplicationInfo.isolateSnapshotData);&lt;br/&gt;      } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        shellArgs.add(&lt;br/&gt;            &lt;span&gt;&quot;--&quot;&lt;/span&gt; + AOT_SHARED_LIBRARY_NAME + &lt;span&gt;&quot;=&quot;&lt;/span&gt; + flutterApplicationInfo.aotSharedLibraryName);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// Most devices can load the AOT shared library based on the library name&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// with no directory path.  Provide a fully qualified path to the library&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// as a workaround for devices where that fails.&lt;/span&gt;&lt;br/&gt;        shellArgs.add(&lt;br/&gt;            &lt;span&gt;&quot;--&quot;&lt;/span&gt;&lt;br/&gt;                + AOT_SHARED_LIBRARY_NAME&lt;br/&gt;                + &lt;span&gt;&quot;=&quot;&lt;/span&gt;&lt;br/&gt;                + flutterApplicationInfo.nativeLibraryDir&lt;br/&gt;                + File.separator&lt;br/&gt;                + flutterApplicationInfo.aotSharedLibraryName);&lt;br/&gt;      }&lt;br/&gt;&lt;br/&gt;      shellArgs.add(&lt;span&gt;&quot;--cache-dir-path=&quot;&lt;/span&gt; + result.engineCachesPath);&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (!flutterApplicationInfo.clearTextPermitted) {&lt;br/&gt;        shellArgs.add(&lt;span&gt;&quot;--disallow-insecure-connections&quot;&lt;/span&gt;);&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (flutterApplicationInfo.domainNetworkPolicy != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        shellArgs.add(&lt;span&gt;&quot;--domain-network-policy=&quot;&lt;/span&gt; + flutterApplicationInfo.domainNetworkPolicy);&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (settings.getLogTag() != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        shellArgs.add(&lt;span&gt;&quot;--log-tag=&quot;&lt;/span&gt; + settings.getLogTag());&lt;br/&gt;      }&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;long&lt;/span&gt; initTimeMillis = SystemClock.uptimeMillis() - initStartTimestampMillis;&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (FlutterInjector.instance().shouldLoadNative()) {&lt;br/&gt;        FlutterJNI.nativeInit(&lt;br/&gt;            applicationContext,&lt;br/&gt;            shellArgs.toArray(&lt;span&gt;new&lt;/span&gt; String[&lt;span&gt;0&lt;/span&gt;]),&lt;br/&gt;            kernelPath,&lt;br/&gt;            result.appStoragePath,&lt;br/&gt;            result.engineCachesPath,&lt;br/&gt;            initTimeMillis);&lt;br/&gt;      }&lt;br/&gt;&lt;br/&gt;      initialized = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;      Log.e(TAG, &lt;span&gt;&quot;Flutter initialization failed.&quot;&lt;/span&gt;, e);&lt;br/&gt;      &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(e);&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要是拼接各种参数，最终调用了一个native方法，让engine执行自己的初始化逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此，&lt;code&gt;FlutterActivityAndFragmentDelegate#onAttach&lt;/code&gt;的逻辑终于走完了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;FlutterActivityAndFragmentDelegate#onActivityCreated&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;onActivityCreated&lt;/span&gt;&lt;span&gt;(@Nullable Bundle bundle)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Log.v(TAG, &lt;span&gt;&quot;onActivityCreated. Giving framework and plugins an opportunity to restore state.&quot;&lt;/span&gt;);&lt;br/&gt;    ensureAlive();&lt;br/&gt;&lt;br/&gt;    Bundle pluginState = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;byte&lt;/span&gt;[] frameworkState = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (bundle != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      pluginState = bundle.getBundle(PLUGINS_RESTORATION_BUNDLE_KEY);&lt;br/&gt;      frameworkState = bundle.getByteArray(FRAMEWORK_RESTORATION_BUNDLE_KEY);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (host.shouldRestoreAndSaveState()) {&lt;br/&gt;      flutterEngine.getRestorationChannel().setRestorationData(frameworkState);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (host.shouldAttachEngineToActivity()) {&lt;br/&gt;      flutterEngine.getActivityControlSurface().onRestoreInstanceState(pluginState);&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;状态恢复相关，一般无需关注。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;FlutterActivity#createFlutterView&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &lt;span&gt;@NonNull&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;private&lt;/span&gt; View &lt;span&gt;createFlutterView&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; delegate.onCreateView(&lt;br/&gt;        &lt;span&gt;null&lt;/span&gt; &lt;span&gt;/* inflater */&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt; &lt;span&gt;/* container */&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt; &lt;span&gt;/* savedInstanceState */&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;继续：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &lt;span&gt;View &lt;span&gt;onCreateView&lt;/span&gt;&lt;span&gt;(&lt;br/&gt;      LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Log.v(TAG, &lt;span&gt;&quot;Creating FlutterView.&quot;&lt;/span&gt;);&lt;br/&gt;    ensureAlive();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (host.getRenderMode() == RenderMode.surface) {&lt;br/&gt;      FlutterSurfaceView flutterSurfaceView =&lt;br/&gt;          &lt;span&gt;new&lt;/span&gt; FlutterSurfaceView(&lt;br/&gt;              host.getActivity(), host.getTransparencyMode() == TransparencyMode.transparent);&lt;br/&gt;&lt;br/&gt;      host.onFlutterSurfaceViewCreated(flutterSurfaceView);&lt;br/&gt;&lt;br/&gt;      flutterView = &lt;span&gt;new&lt;/span&gt; FlutterView(host.getActivity(), flutterSurfaceView);&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      FlutterTextureView flutterTextureView = &lt;span&gt;new&lt;/span&gt; FlutterTextureView(host.getActivity());&lt;br/&gt;&lt;br/&gt;      host.onFlutterTextureViewCreated(flutterTextureView);&lt;br/&gt;&lt;br/&gt;      flutterView = &lt;span&gt;new&lt;/span&gt; FlutterView(host.getActivity(), flutterTextureView);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    flutterView.addOnFirstFrameRenderedListener(flutterUiDisplayListener);&lt;br/&gt;&lt;br/&gt;    flutterSplashView = &lt;span&gt;new&lt;/span&gt; FlutterSplashView(host.getContext());&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) {&lt;br/&gt;      flutterSplashView.setId(View.generateViewId());&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      flutterSplashView.setId(&lt;span&gt;486947586&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;    flutterSplashView.displayFlutterViewWithSplash(flutterView, host.provideSplashScreen());&lt;br/&gt;&lt;br/&gt;    Log.v(TAG, &lt;span&gt;&quot;Attaching FlutterEngine to FlutterView.&quot;&lt;/span&gt;);&lt;br/&gt;    flutterView.attachToFlutterEngine(flutterEngine);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; flutterSplashView;&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里会根据不同mode，创建不同类型的FlutterView，这个View承载了Flutter的UI在Android端的显示。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，会创建一个&lt;code&gt;FlutterSplashView&lt;/code&gt;作为启动阶段的闪屏。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，&lt;code&gt;FlutterView#attachToFlutterEngine&lt;/code&gt;会把FlutterView和FlutterEngine关联起来：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;attachToFlutterEngine&lt;/span&gt;&lt;span&gt;(@NonNull FlutterEngine flutterEngine)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Log.v(TAG, &lt;span&gt;&quot;Attaching to a FlutterEngine: &quot;&lt;/span&gt; + flutterEngine);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (isAttachedToFlutterEngine()) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (flutterEngine == &lt;span&gt;this&lt;/span&gt;.flutterEngine) {&lt;br/&gt;        Log.v(TAG, &lt;span&gt;&quot;Already attached to this engine. Doing nothing.&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;      }&lt;br/&gt;      Log.v(&lt;br/&gt;          TAG,&lt;br/&gt;          &lt;span&gt;&quot;Currently attached to a different engine. Detaching and then attaching&quot;&lt;/span&gt;&lt;br/&gt;              + &lt;span&gt;&quot; to new engine.&quot;&lt;/span&gt;);&lt;br/&gt;      detachFromFlutterEngine();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.flutterEngine = flutterEngine;&lt;br/&gt;&lt;br/&gt;    FlutterRenderer flutterRenderer = &lt;span&gt;this&lt;/span&gt;.flutterEngine.getRenderer();&lt;br/&gt;    isFlutterUiDisplayed = flutterRenderer.isDisplayingFlutterUi();&lt;br/&gt;    renderSurface.attachToRenderer(flutterRenderer);&lt;br/&gt;    flutterRenderer.addIsDisplayingFlutterUiListener(flutterUiDisplayListener);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// in a way that Flutter understands.&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.N) {&lt;br/&gt;      mouseCursorPlugin = &lt;span&gt;new&lt;/span&gt; MouseCursorPlugin(&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.flutterEngine.getMouseCursorChannel());&lt;br/&gt;    }&lt;br/&gt;    textInputPlugin =&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; TextInputPlugin(&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.flutterEngine.getTextInputChannel(),&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.flutterEngine.getPlatformViewsController());&lt;br/&gt;    localizationPlugin = &lt;span&gt;this&lt;/span&gt;.flutterEngine.getLocalizationPlugin();&lt;br/&gt;    androidKeyProcessor =&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; AndroidKeyProcessor(&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.flutterEngine.getKeyEventChannel(), textInputPlugin);&lt;br/&gt;    androidTouchProcessor =&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; AndroidTouchProcessor(&lt;span&gt;this&lt;/span&gt;.flutterEngine.getRenderer(), &lt;span&gt;/*trackMotionEvents=*/&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;    accessibilityBridge =&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; AccessibilityBridge(&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;,&lt;br/&gt;            flutterEngine.getAccessibilityChannel(),&lt;br/&gt;            (AccessibilityManager) getContext().getSystemService(Context.ACCESSIBILITY_SERVICE),&lt;br/&gt;            getContext().getContentResolver(),&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.flutterEngine.getPlatformViewsController());&lt;br/&gt;    accessibilityBridge.setOnAccessibilityChangeListener(onAccessibilityChangeListener);&lt;br/&gt;    resetWillNotDraw(&lt;br/&gt;        accessibilityBridge.isAccessibilityEnabled(),&lt;br/&gt;        accessibilityBridge.isTouchExplorationEnabled());&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.flutterEngine.getPlatformViewsController().attachAccessibilityBridge(accessibilityBridge);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.flutterEngine&lt;br/&gt;        .getPlatformViewsController()&lt;br/&gt;        .attachToFlutterRenderer(&lt;span&gt;this&lt;/span&gt;.flutterEngine.getRenderer());&lt;br/&gt;&lt;br/&gt;    textInputPlugin.getInputMethodManager().restartInput(&lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Push View and Context related information from Android to Flutter.&lt;/span&gt;&lt;br/&gt;    sendUserSettingsToFlutter();&lt;br/&gt;    localizationPlugin.sendLocalesToFlutter(getResources().getConfiguration());&lt;br/&gt;    sendViewportMetricsToFlutter();&lt;br/&gt;&lt;br/&gt;    flutterEngine.getPlatformViewsController().attachToView(&lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Notify engine attachment listeners of the attachment.&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (FlutterEngineAttachmentListener listener : flutterEngineAttachmentListeners) {&lt;br/&gt;      listener.onFlutterEngineAttachedToFlutterView(flutterEngine);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (isFlutterUiDisplayed) {&lt;br/&gt;      flutterUiDisplayListener.onFlutterUiDisplayed();&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里主要是关联两个对象的字段，同时对一些必要的Plugin进行初始化。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;FlutterActivity#onStart&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onStart&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;super&lt;/span&gt;.onStart();&lt;br/&gt;    lifecycle.handleLifecycleEvent(Lifecycle.Event.ON_START);&lt;br/&gt;    delegate.onStart();&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;核心逻辑在delegate里面：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;onStart&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Log.v(TAG, &lt;span&gt;&quot;onStart()&quot;&lt;/span&gt;);&lt;br/&gt;    ensureAlive();&lt;br/&gt;    doInitialFlutterViewRun();&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doInitialFlutterViewRun&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (host.getCachedEngineId() != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (flutterEngine.getDartExecutor().isExecutingDart()) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    String initialRoute = host.getInitialRoute();&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (initialRoute == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      initialRoute = getInitialRouteFromIntent(host.getActivity().getIntent());&lt;br/&gt;    }&lt;br/&gt;    Log.v(&lt;br/&gt;        TAG,&lt;br/&gt;        &lt;span&gt;&quot;Executing Dart entrypoint: &quot;&lt;/span&gt;&lt;br/&gt;            + host.getDartEntrypointFunctionName()&lt;br/&gt;            + &lt;span&gt;&quot;, and sending initial route: &quot;&lt;/span&gt;&lt;br/&gt;            + initialRoute);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (initialRoute != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      flutterEngine.getNavigationChannel().setInitialRoute(initialRoute);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    String appBundlePathOverride = host.getAppBundlePath();&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (appBundlePathOverride == &lt;span&gt;null&lt;/span&gt; || appBundlePathOverride.isEmpty()) {&lt;br/&gt;      appBundlePathOverride = FlutterInjector.instance().flutterLoader().findAppBundlePath();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    DartExecutor.DartEntrypoint entrypoint =&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; DartExecutor.DartEntrypoint(&lt;br/&gt;            appBundlePathOverride, host.getDartEntrypointFunctionName());&lt;br/&gt;    flutterEngine.getDartExecutor().executeDartEntrypoint(entrypoint);&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可见其核心行为是启动dart虚拟机。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;FlutterActivity#onResume&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onResume&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;super&lt;/span&gt;.onResume();&lt;br/&gt;    lifecycle.handleLifecycleEvent(Lifecycle.Event.ON_RESUME);&lt;br/&gt;    delegate.onResume();&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样看delegate的代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// io/flutter/embedding/android/FlutterActivityAndFragmentDelegate.java&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;onResume&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Log.v(TAG, &lt;span&gt;&quot;onResume()&quot;&lt;/span&gt;);&lt;br/&gt;    ensureAlive();&lt;br/&gt;    flutterEngine.getLifecycleChannel().appIsResumed();&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里向Flutter发送了一个通知，宿主Activity处于onResume状态了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上，就是Android Embedder层的启动流程。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5400986ffc30614e434b16093ccf14f7</guid>
<title>在 Android 和 Hilt 中限定作用域</title>
<link>https://toutiao.io/k/0quw061</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot;&gt;&lt;p&gt;将对象 A 的作用域限定到对象 B，指的是对象 B 的整个生命周期内始终持有相同的 A 实例。当涉及到 DI (依赖项注入) 时，限定对象 A 的作用域为一个容器，则意味着该容器在销毁之前始终提供相同的 A 实例。&lt;/p&gt;&lt;p&gt;在 Hilt 中，您可以通过注解将类型的作用域限定在某些容器或组件内。例如，您的应用中有一个处理登录和注销的 &lt;code&gt;UserManager&lt;/code&gt; 类型。您可以使用 &lt;code&gt;@Singleton&lt;/code&gt; 注解将该类型的作用域限定为 &lt;code&gt;ApplicationComponent&lt;/code&gt; (&lt;code&gt;ApplicationComponent&lt;/code&gt; 是一个被整个应用的生命周期管理的容器)。被限定作用域的类型在应用组件中沿 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/training/dependency-injection/hilt-android%23component-hierarchy&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;组件层次结构&lt;/a&gt;&lt;/b&gt; 向下传递: 在本案例中，相同的 &lt;code&gt;UserManager&lt;/code&gt; 实例将被提供给层次结构内其余的 Hilt 组件。应用中任何依赖于 &lt;code&gt;UserManager&lt;/code&gt; 的类型都将获得相同的实例。&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;注意&lt;/b&gt; : 默认情况下，Hilt 中的绑定都 &lt;b&gt;未限定作用域&lt;/b&gt; 。这些绑定不属于任何组件，并且可以在整个项目中被访问。每次被请求都会提供该类型的不同实例。当您将绑定的作用域限定为某个组件时，它会限制您使用该绑定的范围以及该类型可以具有的依赖项。&lt;/blockquote&gt;&lt;p&gt;在 Android 中，您不使用 DI 库也可以通过 Android Framework 来手动限定作用域。让我们看看如何手动限定作用域，以及如何改用 Hilt 来限定作用域。最后，我们将比较使用 Android Framework 手动限定作用域和使用 Hilt 限定作用域的区别。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;在 Android 中限定作用域&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;看了上文的定义，您可能会有这样的异议: 在某个特定类中使用一个类型的实例变量也可以做到限定该变量类型的作用域。没错！不使用 DI 时，您可以执行如下操作:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ExampleActivity&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AppCompatActivity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;analyticsAdapter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AnalyticsAdapter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;analyticsAdapter&lt;/code&gt; 变量的作用域被限定为 &lt;code&gt;MyActivity&lt;/code&gt; 的生命周期，这意味着只要 Activity 没有被销毁，该变量就是同一个实例。如果另一个类出于某种原因需要访问这个被限定了作用域的变量，每次访问也会获得相同实例。当新的 &lt;code&gt;MyActivity&lt;/code&gt; 实例被创建时 (如系统设置改变)，一个新的 &lt;code&gt;AnalyticsAdapter&lt;/code&gt; 实例将会被创建。&lt;/p&gt;&lt;p&gt;使用 Hilt，等效代码如下:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;&lt;span class=&quot;n&quot;&gt;@ActivityScoped&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AnalyticsAdapter&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;@Inject&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;@AndroidEntryPoint&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ExampleActivity&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AppCompatActivity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;@Inject&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;lateinit&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;analyticsAdapter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AnalyticsAdapter&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;每次创建的 &lt;code&gt;MyActivity&lt;/code&gt; 都会持有一个 &lt;code&gt;ActivityComponent&lt;/code&gt; DI 容器的新实例，在 Activity 被销毁之前，该实例将向 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/training/dependency-injection/hilt-android%23component-hierarchy&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;组件层次结构&lt;/a&gt;&lt;/b&gt; 下的依赖项提供相同的 &lt;code&gt;AnalyticsAdapter&lt;/code&gt; 实例。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-96e8be897eabcee2a6dfdeef895a6d13_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;882&quot; data-rawheight=&quot;212&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-96e8be897eabcee2a6dfdeef895a6d13_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;882&quot; data-rawheight=&quot;212&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-96e8be897eabcee2a6dfdeef895a6d13_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-96e8be897eabcee2a6dfdeef895a6d13_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;更改系统设置后，您将获得一个新的 AnalyticsAdapter 和 MainActivity 实例&lt;/p&gt;&lt;h2&gt;&lt;b&gt;通过 ViewModel 限定作用域&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;然而，我们可能希望 &lt;code&gt;AnalyticsAdapter&lt;/code&gt; 可以在系统设置更改后留存！或者说，我们希望直到用户离开 Activity 之前，都限定该实例的作用域为 Activity。&lt;/p&gt;&lt;p&gt;为此，您可以使用 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/topic/libraries/architecture/viewmodel&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;组件架构中的 ViewModel&lt;/a&gt;&lt;/b&gt;，因为它可以在系统设置更改后留存。&lt;/p&gt;&lt;p&gt;不使用依赖项注入时，您可能有如下代码:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AnalyticsAdapter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ExampleViewModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ViewModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;analyticsAdapter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AnalyticsAdapter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ExampleActivity&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AppCompatActivity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;viewModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ExampleViewModel&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;viewModels&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;analyticsAdapter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;viewModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;analyticsAdapter&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过这种方式，您将 &lt;code&gt;AnalyticsAdapter&lt;/code&gt; 的作用域限定为 ViewModel。因为 Activity 具有 ViewModel 的访问权限，所以在该 Activity 中可以始终获得相同的 &lt;code&gt;AnalyticsAdapter&lt;/code&gt; 实例。&lt;/p&gt;&lt;p&gt;通过使用 Hilt，您可以通过限定 &lt;code&gt;AnalyticsAdapter&lt;/code&gt; 的作用域为 &lt;code&gt;ActivityRetainedComponent&lt;/code&gt; 来实现相同的行为，因为 &lt;code&gt;ActivityRetainedComponent&lt;/code&gt; 也可以在系统设置更改后留存。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;&lt;span class=&quot;n&quot;&gt;@ActivityRetainedScoped&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AnalyticsAdapter&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;@Inject&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;@AndroidEntryPoint&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ExampleActivity&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AppCompatActivity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;@Inject&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;lateinit&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;analyticsAdapter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AnalyticsAdapter&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-51c5dfca98dad5047943ca59d4579cc8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;877&quot; data-rawheight=&quot;213&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-51c5dfca98dad5047943ca59d4579cc8_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;877&quot; data-rawheight=&quot;213&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-51c5dfca98dad5047943ca59d4579cc8_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-51c5dfca98dad5047943ca59d4579cc8_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;通过使用 ViewModel 或者 Hilt 中的 ActivityRetainedScope 注解，您可以在系统设置更改后获得相同的实例&lt;/p&gt;&lt;p&gt;如果您希望在遵循良好的 DI 实践的同时，保留 ViewModel 用于处理视图逻辑，您可以使用 @ViewModelInject 提供 ViewModel 的依赖项，该注解的详细描述请参见: &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/training/dependency-injection/hilt-jetpack%23viewmodels&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;文档 | 使用 Hilt 注入 ViewModel 对象&lt;/a&gt;&lt;/b&gt;。这样一来，&lt;code&gt;AnalyticsAdapter&lt;/code&gt; 的作用域就无需被限定为 &lt;code&gt;ActivityRetainedComponent&lt;/code&gt;，因为此时它的作用域被手动限定为 ViewModel:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AnalyticsAdapter&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;@Inject&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ExampleViewModel&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;@ViewModelInject&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;analyticsAdapter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AnalyticsAdapter&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ViewModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;@AndroidEntryPoint&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ExampleActivity&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AppCompatActivity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;viewModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ExampleViewModel&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;viewModels&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;analyticsAdapter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;viewModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;analyticsAdapter&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们刚才所看到的内容，可以应用到任何由 Android Framework 生命周期类管理的 Hilt 组件中。点击查看 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/training/dependency-injection/hilt-android%23component-scopes&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;全部可用作用域&lt;/a&gt;&lt;/b&gt;。回到我们最初的示例，将作用域限定为 &lt;code&gt;ApplicationComponent&lt;/code&gt;，等同于不使用 DI 框架时在 Application 类中持有该实例。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;对比 Hilt 及 ViewModel 限定作用域&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;使用 Hilt 限定作用域，优势为您可在 Hilt 组件层次结构中使用被限定的类型；而对于 ViewModel，则必须通过 ViewModel 手动访问被限定作用域的类型。&lt;/p&gt;&lt;p&gt;使用 ViewModel 限定作用域，优势为您可以在应用中任何 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/androidx/lifecycle/LifecycleOwner&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;LifecyclerOwner&lt;/a&gt;&lt;/b&gt; 对象中持有 ViewModel。例如，如果您使用了 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/guide/navigation/navigation-getting-started&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Jetpack Navigation 库&lt;/a&gt;&lt;/b&gt;，则可以将 ViewModel 绑定到 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/androidx/navigation/fragment/NavHostFragment&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;NavGraph&lt;/a&gt;&lt;/b&gt; 上。&lt;/p&gt;&lt;p&gt;Hilt 提供的作用域数量有限。可能没有符合您特定使用场景的作用域。例如嵌套 Fragment，对于这种情况，您可以退一步使用 ViewModel 限定作用域。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;使用 Hilt 注入 ViewModel&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;如上文所述，您可以使用 &lt;code&gt;@ViewModelInject&lt;/code&gt; 向 ViewModel 注入依赖项。其原理是这些绑定关系保存在 &lt;code&gt;ActivityRetainedComponent&lt;/code&gt; 中，这也是为什么您只能注入未限定作用域的类型，或者是限定作用域为 &lt;code&gt;ActivityRetainedComponent&lt;/code&gt; 以及 &lt;code&gt;ApplicationComponent&lt;/code&gt; 的类型。&lt;/p&gt;&lt;p&gt;如果 Activity 或 Fragment 被 &lt;code&gt;@AndroidEntryPoint&lt;/code&gt; 注解修饰，就可以通过 &lt;code&gt;getDefaultViewModelProviderFactory()&lt;/code&gt; 方法获取 Hilt 生成的 ViewModel 工厂了。由于可以在 &lt;code&gt;ViewModelProvider&lt;/code&gt; 中使用这些 ViewModel 工厂，使您获取 ViewModel 的方式变得更加灵活。例如: 将作用域限定为 &lt;code&gt;BackStackEntry&lt;/code&gt; 的 ViewModel。&lt;/p&gt;&lt;p&gt;限定作用域会有一些代价，因为提供的对象在持有者被销毁之前将一直保留在内存中。请在应用中慎重地考虑使用限定作用域的对象。如果对象的内部状态要求使用同一实例，对象需要同步，或者对象的创建成本很高，那么限定作用域是恰当的做法。&lt;/p&gt;&lt;p&gt;当然，当您需要限定作用域时，您可以使用 Hilt 中的作用域注解，也可以直接使用 Android Framework。&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7d370ee9fee8afeaaf715505539077aa</guid>
<title>面试：Spark 刷爆磁盘与 Java 弱引用的关系</title>
<link>https://toutiao.io/k/eb5vd84</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7289855072463768&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TwK74MzofXcZZVaX1iaUia4y07rBHv89eVcl5dYK8CkwIwyiaicqDJepBmOl0uA3c5qPde1f61UiaZBHibxicoKmZJiaZg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1380&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7540500736377025&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TwK74MzofXf24ZSVT75Ry6DeTichH884x20V1yPqBvoqTgRN7IicO6tjjGM06DiagCS9UG5hA5s71QuYQQj5oXbjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1358&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;一 引用基本概念&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7540500736377025&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TwK74MzofXcZZVaX1iaUia4y07rBHv89eVs2YiatQuicWjWjBToZhQqzTibVOd6cMiaK8qApSAPibS17vlP0BAT5yDeMQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1358&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7533234859675036&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TwK74MzofXf24ZSVT75Ry6DeTichH884xtw1fGXxwFj1sftaA3iajw9el6HWgppI0QrxWApKLcTYNS90yibZlHn8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1354&quot;/&gt;&lt;/p&gt;&lt;p&gt;如下面，定义两个变量num，str，存储模型大致如下图：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;int num = 6;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;String str = “浪尖聊大数据”;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6552748885586924&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TwK74MzofXf24ZSVT75Ry6DeTichH884xk7xMuUQVotp9pEmg16Ly71ulQuorsWbdsbCKQpkoxkPl2nJpuNiacRg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1346&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7566765578635015&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TwK74MzofXf24ZSVT75Ry6DeTichH884x893VfJ4PuhsFTkOAzS9nc9fLc5tnJsxycvvkSZicicWaXavapeh5rUzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1348&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7548579970104634&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TwK74MzofXf24ZSVT75Ry6DeTichH884x4RWibFCYjDQZvDQg551ViamRpuVaDmI7GMvUYQsaibsiaRm9KuxHOFat0Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1338&quot;/&gt;&lt;/p&gt;&lt;p&gt;变量num值直接从6修改为了8；变量str只是修改了其保存的地址，从0x88修改为0x86，对象 “浪尖聊大数据 ”本身还在内存中，并没有被修改。只是内存中新增了对象 “浪尖是帅哥”。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;二 值传递&amp;amp;引用传递&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7474150664697193&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TwK74MzofXcZZVaX1iaUia4y07rBHv89eVmj3RA3f6Flr4sZuSoAvZF6txoYdn7MOibOcqlKIdiaMvOdKypPYhT6jg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1354&quot;/&gt;&lt;/p&gt;&lt;p&gt;举例说明引用传递和值传递：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;第一个栗子：基本类型&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;void foo(int value) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    value = 88;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;foo(num); // num 没有被改变&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;第二个栗子：没有提供改变自身方法的引用类型&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;void foo(String text) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    text = &quot;mac&quot;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;foo(str); // str 也没有被改变&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;第三个栗子：提供了改变自身方法的引用类型&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;StringBuilder sb = new StringBuilder(&quot;vivo&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;void foo(StringBuilder builder) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    builder.append(&quot;5&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;foo(sb); // sb 被改变了，变成了&quot;vivo5&quot;。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;第四个栗子：提供了改变自身方法的引用类型，但是不使用，而是使用赋值运算符。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;StringBuilder sb = new StringBuilder(&quot;oppo&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;void foo(StringBuilder builder) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    builder = new StringBuilder(&quot;vivo&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;foo(sb); // sb 没有被改变，还是 &quot;oppo&quot;。&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;三 引用的类型&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7316715542521994&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TwK74MzofXcZZVaX1iaUia4y07rBHv89eVWIJLDS7bvsDyv3J30kF7Tnx58Qce7qvlXJLFS4Zxic3wib69liaWJEYdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1364&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7507374631268436&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TwK74MzofXf24ZSVT75Ry6DeTichH884xkRytqPmX7Eic1wmfG0n0KqyHBS6iamp47Ghvibuqyl9HXOKGf6NXOF0Og/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1356&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7511111111111111&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TwK74MzofXf24ZSVT75Ry6DeTichH884xsMAoEN5z7rLPOI2Vw8eN9GFDwsic9CandQR6APxNGxnrMzIyrwakI5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1350&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.748159057437408&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TwK74MzofXf24ZSVT75Ry6DeTichH884xd97R4zTUIib47rDL8HC1dHFibP87Ihu4lEnkn7FGBiabibiaLX85jFH1dpQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1358&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;单纯的申明一个软引用，指向一个person对象&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt; SoftReference pSoftReference=&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; SoftReference(&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Person(“张三”,&lt;span class=&quot;code-snippet__number&quot;&gt;12&lt;/span&gt;));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;声明一个引用队列&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;ReferenceQueue&amp;lt;Person&amp;gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;queue&lt;/span&gt; = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ReferenceQueue&amp;lt;&amp;gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;声明一个person对象，李四，obj是其强引用&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Person obj = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Person(“李四”,&lt;span class=&quot;code-snippet__number&quot;&gt;13&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;使软引用softRef指向李四对应的对象，并且将该软引用关联到引用队列&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt; SoftReference softRef = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; SoftReference&amp;lt;Object&amp;gt;(obj,&lt;span class=&quot;code-snippet__built_in&quot;&gt;queue&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;声明一个person对象，名叫王酒，并保证其仅含软引用，且将软引用关联到引用队列&lt;span class=&quot;code-snippet__built_in&quot;&gt;queue&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt; SoftReference softRef = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; SoftReference&amp;lt;Object&amp;gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Person(“王酒”,&lt;span class=&quot;code-snippet__number&quot;&gt;15&lt;/span&gt;),&lt;span class=&quot;code-snippet__built_in&quot;&gt;queue&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;使用很简单softRef.get即可获取对应的value。&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.757396449704142&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TwK74MzofXf24ZSVT75Ry6DeTichH884xW9fMic3sMkkRkfx5GiaToyKGr8Tia93XbNZSKfk4zibH9NmQmCK5Zw1wGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1352&quot;/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;WeakReference&amp;lt;Person&amp;gt; weakReference = new WeakReference&amp;lt;&amp;gt;(new Person(“浪尖”，18));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;声明一个引用队列&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;ReferenceQueue&amp;lt;Person&amp;gt; queue = new ReferenceQueue&amp;lt;&amp;gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;声明一个person对象，李四，obj是其强引用&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Person obj = new Person(“李四”,13);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;声明一个弱引用，指向强引用obj所指向的对象，同时该引用绑定到引用队列queue。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;WeakReference weakRef = new WeakReference&amp;lt;Object&amp;gt;(obj,queue);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;使用弱引用也很简单，weakRef.get&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.75&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TwK74MzofXf24ZSVT75Ry6DeTichH884x1CuMwib2yzDBicvTPo8WTEVufbr6QIYiagEHNiaoIPibUu3MrwkibLRZPqicw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1352&quot;/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;声明引用队列&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;ReferenceQueue queue = new ReferenceQueue();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;声明一个虚引用&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;PhantomReference&amp;lt;Person&amp;gt; reference = new PhantomReference&amp;lt;Person&amp;gt;(new Person(“浪尖”,18), queue);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;获取虚引用的值，直接为null，因为无法通过虚引用获取引用对象。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;System.out.println(reference.get());&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7305475504322767&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TwK74MzofXf24ZSVT75Ry6DeTichH884xh2MXkTu3T1UuM0f0NLkDIEPEId7XicZMFoicyCNpvx5uLvxc2sxCYv1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1388&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.619277108433735&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TwK74MzofXf24ZSVT75Ry6DeTichH884xFSmT6NLDHubOKfThicXxDgia4jyDZgGQXDwxV56qibwpSe9FehXZHOpsQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;830&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7540263543191801&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TwK74MzofXcZZVaX1iaUia4y07rBHv89eV6wx7Apb1ibOz0vhdLFblyXgHx4AeluiaRymp5fEJtDdNVibZx8YdjNKHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1366&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;四 Threadlocal如何使用弱引用&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7540983606557377&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TwK74MzofXf24ZSVT75Ry6DeTichH884xicynMZJVqnBhy99JwlibArBLoxFSV66NupiaHfxicS0PeB9tpKk5e4CheQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1342&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.43509615384615385&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TwK74MzofXf24ZSVT75Ry6DeTichH884x3SD587Hp8voxMI7J7QLDHf9ibuqaZg0on9WPDlnGvKiadibSWV9sxJo5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;832&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;五 spark如何使用弱引用进行数据清理&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.76&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TwK74MzofXf24ZSVT75Ry6DeTichH884xoFV0QQeV15BEGwrH9AdlJR51kStVnZZy6yX983PicVotEzk2y734I6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1350&quot;/&gt;&lt;/p&gt;&lt;p&gt;shuffle相关的引用，实际上是在ShuffleDependency内部实现了，shuffle状态注册到ContextCleaner过程：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;p&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  _rdd.sparkContext.cleaner.foreach(_.registerShuffleForCleanup(this))&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;然后，我们翻开registerShuffleForCleanup函数源码可以看到，注释的大致意思是注册ShuffleDependency目的是在垃圾回收的时候清除掉它对应的数据：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;python&quot;&gt;&lt;p&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/** Register a ShuffleDependency for cleanup when it is garbage collected. */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  def registerShuffleForCleanup(shuffleDependency: ShuffleDependency[_, _, _]): Unit = {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    registerForCleanup(shuffleDependency, CleanShuffle(shuffleDependency.shuffleId))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;其中，registerForCleanup函数如下：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;p&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/** Register an object for cleanup. */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  private def registerForCleanup(objectForCleanup: AnyRef, task: CleanupTask): Unit = {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    referenceBuffer.add(new CleanupTaskWeakReference(task, objectForCleanup, referenceQueue))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;referenceBuffer主要作用保存CleanupTaskWeakReference弱引用，确保在引用队列没处理前，弱引用不会被垃圾回收。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;p&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/**&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   * A buffer to ensure that `CleanupTaskWeakReference`s are not garbage collected as long as they&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   * have not been handled by the reference queue.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  private val referenceBuffer =&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Collections.newSetFromMap[CleanupTaskWeakReference](new ConcurrentHashMap)&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;ContextCleaner内部有一个线程，循环从引用队列里取被垃圾回收的RDD等相关弱引用，然后完成对应的数据清除工作。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;p&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  private val cleaningThread = new Thread() { override def run(): Unit = keepCleaning() }&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;其中，keepCleaning函数，如下：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;p&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; /** Keep cleaning RDD, shuffle, and broadcast state. */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  private def keepCleaning(): Unit = Utils.tryOrStopSparkContext(sc) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    while (!stopped) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      try {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        val reference = Option(referenceQueue.remove(ContextCleaner.REF_QUEUE_POLL_TIMEOUT))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          .map(_.asInstanceOf[CleanupTaskWeakReference])&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // Synchronize here to avoid being interrupted on stop()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        synchronized {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          reference.foreach { ref =&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            logDebug(&quot;Got cleaning task &quot; + ref.task)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            referenceBuffer.remove(ref)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            ref.task match {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              case CleanRDD(rddId) =&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                doCleanupRDD(rddId, blocking = blockOnCleanupTasks)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              case CleanShuffle(shuffleId) =&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                doCleanupShuffle(shuffleId, blocking = blockOnShuffleCleanupTasks)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              case CleanBroadcast(broadcastId) =&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                doCleanupBroadcast(broadcastId, blocking = blockOnCleanupTasks)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              case CleanAccum(accId) =&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                doCleanupAccum(accId, blocking = blockOnCleanupTasks)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              case CleanCheckpoint(rddId) =&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                doCleanCheckpoint(rddId)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      } catch {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        case ie: InterruptedException if stopped =&amp;gt; // ignore&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        case e: Exception =&amp;gt; logError(&quot;Error in cleaning thread&quot;, e)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;shuffle数据清除的函数是doCleanupShuffle，具体内容如下：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;p&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/** Perform shuffle cleanup. */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  def doCleanupShuffle(shuffleId: Int, blocking: Boolean): Unit = {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    try {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      logDebug(&quot;Cleaning shuffle &quot; + shuffleId)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      mapOutputTrackerMaster.unregisterShuffle(shuffleId)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      shuffleDriverComponents.removeShuffle(shuffleId, blocking)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      listeners.asScala.foreach(_.shuffleCleaned(shuffleId))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      logDebug(&quot;Cleaned shuffle &quot; + shuffleId)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } catch {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      case e: Exception =&amp;gt; logError(&quot;Error cleaning shuffle &quot; + shuffleId, e)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;细节就不细展开了。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7276657060518732&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TwK74MzofXcZZVaX1iaUia4y07rBHv89eVao7fOh3LpKIOaDlecNjqyCbTkQhD0cfe6c1TMZ0q9XtTJQqhvDRN3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1388&quot;/&gt;&lt;/p&gt;&lt;p&gt;ContextCleaner的start函数被调用后，实际上启动了一个调度线程，每隔30min主动调用了一次System.gc()，来触发垃圾回收。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;p&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; /** Start the cleaner. */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  def start(): Unit = {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    cleaningThread.setDaemon(true)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    cleaningThread.setName(&quot;Spark Context Cleaner&quot;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    cleaningThread.start()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    periodicGCService.scheduleAtFixedRate(() =&amp;gt; System.gc(),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      periodicGCInterval, periodicGCInterval, TimeUnit.SECONDS)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;具体参数是：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;p&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;spark.cleaner.periodicGC.interval&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7522123893805309&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TwK74MzofXf24ZSVT75Ry6DeTichH884xfyHicMbfLDer26zfSDL4rgib8ZaLAnq2MEZoeusjicibMUJVkWKIBhpViaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1356&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;推荐阅读：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMDA4OTY3MQ==&amp;amp;mid=2247492329&amp;amp;idx=2&amp;amp;sn=3bae810898a5713feceeb683ad6b2f69&amp;amp;chksm=f9ed1bc1ce9a92d78b6693f70282258bdf828574a101020e11c2f4ab9590bb8d289955bdacf6&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Hbase Bulkload 原理｜面试必备&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMDA4OTY3MQ==&amp;amp;mid=2247492168&amp;amp;idx=1&amp;amp;sn=2fe29c3d1da61c33ba45117a9d128a61&amp;amp;chksm=f9ed1b60ce9a9276ec9202ede19eb2d917f41da5e16c588e803a4f80a1ba506e71cf91173364&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;漫画｜讲解一下如何写简历&amp;amp;项目&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMDA4OTY3MQ==&amp;amp;mid=2247491877&amp;amp;idx=1&amp;amp;sn=2eda60d6a7774713d0a75520bad1a8bb&amp;amp;chksm=f9ed180dce9a911bce206748a64eb0e3548580fb8c7ff6b9db61789113d44b816c8070f3fa43&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;漫画面试回答kafka为何如此之快｜满分&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMDA4OTY3MQ==&amp;amp;mid=2247491417&amp;amp;idx=1&amp;amp;sn=5b94f1c1ab2226503face1d6c61a2c23&amp;amp;chksm=f9eee671ce996f67776ee4a7bc2c262c918eb775dd2dde6e2ad309476163152694e3f143511e&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;漫画全面解释Spark企业调优点&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6764091858037579&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TwK74MzofXeFzuCNYd7EAPsScZvZ6KhcWvvLhicX9SVRibv8pY7MtyrEYicyrfXfae9E6OQbUtIUr4bicpKBJSFNmA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;958&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;点个在看 你最好看&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.8&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ImtD1PjRzRibmwqBpXL6icIKqbwdwwR26NfB89hJ09AJCorfLHxNdGlIIKr02IiajJ3O6t3qzXFXcJZ1lUxUnibTIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;50&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d7c5088e35dc4005008d9237984d98de</guid>
<title>备受争议的 PHP 前景究竟如何？我们该何去何从？</title>
<link>https://toutiao.io/k/rvi2msw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-content article-content&quot; id=&quot;post-content&quot;&gt;
                                &lt;p&gt;导语：&lt;/p&gt;
&lt;p&gt;最近以来，小编在网上总是会看到这样或那样的关于php的新闻或者信息。比如，PHP一直是被黑。尤其是一些培训机构不断设置编程语言排名，以促进python和Java等语言的培训，从而误导了编程的初学者，并给初学者以PHP不好的印象。&lt;br/&gt;
&lt;img src=&quot;https://wjcms.oss-cn-beijing.aliyuncs.com/blog//v2-054788b296eea7845fb936e7659d22c4_720w_1605351728440.jpg?x-oss-process=style/watermark&quot; alt=&quot;v2054788b296eea7845fb936e7659d22c4_720w.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;PHP真的下坡了吗？ PHP语言占据什么市场份额？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从市场份额来看。您可能需要根据W3Techs提供的数据和报告，查看最新的PHP使用情况统计信息和市场地位。 W3Techs是一个外国网站，专门从事网络技术研究，并提供有关各种网络技术使用的信息。从最新的结果中，我们可以看出其服务器端编程语言的所有网站中，有79％使用PHP，稳居第一！将排在第二位的ASP.NET和第三位的JAVA远远甩在身后。&lt;br/&gt;
&lt;img src=&quot;https://wjcms.oss-cn-beijing.aliyuncs.com/blog//20201114151307_1605351744130.jpg?x-oss-process=style/watermark&quot; alt=&quot;20201114151307.jpg&quot;/&gt;&lt;br/&gt;
而且，从十月以来全球增长的网站来看，php也排在第二位。&lt;br/&gt;
&lt;img src=&quot;https://wjcms.oss-cn-beijing.aliyuncs.com/blog//20201114151037_1605351758310.jpg?x-oss-process=style/watermark&quot; alt=&quot;20201114151037.jpg&quot;/&gt;&lt;br/&gt;
从编程语言排名来看。PHP自2001年该指数开始以来，PHP一直处于TIOBE指数的前10位，地位从未动摇。&lt;br/&gt;
&lt;img src=&quot;https://wjcms.oss-cn-beijing.aliyuncs.com/blog//20201114121130_1605351783248.jpg?x-oss-process=style/watermark&quot; alt=&quot;20201114121130.jpg&quot;/&gt;&lt;br/&gt;
而且，PHP常年平均排名处于前列，第四位和第七位，它甚至是2004年TIOBE的年度编程。&lt;br/&gt;
&lt;img src=&quot;https://wjcms.oss-cn-beijing.aliyuncs.com/blog//20201114121226_1605351789877.jpg?x-oss-process=style/watermark&quot; alt=&quot;20201114121226.jpg&quot;/&gt;&lt;br/&gt;
从语言发展来看。PHP最受争议的“弱类型”特性，但是随着语言版本的发布和完善，功能和特性方面的批评开始变少了。HHVM通过hack直接“删除”“弱类型”功能的事实表明HHVM不喜欢“弱类型”功能。但是，在许多PHP程序员看来，这是PHP的主要优势之一。 PHP变量的设计随意而优雅，可向所有河流开放，并为一切准备就绪。语言不是很简单吗？HHVM对PHP的性能提升，让人眼前一亮，而磨刀霍霍的PHP7则让人万分期待。&lt;/p&gt;
&lt;p&gt;还有另外一个最受争议的性能问题，就在前几天刚发布了8.0.0RC4,11月 26 日就会发布正式版本。从&lt;a href=&quot;https://www.phoronix.com/测试性能基准测试报告结果来看，从&quot;&gt;https://www.phoronix.com/测试性能基准测试报告结果来看，从&lt;/a&gt; PHP 7.4 stable 到 PHP 8 有小幅度改进，大约是 7% 的提升，但如果 PHP 8 启用了 JIT，性能改进可以说是非常明显，比 PHP 7.4 stable 提升了 92%。至于更旧的版本，PHP 8 with JIT 的性能是 PHP 5.4 的 5 倍。&lt;br/&gt;
&lt;img src=&quot;https://wjcms.oss-cn-beijing.aliyuncs.com/blog//060022_kYvL_2720166_1605351856641.png?x-oss-process=style/watermark&quot; alt=&quot;060022_kYvL_2720166.png&quot;/&gt;&lt;br/&gt;
最重要的是，越来越多优秀的扩展开发出来，给初中级开发者铺好了更多道路，发挥好社区化开发的路径，能为快速构建出自己的项目，高级程序员能够轻松利用特性，开发出更多好的扩展，构建更强大的生态系统。&lt;/p&gt;
&lt;p&gt;非常多的优秀框架支撑php的强大，例如Symfony/YII/laravel/thinkphp/CI等，在类似项目中重用代码可以节省开发人员大量时间和精力。框架提供了用于执行繁琐的代码任务的预构建模块。因此，开发人员可以花时间开发实际的应用程序，而不必重建每个项目的基本功能。&lt;/p&gt;
&lt;p&gt;结语：&lt;/p&gt;
&lt;p&gt;PHP是有史以来最好的语言，没有之一。PHP一直作为Web开发中的统治力量而存在，在PHP8.0版本的加持下，PHP必将开创新局面，许多PHP专业人员都留在角落，实际上，每个人都必须接受PHP带来的变化和生态。 Swoole解决了IO繁重方案的问题，而JIT解决了计算繁重方案的问题。未来的PHP开发还不错。最后希望大家都成为一名优秀的CTO和架构师。&lt;/p&gt;

                            &lt;/div&gt;
                            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>