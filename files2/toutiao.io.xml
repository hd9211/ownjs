<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>c991d74de44ec6e46fbaa8a83f979623</guid>
<title>我们是如何变普通的？</title>
<link>https://toutiao.io/k/t7l9mpf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;p&gt;&lt;span&gt;前段时间，特别火的一段话就是：&lt;/span&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;23&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;23&quot;&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section&gt;“&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;人这一生有三个阶段：懂得父母是普通人，接受自己是普通人，允许孩子是普通人。&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;也许很多人最终都会活成普通人，那我们是如何由一个个有梦想的热血青年逐步变成为普通的样子呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;最近个人的一点思考，分享给大家~&lt;/span&gt;&lt;/p&gt;&lt;section data-id=&quot;t3&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p data-markdown=&quot;&quot;&gt;&lt;strong&gt;&lt;span&gt;1、出身影响认知&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;我们每人的出身各异，但最不可控的就是我们的出身。&lt;/span&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86005&quot;&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;伴随一阵阵哇哇的哭声，婴儿呱呱坠地，我们降生于世，无法选择，或出于富贵，或生于贫穷，而更多的人出生在芸芸的普通家庭中。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;出身环境差异影射到我们的身上成为了什么，是从根本上的决定了我们的人生轨迹吗？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不，是&lt;strong&gt;认知上的差距&lt;/strong&gt;，不好的出身环境往往从&lt;strong&gt;根本上切断了我们认知的机会&lt;/strong&gt;！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;出身环境差带给我们最大的遗憾不是那些富家子弟才有的资源、平台和机会，而是我们失去的正确认知的机会。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;差的出身环境下，你接触最多的就是面朝黄土背朝天，接触最多的就是做家务，照顾家里人.....&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们在没有足够的资源支持情况下，哪里来的保障来让你更多的学习机会，更多的认知成长与进步呢。&lt;/span&gt;&lt;/p&gt;&lt;section data-id=&quot;t3&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p data-markdown=&quot;&quot;&gt;&lt;strong&gt;&lt;span&gt;2、选择偏差&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;认知的不足，往往有或多或少的带来选择上的偏差，因为你不能对选项做全面的分析判断。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在一个事务你都不能全面认识分析的情况下来做选择，多半都是不太靠谱的选择。&lt;/span&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86005&quot;&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;当我们在面临上学或者择业的情况下，是我们自己选择还是求助于父母或者老师？那又有多少人的父母和身边的老师真正了解他们建议你选择的专业？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很多时候，他们只是觉得这个专业好，或曾经听别人说过这个专业好，再者经过他们已有的阅历和经验分析出，这个专业好。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;我们的选择出现选择偏差，大部分原因是&lt;strong&gt;我们对问题的认识不足&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而有些人，会对问题有充分的认识，一次次做着对他最有利的选择，而在一次次选择间，人与人的差距会被逐渐拉大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总有些事，必须经历才知道；总有些事，也许一辈子也认识不到。&lt;/span&gt;&lt;/p&gt;&lt;section data-id=&quot;t3&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p data-markdown=&quot;&quot;&gt;&lt;strong&gt;&lt;span&gt;3、自我和解&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;我们由于出身不好，没有良好的认知，或由于选择上的偏差，导致最终我们过着和我们所预期不一样的生活，却告诉自己「&lt;strong&gt;这样也挺好&lt;/strong&gt;」&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们承认人与人之间存在智商上的差异，但是实际上差异并不大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当我们发现短期的努力无法带来超额的回报，就因此放弃了努力。&lt;/span&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86005&quot;&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;比如追女生，不是跟妹子交往一个礼拜就可以表白成功；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如学习编程，不是自己啃一个礼拜《编码大全》就可以完美解决实际工作中形形色色的问题；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如学习投资，不是研究一个礼拜的巴菲特就可以投资赚钱了。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;人们总是重视短期的努力所达成的效果，而轻视长期的付出所带来的的回报。一旦短期努力达不到自己想要的成就，就不愿意再去付出了，就学会了&lt;strong&gt;自我和解&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;觉得一切就这样，凑合吧，这样也挺好的，最后成为了一名庸庸碌碌的普通人......&lt;/span&gt;&lt;/p&gt;&lt;section data-id=&quot;t3&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p data-markdown=&quot;&quot;&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;不同的出身，认知的差距，让我们做出了不同的选择，人与人的间距开始拉大；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;选择偏差，让我们会走了更多的弯路，直到自我否定。&lt;/span&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86005&quot;&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;2006年，湖南卫视的《变形记》首播，几年的热潮之后，其背后的社会问题引发的众人思考：“那些被交换出去的农村孩子，如何接受自己再次回到农村所产生的落差”&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2013年，一篇名为《寒门再难出贵子》的文章大火，作者的观点是：“那些学习更好，能力更强的孩子往往出现在富裕家庭”&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;曾几何时，我们本可以走出舒适圈，向现在的自己挑战。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们本可以选择终身学习，不断去学习改善，形成我们正确的认知；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;成为一个普通人真的so easy，破除这个壁垒的办法，就是&lt;strong&gt;终其一生去阅读，去践行，去纠正谬误&lt;/strong&gt;，无他。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;往期热文推荐：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;98311&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;395&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;395&quot; data-ratio=&quot;0.36484375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgSxEpr7AzM5lGCicdEjfuE6jaiae9Rmj1CVCg85GJKaFKuico89ZlnhGicQiciciccOiaqVibE5cmKXwO1AOuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;87502&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;「技术架构精进」专注分享&lt;/span&gt;&lt;span&gt;技术架构、团队管理及商业认知等&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Thanks for reading!&lt;/span&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;28&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;28&quot;&gt;&lt;p data-brushtype=&quot;text&quot;&gt;&lt;span&gt;如果您觉得还不错，欢迎关注和转发~&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ee79897d0a633f7e837c6ccccd66e157</guid>
<title>厂商 push 不通排查指南</title>
<link>https://toutiao.io/k/r5ml6u2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.19278996865203762&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/Ly9fQtHVgNnmeyR6Hpv9ZG1hDZsaickf3YiatpjQoBom6XibWhK2Wh9SE7qYJP5IVSiazNakU7UuiaOCnKnhQGQkppw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;638&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p data-lake-id=&quot;6f771e83d5768b536eecda5bddf515e5&quot;&gt;&lt;span data-mce-style=&quot;font-size: 9px&quot;&gt;为了提升&lt;/span&gt;&lt;span data-mce-style=&quot;font-size: 9px&quot;&gt;&lt;strong&gt;「MPS 消息推送」&lt;/strong&gt;&lt;/span&gt;&lt;span data-mce-style=&quot;font-size: 9px&quot;&gt;的推送的到达率，mPaaS 集成了华为、小米等厂商的推送功能，从而有效地提高用户留存率，提升用户体验。在日常运维过程中，发现少部分设备在厂商 push下无法 push，在此分享下相关案例的排查过程，方便后续同类问题借鉴。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-lake-id=&quot;8189700b86f5d1fb6bc0b5cade7aadf5&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;d8ffc7ad6e8fb69b8cb5a70a03d33345&quot;&gt;&lt;/p&gt;&lt;h2 data-lake-id=&quot;30f9ec1e13577b02aa91930dd5f0fdfd&quot;&gt;一、push 相关背景&lt;/h2&gt;&lt;h3 data-lake-id=&quot;26747029f471ef8f96634556e616d130&quot;&gt;1. push 整体架构&lt;/h3&gt;&lt;p data-lake-id=&quot;a6f9d178348cbe37ac7410db8ed17ef2&quot;&gt;&lt;span&gt;以接触最多的国内 Android 设备为例，整体结构如下：&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;3ad4dc7f69d98a4d5bd84e885c949ca3&quot;&gt;&lt;img data-height=&quot;593px&quot; data-ratio=&quot;0.706&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ly9fQtHVgNnmeyR6Hpv9ZG1hDZsaickf3ibzZUgVeeKm3O5WEH0jNdpA92BmXgZfxcCQnbzQo7sfL2OorEw8gfCg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1500&quot; title=&quot;image&quot;/&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;d980e2d2a7e52fd73efd79a2dfaed95c&quot;&gt;&lt;em&gt;&lt;span data-mce-style=&quot;font-size: 9px&quot;&gt;公众号后台回复“MPS排查”了解更多详情&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;36d98a9455b84f823eba07ebe2fa7e66&quot;&gt;&lt;/p&gt;&lt;h3 data-lake-id=&quot;439452d0bcd43159e85dcafc8f8efc68&quot;&gt;2. 厂商 push 和自建 push&lt;/h3&gt;&lt;p data-lake-id=&quot;18dee12bd3b9e7fe43b1fcbe15ac1476&quot;&gt;&lt;span&gt;厂商 push 通道：优点是通过各个 OS 厂商维护的长链接进行推送，在 App 被系统杀掉后也可以进行推送，推送到达率高于自建push。支持华为，小米，oppo，vivo等厂商。缺点是，目前厂商的push基本都只支持通知栏消息的推送，&lt;span&gt;&lt;strong&gt;在用户点击通知前，不启动应用&lt;/strong&gt;&lt;/span&gt;，对红点, 图片等消息格式支持有限。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;34be2fbca5bacf4a9adf8c210e7d9dcb&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;378b3cc6bc4ebe78a90b699309e878ac&quot;&gt;&lt;span&gt;自建push通道：通过App启动后和自建服务端的长连接通道实现推送，缺点也很明显，App被杀掉后，就无法收到信息。主要用于不支持厂商渠道场景下的push。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;c7b90ee176559d5a129faa6a2c39747c&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;2e3020082cdfcf3c3f7568702f4c9d96&quot;&gt;&lt;/p&gt;&lt;h2 data-lake-id=&quot;47d375b119b2ce83c109c7b881ebf52b&quot;&gt;二、问题排查举例&lt;/h2&gt;&lt;p data-lake-id=&quot;efcee40a16650164b76023965bbb9321&quot;&gt;&lt;span&gt;通过上面的介绍，可以看出三方厂商 push 是否成功，主要取决于三个链路，分别为：&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;caa7e59f6891ee56a091dc69936e1441&quot;&gt;&lt;span&gt;1.三方 token 正确生成上报&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;63b0cc5043fd129b31c1480c3dfe2c06&quot;&gt;&lt;span&gt;2.服务端正常转发到厂商服务器  &lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;e7b970bf799004683d70c2316a3ae459&quot;&gt;&lt;span&gt;3.下发到客户端消息可以正常显示&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;ed485673ca5b3e63870ddafa729cdcf7&quot;&gt;&lt;/p&gt;&lt;h3 data-lake-id=&quot;26aade090d8bf4534b3a80a5bc1f7e31&quot;&gt;1. 测试准备&lt;/h3&gt;&lt;p data-lake-id=&quot;548e50407a1c8428122ecd6d516c413d&quot;&gt;&lt;span&gt;为了快速验证问题，我们需要准备一个推送程序，可以快速推送信息到 App 上。MPS 提供了推送的 Http 接口供外部调用，我们可以通过初始化一个简单的 Java 程序实现推送信息的发送，方便联调。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;8d0810280c2effa112eb54e713f8c9c2&quot;&gt;&lt;img data-height=&quot;168px&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ly9fQtHVgNnmeyR6Hpv9ZG1hDZsaickf3ic6t1UVh8JDUr8ZiamE4SgvxObcn7OnniclzWLE0VHicok5VkssCxeCEvA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;256&quot; title=&quot;image.png&quot;/&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;fd225bdcae0cd197858de48fa9b99d4f&quot;&gt;&lt;em&gt;&lt;span data-mce-style=&quot;font-size: 9px&quot;&gt;扫描二维码了解服务端 API 说明&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;62461b77fe345fdf553f9f9ecf3033cf&quot;&gt;&lt;/p&gt;&lt;h3 data-lake-id=&quot;704d69b215ed78fce520509c29360b0b&quot;&gt;2. 三方 token 生成阶段&lt;/h3&gt;&lt;p data-lake-id=&quot;097cb5c5e9bf09963eee954f17c4b6cf&quot;&gt;&lt;span&gt;目前 mPaaS 对三方厂商 push 的 token 生成分为以下步骤。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;06c93386a278b70121aedadee756d3fc&quot;&gt;&lt;/p&gt;&lt;h4 data-lake-id=&quot;d68b4ff53df75e7156dce1e884ed4dd8&quot;&gt;2.1 设备在三方push的厂商列表里&lt;/h4&gt;&lt;p data-lake-id=&quot;cffb57a31dd4f0ec2868b99fbcc4ebb9&quot;&gt;&lt;span&gt;以华为设备为例，判断是否是华为设备的标准是，检测当前手机是否是 emui，如果是才走华为 PUSH SDK。在我们日常运维的 case 中，发现过部分设备由于刷机或者其他操作，在华为手机上安装的不是 emui，类似这种设备是走不了华为 push 的，只能走自建 push。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;d9d45d0c99746b65168a32c768d2dea1&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;c007903dee3d9dada4e90f909f056875&quot;&gt;&lt;span&gt;以vivo设备为例，低版本手机只有在vivo公布的白名单设备内才支持推送。 &lt;/span&gt; &lt;/p&gt;&lt;p data-lake-id=&quot;29300dfbe0e3fa0ffa74f6d88e89032a&quot;&gt;&lt;img data-height=&quot;1078px&quot; data-ratio=&quot;1.2833935018050542&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ly9fQtHVgNnmeyR6Hpv9ZG1hDZsaickf3huOpI93K3faO2MibZ0SEXicbGXiaTas0XlfQQYd5seO2kAENPPA6SgEKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot; title=&quot;image&quot;/&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;c72ba6c27e7c25c598ab7393fe09e122&quot;&gt;&lt;em&gt;&lt;span data-mce-style=&quot;font-size: 9px&quot;&gt;*资料来源于 VIVO 官网&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;3e01e4b2bbfdbd69613166105126642d&quot;&gt;&lt;/p&gt;&lt;h4 data-lake-id=&quot;3b2e48bab70fd9f20b617492b85eee35&quot;&gt;2.2 生成三方 token&lt;/h4&gt;&lt;p data-lake-id=&quot;b626c2aa189dc6a2ddff8d08cc3eaff2&quot;&gt;&lt;span&gt;在调用 push sdk 生成 token 的过程中，由于 push sdk 的生成也依赖当前手机的 room 版本，以华为为例，就强依赖华为手机内置的 HMS Core 版本。针对这种场景下的问题，在获取三方 token 失败的时候，会在回调里返回对应错误码。如下图所示，搜索 push 的关键字 mPush14，然后过滤，可以获取 token 返回错误码2。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;bf218b3822b85be5d4f57f29af90f97c&quot;&gt;&lt;img data-height=&quot;198px&quot; data-ratio=&quot;0.23525469168900803&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ly9fQtHVgNnmeyR6Hpv9ZG1hDZsaickf3eCqgjtegnzRYJicOZSpibrNpvRPMVQL1QE3I7V5uIRicnj2Iwua2SJKOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1492&quot; title=&quot;image&quot;/&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;bdb87bf0629742aa3fa822473a502c0a&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;54393be622d51dc1f2732448fc42f1e8&quot;&gt;&lt;span&gt;我们查看华为定义的错误码，发现2表示 SERVICE_VERSION_UPDATE_REQUIRED，需要升级当前的 HMS 版本。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;cc8eda4740786a7c5a69ab3e24253d14&quot;&gt;&lt;img data-height=&quot;128px&quot; data-ratio=&quot;0.15281501340482573&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ly9fQtHVgNnmeyR6Hpv9ZG1hDZsaickf3MibVN65JLcJEboqmRawcPcu7cvmQRnjn4bicSPnOTG5jpWzkFqX6Nq9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1492&quot; title=&quot;image&quot;/&gt;&lt;em&gt;&lt;span data-mce-style=&quot;font-size: 9px&quot;&gt;*资料来源于华为官网&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;f12f247bf9cc25f627db0a570e00cb4b&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;f8a79843e830b29c478a17322f5cb7b9&quot;&gt;&lt;span&gt;升级HMS版本的方案有两个&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;6b3fbd8aa222f36ae767854d3779ffd7&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;2f3332c102bbe93ff0bb8ad83467ff60&quot;&gt;&lt;span&gt;方案1：主动升级,调用更新服务接口,升级更新效果如下所示：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;在启动阶段调用如下服务，安装更新华为推送服务&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (HuaweiApiAvailability.getInstance().isHuaweiMobileNoticeAvailable(context) == ConnectionResult.SERVICE_VERSION_UPDATE_REQUIRED) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  HuaweiApiAvailability.getInstance().resolveError(activity, ConnectionResult.SERVICE_VERSION_UPDATE_REQUIRED, &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;span/&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p data-lake-id=&quot;309b9eddf034da4067d737457e9d5412&quot;&gt;&lt;img data-height=&quot;382px&quot; data-ratio=&quot;0.45441176470588235&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ly9fQtHVgNnmeyR6Hpv9ZG1hDZsaickf3bMsb7fiauOqicaoYa8S81yiawFMm4EYYNEPEJxtibEh4INtxBic0nnnia0yg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1360&quot; title=&quot;image&quot;/&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;0b50ad227f347c50eec3ac52aa8398ae&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;4632cad6649da2382ee5d190a1124085&quot;&gt;&lt;span&gt;方案2：&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;更新 HMS Core（华为移动服务）到最新版本&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;cd8c18f81d61ec5bcc2f63a364c12bd1&quot;&gt;&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;&lt;img data-height=&quot;553px&quot; data-ratio=&quot;0.6606929510155317&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ly9fQtHVgNnmeyR6Hpv9ZG1hDZsaickf3xHLOZsV9aIXeUP8dediciaricCkk5jFMrD4XRJYCChjIc4Sf3CUK7Touw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;837&quot; title=&quot;image.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;cc427a3778f51d996aa39e175d831fb9&quot;&gt;&lt;em&gt;&lt;span data-mce-style=&quot;font-size: 9px&quot;&gt;图片内容来自于华为官网&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;71db3a102f2aa406f2c62d6e6bdb3e88&quot;&gt;&lt;/p&gt;&lt;h4 data-lake-id=&quot;559cc12dae0939b15d10701b101a8314&quot;&gt;2.3 三方 token 正常上报&lt;/h4&gt;&lt;p data-lake-id=&quot;c6dbc5bd1a97339b90899b40ccea8e9b&quot;&gt;&lt;span&gt; 生成 token 后会通过 RPC 接口上报到 MPS 服务端，需要检查 RPC 接口是否有异常，上报接口是：alipay.client.yunpushcore.device.report&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;876e0f5d8c10a0d5c6ac08d722aa212b&quot;&gt;&lt;img data-height=&quot;97px&quot; data-ratio=&quot;0.116&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ly9fQtHVgNnmeyR6Hpv9ZG1hDZsaickf3Nozo1OT7e7CoHAibcyGHNF8v7ibJvsghFBAzbCryXtcYyC44Qbml33Nw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1500&quot; title=&quot;image&quot;/&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;cc97c72e5d492a681307dc518aa1981b&quot;&gt;&lt;/p&gt;&lt;h4 data-lake-id=&quot;496010569a42852c3e2c114694bc600c&quot;&gt;2.4 token 过期&lt;/h4&gt;&lt;p data-lake-id=&quot;a3dbab0f71614ff92a37076c89665122&quot;&gt;&lt;span&gt;以 oppo 为例，是在应用第一次启动时注册生效，后在刷机、还原手机（设置-其他设置-还原手机）、卸载应用时会失效，需要重新注册才能推送。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;ace8810e51f806950044ae9c729b2226&quot;&gt;&lt;img data-height=&quot;622px&quot; data-ratio=&quot;0.7405582922824302&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ly9fQtHVgNnmeyR6Hpv9ZG1hDZsaickf3pScbRSFkFExVyBmPpXMibuTYQPEACnj1ibAiawMZdrponDtDgxuAKHnaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1218&quot; title=&quot;image&quot;/&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;641ee554e64bd24a57dbf23f667c1ebf&quot;&gt;&lt;/p&gt;&lt;h3 data-lake-id=&quot;ac73320565befa7476583953a0157e10&quot;&gt;3. 服务端投送阶段&lt;/h3&gt;&lt;h4 data-lake-id=&quot;36bce7bf892b02d27f9b9326c37a1e1c&quot;&gt;3.1 消息包含了红点，静默，群发&lt;/h4&gt;&lt;p data-lake-id=&quot;89fd0dd96034cc38414d878dde47c392&quot;&gt;&lt;span&gt;目前如果消息设置了红点或者静默，因为厂商 push 不支持，MPS 会自动走自建 push。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;63adcb01fa1e64d6766ad7a4bbc900b9&quot;&gt;&lt;/p&gt;&lt;h4 data-lake-id=&quot;0aa638a5718a2103da4665e0ccbaaa15&quot;&gt;3.2 三方服务端报错&lt;/h4&gt;&lt;p data-lake-id=&quot;f9ecbdc30fb2d71bcfa0d5207f95c36c&quot;&gt;&lt;span&gt;这种主要用作 mPaaS 服务端推送到三方服务端后，三方返回异常。这种需要去 MPS 拉取服务端报错日志，然后核对厂商文档解决，比如华为服务端报错文档。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;b241a6b0198df4f9f31c6a10536f44ed&quot;&gt;&lt;/p&gt;&lt;h4 data-lake-id=&quot;ed97c716fac4a188760619283a8a8448&quot;&gt;3.3 三方服务端限流&lt;/h4&gt;&lt;p data-lake-id=&quot;9f5296ee3645b141b54166d74556f713&quot;&gt;以 vivo 为例，默认推送走的是运营消息，每天只能对同一个用户推送 5 次。只有改成系统 push 类型才能没有这个限制。&lt;/p&gt;&lt;h3 data-lake-id=&quot;4a3444ba9afeacf32b36e266f191cf01&quot;&gt;4. 设备显示阶段&lt;/h3&gt;&lt;h4 data-lake-id=&quot;7c8156a5f2974f3d1f73705db6126018&quot;&gt;4.1 设备必须打开通知权限才能显示&lt;/h4&gt;&lt;p data-lake-id=&quot;f9bc1d6b3969391b25cf1f8a7dd5359d&quot;&gt;比如 oppo 的通知权限默认是关闭的，需要打开通知权限，或者引导用户打开后才能显示。&lt;/p&gt;&lt;p data-lake-id=&quot;33fe52a8d4d8689c10337502eb23326a&quot;&gt;&lt;/p&gt;&lt;h4 data-lake-id=&quot;1e8d78159dcacd84a46d462af88a247a&quot;&gt;4.2 应用包名和注册 oppo 配置保持一致&lt;/h4&gt;&lt;p data-lake-id=&quot;b722629491095325007301d481230af0&quot;&gt;应用的包名要和注册 oppo 平台填写的包名要一致，不然不会显示。&lt;/p&gt;&lt;p data-lake-id=&quot;66ceb316fafa83561d690dcf8c6b2ac6&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;14a862b46fbfdc0d6d047fac40d70273&quot;&gt;&lt;/p&gt;&lt;h2 data-lake-id=&quot;8820f6bfaebf99ce260de4b76a654871&quot;&gt;三、其他常见问题&lt;/h2&gt;&lt;h3 data-lake-id=&quot;d4ce99300dfe2c8f9e5a81d662928a64&quot;&gt;1. 常用日志举例&lt;/h3&gt;&lt;h4 data-lake-id=&quot;022242f4da45ab9379397c21d557c780&quot;&gt;1.1 tag：mPush14&lt;/h4&gt;&lt;p data-lake-id=&quot;c8ccbdd02fee466b4122c8924f3c107e&quot;&gt;主要是 mPaaS 上层应用层日志打印，打印 push 注册 token 相以及自建通道 push 相关信息&lt;/p&gt;&lt;p data-lake-id=&quot;eb675e7fa937576991626cae8b0130f1&quot;&gt;&lt;img data-height=&quot;198px&quot; data-ratio=&quot;0.23525469168900803&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ly9fQtHVgNnmeyR6Hpv9ZG1hDZsaickf3eCqgjtegnzRYJicOZSpibrNpvRPMVQL1QE3I7V5uIRicnj2Iwua2SJKOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1492&quot; title=&quot;image&quot;/&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;b8b013cd14bff7a5654927f2ca3e8800&quot;&gt;&lt;/p&gt;&lt;h4 data-lake-id=&quot;b7e8fb70c3ca922cdb42805d2f4e6246&quot;&gt;1.2 tag: mcssdk&lt;/h4&gt;&lt;p data-lake-id=&quot;08628e250974c3b7df17841a3ee31721&quot;&gt;mcssdk 是 oppo push sdk 的日志 tag，可以查看厂商的一些日志信息，比如查看三方 token&lt;/p&gt;&lt;p data-lake-id=&quot;e3724f158d7b51ae0cf5da2e4db0d7c4&quot;&gt;&lt;span data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fintranetproxy.alipay.com%2Fskylark%2Flark%2F0%2F2020%2Fpng%2F290899%2F1606199835535-f8fbdaec-f7d5-4d95-b55b-237dcbfc7b01.png%22%2C%22originWidth%22%3A1500%2C%22originHeight%22%3A619%2C%22size%22%3A0%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22search%22%3A%22%22%2C%22margin%22%3A%7B%22top%22%3Afalse%2C%22bottom%22%3Afalse%7D%2C%22width%22%3A840%2C%22height%22%3A347%7D&quot;&gt;&lt;img data-height=&quot;347px&quot; data-ratio=&quot;0.4126666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ly9fQtHVgNnmeyR6Hpv9ZG1hDZsaickf30aKSSiapSeVGBODia14ueYxFG45h4nRqTjIiaesNEibUSJlibvpBjWaSpUw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1500&quot; title=&quot;image&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;14fe45f5b9709839fb9298caefa2c541&quot;&gt;&lt;/p&gt;&lt;h3 data-lake-id=&quot;a66e7b2a10d19a059c7e78f7f1161abf&quot;&gt;2. 其他思路&lt;/h3&gt;&lt;p data-lake-id=&quot;ec2a2ca0149847dccb6859dfbc12d0ee&quot;&gt;如果以上都解决不了，最后建议去看各个厂商的官方介绍，可能会找到一些思路。&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;p data-lake-id=&quot;3cd86401ba383d24aeaa69f6a564007d&quot;&gt;&lt;span data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fintranetproxy.alipay.com%2Fskylark%2Flark%2F0%2F2020%2Fpng%2F290899%2F1606377562629-2c4d433d-eb35-4e1c-be22-5f4537be84cf.png%22%2C%22originWidth%22%3A256%2C%22originHeight%22%3A256%2C%22name%22%3A%22image.png%22%2C%22size%22%3A46727%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22ocrLocations%22%3A%5B%5D%2C%22style%22%3A%22none%22%2C%22search%22%3A%22%22%2C%22margin%22%3A%7B%22top%22%3Afalse%2C%22bottom%22%3Afalse%7D%2C%22width%22%3A256%2C%22height%22%3A256%7D&quot;&gt;&lt;img data-height=&quot;256px&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ly9fQtHVgNnmeyR6Hpv9ZG1hDZsaickf3bja2rkHrOmP8u5CML4jEtwboFPiclicIeslm7wV4F96T43IUDaNHTpqA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;256&quot; title=&quot;image.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p data-lake-id=&quot;747788d225a117d8026deceae39f2fb4&quot;&gt;&lt;span data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fintranetproxy.alipay.com%2Fskylark%2Flark%2F0%2F2020%2Fpng%2F290899%2F1606377592094-fa9f1935-3f0a-4196-b77b-0a9f7ec9b7a6.png%22%2C%22originWidth%22%3A256%2C%22originHeight%22%3A256%2C%22name%22%3A%22image.png%22%2C%22size%22%3A42700%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22ocrLocations%22%3A%5B%5D%2C%22style%22%3A%22none%22%2C%22search%22%3A%22%22%2C%22margin%22%3A%7B%22top%22%3Afalse%2C%22bottom%22%3Afalse%7D%2C%22width%22%3A256%2C%22height%22%3A256%7D&quot;&gt;&lt;img data-height=&quot;256px&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ly9fQtHVgNnmeyR6Hpv9ZG1hDZsaickf3V1WiaXNHyfTNRj4QYpfxIAkrpHNHEHLymnH9qxmVP4XV2DjPPOslZYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;256&quot; title=&quot;image.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p data-lake-id=&quot;7ae63e3b44b0b97132b1b3bbd61cff2a&quot;&gt;vivo的faq&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p data-lake-id=&quot;a0e47856a79611bb8f264515f40475a3&quot;&gt;oppo的faq&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p data-lake-id=&quot;a9d0a5ca669106188176f630b1454034&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.42205882352941176&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;680&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Ly9fQtHVgNmkwhXMicTx6vM76libGhlcCYZ44RG3Hc8pRzGlj4icyOIVY37tTkV7JztyI2VicPqzzjtEicfVokCxwhQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;100704&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.8571428571428571&quot; data-type=&quot;png&quot; data-w=&quot;28&quot; data-width=&quot;100%&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ly9fQtHVgNkOxzgCHibFxrkDKQMnZ4ia7GWYG3w93KdBj03tXwzgxZ8FtBDA5IjdxhrsWktGhKlrd8VmjoIjylQA/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;mPaaS 登陆计划现已启动&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;01&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;活动规则&lt;/section&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p hm_fix=&quot;427:585&quot;&gt;&lt;span&gt;在2020年12月31日前，mPaaS MDS RPC 调用次数超过 5000 次的 mPaaS 用户，发送「UID」和「MDS RPC 调用次数」等证明实际调用量的截图后申领相应等级的礼物，由 mPaaS 官方核实后，进行发放。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;02&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;注意事项&lt;/section&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;本期活动礼品申领截至时间为2020年12月31日，但由于部分礼品数量有限，领完即止，您可选择申领其他满足条件的奖品或者等候下次「登陆」&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;120&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ly9fQtHVgNkOxzgCHibFxrkDKQMnZ4ia7GJQkt4b98ETe1K4IiaMicapSDGQMarpRaNmOmEz7WHZ5AFTgxNHFjPv7g/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;立即扫码，申领奖品&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-style-type=&quot;7&quot; data-tools=&quot;新媒体排版&quot; data-id=&quot;8663&quot;&gt;&lt;p&gt;&lt;span&gt;- &lt;strong&gt;END &lt;/strong&gt;-&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.1&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;800&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ly9fQtHVgNn8rstVfDv9pmtT4bLjphmE9ibjzMtp0CJxtiajyHY2FHl8hybIco0ic95eB1qEVRSawKUewKf8tJJmQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMDk2MzUzMQ==&amp;amp;mid=2247485765&amp;amp;idx=1&amp;amp;sn=c59e1466813959129bc1b4072bd19dd4&amp;amp;chksm=f9e31de1ce9494f72f2f2c03977d859c23aeafbfdf457100f06654dfe984520f91f7c7e1b69f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot; hasload=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.1578125&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Ly9fQtHVgNlaz7e87d7mbNFwy0tR9hVj6QucRLN1CTaQibRAIXjAufibeqBTVIia3C2jUHLpeSvvjmKOTicsjlOM4A/640?wx_fmt=jpeg&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMDk2MzUzMQ==&amp;amp;mid=2247485859&amp;amp;idx=1&amp;amp;sn=499fc8f5e8f663f810a63f62d9cfc82e&amp;amp;chksm=f9e31d07ce9494115d507ae05d3e713b73f82ff6b94c4212f641a1bb74f5552cd114eb29bc28&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.1578125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ly9fQtHVgNm5Jr4A4hmb8QKTl1n7uicZzRf01NprcbBCvicgqEib2WewggdRpcicibJufRgiaPELjCybicW8moWmOtUBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages __bg_gif&quot; data-ratio=&quot;0.3359173126614987&quot; data-s=&quot;300,640&quot; data-type=&quot;gif&quot; data-w=&quot;1548&quot; data-backw=&quot;357&quot; data-backh=&quot;120&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/Ly9fQtHVgNkW5XM01qD7S0PrzSL4XF4j8aP07jS3gN59VyiaInelAh9R0icHicaYmTnc9ev8xM4PK8HltbeQTOleQ/640?wx_fmt=gif&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;79&quot; data-ratio=&quot;0.214900947459087&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ly9fQtHVgNm5Jr4A4hmb8QKTl1n7uicZzqJ75oyzVLvGCkK9QhzGgc2Ux9GiaXicf7UUG4Ns1GMyr0YkTIU7fNeHQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2322&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;点击下方“&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;阅读原文&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;”，了解「MPS 消息推送」更多资讯&lt;/span&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a01cef26b4ca05705a84ea41e2e36c0a</guid>
<title>十张动图带你搞懂排序算法（附 Go 实现代码）</title>
<link>https://toutiao.io/k/ciar2yc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.3 代码示例(go实现)&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; uint64Slice []&lt;span&gt;uint64&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt;&lt;br/&gt; numbers := []&lt;span&gt;uint64&lt;/span&gt;{&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;}&lt;br/&gt; sortBubble(numbers)&lt;br/&gt; fmt.Println(numbers)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;sortBubble&lt;/span&gt;&lt;span&gt;(numbers uint64Slice)&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; length := &lt;span&gt;len&lt;/span&gt;(numbers)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; length == &lt;span&gt;0&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; flag := &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i:=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;length &amp;amp;&amp;amp; flag;i++{&lt;br/&gt;  flag = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; j:=length&lt;span&gt;-1&lt;/span&gt;;j&amp;gt;i;j--{&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; numbers[j&lt;span&gt;-1&lt;/span&gt;] &amp;gt; numbers[j] {&lt;br/&gt;    numbers.swap(j&lt;span&gt;-1&lt;/span&gt;,j)&lt;br/&gt;    flag = &lt;span&gt;true&lt;/span&gt; &lt;span&gt;// 有数据才交换&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 交换方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(numbers uint64Slice)&lt;/span&gt;&lt;span&gt;swap&lt;/span&gt;&lt;span&gt;(i,j &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; numbers[i],numbers[j] = numbers[j],numbers[i]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.4 复杂度分析&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分析一下他的时间复杂度吧。当最好的情况下，也就是要排序的表本身就是有序的，那么我们比较次数，根据我们的代码可以推断出来就是&lt;code&gt;n-1&lt;/code&gt;次的比较，没有数据交换，时间复杂度为&lt;code&gt;O(n)&lt;/code&gt;。当最坏情况下，即待排序表是逆序的，那么我们可以列出一个公式如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.16791044776119404&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/k5430ljpYPMpkFUr3BCNATOIkthtqYDYbAda1gXKm94zicKicwzk9klWzEUdTLBZmovsuSC51SsFwgiaGuog6cdFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;268&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;, 因此可以计算出冒泡排序的时间复杂度为&lt;code&gt;O(n2)&lt;/code&gt;。因为我们的代码在运行时运行过程中临时占用存储空间大小的量度没有变化，所以空间复杂度仍为&lt;code&gt;O(1)&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 快速排序&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1 算法步骤&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;从数列中挑出一个元素，称为 “基准”（pivot）;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2 动画演示&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.626984126984127&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/k5430ljpYPMpkFUr3BCNATOIkthtqYDYxS48ZupWFWP9gh7SMGu7KGJTvC2sXcXEamYzjsk4hrrhC0PSbJKQdA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;504&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.3 代码示例&lt;/span&gt;&lt;span/&gt;&lt;br/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; uint64Slice []&lt;span&gt;uint64&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; numbers := []&lt;span&gt;uint64&lt;/span&gt;{&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;20&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;}&lt;br/&gt; quickSort(numbers,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;len&lt;/span&gt;(numbers)&lt;span&gt;-1&lt;/span&gt;)&lt;br/&gt; fmt.Println(numbers)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;quickSort&lt;/span&gt;&lt;span&gt;(numbers uint64Slice,start,end &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; middle &lt;span&gt;int&lt;/span&gt;&lt;br/&gt; tempStart := start&lt;br/&gt; tempEnd := end&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; tempStart &amp;gt;= tempEnd{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; pivot := numbers[start]&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; start &amp;lt; end{&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; start &amp;lt; end &amp;amp;&amp;amp; numbers[end] &amp;gt; pivot{&lt;br/&gt;   end--&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; start&amp;lt;end{&lt;br/&gt;   numbers.swap(start,end)&lt;br/&gt;   start++&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; start &amp;lt; end &amp;amp;&amp;amp; numbers[start] &amp;lt; pivot{&lt;br/&gt;   start++&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; start&amp;lt;end{&lt;br/&gt;   numbers.swap(start,end)&lt;br/&gt;   end--&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt; numbers[start] = pivot&lt;br/&gt; middle = start&lt;br/&gt;&lt;br/&gt; quickSort(numbers,tempStart,middle&lt;span&gt;-1&lt;/span&gt;)&lt;br/&gt; quickSort(numbers,middle+&lt;span&gt;1&lt;/span&gt;,tempEnd)&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 交换方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(numbers uint64Slice)&lt;/span&gt;&lt;span&gt;swap&lt;/span&gt;&lt;span&gt;(i,j &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; numbers[i],numbers[j] = numbers[j],numbers[i]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.4 复杂度分析&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;快速排序涉及到递归调用，所以该算法的时间复杂度还需要从递归算法的复杂度开始说起；递归算法的时间复杂度公式：T[n] = aT[n/b] + f(n)  ；对于递归算法的时间复杂度这里就不展开来说了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;快速排序最优的情况就是每一次取到的元素都刚好平分整个数组(很显然我上面的不是)；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时的时间复杂度公式则为：T[n] = 2T[n/2] + f(n)；T[n/2]为平分后的子数组的时间复杂度，f[n] 为平分这个数组时所花的时间；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面来推算下，在最优的情况下快速排序时间复杂度的计算(用迭代法)：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;T[n] =  2T[n/2] + n              ----------------第一次递归&lt;br/&gt;令：n = n/2        =  2 { 2 T[n/4] + (n/2) }  + n     ----------------第二次递归&lt;br/&gt;                  =  2^2 T[ n/ (2^2) ] + 2n&lt;br/&gt;&lt;br/&gt;令：n = n/(2^2)   =  2^2  {  2 T[n/ (2^3) ]  + n/(2^2)}  +  2n    ----------------第三次递归  &lt;br/&gt;                 =  2^3 T[  n/ (2^3) ]  + 3n&lt;br/&gt;......................................................................................                        &lt;br/&gt;令：n = n/(  2^(m-1) )    =  2^m T[1]  + mn   ----------------第m次递归(m次后结束)&lt;br/&gt;&lt;br/&gt;当最后平分的不能再平分时，也就是说把公式一直往下跌倒，到最后得到T[1]时，说明这个公式已经迭代完了（T[1]是常量了）。&lt;br/&gt;得到：T[n/ (2^m) ]  =  T[1]    ===&amp;gt;&amp;gt;   n = 2^m   ====&amp;gt;&amp;gt; m = logn；&lt;br/&gt;T[n] = 2^m T[1] + mn ；其中m = logn;&lt;br/&gt;T[n] = 2^(logn) T[1] + nlogn  =  n T[1] + nlogn  =  n + nlogn  ；其中n为元素个数&lt;br/&gt;又因为当n &amp;gt;=  2时：nlogn  &amp;gt;=  n  (也就是logn &amp;gt; 1)，所以取后面的 nlogn；&lt;br/&gt;综上所述：快速排序最优的情况下时间复杂度为：O( nlogn )&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最差的情况就是每一次取到的元素就是数组中最小/最大的，这种情况其实就是冒泡排序了(每一次都排好一个元素的顺序)
这种情况时间复杂度就好计算了，就是冒泡排序的时间复杂度：T[n] = n * (n-1) = n^2 + n;
综上所述：快速排序最差的情况下时间复杂度为：O( n^2 )&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先就地快速排序使用的空间是O(1)的，也就是个常数级；而真正消耗空间的就是递归调用了，因为每次递归就要保持一些数据；最优的情况下空间复杂度为：O(logn)  ；每一次都平分数组的情况。最差的情况下空间复杂度为：O( n )    ；退化为冒泡排序的情况。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 插入排序&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1 算法步骤&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2 动画演示&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.3 代码示例&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; uint64Slice []&lt;span&gt;uint64&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; numbers := []&lt;span&gt;uint64&lt;/span&gt;{&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;20&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;9&lt;/span&gt;}&lt;br/&gt; insertSort(numbers)&lt;br/&gt; fmt.Println(numbers)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;insertSort&lt;/span&gt;&lt;span&gt;(numbers uint64Slice)&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i:=&lt;span&gt;1&lt;/span&gt;; i &amp;lt; &lt;span&gt;len&lt;/span&gt;(numbers); i++{&lt;br/&gt;  tmp := numbers[i]&lt;br/&gt;  &lt;span&gt;// 从待排序序列开始比较,找到比其小的数&lt;/span&gt;&lt;br/&gt;  j:=i&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; j&amp;gt;&lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; tmp&amp;lt;numbers[j&lt;span&gt;-1&lt;/span&gt;] {&lt;br/&gt;   numbers[j] = numbers[j&lt;span&gt;-1&lt;/span&gt;]&lt;br/&gt;   j--&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;// 存在比其小的数插入&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; j!=i{&lt;br/&gt;   numbers[j] = tmp&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 交换方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(numbers uint64Slice)&lt;/span&gt;&lt;span&gt;swap&lt;/span&gt;&lt;span&gt;(i,j &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; numbers[i],numbers[j] = numbers[j],numbers[i]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.4 复杂度分析&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来分析一下这个算法，从空间上来看，它只需要一个记录的辅助空间，因此关键是看它的时间复杂度。在最好的情况，我们要排序的表本身就是有序的，那我们的比较次数就是上面代码&lt;code&gt;tmp&amp;lt;numbers[j-1]&lt;/code&gt;的比较，因此没有移动记录，时间复杂度为O(n)。当最坏情况，即待排序表是逆序的情况，此时需要比较&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.23076923076923078&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/k5430ljpYPMpkFUr3BCNATOIkthtqYDYOYeDZDDMT14vbkfeqibmuZSf4GKYqZOkpTnUgTq6onsTxDcpkkiaLNOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;195&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;,而记录的移动次数也达到最大值&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.28662420382165604&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/k5430ljpYPMpkFUr3BCNATOIkthtqYDYec5Yv53nQKrZ31uk3pyAcPncuOokic46CqlhP2ygtyF9rahIX24haTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;157&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;次。如果排序记录是随机的，那么根据概率相同的原则，平均比较和移动次数约为&lt;code&gt;𝑛2/4&lt;/code&gt;次。因此，我们得出直接插入排序法的时间复杂度为&lt;code&gt;O(𝑛2)&lt;/code&gt;。从这里也可以看出，同样的&lt;code&gt;O(𝑛2)&lt;/code&gt;时间复杂度，直接插入排序比冒泡排序性能要好一些。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4 希尔排序&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.1 算法步骤&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;选择一个增量序列 t1，t2，……，tk，其中 ti &amp;gt; tj, tk = 1；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;按增量序列个数 k，对序列进行 k 趟排序；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.2 动画演示&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5203426124197003&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/k5430ljpYPMpkFUr3BCNATOIkthtqYDYYahiciboKCfPKu27unspgZhu5AfuAKWH7MEQSnXibbiaCI36z8S4OtFpDw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;934&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.3 代码示例&lt;/span&gt;&lt;span/&gt;&lt;br/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;math&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; uint64Slice []&lt;span&gt;uint64&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; numbers := []&lt;span&gt;uint64&lt;/span&gt;{&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;}&lt;br/&gt; shellSort(numbers)&lt;br/&gt; fmt.Println(numbers)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;shellSort&lt;/span&gt;&lt;span&gt;(numbers uint64Slice)&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; gap := &lt;span&gt;1&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; gap &amp;lt; &lt;span&gt;len&lt;/span&gt;(numbers){&lt;br/&gt;  gap = gap * &lt;span&gt;3&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; gap &amp;gt; &lt;span&gt;0&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; i:= gap; i &amp;lt; &lt;span&gt;len&lt;/span&gt;(numbers); i++{&lt;br/&gt;   tmp := numbers[i]&lt;br/&gt;   j := i - gap&lt;br/&gt;   &lt;span&gt;for&lt;/span&gt; j&amp;gt;=&lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; numbers[j] &amp;gt; tmp{&lt;br/&gt;    numbers[j+gap] = numbers[j]&lt;br/&gt;    j -= gap&lt;br/&gt;   }&lt;br/&gt;   numbers[j+gap] = tmp&lt;br/&gt;  }&lt;br/&gt;  gap = &lt;span&gt;int&lt;/span&gt;(math.Floor(&lt;span&gt;float64&lt;/span&gt;(gap / &lt;span&gt;3&lt;/span&gt;)))&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.4 复杂度分析&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面的代码我们可以分析，希尔排序的关键并不是随便分组后各自排序，而是将相隔某个&quot;增量&quot;的记录组成一个子序列，实现跳跃式的移动，使得排序的效率提高。这里的&quot;增量&quot;选取就非常关键了。我们是用&lt;code&gt;gap = gap * 3 + 1&lt;/code&gt;的方式选取增量，可究竟应该选取什么样的增量才是最好的呢？目前还是数学难题，迄今为止还没有人找到一种最好的增量序列。不过大量研究表明，当增量序列为&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.10074626865671642&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/k5430ljpYPMpkFUr3BCNATOIkthtqYDY5iaoCfNVCHHK9pUFuLRh0bHgiaibibasH4H29EHiaXkzetEea9WQpF2YQxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;268&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;时，可以获得不错的效率，其时间复杂度为&lt;code&gt;O(n3/2)&lt;/code&gt;，要好于直接排序的&lt;code&gt;O(n2)&lt;/code&gt;。需要注意的是，增量最后一个增量值必须等于1才行。因为记录是跳跃式移动，希尔排序并不是一种稳定的排序算法。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. 选择排序&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.1 算法步骤&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;重复第二步，直到所有元素均排序完毕。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.2 动画演示&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.49693251533742333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/k5430ljpYPMpkFUr3BCNATOIkthtqYDYot3m7WGyl7nbHcKSlYw3UBeaibqicVq2Vg4dGCITHic4RYoadmScQiar1w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;652&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.3 代码示例&lt;/span&gt;&lt;span/&gt;&lt;br/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; uint64Slice []&lt;span&gt;uint64&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; numbers := []&lt;span&gt;uint64&lt;/span&gt;{&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;23&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;}&lt;br/&gt; selectSort(numbers)&lt;br/&gt; fmt.Println(numbers)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;selectSort&lt;/span&gt;&lt;span&gt;(numbers uint64Slice)&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;len&lt;/span&gt;(numbers) - &lt;span&gt;1&lt;/span&gt;; i++{&lt;br/&gt;  &lt;span&gt;// 记录最小值位置&lt;/span&gt;&lt;br/&gt;  min := i&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; j:= i+&lt;span&gt;1&lt;/span&gt;; j&amp;lt;&lt;span&gt;len&lt;/span&gt;(numbers);j++{&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; numbers[j] &amp;lt; numbers[min]{&lt;br/&gt;    min = j&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; i != min{&lt;br/&gt;   numbers.swap(i,min)&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 交换方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(numbers uint64Slice)&lt;/span&gt;&lt;span&gt;swap&lt;/span&gt;&lt;span&gt;(i,j &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; numbers[i],numbers[j] = numbers[j],numbers[i]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.4 复杂度分析&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从简单选择排序的过程来看，他最大的特点就是交换移动数据次数相当少，这样也就节约了相应的时间。分析它的时间复杂度发现，无论最好最差的情况，其比较次数都是一样的多，第&lt;code&gt;i&lt;/code&gt;趟排序需要进行&lt;code&gt;n-i&lt;/code&gt;次关键字的比较，此时需要比较&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.1724137931034483&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/k5430ljpYPMpkFUr3BCNATOIkthtqYDYicmzH8ray71T0MFZr8PiaPR617Ws7MGpbDcoDjVsWMYcqTlwwSSIlwMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;261&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;。而对于交换次数而言，当最好的时候，交换为0次，最差的时候，也就初始降序时，交换次数为&lt;code&gt;n-1&lt;/code&gt;次，基于最终的排序时间是比较与交换的次数总和，因此，总的时间复杂度依然为&lt;code&gt;O(n2)&lt;/code&gt;。虽然与冒泡排序同为&lt;code&gt;O(n2)&lt;/code&gt;，但选择排序的性能上还是要略优于冒泡排序的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. 堆排序&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.1 算法步骤&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&amp;lt;=R[n]；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.2 动画演示&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5203562340966921&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/k5430ljpYPMpkFUr3BCNATOIkthtqYDYxWCh0fPG0VPH4wMIuhAhbiaGwYL1YJ0pEszsmf9FOHYianLfUtiaT9RwQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1572&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.3 代码示例&lt;/span&gt;&lt;span/&gt;&lt;br/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; uint64Slice []&lt;span&gt;uint64&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; numbers := []&lt;span&gt;uint64&lt;/span&gt;{&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;}&lt;br/&gt; sortHeap(numbers)&lt;br/&gt; fmt.Println(numbers)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;sortHeap&lt;/span&gt;&lt;span&gt;(numbers uint64Slice)&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; length := &lt;span&gt;len&lt;/span&gt;(numbers)&lt;br/&gt; buildMaxHeap(numbers,length)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := length&lt;span&gt;-1&lt;/span&gt;;i&amp;gt;&lt;span&gt;0&lt;/span&gt;;i--{&lt;br/&gt;  numbers.swap(&lt;span&gt;0&lt;/span&gt;,i)&lt;br/&gt;  length -=&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;  heapify(numbers,&lt;span&gt;0&lt;/span&gt;,length)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 构造大顶堆&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;buildMaxHeap&lt;/span&gt;&lt;span&gt;(numbers uint64Slice,length &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := length / &lt;span&gt;2&lt;/span&gt;; i &amp;gt;= &lt;span&gt;0&lt;/span&gt;; i-- {&lt;br/&gt;  heapify(numbers, i, length)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;heapify&lt;/span&gt;&lt;span&gt;(numbers uint64Slice, i, length &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; left := &lt;span&gt;2&lt;/span&gt;*i + &lt;span&gt;1&lt;/span&gt;&lt;br/&gt; right := &lt;span&gt;2&lt;/span&gt;*i + &lt;span&gt;2&lt;/span&gt;&lt;br/&gt; largest := i&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; left &amp;lt; length &amp;amp;&amp;amp; numbers[left] &amp;gt; numbers[largest] {&lt;br/&gt;  largest = left&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; right &amp;lt; length &amp;amp;&amp;amp; numbers[right] &amp;gt; numbers[largest] {&lt;br/&gt;  largest = right&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; largest != i {&lt;br/&gt;  numbers.swap(i, largest)&lt;br/&gt;  heapify(numbers, largest, length)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 交换方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(numbers uint64Slice)&lt;/span&gt;&lt;span&gt;swap&lt;/span&gt;&lt;span&gt;(i,j &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; numbers[i],numbers[j] = numbers[j],numbers[i]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.4 复杂度分析&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;堆排序的运行时间主要消耗在初始构建堆和在重建堆时的反复筛选上。在构建堆的过程中，因为我们是完全二叉树从最下层最右边的非终端节点开始构建，将它与其孩子进行比较，若有必要的交换，对于每个非终端节点来说，其实最多进行两次比较和呼唤操作，因此整个构建堆的时间复杂度为&lt;code&gt;O(n)&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在正式排序时，第&lt;code&gt;i&lt;/code&gt;次取堆顶记录重建堆需要用&lt;code&gt;O(logi)&lt;/code&gt;的时间(完全二叉树的某个节点到根结点的距离为&lt;code&gt;|logi|+1&lt;/code&gt;)，并且需要取&lt;code&gt;n-1&lt;/code&gt;次堆顶记录，因此，重建堆的时间复杂度为&lt;code&gt;O(nlogn)&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以总体来说，堆排序的时间复杂度为&lt;code&gt;O(nlogn)&lt;/code&gt;。由于堆排序对原始记录的排序状态并不敏感，因此他无论是最好、最坏和平均时间复杂度均为&lt;code&gt;O(nlogn)&lt;/code&gt;。这在性能上显然要远远好过于冒泡、简单选择、直接插入的&lt;code&gt;O(n2)&lt;/code&gt;的时间复杂度了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;空间复杂度上，他只有一个用来交换的暂存单元，也非常的不错。不过由于记录的比较与交换是跳跃式进行的，因此堆排序也是一种不稳定的排序方法。&lt;strong&gt;注意：由于初始构建堆所需的比较次数较多，因此，他并不适合待排序序列个数较少的情况。&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.  归并排序&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.1 算法步骤&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设定两个指针，最初位置分别为两个已经排序序列的起始位置；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;重复步骤 3 直到某一指针达到序列尾；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将另一序列剩下的所有元素直接复制到合并序列尾。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.2 动画演示&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6096698113207547&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/k5430ljpYPMpkFUr3BCNATOIkthtqYDYGGo93Rwe4tyLZpb9xq8AFI1E7xHB7C4YzjeYItpSwKeXjM6s5DN99g/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1696&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.3 代码示例&lt;/span&gt;&lt;span/&gt;&lt;br/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; uint64Slice []&lt;span&gt;uint64&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; numbers := []&lt;span&gt;uint64&lt;/span&gt;{&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;44&lt;/span&gt;,&lt;span&gt;38&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;47&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;,&lt;span&gt;36&lt;/span&gt;,&lt;span&gt;26&lt;/span&gt;,&lt;span&gt;27&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;46&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;19&lt;/span&gt;,&lt;span&gt;50&lt;/span&gt;,&lt;span&gt;48&lt;/span&gt;}&lt;br/&gt; res := mergeSort(numbers)&lt;br/&gt; fmt.Println(res)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;mergeSort&lt;/span&gt;&lt;span&gt;(numbers uint64Slice)&lt;/span&gt; &lt;span&gt;uint64Slice&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; length := &lt;span&gt;len&lt;/span&gt;(numbers)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; length &amp;lt; &lt;span&gt;2&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; numbers&lt;br/&gt; }&lt;br/&gt; middle := length/&lt;span&gt;2&lt;/span&gt;&lt;br/&gt; left := numbers[&lt;span&gt;0&lt;/span&gt;:middle]&lt;br/&gt; right := numbers[middle:]&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; merge(mergeSort(left),mergeSort(right))&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;merge&lt;/span&gt;&lt;span&gt;(left uint64Slice,right uint64Slice)&lt;/span&gt; &lt;span&gt;uint64Slice&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; result := &lt;span&gt;make&lt;/span&gt;(uint64Slice,&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;(left) != &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; &lt;span&gt;len&lt;/span&gt;(right) != &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; left[&lt;span&gt;0&lt;/span&gt;] &amp;lt;= right[&lt;span&gt;0&lt;/span&gt;] {&lt;br/&gt;   result = &lt;span&gt;append&lt;/span&gt;(result, left[&lt;span&gt;0&lt;/span&gt;])&lt;br/&gt;   left = left[&lt;span&gt;1&lt;/span&gt;:]&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;   result = &lt;span&gt;append&lt;/span&gt;(result, right[&lt;span&gt;0&lt;/span&gt;])&lt;br/&gt;   right = right[&lt;span&gt;1&lt;/span&gt;:]&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;(left) != &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;  result = &lt;span&gt;append&lt;/span&gt;(result, left[&lt;span&gt;0&lt;/span&gt;])&lt;br/&gt;  left = left[&lt;span&gt;1&lt;/span&gt;:]&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;(right) != &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;  result = &lt;span&gt;append&lt;/span&gt;(result, right[&lt;span&gt;0&lt;/span&gt;])&lt;br/&gt;  right = right[&lt;span&gt;1&lt;/span&gt;:]&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; result&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 交换方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(numbers uint64Slice)&lt;/span&gt;&lt;span&gt;swap&lt;/span&gt;&lt;span&gt;(i,j &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; numbers[i],numbers[j] = numbers[j],numbers[i]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.4 复杂度分析&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以说合并排序是比较复杂的排序，特别是对于不了解分治法基本思想的同学来说可能难以理解。总时间=分解时间+解决问题时间+合并时间。分解时间就是把一个待排序序列分解成两序列，时间为一常数，时间复杂度o(1).解决问题时间是两个递归式，把一个规模为n的问题分成两个规模分别为n/2的子问题，时间为2T(n/2).合并时间复杂度为o（n）。总时间T(n)=2T(n/2)+o(n).这个递归式可以用递归树来解，其解是o(nlogn).此外在最坏、最佳、平均情况下归并排序时间复杂度均为o(nlogn).从合并过程中可以看出合并排序稳定。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用递归树的方法解递归式T(n)=2T(n/2)+o(n):假设解决最后的子问题用时为常数c，则对于n个待排序记录来说整个问题的规模为cn。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.9187817258883249&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/k5430ljpYPMpkFUr3BCNATOIkthtqYDYq7gtayYyrkB7Rbcgpg4Y8cnVQAvR7GQyuIbHQSzprCic8ibPacF9s5cg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;788&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8. 计数排序&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8.1 算法步骤&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;花O(n)的时间扫描一下整个序列 A，获取最小值 min 和最大值 max&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;开辟一块新的空间创建新的数组 B，长度为 ( max - min + 1)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数组 B 中 index 的元素记录的值是 A 中某元素出现的次数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后输出目标整数序列，具体的逻辑是遍历数组 B，输出相应元素以及对应的个数&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8.2 动画演示&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6695121951219513&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/k5430ljpYPMpkFUr3BCNATOIkthtqYDYibTFTfISgGln8smT2sJXmtgicZvSPmicKevKt1Iwfyicuia4cRZ0rWiat1Hw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1640&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8.3 代码示例&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; uint64Slice []&lt;span&gt;uint64&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; numbers := []&lt;span&gt;uint64&lt;/span&gt;{&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;}&lt;br/&gt;&lt;br/&gt; countSort(numbers,getMaxValue(numbers))&lt;br/&gt; fmt.Println(numbers)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;countSort&lt;/span&gt;&lt;span&gt;(numbers uint64Slice,maxValue &lt;span&gt;uint64&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; bucketLen := maxValue + &lt;span&gt;1&lt;/span&gt;&lt;br/&gt; bucket := &lt;span&gt;make&lt;/span&gt;(uint64Slice,bucketLen) &lt;span&gt;// 初始都是0的数组&lt;/span&gt;&lt;br/&gt; sortedIndex := &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; _,v:= &lt;span&gt;range&lt;/span&gt; numbers{&lt;br/&gt;  bucket[v] +=&lt;span&gt;1&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; j &lt;span&gt;uint64&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; j=&lt;span&gt;0&lt;/span&gt;;j&amp;lt;bucketLen;j++{&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; bucket[j]&amp;gt;&lt;span&gt;0&lt;/span&gt;{&lt;br/&gt;   numbers[sortedIndex] = j&lt;br/&gt;   sortedIndex +=&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;   bucket[j] -= &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;getMaxValue&lt;/span&gt;&lt;span&gt;(numbers uint64Slice)&lt;/span&gt; &lt;span&gt;uint64&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;   maxValue := numbers[&lt;span&gt;0&lt;/span&gt;]&lt;br/&gt;   &lt;span&gt;for&lt;/span&gt; _,v:=&lt;span&gt;range&lt;/span&gt; numbers {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; maxValue &amp;lt; v {&lt;br/&gt;     maxValue = v&lt;br/&gt;    }&lt;br/&gt;   }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; maxValue&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8.4 复杂度分析&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个算法不是基于比较的排序算法，因此它的下界可以优于Ω(nlgn)，甚至这个算法都没有出现比较元素的操作。这个算法很明显是&lt;strong&gt;稳定的&lt;/strong&gt;，也就是说具有相同值得元素在输出数组中的相对次序和他们在输入数组中的相对次序相同。算法中的循环时间代价都是线性的，还有一个常数k，因此时间复杂度是Θ(n+k)。当k=O(n)时，我们采用计数排序就很好，总的时间复杂度为Θ(n)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;计数排序是&lt;strong&gt;复杂度为O(n+k)的稳定的排序算法&lt;/strong&gt;，k是待排序列最大值，适用在对&lt;strong&gt;最大值不是很大的整型元素序列&lt;/strong&gt;进行排序的情况下（整型元素可以有负数，我们可以把待排序列整体加上一个整数，使得待排序列的最小元素为0，然后执行计数排序，完成之后再变回来。这个操作是线性的，所以计数这样做计数排序的复杂度仍然是O(n+k)）。本质上是一种空间换时间的算法，如果k比较小，计数排序的效率优势是很明显的，当k变得很大的时候，这个算法可能就不如其他优秀的排序算法。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9. 桶排序&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9.1 算法步骤&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;桶排序是计数排序的升级版。这个是利用了函数的映射关系，是否高效就在于这个映射函数的确定。所以为了使桶排序更加高效，我们要保证做到以下两点：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;1.&lt;/span&gt; 在额外空间充足的情况下，尽量增大桶的数量&lt;br/&gt;&lt;span&gt;2.&lt;/span&gt; 使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;设置固定数量的空桶。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;把数据放到对应的桶中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对每个不为空的桶中数据进行排序。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;拼接不为空的桶中数据，得到结果&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9.2 动画演示&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5900383141762452&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/k5430ljpYPMpkFUr3BCNATOIkthtqYDYheNnnR3rdE987uztIjdMXXD0l5kNAxiaabdCskjRsttfEeshAKKwFjw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1566&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9.3 代码示例&lt;/span&gt;&lt;span/&gt;&lt;br/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; numbers := []&lt;span&gt;uint64&lt;/span&gt;{&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;}&lt;br/&gt; sortBucket(numbers)&lt;br/&gt; fmt.Println(numbers)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;sortBucket&lt;/span&gt;&lt;span&gt;(numbers []&lt;span&gt;uint64&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; num := &lt;span&gt;len&lt;/span&gt;(numbers) &lt;span&gt;// 桶数量&lt;/span&gt;&lt;br/&gt; max := getMaxValue(numbers)&lt;br/&gt; buckets := &lt;span&gt;make&lt;/span&gt;([][]&lt;span&gt;uint64&lt;/span&gt;,num)&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; index &lt;span&gt;uint64&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; _,v := &lt;span&gt;range&lt;/span&gt; numbers{&lt;br/&gt;  &lt;span&gt;// 分配桶 index = value * (n-1)/k&lt;/span&gt;&lt;br/&gt;  index = v * &lt;span&gt;uint64&lt;/span&gt;(num&lt;span&gt;-1&lt;/span&gt;) / max&lt;br/&gt;&lt;br/&gt;  buckets[index] = &lt;span&gt;append&lt;/span&gt;(buckets[index],v)&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 桶内排序&lt;/span&gt;&lt;br/&gt; tmpPos := &lt;span&gt;0&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; k:=&lt;span&gt;0&lt;/span&gt;; k &amp;lt; num; k++ {&lt;br/&gt;  bucketLen := &lt;span&gt;len&lt;/span&gt;(buckets[k])&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; bucketLen&amp;gt;&lt;span&gt;0&lt;/span&gt;{&lt;br/&gt;   sortUseInsert(buckets[k])&lt;br/&gt;   &lt;span&gt;copy&lt;/span&gt;(numbers[tmpPos:],buckets[k])&lt;br/&gt;   tmpPos +=bucketLen&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;sortUseInsert&lt;/span&gt;&lt;span&gt;(bucket []&lt;span&gt;uint64&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; length := &lt;span&gt;len&lt;/span&gt;(bucket)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; length == &lt;span&gt;1&lt;/span&gt; {&lt;span&gt;return&lt;/span&gt;}&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;1&lt;/span&gt;; i &amp;lt; length; i++ {&lt;br/&gt;  backup := bucket[i]&lt;br/&gt;  j := i &lt;span&gt;-1&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt;  j &amp;gt;= &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; backup &amp;lt; bucket[j] {&lt;br/&gt;   bucket[j+&lt;span&gt;1&lt;/span&gt;] = bucket[j]&lt;br/&gt;   j --&lt;br/&gt;  }&lt;br/&gt;  bucket[j + &lt;span&gt;1&lt;/span&gt;] = backup&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//获取数组最大值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;getMaxValue&lt;/span&gt;&lt;span&gt;(numbers []&lt;span&gt;uint64&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;uint64&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt; max := numbers[&lt;span&gt;0&lt;/span&gt;]&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;1&lt;/span&gt;; i &amp;lt; &lt;span&gt;len&lt;/span&gt;(numbers); i++ {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; numbers[i] &amp;gt; max{ max = numbers[i]}&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; max&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9.4 复杂度分析&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1. 时间复杂度&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为时间复杂度度考虑的是最坏的情况，所以桶排序的时间复杂度可以这样去看(只看主要耗时部分，而且常熟部分K一般都省去)&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;N次循环，每一个数据装入桶&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;然后M次循环，每一个桶中的数据进行排序(每一个桶中有N/M个数据)，假设为使用比较先进的排序算法进行排序&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般较为先进的排序算法时间复杂度是O(N*logN)，实际的桶排序执行过程中，桶中数据是以链表形式插入的，那么整个桶排序的时间复杂度为:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;O(N)+O(M*(N/M)*&lt;span&gt;log&lt;/span&gt;(N/M))=O(N*(&lt;span&gt;log&lt;/span&gt;(N/M)+1))&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;所以，理论上来说(N个数都符合均匀分布)，当M=N时，有一个最小值为O(N)&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;PS:这里有人提到最后还有M个桶的合并，其实首先M一般远小于N，其次再效率最高时是M=N，这是就算把这个算进去，也是O(N&lt;/em&gt;(1+log(N/M)+M/N))，极小值还是O(2&lt;em&gt;N)=O(N)&lt;/em&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;求M的极小值，具体计算为:(其中N可以看作一个很大的常数)&lt;br/&gt;F(M) = &lt;span&gt;log&lt;/span&gt;(N/M)+M/N) = LogN-LogM+M/N&lt;br/&gt;它的导函数&lt;br/&gt;F&lt;span&gt;&#x27;(M) = -1/M + 1/N&lt;br/&gt;因为导函数大于0代表函数递增，小于0代表函数递减&lt;br/&gt;所以F(M)在(0,N) 上递减&lt;br/&gt;在(N,+∞)上递增&lt;br/&gt;所以当M=N时取到极小值&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2. 空间复杂度&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;空间复杂度一般指算法执行过程中需要的额外存储空间&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;桶排序中，需要创建M个桶的额外空间，以及N个元素的额外空间&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以桶排序的空间复杂度为 &lt;strong&gt;O(N+M)&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3. 稳定性·&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;稳定性是指，比如a在b前面，a=b，排序后，a仍然应该在b前面，这样就算稳定的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;桶排序中，假如升序排列，a已经在桶中，b插进来是永远都会a右边的(因为一般是从右到左，如果不小于当前元素，则插入改元素的右侧)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;所以桶排序是稳定的&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;PS:当然了，如果采用元素插入后再分别进行桶内排序，并且桶内排序算法采用快速排序，那么就不是稳定的&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;用排序主要适用于均匀分布的数字数组，在这种情况下能够达到最大效率&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10. 基数排序&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10.1 算法步骤&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基数排序与桶排序、计数排序都用到了桶的概念，但对桶的使用方法上有明显差异：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;基数排序：根据键值的每位数字来分配桶；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;计数排序：每个桶只存储单一键值；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;桶排序：每个桶存储一定范围的数值；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基数排序按取数方向分为两种：从左取每个数列上的数，为&lt;strong&gt;最高位优先（Most Significant Digit first, MSD）&lt;/strong&gt;；从右取每个数列上的数，为&lt;strong&gt;最低位优先（Least Significant Digit first, LSD）&lt;/strong&gt;。下列以LSD为例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基数排序步骤：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从最低位开始，依次进行一次排序&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10.2 动画演示&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5251063829787234&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/k5430ljpYPMpkFUr3BCNATOIkthtqYDYZkWRc4DkPicgV9eUw73Es7PjPibiaicJAV1hsRibxAm1YrJOT04giaa2d59g/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;2350&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10.3 代码示例&lt;/span&gt;&lt;span/&gt;&lt;br/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; numbers := []&lt;span&gt;uint64&lt;/span&gt;{&lt;span&gt;3221&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;9680&lt;/span&gt;, &lt;span&gt;577&lt;/span&gt;, &lt;span&gt;9420&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;, &lt;span&gt;5622&lt;/span&gt;, &lt;span&gt;4793&lt;/span&gt;, &lt;span&gt;2030&lt;/span&gt;, &lt;span&gt;3138&lt;/span&gt;, &lt;span&gt;82&lt;/span&gt;, &lt;span&gt;2599&lt;/span&gt;, &lt;span&gt;743&lt;/span&gt;, &lt;span&gt;4127&lt;/span&gt;}&lt;br/&gt; radixSort(numbers)&lt;br/&gt; fmt.Println(numbers)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;radixSort&lt;/span&gt;&lt;span&gt;(numbers []&lt;span&gt;uint64&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; key := maxDigits(numbers)&lt;br/&gt; tmp := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;uint64&lt;/span&gt;,&lt;span&gt;len&lt;/span&gt;(numbers),&lt;span&gt;len&lt;/span&gt;(numbers))&lt;br/&gt; count := &lt;span&gt;new&lt;/span&gt;([&lt;span&gt;10&lt;/span&gt;]&lt;span&gt;uint64&lt;/span&gt;)&lt;br/&gt; length := &lt;span&gt;uint64&lt;/span&gt;(&lt;span&gt;len&lt;/span&gt;(numbers))&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; radix &lt;span&gt;uint64&lt;/span&gt; =  &lt;span&gt;1&lt;/span&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; i, j, k &lt;span&gt;uint64&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; key; i++ { &lt;span&gt;//进行key次排序&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; &lt;span&gt;10&lt;/span&gt;; j++ {&lt;br/&gt;   count[j] = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; length; j++ {&lt;br/&gt;   k = (numbers[j] / radix) % &lt;span&gt;10&lt;/span&gt;&lt;br/&gt;   count[k]++&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;; j &amp;lt; &lt;span&gt;10&lt;/span&gt;; j++ { &lt;span&gt;//将tmp中的为准依次分配给每个桶&lt;/span&gt;&lt;br/&gt;   count[j] = count[j&lt;span&gt;-1&lt;/span&gt;] + count[j]&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; j = length&lt;span&gt;-1&lt;/span&gt;; j &amp;gt; &lt;span&gt;0&lt;/span&gt;; j-- {&lt;br/&gt;   k = (numbers[j] / radix) % &lt;span&gt;10&lt;/span&gt;&lt;br/&gt;   tmp[count[k]&lt;span&gt;-1&lt;/span&gt;] = numbers[j]&lt;br/&gt;   count[k]--&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; length; j++ {&lt;br/&gt;   numbers[j] = tmp[j]&lt;br/&gt;  }&lt;br/&gt;  radix = radix * &lt;span&gt;10&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//获取数组的最大值的位数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;maxDigits&lt;/span&gt;&lt;span&gt;(arr []&lt;span&gt;uint64&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(ret &lt;span&gt;uint64&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; ret = &lt;span&gt;1&lt;/span&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; key &lt;span&gt;uint64&lt;/span&gt; = &lt;span&gt;10&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;len&lt;/span&gt;(arr); i++ {&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; arr[i] &amp;gt;= key {&lt;br/&gt;   key = key * &lt;span&gt;10&lt;/span&gt;   ret++&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10.4 复杂度分析&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果使用桶排序或者计数排序（必需是稳定排序算法），时间复杂度可以做到 O(n)。**如果要排序的数据有 k 位，那我们就需要 k 次桶排序或者计数排序，总的时间复杂度是 O(kn)。当 k 不大的时候，比如手机号码排序的例子，基数排序的时间复杂度就近似于 O(n)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基数排序对要排序的数据要求如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;需要分割出独立的&quot;位&quot;来比较，而且位之间可以进行比较。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n)。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果排序的元素位数不一样，位数不够的可以在后面补位。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章总结到这里就结束了，花费了好长时间耶(动画太难弄了)～～。这排序算法长时间不写都快忘光了，这一次又重新整理了一遍，收获很大。虽然这些算法是很简单的算法，但是却很重要，日常开发都会用到，所以大家一定要学好。希望这篇文章对你们有用。如果觉得不错，给个三连吧（点赞、看一看，分享），这就对笔者的最大鼓励，感谢啦～～～。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;代码已经收录到我的github，需要的自取：https://github.com/asong2020/go-algorithm/tree/master/sort&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;好啦，这一篇文章到这就结束了，我们下期见～～。希望对你们有用，又不对的地方欢迎指出，可添加我的golang交流群，我们一起学习交流。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;结尾给大家发一个小福利吧，最近我在看[微服务架构设计模式]这一本书，讲的很好，自己也收集了一本PDF，有需要的小伙可以到自行下载。获取方式：关注公众号：[Golang梦工厂]，后台回复：[微服务]，即可获取。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;最近被吐槽说我写的代码太丑陋了，所以最近也在看&lt;code&gt;clean code&lt;/code&gt;这本书，有需要的小伙伴公众号自取哈。获取方式：关注公众号：[Golang梦工厂]，后台回复：[code]，即可获取&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;我翻译了一份GIN中文文档，会定期进行维护，有需要的小伙伴后台回复[gin]即可下载。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;翻译了一份Machinery中文文档，会定期进行维护，有需要的小伙伴们后台回复[machinery]即可获取。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;我是asong，一名普普通通的程序猿，让gi我一起慢慢变强吧。我自己建了一个&lt;code&gt;golang&lt;/code&gt;交流群，有需要的小伙伴加我&lt;code&gt;vx&lt;/code&gt;,我拉你入群。欢迎各位的关注，我们下期见~~~&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/k5430ljpYPMpkFUr3BCNATOIkthtqYDY9YGBSZh6NLvdUgTX4CyzsXSSL5WhxROttMcBh81cjxialhiaOhEweH2g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推荐往期文章：&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9abb70ff0de8df03b377805baf3e7adb</guid>
<title>求你了，不要再在对外接口中使用枚举类型了</title>
<link>https://toutiao.io/k/mv4rps0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article class=&quot;article-content&quot;&gt;
&lt;p&gt;最近，我们的线上环境出现了一个问题，线上代码在执行过程中抛出了一个IllegalArgumentException，分析堆栈后，发现最根本的的异常是以下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;java.lang.IllegalArgumentException: 
No enum constant com.a.b.f.m.a.c.AType.P_M
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;大概就是以上的内容，看起来还是很简单的，提示的错误信息就是在AType这个枚举类中没有找到P_M这个枚举项。&lt;/p&gt;
&lt;p&gt;于是经过排查，我们发现，在线上开始有这个异常之前，该应用依赖的一个下游系统有发布，而发布过程中是一个API包发生了变化，主要变化内容是在一个RPC接口的Response返回值类中的一个枚举参数AType中增加了P_M这个枚举项。&lt;/p&gt;
&lt;p&gt;但是下游系统发布时，并未通知到我们负责的这个系统进行升级，所以就报错了。&lt;/p&gt;
&lt;p&gt;我们来分析下为什么会发生这样的情况。&lt;/p&gt;
&lt;h3&gt;问题重现&lt;/h3&gt;
&lt;p&gt;首先，下游系统A提供了一个二方库的某一个接口的返回值中有一个参数类型是枚举类型。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一方库指的是本项目中的依赖 二方库指的是公司内部其他项目提供的依赖 三方库指的是其他组织、公司等来自第三方的依赖&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;public interface AFacadeService {

    public AResponse doSth(ARequest aRequest);
}

public Class AResponse{

    private Boolean success;

    private AType aType;
}

public enum AType{

    P_T,

    A_B
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后B系统依赖了这个二方库，并且会通过RPC远程调用的方式调用AFacadeService的doSth方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class BService {

    @Autowired
    AFacadeService aFacadeService;

    public void doSth(){
        ARequest aRequest = new ARequest();

        AResponse aResponse = aFacadeService.doSth(aRequest);

        AType aType = aResponse.getAType();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这时候，如果A和B系统依赖的都是同一个二方库的话，两者使用到的枚举AType会是同一个类，里面的枚举项也都是一致的，这种情况不会有什么问题。&lt;/p&gt;
&lt;p&gt;但是，如果有一天，这个二方库做了升级，在AType这个枚举类中增加了一个新的枚举项P_M，这时候只有系统A做了升级，但是系统B并没有做升级。&lt;/p&gt;
&lt;p&gt;那么A系统依赖的的AType就是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public enum AType{

    P_T,

    A_B,

    P_M
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而B系统依赖的AType则是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public enum AType{

    P_T,

    A_B
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种情况下&lt;strong&gt;，在B系统通过RPC调用A系统的时候，如果A系统返回的AResponse中的aType的类型位新增的P_M时候，B系统就会无法解析。一般在这种时候，RPC框架就会发生反序列化异常。导致程序被中断。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;原理分析&lt;/h3&gt;
&lt;p&gt;这个问题的现象我们分析清楚了，那么再来看下原理是怎样的，为什么出现这样的异常呢。&lt;/p&gt;
&lt;p&gt;其实这个原理也不难，这类&lt;strong&gt;RPC框架大多数会采用JSON的格式进行数据传输&lt;/strong&gt;，也就是客户端会将返回值序列化成JSON字符串，而服务端会再将JSON字符串反序列化成一个Java对象。&lt;/p&gt;
&lt;p&gt;而JSON在反序列化的过程中，对于一个枚举类型，会尝试调用对应的枚举类的valueOf方法来获取到对应的枚举。&lt;/p&gt;
&lt;p&gt;而我们查看枚举类的valueOf方法的实现时，就可以发现，&lt;strong&gt;如果从枚举类中找不到对应的枚举项的时候，就会抛出IllegalArgumentException&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static &amp;lt;T extends Enum&amp;lt;T&amp;gt;&amp;gt; T valueOf(Class&amp;lt;T&amp;gt; enumType,
                                            String name) {
    T result = enumType.enumConstantDirectory().get(name);
    if (result != null)
        return result;
    if (name == null)
        throw new NullPointerException(&quot;Name is null&quot;);
    throw new IllegalArgumentException(
        &quot;No enum constant &quot; + enumType.getCanonicalName() + &quot;.&quot; + name);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;关于这个问题，其实在《阿里巴巴Java开发手册》中也有类似的约定：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hollischuang.com/wp-content/uploads/2020/11/16066271055035-scaled.jpg&quot; alt=&quot;-w1538&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;这里面规定”&lt;strong&gt;对于二方库的参数可以使用枚举，但是返回值不允许使用枚举&lt;/strong&gt;“。这背后的思考就是本文上面提到的内容。&lt;/p&gt;
&lt;h3&gt;扩展思考&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;为什么参数中可以有枚举？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不知道大家有没有想过这个问题，其实这个就和二方库的职责有点关系了。&lt;/p&gt;
&lt;p&gt;一般情况下，A系统想要提供一个远程接口给别人调用的时候，就会定义一个二方库，告诉其调用方如何构造参数，调用哪个接口。&lt;/p&gt;
&lt;p&gt;而这个二方库的调用方会根据其中定义的内容来进行调用。而参数的构造过程是由B系统完成的，如果B系统使用到的是一个旧的二方库，使用到的枚举自然是已有的一些，新增的就不会被用到，所以这样也不会出现问题。&lt;/p&gt;
&lt;p&gt;比如前面的例子，B系统在调用A系统的时候，构造参数的时候使用到AType的时候就只有P_T和A_B两个选项，虽然A系统已经支持P_M了，但是B系统并没有使用到。&lt;/p&gt;
&lt;p&gt;如果B系统想要使用P_M，那么就需要对该二方库进行升级。&lt;/p&gt;
&lt;p&gt;但是，返回值就不一样了，返回值并不受客户端控制，服务端返回什么内容是根据他自己依赖的二方库决定的。&lt;/p&gt;
&lt;p&gt;但是，其实相比较于手册中的规定，&lt;strong&gt;我更加倾向于，在RPC的接口中入参和出参都不要使用枚举。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般，我们要使用枚举都是有几个考虑：&lt;/p&gt;

&lt;p&gt;不可否认，使用枚举确实有一些好处，但是我不建议使用主要有以下原因：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;我其实建议大家在接口中使用字符串代替枚举&lt;/strong&gt;，相比较于枚举这种强类型，字符串算是一种弱类型。&lt;/p&gt;
&lt;p&gt;如果使用字符串代替RPC接口中的枚举，那么就可以避免上面我们提到的两个问题，上游系统只需要传递字符串就行了，而具体的值的合法性，只需要在A系统内自己进行校验就可以了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为了方便调用者使用，可以使用javadoc的@see注解表明这个字符串字段的取值从那个枚举中获取。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public Class AResponse{

    private Boolean success;

    /**
    *  @see AType 
    */
    private String aType;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于像阿里这种比较庞大的互联网公司，&lt;strong&gt;随便提供出去的一个接口，可能有上百个调用方&lt;/strong&gt;，而接口升级也是常态，&lt;strong&gt;我们根本做不到每次二方库升级之后要求所有调用者跟着一起升级&lt;/strong&gt;，这是完全不现实的，并且对于有些调用者来说，他用不到新特性，完全没必要做升级。&lt;/p&gt;
&lt;p&gt;还有一种看起来比较特殊，但是实际上比较常见的情况，就是有的时候一个接口的声明在A包中，而一些枚举常量定义在B包中，比较常见的就是阿里的交易相关的信息，订单分很多层次，每次引入一个包的同时都需要引入几十个包。&lt;/p&gt;
&lt;p&gt;对于调用者来说，我肯定是不希望我的系统引入太多的依赖的，&lt;strong&gt;一方面依赖多了会导致应用的编译过程很慢，并且很容易出现依赖冲突问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以，在调用下游接口的时候，如果参数中字段的类型是枚举的话，那我没办法，必须得依赖他的二方库。但是如果不是枚举，只是一个字符串，那我就可以选择不依赖。&lt;/p&gt;
&lt;p&gt;所以，我们在定义接口的时候，会尽量避免使用枚举这种强类型。规范中规定在返回值中不允许使用，而我自己要求更高，就是即使在接口的入参中我也很少使用。&lt;/p&gt;
&lt;p&gt;最后，我只是不建议在对外提供的接口的出入参中使用枚举，并不是说彻底不要用枚举，我之前很多文章也提到过，枚举有很多好处，我在代码中也经常使用。所以，切不可因噎废食。&lt;/p&gt;
&lt;p&gt;当然，文中的观点仅代表我个人，具体是是不是适用其他人，其他场景或者其他公司的实践，需要读者们自行分辨下，建议大家在使用的时候可以多思考一下。&lt;/p&gt;
&lt;center&gt;&lt;b&gt;(全文完)&lt;/b&gt;&lt;/center&gt;&lt;hr/&gt;&lt;center&gt;&lt;b&gt;扫描二维码，关注作者微信公众号&lt;/b&gt;&lt;/center&gt;&lt;img src=&quot;http://www.hollischuang.com/wp-content/uploads/2019/04/二维码.png&quot;/&gt;
&lt;/article&gt;
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e636c2099298f8248fa1e8254420abdf</guid>
<title>初识 GitLab 工作流</title>
<link>https://toutiao.io/k/wvirq27</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;git对我来说挺难理解的，平时遇到问题也是绕着走，倒也没啥大问题，但基于git软件的工作流却很重要，尤其对于一个组织来说。&lt;/p&gt;&lt;p&gt;git工作流、github工作流、gitlab工作流都属于特性分支（feature branches）的类别，今天主要理解gitlab工作流，它结合了特性驱动开发、特性分支、issuse跟踪。&lt;/p&gt;&lt;p&gt;1：git工作流的问题&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.3257575757575757&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5Wib5Wh04ugzy6UUicicGVSRIyZ5ibBtPdUU86VMIXy5icmJSYIibp8EgvvUA7cFPfPILGhXnStU8mzib9kDC02a1y7DQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;528&quot;/&gt;&lt;/p&gt;&lt;p&gt;git工作流比较古老，最大的问题是太复杂，它包含master、develop分支，还包含了features、releases、hotfixes分支。&lt;/p&gt;&lt;p&gt;它从develop分支开始，然后移动到release分支，最终合并到master分支。&lt;/p&gt;&lt;p&gt;它有两个最大的问题：第一个问题就是必须从develop分支开始（而不是master分支，master is reserved for code that is released to production），这有点反人类，约定俗成大部分工具都是从master分支开始的。&lt;/p&gt;&lt;p&gt;第二个问题就是它引入了hotfixes和release分支，现在大部分组织都是基于master做CD（即master分支是可以直接部署的），而对于CD持续交付来说，是没有hotfixes和release分支概念的，也不建议引入一些规范（比如将代码合并回release分支），另外也会经常犯错（比如把代码合并到master，但没有合并到develop分支）。&lt;/p&gt;&lt;p&gt;总之git工作流太复杂了，其实我也没理解。&lt;/p&gt;&lt;p&gt;2：github工作流&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.2289473684210526&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5Wib5Wh04ugzy6UUicicGVSRIyZ5ibBtPdUUwYrbqhQPPQqEp2Np29p9f5eq7icKJogoZ7iar6OJTx6JPT3MCJpdja3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;380&quot;/&gt;&lt;/p&gt;&lt;p&gt;非常简单，就两个分支（master和features），要做的就是将features发送PR到master，提倡频繁部署，减少未发布的代码，良好践行精益开发和持续集成这些最佳实践。&lt;/p&gt;&lt;p&gt;什么意思呢？就是鼓励你尽可能的合并到master（代表可以部署了），这个工作流在github上没有问题，但对于一个组织来说，它还有很多问题没有解决，比如说部署、多环境、发布、issues这些问题（部署和发布不是一个概念，部署针对于代码部署，发布针对于用户）。&lt;/p&gt;&lt;p&gt;那如何解决呢？gitlab来了，它不仅仅是一个git管理工具，更包含一整套的工作流方法。&lt;/p&gt;&lt;p&gt;3：gitlab工作流之生产分支&lt;/p&gt;&lt;p&gt;gitlab工作流有三个变种，先说生产分支。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.6242603550295858&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5Wib5Wh04ugzy6UUicicGVSRIyZ5ibBtPdUUPGRYuWWCwXdqo8FPPfPX6k96oWApXIxIauC2WI0CviadUGeEJvPn7DA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;338&quot;/&gt;&lt;/p&gt;&lt;p&gt;github工作流假设一旦你将feature分支合并到master后就可以部署了，但现实并不是如此，因为各种原因并不能精准控制release时间，比如说IOS审核，你将代码合并到master的时候其实整个服务还没有release；再比如release时间是固定的，但merge时间可能并不是release时间点。&lt;/p&gt;&lt;p&gt;那怎么保障merge时刻的代码就是真正要发布的代码呢？同时又不影响持续集成，其实merge后，可以将master分支合并到生产分支。&lt;/p&gt;&lt;p&gt;通过这样的工作流，如果想看线上代码是什么，可以直接查看生产分支；如果想精确知晓release时间，还可以基于生产分支打一个tag。&lt;/p&gt;&lt;p&gt;有一个问题，master是可以持续集成了，生产分支也打出来了，但还没到发布时间，这时候突然有个bug，开发人员基于master创建出一个特性分支（其实已经包含了未发布的代码），修复后要紧急上线，怎么办?&lt;/p&gt;&lt;p&gt;第一可以直接将master合并到生产分支发布修复代码；第二可以pick出修复的代码（特性分支）到生产分支，&lt;/p&gt;&lt;p&gt;必须记住，代码在master上就表示可以发布了（也许要做特性开关）。&lt;/p&gt;&lt;p&gt;4：gitlab工作流之环境分支&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.1035714285714286&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5Wib5Wh04ugzy6UUicicGVSRIyZ5ibBtPdUUaxCJicrKiaW7AkdOgrI7jV1MzRLsnN3xCV7IVsPL6iasRyOpzF5puIHNg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;560&quot;/&gt;&lt;/p&gt;&lt;p&gt;在真实的世界，每个分支对应于基础设施的环境（环境和分支的名称不一样），比如master分支对应于staging环境，pre-production分支对应于仿真环境，production分支对应于线上环境。&lt;/p&gt;&lt;p&gt;如果想在仿真测试，将master合并到pre-production分支；仿真测试没问题后，再将pre-production分支合并到production分支上。&lt;/p&gt;&lt;p&gt;这种基于下行的工作流（This workflow, where commits only flow downstream）确保每个环境的代码都是经过测试的。&lt;/p&gt;&lt;p&gt;假如要修复一个bug，cherry-pick一个hotfix提交，通常的做法就是（从master还是production）创建一个feature分支，然后合并到master，此时先不要删除feature分支，测试通过后，再将master合并到其它分支（当然也可以提交一个MR到其他任何的downstream分支）。&lt;/p&gt;&lt;p&gt;我们的工作流有点类似环境分支，因为要确保master分支是真正意义上可部署的，但开发环境的代码只是开发人员自己测试，没有把握直接merge到master，所以在master分支前还有一个qa分支，qa分支由测试人员测试，有几点变化：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;qa环境测试通过基本代表可发布&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;其他特性分支统一合并到qa做测试（而非master）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;并不是将qa分支合并到master分支，而是qa测试通过后，将特性分支合并到master分支，master分支和qa分支是隔离的（这可能会有问题）。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;同理到production分支，不是master分支合并到production分支，也不是qa分支合并到production分支，而是基于特性分支合并到production分支。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;对于共享的特性分支来说，尽量减少提交到远端，或者动不动就合并到qa，这是我们现在比较大的一个问题（开发和测试都在qa分支上）。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;以上还需要理解的更透彻一些。&lt;/p&gt;&lt;p&gt;5：gitlab工作流之发布分支&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.3072727272727274&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5Wib5Wh04ugzy6UUicicGVSRIyZ5ibBtPdUU4w5Gzj4DJuSO2N67QH9ZId0mpPJHhctc1qoNVJ8vb7PMyozhMicUzvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;550&quot;/&gt;&lt;/p&gt;&lt;p&gt;这种工作流可能在互联网公司并不常见，这种场景下，每个分支包含一个版本号（比如2-3-stable, 2-4-stable）。&lt;/p&gt;&lt;p&gt;这些分支基于master，而且尽可能晚一点merge到发布分支，因为减少了bug修复的merge。一般情况下，只有非常严重的bug才会再发布一个版本，具体的做法是先合并到master，然后再cherry-pick到发布分支，这样在后续的版本中就不会遇到相同的bug了，先merge到master再pick到release这种做法叫做upstream first策略，google和red hat就是这么做的。&lt;/p&gt;&lt;p&gt;在release分支中修复一个bug后，也会打一个tag并增加版本号。&lt;/p&gt;&lt;p&gt;6：Merge/pull requests&lt;/p&gt;&lt;p&gt;这两个词是由git管理应用程序（比如gitlab和github）创建的，github上叫做pull request（因为第一个步骤是pull特性分支），gitlab叫做merge request（因为最后一个动作是合并特性分支）。&lt;/p&gt;&lt;p&gt;在特性分支工作了几个小时，为了分享工作成果，可以创建一个MR给任何人（也可以@某个人），这个动作表示该请求并不是为了merge（标题以[WIP]开头），而是希望得到反馈或code review。&lt;/p&gt;&lt;p&gt;团队成员能够对MR进行评论，如果发现问题，任何人（一般是MR发起者）发送一个fix push，这个MR会立刻更新。&lt;/p&gt;&lt;p&gt;如果准备将这个特性分支合并到master，一般将这个MR发给具有一定权限的人，他可以选择merge或者直接关闭MR。&lt;/p&gt;&lt;p&gt;在gitlab中，一般会保护长期存在的分支（比如master），所以开发人员一般不会直接修改该分支，只有特定权限的人才能merge到master分支。&lt;/p&gt;&lt;p&gt;合并完成后，一般会删除特性分支，确保gitlab上的分支大部分都是处于工作状态的，另外再开一个相同名的分支也不会出现问题。&lt;/p&gt;&lt;p&gt;7：Issue跟踪&lt;/p&gt;&lt;p&gt;gitlab工作流可以让issue和代码之间的关系更加透明。&lt;/p&gt;&lt;p&gt;任何的代码修改都来源于一个issue（可能是bug，也可能是需求），并尽量让特性分支范围小一点。&lt;/p&gt;&lt;p&gt;在写代码的时候，根据issue创建一个分支（名字和issue编号有关，比如15-require-a-password-to-change-it），解决后发送MR，merge成功一般会产生一个合并提交（不产生Fast-Forward）。&lt;/p&gt;&lt;p&gt;8：从MR中link或关闭 issue&lt;/p&gt;&lt;p&gt;发送MR的时候，“Fixes #16” ，一方面表示关联issue，另外合并成功过后会自动关闭该issue。&lt;/p&gt;&lt;p&gt;9：通过rebase压缩commit&lt;/p&gt;&lt;p&gt;在git中，能够使用交互式的rebase(rebase -i)将多个请求合并为一个（代表完成一个功能）或重新排序，这个功能很有用。&lt;/p&gt;&lt;p&gt;但如果你的提交已经提交到远程仓库（相同的分支还有其他开发者），则必须禁止rebase，因为rebase会产生新的commit（就是commit id会变化），从而导致合并冲突，因为相同的变化有不同的commit id；也会导致合并错误，因为对于工作在相同分支上的人来说，他们的git历史和你的提交并不匹配。&lt;/p&gt;&lt;p&gt;如果rebase已经同步到远端的分支，对于作者和其他合作者都会很麻烦，一些人已经review过代码了，但rebase会让人很难知道上次review后发生了什么。&lt;/p&gt;&lt;p&gt;由于&lt;strong&gt;我们现在&lt;/strong&gt;很多人在一个分支上开发，会经常遇到同一个分支merge的问题，建议不要使用rebase -i或rebase合并（需要进一步理解），而使用merge（虽然会导致git历史不太好看）。&lt;/p&gt;&lt;p&gt;如果合并的时候有很多提交，恢复的时候比较难，可以通过gitlab的Squash-and-Merge功能，就是在合并的时候压缩为一个提交。另外还有一个简单办法可以撤销（revert）所有的提交，就是总是使用“no fast-forward” (—no-ff) 策略。&lt;/p&gt;&lt;p&gt;这个工作流在工作中很常见，需要&lt;strong&gt;仔细体会&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;10：减少在特性分支上进行merge操作&lt;/p&gt;&lt;p&gt;如果一个分支上有很多merge提交，会让git历史记录很混乱，所以应该尽量避免在特性分支上进行merge操作。&lt;/p&gt;&lt;p&gt;通常在master分支上如果有新的提交，建议通过rebase重新排序或合并commit，从而避免merge操作(Often, people avoid merge commits by just using rebase to reorder their commits after the commits on the master branch)。&lt;strong&gt;题外音&lt;/strong&gt;，很少会在master上提交。&lt;/p&gt;&lt;p&gt;在特性分支上，如果需要同步master的操作，应该使用rebase master，尽量避免merge master，从而保持一个线性的提交。当然上面也说过了，如果你的分支已经在远端和人分享了，应该避免进行rebase操作。&lt;/p&gt;&lt;p&gt;rebase操作会产生很多的工作，每次rebase的时候，会处理相同的冲突，而merge更合适，解决冲突只需要一次。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;听了那么多&lt;/strong&gt;，在本地开发的时候建议rebase -i，在master的时候可以rebase，其他场景建议少用。&lt;/p&gt;&lt;p&gt;接下去回答为啥应该减少在特性分支上进行merge操作。一般情况下进行在特性分支上进行merge有三个原因。&lt;/p&gt;&lt;p&gt;（1）utilizing 新代码，假如你想使用master上的一些新代码（特性分支创建后产生的提交），可以使用cherry-picking一个commit。&lt;/p&gt;&lt;p&gt;（2）解决合并冲突，如果一个特性分支有很多开发者，在更新代码的时候比如会遇到冲突，所以合并也是合理的。&lt;/p&gt;&lt;p&gt;（3）同步master上的代码&lt;/p&gt;&lt;p&gt;为了保证特性分支上的代码较新（short-lived），有的时候会合并master上的代码（有时候我经常这么做），但其实应该减少这样的行为，大部分特性分支应该小于一天的工作量（&lt;strong&gt;并不现实&lt;/strong&gt;，至少我没见过），如果花费很长时间，建议将任务拆分的更小。&lt;/p&gt;&lt;p&gt;对于多余一天工作量的分支，有两种策略保持代码较新：&lt;/p&gt;&lt;p&gt;（1）将代码merge到master做CI，CI/CD提倡自动化测试，其实目前我们做不到，是不太敢直接提交到master分支，这种观念很难&lt;strong&gt;扭转&lt;/strong&gt;过来。&lt;/p&gt;&lt;p&gt;（2）Another option is to only merge in from well-defined points in time, for example, a tagged release（没理解）。&lt;/p&gt;&lt;p&gt;另外合并到master就代表引入了新功能，代表可以部署了，&lt;/p&gt;&lt;p&gt;有的时候特性分支经常性合并到master做CI，虽然测试没问题，但可能功能还没完成或不想暴露出来，此时必须使用feature toggles隐藏未完成的测试。&lt;/p&gt;&lt;p&gt;总之，特性分支应该尽量减少合并提交，但不要消除它们。codebase应该保持干净，但也要记录实际发生的情况（历史记录很重要）。&lt;/p&gt;&lt;p&gt;这个工作流在工作中很常见，需要&lt;strong&gt;仔细体会&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;11：commit信息应该有意义&lt;/p&gt;&lt;p&gt;commit不仅仅是提交代码，还要体现出意图，所以少用fix，improve这样的字眼。&lt;/p&gt;&lt;p&gt;12：合并之前要测试&lt;/p&gt;&lt;p&gt;一般情况下，特性分支会做CI持续集成，测试通过才会发送MR，这个是没有问题的，但有个问题，只测试特性分支而没有测试merge后的代码。&lt;/p&gt;&lt;p&gt;也就是说merge后还要再测试一次，看上去很浪费时间。&lt;/p&gt;&lt;p&gt;但其实如果合并没有冲突，特性分支合并到master的风险是可控的，如果有冲突，应该将master代码merge到特性分支重新进行测试，测试通过后，再merge到master。&lt;/p&gt;&lt;p&gt;13：在特性分支上进行工作&lt;/p&gt;&lt;p&gt;一般情况下，初始化一个feature分支时总是从最新的master分支（upstream分支）拉取的代码。&lt;/p&gt;&lt;p&gt;假如已经知道你的分支依赖别的分支，则可从该依赖分支拉取代码。&lt;/p&gt;&lt;p&gt;如果特性分支需要合并到别的分支，那么需要在merge commit的信息中写清楚原因。&lt;/p&gt;&lt;p&gt;如果还没有把特性分支的commit提交的远程库，那么可以rebase master或其他分支（这样历史信息更有用）。&lt;/p&gt;&lt;p&gt;如果代码正常工作且不需要合并，那么就不要再一次merge upstream分支，Merging only when needed prevents creating merge commits in your feature branch that later end up littering the master history.&lt;/p&gt;&lt;p&gt;参考：https://docs.gitlab.com/ee/topics/gitlab_flow.html&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>