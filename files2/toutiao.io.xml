<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>828293600a26852bdfdc48a2a064091e</guid>
<title>一起聊聊 Go Context 的正确使用姿势</title>
<link>https://toutiao.io/k/gbdgzek</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是煎鱼。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Go 语言中，Goroutine（协程），也就是关键字 &lt;code&gt;go&lt;/code&gt; 是一个家喻户晓的高级用法。这起的非常妙，说到 Go，就会想到这一门语言，想到 goroutine 这一关键字，而与之关联最深的就是 context。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4jGX464icOIibEH9tQmxEwY73K9yKic3E1aaGAtWIIEVYylibQrMttK6EibN7ia9I1fpGd59hzg6fhZ9icxg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1440&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;背景&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;平时在 Go 工程中开发中，几乎所有服务端（例如：HTTP Server）的默认实现，都在处理请求时新起 goroutine 进行处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但一开始存在一个问题，那就是当一个请求被取消或超时时，所有在该请求上工作的 goroutines 应该迅速退出，以便系统可以回收他们正在使用的任何资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当年可没有 context 标准库。很折腾。因此 Go 官方在 2014 年正式宣发了 context 标准库，形成一个完整的闭环。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但有了 context 标准库，Go 爱好者们又奇怪了，前段时间我就被问到了：“Go context 的正确使用姿势是怎么样的”？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（一张忘记在哪里被问的隐形截图）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天这篇文章就由煎鱼带你看看。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Context 用法&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Go context 用法中，我们常常将其与 select 关键字结合使用，用于监听其是否结束、取消等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; shortDuration = &lt;span&gt;1&lt;/span&gt; * time.Millisecond&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; ctx, cancel := context.WithTimeout(context.Background(), shortDuration)&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; cancel()&lt;br/&gt;&lt;br/&gt; &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; &amp;lt;-time.After(&lt;span&gt;1&lt;/span&gt; * time.Second):&lt;br/&gt;  fmt.Println(&lt;span&gt;&quot;脑子进煎鱼了&quot;&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; &amp;lt;-ctx.Done():&lt;br/&gt;  fmt.Println(ctx.Err())&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;context deadline exceeded&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是更进一步结合 goroutine 的话，常见的例子是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(ctx context.Context)&lt;/span&gt; &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  dst := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;  n := &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; &amp;lt;-ctx.Done():&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; dst &amp;lt;- n:&lt;br/&gt;     n++&lt;br/&gt;    }&lt;br/&gt;   }&lt;br/&gt;  }()&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; dst&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们平时工程中会起很多的 goroutine，这时候会在 goroutine 内结合 for+select，针对 context 的事件进行处理，达到跨 goroutine 控制的目的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;正确的使用姿势&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;对第三方调用要传入 context&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Go 语言中，Context 的默认支持已经是约定俗称的规范了。因此在我们对第三方有调用诉求的时候，要传入 context：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; req, err := http.NewRequest(&lt;span&gt;&quot;GET&quot;&lt;/span&gt;, &lt;span&gt;&quot;https://eddycjy.com/&quot;&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  fmt.Printf(&lt;span&gt;&quot;http.NewRequest err: %+v&quot;&lt;/span&gt;, err)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; ctx, cancel := context.WithTimeout(req.Context(), &lt;span&gt;50&lt;/span&gt;*time.Millisecond)&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; cancel()&lt;br/&gt;&lt;br/&gt; req = req.WithContext(ctx)&lt;br/&gt; resp, err := http.DefaultClient.Do(req)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  fmt.Printf(&lt;span&gt;&quot;http.DefaultClient.Do err: %+v&quot;&lt;/span&gt;, err)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; resp.Body.Close()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样子由于第三方开源库已经实现了根据 context 的超时控制，那么当你所传入的时间到达时，将会中断调用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;若你发现第三方开源库没支持 context，那建议赶紧跑，换一个。免得在微服务体系下出现级联故障，还没有简单的手段控制，那就很麻烦了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;不要将上下文存储在结构类型中&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家会发现，在 Go 语言中，所有的第三方开源库，业务代码。清一色的都会将 context 放在方法的一个入参参数，作为首位形参。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.48981900452488686&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4jGX464icOIibEH9tQmxEwY73eI5x3wWib6JCr7MgTPXzkKQoPESyFJOjyALJe94By0Tian0WVDnFysNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1768&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标准要求：每个方法的第一个参数都将 context 作为第一个参数，并使用 ctx 变量名惯用语。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，我们也不能一杆子打死所有情况。确实存在极少数是把 context 放在结构体中的。基本常见于：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个请求都是独立的，context 自然每个都不一样，想清楚自己的应用使用场景很重要，否则遵循 Go 基本规范就好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在真实案例来看，有的 Leader 会单纯为了不想频繁传 context 而设计成结构体，结果导致一线 RD 就得天天 NewXXX，甚至有时候忘记了，还得背个小锅。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;函数调用链必须传播上下文&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们会把 context 作为方法首位，本质目的是为了传播 context，自行完整调用链路上的各类控制：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;List&lt;/span&gt;&lt;span&gt;(ctx context.Context, db *sqlx.DB)&lt;/span&gt; &lt;span&gt;([]User, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; ctx, span := trace.StartSpan(ctx, &lt;span&gt;&quot;internal.user.List&quot;&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; span.End()&lt;br/&gt;&lt;br/&gt; users := []User{}&lt;br/&gt; &lt;span&gt;const&lt;/span&gt; q = &lt;span&gt;`SELECT * FROM users`&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err := db.SelectContext(ctx, &amp;amp;users, q); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, errors.Wrap(err, &lt;span&gt;&quot;selecting users&quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; users, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像在上述例子中，我们会把所传入方法的 context 一层层的传进去下一级方法。这里就是将外部的 context 传入 List 方法，再传入 SQL 执行的方法，解决了 SQL 执行语句的时间问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;context 的继承和派生&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Go 标准库 context 中具有以下派生 context 的标准方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;WithCancel&lt;/span&gt;&lt;span&gt;(parent Context)&lt;/span&gt; &lt;span&gt;(ctx Context, cancel CancelFunc)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;WithDeadline&lt;/span&gt;&lt;span&gt;(parent Context, d time.Time)&lt;/span&gt; &lt;span&gt;(Context, CancelFunc)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;WithTimeout&lt;/span&gt;&lt;span&gt;(parent Context, timeout time.Duration)&lt;/span&gt; &lt;span&gt;(Context, CancelFunc)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码例子如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;handle&lt;/span&gt;&lt;span&gt;(w http.ResponseWriter, req *http.Request)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// parent context&lt;/span&gt;&lt;br/&gt; timeout, _ := time.ParseDuration(req.FormValue(&lt;span&gt;&quot;timeout&quot;&lt;/span&gt;))&lt;br/&gt; ctx, cancel := context.WithTimeout(context.Background(), timeout)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// chidren context&lt;/span&gt;&lt;br/&gt; newCtx, cancel := context.WithCancel(ctx)&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; cancel()&lt;br/&gt; &lt;span&gt;// do something...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般会有父级 context 和子级 context 的区别，我们要保证在程序的行为中上下文对于多个 goroutine 同时使用是安全的。并且存在父子级别关系，父级 context 关闭或超时，可以继而影响到子级 context 的程序。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;不传递 nil context&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多时候我们在创建 context 时，还不知道其具体的作用和下一步用途是什么。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种时候大家可能会直接使用 &lt;code&gt;context.Background&lt;/code&gt; 方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; (&lt;br/&gt;   background = &lt;span&gt;new&lt;/span&gt;(emptyCtx)&lt;br/&gt;   todo       = &lt;span&gt;new&lt;/span&gt;(emptyCtx)&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Background&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;Context&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; background&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;TODO&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;Context&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; todo&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但在实际的 context 建议中，我们会建议使用 &lt;code&gt;context.TODO&lt;/code&gt; 方法来创建顶级的 context，直到弄清楚实际 Context 的下一步用途，再进行变更。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;context 仅传递必要的值&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在使用 context 作为上下文时，经常有信息传递的诉求。像是在 gRPC 中就会有 metadata 的概念，而在 gin 中就会自己封装 context 作为参数管理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 标准库 context 也有提供相关的方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Context&lt;br/&gt;    &lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;WithValue&lt;/span&gt;&lt;span&gt;(parent Context, key, val &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;Context&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码例子如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;type&lt;/span&gt; favContextKey &lt;span&gt;string&lt;/span&gt;&lt;br/&gt; f := &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(ctx context.Context, k favContextKey)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; v := ctx.Value(k); v != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   fmt.Println(&lt;span&gt;&quot;found value:&quot;&lt;/span&gt;, v)&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  fmt.Println(&lt;span&gt;&quot;key not found:&quot;&lt;/span&gt;, k)&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; k := favContextKey(&lt;span&gt;&quot;脑子进&quot;&lt;/span&gt;)&lt;br/&gt; ctx := context.WithValue(context.Background(), k, &lt;span&gt;&quot;煎鱼&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt; f(ctx, k)&lt;br/&gt; f(ctx, favContextKey(&lt;span&gt;&quot;小咸鱼&quot;&lt;/span&gt;))&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;found value: 煎鱼&lt;br/&gt;key not found: 小咸鱼&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在规范中，我们建议 context 在传递时，仅携带必要的参数给予其他的方法，或是 goroutine。甚至在 gRPC 中会做严格的出、入上下文参数的控制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在业务场景上，context 传值适用于传必要的业务核心属性，例如：租户号、小程序ID 等。不要将可选参数放到 context 中，否则可能会一团糟。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;对第三方调用要传入 context，用于控制远程调用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不要将上下文存储在结构类型中，尽可能的作为函数第一位形参传入。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;函数调用链必须传播上下文，实现完整链路上的控制。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;context 的继承和派生，保证父、子级 context 的联动。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不传递 nil context，不确定的 context 应当使用 TODO。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;context 仅传递必要的值，不要让可选参数揉在一起。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e009068c0019ab33652bb39889d28a5d</guid>
<title>声网下一代视频引擎架构探索与实践</title>
<link>https://toutiao.io/k/imed5iy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;为应对愈发多样化的音视频互动场景下的挑战，Agora 开始设计自己的下一代视频处理引擎，在过程中关于引擎架构、性能调优、插件系统设计等方面总结了很多经验，希望与各位音视频领域的爱好者、行业从业者分享。&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;月26日下午&lt;/span&gt;&lt;span&gt;，QCon全球软件开发大会「实时音视频专场」活动中，声网Agora 架构师李雅琪带来了以《声网下一代视频处理引擎》为主题的大量干货分享，本文是对分享内容的整理。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;今天的分享主要会分三部分来进行：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;一，为什么我们要打造下一代视频处理引擎，以及引擎的设计原则和目标是什么；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;二，我们是如何达到设计原则和目标的；&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;三，下一代视频引擎的实际落地效果如何。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-type=&quot;png&quot; data-w=&quot;776&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBEia71SKY2bboiaVv2ojGWJveiaOJSLu9Dks1lG3UIuWxT9e9Y1IOhTK4lFcDEzcicaoiaQb74IlK3W1HA/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBEia71SKY2bboiaVv2ojGWJveJ6UicrPMKTKYrnl85DdGuS3HMJ9hVHKapHNowziby5BQnwnk3GqxkFvg/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着音视频技术快速发展，&lt;strong&gt;&lt;span&gt;实时音视频互动在各种各样的领域，如社交娱乐、在线直播、医疗中都得到了广泛的应用和发展。&lt;/span&gt;&lt;/strong&gt;疫情以来，越来越多的场景迁移到线上，不少读者可能也都有观看直播带货，或是陪小孩参加在线教育的经历。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么这两个场景中会有哪些痛点呢？在视频直播场景中，处理多路视频源的需求越来越广泛。比如电商直播场景中，主播通常需要使用多个机位进行多角度拍摄，以达到更好的带货效果。这类直播可能还会同步搭配使用导播台，在多个视频源中进行多种实时直播组合和无缝切换。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而对于在线教育场景来说，比较传统的方式是摄像头拍摄老师，老师进行屏幕分享。为了丰富在线教育的手段，我们还可以增加一路视频拍摄，拍摄老师在手写板上的书写，甚至额外增加一个功能，支持老师播放本地课件或者在线课件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在多路视频源的基础上，还会衍生出来对多路视频源的实时编辑和合图的需求。在直播助手的应用场景中，主播可能需要对多路视频源的采集进行实时合图和编辑，再添加本地素材和动态表情包来丰富直播效果，同时降低上行带宽压力。在多人互动场景中，为了降低接收端的带宽压力和性能损耗，需要在云端将多路主播视频合成一路流再发送给各个接收端。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着 AI 技术在图像处理的快速发展，融合 AI 算法的高级视频前处理功能也得到越来越多的应用，诸如一些高级美颜功能、背景分割、背景替换。结合这三个场景我们可以看到，&lt;strong&gt;&lt;span&gt;下一代视频引擎的灵活可扩展能力被提出了更高的要求。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBEia71SKY2bboiaVv2ojGWJveWfmaPbTolT5GBVylVf2wNQpfmfyEicT9BbAm9LM0AlkA5tZ28O26ePg/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，随着我们公司业务和团队规模的不断增长，下一代视频引擎的用户体量也在剧增，不同用户对集成开发的需求也各异。对于研发团队规模较小的开发者或个人开发者，他们需要的是引擎的集成简易度，低代码量，快速上线。而对于企业业务中台的开发者，会要求引擎开放更多的基础视频处理功能，从而可以定制化的实现视频处理业务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;面向各开发者群体的需求，&lt;strong&gt;&lt;span&gt;声网的下一代视频处理引擎需要一个有弹性的设计来满足差异化的集成需求。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBEia71SKY2bboiaVv2ojGWJveOfGXicGfQQdOcXhWTViarFDuibXoXU9s0lQqibbdIYKocOeYSrxyDoYIxA/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不仅是弹性的设计，视频直播体验也是很重要的指标。随着 5G 时代的到来，网络基础设施足够支持用户对更清晰更流畅直播的体验需求，下一代 SDK 必须在性能优化方面做到极致，&lt;strong&gt;&lt;span&gt;支持更高的视频分辨率，更高的帧率。&lt;/span&gt;&lt;/strong&gt;考虑到实时互动业务场景不断扩展，用户分布也越来越广，为了在网络基础设施较弱的国家和地区、性能较差的低端机型上，引擎都可以提供比较好的视频直播体验，&lt;strong&gt;&lt;span&gt;我们就要支撑更好的弱网抗性，并优化性能资源消耗。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBEia71SKY2bboiaVv2ojGWJve9wicGUkluia1oYrZDrLibbMQnEIZWM884HMk7TnztKTvqIzegg0WVqsjA/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;结合上面提到的场景丰富性、用户差异性，以及对视频直播体验的需求。我们将下一代视频处理引擎设计原则和目标可以总结为四个方面：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;1. 满足不同的用户对集成的差异化需求；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 灵活可扩展，可快速支撑各种新业务和新技术场景落地；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. 视频处理引擎的核心系统要提供丰富强大的功能，降低开发人员的心智负担，做到快速可靠；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 性能优越可监控，需要持续优化视频直播处理引擎性能，同时提高监控手段，形成闭环并不断迭代优化引擎的处理性能。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来我们进入第二部分，针对上面所提到的四个设计目标，声网具体采用了哪些软件设计的方法来进行实施落地。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-type=&quot;png&quot; data-w=&quot;776&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBEia71SKY2bboiaVv2ojGWJveaRwfUBCKjclcKnCC7qmrCNxU9c4iaTIsaGx54brs4mXm7p32Jm92j2g/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBEia71SKY2bboiaVv2ojGWJvecA8EdLP7Gw8LeAylw0iaeyDWkcicqG9ZfVvxJpTcjk7Kz4KIzZahia29g/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;前面提到的第一个设计目标，我们要满足不同用户差异化的集成需求：引擎的使用者是天然分层的，一部分使用者追求低代码快速上线，需要引擎尽可能提供贴近他业务的功能；另外一部分用户，需要我们提供更多的核心视频基础能力，在这之上客户可以按照自己的需要定制视频处理业务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据这个用户形态我们的架构也采取分层业务设计，分成 High Level 和 Low Level。Low level 部分是面向视频处理核心功能进行建模，抽象出了视频源处理单元，前/后处理单元、渲染器单元、编解码器单元、核心基础设施单元等。通过这些基础模块的组合和开发，在 Low level 的基础上，我们又抽象出面向客户业务的视频源 Track 的概念，网络视频流 Stream 的概念和场景的概念，在这上面封装了更贴近用户业务的 High Level API 。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBEia71SKY2bboiaVv2ojGWJveaxm3u5Wq6rgVxo0D3cPCXxWbPa7HSckc96bW1axbvUs7sDGMwPsalA/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们来通过实际例子看一下 High Level 和 Low Level 两者在使用上的差别：假设现在要实现一个非常简单的场景，打开本地摄像头开启预览，发布到远端。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果使用 High Level API，可以只通过 2 个简单 API 的调用，完成这个实时互动业务场景的搭建。首先通过 StartPreview API 开启本地摄像头并预览，然后通过 JoinChannel API 加入频道并发布视频流。若用户想在这一简单场景上实现更多定制业务功能，就可以使用 Low Level API。首先创建本地相机采集管线 CreateCameraTrack，这个 Track 提供了多种多样进行形态组建和状态控制的接口。同时我们将本地媒体处理和网络发布节点进行了解耦，视频流可以发布到声网自研的 RTC 系统中去或发布到 CDN 网络。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBEia71SKY2bboiaVv2ojGWJve5iaCgQR2GKr7iccNcy40NNicYrSdHZfgDJYQ5xvEb3pnDmSYibhloY7EIw/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过上面的例子可以看出。为了满足用户差异化需求我们采用了分层设计，High Level 面向业务提供易用性，Low Level 提供核心功能和灵活性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBEia71SKY2bboiaVv2ojGWJveaNVeqovgFw90Ckpia5O6zvbSyZEuvMTFpHBLL5Wdx14aWmErNNaxK6Q/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们看第二个目标，灵活可扩展这一点我们是如何做到的呢？在这之前我简单介绍一下关于视频处理当中的基本概念，视频处理的过程是以视频帧作为视频数据的载体。以本地发送处理流程为例，视频数据被采集之后会经过一系列的前处理单元，然后送到编码器单元进行压缩编码，最后根据不同网络协议通过封装之后发送到远端网络。接收的处理流程是从网络当中接收到视频流后进行解封装操作，送到解码器当中，经过一系列后处理单元后，再到渲染器进行展示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们把以视频帧为数据载体的序列化视频处理 称为视频处理管线，每一个视频处理单元我们把它称为一个模块。每个具体的视频处理单元可以有不同的实现，比如说视频源模块，可以是自采集的视频源，可以是摄像头采集的视频源或者屏幕共享的视频源。不同编码器根据编码标准和编码器实现也是可以有不同的扩展功能。网络发送节点可以根据不同协议发送到自研的 RTC 网络或者 CDN。不同的视频业务其实是基础视频处理单元根据业务灵活编排形成的。我们希望可以把灵活编排的能力作为我们视频处理引擎的基础能力开放给到开发者，这样开发者就可以通过灵活自由的 API 组合，搭建满足自己业务需求的处理管线。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YO07vjlZVBEia71SKY2bboiaVv2ojGWJvew4maDKcWyfKXhu7KwIssmlJ7pTYdPy5RuSQyoRtdvtaFEtq4U0W4xA/640?wx_fmt=jpeg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;为了做到这一点，我们的视频处理引擎核心架构是采用了 Microkernel Architecture 的架构，分离了整个引擎的变量和不变量。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;span&gt;如图所示分两个部分，中间的 Core System 和外围的 Pluggable modules。中间黄色的部分是整个的核心系统部分，对应着整个下一代视频处理引擎的不变量。在核心系统中，我们抽象出来了各个基础视频处理单元的模块，以及提供了统一的控制面和数据面的接口。同时，引擎还提供了对这些基础视频模块进行组装和灵活编排的控制接口。此外，核心系统还提供了一系列基础设施功能，比如跟视频处理相关的视频数据格式转换，基础的视频处理算法，针对视频处理特征进行内存管理优化的内存池以及线程模型，日志系统和消息总线等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;利用核心系统底层能力，各个模块可以方便地进行业务扩展，比方说视频源模块，可以有推流模式视频源模块，也可以支持拉流模式的视频源模块，甚至支持一种特殊的视频源，即在转码的过程我们可以把远端用户的视频解码后的视频帧作为新的视频源加入到本地发送的管线当中去。前处理模块和后处理模块也可以扩展出各种各样的实现，如基础的裁减缩放功能、美颜、水印功能等。编解码模块更为复杂，一方面要支持多种编码标准，还有相应多种实现，软硬编等。同时，编解码选择还是一个比较复杂的动态决策过程，我们在编解码基础模块当中内置了根据能力协商、机型和实时视频编码质量进行动态选择切换的编码器选择策略。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YO07vjlZVBEia71SKY2bboiaVv2ojGWJvenT7L8KXicKsEiaFGb0zb1fvfQ84KjMNDhrESTibbPyhmtYVl6K99N9mmA/640?wx_fmt=jpeg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来，结合实际运用场景看我们如何灵活的搭建视频处理管线满足不同的业务组合场景。回到在线教育场景当中，假设现在在一个复杂的在线教育场景当中，需要一个摄像头拍摄老师黑板书写，再有一路摄像头拍摄老师的人像，同时老师会通过屏幕共享进行课件分享，或者使用媒体播放器来播放本地或者在线的多媒体视频文件。一些高级场景当中，老师为了更好的直播效果，会开启背景分割和背景替换模式，把老师的头像和课件叠加在一起，达到更好的效果。老师还可以在本地开启录制功能，将自己直播上课的视频录制到本地。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBEia71SKY2bboiaVv2ojGWJvehCzN89KEUNntSzsNQtIhSXSDicW8VZj2IwmrN8piaUMiahRBR8oclsnIQ/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对复杂的组合应用都可以通过管线搭建来实现，上图是一个本地处理管线的概念图，对于刚才所说的拍摄黑板，老师人像和课件分享，我们可以通过动态替换采集源模块的具体实现来做。背景分割是特殊的前处理模块，可以将老师头像实时分析出来，然后再叠加到屏幕共享的采集源上。本地录制是一种特殊形态的渲染器模块，它是将本地视频帧按照文件格式封装、存储到本地路径当中，我们将整个媒体处理和最后网络发送进行解耦，它可以动态选择是推送到我们的 RTC 网络中还是推送到 CDN。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBEia71SKY2bboiaVv2ojGWJveg6icLRcYyibfjqibv917L6vClKXYQfqM7YQTII9gXmJKWPgHcNA2LkqHQ/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来看一个接收管线组合应用的场景，我们后台有一个后台媒体处理中心，可以根据用户业务处理器需求去进行实时的流媒体处理服务，其中包括云录制（对接收到的视频进行转储）云端进行视频鉴黄，低码高清处理，合图转码服务等。还有 Cloud Player 功能，将远端视频拉取下来之后推到 RTC 频道当中去。以及旁路推流，可以在我们 RTC 网络当中将接收到的视频流转推到 CDN 当中去。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那接下来我们看一下是如何通过搭建接收管线来满足不同运用场景的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBEia71SKY2bboiaVv2ojGWJveiazZzE6Q3EJXicicqkdWw0HHQRohB0cYfG0EZV6HAuwMyluUyofLJz0ibA/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先是我们网络接收源的模块，它可以通过动态切换来接收来自 RTN 网络或者 CDN 的视频流。通过解码器模块之后送到一系列后处理模块当中去，包括刚才提到的鉴黄模块、低码高清后处理模块等等。接收的渲染器模块的数量和位置都是可以灵活定制的，比如刚才云录制的功能，它实际上就是一个特殊的渲染器模块。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;刚才介绍的是我们通过微内核式架构设计实现了灵活扩展目标，各个模块功能可以快速扩展的。视频处理管线也可以通过搭积木式的组合来实现业务的灵活编排。接下来我们看一下快速可靠这个目标，我们是想说&lt;strong&gt;&lt;span&gt;我们核心系统要提供丰富且稳定的功能，在这基础上可以极大降低开发工作人员的心智负担，提升研发效能。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBEia71SKY2bboiaVv2ojGWJveOTYe8e6Hjzla88n42ZtYTYKO67fic73B7uFyLiawd4cDaUOpAjW1TpbQ/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;介绍这个之前，我们先想一个问题，如果我们没有一个稳定可靠的核心系统，一个开发人员要从零开始在我们的管线上开发一个美颜插件，需要思考哪些问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;首先毫无疑问是要开发美颜本身的业务逻辑。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;除此之外，在跟管线集成的时候，首先要考虑模块在管线当中是否可以加载到正确的位置，前序处理模块对它有哪些影响，以及它的业务模块对后续功能产生哪些影响。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;第二是数据格式问题，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;当管线上流转的数据格式不是美颜模块需要用到的格式的时候，它要对数据格式进行转换，这个数据转换算法实现的业务逻辑也需要模块的开发者来实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;接下来是和管线集成过程当中，它需要了解整个管线的线程模型和内存管理模式。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;在配合管线的状态切换当中，美颜模块自身也要实现相应的状态控制的业务逻辑。同时，在一个管线当中，如果后续节点根据视频质量对前序节点有反馈的话，譬如后续节点说你需要调节你的吞吐量，它也需要有一种机制来接收和处理后续模块反馈的消息。同时，当美颜插件运行的时候，有一些消息通知要发送给用户的话，就需要设计一套消息通知机制。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBEia71SKY2bboiaVv2ojGWJvevph0JBu4bHfkM3I0GXWxgxelcwAUDHLW6Uu2469q4ib0pTpMBICJnrA/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于美颜插件是集成到提供了核心功能的 SDK 当中，插件的开发就会变得特别简单，插件作者只要按照核心系统的接口协议的约定去实现相关的接口即可，核心系统会自动根据它的功能以及从全局性能优化的角度，把它加载到正确的位置，那我们 SDK 的使用者就可以使用这个插件了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总结一下，关于快速可靠这一块实现了丰富强大的核心系统功能，可以极大降低模块开发者的心智负担，从而提升研发效能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBEia71SKY2bboiaVv2ojGWJveYIuxtJeicfqIKFiadXicCymT0R75NI0ic4ggvibmiaWomfuZg4H0IcU4UNcA/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后，我们来看一下性能优越可监控这一块，首先我们对整个视频处理管线在移动端上数据传递效率进行优化，实现了对移动端原生数据格式全链路支持，包括采集模块、渲染模块、前处理模块，使用硬件的情况下可以实现整个处理链路的零拷贝，同时根据各个模块处理特性协商，可以把相应模块在管线上的位置进行优化，减少 CPU 和 GPU 跨越，从而更好的提高数据传输效率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBEia71SKY2bboiaVv2ojGWJveNTzAUTGbeLaNic6bdQVzfvMCvuv4lX0HTYKrq2boSpbbAticPegqQqtQ/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，我们在刚才也提到了通过基础视频处理单元，将控制面和数据面进行了一定分离，这样有一定的好处，比如用户对模块控制可以得到及时的响应，对于摄像机这类设备操作，是属于比较重的操作。当用户频繁切换前置后置摄像头时，这类操作会阻塞用户 UI 造成较大延时。通过进行控制面和数据面的分离，我们可以在保证最后状态正确性的前提下实现快速响应的相机操作。并让控制路径不再阻塞数据流转。同时控制路径可以不阻塞数据流转，我们可以做到对本地图源进行实时编辑和发送。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBEia71SKY2bboiaVv2ojGWJvetWo2njfltn64E7Od2wUlGINmm9ZnIjbnIBT9XGqiaaX4uV8uQicDm1mA/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;降低系统资源消耗方面，我们构建了适用于视频数据存储格式的内存池，支持多种视频格式的帧间内存复用，同时，可以根据系统内存使用情况和管线负载情况、动态调整达到动态平衡的状态，这样可以减少频繁的内存分配和释放，从而降低 CPU 使用率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBEia71SKY2bboiaVv2ojGWJveLHUt8j9JBId95XIeQ7MyC0xzltekyE1NoU2zQnkre0HvkT1LM5ZaIw/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后，为了形成一个性能优化闭环反馈的通路，我们实现了全链路的性能质量监控机制，对每一个基础视频处理单元，都会统计和上报入帧和出帧的分辨率和和帧率，以及一些模块特有的数据。系统层面上对耗时较长的任务也有监控和上报，根据不同问题调查的需求，我们将这部分数据按需导入用户本地日志，并将体验相关的数据上报线上质量监控系统，达到对问题快速定位以及优化性能反馈的效果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总结一下，&lt;strong&gt;&lt;span&gt;在性能优越可监控方面，我们首先优化了移动端数据处理链路，分离了控制面和数据面，提升了整体视频数据的传输效率。另外构建了视频处理特性相关的内存池来降低系统资源消耗。最后，实现了全链路视频质量监控机制，来对视频优化性能达到闭环反馈的效果。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实际上，我们现在下一代视频处理引擎已经进入到了落地和打磨阶段。架构优越性在实践中也得到了验证，我们现在就来看一下实际应用案例。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;下一代视频引擎具有高度的灵活性和可扩展性。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;基于这个视频引擎，通过业务组合方式搭建了前后端统一的合图转码通用框架，基于这个框架基础上，我们可以快速响应前端和后端的各类合图需求。比如在线视频相亲场景，这是典型的多人互动实时场景，传统一个嘉宾需要订阅红娘以及其他嘉宾视频流，对下行带宽和机器处理性能造成很大的压力，为了解决这个问题，我们快速运用合图转码通用框架上线云端合图项目，在云端将各个嘉宾和红娘视频合成一路流再推送给观众。同时合图布局和背景图、嘉宾视频中断显示策略可以根据用户业务进行定制: 比如显示最后一帧、背景图、占位图等等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同样的合图转码框架应用在本地的话，我们实现了本地实时视频编辑混流的功能，可以用在电商直播等等领域当中，主播可以在本地将各种各样图源，比如多路摄像头，多路屏幕共享，媒体播放器和远端用户视频以及不同的图片素材进行实时合流推送。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们分享就这些，谢谢大家！&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>33cec1f3d81459b80544683cbbd72752</guid>
<title>Google 官方开源的推荐系统工具库介绍（含视频教程）</title>
<link>https://toutiao.io/k/69gbf1t</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzA3MzM4NDQ2MQ==&amp;amp;mid=2247484958&amp;amp;idx=1&amp;amp;sn=cfedfb5de6ae5d0e535f5007f4900b0c&amp;amp;scene=21#wechat_redirect&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;    1. 谷歌开源推荐系统库(TensorFlow Recommenders)&lt;/a&gt;&lt;br/&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1OTMyNDcxMQ==&amp;amp;mid=2247495121&amp;amp;idx=1&amp;amp;sn=9d0291a33026a0dcf826cd556a68c7fc&amp;amp;scene=21#wechat_redirect&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;    2. 中文视频 | TF Recommenders 系列视频教程&lt;/span&gt;&lt;/a&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;TensorFlow Recommenders&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TensorFlow推荐器是一个使用TensorFlow构建推荐系统模型的库。它有助于构建推荐系统的全部工作流程:数据准备、模型制定、训练、评估和部署。它构建在Keras上，目标是让学习者有一个平缓的学习曲线，同时仍然给你构建复杂模型的灵活性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安装(确保安装了TensorFlow 2.x)&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;pip install tensorflow-recommenders&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TFRS支持：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;建立并评估灵活的推荐检索模型&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自由地将item、user和上下文信息合并到推荐模型中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;联合训练多目标推荐的多任务模型&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;TFRS模块&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;datasets：数据集模块&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;examples：示例中使用的功能模块&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;layers：图层模块&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;losses：损失函数模块&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;metrics：指标模块&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;models：模型模块&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;tasks：任务库模块&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;一个例子&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;导入库&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;import tensorflow_datasets as tfds&lt;br/&gt;import tensorflow_recommenders as tfrs&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;导入数据&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;# 评分数据.&lt;/span&gt;&lt;br/&gt;ratings = tfds.load(&lt;span&gt;&#x27;movie_lens/100k-ratings&#x27;&lt;/span&gt;, split=&lt;span&gt;&quot;train&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;# 电影特征数据.&lt;/span&gt;&lt;br/&gt;movies = tfds.load(&lt;span&gt;&#x27;movie_lens/100k-movies&#x27;&lt;/span&gt;, split=&lt;span&gt;&quot;train&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 选取特征.&lt;/span&gt;&lt;br/&gt;ratings = ratings.map(lambda x: {&lt;br/&gt;    &lt;span&gt;&quot;movie_id&quot;&lt;/span&gt;: tf.strings.to_number(x[&lt;span&gt;&quot;movie_id&quot;&lt;/span&gt;]),&lt;br/&gt;    &lt;span&gt;&quot;user_id&quot;&lt;/span&gt;: tf.strings.to_number(x[&lt;span&gt;&quot;user_id&quot;&lt;/span&gt;])&lt;br/&gt;})&lt;br/&gt;movies = movies.map(lambda x: tf.strings.to_number(x[&lt;span&gt;&quot;movie_id&quot;&lt;/span&gt;]))&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;构建模型&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;# Build a model.&lt;/span&gt;&lt;br/&gt;class Model(tfrs.Model):&lt;br/&gt;&lt;br/&gt;  def __init__(self):&lt;br/&gt;    super().__init__()&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# user embedding.&lt;/span&gt;&lt;br/&gt;    self.user_model = tf.keras.layers.Embedding(&lt;br/&gt;        input_dim=2000, output_dim=64)&lt;br/&gt;    &lt;span&gt;# movie embedding.&lt;/span&gt;&lt;br/&gt;    self.item_model = tf.keras.layers.Embedding(&lt;br/&gt;        input_dim=2000, output_dim=64)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# 在整个候选数据集上设置检索任务和评估指标。&lt;/span&gt;&lt;br/&gt;    self.task = tfrs.tasks.Retrieval(&lt;br/&gt;        metrics=tfrs.metrics.FactorizedTopK(&lt;br/&gt;            candidates=movies.batch(128).map(self.item_model)&lt;br/&gt;        )&lt;br/&gt;    )&lt;br/&gt;&lt;br/&gt;  def compute_loss(self, features: Dict[Text, tf.Tensor], training=False) -&amp;gt; tf.Tensor:&lt;br/&gt;&lt;br/&gt;    user_embeddings = self.user_model(features[&lt;span&gt;&quot;user_id&quot;&lt;/span&gt;])&lt;br/&gt;    movie_embeddings = self.item_model(features[&lt;span&gt;&quot;movie_id&quot;&lt;/span&gt;])&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; self.task(user_embeddings, movie_embeddings)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;模型训练和评估&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;model = Model()&lt;br/&gt;model.compile(optimizer=tf.keras.optimizers.Adagrad(0.5))&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# Randomly shuffle data and split between train and test.&lt;/span&gt;&lt;br/&gt;tf.random.set_seed(42)&lt;br/&gt;shuffled = ratings.shuffle(100_000, seed=42, reshuffle_each_iteration=False)&lt;br/&gt;&lt;br/&gt;train = shuffled.take(80_000) &lt;span&gt;# 取前8000做训练集&lt;/span&gt;&lt;br/&gt;&lt;span&gt;test&lt;/span&gt; = shuffled.skip(80_000).take(20_000) &lt;span&gt;# 取80000-100000为测试集&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# Train.&lt;/span&gt;&lt;br/&gt;model.fit(train.batch(4096), epochs=5)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# Evaluate.&lt;/span&gt;&lt;br/&gt;model.evaluate(test.batch(4096), return_dict=True)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;更多细节&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;源码：https://github.com/tensorflow/recommenders&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;指南:https://www.tensorflow.org/recommenders/examples/quickstart&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;API：https://www.tensorflow.org/recommenders/api_docs/tfrs&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了TensorFlow Recommenders之外，还开源了一些其他的模块：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;TensorFlow Ranking
https://github.com/tensorflow/ranking&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ScaNN
https://github.com/google-research/google-research/tree/master/scann&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TensorFlow Lite 端侧推荐模
https://tensorflow.google.cn/lite/examples/recommendation/overview&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TensorFlow Model Garden 推荐模型
https://github.com/tensorflow/models/tree/master/official/recommendation&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;TFRS公开课&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;tensorflow官方不仅开源了tfrs的模块，也提供了对应的视频教程，目前视频已被上传到 B 站 TensorFlow 频道中，大家有兴趣可以去进行学习。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;https://www.bilibili.com/video/BV1Hb4y1Z7zK&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一期视频中，主要介绍推荐系统的概述，探讨推荐系统的价值和挑战，并给大家简单介绍 Google 开源的一系列相关组件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二期视频中，主要介绍两种推荐系统的传统算法：基于内容的过滤和协同过滤，从理论的角度看看如何搭建推荐系统。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三期视频中，主要从代码的角度看看如何使用 TensorFlow 2 的核心 API 来搭建推荐系统，并构造一个神经协同过滤模型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第四期视频中，主要介绍的是&lt;span&gt;TensorFlow Recommenders (TFRS)。TFRS 库是专为搭建推荐系统打造的全栈工具库，它包含了一整套的工具来简化搭建推荐系统，也是Google推荐使用的工具库，将演示如何使用 TFRS 构造一个双塔召回模型。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第五期视频中，主要介绍如何使用 TFRS 搭建排序模型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第六期视频中，主要介绍如何使用场景特征和多任务学习来改进推荐模型的准确度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第七期视频中，主要介绍一种更复杂的模型，深度交叉网络 (DCN)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后一期视频中，主要介绍如何使用 ScaNN 工具库高效部署召回模型完成近似近邻搜索。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信大家在观看这八个视频教程后，会对推荐系统和 TF Recommenders 库有一定的了解，从而为以后打造自己的推荐系统打下坚实基础。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，如果你需要打造超大规模的推荐系统，Google已经有了一个 TF SIG Recommenders Addons(TFRA) 社区，由腾讯/阿里/唯品会等公司的同学贡献了许多代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点击文末「&lt;strong&gt;阅读原文&lt;/strong&gt;」，直达视频首页！&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;27&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;27&quot; data-custom=&quot;#1e9be8&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;关注我们不错过每一篇精彩&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI2MDU3OTgyOQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/02kicEWsIniciaRWJ07GCCGQZ65yrAqsUqjdJ5e37HmjZBE5JaFMGb7VmW4p3YcuYRpibEzFTabwl07IaMEqCNwzcA/0?wx_fmt=png&quot; data-nickname=&quot;搜索与推荐Wiki&quot; data-alias=&quot;SearchAndRecWiki&quot; data-signature=&quot;专注于搜索和推荐系统，以系列分享为主，持续打造精品内容！&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;27&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;27&quot; data-custom=&quot;#1e9be8&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;「搜索与推荐Wiki」猜你喜欢&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;93040&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;92886&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;1、&lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MDU3OTgyOQ==&amp;amp;mid=2247496195&amp;amp;idx=1&amp;amp;sn=f790b600e57224e268d1aff976dc88ff&amp;amp;chksm=ea653a99dd12b38f6af2f673015b060522ac75f60320ebbfe8212bcf508deefa9bb1025a0b47&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong/&gt;&lt;/a&gt;&lt;strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MDU3OTgyOQ==&amp;amp;mid=2247499624&amp;amp;idx=1&amp;amp;sn=b9318a4abb28aeadd0b222b3abb6bf2c&amp;amp;chksm=ea6537f2dd12bee40fa9f1d87ab2def8936beb9fef31cf939a092805b64836483827515c5b50&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;推荐系统中稀疏特征Embedding的优化表示方法&lt;/strong&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;span&gt;、&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MDU3OTgyOQ==&amp;amp;mid=2247487385&amp;amp;idx=1&amp;amp;sn=d0ca721eccc33335aa4682035ff432fe&amp;amp;chksm=ea66c703dd114e15f4fca5d6579e08ac7f9ab196b088d1615428b851a9236c41309a62ed9983&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong/&gt;&lt;/a&gt;&lt;strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MDU3OTgyOQ==&amp;amp;mid=2247499624&amp;amp;idx=1&amp;amp;sn=b9318a4abb28aeadd0b222b3abb6bf2c&amp;amp;chksm=ea6537f2dd12bee40fa9f1d87ab2def8936beb9fef31cf939a092805b64836483827515c5b50&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;CTR预估模型中的正负样本问题&lt;/strong&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;3、&lt;/strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzkyMzIyODYxOA==&amp;amp;mid=2247483848&amp;amp;idx=1&amp;amp;sn=a8cce817fa05ad2bcf5897da9574cde9&amp;amp;scene=21#wechat_redirect&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;雨后妙峰山的日出日落堪称奇美，但也有遗憾&lt;/strong&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;4、&lt;/strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MDU3OTgyOQ==&amp;amp;mid=2247499558&amp;amp;idx=1&amp;amp;sn=8a07b0573af0b941a7b021e4b4ec5ebd&amp;amp;chksm=ea6537bcdd12beaab7c35e5b39a066a48551396f5b287b122dbfb1b438ad9687d97e56027462&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;strong/&gt;&lt;/a&gt;&lt;strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MDU3OTgyOQ==&amp;amp;mid=2247499624&amp;amp;idx=1&amp;amp;sn=b9318a4abb28aeadd0b222b3abb6bf2c&amp;amp;chksm=ea6537f2dd12bee40fa9f1d87ab2def8936beb9fef31cf939a092805b64836483827515c5b50&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;从矩阵分解到FM的演进、FM如何用于召回和排序以及实现说明&lt;/strong&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;pre&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;—&lt;/span&gt;&lt;/strong&gt;完&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;—&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;pre&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages __bg_gif&quot; data-backh=&quot;321&quot; data-backw=&quot;578&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;321&quot; data-ratio=&quot;0.5555555555555556&quot; data-type=&quot;gif&quot; data-w=&quot;639&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/02kicEWsInicjLSQIJKCWcOk64en0p55eBNywfpYexwFVhjtMkEZ2cUKf0qZ2BCiaL2SBo2fPm1Zdn1LYZchqSmKA/640?wx_fmt=gif&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages __bg_gif&quot; data-backh=&quot;33&quot; data-backw=&quot;546&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;546&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;33&quot; data-ratio=&quot;0.059654631083202514&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/TsomEQAKP4eyMZqYnRlJaibWPMPOK9EE6SaWtprTnQ0rsZd6mTHRCD2dHLKIKicHP6cibfNSAPJndY8OicbSmZYibEw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;637&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>58be7c134f175017947fe426429c0681</guid>
<title>符号执行，从漏洞扫描到自动化生成测试用例</title>
<link>https://toutiao.io/k/z7bq6go</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entry-content&quot; itemprop=&quot;articleBody&quot;&gt;&amp;#13;
&lt;h3&gt;背景&lt;/h3&gt;
&lt;p&gt;ThoughtWorks安全团队曾经在可信Frimware领域做了一些探索和研究。背景大概是这样的：整车制造过程中，常常会引入供应商的部分设备，如车载娱乐系统，但是出于知识产权的原因，这些供应商很难提供完整的源码给整车制造方，因此二进制的固件就成了整车制造环节中的安全隐患，各种漏洞都可能被供应商的零部件引入，存在于车载系统之中，随时可能被攻击者利用而影响整车的安全性。&lt;/p&gt;
&lt;p&gt;为了探测二进制程序中的漏洞，经过一段时间的探索和研究后，把核心技术锁定到了符号执行，利用该技术帮客户搭建了一套自动化的二进制漏洞扫描平台。并且，在后来不断的研究中，我们发现，符号执行也可以用来自动化生成测试用例，为我们更加全面的编写测试用例, 带来新的思路。&lt;/p&gt;
&lt;h3&gt;什么是符号执行&lt;/h3&gt;
&lt;p&gt;Wikipedia上对符号执行的解释：是一种程序分析技术，其可以通过分析程序来得到让特定代码区域执行的输入。使用符号执行分析一个程序时，该程序会使用符号值作为输入，而非一般执行程序时使用的具体值。在达到目标代码时，分析器可以得到相应的路径约束，然后通过约束求解器来得到可以触发目标代码的具体值。&lt;/p&gt;
&lt;p&gt;讲的比较绕，举个通俗的例子来说明：假设程序现在是一个王者荣耀中的英雄，这个英雄经过一定的出装就会有一定的战力(攻速，物理伤害，防御等)，符号执行的技术就是，给出了一个英雄的战力，可以反推出什么样的出装可以达到这样的战力。&lt;/p&gt;
&lt;p&gt;再举个实际的代码例子来说明符号执行:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void foo(int x, int y)
{
    int t = 0;
    if( x &amp;gt; y ){
        t = x;
    }else{
        t = y;
    }
    if (t &amp;lt; x ){
        assert false;
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;假设当&lt;code&gt;t&amp;lt;x&lt;/code&gt;时，是我们程序的漏洞，我们要使用符号执行判断是否有达到&lt;code&gt;t&amp;lt;x&lt;/code&gt;这个分支的可能。符号执行的方法就是在给定的时间内，生成一组输入，以尽可能多的探索所有的执行路径，在分析时，该程序会使用符号值作为输入，而非具体的值，去探索每一条分支。比如该程序在符号执行完后，会生成如下类似的方程组：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(x&amp;gt;y) =&amp;gt; t=x
(x&amp;lt;=y) =&amp;gt; t=y&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来，符号执行会通过约束求解，去分析上述的每条路径，通过约束求解分析得，如上的两条路径在任何情况下都不可能达到&lt;code&gt;t&amp;lt;x&lt;/code&gt;这个分支。约束求解可以简单的理解为解方程，有很多开源的约束求解器，比如&lt;a href=&quot;https://github.com/Z3Prover/z3&quot;&gt;Z3&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;使用符号执行进行漏洞扫描&lt;/h3&gt;
&lt;p&gt;那我们是如何把符号执行运用在自动化漏洞扫描的场景上？&lt;/p&gt;
&lt;p&gt;首先要说明的是，我们要扫描的对象是Linux kernel，对于kernel来说有很多已知的CVE漏洞，我们的任务就是去发现二进制的kernel上是否存在这些CVE漏洞。思路如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过一些简单的逆向，得到该内核的版本。&lt;/li&gt;
&lt;li&gt;有了内核版本，就可以得到内核的源码，以及该内核版本对应的所有CVE漏洞和补丁。&lt;/li&gt;
&lt;li&gt;给内核源码打上所有的CVE补丁，在二进制层面diff前后的补丁，对每个补丁提取唯一的特征（漏洞指纹）。&lt;/li&gt;
&lt;li&gt;用漏洞指纹与目标kernel进行对比，扫描得到最终的漏洞列表。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由上述可知，提取漏洞的唯一特征是最重要的一步，接下来介绍如何使用符号执行来提取漏洞指纹。&lt;/p&gt;
&lt;p&gt;首先介绍两个基本的概念BB(basic block)和CFG(control flow graph):BB是指从汇编的角度来看程序，一段连续的汇编指令就是一个BB，这段连续的汇编仅仅包含一个入口和一个出口，换句话说，BB内部不会有分支和跳转。由此我们可以得出，一个程序，是由一堆的bb组成的，它们之间有复杂的调用和跳转关系，最终形成了一张图，这个图就是CFG。例如下图是一个简单的CFG：&lt;br/&gt;
&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/05/1-symbolic-execution-testcases-.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/05/1-symbolic-execution-testcases-.png&quot; alt=&quot;简单的CFG&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有了这两个概念，我们就可以对漏洞进行唯一的特征描述了。&lt;/p&gt;
&lt;h4&gt;漏洞指纹特征&lt;/h4&gt;
&lt;p&gt;由上面可知，CFG其实表示了一段程序执行的所有路径，而符号执行的第一步就是去探索所有的执行路径。如果您了解过内核的CVE漏洞，就会发现内核很大一部分的CVE漏洞补丁，就是在一些关键的代码上加了一些if分支和判断。例如CVE-2019-19252的补丁如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;diff --git a/drivers/tty/vt/vc_screen.c b/drivers/tty/vt/vc_screen.c
index 1f042346e7227..778f83ea22493 100644
--- a/drivers/tty/vt/vc_screen.c
+++ b/drivers/tty/vt/vc_screen.c
@@ -456,6 +456,9 @@ vcs_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
size_t ret;
char *con_buf;
+ if (use_unicode(inode))
+ return -EOPNOTSUPP;
+
con_buf = (char *) __get_free_page(GFP_KERNEL);
if (!con_buf)
return -ENOMEM;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该补丁只是在vcs_write的函数中添加了一个if判断，对于这类补丁，在使用符号执行生成CFG的时候，前后肯定会出现一个明显的差异，因为多了一个分支，整个的程序流图也就多了一个分支。对于这种类型的补丁，使用CFG就可以作为漏洞的特征，通过对比发现，前后的CFG不一样，就说明漏洞存在。&lt;/p&gt;
&lt;p&gt;那么，仅仅通过CFG是否就可以唯一的确定这个漏洞吗？请看下面的CVE-2019-8956的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;diff --git a/net/sctp/socket.c b/net/sctp/socket.c
index f93c3cf9e5674..65d6d04546aee 100644
--- a/net/sctp/socket.c
+++ b/net/sctp/socket.c
@@ -2027,7 +2027,7 @@ static int sctp_sendmsg(struct sock *sk, struct msghdr *msg, size_t msg_len)
struct sctp_endpoint *ep = sctp_sk(sk)-&amp;gt;ep;
struct sctp_transport *transport = NULL;
struct sctp_sndrcvinfo _sinfo, *sinfo;
- struct sctp_association *asoc;
+ struct sctp_association *asoc, *tmp;
struct sctp_cmsgs cmsgs;
union sctp_addr *daddr;
bool new = false;
@@ -2053,7 +2053,7 @@ static int sctp_sendmsg(struct sock *sk, struct msghdr *msg, size_t msg_len)
/* SCTP_SENDALL process */
if ((sflags &amp;amp; SCTP_SENDALL) &amp;amp;&amp;amp; sctp_style(sk, UDP)) {
- list_for_each_entry(asoc, &amp;amp;ep-&amp;gt;asocs, asocs) {
+ list_for_each_entry_safe(asoc, tmp, &amp;amp;ep-&amp;gt;asocs, asocs) {
err = sctp_sendmsg_check_sflags(asoc, sflags, msg,
msg_len);
if (err == 0)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于这种漏洞补丁，没有分支上的增减，只是改变了一个函数的入参个数，那么补丁前后的CFG可能是一样的，所以我们就不能仅仅通过CFG来判断补丁是否存在，必须加上在语义上的分析，语义即这个参数对函数的整体影响。这就引出了符号执行的另一步：约束求解，前面我们提到符号执行会对所有路径形成类似方程组的概念，然后使用约束求解器求出到达每个路径的解的集合。如果其中某些变量发生了改变，其最终的解一定是不一样的，以此作为漏洞标识的另一个特征。&lt;/p&gt;
&lt;h4&gt;漏洞扫描总结&lt;/h4&gt;
&lt;p&gt;所以最终，我们是采用符号执行从CFG和语义分析两个维度来唯一的确定一个漏洞的特征，然后用这个唯一的特征去目标的kernel中对比。以此来确定补丁是否已经存在。这个就是我们检测二进制漏洞的关键技术，大致流程如下图：&lt;br/&gt;
&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/05/2-symbolic-execution-testcases.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/05/2-symbolic-execution-testcases-768x194.png&quot; alt=&quot;二进制漏洞的关键技术&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在整个过程中，我们会使用开源的符号执行引擎和约束求解器，比如&lt;a href=&quot;https://github.com/angr/angr&quot;&gt;Angr&lt;/a&gt;和&lt;a href=&quot;https://github.com/Z3Prover/z3&quot;&gt;Z3&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;符号执行的其他应用场景&lt;/h3&gt;
&lt;p&gt;前面是符号执行在漏洞提取和扫描的一个案例，除此之外，符号执行在漏洞挖掘，CTF等方面也有比较广泛的应用。例如如下程序是我用Ghidra逆向的一道CTF的题目：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int verify(EVP_PKEY_CTX *ctx, uchar *sig, size_t siglen, uchar *tbs, size_t tbslen)
{
byte bvar1;
int local_c;
local_c = 0;
while(true) {
if(ctx[(long)local_c] == (EVP_PKEY_CTX)0x0) {
return (int)(uint)(local_c == 0x17);
}
bVar1 = (byte)local_c;
if(encrypted{(long)local_c} != (byte)(((byte)((int)(uint)(bVar1 ^ (byte)ctx[(log)local_c]) \
&amp;gt;&amp;gt; (8-((bVar1 ^9)&amp;amp;3) &amp;amp; 0x1f)) | (bVar1 ^ (byte)ctx[(long)local_c]) &amp;lt;&amp;lt; ((bVar1 ^9) &amp;amp; 3))+8)){
break;
}
local_c = local_c + 1
}
return 0;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以发现，其核心关键是去破解这个加解密的算法（异或，加减等操作），如果人工逆向，可能需要很长时间的推算和尝试，而符号执行则可以自动的去不断尝试每个路径的解，直到算出一个自己需要的值。有兴趣的读者，可以使用angr和z3去做一下这个CTF的破解，非常容易，这里不再赘述。需要说明的是，在破解和CTF中，符号执行往往和IDA/Ghidra等工具来配合使用。&lt;/p&gt;
&lt;p&gt;另一方面是在测试领域，在单元测试中代码覆盖率往往被用于评估代码的测试充分性水平，在软件工业界，人工设计测试用例的方法被广泛使用，即依靠人对程序代码的理解设计测试用例，但对应的人力成本很高，有时候为了降低人力成本且提高自动化程度，随机测试的方法也被常常使用，但一般只能检测到有限的程序行为，容易遗漏软件错误。&lt;/p&gt;
&lt;p&gt;在单元测试中，常用的白盒测试的充分性准则大多属于基于控制流的覆盖准则，如语句覆盖，分支覆盖和MC/DC覆盖等。而测试准则的选取一般根据实际的测试需求而确定，比如，传统软件的测试一般要求实现尽可能高的语句覆盖和分支覆盖，而对于航天，轨交等控制软件一般要求代码满足100%的分支覆盖。而这种同时实施多种测试标准的需求，进一步加大了单元测试的工作量和难度， 使得单元测试在实际软件开发中往往被忽略，最终导致软件缺陷没有在早期被及时发现。&lt;/p&gt;
&lt;p&gt;而符号执行的特点是会尽可能的遍历每条路径，每一次符号执行的结果等价于大量的测试案例。符号执行为软件的各种情况自动生成了有效的输入，覆盖率高，可以更加容易检测到程序是否存在缺陷和错误。所以，其实我们可以运用符号执行生成测试用例。&lt;/p&gt;
&lt;p&gt;目前学术界有不少的论文研究如何使用符号执行自动化生成更好的测试用例。也有一些有意思的demo，可以让您体验：&lt;/p&gt;
&lt;p&gt;C语言： &lt;a href=&quot;https://github.com/Sajed49/C-Path-Finder&quot;&gt;https://github.com/Sajed49/C-Path-Finder&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Java语言：&lt;a href=&quot;https://github.com/kaituo/sedge&quot;&gt;https://github.com/kaituo/sedge&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;以上是我们对符号执行的一些探索，欢迎您与我们一起进行更加深入的研究。随着大家对安全的越来越重视，基于符号执行的漏洞扫描，自动测试，fuzz测试等越来越受到人们的重视。&lt;a href=&quot;https://www.congress.gov/115/bills/hr5515/BILLS-115hr5515enr.pdf&quot;&gt;2019年美国《国防法》National Defense Act的H.R.5515—517&lt;/a&gt; 就推荐使用二进制分析和符号执行工具来增强关键软件系统的安全。目前，ThoughtWorks安全团队正在积极探索符号执行在安全领域的威力，通过自动生成测试用例，再结合模糊测试（fuzz）工具，集成到DevOps的环境中，在整个软件的开发周期内持续的发现安全漏洞，为软件安全保驾护航。&lt;/p&gt;
&amp;#13;
&lt;/div&gt;&amp;#13;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d54a1701a5fcac2a74952308f2cc567e</guid>
<title>Android 架构师之路：App 启动性能速度优化</title>
<link>https://toutiao.io/k/oiq8w7v</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、浅谈启动性能优化原因&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1、引起性能问题的原因&lt;/strong&gt;&lt;/p&gt;&lt;p data-tools-id=&quot;15013&quot;&gt;&lt;span&gt;随着项目不断的快速迭代，往往会造成App启动卡慢现象，因为可能在App主进程启动阶段或者在主界面启动阶段放了很多初始化其他业务的逻辑，而这些业务落地可能一开始并不需要用到；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2、为什么要做启动速度优化&lt;/strong&gt;&lt;/p&gt;&lt;p data-tools-id=&quot;21625&quot;&gt;&lt;span&gt;&lt;strong&gt;二、分析怎么做启动优化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1、启动过程简单分析&lt;/strong&gt;&lt;/p&gt;&lt;p data-tools-id=&quot;36542&quot;&gt;&lt;span&gt;App从点击桌面图标到我们看到App的主界面整个过程中经过了哪些步骤，哪些地方是我们可以优化的地方;&lt;/span&gt;&lt;/p&gt;&lt;p data-tools-id=&quot;38222&quot;&gt;&lt;span&gt;下图是App启动过程的一个大概描述&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.544468546637744&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kyDL16ViavhHnAibCibcwjzFmb421z690PZEhicxJcHcjGibw0HkYk77zgSHLGEia8wQl549QYEib9KC8HPQYl4oWwic9g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;461&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2、从启动过程找出优化点&lt;/strong&gt;&lt;/p&gt;&lt;p data-tools-id=&quot;60624&quot;&gt;&lt;span&gt;App启动过程中我们优化的地方包括主进程启动流程和主界面启动流程，主进程启动就是Application的创建过程，主界面启动就是MainActivity的创建过程；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;只需要分别对这两个部分进行优化即可:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3、统计耗时操作&lt;/strong&gt;&lt;/p&gt;&lt;p data-tools-id=&quot;23073&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;strong&gt;函数耗时统计工具之Hugo&lt;/strong&gt;&lt;/span&gt; &lt;/span&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;82&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;Hugo项目是一个调试函数调用耗时的工具，通过对方法或者类添加@DebugLog注解，在运行时会将函数的耗时打印在控制台中，通常用于排查函数耗时，或者用于卡顿检测；&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;①使用方法&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;项目根目录build.gradle添加hugo插件依赖&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;classpath&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;com.jakewharton.hugo:hugo-plugin:1.2.1&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tools-id=&quot;15109&quot;&gt;&lt;strong&gt;②主工程或者library的录build.gradle中声明hugo插件&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;apply&lt;/span&gt; plugin: &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;com.jakewharton.hugo&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;复制代码可通过配置开启或关闭hugo功能。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;hugo&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attribute&quot;&gt;enabled&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tools-id=&quot;30402&quot;&gt;&lt;strong&gt;③在类或方法上声明@DebugLog注解&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@DebugLog&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; getName(&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; first, &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; last) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  SystemClock.sleep(&lt;span class=&quot;code-snippet__number&quot;&gt;15&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; first + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot; &quot;&lt;/span&gt; + last;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tools-id=&quot;51329&quot;&gt;&lt;strong&gt;④运行程序会在控制台会打印函数耗时日志：&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;getName&lt;/span&gt; [&lt;span class=&quot;code-snippet__number&quot;&gt;16ms&lt;/span&gt;] = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;testtest&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tools-id=&quot;40767&quot;&gt;&lt;span&gt;其实 hugo项目很简单，后续我们会讲解怎么自己写一个；&lt;/span&gt;&lt;/p&gt;&lt;p data-tools-id=&quot;92239&quot;&gt;&lt;span&gt;&lt;strong&gt;三、优化步骤&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tools-id=&quot;10523&quot;&gt;&lt;strong&gt;1、Application中加入异步线程&lt;/strong&gt;&lt;/p&gt;&lt;p data-tools-id=&quot;33053&quot;&gt;&lt;span&gt;是把不必要提前做的操作放到异步线程中去做，也就是我们经常做的异步加载；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面简单写个代码示例&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;StartUpApplication&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Application&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;super&lt;/span&gt;.onCreate();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        onSyncLoadForCreate();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;attachBaseContext&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(Context base)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;super&lt;/span&gt;.attachBaseContext(base);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        onSyncLoad();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        onAsyncLoad();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;onSyncLoadForCreate&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Logutils.log(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;onSyncLoadForCreate &quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Thread.sleep(&lt;span class=&quot;code-snippet__number&quot;&gt;200&lt;/span&gt;);模拟阻塞&lt;span class=&quot;code-snippet__number&quot;&gt;200&lt;/span&gt;毫秒&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;onSyncLoad&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Logutils.log(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;onSyncLoad &quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          Thread.sleep(&lt;span class=&quot;code-snippet__number&quot;&gt;200&lt;/span&gt;);模拟阻塞&lt;span class=&quot;code-snippet__number&quot;&gt;100&lt;/span&gt;毫秒&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;onAsyncLoad&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Runnable() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;ApplicationAsyncLoad&quot;&lt;/span&gt;).start();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2、主页面加入异步线程和延迟加载功能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;与Application的优化思路一样，也是封装onSyncLoad和onAsyncLoad方法对现有代码进行一个分类，但是这两个方法的调用时机要晚一点，是在主界面首屏绘制完成的时候调用。这个步骤也需要new一个Thead，属于额外的开销，不过这不影响我们整体性能；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3、态加载布局：主布局文件优化&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;把主界面中不需要第一次就用到的布局全部使用动态加载的方式来处理，使用ViewStub或者直接在使用时动态addView的方式；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4、主布局文件深度优化&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果做了上面这些优化还是会发现进入主界面还是有些慢，那么需要重点关注主布局文件了。主布局文件的复杂度直接影响到了Activity的加载速度，这个时候需要对主布局文件进行深度优化了；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Activity在加载布局的时候，会对整个布局文件进行解析，测量（measure）,布局（layout）和绘制（draw），所以设计简单合理的布局尤为重要。几个重要的优化如下：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;减少布局层级&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;减少首次加载View的数量&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;减少过度绘制&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;5、页面功能的分模块化和懒加载&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;一个页面上有很多功能模块，最好每个功能模块都单独的分开，模块之间用接口进行数据沟通；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;按需加载所需要的功能，不要打开一个页面都加载所有的功能；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;加载完所需要的功能，如果是一次性加载不需要保持在内存中，尽快销毁掉，形成良好的习惯；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>