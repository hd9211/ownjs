<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>05752d6d8b21675d80276c60f92e4742</guid>
<title>3 分钟用 Go 写完验证码，面试官现场发 Offer</title>
<link>https://toutiao.io/k/d86s58p</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100001217&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4255555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/oiccOczwQpF8Ot0ZSBRxu5SRkJVXnr4XWsq2rKrJgF3eUNQCZlSfmuiakm2NM7DJbf5JTj9dTcqVxwUPVPZeJGBQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我记得在17年那会儿网站登录注册这些随处都可以看到下面这种验证码：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100001204&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5571428571428572&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oiccOczwQpF8Ot0ZSBRxu5SRkJVXnr4XWHciaGY6ib35zcaddeFlJuBVgV0GQ8NrsuOdGCLcaU4clK5p3OyXkEvpw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;420&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是好像近些年，这种验证码消失了，出现了特别多的人机验证，如下图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100001205&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7874251497005988&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oiccOczwQpF8Ot0ZSBRxu5SRkJVXnr4XWH60Tibia4d42icIwEaXXBzPEluNW11ZC6qD05qe51GvbKE7F49rsook2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;334&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;真的是要感叹技术的发展真的不要太爽了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;人机校验&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能很多同学还不知道他的用处：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;他最大的用处就是鉴别是人在操作你的产品还是机器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如：最常见的注册、登录业务，如果你不上一些验证手段，可能人家就可以随便找一个工具，直接对你注册接口疯狂输出，让你分分钟拥有十几万神秘用户。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在人机验证没出来之前，人们用的最多的就是用验证码来拦截，要注册或者登录，必须输入验证码里面的内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是随着&lt;strong&gt;图片识别技术&lt;/strong&gt;的发展，这种技术几乎已经失守。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是一看价格：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100001206&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.37876506024096385&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oiccOczwQpF8Ot0ZSBRxu5SRkJVXnr4XWToDOgJ1Gc4TTXR5nKX8vGny7V5UkIUq4lMRd2a0nezyTglWHdVIksA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1328&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100001207&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8582574772431729&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oiccOczwQpF8Ot0ZSBRxu5SRkJVXnr4XWpvB1lGv2e6Q94LbowIe2LNfh2VVfH5fzCFib7YnmwnpUzjdOHQQvCzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;769&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上阿里和腾讯两家的价格，不算特别便宜哈。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前后端分离下实现验证码服务的逻辑&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然人机校验好处多多，但是介于价格可能很多公司或者个人还是会望而却步。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实刚上的新服务，前期还是可以先使用验证码来鉴别的，到中后期再接入人机也是可以的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;验证码的逻辑&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在传统的单体服务，非前后端分离的情况下，我们可以使用 session 来存储，整个流程可以像下图这样走：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100001208&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.096774193548387&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oiccOczwQpF8Ot0ZSBRxu5SRkJVXnr4XWhwwKqUE0156r1aOLicWfQcvia7ibqzmwx5Vhq22hsWjR5bUPicoFiadNGJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;744&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是现在都前后端分离了，请求会话都是无状态的，该怎么实现呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现方式可能有很多，但是我个人建议可以借鉴下人机交互的逻辑，如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100001209&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9828850855745721&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oiccOczwQpF8Ot0ZSBRxu5SRkJVXnr4XW8HhnEnaZ9pjCOlsV8ObrfGRLP1BM79ic5ZEnl9MAFoALrNFl0b0PQmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;818&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们把会话和验证码分离开了，只要需要用到验证码的地方，都可以去请求这个接口，在下一次请求的时候带上返回的 key 和输入的值就可以了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个流程其实还是有很多漏洞在里面，&lt;strong&gt;实际上生产肯定不能直接这么简单的上&lt;/strong&gt;，还要加上很多其他技术在里面，比如把生成的验证码和下一步请求的地址关联起来、签名呀这些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这已经能拦截一大批攻击者了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种做法和人机验证最大的区别在于，我们生产的验证码容易别人用工具识别出来，人机验证的他们有一套算法去防止被机器识别出来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后期如果要换成人机也非常容易，因为流程是一样的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;基于 Gin 实现一套验证码&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面说了那么多的理论逻辑，下面开始上代码：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完整的代码可以到我们官方的 Github 库查看：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;https://github.com/GoLangStackDev/captcha-demo.git&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;使用到的库&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们处理 Gin 之外还要用到  &lt;code&gt;captcha&lt;/code&gt; 库：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官方 GitHub 地址：&lt;code&gt;github.com/dchest/captcha&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个库功能非常强大，他支持生成图片验证码和音频验证码：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100001210&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4080808080808081&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oiccOczwQpF8Ot0ZSBRxu5SRkJVXnr4XWEOdkIDEYr58IPngqCEhYYFPn7PrU4YpKWIr64mbO1RRXxic1lZlUKIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;495&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现思路一样的，代码几乎一样，只是类型不一样，我们主要以生成图片为准。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;安装库&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们需要安装两个库：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go get github.com/dchest/captcha&lt;br/&gt;go get github.com/gin-gonic/gin&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;先实现工具类&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个工具类我们专门用来处理验证码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Captcha 方便后期扩展&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Captcha &lt;span&gt;struct&lt;/span&gt; {}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 单例&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; captchaInstance *Captcha&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Instance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; *&lt;span&gt;Captcha&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; captchaInstance==&lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  captchaInstance = &amp;amp;Captcha{}&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; captchaInstance&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们声明了一个结构体，方便后期在 captcha 这个库上进行扩展。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// CreateImage 创建图片验证码&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(this *Captcha)&lt;/span&gt; &lt;span&gt;CreateImage&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; length := captcha.DefaultLen&lt;br/&gt; captchaId := captcha.NewLen(length)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; captchaId&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建验证码也很容易，我们这里直接全部使用他默认的配置，生产6位数的数字验证码，后期有需要可以参考 captcha 库进行调整配置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里会返回一个 ID 给我们，这个 ID 就是刚我画的流程图里面的 key，他关联了一个随机数，也就是图片的数字。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这里他存放在哪里的呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认是内存，所以重启程序后就可能找不到已经生成的验证码了，但你可以修改他存放在哪里。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Reload 重载&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(this *Captcha)&lt;/span&gt; &lt;span&gt;Reload&lt;/span&gt;&lt;span&gt;(captchaId &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; captcha.Reload(captchaId)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为不可能用户每次都能输对，所以有些时候用户不能识别的情况下就需要进行重新生成随机数，也就是重新生成一张图片，但是 key 也就是 ID 是不能变的，此时就要用到重载。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Verify 验证&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(this *Captcha)&lt;/span&gt; &lt;span&gt;Verify&lt;/span&gt;&lt;span&gt;(captchaId,val &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; captcha.VerifyString(captchaId, val)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是验证了，传入 ID 和 用户输入的值就可验证了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// GetImageByte 获取图片二进制流&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(this *Captcha)&lt;/span&gt; &lt;span&gt;GetImageByte&lt;/span&gt;&lt;span&gt;(captchaId &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; []&lt;span&gt;byte&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; content bytes.Buffer&lt;br/&gt; err := captcha.WriteImage(&amp;amp;content, captchaId, captcha.StdWidth, captcha.StdHeight)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err!=&lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  log.Println(err)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; content.Bytes()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后就是关键了，怎么把图片输出给用户，captcha 库他会生成一个图片的二进制流，你只需要把这个二进制流返回回去即可得到图片。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Gin部分的代码&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里都只展示关键部分的代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 创建&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 这里方便看到效果 我用的 GET 请求，实际生产最好不要用 GET&lt;/span&gt;&lt;br/&gt;r.Handle(&lt;span&gt;&quot;GET&quot;&lt;/span&gt;, &lt;span&gt;&quot;/captcha/create&quot;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(c *gin.Context)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; imgId := captcha.Instance().CreateImage()&lt;br/&gt; c.JSON(http.StatusOK,&lt;br/&gt;  gin.H{&lt;br/&gt;   &lt;span&gt;&quot;code&quot;&lt;/span&gt;: &lt;span&gt;200&lt;/span&gt;,&lt;br/&gt;   &lt;span&gt;&quot;key&quot;&lt;/span&gt;: imgId,&lt;br/&gt;   &lt;span&gt;&quot;url&quot;&lt;/span&gt;: &lt;span&gt;&quot;/captcha/img/&quot;&lt;/span&gt;+imgId,&lt;br/&gt;  })&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先是创建的接口，这里直接调用我们工具类的 CreateImage 方法拿到 key 即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的 URL 和下面这个现实的 API 关联。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 现实图片&lt;/span&gt;&lt;br/&gt;r.Handle(&lt;span&gt;&quot;GET&quot;&lt;/span&gt;, &lt;span&gt;&quot;/captcha/img/:key&quot;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(c *gin.Context)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; captchaId := c.Param(&lt;span&gt;&quot;key&quot;&lt;/span&gt;)&lt;br/&gt; c.Writer.Header().Set(&lt;span&gt;&quot;Cache-Control&quot;&lt;/span&gt;, &lt;span&gt;&quot;no-cache, no-store, must-revalidate&quot;&lt;/span&gt;)&lt;br/&gt; c.Writer.Header().Set(&lt;span&gt;&quot;Pragma&quot;&lt;/span&gt;, &lt;span&gt;&quot;no-cache&quot;&lt;/span&gt;)&lt;br/&gt; c.Writer.Header().Set(&lt;span&gt;&quot;Expires&quot;&lt;/span&gt;, &lt;span&gt;&quot;0&quot;&lt;/span&gt;)&lt;br/&gt; c.Writer.Header().Set(&lt;span&gt;&quot;Content-Type&quot;&lt;/span&gt;, &lt;span&gt;&quot;image/png&quot;&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;// 重载一次&lt;/span&gt;&lt;br/&gt; captcha.Instance().Reload(captchaId)&lt;br/&gt; &lt;span&gt;// 输出图片&lt;/span&gt;&lt;br/&gt; c.Writer.Write(captcha.Instance().GetImageByte(captchaId))&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们每请求一次这个 key 就重载刷新一下他的 Code，方便前端刷新。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前端只需要在这个地址后面加上随机参数即可实现刷新验证码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最关键的地方就是要设置客户端的请求头里面不能让他缓存。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 校验&lt;/span&gt;&lt;br/&gt;r.Handle(&lt;span&gt;&quot;GET&quot;&lt;/span&gt;, &lt;span&gt;&quot;/captcha/verify/:key/:val&quot;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(c *gin.Context)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; captchaId := c.Param(&lt;span&gt;&quot;key&quot;&lt;/span&gt;)&lt;br/&gt; val := c.Param(&lt;span&gt;&quot;val&quot;&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; captcha.Instance().Verify(captchaId,val) {&lt;br/&gt;  c.JSON(http.StatusOK, gin.H{&lt;span&gt;&quot;code&quot;&lt;/span&gt;: &lt;span&gt;200&lt;/span&gt;})&lt;br/&gt; }&lt;span&gt;else&lt;/span&gt;{&lt;br/&gt;  c.JSON(http.StatusOK, gin.H{&lt;span&gt;&quot;code&quot;&lt;/span&gt;: &lt;span&gt;400&lt;/span&gt;})&lt;br/&gt; }&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后就是校验了，正常来说这个接口是不能放出来了的，因为：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、 captcha 库，只要校验一次，不管成功失败他的 ID 就失效了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、我们一般都只在业务里面去校验。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后来看下效果吧：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100001211&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7550644567219152&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oiccOczwQpF8Ot0ZSBRxu5SRkJVXnr4XWYb8zfbMHskOUpkfN3t8c6ur17obRic3cTibfaZv9rOict4ic75icTMzAMqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1086&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2da0edb395d491c36b657449449a760c</guid>
<title>聊聊 SQL 优化的 15 个小技巧</title>
<link>https://toutiao.io/k/48e8g89</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sql优化是一个大家都比较关注的热门话题，无论你在面试，还是工作中，都很有可能会遇到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果某天你负责的某个线上接口，出现了性能问题，需要做优化。那么你首先想到的很有可能是优化sql语句，因为它的改造成本相对于代码来说也要小得多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何优化sql语句呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章从15个方面，分享了sql优化的一些小技巧，希望对你有所帮助。&lt;/p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.4396782841823057&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEU1Oia130N2IFx8rmOZ0srhia0ZuRo37mU5cwXLjKbUTqWwNP43CVkAzJQLjMAApRIf14B3LJXF7kA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;746&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1 避免使用select *&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多时候，我们写sql语句时，为了方便，喜欢直接使用&lt;code&gt;select *&lt;/code&gt;，一次性查出表中所有列的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;反例：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实际业务场景中，可能我们真正需要使用的只有其中一两列。查了很多数据，但是不用，白白浪费了数据库资源，比如：内存或者cpu。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，多查出来的数据，通过网络IO传输的过程中，也会增加数据传输的时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一个最重要的问题是：&lt;code&gt;select *&lt;/code&gt;不会走&lt;code&gt;覆盖索引&lt;/code&gt;，会出现大量的&lt;code&gt;回表&lt;/code&gt;操作，而从导致查询sql的性能很低。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何优化呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;正例：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;,age &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sql语句查询时，只查需要用到的列，多余的列根本无需查出来。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2 用union all代替union&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道sql语句使用&lt;code&gt;union&lt;/code&gt;关键字后，可以获取排重后的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而如果使用&lt;code&gt;union all&lt;/code&gt;关键字，可以获取所有数据，包含重复的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;反例：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;(&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;) &lt;br/&gt;&lt;span&gt;union&lt;/span&gt; &lt;br/&gt;(&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;排重的过程需要遍历、排序和比较，它更耗时，更消耗cpu资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以如果能用union all的时候，尽量不用union。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;正例：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;(&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;) &lt;br/&gt;&lt;span&gt;union&lt;/span&gt; &lt;span&gt;all&lt;/span&gt;&lt;br/&gt;(&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除非是有些特殊的场景，比如union all之后，结果集中出现了重复数据，而业务场景中是不允许产生重复数据的，这时可以使用union。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3 小表驱动大表&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小表驱动大表，也就是说用小表的数据集驱动大表的数据集。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如有order和user两张表，其中order表有10000条数据，而user表有100条数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时如果想查一下，所有有效的用户下过的订单列表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以使用&lt;code&gt;in&lt;/code&gt;关键字实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;order&lt;/span&gt;&lt;br/&gt;&lt;span&gt;where&lt;/span&gt; user_id &lt;span&gt;in&lt;/span&gt; (&lt;span&gt;select&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;status&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也可以使用&lt;code&gt;exists&lt;/code&gt;关键字实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;order&lt;/span&gt;&lt;br/&gt;&lt;span&gt;where&lt;/span&gt; &lt;span&gt;exists&lt;/span&gt; (&lt;span&gt;select&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; order.user_id = user.id &lt;span&gt;and&lt;/span&gt; &lt;span&gt;status&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面提到的这种业务场景，使用in关键字去实现业务需求，更加合适。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为如果sql语句中包含了in关键字，则它会优先执行in里面的&lt;code&gt;子查询语句&lt;/code&gt;，然后再执行in外面的语句。如果in里面的数据量很少，作为条件查询速度更快。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而如果sql语句中包含了exists关键字，它优先执行exists左边的语句（即主查询语句）。然后把它作为条件，去跟右边的语句匹配。如果匹配上，则可以查询出数据。如果匹配不上，数据就被过滤掉了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个需求中，order表有10000条数据，而user表有100条数据。order表是大表，user表是小表。如果order表在左边，则用in关键字性能更好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结一下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;in&lt;/code&gt; 适用于左边大表，右边小表。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;exists&lt;/code&gt; 适用于左边小表，右边大表。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不管是用in，还是exists关键字，其核心思想都是用小表驱动大表。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4 批量操作&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你有一批数据经过业务处理之后，需要插入数据，该怎么办？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;反例：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt;(Order order: list){&lt;br/&gt;   orderMapper.insert(order):&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在循环中逐条插入数据。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; &lt;span&gt;order&lt;/span&gt;(&lt;span&gt;id&lt;/span&gt;,code,user_id) &lt;br/&gt;&lt;span&gt;values&lt;/span&gt;(&lt;span&gt;123&lt;/span&gt;,&lt;span&gt;&#x27;001&#x27;&lt;/span&gt;,&lt;span&gt;100&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该操作需要多次请求数据库，才能完成这批数据的插入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但众所周知，我们在代码中，每次远程请求数据库，是会消耗一定性能的。而如果我们的代码需要请求多次数据库，才能完成本次业务功能，势必会消耗更多的性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么如何优化呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;正例：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;orderMapper.insertBatch(list):&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提供一个批量插入数据的方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; &lt;span&gt;order&lt;/span&gt;(&lt;span&gt;id&lt;/span&gt;,code,user_id) &lt;br/&gt;&lt;span&gt;values&lt;/span&gt;(&lt;span&gt;123&lt;/span&gt;,&lt;span&gt;&#x27;001&#x27;&lt;/span&gt;,&lt;span&gt;100&lt;/span&gt;),(&lt;span&gt;124&lt;/span&gt;,&lt;span&gt;&#x27;002&#x27;&lt;/span&gt;,&lt;span&gt;100&lt;/span&gt;),(&lt;span&gt;125&lt;/span&gt;,&lt;span&gt;&#x27;003&#x27;&lt;/span&gt;,&lt;span&gt;101&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样只需要远程请求一次数据库，sql性能会得到提升，数据量越多，提升越大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但需要注意的是，不建议一次批量操作太多的数据，如果数据太多数据库响应也会很慢。批量操作需要把握一个度，建议每批数据尽量控制在500以内。如果数据多于500，则分多批次处理。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5 多用limit&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，我们需要查询某些数据中的第一条，比如：查询某个用户下的第一个订单，想看看他第一次的首单时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;反例：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;, create_date &lt;br/&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;order&lt;/span&gt; &lt;br/&gt;&lt;span&gt;where&lt;/span&gt; user_id=&lt;span&gt;123&lt;/span&gt; &lt;br/&gt;&lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; create_date &lt;span&gt;asc&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据用户id查询订单，按下单时间排序，先查出该用户所有的订单数据，得到一个订单集合。然后在代码中，获取第一个元素的数据，即首单的数据，就能获取首单时间。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;Order&amp;gt; list = orderMapper.getOrderList();&lt;br/&gt;Order order = list.get(&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽说这种做法在功能上没有问题，但它的效率非常不高，需要先查询出所有的数据，有点浪费资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何优化呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;正例：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;, create_date &lt;br/&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;order&lt;/span&gt; &lt;br/&gt;&lt;span&gt;where&lt;/span&gt; user_id=&lt;span&gt;123&lt;/span&gt; &lt;br/&gt;&lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; create_date &lt;span&gt;asc&lt;/span&gt; &lt;br/&gt;&lt;span&gt;limit&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;limit 1&lt;/code&gt;，只返回该用户下单时间最小的那一条数据即可。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;此外，在删除或者修改数据时，为了防止误操作，导致删除或修改了不相干的数据，也可以在sql语句最后加上limit。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;update&lt;/span&gt; &lt;span&gt;order&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; &lt;span&gt;status&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;,edit_time=&lt;span&gt;now&lt;/span&gt;(&lt;span&gt;3&lt;/span&gt;) &lt;br/&gt;&lt;span&gt;where&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;&amp;gt;=&lt;span&gt;100&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;&amp;lt;&lt;span&gt;200&lt;/span&gt; &lt;span&gt;limit&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样即使误操作，比如把id搞错了，也不会对太多的数据造成影响。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6 in中值太多&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于批量查询接口，我们通常会使用&lt;code&gt;in&lt;/code&gt;关键字过滤出数据。比如：想通过指定的一些id，批量查询出用户信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sql语句如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;,&lt;span&gt;name&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;category&lt;/span&gt;&lt;br/&gt;&lt;span&gt;where&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3.&lt;/span&gt;.&lt;span&gt;.100000000&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们不做任何限制，该查询语句一次性可能会查询出非常多的数据，很容易导致接口超时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时该怎么办呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;,&lt;span&gt;name&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;category&lt;/span&gt;&lt;br/&gt;&lt;span&gt;where&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3.&lt;/span&gt;.&lt;span&gt;.100&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;limit&lt;/span&gt; &lt;span&gt;500&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以在sql中对数据用limit做限制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过我们更多的是要在业务代码中加限制，伪代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Category&amp;gt; &lt;span&gt;getCategory&lt;/span&gt;&lt;span&gt;(List&amp;lt;Long&amp;gt; ids)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt;(CollectionUtils.isEmpty(ids)) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt;(ids.size() &amp;gt; &lt;span&gt;500&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BusinessException(&lt;span&gt;&quot;一次最多允许查询500条记录&quot;&lt;/span&gt;)&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; mapper.getCategoryList(ids);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一个方案就是：如果ids超过500条记录，可以分批用多线程去查询数据。每批只查500条记录，最后把查询到的数据汇总到一起返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过这只是一个临时方案，不适合于ids实在太多的场景。因为ids太多，即使能快速查出数据，但如果返回的数据量太大了，网络传输也是非常消耗性能的，接口性能始终好不到哪里去。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7 增量查询&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，我们需要通过远程接口查询数据，然后同步到另外一个数据库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;反例：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果直接获取所有的数据，然后同步过去。这样虽说非常方便，但是带来了一个非常大的问题，就是如果数据很多的话，查询性能会非常差。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时该怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;正例：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;select * from user &lt;br/&gt;where id&amp;gt;#{lastId} and create_time &amp;gt;= #{lastCreateTime} &lt;br/&gt;limit &lt;span&gt;100&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按id和时间升序，每次只同步一批数据，这一批数据只有100条记录。每次同步完成之后，保存这100条数据中最大的id和时间，给同步下一批数据的时候用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过这种增量查询的方式，能够提升单次查询的效率。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8 高效的分页&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，列表页在查询数据时，为了避免一次性返回过多的数据影响接口性能，我们一般会对查询接口做分页处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在mysql中分页一般用的&lt;code&gt;limit&lt;/code&gt;关键字：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;,&lt;span&gt;name&lt;/span&gt;,age &lt;br/&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;limit&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;,&lt;span&gt;20&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果表中数据量少，用limit关键字做分页，没啥问题。但如果表中数据量很多，用它就会出现性能问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如现在分页参数变成了：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;,&lt;span&gt;name&lt;/span&gt;,age &lt;br/&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;limit&lt;/span&gt; &lt;span&gt;1000000&lt;/span&gt;,&lt;span&gt;20&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;mysql会查到1000020条数据，然后丢弃前面的1000000条，只查后面的20条数据，这个是非常浪费资源的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，这种海量数据该怎么分页呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优化sql：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;,&lt;span&gt;name&lt;/span&gt;,age &lt;br/&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; &amp;gt; &lt;span&gt;1000000&lt;/span&gt; &lt;span&gt;limit&lt;/span&gt; &lt;span&gt;20&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先找到上次分页最大的id，然后利用id上的索引查询。不过该方案，要求id是连续的，并且有序的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还能使用&lt;code&gt;between&lt;/code&gt;优化分页。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;,&lt;span&gt;name&lt;/span&gt;,age &lt;br/&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; &lt;span&gt;between&lt;/span&gt; &lt;span&gt;1000000&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; &lt;span&gt;1000020&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是between要在唯一索引上分页，不然会出现每页大小不一致的问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9 用连接查询代替子查询&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;mysql中如果需要从两张以上的表中查询出数据的话，一般有两种实现方式：&lt;code&gt;子查询&lt;/code&gt; 和 &lt;code&gt;连接查询&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;子查询的例子如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;order&lt;/span&gt;&lt;br/&gt;&lt;span&gt;where&lt;/span&gt; user_id &lt;span&gt;in&lt;/span&gt; (&lt;span&gt;select&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;status&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;子查询语句可以通过&lt;code&gt;in&lt;/code&gt;关键字实现，一个查询语句的条件落在另一个select语句的查询结果中。程序先运行在嵌套在最内层的语句，再运行外层的语句。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;子查询语句的优点是简单，结构化，如果涉及的表数量不多的话。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但缺点是mysql执行子查询时，需要创建临时表，查询完毕后，需要再删除这些临时表，有一些额外的性能消耗。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时可以改成连接查询。具体例子如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; o.* &lt;span&gt;from&lt;/span&gt; &lt;span&gt;order&lt;/span&gt; o&lt;br/&gt;&lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; u &lt;span&gt;on&lt;/span&gt; o.user_id = u.id&lt;br/&gt;&lt;span&gt;where&lt;/span&gt; u.status=&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10 join的表不宜过多&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据阿里巴巴开发者手册的规定，join表的数量不应该超过&lt;code&gt;3&lt;/code&gt;个。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;反例：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; a.name,b.name.c.name,d.name&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; a &lt;br/&gt;&lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; b &lt;span&gt;on&lt;/span&gt; a.id = b.a_id&lt;br/&gt;&lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; c &lt;span&gt;on&lt;/span&gt; c.b_id = b.id&lt;br/&gt;&lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; d &lt;span&gt;on&lt;/span&gt; d.c_id = c.id&lt;br/&gt;&lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; e &lt;span&gt;on&lt;/span&gt; e.d_id = d.id&lt;br/&gt;&lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; f &lt;span&gt;on&lt;/span&gt; f.e_id = e.id&lt;br/&gt;&lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; g &lt;span&gt;on&lt;/span&gt; g.f_id = f.id&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果join太多，mysql在选择索引的时候会非常复杂，很容易选错索引。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且如果没有命中中，nested loop join 就是分别从两个表读一行数据进行两两对比，复杂度是 n^2。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们应该尽量控制join表的数量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;正例：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; a.name,b.name.c.name,a.d_name &lt;br/&gt;&lt;span&gt;from&lt;/span&gt; a &lt;br/&gt;&lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; b &lt;span&gt;on&lt;/span&gt; a.id = b.a_id&lt;br/&gt;&lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; c &lt;span&gt;on&lt;/span&gt; c.b_id = b.id&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果实现业务场景中需要查询出另外几张表中的数据，可以在a、b、c表中&lt;code&gt;冗余专门的字段&lt;/code&gt;，比如：在表a中冗余d_name字段，保存需要查询出的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过我之前也见过有些ERP系统，并发量不大，但业务比较复杂，需要join十几张表才能查询出数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以join表的数量要根据系统的实际情况决定，不能一概而论，尽量越少越好。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;11 join时要注意&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在涉及到多张表联合查询的时候，一般会使用&lt;code&gt;join&lt;/code&gt;关键字。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而join使用最多的是left join和inner join。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;left join&lt;/code&gt;：求两个表的交集外加左表剩下的数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;inner join&lt;/code&gt;：求两个表交集的数据。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用inner join的示例如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; o.id,o.code,u.name &lt;br/&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;order&lt;/span&gt; o &lt;br/&gt;&lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; u &lt;span&gt;on&lt;/span&gt; o.user_id = u.id&lt;br/&gt;&lt;span&gt;where&lt;/span&gt; u.status=&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果两张表使用inner join关联，mysql会自动选择两张表中的小表，去驱动大表，所以性能上不会有太大的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用left join的示例如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; o.id,o.code,u.name &lt;br/&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;order&lt;/span&gt; o &lt;br/&gt;&lt;span&gt;left&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; u &lt;span&gt;on&lt;/span&gt; o.user_id = u.id&lt;br/&gt;&lt;span&gt;where&lt;/span&gt; u.status=&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果两张表使用left join关联，mysql会默认用left join关键字左边的表，去驱动它右边的表。如果左边的表数据很多时，就会出现性能问题。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;要特别注意的是在用left join关联查询时，左边要用小表，右边可以用大表。如果能用inner join的地方，尽量少用left join。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;12 控制索引的数量&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;众所周知，索引能够显著的提升查询sql的性能，但索引数量并非越多越好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为表中新增数据时，需要同时为它创建索引，而索引是需要额外的存储空间的，而且还会有一定的性能消耗。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阿里巴巴的开发者手册中规定，单表的索引数量应该尽量控制在&lt;code&gt;5&lt;/code&gt;个以内，并且单个索引中的字段数不超过&lt;code&gt;5&lt;/code&gt;个。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;mysql使用的B+树的结构来保存索引的，在insert、update和delete操作时，需要更新B+树索引。如果索引过多，会消耗很多额外的性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，问题来了，如果表中的索引太多，超过了5个该怎么办？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题要辩证的看，如果你的系统并发量不高，表中的数据量也不多，其实超过5个也可以，只要不要超过太多就行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但对于一些高并发的系统，请务必遵守单表索引数量不要超过5的限制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，高并发系统如何优化索引数量？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;能够建联合索引，就别建单个索引，可以删除无用的单个索引。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将部分查询功能迁移到其他类型的数据库中，比如：Elastic Seach、HBase等，在业务表中只需要建几个关键索引即可。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;13 选择合理的字段类型&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;char&lt;/code&gt;表示固定字符串类型，该类型的字段存储空间的固定的，会浪费存储空间。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;alter&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;order&lt;/span&gt; &lt;br/&gt;&lt;span&gt;add&lt;/span&gt; &lt;span&gt;column&lt;/span&gt; code &lt;span&gt;char&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;varchar&lt;/code&gt;表示变长字符串类型，该类型的字段存储空间会根据实际数据的长度调整，不会浪费存储空间。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;alter&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;order&lt;/span&gt; &lt;br/&gt;&lt;span&gt;add&lt;/span&gt; &lt;span&gt;column&lt;/span&gt; code &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是长度固定的字段，比如用户手机号，一般都是11位的，可以定义成char类型，长度是11字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果是企业名称字段，假如定义成char类型，就有问题了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果长度定义得太长，比如定义成了200字节，而实际企业长度只有50字节，则会浪费150字节的存储空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果长度定义得太短，比如定义成了50字节，但实际企业名称有100字节，就会存储不下，而抛出异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以建议将企业名称改成varchar类型，变长字段存储空间小，可以节省存储空间，而且对于查询来说，在一个相对较小的字段内搜索效率显然要高些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在选择字段类型时，应该遵循这样的原则：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;能用数字类型，就不用字符串，因为字符的处理往往比数字要慢。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;尽可能使用小的类型，比如：用bit存布尔值，用tinyint存枚举值等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;长度固定的字符串字段，用char类型。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;长度可变的字符串字段，用varchar类型。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;金额字段用decimal，避免精度丢失问题。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有很多原则，这里就不一一列举了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;14 提升group by的效率&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们有很多业务场景需要使用&lt;code&gt;group by&lt;/code&gt;关键字，它主要的功能是去重和分组。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常它会跟&lt;code&gt;having&lt;/code&gt;一起配合使用，表示分组后再根据一定的条件过滤数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;反例：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; user_id,user_name &lt;span&gt;from&lt;/span&gt; &lt;span&gt;order&lt;/span&gt;&lt;br/&gt;&lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; user_id&lt;br/&gt;&lt;span&gt;having&lt;/span&gt; user_id &amp;lt;= &lt;span&gt;200&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种写法性能不好，它先把所有的订单根据用户id分组之后，再去过滤用户id大于等于200的用户。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分组是一个相对耗时的操作，为什么我们不先缩小数据的范围之后，再分组呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;正例：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; user_id,user_name &lt;span&gt;from&lt;/span&gt; &lt;span&gt;order&lt;/span&gt;&lt;br/&gt;&lt;span&gt;where&lt;/span&gt; user_id &amp;lt;= &lt;span&gt;200&lt;/span&gt;&lt;br/&gt;&lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; user_id&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用where条件在分组前，就把多余的数据过滤掉了，这样分组时效率就会更高一些。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;其实这是一种思路，不仅限于group by的优化。我们的sql语句在做一些耗时的操作之前，应尽可能缩小数据范围，这样能提升sql整体的性能。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;15 索引优化&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sql优化当中，有一个非常重要的内容就是：&lt;code&gt;索引优化&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多时候sql语句，走了索引，和没有走索引，执行效率差别很大。所以索引优化被作为sql优化的首选。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;索引优化的第一步是：检查sql语句有没有走索引。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何查看sql走了索引没？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以使用&lt;code&gt;explain&lt;/code&gt;命令，查看mysql的执行计划。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;explain select * from `order` where code=&lt;span&gt;&#x27;002&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结果：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.07168894289185905&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEU1Oia130N2IFx8rmOZ0srh12xmAaI6TZBZaPVU13tmEaRT9ibvoaMp0lGrvmRyV2dfCdCY5M01Ruw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1646&quot;/&gt;通过这几列可以判断索引使用情况，执行计划包含列的含义如下图所示：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1130434782608696&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEU1Oia130N2IFx8rmOZ0srhRJiaf4SicPlQ725icaeYAgLlmhTz7UVFfMpPx82njv3JKUicnvuBeaKuVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;920&quot;/&gt;如果你想进一步了解explain的详细用法，可以看看我的另一篇文章《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUxODkzNTQ3Nw==&amp;amp;mid=2247485392&amp;amp;idx=1&amp;amp;sn=a0a2728179e20ad09487f09e0a785ec2&amp;amp;chksm=f980010acef7881c0591beb4e90220de5c283a63c74e02910830f4cb99922c388ee0226e7c88&amp;amp;token=393604486&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;explain | 索引优化的这把绝世好剑，你真的会用吗？&lt;/a&gt;》&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说实话，sql语句没有走索引，排除没有建索引之外，最大的可能性是索引失效了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面说说索引失效的常见原因：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7130281690140845&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEU1Oia130N2IFx8rmOZ0srhPUxuOdm28F1LkrKrHxItEX79Yey6orTlywyQEFB4JymRVOQIa3MUXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1136&quot;/&gt;如果不是上面的这些原因，则需要再进一步排查一下其他原因。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，你有没有遇到过这样一种情况：明明是同一条sql，只有入参不同而已。有的时候走的索引a，有的时候却走的索引b？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，有时候mysql会选错索引。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;必要时可以使用&lt;code&gt;force index&lt;/code&gt;来强制查询sql走某个索引。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至于为什么mysql会选错索引，后面有专门的文章介绍的，这里先留点悬念。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>398ffc4b0606918cbbfa497e29d9e12c</guid>
<title>基于深度学习的音频编/解码的实现与落地挑战</title>
<link>https://toutiao.io/k/vnjvfv1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;blockquote&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;今年也是基于深度学习的音频编解码的元年，各家公司都发布了一些编解码器。声网在今年也公布了自研的 AI-Codec 技术——Silver。在本场大会上，声网Agora 音频算法专家冯建元分享了基于深度学习的音频编解码器的研究，以及落地挑战。关注本文标签「RTE 技术分享」，我们将陆续更新更多演讲干货。以下为演讲实录。&lt;/span&gt;&lt;/em&gt;&lt;span/&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5Fdmibt2lwubxrTWdicSIsXj7K8Pg0NzPIoyibsXQLrQQgcDQ4kEw2bmjt95eg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;▲图：声网Agora 音频算法专家 冯建元&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5Fdmibaicj3nqyHtEB3cHrL6gryWzNw2z3sXlH5QguPicvAWLSibiaXffGk197gg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;冯建元认为目前市面上主流的基于深度学习的音频编码解码器主要有 Silver、Lyra、Satin、LPCnet、SoundStream 这几种，他们分别有各自的优缺点，于是乎整理了一张表格，显示得更佳直观。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibAGrQVa6Hl4hn9zQVibC3PQ2zsg4EJ01CxF8SiaYxzl4Za6wQayW8uSDA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以从这张表格中很清楚的看到 Silver 和 Satin 支持的比特率是最高的，LPCnet 支持的比特率是最低的，其它几个 AI codec 则相差无几，同时只有 SoundStream 是支持音乐的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibgrlVT4OTb2WLGqYxrQWrbGp1tzLDL4Y7Qkk4omrk6LiawUoBF8nYL4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;冯建元讲解了一下基于深度学习的编解码的具体的几种实现框架，第一种是基于 AI-vocoder。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibbggSDhgUibosVuRyN6T43VhJDtDPFHpNdfyxPUjusYHPmV4hicjb9reg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先是是特征提取，然后编码压缩，最后提取特征，可以使用 AI-vocoder 这个框架去完成整体的操作。AI-vocoder 在 TTS 等场景中可以获得十分接近人类正常说话的水平的 MOS 分。他的核心有两点：首先逐点生成的自回归模型可以带来一个巨大的音质提升，同时编码算力低，而解码算力高，更加适合语音的编码解码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibNC9M96aiabM0mvYcI2bR3W57HkjAUE9G1PCw0erch7znATC8rAgZIEA/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第二种是基于 Auto-encoder 的一个自编码的框架，上面的那个框架虽然可以在纯人声的场景下表现不错，但是在噪声鲁棒性等方面表现总是不尽如人意，于是就有了基于 Auto-encoder 以及变种的深度学习，这个框架在降噪、变声等更为专业的领域都有着不错的效果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5Fdmibh3j4ib4fiaSNpibpicDbruqJrkiayT00ChxYNVGOM7MO6icq2TU7t8GiaWQdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;883&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Auto-encoder 的核心也很简单，就是利用深度学习的模型来做到端到端的音频压缩和编码、解码。特点是这种方式的编解码算力都比较高，但可以同时处理语音和音乐。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibBEhefzC9ETUsK33CgcJ33diby4rIIeiauC6KQUkTmA2eN40q7LUEhRuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;411&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibhfYLibib1sqb4oEE4DDmhicktvx0mV9hLj2GBoaGQRQOiacEOgElqiaCaqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;基于深度学习的编解码器存在三个问题：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第一个是噪声鲁棒性，&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;在噪声的情况下，由于低码率的传输，会影响我们对噪声的听感，有的噪声不会令人厌烦。但是如果在一个低码率的情况下，它的噪声可能会变成杂音，听上去很不自然，降低了听感。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;第二个是移动端部署的实时性，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;也需要做很多的工程部署挑战。算力比较受限的情况下，做实时的编解码，甚至还需要多路同时进行解码的工作，这时都会受到实时性的挑战。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;第三个是低码率的实时生成的稳定性，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;在这里会发现模型的算力越大，码率越高，自然度就越好。但是 AI 模型在一些低码率的情况下，本就需要更多的算力来保证自然度，而模型又同时受到算力的影响，也不能太大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们从以下两个音频对比，就可以直观感受其中存在的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section class=&quot;custom_select_card_wrp wx-edui-media-wrp&quot;&gt;&lt;mpvoice class=&quot;js_editor_audio audio_iframe js_uneditable custom_select_card&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/audio_tmpl&amp;amp;name=%E5%8E%9F%E5%A3%B0&amp;amp;play_length=00:06&quot; isaac2=&quot;1&quot; low_size=&quot;11.07&quot; source_size=&quot;11.1&quot; high_size=&quot;35.48&quot; name=&quot;原声&quot; play_length=&quot;6000&quot; voice_encode_fileid=&quot;MzU1NjU4NzE0Ml8yMjQ3NDg1MTUx&quot; data-topic_id=&quot;&quot; data-topic_name=&quot;&quot; data-pluginname=&quot;insertaudio&quot;/&gt;&lt;/section&gt;&lt;section class=&quot;custom_select_card_wrp wx-edui-media-wrp&quot;&gt;&lt;mpvoice class=&quot;js_editor_audio audio_iframe js_uneditable custom_select_card&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/audio_tmpl&amp;amp;name=%E4%B8%8D%E5%81%9A%E5%A4%84%E7%90%86%E7%9A%84DL-codec&amp;amp;play_length=00:05&quot; isaac2=&quot;1&quot; low_size=&quot;10.74&quot; source_size=&quot;10.7&quot; high_size=&quot;17.55&quot; name=&quot;不做处理的DL-codec&quot; play_length=&quot;5000&quot; voice_encode_fileid=&quot;MzU1NjU4NzE0Ml8yMjQ3NDg1MTUy&quot; data-topic_id=&quot;&quot; data-topic_name=&quot;&quot; data-pluginname=&quot;insertaudio&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibyNcuAu9xyuxnz9LMic7bARyxzkpyQ3EhhVeNed46NDXJHTXYHbYFFVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先看一下深度学习编解码器问题的大致的框架。AI 在降噪领域已经相对成熟，如果你是做一款语音编解码器，你要传递的信息就是语音，这时 AI 降噪就可以做一个很好的前处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在做编解码器之前，我们先用 AI 降噪的方法来实现。基于深度学习网络的降噪，能够很好地提取语音信号，把这些噪声、杂音都去掉。这里要注意降噪算法需要和编解码器的采样率相匹配，在编解码之前我们加入了一个实时的全频带的 AI 降噪算法，最高支持到 48K Hz 的采样率的语音信号的提纯、降噪。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样，大部分的噪声已经被去除，就可以很好地降低码率，同时降低模型的编解码的难度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是 AI 在降噪也是引入了额外的算力。在移动端部署时，基于深度学习的降噪和传统算法的语音分析作为编码，能够在像高通 855 的单核上实现 0.05RTF 的实时编码，也就是可以 20 倍实时编码，算力可以做到很低。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibQULebqGPUKNVKKl6RDJRv5K41fudwSERMhZuoiaxaOJkzZ8rldkUe2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Silver 语音编解码器有四个优点：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;第一个是可以结局噪声鲁棒性的问题，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;加入了实时全频带的 AI 降噪算法，可以更大程度上降低噪音。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;第二个是移动端的实时性，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;基于深度学习的降噪和传统算法的语音分析相结合进行编码，高通 855 单核上可以实现 0.05RTF 的实时编码，同时有基于深度优化的 WaveRNN 模型以及极小的算力实现语音解码，高通 855 单核上可以实现 0.125RTF 的实时解码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;第三个是有超低码率，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;仅仅只有 3.6kbps。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;第四个是自然，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;这也是最重要的，它支持高音质，支持 32KHz 采样率，超宽带音质编码，音色饱满自然，给你不一样的体验。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5Fdmibp4OO5pqOiawibyu2R3uuibaKHA7GnSlsAuXWzbjQlI5nXm1GKxUatnYGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;833&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;市面上主流的解码/编码器的比较图如下。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibjIRX32O7TYYKJEFvzJ8NbKicjicQFJXl32NfaCiam8KJTagicWlHHt9XpQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;574&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5Fdmib9kVCpNUt5Ds71lmsfebTQJYBNftlIDEVtJayVgA0WFMgaHX3oxRDcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;942&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibMFUbLibYU3DBSMQy3UY9MJ1zpd1VCLMGu7B0J7sUuj2KzSnGw7chNrQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大概可以分为三个方向来说明，首先是前处理，AI-NS 降噪算法可以提升语音信噪比，从而减少低码率带来的 artifact。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其次是编码，基于传统算法的分频带特征提取（基频、子带频谱包络、能量等），而基于 RVQ、距离编码等方法可以实现特征编码，从而达到节省码率的效果。最后一步是解码，采用自回归模型和宽带拓展的 WaveRNN 模型实现模型算力的精简，基于自研的多平台 AI 推理引擎实现的非对称量化、混合精度推理、计算压缩解码耗时会更少。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibZjzffvaGJGvwicicElWf5DMtRDvibzDMMFx6WJkRepWQNsDW2UIedCBgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;982&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section class=&quot;custom_select_card_wrp wx-edui-media-wrp&quot;&gt;&lt;mpvoice class=&quot;js_editor_audio audio_iframe js_uneditable custom_select_card&quot; src=&quot;https://mp.weixin.qq.com/cgi-bin/readtemplate?t=tmpl/audio_tmpl&amp;amp;name=%E5%8E%9F%E5%A3%B0&amp;amp;play_length=00:06&quot; isaac2=&quot;1&quot; low_size=&quot;11.02&quot; source_size=&quot;11&quot; high_size=&quot;47.29&quot; name=&quot;原声&quot; play_length=&quot;6000&quot; voice_encode_fileid=&quot;MzU1NjU4NzE0Ml8yMjQ3NDg1MTUz&quot; data-topic_id=&quot;&quot; data-topic_name=&quot;&quot; data-pluginname=&quot;insertaudio&quot; data-name=&quot;原声&quot; data-length=&quot;0:((time % 60000) / 1000)&quot;/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section class=&quot;custom_select_card_wrp wx-edui-media-wrp&quot;&gt;&lt;mpvoice class=&quot;js_editor_audio audio_iframe js_uneditable custom_select_card&quot; src=&quot;https://mp.weixin.qq.com/cgi-bin/readtemplate?t=tmpl/audio_tmpl&amp;amp;name=Opus&amp;amp;play_length=00:06&quot; isaac2=&quot;1&quot; low_size=&quot;11.02&quot; source_size=&quot;11&quot; high_size=&quot;17.97&quot; name=&quot;Opus&quot; play_length=&quot;6000&quot; voice_encode_fileid=&quot;MzU1NjU4NzE0Ml8yMjQ3NDg1MTU0&quot; data-topic_id=&quot;&quot; data-topic_name=&quot;&quot; data-pluginname=&quot;insertaudio&quot; data-name=&quot;Opus&quot; data-length=&quot;0:((time % 60000) / 1000)&quot;/&gt;&lt;/section&gt;&lt;section class=&quot;custom_select_card_wrp wx-edui-media-wrp&quot;&gt;&lt;mpvoice class=&quot;js_editor_audio audio_iframe js_uneditable custom_select_card&quot; src=&quot;https://mp.weixin.qq.com/cgi-bin/readtemplate?t=tmpl/audio_tmpl&amp;amp;name=Silver&amp;amp;play_length=00:06&quot; isaac2=&quot;1&quot; low_size=&quot;11&quot; source_size=&quot;11&quot; high_size=&quot;35.48&quot; name=&quot;Silver&quot; play_length=&quot;6000&quot; voice_encode_fileid=&quot;MzU1NjU4NzE0Ml8yMjQ3NDg1MTU1&quot; data-topic_id=&quot;&quot; data-topic_name=&quot;&quot; data-pluginname=&quot;insertaudio&quot; data-name=&quot;Silver&quot; data-length=&quot;0:((time % 60000) / 1000)&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在传统的编解码里面，码率越低，能支持的采样率也越低，听起来高频部分会有很多衰减。同时在噪声环境下，听到了风噪，由于它的降噪能力，又能体现出在噪声环境下的低码率的编解码的能力。所以，在采样率和抗噪能力上，都能够有不错的提升。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上是关于编解码器本身的能力，但进行在移动端的部署，就会遇到很多需要去权衡码率、算力的效果这些方面的问题和挑战。以 AI-vocoder为例给大家进行介绍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;刚提到，越大的模型，算力越大，越能够提供比较好的声音还原能力。对 TTS 或者是语音生成的模型进行对比，不同的模型生成，跑出来的主观评测的分数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;例如 WavNet 的算力是 100G，几乎在 CPU 上完全不可能，只能在 GPU 上的，甚至在 GPU 上也不能做到实时的算力。它的评分能达到 90，几乎接近于满分。比它小的是 WavRNN 模型，算力降了 6 倍左右，其实可以达到 16.3GFLOPS，它的分数也降了不少，降到了 75 分。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样一个算力在一些 GPU 端，已经可以做到实时，但是如果放到 CPU 上，或者手机的移动端上，还不能实现。比如LPCnet已经降到了 3GFLOPS，大概是 70 分，大概是可用的分数线。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看到，模型越大，主观生成的音频质量越好。但是要找到其中的一个平衡点即用多大的算力去能够实现实时性，同时分数又不会降得太低。可以想到在自回归的逐点生成的编解码器，如果在低频段用逐点生成，高频采用一些 BWE 的技术进行高频的扩展，这样就会损到很多高频带宽编解码的算力，就能够把它降下来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主要是看做了哪些处理。前处理部分，提升信噪比也是减少码率的较好的措施。如果经过了 AI 降噪以后的语音，再做编解码，自然就可以把它的码率压到更低，同时在还原时又不去影响它的音质。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外在编码的时候，基于传统算法的分频带的特征提取，可以分成不同的子带，每个子带有不同的处理形式。通过一些特征的建模，在编码处就可以把它分成不同的频带去针对性地处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;传统方法也有类似，比如距离编码，可以实现特征维度的压缩。这样，可以把码率压到 3.6K pbs。在解码端的时候，自回归模型就会把它拆成两个部分，去做低频的部分，然后结合 BWE，实现对模型的改造，这样可以实现模型算力的精简。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在部署的时候，比如 ARM 平台数据一般以4为单位组合计算，在其他平台基于不同芯片计算优化也不同，会涉及到多平台的优化。这里我们有一个自研的多平台的 AI 推力引擎，去实现量化、混合精度推理的加速，在工程的角度上进一步压缩解码端的耗时。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后我们可以看看深度学习现在到了一个什么样的阶段，以及后续会有哪些可以做的方向。对于现在还是针对于极低码率的编码，看看深度学习能够把音频还原到什么样的程度。其实用深度学习，已经能够实现在 10K 以下的码率，超越传统的编解码器。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再往上，传统算法是在 100K pbs 以上，这已经能够做到我们对音频的编解码透明的状态，我们编解码后，大家已经分辨不出它是否经过编解码。在这种角度上说，AI-codec 现在还没有能够完美地还原音频编解码的能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再比如大于 100K pbs，我们甚至可以编一些立体声的声音。超过 100K pbs，甚至可以编一些多通道的音频。再对音质体验的更高的要求，如果能把码率降下来，对于基于深度学习的音频编解码器会带来更多收益，这也是冯建元的研究方向。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了编解码本身，为了保证整条音频链路沟通的流畅性，我们还需要很多弱网的丢包的策略。比如一个比较低码率的编解码器，能够更好地去冗余、重传，这也可以更方便地做。比如本来冗余只能多做一倍，现在因为码率比较低，可以做更多倍的冗余，在弱网情况下，它的音质体验会更好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于生成的模型，在做丢包补偿，如果丢一个包，后续可以把这个包再恢复出来，这也是不错的尝试，后续我们会给大家放一个 demo。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们现在基本上能做到把深度学习的编解码器放到移动端，但是我们现在能最多做到的解码，是在高通 855 芯片上做到8路同时的解码。但是如果在一些低端的手机，可能就做不了这么多路，还需要在低端算力的多路编解码的能力上去进行一些持续的优化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了 Agora 本身能够降低码率外，其实还能够在一些丢包补偿上进行进一步提升。如果是 Agora 的解码部分，即 AI 的声码器，冯建元对做丢包补偿效果做了音频展示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section class=&quot;custom_select_card_wrp wx-edui-media-wrp&quot;&gt;&lt;mpvoice class=&quot;js_editor_audio audio_iframe js_uneditable custom_select_card&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/audio_tmpl&amp;amp;name=AI%20PLC%E8%A1%A5%E5%81%BF%E5%89%8D%E7%9A%84%E7%94%B7%E5%A3%B0&amp;amp;play_length=00:06&quot; isaac2=&quot;1&quot; low_size=&quot;9.35&quot; source_size=&quot;9.4&quot; high_size=&quot;17.87&quot; name=&quot;AI PLC补偿前的男声&quot; play_length=&quot;6000&quot; voice_encode_fileid=&quot;MzU1NjU4NzE0Ml8yMjQ3NDg1MTU2&quot; data-topic_id=&quot;&quot; data-topic_name=&quot;&quot; data-pluginname=&quot;insertaudio&quot;/&gt;&lt;/section&gt;&lt;section class=&quot;custom_select_card_wrp wx-edui-media-wrp&quot;&gt;&lt;mpvoice class=&quot;js_editor_audio audio_iframe js_uneditable custom_select_card&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/audio_tmpl&amp;amp;name=AI%20PLC%E8%A1%A5%E5%81%BF%E5%89%8D%E7%9A%84%E5%A5%B3%E5%A3%B0&amp;amp;play_length=00:03&quot; isaac2=&quot;1&quot; low_size=&quot;6.27&quot; source_size=&quot;6.3&quot; high_size=&quot;11.75&quot; name=&quot;AI PLC补偿前的女声&quot; play_length=&quot;3000&quot; voice_encode_fileid=&quot;MzU1NjU4NzE0Ml8yMjQ3NDg1MTU3&quot; data-topic_id=&quot;&quot; data-topic_name=&quot;&quot; data-pluginname=&quot;insertaudio&quot;/&gt;&lt;/section&gt;&lt;section class=&quot;custom_select_card_wrp wx-edui-media-wrp&quot;&gt;&lt;mpvoice class=&quot;js_editor_audio audio_iframe js_uneditable custom_select_card&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/audio_tmpl&amp;amp;name=AI%20PLC%E8%A1%A5%E5%81%BF%E5%90%8E%E7%9A%84%E7%94%B7%E5%A3%B0&amp;amp;play_length=00:06&quot; isaac2=&quot;1&quot; low_size=&quot;11.36&quot; source_size=&quot;11.4&quot; high_size=&quot;17.87&quot; name=&quot;AI PLC补偿后的男声&quot; play_length=&quot;6000&quot; voice_encode_fileid=&quot;MzU1NjU4NzE0Ml8yMjQ3NDg1MTU4&quot; data-topic_id=&quot;&quot; data-topic_name=&quot;&quot; data-pluginname=&quot;insertaudio&quot;/&gt;&lt;/section&gt;&lt;section class=&quot;custom_select_card_wrp wx-edui-media-wrp&quot;&gt;&lt;mpvoice class=&quot;js_editor_audio audio_iframe js_uneditable custom_select_card&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/audio_tmpl&amp;amp;name=AI%20PLC%E8%A1%A5%E5%81%BF%E5%90%8E%E7%9A%84%E5%A5%B3%E5%A3%B0&amp;amp;play_length=00:03&quot; isaac2=&quot;1&quot; low_size=&quot;7.54&quot; source_size=&quot;7.5&quot; high_size=&quot;11.75&quot; name=&quot;AI PLC补偿后的女声&quot; play_length=&quot;3000&quot; voice_encode_fileid=&quot;MzU1NjU4NzE0Ml8yMjQ3NDg1MTU5&quot; data-topic_id=&quot;&quot; data-topic_name=&quot;&quot; data-pluginname=&quot;insertaudio&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以听到在补偿之前，因为有丢包，所以声音是不连续的，在可懂度方面下降得很快，在弱网情况下就很影响听感，甚至不知道对方在说什么。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在经过 PLC 之后，模型是一样的，可以复用 AI 的解码能力，就能够把丢失掉的包的信息补偿回来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总结：基于 TTS 的发展，我们一步一步地实现了深度学习的音频编解码器。类似的这种框架，可以在音频的框架中再找一找，可能还有其他方向的发展。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在现阶段，音频编解码器还面临着很多比如噪声鲁棒性、实时性以及低码率的音频生成的稳定性的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Silver 提供了一种可落地的实现方案，它的特性主要来源于 AI 降噪对于它的前处理，解决了噪声的问题，采用频带扩展、自回归模型相结合的形式，还有多平台的工程优化，最后实现了移动端的部署。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在深度学习的音频编解码中，还有高音质、多通道以及对抗弱网等方向，期待有更多发展。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5Fdmib9Dv8e1RutetIqiaIfUMUSGZtRmDWGdg4oxBPsjmibh8vdF5CKKtSiao4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于未来的深度学习的音频编码/解码将有三点展望，首先第一点是对于低码率、高保真编/解码器能力边界的探索，其次是增加立体声、多通道音频的编/解码的能力，同时增加弱网抗丢包等场景的策略完善，最后是对于低端算力的多路编解码的持续算力优化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibWIF2quSr2nxLQ7r0d1AYzgUl2PJLoPxsd4VQIM6FNYLpFOesepJw9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4c357d33d20c592d5f32d651f26667cc</guid>
<title>堪称货拉拉混合云数据库建设史，一场 DBA 团队的逆袭之战</title>
<link>https://toutiao.io/k/270564h</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;多站点一站式运维管控：我不希望每个数据库及中间件都要单独做一个系统去管控然后各个站点都单独部署一套，这样做最大的问题是管理分散，DBA运维过程体感非常差，这是我非常不希望看到的也是绝对不能容忍的，我们要做的就是一站式的跨云多站点统一管控平台，虽然略微复杂但是用户使用体验非常好，技术本身就是把复杂留给自己简单留给用户，即使是内部系统自己使用也坚决不妥协。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;多云环境下的一致性运维与研发体验：比如对DB来说，我希望经过系统对底层基础设施的差异做了屏蔽后会做一个统一的呈现而不是对各个云商产品进行针对性的设计系统，避免造成运维过程中的困惑。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对研发同学来说，他是完全不需要关心各家云商产品间的差异性问题，同时也无需考虑多云环境下研发日常涉及数据库的变更、资源申请、数据订阅等可能存在的差异性问题，这些复杂性由系统统一包掉。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;三、痛点&amp;amp;诉求&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;272&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.4796875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsBS9dicx97fiby43HK7MicoOkomMXAuQyyKoTXkJL48QnRaiaV3VPy22S9g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;1、稳定性&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;历史上日常故障率实在是太高了，隔三差五的故障，P2-3家常便饭，P0-1也非常多见。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;2、研发效率&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;DBA完全靠人肉来满足研发诉求，研发跟DBA的交互完全靠吼，研发很多资源诉求、需求处理、问题排查都难以快速高效的满足。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不过这只是当初的表象问题，更大的问题在于如果这些问题不能快速得到解决后续随着业务的快速发展技术团队的规模快速增长，作为基础技术支撑团队一定会出现更多更严重的问题，这些都是可以预想到的毕竟经历过类似的快速成长的公司基本上会有相应的心理预判。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;3、成本&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;在自建机房时代只要购买一次机器可以用上3~5年这期间可以不用一直付费，云上付费方式的差异可能会让老板觉得一直在花钱(毕竟每个月都有账单)。也许这是开玩笑不过当时是非常难以理解在一个快速成长的公司成本诉求来的太早了，这会对业务发展甚至稳定性产生一些掣肘。不过在一年后的今天来看确实是非常有必要的(我们在平台化后通过初步的数据分析后发现资源使用不合理居然普遍存在，我们在DB上节约的成本就相当可观，后续会介绍)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不管是面对研发还是DBA自身又或者是老板各种的“不讲道理”都有不小的压力，但这又是不得不解决的问题。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;四、治理基本思路&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;316&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5564924114671164&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsCcGRf8WVcbbog5ARFvuSU2YTgreKwtcXSRgmxSkvVx11jtgsqPMUyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1186&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;1、做减法&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;从一个我看到的现象说起，我注意到研发有高频的订正数据的需求，正常我想这是不应该的，除了个别的误操作及运营特殊需求不应该有这样的需求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;后来经过了解后发现，这样的一个现象，比如：由于订单逻辑的复杂性，一部分数据在落库时写MySQL，一部分数据要写Mongo或者ES或者Redis，用这些产品本身是没问题的，但如果打包到一个业务逻辑里面就有问题了，总会出现类似无法保证事务一致性的问题。当然里面有业务使用姿势的问题，但是另外一个非常重要的原因是，业务在设计之初缺乏合理的设计，或者说为了简单滥用了数据库的某些能力。比如为避免关系型数据库DDL麻烦的问题，就想着用Mongo来代替，最终也是一个挖坑操作；另外一方面，很多数据库选型是我们hold不住的，不是不能投入时间去研究，而是在有限的时间要解决最关键的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;paragraph&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section label=&quot;Copyright © 2015 Yead All Rights Reserved.&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;结合我过往的经验看，还没见到一家公司的业务复杂到需要近10款数据库类型才能支撑的。警惕研发的肆意的、缺乏大局观的数据库选型，DBA有权利say no&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此，砍掉一些数据库选型尽管有不理解但也要坚决推行，DBA也不再接受研发过去的套路，(通常的台词是：系统已经开发完毕了，明天要上线...)找回DBA丢失的话语权，也是给DBA对外打交道上建立一点自信，当然减少数据库选型也一定程度上降低了后续平台化的复杂度，毕竟时间有限。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;2、定义规范&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;过去是完全没有规范的，或者错误的规范，同时我们要明确DBA的职责及SLA保障标准，目的就是告诉研发：该做什么不该做什么。(比如研发过程使用某种我们不支持的数据库则不准上线！)及各种要遵循的规范化的内容。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DBA提供SLA保障标准也是对DBA严格要求，通过建立规范标准，让DBA有“法”可依，最起码也是起到保护DBA的作用。规范的建立如果只是文字性的内容往往是没有意义的，必须是能写进代码里，同时也要做好系统收口才能良好的执行，否则就是一纸空文(只有在跟产研打官司的时候有用，但是不希望发生这种情况)，因此平台化是非常必要的。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;3、建能力&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;如何通过平台化方式解决当下的问题，或者落地具体的治理手段。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;4、70分标准&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;我们没有非常充足的时间去追求完美，优先解决核心的问题，做到差不多就行了，然后解决另外一个核心问题。也就是小步快跑，绝对不在某个不完美的点上磨磨唧唧，留在后续在不断的迭代优化、稳步向前推进。但是也要争取做一个功能就成功一个，否则面对这么多功能要做，总是失败会打击自己跟团队的自信，先取得一个个的小目标再计划后续。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;5、优先解决生存问题&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;DBA很长一段时间里陷入到对研发人工支持上，比如：经常忙到很晚的发布，日常的资源交付，协助研发线上问题排查，各类研发工单处理等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这些日常事务极大的消耗了DBA的精力，DBA长期挣扎在这些日常事务处理上，无暇他顾，形成恶性循环。如何通过平台化手段解决这些问题，让DBA从泥潭中抽身？这是所有问题中的最优先要解决的。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;五、平台整体架构&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;283&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.49765625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rseOvXhKzNZ8EWoVL8wguu1pQo6SHrJNRxvBfd602fMKAoYUm30VNmVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;1、技术栈&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;应该算是相对主流的技术栈选择，语言选择上没有优劣，只要自己掌握的了都不影响实现结果。只是不同语言特性的，可能会比较适合解决特定场景下的问题。比如我们要做Agent，选择Python显然就不是一个特别好的选择。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;2、功能层面&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;主要面向跟DBA跟研发，为了方便DBA能随时随地处理问题，做了自己的小程序。比如在地铁里能做一下工单的审批及其他常规操作需求，或者躺床上盯盘等，提升工作效率跟幸福感。研发能自助解决日常的大部分问题，避免跟DBA有过度交互。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;3、统一网关&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;一般简易的单点平台是不需要网关层的，一个Django就解决了。由于我们要通过一个平台解决多节点管控问题，我们平台服务层(Service-API)都是微服务化多站点部署的，此时微服务化的下统一网关就显得很有必要。前端跟后端交互时只要在Header里面带上Region信息即可正确的路由到指定的服务节点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;平台在设计之初就考虑到多站点的统一管理问题，我是非常不希望看到一套系统在各个站点反复部署的，使用体验简直不要太差！这里是稍微介绍一下为什么需要统一网关如图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;417&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsRntTHN3MhmyTicQLMicQdY1QiaiaQ7q0AAczLZMn2KpUh2Y27MiaOiaE0zTg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种微服务化的架构在部署跟实际使用过程中对DBA及研发体验都非常好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）数据总线：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主要用于数据(监控metric类数据非业务数据)传输使用，比如从最远端的站点A到集中管控系统部署站点的网络延迟在600ms如果A站点的监控数据要往管理站点上报要通过网络直接上报就显得很困难。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;236&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.415625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsd6W4UenXo0urAbJIn1tNyVnxCicPZITn4P5LpAdibmZCWb7icHahBQj3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了减少过多的Kafka部署增加运维的复杂性我们其他站点的监控数据统一上报到一个网络距离上处在相对中间的kafka集群，然后在通过mirror的方式将监控数据同步到管控节点进行集中的消费处理，整体看监控数据从最远端的站点传回到集中管控节点通常控制在1s内整体可以接受，其实最主要的是监控数据写到Kafka避免监控数据因为网络原因导致丢失。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）平台组件集：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其他组件后续会陆续介绍，这里简单介绍一下任务调度：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DBA日常工作中肯定会有很多定时任务要维护即使平台化了也仍旧需要，过去DBA是将这些任务通过crontab进行管理，但是这样是很局限的，比如获取执行状态、结果、日志比较麻烦，存在单点问题，脚本分散化不利于维护，年久容易失修一但被遗忘里面的脚本逻辑中可能会产生破坏作用，存在安全隐患，为此我们单独实现了一个调度管理系统对散落在各个站点上的任务进行统一集中管理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;334&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.58828125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsibTe5ibiaH1ic83U5QANs99eII2QgByia0Akk1mNDVibZtAUicWibicfQHBgtgg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;调&lt;/span&gt;&lt;span&gt;度本身实现是比较简单的可以理解成crontab的网络版，只是在调度本身的基础上添加了一些管理模块如:节点注册，通讯模块，心跳检测等，如果不清楚crontab实现原理的可以搜索Github有比较多的实现参考方式。&lt;/span&gt;&lt;span&gt;其实功能还是比较简单的只是实现了调度的基本功能跟分布式部署，时间关系(70分标准)并未来得及将节点实现集群化避免调度单点问题比如某一个调度节点down机其他节点会自动接管。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3）添加一个任务：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;309&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.54453125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsoxCkyQ2Vb0UsWrmQHVnojD3AoOh7ia5dicG1warnk52xY5a1SYWeaErw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4）注册一个脚本:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;298&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.525&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rs2KzOINVPcqJrWMUr9HDbUb0HIrN6iahboahclVBTSQohZEWzcu3uArA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;5）任务管理：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;184&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.32421875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsp8lYE0za9hHfkNC4oyg4Q7MTQI3eUSbor7eC4aibCrIOP67F2oAYRsQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过调度系统很快就完成收拢散落在各个站点上的crontab任务。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;六、MySQL平台化建设&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;295&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.51953125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsvseAFHYnz2hUUHVVGjZEUIc2067dd9lC74IhKnyBXU3gCR5hOkG99Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;1、监控报警&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）健康大盘:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;217&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.38125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsZIoASjwoiab7IlgrsDR2NBudCoO2mctQBoJCGPlV1KmOmomicYOPNS2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过对数据库近50个监控指标的权重打分，得到一个数据库实例的健康度，Dashboard直接按照健康度排序，即可一眼看透当前所有实例的健康状况。&lt;/span&gt;&lt;span&gt;同时，在做权重打分时也会顺带将有问题的地方做好描述，方便DBA直接通过系统一眼定位问题。&lt;/span&gt;&lt;span&gt;大致是这样的:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;254&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.446875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsooRV5W3IlAprsIAuZa27OHuIm1naqCWwwDibh1QTwiboJxs3SnMx7tVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然，为了方便DBA能对问题进行快速深入的分析处理，我们几乎将DBA所有常用操作，都封装到了监控大盘的快捷操作中。&lt;/span&gt;&lt;span&gt;如：&lt;/span&gt;&lt;span&gt;SQL快照(包含用户、状态、时间、锁信息等)，实时抓取SQL信息、Kill SQL、SQL限流/熔断、报警屏蔽等。&lt;/span&gt;&lt;span&gt;日常工作中，尽量避免DBA通过命令行登录到数据库实例进行黑屏操作，这个是我们形成共识。&lt;/span&gt;&lt;span&gt;不管多么资深的DBA一定在命令行模式下犯过一些低级错误！&lt;/span&gt;&lt;span&gt;！&lt;/span&gt;&lt;span&gt;因此平台化要能覆盖到这些微小的点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）报警：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们数据库的报警量还是比较多的（每天2-500条左右），这也是我们做的不够好的地方。回顾我经历过的一些公司或者了解到的一些公司，几乎都是有类似的问题，甚至每天收到上千条报警的也不在少数。报警看似是非常简单的，但是要做好其实是非常困难的，既想报警少，又想核心报警不能漏。有时大家为了减少报警，甚至想干掉报警本身，而不是是去想着解决问题，这是本末倒置的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实很多报警是可以不用发出来的，因为发出来也没有人去进一步处理，或者被自愈系统自动处理掉了。但是种种原因考虑又不得不发。在治理水平跟不上时，宁愿多报也不能漏报(漏报关键报警信息是非常严重的，如果有问题则罪加一等)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;报警多其实反应的是治理水平没有跟上，有些问题看似是非致命性问题，但是如果长期不去处理，问题最终会被放大甚至恶化成故障。我们的做法是：将报警数据化统计分析呈现每日趋势，重点盯住报警趋势线，安排专人跟进，将趋势线控制在合理的范围。从统计数据上解决面的问题，而不是点对点的解决某一个问题。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;2、运维管理&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;此前，数据库的基础信息一直是存放Excel里面的，所以很难想象这种Excel式运维有多痛苦！需要通过系统方式进行有效管理，只有这些基本元数据信息有效的管理起来，后续功能才能依次展开，比如集群包含的实例信息，集群与集群组间的关系、数据库与集群的关系、数据库内的对象信息等等。有了这些基本信息，再对其打上各类运维需要的标签信息，方便做更多细粒度的管理工作&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;251&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.44140625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsj3ICnGgTK6x8xLRiaj9EGGRSb8d0ibJzicNohfaQoyicvZg9LjtI7HLj9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;运维中很重要的一个工作就是发布，尤其是在公司高速发展阶段，产品功能快速迭代自然就涉及大量的发布工作。&lt;/span&gt;&lt;span&gt;为了减轻DBA的负担，让研发不再受制于DBA，人力问题我们需要将它自助化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;155&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.2734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rseiaBMqUkNHYEzCIatZHfOWtrzTXNMVc6qzghUbx3sZ5VYuMts7ic7UqA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;研发可以通过系统自助完成发布工作，这里比较麻烦的是：如何做好用户间的权限隔离，避免误发布？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里需要结合公司SSO+系统元数据管理，其中，&lt;strong&gt;系统元数据的有效性是整个系统能否做成功的最关键的因素。&lt;/strong&gt;我们不能依靠DBA来维护元数据信息，必须依靠完善的系统机制保证，做到元数据接近准实时状态。比如DB跟用户组织结构的关联问题，我们采用类似协商的机制，来保障它们间的绝对准确。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如A先认领了数据库DB1，B用户也来认领该数据库，如果它们同属一个组织结构，则B的认领是合法的，否则会被系统拒绝。后续如果A或者B组织结构发生调整，则涉及该数据库的发布操作将被禁止，用户必须内部完成协商：要么带走这个数据库(别人取消认领)，要么留下这个数据库(自己取消认领)。类似的场景在系统里面有多处，如果依靠DBA来管理这些变化是非常困难的，因此&lt;strong&gt;元数据的自闭环管理是整个系统最底层的逻辑，元数据必须是100%可靠的。&lt;/strong&gt;很多系统比如CMDB，之所以难做或者很少有公司CMDB能做好，个人理解，很重要的一个原因就是在这里没做好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;发布系统实现上其实是有很多的复杂性的，不仅仅是业务逻辑复杂，比如Sharding表跟普通表如何区分？Sharding表要怎么处理才能保证效率跟安全问题？大量DDL任务下发到执行服务器（DDL执行节点）如何保证执行节点不被打挂？等等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;paragraph&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section label=&quot;Copyright © 2015 Yead All Rights Reserved.&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;我们基于gh-ost改造实现DDL，DDL过程会有非常大的Binlog解析动作，如果并发控制不好，会导致执行节点网卡被打爆。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这些都是比较复杂的问题。当然整个发布流程还涉及很多基础组件的设计开发工作，比如SQLReview、gh-ost、Rollback后续篇幅将依次介绍，发布系统使用简单但是开发过程确是一个系统性的工程有比较大的工作量，我们目前研发自助发布率几乎接近100%，DBA不用再忙到半夜搞发布。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;3、应急/自愈&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;数据库需要应急的场景，最多的就是：SQL把数据库打垮了。此前，我们是通过操作阿里云的管理后台实现限流，但这个方法只能使用于阿里云数据库，我们还有其他云数据库选型，而且操作阿里云限流效率不是特别的高，要登录到控制台，然后还要根据出问题的InstanceID，找对应的实例，再找到管理页面操作......而且没有提供SDK操作不够便利。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;还记得我们前面一直提到的：提供一致性的运维与研发体验吗？作为平台研发就要考虑通用的解决方案，比如通过我们自己的中间件，来实现统一限流，这样就不存在云上产品差异的问题，内部系统操作上也便利，也有SDK接口跟我们的DMS系统对接。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.3497652582159625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsrevnHPEs0wIVxtomnDsM04eMf1aFL25lEZFLXV0Gv9diaxulyk4gcxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;426&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;还有诸如冒烟事件处理，自愈系统会实时检测系统存在的异常，比如:未提交事务、锁等待、连接数飙升、长查询、SQL执行堆积、CPU飙升等，系统会实时检测并针对性的启动相关处理规则，将冒烟扑灭，避免冒烟演变成火灾。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;4、数据统计分析&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;通过平台的任务管理部署采集脚本每天对系统表：tables，table_io_waits_summary_by_index_usage，table_io_waits_summary_by_table进行采集分析，我们可以清楚的知道：当前那些DB/Table的冷热度情况。每张表的每个索引使用情况(那些未使用)，为后续治理提供数据支撑。比如，随着业务的迭代，很多库跟表已经被遗弃了，但长期存在于数据库中，DBA又不能删除清理掉。尤其在云上，这就涉及资源闲置跟成本浪费。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;paragraph&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section label=&quot;Copyright © 2015 Yead All Rights Reserved.&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;即使出于DBA的洁癖，也应该及时识别出这些数据进行清理。(这些残留信息存在的越久则治理越腐朽。）&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;159&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.2796875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsHBRc0gCaGxuTkmv51hZc8NZZjl2UEk75ZVvNTtKxTlUCSdPhQWoZGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;157&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.2765625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rshkNvmIWV98qdwUYewKhpPrf9x5iaticiabR8TjSdiaU4w9lolRDWMXoXmA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;慢查询是相对简单的功能。&lt;/span&gt;&lt;span&gt;但是由于各家云上产品差异，我们系统对每家云产品特点做了针对性封装。&lt;/span&gt;&lt;span&gt;比如阿里云，我们直接通过SDK获取，AWS则要下载文件到本地化，然后进行分析然后在统一呈现，这还是比较麻烦的，我们目前已经放弃该方案。&lt;/span&gt;&lt;span&gt;所有DB都已经接了数据库中间件，所有的SQL都通过旁路的方式落库，数据库中间件对SQL打有足够多的标签描述，不仅仅能反应出慢查询的情况，还能根据全量SQL做更多分析工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于SQL量非常巨大，要想存储起来分析是很难的。我们采用了折中的方案，中间件会根据SQL指纹对SQL采用聚合，这样落库的SQL数量就呈现指数级下降，便于统计与分析。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;5、DB上云与自建的差别&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;326&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5738498789346247&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsJ6ahIVt5jLZ89GvicFXTbcjEOrGQw7mHMddeVUFE3fF3wNHx2cfOzJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;826&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上述功能其实都不涉及传统自建时代，围绕基础设施做的一系列的建设工作，功能本&lt;/span&gt;&lt;span&gt;身更多是聚焦业务功能本身。&lt;/span&gt;&lt;span&gt;因此，开发过程中相对还是轻量的。&lt;/span&gt;&lt;span&gt;如果是自建，则要考虑的问题非常多，从硬件、系统、数据库、HA等等，都是非常复杂的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;过去DBA在这块积累的大量的经验，每个资深DBA可能在这块，都有专属于自己的黑科技，这也是DBA过去比较有价值跟难以替代的地方。但是随着DB的上云成为趋势，传统的做法正在成为历史，也逐渐的被新入行的DBA所淡忘，云对基础设施的封装是时代的进步。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;回想10年前入行的时候，那时还是11k/15k的SAS盘，还在折腾什么场景该用Raid10还是Raid5？是Write Through还是Write Back？不同机型配置下my.cnf该怎么设置？OS内核调参、不同数据库版本下特性有什么不同？尤其复制的改进，对实现HA起到什么影响？HA该怎么选做？是MMM还是MHA、ORC还是自己做一个HA系统？如何快速安装部署、快速搭建主从？备份是物理还是逻辑备份等等，这些随着技术的进步及云的进一步渗透，正在成为远古记忆。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;6、MySQL中间件建设&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;277&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.48828125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsbWvkRBq9oKtnNZBsruWicvZlpF4f6N8JeicJiaTc9GaWcYqf1B6MONdCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;自建中间件其实是有很多考量因素主要集中在这3点:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）统一数据库保护层&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;前文提到混合云下，云产品的差异性不同，不同云产品对数据库保护机制不一样，也不开放SDK。此外，由于云上实例规格普遍都是小规格，一般都是购买4C/8C这样规格。这样的小规格下，应对异常情况下的抗压能力其实是非常差的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;跟自建时普遍32C的规格比，可能一个执行计划不是非常理想的查询，就可以导致CPU被打满，导致数据库进一步恶化加速。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为此，我们建设了自己的数据库中间件，提供统一的保护机制。中间件有一个SQL执行队列，一但遇到数据库性能恶化RT增加队列就会堆积，中间件就会感知到数据库的响应异常，会主动地启动保护机制。此时，DBA监控系统也会感知到DB的异常情况，借助DMS的快速分析处理能力可以快速定位具体的SQL，紧接着就可以启动针对SQL的限流或者熔断机制，保证数据库的安全。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）数据库可扩展问题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;即使在云上，数据库规格也是有限的，货拉拉运营这么多年，加上近两年订单不断的翻倍，累计了几百TB的数据。这些数据很难通过单实例的方式存储。虽然过去货拉拉也做了分库分表，但是支撑非常困难。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;paragraph&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section label=&quot;Copyright © 2015 Yead All Rights Reserved.&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;这些开源的中间件问题比较多很难被hold住，距离一款商业化的产品还有比较远的距离，因此一个开源产品如果用于核心场景，必须是能hold住的，否则出问题那叫一个干着急啊。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;云上目前已经有很多分布式数据库，或者可以水平扩展的数据库选型，但还是不能被我们直接使用。一方面不够熟悉，另一方面，各家云商产品标准不一样，最后就是价格太贵。何况我们也还没到海量数据的程度，杀鸡无需用牛刀；而且引入一款新的数据库，考虑因素太多了，如果只是单一云环境尝鲜新，数据库选型也可以考虑。但是多云环境下，按照云商的推荐去搞会导致数据库选型泛滥，最终会制造无限的麻烦，还是尽量选择能被完全把控的方案相对稳妥。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以预见，未来企业肯定也是以混合云为主。如何做好产品选择是很重要的，一定要考虑好产品间的兼容性与业务系统程序的可移植性，避免跨云移植水土不服。不兼容是必然存在的，作为核心基础设施的我们，在能力建设上要充分地考虑跟对应的能力建设工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3）多语言统一访问层&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;创业型公司语言选择往往是很混乱的：PHP、Python、Go、Java可能都会有。几年前在饿厂的时候就听过这样一句话:“语言的选择可能会决定一家公司的成败”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;paragraph&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section label=&quot;Copyright © 2015 Yead All Rights Reserved.&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如货拉拉以PHP为主，它的整个生态，或者语言局限给后续上规模化后的管理、运维、服务治理带来很多问题。这种小语种甚至都找不到靠谱的开发，更别提其生态建设了。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如在数据库上，普遍采用短连接有的核心服务就有几百个，Pod高峰期数据库连接数大几千个，这对于小规格内存只有16G/32G左右的实例来说实在是太重了。接入中间件后，连接数直接能从5000降低到300，这还是非常可观的。这里顺便说一句：之所以缓存既选择了Codis又有哨兵，还有Cluster，跟PHP都有一定关系，其中PHP业务就是Codis为主（所以前面吐槽PHP的原因就在这里，当然吐槽的不仅仅是数据库，还有服务治理上的...）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了适应PHP的长期存在我们也在对Redis进行Mesh化建设与治理暂且按下不表。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同时的在数据库的深度可观测性上，可以做更多工作，过去对热点SQL、SQL分布、RT分布是很难有合适的手段的（虽然后续有了PS功能，但还是显得很局限），通过中间件旁路，这些信息可以轻松获取到。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;213&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.37531486146095716&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsLf6fib4xkibtQkqWRxfv2icPQoHkysE7gsaTWx2iaN5icR0TFu1scWW6oAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;794&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;216&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.379746835443038&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsNsrujvGYcr4XE9Xf87kXyh51jxNojHTiae74ibOxp5RGKa5j86YQxWMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;790&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有了中间件的加持+DBA服务治理+平台建设，数据库的稳定性有了长效的保障机制。&lt;/span&gt;&lt;span&gt;中间件的建设也为解决一致性运维与研发体验提供一些支持。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;7、MySQL基础工具建设&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;277&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.48828125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rskuYQyw56UZKbvVUvwRDzCdoNSy1IrbjnibdLTX5m86DYUJib3LWqJrNg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;自愈系统：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;系统会实时感知到数据库负载情况，结合数据库中间件的能力快速作出决策进行限流或者SQL查杀。同时，基于云的弹性能力进行自动扩容，云上都有类似的ModifyDBInstanceSpec接口，比如检测到空间不足则立即扩容，因此我们可以将实例空间维持在一个很高的使用水位，尽量成本合理化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）SQLReview&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前在业内有很多开源的解决方案，但是我还是坚持自己做了一个，理由也很简单：可以自由灵活的个性化定制。不仅仅覆盖面要全，同时也融入DBA经验性的内容，可以基于统计数据做公司内的“大数据”分析，清楚地知道：大家整体容易在什么地方犯错？哪些团队做的好？哪些团队做的差等。同时，自研一个因为完全能hold住，跟其他自研系统可以无缝对接高度的灵活。此外还针对性地对货拉拉过去规范上的错误或者不足，做出识别与纠正，如果基于开源就不太容易做到，或者有一定改造成本。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;SQLReview核心模块就是SQL解析，这个参考了TIDB的实现模块，有兴趣的可以看下其核心解析模块：githup.com/pingcap/tidb/ast，githup.com/pingcap/tidb/parser，不过这块随着源码的不断提交会有一定的差异。如果我们一直跟着官方最新代码包去编译，容易产生非预期问题，建议是本地化包管理或者干脆把这个解析模块单独扣出来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于审核规则，一方面充分吸收了开源系统的的一些规则，还融入了一些DBA经验理解及过往错误规则纠正:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;199&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.35040983606557374&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rszDia8OKqfa6zJicBibS85HPuhlSI09curd0uicEKoumItHdA1MEiaQD7UfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;976&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;439&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.7737003058103975&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rs1QYofsHQiaGnhvUWmex0sDkrdx1s5ZvAuY0NDNyicX7ic62IOszraRGiaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;981&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;410&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.7225609756097561&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsIKYf1RoicuXN5C1PmWP1KT26NbdgicWiadiaZjX3p5b5ullGD18n4FYI4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;984&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这些会在研发提交到发布系统前进行统一的校验。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）gh-ost建设&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;gh-ost(相信很多人已经对他很熟悉了)只是一个单纯的DDL工具，如果跟平台进行整合还是要做一些改动的，以适应我们多站点化的部署：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;365&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.6421875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsyXy6ib3Cl4gmItFyU4mRvic5tnDNS5IAERulKZibDmgJK9pu7k1NrLWqQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据统计我们平均每天的DDL量超过200+，如果是sharding一个逻辑表的DDL，会被拆分成1024个DDL，如果这些DDL由一台机器来完成是非常困难的，而且研发在提交发布的时候，可能都集中在发布窗口自动打开之后的一段时间内。&lt;/span&gt;&lt;span&gt;因此，即使在同一个站点内，执行节点也需要部署多个，每次向执行节点分发任务都会根据执行节点的任务数来做均衡分发。&lt;/span&gt;&lt;span&gt;之所以还需要在每个执行节点维护一个执行队列，主要是因为gh-ost本身导致的。&lt;/span&gt;&lt;span&gt;简单回顾一下其基本原理：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;254&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.44765625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsDbgE0KtjlUDOQwJbYZ44ibOia0L9KsFia0EU2kJDcU72OR3TqJJJcWEDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于其通过拉取并解析Binlog来代替PT的触发器机制，因此，当对Binlog产生量比较大的实例进行DDL时，网络带宽会比较高。&lt;/span&gt;&lt;span&gt;当多个任务同时进行时，带宽可能会被打满(在云上DMS使用的ECS，EC2网络配置都不是特别高基本都在4C~8C、2Gb~5Gb带宽)，同时CPU也会很高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主要是gh-ost要对记录做循环的逐行逐列处理，系统高负载下会导致DDL失败的概率增加。所以在每个执行节点上都加入了一个任务队列，通过线程池做稳妥的并行化控制，避免相互影响。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外，还通过网络模块对其进行良好的控制，比如优雅终止，还有日志的阉割(其日志实在是有点啰嗦)，由于比较简单不做赘述。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3）Flashback(DML回滚)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们并没有将回滚内置到DMS发布系统里面，主要还是嫌麻烦，毕竟实际需要回滚的场景还是非常稀少的，内置到发布系统做起来有点重。当然好处是需要用的时候很快捷，我们是在gh-ost执行过程中埋点关键点位信息：start binlogfile~end binlogfile，start pos~end pos，ThreadID ，有这几个关键点位信息，根据ThreadID可以精确获取对应变更的BinlogEvents然后生成逆向SQL。其实很多开源的系统也是这么做的，所不同的是，直接根据Binlog QueryEventData里面的Threadid，一边DML一边进行Binlog解析，然后拼装成对应的逆向SQL保存，当需要的时候直接执行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很早以前，对误操作或者闪回DBA也是伤透脑筋，甚至想出了各种各样的黑科技做法。比如以正则表达式为代表的脚本工具类的居多，但是这些都是不靠谱的。随着对MySQL的进一步深入及开源化建设（或者说生态逐步完善），这些实现变的越来越廉价，适当的掌握一定开发能力可能都会轻松实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不过，仅仅是基于一下开源的堆砌，是难以做到合理的平台化整合，只有深入理解或者对其代码逻辑结构有比较多的理解，然后在此基础上进行深入改造融合，才能用起来比较趁手。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们MySQL主要还是围绕云服务来进行建设，但是我们还是做了大量的基本能力建设工作，不是说上云了就是万事大吉，还是有很多事情要去做。云解决了基础设施的SLA保障问题，但是业务层面的问题还是需要我们自己来解决。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们的系统完全由DBA自己开发完成，从前端到服务端到架构到各个数据库平台具体功能细节，DBA基本已经不是单纯的DBA了。在云时代下，DBA需要更加的多元化的能力模型，入门门槛很低（会操作就行），但是要求确非常高(全栈工程师的要求)，很多新手DBA在云时代下越来越难以接触到数据库完整的生命周期管理(从硬件-&amp;gt;软件-&amp;gt;资源交-&amp;gt;HA...)更多越来越偏向业务本身，因此相比过去的老一代DBA，他们缺少了一点点底蕴，不过新手DBA一定不要陷入一个误区：以为会操作就是玩转了数据库，殊不知当前之所以能玩得转，可能是因为构建在当前运维管理体系下的，如果有一天脱离了这个体系，自己是否还能hold得住。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;七、Redis平台化建设&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;267&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.46953125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsO9sfW6D29YH2klt1oq9Yty2BWI2ibiakErHib9ibJia2erb5icCmevEJthJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于很多因素，我们Redis服务是基于云ECS自建的。&lt;/span&gt;&lt;span&gt;Redis本身的运维其实是非常简单的，没有MySQL那么多复杂的东西，在基础功能上涵盖了DBA日常用到的绝大部分功能，功能实现上也没有特别多的复杂内容。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;1、监控大盘&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;出于个人喜好的原因，Redis沿袭了MySQL的大盘套路：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;249&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.4390625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsdVGUCia6J4nrA7Gvg8TmcvgnuPu398Qdeodj3p1MgOB9ziaPibQgb8Nrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总的来说，就要达到一眼定位问题，同时将所有DBA排查定位问题，日常操作等功能都集成进来。&lt;/span&gt;&lt;span&gt;比如:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;371&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.65390625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsczCu3vYfUQuNW7jwdU3fayjyRLdt8oGEf9NYQL45Pod6wia4YQtfhCQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;315&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.55390625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rscpPpuQgYPxDLSKBmftXngthZXibdLTicJaA3v8BTb3BeTfPEHYoO08ZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;2、实例替换&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;198&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.34921875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsHXibGr7MPbia1cIBePO6UA4I3iabDuIDl46YYib4rptptaBnOkqLlB1bTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以快速完成实例的迁移替换，及某一台机器的快速替换。&lt;/span&gt;&lt;span&gt;主要用在服务器内存超卖策略下，某一个机器内存不足或者单个实例过大时的便捷操作。&lt;/span&gt;&lt;span&gt;由于我们整个DB、缓存、队列的资源交付统一是资源ID的交付模式，原则上底层资源变动对上游业务无感:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;127&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.22421875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsalAmiciaiaIpWJlB8qu6ZFG7QHyV2JuJicic4GkNyK9ibXm74TyeFZaMx5hw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;研发不用关注数据源的配置是什么，只要将资源ID跟APP ID建立绑定关系即可访问到数据。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;3、扩缩容&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;295&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.51875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rs8N6WOiahjHiciaqIYpq8KLkqjEmyc7yKVZSyak7f6kD4kTRTziabwJ4qTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;293&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.515625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsRDM04cCk2V9WsP4vo11OJHtzASCASzlJB6X8QYGJRH7D3tNf5a7ImQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;扩缩缩容的背后，系统维护了一个资源池。&lt;/span&gt;&lt;span&gt;我们会常态化地保持池内有一定的闲置资源，确保随时可以使用。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;4、全量Key分析&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;Redis运维过程中，非常重要的事情就是：做好Key的分析与监测，比如Big key。此前，我们做这个功能的时候，是在每台机器上部署任务，定时将RDB保存到共享存储里面，然后进行集中分析。这种方案非常的笨重低效，在Agent开发完善后我们做了全面的改进:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;307&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.53984375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rssy9jXOuc7RosyQejmnT8EqumgZUicdRmRD6icYYmdrlVzicrVf3RefJGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Agent内置了RDB分析功能，同时也有网络模块提供对外调用，由于我们一台ECS上部署了多个节点，如果Agent同时分析，会对服务器有一定的入侵，比如会占用一定的内存资源。&lt;/span&gt;&lt;span&gt;为此，每个Service都内置一个调度模块做任务调度协调与任务分发，避免集中分析对服务器的侵入。&lt;/span&gt;&lt;span&gt;我们对RDB的分析本身也做了很多细致工作，比如我们在通过开源工具分析RDB时发现：&lt;/span&gt;&lt;span&gt;对于比较大的RDB文件，分析时会占用非常多的系统内存，这是不符合Agent低侵入要求的。&lt;/span&gt;&lt;span&gt;我们通过Agent做超过20G的RDB分析，Agent整体内存也始终控制在100MB以内。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Agent基于Go实现无其他依赖，每台DBA交付的ECS/EC2上默认会部署并启动Agent，Agent会主动报告：我是谁(IP)、在哪里(region:区域/节点)。因此，基于Agent我们可以做很多自动化运维的事情，比如自动化的安装部署等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;156&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.275&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsbVhBJ2Eq8SZvq0bbrXvpaou27Fo1JBImBP3bwx5vdmJxg1LibpA4zng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于历史原因，选型上有云、Redis、哨兵(占比80%)、Codis、Cluster，出于统一运维标准的考虑，统一采用Cluster模式，因此其他选型到今天已基本被淘汰。Cluster在可扩展性上会有更多的优势，也是未来的主流方向，但是我们还有很多PHP的服务，从Codis改造到Cluster后出现了很多其他的一些问题：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;php&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;$redisList = [&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;tcp://127.0.0.1.1:7000?timout=3.0&#x27;&lt;/span&gt;, &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;tcp://127.0.0.1:7000?timout=3.0&#x27;&lt;/span&gt;, &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;tcp://127.0.0.1:7000?timout=3.0&#x27;&lt;/span&gt;, &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;tcp://127.0.0.1:7000?timout=3.0&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;$redisList = [&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;tcp://127.0.0.1:7000?timout=3.0&amp;amp;slots=1-100&#x27;&lt;/span&gt;, &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;tcp://127.0.0.1:7000?timout=3.0&amp;amp;slots=101-200&#x27;&lt;/span&gt;, &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;tcp://127.0.0.1:7000?timout=3.0&amp;amp;slots=201-300&#x27;&lt;/span&gt;, &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;tcp://127.0.0.1:7000?timout=3.0&amp;amp;slots=301-400&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;....&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;];&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总的来说，在Redis的基础运维上全面实现Cluster化后，我们当前的方式是没有太大问题的。但是在进一步的深入治理上，我们做的还不够的。因此，我们也正在做我们的Mesh化建设。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;八、Redis ServiceMesh建设&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;278&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.48984375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsQhcZ3x2R7yYEs4wC9SVshvDC7bcD6DxrTu9E8dHDKicjDGFHickzvy8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所谓Mesh化其实就是将Proxy本地化内置到客户端服务器，即sidecar模式。&lt;/span&gt;&lt;span&gt;Local Proxy可以充分利用客户端资源，缩短链路，减少云上跨AZ带来网络上的不确定性。&lt;/span&gt;&lt;span&gt;我们前面在Codis上也出现过客户端跨多AZ跟Proyx间网络问题，导致部分Client有影响。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;1、服务&amp;amp;成本治理&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;250&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.43984375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsoeGP27nh9BUicVKolW2dzcN6iaFBBMWV5CkhDdMbRia3FKia68ANzU5ONA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是这也还是有缺陷的，虽然集群内部Key是可以避免冲突的，但是没办法做到资源的隔离，而只是逻辑的隔离。&lt;/span&gt;&lt;span&gt;我们将一些小容量的Cluster，集中迁移到统一的大集群中进行租户划分，尽管无法做到资源隔离，但是通过适度的资源冗余，也能很好的避免性能问题。&lt;/span&gt;&lt;span&gt;同时，由于混部集中会有效减少资源浪费，根据我们现有的数据测算，可以节约40%~60的内存成本，同时有效减少现有集群规模跟节点数量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;九、Kafka平台化建设&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;1、Kafka治理背景&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）一种开源工具拼凑的管理系统&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）管控能力弱，碎片化监控 &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3）集群内部对象状态缺乏感知&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4）平台化建设缺乏有效参考&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;2、Kafka平台&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;309&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.54453125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsve6u94L6gSy9HRYI6YsUgLLpbnOBwa7rBicpDZDOxib3wkOYscz3WwKQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）集群管理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此前我们都是在各个站点进行分别部署对应的开源管理系统，管理比较分散，现在得益于现有架构的实现，我们可以轻松实现一站式管控&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;154&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.27109375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsa6ZibapYicoLXxFhibAbvmcAaAaXJOpZk0SvFYg5E0dLwHJCAH2IsTDQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）Topic管理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;186&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.328125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsfTCjzU5MHic2TAczHO5LPkPNpPohouiaBHTLgBrNVBicj9TNuNQhz8SMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了对Topic的常规操作封装到平台外，还通过对Topic元数据信息落库，我们可以在全局的角度分析一些问题。&lt;/span&gt;&lt;span&gt;比如当前哪些Topic是热点Topic？&lt;/span&gt;&lt;span&gt;那些Topic msg body比较大？&lt;/span&gt;&lt;span&gt;(可能需要DBA找下业务方确认合理性，很多数据来源是Canal-&amp;gt;MySQL-&amp;gt;Kafka，研发为了简单可能会将全字段写入Kafka)，那些Topic体量比较大等等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;①Topic详细信息：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;233&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.41015625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rstPlhgNAiczMTvQrtPHGheIfiaawjqzX6hJcZTEUZh3Kpxmia2IsdL9Org/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;60&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.10625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsc8Np1icia5KvkUYzDklKK5lxevicM2dgCeVpQib3Ya0sheADRSiccUOThdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过对每个Topic的消息大小采样，可以知道：&lt;/span&gt;&lt;span&gt;消息体大小分布情况，通过采样消息分析消息体大小突变的原因，方便作出优化处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;②Topic分区信息:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;147&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.25859375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsUrjrhMM8RFA8yfEZzLfUPnRuYv4OfTiaoZgJCSmKeH3CA7MM4rgS5uw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同时对Topic的分区分布情况进行展示(实现对kafka对象信息的完整覆盖，完全实现了Kafka-manager的全部功能，篇幅原因不做详细介绍)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;240&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.42265625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsuNbeWbz7BPFw8v17Az141JN61libRTm2mGz0dnTOeHcKVV4wcibKy2tQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同时为了方便研发&amp;amp;DBA临时查看消息的诉求，也提供基础的查询能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）Consumer管理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;156&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.27421875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsunH527gDTQClysOicx7eiaBaG5G97gulHRw9fGgzerwUkYAYPu2ZJiaSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;系统将Topic跟consumer的关系进行采集、保留，方便运维需要。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;①Consumer Lag:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;292&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.51484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rs64XPj1LKjpaGk0DP0jtLKj9vuLwGQNnuon2zMzDtBt6ogowjVF3b9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一般的Kafka延迟通常以Lags来衡量，但是Lags最大的问题在于难以做时间维度的量化，以至于难以判断延迟的真正程度，也不方便提供研发订阅(研发需要知道自己消费延迟情况，但是Lags对研发不够直观友好)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如上图，Lag=250k表达出来的意思就不如延迟时间=600s来的直观，基于时间的延迟实现，我们在提供研发做报警订阅时就有了直观的衡量标准。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是受到Kafka HW及consumer延迟commit的影响，要获取consumer的精确延迟时间是不可能的。以上图为例，这是典型的大数据消费处理的特征：消费一批数据后在做commit，这时我们观察到它的延迟时间跟commit时机有非常大关系，呈现出了周期性波动。但是实际上，延迟的真实时间是小于600s的。而受到上述机制的影响，我们没有办法做精确计算。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;273&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.48046875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rs1icRtic1Pes75pBibDE6FApKmPSU0uXDasuqtYKMBl94na5NbCWoI0t6g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如上图，我们可推测该consumer消费时就是典型的生产业务消费特征：&lt;/span&gt;&lt;span&gt;逐条或者小批量消费后立即commit。&lt;/span&gt;&lt;span&gt;我们看到它的延迟就相对稳定、(生产与消费比较稳定无明显的周期波动)波动在正常范畴内。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;②计算延迟时间思路:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;delay~= (hw offset msg body).timestamp-(consumer offset msg body).timestamp&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过获取两个offset点位的消息体&lt;/span&gt;&lt;span&gt;中的时间戳做减法的方式，效率比较低理论上准确度好一点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;非常高效但是准确度稍差，目前主要采用这种方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;说明：实际实现要稍微复杂一点点，两种方案都会遇到很多细节要处理，篇幅原因不在细节上面面俱到。再次申明这是不精确的，只是相比Lags要更加可度量，方便做报警配置及研发订阅告警。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3）Broker管理&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;145&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.25546875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsfib66IJCcib8StXHTfwnVyA6Co0SO60mqBo7ySofxNRfh13GFeBXKArQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们对Broker做了zone分组，方便实现后续的资源隔离。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;3、元数据网关&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;目前研发消费Topic时只需要拿到Topic所在集群地址即可消费，这样就给我们管理带来一定问题同时也不够安全。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;前面提到，我们现在所有的资源交付都是通过资源ID进行交付的，研发也必须只能通过资源ID才能访问到Kafka，因此我们网关就基于这个点进行建设：用户的consumer必须在DBA交付的资源ID中建立Topic跟consumer的绑定关系，用户在拿资源ID时需要对其指定的password、Topic跟consumer进行绑定关系验证。(框架对Kafka Client做了封装)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;否则就拿不到资源ID，当然这个实现肯定是不完美的，聪明的研发肯定能想到办法绕过。比较理想的做法就是将绑定关系内置到Kafka server中，但是目前还没有精力进行这方面的投入。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;4、多租户隔离&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;我们目前Kafka使用呈现出了两极分化的趋势，一个是超大规格的Topic，另外就是小规格Topic。尤其在高峰期时，网络带宽非常高，单机网卡流量能打到7Gb+。这影响了其他小规格的Topic业务正常使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们知道在云上CPU、网络、存储资源都是比较贵的，而Kafka这种特性，决定了我们可以选择CPU规格略低一点，但是网络、存储要求比较高。不过遗憾的是，云上CPU、网络、存储是存在比例关系的。有时为了获取更大规格的网络跟存储资源，需要购买规格更大的机器。这样就造成了资源上的浪费，同时Topic间也相互影响。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们对集群的Broker划分成多个zone，每个zone里面一般由3~5个Broker组成:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;210&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.36953125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rs4q5bIBgib9g7GQCibXO5OAqFnIL05kx9eiaqxPmGymDYUDnS0ibBo1xPGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;每个zone可以根据Topic的场景、业务场景或业务线来进行分配，比如zone_1可以分配给风控业务的大规模数据处理使用；&lt;/span&gt;&lt;span&gt;zone_2则分配给一下小的业务场景混合使用。&lt;/span&gt;&lt;span&gt;同时，正对zone_1的业务场景，我们分配给它高配的机器，zone_2我们分配给它低配置的机器。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样一方面做到资源隔离，另一方面做到资源的合理使用，最大化发挥机器能力。但这样似乎还是不完美。比如：当zone里面有Topic规格发生变化，需要升级配置或者降低配置的时候，就会对现有zone的资源进行调整。为此我们也是有解决方案：依靠监控，我们可以清楚的知道Topic的及zone中Broker的容量情况的，当资源不足时，我们可以加新的Broker，或者将Topic调度到其他zone中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;230&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.40546875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsiaNxbwWXHynwCkdR4gQ5uF2cFxmFZZO0cb4DflCicKic8hnyz7BXdfFWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前平台基础功能已基本覆盖了开源的Kafka-manager，同时我们也对比较好的开源实现思路整合进平台。&lt;/span&gt;&lt;span&gt;而且我们也做了很多的数据沉淀，为我们更好地治理提供依据。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;十、ES，RabbitMQ，Canal平台建设背景 &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;141&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.2484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsnBbtI1Wp36VEJm1RWXu0MmQy9BA2qTdGmib8A8iaFiaciaicEgdwdGxicw1A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;难以想象，这些中间件的管理系统加起来有几十个之多！&lt;/span&gt;&lt;span&gt;难以忍受！&lt;/span&gt;&lt;span&gt;！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;283&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.49765625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsMZNsXUe7wtnibjbNx9ICMUiaUYXX5lmZTxvXXZQ3L23o5yA3dl1icjtYQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ES，Canal，MQ其自身的可观测不是特别好。&lt;/span&gt;&lt;span&gt;不过好在它们都再带了自己的Web-admin，这就给实现集中式管理提供了可能。&lt;/span&gt;&lt;span&gt;除了我们通过分析起Web-admin、API将其关键元数据缓存之外，我们DMS平台的诸多功能都是对现有Web-admin的API的调用实现，一种非常取巧的实现方式。&lt;/span&gt;&lt;span&gt;同时，元数据的采集也对我们更好地维护治理这些基础中间件，提供更好的依据。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;1、ES&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;187&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.32890625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rskeQ2u3ribzNlNDEoyLibnGicBBPnibbFUrvNNWOjFXRYibBqLjPNUo9dTDg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对集群有了更多运维属性的标签便于维护&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;158&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.27890625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsngDQVqp5CVHxfoNrZXEfeQH3ZVia4doaTvwj7axXVkICMNUCfYeXyJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过DMS对索引添加研发属性描述，便于后续维护&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;176&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.31015625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rs9omzh66oZ4lW7zuexbPCDukGE6SFrfnamEn5hd7DvwB1UBQ6wibRRyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;资源申请与统一交付&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;262&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.46171875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsrMAiaaGBTOcLBiaabT5DoKKOg3icITSnRFcg0c3yLHj8wK14REK0m275Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;索引轮转统一管理，减轻研发心智&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;2、MQ&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;174&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.30625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsImlFQ05HGI8yJ8OnzTYus1Pa3c1o4RkmYeyqB0EObxXQPYwJRNLCSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;181&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.31953125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rskN2fcOygvBrw9bD4ZoduDWq7R43KDdewbY4kwjgQ2PI3aWErPuGPQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个完整版的MQ-Admin，实现管理从分散到集中化的管理，操作便捷高效。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;3、Canal&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;159&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.28046875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsUWGJpo3UUgGAzqoVDiaKT55TXGINuMkdKtfspWicmLHxlOTcJ6wkRpTg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;完整版本的CanlAdmin&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;207&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.36484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsk4tuqScMvw61vymcgtOSSRRERKtsUbwBykEJrYXa4pUGmJEEDwruwA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;流程化数据订阅：Canal-&amp;gt;Kafka-&amp;gt;研发消费，DBA高效交付，研发使用便捷。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;260&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.45703125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsPSfKFLK9Xicn5FFrSNlDZpHMSJUcRZV7fwEoY55iaibJ7Iaia6TQOzDh8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关键监控点采集可视化提供统一预警。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;十一、研发自助化平台建设&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;281&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.4953125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsLBkAHv0Xw79GSquTAMR76h0wZtWmvicRbAWEEIqWiaUbOPFnbtlSCcpw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;服务一个几千人的研发团队，如果依靠DBA人肉支持，后果是难以想象的。&lt;/span&gt;&lt;span&gt;DMS满足了开发同学对研发过程中对DBA的诉求，所有的操作基本都可以通过平台化手段进行自助。&lt;/span&gt;&lt;span&gt;DBA如何变被动为主动？&lt;/span&gt;&lt;span&gt;平台化就是关键手段。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;273&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.48125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsVafgDx4eo2JERa7VCclKuuatHzzfShkd6rFhCf5Oj0bA8ib5gBu6uQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;研发想要的我们都提供，同时也主动展示给研发一些开发过程中暴露出来的问题，方便研发改造。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;269&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.4734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsaclsx9B2KX4IwXPINyvBhw6kyjK3n73MM6Mw14A1dkYoraSPYa2pkg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;包含MySQL、Redis、ES、Kafka的查询等。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;十二、从运维走向运营&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;277&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.4878048780487805&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsnf4JMykCgNU0BViaibaVIQHfGGwbZV8IQKQtrxGhyy65F4FE2icibLXJoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1230&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经过一年的马不停蹄，虽然数据库类型很多，但是我们还是基本上完成了每款数据库及中间件的核心功能的建设工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是我们并没有考虑跟进一步走向所谓的智能化阶段，应该说，目前业内呈现的智能化还是一个很虚的概念，真正付出实践的太少了，或者大多数都是基于规则引擎的更高程度的自动化，对于一些体量不大公司基本上属于KPI驱动的产物。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于当下的货拉拉，我觉得比较务实的举动就是实现运维的数字化运营。这是当前正在做的方向，其实也比较简单，就是基于平台的数据沉淀，对核心指标进行展示、体现出整体稳定性治理的趋势、云上资源利用率分布变化等等。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;十三、近一年治理成效 &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;288&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsQiaYF8GeDwSB3z3mMSKSDjUxRsB4O4XRKXZr5lhhiazBiahibbUg5dBDTg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经过一年的建设我们在稳定性上有了长足的进步，同时，基于平台化建立起标准化的运维体系。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;paragraph&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section label=&quot;Copyright © 2015 Yead All Rights Reserved.&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;我们一直说标准化与体系化，那么是什么标准化跟体系化？如何来践行？我个人的理解就是通过编程的方式将我们的标准规范流程固化到系统里统一接收外界输入或者对外界统一输出。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在这一年里我们以超越预期的速度进行疯狂输出，也很庆幸结果也都超预期，否则很难想象，今天可以轻松服务几千人的研发团队！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们在平台化没有成型前，是没有数据支撑我们做成本的优化的，有了数据的支持，我们发现资源的浪费其实还是很严重的，好在云上都具备规格弹性能力，经过合理的缩容、资源合并、老旧业务下线改造等方式，在成本上有着非常可观的节约。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上述平台建设与治理内容，我们用了一年的时间走完了3年的历程。一方面有云的加持，另一方面我们也多了大量的投入。平台人员投入2.5人(我算半个)今天也就3个平台研发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从前端React到后端Python、Go到框架到架构设计，几乎是全栈DBA，很多数据库选型我们都是第一次接触，但是丝毫不会阻碍进度，比如Kafka从0认知到完整的平台化也不超过3个月，ES、MQ也几乎是1~2个月就落地的。应该说我们不再是单纯DBA的定位，这种多元、综合的能力建立，是我对整个DBA团队后续的期望跟要求！&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;十四、云时代下对DBA的思考&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;280&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.49375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rszicw8uLwR5ibkjrNR2dp2kht81WIiaWZwRheSicsfe5FWuichNfr368ApwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;云极大的简化了传统自建时代，围绕基础设施稳定性建设的复杂性，云已经成为了一种新的基础设施。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;1、DBA职责转变&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;云上数据库的可靠性、稳定性在云能力的加持下，不再是核心工作，DBA将更加偏向业务，比如性能优化，成本优化等等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们在自建时代也会考虑成本，但是通常都非常难做到非常高的资源利用率，这里面有非常多的原因。近几年也看到将DB搬到K8s的做法，其实本质的就是想通过这样的手段来达到类似云的能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是这个投入是非常大的，甚至超过了收益，也伴随很多的风险，非常不建议中小公司做这种尝试。个人也非常不看好K8s里面跑DB的做法(云原生才是未来)，千万不要以为能将它跑起来就是能驾驭的了他。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;2、能力模型改变&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;围绕自建打造的传统能力将没有生命力(还有比一个SDK来的更简单高效的吗)，DBA在自建时代的很多“黑科技”将逐步失去用武之地。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;过去DBA深入研究数据库内核，比如对MySQL的各种原理机制理解的非常透彻，虽然这些也还是非常重要，但是留给DBA的操作空间并不大，比如云上有规格跟参数模板严格的参数控制，基于开源理解的特性跟云上优化，或者改造后的并不完全一致，因此DBA深入理解云产品比深如理解数据库本身，可能更有帮助。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;paragraph&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section label=&quot;Copyright © 2015 Yead All Rights Reserved.&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;不过遗憾的是目前云产品本身的帮助文档还非常的不健全或者介绍的过于简单了。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;3、上云误区&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;云上DBA仍旧有用武之地，仍旧有很多有挑战的事情要去解决。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;4、转型思考&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;拥抱变化上云不可抵抗，不要把自己定位是一个DBA这太局限了(省略后续鸡汤)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;292&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5140625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bdeLXzVF0jpNdZYZhlV7rsXlrC0Jn2ZdK4icv8vqxIiad590gREaJT0eSAbicMdA5icHe9xFd7Ge1YVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实际使用云的过程中从各家云提供的SDK已经高度模块化了，稍微有点编程能力就可以将这些SDK组装起来，拼凑成你要的样子，很大程度上降低了开发的复杂性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不知道我们是否思考过一个问题：为什么每家公司，不管是DBA还是其他运维部门，都还在不遗余力的做平台？这些平台其实功能都是同质化的，或者说高度的重复性建设，虽然呈现形态不一样，但是内部的机制几乎都一样。我觉得未来这种局面会随着云上对运维标准的定义和建立而发生很大改变，或许以后我们不用再建立平台，而是直接使用云平台，或者采购三方开发者提供的标准化解决方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;云正在重新塑造整个IT行业，作为从业者积极调整改变很重要，如果打不过他们，那就加入他们(云厂商)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.36086956521739133&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8YY6J547ZhgwY87vBia8l2ic7vAeqPaIJicV0RiacMHFOs2HBwzojCN94ROMWN3hCF1Z5DAwEaibibQSLxQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1150&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;↓点这里可下载本文PPT，提取码：lala&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7fcce734e52aa49ab3e526a8c7cf3de9</guid>
<title>Rust 中的无锁编程技术（四）</title>
<link>https://toutiao.io/k/5i10b1q</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section&gt;&lt;span&gt;在之前的博客里面，我们通过最基本的SpinLock的实现对锁有一个比较完整的认识了，但同时我也指出了自旋锁实际上是相当粗糙的，我们只要仔细想想其工作原理就会发现，最大的问题是线程与线程之间毫无公平性可言，导致这个结果的本质原因是对于Atomic类的&lt;/span&gt;&lt;code&gt;&lt;span&gt;compare_and_swap&lt;/span&gt;&lt;/code&gt;&lt;span&gt;对于不同线程之间是完全随机的，也就是这个函数没有办法控制哪个线程将会成功置换共享内存中的值。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;那么从理论上来讲，如果我们的操作系统没有很好的处理好CPU调度的优先级的问题，有可能有的线程会饿死，而有的线程可能可以一直占据共有资源。那么我们如何解决这个问题呢？&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;一个更好的模型（TicketLock）&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;我们先思考一下SpinLock的模型：&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;有多个线程在同时试着置换其&lt;/span&gt;&lt;code&gt;&lt;span&gt;AtomicBool&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;OS会在这些线程中随机选一个线程，让其成功置换&lt;/span&gt;&lt;code&gt;&lt;span&gt;AtomicBool&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的值。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;其他线程会一直卡在代码某处，一直自旋。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;当上一个线程结束了对共享资源的使用后，会回到上诉的第二点。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;这就好像我们去银行办业务，但是只有一个窗口，大家都挤在这个窗口前面，谁将会是下一个可以办业务的人完全看业务员的心情。更好的做法应该是叫号的模式，我们现在去银行，都会提前去前台拿一个号码，当上一个人的业务办完了，就轮到了持有下一个号码的人去办业务。即使有许多人同时去办业务，前台的工作人员也会&lt;span&gt;按顺序&lt;/span&gt;给每一个前来办业务的人一个独有的号码。比起第一种模式，这种模式就会更加的公平，确保了先到先得的顺序。我们可以将这种模式运用到锁的实现里面，这个就是我们常说的TicketLock。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;pub struct TicketLock {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    curr: AtomicUsize,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    next: AtomicUsize,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;impl Default for TicketLock {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    fn default() -&amp;gt; Self {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Self {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            curr: AtomicUsize::new(0),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            next: AtomicUsize::new(0),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;比起SpinLock，TicketLock维护了两个共享变量，&lt;/span&gt;&lt;code&gt;&lt;span&gt;curr&lt;/span&gt;&lt;/code&gt;&lt;span&gt;以及&lt;/span&gt;&lt;code&gt;&lt;span&gt;next&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，其&lt;span&gt;语义&lt;/span&gt;表示的是当前正在处理的号码及下一个将会处理的号码。我们来看一下&lt;/span&gt;&lt;code&gt;&lt;span&gt;lock&lt;/span&gt;&lt;/code&gt;&lt;span&gt;以及&lt;/span&gt;&lt;code&gt;&lt;span&gt;unlock&lt;/span&gt;&lt;/code&gt;&lt;span&gt;函数的实现：&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ruby&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;impl RawLock for TicketLock {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    type Token = usize;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    fn lock(&amp;amp;self) -&amp;gt; usize {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        let ticket = self.next.fetch_add(1, Ordering::Relaxed);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        let backoff = Backoff::new();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        while self.curr.load(Ordering::Acquire) != ticket {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            backoff.snooze();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        ticket&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    unsafe fn unlock(&amp;amp;self, ticket: usize) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        self.curr.store(ticket.wrapping_add(1), Ordering::Release);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;我们还是忽略掉&lt;/span&gt;&lt;code&gt;&lt;span&gt;Backoff&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;code&gt;&lt;span&gt;AtomicUsize&lt;/span&gt;&lt;/code&gt;&lt;span&gt;类型会提供一个&lt;/span&gt;&lt;code&gt;&lt;span&gt;fetch_add&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的函数，我们还是先忽略掉关于&lt;span&gt;Memory Ordering&lt;/span&gt;的参数，&lt;/span&gt;&lt;code&gt;&lt;span&gt;fetch_add&lt;/span&gt;&lt;/code&gt;&lt;span&gt;函数和一般我们认识的自加函数类似，但是&lt;/span&gt;&lt;code&gt;&lt;span&gt;fetch_add&lt;/span&gt;&lt;/code&gt;&lt;span&gt;是适用于多线程编程环境的。打个比方，比如100个线程同时对一个&lt;/span&gt;&lt;code&gt;&lt;span&gt;AtomicUsize&lt;/span&gt;&lt;/code&gt;&lt;span&gt;变量进行一次&lt;/span&gt;&lt;code&gt;&lt;span&gt;fetch_add&lt;/span&gt;&lt;/code&gt;&lt;span&gt;操作，并且&lt;/span&gt;&lt;code&gt;&lt;span&gt;AtomicUsize&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的初始值为0，那么我们最后得到的结果一定是100，因为这个是CPU指令集给我们提供的最小的保障了。但是如果是一个普通的&lt;/span&gt;&lt;code&gt;&lt;span&gt;usize&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的变量，那么我们是无法保证最后的结果是100的，有可能是小于或等于100的任何的值。所以通过&lt;/span&gt;&lt;code&gt;&lt;span&gt;fetch_add&lt;/span&gt;&lt;/code&gt;&lt;span&gt;这个函数，我们可以确保我们的ticket一定是单调线性递增的，并且每个ticket之间相差为1。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;那么我们来思考下假设现在有许多线程同时在调用TicketLock的&lt;/span&gt;&lt;code&gt;&lt;span&gt;lock&lt;/span&gt;&lt;/code&gt;&lt;span&gt;函数，那么每个线程都会得到一个唯一的ticket，如果像我们的例子中，&lt;/span&gt;&lt;code&gt;&lt;span&gt;AtomicUsize&lt;/span&gt;&lt;/code&gt;&lt;span&gt;是从0开始的，那么接下来的线程会得到的ticket将会是1,2,3,4…这样的顺序排列下去。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;接下来，每个线程都会卡在以下这一行。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;php&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;while self.curr.load(Ordering::Acquire) != ticket {}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;在这里每个线程相当于在等待叫号，如果当前办业务的号码并不是自己手里的号码，那么这个线程将会在这个位置等待，直到叫到自己的号码为止才可以继续执行下去。值得注意的地方是，每个线程在拿号的时候，用的是&lt;/span&gt;&lt;code&gt;&lt;span&gt;self.next&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，而线程在等待的时候用的是&lt;/span&gt;&lt;code&gt;&lt;span&gt;self.curr&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，其实从&lt;span&gt;语义&lt;/span&gt;上来讲，这个是非常好理解的。拿号的时候，我们用的是&lt;/span&gt;&lt;code&gt;&lt;span&gt;next&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，而真正等叫号的是&lt;/span&gt;&lt;code&gt;&lt;span&gt;curr&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;有了上面对语义的理解，接下来的&lt;/span&gt;&lt;code&gt;&lt;span&gt;unlock&lt;/span&gt;&lt;/code&gt;&lt;span&gt;函数便非常好理解了，当上一个线程结束了对共享资源的使用后，就会&lt;/span&gt;&lt;code&gt;&lt;span&gt;unlock&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，也就是准备让窗口的业务员叫下一个号码，因此，我们在&lt;/span&gt;&lt;code&gt;&lt;span&gt;unlock&lt;/span&gt;&lt;/code&gt;&lt;span&gt;函数中将当前的&lt;/span&gt;&lt;code&gt;&lt;span&gt;curr&lt;/span&gt;&lt;/code&gt;&lt;span&gt;增加1，这时候，之前卡在&lt;/span&gt;&lt;code&gt;&lt;span&gt;while&lt;/span&gt;&lt;/code&gt;&lt;span&gt;处，并且号码是上一个线程ticket的值+1的线程便可以跳出循环得到了共享资源的使用权。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们可以看到，TicketLock比起SpinLock在实现上面巧妙的运用了&lt;/span&gt;&lt;code&gt;&lt;span&gt;Token&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。在之前的SpinLock中，&lt;/span&gt;&lt;code&gt;&lt;span&gt;Token&lt;/span&gt;&lt;/code&gt;&lt;span&gt;就是&lt;/span&gt;&lt;code&gt;&lt;span&gt;()&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，并没有好好利用其&lt;span&gt;传递&lt;/span&gt;的特性，我们仔细想想，当一个线程&lt;/span&gt;&lt;code&gt;&lt;span&gt;lock&lt;/span&gt;&lt;/code&gt;&lt;span&gt;成功时，获取了&lt;/span&gt;&lt;code&gt;&lt;span&gt;Token&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，表示其可以独占共享资源，当这个线程&lt;/span&gt;&lt;code&gt;&lt;span&gt;unlock&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的时候，&lt;/span&gt;&lt;code&gt;&lt;span&gt;Token&lt;/span&gt;&lt;/code&gt;&lt;span&gt;会作为一个参数传入到&lt;/span&gt;&lt;code&gt;&lt;span&gt;unlock&lt;/span&gt;&lt;/code&gt;&lt;span&gt;函数中，TicketLock通过一个共享变量&lt;/span&gt;&lt;code&gt;&lt;span&gt;curr&lt;/span&gt;&lt;/code&gt;&lt;span&gt;将上一个线程的信息传递给了下一个线程，这样的实现方式使得线程间具有了&lt;span&gt;公平性&lt;/span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是事情并没有那么美好，无论是SpinLock还是TicketLock，所有的线程都在为同一个内存空间在打架，在SpinLock中，线程们都在争夺一个&lt;/span&gt;&lt;code&gt;&lt;span&gt;AtomicBool&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，在TicketLock中，线程们都在争夺一个&lt;/span&gt;&lt;code&gt;&lt;span&gt;AtomicUsize&lt;/span&gt;&lt;/code&gt;&lt;span&gt;（&lt;/span&gt;&lt;code&gt;&lt;span&gt;self.curr&lt;/span&gt;&lt;/code&gt;&lt;span&gt;）。其实这样的设计从资源利用的角度来看是很不好的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;从OS的角度来看，每一次线程的切换，都会有Context Swtich，这对于系统来说都是一笔不小的开销，并且对多个线程同时访问同一个Atomic的内存地址来说，必须要等前一个线程访问结束了，才可以换下一个线程。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;那么解决这个问题的思路就是我们能不能通过内存来换取系统等待的时间？最理想的情况就是每个线程只需要访问&lt;span&gt;自己独有的一个&lt;/span&gt;内存空间，我们的设计尽量要减少对同一个共享变量访问的线程的数量。这个就是下一个博客会介绍的内容，CLHLock的实现。&lt;/span&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>