<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>a47eb4820ae75c791360cceb624b9c1e</guid>
<title>[推荐] 这 30 个我精选的含答案的面试题，硬不硬你说吧</title>
<link>https://toutiao.io/k/v9aar7o</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你好，我是最近写累了的 yes。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面霸系列第二篇来了，满满当当 31 题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上一篇面霸我看阅读完成率就 34.53%，不知道这篇能有多少，&lt;span&gt;因为这篇比那篇还长&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所以我先把一些话放到开头来说，哈哈，别急就一小段&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样所有的答案都是我的原创，能延伸的我都延伸了，估计有不少错别字，这篇和上篇合成 pdf 的时候我再校对一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果发现有错误或者错别字的请联系我，感激不尽。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 基础面试题就到这篇文章此为止了，接下来要写哪个？&lt;span&gt;文末搞个投票，哪个高先写哪个&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面截图还漏了些， redis 啥的，投票会加上的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7836879432624113&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nGKnoFLBg9zuEFYQErIHibbfYasMt6vaTg7UeULTYJ2SuicscRGPuzlGHGiaCQM9S2ZgmiazS2j4aotFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;282&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后最近搞了个面试交流群，交流面试题，最近找工作的可以加我，拉你入群。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.137299771167048&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nGKnoFLBg9zuEFYQErIHibbfcmXzqGK0yBkONZjZwMEUtGOIsP168sWuXQkB16ictmLZum8S83jneog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;874&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;好了，gogogo&lt;/span&gt;！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;21.Exception 和 Error 的区别知道吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Exception 是程序正常运行过程中可以预料到的意外情况，应该被开发者捕获并且进行相应的处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Error 是指在正常情况下不太可能出现的情况，绝大部分的 Error 都会导致程序处于不正常、不可恢复的状态，也就是挂了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以不便也不需被开发者捕获，因为这个情况下你捕获了也无济于事。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Exception和Error都是继承了Throwable类，在Java代码中只有继承了Throwable类的实例才可以被throw或者被catch。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随便我再提一提异常处理的注意点，之前写过文章总结过：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;尽量不要捕获类似Exception这样通用的异常，而应该捕获特定的异常。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;软件工程是一门协作的艺术，在日常的开发中我们有义务使自己的代码能更直观、清晰的表达出我们想要表达的信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是如果你什么异常都用了Exception，那别的开发同事就不能一眼得知这段代码实际想要捕获的异常，并且这样的代码也会捕获到可能你希望它抛出而不希望捕获的异常。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;不要&quot;吞&quot;了异常&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们捕获了异常，不把异常抛出，或者没有写到日志里，那会出现什么情况？线上除了 bug 莫名其妙的没有任何的信息，你都不知道哪里出错以及出错的原因。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这可能会让一个简单的bug变得难以诊断，而且有些同学比较喜欢用 catch 之后用e.printStackTrace()，在我们产品中通常不推荐用这种方法，一般情况下这样是没有问题的但是这个方法输出的是个标准错误流。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.12934362934362933&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nGKnoFLBg9zuEFYQErIHibbflSe97uibJAtAZic82ia01CuqahFo6zun3mib8dVfwEYFO2aflibOEjpxh3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;518&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如是在分布式系统中，发生异常但是找不到stacktrace。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以最好是输入到日志里，我们产品可以自定义一定的格式，将详细的信息输入到日志系统中，适合清晰高效的排查错误。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;ol start=&quot;3&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;不要延迟处理异常&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如你有个方法，参数是个 name，函数内部调了别的好几个方法，其实你的name传的是 null 值，但是你没有在进入这个方法或者这个方法一开始就处理这个情况，而是在你调了别的好几个方法然后爆出这个空指针。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样的话明明你的出错堆栈信息只需要抛出一点点信息就能定位到这个错误所在的地方，进过了好多方法之后可能就是一坨堆栈信息。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;ol start=&quot;4&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;只在需要try-catch的地方try-catch，try-catch的范围能小则小&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只要必要的代码段使用try-catch，不要不分青红皂白try住一坨代码，因为try-catch中的代码会影响JVM对代码的优化，例如重排序。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;ol start=&quot;5&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;不要通过异常来控制程序流程&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一些可以用if/else的条件语句来判断例如null值等，就不要用异常，异常肯定是比一些条件语句低效的，有 CPU 分支预测的优化等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且每实例化一个Exception都会对栈进行快照，相对而言这是一个比较重的操作，如果数量过多开销就不能被忽略了。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;ol start=&quot;6&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;不要在finally代码块中处理返回值或者直接return&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在finally中return或者处理返回值会让发生很诡异的事情，比如覆盖了 try 中的return，或者屏蔽的异常。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;22.深拷贝和浅拷贝?&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;深拷贝：完全拷贝一个对象，包括基本类型和引用类型，堆内的引用对象也会复制一份。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;浅拷贝：仅拷贝基本类型和引用，堆内的引用对象和被拷贝的对象共享。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以假如拷贝的对象成员间有一个 list，深拷贝之后堆内有 2 个 list，之间不会影响，而浅拷贝的话堆内还是只有一个 list。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如现在有个 teacher 对象，然后成员里面有一个 student 列表。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.657258064516129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nGKnoFLBg9zuEFYQErIHibbfBTGDDoABn3VcdmylZ3LL7JPWuRQiaXPLPZq7ibBZkLlEtsibrMCXvfx2g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此深拷贝是安全的，浅拷贝的话如果有引用对象则原先和拷贝对象修改引用对象的值会相互影响。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;23.面向对象编程和面向过程编程的区别？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;面向对象编程&lt;/span&gt;(Object Oriented Programming，OOP)是一种编程范式或者说编程风格。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;把类或对象作为基本单元来组织代码&lt;/span&gt;，并且运用提炼出的：封装、继承和多态来作为代码设计指导。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;面向过程编程&lt;/span&gt;是以过程作为基本单元来组织代码的，过程其实就是动作，对应到代码中来就是函数，面向过程中函数和数据是分离的，数据其实就是成员变量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而面向对象编程的类中数据和动作是在一起的，这也是两者的一个显著的区别。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果对这两个概念还是比较模糊的话，可以看我写的这篇文章，4800多字来讲面向对象和面向过程，看完之后肯定懂！&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkxNTE3NjQ3MA==&amp;amp;mid=2247486481&amp;amp;idx=1&amp;amp;sn=c02f75cd8f91b80da04c7706ad806023&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;面向对象和面向过程解析&lt;/a&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;24.重载与重写的区别？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重载：指的是方法名相同，参数类型或者顺序或个数不同，&lt;span&gt;这里要注意和返回值没有关系&lt;/span&gt;，方法的签名是名字和参数列表，不包括返回值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重写：指的是子类重写父类的方法，方法名和参数列表都相同，也就是方法签名是一致的。重写的子类逻辑抛出的异常和父类一样或者是其父类异常的子类，并且方法的访问权限不得低于父类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单的理解为儿子不要超过爸爸，要尊老爱幼。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;25.什么是内部类，有什么用？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内部类顾名思义就是定义在一个类的内部的类，按位置分：在成员变量的位置定义，则是成员内部类，在方法内定义，则是局部内部类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果用 static 修饰则为静态内部类，还有匿名内部类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般而言只会用成员内部类、静态内部类和匿名内部类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;成员内部类可以使用外部类的所有成员变量以及方法，包括 private 的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;静态内部类只能使用外部类的静态成员变量以及方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;匿名类常用来作为回调，使用的时候再实现具体逻辑来执行回调。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上内部类是一个编译层面的概念，像一个语法糖一样，经过编译器之后其实内部类会提升为外部顶级类，和外部类没有任何区别，所以&lt;span&gt;在 JVM 中是没有内部类的概念的&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般情况下非静态内部类用在内部类和其他类无任何关联，专属于这个外部类使用，并且也便于调用外部类的成员变量和方法，比较方便。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;静态外部类其实就等于一个顶级类，可以独立于外部类使用，所以更多的只是表明类结构和命名空间。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;26.说说 Java 的集合类吧？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种问题一般大致提一下，然后等着面试官深挖。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常用的集合有 List、Set、Map、Queue 等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;List 常见实现类有 ArrayList 和 LinkedList。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;ArrayList 基于动态数组实现，支持下标随机访问，对删除不友好。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;LinkedList 基于双向链表实现，不支持随机访问，只能顺序遍历，但是支持O(1)插入和删除元素。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Set 常见实现类有：HashSet、TreeSet、LinkedHashSet。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;HashSet 其实就是 HashMap 包了层马甲，支持 O(1)查询，无序。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;TreeSet 基于红黑树实现，支持范围查询，不过基于红黑树的查找时间复杂度是O(lgn)，有序。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;LinkedHashSet，比 HashSet 多了个双向链表，通过链表保证有序。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Map 常见实现类有：HashMap、TreeMap、LinkedHashMap&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;HashMap：基于哈希表实现，支持 O(1) 查询，无序。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;TreeMap：基于红黑树实现，O(lgn)查询，有序。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;LinkedHashMap：同样也是多了双向链表，支持有序，可以很好的支持 lru 的实现。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置有序，并且重写LinkedHashMap中的 removeEldestEntry 方法，即可实现 lru。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里有一点要提一下，如果你对某个东西比较熟悉就要在合适的地方抛出来。比如通过 LinkedHashMap 你还能延伸到 lru ，这表明你对 LinkedHashMap 有研究并且也知晓 lru，面试官自己可能都不清楚，会觉得你有点东西。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;而且面试官基本会追问  lru 然后接着延伸，比如延伸到改进的 lru ，mysql 缓存中的 lru 等等，这就是通过你的引导把问题领域迁移到你自身熟悉的地方，这岂不美哉？如果你不熟悉，那少 bb。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Queue 常见的实现类有：LinkedList、PriorityQueue。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PriorityQueue：优先队列，是基于堆实现的，底层其实就是数组。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基本上回答不了这么全，稍微讲几个可能就被打断，然后深挖了，届时只能见招拆招。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;27.说说 ThreadLocal ？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocal 本质是通过本地化资源来避免共享，也就是每个线程都有自己的本地私有化变量，这样每个线程访问自己属性即可，避免了多线程竞争导致的锁等消耗。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体关系如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5500848896434635&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nGKnoFLBg9zuEFYQErIHibbf45QKRvZZ8qnDjpCCAqosu2cMJBeqTuNicPEFh7lyayuPPRXhIFhSP3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1178&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocalMap 是采用线性探测的方式来解决 hash 冲突，所以要注意 ThreadLocal 的数量，因为这种冲突解决方式比较低效。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocal 在 Entry 中作为 key 是弱引用，所以当外部对 ThreadLocal 的强引用消失之后，只剩下弱引用的 ThreadLocal 会被 GC 清除，这时候 Entry 中的 value 还在，但是已经访问不到了，所以称之为内存泄漏。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过当调用 get 和 set 方法时，如果直接 hash 没中，开始线性探测，那么碰到 key 为 null 的节点才会清理掉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然更好的方式是显示的在用完之后调用 remove，这样就能及时清理。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;既然弱引用会导致内存泄漏，那为什么还要弱引用？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先如果 key 不用弱引用，那么当外部对 ThreadLocal 的强引用消失之后，由于 ThreadLocalMap 是这个线程的成员之一，所以这个线程还在，那么 ThreadLocalMap 就在，而 ThreadLocalMap 在，那么 Entry 肯定在，而 Entry 在那么强引用的 key 和 value 就肯定在。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以如果 key 不用弱引用，那么 key 都无法被 GC 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以 key 用弱引用那么至少 key 这点内存是可以被省掉的，并且线性探测还能清一些 Entry。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实发生内存泄漏的根本不在于 key 是弱引用，因为他们都属于一个线程的属性，所以线程活着它们就不能被 GC，这一条引用链是无法更改的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后现在都是用线程池，所以线程有可能长时间存活，因此就会逐渐堆积，导致内存满了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以这点需要明确。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;与之相关的还有个 InheritableThreadLocal&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这玩意可以理解为就是可以把父线程的 threadlocal 传递给子线程，所以如果要这样传递就用 InheritableThreadLocal ，不要用 threadlocal。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原理其实很简单，在 Thread 中已经包含了这个成员：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.35067114093959734&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nGKnoFLBg9zuEFYQErIHibbfLuSCBs6Oyz5jiaruec6Y2l6DWfY4UuNDeF2FjcYREQ376PnDAwTKMsA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1192&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在父线程创建子线程的时候，子线程的构造函数可以得到父线程，然后判断下父线程的 InheritableThreadLocal 是否有值，如果有的话就拷过来。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7935483870967742&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nGKnoFLBg9zuEFYQErIHibbfbwfRjV1Oteox7SC2ul1gFc72hCMAKrJvibpv2a06VKYRriaqOiaqDRQnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里要注意，&lt;span&gt;只会在线程创建的时会拷贝 InheritableThreadLocal 的值&lt;/span&gt;，之后父线程如何更改，子线程都不会首其影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此有关 ThreadLocal 的知识点就差不多了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;28.同步、异步、阻塞、非阻塞 IO 的区别？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的程序和硬件之间隔了个操作系统，而为了安全考虑，Linux 系统分了：用户态和内核态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个前提下，我们再明确程序要从磁盘（网卡）读数据的两个步骤：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;数据从存储设备拷贝到内核缓存&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据再从内核缓存拷贝到用户空间&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7464454976303317&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nGKnoFLBg9zuEFYQErIHibbfXYl0J8GlOVSrbSFT5NTZUVceDq2KeA8Haicm1z4Azy7GicgzSHW5BoXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;844&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，现在咱们可以看看这几个概念了。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;同步I/O：指的是线程需要等待 2 执行完毕。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;异步I/O：指的是线程不需要等待 2 执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;阻塞I/O：指的是步骤 1 会阻塞，即线程需要阻塞等待 1 执行完毕。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;非阻塞I/O：指的是步骤 1 不会被阻塞，不需要阻塞等待。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以平时还会有同步阻塞I/O，或者啥同步非阻塞I/O，就是步骤 1 和 2 的组合罢了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再来理解一下，毕竟咱们这面霸系列不是背诵，是理解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同步和异步指的是：是否需要等待方法的调用执行完毕。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两个概念主要注重的是调用方式，同步和异步调用编码方式是不同的，同步其实就是一条道写下来，异步则是需要回调、事件等方式来实现后面的逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阻塞和非阻塞：&lt;span&gt;一般用在底层系统调用身上，阻塞指的是线程未满足条件会被阻塞，进入 sleep 状态&lt;/span&gt;，即时间片还未到就让出 CPU，非阻塞则是计算未满足条件也直接返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以阻塞是真的被阻塞住了，是在等待数据，是需要让出时间片的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而同步的线程其实还是有时间片的，所以同步一般有个超时时间，计算超时之后就会返回继续执行后面的代码。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;29.BIO、NIO、AIO？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;BIO 指的是同步阻塞I/O，相信看了 28 题之后对这个同步阻塞很清晰了，就是等着。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这种模型下只能是来一个连接用一个线程，连接多并发大的话服务器顶不住这么多线程的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;NIO 指的是同步非阻塞I/O，我们熟知的 IO 多路复用就是NIO，适合用在连接多、每次传输较为短的场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AIO 指的是异步I/O，调用了之后就不管了，数据来了自动会执行回调方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;异步可以有效的减少线程的等待，减少了用户线程拷贝数据的那段等待，效率更高。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;30.JDK8 有哪些新特性？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK8 较为重要和平日里经常被问的特性如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;用元空间替代了永久代。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;引入了 Lambda 表达式。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;引入了日期类、接口默认方法、静态方法。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;新增 Stream 流式接口&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后相信你们对 HashMap 和 ConcurrentHashMap 有一定的准备，所以抛出来&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;修改了 HashMap 和 ConcurrentHashMap 的实现（等着八股文之问）&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;新增了 CompletableFuture 、StampedLock 等并发实现类。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像一些中间件异步化代码都用了 CompletableFuture 来实现，所以还是得做一些了解的，如果不熟悉这条就不用提了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;31.你都用过哪些 Java 并发工具类？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Semaphore、CyclicBarrier、CountDownLatch 三连。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然 JUC 下面还有挺多，反正列几个说说就行，面试的时候切忌不要一股脑儿的把知道的都扔出来，这叫&lt;span&gt;留白&lt;/span&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Semaphore&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这玩意叫信号量，广泛应用于各种操作系统中，相对于平日只允许一个线程访问临界区的 lock 和 synchronized 来说，&lt;span&gt;信号量允许多线程同时访问一个临界区&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原理就简单的理解为初始化一个数，如果来了一个线程则把数减一，如果减一之后数的值小于 0 则阻塞当前线程，移入一个阻塞队列中，否则允许执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一个线程执行完毕之后将数加一，并唤醒阻塞队列中的一个等待线程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际是内部有个继承自 AQS 的 Sync 类，通过依托 AQS 的封装来实现功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要用于流量的控制，比如停车场只允许停一定数量的车位。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单示例如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; int count;&lt;br/&gt;    final Semaphore semaphore   = new Semaphore(1); // 初始化信号量&lt;br/&gt;    // 用信号量保证互斥    &lt;br/&gt;    void &lt;span&gt;&lt;span&gt;addOne&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;      try {&lt;br/&gt;          semaphore.acquire();   //对应down，计数减一&lt;br/&gt;          count+=1;&lt;br/&gt;        } catch (InterruptedException e) {&lt;br/&gt;          e.printStackTrace();&lt;br/&gt;        } finally {&lt;br/&gt;          semaphore.release();  //对应up，计数加一&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;CyclicBarrier&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从名字分析，这是一个可循环的屏障。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;屏障的意思是：让一组线程都运行到同一个屏障点之后，线程会阻塞等待所有线程都达到这个屏障点，然后所有线程才得以继续执行。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6379032258064516&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nGKnoFLBg9zuEFYQErIHibbfianAUOwsMy4Xt0p1N6FCiaBeyqJuZGutm2a5IHjiaJWaTfeP3QnMnJozw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来看一下用法：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6935483870967742&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nGKnoFLBg9zuEFYQErIHibbfL6iarQUJXpmZWZYqyoUnVLNSdHFjqgSJSSSxnfNqQ0IrXib9ASIiajx8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结果如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;2.9215686274509802&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nGKnoFLBg9zuEFYQErIHibbfprK7JKuPUoq3MW2WmbRTia5xU1Wkkt4aUpjyFMRmsO2ZcrPliaFGAtoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;306&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它实际上是基于 ReentrantLock 和 Condition 的封装来实现这一功能的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;原理我先口述一下，因为面试官很有可能会问原理&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先设置了达到屏障的线程数量，当线程调用 await 的时候计数器会减一，如果计数器减一不等于 0 的时候，线程会调用 condition.await 进行阻塞等待。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果计数器减一的值等于0，说明最后一个线程也到达了屏障，于是如果有 barrierCommand 就执行 barrierCommand ，然后调用 condition.signalAll 唤醒之前等待的线程，并且重置计数器，然后开启下一代。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源码我就不贴了，建议自己看下，不难的，算上一大推注释都不到 500 行，核心方法就 60 几行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至于循环的话，来看一下这个代码就理解了：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3934010152284264&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nGKnoFLBg9zuEFYQErIHibbfky5fW4XjV3ofjZD5rZS1zPhcM1XzibQPicGvp5eM08K9sP1lSGtfxyPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;788&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当规定数量的线程到达屏障之后会把计数重置回去，并且开启了下一代，所以 CyclicBarrier 是可以循环使用的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;CountDownLatch&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个锁其实和 CyclicBarrier 有点类似，都是等待一个节点的到达，但是还是不太一样的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CyclicBarrier 是各个线程等待阻塞所有线程都达到一个节点之后，所有线程继续执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CountDownLatch 是一个线程阻塞着等待其他线程到达一个节点之后才能继续执行，&lt;span&gt;这个过程中其他线程是不会阻塞的&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.760483870967742&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nGKnoFLBg9zuEFYQErIHibbfZ5bpeSlBVIZiaTNsRa3uksdu7w2RlbZ1vHKnceMgWnUqFiaFDWTORqHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结果如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.27936507936507937&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nGKnoFLBg9zuEFYQErIHibbfCpd1nTzONWMJfmxup4bL4fk3tSDCccl0PzCUdGicY4wFEsCXBTW0B0A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;630&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现原理：内部又一个继承自 AQS 的 Sync 类，核心其实就是围绕一个整数 state。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初始化 state 的值，当调用一次 countDown 会把 state 的值减一，当 state 的值减到 0 的时候就会唤醒之前调用 await 等待的线程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要是依靠 AQS 封装的好，所以代码很少，原理也很清晰简单。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;StampedLock&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然30题提到了这个，之前也专门写过文章分析，那刚好拿来讲讲。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以认为是读写锁的“改进”版本。读写锁读写是互斥的，而 StampedLock 搞了个悲观读和乐观读，悲观读和写是互斥的，乐观读则不会。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;搞个官方示例看下就很清晰了:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; class Point {&lt;br/&gt;   private double x, y;&lt;br/&gt;   private final StampedLock sl = new StampedLock();&lt;br/&gt;&lt;br/&gt;   void move(double deltaX, double deltaY) { // an exclusively locked method&lt;br/&gt;     long stamp = sl.writeLock();  //获取写锁&lt;br/&gt;     try {&lt;br/&gt;       x += deltaX;&lt;br/&gt;       y += deltaY;&lt;br/&gt;     } finally {&lt;br/&gt;       sl.unlockWrite(stamp); //释放写锁&lt;br/&gt;     }&lt;br/&gt;   }&lt;br/&gt;&lt;br/&gt;   double &lt;span&gt;&lt;span&gt;distanceFromOrigin&lt;/span&gt;&lt;/span&gt;() { // A &lt;span&gt;read&lt;/span&gt;-only method&lt;br/&gt;     long stamp = sl.tryOptimisticRead(); //乐观读&lt;br/&gt;     double currentX = x, currentY = y;&lt;br/&gt;     &lt;span&gt;if&lt;/span&gt; (!sl.validate(stamp)) { //判断共享变量是否已经被其他线程写过&lt;br/&gt;        stamp = sl.readLock();  //如果被写过则升级为悲观读锁&lt;br/&gt;        try {&lt;br/&gt;          currentX = x;&lt;br/&gt;          currentY = y;&lt;br/&gt;        } finally {&lt;br/&gt;           sl.unlockRead(stamp); //释放悲观读锁&lt;br/&gt;        }&lt;br/&gt;     }&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; Math.sqrt(currentX * currentX + currentY * currentY);&lt;br/&gt;   }&lt;br/&gt;&lt;br/&gt;   void moveIfAtOrigin(double newX, double newY) { // upgrade&lt;br/&gt;     // Could instead start with optimistic, not &lt;span&gt;read&lt;/span&gt; mode&lt;br/&gt;     long stamp = sl.readLock(); //获取读锁&lt;br/&gt;     try {&lt;br/&gt;       &lt;span&gt;while&lt;/span&gt; (x == 0.0 &amp;amp;&amp;amp; y == 0.0) {&lt;br/&gt;         long ws = sl.tryConvertToWriteLock(stamp);  //升级为写锁&lt;br/&gt;         &lt;span&gt;if&lt;/span&gt; (ws != 0L) {&lt;br/&gt;           stamp = ws;&lt;br/&gt;           x = newX;&lt;br/&gt;           y = newY;&lt;br/&gt;           &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;         }&lt;br/&gt;         &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;           sl.unlockRead(stamp);&lt;br/&gt;           stamp = sl.writeLock();&lt;br/&gt;         }&lt;br/&gt;       }&lt;br/&gt;     } finally {&lt;br/&gt;       sl.unlock(stamp);&lt;br/&gt;     }&lt;br/&gt;   }&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;乐观锁就是获取判断一下，如果被修改了那么就升级为悲观锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是 Semaphore 是不可重入锁，而且也不支持 condition 。并且如果线程使用writeLock() 或者readLock() 获得锁之后，线程还没执行完就被 interrupt() 的话，会导致CPU飙升，需要用 &lt;code&gt;readLockInterruptibly 或者 writeLockInterruptibly&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;32.Java 中的阻塞队列用过哪些?&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阻塞队列主要用来阻塞队列的插入和获取操作，当队列满了的时候阻塞队列的插入操作，直到队列有空位。当队列为空的时候阻塞队列的获取操作，直到队列有值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常用在实现生产者和消费者场景，在笔试题中比较常见。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的有 ArrayBlockingQueue 和 LinkedBlockingQueue，分别是基于数组和链表的有界阻塞队列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两者原理都是基于 ReentrantLock 和 Condition 。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;都是有界阻塞队列两者有什么区别？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ArrayBlockingQueue 基于数组，内部实现只用了一把锁，可以指定公平或者非公平锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;LinkedBlockingQueue 基于链表，内部实现用了两把锁，take 一把、put 一把，所以入队和出队这两个操作是可以并行的，从这里看并发度应该比 ArrayBlockingQueue 高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有 PriorityBlockingQueue  和 DelayQueue，分别是支持优先级的无界阻塞队列和支持延时获取的无界阻塞队列，如果你看过 DelayQueue 实现就会发现内部用的是 PriorityQueue。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2171875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nGKnoFLBg9zuEFYQErIHibbfEQicwrGK1RnElIVQpyNDSAaruytwhSrYrHCmMXOlOUoKxvrBaLo7XGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有 SynchronousQueue、 LinkedBlockingDeque 和 LinkedTransferQueue。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SynchronousQueue 前面线程池分析有提到过，它是不占空间的，入队比如等待一个出队，也就是生产者必须等待消费者拿货，无法把先把货存在队列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;LinkedBlockingDeque 是双端阻塞无界队列，就是队列的头尾都能操作，头尾都能插入和移除。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;LinkedTransferQueue，相对于其他阻塞队列从名字来看它有 Transfer 功能，其实也不是什么神奇功能，一般阻塞队列都是将元素入队，然后消费者从队列中获取元素。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而 LinkedTransferQueue 的 transfer 是元素入队的时候看看是否已经有消费者在等了，如果有在等了直接给消费者即可，所以就是这里少了一层，没有锁操作。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;33.用过Java 中哪些原子类？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原子类是 JUC 封装的通过无锁的方式实现的一系列线程安全的原子操作类。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.2439862542955327&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nGKnoFLBg9zuEFYQErIHibbfX8xvIPNZBNWacMGEvriaTUsRchdLI39Jmyb4GUM5NFUDGj0RGzibCURA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;291&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面截图的原子类主要分为五大类，我画个脑图汇总一下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.41286307053941906&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nGKnoFLBg9zuEFYQErIHibbfkkG5t0sNhKVXTTSibLPkFGLISIMjHRpxVfmiaBn5kwfxtoHsP8jIRWtw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;964&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原子类的核心原理就是基于 CAS（Compare And Swap）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CAS 简单的理解为：给予一个共享变量的内存地址，然后内存中应该的值(预期值)和新值，然后通过&lt;span&gt;一条 CPU 指令&lt;/span&gt;来比较此内存地址上的值是否等于预期值，如果是则替换内存地址上的值为新值，如果不是则不予替换且换回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说硬件层面支持一条指令来实现这么几个操作，一条指令是不会被打断的，所以保证了原子性。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;基本类型&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以简单的理解为通过基本类型原子类 AtomicBoolean、AtomicInteger 和 AtomicLong 就可线程安全地、原子地更新这几个基本类型。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数组类型&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AtomicIntegerArray、AtomicLongArray 和 AtomicReferenceArray，简单的理解为可以原子化地更新数组内的每个元素，几个的差别无非就是数组里面存储的数据是什么类型。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;引用类型&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AtomicReference、AtomicStampedReference 和 AtomicMarkableReference，就是对象引用的原子化更新。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;差别在于 AtomicStampedReference 和 AtomicMarkableReference 可以避免 CAS 的 ABA 问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AtomicStampedReference  是通过版本号 stamp 来避免， AtomicMarkableReference  是通过一个布尔值 mark 来避免。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;ABA 问题&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为 CAS 是将期望值和当时内存地址上的值进行对比，假设期望值是 1 ，地址上的值现在是 1，只不过中间被人改成了 2 ，然后又改回了1，所以此时你 CAS 操作去对比是可以替换的，你无法得知中间值是否改过，这种情况就叫 ABA 问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而解决 ABA 问题的做法就是用版本号，每次修改版本就+1，这样即使值是一样的但是版本不同，就能得知之前被改过了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;属性更新类型&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AtomicIntegerFieldUpdater、AtomicLongFieldUpdater 和 AtomicReferenceFieldUpdater，是通过反射，原子化的更新对象的属性，不过要求属性必须用 volatile 修饰来保证可见性，看下源码，很直观。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2072678331090175&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nGKnoFLBg9zuEFYQErIHibbfJco4XJ84t0Zpms1chweEcVZ2tOSdkw0asYLzM1K62HiaARAwSVMAZgA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;743&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;累加器&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述的都是更新数据，而 DoubleAccumulator、DoubleAdder、LongAccumulator 和 LongAdder 主要用来累加数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先 AtomicLong  也能累加，而 LongAdder 是专业累加，也只能累加，并发度更高，它通过分多个 cells 来减少线程的竞争，提高了并发度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以理解为如果拿 AtomicLong  是实现累加就是一本本子，然后 20 个人要让本子上累加计数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而 LongAdder 分了 10 个本子，20个人可以分别拿这 10 个本子来计数(减少了竞争，提高了并发度)，然后最后的结果再由 10个本子上的数相加即可。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;xxxAccumulator 和 xxxAdder 两者的区别?&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;xxxAccumulator 的功能比 xxxAdder 丰富，可以自定义累加方法，也可以设置初始值，按照注释上的解释 xxxAdder  等价于 new xxxAccumulator((x, y) -&amp;gt; x + y, 0L}。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以可以说 xxxAdder 是 xxxAccumulator 的一个特例。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;34.Synchronized 和 ReentrantLock 区别？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Synchronized 和 ReentrantLock 都是可重入锁，ReentrantLock 需要手动解锁，而 Synchronized 不需要。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ReentrantLock 支持设置超时时间，可以避免死锁，比较灵活，并且支持公平锁，可中断，支持条件判断。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Synchronized 不支持超时，非公平，不可中断，不支持条件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总的而言，一般情况下用 Synchronized 足矣，比较简单，而 ReentrantLock 比较灵活，支持的功能比较多，所以复杂的情况用 ReentrantLock 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至于说 Synchronized 性能不如 ReentrantLock 的，那都是 N 多年前的事儿了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;35.Synchronized 原理知道不？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Synchronized 的原理其实就是基于一个锁对象和锁对象相关联的一个 monitor 对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在偏向锁和轻量级锁的时候只需要利用 CAS 来操控锁对象头即可完成加解锁动作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在升级为重量级锁之后还需要利用 monitor 对象，利用 CAS 和 mutex 来作为底层实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;monitor 对象颞部会有等待队列和条件等待队列，未竞争到锁的线程存储到等待队列中，获得锁的线程调用 wait 后便存放在条件等待队列中，解锁和 notify 都会唤醒相应队列中的等待线程来争抢锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后由于阻塞和唤醒依赖于底层的操作系统实现，系统调用存在用户态与内核态之间的切换，所以有较高的开销，&lt;span&gt;因此称之为重量级锁&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以才会有偏向锁和轻量级锁的优化，并且引入自适应自旋机制，来提高锁的性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于 Synchronized 其实我写过两篇文章，看完这两篇文章你可以跟 Synchronized 说，你看过 JVM 源码，毫不夸张，因为就是从源码级别上分析的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且指明了一个几乎网上都错了的观点和一个常见的认知错误。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总而言之，看完之后对 Synchronized 基本上超越很多人了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkxNTE3NjQ3MA==&amp;amp;mid=2247488192&amp;amp;idx=1&amp;amp;sn=85fa12be29fef85d41c571b2c853de5d&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Synchronized 深入JVM分析&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkxNTE3NjQ3MA==&amp;amp;mid=2247488213&amp;amp;idx=1&amp;amp;sn=3608335c066a0d94d7f49cacf98e358e&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Synchronized 升级到重量级锁之后就下不来了？你错了！&lt;/a&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;36.ReentrantLock 的原理？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ReentrantLock 其实就是基于 AQS 实现的一个可重入锁，支持公平和非公平两种方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内部实现其实就是依靠一个 state 变量和两个等待队列：同步队列和等待队列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;利用 CAS 修改 state 来争抢锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;争抢不到则入同步队列等待，同步队列是一个双向链表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;条件 condition 不满足时候则入等待队列等待，也是个双向链表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是否是公平锁的区别在于：线程获取锁时是加入到同步队列尾部还是直接利用 CAS 争抢锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就是这么回事儿，理解起来应该不难，操心的我再画个图，嘿嘿。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8537234042553191&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nGKnoFLBg9zuEFYQErIHibbfsc5HOgo5mxzBGciaMXv6MqgouxRjwJeBMyydGKRZxYIaicdicudS8bXFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;752&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;37.说说 AQS 吧？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AQS 的原理其实就是上面提到的，这里就不再赘述了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果面试官问你为什么需要 AQS ，就这样回答。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;AQS 将一些操作封装起来，比如入队等基本方法，暴露出方法&lt;/span&gt;，便于其他相关 JUC 锁的使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如 CountDownLatch、Semaphore 等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就是起到了一个抽象，封装的作用。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;38.读写锁知道不?&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读写锁在 Java 中一般默认指的是 ReentrantReadWriteLock。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读写锁是有两把锁，分别是读锁和写锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了读读操作不互斥之外，其他都互斥。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以读很多写比较少的情况，用读写锁比较合适。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一点要注意，如果不是这种情况不要用读写锁，&lt;span&gt;因为读写锁需要额外维护读锁的状态，所以如果读读操作不多还不如一般的锁&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读写锁也是基于 AQS 实现的，再具体点的实现就是将 state分为了两部分，高16bit用于标识读状态、低16bit标识写状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就这样灵巧的通过一个 state 实现了两把锁，嘿嘿。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;39.CAS 知道不？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CAS 就是 compare and swap，即比较并交换。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子，我们经常有累加需求，比较一个值是否等于 1，如果等于 1 我们将它替换成 2，如果等于 2 替换成 3。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种比较在多线程的情况下就不安全，比如此时同时有两个线程执行到比较值是否等于 1，然后两个线程发现都等于 1。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后两个线程都将它变成了 2，这样明明加了两次，值却等于 2。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6460807600950119&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nGKnoFLBg9zuEFYQErIHibbf3MontLm8MQB0Q9AbhfriaQyy9A4t8K7GpMcPTRuiaB4BsQ5oJMCiaMdLQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;421&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种情况其实加锁可以解决，但是加锁是比较消耗资源的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此硬件层面就给予支持，将这个比较和交换的动作封装成一个指令，这样就保证了原子性，不会判断值确实等于 1，但是替换的时候值以及不等于 1了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这指令就是 CAS。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CAS 需要三个操作数，分别是旧的预期值(图中的1)，变量内存地址(图中a的内存地址)，新值(图中的2)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;指令是根据变量地址拿到值，比较是否和预期值相等，如果是的话则替换成新值，如果不是则不替换&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实 33 题已经提过这个了，包括 ABA 问题，之所以再写一下是可以从我提供的思路跟面试官说。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不要一上来就三个操作数&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你把遇到的场景(上面说的累加)，然后多线程不安全，然后用锁不好，然后硬件提供了这个指令。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按这样的思路说出来，如果我是面试官，我一听就会觉得，小伙子可以。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;40.说说线程的生命周期？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以分为初始状态、可运行状态、终止状态和休眠状态四大类。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.584192439862543&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nGKnoFLBg9zuEFYQErIHibbfJd18CE21LJIfo1icW5KSphwpPTQZjrjHWX7woh2uttghribX2E7Ll9Mg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;582&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程新建的时候就是初始状态，还未start。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可运行状态就是可以运行，可能正在运行，也可能正在等 CPU 时间片。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;休眠状态分为三种，一种是等待锁的 blocked 状态，一种是等待条件的 waitting 状态，或者有时间限制的等待 timed_waitting 状态。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;等待条件的操作有：Object.wait、Thread.join、LockSupport.park()&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;时间等待就是上面设置了timeout参数的方法，例如Object.wait(1000)。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;终止状态就是线程结束执行了，可以是结束任务后的自动结束，也可以是产生了异常而结束。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;41.什么是 JMM ？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JMM 即 Java Memory Model，Java 内存模型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JMM 其实是一组规则，规定了一个线程的写操作何时会对另一个线程可见(JSR133)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;抽象的&lt;/span&gt;来看 JMM 会把内存分为本地内存和主存，每个线程都有自己的私有化的本地内存，然后还有个存储共享数据的主存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由 JMM 来定义这两个内存之间的交互规则。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里要注意本地内存只是一种抽象的说法，实际指代：寄存器、CPU 缓存等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总之 JMM 屏蔽了各大底层硬件的细节，是抽象出来的一套虚拟机层面的内存规范。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;42.说说原子性、可见性、有序性？&lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原子性&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;指的是一个操作不会被中断，要么这个操作执行完毕，要么不会执行，不会有执行一半的存在。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;可见性&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;指的是一个线程对某个共享变量进行了修改，则其他线程能立刻获取到最新值。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;有序性&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;指的是编译器或者处理器会将指令进行重排，这种操作会影响多线程的执行顺序导致错误。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;43.说说 Java 常见的垃圾收集器？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这题我不太想写答案，内容比较死板，建议还是看《深入理解JVM虚拟机》吧，不过那本书里面没有详细说 ZGC。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而 ZGC 我倒是写了一篇，可以看看呐。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkxNTE3NjQ3MA==&amp;amp;mid=2247486132&amp;amp;idx=1&amp;amp;sn=0974847d831d9870c0d1a7b55d13985e&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;美团面试官问我：ZGC 的 Z 是什么意思？&lt;/a&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;44.垃圾回收，如何判断对象是否是垃圾？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一共有两种方式，分别是引用计数和可达性分析。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引用计数有循环依赖的问题，但是是可以解决的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可达性分析则是从根引用（GCRoots） 开始进行引用链遍历扫描，如果可达则对象存活，如果不可达则对象已成为垃圾。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所谓的根引用包括全局变量、栈上引用、寄存器上的等。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6498855835240275&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nGKnoFLBg9zuEFYQErIHibbfEflByibT0nYcN2RywVgiaZ5l9viaOiawfOg1WFPeUSGnmArqmLiaJJlCbyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;437&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我之前也写过，详细的看这篇文章吧，看完之后这一块针对面试绝对没问题，而且已经超越了很多面试官。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkxNTE3NjQ3MA==&amp;amp;mid=2247485910&amp;amp;idx=1&amp;amp;sn=54ebca3a2dfe449e7f922f347aa4d2dc&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;深度揭秘垃圾回收底层，这次让你彻底弄懂它&lt;/a&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;45.你知道有哪些垃圾回收算法？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的就是：复制、标记-清除、标记整理。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;标记-清除&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标记-清除算法应该是最符合我们人一开始处理垃圾的思路的算法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如我们想清除房间的垃圾，我们肯定是先定位(对应标记)哪些是垃圾，然后把这些垃圾之后扔了(对应清除)，简单粗暴，剩下的不是垃圾的东西我也懒得理，不管了哈哈哈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，这算法有个缺点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;空间碎片问题，这样会使得比较大的对象要申请比较多的连续空间的时候申请不到，明明你空间还很足的。然后导致又一次GC。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;复制算法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;复制算法一般用于新生代，粗暴的复制算法就是把空间一分为二，然后将一边存活的对象复制到另一边，这样没有空间碎片问题，但是内存利用率太低了，只有 50%，所以 HotSpot 中是把一块空间分为 3 块，一块Eden,两块Survivor。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为正常情况下新生代的大部分对象都是短命鬼，所以能活下来的不多，所以默认的空间划分比例是 8:1:1。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用法就是每次只使用Eden和一块Survivor,然后把活下来的对象都扔到另一块Survivor。再清理Eden和之前的那块Survivor。然后再把Eden和存放存活对象的那一块Survivor用来迎接新的对象。就等于每次回收了之后都会对调一下两个Survivor。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;标记-整理算法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标记-整理算法的思路也是和标记-清除算法一样，先标记那些需要清除的对象，但是后续步骤不一样，它是整理，对就是像上面说的那些清除房间垃圾每次都会整理的人一样那么勤劳。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每次会移动所有存活的对象，且按照内存地址次序依次排列，也就是把活着的对象都像一端移动，然后将末端内存地址以后的内存全部回收。所以用了它也就没有空间碎片的问题了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来吧，之前写的，看完之后差不多了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkxNTE3NjQ3MA==&amp;amp;mid=2247486059&amp;amp;idx=1&amp;amp;sn=c6c19c356fa7d4a96fe9e6c98946973e&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;炸了！一口气问了我18个JVM问题！&lt;/a&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;46.String，Stringbuffer，StringBuilder的区别？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;String 是 Java 中基础且重要的类，并且 String 也是 Immutable 类的典型实现，被声明为 final class，除了 hash 这个属性其它属性都声明为 final。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为它的不可变性，所以例如拼接字符串时候会产生很多无用的中间对象，如果&lt;span&gt;频繁的进行这样的操作&lt;/span&gt;对性能有所影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;StringBuffer 就是为了解决大量拼接字符串时产生很多中间对象问题而提供的一个类&lt;/span&gt;，提供 append 和 add 方法，可以将字符串添加到已有序列的末尾或指定位置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的本质是一个线程安全的可修改的字符序列，把所有修改数据的方法都加上了 synchronized。但是保证了线程安全是需要性能的代价的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在很多情况下我们的字符串拼接操作不需要线程安全，这时候&lt;span&gt;StringBuilder&lt;/span&gt;登场了，StringBuilder是JDK1.5发布的，它和StringBuffer 本质上没什么区别，就是&lt;span&gt;去掉了保证线程安全的那部分，减少了开销&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;StringBuffer 和 StringBuilder 二者都继承了 AbstractStringBuilder ，底层都是利用可修改的 char 数组(JDK 9 以后是 byte 数组)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以如果我们有大量的字符串拼接，如果能预知大小的话最好在new StringBuffer 或者StringBuilder 的时候设置好 capacity，避免多次扩容的开销。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;扩容要抛弃原有数组，还要进行数组拷贝创建新的数组。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;47.happens-before 听过吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题估计应该都是来自《深入理解Java虚拟机》这本书的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;happens-before 就是定义的一些规则，在一些特定场景下，一些操作会先行发生于另一些操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;A先行发生于B，其实含义就是 A 操作得到的结果在 B 操作开始时可以得到，重点不在于 A 执行的时间比 B 早，而是 A 的结果是可以在 B 开始时候被 B 读取的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是 JVM 规定的有序性，你也可以认为写 JVM 的程序员需要按照这样的规则来实现 JVM。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如操作符合以下的规则就会按照下面的定义动作先行发生。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后顺序。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;传递性规则：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对象终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;48.什么是锁的自适应自旋？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里指的就是 Syncronized 在身为重量级锁时候的自旋。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体指的是在重量级锁时，一个线程如果竞争锁失败会进行自旋操作，说白了就是执行一些无意义的执行，空转 CPU 等着锁的释放。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为一些情况下可能线程刚被阻塞，锁就被释放了，这样开销就比较大，所以自旋在一定程度上是有优化的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;形象一点就像怠速停车和熄火的区别，如果等待时候很长(长时候都拿不到锁)，那肯定熄火划算(阻塞)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一会儿就要出发(拿到锁)，那怠速停车(自旋)比较划算。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过因为这个自旋次数不好判断，所以&lt;span&gt;引入自适应自旋&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说白了就是结合经验值来看，如果上次自旋一会儿就拿到锁，那这次多自旋几次，如果上次自旋很久都拿不到，这次就少自旋。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就叫锁的自适应自旋。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;49.JVM 内存区域划分&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 虚拟机运行时数据区分为程序计数器、虚拟机栈、本地方法栈、堆、方法区。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5781544256120528&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nGKnoFLBg9zuEFYQErIHibbfH6Q5xY5KSfexk71iaZcqrZn2rtviaHOBehkQbib8AFpS33PsDtPzjj98A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;531&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序计数器、虚拟机栈、本地方法栈这 3 个区域是线程私有的，会随线程消亡而自动回收，所以不需要管理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而堆和方法区是线程共享的，所以垃圾回收器会关注这两个地方。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;堆只要存放的就是平时 new 的对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法区存放的就是加载的类型信息、即时编译(JIT)后的代码等。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;50. 指令重排知道吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了提高程序执行的效率，CPU或者编译器就将执行命令重排序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原因是因为内存访问的速度比 CPU 运行速度慢很多，因此需要编排一下执行的顺序，防止因为访问内存的比较慢的指令而使得 CPU 闲置着。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CPU 执行有个指令流水线的概念，还有分支预测等，关于这个我之前写过一篇文章，可以看下&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkxNTE3NjQ3MA==&amp;amp;mid=2247485729&amp;amp;idx=1&amp;amp;sn=cc8ed967615de699e5733790f2099846&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;CPU分支预测&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总之为了提高效率就会有指令重排的情况，导致指令乱序执行的情况发生，不过会保证结果肯定是与单线程执行结果一致的，这叫 &lt;code&gt;as-if-serial&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过多线程就无法保证了，在 Java 中的 volatile 关键字可以禁止修饰变量前后的指令重排。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;51.final 和可以保证可见性吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不可以&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可能看到一些答案说可以保证可见性，&lt;span&gt;那不是我们常说的可见性&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般而言我们指的可见性是一个线程修改了共享变量，另一个线程可以立马得知更改，得到最新修改后的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而 final 并不能保证这种情况的发生，volatile 才可以。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而有些答案提到的 final 可以保证可见性，其实指的是 final 修饰的字段在构造方法初始化完成，并且期间没有把  this 传递出去，那么当构造器执行完毕之后，其他线程就能看见 final 字段的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不用 final 修饰的话，那么有可能在构造函数里面对字段的写操作被排序到外部，这样别的线程就拿不到写操作之后的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来看个代码就比较清晰了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;YesFinalTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; a; &lt;br/&gt;   &lt;span&gt;int&lt;/span&gt; b;&lt;br/&gt;   &lt;span&gt;static&lt;/span&gt; YesFinalTest testObj;&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;YesFinalTest&lt;/span&gt; &lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;//对字段赋值&lt;/span&gt;&lt;br/&gt;       a = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;       b = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;   }&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;newTestObj&lt;/span&gt; &lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{  &lt;span&gt;// 此时线程 A 调用这个方法&lt;/span&gt;&lt;br/&gt;       testObj = &lt;span&gt;new&lt;/span&gt; YesFinalTest ();&lt;br/&gt;   }&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;getTestObj&lt;/span&gt; &lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{  &lt;span&gt;// 此时线程 B 执行这个方法&lt;/span&gt;&lt;br/&gt;       YesFinalTest object = obj; &lt;br/&gt;       &lt;span&gt;int&lt;/span&gt; a = object.a; &lt;span&gt;//这里读到的肯定是 1&lt;/span&gt;&lt;br/&gt;       &lt;span&gt;int&lt;/span&gt; b = object.b; &lt;span&gt;//这里读到的可能是 2&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 final 域，编译器和处理器要遵守两个重排序规则(参考自infoq程晓明)：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在构造函数内对一个 final 域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。初次读一个包含&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;final 域的对象的引用，与随后初次读这个 final 域，这两个操作之间不能重排序。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以这才是 final 的可见性，这种可见性和我们在并发中常说的可见性不是一个概念！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所以 final 无法保证可见性&lt;/span&gt;！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;52.锁如何优化？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要注意锁的粒度，不能粗暴的直接在方法外围定义锁，锁的代码块越小越好，像双检锁就是典型的优化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不同场景定义不同的锁，不能粗暴的一把锁搞定，例如在读多写少的场景可以使用读写锁、写时复制等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再具体的可以看看我之前写的&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkxNTE3NjQ3MA==&amp;amp;mid=2247485739&amp;amp;idx=1&amp;amp;sn=801792f4987c4c3bd3d976d030476113&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Java锁事&lt;/a&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最后&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这里的都是勇士！来投票吧！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;vote_area&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我是 yes，从一点点到亿点点，我们下篇见，看到这的需要有奖励，哈哈&lt;/span&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>337231ed1034135a3c034b46e065f573</guid>
<title>[推荐] 高并发下如何保证接口的幂等性？</title>
<link>https://toutiao.io/k/f0361xm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUxODkzNTQ3Nw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/uL371281oDFEpxenPicr7Kh8c9P0I97yVWw9JfljjPy5gVBLDiaIrWkzAGHGib09Kib4TQtyw8jpLicW3yoyibMY8yMA/0?wx_fmt=png&quot; data-nickname=&quot;苏三说技术&quot; data-alias=&quot;&quot; data-signature=&quot;「苏三说技术」 维护者目前就职于某知名互联网公司，从事开发、架构和部分管理工作。实战经验丰富，对jdk、spring、springboot、springcloud、mybatis等开源框架源码有一定研究，欢迎关注，和我一起交流。&quot;/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;前言&lt;br/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;接口幂等性&lt;/code&gt;问题，对于开发人员来说，是一个跟语言无关的公共问题。本文分享了一些解决这类问题非常实用的办法，绝大部分内容我在项目中实践过的，给有需要的小伙伴一个参考。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道你有没有遇到过这些场景：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;有时我们在填写某些&lt;code&gt;form表单&lt;/code&gt;时，保存按钮不小心快速点了两次，表中竟然产生了两条重复的数据，只是id不一样。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我们在项目中为了解决&lt;code&gt;接口超时&lt;/code&gt;问题，通常会引入了&lt;code&gt;重试机制&lt;/code&gt;。第一次请求接口超时了，请求方没能及时获取返回结果（此时有可能已经成功了），为了避免返回错误的结果（这种情况不可能直接返回失败吧？），于是会对该请求重试几次，这样也会产生重复的数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;mq消费者在读取消息时，有时候会读取到&lt;code&gt;重复消息&lt;/code&gt;（至于什么原因这里先不说，有兴趣的小伙伴，可以找我私聊），如果处理不好，也会产生重复的数据。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，这些都是幂等性问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;接口幂等性&lt;/code&gt;是指用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这类问题多发于接口的：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;insert&lt;/code&gt;操作，这种情况下多次请求，可能会产生重复数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;update&lt;/code&gt;操作，如果只是单纯的更新数据，比如：&lt;code&gt;update user set status=1 where id=1&lt;/code&gt;，是没有问题的。如果还有计算，比如：&lt;code&gt;update user set status=status+1 where id=1&lt;/code&gt;，这种情况下多次请求，可能会导致数据错误。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么我们要如何保证接口幂等性？本文将会告诉你答案。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. insert前先select&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常情况下，在保存数据的接口中，我们为了防止产生重复数据，一般会在&lt;code&gt;insert&lt;/code&gt;前，先根据&lt;code&gt;name&lt;/code&gt;或&lt;code&gt;code&lt;/code&gt;字段&lt;code&gt;select&lt;/code&gt;一下数据。如果该数据已存在，则执行&lt;code&gt;update&lt;/code&gt;操作，如果不存在，才执行  &lt;code&gt;insert&lt;/code&gt;操作。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.0972762645914398&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEulLjl08cXVC1y0sFSlxNrFw4QIBGFicltUPsasY7lgUVEK7cVLS1GK3mibMW5Jcy4t1TvNmaBnGew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;514&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该方案可能是我们平时在防止产生重复数据时，使用最多的方案。但是该方案不适用于并发场景，在并发场景中，要配合其他方案一起使用，否则同样会产生重复数据。我在这里提一下，是为了避免大家踩坑。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 加悲观锁&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在支付场景中，用户A的账号余额有150元，想转出100元，正常情况下用户A的余额只剩50元。一般情况下，sql是这样的：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;update&lt;/span&gt; user amount = amount-&lt;span class=&quot;code-snippet__number&quot;&gt;100&lt;/span&gt; where id=&lt;span class=&quot;code-snippet__number&quot;&gt;123&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果出现多次相同的请求，可能会导致用户A的余额变成负数。这种情况，用户A来可能要哭了。于此同时，系统开发人员可能也要哭了，因为这是很严重的系统bug。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决这个问题，可以加悲观锁，将用户A的那行数据锁住，在同一时刻只允许一个请求获得锁，更新数据，其他的请求则等待。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常情况下通过如下sql锁住单行数据：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;code-snippet__number&quot;&gt;123&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;update&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体流程如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.9544554455445544&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEulLjl08cXVC1y0sFSlxNrlFMScuviaupFRboxZnOVWkojRVNxya7e2a0BUvnU7cwcAw9jYMLvJXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1010&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体步骤：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;多个请求同时根据id查询用户信息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;判断余额是否不足100，如果余额不足，则直接返回余额不足。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果余额充足，则通过for update再次查询用户信息，并且尝试获取锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;只有第一个请求能获取到行锁，其余没有获取锁的请求，则等待下一次获取锁的机会。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第一个请求获取到锁之后，判断余额是否不足100，如果余额足够，则进行update操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果余额不足，说明是重复请求，则直接返回成功。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;需要特别注意的是：如果使用的是mysql数据库，存储引擎必须用innodb，因为它才支持事务。此外，这里id字段一定要是主键或者唯一索引，不然会锁住整张表。&lt;/p&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;悲观锁需要在同一个事务操作过程中锁住一行数据，如果事务耗时比较长，会造成大量的请求等待，影响接口性能&lt;/span&gt;。&lt;/section&gt;&lt;section&gt;此外，每次请求接口很难保证都有相同的返回值，所以不适合幂等性设计场景，但是在防重场景中是可以的使用的。&lt;/section&gt;&lt;section&gt;&lt;span&gt;在这里顺便说一下，&lt;/span&gt;&lt;code&gt;防重设计&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;幂等设计&lt;/code&gt;&lt;span&gt;，其实是有区别的。&lt;/span&gt;&lt;span&gt;防重设计主要为了避免产生重复数据，对接口返回没有太多要求。&lt;/span&gt;&lt;span&gt;而幂等设计除了避免产生重复数据之外，还要求每次请求都返回一样的结果。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;3. 加乐观锁&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然悲观锁有性能问题，为了提升接口性能，我们可以使用乐观锁。需要在表中增加一个&lt;code&gt;timestamp&lt;/code&gt;或者&lt;code&gt;version&lt;/code&gt;字段，这里以&lt;code&gt;version&lt;/code&gt;字段为例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在更新数据之前先查询一下数据：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;id&lt;/span&gt;,amount,&lt;span class=&quot;code-snippet__keyword&quot;&gt;version&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;code-snippet__number&quot;&gt;123&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果数据存在，假设查到的&lt;code&gt;version&lt;/code&gt;等于&lt;code&gt;1&lt;/code&gt;，再使用&lt;code&gt;id&lt;/code&gt;和&lt;code&gt;version&lt;/code&gt;字段作为查询条件更新数据：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;update&lt;/span&gt; user set amount=amount+&lt;span class=&quot;code-snippet__number&quot;&gt;100&lt;/span&gt;,version=version+&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;where id=&lt;span class=&quot;code-snippet__number&quot;&gt;123&lt;/span&gt; and version=&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更新数据的同时&lt;code&gt;version+1&lt;/code&gt;，然后判断本次&lt;code&gt;update&lt;/code&gt;操作的影响行数，如果大于0，则说明本次更新成功，如果等于0，则说明本次更新没有让数据变更。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于第一次请求&lt;code&gt;version&lt;/code&gt;等于&lt;code&gt;1&lt;/code&gt;是可以成功的，操作成功后&lt;code&gt;version&lt;/code&gt;变成&lt;code&gt;2&lt;/code&gt;了。这时如果并发的请求过来，再执行相同的sql：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__attribute&quot;&gt;update&lt;/span&gt; user set amount=amount+&lt;span class=&quot;code-snippet__number&quot;&gt;100&lt;/span&gt;,version=version+&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;where id=&lt;span class=&quot;code-snippet__number&quot;&gt;123&lt;/span&gt; and version=&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该&lt;code&gt;update&lt;/code&gt;操作不会真正更新数据，最终sql的执行结果影响行数是&lt;code&gt;0&lt;/code&gt;，因为&lt;code&gt;version&lt;/code&gt;已经变成&lt;code&gt;2&lt;/code&gt;了，&lt;code&gt;where&lt;/code&gt;中的&lt;code&gt;version=1&lt;/code&gt;肯定无法满足条件。但为了保证接口幂等性，接口可以直接返回成功，因为&lt;code&gt;version&lt;/code&gt;值已经修改了，那么前面必定已经成功过一次，后面都是重复的请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体流程如下：&lt;img data-ratio=&quot;1.5942028985507246&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEulLjl08cXVC1y0sFSlxNrVUKwejvF2k3OTVPD2JPAiaV5diaMl16ictoclcWwgcvJsMV8mibVOartVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;552&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体步骤：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;先根据id查询用户信息，包含version字段&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;根据id和version字段值作为where条件的参数，更新用户信息，同时version+1&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;判断操作影响行数，如果影响1行，则说明是一次请求，可以做其他数据操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果影响0行，说明是重复请求，则直接返回成功。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. 加唯一索引&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;绝大数情况下，为了防止重复数据的产生，我们都会在表中加唯一索引，这是一个非常简单，并且有效的方案。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;alter table &lt;span class=&quot;code-snippet__string&quot;&gt;`order`&lt;/span&gt; add UNIQUE KEY &lt;span class=&quot;code-snippet__string&quot;&gt;`un_code`&lt;/span&gt; (&lt;span class=&quot;code-snippet__string&quot;&gt;`code`&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加了唯一索引之后，第一次请求数据可以插入成功。但后面的相同请求，插入数据时会报&lt;code&gt;Duplicate entry &#x27;002&#x27; for key &#x27;order.un_code&lt;/code&gt;异常，表示唯一索引有冲突。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽说抛异常对数据来说没有影响，不会造成错误数据。但是为了保证接口幂等性，我们需要对该异常进行捕获，然后返回成功。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是&lt;code&gt;java&lt;/code&gt;程序需要捕获：&lt;code&gt;DuplicateKeyException&lt;/code&gt;异常，如果使用了&lt;code&gt;spring&lt;/code&gt;框架还需要捕获：&lt;code&gt;MySQLIntegrityConstraintViolationException&lt;/code&gt;异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体流程图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.47766323024055&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEulLjl08cXVC1y0sFSlxNrs24WBMr0ktqAewryz7neZsASO9B8Qseqb8ict8CyLyia8lzv2YlY5LQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;582&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体步骤：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;用户通过浏览器发起请求，服务端收集数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将该数据插入mysql&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;判断是否执行成功，如果成功，则操作其他数据（可能还有其他的业务逻辑）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果执行失败，捕获唯一索引冲突异常，直接返回成功。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5. 建防重表&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候表中并非所有的场景都不允许产生重复的数据，只有某些特定场景才不允许。这时候，直接在表中加唯一索引，显然是不太合适的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对这种情况，我们可以通过&lt;code&gt;建防重表&lt;/code&gt;来解决问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该表可以只包含两个字段：&lt;code&gt;id&lt;/code&gt; 和 &lt;code&gt;唯一索引&lt;/code&gt;，唯一索引可以是多个字段比如：name、code等组合起来的唯一标识，例如：susan_0001。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体流程图如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.198952879581152&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEulLjl08cXVC1y0sFSlxNrbAGE1PLlnV6ibnZcTeNeyic7bv6jewYbu1Tfo7KO99iciaZcbf5icgSPovA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;764&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体步骤：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;用户通过浏览器发起请求，服务端收集数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将该数据插入mysql防重表&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;判断是否执行成功，如果成功，则做mysql其他的数据操作（可能还有其他的业务逻辑）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果执行失败，捕获唯一索引冲突异常，直接返回成功。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;需要特别注意的是：防重表和业务表必须在同一个数据库中，并且操作要在同一个事务中。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6. 根据状态机&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多时候业务表是有状态的，比如订单表中有：1-下单、2-已支付、3-完成、4-撤销等状态。如果这些状态的值是有规律的，按照业务节点正好是从小到大，我们就能通过它来保证接口的幂等性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如id=123的订单状态是&lt;code&gt;已支付&lt;/code&gt;，现在要变成&lt;code&gt;完成&lt;/code&gt;状态。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;update&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;`order`&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;status&lt;/span&gt;=&lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;code-snippet__number&quot;&gt;123&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;status&lt;/span&gt;=&lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一次请求时，该订单的状态是&lt;code&gt;已支付&lt;/code&gt;，值是&lt;code&gt;2&lt;/code&gt;，所以该&lt;code&gt;update&lt;/code&gt;语句可以正常更新数据，sql执行结果的影响行数是&lt;code&gt;1&lt;/code&gt;，订单状态变成了&lt;code&gt;3&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后面有相同的请求过来，再执行相同的sql时，由于订单状态变成了&lt;code&gt;3&lt;/code&gt;，再用&lt;code&gt;status=2&lt;/code&gt;作为条件，无法查询出需要更新的数据，所以最终sql执行结果的影响行数是&lt;code&gt;0&lt;/code&gt;，即不会真正的更新数据。但为了保证接口幂等性，影响行数是&lt;code&gt;0&lt;/code&gt;时，接口也可以直接返回成功。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体流程图如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.5646551724137931&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEulLjl08cXVC1y0sFSlxNrWHME47uFVibJDCibIPILsuFib5nq3batoka8m58tN42JdX4HgKSrKiaF9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;464&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体步骤：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;用户通过浏览器发起请求，服务端收集数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;根据id和当前状态作为条件，更新成下一个状态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;判断操作影响行数，如果影响了1行，说明当前操作成功，可以进行其他数据操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果影响了0行，说明是重复请求，直接返回成功。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;主要特别注意的是，该方案仅限于要更新的&lt;code&gt;表有状态字段&lt;/code&gt;，并且刚好要更新&lt;code&gt;状态字段&lt;/code&gt;的这种特殊情况，并非所有场景都适用。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7. 加分布式锁&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实前面介绍过的&lt;code&gt;加唯一索引&lt;/code&gt;或者&lt;code&gt;加防重表&lt;/code&gt;，本质是使用了&lt;code&gt;数据库&lt;/code&gt;的&lt;code&gt;分布式锁&lt;/code&gt;，也属于分布式锁的一种。但由于&lt;code&gt;数据库分布式锁&lt;/code&gt;的性能不太好，我们可以改用：&lt;code&gt;redis&lt;/code&gt;或&lt;code&gt;zookeeper&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;鉴于现在很多公司分布式配置中心改用&lt;code&gt;apollo&lt;/code&gt;或&lt;code&gt;nacos&lt;/code&gt;，已经很少用&lt;code&gt;zookeeper&lt;/code&gt;了，我们以&lt;code&gt;redis&lt;/code&gt;为例介绍分布式锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前主要有三种方式实现redis的分布式锁：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;setNx命令&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;set命令&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Redission框架&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每种方案各有利弊，具体实现细节我就不说了，有兴趣的朋友可以加我微信找我私聊。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体流程图如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.2676470588235293&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEulLjl08cXVC1y0sFSlxNrkm3ibIJnLzKpwSdxcSPGh8lfuCCGLO2QVnYp2msIvLgoLuHsyOjHdWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;680&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体步骤：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;用户通过浏览器发起请求，服务端会收集数据，并且生成订单号code作为唯一业务字段。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用redis的set命令，将该订单code设置到redis中，同时设置超时时间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;判断是否设置成功，如果设置成功，说明是第一次请求，则进行数据操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果设置失败，说明是重复请求，则直接返回成功。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;需要特别注意的是：分布式锁一定要设置一个合理的过期时间，如果设置过短，无法有效的防止重复请求。如果设置过长，可能会浪费&lt;code&gt;redis&lt;/code&gt;的存储空间，需要根据实际业务情况而定。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8. 获取token&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了上述方案之外，还有最后一种使用&lt;code&gt;token&lt;/code&gt;的方案。该方案跟之前的所有方案都有点不一样，需要两次请求才能完成一次业务操作。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一次请求获取&lt;code&gt;token&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二次请求带着这个&lt;code&gt;token&lt;/code&gt;，完成业务操作。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体流程图如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一步，先获取token。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bec22276e57942af70bb9cd7256c50a3</guid>
<title>[推荐] 万字详解整个数据仓库建设体系</title>
<link>https://toutiao.io/k/ny7vvdw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数据仓库的基本概念&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据仓库概念:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;英文名称为Data Warehouse，可简写为DW或DWH。数据仓库的目的是&lt;span&gt;构建面向分析的集成化数据环境，为企业提供决策支持&lt;/span&gt;（Decision Support）。它出于分析性报告和决策支持目的而创建。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;数据仓库本身并不“生产”任何数据，同时自身也不需要“消费”任何的数据，数据来源于外部，并且开放给外部应用，这也是为什么叫“仓库”，而不叫“工厂”的原因&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基本特征:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据仓库是&lt;span&gt;面向主题的&lt;/span&gt;、&lt;span&gt;集成的&lt;/span&gt;、&lt;span&gt;非易失的&lt;/span&gt;和&lt;span&gt;时变的&lt;/span&gt;数据集合，用以支持管理决策。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;面向主题:&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;传统数据库中，最大的特点是面向应用进行数据的组织，各个业务系统可能是相互分离的。而数据仓库则是面向主题的。主题是一个抽象的概念，是较高层次上企业信息系统中的数据综合、归类并进行分析利用的抽象。在逻辑意义上，它是对应企业中某一宏观分析领域所涉及的分析对象。&lt;/p&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;集成性:&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过对分散、独立、异构的数据库数据进行&lt;span&gt;抽取、清理、转换和汇总&lt;/span&gt;便得到了数据仓库的数据，这样保证了数据仓库内的数据关于整个企业的一致性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据仓库中的综合数据不能从原有的数据库系统直接得到。因此在数据进入数据仓库之前，必然要经过统一与综合，这一步是数据仓库建设中最关键、最复杂的一步，所要完成的工作有：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;要统一源数据中所有矛盾之处&lt;/strong&gt;，如字段的同名异义、异名同义、单位不统一、字长不一致，等等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;进行数据综合和计算&lt;/strong&gt;。数据仓库中的数据综合工作可以在从原有数据库抽取数据时生成，但许多是在数据仓库内部生成的，即进入数据仓库以后进行综合生成的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下图说明一个保险公司综合数据的简单处理过程，其中数据仓库中与“保险” 主题有关的数据来自于多个不同的操作型系统。这些系统内部数据的命名可能不同，数据格式也可能不同。把不同来源的数据存储到数据仓库之前，需要去除这些不一致。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5227765726681128&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zE5iaxpss0PTFDecPH0qXOgSUsp8BHsQC0TaY9027Zniaeib6QiahsNrKU26AOPNhK225rfnyuzoNTVrg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;461&quot;/&gt;&lt;figcaption&gt;数仓主题&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;非易失性（不可更新性）&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据仓库的数据反映的是一段相当长的时间内&lt;strong&gt;历史数据的内容&lt;/strong&gt;，是不同时点的数据库快照的集合，以及基于这些快照进行统计、综合和重组的导出数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据非易失性主要是针对应用而言。数据仓库的用户对数据的操作大多是数据查询或比较复杂的挖掘，一旦数据进入数据仓库以后，一般情况下被较长时间保留。数据仓库中一般有大量的查询操作，但修改和删除操作很少。因此，&lt;strong&gt;数据经加工和集成进入数据仓库后是极少更新的，通常只需要定期的加载和更新&lt;/strong&gt;。&lt;/p&gt;&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;时变性&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据仓库包含各种粒度的历史数据。数据仓库中的数据可能与某个特定日期、星期、月份、季度或者年份有关。数据仓库的目的是通过分析企业过去一段时间业务的经营状况，挖掘其中隐藏的模式。虽然&lt;span&gt;数据仓库的用户不能修改数据，但并不是说数据仓库的数据是永远不变的&lt;/span&gt;。分析的结果只能反映过去的情况，当业务变化后，挖掘出的模式会失去时效性。因此数据仓库的数据需要更新，以适应决策的需要。从这个角度讲，数据仓库建设是一个项目，更是一个过程。数据仓库的数据随时间的变化表现在以下几个方面：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）数据仓库的数据时限一般要远远长于操作型数据的数据时限。&lt;br/&gt;（2）操作型系统存储的是当前数据，而数据仓库中的数据是历史数据。&lt;br/&gt;（3）数据仓库中的数据是按照时间顺序追加的，它们都带有时间属性。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1. 数据仓库与数据库的区别&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据库与数据仓库的区别实际讲的是 &lt;strong&gt;OLTP&lt;/strong&gt; 与 &lt;strong&gt;OLAP&lt;/strong&gt; 的区别。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;操作型处理，叫联机事务处理 OLTP&lt;/span&gt;（On-Line Transaction Processing，），也可以称面向交易的处理系统，它是针对具体业务在数据库联机的日常操作，通常对少数记录进行查询、修改。&lt;strong&gt;用户较为关心操作的响应时间、数据的安全性、完整性和并发支持的用户数等问题&lt;/strong&gt;。传统的数据库系统作为数据管理的主要手段，主要用于操作型处理，像Mysql，Oracle等关系型数据库一般属于OLTP。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;分析型处理，叫联机分析处理 OLAP&lt;/span&gt;（On-Line Analytical Processing）一般针对某些主题的历史数据进行分析，支持管理决策。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先要明白，数据仓库的出现，并不是要取代数据库。数据库是面向事务的设计，数据仓库是面向主题设计的。数据库一般存储业务数据，数据仓库存储的一般是历史数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据库设计是尽量避免冗余，一般针对某一业务应用进行设计，比如一张简单的User表，记录用户名、密码等简单数据即可，符合业务应用，但是不符合分析。&lt;strong&gt;数据仓库在设计是有意引入冗余，依照分析需求，分析维度、分析指标进行设计&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;数据库是为捕获数据而设计，数据仓库是为分析数据而设计&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以银行业务为例。数据库是事务系统的数据平台，客户在银行做的每笔交易都会写入数据库，被记录下来，这里，可以简单地理解为用数据库记账。数据仓库是分析系统的数据平台，它从事务系统获取数据，并做汇总、加工，为决策者提供决策的依据。比如，某银行某分行一个月发生多少交易，该分行当前存款余额是多少。如果存款又多，消费交易又多，那么该地区就有必要设立ATM了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然，银行的交易量是巨大的，通常以百万甚至千万次来计算。事务系统是实时的，这就要求时效性，客户存一笔钱需要几十秒是无法忍受的，这就要求数据库只能存储很短一段时间的数据。而分析系统是事后的，它要提供关注时间段内所有的有效数据。这些数据是海量的，汇总计算起来也要慢一些，但是，只要能够提供有效的分析数据就达到目的了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;数据仓库，是在数据库已经大量存在的情况下，为了进一步挖掘数据资源、为了决策需要而产生的，它决不是所谓的“大型数据库”&lt;/strong&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2.  数据仓库分层架构&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照数据流入流出的过程，数据仓库架构可分为：&lt;strong&gt;源数据&lt;/strong&gt;、&lt;strong&gt;数据仓库&lt;/strong&gt;、&lt;strong&gt;数据应用&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5741556534508077&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zE5iaxpss0PTFDecPH0qXOgSgQcmAC8vsG1DnGHibcjEBqnCdfZjKib459q8VTyQ2cqrpPAZs4Sj8VjA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;681&quot;/&gt;&lt;figcaption&gt;数据仓库&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据仓库的数据来源于不同的源数据，并提供多样的数据应用，数据自下而上流入数据仓库后向上层开放应用，而数据仓库只是中间集成化数据管理的一个平台。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;源数据&lt;/strong&gt;：此层数据无任何更改，直接沿用外围系统数据结构和数据，不对外开放；为临时存储层，是接口数据的临时存储区域，为后一步的数据处理做准备。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;数据仓库&lt;/strong&gt;：也称为细节层，DW层的数据应该是一致的、准确的、干净的数据，即对源系统数据进行了清洗（去除了杂质）后的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;数据应用&lt;/strong&gt;：前端应用直接读取的数据源；根据报表、专题分析需求而计算生成的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据仓库从各数据源获取数据及在数据仓库内的数据转换和流动都可以认为是ETL（&lt;strong&gt;抽取Extra, 转化Transfer, 装载Load&lt;/strong&gt;）的过程，ETL是数据仓库的流水线，也可以认为是数据仓库的血液，它维系着数据仓库中数据的新陈代谢，而数据仓库日常的管理和维护工作的大部分精力就是保持ETL的正常和稳定。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;那么为什么要数据仓库进行分层呢&lt;/strong&gt;&lt;/span&gt;?&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;用空间换时间&lt;/span&gt;，通过大量的预处理来提升应用系统的用户体验（效率），因此数据仓库会存在大量冗余的数据；不分层的话，如果源业务系统的业务规则发生变化将会影响整个数据清洗过程，工作量巨大。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;通过数据分层管理可以&lt;span&gt;简化数据清洗的过程&lt;/span&gt;，因为把原来一步的工作分到了多个步骤去完成，相当于把一个复杂的工作拆成了多个简单的工作，把一个大的黑盒变成了一个白盒，每一层的处理逻辑都相对简单和容易理解，这样我们比较容易保证每一个步骤的正确性，当数据发生错误的时候，往往我们只需要局部调整某个步骤即可。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.  数据仓库元数据的管理&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;元数据（Meta Date），主要记录数据仓库中模型的定义、各层级间的映射关系、监控数据仓库的数据状态及ETL的任务运行状态&lt;/strong&gt;。一般会通过元数据资料库（Metadata Repository）来统一地存储和管理元数据，其主要目的是使数据仓库的设计、部署、操作和管理能达成协同和一致。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;元数据是数据仓库管理系统的重要组成部分&lt;/span&gt;，元数据管理是企业级数据仓库中的关键组件，贯穿数据仓库构建的整个过程，直接影响着数据仓库的构建、使用和维护。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;构建数据仓库的主要步骤之一是ETL。这时元数据将发挥重要的作用，它定义了源数据系统到数据仓库的映射、数据转换的规则、数据仓库的逻辑结构、数据更新的规则、数据导入历史记录以及装载周期等相关内容。数据抽取和转换的专家以及数据仓库管理员正是通过元数据高效地构建数据仓库。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用户在使用数据仓库时，通过元数据访问数据，明确数据项的含义以及定制报表。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据仓库的规模及其复杂性离不开正确的元数据管理，包括增加或移除外部数据源，改变数据清洗方法，控制出错的查询以及安排备份等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;元数据可分为技术元数据和业务元数据。&lt;strong&gt;技术元数据&lt;/strong&gt;为开发和管理数据仓库的IT 人员使用，它描述了与数据仓库开发、管理和维护相关的数据，包括数据源信息、数据转换描述、数据仓库模型、数据清洗与更新规则、数据映射和访问权限等。而&lt;strong&gt;业务元数据&lt;/strong&gt;为管理层和业务分析人员服务，从业务角度描述数据，包括商务术语、数据仓库中有什么数据、数据的位置和数据的可用性等，帮助业务人员更好地理解数据仓库中哪些数据是可用的以及如何使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由上可见，元数据不仅定义了数据仓库中数据的模式、来源、抽取和转换规则等，而且是整个数据仓库系统运行的基础，&lt;span&gt;元数据把数据仓库系统中各个松散的组件联系起来，组成了一个有机的整体&lt;/span&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数仓建模方法&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据仓库的建模方法有很多种，&lt;span&gt;每一种建模方法代表了哲学上的一个观点&lt;/span&gt;，代表了一种归纳、概括世界的一种方法。常见的有 &lt;strong&gt;范式建模法、维度建模法、实体建模法&lt;/strong&gt;等，&lt;span&gt;每种方法从本质上将是从不同的角度看待业务中的问题&lt;/span&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1. 范式建模法（Third Normal Form，3NF）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;范式建模法其实是我们在构建数据模型常用的一个方法，该方法的主要由 Inmon 所提倡，主要解决关系型数据库的数据存储，利用的一种技术层面上的方法。目前，我们在关系型数据库中的建模方法，大部分采用的是三范式建模法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;范式 是符合某一种级别的关系模式的集合。构造数据库必须遵循一定的规则，而在关系型数据库中这种规则就是范式，这一过程也被称为规范化。目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、Boyce-Codd范式（BCNF）、第四范式（4NF）和第五范式（5NF）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在数据仓库的模型设计中，一般采用第三范式。一个符合第三范式的关系必须具有以下三个条件 :&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;每个属性值唯一，不具有多义性 ;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;每个非主属性必须完全依赖于整个主键，而非主键的一部分 ;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;每个非主属性不能依赖于其他关系中的属性，因为这样的话，这种属性应该归到其他关系中去。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4305694305694306&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zE5iaxpss0PTFDecPH0qXOgSAibYQt6N6JzBkU52pKPXFE5HIhwrdeEKjWc54rvjHs3jSRc1IXqneNQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1001&quot;/&gt;&lt;figcaption&gt;范式建模&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据 Inmon 的观点，数据仓库模型的建设方法和业务系统的企业数据模型类似。在业务系统中，企业数据模型决定了数据的来源，而企业数据模型也分为两个层次，即主题域模型和逻辑模型。同样，主题域模型可以看成是业务模型的概念模型，而逻辑模型则是域模型在关系型数据库上的实例化。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2. 维度建模法（Dimensional Modeling）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;维度模型是数据仓库领域另一位大师Ralph Kimall所倡导，他的《数据仓库工具箱》是数据仓库工程领域最流行的数仓建模经典。维度建模以分析决策的需求出发构建模型，构建的数据模型为分析需求服务，因此它重点解决用户如何更快速完成分析需求，同时还有较好的大规模复杂查询的响应性能。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6598639455782312&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zE5iaxpss0PTFDecPH0qXOgSSFd7vMs0OWkc9CBeePTG5CsQjdZjibNtKgXMzvSOF7E5KkmCvaRwkAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;441&quot;/&gt;&lt;figcaption&gt;维度建模&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;典型的代表是我们比较熟知的星形模型（Star-schema），以及在一些特殊场景下适用的雪花模型（Snow-schema）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;维度建模中比较重要的概念就是 事实表（Fact table）和维度表（Dimension table）。其最简单的描述就是，按照事实表、维度表来构建数据仓库、数据集市。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;目前在互联网公司最常用的建模方法就是维度建模，稍后将重点讲解。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3. 实体建模法（Entity Modeling）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实体建模法并不是数据仓库建模中常见的一个方法，它来源于哲学的一个流派。从哲学的意义上说，客观世界应该是可以细分的，客观世界应该可以分成由一个个实体，以及实体与实体之间的关系组成。那么我们在数据仓库的建模过程中完全可以引入这个抽象的方法，将整个业务也可以划分成一个个的实体，而每个实体之间的关系，以及针对这些关系的说明就是我们数据建模需要做的工作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然实体法粗看起来好像有一些抽象，其实理解起来很容易。即我们可以将任何一个业务过程划分成 3 个部分，&lt;strong&gt;实体，事件，说明&lt;/strong&gt;，如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4356005788712012&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zE5iaxpss0PTFDecPH0qXOgSLlqf8SqfBibvWWF1y5zu3X9NoynJ87iaRtUM67N0Cleiaq4W3zb7VjypA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;691&quot;/&gt;&lt;figcaption&gt;实体建模&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图表述的是一个抽象的含义，如果我们描述一个简单的事实：“小明开车去学校上学”。以这个业务事实为例，我们可以把“小明”，“学校”看成是一个实体，“上学”描述的是一个业务过程，我们在这里可以抽象为一个具体“事件”，而“开车去”则可以看成是事件“上学”的一个说明。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;维度建模&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;维度建模是目前应用较为广泛的，专门应用于分析型数据库、数据仓库、数据集市建模的方法。数据集市可以理解为是一种&quot;小型数据仓库&quot;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1. 维度建模中表的类型&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 事实表&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发生在现实世界中的操作型事件，其所产生的可度量数值，存储在事实表中。从最低的粒度级别来看，事实表行对应一个度量事件，反之亦然。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;事实表表示对分析主题的度量&lt;/strong&gt;。比如一次购买行为我们就可以理解为是一个事实。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6738197424892703&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zE5iaxpss0PTFDecPH0qXOgSAcJy4kZsWh7WlId5tWU8NuiciaCbhKEHY9BUibUpIOv2so9V0tt54nSdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;699&quot;/&gt;&lt;figcaption&gt;事实与维度&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图中的订单表就是一个事实表，你可以理解他就是在现实中发生的一次操作型事件，我们每完成一个订单，就会在订单中增加一条记录。事实表的特征：表里没有存放实际的内容，他是一堆主键的集合，这些ID分别能对应到维度表中的一条记录。事实表包含了与各维度表相关联的外键，可与维度表关联。事实表的度量通常是数值类型，且记录数会不断增加，表数据规模迅速增长。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;明细表（宽表）：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事实表的数据中，有些属性共同组成了一个字段（糅合在一起），比如年月日时分秒构成了时间,当需要根据某一属性进行分组统计的时候，需要截取拼接之类的操作，效率极低。如：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;local_time&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;2021-03-18 06:31:42&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;为了分析方便，可以事实表中的一个字段切割提取多个属性出来构成新的字段，因为字段变多了，所以称为宽表，原来的成为窄表&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将上述的&lt;code&gt;local_time&lt;/code&gt;字段扩展为如下6个字段：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;year&lt;/th&gt;&lt;th&gt;month&lt;/th&gt;&lt;th&gt;day&lt;/th&gt;&lt;th&gt;hour&lt;/th&gt;&lt;th&gt;m&lt;/th&gt;&lt;th&gt;s&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;2021&lt;/td&gt;&lt;td&gt;03&lt;/td&gt;&lt;td&gt;18&lt;/td&gt;&lt;td&gt;06&lt;/td&gt;&lt;td&gt;31&lt;/td&gt;&lt;td&gt;42&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;又因为宽表的信息更加清晰明细，所以也可以称之为明细表。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2．维度表&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个维度表都包含单一的主键列。维度表的主键可以作为与之关联的任何事实表的外键，当然，维度表行的描述环境应与事实表行完全对应。维度表通常比较宽，是扁平型非规范表，包含大量的低粒度的文本属性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;维度表示你要对数据进行分析时所用的一个量，比如你要分析产品销售情况， 你可以选择按类别来进行分析，或按区域来分析。每个类别就构成一个维度。事实表的图中的用户表、商家表、时间表这些都属于维度表，这些表都有一个唯一的主键，然后在表中存放了详细的数据信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总的说来，在数据仓库中不需要严格遵守规范化设计原则。因为数据仓库的主导功能就是面向分析，以查询为主，不涉及数据更新操作。&lt;strong&gt;事实表的设计是以能够正确记录历史信息为准则，维度表的设计是以能够以合适的角度来聚合主题内容为准则&lt;/strong&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2. 维度建模三种模式&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 星型模式&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;星形模式(Star Schema)是最常用的维度建模方式。&lt;strong&gt;星型模式是以事实表为中心，所有的维度表直接连接在事实表上，像星星一样&lt;/strong&gt;。星形模式的维度建模由一个事实表和一组维表成，且具有以下特点：a. 维表只和事实表关联，维表之间没有关联；b. 每个维表主键为单列，且该主键放置在事实表中，作为两边连接的外键；c. 以事实表为核心，维表围绕核心呈星形分布；&lt;img data-ratio=&quot;0.7385964912280701&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zE5iaxpss0PTFDecPH0qXOgSiaqZeBQv6HJdTMxfnTqiauJrkZ1BALrJANyql3DoTIuRVH46ke3uXuNg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;570&quot;/&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 雪花模式&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;雪花模式(Snowflake Schema)是对星形模式的扩展。&lt;strong&gt;雪花模式的维度表可以拥有其他维度表的&lt;/strong&gt;，虽然这种模型相比星型更规范一些，但是由于这种模型不太容易理解，维护成本比较高，而且性能方面需要关联多层维表，性能也比星型模型要低。所以一般不是很常用&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6590604026845638&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zE5iaxpss0PTFDecPH0qXOgSHCTWDvKM80k5llibiapp2SDftmTzkQCXnnjOYqlsc1OpYDsHkRSBjVww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;745&quot;/&gt;&lt;figcaption&gt;雪花模式&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3．星座模式&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;星座模式是星型模式延伸而来，星型模式是基于一张事实表的，而&lt;strong&gt;星座模式是基于多张事实表的，而且共享维度信息&lt;/strong&gt;。前面介绍的两种维度建模方法都是多维表对应单事实表，但在很多时候维度空间内的事实表不止一个，而一个维表也可能被多个事实表用到。在&lt;span&gt;业务发展后期，绝大部分维度建模都采用的是星座模式&lt;/span&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5879043600562588&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zE5iaxpss0PTFDecPH0qXOgSPnNbhfv2fnuq3CctdicEjX6FxfSr6q6UiaJriaUAgxfa17A2OGic2EeoVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;711&quot;/&gt;&lt;figcaption&gt;星座模型&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3. 维度建模过程&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道维度建模的表类型有事实表，维度表；模式有星形模型，雪花模型，星座模型这些概念了，但是实际业务中，给了我们一堆数据，我们怎么拿这些数据进行数仓建设呢，数仓工具箱作者根据自身60多年的实际业务经验，给我们总结了如下四步，请务必记住！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数仓工具箱中的维度建模四步走：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.606060606060606&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zE5iaxpss0PTFDecPH0qXOgSvrQvIb7t0iciaWYxBnwia3OpkpeI9t5oUzNuUuiaIEdlQxxppJCdUQrzPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;231&quot;/&gt;&lt;figcaption&gt;维度建模四步走&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请&lt;strong&gt;牢记&lt;/strong&gt;以上四步，不管什么业务，就按照这个步骤来，顺序不要搞乱，因为这四步是环环相扣，步步相连。下面详细拆解下每个步骤怎么做&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1、选择业务过程&lt;/strong&gt;&lt;br/&gt;维度建模是紧贴业务的，所以必须以业务为根基进行建模，那么选择业务过程，顾名思义就是在整个业务流程中选取我们需要建模的业务，根据运营提供的需求及日后的易扩展性等进行选择业务。比如商城，整个商城流程分为商家端，用户端，平台端，运营需求是总订单量，订单人数，及用户的购买情况等，我们选择业务过程就选择用户端的数据，商家及平台端暂不考虑。业务选择非常重要，因为后面所有的步骤都是基于此业务数据展开的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2、声明粒度&lt;/strong&gt;&lt;br/&gt;先举个例子：对于用户来说，一个用户有一个身份证号，一个户籍地址，多个手机号，多张银行卡，那么与用户粒度相同的粒度属性有身份证粒度，户籍地址粒度，比用户粒度更细的粒度有手机号粒度，银行卡粒度，存在一对一的关系就是相同粒度。为什么要提相同粒度呢，因为维度建模中要求我们，在&lt;strong&gt;同一事实表&lt;/strong&gt;中，必须具有&lt;strong&gt;相同的粒度&lt;/strong&gt;，同一事实表中不要混用多种不同的粒度，不同的粒度数据建立不同的事实表。并且从给定的业务过程获取数据时，强烈建议从关注原子粒度开始设计，也就是从最细粒度开始，因为原子粒度能够承受无法预期的用户查询。但是上卷汇总粒度对查询性能的提升很重要的，所以对于有明确需求的数据，我们建立针对需求的上卷汇总粒度，对需求不明朗的数据我们建立原子粒度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3、确认维度&lt;/strong&gt;&lt;br/&gt;维度表是作为业务分析的入口和描述性标识，所以也被称为数据仓库的“灵魂”。在一堆的数据中怎么确认哪些是维度属性呢，如果该列是对具体值的描述，是一个文本或常量，某一约束和行标识的参与者，此时该属性往往是维度属性，数仓工具箱中告诉我们&lt;strong&gt;牢牢掌握事实表的粒度，就能将所有可能存在的维度区分开&lt;/strong&gt;，并且要&lt;strong&gt;确保维度表中不能出现重复数据，应使维度主键唯一&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;4、确认事实&lt;/strong&gt;&lt;br/&gt;事实表是用来度量的，基本上都以数量值表示，事实表中的每行对应一个度量，每行中的数据是一个特定级别的细节数据，称为粒度。维度建模的核心原则之一&lt;strong&gt;是同一事实表中的所有度量必须具有相同的粒度&lt;/strong&gt;。这样能确保不会出现重复计算度量的问题。有时候往往不能确定该列数据是事实属性还是维度属性。记住&lt;strong&gt;最实用的事实就是数值类型和可加类事实&lt;/strong&gt;。所以可以通过分析该列是否是一种包含多个值并作为计算的参与者的度量，这种情况下该列往往是事实。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;实际业务中数仓分层&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数仓分层要结合公司业务进行，并且需要清晰明确各层职责，要保证数据层的稳定又要屏蔽对下游影响，一般采用如下分层结构：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.41845764854614415&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zE5iaxpss0PTFDecPH0qXOgSNouOT3mnKPNzho7JqziaZ9G4QvRChVgteNoumPXghKZdMj83Z7gHIsQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;791&quot;/&gt;&lt;figcaption&gt;数据分层架构&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;数据层具体实现&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;使用四张图说明每层的具体实现&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7231543624161074&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zE5iaxpss0PTFDecPH0qXOgS1hkv9ibJgDkc1ibhhLjK5wEGoGo9fME275uTEzcC2TJ75LzEkMDIRrsw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;596&quot;/&gt;&lt;figcaption&gt;数据源层&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据源层主要将各个业务数据导入到大数据平台，作为业务数据的快照存储。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.66728280961183&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zE5iaxpss0PTFDecPH0qXOgS3ibKQAKTx0X6h850g6iaZ1BZjlEcUptd8NC5YicAgINVh06QcuyQCKKJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;541&quot;/&gt;&lt;figcaption&gt;数据明细层&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事实表中的每行对应一个度量，每行中的数据是一个特定级别的细节数据，称为粒度。要记住的是&lt;strong&gt;同一事实表中的所有度量必须具有相同的粒度&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;维度表一般都是单一主键，少数是联合主键，注意维度表不要出现重复数据，否则和事实表关联会出现&lt;strong&gt;数据发散&lt;/strong&gt;问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候往往不能确定该列数据是事实属性还是维度属性。记住&lt;strong&gt;最实用的事实就是数值类型和可加类事实&lt;/strong&gt;。所以可以通过分析该列是否是一种包含多个值并作为计算的参与者的度量，这种情况下该列往往是事实；如果该列是对具体值的描述，是一个文本或常量，某一约束和行标识的参与者，此时该属性往往是维度属性。但是还是要结合业务进行最终判断是维度还是事实。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5763993948562783&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zE5iaxpss0PTFDecPH0qXOgSZc4zIxiac4opLMDxdPIII38Bqk5Fry2oyQGE5XSibgZzCmwBtP0F1AqQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;661&quot;/&gt;&lt;figcaption&gt;数据轻度汇总层&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此层命名为轻汇总层，就代表这一层已经开始对数据进行汇总，但是不是完全汇总，只是对相同粒度的数据进行关联汇总，不同粒度但是有关系的数据也可进行汇总，此时需要将粒度通过聚合等操作进行统一。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4713656387665198&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zE5iaxpss0PTFDecPH0qXOgSvoJs9NuNwQXicwEPQGcbYz2sWNJ9WEymhczUB0tXSXEibdLem5Ah7ILw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;681&quot;/&gt;&lt;figcaption&gt;数据应用层&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据应用层的表就是提供给用户使用的，数仓建设到此就接近尾声了，接下来就根据不同的需求进行不同的取数，如直接进行报表展示，或提供给数据分析的同事所需的数据，或其他的业务支撑。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最后&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;技术是为业务服务的，业务是为公司创造价值的，离开业务的技术是无意义的。所以数仓的建设与业务是息息相关的，公司的业务不同，数仓的建设也是不同的，只有适合的才是最好的。&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;推荐阅读：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU2MDYzOA==&amp;amp;mid=2247484240&amp;amp;idx=1&amp;amp;sn=c02e7ede2183e8cf9779e79b6c2f21f8&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;结合公司业务分析离线数仓建设&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU2MDYzOA==&amp;amp;mid=2247483716&amp;amp;idx=1&amp;amp;sn=65cd82671c52cb80937d024549e25601&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;数仓建设中最常用模型--Kimball维度建模详解&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.0030211480362537764&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/cZV2hRpuAPia3RFX6Mvw06kePJ7HbmI7b35o17yNJx4WHYPSQj280IElEicRPq2CviaJe8fjL2AeadmIjARqVZWnw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;662&quot; data-backw=&quot;578&quot; data-backh=&quot;2&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg2MzU2MDYzOA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zFt9bNEoZic9Nc7JickzYKsp3tvxRZUE1ibhEPW4HwQvTe7esC7KQRoBoTdFyiaG9UhxgibzkxRDyibrKyQ/0?wx_fmt=png&quot; data-nickname=&quot;五分钟学大数据&quot; data-alias=&quot;LearnBigdata&quot; data-signature=&quot;专注于大数据领域研究，包括 Hadoop、Flink、Spark、Kafka、Hive、HBase 等，深入大数据技术原理，框架的使用，前沿大数据技术&quot;/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-mpa-category=&quot;引导&quot; data-mpa-template-id=&quot;6710&quot;&gt;&lt;section data-mpa-category=&quot;引导&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;    扫描二维码&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;   收获更多技术&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;五分钟学大数据&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;120&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;120&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/ZubDbBye0zHo5ICR7ia2IAFRuQhnq3AfhnzfXwmHuJNZownrjcpWPHK77tGHw9NbnV5keRXVy5mpwSaabwN6icwg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;344&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-mpa-category=&quot;引导&quot; data-mpa-template-id=&quot;6839&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt; &lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;点个&lt;span&gt;&lt;strong&gt;在看&lt;/strong&gt;&lt;/span&gt;，支持一下&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3aefe731a4258089aaab786b592059e1</guid>
<title>[推荐] 超实用的 IDEA 插件推荐！百万级下载量</title>
<link>https://toutiao.io/k/47wemjf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.41904761904761906&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5hLBZVCyG9Q25YpPAcQTDwknUQmiahRjicUuYVbjEVKuL0Njick5MmyWdciaXI6fA99tze61HBK2T7hQjPHBCSvW6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;945&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;超实用的30多款idea插件，有百万级下载量的优秀插件，你值得拥有！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;好的工具助你事半功倍，快速协助敲出更漂亮更有效率的代码。搬运工这里收集了很不错的&lt;strong&gt;IDEA插件&lt;/strong&gt;，相信你一定会喜欢的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;〓&lt;span&gt;必备插件列表：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-copyright=&quot;0&quot; data-ratio=&quot;0.5592592592592592&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/5hLBZVCyG9TCVSBCAJ36O3ib1icbYq8CibwU2StkgKG5V3QF1fardlB1rR3TcHRBUiclcoib96EjIwqnMwAENxFnCMQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-copyright=&quot;0&quot; data-ratio=&quot;0.5675925925925925&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/5hLBZVCyG9TCVSBCAJ36O3ib1icbYq8CibwxpEAMLhCVPeESPIPSSgD5I8ea3LEuibcPadJlwJ9Y1okKmxM24Fc4hQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-copyright=&quot;0&quot; data-ratio=&quot;0.2712962962962963&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/5hLBZVCyG9TCVSBCAJ36O3ib1icbYq8CibwOLPZoa9Oy5H1sQic2sYa4BGTVJ4X2aNP1RAqkakNUBLMic6yuNeNY4PA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.27054545454545453&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5hLBZVCyG9Q25YpPAcQTDwknUQmiahRjickhdACR6aek3tC7jiaAKLpDquPfLUtz8DCty0OxXaRk5fyMtkibZpxnJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1375&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-copyright=&quot;0&quot; data-ratio=&quot;0.5055555555555555&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/5hLBZVCyG9TCVSBCAJ36O3ib1icbYq8Cibw4toUcC4XXxETyXbD2CjNdhG2JDIArHgQ6gfkCErtNy1pmJ5nnaEsUg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-copyright=&quot;0&quot; data-ratio=&quot;0.17777777777777778&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/5hLBZVCyG9TCVSBCAJ36O3ib1icbYq8CibwWsIl7Qne22X8dEXWuZpdND3QSTVuwofG0iaicdOrh0vt239lmWSNliaRg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-copyright=&quot;0&quot; data-ratio=&quot;0.7484407484407485&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/5hLBZVCyG9TCVSBCAJ36O3ib1icbYq8CibwWTmjvxhjm2oGv4BI0h5tSJo8KgNbupb6lQFwSQibgibwlia1pFbuVDANA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;962&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-copyright=&quot;0&quot; data-ratio=&quot;0.5617740232312566&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/5hLBZVCyG9TCVSBCAJ36O3ib1icbYq8CibwEWSEoFazqpGJ1dCdvC59Ae0piaDsC7256b1DkX1flibDOGM5OkNO6eYw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;947&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-copyright=&quot;0&quot; data-ratio=&quot;0.6888888888888889&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/5hLBZVCyG9TCVSBCAJ36O3ib1icbYq8Cibw7jXVQQX1TVkBuX4hqAJj4v3aRxv30WG5P7TqticWD1JGMe6EtoAq1aw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-copyright=&quot;0&quot; data-ratio=&quot;0.4623955431754875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/5hLBZVCyG9TCVSBCAJ36O3ib1icbYq8CibwKIWaCibAZOr3PsVcEnCib0RxxC1qKHicCozcOZcc3zQXEUQDx3P5g2Qmw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1077&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-copyright=&quot;0&quot; data-ratio=&quot;0.9332591768631813&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/5hLBZVCyG9TCVSBCAJ36O3ib1icbYq8CibwN3OCkOKDWWzul2nDsrDr1zXaIZTJBbec9p4Wkz101EovRjljtwpvyg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;899&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Properties &lt;/strong&gt;&lt;strong&gt;to &lt;/strong&gt;&lt;strong&gt;YAML &lt;/strong&gt;&lt;strong&gt;Converter &lt;/strong&gt;：Properties 转 YAML 格式插件&lt;span&gt;，&lt;span&gt;下载量3.7W+，&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;推荐指数：&lt;/span&gt;&lt;span&gt;☆&lt;/span&gt;&lt;span&gt;☆&lt;/span&gt;&lt;span&gt;☆&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Git &lt;/strong&gt;&lt;strong&gt;Flow &lt;/strong&gt;&lt;strong&gt;Integration &lt;/strong&gt;：Git Flow 集成插件，&lt;span&gt;下载量55W+，&lt;/span&gt;&lt;strong&gt;推荐指数：☆&lt;span&gt;☆&lt;/span&gt;&lt;span&gt;☆&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.49490835030549896&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5hLBZVCyG9Q25YpPAcQTDwknUQmiahRjicHHRDL9cILZH1ib6tcRqzJlDrhkXicjCkkdnicMGMNibGvvSQdDTSAaJdyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;491&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.9141221374045801&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5hLBZVCyG9Q25YpPAcQTDwknUQmiahRjicdzeJyFdztQQibjfdfMERCuOJdupwpicjzxHic08w61JAYvSlg8NdeZZ8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;524&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Custom &lt;/strong&gt;&lt;strong&gt;Postfix &lt;/strong&gt;&lt;strong&gt;Templates&lt;/strong&gt;：自定义Postfix模板，&lt;span&gt;下载量7W+，&lt;/span&gt;&lt;strong&gt;推荐指数：☆☆☆&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5543478260869565&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/5hLBZVCyG9Q25YpPAcQTDwknUQmiahRjicUsG6FkdjH3DzvBgyvbC8GezAD0WhtYRibouY3YXE9x20L4FniaxMSXiag/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;736&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Lombok &lt;/strong&gt;&lt;strong&gt;Plugin&lt;/strong&gt;：注解自动生成代码&lt;span&gt;，&lt;span&gt;下载量804W+，&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;推荐指数：☆☆☆&lt;/strong&gt;&lt;span/&gt;&lt;strong&gt;☆&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;217&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.3743218806509946&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5hLBZVCyG9Q25YpPAcQTDwknUQmiahRjicwRoVcpibdicEhskSEOLy0c5GP6QVWxFNApibjEd7gu6DXEl0wUMDvONAw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1106&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.25&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5hLBZVCyG9Q25YpPAcQTDwknUQmiahRjicic3WOrFTuyIsbpp3j0cjXlgKJnYMMbWpVJFYedLiaUuCM4hq5o8eES7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7485493230174082&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5hLBZVCyG9Q25YpPAcQTDwknUQmiahRjic1J8rJ8gqZb0RoibQnE8HTOebWR7VYHcWvia8C7jbHxia0pGpzEAFreKFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;517&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5hLBZVCyG9Q25YpPAcQTDwknUQmiahRjicndmpdZibjRC4iapgUCfHdFRia4NcZQicUNaz1Je3wvorJ88HLECLglxciaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3421875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5hLBZVCyG9Q25YpPAcQTDwknUQmiahRjicSaLFp8JmTeibwBdft34Z2zcb39eDpOcXv24KoJJmnGJN75mMR2bibmMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5015625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5hLBZVCyG9Q25YpPAcQTDwknUQmiahRjiclLPOhCjNY7UAWDbV0bqIicIEnicqZtNdV5lY8mGwcibCA6P8TZJWomWbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;mpcpc js_editor_cpcad=&quot;&quot; class=&quot;js_cpc_area cpc_iframe&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/cpc_tmpl#1609465111069&quot; data-category_id_list=&quot;1|11|16|17|22|24|26|27|28|29|3|31|32|35|36|37|39|41|42|43|45|46|47|48|49|5|50|51|52|53|54|55|6|7|8&quot; data-id=&quot;1609465111069&quot;/&gt;&lt;span&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.609375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5hLBZVCyG9Q25YpPAcQTDwknUQmiahRjicXFo5fh0hY5VT20XHgEF87j3icYGTSsskyF29dRcfdCjia2iaDHblNyxmw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5703063629222309&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5hLBZVCyG9Q25YpPAcQTDwknUQmiahRjicjOKguaIznl5DkCtpTKB8ossubNEmxDAdicibjuXsa9Np2dBhAiawVCIibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1273&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.4972273567467653&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5hLBZVCyG9Q25YpPAcQTDwknUQmiahRjicyMlvIas6dacQJTs1spJ7zPytZBFP3qNQc4ztgW8OdA0bk4WRMyjD8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;541&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-copyright=&quot;0&quot; data-ratio=&quot;0.7534537725823592&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/5hLBZVCyG9TCVSBCAJ36O3ib1icbYq8CibwqMzRG5xHicGejBz9zMMZBxyG4I6LicQmTibe7UQ8OytJY6DrRibX3RO8Rw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;941&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.590521327014218&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5hLBZVCyG9Q25YpPAcQTDwknUQmiahRjic64u4ocMRxiabIMeuWO6GrAiasmmmfQCN6XS9T1faI6BuqBqlKEbT0WrA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1055&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.43521594684385384&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5hLBZVCyG9Q25YpPAcQTDwknUQmiahRjicc7Jw9ibPWTWFqXDf4mhANG7qmlUqxqFolJyTlJcF75uLlMDl7FFcA1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;602&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.565&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/5hLBZVCyG9Q25YpPAcQTDwknUQmiahRjicKvwPszTHTiaZd852ZTQqhF5WkeZPnEzuVbC4neictr5q779073IAc2dw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;‍&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.34609375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/5hLBZVCyG9Q25YpPAcQTDwknUQmiahRjicibelicCibVof86x5DxonBFEJaDgd3IM6XFrc9XAicnJNV0iagbejtTgEbwQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-source-line=&quot;63&quot;&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7092846270928462&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5hLBZVCyG9T580MUuCniazhJQAnIywiceleXYWFrLG58X78GBEnRIiaQVvicN4Fuuu38UgFYWvBytsskiccldzxafDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;657&quot;/&gt;&lt;/p&gt;&lt;p data-source-line=&quot;63&quot;&gt;&lt;br/&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3265625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5hLBZVCyG9Q25YpPAcQTDwknUQmiahRjicraZrgKUykXUm6e5PTiaFjIvMYlK8cESiaycI7hZziaY9aEdWWgbyYvkaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.37265625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5hLBZVCyG9Q25YpPAcQTDwknUQmiahRjicVy2EVMznfULKD8kymVbFVke8MbibvEpJBuM8ndISHlMzLxlndouv6Gw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-source-line=&quot;67&quot;&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4741591468416735&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5hLBZVCyG9Q25YpPAcQTDwknUQmiahRjicdiawJnUH2ImZUIuk4gAMtAJZBpSBpEvuNiboLl0T6qOLwRNDMsUyuDHg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1219&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;LeetCode editor&lt;/strong&gt;：LeetCode刷算法神器，可以拉取到LeetCode题，提交代码到LeetCode帮忙执行，&lt;/span&gt;&lt;span&gt;非常赞。&lt;/span&gt;&lt;span&gt;下载量5.8w+，&lt;/span&gt;&lt;strong&gt;推荐指数：☆☆☆&lt;strong&gt;☆&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;283&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.490625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5hLBZVCyG9QlG1zx26ehRoLx19dV9qrPntRd4lxNcspNbVEzAswukOBRDjNY8Pwmx4BKOqicfvJRWAgic51td4rw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;中文使用文档：&lt;/span&gt;&lt;span&gt;https://github.com/shuzijun/leetcode-editor/blob/master/README_ZH.md&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.475&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5hLBZVCyG9RJmlRRbGXIqiay7JG3wwicDrAph3NhCYdJs8OEq590Nj0gL3QRmCxAl4DtM3HNPlOgOdunzvGBEbyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5462408516300732&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5hLBZVCyG9SCFZAdxPaPfUfY26jiclzVfAzRRTk3jiaM23kxtouMby0Y8tccyAOqywH5TYkCEHfoYEeFdRPsxrrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1503&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ps:以上数据统计于2020.05&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;花了不少时间收集，并且找到对应的图片，太难了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;说了这么多，大家觉得这几款插件怎么样？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果有觉得也不错的插件欢迎留言，大家一起共享^_^。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;附2018版-》&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5NTUzNTA2Mw==&amp;amp;mid=2454932251&amp;amp;idx=1&amp;amp;sn=e69867ba84a8307a61ab9f2b3ceba32a&amp;amp;chksm=871a01a3b06d88b55e18267f4b243f4ce3647e4d31979d6ce7d6f34676837be405427e82df5f&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;必备瑞士军刀IDEA插件，你使用了哪些？&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;推荐好文&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzA5NTUzNTA2Mw==&amp;amp;mid=2454933881&amp;amp;idx=1&amp;amp;sn=4f2bdecf4596d24559ebc519363e6639&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;互联网Code Review最佳实践分享&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;互联网Code Review最佳实践分享&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、&lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5NTUzNTA2Mw==&amp;amp;mid=2454932968&amp;amp;idx=1&amp;amp;sn=f85707232789cbb41c2bebffcb67507b&amp;amp;chksm=871a0750b06d8e467e49858d7c1d64604a84d1316324e30976071fd30347813d490ef4e175b5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;dubbo面试题！会这些，说明你看懂了dubbo源码&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;dubbo面试题！会这些，说明你看懂了dubbo源码&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、&lt;/strong&gt;&lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzA3MTUzOTcxOQ==&amp;amp;mid=2452969933&amp;amp;idx=1&amp;amp;sn=ab685b2cee2b9d1dc3a1996ab3621b49&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span/&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5NTUzNTA2Mw==&amp;amp;mid=2454933508&amp;amp;idx=1&amp;amp;sn=f993f90fd83c0eca8cd1b15a9b6db017&amp;amp;chksm=871a1abcb06d93aa36ebe2ff761193030d3f886f5b6ee894bab49eaccbc0cf30986d078e8e66&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Kafka面试题！掌握它才说明你真正懂Kafka&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Kafka面试题！掌握它才说明你真正懂Kafka&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span/&gt;&lt;br/&gt;&lt;strong&gt;4、&lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5NTUzNTA2Mw==&amp;amp;mid=2454932288&amp;amp;idx=1&amp;amp;sn=149a790e4d3d6b2722ccdb677e54a666&amp;amp;chksm=871a01f8b06d88eeac9200e146c3d3de70351b2deb4e85339a037a6f21c06d8a7b0b299880eb&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Netty 5.0为啥被舍弃？原因竟然是...&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Netty 5.0为啥被舍弃？原因竟然是...&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span/&gt;&lt;br/&gt;&lt;strong&gt;5、&lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzA5NTUzNTA2Mw==&amp;amp;mid=2454933647&amp;amp;idx=1&amp;amp;sn=7021d7c3d4a02de5178c86b7af85be52&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;中台之上——业务架构系列【汇总】&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;中台之上——业务架构系列【汇总】&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;6、&lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5NTUzNTA2Mw==&amp;amp;mid=2454932251&amp;amp;idx=1&amp;amp;sn=e69867ba84a8307a61ab9f2b3ceba32a&amp;amp;chksm=871a01a3b06d88b55e18267f4b243f4ce3647e4d31979d6ce7d6f34676837be405427e82df5f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;必备瑞士军刀IDEA插件，你使用了哪些&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;&lt;span&gt;必备瑞士军刀IDEA插件，你使用了哪些&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;7、&lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5NTUzNTA2Mw==&amp;amp;mid=2454934195&amp;amp;idx=1&amp;amp;sn=62869742d0cdebcef26a0732c9bb03ec&amp;amp;chksm=871a180bb06d911d4da8ab7c3b7699f033d0f0ede1d2eab5263e273ad08c8d1837facd809ae9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;线上热更新代码只需3步 Arthas实战&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;线上热更新代码只需3步 Arthas实战&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;8、&lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5NTUzNTA2Mw==&amp;amp;mid=2454934176&amp;amp;idx=1&amp;amp;sn=b94dd05ecff649c73a89ef191208c0f0&amp;amp;chksm=871a1818b06d910ecdee7d912abb31b3b6bb4efe7cfbc6241b517193f1c4523c075188c724c2&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Eureka源码剖析之七：架构&amp;amp;面试题【总结】&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Eureka源码剖析之七：架构&amp;amp;面试题【总结】&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;9、&lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5NTUzNTA2Mw==&amp;amp;mid=2454933958&amp;amp;idx=1&amp;amp;sn=fcb60a3e46cdff2684fef0e864eee94b&amp;amp;chksm=871a1b7eb06d92680136868aef9a35d59e6c071dda30e67bad75c9c44a0fccba2229d7536ce6&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;互联网工程师应该用这种姿势打印日志&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;互联网工程师应该用这种姿势打印日志&lt;br/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-copyright=&quot;0&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5hLBZVCyG9TSaWN1KPgU0HGEM8uPibRI0xaL9KEnrpjk93rg8UeYsv7G4LVicvD8EOxfDq9rPfUSibarNsLZ5u0Vg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;-关注搬运工来架构，与优秀的你一同进步-&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果喜欢这篇文章可以点在看哦↘&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>464725462769eb3acc252e6b46c772ee</guid>
<title>[推荐] 如何吃透一个 Java 项目？（附学习实践）</title>
<link>https://toutiao.io/k/cifpaoe</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages __bg_gif&quot; data-ratio=&quot;0.16666666666666666&quot; data-s=&quot;300,640&quot; data-type=&quot;gif&quot; data-w=&quot;900&quot; data-backw=&quot;578&quot; data-backh=&quot;96&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/33P2FdAnju95xNQaJWFlU3fWicicxBac5nuOMtveZ6lxCCnoZU1Xd6ITUVhoibJib5eyx6d2hePhGFNbQ4nT3Gicgpg/640?wx_fmt=gif&quot;/&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;88287&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;先说一下自己的情况：&lt;/span&gt;&lt;span&gt;就是对着视频敲Java项目，其中遇到的BUG还能解&lt;/span&gt;&lt;span&gt;决，但就是&lt;/span&gt;&lt;span&gt;每次敲完一个项目，就感觉很空虚，项目里面的知识点感觉懂了但又好像没懂，我应该怎样才能掌握一个项目所用的知识点呢？&lt;/span&gt;&lt;span&gt;至少不至于过了一头半个月就想不起来这个项目是什么东西了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;写博客记录？&lt;/span&gt;&lt;span&gt;，画思维导图？&lt;/span&gt;&lt;span&gt;还是怎么样呢？&lt;/span&gt;&lt;span&gt;有没有过来人能给点经验呢？&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;71b219af727f4f9c1ecdc5a25d7f12de&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;首先，尝试分析下题主感到空虚、似懂非懂的原因，从问题描述来看原因可能有以下几方面：&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;71b219af727f4f9c1ecdc5a25d7f12de&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-lake-id=&quot;ca6fa186228ff7efaa653334195896c8&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;▐  &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;目标不&lt;/span&gt;&lt;span&gt;清&lt;/span&gt;&lt;span&gt;晰&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;71b219af727f4f9c1ecdc5a25d7f12de&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;在项目学习之前，是否有认真梳理和思考过，希望通过项目学习到哪些技术、&lt;/span&gt;&lt;span&gt;重点需掌握哪些知识点？&lt;/span&gt;&lt;span&gt;这些知识点又属于自己技术体系中哪个环节，是需要必须熟练掌握还是了解原理即可？&lt;/span&gt;&lt;span&gt;相信只有明确目标之后才有学习侧重&lt;/span&gt;&lt;span&gt;点和方向。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;71b219af727f4f9c1ecdc5a25d7f12de&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-lake-id=&quot;ca6fa186228ff7efaa653334195896c8&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;▐  学习方法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;h4 data-lake-id=&quot;ca6fa186228ff7efaa653334195896c8&quot; data-wording=&quot;true&quot;&gt;&lt;br/&gt;&lt;/h4&gt;&lt;h4 data-lake-id=&quot;ca6fa186228ff7efaa653334195896c8&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;项目学习过程中，是否有带着问题和思考？比如项目核心需要解决的问题场景、使用了哪些技术方案，为什么需要这些技术，方案选择考虑主要有哪些？系统模块这样分层和实现的好处是？这个方法的实现，性能是否可以进一步优化等等。&lt;/span&gt;&lt;/h4&gt;&lt;h4 data-lake-id=&quot;ca6fa186228ff7efaa653334195896c8&quot; data-wording=&quot;true&quot;&gt;&lt;br/&gt;&lt;/h4&gt;&lt;h4 data-lake-id=&quot;ca6fa186228ff7efaa653334195896c8&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;如果只是纯粹跟着视频将项目代码机械敲一遍，我认为跟练习打字没任何区别，写出来的代码也是没有灵魂如行尸走肉。我相信只有结合自己的思考和理解，才可能赋予新的灵魂，做到知其然知其所以然，相关知识点也才能真正转化为自己的技术。&lt;/span&gt;&lt;/h4&gt;&lt;h4 data-lake-id=&quot;ca6fa186228ff7efaa653334195896c8&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;▐  &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;复习与应用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;纸上得来终觉浅，绝知此事要躬行，相信对编程而言更是如此，唯有实践才能出真知。对项目中学到的相关技术、知识点需要在不同场景反复练习和应用，并对过程中遇到的问题不断总结和反思。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;95401&quot;&gt;&lt;section&gt;&lt;section data-width=&quot;80%&quot;&gt;&lt;img data-ratio=&quot;0.0397489539748954&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/33P2FdAnjuiccUgnPh8mN61ImRu6ibO9SM59BYV8yapap1rP2jHKDKPOlkjlthrHckF0HCk95kNEXxA5OZ0pdfHg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;478&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-lake-id=&quot;04512c184ebe4ec4f854593a029bf69c&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;其次，回到题主问题，如何吃透一个Java项目？从个人经验来看，大致可以从以下几方面入手：&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;04512c184ebe4ec4f854593a029bf69c&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-lake-id=&quot;ca6fa186228ff7efaa653334195896c8&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;▐  &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;项目背景了解&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p data-lake-id=&quot;04512c184ebe4ec4f854593a029bf69c&quot; data-wording=&quot;true&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;学习之前，先对项目业务背景和技术体系做大致的了解，这点非常重要，一是为了解项目核心要解决问题域，二是知道系统涉及哪些技术体系，这样在学习之前可以有相关技术知识准备，以便更轻松高效学习。&lt;/span&gt;&lt;span&gt;另外，学习完之后也可以清楚知道，什么样问题可以使用什么技术、什么方案来解决、如何解决的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-lake-id=&quot;ca6fa186228ff7efaa653334195896c8&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;▐  &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;系统设计文档学习&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对项目和系统大概了解之后，可以开始对系统设计文档熟悉，建议按照架构文档、概要设计、详细设计方式递进。&lt;/span&gt;&lt;span&gt;通过设计文档的学习，可以快速对各系统模块有个框架性认识，知道各系统职责、边界、如何交互、系统核心模型等等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于设计文档的学习，切不可走马观花，一定要带着问题和思考。&lt;/span&gt;&lt;span&gt;比如项目背景中的核心业务问题，架构师是如何转化成技术落地，方案为什么要这样设计，模型为什么要这样抽象，这样做的好处是什么等等？&lt;/span&gt;&lt;span&gt;同时，对不理解的问题做需好笔记，以便后续向老师或其他同事请教或讨论等等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-lake-id=&quot;ca6fa186228ff7efaa653334195896c8&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;▐  &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;系统熟悉和代码阅读&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过设计文档的学习，对系统设计有整体了解之后，接下来就可以结合业务场景、相关问题去看代码如何实现了。&lt;/span&gt;&lt;span&gt;不过代码阅读，也需要注意方式方法，切不可陷入代码细节，应该自顶向下、分层分模块的阅读，以先整体、后模块、单功能点的方式层层递进。&lt;/span&gt;&lt;span&gt;先快速走读整个代码模块逻辑，然后再精读某个类、方法的实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;代码阅读过程中，建议一边阅读一边整理相关代码模块、流程分支、交互时序，以及类图等，以便更好理解，有些IDE工具也可根据代码自动生成，比如IntelliJ IDEA。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;代码阅读除了关注具体功能的实现之外，更重要的是需要关心代码设计上的思路和原理、性能考究、设计模式、以及设计原则的应用等。&lt;/span&gt;&lt;span&gt;同样，阅读代码注释也非常重要，在研究一个API或方法实现时，先认真阅读代码注释会让你事半功倍，尽可能不要做从代码中反推逻辑和功能的事情。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后，对于核心功能代码建议分模块精读，不明白部分可借助代码调试。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;95401&quot;&gt;&lt;section&gt;&lt;section data-width=&quot;80%&quot;&gt;&lt;img data-ratio=&quot;0.0397489539748954&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/33P2FdAnjuiccUgnPh8mN61ImRu6ibO9SM59BYV8yapap1rP2jHKDKPOlkjlthrHckF0HCk95kNEXxA5OZ0pdfHg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;478&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-lake-id=&quot;05c06dbb9068eb17b0de1659a4a8b3f4&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;然后，对于技术学习这块我给几点个人建议，以供题主参考：&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;05c06dbb9068eb17b0de1659a4a8b3f4&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-lake-id=&quot;ca6fa186228ff7efaa653334195896c8&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;▐  &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;制定学习规划&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;梳理一份适合自己的技术规划，并制定明确的学习路线和计划，让学习更有方向和重点。&lt;/span&gt;&lt;span&gt;同样在视频课程的选择上也会更清晰，知道什么样视频该学、什么不该学，也不容易感到迷茫和空虚。&lt;/span&gt;&lt;span&gt;如今网上各种学习资料、视频汗牛充栋，学会如何筛选有效、适合自己的信息非常重要。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-lake-id=&quot;ca6fa186228ff7efaa653334195896c8&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;▐  &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;思考与练习&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于技术编程，无捷径可言，思考和练习都非常重要，需要不断学习、思考、实践反复操练。&lt;/span&gt;&lt;span&gt;从了解、会用、知原理、优化不断演进。&lt;/span&gt;&lt;span&gt;结合学习计划，可以给自己制定不同挑战，比如学习spring可以尝试自己实现一个ioc容器等等。&lt;/span&gt;&lt;span&gt;另外，工作或学习过程中遇到的问题，也是你快速提升技术能力的一个好方法，也请珍惜你遇到的每个问题的机会。&lt;/span&gt;&lt;span&gt;时间允许的话，也请尽可能去帮助别人解答问题，像stackoverflow就是个非常不错的选择，帮助别人的同时提升自己。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-lake-id=&quot;ca6fa186228ff7efaa653334195896c8&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;▐  &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分享与交流&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;保持思考总结的习惯，将学到的技术多与人分享交流，教学相长。&lt;/span&gt;&lt;span&gt;多与优秀的程序员一起、多参与优秀的开源项目等。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;09da967442c70d45037f2659cea6698c&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;a48a500c0c584df4ed6ba893f6367273&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;最后，我再以我们团队Dubbo核心开发@哲良 大神的另一开源框架&lt;/span&gt;&lt;span&gt;TransmittableThreadLocal(TTL)&lt;/span&gt;&lt;span&gt;为例，来讲解下我们该如何学习和快速掌握一个项目。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;a48a500c0c584df4ed6ba893f6367273&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;95401&quot;&gt;&lt;section&gt;&lt;section data-width=&quot;80%&quot;&gt;&lt;img data-ratio=&quot;0.0397489539748954&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/33P2FdAnjuiccUgnPh8mN61ImRu6ibO9SM59BYV8yapap1rP2jHKDKPOlkjlthrHckF0HCk95kNEXxA5OZ0pdfHg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;478&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-lake-id=&quot;a48a500c0c584df4ed6ba893f6367273&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;结合上文所述，首先我会将TTL项目相关&lt;/span&gt;&lt;span&gt;文档&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;issues列表&lt;/span&gt;&lt;span&gt;认真阅读一遍，让自己对项目能有个大体的认识，并梳理出项目一些关键信息，比如：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-lake-id=&quot;ca6fa186228ff7efaa653334195896c8&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;▐  &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;核心要解决的问题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用于解决「在线程池或线程会被复用情况下，如何解决线程ThreadLocal传值问题」&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-lake-id=&quot;ca6fa186228ff7efaa653334195896c8&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;▐  &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;有哪些典型业务场景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;ul data-lake-id=&quot;4e057aa3f3f41daf9713eb0ef3267447&quot; lake-indent=&quot;1&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;ul data-lake-id=&quot;6fe468b24fe82873984803e438ed802d&quot; lake-indent=&quot;0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;分布式跟踪系统或全链路压测（即链路打标）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;日志收集记录系统上下文&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Session级Cache&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;应用容器或上层框架跨应用代码给下层SDK传递信息&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-lake-id=&quot;ca6fa186228ff7efaa653334195896c8&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;▐  &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;使用到的技术&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有线程、线程池、ThreadLocal、InheritableThreadLocal、并发、线程安全等。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;bd0875b2a4618e003c765b6ba249df1d&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;24c4c6281e9a805fe0f60241983eb6dc&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;然后，再结合使用文档编写几个测试demo，通过程序代码练习和框架使用，一步步加深对框架的理解。比如我这里首先会拿TTL与原生JDK InheritableThreadLocal进行不同比较，体验两者的核心区别。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;ThreadLocalTest&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; final AtomicInteger ID_SEQ = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; AtomicInteger();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; final ExecutorService EXECUTOR = Executors.newFixedThreadPool(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;, r -&amp;gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Thread(r, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;TTL-TEST-&quot;&lt;/span&gt; + ID_SEQ.getAndIncrement()));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; ThreadLocal&amp;lt;String&amp;gt; THREAD_LOCAL = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; InheritableThreadLocal&amp;lt;&amp;gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;testThreadLocal&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;) throws InterruptedException&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            THREAD_LOCAL.&lt;span class=&quot;code-snippet__keyword&quot;&gt;set&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;set-task-init-value&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            Runnable task1 = () -&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    String manTaskCtx = THREAD_LOCAL.&lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;task1:&quot;&lt;/span&gt; + Thread.currentThread() + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;, get ctx:&quot;&lt;/span&gt; + manTaskCtx);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    THREAD_LOCAL.&lt;span class=&quot;code-snippet__keyword&quot;&gt;set&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;task1-set-value&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                } &lt;span class=&quot;code-snippet__keyword&quot;&gt;finally&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    THREAD_LOCAL.&lt;span class=&quot;code-snippet__keyword&quot;&gt;remove&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            };&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            EXECUTOR.submit(task1);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            TimeUnit.SECONDS.sleep(&lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            THREAD_LOCAL.&lt;span class=&quot;code-snippet__keyword&quot;&gt;set&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;main-task-value&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            Runnable task2 = () -&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                String manTaskCtx = THREAD_LOCAL.&lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;task2:&quot;&lt;/span&gt; + Thread.currentThread() + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;, get ctx :&quot;&lt;/span&gt; + manTaskCtx);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            };&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            EXECUTOR.submit(task2);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;span class=&quot;code-snippet__keyword&quot;&gt;finally&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            THREAD_LOCAL.&lt;span class=&quot;code-snippet__keyword&quot;&gt;remove&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;String[] args&lt;/span&gt;) throws InterruptedException&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        testThreadLocal();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;task1:Thread[TTL-TEST&lt;span class=&quot;code-snippet__number&quot;&gt;-0&lt;/span&gt;,&lt;span class=&quot;code-snippet__number&quot;&gt;5&lt;/span&gt;,main], &lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt; ctx:&lt;span class=&quot;code-snippet__keyword&quot;&gt;set&lt;/span&gt;-task-init-&lt;span class=&quot;code-snippet__keyword&quot;&gt;value&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;task2:Thread[TTL-TEST&lt;span class=&quot;code-snippet__number&quot;&gt;-0&lt;/span&gt;,&lt;span class=&quot;code-snippet__number&quot;&gt;5&lt;/span&gt;,main], &lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt; ctx :&lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;task1:Thread[TTL-TEST&lt;span class=&quot;code-snippet__number&quot;&gt;-0&lt;/span&gt;,&lt;span class=&quot;code-snippet__number&quot;&gt;5&lt;/span&gt;,main], &lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt; ctx:&lt;span class=&quot;code-snippet__keyword&quot;&gt;set&lt;/span&gt;-task-init-&lt;span class=&quot;code-snippet__keyword&quot;&gt;value&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;task2:Thread[TTL-TEST&lt;span class=&quot;code-snippet__number&quot;&gt;-0&lt;/span&gt;,&lt;span class=&quot;code-snippet__number&quot;&gt;5&lt;/span&gt;,main], &lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt; ctx :main-task-&lt;span class=&quot;code-snippet__keyword&quot;&gt;value&lt;/span&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-lake-id=&quot;b69de778c03291ab01ba379324c08199&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;通过代码运行结果，我们可以直观看到使用JDK原生InheritableThreadLocal，在task2异步任务中是无法正确获取代码⑵处所设置的上下文参数，只有改用TransmittableThreadLocal之后，程序才如我们预期正常获取。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;3903912d8b56f62d55d0d514ad1dc367&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;70eb0c559a868cd9bb99fea4bf1c6715&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;不难发现，由JDK原生ThreadLocal切换到TransmittableThreadLocal，只需要做极少量的代码适配即可。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; ThreadLocal&amp;lt;String&amp;gt; THREAD_LOCAL = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; TransmittableThreadLocal&amp;lt;&amp;gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;task2 = TtlRunnable.&lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt;(task2);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-lake-id=&quot;5537d42cb37993447800edf6b013bf70&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;相信看到这里我们都会不禁想问，为什么只需要简单的更改两行代码，就可以平滑实现上下文透传？TTL框架背后具体都做了哪些工作，到底是怎么实现的呢？相信你和我一样都会比较好奇，也一定有想立马阅读源码一探究竟的冲动。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;15dd59f9c2decd26f205e5d18f1014f9&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;5b7a8ed07958191ac76642568a3b0584&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;不过，通常这个时候，我并不会一头扎进源码，一般都会先做几项准备工作，一是回到设计文档再仔细的阅读下相关实现方案，把关键流程和原理了解清楚；二是把涉及到的技术体相关的基础知识再复习或学习一遍，以避免由于一些基础知识原理的不了解，导致源码无法深入研究或花费大量精力。像这里如果我对Thread、ThreadLocal、InheritableThreadLocal、线程池等相关知识不熟悉的话，一定会把相关知识先学习一遍，比如ThreadLocal基本原理、底层数据结构、InheritableThreadLocal如何实现父子线程传递等等。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;eab151de7abd09b21972c726d14719ae&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;9e71ca56a918f754c60bea7f879d1bca&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;假设这里你对这些知识都已掌握，如果不熟悉，网上相关介绍文章也早已是汗牛充栋，你搜索学习下即可。这里我们先带着到底如何实现的这个疑问，一起来探究下核心源码实现。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;25df6d09eb63b6dbaf111836abaec5f4&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;440cde2a139b27f1840e26e5046970b5&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;首先把源码clone下来导入IDE，然后结合文档把系统工程结构和各功能模块职责快速熟悉一遍，然后结合文档和Demo找到关键接口和实现类，利用IDE把相关类图结构生成出来，以便快速理解类之间关系。非常不错，TTL整体代码非常精练、命名和包信息描述也都非常规范和清晰，我们可以快速圈出来。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;440cde2a139b27f1840e26e5046970b5&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.2883263009845288&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/33P2FdAnjuiccUgnPh8mN61ImRu6ibO9SMaFibsa2wrdk0fdF1yhA24zhraGvFSoCtzdaPv0uiak8dGiaLFicrPsibQIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2844&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;2aad6cfd374aa6581d76b7572bd81a57&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;从类图中我们可以清晰看到核心关键类TransmittableThreadLocal是从ThreadLocal继承而来，这样的好处是不破坏ThreadLocal原生能力的同时还可增强和扩展自有能力，也可保证业务代码原有互操作性和最小改动。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;e1c588447b51a107bad37c23ed1c2b1c&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;e3ba314eb2145f338d94fcb752cbb4d1&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;然后结合Demo代码，&lt;/span&gt;&lt;span&gt;我们不难发现使用TTL主要有三个步骤，&lt;/span&gt;&lt;span&gt;TransmittableThreadLocal声明、set、remove方法的调用。根据整个使用流程和方法调用栈，&lt;/span&gt;&lt;span&gt;我们也可以很方便梳理出整&lt;/span&gt;&lt;span&gt;个代码处理初始化、调用时序。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;e3ba314eb2145f338d94fcb752cbb4d1&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;b109be6e69722d3b11f502ff8b06b3f0&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;(这里借用官方原图)&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7405446293494705&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/33P2FdAnjuiccUgnPh8mN61ImRu6ibO9SMSstwq2827H8dOAz96EOKCfw8hGFGmymbMkqG4cgEl1s8HeibDKZAtYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2644&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;通过流程图，我们可以清晰看到TTL核心流程和原理是通过TransmittableThreadLocal.Transmitter 抓取当前线程的所有TTL值并在其他线程进行回放，然后在回放线程执行完业务操作后，再恢复为回放线程原来的TTL值。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;186&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;TransmittableThreadLocal.Transmitter提供了所有TTL值的抓取、回放和恢复方法（即CRR操作）： &lt;/p&gt;&lt;p&gt;capture方法：抓取线程（线程A）的所有TTL值。 &lt;/p&gt;&lt;p&gt;replay方法：在另一个线程（线程B）中，回放在capture方法中抓取的TTL值，并返回 回放前TTL值的备份 &lt;/p&gt;&lt;p&gt;restore方法：恢复线程B执行replay方法之前的TTL值（即备份）&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;弄明白核心流程和原理后，我们现在来分析下相关核心代码，在声明TransmittableThreadLocal变量时，我们会发现框架初始化了一个类级别的变量holder用于存储用户设置的所有ttl上下文，也是为了后续执行capture抓取时使用。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; final InheritableThreadLocal&amp;lt;WeakHashMap&amp;lt;TransmittableThreadLocal&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt;, ?&amp;gt;&amp;gt; holder =&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; InheritableThreadLocal&amp;lt;WeakHashMap&amp;lt;TransmittableThreadLocal&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt;, ?&amp;gt;&amp;gt;() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;protected&lt;/span&gt; WeakHashMap&amp;lt;TransmittableThreadLocal&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt;, ?&amp;gt; initialValue() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; WeakHashMap&amp;lt;TransmittableThreadLocal&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt;, &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;protected&lt;/span&gt; WeakHashMap&amp;lt;TransmittableThreadLocal&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt;, ?&amp;gt; childValue(WeakHashMap&amp;lt;TransmittableThreadLocal&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt;, ?&amp;gt; parentValue) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; WeakHashMap&amp;lt;TransmittableThreadLocal&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt;, &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt;(parentValue);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    };&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; final &lt;span class=&quot;code-snippet__built_in&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;set&lt;/span&gt;(T value) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (!disableIgnoreNullValueSemantics &amp;amp;&amp;amp; &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt; == value) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            remove();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;super&lt;/span&gt;.set(value);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            addThisToHolder();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;void&lt;/span&gt; addThisToHolder() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (!holder.get().containsKey(&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            holder.get().put((TransmittableThreadLocal&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;); &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-lake-id=&quot;542aa277f8715430b1a0a6bb0f81be22&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;结合set方法实现来看，我们会发现holder变量设计的非常巧妙，业务设置的上下文value部分继续复用ThreadLocal原有数据结构ThreadLocalMap来存储( super.set(value))；capture的数据源利用holder进行引用存储(addThisToHolder put this)。这样的好处是既可保持ThreadLocal数据存储原有的封装性，又很好实现扩展。除此之外，holder还有其他设计考究，这里抛出来大家可以思考下：&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;542aa277f8715430b1a0a6bb0f81be22&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol data-lake-id=&quot;8637cca786d61530d4a95efa2cf91ca5&quot; start=&quot;1&quot; lake-indent=&quot;0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;为什么holder需要设计成static final类级别变量？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;ttl变量的存储为什么需要使用WeakHashMap，而不是hashmap或其他？&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-lake-id=&quot;cb97a548305ff54d8acdc905391a6387&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;beb2658fc2e41504715607c88e792aa2&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;然后我们再来看异步task转换 TtlRunnable.get(task2) 核心代码实现，代码整体实现相对比较简单，get方法是一个静态工厂方法，主要作用是将业务传入的普通Runnable task装饰成TtlRunable类，并在TtlRunable构造方法中进行线程capture动作(具体实现我们后面再分析)，然后将结果存储到对象属性capturedRef中。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__meta&quot;&gt;@Nullable&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; TtlRunnable &lt;span class=&quot;code-snippet__title&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(@Nullable Runnable runnable, &lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; releaseTtlValueReferenceAfterRun, &lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; idempotent)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt; == runnable) &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (runnable &lt;span class=&quot;code-snippet__keyword&quot;&gt;instanceof&lt;/span&gt; TtlEnhanced) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (idempotent) &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; (TtlRunnable) runnable;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; IllegalStateException(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Already TtlRunnable!&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; TtlRunnable(runnable, releaseTtlValueReferenceAfterRun);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;　　&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;TtlRunnable&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Runnable&lt;/span&gt;, &lt;span class=&quot;code-snippet__title&quot;&gt;TtlWrapper&lt;/span&gt;&amp;lt;&lt;span class=&quot;code-snippet__title&quot;&gt;Runnable&lt;/span&gt;&amp;gt;, &lt;span class=&quot;code-snippet__title&quot;&gt;TtlEnhanced&lt;/span&gt;, &lt;span class=&quot;code-snippet__title&quot;&gt;TtlAttachments&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; AtomicReference&amp;lt;Object&amp;gt; capturedRef;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; Runnable runnable;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; releaseTtlValueReferenceAfterRun;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;TtlRunnable&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(@NonNull Runnable runnable, &lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; releaseTtlValueReferenceAfterRun)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;.capturedRef = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; AtomicReference&amp;lt;Object&amp;gt;(capture());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;.runnable = runnable;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;.releaseTtlValueReferenceAfterRun = releaseTtlValueReferenceAfterRun;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; Object captured = capturedRef.get();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (captured == &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt; || releaseTtlValueReferenceAfterRun &amp;amp;&amp;amp; !capturedRef.compareAndSet(captured, &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt;)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; IllegalStateException(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;TTL value reference is released after run!&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; Object backup = replay(captured);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            runnable.run();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;finally&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            restore(backup);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }　&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; 　&lt;span class=&quot;code-snippet__comment&quot;&gt;//........   &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; ｝&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p data-lake-id=&quot;f695b16e952984b11d9315ccf0653674&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;然后是run方法，这也是核心关键的CRR操作了。这里通过模板方法将CRR操作编排在业务逻辑执行的前后了，也即业务逻辑执行前会将capturer的值进行replay恢复，执行后进行复原restore操作。同样这里也有几个问题很值我们思考：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;f695b16e952984b11d9315ccf0653674&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol data-lake-id=&quot;5f1473e039fcb2576bb851eadb6b4c29&quot; start=&quot;1&quot; lake-indent=&quot;0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;capture操作为什么需要放到TtlRunnable构造方法中，而不能在run方法中？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;代码中使用了哪两个设计模式，使用设计模式的好处是什么？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;业务执行完之后为什么还需要restore操作？&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-lake-id=&quot;bec1cba666e1efb630fc42ee645314e6&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;29c06b31f2667ec84e5c57d1764869e9&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;接下来，我们再分别对capture、replay、restore方法实现做个一一分析。首先是capture方法，我们可以看到capture操作整体比较简单，主要是将set操作保存到holder变量中的值进行遍历并以Snapshot结构进行存储返回。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;         * Capture all {@link TransmittableThreadLocal} and registered {@link ThreadLocal} values in the current thread.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;         *&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;         * @return the captured {@link TransmittableThreadLocal} values&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;         * @since 2.3.0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;         */&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__meta&quot;&gt;@NonNull&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt; capture() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Snapshot(captureTtlValues(), captureThreadLocalValues());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; HashMap&amp;lt;TransmittableThreadLocal&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt;, &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt; captureTtlValues() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            HashMap&amp;lt;TransmittableThreadLocal&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt;, &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt; ttl2Value = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;TransmittableThreadLocal&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt;, &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (TransmittableThreadLocal&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt; threadLocal : holder.get().keySet()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                ttl2Value.put(threadLocal, threadLocal.copyValue());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; ttl2Value;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; HashMap&amp;lt;ThreadLocal&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt;, &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt; captureThreadLocalValues() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            final HashMap&amp;lt;ThreadLocal&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt;, &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt; threadLocal2Value = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;ThreadLocal&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt;, &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (Map.Entry&amp;lt;ThreadLocal&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt;, TtlCopier&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt;&amp;gt; entry : threadLocalHolder.entrySet()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                final ThreadLocal&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt; threadLocal = entry.getKey();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                final TtlCopier&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt; copier = entry.getValue();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                threadLocal2Value.put(threadLocal, copier.copy(threadLocal.get()));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; threadLocal2Value;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另一个captureThreadLocalValues，主要是用于将一些已有ThreadLocal中的上下文一起复制，已有ThreadLocal需要通过registerThreadLocal方法来单独注册。相关代码如下&lt;/span&gt;：&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; Transmitter {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__comment&quot;&gt;//....&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; volatile WeakHashMap&amp;lt;ThreadLocal&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt;, TtlCopier&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt;&amp;gt; threadLocalHolder = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; WeakHashMap&amp;lt;ThreadLocal&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt;, TtlCopier&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt;&amp;gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; final &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt; threadLocalHolderUpdateLock = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__comment&quot;&gt;//......&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;boolean&lt;/span&gt; registerThreadLocal(&lt;span class=&quot;code-snippet__meta&quot;&gt;@NonNull&lt;/span&gt; ThreadLocal&amp;lt;T&amp;gt; threadLocal, &lt;span class=&quot;code-snippet__meta&quot;&gt;@NonNull&lt;/span&gt; TtlCopier&amp;lt;T&amp;gt; copier, &lt;span class=&quot;code-snippet__built_in&quot;&gt;boolean&lt;/span&gt; force) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (threadLocal &lt;span class=&quot;code-snippet__keyword&quot;&gt;instanceof&lt;/span&gt; TransmittableThreadLocal) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            logger.warning(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;register a TransmittableThreadLocal instance, this is unnecessary!&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        synchronized (threadLocalHolderUpdateLock) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (!force &amp;amp;&amp;amp; threadLocalHolder.containsKey(threadLocal)) &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            WeakHashMap&amp;lt;ThreadLocal&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt;, TtlCopier&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt;&amp;gt; newHolder = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; WeakHashMap&amp;lt;ThreadLocal&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt;, TtlCopier&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt;&amp;gt;(threadLocalHolder);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            newHolder.put((ThreadLocal&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt;) threadLocal, (TtlCopier&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt;) copier);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            threadLocalHolder = newHolder;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__comment&quot;&gt;//......&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这里代码有个非常关键的处理，由于WeakHashMap非线程安全，为了避免并发问题安全加上了synchronized锁操作。这里有可以思考下除了synchronized关键字还有什么保障线程安全的方法。另外，实现threadLocal注册时为已经在锁块中了，为什么还要做new copy重新替换操作，这样做目的是什么？大家可以想想看。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p data-lake-id=&quot;5d1bed666144b50936b724f9272fa579&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;eccf9ab1c4b81f8edb320605b42f853d&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;最后就是replay和restore方法，整体实现逻辑非常清晰，主要是将captured的值在当前线程ThreadLocal中进行重新赋值初始化，以及业务执行后恢复到原来。这里很佩服作者对不同情况的细致考虑，不是直接将当前holder中的上下文直接备份，而是与之前已capture的内容比较，将业务后set的上下文进行剔除，以免在恢复restore时出现前后不一致的情况。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;eccf9ab1c4b81f8edb320605b42f853d&quot; data-wording=&quot;true&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@NonNull&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt; replay(&lt;span class=&quot;code-snippet__meta&quot;&gt;@NonNull&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt; captured) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    final Snapshot capturedSnapshot = (Snapshot) captured;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Snapshot(replayTtlValues(capturedSnapshot.ttl2Value), replayThreadLocalValues(capturedSnapshot.threadLocal2Value));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@NonNull&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; HashMap&amp;lt;TransmittableThreadLocal&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt;, &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt; replayTtlValues(&lt;span class=&quot;code-snippet__meta&quot;&gt;@NonNull&lt;/span&gt; HashMap&amp;lt;TransmittableThreadLocal&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt;, &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt; captured) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    HashMap&amp;lt;TransmittableThreadLocal&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt;, &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt; backup = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;TransmittableThreadLocal&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt;, &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (final Iterator&amp;lt;TransmittableThreadLocal&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt;&amp;gt; iterator = holder.get().keySet().iterator(); iterator.hasNext(); ) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        TransmittableThreadLocal&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt; threadLocal = iterator.next();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// backup&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        backup.put(threadLocal, threadLocal.get());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// clear the TTL values that is not in captured&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// avoid the extra TTL values after replay when run task&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (!captured.containsKey(threadLocal)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            iterator.remove();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            threadLocal.superRemove();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__comment&quot;&gt;// set TTL values to captured&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    setTtlValuesTo(captured);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__comment&quot;&gt;// call beforeExecute callback&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    doExecuteCallback(&lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; backup;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;void&lt;/span&gt; setTtlValuesTo(&lt;span class=&quot;code-snippet__meta&quot;&gt;@NonNull&lt;/span&gt; HashMap&amp;lt;TransmittableThreadLocal&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt;, &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt; ttlValues) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (Map.Entry&amp;lt;TransmittableThreadLocal&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt;, &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt; entry : ttlValues.entrySet()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        TransmittableThreadLocal&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt; threadLocal = entry.getKey();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        threadLocal.set(entry.getValue());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;void&lt;/span&gt; restore(&lt;span class=&quot;code-snippet__meta&quot;&gt;@NonNull&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt; backup) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    final Snapshot backupSnapshot = (Snapshot) backup;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    restoreTtlValues(backupSnapshot.ttl2Value);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    restoreThreadLocalValues(backupSnapshot.threadLocal2Value);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;void&lt;/span&gt; restoreTtlValues(&lt;span class=&quot;code-snippet__meta&quot;&gt;@NonNull&lt;/span&gt; HashMap&amp;lt;TransmittableThreadLocal&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt;, &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt; backup) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__comment&quot;&gt;// call afterExecute callback&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    doExecuteCallback(&lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (final Iterator&amp;lt;TransmittableThreadLocal&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt;&amp;gt; iterator = holder.get().keySet().iterator(); iterator.hasNext(); ) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        TransmittableThreadLocal&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt; threadLocal = iterator.next();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// clear the TTL values that is not in backup&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// avoid the extra TTL values after restore&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (!backup.containsKey(threadLocal)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            iterator.remove();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            threadLocal.superRemove();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__comment&quot;&gt;// restore TTL values&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    setTtlValuesTo(backup);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-lake-id=&quot;eccf9ab1c4b81f8edb320605b42f853d&quot; data-wording=&quot;true&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;8a9a614e7b8aa959c53569ef71f444a4&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;核心代码分析完之后，再来简单总结下项目中学习到的知识点：&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;8a9a614e7b8aa959c53569ef71f444a4&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol data-lake-id=&quot;6343d6400492f93f8b4cdc537f4d7154&quot; start=&quot;1&quot; lake-indent=&quot;0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对ThreadLocal、InheritableThreadLocal有了更加系统和深入的理解，包括两者继承关系、底层数据结构ThreadLocalMap与Thread关联关系等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;面向gc编程(gc相关)、WeakHashMap(Java对象引用类型强、软、弱等)、线程安全、并发等等&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;设计模式相关，装饰模式、工厂、模板方法、代理等&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;TTL虽然代码量不算多，但短小精悍，也处处体现了作者超高的设计和编程能力，每行代码都值得学习和反复琢磨。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-lake-id=&quot;b4e7598e524c61c5210e1bd24ffd9fea&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;我相信通过类似这样的一个项目学习流程下来，把每个环节都能踏踏实实做好，且过程中有贯穿自己思考和理解。相信你一定能把每个项目吃透，并把项目中的每个技术点都牢牢掌握。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;623ceb5bd6b465859e31e27c9383da20&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;3dac5874d686ae3c54c21c694b702ab7&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;最后，我所在团队是淘系技术部淘系架构团队，主要在负责一站式serverless研发平台建设，为业务不断提升研发效率和极致体验。平台已平稳支撑淘系互动、淘宝人生、金币庄园、特价版、闲鱼、拍卖、品牌轻店等多个业务的6.18、双11、双12、春晚等多个大促活动。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;  阿里巴巴集团淘系技术部招聘啦~  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;欢迎加入淘系架&lt;/span&gt;&lt;span&gt;构团队，团队成员大牛云集，有阿里移动中间件的创始人员、Dubbo核心成员、更有一群热爱技术，期望用技术推动业务的小伙伴。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;f779404ce7c3882dd541a09432741303&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;f779404ce7c3882dd541a09432741303&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;淘系架构团队，推进淘系（淘宝、天猫等）架构升级，致力于为淘系、整个集团提供基础核心能力、产品与解决方案：&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;f779404ce7c3882dd541a09432741303&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-lake-id=&quot;38db22bc8a7b2fc66d84c8fd1ff68bbe&quot; lake-indent=&quot;0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;业务高可用的解决方案与核心能力（精细化流量管控Marconi平台：为业务提供自适应流控、隔离与熔断的柔性高可用解决方案，站点高可用：故障自愈、多机房与异地容灾与快速切流恢复&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;一站式serverless研发平台GAIA，为业务提供高效研发效率和极致体验。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;下一代网络协议QUIC实现与落地&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;移动中间件（API网关MTop、接入层AServer、消息/推送、配置中心等等）&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-lake-id=&quot;276336dfe0598e6708c16f7135f3a9c7&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;期待一起参与加入淘系基础平台的建设~&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;67cb9ddab766585a196f5e905a36e2de&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;1185f002863ed61a11e4ff950d20913a&quot; data-wording=&quot;true&quot;&gt;&lt;span&gt;简历投递至少千&lt;span&gt;📮 &lt;/span&gt;&lt;span&gt;：&lt;/span&gt;zhiheng.gao@alibaba-inc.com&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;✿ &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt;拓展阅读&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&amp;amp;mid=2650423937&amp;amp;idx=1&amp;amp;sn=3f7dddabb1f4775b17c1237518e33cad&amp;amp;chksm=83968a99b4e1038f81e5fed1f27e2aa91b3c6d865b6360b2f80dce54fd3d9ab302c01b2003d5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot; hasload=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;103&quot; data-backw=&quot;578&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;103&quot; data-ratio=&quot;0.179&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1000&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/33P2FdAnju9I4FcCLVbcs5JicK2GFwSG5rR1x7yOefNxxIzibPaoX4jWxlibWTuhFmyXJS10ia8KiaalB1cwB7AugdA/640?wx_fmt=jpeg&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&amp;amp;mid=2650423868&amp;amp;idx=1&amp;amp;sn=b5215326020d4296c8caf0fa8293d110&amp;amp;chksm=83968a24b4e10332302eec4e21da4ad17d334c80a3fa4b2e0674cce9bfdae6da3c4b01dc49dd&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot; hasload=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;103&quot; data-backw=&quot;578&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;103&quot; data-ratio=&quot;0.179&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1000&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/33P2FdAnju9I4FcCLVbcs5JicK2GFwSG5P2F0tuldiaQB7btj8LYJz6H5AZJaDlVQA0iaRfkzg1GQdnd628BeRNyA/640?wx_fmt=jpeg&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&amp;amp;mid=2650423936&amp;amp;idx=1&amp;amp;sn=cec85496cb16c867594ceb8880e75f99&amp;amp;chksm=83968a98b4e1038e0c0df410d7a0b1f96f2280a9efa42489f513f30188c4552bee899e10316a&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot; hasload=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;103&quot; data-backw=&quot;578&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;105&quot; data-ratio=&quot;0.179&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1000&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/33P2FdAnju9I4FcCLVbcs5JicK2GFwSG5x962XZiaC2iacDWrMIibTXGTKA1lwlzSs9K91kwolJzwWvBzZFnDAopbw/640?wx_fmt=jpeg&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;作者&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;少千&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;编辑|&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;橙子君&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;出品|&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;阿里巴巴新零售淘系技术&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;331&quot; data-backw=&quot;578&quot; data-croporisrc=&quot;https://mmbiz.qlogo.cn/mmbiz_png/33P2FdAnju9qJSYLusYZ20IeW1JcwLxOiboFmk6AE4WC0UFUU2MfXQS9E9ibVUdVZoMpic6wE97ylUl6r4olNpDow/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;720&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;412.318339100346&quot; data-ratio=&quot;0.5722222222222222&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;720&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/33P2FdAnju9qJSYLusYZ20IeW1JcwLxOmYpQKzz1XI7PlgmOA3cPARTxwZuKFw6osZsksibeH7HrS9oiaVooQSZQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;94&quot; data-backw=&quot;562&quot; data-ratio=&quot;0.16666666666666666&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;900&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/33P2FdAnju9I3TY9EP8M3D7oDuMfTuEh37yxribyjc3viaicCKBT9nJhqBcib36SSRaib3vIobcZbx93RYyf9QvgzOA/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>