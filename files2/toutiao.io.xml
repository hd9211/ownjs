<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>5acb5b3a0eb34a9be87037a986019a4a</guid>
<title>总结篇：消息中间件MQ的学习境界和路线</title>
<link>https://toutiao.io/k/papwbgk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486853&amp;amp;idx=1&amp;amp;sn=5af0c8abed9b589d2b221bce92a76dd8&amp;amp;chksm=fafde72bcd8a6e3db14d1d76333954d3efbd8b6b5a204e192bf342e8327e9e3c9dc4cf93bbd4&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《深入理解Java类加载机制，再也不用死记硬背了》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《深入理解Java类加载机制，再也不用死记硬背了》&lt;/a&gt;里我提到了对于一门语言&lt;span&gt;的“会”的三个层次。本篇将以知识地图的形式展现学习消息中间件MQ各个层次要掌握的内容。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;知识地图是一种知识导航系统，并显示不同的知识存储之间重要的动态联系。所以本篇重点不是介绍某个知识点，而是介绍掌握消息中间件，需要看哪些文章的导航。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;消息中间件MQ会的三个层次与黄金圈法则相对应。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.51875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRl9CicyXFGJtfsKWUkaiaN9bYu7EAIn48vDjBxL1TEN4zeDApQ0sFrH8NRFkRy99YW7ZjphvXF4jzZmw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;What层：hello world 级别&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;What层：hello&lt;/span&gt; world 级别，知道它能做什么。在&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485843&amp;amp;idx=1&amp;amp;sn=ae07db807669699bc4bec807aa468a5c&amp;amp;chksm=fafde33dcd8a6a2b8a34483bc61771c3cf99a49a7baf46e47e770c58372808e2053f27a203e1&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《RabbitMQ设计原理解析》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《RabbitMQ设计原理解析》&lt;/span&gt;&lt;/a&gt;&lt;span&gt;里详细介绍过，这里再讲一遍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;MQ的主要作用有三个：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、异步处理&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;示例一：在&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485991&amp;amp;idx=1&amp;amp;sn=98d17273c84eefb4a4ad23f749bedb4a&amp;amp;chksm=fafde089cd8a699f12ff60689f73e9ef8a189f3dc2dd36031ea27936863038685125ca0467f1&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《架构师三大难-领域划分问题》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;《架构师三大难-领域划分问题》&lt;/span&gt;&lt;/a&gt;&lt;span&gt;的示例三(异步处理模式)里，我用退款做示例讲了MQ用作异步处理的场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;示例二：还有一个典型的MQ的异步处理场景是日志采集。我所知道的公司，日志集中采集用的都是kafka。业务开发人员只需要专注自己的业务逻辑，将日志打印到磁盘上，kafka会异步的采集到日志服务器。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;示例三：&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486732&amp;amp;idx=1&amp;amp;sn=523d754d7944be46985d098c82f79af2&amp;amp;chksm=fafde7a2cd8a6eb47d6145a8538b907b8b118b09ddb530cd57ba80feaa7b539559279debe893&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;分布式事务&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;分布式事务&lt;/span&gt;&lt;/a&gt;&lt;span&gt;中有一种常用的一致性解决方案：异步确保型解决方案。这个常用的就是基于MQ来实现。在&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247484050&amp;amp;idx=1&amp;amp;sn=3e03ec648d7eebf88b5c857ab487c8dd&amp;amp;chksm=fafde83ccd8a612ac896c3e6176907d78f368a87db5cbface1a74736af72a3a1ca491293bd81&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《服务设计要解决的问题》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《服务设计要解决的问题》&lt;/span&gt;&lt;/a&gt;&lt;span&gt;里有这种场景的说明。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、应用解耦&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;示例二：我在写文章过程中，意识到自己遇到的场景可能和大家自己工作中的认知有一定距离，所以我写了尤娜系列。事实上，由于自己写文章时，都会对文章的论点进行验证，所以尤娜是我几年前开源的一个项目名&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;https://github.com/xiexiaojing/yuna&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;【编程一生】公众号的文章&lt;/span&gt;代码片段很多都能在上面找到。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486894&amp;amp;idx=1&amp;amp;sn=344b221975495bc6e4a2246fe3e0a848&amp;amp;chksm=fafde700cd8a6e16e06e78397e2eb2e229d60335d9a8760072eff23f86fc1a88c1748a271f41&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《尤娜系统的第一次飞行中换引擎的架构垂直拆分改造》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《尤娜系统的第一次飞行中换引擎的架构垂直拆分改造》&lt;/span&gt;&lt;/a&gt;&lt;span&gt;这篇文章就以故事的形式展示了使用MQ做应用拆分的业务背景及整个过程。由于咱们用户群(可加我微信 brmayi 注明：入群)里反馈文章中没有明确使用的拆分方法论，我补充了方法论篇：&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486924&amp;amp;idx=1&amp;amp;sn=99516d226d297fe1a19d9ee252d7672d&amp;amp;chksm=fafde762cd8a6e74f295ce70bed5d4cc4712688d9826bb1e70c251fff1a5757a0633e8244846&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《四种常用的微服务架构拆分方式》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《四种常用的微服务架构拆分方式》&lt;/span&gt;&lt;/a&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、流量削峰&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;&lt;span&gt;示例一：&lt;/span&gt;在&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486865&amp;amp;idx=1&amp;amp;sn=f9987cfa6e08a58f2076ce7a26bd689f&amp;amp;chksm=fafde73fcd8a6e294be3adff01c8b5d9149b4340899d70c48607d94c16691c8fa976938ecbf2&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《从前，有一个简单的通道系统叫尤娜……》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《从前，有一个简单的通道系统叫尤娜……》&lt;/span&gt;&lt;/a&gt;&lt;span&gt;这篇文章中，尤娜系统遇到的就是需要进行请求的削峰填谷。流量削峰我在&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485632&amp;amp;idx=1&amp;amp;sn=509f46446297501ed725d3938360b21f&amp;amp;chksm=fafde26ecd8a6b7812052c291fb0be2c8f6406a3564a331c9133c096795abafcb6422e802e2c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《四种缓存的避坑总结》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《四种缓存的避坑总结》&lt;/span&gt;&lt;/a&gt;&lt;span&gt;里有明确写道这是稳定性保障的一个重要举措，尤娜文章中大家也应该能感受到吧！&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;How层：应用级别&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;How层：应用级别，知道怎么用MQ来实现功能。&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247484948&amp;amp;idx=1&amp;amp;sn=5e5e32ebde19bfb3803e697b6ddf4ef4&amp;amp;chksm=fafdecbacd8a65ac45ac2fabfbba02c70a9ea556e4449991b55a3cd3d9223c636af5f1edd947&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《应用角度看kafka的术语和功能》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《&lt;/span&gt;应用角度看kafka的术语和功能&lt;span&gt;》&lt;/span&gt;&lt;/a&gt;&lt;span&gt;这篇文章里介绍了要达到这一层级所需的知识点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这一层其实在网上能找到的资料最多，实际上就像开头黄金圈的图里画的：也最浅。想在简历上“掌握”，还要进入下一层。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Why层：掌握级别&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Why层：掌握级别，理解原理，遇到问题可以深入剖析到本质。想达到这一层，需要很多相关领域的知识。只要面试者水平不是太差，一般面试官都会问到这一层，以达到了解面试者综合能力的目的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;示例一：&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485702&amp;amp;idx=1&amp;amp;sn=79563d2f2d6a3e38d19459286ac26a6f&amp;amp;chksm=fafde3a8cd8a6abeec857f877d8c1353f2d959871c1634bf138103a7117abd9d5598d4b7ab84&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《Kafka生产端实际项目中的使用分析》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《&lt;/span&gt;Kafka生产端实际项目中的使用分析&lt;span&gt;》&lt;/span&gt;&lt;/a&gt;&lt;span&gt;里提到了给kafka加代理和使用加密kafka的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;示例二：&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247484140&amp;amp;idx=1&amp;amp;sn=1f16a6f7e564f85df87e5ab0ccc17d35&amp;amp;chksm=fafde842cd8a615433874385e62d9422f5fbe735b1c216199354689e27b6a22837338affe4c8&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《架构视角-文件的通用存储原理》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《&lt;span&gt;架构视角-文件的通用存储原理》&lt;/span&gt;&lt;/a&gt;&lt;span&gt;里把Kafka、Redis、关系型数据库、搜索引擎的存储拿出来对比，探讨了存储原理的本质问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;示例三：&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485297&amp;amp;idx=1&amp;amp;sn=e7882369e07e8a1e6d3b4cc7f89e087e&amp;amp;chksm=fafdeddfcd8a64c90c1915187ba1a6d4ae013b5f0ccedf68459b88585c022cb26420a3d91f7c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《稳定性五件套-限流的原理和实现》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《&lt;/span&gt;稳定性五件套-限流的原理和实现》&lt;/a&gt;从算法层面来探讨底层原理。&lt;/p&gt;&lt;h1&gt;&lt;br/&gt;&lt;/h1&gt;&lt;p&gt;示例四：&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485756&amp;amp;idx=1&amp;amp;sn=36600cc4a62d3366b8fa1796a1077061&amp;amp;chksm=fafde392cd8a6a84fc1219260710860c528f0e1cd29e6ac4662eab170de732aa862a23e13687&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《避免线上故障的10条建议》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《避免线上故障的10条建议》&lt;/a&gt;里讨论了使用MQ的风险和规避措施。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;br/&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;咱们用户群(可加我微信 brmayi 注明：入群)里讨论的问题，我喜欢看不发表评论。在大家的讨论中，我其实可以收集很多的问题和大家的关注点。一两句话太浅，我通常会写文章来集中回答大家可能遇到的问题。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;本篇也是咱们用户朋友的提醒：“观察到知识点是承上启下的,是否可以搞一个目录,当连载小说看”。我隔一段时间会做一期&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486616&amp;amp;idx=2&amp;amp;sn=71e9e7f11e688fbc105af9702e721396&amp;amp;chksm=fafde636cd8a6f2047382bc0adb79850d560c58bcc988d103c01d42aadb6322a90965e701c61&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《历史文章分类汇总》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《历史文章分类汇总》&lt;/a&gt;，但是这种分类的方法，文章之间的逻辑关系并不强。正好这篇文章可以顺便介绍一下知识地图这种逻辑关系，作为方法论的介绍。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;最后解释一下黄金圈法则：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;西蒙·斯涅克在他的《从“为什么”开始》一书中提出了“黄金圈法则”的概念。他发现，人们一般向别人表达或者激励时，常规路径是：先现象，而后措施，最后是结果，这种路径收效甚微。而真正能动人心的路径应该是：先理念，而后措施，再到现象，最后是结果。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;有朋友大概听过这个名言：people don&#x27;t buy what you do，they buy why you do it。大意是：人们买的不是你的产品而是你的理念。理念才是核心。掌握一个知识技能也是一样，只有掌握到Why这个层次，才能形成核心竞争力。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;因为公众号平台更改了推送规则，如果不想错过内容，记得读完点一下“在看”，加个“星标”，这样每次新文章推送才会第一时间出现在你的订阅列表里。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486113&amp;amp;idx=1&amp;amp;sn=f3623b2cf257aa37ea83768fd4325762&amp;amp;chksm=fafde00fcd8a691928c66f7e484ab2b7f6fa7797dc32833a7f777bb4ebde58c010750f13c118&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;PDCA方法论&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;PDCA方法论&lt;/a&gt;，检查自己是否错过更新：每周三晚上8点左右，我都会更新文章，如果你没有收到，记得点开【编程一生】公众号找一下(*^▽^*)&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>830dc1ad8fd06210250c98595aedaeab</guid>
<title>20多个好用的 Vue 组件库，请查收！</title>
<link>https://toutiao.io/k/sskayyw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzIwNDMyMTg4Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/wIDSOebZK4NvWoUN1gSpNiaxwF4VLvroSV4fibB1a5iaLEaR23sVIW9ickg4StvsXlxnPpslKAltA6mvJUhkT2PsaA/0?wx_fmt=png&quot; data-nickname=&quot;JavaScript 每日一练&quot; data-alias=&quot;&quot; data-signature=&quot;每天一道JavaScript 实战题，让大家平时多多积累实用的知识，提高开发效率，才有更多的时间摸鱼。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本文中，我们将探讨一些最常见的vue js组件。你可以收藏一波。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Vue Tables-2&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5614754098360656&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LDPLltmNy570PPS4TCaan3wbNfWlvuP3QxZy8rk0mcjPYjKbeghChdy9CF3xPXsykibOOQuWHbzZR160x6UWSng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;地址：https://github.com/matfish2/vue-tables-2&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Vue Tables 2旨在为开发者提供一个功能齐全的工具集，以便用 Vue 创建漂亮而实用的数据表格。数百个商业软件应用正在使用它。此外，Vue Tables 2正在不断成长、改进，同时也在获得新的功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;特点&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;可选行及粘性头部&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;虚拟分页&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;下载客户组件数据的CSV&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有数据层支持的多级分组&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Tailwind 主题&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Handsontable&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7144808743169399&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LDPLltmNy570PPS4TCaan3wbNfWlvuP3XCTSgjDOCe4xMCY1cHTuTGr8YVibdp3ibkAd3muLGQe1gAXhAOyxhc6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;地址：https://github.com/handsontable/handsontable/tree/master/wrappers/vue&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;handsontable是一款页面端的表格交互插件，可以通过它加载显示表格内容，能够支持合并项、统计、行列拖动等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时，支持对加载后的表格页面的处理：添加/删除行/列，合并单元格等操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，它还适用于React、Angular和Vue。Handsontable 是一个JavaScript组件，它将数据网格功能与电子表格的用户体验相结合。此外，它还提供数据绑定、数据验证、过滤、排序和CRUD操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;特点&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;多列排序&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;非连续选择&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;过滤数据和验证数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;导出文件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有条件的格式化&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;合并单元格&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;隐藏行/列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;上下文菜单和注释&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Ag Grid Vue&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5614754098360656&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LDPLltmNy570PPS4TCaan3wbNfWlvuP3vIdfOT8YIibdspDQYJbWAAFo2bJMLIkHKXoWclsiahMsjO6CDC9Z2gUw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;地址：https://github.com/ag-grid/ag-grid&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Ag-Grid 是一个基于Vue.js的数据表格组件。其中，“ag” 表示 “agnostic”。内部 ag-Grid引擎是在TypeScript中实现的，零依赖关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ag-Grid通过包装器组件支持Vue，你可以在应用程序中，就像其他任何Vue组件一样使用ag-Grid。它支持通过属性绑定传递配置，通过事件绑定来处理事件。你甚至可以使用Vue组件来自定义网格UI和单元格内容/行为。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Vue Easytable&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5614754098360656&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LDPLltmNy570PPS4TCaan3wbNfWlvuP36ufC9BugW3hCeEpXLS9A7IoI5XibvFnus2LQS03YM1HJVY6xEdWxRIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;地址：https://github.com/huangshuwei/vue-easytable&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;vue-easytable是我遇到过的最强大的Vue表格组件之一。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;表格组件具有许多内置功能，比如说，单元格省略号、固定/灵活的列大小调整、自定义过滤等等。它有几个特点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;国际化&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主题定制&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内置主题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;虚拟滚动&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;列固定&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;表头固定&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;表头分组&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Vue Good Table&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5614754098360656&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LDPLltmNy570PPS4TCaan3wbNfWlvuP3pXvEG9L7B4MXUyqorbWvziavbTXpcJxUHTSPDyfqUibpLFYWgGibyohxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;地址：https://github.com/xaksis/vue-good-table&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Vue-Good-Table是一个基于Vue.js的数据表组件，简单、干净，具有排序、列过滤、分页等更多基本功能。它有几个特性：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;表搜索和排序&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;列过滤和分页&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;复选框表格&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;行分组&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;行样式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;行多选&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Vue Toastification&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5614754098360656&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LDPLltmNy570PPS4TCaan3wbNfWlvuP3pAibBsPuM0SxmrAYyHtW9gux1WKcdicDXpft6uMdsZiaIKHjCianZlqmYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;地址：https://github.com/Maronato/vue-toastification&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它提供轻巧、简单和漂亮的吐司提示。它有内置的Nuxt支持。而且，它还支持新的Composition API和Vue 3。我们还可以J使用SX来开发自定义组件，提供更加灵活的功能。另外，通用注册允许它在任何应用程序内使用，甚至是React。它有几点特性：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;完全用Typescript编写，支持所有类型&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持RTL&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;定制一切&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;滑动关闭&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用onClose、onClick和onMounted钩子创建自定义体验&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;以编程方式删除和更新吐司&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;Vue Toasted&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;地址：https://github.com/shakee93/vue-toasted&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5614754098360656&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LDPLltmNy570PPS4TCaan3wbNfWlvuP3aY8zo2sSYhpdib60uwdHeRmVJ5LEP4tVmhC6O21NHGUWwF24gq9E4ug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Vue Toasted是 Vue 最好的toast(提示)插件之一。它被Vue，Laravel，NuxtJS 等许多组织所信任，它响应性强，兼容性好，使用方便，吸引人，有丰富的功能、图标、动作等。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Vue Notifications&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5614754098360656&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LDPLltmNy570PPS4TCaan3wbNfWlvuP3TY0j4iazLaK0f5BNCM15AWpgBJ0UlCHPYGhLw3UyB0AuCnh1CtUwlvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;地址：https://github.com/se-panfilov/vue-notifications&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Vue Notifications是一个与库无关的通知组件，非阻塞。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;VueNotiments将您的应用程序与通知UI库连接起来。支持miniToastr、VueToasted、VueEasyToast、toastr、iziToast、Noty、swal。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Vue Awesome Notifications&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5614754098360656&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LDPLltmNy570PPS4TCaan3wbNfWlvuP3Qo3gFrz9dzQhFxz4EOrOmXWXLvmJQY7zVh7A73XuJibBv2iawDicFaHWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;地址：https://f3oall.github.io/awesome-notifications/&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Awesome Notifications是一个轻量级的，完全可自定义的JavaScrip Vue Awesome Notifications，它是Awesome Notifications库的Vue.js版本。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Vue Wait&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5614754098360656&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LDPLltmNy570PPS4TCaan3wbNfWlvuP3rsGRAlj8A8Ohhy8eo9CYgZTr0oS6q47cRGKGNCjG14rhYzJGibpCn5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;地址：https://github.com/f/vue-wait&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Vue Wait 这是一个用于VUE、Vuex和Nuxt应用的复杂装载器和进度管理组件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Vue Wait帮助管理页面上的多个加载状态，状态之间没有任何冲突。基于一个非常简单的想法：通过管理具有多个加载状态的数组(或者Vuex存储)，让内置加载程序组件侦听注册的加载程序，并立即进入加载状态。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Vue Content Loader&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;地址：https://github.com/egoist/vue-content-loader&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5614754098360656&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LDPLltmNy570PPS4TCaan3wbNfWlvuP3gc8qgm794eVTNhSh1m4FbfVic1gtWdkicrsIdaywNUcMHVDSKBnL5RPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Vue Content Loader是一个基于Vue.js的SVG占位符加载，可自定义的SVG组件，用于创建占位符加载，例如Facebook加载卡。Vue Content Loader是react-content-loader的Vue实现。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;完全可定制：你可以改变颜色，速度和大小&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;创建自己的加载：使用在线工具轻松创建你的自定义加载&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你现在就可以使用它：已经有很多预设了&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;性能&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Epic Spinners&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5614754098360656&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LDPLltmNy570PPS4TCaan3wbNfWlvuP3LzEyJF0j9Yz80zwebMfxKRTCaM4rFFvib86QkFBF3BZruFm6l4nbFTQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;地址：https://epic-spinners.epicmax.co/&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;EpicSpinners是一组易于使用的纯css打造的网页Loading效果，并且同时整合了Vue组件可以方便的在Vue项目中进行使用，由于是纯css打造，你可以在任意网页项目中自行整合并使用！&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;Vue Radial Progress&lt;/h4&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5614754098360656&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LDPLltmNy570PPS4TCaan3wbNfWlvuP3FiaflM8iaULnGDwxJo52ghSCuv7IZy4Q9m4jTJVjbicwSz5blHSO3o2IA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;地址：https://github.com/wyzant-dev/vue-radial-progress&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Vue Radial Progress 这是一个径向进度条效果的加载器组件，使用svg和javascript绘制带有渐变径向进度条效果的加载器，可以用作加载、进度提示。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;ICONS&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Vue Feather Icons&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;地址：https://github.com/egoist/vue-feather-icons&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5614754098360656&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LDPLltmNy570PPS4TCaan3wbNfWlvuP3gyO4frJmOgmeXRhykmVfpSp0awhoxlWZDjts4eqiaOEIJpvX5AyOzlg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Feather 是一套面向设计师和开发者的开源图标库，是一个简单漂亮的开源图标库。每个图标都设计在一个24×24的网格上，强调简单，一致性和易读性。很多大厂出品的前端框架都内置了这款可以免费商用的图标。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;特点&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;每一枚图标都是按照统一标准进行设计，具有完美像素对齐；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设计风格一致，完胜那些拼凑混搭的图标库；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;覆盖多种开发场景的支持，对开发者非常友好。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;Vue Awesome&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;地址：https://github.com/Justineo/vue-awesome&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5614754098360656&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LDPLltmNy570PPS4TCaan3wbNfWlvuP35sYlJxBGyaoRRqJlrYSrWhcczMZA2sc3P2x5CJo04GPYBiaV3TUO9MQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Font Awesome是一套流行的图标字体库，我们在实际开发的过程中会经常遇到需要使用图标的场景，对于一些常用的图标，不用设计师，我们可以直接在Font Awesome中找到并且使用。个人感觉Font Awesome的图标还是很齐全的，绝大多数的图标它都包含了，而且支持各种框架。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Vue Material Design Icons&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;地址：https://github.com/robcresswell/vue-material-design-icons&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个作为单文件组件的SVG Material Design图标集合。此外，这个库是一个Vue单文件组件的集合，用于渲染Material Design图标。此外，它还包括一些CSS，有助于使图标的缩放更容易一些。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Charts&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Vue Apexcharts&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;地址：https://github.com/apexcharts/vue-apexcharts&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5614754098360656&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LDPLltmNy570PPS4TCaan3wbNfWlvuP3Hzo59HiarPic5yo6Z9ARJyAWicnCvkNxzic1UshX1ImlZUgGaWxBuvXGbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Apexcharts是一个现代的JavaScript图表库/可通过简单的API构建交互式图表和可视化。Vue Apexcharts是ApexCharts的Vue.js组件。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Vue Echarts&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;地址：https://github.com/Justineo/vue-echarts&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5614754098360656&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LDPLltmNy570PPS4TCaan3wbNfWlvuP3col0KxPQrQic2J6jnHZOJgBsLc7eOH4XOMiaoYgE0ELahkm3lkcx795Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;vue-echarts是基于echarts封装实现的一个组件库，直接按照正常的组件引用方式，安装引用即可，具体的安装和引用读者可以直接阅读vue-echarts技术文档。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Vue Chartjs&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;地址：https://github.com/apertureless/vue-chartjs&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5614754098360656&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LDPLltmNy570PPS4TCaan3wbNfWlvuP3QhfeTMLA46cLyIfjanLiacibX7GuQEpYsoUiaKhPgpCoGibyw7fqzmiaTow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;vue-chartjs 是一个 Vue 对于 Chart.js 的封装，让用户可以在Vue中轻松使用Chart.js，很简单的创建可复用的图表组件，非常适合需要简单的图表并尽可能快地运行的人。vue-chartjs抽象了基本逻辑，同时也暴露了Chart.js对象，让用户获得最大的灵活性。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;V-Charts&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;地址：https://github.com/ElemeFE/v-charts&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5614754098360656&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LDPLltmNy570PPS4TCaan3wbNfWlvuP35EMJy6WABpVDSCcy5yAYrqkDI3lVMAy4RxyTb2GKGw0wnAloibc9ndg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;V-Charts 是基于 Vue2.0 和 Echarts 封装的图标组件，只需要统一提供一种对前后端都友好的数据格式设置简单的配置项，就可以生成常见的图表。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;时间&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Vue Timer Hook&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;地址：https://github.com/riderx/vue-timer-hook&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5614754098360656&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LDPLltmNy570PPS4TCaan3wbNfWlvuP3PQ2vGF2DLsMCVj8QIXsjVf0XF7iasInlTDpltDoJOyew9RY4DWs4RTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Vue3 计时器模块的灵感来自 react-timer-hook。此外，它是一个自定义的钩子，用来处理vue 3 组件中的定时器、秒表和时间逻辑/状态。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Vue Horizontal Timeline:&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;地址：https://github.com/guastallaigor/vue-horizontal-timeline&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5614754098360656&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LDPLltmNy570PPS4TCaan3wbNfWlvuP32SrcBUaXXGBycSzpFkd1doJn9MCTwfEcwVJn9oDILEkBwibzCjND7fA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Vue Horizontal Timeline 是一个用Vue.js制作的简单的水平时间线组件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;作者：lindelof  译者：前端小智 来源:medium &lt;/span&gt;&lt;span&gt;原文：&lt;/span&gt;&lt;span&gt;https://medium.com/js-dojo/20-usefulue-js-components-2022-3bf9fbe5b556&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d0b9e261565c150fa1fe538d66bee4bc</guid>
<title>腾讯云后端 15 连问</title>
<link>https://toutiao.io/k/uyqrh0o</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最近一位朋友（6年工作经验）面了腾讯云，以下是面试题和答案。加油，一起卷。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;1. 聊聊项目，好的设计，好的代码&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;项目的话，你可以聊聊你平时做的项目，尤其有亮点的项目。如果没有什么特别亮点的项目，也可以说说一些好的设计，或者你优化了什么接口，性能提升了多少，优化了什么慢SQL都可以。甚至是一些好的代码写法都可以。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;2. 谈谈什么是零拷贝？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;零拷贝是指计算机执行 IO 操作时，CPU 不需要将数据从一个存储区域复制到另一个存储区域，从而可以减少上下文切换以及 CPU 的拷贝时间。它是一种 I/O 操作优化技术。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;传统 IO 的执行流程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;传统的 IO 流程，包括 read 和 write 的过程。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562037037037037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpzy6xWdXpMBhezAibRyIAEyaSQyhiaKosG5R9NfLibcz9DUJ0COfXvWlrDg4FIT54vQdvPVETibkNlQTg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;用户应用进程调用 read 函数，向操作系统发起 IO 调用，上下文从用户态转为内核态（切换 1）；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;DMA 控制器把数据从磁盘中，读取到内核缓冲区；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;CPU 把内核缓冲区数据，拷贝到用户应用缓冲区，上下文从内核态转为用户态（切换2），read 函数返回；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;用户应用进程通过 write 函数，发起 IO 调用，上下文从用户态转为内核态（切换3）；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;CPU 将用户缓冲区中的数据，拷贝到 socket 缓冲区；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;DMA 控制器把数据从 socket 缓冲区，拷贝到网卡设备，上下文从内核态切换回用户态（切换 4），write 函数返回。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;传统 IO 的读写流程，包括了 &lt;strong&gt;4 次上下文切换&lt;/strong&gt;（4 次用户态和内核态的切换），&lt;strong&gt;4 次数据拷贝&lt;/strong&gt;（两次 CPU 拷贝以及两次的 DMA 拷贝)。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;零拷贝实现方式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;零拷贝并不是没有拷贝数据，而是减少用户态/内核态的切换次数以及 CPU 拷贝的次数。零拷贝一般有这三种实现方式：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;mmap+write&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;sendfile&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;带有DMA收集拷贝功能的sendfile&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;mmap + write&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;mmap 就是用了虚拟内存这个特点，它将内核中的读缓冲区与用户空间的缓冲区进行映射，以减少数据拷贝次数。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5990740740740741&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpzy6xWdXpMBhezAibRyIAEyabibclIvWfLH2icQBc6XOvhSVFIwicx7dVh5zzFU1icNCVmD271OxTCqibnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;用户进程通过 mmap 方法向操作系统内核发起IO调用，上下文从用户态切换为内核态；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;CPU 利用 DMA 控制器，把数据从硬盘中拷贝到内核缓冲区；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;上下文从内核态切换回用户态，mmap 方法返回；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;用户进程通过 write 方法向操作系统内核发起 IO 调用，上下文从用户态切换为内核态；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;CPU 将内核缓冲区的数据拷贝到的 socket 缓冲区；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;CPU 利用 DMA 控制器，把数据从 socket 缓冲区拷贝到网卡，上下文从内核态切换回用户态，write 调用返回。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;mmap + write 实现的零拷贝，I/O 发生了 4 次用户空间与内核空间的上下文切换，以及 3 次数据拷贝（包括了 2 次 DMA 拷贝和 1 次CPU拷贝）。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;sendfile&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;sendfile 表示在两个文件描述符之间传输数据，它是在操作系统内核中操作的，避免了数据从内核缓冲区和用户缓冲区之间的拷贝操作。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5574074074074075&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpzy6xWdXpMBhezAibRyIAEyaroKIbrJxeaMvgFmvC4jBVehWjUWqWia3PXzM1sYPdSYicyXjsIsgYJQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;用户进程发起 sendfile 系统调用，上下文（切换 1）从用户态转向内核态；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;DMA 控制器，把数据从硬盘中拷贝到内核缓冲区；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;CPU 将读缓冲区中数据拷贝到 socket 缓冲区；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;DMA 控制器，异步把数据从 socket 缓冲区拷贝到网卡；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;上下文（切换 2）从内核态切换回用户态，sendfile 调用返回。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;sendfile 实现的零拷贝，I/O 发生了 2 次用户空间与内核空间的上下文切换，以及 3 次数据拷贝。其中 3次 数据拷贝中，包括了 2 次 DMA 拷贝和 1 次 CPU 拷贝。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;带有 DMA 收集拷贝功能的 sendfile&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Linux 2.4 版本之后，对 sendfile 做了优化升级，引入 SG-DMA 技术。其实就是对 DMA 拷贝加入了 scatter/gather 操作，它可以直接从内核空间缓冲区中将数据读取到网卡。使用这个特点搞零拷贝，即还可以多省去一次 CPU 拷贝。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5611111111111111&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpzy6xWdXpMBhezAibRyIAEyavibmyxUCF4jHEnGkGTIPpuMlo0S4ueCbuUa1HXzAHiaVLV17VVyxncBA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;用户进程发起 sendfile 系统调用，上下文（切换 1）从用户态转向内核态；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;DMA 控制器，把数据从硬盘中拷贝到内核缓冲区；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;CPU 把内核缓冲区中的文件描述符信息（包括内核缓冲区的内存地址和偏移量）发送到 socket 缓冲区；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;DMA 控制器根据文件描述符信息，直接把数据从内核缓冲区拷贝到网卡；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;上下文（切换 2）从内核态切换回用户态，sendfile 调用返回。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可以发现，sendfile+DMA scatter/gather 实现的零拷贝，I/O 发生了 2 次用户空间与内核空间的上下文切换，以及 2 次数据拷贝。其中2次数据拷贝都是包 DMA 拷贝。这就是真正的零拷贝（Zero-copy) 技术，全程都没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3. 一共有几种 IO 模型？NIO 和多路复用的区别？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;一共有五种 IO 模型&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;阻塞 IO 模型&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;非阻塞 IO 模型&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;IO 多路复用模型&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;IO 模型之信号驱动模型&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;IO 模型之异步 IO（AIO）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;NIO（非阻塞 IO 模型）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;NIO 即 Non-Blocking IO，是非阻塞 IO 模型。非阻塞 IO 的流程如下：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7074074074074074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpzy6xWdXpMBhezAibRyIAEyaHOyYicv1s7kCmHlyvX22yVicjd4pBhpaQ59CLjTzg1KvZo0Lvyce31Sg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;应用进程向操作系统内核，发起 recvfrom 读取数据；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;操作系统内核数据没有准备好，立即返回 EWOULDBLOCK 错误码；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;应用程序进程轮询调用，继续向操作系统内核发起 recvfrom 读取数据；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;操作系统内核数据准备好了，从内核缓冲区拷贝到用户空间；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;完成调用，返回成功提示。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;NIO（非阻塞 IO 模型）存在性能问题，即频繁的轮询，导致频繁的系统调用，同样会消耗大量的 CPU 资源。可以考虑 IO 复用模型去解决这个问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;IO 多路复用模型&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;IO 多路复用就是，等到内核数据准备好了，主动通知应用进程再去进行系统调用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;IO 复用模型核心思路：系统给我们提供一类函数（如我们耳濡目染的 select、poll、epoll 函数），它们可以同时监控多个 fd 的操作，任何一个返回内核数据就绪，应用进程再发起 recvfrom 系统调用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;IO 多路复用之 select&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;应用进程通过调用 select 函数，可以同时监控多个 fd。在 select 函数监控的 fd 中，只要有任何一个数据状态准备就绪了，select 函数就会返回可读状态，这时应用进程再发起 recvfrom 请求去读取数据。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6111111111111112&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpzy6xWdXpMBhezAibRyIAEya1obicksgLuaDqeGNsrV6e4Ryn8SnITjia7mAibyCwYPKpicVLhNc3BHEaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;非阻塞 IO 模型（NIO）中，需要 N（N&amp;gt;=1）次轮询系统调用。然而，借助 select 的 IO 多路复用模型，只需要发起一次询问就够了。大大优化了性能。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但是呢，select 有几个缺点：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;监听的 IO 最大连接数有限，在 Linux 系统上一般为 1024；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;select 函数返回后，是通过遍历 fdset，找到就绪的描述符 fd（仅知道有 I/O 事件发生却不知是哪几个流，所以遍历所有流）。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因为存在连接数限制，所以后来又提出了 poll。与 select 相比，poll 解决了连接数限制问题。但是呢，select 和 poll 一样，还是需要通过遍历文件描述符来获取已经就绪的 socket。如果同时连接的大量客户端，在一时刻可能只有极少处于就绪状态，伴随着监视的描述符数量的增长，效率也会线性下降。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;IO 多路复用之 epoll&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了解决 select/poll 存在的问题，多路复用模型 epoll 诞生，它采用事件驱动来实现，流程图如下：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6074074074074074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpzy6xWdXpMBhezAibRyIAEyaNNic9NOxwFTQ4HbdFBEaGJ6GiblvWGibBCRybP0YA5RguicI595fZwBHyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;epoll 先通过 epoll_ctl() 来注册一个 fd（文件描述符）。一旦基于某个 fd 就绪时，内核会采用回调机制，迅速激活这个 fd，当进程调用 epoll_wait() 时便得到通知。这里去掉了遍历文件描述符的坑爹操作，而是采用监听事件回调的机制。这就是 epoll 的亮点。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4. Future 实现阻塞等待获取结果的原理？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Future.get() 用于异步结果的获取。它是阻塞的，背后原理是什么呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们可以看下 FutureTask 的类结构图：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7418772563176895&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpzy6xWdXpMBhezAibRyIAEyaStCxNVvXCEE5icG89BCTq4430UYsXpuwkicVpznydCoXaWC3ibsWoFyLQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;FutureTask 实现了 RunnableFuture 接口，RunnableFuture 继承了 Runnable 和 Future 这两个接口。对于 Runnable，我们太熟悉了， 那么 Future 呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Future 表示一个任务的生命周期，并提供了相应的方法来判断是否已经完成或取消，以及获取任务的结果和取消任务等。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Future&lt;/span&gt; &amp;lt; &lt;span class=&quot;code-snippet__title&quot;&gt;V&lt;/span&gt; &amp;gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; mayInterruptIfRunning)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;isCancelled&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;isDone&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;V &lt;span class=&quot;code-snippet__title&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;throws&lt;/span&gt; InterruptedException,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ExecutionException&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;V &lt;span class=&quot;code-snippet__title&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; timeout, TimeUnit unit)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;throws&lt;/span&gt; InterruptedException,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ExecutionException,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    TimeoutException&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;FutureTask 就是 Runnable 和 Future 的结合体，我们可以把 Runnable 看作生产者， Future 看作消费者。而 FutureTask  是被这两者共享的，生产者运行 run 方法计算结果，消费者通过 get 方法获取结果。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;生产者消费者模式，如果生产者数据还没准备的时候，消费者会被阻塞。当生产者数据准备好了以后会唤醒消费者继续执行。我们来看下 FutureTask 内部是如何实现的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;FutureTask 内部维护了任务状态 state：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; NEW = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; COMPLETING = &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; NORMAL = &lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; EXCEPTIONAL = &lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; CANCELLED = &lt;span class=&quot;code-snippet__number&quot;&gt;4&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; INTERRUPTING = &lt;span class=&quot;code-snippet__number&quot;&gt;5&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; INTERRUPTED = &lt;span class=&quot;code-snippet__number&quot;&gt;6&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;生产者 run 方法：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;run&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (state != NEW ||&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        !UNSAFE.compareAndSwapObject(&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;, runnerOffset,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;, Thread.currentThread()))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Callable &amp;lt; V &amp;gt; c = callable;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (c != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; state == NEW) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            V result;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            boolean ran;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                result = c.call();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                ran = &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            } &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (Throwable ex) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                result = &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                ran = &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                setException(ex);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (ran)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;set&lt;/span&gt;(result);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;finally&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        runner = &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; s = state;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (s &amp;gt;= INTERRUPTING)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            handlePossibleCancellationInterrupt(s);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;消费者的 get 方法：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;publicV &lt;span class=&quot;code-snippet__title&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;throws&lt;/span&gt; InterruptedException, ExecutionException &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; s = state;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (s &amp;lt;= COMPLETING)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        s = awaitDone(&lt;span class=&quot;code-snippet__keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; L);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; report(s);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;awaitDone 做了什么事情呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;awaitDone&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; timed, &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; nanos)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; deadline = timed ? System.nanoTime() + nanos : &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; L;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    WaitNode q = &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; queued = &lt;span class=&quot;code-snippet__keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (;;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (Thread.interrupted()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            removeWaiter(q);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; InterruptedException();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; s = state;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (s &amp;gt; COMPLETING) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (q != &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                q.thread = &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; s;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (s == COMPLETING) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            Thread.yield();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (q == &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            q = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; WaitNode();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (!queued)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            queued = UNSAFE.compareAndSwapObject(&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;, waitersOffset,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                q.next = waiters, q);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (timed) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            nanos = deadline - System.nanoTime();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (nanos &amp;lt;= &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; L) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                removeWaiter(q);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; state;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            LockSupport.parkNanos(&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;, nanos);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            LockSupport.park(&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当然，面试的时候不一定要讲到源码这么细，只需要讲个大概思路就好啦。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5. ReentrantLock 和 Synchronized 的区别？Synchronized 原理？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;ReentrantLock 和 Synchronized 的区别？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Synchronized 是依赖于 JVM 实现的，而 ReentrantLock 是 API 实现的；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在 Synchronized 优化以前，synchronized 的性能是比 ReentrantLock 差很多的，但是自从 Synchronized 引入了偏向锁，轻量级锁（自旋锁）后，两者性能就差不多了；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Synchronized 的使用比较方便简洁，它由编译器去保证锁的加锁和释放。而ReentrantLock 需要手工声明来加锁和释放锁，最好在 finally 中声明释放锁；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;ReentrantLock可以指定是公平锁还是非公平锁。而 synchronized 只能是非公平锁；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;ReentrantLock 可响应中断、可轮回，而 Synchronized 是不可以响应中断的。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;6. 聊聊 AOS？ReentrantLock 的实现原理？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;AQS（抽象同步队列）的核心回答要点就是：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;state 状态的维护&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;CLH 队列&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;ConditionObject 通知&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;模板方法设计模式&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;独占与共享模式&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;自定义同步器&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;大家综合 ReentrantLock 的功能，比如可重入，公平锁，非公平锁等，与 AQS 结合一起讲就好啦。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;7. 乐观锁和悲观锁， 让你来写你怎么实现？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;悲观锁&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;悲观锁她专一且缺乏安全感了，它的心只属于当前线程，每时每刻都担心着它心爱的数据可能被别的线程修改。因此一个线程拥有（获得）悲观锁后，其他任何线程都不能对数据进行修改啦，只能等待锁被释放才可以执行。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6044776119402985&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpzy6xWdXpMBhezAibRyIAEyaOKXlu4WJPZn13rXI7lCryxtiaZEZCtadsQTtl3VaLQyj0pQGKnaVQow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;804&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;SQL 语句 select ...for update 就是悲观锁的一种实现&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;还有 Java 的 synchronized 关键字也是悲观锁的一种体现&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;乐观锁&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;乐观锁的很乐观，它认为数据的变动不会太频繁，操作时一般都不会产生并发问题。因此它不会上锁，只是在更新数据时，再去判断其他线程在这之前有没有对数据进行过修改。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;实现方式：乐观锁一般会使用版本号机制或 CAS 算法实现。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6486486486486487&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpzy6xWdXpMBhezAibRyIAEyaVjFicmHhf70Kg2UKtZXiaH4y6iaIMTSQlLbkvKnqgjEmfmxgcHq7eY8Ew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;814&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;8. Paxos 协议了解？工作流程是怎么样的？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;8.1 为什么需要 Paxos 算法？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当前我们应用都是集群部署的，要求所有机器状态一致。假设当前有两台机器 A 和 B， A 要把状态修改为 a，B 要把状态修改为 b，那么应该听谁的呢？这时候可以像 2PC 一样，引入一个协调者，谁最先到就听谁的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7159468438538206&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpzy6xWdXpMBhezAibRyIAEyal2Gh883LcicvyxZuGuWCcHzFwXg5FxyEQiapsZxV4jQYPyXhzMeN4K1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;602&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里有个问题，就是协调者是单节点，如果它挂了呢？因为可以引入多个协调者：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6796992481203008&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpzy6xWdXpMBhezAibRyIAEyacibNnfwaDnhDAWLj5ia1Y9UlykkUmYQhUDyR3RIKDgm9kX8IuwzbSTdg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;665&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但是这么多协调者，应该听谁的呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;引入 Paxos 算法解决这个问题，Paxos 算法是一种基于消息传递的分布式一致性算法。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;8.2  Paxos 的角色&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Paxos 涉及三种角色，分别是 Proposer、Accecptor 、Learner。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;Proposer&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：它可以提出提案（Proposal），提案信息包括提案编号和提案值；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;Acceptor&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：接受接受（accept）提案。一旦接受提案，提案里面的提案值（可以用 V 表示）就被选定了；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;Learner&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：哪个提案被选定了, Learner 就学习这个被选择的提案。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;一个进程可能是 Proposer，可能是 Acceptor，也可能是 Learner。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;8.3 Paxos 算法推导过程&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一致性算法需要前置条件&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在这些被提出的提案中，只有一个会被选定；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果没有提案被提出，就不应该有被选定的提案；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;当提案被选定后，Learner 可以学习被选中的提案。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;假设只有一个 Acceptor，只要 Acceptor 接受它收到的第一个提案，就可以保证只有一个 value 会被选定。但是这个 Acceptor 宕机，会导致整个系统不可用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5047120418848168&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpzy6xWdXpMBhezAibRyIAEyapCpCVsA71e64skDkMbibWdVpotY8eBo4rFiaxFdvhbZoI0V1U8XbOE3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;955&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果是是多个 Proposer 和多个 Acceptor，如何选定一个提案呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6721804511278195&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpzy6xWdXpMBhezAibRyIAEyaBZ0266dmWuuJTicaXN7QibheSphdvLUWMhm8MCibzV1WqkYCxlDM5E79Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;665&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们可以加个约定条件，假设就叫&lt;strong&gt;约束 P1：一个  Acceptor 必须接受它收到的第一个提案&lt;/strong&gt;。但是这样还是可能会有问题，如果每个 Proposer 分别提出不同的 value（如下图 V1、V2、V3），发给了不同的 Acceptor，最后会导致不同的 value 被选择。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5651731160896131&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpzy6xWdXpMBhezAibRyIAEyaUekR8SI5UweRjgGnm8giaw0FTjvHMG8XoDmG0ExynJkfToqMzaoz44Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;982&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们可以给多一个&lt;strong&gt;额外的约定 P1a：一个提案被选定，需要被半数以上 Acceptor 接受&lt;/strong&gt;。这跟 P1 有点矛盾啦，我们可以使用一个全局的编号来标识每一个 Acceptor 批准的提案，当一个具有某 value 值的提案被&lt;strong&gt;半数以上的 Acceptor 批准&lt;/strong&gt;后，我们就认为该 value 被选定了。即提案 P= 提案参数 + 提案值，可以记为&lt;strong&gt;【M,V】&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在可以允许多个提案被选定，但必须保证所有被选定的提案都具有相同的 value 值。要不然又会出现不一致啦。因此可以再加个约束 P2：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果提案 P[M1,V1] 被选定了，那么所有比 M1 编号更高的被选定提案 P，其 value 的值也必须是 V1。&lt;/span&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一个提案要被选定，至少要被一个 Acceptor 接受，因此我们可以把P2约束改成对 Acceptor 接受的约束P2a：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果提案 P[M1,V1] 被接受了，那么所有比 M1 编号更高的。且被 Acceptor 接受的 P，其值也是 V1。&lt;/span&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;多提案被选择的问题解决了，但是如果是网络不稳定或者宕机的原因，还是会有问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5629032258064516&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpzy6xWdXpMBhezAibRyIAEyaPT82lXAGzPSnicypQyBMuNcKtsdgFBfEg2FCibxkibTiclib8qc1Wo06Txw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;假设有 5 个 Acceptor。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Proposer2 提出 [M1,V1]的提案，Acceptor2~5（半数以上）均接受了该提案，于是对于 Acceptor2~5 和 Proposer2 来讲，它们都认为 V1 被选定。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Acceptor1 刚刚从 宕机状态 恢复过来（之前 Acceptor1 没有收到过任何提案），此时 Proposer1 向 Acceptor1 发送了 [M2,V2] 的提案 （V2≠V1 且 M2&amp;gt;M1）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对于 Acceptor1 来讲，这是它收到的第一个提案。&lt;/span&gt;&lt;span&gt;根据 P1（一个 Acceptor 必须接受它收到的 第一个提案），Acceptor1 必须接受该提案。同时 Acceptor1 认为 V2 被选定。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这就出现了两个问题:&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Acceptor1 认为 V2 被选定，Acceptor2~5 和 Proposer2 认为 V1 被选定。出现了不一致；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;V1 被选定了，但是编号更高的被 Acceptor1 接受的提案 [M2,V2] 的 value 为 V2，且 V2≠V1。这就跟 P2a（如果提案 P[M1,V1] 被接受了，那么所有比 M1 编号更高的，且被 Acceptor 接受的 P，其值也是 V1）矛盾了。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们要对 P2a 约束强化一下得到约束 P2b，&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果 P[M1,V1] 被选定后，任何 Proposer 产生的 P，其值也是 V1。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对于 P2b 中的描述，如何保证任何Proposer产生的P，其值也是V1 ？只要满足 P2c 即可：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于任意的 M 和 V，如果提案 [M,V] 被提出，那么肯定存在一个由半数以上的 Acceptor 组成的集合 S，满足以下两个条件中的任意一个:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;要么 S 中每个 Acceptor 都没有接受过编号小于 M 的提案；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;要么 S 中所有 Acceptor 批准的所有编号小于 Mn 的提案中，编号最大的那个提案的 value 值为 Vn。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;8.4 算法流程&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;8.4.1 Proposer 生成提案&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 &lt;strong&gt;P2c 约束&lt;/strong&gt;基础上，如何生成提案呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Proposer 选择一个新的提案编号 N，向 Acceptor 集合 S（数目在半数以上）发送请求，要求 S 中的每一个 Acceptor 做出如下响应：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果 Acceptor 没有接受过提案，则向 Proposer 保证不再接受编号小于 N 的提案；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果 Acceptor 接受过请求，则向 Proposer 返回已经接受过的编号小于 N 的编号最大的提案。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们将这个请求称为编号为 N 的 &lt;strong&gt;Prepare 请求&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果 Proposer 收到半数以上的 Acceptor 响应，则生成编号为 N，value 为 V 的提案 [N,V]，V 为所有响应中编号最大的提案的 value；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果 Proposer 收到的响应中没有提案，那么 value 由 Proposer 自己生成，生成后将此提案发给 S，并期望 Acceptor 能接受此提案。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们称这个请求为 Accept 请求。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;8.4.2 Acceptor接受提案&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一个 Acceptor 可能会受到来自 Proposer 的两种请求：Prepare 请求和 Accept 请求。&lt;/span&gt;&lt;span&gt;Acceptor 什么时候可以响应一个请求呢，它也有个&lt;strong&gt;约束 P1b&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一个 Acceptor 只要尚未响应过任何编号大于 N 的 Prepare 请求，那么它就可以接受这个编号为 N 的提案。&lt;/span&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Acceptor 收到编号为 N 的 Prepare 请求，如果在此之前它已经响应过编号大于 N 的 Prepare 请求。由约束 P1b，该 Acceptor 不会接受这个编号为N的提案。因此，Acceptor 会忽略这个请求。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一个 Acceptor 只需记住两点：已接受的编号最大的提案和已响应的请求的最大编号。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h4&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;8.4.3 Paxos 算法描述&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;阶段一&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Proposer 选择一个提案编号 N，然后向半数以上的 Acceptor 发送编号为 N 的 Prepare 请求。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果一个 Acceptor 收到一个编号为 N 的 Prepare 请求，且 N 大于该 Acceptor 已经响应过的所有 Prepare 请求的编号，那么它就会将它已经接受过的编号最大的提案（如果有的话）作为响应反馈给 Proposer，同时该 Acceptor 承诺不再接受任何编号小于 N 的提案。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;阶段二&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果 Proposer 收到半数以上 Acceptor 对其发出的编号为 N 的 Prepare 请求的响应，那么它就会发送一个针对 [N,V] 提案的 Accept 请求给半数以上的 Acceptor。&lt;/span&gt;&lt;span&gt;（注意：V 就是收到的响应中编号最大的提案的 value，如果响应中不包含任何提案，那么 V 就由 Proposer 自己决定）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果 Acceptor 收到一个针对编号为 N 的提案的 Accept 请求，只要该 Acceptor 没有对编号大于 N 的 Prepare 请求做出过响应，它就接受该提案。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;8.4.4 Learner 学习被选定的 value&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5629032258064516&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpzy6xWdXpMBhezAibRyIAEya8BdibB2zA7JW5WR7XKpGzyhGEiaVvQBKOEHBU71tBAfPI1edFAf6hjog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;9. B+ 树是不是有序？B+ 树和 B- 树的主要区别？B+ 树索引，一次查找过程?&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;B+ 树是有序的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;B+ 树和 B- 树的主要区别？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;B- 树内部节点是保存数据的，而 B+ 树内部节点是不保存数据的，只作索引作用。它的叶子节点才保存数据；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;B+ 树相邻的叶子节点之间是通过链表指针连起来的，B- 树却不是；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;查找过程中，B- 树在找到具体的数值以后就结束，而 B+ 树则需要通过索引找到叶子结点中的数据才结束；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;B- 树中任何一个关键字出现且只出现在一个结点中，而 B+ 树可以出现多次。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;假设有这么一个 SQL：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; Temployee &lt;span class=&quot;code-snippet__keyword&quot;&gt;where&lt;/span&gt; age=&lt;span class=&quot;code-snippet__number&quot;&gt;32&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;age 加个一个索引，这条 SQL 是如何在索引上执行的？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;大家可以举例子画个示意图哈，比如二级索引树：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4166666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpzy6xWdXpMBhezAibRyIAEya16pA0UcicZtVaibwYGoHGepGAKIXic2qZTWia1Q2ExGuVBibQeYlyfia3ia2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;再画出 id 主键索引，我们先画出聚族索引结构图，如下：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4074074074074074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpzy6xWdXpMBhezAibRyIAEyabmHqSMtyjeheOjFG9QSen8nUmpNprywjjrmLozWhCCXucABaAcsoPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因此，这条 SQL 查询语句执行大概流程就是酱紫：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;搜索 idx_age 索引树，将磁盘块 1 加载到内存。由于 32&amp;lt;37 搜索左路分支，到磁盘寻址磁盘块 2；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将磁盘块 2 加载到内存中，在内存继续遍历，找到 age=32 的记录，取得 id = 400；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;拿到 id=400 后，回到 id 主键索引树；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;搜索 id 主键索引树，将磁盘块 1 加载内存，在内存遍历，找到了 400。但是 B+ 树索引非叶子节点是不保存数据的。索引会继续搜索 400 的右分支，到磁盘寻址磁盘块 3；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将磁盘块 3 加载内存，在内存遍历，找到 id=400 的记录，拿到 R4 这一行的数据。好的，大功告成。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;10. TCP 怎么实现拥塞控制？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;拥塞控制是作用于网络的，防止过多的数据包注入到网络中，避免出现网络负载过大的情况。它的目标主要是最大化利用网络上瓶颈链路的带宽。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;实际上，拥塞控制主要有这几种常用算法：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h4&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;慢启动算法&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;慢启动算法，表面意思就是别急慢慢来。它表示 TCP 建立连接完成后，一开始不要发送大量的数据，而是先探测一下网络的拥塞程度。由小到大逐渐增加拥塞窗口的大小，如果没有出现丢包，每收到一个 ACK，就将拥塞窗口 cwnd 大小就加 1（单位是 MSS）。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;每轮次发送&lt;/span&gt;&lt;span&gt;窗口增加一倍，呈指数增长，如果出现丢包，拥塞窗口就减半，进入拥塞避免阶段。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;TCP 连接完成，初始化 cwnd = 1，表明可以传一个 MSS 单位大小的数据；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;每当收到一个 ACK，cwnd 就加一；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;每当过了一个 RTT，cwnd 就增加一倍，呈指数让升。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.4644628099173553&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpzy6xWdXpMBhezAibRyIAEyau6Y9KOJ1qlykyibJaQyia9xWJkZGOKW8AZhKjovOibyict3lZHMh2Fu0Jw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;605&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了防止 cwnd 增长过大引起网络拥塞，还需设置一个&lt;strong&gt;慢启动阀值 ssthresh&lt;/strong&gt;（slow start threshold）状态变量。当 cwnd 到达该阀值后，就好像水管被关小了水龙头一样，减少拥塞状态。即当 &lt;strong&gt;cwnd &amp;gt;ssthresh&lt;/strong&gt; 时，进入了&lt;strong&gt;拥塞避免&lt;/strong&gt;算法。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h4&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;拥塞避免算法&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一般来说，慢启动阀值 ssthresh 是 65535 字节，cwnd 到达慢启动阀值后：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;每收到一个 ACK 时，cwnd = cwnd + 1/cwnd&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;当每过一个 RTT 时，cwnd = cwnd + 1&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;显然这是一个线性上升的算法，避免过快导致网络拥塞问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8820403825717322&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpzy6xWdXpMBhezAibRyIAEyaBSzFk83RReralibv1aGM6Gve7ro11CEJwVVfdibjk6dZWxqgaVfTbcRA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;941&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;拥塞发生&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当网络拥塞发生丢包时，会有两种情况：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果是发生了 RTO 超时重传，就会使用拥塞发生算法：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;慢启动阀值 sshthresh =  cwnd /2&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;cwnd 重置为 1&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;进入新的慢启动过程&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6193433895297249&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpzy6xWdXpMBhezAibRyIAEyaazSdzYuJyLuAyOmGVjL7cicyTbUvY8G6ticiaAroZa5QH0SRiaN3xyp5icA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1127&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这真的是辛辛苦苦几十年，一朝回到解放前。其实还有更好的处理方式，就是快速重传。发送方收到 3 个连续重复的 ACK 时，就会快速地重传，不必等待 RTO 超时再重传。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.4597014925373135&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpzy6xWdXpMBhezAibRyIAEyaqdicjvOFNdfCbsdbWGMXU1an2am0Br17aR1G9jlo7wQswQt7c809hnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;670&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;慢启动阀值 ssthresh 和 cwnd 变化如下：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;拥塞窗口大小 cwnd = cwnd/2&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;慢启动阀值 ssthresh = cwnd&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;进入快速恢复算法&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;快速恢复&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;快速重传和快速恢复算法一般同时使用。快速恢复算法认为，还有 3 个重复 ACK 收到，说明网络也没那么糟糕，所以没有必要像 RTO 超时那么强烈。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;正如前面所说，进入快速恢复之前，cwnd 和 sshthresh 已被更新：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;diff&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__deletion&quot;&gt;- cwnd = cwnd /2&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__deletion&quot;&gt;- sshthresh = cwnd&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;span/&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;然后，真正的快速算法如下：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;cwnd = sshthresh  + 3；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;重传重复的那几个ACK（即丢失的那几个数据包）；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果再收到重复的 ACK，那么 cwnd = cwnd +1；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果收到新数据的 ACK 后, cwnd = sshthresh。因为收到新数据的 ACK，表明恢复过程已经结束，可以再次进入了拥塞避免的算法了。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6173260572987722&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpzy6xWdXpMBhezAibRyIAEyasST8Ty2yfmGw9730KG8Of1sKMZIACIDickWSOLIho5picInBClnRaUcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1466&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;11. JVM 调优&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;11.1 一般什么时候考虑 JVM 调优呢？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Heap内存（老年代）持续上涨达到设置的最大内存值；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Full GC 次数频繁；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;GC 停顿时间过长（超过 1 秒）；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;应用出现 OutOfMemory 等内存异常；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;应用中有使用本地缓存且占用大量内存空间；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;系统吞吐量与响应性能不高或下降。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;11.2 JVM调优的目标&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;延迟：GC 低停顿和 GC 低频率&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;低内存占用&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;高吞吐量&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;11.3 JVM 调优量化目标&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Heap 内存使用率 &amp;lt;= 70%&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Old generation内存使用率 &amp;lt;= 70%&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;avgpause &amp;lt;= 1秒&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Full gc 次数 0 或 avg pause interval &amp;gt;= 24小时 &lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;11.4 JVM 调优的步骤&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;分析 GC 日志及 dump 文件，判断是否需要优化，确定瓶颈问题点；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;确定 JVM 调优量化目标；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;确定 JVM 调优参数（根据历史 JVM 参数来调整）；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;依次调优内存、延迟、吞吐量等指标；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;对比观察调优前后的差异；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;不断的分析和调整，直到找到合适的 JVM 参数配置；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;找到最合适的参数，将这些参数应用到所有服务器，并进行后续跟踪。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;11.5 常见的JVM参数&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;堆栈配置相关&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;diff&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__deletion&quot;&gt;-Xmx3550m -Xms3550m -Xmn2g -Xss128k &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__deletion&quot;&gt;-XX:MaxPermSize=16m -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxTenuringThreshold=0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;span/&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;-Xmx3550m：最大堆大小为 3550m；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;-Xms3550m：设置初始堆大小为 3550m；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;-Xmn2g：设置年轻代大小为 2g；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;-Xss128k：每个线程的堆栈大小为 128k；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;-XX:MaxPermSize：设置持久代大小为 16m；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;-XX:NewRatio=4: 设置年轻代（包括 Eden 和两个 Survivor 区）与年老代的比值（除去持久代）；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;-XX:SurvivorRatio=4：设置年轻代中 Eden 区与 Survivor 区的大小比值。设置为 4，则两个 Survivor 区与一个 Eden 区的比值为 2:4，一个 Survivor 区占整个年轻代的 1/6；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;-XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为 0 的话，则年轻代对象不经过 Survivor 区，直接进入年老代。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;垃圾收集器相关&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;diff&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__deletion&quot;&gt;-XX:+UseParallelGC&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__deletion&quot;&gt;-XX:ParallelGCThreads=20&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__deletion&quot;&gt;-XX:+UseConcMarkSweepGC &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__deletion&quot;&gt;-XX:CMSFullGCsBeforeCompaction=5&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__deletion&quot;&gt;-XX:+UseCMSCompactAtFullCollection：&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__deletion&quot;&gt;-XX:+UseConcMarkSweepGC&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;span/&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;-XX:+UseParallelGC：选择垃圾收集器为并行收集器；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;-XX:ParallelGCThreads=20：配置并行收集器的线程数；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;-XX:+UseConcMarkSweepGC：设置年老代为并发收集；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;-XX:CMSFullGCsBeforeCompaction：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次 GC 以后对内存空间进行压缩、整理；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;-XX:+UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可以消除碎片；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;-XX:+UseConcMarkSweepGC 使用 CMS 垃圾收集器。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;辅助信息&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;-XX&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:+PrintGC&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;-XX&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:+PrintGCDetails&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;span/&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;11.6 常用调优策略&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;选择合适的垃圾回收器；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;调整内存大小（垃圾收集频率非常频繁,如果是内存太小，可适当调整内存大小）；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;调整内存区域大小比率（某一个区域的 GC 频繁，其他都正常）；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;调整对象升老年代的年龄（老年代频繁 GC，每次回收的对象很多）；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;调整大对象的标准（老年代频繁 GC，每次回收的对象很多，而且单个对象的体积都比较大）；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;调整 GC 的触发时机（CMS、G1 经常 Full GC，程序卡顿严重)；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;调整 JVM 本地内存大小（GC 的次数、时间和回收的对象都正常，堆内存空间充足，但是报 OOM)。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;12. 数据库分库分表的缺点是啥？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;事务问题，已经不可以用本地事务了，需要用分布式事务；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;跨节点 Join 的问题：解决这一问题可以分两次查询实现；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;跨节点的 count、order by、group by 以及聚合函数问题：分别在各个节点上得到结果后在应用程序端进行合并；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;ID 问题：数据库被切分后，不能再依赖数据库自身的主键生成机制啦，最简单可以考虑 UUID；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;跨分片的排序分页问题（后台加大 pagesize 处理）。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;13. 分布式事务如何解决？TCC 了解吗？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;分布式事务&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;就是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。简单来说，分布式事务指的就是分布式系统中的事务，它的存在就是为了保证不同数据库节点的数据一致性。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;聊到分布式事务，需要知道这两个基本理论哈。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;CAP 理论&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;一致性（C：Consistency）&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：一致性是指数据在多个副本之间能否保持一致的特性。例如一个数据在某个分区节点更新之后，在其他分区节点读出来的数据也是更新之后的数据；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;可用性（A：Availability）&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：可用性是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。这里的重点是&quot;有限时间内&quot;和&quot;返回结果&quot;；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;分区容错性（P：Partition tolerance）&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;BASE 理论&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;它是对 CAP 中 AP 的一个扩展。对于我们的业务系统，我们考虑牺牲一致性来换取系统的可用性和分区容错性。BASE 是 Basically Available、Soft state 和 Eventually consistent 三个短语的缩写。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;Basically Available（基本可用）&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：通过支持局部故障而不是系统全局故障来实现的。如将用户分区在 5 个数据库服务器上，一个用户数据库的故障只影响这台特定主机那 20% 的用户，其他用户不受影响；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;Soft State（软状态）&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：状态可以有一段时间不同步；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;Eventually Consistent（最终一致）&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：最终数据是一致的就可以了，而不是时时保持强一致。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;分布式事务的几种解决方案：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;2PC（二阶段提交）方案、3PC&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;TCC（Try、Confirm、Cancel）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;本地消息表&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;最大努力通知&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Seata 事务&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;TCC（补偿机制）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;TCC 采用了补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。TCC（Try-Confirm-Cancel）包括三段流程：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;Try 阶段&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：尝试去执行，完成所有业务的一致性检查，预留必须的业务资源；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;Confirm 阶段&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：该阶段对业务进行确认提交，不做任何检查，因为 Try 阶段已经检查过了，默认 Confirm 阶段是不会出错的；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;Cancel 阶段&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：若业务执行失败，则进入该阶段，它会释放 Try 阶段占用的所有业务资源，并回滚 Confirm 阶段执行的所有操作。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下面再拿用户下单购买礼物作为例子来模拟 TCC 实现分布式事务的过程：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;假设用户 A 余额为 100 金币，拥有的礼物为 5 朵。A 花了 10 个金币，下订单，购买 10 朵玫瑰。余额、订单、礼物都在不同数据库。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;TCC 的 Try 阶段&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;生成一条订单记录，订单状态为待确认；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将用户 A 的账户金币中余额更新为 90，冻结金币为 10（预留业务资源）；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将用户的礼物数量为 5，预增加数量为 10；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Try 成功之后，便进入 Confirm 阶段&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Try 过程发生任何异常，均进入 Cancel 阶段。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5342592592592592&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpzy6xWdXpMBhezAibRyIAEyagRqcj7ibLh3Td91tUqBeUc1Bgc1b814fcx9OKP9SY8ZT0MkMln5hKLg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;TCC 的 Confirm 阶段&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;订单状态更新为已支付&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;更新用户余额为90，可冻结为0&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;用户礼物数量更新为15，预增加为0&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Confirm过程发生任何异常，均进入Cancel阶段&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Confirm过程执行成功，则该事务结束&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5148148148148148&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQyyqxha1tS1GAxU1vqGb5Mq6ZEXmLO6mYdKSLp0BftE9kznOAggsXL5mViaicICfrNLVUqv9EEzt3Ww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;TCC 的 Cancel 阶段&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;修改订单状态为已取消&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;更新用户余额回 100&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;更新用户礼物数量为 5&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5046296296296297&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpzy6xWdXpMBhezAibRyIAEyaM573diaMIUfhFlf065uOOaQjA12ElCsb341gjEibZCtdI9CSQK2X0HBA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;TCC 的优点是可以自定义数据库操作的粒度，降低了锁冲突，可以提升性能；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;TCC 的缺点是应用侵入性强，需要根据网络、系统故障等不同失败原因实现不同的回滚策略，实现难度大。一般借助 TCC 开源框架，例如 ByteTCC、TCC-transaction、Himly。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;14.  RocketMQ 如何保证消息的准确性和安全性？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我个人理解的话，这道题换汤不换药。就是为如何保证 RocketMQ 不丢消息，保证不重复消费、消息有序性、消息堆积的处理。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;消息不丢失的话，即从生产者、存储端、消费端去考虑。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;15. 三个数求和&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;注意&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：答案中不可以包含重复的三元组。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;实例1&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;输入：nums = [-1,0,1,2,-1,-4]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;输出：&lt;span class=&quot;code-snippet__selector-attr&quot;&gt;[[-1,-1,2]&lt;/span&gt;,&lt;span class=&quot;code-snippet__selector-attr&quot;&gt;[-1,0,1]&lt;/span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;实例2&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;输入：nums = [0]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;输出：&lt;span class=&quot;code-snippet__selector-attr&quot;&gt;[]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;span/&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;思路&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这道题可以先给数组排序，接着用左右双指针。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;完整代码如下：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Solution&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__type&quot;&gt;List&lt;/span&gt; &amp;lt; &lt;span class=&quot;code-snippet__type&quot;&gt;List&lt;/span&gt; &amp;lt; &lt;span class=&quot;code-snippet__type&quot;&gt;Integer&lt;/span&gt; &amp;gt;&amp;gt; threeSum(int[] nums) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__type&quot;&gt;List&lt;/span&gt; &amp;lt; &lt;span class=&quot;code-snippet__type&quot;&gt;List&lt;/span&gt; &amp;lt; &lt;span class=&quot;code-snippet__type&quot;&gt;Integer&lt;/span&gt; &amp;gt;&amp;gt; result = new &lt;span class=&quot;code-snippet__type&quot;&gt;LinkedList&lt;/span&gt; &amp;lt; &amp;gt; ();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (nums == null || nums.length &amp;lt; &lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;) { &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; result;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__type&quot;&gt;Arrays&lt;/span&gt;.&lt;span class=&quot;code-snippet__built_in&quot;&gt;sort&lt;/span&gt;(nums); &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (int i = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; nums.length - &lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;; i++) { &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (nums[i] &amp;gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) { &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (i &amp;gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; nums[i] == nums[i - &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;]) { &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            int &lt;span class=&quot;code-snippet__keyword&quot;&gt;left&lt;/span&gt; = i + &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            int &lt;span class=&quot;code-snippet__keyword&quot;&gt;right&lt;/span&gt; = nums.length - &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            int target = -nums[i]; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;left&lt;/span&gt; &amp;lt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;right&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (nums[&lt;span class=&quot;code-snippet__keyword&quot;&gt;left&lt;/span&gt;] + nums[&lt;span class=&quot;code-snippet__keyword&quot;&gt;right&lt;/span&gt;] == target) { &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    result.add(&lt;span class=&quot;code-snippet__type&quot;&gt;Arrays&lt;/span&gt;.asList(nums[i], nums[&lt;span class=&quot;code-snippet__keyword&quot;&gt;left&lt;/span&gt;], nums[&lt;span class=&quot;code-snippet__keyword&quot;&gt;right&lt;/span&gt;]));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__keyword&quot;&gt;left&lt;/span&gt;++; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__keyword&quot;&gt;right&lt;/span&gt;--; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;left&lt;/span&gt; &amp;lt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;right&lt;/span&gt; &amp;amp;&amp;amp; nums[&lt;span class=&quot;code-snippet__keyword&quot;&gt;left&lt;/span&gt;] == nums[&lt;span class=&quot;code-snippet__keyword&quot;&gt;left&lt;/span&gt; - &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;]) &lt;span class=&quot;code-snippet__keyword&quot;&gt;left&lt;/span&gt;++; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;left&lt;/span&gt; &amp;lt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;right&lt;/span&gt; &amp;amp;&amp;amp; nums[&lt;span class=&quot;code-snippet__keyword&quot;&gt;right&lt;/span&gt;] == nums[&lt;span class=&quot;code-snippet__keyword&quot;&gt;right&lt;/span&gt; + &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;]) &lt;span class=&quot;code-snippet__keyword&quot;&gt;right&lt;/span&gt;--; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (nums[&lt;span class=&quot;code-snippet__keyword&quot;&gt;left&lt;/span&gt;] + nums[&lt;span class=&quot;code-snippet__keyword&quot;&gt;right&lt;/span&gt;] &amp;lt; target) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__keyword&quot;&gt;left&lt;/span&gt;++; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__keyword&quot;&gt;right&lt;/span&gt;--;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; result;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;参考与感谢&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Callable/Future 使用及原理分析[1]&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;【JVM进阶之路】十：JVM调优总结[2]&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;分布式理论(五) - 一致性算法Paxos[3]&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;这一定是全网讲的最好的Paxos一致性算法&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1] &lt;/span&gt;&lt;span&gt;Callable/Future 使用及原理分析: https://cloud.tencent.com/developer/article/1692202&lt;/span&gt;&lt;span&gt;&lt;br/&gt;[2] &lt;/span&gt;&lt;span&gt;【JVM进阶之路】十：JVM调优总结: https://zhuanlan.zhihu.com/p/363961261&lt;/span&gt;&lt;span&gt;&lt;br/&gt;[3] &lt;/span&gt;&lt;span&gt;分布式理论(五) - 一致性算法Paxos: https://juejin.cn/post/6844903621499289613#heading-19&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>419edcbf67e4bfd529ac6c14cb478113</guid>
<title>万字长文助你上手软件领域驱动设计 DDD</title>
<link>https://toutiao.io/k/72nuj7z</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：faryrong，腾讯 CSIG 后台开发工程师&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;最近看了一本书《解构-领域驱动设计》，书中提出了领域驱动设计统一过程（DDDRUP），它指明了实践 DDD 的具体步骤，并很好地串联了各种概念、模式和思想。因此，我对书本内容做了梳理、简化，融入自己的理解，并结合之前阅读的书籍以及实践经验，最终形成这篇文章。希望可以帮助大伙理顺 DDD 的各种概念、模式和思想，降低上手 DDD 的门槛。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.背景&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;领域驱动设计（DDD）由 Eric Evans 提出，并一经《领域驱动设计：软件核心复杂性应对之道》的发布，在软件行业中引起了不少的轰动。DDD 提供的一种新颖的，甚至有点“另类”的思维方式，它在告诉软件开发者“我们要用业务方案来解决业务问题，而不是技术方案解决业务问题”，有点魔法打败魔法的意思。DDD 虽然让人眼前一亮，但是所提倡的理念有点“违背直觉”（对开发人员而言），因此，在当时并没有流行开来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后来，微服务架构的兴起，大伙惊奇地发现 DDD 是作为划分“微服务边界”的一把利器，并且 DDD 提及的很多设计理念与微服务架构十分契合，因此 DDD 逐渐被开发者们接受并流行起来。毫不夸张地说，了解和学习 DDD 可以算得上是如今软件行业从业者的一门必修课了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是！DDD 的学习曲线较为陡峭。作为一个小白，翻阅过很多相关的书籍、KM 文章和分享，但始终觉得未得要领、一知半解。原因有二：a) DDD 涉及的概念繁多，且不同概念的抽象层次不一样，如果我们直白地去理解，往往会感到疑惑，比如：子域和限界上下文都是用于将问题进行归类和收敛，他们的区别是什么？b)缺少过程指导，难以将概念有序的串联起来。作为方法论，DDD 给出了设计思想，核心原则以及常用工具，但是却缺少细致有序的方法步骤，导致难以上手实践。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;幸运的是，最近看了一本书《解构-领域驱动设计》。这本书提出了领域驱动设计统一过程（DDDRUP），它指明了实践 DDD 的具体步骤，并很好地串联了各种概念、模式和思想。因此，&lt;strong&gt;我对书本内容做了梳理、简化，融入自己的理解，并结合之前阅读的书籍以及实践经验，最终形成这篇文章&lt;/strong&gt;。希望可以帮助大伙理顺 DDD 的各种概念、模式和思想，降低上手 DDD 的门槛。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.DDD 概要与实践感悟&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经典必读书籍《领域驱动设计：软件核心复杂性应对之道》的书名包含了两个关键词：&lt;strong&gt;领域驱动&lt;/strong&gt;和&lt;strong&gt;复杂性，&lt;/strong&gt;分别代表了 DDD 的核心原则以及解决的问题。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1 复杂性&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;系统的复杂性往往并不在技术上，而是来自领域本身、用户的活动或业务服务。当这种领域复杂性在设计中没有得到解决时，基础技术的构思再好也是无济于事。而系统的复杂度体现在三个方面：&lt;strong&gt;规模&lt;/strong&gt;、&lt;strong&gt;结构&lt;/strong&gt;和&lt;strong&gt;变化&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;规模&lt;/strong&gt;：指的是系统所支持的功能点，以及功能点与功能点之间的的关系。DDD 通过子领域，限界上下文，聚合等模式对问题进行拆分和归类，不断收窄问题域，保证聚合边界内所解决的问题集合足够收敛和可控。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;结构&lt;/strong&gt;：指的是系统架构。系统架构是否分层；若分层，每层划分的职责边界是否清晰；架构的基本管理单元是什么，它决定了架构演进时的复杂度。DDD 通过分层架构，独立出领域层，且架构中的每层都有清晰的职责。整体架构的基本管理单元是聚合，它是一个完整的、自治的管理单元，当需要进行服务拆分时，可以直接以聚合作为基本单元进行拆分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;变化&lt;/strong&gt;：指的是系统响应需求变化的能力。快速响应变化的有效手段是分离不易变逻辑和易变逻辑，&quot;以不变应万变&quot;。而通过分层架构独立的领域层正是不易变的逻辑。领域层是对领域知识的封装，其提供的领域服务具有经验性和前瞻性，是对领域内稳定的领域规则的表达。而领域层以外的应用层和基础设施层则是易变逻辑的封装。保证核心的独立和稳定，通过在调整应用层和基础设施层来实现快速响应需求变化。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2 领域驱动&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;领域驱动指的是以领域作为解决问题切入点，面对业务需求，先提炼出领域概念，并构建领域模型来表达业务问题，而构建过程中我们应该尽可能避免牵扯技术方案或技术细节。而编码实现更像是对领域模型的代码翻译，代码（变量名、方法名、类名等）中要求能够表达领域概念，让人见码明义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结合实践经验，以下是本人对“领域驱动”的一些见解：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;思维模式转变&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实践 DDD 以前，我最常使用的是&lt;strong&gt;数据驱动设计&lt;/strong&gt;。它的核心思路针对业务需求进行&lt;strong&gt;数据建模&lt;/strong&gt;：根据业务需求提炼出类，然后通过 ORM 把类映射为表结构，并根据读写性能要求使用范式优化表与表之间的关联关系。数据驱动是从技术的维度解决业务问题，得出的数据模型是对业务需求的直接翻译，并没有蕴含&lt;strong&gt;稳定的&lt;/strong&gt;领域知识/规则。一旦需求发生变化，数据模型就得发生变化，对应的库表的设计也需要进行调整。这种设计思维导致变化从需求穿透到了数据层，中间并没有稳定的，不易变的层级进行阻隔，最终导致系统响应变化的能力很差。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;协同方式转变&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;过去由产品同学提出业务需求，研发同学根据业务需求的 tapd 进行技术方案设计，并编程实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种协同方式的弊端在于：&lt;strong&gt;无法形成能够消除认知差异的模型&lt;/strong&gt;。产品同学从业务角度提出用户需求，这些需求可能是易变的、定制化的，而研发同学在缺少行业经验的情况下，往往会选择直译，即根据需求直接转换为数据模型。而研发同学从技术实现角度设计技术方案，其中涉及很多的技术细节，产品同学无法从中判断是否与自己提出的业务诉求和产品规划相一致，最终形成认知差异。且认知差异会随着迭代不断被放大，最后系统变成一个大泥球。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3419354838709677&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatg1eXj11xia2icAtgCYHZTfDd4K70bOJKM6r9QriaIKmxQicZ5v2ibwuL5c8LJ5bwasBYvFmkRQ3GAlTg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;465&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DDD 通过解锁新角色&lt;strong&gt;”领域专家&quot;&lt;strong&gt;以及&lt;/strong&gt;模型驱动设计&lt;/strong&gt;，有效地降低产品和研发的认知差异。领域专家是具有丰富行业经验和领域知识储备的人，他们能够在易变的、定制化的需求中提炼出清晰的边界，稳定的、可复用的领域概念和业务规则，并携手产品和研发共同构建出领域模型。领域模型是对业务需求的知识表达形式，它不涉及具体的技术细节（但能够指导研发同学进行编程实现），因此消除了产品和研发在需求认知上的鸿沟。而模型驱动设计则要求领域模型能够关联业务需求和编码实现，模型的变更意味着需求变更和代码变更，协作围绕模型为中心。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6615384615384615&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatg1eXj11xia2icAtgCYHZTfDnJo6ibGt3Tx9LtPMeoPMicVkViasSCcHruQ0AR8ibyOuGbJ7r8x2d9e2icA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;455&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;精炼循环&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;精炼循环指的是在统一语言，提炼领域概念，明确边界，构建模型，绑定实现过程中，这些环节相互影响和反馈，在不断的迭代试错-调整以最终沉淀出稳定的、深层次的模型的过程。比如，我们在提炼领域概念的时候会觉得统一语言定义不合理/有歧义，此时我们就会调整统一语言的定义，并重新进行提炼领域概念。通过精炼循环，我们逐步形成稳定的领域模型。在 DDD 中，让领域专家来主导概念提炼、边界划分等宏观设计，原因就在于领域专家的经验和行业洞见来源于过去已经迭代的无数个精炼循环，因此由这些宏观设计推导出来的领域模型，往往都是非常稳定的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;精炼循环的核心是循环，它避免知识只朝单一方向流动，最终因各环节上的认知差异，最终导致模型无法在产品、领域专家和研发中达成一致、模型与实现割裂。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.3 怎么才算 DDD？&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我早期实践 DDD 的时候，认为代码分层遵循四层架构就是 DDD，抑或分离接口和实现，实现下沉至基础设施层就是 DDD，实则不然。结合上述内容，目前个人认为只要满足以下条件即为实践 DDD：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;构建出产品、领域专家和研发同学认知一致且便于交流的模型，并且模型与实现紧密绑定；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;模型逐步演进，反复消化和精炼；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;模型蕴含领域知识，足够稳定。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.问题空间&amp;amp;解空间&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1 问题空间&amp;amp;解空间&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题空间和解空间并非 DDD 特有的概念，而是人们为了区分真实世界和理念世界而提出的概念。问题空间表示的是真实世界，是具体的问题、用户的诉求，而解空间则是针对问题空间求解后构建的理念世界，其中包括了解决方案、模型等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DDD 提出的战略设计覆盖了问题空间和解空间，而战术设计则聚焦在解空间上。明确 DDD 中的概念是作用于问题空间还是解空间，更有助于我们理解它们。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2 示例-学生管理系统的问题空间&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;学生管理系统（Student Management System，下文简称 SMS）作为 DDDRUP 的讲解示例，以下为其问题空间的描述。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;学校需要构建一个学生管理系统（Student Management System, SMS）。&lt;br/&gt;&lt;br/&gt;通过这个管理系统，学生可以进行选课，查询成绩，查询绩点。&lt;br/&gt;&lt;br/&gt;而老师则可以通过这个系统录入授课课程的成绩。录入的分数会由系统自动换算为绩点，规则如下：若分数&amp;gt;= 90，绩点为4.0；90&amp;gt;= 分数&amp;gt; 80，绩点为3.0；80 &amp;gt;= 分数 &amp;gt; 70，绩点为2.0；70 &amp;gt;= 分数 &amp;gt;= 60，绩点为1.0；成绩&amp;lt; 60，则没有绩点，并邮件通知教务员，由教务员联系学生商榷重修事宜。&lt;br/&gt;&lt;br/&gt;成绩录入后的一周内，若出现录入成绩错误的情况，老师可提交修改申请，由教务员审核后即可完成修改。审核完成后系统会通过邮件告知老师审核结果。一周后成绩将锁定，不予修改。成绩锁定后，次日系统会自动计算各年级、各班的学生的总绩点（总绩点由各门课程的学分与其绩点进行加权平均后所得）。&lt;br/&gt;&lt;br/&gt;而教务员则可以通过该系统发布可以选修的课程。同时，教务员能够查看到各年级，各班的学生的总绩点排名。&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.领域驱动设计统一过程（DDDRUP）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然领域驱动设计划分了&lt;strong&gt;战略设计&lt;/strong&gt;和&lt;strong&gt;战术设计&lt;/strong&gt;，也提供了诸多模式和工具，但却没有一个统一过程去规范这两个阶段需要执行的活动、交付的工件以及阶段里程碑，甚至没有清晰定义这两个阶段如何衔接、它们之间执行的工作流到底是怎么样的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而《解构-领域驱动设计》提出的 DDDRUP 给出了更细致的步骤、步骤与步骤之间的衔接，以及明确的阶段里程碑，最重要的是 DDDRUP 可以串联 DDD 的所有概念和模式，非常便于初学者做知识梳理和上手实践。&lt;strong&gt;下文我会依照 DDDRUP 的步骤流程进行讲述，而非战略设计+战术设计的思路&lt;/strong&gt;。（DDDRUP 各步骤与战略&amp;amp;战术设计的关系见下表）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.32679738562091504&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatg1eXj11xia2icAtgCYHZTfD67YGKuIkqysXSWWeGE4gfGjrn6n0fXJPMWp1qxCJCvF6dCov6JC47g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1071&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.全局分析阶段&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;全局分析阶段对&lt;strong&gt;问题空间&lt;/strong&gt;进行的梳理和分析，&lt;strong&gt;形成统一语言&lt;/strong&gt;（ubiquitous language）, 获取问题空间的&lt;strong&gt;价值需求&lt;/strong&gt;以及&lt;strong&gt;业务需求&lt;/strong&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.1 形成统一语言&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;统一语言&lt;/strong&gt;：蕴含领域知识的、团队内统一的领域术语。产品、领域专家以及开发人员掌握的领域知识存在差异，往往导致对同一个事物使用不同的术语。比如，商品的价格（Price）和商品的金额（Amount），它们本质是同一个东西，但是却有不同的术语表示。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;统一语言会参与 DDDRUP 的全流程，且会在精炼循环过程中不断进行调整，以反映出更合适、更深层次的领域知识。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据业务需求形成统一语言，有助于团队对事物的认知达成一致。统一语言可以通过词汇表的形式展示，其中词汇表最好还要包含术语对应的英文描述，便于研发同学在代码层面表达统一语言。示例-SMS 的统一语言词汇表如下。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3488120950323974&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatg1eXj11xia2icAtgCYHZTfDmFShylKnFvJAbolpKicXLERbVAicwib5q2d4w2mJsVTed0DmMC36lgUpQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1852&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.2 价值需求分析&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;价值需求分析主要做的三个工作是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;识别利益相关者。利益相关者指的是与目标系统存在利益关系的人、团队或组织, 可以简单理解为目标系统的用户，或与目标系统有直接交互的人、团队或组织。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;明确系统愿景。阐明目标系统要做什么，以及为何要做。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;确定系统范围。确定系统问题空间的边界，明确系统什么该做，什么不该做。结合目标系统&lt;strong&gt;当前状态&lt;/strong&gt;和&lt;strong&gt;未来状态&lt;/strong&gt;进行判断。当前状态指的是系统的可用资源，包括业务资源、人力资源，资金资源等；而未来的状态则由业务目标、组织的战略规划和产品规划共同构成。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并非任何系统都 DDD，DDD 的核心是解决领域复杂性，若系统逻辑简单，功能不多，引入 DDD 则会得不偿失。而在进行价值需求分析后，我们便能判断是否需要通过 DDD 驱动系统的设计。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.3 业务需求分析&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;strong&gt;5.3.1 业务流程、业务场景、业务服务和业务规则&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;strong&gt;业务流程、业务场景、业务服务&lt;/strong&gt;和&lt;strong&gt;业务规则&lt;/strong&gt;来表示业务需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;业务流程&lt;/strong&gt;：表示的是一个完整的、端对端的服务过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;业务场景&lt;/strong&gt;：按阶段性的业务目标划分业务流程，就可以获得业务场景。在示例-SMS 中，老师修改成绩就分为了老师“提交申请单”，以及教务员“同意申请单”两个场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;业务服务&lt;/strong&gt;：角色主动向目标系统发起服务请求完成一次&lt;strong&gt;完整&lt;/strong&gt;的功能交互，以实现业务目标。角色可以用户、策略（定时任务）或者其他系统，完整则强调的是业务服务的执行序列的所有步骤都应该是&lt;strong&gt;连续且不可中断&lt;/strong&gt;的。业务服务是业务需求分析最核心，也是最基础的单元，而&lt;strong&gt;业务流程和业务场景是为了更好地分析出业务服务&lt;/strong&gt;。在示例-SMS 中的“同意申请单”场景中包含了两个业务服务：教务员“同意申请单”和系统“邮件通知”教务员。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;业务规则&lt;/strong&gt;：指对业务服务约束的描述，用于控制业务服务的对外行为。业务规则是业务服务正确性的基础。常见的业务规则有：a) 意如“若… , 就….” 的需求描述，比如示例-SMS 中可提炼出“若成绩录入时间间隔超过一周，不予修改”；b) 具有事务性的操作。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.26204564666103125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatg1eXj11xia2icAtgCYHZTfDpjcwAfh7KSCYwepEoxudmBGbCMKBxWS8gMTUz178UbBjgBkNDiakb7Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1183&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;strong&gt;5.3.2 子领域&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过业务流程、业务场景和业务服务的梳理，基本可以分析出业务需求所需要的业务服务。然而，业务服务粒度太细，而问题空间又太大，我们需要找一个更粗粒度的业务单元，来帮助我们对业务服务进行聚类，一方面可以降低管理过多细粒度业务服务导致的额外复杂度，另一方面可以帮助领域专家和开发团队分析问题和设计方案时不至于陷入到业务细节中。而这个更粗粒度的业务单元就是&lt;strong&gt;子领域&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;子领域的作用&lt;/strong&gt;：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;划分问题空间，作为业务服务分类的边界；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用于分辨问题空间的核心问题和次要问题。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;子领域的分类：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;核心子领域&lt;/strong&gt;：能够体现系统愿景，具有产品差异化和核心竞争力的业务服务；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;通用子领域&lt;/strong&gt;：包含的内容缺乏领域个性，具有较强的通用性，例如权限管理和邮件管理；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;支撑子领域&lt;/strong&gt;：包含的内容多为“定制开发”，其为核心子领域的功能提供了支撑。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;子领域的功能分类策略：&lt;/strong&gt;问题空间应该分为哪些子领域，需要团队对目标系统整体进行探索，并根据&lt;strong&gt;功能分类策略&lt;/strong&gt;进行分解。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;业务职能：&lt;/strong&gt;当目标系统运用于企业的生产和管理时，与目标系统业务有关的职能部门往往会影响目标系统的子领域划分，并形成一种简单的映射关系。这是康威定律的一种运用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;业务产品：&lt;/strong&gt;当目标系统为客户提供诸多具有业务价值的产品时，可以按照产品的内容与方向进行子领域划分。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;业务环节&lt;/strong&gt;对贯穿目标系统的核心业务流程进行阶段划分，然后按照划分出来的每个环节确定子领域。（这也是我们最常用的策略）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;业务概念：&lt;/strong&gt;捕捉目标系统中一目了然的业务概念，将其作为子领域。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;划分子领域的过程存在很多经验因素，一个对该行业领域知识了如指掌的领域专家，可以在完成价值需求分析后，结合自身的领域经验，能够选择合适的聚类策略并给出稳定的子领域列表。但，没有领域经验也没有关系！因为根据知识消化循环思路，再经历多个迭代后收敛出来的子领域划分也会逐渐合理，逼急领域专家凭经验得出的子领域划分，只是可能需要的时间要长一些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.架构映射阶段&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在架构映射阶段，我们需要识别限界上下文，并通过上下文映射表示限界上下文之间的协作关系。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.1 限界上下文的定义和特征&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.1.1 限界上下文的定义&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;限界上下文是语义和语境的边界&lt;/strong&gt;。在问题空间，统一语言形成了团队对领域概念的统一表达，子领域形成了领域概念之间的边界。而在解空间，限界上下文可以看做是统一语言+子领域的融合体，统一语言需要在限界上下文内才具有明确的业务含义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以电商购物场景为例。在进行商品下单后，系统会生成一个订单；在用户付款完成后，系统也会生成一个订单；到了物流派送流程，系统还会生成一个订单。虽然这三个步骤中的领域概念都叫订单，但是他们的关注点/职责却不同：商品订单关注的是商品详情，支付订单关注的是支付金额和分润情况，物流订单关注的是收货地址。也就是说，商品、支付和物流分别为三个限界上下文，而订单作为统一语言需要在特定的限界上下文内，我们才能够明确其关注点/负责的职责。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.1.2 限界上下文的特征&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;最小完备：&lt;/strong&gt;限界上下文在履行属于自己的业务能力时，拥有的领域知识是完整的，无须针对自己的信息去求助别的限界上下文。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;自我履行：&lt;/strong&gt;限界上下文能够根据自己拥有的知识来完成业务能力。自我履行体现了限界上下文&lt;strong&gt;纵向切分业务能力&lt;/strong&gt;的特征。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里需要强调一下&lt;strong&gt;业务模块（横向切分）&lt;/strong&gt;和&lt;strong&gt;限界上下文（纵向切分）&lt;/strong&gt;的区别。业务模块不具备完整、独立的业务能力，它没有按照同一个业务变化的方向进行。而限界上下文是对目标系统架构的纵向切分，切分的依据是从业务进行考虑的领域维度。为了提供完整的业务能力，在根据领域维度进行划分时，还需要考虑支撑业务能力的基础设施实现，如与该业务相关的数据访问逻辑，以及将领域知识持久化的数据库模型，形成纵向的逻辑边界，即限界上下文边界。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6235138705416117&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatg1eXj11xia2icAtgCYHZTfDFUPpIiaI0Iwa9yMvXZjSn5dk4atEL8M2qXzre1sAORFOJf0k0kkpUUw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;757&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;稳定空间：&lt;/strong&gt;限界上下文必须防止和减少外部变化带来的影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;独立进化：&lt;/strong&gt;指减少限界上下文内部变化对外界产生的影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述的四个特征可以帮助我们验证识别出来的限界上下文。限界上下文划分是否合理、职责分配是否合理（最小完备 &amp;amp; 自我履行），是否合理运用上下文映射的手段隔离外部变化的影响（稳定空间）、是否有合理的封装，对外提供的接口是否稳定（独立进化）？&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.2 限界上下文的识别&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.2.1 按业务维度识别&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1. 归类&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照业务相关性对业务服务进行归类，业务相关性体现为：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;语义相关性&lt;/strong&gt;：存在相同或相似的领域概念，对应于业务服务描述的名词，如果不同的业务服务操作了相同或相似的对象，即可认为它们存在语义相关性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;功能相关性&lt;/strong&gt;：体现领域行为的相关性，业务服务是否服务于同一个业务目标。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2. 归纳&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;归纳是对归类后的限界上下文进行命名。给限界上下文命名的过程，实际上也是对归类是否合理的再一次复查。限界上下文的命名同样需要遵循单一职责原则，它只能代表唯一的最能体现其特征的领域概念。倘若归类不合理，命名就会变得困难，这时候我们就需要反思（遵循知识消化循环）归类是否合理，并重新设计归类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3. 边界梳理&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;归类和归纳之后，限界上下文的边界基本已经确定，边界梳理则是根据&lt;strong&gt;限界上下文特征（最小完备、自我履行、稳定空间和独立进化）&lt;/strong&gt;以及&lt;strong&gt;子领域&lt;/strong&gt;进行微调（当然也不排除大调）。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;为什么需要根据子领域进行限界上下文边界的调整？限界上下文和子领域的关系是什么？&lt;br/&gt;&lt;br/&gt;理想的限界上下文与子领域的关系是一一对应的。上文提到，子领域是领域专家根据领域经验选择合适的功能分类策略进行划分，这个过程不会牵扯对业务服务的分析，体现的是领域专家对行业的洞见和深刻认识，可见获取子领域是一个自顶向下的过程。而限界上下文则是对业务服务进行归类、归纳、梳理和调整，最终形成一个个的边界，这是一个自下而上的过程。理想情况下，两者应该是双向奔赴的，自顶向下得到的子领域和自下而上得到的限界上下文能够完美契合！但是，现实哪有这么理想呢！所以一般情况下都需要我们进行调整，力求这两者能够一一对应。&lt;br/&gt;&lt;br/&gt;这里就再cue一下知识消化循环。优秀的领域专家划分出来的子领域，往往能够实现与限界上下文的一一对应。这就是经验的力量！那经验是怎么来的呢？我认为是领域专家经历了无数个知识消化循环之后沉淀下来的。领域专家一开始也是小白，划分出来的子领域在映射为限界上下文之后发现不同限界之间可能存在语义重叠，角色在不同限界上下文之中履行的职责可能很相似，于是他们通过知识消化循环，不断调整限界上下文的边界，然后又通过限界上下文调整子领域。慢慢地，稳定、可复用的子领域就被沉淀下来了。因此，识别限界上下文不是一个单向的过程，而是一个根据子领域调整限界上下文，然后又根据限界上下文调整子领域的循环的过程。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;strong&gt;6.2.2 验证&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;正交原则&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正交性：如果两个或更多事物中的一个发生变化，不会影响其他事物，这些事物就是正交的。要破坏变化的传递性，就要保证每个限界上下文对外提供的业务服务不能出现雷同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;奥卡姆剃刀原理&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“如无必要，勿增实体”。这是避免过度设计的良方，同样也是我们识别限界上下文的原则。如果对识别出来的限界上下文的准确性依然心存疑虑，比较务实的做法是&lt;strong&gt;保证限界上下文具备一定的粗粒度&lt;/strong&gt;。遵循该原则，意味着当我们没有寻找到必须切分限界上下文的必要证据时，就不要增加新的限界上下文。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.3 上下文映射&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;限界上下文封装了分离的业务能力，上下文映射则建立了限界上下文之间的关系。上下文映射提供了各种模式（防腐层、开放主机服务、发布语言、共享内核、合作者、客户方/供应方、分离方式、遵奉者、大泥球），&lt;strong&gt;本质是在控制变化在限界上下文之间传递所产生的影响&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下文将提供服务的限界上下文称为“上游”上下文（U 表示），消费服务的限界上下文称为“下游”上下文（D 表示）。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.3.1 防腐层&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引入防腐层的目的是为了&lt;strong&gt;隔离耦合&lt;/strong&gt;。防腐层往往位于下游，通过它隔离上游上下文发生的变化。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.22437673130193905&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatg1eXj11xia2icAtgCYHZTfDo1y9lepRZLEc0NTxLQbDhuKxMy9ChVuBFW2xJcBH0R9bJ2hQjuEgibQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;361&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.3.2 开放主机服务&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开放主机服务定义公开服务的协议（亦称为“服务契约”），包括通信方式、传递消息的格式（协议），让限界上下文可以被当做一组服务访问。开放主机服务也可以视为一种承诺，保证开放的服务不会轻易做出变化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于进程内的开放主机服务，称为&lt;strong&gt;本地服务&lt;/strong&gt;（对应 DDD 中的应用服务）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于进程间的开放主机服务，成为&lt;strong&gt;远程服务&lt;/strong&gt;。根据选择的分布式通信技术的不同，又可以定义出类型不同的远程服务：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;面向服务行为，比如基于 RPC，称为提供者（Provider）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;面向服务资源，比如基于 REST，称为资源（Resource）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;面向事件，比如基于消息中间件，称为订阅者（Subscriber）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;面向视图模型，比如基于 MVC，称为控制器（Controller）；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.22437673130193905&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatg1eXj11xia2icAtgCYHZTfD11TsTfkpO9pia315auxECoSWzKURosZylz2sL7iau9VBgWUPhxnr8x0Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;361&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.3.3 发布语言&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发布语言是一种公共语言，用于两个限界上下文之间的模型转换。防腐层和开放主机服务都是访问领域模型时建立的一层包装，前者针对发起调用的下游（通过基础设施层体现），后者针对响应请求的上游（通过应用层+远程服务），以避免上下游之间的通信集成将各自的领域模型引入进来，造成彼此之间的强耦合。因此，&lt;strong&gt;防腐层和开放主机服务操作的对象都不应该是各自的领域模型&lt;/strong&gt;，这正是引入发布语言的原因。（对于熟悉云 API 的小伙伴就会发现，其实云 API 根据我们定义的接口生成对应的 Request 对象和 Response 对象，并集成在云 API 的 SDK 中，这些对象就是发布语言）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般情况下，发布语言根据开放主机服务的服务契约进行定义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说到这里，我们惊讶地发现&lt;strong&gt;防腐层&lt;/strong&gt;，&lt;strong&gt;开放主机服务&lt;/strong&gt;和&lt;strong&gt;发布语言&lt;/strong&gt;可以完美联动！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.28254847645429365&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatg1eXj11xia2icAtgCYHZTfDsXYB7oo0DqgeXBfP71ep1xZ0zric97ajWYrRDHc3XiahSXacnfCUGJIw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;361&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.3.4 共享内核&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;共享内核指将限界上下文中的领域模型直接暴露给其他限界上下文使用。注意，这会削弱了限界上下文边界的控制力。上面我们讲述的防腐层、开放主机服务以及发布语言无不传达一种思想，限界上下文不能直接暴露自己的领域模型或直接访问其他限界上下文的领域模型，一定要有隔离层！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，在特定的场景下，共享内核不见得不是一种合理的方式。&lt;strong&gt;任何软件设计决策都要考量成本与收益，只有收益高于成本，决策才是合理的。&lt;/strong&gt;一般对于一些领域通用的值对象是相对稳定的，这些类型通常属于通用子领域，会被系统中几乎所有的限界上下文复用，那么这些领域模型就适合使用共享内核的方式。共享内核的收益不言而喻，而面临的风险则是共享的领域模型可能产生的变化。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.27671232876712326&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatg1eXj11xia2icAtgCYHZTfDJDGq2PszLbP5xEKkxE7syG6dTUg5FiaZsvtYsEvuBtktXARM2xaraDw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;365&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.3.5 合作者&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;合作关系指的是协作的限界上下文由不同的团队负责，且这些团队之间具有要么一起成功，要么一起失败的强耦合关系。合作者模式要求参与的团队一起做计划、一起提交代码、一起开发和部署，采用持续集成的方式保证两个限界上下文的集成度与一致性，避免因为其中一个团队的修改影响集成点的失败。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.3.6 客户方/供应方&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一个限界上下文单向地为另一个限界上下文提供服务时，它们对应的团队就形成了客户方/供应方模式。这是最为常见的团队协作模式，客户方作为下游团队，供应方作为上游团队，二者协作的主要内容包括：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;下游团队对上游团队提出的服务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;上游团队提供的服务采用什么样的协议与调用方式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;下游团队针对上游服务的测试策略&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;上游团队给下游团队承诺的交付日期&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当上游服务的协议或调用方式发生变更时，如何控制变更&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.3.7 分离方式&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分离方式的团队协作模式是指两个限界上下文之间没有一丁点关系。如果此时双方使用到了相似/相同的领域模型，则可以通过拷贝的方式解决，保证限界上下文之间的物理隔离！&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.3.8 遵奉者&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当上游的限界上下文处于强势地位，且上游团队响应不积极时，我们可以采用遵奉者模式。即下游严格遵从上游团队的模型，以消除复杂的转换逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当下游团队选择“遵奉”于上游团队设计的模型时，意味着：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;可以直接复用上游上下文的模型（好的）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;减少了两个限界上下文之间模型的转换成本（好的）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使得下游限界上下文对上游产生了模型上的强依赖（坏的）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.3.9 大泥球&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一定要避免制造大泥球！大泥球的特点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;越来越多的聚合因为不合理的关联和依赖导致交叉污染；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对大泥球的维护牵一发而动全身；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;强调“个人英雄主义”，只有个别“超人”能够理清逻辑。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.4 示例-SMS 的限界上下文及其映射&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例-SMS 的限界上下文可划分为：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;成绩上下文&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;课程上下文&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;审批上下文&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;权限上下文&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;邮件上下文&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上下文映射图如下所示。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42459893048128344&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatg1eXj11xia2icAtgCYHZTfDrZOP4zN0G86FMPm2xRaZkJQmIzXDMcEvS4fdWBjThulVyhJR3IE8iag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;935&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.领域建模阶段&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;领域建模阶段由领域分析建模，领域设计建模和领域实现建模组成。在正式讲解建模活动前，先了解一下什么是模型驱动设计。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.1 模型驱动设计&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;模型是一种知识形式，它对知识进行了选择性的简化和有意的结构化，从而解决信息超载的问题。模型便于人们理解信息的意义，并专注核心问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;建模过程一般由&lt;strong&gt;分析活动&lt;/strong&gt;、&lt;strong&gt;设计活动&lt;/strong&gt;和&lt;strong&gt;实现活动&lt;/strong&gt;组成。每一次建模活动都是一次对知识的提炼和转换，并产生相应的模型，即&lt;strong&gt;分析模型&lt;/strong&gt;、&lt;strong&gt;设计模型&lt;/strong&gt;和&lt;strong&gt;实现模型&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;建模过程并非是分析、设计和实现单向的前后串行过程，而是相互影响，不断切换和递进的关系。模型驱动设计的建模过程是：分析中蕴含了设计，设计中夹带了实现，甚至实现后还要回溯到设计和分析的一种&lt;strong&gt;迭代的&lt;/strong&gt;、&lt;strong&gt;螺旋上升的&lt;/strong&gt;演进过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据分解问题的视角不同，我们日常建立的模型可以大致分为以下三类：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;数据模型&lt;/strong&gt;：将问题空间抽取出来的概念视为数据信息，在求解过程中关注数据实体的样式和它们之间的关系，由此建立的模型就是数据模型。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;服务模型&lt;/strong&gt;：将每个问题视为目标系统为客户端提供的服务，在求解过程就会关注客户端发起的请求以及服务返回的响应，由此建立的模型就是服务模型。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;领域模型&lt;/strong&gt;：围绕问题空间的业务需求，在求解过程中力求提炼出表达领域知识的逻辑概念，由此建立的模型就是领域模型。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.1.1 领域模型驱动设计&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个优秀的领域模型应该具备以下的特征（我们也可以说具备这些特征的模型就是领域模型）：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;运用统一语言来表达领域中的概念；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;蕴含业务活动和规则等领域知识；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对领域知识进行适度的提炼和抽象；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;由一个迭代的演进过程建立；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有助于产品、领域专家和开发同学进行交流。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;领域建模阶段目的便是建立领域模型。领域模型由&lt;strong&gt;领域分析模型&lt;/strong&gt;、&lt;strong&gt;领域设计模型&lt;/strong&gt;以及&lt;strong&gt;领域实现模型&lt;/strong&gt;共同组成，它们也分别是领域分析建模、领域设计建模和领域实现建模三个建模活动的产物。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;值得注意的是，领域模型并非由开发团队单方面输出的产物，而是由产品、领域专家和开发团队共同协作的结果。领域专家通过领域模型能够判断系统所支持的领域能力，以及由此编排出来的上层业务能力；开发团队通过领域模型能够形成基本的代码框架（包括架构分层，每层需要定义的接口，接口的命名等）。同理，领域模型的调整，也意味着领域知识或业务规则的变化，也预示着系统所支持的业务能力和代码实现同样需要作出改变。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.2 领域分析建模&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;领域分析建模&lt;/strong&gt;：在限界上下文内，以“领域”为中心，提炼业务服务中的领域概念，确定领域概念之间的关系，最终形成领域分析模型。领域分析模型描述了各个限界上下文中的领域概念，以及领域概念之间的关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面讲述如何通过“快速建模法”来构建领域分析模型。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.2.1 名词建模&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;找到业务服务中的名词，在统一语言指导下将其映射为领域概念。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.2.2 动词建模&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;识别动词并不是为领域模型对象分配职责、定义方法，而是将识别出来的动词当做一个领域行为，然后看它是否产生了影响管理、法律或财务的&lt;strong&gt;过程数据&lt;/strong&gt;。若存在，则将这些过程数据作为领域概念放到领域分析模型中。注意，这里的过程数据是要求会对企业运营和管理产生影响的数据，比如示例-SMS 系统中老师提交修改申请，就会产生&lt;strong&gt;申请单&lt;/strong&gt;这个过程数据，而请求流水记录、任务执行记录都不属于过程数据。动词建模通过分析领域行为是否产生过程数据来找到隐藏的领域概念，弥补了名词建模的不足。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;特别地，对于会产生领域事件的动词，一般可以抽象出一个已完成该动作的状态。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.2.3 提取隐式概念&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了“名词”和“动词”，概念中其他重要的类别也可以在模型中显式地表现出来，主要包括：&lt;strong&gt;约束&lt;/strong&gt;和&lt;strong&gt;规格&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;约束&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;约束一般是对领域概念的限制，我们可以将约束条件提取到自己的方法中，并通过方法名显式地表达约束的含义。比如示例-SMS 中关于 GPA 运算的约束。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8878048780487805&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatg1eXj11xia2icAtgCYHZTfDo6toDLW4hIq9oFrqYEiagB3ziacHoibgEMWbib2Kclp6EUhHSLCFxBs9Sg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;410&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些时候，约束条件无法用单独一个方法来轻松表达，抑或约束条件中会使用到与对象职责无关的信息，那么我们就可以将其提取到一个显式的对象中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;规格（SPECIFICATION）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多时候业务规则并不适合作为实体或值对象的职责，而且规则的变化和组合也会掩盖领域对象的含义。但是，将规则移出领域层则导致领域代码无法表达模型。此时，我们可以定义&lt;strong&gt;规格&lt;/strong&gt;（&lt;strong&gt;谓词形式&lt;/strong&gt;的显式&lt;strong&gt;值对象&lt;/strong&gt;），它用于确定对象是否满足指定的标准。规格将规则保留在领域层，由于规格是一个完备的对象，所以这种设计也能更加清晰地反映模型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;规格一般有如下三种用法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;（验证）验证对象，检查它是否能满足某些标准，比如示例-SMS 中成绩实体在修改分数时就需要通过规约判断当前是否满足修改的标准；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;（选择）从集合中选择一个符合要求的对象，&lt;strong&gt;可以搭配资源库使用&lt;/strong&gt;；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;（根据要求来创建）指定在创建新对象时必须满足某种要求。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.358&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatg1eXj11xia2icAtgCYHZTfD00AxBiaNWCG0rfHNEdl2GBeia4AzB9sC8NQFaicaOMj12IdXwvvMpNvZw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;500&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;规格由“谓词”概念演变而来，因此我们可以使用“AND”，“OR”和“NOT”等运算对规格进行组合和修改。比如在 SMS 中，教务员需要查询流程完结的申请单，我们就可以通过“AND”组合不同的规格进行实现。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.16199756394640683&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatg1eXj11xia2icAtgCYHZTfDL0YiakhGx9INF0Ks0ITWpxEtxQHNpKAPic5yUhMLBsrjiaE8gWFpbOI3w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1642&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.2.4 归纳抽象&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于有定语修饰的名词，要注意分辨它们是&lt;strong&gt;类型的差异&lt;/strong&gt;，还是&lt;strong&gt;值的差异&lt;/strong&gt;。如配送地址和家庭地址，订单状态和商品状态。如果是值的差异，类型相同，应归并为一个领域概念（如，配送地址和家庭地址）；而类型不同，则不能合并（如，订单状态和商品状态）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;特别地，当定语修饰的名词中，定语表示的是不同的限界上下文，且名词相同时（即名称相同、含义不同的领域概念），我们应该尽可能调整命名，确保含义不同的领域概念的名称不同，以避免不必要的歧义和沟通上的误解。比如：商品的订单和库存的订单在特定限界上下文内都可以命名为 order，但是如果把库存的订单改为库存的配送单 delivery 效果会更好。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.2.5 确认关系&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据业务需求和领域知识，判断领域概念之间是否存在关联。且对于 1:N, N:1, M:N 的关联关系，我们需要判断是否可以为这些关联关系定义一个新的类型，比如作品与读者存在 1:N 的关系，我们可以定义“订阅”这个概念来描述这种关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意，我们需要尽量避免对象中的双向关系，即对象 A 关联对象 B，而对象 B 关联对象 A。当两个对象存在双向关系时，会为管理他们的生命周期带来额外的复杂度。我们应该规定一个遍历方向，来表明&lt;strong&gt;一个方向的关联比另一个方向的关联更有意义且更重要&lt;/strong&gt;，比如示例 SMS 中，成绩会关联课程（成绩实例中包含课程 ID），而课程不会关联成绩。当然，当双向关系是领域的一个概念时，我们还是应该保留它。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.2.6 示例-SMS 的领域分析模型&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过名词建模，动词建模和归纳抽象后，可提炼出以下领域对象：成绩（Result）、绩点（gpa）、总成绩（total result）、总绩点（total gpa）、学年（school year）、学期（semester）、课程（course）、学分（credit）、申请单（application receipt），邮件（mail），排名（rank），申请单状态（application receipt status）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些领域对象之间的关系如下图所示。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5619546247818499&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatg1eXj11xia2icAtgCYHZTfDHiacnZUib14cWnr9iabFOLHB5UOumf89JgCzNqu4XVUuodlhkWYXdGPdg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;573&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.3 领域设计建模&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;领域设计建模的核心工作就是&lt;strong&gt;设计聚合&lt;/strong&gt;和&lt;strong&gt;设计服务&lt;/strong&gt;，在这之前我们需要先了解一下设计要素（实体、值对象、聚合、工厂、资源库、领域服务、领域事件）。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.3.1 设计要素&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;领域驱动设计强调以“领域”为核心驱动力。设计领域模型时应该尽量避免陷入到技术实现的细节约束中。但很多时候我们又不得不去思考一些非领域相关的问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;领域模型对象在身份上是否存在明确的差别？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;领域模型对象的加载以及对象间的关系如何处理？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;领域模型对象如何实现数据的持久化？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;领域模型对象彼此之间如何做到弱依赖地完成状态的变更通知？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解答上述的四个问题，&lt;strong&gt;DDD 提供了很多的设计要素，它们能够帮助我们在不陷入到具体技术细节的情况下进行领域模型的设计&lt;/strong&gt;。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;strong&gt;7.3.1.1 实体&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实体的核心三要素：&lt;strong&gt;身份标识&lt;/strong&gt;、&lt;strong&gt;属性&lt;/strong&gt;和&lt;strong&gt;领域行为&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;身份标识&lt;/strong&gt;：身份标识的主要目的是管理实体的生命周期。身份标识可分为：通用类型和领域类型。通用类型 ID 没有业务含义；而领域类型 ID 则组装了业务逻辑，建议使用值对象作为领域类型 ID。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;属性&lt;/strong&gt;：实体的属性用来说明主体的静态特征，并持有数据与状态。属性分为：原子属性和组合属性。组合属性可以是实体，也可以是值对象，取决于该属性是否需要身份标识。我们应该尽可能将实体的属性定义为组合属性，以便于在实体内部形成各自的抽象层次。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;领域行为&lt;/strong&gt;：体现了实体的动态特征。实体具有的领域行为一般可以分为：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;变更状态的领域行为&lt;/strong&gt;：变更状态的领域行为体现的是实体/值对象内部的状态转移，对应的方法入参为期望变更的状态。（有入参，无出参）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;自给自足的领域行为&lt;/strong&gt;：自给自足意味着实体对象只操作了自己的属性，不外求于别的对象。（无入参）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;互为协作的领域行为&lt;/strong&gt;：需要调用者提供必要的信息。（有入参，有出参）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;创建行为&lt;/strong&gt;：代表了对象在内存的从无到有。创建行为由构造函数履行，但对于创建行为较为复杂或需要表达领域语义时，我们可以在实体中定义简单工厂方法，或使用专门的工厂类进行创建。（有出参，且出参为特定实体实例）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;7.3.1.2 值对象&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个领域概念到底该用值对象还是实体类型，判断依据：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;业务的参与者对它的相等判断是依据值还是依据身份标识；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;确定对象的属性值是否会发生变化，如果变化了，究竟是产生一个完全不同的对象，还是维持相同的身份标识；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;生命周期的管理。值对象无需进行生命周期管理。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;值对象具有不变性&lt;/strong&gt;。值对象完成创建后，其属性和状态就不应该再进行变更了，如果需要更新值对象，则通过创建新的值对象进行替换。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于值对象的属性是在其创建的时候就完成传入的，那么值对象所具有的领域行为大部分情况下都是“自给自足的领域行为”，即入参为空。这些领域行为一般提供以下的能力。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;自我验证&lt;/strong&gt;：验证传入值对象的外部数据是否正确，一般在创建该值对象时进行验证。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;自我组合&lt;/strong&gt;：当值对象涉及到数值运算时，可以定义相同类型值对象的方法，使值对象具有自我组合能力。比如示例-SMS 中，在统计成绩时会涉及学分相加的运算，因此我们可以将相加运算定义为可组合的方法，便于调用者使用。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.03647798742138365&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatg1eXj11xia2icAtgCYHZTfDPDZh4yTxETCjER0GibY4Y7dFFbSAUibU6bqvGBWnPu4kHmW8Jk6cAvEQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1590&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.04715969989281887&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatg1eXj11xia2icAtgCYHZTfDk7lSFq7wTpV1wVtSWCTuRzZwOicyTtCib4yicCLRiaVT95r4zSIK32k6jA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1866&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在进行领域设计建模时，要善于运用值对象而非内建类型去表达细粒度的领域概念。相比于内建类型，值对象的优势有：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;值对象在类型层面就可以表达领域概念，而不仅仅依赖命名；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;值对象可以封装领域行为，进行自我验证，自我组合，自我运算。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;7.3.1.3 聚合&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;聚合的基本特征：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;聚合是包含了实体和值对象的一个边界。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;聚合内包含的实体和值对象形成一棵树，只有实体才能作为这棵树的根。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;外部对象只允许持有聚合根的引用，以起到边界控制作用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;聚合作为一个完整的领域概念整体，其内部会维护这个领域概念的完整性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;由聚合根统一对外提供履行该领域概念职责的行为方法，实现内部各个对象之间的行为协作。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;7.3.1.4 工厂&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;聚合中的工厂：一个类或方法只要封装了聚合对象的创建逻辑，都可以认为是工厂。表现形式如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;引入专门的聚合工厂（尤其适合需要通过访问外部资源来完成创建的复杂创建逻辑）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;聚合自身担任工厂（简单工厂模式）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务契约对象或装配器（assembler）担任工厂（负责将外部请求对象 DTO 转换为实体）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用构建者组装聚合&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意！这里工厂创建的基本单元是聚合，而非实体，注意与实体中的创建行为区分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;7.3.1.5 资源库&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;资源库是对数据访问的一种业务抽象，用于解耦领域层与外部环境，使领域层变得更为纯粹。资源库可以代表任何可以获取资源的仓库，例如网络或其他硬件环境，而不局限于数据库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;一个聚合对应一个资源库&lt;/strong&gt;。领域驱动设计引入资源库，主要目的是管理聚合的生命周期。资源库负责聚合记录的查询与状态变更，即“增删改查”操作。资源库分离了聚合的领域行为和持久化行为，保证了领域模型对象的业务纯粹性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;值得注意的是，资源库的操作单元是聚合。当我们定义资源库的接口时，接口的入参应该为聚合的根实体。如果要访问聚合内的非根实体，也只能通过资源库获得整个聚合后，将根实体作为入口，在内存中访问封装在聚合边界内的非根实体对象。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;资源库与数据访问对象（DAO）的区别：&lt;br/&gt;&lt;br/&gt;根本区别在于，数据访问对象在访问数据时，并无聚合的概念，也就是没有定义聚合的边界约束领域模型对象，使得数据访问对象的操作粒度可以针对领域层的任何模型对象。数据访问对象（DAO）可以自由地操作实体和值对象。没有聚合边界控制的数据访问，会在不经意间破坏领域概念的完整性，突破聚合不变量的约束，也无法保证聚合对象的独立访问与内部数据的一致性。&lt;br/&gt;&lt;br/&gt;其次，资源库是基于领域模型对存储系统进行的抽象，因此资源库中的方法命名可以表达领域概念；而数据访问对象（DAO）是存储系统对外暴露的抽象，其方法命名更贴合数据库本身的操作。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;**7.3.1.6 领域服务
**&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;聚合通过聚合根的领域行为对外提供服务，而&lt;strong&gt;领域服务则是对聚合根的领域行为的补充&lt;/strong&gt;。因此，我们应该尽量&lt;strong&gt;优先通过聚合根的领域行为来满足业务服务&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那什么场景下我们会需要用到领域服务呢？有如下两个：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;生命周期管理&lt;/strong&gt;。为了避免领域知识的泄露，应用服务不会直接引用聚合生命周期相关的服务（工厂、资源库接口），而聚合根实体一般不会依赖资源库接口，此时就需要领域服务进行组合对外暴露。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;依赖外部资源&lt;/strong&gt;。&lt;strong&gt;为了保证聚合的稳定性，聚合根实体不会依赖防腐层接口&lt;/strong&gt;。因此，当聚合对外暴露的服务需要设计外部资源访问时，就需要通过领域服务来完成。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;7.3.1.7 领域事件&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;领域事件属于领域层的领域模型对象，由限界上下文中的聚合发布，感兴趣的聚合（同一限界上下文/不同限界上下文）可以进行消费。而当一个事件由应用层发布，则该事件为应用事件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引入领域事件首要目的是更好地跟踪实体状态的变更，并在状态变更时，通过事件消息的通知完成领域模型对象之间的协作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;领域事件的特征&lt;/strong&gt;：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;领域事件代表了领域的概念；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;领域事件是已经发生的事实（表示事件的名称应该是过去时，比如 Committed）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;领域事件是不可变的领域对象；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;领域事件会基于某个条件而触发。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;领域事件的用途&lt;/strong&gt;：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;发布状态变更；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;发布业务流程中的阶段性成果；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;异步通信。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;领域事件应该包含：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;身份标识，即事件 ID，为通用类型的身份标识；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;事件发生的时间戳，便于记录和跟踪；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;属性需要针对订阅者的需求，在&lt;strong&gt;增强事件&lt;/strong&gt;和&lt;strong&gt;反向查询&lt;/strong&gt;之间进行权衡。增强事件指属性中包含订阅者所需的所有数据；反向查询则是属性包含事件 ID，当订阅者需要数据时通过事件 ID 进行反向查询。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.3.2 设计聚合&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在领域设计模型中，聚合是最小的设计单元。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;7.3.2.1 设计的经验法则&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有四条经验法则：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在聚合边界内保护业务规则不变性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;聚合要设计得小巧。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过身份标识符关联关系其他聚合。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用最终一致性更新其他聚合。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面展开讲述法则 1 和法则 3。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;法则 1&lt;/strong&gt; &lt;strong&gt;在聚合边界内保护业务规则不变性&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;法则 1 包含了两个关键点：a) 参与维护业务规则不变性的领域概念应该置于同一个聚合内；b) 在任何情况下都要保护业务规则不变性。比如，在 sms 系统中分数和绩点具有转换关系，这是业务规则的不变性，因此这两个概念被放在了同一个聚合边界内；当出现老师修改分数的场景时，需要保证绩点的换算同时被执行。由于这里绩点对象是值对象，不需要关心其生命周期管理的问题。当业务规则涉及到多个实体时，就需要通过&lt;strong&gt;本地事务&lt;/strong&gt;来保证规则不变性（即实体间基于业务规则的数据一致性）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;法则 3 通过身份标识符关联其他聚合。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意这里强调了&lt;strong&gt;关联关系&lt;/strong&gt;，关联关系会涉及聚合 A 对聚合 B 的生命周期管理的问题，对于这种聚合间的关联关系，我们通过&lt;strong&gt;身份标识&lt;/strong&gt;建立关联。而当聚合 A 引用聚合 B，但不需要对聚合 B 进行生命周期管理时，我们认为这是一种&lt;strong&gt;依赖关系&lt;/strong&gt;（比如方法中的入参，而非类中的属性），对于聚合间的依赖关系，我们可以通过&lt;strong&gt;对象引用&lt;/strong&gt;（聚合根实体的引用）的方式建立依赖。（PS：假设设计之初难以判断聚合之间到底是关联关系，还是依赖关系，我们就统一使用身份标识符作为关系引用即可）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.29656607700312176&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatg1eXj11xia2icAtgCYHZTfDAnvibkrBzqLFyTQ3IVFdTd7qrSa2j41iamHhABgdleztafOawAZYib0cw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1922&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;聚合间的依赖关系通常分为两种方式&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;职责的委派：一个聚合作为另一个聚合的方法参数， 就会形成职责的委派。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;聚合的创建：一个聚合创建另外一个聚合，就会形成实例化的依赖关系。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;7.3.2.2 设计步骤&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1. 理顺对象图&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分析对象是实体还是值对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2. 分解关系薄弱处&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;聚合本质是一个高内聚的边界，因此我们可以根据领域对象之间关系的强弱来定义出聚合的边界。对象间的关系由强到弱可以分为：泛化关系，关联关系和依赖关系。其中关联关系和依赖关系在 7.3.2.1 小节已讲述，而泛化关系可以理解为是继承关系（即父子关系）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;泛化关系&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然泛化关系是强耦合关系，但是根据对业务理解的视角不同，会产生不同的设计：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;整体视角：调用者并不关心特化的子类之间的差异，而是将整个继承体系视为一个整体。此时应以泛化的父类作为聚合根。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;独立视角：调用这只关注具体的特化子类，体现了概念的独立性，此时应以特化的子类作为独立的聚合根。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;关联关系&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述提到过，聚合间的关联关系会涉及聚合 A 对聚合 B 的生命周期管理，这其实是一个比较宽松的约束。那聚合内实体的关联关系应该是怎么样的呢？&lt;strong&gt;生命周期一致的、共存亡的，当主实体被销毁时，从实体也随之会被销毁。&lt;/strong&gt;比如商品实体和商品明细实体。而在示例-SMS 中，成绩和总成绩会被定义为两个聚合，原因是总成绩在成绩锁定后被统计，随后将不再发生改变，可见两者不存在上述的共存亡的关联关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PS: 实际上&lt;strong&gt;根据关联关系来区分边界的方法同样适用于限界上下文的边界划分&lt;/strong&gt;。比如示例-SMS 中的课程和成绩生命周期不同，先有课程，后有成绩；而且成绩锁定后，课程被撤销也不会对成绩有影响，因此就可以定义出课程上下文和成绩上下问。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;依赖关系&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;依赖关系主要体现的是实体间的职责委派和创建行为，可以分到不同的聚合边界。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3. 调整聚合边界&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据&lt;strong&gt;业务规则&lt;/strong&gt;调整聚合边界。为了维护业务规则的不变性，相关的实体应该至于同一个聚合边界内。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.3.3 设计服务&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的服务是对&lt;strong&gt;应用服务&lt;/strong&gt;、&lt;strong&gt;领域服务&lt;/strong&gt;、&lt;strong&gt;领域行为&lt;/strong&gt;（实体提供的方法）和&lt;strong&gt;端口&lt;/strong&gt;（资源库接口、防腐层接口）的统称。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;strong&gt;7.3.3.1 分解任务&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;业务服务&lt;/strong&gt;包含若干个&lt;strong&gt;组合服务&lt;/strong&gt;，组合服务包含若干个&lt;strong&gt;原子服务&lt;/strong&gt;。&lt;strong&gt;领域行为&lt;/strong&gt;和&lt;strong&gt;端口&lt;/strong&gt;都可以认为是原子服务。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;strong&gt;7.3.3.2 分配职责&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;应用服务：&lt;/strong&gt;匹配业务服务，提供满足业务需求的服务接口。应用服务自身并不包含任何领域逻辑，仅负责协调领域模型对象，通过它们的领域能力组合完整一个完整的应用目标。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;领域服务：&lt;/strong&gt;匹配组合服务，执行业务功能，若原子任务为无状态行为或独立变化的行为，也可以匹配领域服务。控制多个聚合与端口之间的协作，由它来承担组合任务的执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;领域行为：&lt;/strong&gt;匹配原子服务，提供业务功能的业务实现。强调无状态和独立变化，由实体提供。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;端口：&lt;/strong&gt;匹配原子服务，抽象对外资源的访问，主要的端口包括资源库接口和防腐层接口。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;虽然上述给出了应用服务、领域服务、领域行为和端口与业务服务、组合服务和原子服务的匹配关系，但是对于应用服务、领域服务、领域行为和端口之间的关联关系却还不清晰，这里结合书中内容和个人实践给出一个参考。&lt;br/&gt;&lt;br/&gt;应用服务：核心职责是编排聚合间的领域服务。&lt;br/&gt;- 领域服务&lt;br/&gt;- 防腐层接口：当多聚合间领域服务进行协作后需要访问外部资源，此时相关的防腐层逻辑应该至于应用层。（防腐层是上下文映射的方式，并非领域模型特有）&lt;br/&gt;- 工厂：特指服务契约对象或装配器担任工厂，即将DTO转换为实体的工厂。&lt;br/&gt;- 领域行为：在上述工厂创建实体后，若只需要调用实体的领域行为，而不需要涉及生命周期管理，可直接在应用服务中进行调用。&lt;br/&gt;&lt;br/&gt;领域服务：细粒度的领域对象可能会把领域层的知识泄露到应用层中。这产生的结果是应用层不得不处理复杂的、细致的交互，从而使得领域知识蔓延到应用层或用户界面代码当中，而领域层会丢失这些知识。明智地引入领域层服务有助于在应用层和领域层之间保持一条明确的界限，因此应用层多数情况下也不会直接引用聚合的领域行为。&lt;br/&gt;- 工厂&lt;br/&gt;- 领域行为&lt;br/&gt;- 防腐层接口：聚合内需要依赖外部资源，则将防腐逻辑收拢在领域服务中。&lt;br/&gt;- 资源库接口&lt;br/&gt;&lt;br/&gt;领域行为：不要关联资源库和防腐层接口。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.3.4 示例-SMS 的领域设计模型&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;聚合设计&lt;/strong&gt;：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6405228758169934&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatg1eXj11xia2icAtgCYHZTfDkJHR1QicSSEnXtlIic9FibW0skqrb3xCqf7SRgzsIH9rfs1lK4fNVvrLQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;612&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;服务设计&lt;/strong&gt;：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面只罗列非查询类的服务设计。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2362385321100917&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatg1eXj11xia2icAtgCYHZTfDNlsDwwJAN1v1GZTGTUrDgvys3XFyRXSOy3tBYnvdgTn4C5tjSAjiaCA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;872&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8360655737704918&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatg1eXj11xia2icAtgCYHZTfD790p6nxco378w7JLgIxxTIAuzh8pq8a46f9HRXXhmmgswRricYUZBLg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;732&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0877944325481799&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatg1eXj11xia2icAtgCYHZTfDlLHO7ouib4WEEBqfj3BsicL1icXuFYIBiaWRp6fM2yUTrlzAyOZxPeOzZg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;934&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.4 领域实现建模&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;领域实现建模关注的并非是如何进行代码实现，而是&lt;strong&gt;如何验证代码实现的正确性，保证实现的高质量&lt;/strong&gt;。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.4.1 领域模型与测试金字塔&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;领域模型中的服务包括了&lt;strong&gt;应用服务&lt;/strong&gt;、&lt;strong&gt;领域服务&lt;/strong&gt;、&lt;strong&gt;领域行为&lt;/strong&gt;和&lt;strong&gt;端口&lt;/strong&gt;。其中通过 Provider（面向服务行为）、Resource（面向服务资源）、Subscriber（面向事件）、Controller（面向视图模型）对外进行暴露的，我们称为&lt;strong&gt;远程服务&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;领域模型中的服务与测试金字塔的关系如下图所示。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3541341653666147&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatg1eXj11xia2icAtgCYHZTfDT3JT1sTAqkkG6MxSTKogUmlMjkR2VibeR44yu2NwdbCZiaeGzk2Dibu0g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;641&quot;/&gt;&lt;/figure&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.4.2 测试驱动开发&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;领域实现建模提倡的是&lt;strong&gt;测试驱动开发&lt;/strong&gt;的编程思想，即要求开发者在进行逻辑实现前，优先进行测试用例的编写，&lt;strong&gt;站在调用者角度而非实现者角度&lt;/strong&gt;去思考接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上述测试金字塔中，开发者需要关注的是单元测试（不依赖任何外部资源的测试就是单元测试）。在领域设计建模阶段，我们对业务服务/应用服务进行分解，定义出了领域行为和领域服务。对于领域行为，由于其不依赖外部资源，因此我们可以直接编写单元测试；而对于领域服务，其可能会通过端口访问外部资源，此时我们需要对端口进行 mock，以隔离外部资源对领域逻辑验证的干扰。特别地，&lt;strong&gt;单元测试一定要覆盖所有对业务规则的验证&lt;/strong&gt;，这是保证领域行为和领域服务正确性的基础。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单元测试编码规范：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;测试类的命名应与被测试类保持一致，为“被测类名称+Test 后缀”。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;测试方法表达业务或业务规则为目的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;测试方法体遵循 Given-When-Then 模式。&lt;strong&gt;Given&lt;/strong&gt;: 为要测试的方法提供准备，包括创建被测试对象，为调用方法准备输入参数实参等；&lt;strong&gt;When&lt;/strong&gt;: 调用被测试的方法，遵循单一职责原则，在一个测试方法的 When 部分，应该只有一条语句对被测方法进行调用；&lt;strong&gt;Then&lt;/strong&gt;: 对被测方法调用后的结果进行预期验证。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8.分层架构与代码骨架&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8.1 分层架构&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9147121535181236&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatg1eXj11xia2icAtgCYHZTfDhwwBnU5br6b31ib1Z9NkaxgC1fpNptzKPsTShicd2EXRvrRUqiahE5ZPA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;469&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码架构分层是经典 DDD 四层：&lt;strong&gt;用户接口层&lt;/strong&gt;，&lt;strong&gt;应用层&lt;/strong&gt;，&lt;strong&gt;领域层&lt;/strong&gt;和&lt;strong&gt;基础设施层&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的的地方是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;用户接口层根据通信方式的不同，区分开了 Provider（面向服务行为）、Subscriber（面向事件）、Controller（面向视图模型&amp;amp;资源） 、Task（面向策略/定时任务）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;基础设施层单独划分了 infranstructure-impl 模块。为了保证领域层的纯洁性，DDD 通过依赖倒置把访问外部系统（数据库，第三方系统）的服务的实现都下放到了基础设施层，而 infranstructure-impl 模块 则是对这些实现进行了归集。这样做的好处有两个：第一，依赖关系明确，（infransturcture-impl —&amp;gt; domain，application）, （interface、application、domain —&amp;gt; infranstructure）；第二，拆分服务更便捷。当我们需要部分领域独立拆分出来的时候，在实现层面就只需要关注 infransturcture-impl 模块 即可。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Infranstructure-impl 模块依赖应用层的原因是应用层可能会抽象出防腐层接口，需要 infranstruct-impl 为其提供实现。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8.2 代码骨架&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8.2.1 用户接口层&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户接口层的核心职能：协议转换和适配、鉴权、参数校验和异常处理。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;├── controller                             //面向视图模型&amp;amp;资源&lt;br/&gt;│   ├── ResultController.java&lt;br/&gt;│   ├── assembler                         // 装配器，将VO转换为DTO&lt;br/&gt;│   │   └── ResultAssembler.java&lt;br/&gt;│   └── vo                                // VO(View Object)对象&lt;br/&gt;│       ├── EnterResultRequest.java&lt;br/&gt;│       └── ResponseVO.java&lt;br/&gt;├── provider                               // 面向服务行为&lt;br/&gt;├── subscriber                             // 面向事件&lt;br/&gt;└── task                                   // 面向策略&lt;br/&gt;    └── TotalResultTask.java&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8.2.2 应用层&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应用层的核心职能：编排领域服务、事务管理、发布应用事件。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;├── assembler                              // 装配器，将DTO转换为DO&lt;br/&gt;│   ├── ResultAssembler.java&lt;br/&gt;│   └── TotalResultAssembler.java&lt;br/&gt;├── dto                                    // DTO(Data Transfer Object)对象&lt;br/&gt;│   ├── cmd                                // 命令相关的DTO对象&lt;br/&gt;│   │   ├── ComputeTotalResultCmd.java&lt;br/&gt;│   │   ├── EnterResultCmd.java&lt;br/&gt;│   │   └── ModifyResultCmd.java&lt;br/&gt;│   ├── event                             // 应用事件相关的DTO对象, subscriber负责接收&lt;br/&gt;│   └── qry                               // 查询相关的DTO对象&lt;br/&gt;└── service                                // 应用服务&lt;br/&gt;    ├── ResultApplicationService.java&lt;br/&gt;    ├── event                              // 应用事件，用于发布&lt;br/&gt;    └── adapter                            // 防腐层适配器接口&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8.2.3 领域层&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码组织以聚合为基本单元。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;├── result                                 // 成绩聚合&lt;br/&gt;│   ├── entity                            // 成绩聚合内的实体&lt;br/&gt;│   │   └── Result.java&lt;br/&gt;│   ├── service                           // 领域服务&lt;br/&gt;│   │   ├── ResultDomainService.java&lt;br/&gt;│   │   ├── event                         // 领域事件&lt;br/&gt;│   │   ├── adapter                       // 防腐层适配器接口&lt;br/&gt;│   │   ├── factory                       // 工厂&lt;br/&gt;│   │   └── repository                    // 资源库&lt;br/&gt;│   │       └── ResultRepository.java&lt;br/&gt;│   └── valueobject                        // 成绩聚合的值对象&lt;br/&gt;│       ├── GPA.java&lt;br/&gt;│       ├── ResultUK.java&lt;br/&gt;│       ├── SchoolYear.java&lt;br/&gt;│       └── Semester.java&lt;br/&gt;└── totalresult                             // 总成绩聚合&lt;br/&gt;    ├── ... 这段有点长，其代码结构与成绩聚合一致，因此省略 ...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8.2.4 基础设施实现层&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该层主要提供领域层接口（资源库、防腐层接口）和应用层接口（防腐层接口）的实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码组织基本以聚合为基本单元。对于应用层的防腐层接口，则直接以 application 作为包名组织。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;├── application                                  // 应用层相关实现&lt;br/&gt;│   └── adapter                                 // 防腐层适配器接口实现&lt;br/&gt;│       ├── facade                              // 外观接口&lt;br/&gt;│       └── translator                          // 转换器，DO -&amp;gt; DTO&lt;br/&gt;├── result                                       // 成绩聚合相关实现&lt;br/&gt;│   ├── adapter&lt;br/&gt;│   │   ├── facade&lt;br/&gt;│   │   └── translator&lt;br/&gt;│   └── repository                              // 成绩聚合资源库接口实现&lt;br/&gt;│       └── ResultRepositoryImpl.java&lt;br/&gt;└── totalresult                                  // 总成绩聚合相关实现&lt;br/&gt;    ├── adapter&lt;br/&gt;    │   ├── CourseAdapterImpl.java&lt;br/&gt;    │   ├── facade&lt;br/&gt;    │   └── translator&lt;br/&gt;    └── repository&lt;br/&gt;        └── TotalResultRepositoryImpl.java&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9.杂谈&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9.1 DDD 与微服务&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;微服务拆解&lt;/strong&gt;指的是把一个单体服务拆分为粒度“足够小”的多个服务，而这里的“足够小”是一个主观的，没有任何标准的定义。尽管如此，我们对“&lt;strong&gt;微&lt;/strong&gt;”这个词还是有一些基本要求的：足够内聚，足够独立，足够完备，这才使得拆分出来的微服务收益大于投入，试想如果一个微服务提供的业务功能会牵扯到与其他众多微服务的协作，那岂不是芭比 Q 了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而上述我们对微服务的基本要求，实际上与限界上下文的特征（最小完备，自我履行，稳定空间，独立进化）不谋而合，因此，我们可以把&lt;strong&gt;限界上下文映射为微服务&lt;/strong&gt;。我在日常实践中，都是将限界上下文和微服务的关系进行一一对应的，但这不是绝对的！限界上下文是站在领域角度给出的逻辑边界，而微服务的设计往往还要考虑物理边界，以及实际的质量需求（性能，可用性，安全性等），比如当我们采用的是 CQRS 架构，领域模型会被分为命令模型和查询模型，虽然它们同属一个限界上下文，但是它们往往是物理隔离的。因此，限界上下文只能作为微服务拆分的指导，而拆分过程中需要考虑质量需求，架构设计等技术因素。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5706422018348624&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatg1eXj11xia2icAtgCYHZTfDgvYRO79PbY43svEJibu7KzGV5zXrD734qXRJvia0eDxWhrNquLJShhNA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;545&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9.2 事务&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9.2.1 本地事务&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上文在提及限界上下文识别和聚合设计的时候其实都提到需要考虑事务属性，即需要通过本地事务来保证业务规则的不变性/一致性。这里我们会疑惑的是：&lt;strong&gt;谁来承担管理事务的职责？事务管理的边界是什么？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;应用层承担管理事务的职责&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事务本质是一种技术手段，而领域模型本身与技术无关，因此事务应该由应用层负责管理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;事务管理的边界是聚合，有时限界上下文也可以&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;资源库操作的基本单元是聚合，因此事务管理的边界是聚合便是自然而然得出的结论。这里需要考虑的是当需要保证事务属性的不仅仅只有资源库操作，还包括发布领域事件时（即保证聚合落库和事件发布的原子性），我们可能需要采用&lt;strong&gt;可靠事件模式&lt;/strong&gt;，即通过把领域事件落库事件表来表示事件的发布。此时应用层在管理事务时就没什么心智负担了。当然，采用可靠事件模式实际是限制了领域模型的实现，也算是技术对领域模型的一种入侵吧，但相比于解放应用层而言，应该是利大于弊。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们也知道，应用层的核心职责是负责编排和协调不同聚合的领域服务，而应用层又负责事务管理，自然我们能推到出事务管理的边界是多个聚合（即限界上下文）。但这里有两个关注点：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;a）一般是出于质量需求（性能会好一些，时效性更高一些）；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;b）同一个限界上下文内的多个聚合共享一个 DB。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9.2.2 Saga 事务&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了避免耦合，DDD 主张通过柔性事务来保证跨聚合、跨限界上下文的最终一致性。而目前业界比较主流的应用是 Saga 模式：&lt;strong&gt;通过使用异步消息来协调一系列本地事务，从而维度多个服务之间的数据一致性&lt;/strong&gt;。而另一个非常著名的柔性事务方案 TCC 为啥没有 Saga 契合呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCC 共分为三个阶段：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Try 阶段：准备阶段，对资源进行锁定或预留；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Confirm 阶段：提交阶段，执行实际的操作；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Cancel 阶段：补偿阶段，任意执行的操作出错了，就需要执行补偿，即释放 Try 阶段预留的资源。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到 TCC 实际对领域模型的侵入是比较大的：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;a）TCC 要求领域模型设计时，定义相关的属性以支持资源锁定/预留的问题；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;b）TCC 对服务接口定义做出了要求，领域模型需要提供 Try，Confirm 和 Cancel 相应的领域服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Saga 模式并不要求其对资源进行锁定/预留，而其补偿操作也是通过执行操作的&lt;strong&gt;逆操作&lt;/strong&gt;来完成（比如支付的逆操作是退款）。而大部分情况下，完整的领域模型都会对外提供操作及其逆操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10. 参考&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;《解耦-领域驱动设计》&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;《领域驱动设计：软件核心复杂性应对之道》&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;《实现领域驱动设计》&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;《微服务架构设计模式》&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;极客时间《DDD 实战课》&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;极客时间《如何落地业务建模》&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;《领域驱动设计精粹》&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;最近其他好文：&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&amp;amp;mid=2649769487&amp;amp;idx=1&amp;amp;sn=575d1d17418a677b2c62bf794d508129&amp;amp;chksm=beccd57489bb5c6244e1daff72e48a115d450557ce5cd3482b20be4b4bc09155eb6464c98abf&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;深入揭秘 epoll 是如何实现 IO 多路复用的&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;深入揭秘 epoll 是如何实现 IO 多路复用的&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&amp;amp;mid=2649769420&amp;amp;idx=1&amp;amp;sn=e250de87dbcde414f9c67bf50cc32022&amp;amp;chksm=beccd6b789bb5fa1878d5ca110cdd45f186edf173058ebf5d0b28c62a2bb87fc24b5093b74c6&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;低代码是什么？有什么优势&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;低代码是什么？有什么优势&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&amp;amp;mid=2649769371&amp;amp;idx=1&amp;amp;sn=2aa88c3a960edeeeac98fbbe741e5207&amp;amp;chksm=beccd6e089bb5ff6e1f9c915f40af886cb00c42668395e1d13bb0fa53d254a712a1cc510eabd&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Go 高性能编程技法&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Go 高性能编程技法&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.7770582793709528&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatg1eXj11xia2icAtgCYHZTfDxIIZUaicM0v9WTBKH3uR6LhkvOkjDyGpic0VEWCfsGFAZdknUuzY595w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1081&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_live_iframe&quot; data-pluginname=&quot;videosnap&quot; data-headimgurl=&quot;https://wx.qlogo.cn/finderhead/I7awtksbibjQe7RZAy84xESOBAfIZ8xQ9ApXt4uTe8po/0&quot; data-username=&quot;v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder&quot; data-nickname=&quot;腾讯程序员&quot; data-desc=&quot;将在03月31日 19:30 直播&quot; data-intro=&quot;腾讯工程师分享：详解正则表达式&quot; data-noticeid=&quot;finderlivenotice-v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder-1648202215698886-1458631659&quot; data-type=&quot;live&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>89201b6eae8d96e209adc743dd43fe3e</guid>
<title>基于 Apache Hudi 构建增量和无限回放事件流的 OLAP 平台</title>
<link>https://toutiao.io/k/ahzd111</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
            &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.56796875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/brR21T72gFrmTKhyiaiaqic375VKib6NwQ8MrmrqW22LOCzpP13VTklzxJRgoM7TVejUic6ial590tbDF8TB1AdNmzgA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;1. 摘要&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;在本博客中，我们将讨论在构建流数据平台时如何利用 Hudi 的两个最令人难以置信的能力。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;• 增量消费--每 30 分钟处理一次数据，并在我们的组织内构建每小时级别的OLAP平台&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;• 事件流的无限回放--利用 Hudi 的提交时间线在超级便宜的云对象存储（如 AWS S3）中存储 10 天的事件流（想象一个具有 10 天保留期的 kafka 主题）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;• 具有部分记录更新的自定义 Hudi Payload 类&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;2. 当前状态&lt;/h2&gt;&lt;h3&gt;2.1 问题说明&lt;/h3&gt;&lt;p&gt;对于大多数业务需要手动干预以通过查看 KPI 和数据趋势来决定下一组操作用例以及其他不太实时的用例，我们需要具有成本效益和高性能的近实时系统。&lt;/p&gt;&lt;p&gt;但是我们在数据湖中获得的数据通常以 D -1 的每日批处理粒度出现，即使我们每天不止一次地运行这些日常批处理数据处理系统以获取当前 D 的最新数据，这些批处理系统的固有局限性也无助于我们解决近实时业务用例。&lt;/p&gt;&lt;h3&gt;2.2 挑战&lt;/h3&gt;&lt;p&gt;在将批处理数据摄取到我们的数据湖时，我们支持 S3 的数据集在每日更新日期分区上进行分区。即使我们每天多次运行这些批处理系统，我们从上游 Kafka 或 RDBMS 应用程序数据库中提取的最新批处理也会附加到 S3 数据集中当前日期的分区中。&lt;/p&gt;&lt;p&gt;当下游系统想要从我们的 S3 数据集中获取这些最新记录时，它需要重新处理当天的所有记录，因为下游进程无法在不扫描整个数据分区的情况下从增量记录中找出已处理的记录。&lt;/p&gt;&lt;p&gt;此外如果我们按小时（而不是每日分区）对 S3 数据集进行分区，那么这会将分区粒度设置为每小时间隔。任何试图以低于一小时（例如最后 x 分钟）的粒度获取最新更新的下游作业都必须在每次运行时再次重新处理每小时数据分区，即这些批处理源将错过解决近实时用例所需的关键增量数据消费。&lt;/p&gt;&lt;h3&gt;2.3 无限播放事件流&lt;/h3&gt;&lt;p&gt;现在回到帮助我们解决这些挑战的 Apache Hudi 的特性，让我们首先尝试了解commit（提交）和commit timeline（提交时间线）如何影响增量消费和事件流保留/回放。&lt;/p&gt;&lt;p&gt;Hudi 维护了在不同时刻在表上执行的所有操作的时间表，这些commit（提交）包含有关作为 upsert 的一部分插入或重写的部分文件的信息，我们称之为 Hudi 的提交时间线。&lt;/p&gt;&lt;p&gt;对于每个 Hudi 表，我们可以选择指定要保留多少历史提交，要保留的默认提交是 10 次，即在 10 次提交之后，第 11 次提交将另外运行一个清理服务，该服务将清除第一次提交历史记录。&lt;/p&gt;&lt;p&gt;清理commit（提交）时，清理程序会清理与该提交对应的部分文件的过时版本，相关数据被保留，因为过时的文件中的所有数据无论如何都存在于新版本的文件中，这里重要的是我们可以触发快照查询来获取数据的最新状态，但我们将无法对已清理的提交运行增量查询来获取增量数据。&lt;/p&gt;&lt;p&gt;简而言之，如果清除了commit（提交），我们就失去了从该commit（提交）回放事件流的能力，但是我们仍然可以从任何尚未清理的commit（提交）中回放事件流。&lt;/p&gt;&lt;p&gt;在我们的例子中，我们将 Hudi 表配置为保留 10K 提交，从而为我们提供 10 天的增量读取能力（类似于保留 10 天的 kafka 主题） 我们保留的历史提交数量越多，我们就越有能力及时返回并重放事件流。&lt;/p&gt;&lt;h2&gt;3. 每小时 OLAP&lt;/h2&gt;&lt;p&gt;让我快速展示一下我们的端到端消息 OLAP 计算管道与 10 天事件流的架构&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.127591706539075&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/brR21T72gFrmTKhyiaiaqic375VKib6NwQ8MyB0SiaFIMMlfCqicBBJVEFCqsKj0q9Vibc9gE43zjPlSL277NIpY5dBFw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;627&quot;/&gt;&lt;/p&gt;&lt;p&gt;在 kafka 层，我们的 kafka 输入源每个都有 1 天的主题保留期。&lt;/p&gt;&lt;p&gt;在摄取层，我们有 Spark 结构化流作业，从 kafka 源读取数据并将微批处理写入 S3 支持的 Hudi 表。这是我们配置为保持 10k 提交以启用 10 天事件流播放的地方。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;.option(&lt;span&gt;&quot;hoodie.cleaner.commits.retained&quot;&lt;/span&gt;, &lt;span&gt;10000&lt;/span&gt;)&lt;br/&gt;.option(&lt;span&gt;&quot;hoodie.keep.max.commits&quot;&lt;/span&gt;, &lt;span&gt;10002&lt;/span&gt;)&lt;br/&gt;.option(&lt;span&gt;&quot;hoodie.keep.min.commits&quot;&lt;/span&gt;, &lt;span&gt;10001&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;计算层由我们当前每 30 分钟运行一次的批处理 Spark 作业组成，并重新处理我们在过去 60 分钟内摄取到 Hudi 表中的所有事件。每小时 OLAP 作业读取两个跨国表和可选的 N 维表，并将它们全部连接起来以准备我们的 OLAP 增量DataFrame。&lt;/p&gt;&lt;p&gt;我们每 30 分钟处理一次 60 分钟的数据，以增强表连接的一致性。&lt;/p&gt;&lt;p&gt;有趣的是生产系统中通常不建议保留 1 天的 kafka 保留期，但是我们能够进行这种权衡以节省一些 SSD 和 Kafka 代理成本，因为无论如何我们都可以通过 S3 支持的 Hudi 表实现 10 天的事件流播放能力。&lt;/p&gt;&lt;h2&gt;4. 部分记录更新&lt;/h2&gt;&lt;p&gt;上面的管道显示了我们如何通过读取和合并两个增量上游数据源来创建每小时增量 OLAP。&lt;/p&gt;&lt;p&gt;然而这些增量数据处理有其自身的挑战。可能会发生在两个上游表中，对于主键，我们在其中一个数据源中获得更新，但在另一个数据源中没有，我们称之为不匹配的交易问题。&lt;/p&gt;&lt;p&gt;下面的插图试图帮助我们理解这一挑战，并看看我们实施的解决方案。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.1343283582089552&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/brR21T72gFrmTKhyiaiaqic375VKib6NwQ8McRuHBrPNjmhhAzj7KuQN0ZKYLYTUicSHAqu66OfSAfwAw0Eto18aJFg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;469&quot;/&gt;&lt;/p&gt;&lt;p&gt;在这里，表A和B都有一些对应的匹配事务和一些不匹配的事务。使用内部连接将简单地忽略不匹配的事务，这些事务可能永远不会流入我们的基础 OLAP。相反使用外连接会将不匹配的事务合并到我们的每小时增量数据加载中。但是使用外连接会将缺失的列值添加为 null，现在这些空值将需要单独处理。&lt;/p&gt;&lt;p&gt;在使用默认有效负载类将此每小时增量数据更新到基础 Hudi OLAP 时，它将简单地用我们准备的每小时增量数据中的新记录覆盖基础 Hudi OLAP 中的记录。但是通过这种方式，当我们用传入记录中的空列值覆盖现有记录时，我们将丢失现有记录中可能已经存在的信息。因此为了解决这个问题，我们提供了我们的自定义部分行更新有效负载类，同时将外部连接的每小时增量数据插入到基础 Hudi OLAP。有效负载类定义了控制我们在更新记录时如何合并新旧记录的函数。我们的自定义有效负载类比较存储和传入记录的所有列，并通过将一条记录中的空列与另一条记录中的非空列重叠来返回一条新记录。因此即使只有一个上游表得到了更新，我们的自定义有效负载类也会使用这个部分可用的新信息，它会返回包含部分更新信息的完全最新记录。由于存储和部分行更新记录的主键和分区键相同，因此 Hudi upsert 操作会自动更新旧记录，从而为我们提供基本 OLAP 的去重和一致视图。有关如何编写自己的有效负载类的&lt;span&gt;更多技术细节&lt;sup&gt;[1]&lt;/sup&gt;&lt;/span&gt;。&lt;/p&gt;&lt;h2&gt;5. 结语&lt;/h2&gt;&lt;p&gt;结合这三个概念，即增量消费、增量每小时 OLAP 处理和自定义部分行更新有效负载类，我们为我们的独角兽初创公司构建了一个强大的流处理平台，以使其一直扩展成为一个百角兽组织。&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzIyMzQ0NjA0MQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/brR21T72gFrSJYpz6hjcEOYH86LMkT7PhEydJe1NtcENI8CvRygysXmDjUnlzobK6f2OkrwWfOWkqwfRia4fmnw/0?wx_fmt=png&quot; data-nickname=&quot;ApacheHudi&quot; data-alias=&quot;ApacheHudi&quot; data-signature=&quot;Apache Hudi是一个支持插入、更新、删除的增量数据湖处理框架；可助力构建高效的企业级数据湖。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.52&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3EcuPIickyyEwbzUrMVnXJaXicEHYVRUz1Xar9X3Tic8ZUNJ3IfuVNP8wUpaKiafwYOY6lfXjlYbcJUJklKI7psbsg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIyMzQ0NjA0MQ==&amp;amp;mid=2247488591&amp;amp;idx=1&amp;amp;sn=9eddead1cb8bf1bf370178053527461c&amp;amp;chksm=e81f4139df68c82f8e8c04e0ab6afda5257cd180f2b573a9b7a9bf2cc377fc69852c1bb3bb6d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;基于Apache Hudi在Google云平台构建数据湖&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;基于Apache Hudi在Google云平台构建数据湖&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIyMzQ0NjA0MQ==&amp;amp;mid=2247488582&amp;amp;idx=2&amp;amp;sn=6dd06826947b7193165028292b703c53&amp;amp;chksm=e81f4130df68c8260bca16d05f072fd8bea4624e3402b6af53f5cead630258dfa5f5d87be7f3&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;聊一聊Hudi的原理（2）&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;聊一聊Apache Hudi的原理（2）&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIyMzQ0NjA0MQ==&amp;amp;mid=2247488537&amp;amp;idx=1&amp;amp;sn=301df0833fc89991fb4699402f140c0a&amp;amp;chksm=e81f416fdf68c879ff96f7064d069f51a8dd56250b7f205e99bd79f42a19416307be646f62c7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;重磅！Apache Hudi联合传智教育推出免费中文视频教程&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;重磅！Apache Hudi联合传智教育推出免费中文视频教程&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIyMzQ0NjA0MQ==&amp;amp;mid=2247488377&amp;amp;idx=1&amp;amp;sn=eef38326fa6f419359dccb258b42618b&amp;amp;chksm=e81f460fdf68cf19527043ed7037d333b8be20a60244fae5d74d1093621f2c60f4b02220befa&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Robinhood基于Apache Hudi的下一代数据湖实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Robinhood基于Apache Hudi的下一代数据湖实践&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIyMzQ0NjA0MQ==&amp;amp;mid=2247488396&amp;amp;idx=2&amp;amp;sn=ef64253ef9d705feee2dabcd0e4819fb&amp;amp;chksm=e81f46fadf68cfec5da9d57a0371138cf82e235ebe55e4cba9e0fac67ce3f54280dc66962589&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Apache Hudi Bucket Index 在字节跳动的设计与实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Apache Hudi Bucket Index 在字节跳动的设计与实践&lt;/a&gt;&lt;/p&gt;&lt;h4&gt;引用链接&lt;/h4&gt;&lt;p&gt;&lt;code&gt;[1]&lt;/code&gt; 更多技术细节: &lt;em&gt;[https://hudi.apache.org/learn/faq/#can-i-implement-my-own-logic-for-how-input-records-are-merged-with-record-on-storage](https://hudi.apache.org/learn/faq/#can-i-implement-my-own-logic-for-how-input-records-are-merged-with-record-on-storage)&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>