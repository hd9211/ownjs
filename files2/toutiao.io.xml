<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>cf5ab0f6543513ea328101035a03cced</guid>
<title>2.5 万字详解：23 种设计模式</title>
<link>https://toutiao.io/k/bjjvhwf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;本文简述了各大设计模式，并通过UML和代码详细说明。本文大约共 2.5W 字，建议收藏。下方是本文的目录：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;一、设计模式的认识&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;二、设计模式的分类&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;三、设计模式的优点&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;四、设计模式中关键点&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;五、创建型模式&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;简单（静态）工厂模式&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;工厂方法模式&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;抽象工厂模式&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;单例模式&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;原型模式&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;建造者模式&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;六、个人体会&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一、设计模式的认识&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;设计模式(Design Pattern)是前辈们经过相当长的一段时间的试验和错误总结出来的，是软件开发过程中面临的通用问题的解决方案。这些解决方案使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;二、设计模式的分类&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（1）根据其目的&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;即模式是用来做什么的，可分为创建型(Creational)，结构型(Structural)和行为型(Behavioral)三种：①创建型模式主要用于创建对象。②结构型模式主要用于处理类或对象的组合。③行为型模式主要用于描述对类或对象怎样交互和怎样分配职责。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（2） 根据范围&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;即模式主要是用于处理类之间关系还是处理对象之间的关系，可分为类模式和对象模式两种：类模式处理类和子类之间的关系，这些关系通过继承建立，在编译时刻就被确定下来，是属于静态的。对象模式处理对象间的关系，这些关系在运行时刻变化，更具动态性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4903677758318739&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tshryEKfLJODAruawvHK3OjRTibsmwHrzMl8AbXclMQ7N5KF3FsnpjPpp9seZibHM7NlZyMgA6RAibuyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1142&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;三、设计模式的优点&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;①可以提高程序员的思维能力、编程能力和设计能力。②使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。③使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。&lt;strong&gt;现在这样说肯定有些懵逼，需要在实际开发中才能体会得到真正的好处&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;四、设计模式中关键点&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;（1）创建型模式&lt;/strong&gt;：&lt;strong&gt;简单工厂&lt;/strong&gt;：一个工厂类根据传入的参量决定创建出那一种产品类的实例。&lt;strong&gt;工厂方法&lt;/strong&gt;：定义一个创建对象的接口，让子类决定实例化那个类。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;抽象工厂&lt;/strong&gt;：创建相关或依赖对象的家族，而无需明确指定具体类。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;建造者模式&lt;/strong&gt;：封装一个复杂对象的构建过程，并可以按步骤构造。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;单例模式&lt;/strong&gt;：某个类只能有一个实例，提供一个全局的访问点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;原型模式&lt;/strong&gt;：通过复制现有的实例来创建新的实例。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;（2）结构型模式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;外观模式&lt;/strong&gt;：对外提供一个统一的方法，来访问子系统中的一群接口。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;桥接模式&lt;/strong&gt;：将抽象部分和它的实现部分分离，使它们都可以独立的变化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;组合模式&lt;/strong&gt;：将对象组合成树形结构以表示“”部分-整体“”的层次结构。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;装饰模式&lt;/strong&gt;：动态的给对象添加新的功能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;代理模式&lt;/strong&gt;：为其他对象提供一个代理以便控制这个对象的访问。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;适配器模式&lt;/strong&gt;：将一个类的方法接口转换成客户希望的另外一个接口。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;亨元（蝇量）模式&lt;/strong&gt;：通过共享技术来有效的支持大量细粒度的对象。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;（3）行为型模式&lt;/strong&gt;&lt;strong&gt;模板模式&lt;/strong&gt;：定义一个算法结构，而将一些步骤延迟到子类实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;解释器模式&lt;/strong&gt;：给定一个语言，定义它的文法的一种表示，并定义一个解释器。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;策略模式&lt;/strong&gt;：定义一系列算法，把他们封装起来，并且使它们可以相互替换。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;状态模式&lt;/strong&gt;：允许一个对象在其对象内部状态改变时改变它的行为。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;观察者模式&lt;/strong&gt;：对象间的一对多的依赖关系。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;备忘录模式&lt;/strong&gt;：在不破坏封装的前提下，保持对象的内部状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;中介者模式&lt;/strong&gt;：用一个中介对象来封装一系列的对象交互。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;命令模式&lt;/strong&gt;：将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;访问者模式&lt;/strong&gt;：在不改变数据结构的前提下，增加作用于一组对象元素的新功能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;责任链模式&lt;/strong&gt;：将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;迭代器模式&lt;/strong&gt;：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;五、创建型模式&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（1）简单（静态）工厂模式&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.认识&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;①一句话来说就是，一个工厂类根据传入的参量决定创建出那一种产品类的实例。因为逻辑实现简单，所以称为&lt;strong&gt;简单工厂模式&lt;/strong&gt;，也因为工厂中的方法一般设置为静态，所以也称为&lt;strong&gt;静态工厂&lt;/strong&gt;，它不属于23种模式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;②简单工厂模式专门定义一个工厂类来负责创建其他类的实例，被创建的实例通常都具有共同的父类，在工厂类中，可以根据参数的不同返回不同类的实例。升级版本简单工厂模式，通过反射根据类的全路径名生成对象。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;③简单工厂模式就是将这部分创建对象语句分离出来，由工厂类来封装实例化对象的行为，修改时只需要修改类中的操作代码，使用时调用该类不需要考虑实例化对象的行为，使得后期代码维护升级更简单方便，有利于代码的可修改性与可读性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;④但是如果增加新的产品的话，需要修改工厂类的判断逻辑，违背开闭原则。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.UML图解&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;简单介绍一下UML：&lt;strong&gt;泛化&lt;/strong&gt;：继承
带三角箭头的实线，箭头指向类&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;实现&lt;/strong&gt;：实现
带三角箭头的虚线，箭头指向接口&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;依赖&lt;/strong&gt;：new A的对象当作方法参数传递进来作为B类的局部变量
带箭头的虚线，指向被使用者&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;关联&lt;/strong&gt;：一个类作为另一个类的成员变量
带普通箭头的实心线，指向被拥有者&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;聚合&lt;/strong&gt;：new A的对象当作方法参数传递进来作为B类的成部变量
带空心菱形的实心线，菱形指向整体&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;组合&lt;/strong&gt;：new A的对象当作构造方法参数传递进来作为B类的成部变量或者A类作为B类成员变量并已经new A（A类和B类具有相同的生命周期）
带实心菱形的实线，菱形指向整体
总结：各种关系的强弱顺序：泛化 = 实现 &amp;gt; 组合 &amp;gt; 聚合 &amp;gt; 关联 &amp;gt; 依赖&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;区分&lt;/strong&gt;：①如果B类作为了A类的成员变量（has的关系），则一般是A类与B类是关联(A类与B类平级)、聚合（A类是整体，B类是部分）、组合的关系（A类是整体，B类是部分，且A类B类有相同的生命周期，）根据上下文语意区分：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;聚合&lt;/strong&gt;（B类即便不在A类中也可以单独存在），&lt;strong&gt;组合&lt;/strong&gt;（B类不在A类中就无法单独存在）。②如果B类作为了A类的局部变量（use的关系），方法的形参，或者对静态方法的调用一般是依赖关系。&lt;strong&gt;UML类图如下：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4011111111111111&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tshryEKfLJODAruawvHK3OjR2EG7soIhPtvVgYrUCIcBuhTQicvIJ6KZz92cHINdwy482hLEgM3HqQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;UML说明：&lt;/strong&gt;苹果手机和红米手机继承了手机这个抽象类，工厂类里根据客户端传入的参数生成相应的对象，如，客户说要红米，工厂给客户一个红米手机，客户说要苹果，工厂给客户一个苹果手机。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;简单工厂有三个对象：&lt;/strong&gt;①抽象产品类：提供抽象方法供具体产品类实现
②具体产品类：提供具体的产品
③工厂：根据内部逻辑返回相应的产品&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.代码实现&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;（1）抽象产品类Phone
这里可以是类，也可以是接口或者抽象类，千万不要思维定式。我比较喜欢面向接口编程，所以我这里用了接口。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Phone&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;     &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;produce&lt;/span&gt;()&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;（2）具体产品类&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;在这里插入代码片&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ApplePhoneImpl&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Phone&lt;/span&gt;&lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;produce&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        System.out.println(&lt;span&gt;&quot;生产苹果手机&quot;&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RedmiPhoneImpl&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Phone&lt;/span&gt;&lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;produce&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        System.out.println(&lt;span&gt;&quot;生产了红米手机&quot;&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;（3）工厂类&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Factory&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Phone &lt;span&gt;getPhone&lt;/span&gt;(&lt;span&gt;String type&lt;/span&gt;)&lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        Phone phone = &lt;span&gt;null&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;&quot;红米&quot;&lt;/span&gt;.&lt;span&gt;equals&lt;/span&gt;(type)){&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            phone = &lt;span&gt;new&lt;/span&gt; RedmiPhoneImpl();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;&quot;苹果&quot;&lt;/span&gt;.&lt;span&gt;equals&lt;/span&gt;(type)){&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            phone = &lt;span&gt;new&lt;/span&gt; ApplePhoneImpl();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        }&lt;span&gt;//.....&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; phone;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;（4）客户端使用&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@&lt;span&gt;Test&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;()&lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        Factory factory = &lt;span&gt;new&lt;/span&gt; Factory();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;br mpa-from-tpl=&quot;t&quot;/&gt;        Phone redmiPhone = factory.getPhone(&lt;span&gt;&quot;红米&quot;&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        System.&lt;span&gt;out&lt;/span&gt;.println(redmiPhone);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        redmiPhone.produce();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        Phone applePhone = factory.getPhone(&lt;span&gt;&quot;苹果&quot;&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        System.&lt;span&gt;out&lt;/span&gt;.println(applePhone);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        applePhone.produce();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;运行结果如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.2832699619771863&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tshryEKfLJODAruawvHK3OjRU36D9iasQh20uV0L1A3YXPl0oforM05ibWA4beAXrMTe6R8suNIPpf5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1052&quot;/&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.总结&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;优点：&lt;/strong&gt;只需要传入一个正确的参数，就可以获取你所需要的对象而无需知道其创建对象的细节&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;缺点：&lt;/strong&gt;扩展性差，当增加新的产品需要修改工厂类的判断逻辑，违背开闭原则，如我想要买一个华为手机的话，除了&lt;strong&gt;新增&lt;/strong&gt;华为手机这个产品类，还需要&lt;strong&gt;修改&lt;/strong&gt;工厂中的逻辑&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.升级版本&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;通过反射创建对象，以改进了之前提到的缺点（增加新的产品需要修改工厂类的判断逻辑），现在&lt;strong&gt;增加&lt;/strong&gt;新的具体产品的时候&lt;strong&gt;不需要修改&lt;/strong&gt;工厂中的代码。满足了开闭原则。（1）工厂类代码如下：&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FactoryPlus&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Phone &lt;span&gt;getPhone&lt;/span&gt;&lt;span&gt;(Class clazz)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; (Phone) Class.forName(clazz.getName()).newInstance();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;（2）客户端代码如下：&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@&lt;span&gt;Test&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test2&lt;/span&gt;() throws Exception &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        FactoryPlus factory = &lt;span&gt;new&lt;/span&gt; FactoryPlus();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        Phone redmiPhone = factory.getPhone(RedmiPhoneImpl.class);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        System.&lt;span&gt;out&lt;/span&gt;.println(redmiPhone);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        redmiPhone.produce();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        Phone applePhone = factory.getPhone(ApplePhoneImpl.class);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        System.&lt;span&gt;out&lt;/span&gt;.println(applePhone);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        applePhone.produce();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;运行结果如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.2641996557659208&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tshryEKfLJODAruawvHK3OjRZhpvrbqw4prhmRaDlskicVmbubmHgn0h5aUOYMudA4PxAlYECZqlzhQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1162&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;（3）总结&lt;strong&gt;优点&lt;/strong&gt;：工厂类中的方法逻辑，是利用反射机制生成对象返回，好处是增加一种产品时，不需要修改工厂类中的代码。满足了开闭原则。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;缺点&lt;/strong&gt;：这种写法粗看牛逼，细想之下，不谈reflection的效率还有以下问题：个人觉得不好，因为Class.forName(clz.getName()).newInstance()调用的是&lt;strong&gt;无参&lt;/strong&gt;构造函数生成对象，它和&lt;strong&gt;new&lt;/strong&gt; Object()是一样的性质，而工厂方法应该用于复杂对象的初始化 ，当需要调用&lt;strong&gt;有参&lt;/strong&gt;的构造函数时便无能为力了，这样像为了工厂而工厂，没有实际意义。2 不同的产品需要不同额外参数的时候 不支持。&lt;/span&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6.再升级（重要）&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;（1）工厂类：&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FactoryPlusPlus&lt;/span&gt; {&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;/**&amp;lt;bean id=&quot;applePhone&quot; class=&quot;com.wander.design.simplefactory.product.ApplePhoneImpl&quot;/&amp;gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;     * 熟悉吧！！！spring ioc 就是通过将下面的这句话配置在配置文件中，再利用反射创建对象，&lt;br mpa-from-tpl=&quot;t&quot;/&gt;     * 这就是spring ioc的原理：工厂+配置文件+反射！！以达到彻底解耦的目的**/&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String className=&lt;span&gt;&quot;com.wander.design.simplefactory.product.ApplePhoneImpl&quot;&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Phone &lt;span&gt;getPhone&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; throws Exception &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; (Phone) Class.forName(className).newInstance();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(2) 客户端：&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test3&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        Phone phone = FactoryPlusPlus.getPhone();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        phone.produce();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;（3）说明：spring ioc容器的原理就是这种方式：&lt;strong&gt;工厂+配置文件+反射&lt;/strong&gt;，spring通过读取配置文件（&lt;/span&gt;&lt;code&gt;&lt;span&gt;&amp;lt;bean id=&quot;applePhone&quot; class=&quot;com.wander.design.simplefactory.product.ApplePhoneImpl&quot;/&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;)，获取到className再利用反射机制Class.forName(className).newInstance()得到对象赋值给配置文件里bean标签的id属性的值，就是工厂生成的对象名。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;优点：就是满足OCP原则，在不修改源代码的前提下切换底层的实现，达到解耦的目的！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;7.开发常用版本：多方法工厂&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;使用以上两种方法的工厂，都有两个&lt;strong&gt;缺点&lt;/strong&gt;：一是不同的产品需要不同额外参数的时候不支持。二是如果使用时传递的type、Class出错，将不能得到正确的对象，容错率不高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;而多方法的工厂模式为不同产品，提供不同的生产方法，使用时 需要哪种产品就调用该种产品的方法，使用方便、容错率高。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（1）工厂类代码如下：&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FactoryMoreMethod&lt;/span&gt; {&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Phone &lt;span&gt;getApple&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ApplePhoneImpl();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Phone &lt;span&gt;getRedmi&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RedmiPhoneImpl();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;/**新增华为手机产品，只需要在工厂中增加一个静态方法即可，不需要修改原有的方法**/&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Phone &lt;span&gt;getHonor&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; HonorPhoneImpl();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;（2）客户端代码：&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test3&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        Phone apple = FactoryMoreMethod.getApple();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        apple.produce();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        Phone redmi = FactoryMoreMethod.getRedmi();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        redmi.produce();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        Phone honor = FactoryMoreMethod.getHonor();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        honor.produce();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;（3）应用场景：查看java源码：java.util.concurrent.Executors类便是一个生成Executor 的工厂 ，其采用的便是 多方法静态工厂模式：例如ThreadPoolExecutor类构造方法有5个参数，其中三个参数写法固定，前两个参数可配置，如下写。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ExecutorService &lt;span&gt;newFixedThreadPool&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; nThreads)&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(nThreads, nThreads,&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                                      &lt;span&gt;0L&lt;/span&gt;, TimeUnit.MILLISECONDS,&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                                      &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;());&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;又如JDK想增加创建ForkJoinPool类的方法了，只想配置parallelism参数，便在类里增加一个如下的方法：&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ExecutorService &lt;span&gt;newWorkStealingPool&lt;/span&gt;(&lt;span&gt;&lt;span&gt;int&lt;/span&gt; parallelism&lt;/span&gt;) &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ForkJoinPool&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            (parallelism,&lt;br mpa-from-tpl=&quot;t&quot;/&gt;             ForkJoinPool.defaultForkJoinWorkerThreadFactory,&lt;br mpa-from-tpl=&quot;t&quot;/&gt;             &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;（4）总结：多方法工厂的优势，方便创建同种类型的复杂参数对象。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;8.应用场景&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;（1）在任何需要生成&lt;strong&gt;复杂对象&lt;/strong&gt;的地方，都可以使用工厂方法模式。直接用&lt;strong&gt;new&lt;/strong&gt;可以完成的&lt;strong&gt;不需要用工厂模式&lt;/strong&gt;个人理解，重点就是这个复杂 （构造函数有很多参数）和 是否可以 直接用new。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（2）客户端只知道传入工厂类的参数，对于如何创建对象并不关心。（对于升级后的简单工厂模式只知道类名即可） &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（3）工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。（对于升级后的简单工厂模式已解决这个问题，符合开闭原则） &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（4）简单工厂在源码中的使用--Calendar：&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;Calendar cal = Calendar.getInstance(zone.toTimeZone(), locale);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Calendar &lt;span&gt;getInstance&lt;/span&gt;(&lt;span&gt;TimeZone zone, Locale aLocale&lt;/span&gt;) &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;return&lt;/span&gt; createCalendar(zone, aLocale);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Calendar &lt;span&gt;createCalendar&lt;/span&gt;(&lt;span&gt;TimeZone zone, Locale aLocale&lt;/span&gt;) &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;&#x27;部分删减&#x27;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      Calendar cal = &lt;span&gt;null&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;if&lt;/span&gt; (aLocale.hasExtensions()) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;          String caltype = aLocale.getUnicodeLocaleType(&lt;span&gt;&quot;ca&quot;&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;          &lt;span&gt;if&lt;/span&gt; (caltype != &lt;span&gt;null&lt;/span&gt;) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;              &lt;span&gt;switch&lt;/span&gt; (caltype) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;              &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;buddhist&quot;&lt;/span&gt;:&lt;br mpa-from-tpl=&quot;t&quot;/&gt;              cal = &lt;span&gt;new&lt;/span&gt; BuddhistCalendar(zone, aLocale);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                  &lt;span&gt;break&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;              &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;japanese&quot;&lt;/span&gt;:&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                  cal = &lt;span&gt;new&lt;/span&gt; JapaneseImperialCalendar(zone, aLocale);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                  &lt;span&gt;break&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;              &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;Gregory&quot;&lt;/span&gt;:&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                  cal = &lt;span&gt;new&lt;/span&gt; GregorianCalendar(zone, aLocale);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                  &lt;span&gt;break&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;              }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;          }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;if&lt;/span&gt; (cal == &lt;span&gt;null&lt;/span&gt;) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;          &lt;span&gt;if&lt;/span&gt; (aLocale.getLanguage() == &lt;span&gt;&quot;th&quot;&lt;/span&gt; &amp;amp;&amp;amp; aLocale.getCountry() == &lt;span&gt;&quot;TH&quot;&lt;/span&gt;) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;              cal = &lt;span&gt;new&lt;/span&gt; BuddhistCalendar(zone, aLocale);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;          } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (aLocale.getVariant() == &lt;span&gt;&quot;JP&quot;&lt;/span&gt; &amp;amp;&amp;amp; aLocale.getLanguage() == &lt;span&gt;&quot;ja&quot;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                     &amp;amp;&amp;amp; aLocale.getCountry() == &lt;span&gt;&quot;JP&quot;&lt;/span&gt;) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;              cal = &lt;span&gt;new&lt;/span&gt; JapaneseImperialCalendar(zone, aLocale);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;          } &lt;span&gt;else&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;              cal = &lt;span&gt;new&lt;/span&gt; GregorianCalendar(zone, aLocale);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;          }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;return&lt;/span&gt; cal;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（2）工厂方法模式&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.认识&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;①一句话来说就是，定义一个创建对象的接口，让子类决定实例化那个类。因为当需要增加一个新的产品时，我们需要增加一个具体的产品类和与之对应的具体子工厂，然后在具体子工厂方法中进行对象实例化，所以称为工厂方法模式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;②具体来说就是定义一个用于创建对象的工厂接口，但让实现这个工厂接口的子类来决定实例化哪个具体产品类，工厂方法让类的实例化推迟到子类中进行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;③工厂方法模式非常符合“开闭原则”，当需要增加一个新的产品时，我们只需要增加一个具体的产品类和与之对应的具体工厂即可，无须修改原有系统。同时在工厂方法模式中用户只需要知道生产产品的具体工厂即可，无须关系产品的创建过程，甚至连具体的产品类名称都不需要知道。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;④虽然他很好的符合了“开闭原则”，但是由于每新增一个新产品时就需要增加两个类，这样势必会导致系统的复杂度增加。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.UML类图&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5781683626271971&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tshryEKfLJODAruawvHK3OjRX3FuvHfAakHnHHSz6btFs8RPAXgx3GSptfu08qC9EIgQRsq7HRIv9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1081&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;UML说明：&lt;/strong&gt;苹果手机和红米手机实现了手机这个抽象类，苹果工厂和红米工厂实现了抽象工厂，苹果工厂当然要生产（依赖）苹果手机，红米工厂当然要生产（依赖）红米。客户要买苹果手机要去问苹果工厂要苹果手机，客户要买红米手机当然要去问红米工厂要红米手机。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;工厂方法有四个对象：&lt;/strong&gt;抽象产品类：提供抽象方法供具体产品类实现
具体产品类：提供具体的产品
抽象工厂：提供抽象方法供具体工厂实现
具体工厂：提供具体的工厂&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.代码实现&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;（1）抽象产品类和简单工厂的抽象产品类一样&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（2）具体产品类和简单工厂的具体产品类一样 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（3）抽象工厂&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&lt;span&gt;ublic&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Factory&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;Phone &lt;span&gt;getPhone&lt;/span&gt;()&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;（4）具体工厂&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AppleFactoryImpl&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Factory&lt;/span&gt;&lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Phone &lt;span&gt;getPhone&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ApplePhoneImpl();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RedmiFactoryImpl&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Factory&lt;/span&gt;&lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Phone &lt;span&gt;getPhone&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RedmiPhoneImpl();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;（5）客户端&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@&lt;span&gt;Test&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;()&lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        Factory applePhoneFactory = &lt;span&gt;new&lt;/span&gt; AppleFactoryImpl();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        Factory redmiPhoneFactory = &lt;span&gt;new&lt;/span&gt; RedmiFactoryImpl();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        Phone applePhone = applePhoneFactory.getPhone();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        Phone redmiPhone = redmiPhoneFactory.getPhone();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        System.&lt;span&gt;out&lt;/span&gt;.println(applePhone);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        System.&lt;span&gt;out&lt;/span&gt;.println(redmiPhone);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        applePhone.produce();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        redmiPhone.produce();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;执行结果如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.30344827586206896&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tshryEKfLJODAruawvHK3OjRXpD5HxibuvXoCMmfJaFtwhXoPhnyzAlK7XiaMurpKspwibWB5cRLeK0YQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1015&quot;/&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.总结&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;优点：&lt;/strong&gt;①用户只需要关心所需产品的对应工厂，无需关心细节 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;②完全支持开闭原则，提高可扩展性。所谓的开闭原则就是对扩展开放，对修改关闭，再说白点就是实现工厂方法以后要进行扩展时不需要修改原有代码，只需要增加一个工厂实现类和产品实现类就可以。这样的好处可以降低因为修改代码引进错误的风险。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;缺点：&lt;/strong&gt;①每加入一种产品，会创建一个具体工厂类和具体产品类，因此，类的个数容易过多，增加复杂度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;②抽象工厂和抽象产品增加了系统的抽象性和理解难度&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.工厂方法与简单工厂的区别&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;①可以看出，工厂方法模式特点：不仅仅做出来的产品要抽象， 工厂也应该需要抽象。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;②工厂方法使一个产品类的实例化延迟到其具体工厂子类. &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;③工厂方法的好处就是更拥抱变化。当需求变化，只需要增删相应的类，不需要修改已有的类。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;④而简单工厂需要&lt;strong&gt;修改&lt;/strong&gt;工厂类的方法，多方法静态工厂模式需要&lt;strong&gt;增加&lt;/strong&gt;一个静态方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;缺点：&lt;/strong&gt;引入抽象工厂层后，每次新增一个具体产品类，也要同时&lt;strong&gt;新增&lt;/strong&gt;一个具体&lt;strong&gt;工厂类&lt;/strong&gt;，所以我更青睐多方法静态工厂，每次新增一个具体产品类，工厂只需要&lt;strong&gt;新增&lt;/strong&gt;一个静态&lt;strong&gt;方法&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6.应用场景&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;（1）客户端不知道它所需要的对象的类。（需要知道所需的对象的类使用升级版简单工厂模式，需要知道所需的参数的类使用简单工厂模式）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（2）抽象工厂类通过其子类来指定创建哪个对象。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（3）简单工厂在源码中的使用--Collection：Collection(抽象工厂)：&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Collection&lt;/span&gt;&amp;lt;&lt;span&gt;E&lt;/span&gt;&amp;gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Iterable&lt;/span&gt;&amp;lt;&lt;span&gt;E&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt; &lt;span&gt;Iterator&amp;lt;E&amp;gt; &lt;span&gt;iterator&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;ArrayList(具体工厂）：&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ArrayList&lt;/span&gt;&amp;lt;E&amp;gt;{&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;public&lt;/span&gt; Iterator&amp;lt;E&amp;gt; iterator() {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Itr();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Iterator(抽象产品）：&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Iterator&lt;/span&gt;&amp;lt;&lt;span&gt;E&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt; &lt;span&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;hasNext&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Itr（具体产品）：&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Itr&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Iterator&lt;/span&gt;&amp;lt;&lt;span&gt;E&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt; &lt;span&gt;int&lt;/span&gt; cursor; &lt;span&gt;// index of next element to return&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;int&lt;/span&gt; lastRet = -&lt;span&gt;1&lt;/span&gt;; &lt;span&gt;// index of last element returned; -1 if no such&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;int&lt;/span&gt; expectedModCount = modCount;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;hasNext&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;return&lt;/span&gt; cursor != size;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&#x27;省略代码...&#x27;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（3）抽象工厂模式&lt;/span&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.认识&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;①一句话来说就是，创建相关或依赖对象的家族，而无需明确指定具体类。因为我们可以定义具体产品类实现不止一个抽象工厂接口，一个工厂也可以生成不止一个产品类，是三个模式中较为抽象，并具一般性的模式。我们在使用中要注意使用抽象工厂模式的条件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;②所谓抽象工厂模式就是提供一个接口，用于创建相关或者依赖对象的家族，而不需要明确指定具体类。他允许客户端使用抽象的接口来创建一组相关的产品，而不需要关心实际产出的具体产品是什么。这样一来，客户就可以从具体的产品中被解耦。它的优点是隔离了具体类的生成，使得客户端不需要知道什么被创建了，而缺点就在于新增新的行为会比较麻烦，因为当添加一个新的产品对象时，需要更改接口及其下所有子类。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.UML类图&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.7546816479400749&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tshryEKfLJODAruawvHK3OjRBsib3Y9IFteJPn5BSAjBIZbINDVtAQ6Wiadx8He5K8jgGFf1DV9rLcrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1068&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;UML说明：&lt;/strong&gt;具体的苹果手机产品和具体的红米手机产品实现了手机产品抽象类，具体的苹果充电器产品和具体的红米充电器产品实现了充电器产品抽象类。具体的苹果工厂和具体的红米工厂实现了手机抽象工厂，然后苹果工厂生产苹果手机和苹果充电器，红米工厂生成红米手机和红米充电器。客户想要苹果手机和苹果充电器就要向苹果工厂要产品（对象），客户想要红米手机和红米充电器就要向红米工厂要产品（对象）。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;工厂方法有四个对象：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;①&lt;strong&gt;抽象产品类&lt;/strong&gt;：为每种具体产品声明接口，如图中Phone手机抽象类和Charger充电器抽象类 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;②&lt;strong&gt;具体产品类&lt;/strong&gt;：定义了工厂生产的具体产品对象，实现抽象产品接口声明的业务方法，如图中ApplePhoneImpl、RedmiPhoneImpl，AppleChargerImpl,RedmiChargerImpl&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;③&lt;strong&gt;抽象工厂&lt;/strong&gt;：它声明了一组用于创建一种产品的方法，每一个方法对应一种产品，如上述类图中的Factory就定义了两个方法，分别创建Phone和Charger&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;④&lt;strong&gt;具体工厂&lt;/strong&gt;：它实现了在抽象工厂中定义的创建产品的方法，生产一组具体产品，这组产品构件成了一个产品种类，每一个产品都位于某个产品等级结构中，如上述类图中的AppleFactoryImpl和RedmiFactoryImpl&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.代码实现&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;（1）抽象的产品&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Phone&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;produce&lt;/span&gt;()&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Charger&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;produce&lt;/span&gt;()&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;（2）具体的产品 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;① 苹果具体的产品&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AppleChargerImpl&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Charger&lt;/span&gt;&lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;produce&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        System.out.println(&lt;span&gt;&quot;生产苹果充电器&quot;&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ApplePhoneImpl&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Phone&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;produce&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        System.out.println(&lt;span&gt;&quot;生产苹果手机&quot;&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;② 红米具体的产品&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RedmiChargerImpl&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Charger&lt;/span&gt;&lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;produce&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        System.out.println(&lt;span&gt;&quot;生产红米充电器&quot;&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RedmiPhoneImpl&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Phone&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;produce&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        System.out.println(&lt;span&gt;&quot;生产了红米手机&quot;&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;（3）抽象工厂&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Factory&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;Phone &lt;span&gt;getPhone&lt;/span&gt;()&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;Charger &lt;span&gt;getCharger&lt;/span&gt;()&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;（4）具体的工厂&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AppleFactoryImpl&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Factory&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Phone &lt;span&gt;getPhone&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ApplePhoneImpl();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Charger &lt;span&gt;getCharger&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; AppleChargerImpl();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RedmiFactoryImpl&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Factory&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Phone &lt;span&gt;getPhone&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RedmiPhoneImpl();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Charger &lt;span&gt;getCharger&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RedmiChargerImpl();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(5)客户端&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@&lt;span&gt;Test&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;()&lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        Factory appleFactory = &lt;span&gt;new&lt;/span&gt; AppleFactoryImpl();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        Phone applePhone = appleFactory.getPhone();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        Charger appleCharger = appleFactory.getCharger();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        System.&lt;span&gt;out&lt;/span&gt;.println(appleFactory);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        applePhone.produce();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        appleCharger.produce();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        Factory redmiFactory = &lt;span&gt;new&lt;/span&gt; RedmiFactoryImpl();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        Phone redmiPhone = redmiFactory.getPhone();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        Charger redmiCharger = redmiFactory.getCharger();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        System.&lt;span&gt;out&lt;/span&gt;.println(redmiFactory);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        redmiPhone.produce();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        redmiCharger.produce();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（5）执行结果&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.31009023789991796&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tshryEKfLJODAruawvHK3OjRCyV5G17WtLfeuJAaRqOB3lRyictXjKaickYzIKfTS3dPbGz5MRx6Pfew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1219&quot;/&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.总结&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;①具体产品在应用层代码隔离，无须关系创建细节 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;②将一个系列的产品统一到一起创建&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;③对于增加新的产品族（一个具体工厂就是一个产品族），抽象工厂模式很好地支持了“开闭原则”，只需要增加具体产品并对应增加一个新的具体工厂，对已有代码无须做任何修改。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;缺点：&lt;/strong&gt;①规定了所有可能被创建的产品集合，产品族扩展新的产品（工厂中添加新的方法）困难。如果产品族扩展新的产品，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，违背了“开闭原则”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;②增加了系统的抽象性和理解难度&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.应用场景&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;抽象工厂在实际的开发中运用并不多，主要是在开发工程中很少会出现多个产品种类的情况，大部分情况使用以上两种工厂模式即可解决&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6.个人总结&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;一句话总结工厂模式：&lt;strong&gt;方便创建 同种产品类型的 复杂参数 对象&lt;/strong&gt;工厂模式重点就是适用于 &lt;strong&gt;构建同产品类型&lt;/strong&gt;（同一个接口 基类）的不同对象时，这些对象new很复杂，&lt;strong&gt;需要很多的参数&lt;/strong&gt;，而这些参数中大部分都是&lt;strong&gt;固定&lt;/strong&gt;的，so，懒惰的程序员便用工厂模式封装之。（如果构建某个对象很复杂，需要很多参数，但这些参数大部分都是“&lt;strong&gt;不固定&lt;/strong&gt;”的，应该使用建造者Builder模式）&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（4）单例模式&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.认识&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;①一句话来说就是，某个类只能有一个实例，提供一个全局的访问点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;②单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;③使用Singleton的好处还在于可以节省内存，因为它限制了实例的个数，有利于Java垃圾回收（garbage collection），而且确保所有对象都访问唯一实例。但是不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态。用单例模式，就是在适用其优点的状态下使用&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.UML类图&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4518413597733711&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tshryEKfLJODAruawvHK3OjRlHJuBvu6mDClRCFggtteqvZ51tJ7ibyTwhicmRqGGqSjSv1X1t2HWFFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;706&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;UML说明：1.构造方法私有化：可以使得该类不被实例化即不能被new
2.在类本身里创建自己的对象
3.提供一个公共的方法供其他对象访问&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.代码实现&lt;/span&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（1）饿汉式&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;&lt;span&gt;①第一种：&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Singleton&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;/**&lt;br mpa-from-tpl=&quot;t&quot;/&gt;     * static：&lt;br mpa-from-tpl=&quot;t&quot;/&gt;     * ①表示共享变量，语意符合&lt;br mpa-from-tpl=&quot;t&quot;/&gt;     * ②使得该变量能在getInstance()静态方法中使用&lt;br mpa-from-tpl=&quot;t&quot;/&gt;     * final:&lt;br mpa-from-tpl=&quot;t&quot;/&gt;     * ①final修饰的变量值不会改变即常量，语意也符合，当然不加final也是可以的&lt;br mpa-from-tpl=&quot;t&quot;/&gt;     * ②保证修饰的变量必须在类加载完成时就已经进行赋值。&lt;br mpa-from-tpl=&quot;t&quot;/&gt;     * final修饰的变量，前面一般加static&lt;br mpa-from-tpl=&quot;t&quot;/&gt;     */&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Singleton singleton = &lt;span&gt;new&lt;/span&gt; Singleton();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;/**&lt;br mpa-from-tpl=&quot;t&quot;/&gt;     * 私有化构造方法，使外部无法通过构造方法构造除singleton外的类实例&lt;br mpa-from-tpl=&quot;t&quot;/&gt;     * 从而达到单例模式控制类实例数目的目的&lt;br mpa-from-tpl=&quot;t&quot;/&gt;     */&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; Singleton(){}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;/**&lt;br mpa-from-tpl=&quot;t&quot;/&gt;     * 类实例的全局访问方法&lt;br mpa-from-tpl=&quot;t&quot;/&gt;     * 因为构造方法以及被私有化，外部不可能通过new对象来调用其中的方法&lt;br mpa-from-tpl=&quot;t&quot;/&gt;     * 加上static关键词使得外部可以通过类名直接调用该方法获取类实例&lt;br mpa-from-tpl=&quot;t&quot;/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;     */&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Singleton getSingleton() {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; singleton;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;②第二种&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SingletonStatic&lt;/span&gt; {&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; final SingletonStatic singletonStatic;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;/**&lt;br mpa-from-tpl=&quot;t&quot;/&gt;     * 和第一种没有什么区别，这种看起来高大上面试装逼使用&lt;br mpa-from-tpl=&quot;t&quot;/&gt;     */&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;static&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        singletonStatic = &lt;span&gt;new&lt;/span&gt; SingletonStatic();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;SingletonStatic&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SingletonStatic &lt;span&gt;getSingletonStatic&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; singletonStatic;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;说明&lt;/strong&gt;：①优点：一般使用static和final修饰变量（具体作用已经在代码里描述了），只在类加载时才会初始化，以后都不会，线程绝对安全，无锁，效率高。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;②缺点：类加载的时候就初始化，不管用不用，都占用空间，会消耗一定的性能(当然很小很小，几乎可以忽略不计，所以这种模式在很多场合十分常用而且十分简单)&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;注&lt;/strong&gt;：这里有两个小知识点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;a&lt;/strong&gt;.如果是final非static成员，必须在构造器、代码块、或者直接定义赋值&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;b&lt;/strong&gt;.如果是final static 成员变量，必须直接赋值 或者在静态代码块中赋值&lt;/span&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（2）懒汉式&lt;/span&gt;&lt;/h5&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Singleton&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Singleton singleton = &lt;span&gt;null&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;Singleton&lt;/span&gt;()&lt;/span&gt;{}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Singleton &lt;span&gt;getSingleton&lt;/span&gt;() &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;if&lt;/span&gt;(singleton == &lt;span&gt;null&lt;/span&gt;){&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            singleton = &lt;span&gt;new&lt;/span&gt; Singleton();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; singleton;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;①优点：在外部需要使用的时候才进行实例化，不使用的时候不会占用空间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;②缺点：线程不安全。看上去，这段代码没什么明显问题，但它不是线程安全的。假设当前有N个线程同时调用getInstance（）方法，由于当前还没有对象生成，所以一部分同时都进入if语句new Singleton(),那么就会由多个线程创建多个多个user对象。&lt;/span&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（3）线程安全的懒汉式&lt;/span&gt;&lt;/h5&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Singleton&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Singleton singleton;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;Singleton&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{};&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; Singleton &lt;span&gt;getSingleton&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;if&lt;/span&gt;(singleton == &lt;span&gt;null&lt;/span&gt;){&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            singleton = &lt;span&gt;new&lt;/span&gt; Singleton();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; singleton;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;说明：&lt;/strong&gt;①优点：解决了懒汉式线程不安全的问题
②缺点：线程阻塞，影响性能。&lt;/span&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（4）DCL单例 - 高性能的懒汉式&lt;/span&gt;&lt;/h5&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Singleton&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt; &lt;span&gt;/*volatile在这里发挥的作用是：禁止指令重排序（编译器和处理器为了优化程序性能&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    * 而对指令序列进行排序的一种手段。）&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    * singleton = new Singleton();这句代码是非原子性操作可分为三行伪代码&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    * a:memory = allocate() //分配内存，在jvm堆中分配一段区域&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    * b:ctorInstanc(memory) //初始化对象，在jvm堆中的内存中实例化对象&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    * c:instance = memory //赋值，设置instance指向刚分配的内存地址&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    * 上面的代码在编译运行时，可能会出现重排序从a-b-c排序为a-c-b。&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    * 重排序是为了优化性能，但是不管怎么重排序，在单线程下程序的执行结果不能被改变&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    * 保证最终一致性。而在多线程环境下，可能发生重排序，会影响结果。&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    * ①若A线程执行到代码singleton = new Singleton()时;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    * ②同时若B线程进来执行到代码到第一层检查if (singleton == null)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    * ③当cpu切换到A线程执行代码singleton = new Singleton();时发生了指令重排序，&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    * 执行了a-b，没有执行c,此时的singleton对象只有地址，没有内容。然后cpu又切换到了B线程，&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    * 这时singleton == null为false（==比较的是内存地址），&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    * 则代码会直接执行到了return，返回一个未初始化的对象（只有地址，没有内容）。&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    * */&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Singleton singleton;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;Singleton&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Singleton &lt;span&gt;getSingleton&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;/*第一层检查，检查是否有引用指向对象，高并发情况下会有多个线程同时进入&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        * ①当多个线程第一次进入，所有线程都进入if语句&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        * ②当多个线程第二次进入，因为singleton已经不为null，因此所有线程都不会进入if语句，&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        * 即不会执行锁，从而也就不会因为锁而阻塞，避免锁竞争*/&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;if&lt;/span&gt; (singleton == &lt;span&gt;null&lt;/span&gt;) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;/*第一层锁，保证只有一个线程进入，&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            * ①多个线程第一次进入的时候，只有一个线程会进入，其他线程处于阻塞状态&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            * 当进入的线程创建完对象出去之后，其他线程又会进入创建对象，所以有了第二次if检查&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            * ②多个线程第二次是进入不到这里的，因为已被第一次if检查拦截*/&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;synchronized&lt;/span&gt; (Singleton.class) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                &lt;span&gt;/*第二层检查，防止除了进入的第一个线程的其他线程重复创建对象*/&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                &lt;span&gt;if&lt;/span&gt; (singleton == &lt;span&gt;null&lt;/span&gt;) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                    singleton = &lt;span&gt;new&lt;/span&gt; Singleton();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; singleton;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;strong&gt;代码注释已详细讲解volatile在该单例模式的作用，已经双重锁的作用。&lt;/strong&gt;①优点：解决了线程阻塞的问题
②缺点：多个线程第一次进入的时候会造成大量的线程阻塞，代码不够优雅。&lt;/span&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（5）静态内部类的方式&lt;/span&gt;&lt;/h5&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Singleton&lt;/span&gt; {&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;Singleton&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LayzInner&lt;/span&gt;{&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Singleton singleton = &lt;span&gt;new&lt;/span&gt; Singleton();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Singleton &lt;span&gt;getSingleton&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; LayzInner.singleton;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;说明：&lt;/strong&gt;①优点：第一次类创建的时候加载，避免了内存浪费，不存在阻塞问题，线程安全，唯一性
②缺点：序列化-漏洞：反射，会破坏内部类单例模式&lt;/span&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（6）枚举单例模式&lt;/span&gt;&lt;/h5&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt; EnumSingleton {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    INSTANCE;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; Singleton singleton;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    EnumSingleton(){&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        singleton = &lt;span&gt;new&lt;/span&gt; Singleton();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Singleton &lt;span&gt;getSingleton&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; singleton;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;说明：&lt;/strong&gt;单元素的枚举类型已经成为实现Singleton的最佳方法，无法反射创建对象，但是特殊的饿汉式。&lt;/span&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（7）静态内部类升级版&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;&lt;span&gt;借鉴枚举单例的内部实现的方式&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Singleton&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;Singleton&lt;/span&gt;()&lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;if&lt;/span&gt;(LayzInner.singleton != &lt;span&gt;null&lt;/span&gt;){&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&lt;span&gt;&quot;不能够进行反射！&quot;&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;LayzInner&lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Singleton singleton = &lt;span&gt;new&lt;/span&gt; Singleton();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Singleton &lt;span&gt;getSingleton&lt;/span&gt; ()&lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; LayzInner.singleton;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;说明：&lt;/strong&gt;①优点：第一次类创建的时候加载，避免了内存浪费，不存在阻塞问题，线程安全，唯一性，解决了反射会破坏内部类单例模式的问题&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;②缺点：不是官方的&lt;/span&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（8）容器式单例&lt;/span&gt;&lt;/h5&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Singleton {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; Singleton() {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Map&amp;lt;&lt;span&gt;String&lt;/span&gt;, &lt;span&gt;Object&lt;/span&gt;&amp;gt; ioc = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;Object&lt;/span&gt; getBean(&lt;span&gt;String&lt;/span&gt; className) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        synchronized (ioc) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;if&lt;/span&gt; (ioc.containsKey(className)) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                &lt;span&gt;Object&lt;/span&gt; o = &lt;span&gt;null&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                    o = Class.forName(className).newInstance();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                    e.printStackTrace();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                &lt;span&gt;return&lt;/span&gt; o;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                &lt;span&gt;return&lt;/span&gt; ioc.get(className);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;说明&lt;/strong&gt;：Spring ioc 单例 是懒汉式 枚举上的升级&lt;/span&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（9）ThreadLocal单例&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5503597122302158&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tshryEKfLJODAruawvHK3OjRdIaAzOuREuoPa3H8ibONHeicGvowiccSPicM0riaaIRyaFsw1LNk3eGLNRA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1112&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;说明&lt;/strong&gt;：局部单例模式：某一个线程里唯一 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;①ThreadLocal的作用呢，是提供线程内的局部变量，在多线程环境访问时，能保证各个线程内的ThreadLocal变量各自独立。也就是说每个线程的ThreadLocal变量是自己专用的，其他线程是访问不到的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;②ThreadLocal最常用于在多线程环境下存在对非线程安全对象的并发访问，而且该对象不需要在线程内共享，如果对该对象加锁，会造成大量线程阻塞影响程序性能，这时候就可以使用ThreadLocal来使每个线程都持有该对象的副本，这是典型的空间换取时间从而提高执行效率的方式。例如项目里经常使用的SimpleDateFormat日期格式化对象，该对象是线程不安全的，而且不需要在线程内共享，因此可以使用ThreadLocal保证其线程安全。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（5）原型模式&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.认识&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;①一句话来说就是，通过复制现有的实例来创建新的实例。因为是同过原有的对象创建新的对象，所以称为原型模式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;②原型模式是用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。原型模式允许一个对象再创建另外一个可定制的对象，无须知道任何创建的细节。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;③用于创建重复的对象，同时又能保证性能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（1）&lt;strong&gt;浅拷贝&lt;/strong&gt;：我们只拷贝对象中的基本数据类型（8种），对于数组、容器、引用对象等都不会拷贝，只会拷贝对这些对象的引用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（2）&lt;strong&gt;深拷贝&lt;/strong&gt;：不仅能拷贝基本数据类型，还能拷贝那些数组、容器、引用对象（不仅拷贝对这些对象的引用，而且拷贝对象本身）。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.UML类图&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4081419624217119&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tshryEKfLJODAruawvHK3OjRiaWW4ROJgE1x6W7W3VV9Zg742ToicMuGSaHicygMz5KgKfr1uVMZj9Lgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;958&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;UML说明：&lt;/strong&gt;实体类实现Cloneable接口，重写clone方法&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.代码实现&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;（1）Prototype类：&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Prototype&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Cloneable&lt;/span&gt; {&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; Integer id;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; String name;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, Double&amp;gt; &lt;span&gt;map&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    @&lt;span&gt;Override&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;protected&lt;/span&gt; Prototype &lt;span&gt;clone&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; throws CloneNotSupportedException &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;//浅拷贝方式&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        Prototype prototype = (Prototype) super.clone();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;//深拷贝方式：对每一个复杂类型分别进行克隆&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;//测试浅拷贝的时候注释下面代码&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        prototype.&lt;span&gt;map&lt;/span&gt; = (Map&amp;lt;String, Double&amp;gt;) ((HashMap)&lt;span&gt;this&lt;/span&gt;.&lt;span&gt;map&lt;/span&gt;).clone();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; prototype;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Prototype&lt;/span&gt;&lt;span&gt;(Integer id, String name, Map&amp;lt;String, Double&amp;gt; &lt;span&gt;map&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;this&lt;/span&gt;.id = id;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;this&lt;/span&gt;.name = name;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;this&lt;/span&gt;.&lt;span&gt;map&lt;/span&gt; = &lt;span&gt;map&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;/**省略get、set方法和toString方法*/&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（2）客户端：&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Client&lt;/span&gt; {&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    @&lt;span&gt;Test&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; throws CloneNotSupportedException &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        Map&amp;lt;String, Double&amp;gt; &lt;span&gt;map&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;map&lt;/span&gt;.put(&lt;span&gt;&quot;数学&quot;&lt;/span&gt;,&lt;span&gt;100&lt;/span&gt;D);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        Prototype prototype = &lt;span&gt;new&lt;/span&gt; Prototype(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;&quot;小明&quot;&lt;/span&gt;,&lt;span&gt;map&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;br mpa-from-tpl=&quot;t&quot;/&gt;        Prototype prototype1 = prototype.clone();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        Map&amp;lt;String, Double&amp;gt; map1 = prototype1.getMap();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        map1.put(&lt;span&gt;&quot;数学&quot;&lt;/span&gt;,&lt;span&gt;99&lt;/span&gt;d);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;br mpa-from-tpl=&quot;t&quot;/&gt;        System.out.println(prototype);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        System.out.println(prototype1);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（3）执行结果：&lt;strong&gt;浅拷贝：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.24583333333333332&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tshryEKfLJODAruawvHK3OjRb9yI0DPqRYfKuZHLWSibiajDPtlW00vCrfgkWZicpibjhBgaLnxuIWicpMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;改变其中一个对象map的值，两个对象的map内容都发生了变化&lt;strong&gt;深拷贝：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.2256509161041466&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tshryEKfLJODAruawvHK3OjRjtBrCBoibT8x0cBeWELRH3SAPn5fhsTlauYyibAGDDUsibE84KZojtXog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1037&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;改变其中一个对象map的值，该对象的map内容发生了变化，另一个对象map的内容没有发生变化&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.总结&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;优点：&lt;/strong&gt;①提高了性能，在需要短时间创建大量的对象和创建对象很耗时的情况下，原型模式比通过new对象大大提高了时间效率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;② 逃避构造函数的约束。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、实现原型模式每个派生类都必须实现 Clone接口。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.应用场景&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;1.通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。比如，向数据库表插入多条测试数据，可以用到。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过clone的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与Java融为浑然一体，大家可以随手拿来使用。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（6）建造者模式&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.认识：&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;①一句话来说：封装一个复杂对象的构建过程，并可以按步骤构造。因为需要对对象一步步建造起来，所以称为建造者模式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;②将复杂产品的构建过程封装分解在不同的方法中，使得创建过程非常清晰，能够让我们更加精确的控制复杂产品对象的创建过程，同时它隔离了复杂产品对象的创建和使用，使得相同的创建过程能够创建不同的产品。但是若内部变化复杂，会有很多的建造类。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.UML类图：&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5193014705882353&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tshryEKfLJODAruawvHK3OjRPxCAHOlCglBcy9xSlCfc5rxwia46nnBC4VdibCLKwicU2Esz46vODvpSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1088&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;UML说明：Product（产品角色）：一个具体的产品对象。Builder（抽象建造者）：创建一个Product对象的各个部件指定的抽象接口。ConcreteBuilder（具体建造者）：实现抽象接口，构建和装配各个部件。Director（指挥者）：构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.代码如下：&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;1.产品类：&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Product {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; part1;&lt;span&gt;//可以是任意类型&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; part2;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; part3;&lt;br mpa-from-tpl=&quot;t&quot;/&gt; &lt;span&gt;/**set get 方法省略&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;2.抽象建造者&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Builder&lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    Product product = &lt;span&gt;new&lt;/span&gt; Product();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;buildPart1&lt;/span&gt;()&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;buildPart2&lt;/span&gt;()&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;buildPart3&lt;/span&gt;()&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Product &lt;span&gt;getResult&lt;/span&gt;()&lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; product;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    };&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.具体建造者&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ConcreteBuilder&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Builder&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;buildPart1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        System.out.println(&lt;span&gt;&quot;建造part1&quot;&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;buildPart2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        System.out.println(&lt;span&gt;&quot;建造part2&quot;&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;buildPart3&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        System.out.println(&lt;span&gt;&quot;建造part3&quot;&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4.指挥者：&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Director&lt;/span&gt; {&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; Builder builder;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Director&lt;/span&gt;&lt;span&gt;(Builder builder)&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;this&lt;/span&gt;.builder = builder;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Product &lt;span&gt;build&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        builder.buildPart1();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        builder.buildPart2();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        builder.buildPart3();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; builder.getResult();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5.客户端&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Client&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Test&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        Builder builder = &lt;span&gt;new&lt;/span&gt; ConcreteBuilder();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        Director director = &lt;span&gt;new&lt;/span&gt; Director(builder);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        director.build();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;6.执行结果&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.2409532215357458&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tshryEKfLJODAruawvHK3OjR7UNVB3VZeHNQJc0p8LJvYUVwlRBPdePs9EhQoS9VXaibz7nElBtxWYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1133&quot;/&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.总结&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;优点&lt;/strong&gt;：1、建造者独立，易扩展。将复杂产品的构建过程封装分解在不同的方法中，使得创建过程非常清晰，能够让我们更加精确的控制复杂产品对象的创建过程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、便于控制细节风险。它隔离了复杂产品对象的创建和使用，使得相同的创建过程能够创建不同的产品。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;缺点&lt;/strong&gt;：1、产品必须有共同点，范围有限制。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、如内部变化复杂，会有很多的建造类，导致系统庞大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;应用场景&lt;/strong&gt;1、需要生成的对象具有复杂的内部结构。2、需要生成的对象内部属性本身相互依赖。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.应用场景&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;JAVA 中的 StringBuilder。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;六、个人体会&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;设计模式是一种解决问题的思维和方式，不要生搬硬套，为了设计模式而模式。本文作者：王德印，欢迎复制下方链接关注博主动态。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;链接：https:&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果看到这里，说明你喜欢这篇文章，请 转发、点赞。微信搜索「web_resource」，关注后回复「进群」或者扫描下方二维码即可进入无广告交流群。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;↓扫描二维码进群↓&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;62&quot; data-cropselx2=&quot;512&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;800&quot; data-ratio=&quot;1.2865731462925851&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tshb50Sh1khH7996ErEXibIF96rLzrCibry7dwbibDTchlg81suicLyiaz2JVbiacV6rpLpcdC2Y0vpkh3Ag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;499&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;hr/&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;1. &lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247498662&amp;amp;idx=1&amp;amp;sn=0087c4f3b79ba3420e917e9b42d45eda&amp;amp;chksm=f9a2286fced5a1794eb9a73d0be7c2e16eaceabf3a0420647c40cb4202bd116d9a15dd57c008&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;GitHub 上有什么好玩的项目？&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2. &lt;/span&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2MjEwMjI1Mg==&amp;amp;mid=2247518355&amp;amp;idx=2&amp;amp;sn=23c5bc3477a0185b517840b8318fb166&amp;amp;chksm=ce0e3f10f979b606a9915aea543e34da632e6af092d65f0a071845e2c079cf6fe7077bf2315c&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;Linux 运维必备 150 个命令汇总&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;3.&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt; &lt;/span&gt;&lt;/em&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2MjEwMjI1Mg==&amp;amp;mid=2247516734&amp;amp;idx=1&amp;amp;sn=966d166d3052f10b9310ff4014733669&amp;amp;chksm=ce0e35bdf979bcabbb75366e1bad32bdbf8f41d1dc80b8be6e39225bd708913ce2c93472f2fc&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;SpringSecurity + JWT 实现单点登录&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;4. &lt;/span&gt;&lt;/em&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2MjEwMjI1Mg==&amp;amp;mid=2247516664&amp;amp;idx=1&amp;amp;sn=0dae1a8cf99c4bde8fd8c9c197769009&amp;amp;chksm=ce0e367bf979bf6dec769decc0194bb36de4caeae7947671aba1852fe6bac8e5dab7d20916a5&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;100 道 Linux 常见面试题&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;237&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;237&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0025974025974025&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tshn9SMhG6BHgRk5qpevy0F2xsmyU0njUOunKP8SYtDOhCGJpv8BR83CibJTN1heZibawIdQwmTs0Adw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;770&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>edccea61c90cb0778374e26dc33d61cf</guid>
<title>代码写的烂，经常被同事怼，教你一招</title>
<link>https://toutiao.io/k/4hdm0ni</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是Tom哥~&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;面对复杂的业务场景，千变万化的客户需求，如何以一变应万变，以最小的开发成本快速落地实现，同时保证系统有着较低的复杂度，能够保证系统后续de持续迭代能力，让系统拥有较高的可扩展性。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这些是一个合格的架构师必须修炼的基础内功，但是如何修炼这门神功？？？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我将常用的软件设计模式，做了汇总，目录如下：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;3.113573407202216&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshweToKjhKuczLNAV2XHerOgXzwYAvMe5YsQlj3W7lsib6laCPLTXiaHKG3r8iaJPeicanO6aCpTBOsr47g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;361&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;(考虑到内容篇幅较大，为了便于大家阅读，将软件设计模式系列（共23个）拆分成四篇文章，每篇文章讲解六个设计模式，采用不同的颜色区分，便于快速消化记忆）&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;前文回顾：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文是主要讲解&lt;code&gt;桥接模式&lt;/code&gt;、&lt;code&gt;组合模式&lt;/code&gt;、&lt;code&gt;装饰模式&lt;/code&gt;、&lt;code&gt;门面模式&lt;/code&gt;、&lt;code&gt;代理模式&lt;/code&gt;、&lt;code&gt;责任链模式&lt;/code&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg2NzYyNjQzNg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwdmOC0H6kaQlnh3rvWF2hPpzBoAoibbfQkhLdXfEpQgd8frHoDJDH503rv3FaMK6las2rCNQY7icr6w/0?wx_fmt=png&quot; data-nickname=&quot;微观技术&quot; data-alias=&quot;weiguanjishu&quot; data-signature=&quot;前阿里架构师，研究生，CSDN博客专家。负责过电商交易、社区团购、流量营销等业务。分享后端架构技能、一线大厂面试经验、团队管理等话题。欢迎关注&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、桥接模式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;自然界一般由实体和行为组成。当然为了提升系统的扩展性，它们两个又可以各自抽象，然后在抽象类中描述两者的依赖。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;定义：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;将抽象部分与它的实现部分分离，使它们都可以独立地变化。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;什么场景使用桥接模式？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;一个类存在两个（或多个）独立变化的维度，且这两个（或多个）维度都需要独立进行扩展。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;对于那些不希望使用继承或因为多层继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;核心思路：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;抽象实体：定义的一种抽象分类。比如：人&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;具体实体：继承抽象实体的子类实体。比如：中国人、美国人、韩国人&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;抽象行为：定义抽象实体中具备的多种行为。比如：学汉语、吃汉堡&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;具体行为：实现抽象行为的具体算法。比如：中国人学汉语、美国人吃汉堡&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.38203125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshweToKjhKuczLNAV2XHerOgXElzF76gEZLKtt415cPzD2iaF2BwlNTJ151LU2X4wg9G5oekCCicQibP0w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;代码示例：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;/**&lt;br/&gt; * @author 微信公众号：微观技术&lt;br/&gt; * 抽象实体&lt;br/&gt; */&lt;br/&gt;public abstract class AbstractEntity {&lt;br/&gt;    protected AbstractBehavior abstractBehavior;&lt;br/&gt;&lt;br/&gt;    public AbstractEntity(AbstractBehavior abstractBehavior) {&lt;br/&gt;        this.abstractBehavior = abstractBehavior;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public abstract void out();&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;/**&lt;br/&gt; * 抽象行为&lt;br/&gt; */&lt;br/&gt;public interface AbstractBehavior {&lt;br/&gt;&lt;br/&gt;    public String action(String name);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;/**&lt;br/&gt; * 关于食物的行为&lt;br/&gt; */&lt;br/&gt;public class FoodBehavior implements AbstractBehavior {&lt;br/&gt;&lt;br/&gt;    @Override&lt;br/&gt;    public String action(String name) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;中国人&quot;&lt;/span&gt;.equals(name)) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;吃 饺子&quot;&lt;/span&gt;;&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;美国人&quot;&lt;/span&gt;.equals(name)) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;吃 汉堡&quot;&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; null;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;桥接模式是将抽象与抽象之间分离，具体实现类依赖于抽象。抽象的分离间接完成了具体类与具体类之间的解耦，它们之间使用抽象来进行组合或聚合，而不再靠多重继承来实现。&lt;/span&gt;&lt;code&gt;&lt;span&gt;本质是将一个对象的实体和行为分离，然后再基于这两个维度进行独立的演化。&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;适用场景：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;拆分复杂的类对象时。当一个类中包含大量对象和方法时，既不方便阅读，也不方便修改。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;希望从多个独立维度上扩展时。比如，系统功能性和非功能性角度，业务或技术角度等。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;运行时，组合不同的组件&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、组合模式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;定义：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;组合模式也称整体模式，把一组相似的对象当作一个单一的对象，然后将对象组合成树形结构以表示整个层次结构。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里边有两个关键点：1、树形结构分层  2、业务统一化来简化操作&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;核心思路：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;抽象组件（AbstractNode）：定义需要实现的统一操作。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;组合节点（CompositeNode）：抽象组件的衍生子类，包含了若干孩子节点（其它组合节点或叶子节点）。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;叶子节点（LeafNode）：抽象组件的子类，但它的下面没有子节点。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.58671875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshweToKjhKuczLNAV2XHerOgXB6JLVbic6BlV4c3g2TA88VCwFu2DEBMRta0rFgpuHQAyg8ZBUDUbgxQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;代码示例：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;public abstract class AbstractNode {&lt;br/&gt;    public abstract void add(AbstractNode abstractNode);&lt;br/&gt;    public abstract void remove(AbstractNode abstractNode);&lt;br/&gt;    public abstract void action();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;public class CompositeNode extends AbstractNode {&lt;br/&gt;    private Long nodeId;&lt;br/&gt;    private List&amp;lt;AbstractNode&amp;gt; childNodes;  //存放子节点列表&lt;br/&gt;    public CompositeNode(Long nodeId, List&amp;lt;AbstractNode&amp;gt; childNodes) {&lt;br/&gt;        this.nodeId = nodeId;&lt;br/&gt;        this.childNodes = childNodes;&lt;br/&gt;    }&lt;br/&gt;    @Override&lt;br/&gt;    public void add(AbstractNode abstractNode) {&lt;br/&gt;        childNodes.add(abstractNode);&lt;br/&gt;    }&lt;br/&gt;    @Override&lt;br/&gt;    public void remove(AbstractNode abstractNode) {&lt;br/&gt;        childNodes.remove(abstractNode);&lt;br/&gt;    }&lt;br/&gt;    @Override&lt;br/&gt;    public void &lt;span&gt;action&lt;/span&gt;() {&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (AbstractNode childNode : childNodes) {&lt;br/&gt;            childNode.action();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;public class LeafNode extends AbstractNode {&lt;br/&gt;    private Long nodeId;&lt;br/&gt;    public LeafNode(Long nodeId) {&lt;br/&gt;        this.nodeId = nodeId;&lt;br/&gt;    }&lt;br/&gt;    @Override&lt;br/&gt;    public void add(AbstractNode abstractNode) {&lt;br/&gt;        // 无子节点，无需处理&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    @Override&lt;br/&gt;    public void remove(AbstractNode abstractNode) {&lt;br/&gt;        // 无子节点，无需处理&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    @Override&lt;br/&gt;    public void &lt;span&gt;action&lt;/span&gt;() {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;叶子节点编号：&quot;&lt;/span&gt; + nodeId);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;叶子节点不能新增、删除子节点，所以对应的方法为空。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;组合模式本质上封装了复杂结构的内在变化，让使用者通过一个统一的整体来使用对象之间的结构。数据结构方面支持&lt;/span&gt;&lt;code&gt;&lt;span&gt;树形结构&lt;/span&gt;&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;&lt;span&gt;环形结构&lt;/span&gt;&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;&lt;span&gt;网状结构&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。如我们常见的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;深度优先搜索&lt;/span&gt;&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;&lt;span&gt;广度优先搜索&lt;/span&gt;&lt;/code&gt;&lt;span&gt;都是采用这种模式。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;适用场景：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;一组对象按照某种层级结构进行管理。如：管理文件夹和文件，管理订单下的商品。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;需要按照统一的行为来处理复杂结构中的对象&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;快速扩展对象组合。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.51171875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshweToKjhKuczLNAV2XHerOgXrrlF5TZSxHpGusndQ0EbLJcfkHhbG2icjznb1po4a8Sxe4dyaMBPohA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;手机开始是按品牌来归属分类，现在业务增加价格维度分类，我们只需要引入新的分支节点，按新的维度构建组合关系。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3、装饰模式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;定义：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;动态地向一个现有对象添加新的职责和行为，同时又不改变其结构，相当于对现有的对象进行包装。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;核心思路：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;抽象组件（Component）：装饰器基类，定义组件的基本功能&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;具体组件（ConcreteComponent）：抽象组件的具体实现&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;抽象装饰器（Decorator）：包含抽象组件的引用&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;具体装饰器（ConcreteDecorator）：抽象装饰器的子类，并重写组件接口方法，同时可以添加附加功能。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshweToKjhKuczLNAV2XHerOgXGL0oS8eCgfeGxcjUszicxhBPeb3icsdumvoOgUNJPgfX2BH3qF461Ozw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;代码示例：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;public abstract class Component {&lt;br/&gt;    public abstract void execute();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;public class ConcreteComponent extends Component {&lt;br/&gt;    @Override&lt;br/&gt;    public void &lt;span&gt;execute&lt;/span&gt;() {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;具体子类 ConcreteComponent invoke !&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;public class Decorator extends Component {&lt;br/&gt;    protected Component component;&lt;br/&gt;    public Decorator(Component component) {&lt;br/&gt;        this.component = component;&lt;br/&gt;    }&lt;br/&gt;    @Override&lt;br/&gt;    public void &lt;span&gt;execute&lt;/span&gt;() {&lt;br/&gt;        component.execute();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;public class ConcreteDecorator extends Decorator {&lt;br/&gt;    public ConcreteDecorator(Component component) {&lt;br/&gt;        super(component);&lt;br/&gt;    }&lt;br/&gt;    @Override&lt;br/&gt;    public void &lt;span&gt;execute&lt;/span&gt;() {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;装饰器子类 ConcreteDecorator invoke !&quot;&lt;/span&gt;);&lt;br/&gt;        super.execute();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;装饰模式本质上就是给已有不可修改的类附加新的功能，同时还能很方便地撤销。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg2NzYyNjQzNg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwdmOC0H6kaQlnh3rvWF2hPpzBoAoibbfQkhLdXfEpQgd8frHoDJDH503rv3FaMK6las2rCNQY7icr6w/0?wx_fmt=png&quot; data-nickname=&quot;微观技术&quot; data-alias=&quot;weiguanjishu&quot; data-signature=&quot;前阿里架构师，研究生，CSDN博客专家。负责过电商交易、社区团购、流量营销等业务。分享后端架构技能、一线大厂面试经验、团队管理等话题。欢迎关注&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;适用场景：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;无需修改代码的情况下即可使用对象， 且希望在运行时为对象新增额外的功能&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将业务逻辑组织为层次结构，可以为各层创建一个装饰，在运行时将各种不同逻辑组合成对象。由于这些对象都遵循通用接口，客户端代码能以相同的方式使用这些对象。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;不支持继承扩展类的场景。如：&lt;/span&gt;&lt;code&gt;&lt;span&gt;final&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 关键字限制了某个类的进一步扩展，可以通过装饰器对其进行封装，从而具备扩展能力。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4、门面模式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;定义：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;门面模式提供一个高层次的接口，要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行，使得子系统更易于使用。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;门面模式要求我们使用统一的标准与系统交互，比如：我们打印日志基本会选择&lt;/span&gt;&lt;code&gt;&lt;span&gt;slf4j&lt;/span&gt;&lt;/code&gt;&lt;span&gt;框架，其内部统一了&lt;/span&gt;&lt;code&gt;&lt;span&gt;log4j&lt;/span&gt;&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;&lt;span&gt;log4j2&lt;/span&gt;&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;&lt;span&gt;CommonLog&lt;/span&gt;&lt;/code&gt;&lt;span&gt;等日志框架，简化了我们的开发成本。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;核心思路：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;门面系统。接收外部请求，并将请求转发给适当的子系统进行处理&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;子系统。表示某个领域内的功能实现、或者具体子接口实现，比如，订单、支付等，专门处理由门面系统指派的任务。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;简单来讲，引入一个外观角色来简化客户端与子系统之间的交互，为复杂的子系统调用提供一个统一的入口。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;可能很多人有疑问，这个不就是代理模式吗？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;门面模式可能代理的是多个接口，而代理模式通常只是代理一个接口。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;业务场景：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;移动互联网，我们都习惯了在线支付，相信很多人在付款时都听过这么一句话，”微信支付还是支付宝“，商户根据用户反馈再针对性选择收款渠道。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;是不是很繁琐，为了解决这个问题，市面就有了聚合支付（该领域做非常棒的是收钱吧），整个业务模式就是这节要讲的门面模式，不管你用什么软件支付，只要打开付款二维码即可，收钱吧底层识别解析二维码，并根据扫描结果自动适配对应的收款渠道，完成用户的扣款动作，确实带来不错的用户体验。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.8433734939759037&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshweToKjhKuczLNAV2XHerOgX66SZnRL2kXIZ4j87iaM7501hvpcD56Nk1iaDBTiclKEWWn6oicJTXyt8ag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;996&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;br/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;简化复杂系统，提供统一接口规范。比如：&lt;/span&gt;&lt;code&gt;&lt;span&gt;JPA&lt;/span&gt;&lt;/code&gt;&lt;span&gt;提供了统一Java持久层API，底层适配多样化的存储系统。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;复杂的业务逻辑由内部子系统消化，只要对外接口规范不变，外部调用方不需要频繁修改&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;扩展性较好，类似于&lt;/span&gt;&lt;code&gt;&lt;span&gt;SPI架构&lt;/span&gt;&lt;/code&gt;&lt;span&gt;一样，支持水平扩展。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;较高的平滑过渡性。比如：我们要对老的系统架构升级，开发一系列新接口来替换原来的老接口，过渡期需要新老灰度测试、流量切换、平滑升级，可以采用该模式。门面模式在兼容多套系统、系统重构方面是把利器。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;5、代理模式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;定义：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;为其他对象提供一种代理以控制对这个对象的访问&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;现实场景：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;核心思路：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;抽象主题类（AbstractSubject）：定义接口方法，供客户端使用&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;主题实现类（RealSubject）：实现了&lt;/span&gt;&lt;code&gt;&lt;span&gt;抽象主题类&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的接口方法&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;代理类（Proxy）：实现了&lt;/span&gt;&lt;code&gt;&lt;span&gt;抽象主题类&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的接口方法，内部包含&lt;/span&gt;&lt;code&gt;&lt;span&gt;主题实现类&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的逻辑， 同时还包含一些自身的扩展操作。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;代理模式与适配器模式相似。但适配器模式是转换为新的接口，而代理模式不会改变原有接口。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6094276094276094&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshweToKjhKuczLNAV2XHerOgXclQPd9zDAEqrTRbiaCONstCHicVO8xdvnucAVcVycCJJEk9JkH04Z0kw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1188&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;代码示例：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;/**&lt;br/&gt; * @author 微信公众号：微观技术&lt;br/&gt; */&lt;br/&gt;public interface AbstractSubject {&lt;br/&gt;    void execute();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;public class RealSubject implements AbstractSubject {&lt;br/&gt;    @Override&lt;br/&gt;    public void &lt;span&gt;execute&lt;/span&gt;() {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;我是Tom哥，我要努力工作！&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;public class Proxy implements AbstractSubject {&lt;br/&gt;&lt;br/&gt;    private AbstractSubject abstractSubject;&lt;br/&gt;&lt;br/&gt;    public Proxy(AbstractSubject abstractSubject) {&lt;br/&gt;        this.abstractSubject = abstractSubject;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    @Override&lt;br/&gt;    public void &lt;span&gt;execute&lt;/span&gt;() {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;老板给Tom哥分配工作了。。。&quot;&lt;/span&gt;);&lt;br/&gt;        abstractSubject.execute();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;按使用职责分为静态代理和动态代理。&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;静态代理，代理类需要自己编写代码完成。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;动态代理，代理类通过 Proxy#newProxyInstance(ClassLoader loader,Class&amp;lt;?&amp;gt;[] interfaces,InvocationHandler h) 方法生成。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;JDK实现的代理中不管是静态代理还是动态代理，都是面向接口编程。CGLib可以不限制一定是接口。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;职责清晰&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;高扩展，只要实现了接口，都可以用代理&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;智能化，动态代理&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;降低了对象的直接耦合&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;适用场景：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;远程代理。无法直接操作远程对象。比如：Dubbo、gRPC，提供远程服务，客户端调用时需要走参数组装、序列化、网络传输等操作，这些通用逻辑都可以封装到代理中，客户端调用代理对象访问远程服务，就像调用本地对象一样方便。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;保护代理。当客户端通过代理对象访问原始对象时，代理对象会根据规则判断客户端是否有权限访问。比如：防火墙&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;日志代理。比如：日志监控，正常业务访问时，调用代理，增加一些额外的日志记录功能。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;虚拟代理，适用于延迟初始化，用小对象表示大对象的场景，减少资源损耗，提升运行速度。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;不希望改变原对象，但需要增加类似于权限控制、日志、流控等附加功能时，可以使用代理模式。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;6、责任链模式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;定义：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;责任链模式是一种行为设计模式，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链。收到请求后，每个处理者均可对请求进行处理，或将其传递给链中的下个处理者。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;责任链模式是对数据结构中的&lt;/span&gt;&lt;code&gt;&lt;span&gt;链表&lt;/span&gt;&lt;/code&gt;&lt;span&gt;结构的具体应用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;核心思路：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;抽象处理者（Handler）：定义一个接口，内部包含处理方法和下一个节点的引用对象&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;具体处理者（ConcreteHandler）：&lt;/span&gt;&lt;code&gt;&lt;span&gt;抽象处理者&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的实现子类，判断本次请求是否处理，如果需要则处理，否则跳过，然后将请求转发给下一个节点。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.66875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshweToKjhKuczLNAV2XHerOgXqibxgLNdrl2vOQnhoRpV5UuzDA0HeAqD4hztETtlQiaOmQdOs4DUcL2w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;降低了对象之间的耦合度。链上各个节点各司其职，通过上下文传递数据，避免直接依赖。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;增强系统的可扩展性。如果有新的业务需求，只需要在合适的位置增加一个链节点即可，满足开闭原则。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;灵活性强。如果业务有变化，需要对工作流程做调整，只需要动态调整链上节点的次序即可。甚至为了满足多元化业务的多样化需求，我们可以为不同的业务类型定义自己的专属执行顺序。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;简化了对象之间的连接。每个对象只需保存下一个节点的引用，而不需保持所有节点。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;责任明确。每个节点只需处理自己的工作，如果不处理则传递给下一个对象。明确各类的责任范围，符合类的单一职责原则。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;像我们常见的网关架构推荐使用该模式，通过服务编排，可以自由地在任意位置添加或移除节点，满足一系列个性化功能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.38125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshweToKjhKuczLNAV2XHerOgXichmPVJaJ4yPq86OH2v3mqzudkgvicqSumeZUziaaV6ibCtIQDsL3gqb5g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;写在最后&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;设计模式很多人都学习过，但项目实战时总是晕晕乎乎，原因在于没有了解其核心是什么，底层逻辑是什么，《设计模式：可复用面向对象的基础》有讲过，&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在设计中思考什么应该变化，并封装会发生变化的概念。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;软件架构的精髓：找到变化，封装变化。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;业务千变万化，没有固定的编码答案，千万不要硬套设计模式。无论选择哪一种设计模式，尽量要能满足&lt;/span&gt;&lt;code&gt;&lt;span&gt;SOLID&lt;/span&gt;&lt;/code&gt;&lt;span&gt;原则，自我review是否满足业务的持续扩展性。有句话说的好，“不论白猫黑猫，能抓老鼠就是好猫。”&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;关于我：前阿里架构师，出过专利，竞赛拿过奖，CSDN博客专家，负责过电商交易、社区生鲜、营销、金融等业务，多年团队管理经验，爱思考，喜欢结交朋友&lt;/span&gt;&lt;/section&gt;&lt;h1 accuse=&quot;qTitle&quot;&gt;&lt;span&gt;&lt;span&gt;「长按2秒」↓↓&lt;/span&gt;&lt;span&gt;↓ 二维码，拉你进群，BAT大厂大神技术交流&lt;/span&gt;&lt;/span&gt;&lt;/h1&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0431654676258992&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwcKcwUzqiaWBaTAJKnfZ3dEhHLpic5tEKBfZl6Aajibcu5OasBiaDXrIPRib3TqpwTy1ERyR4dycicyiaZwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;556&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&amp;amp;mid=2247485030&amp;amp;idx=1&amp;amp;sn=fae128c2991e69101e6e4732001bcb76&amp;amp;chksm=ceb9facdf9ce73db7f26fe269b2fb7f7f16fe1aed7bfbf4028c81239f75890ebab8d27a3a50d&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;面试题：mysql 一棵 B+ 树能存多少条数据？&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&amp;amp;mid=2247484980&amp;amp;idx=1&amp;amp;sn=25a530689f0657750d579263800369a6&amp;amp;chksm=ceb9fa9ff9ce7389974d2f33bea9d861920cb75cca559f1f2810c89f729011bb3c2839ac46da&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;学会这10个设计原则，离架构师又进了一步！！！&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&amp;amp;mid=2247484947&amp;amp;idx=1&amp;amp;sn=5a70f88fba83b435b8144bf1ddd3cc9f&amp;amp;chksm=ceb9fab8f9ce73ae97afc43f87314dd3bb61c966b9a40c12801cddc454dcf2845bbb605694e3&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;亿级系统的Redis缓存如何设计？？？&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&amp;amp;mid=2247484957&amp;amp;idx=1&amp;amp;sn=e50e0808cb6503ca7214bdd6fee4f134&amp;amp;chksm=ceb9fab6f9ce73a0c0725e381673fc7dc50c0594fb995b5f985b263143b34371e5e2936d7be0&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;【高并发、高性能、高可用】系统设计经验&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&amp;amp;mid=2247484929&amp;amp;idx=1&amp;amp;sn=d8cb3306dea9f1b92fd30d59da3f536a&amp;amp;chksm=ceb9faaaf9ce73bca59b46021a450fdc84aa0f85d6b49ff0e5578cc3abaa1433447f7dffc5e4&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;人人都是架构师？？？谈何容易！！&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&amp;amp;mid=2247484921&amp;amp;idx=1&amp;amp;sn=b429efe7e622759fc8f3bb24c2979a90&amp;amp;chksm=ceb9f952f9ce7044b001528ce8ae0ec89ed63727764081c21a8400e9f8f685345ec9cb0a54d7&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【万级并发】电商库存扣减如何设计？不超卖！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9a32b5d7dbd591ad5e54f7a7df7c6b85</guid>
<title>手痒想写项目？我挑了 10 个开源项目送你</title>
<link>https://toutiao.io/k/nw9yd13</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xBgIbW1vdNNyfVBIy0fRfvogFxBsrE4OS2p20yI6hZtfxicHKa2TSc8MfqsebJGhiaoycJknwR2bHjTYv89nkQyw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我刚学完 Python 语法那会儿，手痒想写个项目展示自己的学习成果。&lt;/span&gt;&lt;span&gt;但却不知道写个啥，经过几次失败的尝试和碰壁后认清了现实，发现到自己只是刚学会基本语法，想要从零写个项目还差得远。&lt;/span&gt;&lt;span&gt;不知道有多少朋友和我一样，手痒想写个项目。&lt;/span&gt;&lt;span&gt;但：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;不知道能写什么&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;知道写什么，但无从下手&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5566666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xBgIbW1vdNNyfVBIy0fRfvogFxBsrE4OMS89S6WpiaSibHsY2Iah1C1OS2rR0hIpl9GVcXcFADHLEOLbGNy1vP5g/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;300&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果刚学完语法想写个项目，可以先从 Web 方向入手。因为这方面有很多现成的框架和资料，但不要上来就去学习框架（看文档）不然你“手痒”的冲动和仅有的那点激情，可能就全部消耗在了啃框架上。我建议你去找一个 &lt;strong&gt;感兴趣的 Web 开源项目，然后把它跑起来&lt;/strong&gt;，先不要去探究每行代码的意思，就跟着部署说明一步步执行命令就好。在运行项目的过程中不可避免会遇到三方库的安装、运行报错等情况，这个时候就必然要去看文档，带着问题去看文档能够把文档读“薄”。但不管怎么样想把一个项目跑起来都是件十分痛苦的事情，这也是必经之路没有什么捷径可言。你需要做的是 &lt;strong&gt;不断解决眼下的每一个报错直到没有任何问题，让项目顺利地跑起来&lt;/strong&gt; 这可比学会一个框架，然后用它写一个项目简单多了！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当你成功运行起来一个项目，相信 Web 框架和项目的文档也零碎地翻了几遍了。这时候再去学习框架就&lt;strong&gt;不再是枯燥的学框架和背代码&lt;/strong&gt;，而是把你在运行项目时积累的知识碎片串起来融会贯通，另外运行时遇到的问题也会随着学习的深入迎刃而解。最后，站在“大佬的肩膀”上照猫画虎地修改项目代码增加功能感受 DIY 带来的乐趣，一定要多动手运行+调试才能吃透项目，从而看懂项目结构和架构。随着把玩的开源项目多了，再遇到手痒的时候就能自己写个“玩意儿”啦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写项目先从&lt;strong&gt;跑起来一个开源项目开始&lt;/strong&gt;！下面就给大家介绍 7 个有趣的 Web 开源项目和 3 个桌面软件，跑起来就能用！涵盖多种主流编程语言：C/C++、Java、Python、JavaScript、PHP 等，希望你在 HelloGitHub 找到感兴趣的开源项目。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1、novel-plus（小说）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Star 数&lt;/strong&gt;：1.5k｜&lt;strong&gt;语言&lt;/strong&gt;：Java&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个功能齐全的原创文学平台。类似起点中文网：看小说+写小说，它由前台门户、作家后台管理、平台后台管理、爬虫等多个子系统构成，采用 SpringBoot、MyBatis、MySQL、Redis 等技术实现。功能强大不仅支持多端的小说阅读，还有新闻模块、作家专区以及会员充值和订阅模式等功能。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6833333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNNyfVBIy0fRfvogFxBsrE4OhialJNTrxG1Gcosb5nJeNv6HtT89pzp1SdvZommof9eEic31TOtTRedg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;演示：http://47.106.243.172:8888/&lt;/p&gt;&lt;p&gt;地址：https://github.com/201206030/novel-plus&lt;/p&gt;&lt;p&gt;官网：https://201206030.github.io/&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2、homeland（论坛）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Star 数&lt;/strong&gt;：3.4k｜&lt;strong&gt;语言&lt;/strong&gt;：Ruby&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一款开源不限制商用的精致社区/论坛系统。国内最大的 Ruby 社区 Ruby China 开源的项目，值得一提的是该系统拥有完整的实时通知和社交功能：关注的人和话题动态通知、@提及通知、丰富的表情系统等。如果你能把这个项目跑起来，就立刻拥有了一个“社区”。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.38055555555555554&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNNyfVBIy0fRfvogFxBsrE4Ov8jH776NwhMPuric6udGTDPQ3wdbdZ9P7Gw4ZWpUMrlG4yOmB9eXGYg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;演示：https://ruby-china.org/&lt;/p&gt;&lt;p&gt;地址：https://github.com/ruby-china/homeland&lt;/p&gt;&lt;p&gt;官网：https://homeland.ruby-china.org/zh-CN/&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3、nopCommerce（电商）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Star 数&lt;/strong&gt;：6.3k｜&lt;strong&gt;语言&lt;/strong&gt;：C#&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;免费开源基于 ASP.NET 电商购物平台。习惯了用 Java 写的电商平台，换个口味来看看这个用 ASP.NET 构建，适合中小型企业和个人的商城项目。它始于 2008 年由专业团队开发和维护，支持 Windows、Linux、macOS 平台，还有开箱即用的 Docker 部署方式。让 nopCommerce 跑起来，开启电商的大门。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.542&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNNyfVBIy0fRfvogFxBsrE4OwH2MM8iaQQSNFtaNAdt7gON55lUaXibS5JuF5mQ1V8xdcV26MXphzA6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;500&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;演示：http://frontend.nopcommerce.com/&lt;/p&gt;&lt;p&gt;地址：https://github.com/nopSolutions/nopCommerce&lt;/p&gt;&lt;p&gt;官网：https://www.nopcommerce.com/zh&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4、filebrowser（文件）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Star 数&lt;/strong&gt;：10k｜&lt;strong&gt;语言&lt;/strong&gt;：Go&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在线文件管理系统。安装成功后直接指定目录即可运行起来一个 Web 文件管理系统，支持文件浏览、生成分享链接、批量上传、文件夹管理、用户系统等功能。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6431881371640408&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xBgIbW1vdNNyfVBIy0fRfvogFxBsrE4OCrzSIBQIXicNz79RjbibPic3vKTsoZH8606rBw2XeKhRx6lljicakRWicLQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1079&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;安装：https://filebrowser.org/installation&lt;/p&gt;&lt;p&gt;地址：https://github.com/filebrowser/filebrowser&lt;/p&gt;&lt;p&gt;官网：https://filebrowser.org/&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5、humhub（社交）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Star 数&lt;/strong&gt;：5.4k｜&lt;strong&gt;语言&lt;/strong&gt;：PHP&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开源的社交平台。相信看过《社交网络》的小伙伴都知道，大名鼎鼎的 Facebook 最早就是扎克伯格用 PHP 语言写的。这个项目基于 Yii 2 框架实现，包含了社交平台所需的基本功能而且运行简单，跑起来后来个二次开发，搞一个有特色的社交平台。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4925925925925926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNNyfVBIy0fRfvogFxBsrE4O4DvEKk6qicne7bBnBlBvTu3XMhTmr8ebe44NztiblptgAavCe88cJXSg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;地址：https://github.com/humhub/humhub&lt;/p&gt;&lt;p&gt;官网：https://www.humhub.com/en&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6、wiki（维基）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Star 数&lt;/strong&gt;：13.2k｜&lt;strong&gt;语言&lt;/strong&gt;：JavaScript&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;强大且漂亮的开源维基平台。项目采用 Vue.js+Node.js+Git 实现，可直接部署用于团队内部多人协作下的写作和知识管理。想要做全栈的小伙伴，快拿下这个项目吧。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5555555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNNyfVBIy0fRfvogFxBsrE4OEtEYkfN5TBUiaNhtskib2nAEQRcWpQXnznyGL0YPp8SC1621G9OGoKAg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;演示：https://docs.requarks.io/demo&lt;/p&gt;&lt;p&gt;地址：https://github.com/Requarks/wiki&lt;/p&gt;&lt;p&gt;官网：https://js.wiki/&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7、explainshell（有趣）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Star 数&lt;/strong&gt;：9.4k｜&lt;strong&gt;语言&lt;/strong&gt;：Python&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个用于解析 Linux 命令的网站。输入命令就能解析出对应的命令说明和参数解释，属于比较新颖的 Web 项目。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4861111111111111&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNNyfVBIy0fRfvogFxBsrE4Or5TRbiavDRibzvJJtN01vKn2w45clV58sbePcFG61liaibd1iar9hsBAN3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;演示：https://www.explainshell.com/&lt;/p&gt;&lt;p&gt;地址：https://github.com/idank/explainshell&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8、DungeonRush（贪吃蛇）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Star 数&lt;/strong&gt;：1.3k｜&lt;strong&gt;语言&lt;/strong&gt;：C&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不一样的单机贪吃蛇游戏。作者受到元气骑士的启发，在原版的贪吃蛇玩法上进行一些创新。该项目适用于 C 语言初学者，尝试使用跨平台图形库开发软件的同学。参考本项目可以写出一个可玩性高的游戏，收获满满的成就感&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6200185356811863&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xBgIbW1vdNNyfVBIy0fRfvogFxBsrE4OmZp6ksjJoHYW8gqV5srGaYFWxaeEAsVRicBZGVCP7IxKkP1HOCA4ofw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1079&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;地址：https://github.com/Rapiz1/DungeonRush&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9、chinessChess（象棋）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Star 数&lt;/strong&gt;：1.3k｜&lt;strong&gt;语言&lt;/strong&gt;：C++&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于 Qt5 开发的中国象棋网络对战平台。实现了联机、单机、AI 等功能，边玩边学吧。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8348017621145375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNNyfVBIy0fRfvogFxBsrE4OUsx3udOkGialeaJOicRpZ715j5JZSKbDIWMaGHbrXMCfulDDwn6mRTYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;908&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;地址：https://github.com/xmuli/chinessChess&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10、eul（工具）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Star 数&lt;/strong&gt;：5.8k｜&lt;strong&gt;语言&lt;/strong&gt;：Swift&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一款极简免费的 macOS 状态监控工具。使用 SwiftUI 编写，先体验它的好，再剖析它的妙。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;安装：brew install --cask eul&lt;br/&gt;或 App Store 搜 eul&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8166666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xBgIbW1vdNNyfVBIy0fRfvogFxBsrE4OibdWMkJAFBWeweJz7JzfovxhaZlZorzqP3Ey2cKNWvvelwApMOkZiaiaA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;地址：https://github.com/gao-sun/eul&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是本期推荐的 10 个适合实战的开源项目，更多有趣、入门级的开源项目尽在 &lt;strong&gt;HelloGitHub&lt;/strong&gt; 在这里找到让你感兴趣的开源项目吧。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>39ea2fbed89b02ca230f61259d02d8cb</guid>
<title>系统设计之路：如何设计搜索提示（一）</title>
<link>https://toutiao.io/k/viodnlo</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;今天&lt;/span&gt;&lt;span&gt;来说说搜索&lt;/span&gt;&lt;span&gt;提示的设计&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;搜索提示 &lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Search Suggestion)&lt;/span&gt;&lt;span&gt;，又叫自动补全 &lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Auto-complete&lt;/span&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span&gt;。现如今&lt;/span&gt;&lt;span&gt;，但凡数据量&lt;/span&gt;&lt;span&gt;大一点的网站或应&lt;/span&gt;&lt;span&gt;用，就&lt;/span&gt;&lt;span&gt;会有搜索，&lt;/span&gt;&lt;span&gt;有搜索的&lt;/span&gt;&lt;span&gt;江湖，搜索提示就会如影随&lt;/span&gt;&lt;span&gt;行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;262&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.453781512605042&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/la8s6uvJibdRt3ZHwyaHZwEP166Hwk3W3ZcQ5fDNcMmntLhtlQ7d1GRY19BHBmkEJ5QoMl79C8B977ZAlT8sfuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;833&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上图，就是在我在 &lt;/span&gt;&lt;span&gt;Google&lt;/span&gt;&lt;span&gt; 输入 “&lt;/span&gt;&lt;span&gt;ultraman&lt;/span&gt;&lt;span&gt;” 的时候，出现的 &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt; 个搜索提示。本来我是想输入“&lt;/span&gt;&lt;span&gt;ultraman names&lt;/span&gt;&lt;span&gt;”，来了解一下 &lt;/span&gt;&lt;span&gt;ultraman&lt;/span&gt;&lt;span&gt; 系列都有哪些人物。不过没等我输完，系统好像知道了我想搜索什么，就返回了 “&lt;/span&gt;&lt;span&gt;ultraman”&lt;/span&gt;&lt;span&gt; 开头的 &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt; 个提示词。从返回的 &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt; 个搜索提示中，我不必再输入后面的内容，就能大致知道有哪些 &lt;/span&gt;&lt;span&gt;ultraman&lt;/span&gt;&lt;span&gt; 人物了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;借助搜索提示，一方面，可以让用户少输入一些关键词，加快搜索过程；另一方面，在一些连用户自己都不知道下一个关键词该输入什么的场合，搜索提示可以预测用户的输入，仿佛是隔着屏幕在对你说：&quot;嘿，朋友，你要查询的是不是以下这些关键词？&quot;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，一个既快又好的搜索提示服务，能大大提升用户的搜索体验。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么，如何设计一个搜索提示服务呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们先来讨论怎么设计英文语境下的搜索提示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.  系统需求&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;功能性需求：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;满足前缀匹配：即如果用户输入“&lt;/span&gt;&lt;span&gt;ultra&lt;/span&gt;&lt;span&gt;”，那么系统返回的所有提示词，都要以 “&lt;/span&gt;&lt;span&gt;ultra&lt;/span&gt;&lt;span&gt;” 作为开头 (忽略大小写)，无需满足中间匹配；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;返回 &lt;/span&gt;&lt;span&gt;Top K&lt;/span&gt;&lt;span&gt; 个提示词，这里 &lt;/span&gt;&lt;span&gt;K = 10&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Top K&lt;/span&gt;&lt;span&gt; 提示词按热度从到小排序；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;热度需要考虑词频和时间因子，需定期更新。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;非功能性需求：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.  概要设计&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;通过需求分析，系统可以拆成两部分：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;关键词提示服务 (&lt;/span&gt;&lt;span&gt;Qu&lt;/span&gt;&lt;span&gt;ery&lt;/span&gt;&lt;span&gt; Suggestion Service)&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;    功能：用户输入关键词，返回 &lt;/span&gt;&lt;span&gt;Top K&lt;/span&gt;&lt;span&gt; 个提示词。&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;数据收集服务 (&lt;/span&gt;&lt;span&gt;Query Gathering Service)&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;    功能：从搜索日志中定期收集关键词 (&lt;/span&gt;&lt;span&gt;query) &lt;/span&gt;&lt;span&gt;信息，更新 &lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt; 的热度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;初步的系统架构图如图 &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt; 所示：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;246&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.4262295081967213&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/la8s6uvJibdRt3ZHwyaHZwEP166Hwk3W3ltAt2v6u5vWEmrGJLKHvnhFEDMcN9pgykh0Nf5wZ1oSm77AE71ONzQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;图 1&lt;/span&gt;&lt;span&gt;：系统的初步架构&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;3&lt;/span&gt;. &lt;strong&gt;Query Suggestion Service &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;详细设计&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;方案 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;1&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：使用&lt;/span&gt;&lt;span&gt;数据库的 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;like&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;假设有如下的&lt;/span&gt;&lt;span&gt;词频表 &lt;span&gt;t_query_rank&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;table interlaced=&quot;enabled&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;ue-table-interlace-color-single&quot;&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;strong&gt;&lt;span&gt;id&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;strong&gt;&lt;span&gt;query&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;strong&gt;&lt;span&gt;rank&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-double&quot;&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;1&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;ultraman&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;100&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-single&quot;&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;2&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;ultraman taro&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;45&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-double&quot;&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;3&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;ultraman orb&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;70&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-single&quot;&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;4&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;ultraman tiga&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;56&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-double&quot;&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;5&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;ultraman geed&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;48&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-single&quot;&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;ultr&lt;/span&gt;&lt;span&gt;am&lt;/span&gt;&lt;span&gt;an zero&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;88&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-double&quot;&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;7&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;ultra football&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;128&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-single&quot;&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;8&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;ultra sound&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;136&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-double&quot;&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;9&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;ultra boost&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;150&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-single&quot;&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;10&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;ultraviolet&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;30&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-double&quot;&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;11&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;ultraedit&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;90&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;表 1&lt;/span&gt;&lt;span&gt;： &lt;span&gt;t_query_rank&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;假设 &lt;span&gt;t_query_rank&lt;/span&gt; 表的主键索引是 &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;，非主键索引是&lt;/span&gt;&lt;span&gt; query&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;当用户在搜索框中输入“&lt;/span&gt;&lt;span&gt;ultra&lt;/span&gt;&lt;span&gt;” 时，数据库会执行如下 &lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;query&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; t_query_rank &lt;span class=&quot;code-snippet__keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;query&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;like&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;ultra%&#x27;&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;rank&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;desc&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;limit&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;返回&lt;span&gt;如&lt;/span&gt;&lt;span&gt;下&lt;/span&gt; &lt;/span&gt;&lt;span&gt;top 10 &lt;/span&gt;&lt;span&gt;结果：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.453183520599251&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/la8s6uvJibdRt3ZHwyaHZwEP166Hwk3W3PqwMXhF3zVcGuyvhaO6oa5tUddDHib8n5ibgRx0ia69ic1HsO7TMBibDHpQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;267&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;我们来分析一下这个过程的时间复杂度。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;先假设：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;N&lt;/span&gt;&lt;span&gt; - 数据库中满足特定前缀的 &lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt; 总数&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt; - 返回排序最靠前的 &lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt; 条记录&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;L&lt;/span&gt;&lt;span&gt; - 前缀的长度&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;查询前缀为 “&lt;span&gt;ultr&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;” 的 &lt;/span&gt;&lt;span&gt;top 10&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt; 的主要流程为：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Step 1&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;span&gt;  在非主键 &lt;/span&gt;&lt;span&gt;B+&lt;/span&gt;&lt;span&gt; 树索引中使用范围查询，定位到&lt;span&gt;第一个以 “&lt;/span&gt;&lt;span&gt;ultra&lt;/span&gt;&lt;span&gt;” 为前缀的 &lt;/span&gt;&lt;/span&gt;&lt;span&gt;query &lt;/span&gt;&lt;span&gt;后，可以依次遍历后续节点，同时做前缀匹配。遍历+匹配 的时间复杂度为：&lt;/span&gt;&lt;em&gt;&lt;span&gt;O(N * L)&lt;/span&gt;&lt;/em&gt;&lt;span&gt;；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Step 2&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;span&gt;  根据 &lt;/span&gt;&lt;span&gt;step 1&lt;/span&gt;&lt;span&gt; 中返回的记录 &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;，在主索引中回表查询 &lt;/span&gt;&lt;span&gt;rank &lt;/span&gt;&lt;span&gt;信息，&lt;span&gt;时间复杂度&lt;/span&gt;：&lt;/span&gt;&lt;em&gt;&lt;span&gt;O(N)&lt;/span&gt;&lt;/em&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Step 3&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;: &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;对结果集按 &lt;/span&gt;&lt;span&gt;rank&lt;/span&gt;&lt;span&gt; 进行排序，&lt;span&gt;时间复杂度&lt;/span&gt;：&lt;/span&gt;&lt;em&gt;&lt;span&gt;O(N * logK)&lt;/span&gt;&lt;/em&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，方案 &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt; 的时间复杂度为：&lt;/span&gt;&lt;em&gt;&lt;span&gt;O(N * L) + O(N) + O(N * logK)&lt;/span&gt;&lt;/em&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;方案 &lt;/span&gt;&lt;span&gt;1 &lt;/span&gt;&lt;span&gt;简单粗暴，在系统起步阶段，数据量和查询 &lt;span&gt;QPS&lt;/span&gt; &lt;/span&gt;&lt;span&gt;都不是很高的时候，这种方案可以先顶一下。但是，数据量和 &lt;/span&gt;&lt;span&gt;QPS&lt;/span&gt;&lt;span&gt; 大起来后，数据库的读性能就会马上成为瓶颈。我们需要继续优化方案。&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;方案 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;2&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：基于 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;树&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Trie &lt;/span&gt;&lt;span&gt;(发音：&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;) 树，又称字典树，是一种前缀树。&lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树的最大优势是：可以利用字符串的公共前缀来减少存储空间，同时它可以在 &lt;/span&gt;&lt;em&gt;&lt;span&gt;O(L)&lt;/span&gt;&lt;/em&gt;&lt;span&gt; 的时间内找到满足特定前缀的&lt;/span&gt; &lt;span&gt;query&lt;/span&gt;&lt;span&gt;（假设前缀长度为 &lt;/span&gt;&lt;em&gt;&lt;span&gt;L&lt;/span&gt;&lt;/em&gt;&lt;span&gt;）。因为有公共前缀的 &lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt; 可以共享父节点，所以当相同前缀的 &lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt; 越多时，能压缩的存储空间就越多。&lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树&lt;span&gt;很适合用来做分词和搜索提示。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;假设我们要对下表 &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt; 中的 &lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt; 建 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;table interlaced=&quot;enabled&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;ue-table-interlace-color-single&quot;&gt;&lt;td valign=&quot;top&quot;&gt;&lt;strong&gt;&lt;span&gt;query&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;strong&gt;&lt;span&gt;rank&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-double&quot;&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;bad&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;12&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-single&quot;&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;bag&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;26&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-double&quot;&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;ban&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;15&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-single&quot;&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;&lt;span&gt;banana&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;35&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-double&quot;&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;&lt;span&gt;ban&lt;/span&gt;&lt;span&gt;ne&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;25&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-single&quot;&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;big&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;18&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-double&quot;&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;bit&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;28&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-single&quot;&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;&lt;span&gt;bite&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;&lt;span&gt;11&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;section&gt;&lt;span&gt;表 2&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;建好的&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;树如下图&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;521&quot; data-backw=&quot;475&quot; data-ratio=&quot;1.0968421052631578&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/la8s6uvJibdTIicn1KUsf9NKOI1Mju3GRiamxZ3L60nlqPwriblhSZPJhciaG3sasE26ibgS30BfbYaibFtzO2GdkibJ3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;475&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 2&lt;/span&gt;&lt;span&gt;：一棵原始的 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上图中，&lt;span&gt;有权重值的节点，叫终止节点，&lt;/span&gt;从 &lt;/span&gt;&lt;span&gt;&lt;span&gt;root&lt;/span&gt;&lt;/span&gt;&lt;span&gt; 到&lt;span&gt;终止节点&lt;/span&gt;，就可以组成一个完整的 &lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们再来看一下基于 &lt;/span&gt;&lt;span&gt;Trie &lt;/span&gt;&lt;span&gt;树，查找含公共前缀&lt;/span&gt;&lt;span&gt;的所有 &lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt; 的过程。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Step 1:&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt; 从根节点开始往下，找到匹配的前缀，时间复杂度：&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;O(L)&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Step 2:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;  在 &lt;/span&gt;&lt;span&gt;step 1 &lt;/span&gt;&lt;span&gt;匹配的前缀节点下，遍历所有的 &lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;，时间复杂度：&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;O(N)&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Step 3:&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt; 对遍历得到的 &lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt; 进行排序，&lt;span&gt;时间复杂度&lt;/span&gt;：&lt;/span&gt;&lt;span&gt;&lt;span/&gt;&lt;em&gt;&lt;span&gt;O(N * logK)&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;下图 &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt; 展示了在 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树中查找前缀为 ”&lt;/span&gt;&lt;span&gt;ba&lt;/span&gt;&lt;span&gt;“ 的 &lt;/span&gt;&lt;span&gt;query &lt;/span&gt;&lt;span&gt;的过程。&lt;/span&gt;&lt;span&gt;3 &lt;/span&gt;&lt;span&gt;种不同颜色分别代表了 &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt; 个过程。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;727&quot; data-backw=&quot;562&quot; data-ratio=&quot;1.293594306049822&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/la8s6uvJibdTIicn1KUsf9NKOI1Mju3GRiafjBRSsdG6G80gh1OSgLRNjicQNnHEuBAlaJibdibGtFBL9g5R6l2XYrbw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;562&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 3&lt;/span&gt;&lt;span&gt;：在 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树中查询前缀为&lt;/span&gt;&lt;span&gt;&quot;&lt;span&gt;ba&quot;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;的 &lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;方案 &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt; 的时间复杂度为：&lt;/span&gt;&lt;em&gt;&lt;span&gt;O&lt;/span&gt;&lt;/em&gt;&lt;em&gt;&lt;span&gt;(L) + O(N) + O(N * logK)&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;针对上述的表达式，为什么&lt;span&gt;前缀匹配后，&lt;/span&gt;还需要用 &lt;/span&gt;&lt;em&gt;&lt;span&gt;O(N) &lt;/span&gt;&lt;/em&gt;&lt;span&gt;的时间去遍历该前缀下的&lt;span&gt;所有&lt;/span&gt; &lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;？这不是可以在 &lt;/span&gt;&lt;em&gt;&lt;span&gt;O(1)&lt;/span&gt;&lt;/em&gt;&lt;span&gt; 时间内搞定吗？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这是因为，在原始的 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 结构下，虽然找到了匹配的前缀，但我们仍然无法直接知道该前缀节点下有哪些 &lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;，只有遍历完它所有的子孙节点才知道。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;那么，怎么&lt;/span&gt;&lt;span&gt;继续优化呢？&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;方案 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;3&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：改造 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 树&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;改造点 &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;如果&lt;/span&gt;&lt;span&gt;一&lt;/span&gt;&lt;span&gt;个&lt;/span&gt;&lt;span&gt;父节点&lt;/span&gt;&lt;span&gt;只&lt;/span&gt;&lt;span&gt;有一个子节点，且父节点不是终止节点，&lt;/span&gt;&lt;span&gt;那么可以&lt;/span&gt;&lt;span&gt;把&lt;/span&gt;&lt;span&gt;父节点和子&lt;/span&gt;&lt;span&gt;节&lt;/span&gt;&lt;span&gt;点合&lt;/span&gt;&lt;span&gt;在一起&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;减&lt;/span&gt;&lt;span&gt;少&lt;/span&gt;&lt;span&gt;节点的数量。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;图 &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt; 中的 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树，经过子节点的合并后，就变成如图 &lt;/span&gt;&lt;span&gt;4 &lt;/span&gt;&lt;span&gt;的 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;381&quot; data-backw=&quot;475&quot; data-ratio=&quot;0.8021052631578948&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/la8s6uvJibdTIicn1KUsf9NKOI1Mju3GRiaqnYnazStvSe6K0eVBGdp6PRkf4iauOXYM0oldVhfrWgeM5or2o07ErQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;475&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 4&lt;/span&gt;&lt;span&gt;：部分子节点合并后的 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;改造点&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt; 2&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：提前计算好子节点信息，并把结果存在 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了不用每次都在 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树中遍历公共前缀的所有子节点，然后再排序，我们可以在 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树结构中新增一个容量大小为 &lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt; 的优先队列，称为 &lt;/span&gt;&lt;span&gt;hotList&lt;/span&gt;&lt;span&gt;。&lt;span&gt;hot&lt;/span&gt;&lt;span&gt;List &lt;/span&gt;&lt;/span&gt;&lt;span&gt;中存放含有相同前缀的前 &lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt; 个 &lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;。改造后的 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树，如图 &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt; 所示（注：图中只展示了部分节点的&lt;span&gt;ho&lt;/span&gt;&lt;span&gt;t&lt;/span&gt;&lt;span&gt;List&lt;/span&gt;&lt;/span&gt;&lt;span&gt;，而实际上每个&lt;/span&gt;&lt;span&gt;&lt;span&gt; Trie &lt;/span&gt;&lt;/span&gt;&lt;span&gt;树节点都有&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;span&gt;ho&lt;/span&gt;&lt;span&gt;t&lt;/span&gt;&lt;span&gt;List&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;271&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.4681372549019608&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/la8s6uvJibdTIicn1KUsf9NKOI1Mju3GRiaXx24WRN1ibULjIibcQwpjNmRECWgHZ8oeelI1a4BIOSKo83wXv1gZ2ww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;816&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 5&lt;/span&gt;&lt;span&gt;：加了 &lt;/span&gt;&lt;span&gt;hotList&lt;/span&gt;&lt;span&gt; 后的 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;需要注意的是，在构建 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树的时候，每当新增或更新一个节点，由于子节点排序值的变化，可能会引起父节点 &lt;/span&gt;&lt;span&gt;hotList&lt;/span&gt;&lt;span&gt; 的改变，所以需要从下往上逐层更新父节点，直至根节点。&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;比如，&quot;&lt;/span&gt;&lt;span&gt;bad&lt;/span&gt;&lt;span&gt;&quot; 的权重从 &lt;/span&gt;&lt;span&gt;12&lt;/span&gt;&lt;span&gt; 更新到了 &lt;/span&gt;&lt;span&gt;19&lt;/span&gt;&lt;span&gt;，在子节点更新完权重后，需逐层往上更新父节点的 &lt;/span&gt;&lt;span&gt;hotList&lt;/span&gt;&lt;span&gt;。更新过程如图 &lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt; 所示。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;251&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.4349315068493151&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/la8s6uvJibdTIicn1KUsf9NKOI1Mju3GRiaCrqkJZ272V3ksU6iaA349nTmZe47RvcXZxzLEzhOTLiaItKKhV05U2Iw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;876&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;图 6&lt;/span&gt;&lt;span&gt;：更新了&quot;&lt;/span&gt;&lt;span&gt;bad&lt;/span&gt;&lt;span&gt;&quot;的排序值后&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;自下而上更新父节点的 &lt;span&gt;hotList&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对比方案 &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;，方案&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt; 在建 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树的时候，因为在每个节点多了一个 &lt;/span&gt;&lt;span&gt;hotList&lt;/span&gt;&lt;span&gt;&lt;span&gt;，需在用户正式查询&lt;span&gt;前计算并存储 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;Top K&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; 个前缀词，因此&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;多&lt;/span&gt;&lt;span&gt;了一些空间和时间上的开销。但 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树建好后，由于没有了子节点的遍历和排序，查询效率才得以大大提升。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;通过以上分析，基于方案 &lt;/span&gt;&lt;span&gt;&lt;span&gt;3&lt;/span&gt;&lt;/span&gt;&lt;span&gt;，查询&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;特定前缀的前 &lt;span&gt;K&lt;/span&gt;&lt;span&gt;&lt;span&gt; 个&lt;/span&gt;&lt;/span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;query&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; 的&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;时间复杂度为：&lt;/span&gt;&lt;em&gt;&lt;span&gt;O(L) + O(K)&lt;span/&gt;&lt;/span&gt;&lt;/em&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;因为 &lt;/span&gt;&lt;span&gt;&lt;span&gt;K&lt;/span&gt;&lt;/span&gt;&lt;span&gt; 是固定的（即最多返回提示词的个数，本文中为 &lt;/span&gt;&lt;span&gt;&lt;span&gt;10&lt;/span&gt;&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;span&gt;，所以，&lt;em&gt;&lt;span&gt;O(K) &lt;/span&gt;&lt;/em&gt;这项可以作为常数时间 &lt;em&gt;&lt;span&gt;O(1)&lt;/span&gt;&lt;/em&gt;&lt;em&gt;&lt;span&gt; &lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;处理&lt;/span&gt;&lt;span&gt;。所以，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;方案 &lt;/span&gt;&lt;span&gt;&lt;span&gt;3&lt;/span&gt;&lt;/span&gt;&lt;span&gt; 的查询时间复杂度为：&lt;em&gt;&lt;span&gt;O(L)&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;&lt;span/&gt;&lt;/em&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;span&gt;因为前缀长度 &lt;/span&gt;&lt;span&gt;L&lt;/span&gt;&lt;span&gt; 是不固定的，所以 &lt;em&gt;&lt;span&gt;O(L) &lt;/span&gt;&lt;/em&gt;不是常数时间，而是一个变量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;那么，怎么&lt;/span&gt;&lt;span&gt;继续优化呢？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;方案 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;4&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：固定 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;L&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们在使用搜索的时候，应该有这样的体会：刚开始输入少数几个词时，下拉框中会有很多提示词可选择。但是当输入的词超过一定个数，比如 &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt; 个的时候，基本没有什么提示词了。就像现实中的招聘一样，条件少一些，可选的范围就大一些，条件越多，满足要求的人就越少。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从用户的角度来看，搜索提示的目的，是让用户尽量减少输入。如果用户输入的查询词&lt;/span&gt;&lt;span&gt;越来越长，一方面，说明系统给的提示不是他想要的；另一方面，也说明用户有了明确的搜索意图。在这种场景下，其实给不给提示已经不重要了。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于此，我们可以合理地限制 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树中前缀字符串的最大长度。假设最大前缀长度为 &lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;，那么，当用户输入的关键词长度超过 &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt; 的时候，后面再输入的词就会被系统自动截断。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样处理的好处是：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;节省内存空间&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;提高前缀匹配的效率：固定了最大的前缀长度 &lt;/span&gt;&lt;span&gt;L&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;L&lt;/span&gt;&lt;span&gt; 就变成一个常数。这样，前缀匹配的时间复杂度就从线性的 &lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;O(L) &lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;降到常数的：&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;O(1)&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;所以，经过方案 &lt;/span&gt;&lt;span&gt;4 &lt;/span&gt;&lt;span&gt;的进一步优化，&lt;span&gt;查询&lt;/span&gt;&lt;span&gt;特定前缀的前 &lt;span&gt;K&lt;/span&gt; 个 &lt;/span&gt;&lt;span&gt;&lt;span&gt;query&lt;/span&gt;&lt;/span&gt;&lt;span&gt; 的&lt;/span&gt;&lt;span&gt;时间复杂度为&lt;/span&gt;：&lt;/span&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;O(1)&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;strong&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;Nice&lt;/span&gt;&lt;/span&gt;&lt;span&gt;！&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;那么，还可以继续优化吗？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;方案 &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;：上缓存&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在方案 &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt; 中，我们限制了最大的前缀长度 &lt;/span&gt;&lt;span&gt;L&lt;/span&gt;&lt;span&gt;，理论上已经可以在常数时间复杂度内搜索&lt;/span&gt;&lt;span&gt; Trie &lt;/span&gt;&lt;span&gt;树，并返回搜索提示。但是，即使是常数时间，也可以减小常数系数，来进一步提升系统性能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如，如果查询要前缀是 “&lt;/span&gt;&lt;span&gt;ba&lt;/span&gt;&lt;span&gt;” 的 &lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;，需先从根节点开始，沿着 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树向下访问两个节点，然后再返回&lt;span&gt;前缀是&lt;/span&gt; “&lt;/span&gt;&lt;span&gt;ba&lt;/span&gt;&lt;span&gt;” 的 &lt;/span&gt;&lt;span&gt;Top K&lt;/span&gt;&lt;span&gt; 个提示词。如果我们把 “&lt;/span&gt;&lt;span&gt;ba&lt;/span&gt;&lt;span&gt;” 作为&lt;/span&gt;&lt;span&gt; key&lt;/span&gt;&lt;span&gt;，把&lt;span&gt;前缀是&lt;/span&gt; “&lt;/span&gt;&lt;span&gt;ba&lt;/span&gt;&lt;span&gt;” 的 &lt;span&gt;Top K&lt;/span&gt;&lt;span&gt; 个搜索提示作为&lt;/span&gt; &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;，放在一个&lt;/span&gt;&lt;span&gt; K-V &lt;/span&gt;&lt;span&gt;结构中，比如 &lt;span&gt;R&lt;/span&gt;&lt;span&gt;edis&lt;/span&gt;&lt;span&gt; 中&lt;/span&gt;，当用户&lt;span&gt;下&lt;/span&gt;&lt;span&gt;次&lt;/span&gt;再输入“&lt;/span&gt;&lt;span&gt;ba&lt;/span&gt;&lt;span&gt;” 时，就会先到 &lt;/span&gt;&lt;span&gt;Redis&lt;/span&gt;&lt;span&gt; 中去查询。如果有“&lt;/span&gt;&lt;span&gt;ba&lt;/span&gt;&lt;span&gt;” 这个 &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;，就直接返回&lt;span&gt;&lt;span&gt;对应的 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;，而不必在 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树中从 &lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt; 开始再次访问两个节点。&lt;span&gt;如果缓存没有命中，就到 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树中查询，并把查询结果写到缓存中。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了进一步提升缓存命中率，我们可以把 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树节点中的各个前缀对应的&lt;/span&gt; &lt;span&gt;hotList &lt;/span&gt;&lt;span&gt;提前放到缓存中。如下图 &lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt; 所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;291&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5028506271379704&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/la8s6uvJibdTIicn1KUsf9NKOI1Mju3GRianmm4xn8hQPGCsZUqGNicWRbJE3ELcDia1y1Fh1BHMgPiagtiaQ19VzvqOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;877&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;图 7&lt;/span&gt;&lt;span&gt;：将前缀及 &lt;/span&gt;&lt;span&gt;&lt;span&gt;hotList &lt;/span&gt;&lt;/span&gt;&lt;span&gt;映射到&lt;/span&gt;&lt;span&gt;&lt;span&gt; K-V &lt;/span&gt;&lt;/span&gt;&lt;span&gt;结构中&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们可以根据 &lt;/span&gt;&lt;span&gt;Re&lt;/span&gt;&lt;span&gt;dis&lt;/span&gt;&lt;span&gt; 服务器内存的大小，选择把全部前缀或部分热门的前缀，提前放到 &lt;/span&gt;&lt;span&gt;Redis&lt;/span&gt;&lt;span&gt; 中，来做缓存的预热，让热门的查询能命中缓存，给用户快速返回结果。&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Redis &lt;/span&gt;&lt;span&gt;中&lt;/span&gt;&lt;span&gt; key&lt;/span&gt;&lt;span&gt; 的过期时间和 &lt;/span&gt;&lt;span&gt;query &lt;/span&gt;&lt;span&gt;权重的更新周期保持一致。&lt;span&gt;Reids&lt;/span&gt;&lt;span&gt; 的缓存淘汰策略，可以采用 &lt;/span&gt;&lt;span&gt;LRU&lt;/span&gt;&lt;span&gt;，让最近被访问的&lt;/span&gt;&lt;span&gt; key&lt;/span&gt;&lt;span&gt;，可以在缓存中存活得长一点，提升缓存命中率。&lt;/span&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 树的更新机制&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们先来看一下单个 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树节点的更新。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;和插入一个新的 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树节点一样，更新和删除一个 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树节点，都要从结束节点开始，自下而上地更新父节点中的 &lt;/span&gt;&lt;span&gt;hotList&lt;/span&gt;&lt;span&gt;，直至根节点，更新的过程如图 &lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于每次更新一个 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树节点，都需要依次更新多个父节点，所以 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树的更新是一个很耗时的操作。如果选择多线程实时更新 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树，还需要考虑加入读写锁或 &lt;/span&gt;&lt;span&gt;Copy on Write&lt;/span&gt;&lt;span&gt; 机制，来处理高并发下对共享数据的读写冲突。如果更新太频繁，正常的查询服务&lt;span&gt;就会大受影响&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而事实上，在&lt;span&gt;大多情况下，我们并不需要实时地对 &lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树进行更新&lt;/span&gt;。因为，&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;Top K&lt;/span&gt;&lt;/span&gt;&lt;span&gt; 个 &lt;/span&gt;&lt;span&gt;query &lt;/span&gt;&lt;span&gt;的排序，在一段时间内通常不会有明显的变化。也就是说，&lt;/span&gt;&lt;span&gt;1 &lt;/span&gt;&lt;span&gt;个小时前搜 “&lt;/span&gt;&lt;span&gt;ba&lt;/span&gt;&lt;span&gt;”，返回的前&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt; 个提示词，&lt;/span&gt;&lt;span&gt;1 &lt;/span&gt;&lt;span&gt;个小时后再次搜 &lt;span&gt;“&lt;/span&gt;&lt;span&gt;ba&lt;/span&gt;&lt;span&gt;”，返回的提示词及其排序，与 &lt;/span&gt;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&lt;span&gt; 小时前&lt;/span&gt;基本上是一致的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，我们可以用定期批量更新的方式，来对 &lt;/span&gt;&lt;span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;/span&gt;&lt;span&gt; 树进行更新。而批量更新通常采用的是离线操作，这样就不会影响到线上的 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树查询服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么，怎么做 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树的批量更新呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主要有以下两种策略：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;策略 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;1&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 在单台服务器上使用 &lt;/span&gt;&lt;span&gt;Double Buffer&lt;/span&gt;&lt;span&gt;（双缓冲）机制。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们可以在内存中同时保存两个一样的 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树，假设一个是 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树&lt;/span&gt;&lt;span&gt; A&lt;/span&gt;&lt;span&gt;，一个是 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树 &lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;。我们会使用一个指针 &lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt; 指向 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树 &lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;，由 &lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt; 来提供当前的读服务。这个时候，如果要更新 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树节点，只需更新 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树 &lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;。等 &lt;/span&gt;&lt;span&gt;B &lt;/span&gt;&lt;span&gt;更新完后，就把指针 &lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt; 指向 &lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;，由 &lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt; 来提供读服务，而 &lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt; 则去执行更新操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于 &lt;/span&gt;&lt;span&gt;&lt;span&gt;Double Buffer &lt;/span&gt;的 &lt;/span&gt;&lt;span&gt;Trie &lt;/span&gt;&lt;span&gt;树更新过程如下图 &lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt; 所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;841&quot; data-backw=&quot;578&quot; data-ratio=&quot;1.4554183813443073&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/la8s6uvJibdTIicn1KUsf9NKOI1Mju3GRiaqTbxb49PuibzFyxbZCeXgp470oqqoicE8RoBttcAkFCuA8ldTjtXibGpQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;729&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;图 8&lt;/span&gt;&lt;span&gt;：基于 &lt;/span&gt;&lt;/span&gt;&lt;span&gt;Double Buffer &lt;/span&gt;&lt;span&gt;的 &lt;/span&gt;&lt;span&gt;Trie &lt;/span&gt;&lt;span&gt;树更新过程&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;整个过程中，读和写是分离的，这样 &lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt; 之间就不存在对共享资源的读写冲突，是一种无锁的实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然，我们前面也说了，在多数场合下没有必要对 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树进行实时更新，所以不必来一个请求，就更新一下 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树，导致&lt;span&gt;指针 &lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;/span&gt;&lt;span&gt;在 &lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt; 之间频繁切换。我们可以把请求先 &lt;/span&gt;&lt;span&gt;delay &lt;/span&gt;&lt;span&gt;一段时间或积累一定数量，再做批量更新。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用 &lt;/span&gt;&lt;span&gt;Double Buffer&lt;/span&gt;&lt;span&gt; 机制更新索引是一个高效的方案，但缺点也很明显：耗内存！因为要在同一台服务上维护两棵 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树，导致了内存的双倍开销。所以，该策略较适用在数据量比较小的场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;策略 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;2&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 使用主备配置（&lt;/span&gt;&lt;span&gt;Master-Backup&lt;/span&gt;&lt;span/&gt;&lt;span&gt;）策略。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们可以给每一棵 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树配置一主一备两台服务器。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;正常情况下，这两台服务器都可以对外提供数据查询服务。而当开始批量更新 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树节点时，需修改 &lt;/span&gt;&lt;span&gt;API &lt;/span&gt;&lt;span&gt;网关（比如 &lt;/span&gt;&lt;span&gt;nginx&lt;/span&gt;&lt;span&gt;）配置，只由 &lt;span&gt;Master &lt;/span&gt;服务器对外提供读服务，而 &lt;span&gt;Backup &lt;/span&gt;服务器则停止提供读服务，去进行 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树的更新操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Backup &lt;/span&gt;服务器上的 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树更新又有两种方式：全量更新 和 增量更新。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;全量更新，就是&lt;span&gt;每&lt;/span&gt;&lt;span&gt;次都读取&lt;/span&gt;最新的全量的 &lt;/span&gt;&lt;span&gt;q&lt;/span&gt;&lt;span&gt;uery&lt;/span&gt;&lt;span&gt; 数据，从头开始重建 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树。而增量更新，则不需要每次读取全量数据&lt;/span&gt;&lt;span&gt;，而是在原 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树基础上，对新增的 &lt;/span&gt;&lt;span&gt;query &lt;/span&gt;&lt;span&gt;做&lt;span&gt;批量&lt;/span&gt;更新&lt;/span&gt;&lt;span&gt;。全量更新的周期会长一些，一般以天或周计，而增量更新的周期则短一些，一般以小时计。全量更新 &lt;/span&gt;&lt;span&gt;focus&lt;/span&gt;&lt;span&gt; 数据的一致性，而增量更新则是一致性和实时性之间的一种权衡。实际的线上应用，会采用全量更新 + 增量更新 的方式来更新&lt;/span&gt;&lt;span&gt; Trie&lt;/span&gt;&lt;span&gt; 树。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Backup &lt;/span&gt;&lt;span&gt;服务器更新完&lt;/span&gt; &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树后，我们要对更新后 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树做一些必要的验证，看看新老数据是否正确。校验通过&lt;/span&gt;&lt;span&gt;后，就可以修改 &lt;span&gt;API &lt;/span&gt;&lt;span&gt;网关&lt;/span&gt;配置，重新开放 &lt;span&gt;Backup &lt;/span&gt;&lt;/span&gt;&lt;span&gt;服务器的&lt;/span&gt;&lt;span&gt;读服务。同时，关闭 &lt;span&gt;Master &lt;/span&gt;服务器的读服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来，在 &lt;span&gt;Master &lt;/span&gt;&lt;span&gt;服务器上对同样的数据进行&lt;/span&gt; &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树的&lt;span&gt;更&lt;/span&gt;&lt;span&gt;新&lt;/span&gt;。&lt;/span&gt;&lt;span&gt;更新完 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树，通过&lt;/span&gt;&lt;span&gt;校验&lt;/span&gt;&lt;span&gt;，修改 &lt;span&gt;API &lt;/span&gt;网关配置，&lt;span&gt;Mas&lt;/span&gt;&lt;span&gt;t&lt;/span&gt;&lt;span&gt;er &lt;/span&gt;&lt;/span&gt;&lt;span&gt;服务器又可以重新对外提供&lt;/span&gt;&lt;span&gt;读服务。过程如图 &lt;/span&gt;&lt;span&gt;9 &lt;/span&gt;&lt;span&gt;所示。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;729&quot; data-backw=&quot;578&quot; data-ratio=&quot;1.2603911980440097&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/la8s6uvJibdSibqpmTUiaV8Wwd2A78K5gs5ODNKaGBfrkYI3JrW7yziboAV9ljD0iaP6B7ia5cydBEia9s0dIiaKiahFH4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;818&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;&lt;span&gt;图 9&lt;/span&gt;&lt;span&gt;：基于 &lt;/span&gt;&lt;/span&gt;&lt;span&gt;Master-Backup &lt;/span&gt;&lt;span&gt;的 &lt;/span&gt;&lt;span&gt;Trie &lt;/span&gt;&lt;span&gt;树更新过程&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 树的持久化&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;由于 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树是在内存中的，如果服务器宕机重启，内存中的数据就会丢失，就需要重建 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;我们对重建的 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树有两个要求：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;1.&lt;/span&gt;&lt;span&gt; 重建过程要快；&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;2.&lt;/span&gt;&lt;span&gt; 数据要新，最好和宕机前的 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树一样。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;基于上述要求，我们可以采用业界常用的 “快照” 技术，比如 &lt;/span&gt;&lt;span&gt;Redis&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;RDB&lt;/span&gt;&lt;span&gt;快照。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用快照，可以记录某个时刻 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt;&lt;span&gt; 树各节点的状态，&lt;span&gt;并将其持久化到&lt;span&gt;存储设备中&lt;/span&gt;。&lt;span&gt;存储设备可以是文件，也可以是 &lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt; 或 &lt;/span&gt;&lt;span&gt;NoSQL&lt;/span&gt;&lt;span&gt; 数据库。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;这样，当服务器&lt;span&gt;宕机重启时&lt;/span&gt;，就可以读取最新的快照，快速地恢复出最近时刻的 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树。&lt;/span&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;问题 &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;1&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt; 什么时候对 &lt;/span&gt;&lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt;&lt;span&gt; 树进行快照？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;快&lt;/span&gt;&lt;span&gt;照的&lt;/span&gt;主要时机有：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;问题 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;2&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;怎么给 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树拍快照，也即：怎么序列化 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们先定义一下 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树节点的数据结构：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;php&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Trie&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; String prefix;          &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; float rank;             &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; Queue&amp;lt;Trie&amp;gt; topKList;   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;List&lt;/span&gt;&amp;lt;Trie&amp;gt; childNodes;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;然后，需要再定义一种序列化协议，将 &lt;span&gt;T&lt;/span&gt;&lt;span&gt;rie &lt;/span&gt;&lt;/span&gt;&lt;span&gt;树&lt;/span&gt;&lt;span&gt;对象根据&lt;span&gt;序&lt;/span&gt;&lt;span&gt;列&lt;/span&gt;&lt;span&gt;化&lt;/span&gt;&lt;/span&gt;&lt;span&gt;协议进行转化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文中，我们按&lt;span&gt;：&quot;&lt;/span&gt;&lt;span&gt;前缀字符_子节点个数_排序值，&lt;span&gt;前缀字符&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;子节点个数_&lt;/span&gt;&lt;span&gt;排序值，...&quot; 这种格式对 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; 树进行序列化。并&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;用文件来存储序列化的结果&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;按照上述格式，再来看看&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;下图所示 &lt;/span&gt;&lt;/span&gt;&lt;span&gt;Trie &lt;/span&gt;&lt;span&gt;&lt;span&gt;树的序列化结果。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;464&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.8021052631578948&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/la8s6uvJibdTIicn1KUsf9NKOI1Mju3GRiaqnYnazStvSe6K0eVBGdp6PRkf4iauOXYM0oldVhfrWgeM5or2o07ErQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;475&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;我们按照深度遍历（&lt;/span&gt;&lt;span&gt;DFS&lt;/span&gt;&lt;span&gt;）的方式来访问 &lt;/span&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;rie&lt;/span&gt;&lt;span&gt; 树中的节点。&lt;/span&gt;&lt;span&gt;遍历完成后，文件中的内容如下：&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;_2_0, &lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;_3_0, &lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;_0_12, &lt;/span&gt;&lt;span&gt;g&lt;/span&gt;&lt;span&gt;_0_26, &lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;_2_15, &lt;/span&gt;&lt;span&gt;ana&lt;/span&gt;&lt;span&gt;_0_35, &lt;/span&gt;&lt;span&gt;ner&lt;/span&gt;&lt;span&gt;_0_25, &lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;_2_0, &lt;/span&gt;&lt;span&gt;g&lt;/span&gt;&lt;span&gt;_0_18, &lt;/span&gt;&lt;span&gt;t&lt;/span&gt;&lt;span&gt;_1_28, &lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;_0_11&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;其中，&quot;&lt;span&gt;_&lt;/span&gt;&quot; 是分割符号，也可以用 &lt;/span&gt;&lt;span&gt;ASCII&lt;/span&gt;&lt;span&gt; 码表中其它可见或不可见字符做分割符。需要注意的是，须先过滤 &lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt; 中的分割符，以免对后续的序列化造成影响。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里，可能有人会想，为什么不把 &lt;span&gt;to&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;List &lt;/span&gt;&lt;/span&gt;&lt;span&gt;也写到文件中呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;事实上，&lt;span&gt;to&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;List &lt;/span&gt;&lt;/span&gt;&lt;span&gt;写到文件中不但浪费存储空间，而且最重要的是：没用。&lt;/span&gt;&lt;span&gt;这是因为，&lt;/span&gt;&lt;span&gt;topKList&lt;/span&gt;&lt;span&gt; 中存的是对子节点的引用，是一个内存地址。而 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树在重建的过程中，是从上而下开始构建的，先有父节点，再有下层的子节点。在构建当前节点的时候，其子节点还没有生成，子节点的内存地址就为 &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;只有当子节点构建完成时，才会把节点的排序值从下到上逐层传给父节点，更新过程如图 &lt;/span&gt;&lt;span&gt;6 &lt;/span&gt;&lt;span&gt;所示。每一层的父节点不断 &lt;/span&gt;&lt;span&gt;Merge&lt;/span&gt;&lt;span&gt; 子节点的&lt;span&gt;排序&lt;/span&gt;值，才能生成最终的 &lt;/span&gt;&lt;span&gt;topKList&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面是序列化和反序列化一棵 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树的核心逻辑：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;/** 序列化 **/&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;writeNode(Trie node)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;write&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;node.prefix to file&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;write&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;numOfChildren to file&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;write&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;node.rank to file&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;child in node.childNodes:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;writeNode(child)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;/** 反序列化 **/&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;Trie&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;readNode()&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;    Trie node &lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt; new Trie()&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;read&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;node.prefix from file&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;read&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;numOfChildren from file&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;read&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;node.rank from file&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;(i = 0; i &amp;lt; numOfChildren; i++)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;Trie&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;child = readNode()&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;node.childNodes.add(child)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;update&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;topKList&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;以上， &lt;/span&gt;&lt;span&gt;Enjoy&lt;/span&gt;&lt;span&gt; ~&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来，我们会在第二部分中，进一步探讨 &lt;/span&gt;&lt;span&gt;Trie&lt;/span&gt;&lt;span&gt; 树的分布式扩容方案、数据收集服务、&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt; 权重值的设计、非英文搜索提示的设计、客户端对搜索提示的优化等问题。欢迎关注。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>55d82eced5f77713c6a8a5edb2cf4e42</guid>
<title>浅析 “扣减库存” 的方案设计</title>
<link>https://toutiao.io/k/mquagyh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-tool=&quot;mdnice编辑器&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;今天我们来探讨下&lt;code&gt;扣减库存&lt;/code&gt;的方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生活中，我们总是用各种电商 APP 抢购商品，但是库存数是很少的，特别是秒杀场景，商品可能就一件，那如何保证不会出现超卖的情况呢？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一、扣减库存的三种方案&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.1 下单减库存&lt;/span&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.3537414965986394&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ0sWes1CVdQ3kK58nWAyb8rx7n3CjfibiaBXwA9DBz9UgiaHV5GeqEicyNq4cykCRVDhybicpnqbTHe8Zg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;588&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户下单时减库存&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优点&lt;/strong&gt;：实时减库存，避免付款时因库存不足减库存的问题&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;缺点&lt;/strong&gt;：恶意买家大量下单，将库存用完，但是不付款，真正想买的人买不到&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.2 付款减库存&lt;/span&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.2956810631229236&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ0sWes1CVdQ3kK58nWAyb8rv3NtbCv9qiaGVgmu7pfPNgTxRcKibqCUHqd6gkU3Zicu2KNrVu2lwMvXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;602&quot;/&gt;&lt;span/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下单页面显示最新的库存，下单时不会立即减库存，而是等到支付时才会减库存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优点&lt;/strong&gt;：防止恶意买家大量下单用光库存，避免下单减库存的缺点&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;缺点&lt;/strong&gt;：下单页面显示的库存数可能不是最新的库存数，而库存数用完后，下单页面的库存数没有刷新，出现下单数超过库存数，若支付的订单数超过库存数，则会出现支付失败。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.3 预扣库存&lt;/span&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.228486646884273&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ0sWes1CVdQ3kK58nWAyb8roKF5y304ukpljzlibSIkJd8CYwRPTrhaxUyyXY6Y2ytfwhTpymU4CDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;674&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下单页面显示最新的库存，下单后保留这个库存一段时间（比如10分钟），超过保留时间后，库存释放。若保留时间过后再支付，如果没有库存，则支付失败。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优点&lt;/strong&gt;：结合下单减库存的优点，实时减库存，且缓解恶意买家大量下单的问题，保留时间内未支付，则释放库存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;缺点&lt;/strong&gt;：保留时间内，恶意买家大量下单将库存用完。并发量很高的时候，依然会出现下单数超过库存数。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;二、如何解决恶意买家下单的问题&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的恶意买家指短时间内大量下单，将库存用完的买家。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.1 限制用户下单数量&lt;/span&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ0sWes1CVdQ3kK58nWAyb8rftooMQDaSUAYYeuMc2pmbN7ibcg1J2bQqibwiaR7oEx7UExbPTksYicADQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;792&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优点&lt;/strong&gt;：限制恶意买家下单&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;缺点&lt;/strong&gt;：用户想要多买几件，被限制了，会降低销售量&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.2 标识恶意买家&lt;/span&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7857142857142857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ0sWes1CVdQ3kK58nWAyb8r7WE2NyNQjR79W3TYricr4Xh4kzSpBR9W1f1KrKN0FBPUKb4odp0yzAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;644&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过标识用户的设备 id 或者会员 id，将用户加入黑名单，不足之处是有些用户是模拟的，识别不出来是不是真正的恶意买家。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;三、如何解决下单成功而支付失败（库存不足）的问题&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1 备用库存&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;商品库存用完后，如果还有用户支付，直接扣减备用库存。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5221843003412969&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ0sWes1CVdQ3kK58nWAyb8r5BGlrNeuOAX7Aa7q715lj1ecUbONFGFJbT16aHb5meMia8ib01Wbdg8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;586&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优点&lt;/strong&gt;：缓解部分用户支付失败的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;缺点&lt;/strong&gt;：备用库存只能缓解问题，不能从根本上解决问题。另外备用库存针对普通商品可以，针对特殊商品这种库存少的，备用库存量也不会很大，还是会出现大量用户下单成功却因库存不足而支付失败的问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;四、如何解决高并发下库存超卖的场景&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;库存超卖最简单的解释就是多成交了订单而发不了货。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;场景&lt;/span&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;用户 A 和 B 成功下单，在支付时扣减库存，当前库存数为 10。因 A 和 B 查询库存时，都还有库存数，所以 A 和 B 都可以付款。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;A 和 B 同时支付，A 和 B 支付完成后，可以看做两个请求&lt;code&gt;回调&lt;/code&gt;后台系统扣减库存，有两个线程处理请求，两个线程查询出来的库存数 &lt;code&gt;inventory = 10&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9330543933054394&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ0sWes1CVdQ3kK58nWAyb8rRkKBh1At41ZhDUdlEoFC0RnFEeL7LP25kD9I2mTbD5ESfXGASiaUGBA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;956&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后 A 线程更新最终库存数 ：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;lastInventory = inventory - 1 = 9，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;B 线程更新库存数： &lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;lastInventory = inventory - 1 = 9。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而实际最终的库存应是 8 才对，这样就出现库存超卖的情况，而发不出货。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那如何解决库存超卖的情况呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下方案都是基于数据库层面的。有些同学可能会问，是不是可以用 Redis 分布式锁来，后面会讲到。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;方案一&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SQL语句直接更新库存，而不是先查询出来，然后赋值&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;UPDATE [库存表] SET 库存数 - 1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;方案二&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SQL语句更新库存时，如果扣减库存后，库存数为负数，直接抛异常，利用事务的原子性进行自动回滚。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;方案三&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;利用SQL语句更新库存，防止库存为负数&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;UPDATE [库存表] SET 库存数 - 1 WHERE 库存数 - 1 &amp;gt; 0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果影响条数大于1，则表示扣减库存成功，否则不更新库存，并退款。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;五、秒杀场景下如何扣减库存&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.1 采用下单减库存&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因秒杀场景下，大部分用户都是想直接购买商品的，可以直接用下单减库存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大量用户和恶意用户都是同时进行的，区别是正常用户会直接购买商品，恶意用户虽然在竞争抢购的名额，但是获取到的资格和普通用户一样，所以下单减库存在秒杀场景下，恶意用户下单并不能造成之前说的缺点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且下单直接扣减库存，这个方案更简单，在第一步就扣减库存了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.2  Redis 缓存&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查询缓存要比查询数据库快，所以将库存数放在缓存中，直接在缓存中扣减库存。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.3 限流&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;秒杀场景中，对请求做了很多限流操作，比如前端页面的限流和后端令牌桶限流，真正到扣减库存那一步时，请求数很少了。所以限流常用在秒杀方案中，感觉可以再写一篇限流的文章了～&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外其实真实的项目中，用到了更多的机制来保证能够正常扣减库存，本篇是抛砖引入，希望大家提出宝贵的建议和方案～。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;赠送一张秒杀场景方案总结：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.84779299847793&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ0sWes1CVdQ3kK58nWAyb8rSZHQFYV39XTQe3ZDzWhCibaODLPicHZtMska0IjibYrk5tKycJ0QoKj3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1314&quot;/&gt;&lt;/figure&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;完&lt;/strong&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;往期推荐&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-from=&quot;yb-recommend-list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; data-from=&quot;yb-recommend-list&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; data-from=&quot;yb-recommend&quot; data-recommend-article-type=&quot;normal&quot; data-recomment-template-id=&quot;1&quot; data-recommend-article-id=&quot;2257497433_1&quot; data-recommend-article-time=&quot;1625623200&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/1Fk759B8md5qsbiaIueW3FOoTn1xLR4T1M7SfcrBictfVc6DooCP41EgE8UP8Y35oQhtmNrfqjpbphXzKWKP6Fog/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;在线求CR，你觉得我这段Java代码还有优化的空间吗？&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MjM5OTMyNzQzMg==&amp;amp;mid=2257497433&amp;amp;idx=1&amp;amp;sn=a213659a20f1a22bbd3cd6618e8c2ef0&amp;amp;chksm=a4472efe9330a7e8b5559ab9d86eff60ea95194043233c8c77fdc0dd239ab06cc2c23743ad16#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5OTMyNzQzMg==&amp;amp;mid=2257497433&amp;amp;idx=1&amp;amp;sn=a213659a20f1a22bbd3cd6618e8c2ef0&amp;amp;chksm=a4472efe9330a7e8b5559ab9d86eff60ea95194043233c8c77fdc0dd239ab06cc2c23743ad16&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot;&gt;&lt;section data-recommend-type=&quot;normal&quot; data-recommend-tid=&quot;1&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img data-ratio=&quot;0.42604166666666665&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1Fk759B8md5qsbiaIueW3FOoTn1xLR4T1M7SfcrBictfVc6DooCP41EgE8UP8Y35oQhtmNrfqjpbphXzKWKP6Fog/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;在线求CR，你觉得我这段Java代码还有优化的空间吗？&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;br/&gt;&lt;section data-mpa-template=&quot;t&quot; data-from=&quot;yb-recommend&quot; data-recommend-article-type=&quot;normal&quot; data-recomment-template-id=&quot;1&quot; data-recommend-article-id=&quot;2257497386_1&quot; data-recommend-article-time=&quot;1625450400&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/1Fk759B8md4AD9vdq4eQyg6PvibhyLPWZwrPP4GUlv8d2JI8u9KFRcq4ZB4rrhFLsgeZVFxbibhfcOPhzMLibcRzQ/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;23 种设计模式的通俗解释，看完秒懂&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MjM5OTMyNzQzMg==&amp;amp;mid=2257497386&amp;amp;idx=1&amp;amp;sn=b353630773b357dea106e81cad348f3d&amp;amp;chksm=a4472e8d9330a79be2859bdbfe24d95d14df21ee0d62e63bd24cb9756542a35ce451a9292ce3#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5OTMyNzQzMg==&amp;amp;mid=2257497386&amp;amp;idx=1&amp;amp;sn=b353630773b357dea106e81cad348f3d&amp;amp;chksm=a4472e8d9330a79be2859bdbfe24d95d14df21ee0d62e63bd24cb9756542a35ce451a9292ce3&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot;&gt;&lt;section data-recommend-type=&quot;normal&quot; data-recommend-tid=&quot;1&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img data-ratio=&quot;0.425&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1Fk759B8md4AD9vdq4eQyg6PvibhyLPWZwrPP4GUlv8d2JI8u9KFRcq4ZB4rrhFLsgeZVFxbibhfcOPhzMLibcRzQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;23 种设计模式的通俗解释，看完秒懂&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;br/&gt;&lt;section data-mpa-template=&quot;t&quot; data-from=&quot;yb-recommend&quot; data-recommend-article-type=&quot;normal&quot; data-recomment-template-id=&quot;1&quot; data-recommend-article-id=&quot;2257497358_1&quot; data-recommend-article-time=&quot;1625364000&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/1Fk759B8md5o8ZnvcX7l58gAmEFGSksKvVJ6bJbA75giaRMtOEXD0Q0uwPmGEDbH1icgO53CCvciayDoGsibgtSSew/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;千万别去外包&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MjM5OTMyNzQzMg==&amp;amp;mid=2257497358&amp;amp;idx=1&amp;amp;sn=4bf8b538d87899cbb5524e638191710d&amp;amp;chksm=a4472ea99330a7bf4716a706952f3e4336d16cd31ab7d7d2dd6753d7b75ce683c01bc9814630#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5OTMyNzQzMg==&amp;amp;mid=2257497358&amp;amp;idx=1&amp;amp;sn=4bf8b538d87899cbb5524e638191710d&amp;amp;chksm=a4472ea99330a7bf4716a706952f3e4336d16cd31ab7d7d2dd6753d7b75ce683c01bc9814630&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot;&gt;&lt;section data-recommend-type=&quot;normal&quot; data-recommend-tid=&quot;1&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img data-ratio=&quot;0.425&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1Fk759B8md5o8ZnvcX7l58gAmEFGSksKvVJ6bJbA75giaRMtOEXD0Q0uwPmGEDbH1icgO53CCvciayDoGsibgtSSew/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;千万别去外包&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-from=&quot;yb-recommend&quot; data-recommend-article-type=&quot;normal&quot; data-recomment-template-id=&quot;4&quot; data-recommend-article-id=&quot;2257492907_2&quot; data-recommend-article-time=&quot;1611021600&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/1Fk759B8md4XPLDBXjntlR9hjI9MLmLqSL5JQYichQQWibXIWj5Jm5cdzcJ4wOpO0I1K79rKzNlV9ckc4jWTWfiaw/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;JDK 16 即将发布，新特性速览！&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MjM5OTMyNzQzMg==&amp;amp;mid=2257492907&amp;amp;idx=2&amp;amp;sn=e53286471aa6a03b60cc446e4e0258bf&amp;amp;chksm=a447180c9330911a289223ef42ed3541f1fa0bda9a42012ab73d36bea64aafb88f0adce0e3bb#rd&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-from=&quot;yb-recommend&quot; data-recommend-article-type=&quot;normal&quot; data-recomment-template-id=&quot;4&quot; data-recommend-article-id=&quot;2257492907_2&quot; data-recommend-article-time=&quot;1611021600&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/1Fk759B8md4XPLDBXjntlR9hjI9MLmLqSL5JQYichQQWibXIWj5Jm5cdzcJ4wOpO0I1K79rKzNlV9ckc4jWTWfiaw/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;JDK 16 即将发布，新特性速览！&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MjM5OTMyNzQzMg==&amp;amp;mid=2257492907&amp;amp;idx=2&amp;amp;sn=e53286471aa6a03b60cc446e4e0258bf&amp;amp;chksm=a447180c9330911a289223ef42ed3541f1fa0bda9a42012ab73d36bea64aafb88f0adce0e3bb#rd&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-style=&quot;white-space: normal; background-color: rgb(255, 255, 255); color: rgb(62, 62, 62); letter-spacing: 0.544px; font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 16px;&quot; class=&quot;js_darkmode__155&quot;&gt;&lt;p&gt;&lt;span data-style=&quot;color: rgb(0, 0, 0); font-size: 13px;&quot; class=&quot;js_darkmode__156&quot;&gt;有道无术，术可成；有术无道，止于术&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span data-style=&quot;color: rgb(0, 0, 0); font-size: 13px;&quot; class=&quot;js_darkmode__157&quot;&gt;欢迎大家关注&lt;/span&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;Java之道&lt;/strong&gt;&lt;/span&gt;&lt;span data-style=&quot;color: rgb(0, 0, 0); font-size: 13px;&quot; class=&quot;js_darkmode__158&quot;&gt;公众号&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-copyright=&quot;0&quot; data-ratio=&quot;0.5555555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1Fk759B8md4yPF1ZAnySd6Xqparsv06tG4FibicFOr7moddq2D3087xicOrF9l54yOVLQkkiaWUBheSzFfibyGMgeug/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;p data-style=&quot;white-space: normal; background-color: rgb(255, 255, 255); color: rgb(62, 62, 62); letter-spacing: 0.544px; font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 16px; text-align: right;&quot; class=&quot;js_darkmode__159&quot;&gt;&lt;span data-style=&quot;color: rgb(0, 0, 0); font-size: 14px; letter-spacing: 2px; word-spacing: 2px;&quot; class=&quot;js_darkmode__160&quot;&gt;好文章，我&lt;/span&gt;&lt;span&gt;&lt;span&gt;在看&lt;/span&gt;❤️&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>