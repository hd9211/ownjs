<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>d9adfbc1c81702fd7dfbdad1e614d523</guid>
<title>CURD 系统怎么做出技术含量：怎样引导面试</title>
<link>https://toutiao.io/k/28mbv0o</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;引子&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;很多朋友可能会因为自己做的工作不是特别核心或者业务简单而引起面试中没有自信。但是很多公司面试的时候是可以接受面试者之前岗位的并发量、交易量低一些的。比如我们要招聘和我们交易量同等级或者以上的出来的人才，业界本来就没有多少，但我们还是要招人的。所以很多时候更偏向于考察面试者的设计底蕴、思考和解决问题的能力。&lt;/p&gt;&lt;p&gt;我建议面试时，面试者要争取主动权，主动引导面试。一般作为面试官也很乐意被面试者引导。因为面试官的职责是发现面试者的技术特长，为此我们绞尽脑汁的从简历中、自我介绍中去发掘。如果面试者可以自己有完整清晰的思路，是面试官求之不得的事情。&lt;/p&gt;&lt;p&gt;假设我是一个面试者，近几年做的都是XX后台管理系统。后台管理系统嘛，没有高并发、没有高可用需求、没有复杂架构，属于三无系统。要是我的话，会把自己的以下知识技能放到项目介绍里展示给面试官：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100002274&quot; data-ratio=&quot;0.8759259259259259&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRl8Vl88XukjGrhjia3xufC7HwX03eEB1O64xrdiahT8bNAAHDiadL662RKdP2eecbyAqQRlLDsedRalVg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;可测试性设计&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;谦卑对象模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;作为一个后台管理系统，一般场景下微服务化的价值不大。DDD领域驱动设计这种专门用于复杂问题的解决办法在这里多半也是杀鸡用牛刀。后面会讲到一些DDD技巧还是可以用的。实际中大多是采用前后端分离的架构，这种架构实践一方面是动静分离，便于缓存优化等性能考虑，另一方面也是一个出于可测试性的考虑。分离出可自动化测试的接口层和测试难度高的展现层。&lt;/p&gt;&lt;p&gt;展现层对象等测试难度高的对象在整洁架构中被称为谦卑对象。通过拆分不同的类或者模块，来区分容易测试的行为和不容易测试的行为，这种设计上的隔离模式被称为谦卑对象模型。&lt;/p&gt;&lt;p&gt;现在的很多设计对程序的可测试性提供了友好的改进和支持。比如：程序调用数据库执行操作，mybatis等持久层框架将把sql以接口的形式对外提供服务，接口有成熟的工具来做mock打桩，这是比较典型的谦卑对象模式。&lt;/p&gt;&lt;p&gt;另外一个比较典型的比较典型的谦卑对象模式是feign。netflix的feign把原本需要手写的httpClient(或者OKHttp)代码使用接口调用的的形式，实现了命令式到声明式的转换。同时，谦卑对象和非谦卑对象之间有很好的隔离层，也对测试更友好。对feign想做进一步了解的可参考我之前的文章&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485195&amp;amp;idx=1&amp;amp;sn=9aa72718cdcc24d872f0a89cf63ea34f&amp;amp;chksm=fafdeda5cd8a64b3a55f4de3fdc48d2ee396074d851f686b70a7e679dbcf26862348a79182eb&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《Java&amp;amp;Spring过时的经典语录》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《Java&amp;amp;Spring过时的经典语录》&lt;/a&gt;，这里简单举个例子：&lt;/p&gt;&lt;p&gt;&lt;span&gt;public interface &lt;/span&gt;&lt;span&gt;TestHttpService {&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;p&gt;&lt;/p&gt;&lt;pre&gt;    &lt;span&gt;@RequestLine&lt;/span&gt;(&lt;span&gt;&quot;GET /xxxx?appkey={appkey}&amp;amp;ips={ip}&amp;amp;username={username}&amp;amp;operator={operator}&quot;&lt;/span&gt;)&lt;br/&gt;    Response getTest(&lt;span&gt;@Param&lt;/span&gt;(value = &lt;span&gt;&quot;appkey&quot;&lt;/span&gt;) String appkey,&lt;br/&gt;                                       &lt;span&gt;@Param&lt;/span&gt;(value = &lt;span&gt;&quot;ip&quot;&lt;/span&gt;) String ip,&lt;br/&gt;                                       &lt;span&gt;@Param&lt;/span&gt;(value = &lt;span&gt;&quot;username&quot;&lt;/span&gt;) String username,&lt;br/&gt;                                       &lt;span&gt;@Param&lt;/span&gt;(value = &lt;span&gt;&quot;operator&quot;&lt;/span&gt;) String operator);&lt;br/&gt;&lt;p&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;pre/&gt;&lt;p&gt;&lt;strong&gt;RESTful&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;说起后台管理系统的接口层，RESTful风格的接口是比较流行的最佳实践。虽然这个被提了很多年了，实际严格按照这种风格设计的接口并不多。大多数系统的接口风格像是跟着江南七怪学武的郭靖一般，武功路数驳杂不成体系。&lt;/p&gt;&lt;p&gt;来做个判断题：&lt;/p&gt;&lt;p&gt;下面的代码，类上用了RestController的注解，这是RESTful风格的代码吗？&lt;/p&gt;&lt;pre&gt;&lt;span&gt;@RestController&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public class &lt;/span&gt;JacksonController {&lt;br/&gt;    &lt;span&gt;@Resource&lt;br/&gt;    &lt;/span&gt;&lt;span&gt;private &lt;/span&gt;User &lt;span&gt;user&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;    &lt;/span&gt;&lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/writeStringAsString&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;public &lt;/span&gt;String &lt;span&gt;writeStringAsString&lt;/span&gt;(String toWrite) &lt;span&gt;throws &lt;/span&gt;Exception {&lt;br/&gt;        System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;user&lt;/span&gt;.getAge())&lt;span&gt;;&lt;br/&gt;        &lt;/span&gt;ObjectMapper objectMapper = &lt;span&gt;new &lt;/span&gt;ObjectMapper()&lt;span&gt;;&lt;br/&gt;        return &lt;/span&gt;objectMapper.writeValueAsString(toWrite)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;REST（英文：Representational State Transfer，简称REST） 指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful。&lt;/p&gt;&lt;p&gt;理论上REST架构风格并不是绑定在HTTP上，但是REST本身受Web技术的影响很深， 目前HTTP是唯一与REST相关的实例。&lt;br/&gt;咱们来看看需要满足哪些约束条件和原则。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;资源设计规则：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1&amp;gt;不用大写；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2&amp;gt;用中杠-不用下杠_；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3&amp;gt;用名词不用动词；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4&amp;gt;URI中的名词表示资源集合，使用复数形式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;动作设计规则：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;1&amp;gt;GET（SELECT）：从服务器取出资源（一项或多项）。&lt;/p&gt;&lt;p&gt;2&amp;gt;POST（CREATE）：在服务器新建一个资源。&lt;/p&gt;&lt;p&gt;3&amp;gt;PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。&lt;/p&gt;&lt;p&gt;4&amp;gt;PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。&lt;/p&gt;&lt;p&gt;5&amp;gt;DELETE（DELETE）：从服务器删除资源。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;返回结果规则：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;与HTTP协议标准基本没有新的约束。要注意content-type的accept，包含accept-encoding。之前出个我在测试环境出个一个问题，我们自动化测试回归平台不支持gzip，但是请求时带了gzip，其实平台并不支持导致乱码。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100002279&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3926174496644295&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlic2J7cNVQWgTFniam7jzO9uvBFc2jzdMD6PMFX62OIvwmZjiarr4N7wS0K7m8IykvbKjYeOst3fEunw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;894&quot;/&gt;&lt;/p&gt;&lt;p&gt;通过上面的约束条件和原则咱们来总结一下为什么叫REST：&quot;资源&quot;是一种信息实体，它可以有多种外在表现形式。我们把&quot;资源&quot;具体呈现出来的形式，叫做它的&quot;表现层&quot;（Representation）。&lt;/p&gt;&lt;p&gt;互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生&quot;状态转化&quot;（State Transfer）。而这种转化是建立在表现层之上的，所以就是&quot;表现层状态转化&quot;。&lt;/p&gt;&lt;p&gt;如果大家都理解，那上面判断题的答案也呼之欲出了：因为不满足相应的约束条件和原则，所以不是RESTful风格。@RestController 只是让资源返回结果是RESTful风格的。但不管是不是RESTful风格，都是URI。统一资源标识符（Uniform Resource Identifier，URI)是一个用于标识某一互联网资源名称的字符串。 只要定位到资源了，都是URI。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;领域驱动设计DDD&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;充血模型&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;贫血模型是指实体对象或者说是POJO只包含简单的set、get方法，充血模型认为一个对象是拥有状态和行为的。什么叫状态和行为呢？举个例子：&lt;/p&gt;&lt;pre&gt;&lt;span&gt;@Setter&lt;br/&gt;@Getter&lt;br/&gt;@ToString&lt;br/&gt;@EqualsAndHashCode&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public class &lt;/span&gt;Pojo {&lt;br/&gt;    &lt;span&gt;private &lt;/span&gt;String &lt;span&gt;name &lt;/span&gt;&lt;span&gt;;&lt;br/&gt;    private &lt;/span&gt;String &lt;span&gt;status&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;    public int &lt;/span&gt;&lt;span&gt;getStatus&lt;/span&gt;() {&lt;br/&gt;        &lt;span&gt;return &lt;/span&gt;NumberUtils.&lt;span&gt;toInt&lt;/span&gt;(&lt;span&gt;status&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;    &lt;/span&gt;}&lt;br/&gt;}&lt;/pre&gt;&lt;p&gt;上面类代码上用了lombok的@Setter、@Getter注解之外，还用了@ToString、@EqualsAndHashCode，这两个虽然是Object对象的基本方法，实际上也是做了状态和行为的事情，而不只是@Setter、@Getter的数据存取。与之类似的还有上面的int getStatus，实际上进行了类型转换这个行为。&lt;/p&gt;&lt;p&gt;现在针对到底使用贫血模型还是充血模型更好说法不一。我个人更倾向于使用充血模型，因为这种方法从领域上更内聚。但是很多人不建议使用，主要是因为充血模型对个人能力有更高的要求。充血模型开发者需要自己去识别哪些是实体领域中的。对于一般的spring开发者来说，个人经验上有个简单的办法：凡是要引用@Service、@Component的都不要放到里面，之前本来要放到XXUtils的建议看看更符合哪个实体领域，不要一股脑放到util包下面，看看是否可以划分到实体领域中。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;CQRS&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CQRS — Command Query Responsibility Segregation，&lt;/span&gt;&lt;span&gt;顾名思义&lt;/span&gt;&lt;span&gt;&lt;span&gt;是将 command 与 query 分离的一种模式。&lt;/span&gt;&lt;span&gt;CQRS 将系统中的操作分为两类，即「命令」(Command) 与「查询」(Query)。命令则是对会引起数据发生变化操作的总称，即我们常说的新增，更新，删除这些操作，都是命令。而查询则和字面意思一样，即不会对数据产生变化的操作，只是按照某些条件查找数据。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在后台系统中，某些查询操作可能会过于频繁，比如页面定时刷新获取数据。这些查询操作不需要保证每次都成功。而命令操作如果失败则涉及到事务回滚等操作，需要保证操作的成功率。这时候可以使用CQRS隔离，比如将检查流量和命令流量使用&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485474&amp;amp;idx=1&amp;amp;sn=df22866d7a0b096e7169a5bef81a3058&amp;amp;chksm=fafde28ccd8a6b9a0157fb4e2600a71c8a5db6db7eea37dfdbd6f25e6d3b38b6ab92c4d1f9e3&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;hystrix隔离&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;hystrix隔离&lt;/a&gt;，架构清晰了，还可以画出下面这样清晰的架构图：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;568&quot; data-backw=&quot;578&quot; data-fileid=&quot;100002278&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9831697054698457&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8Vl88XukjGrhjia3xufC7HwFdtG13RnV4JB9zF4xdNMmSRPAUW2yYzWEZCkOiaHWtaRsvCKVmqBSnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;713&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;上面都是后台管理系统中常用的一些技术，其实还有ACL（防腐层），批量操作的隔离、熔断、分片，数据异步转同步等限于篇幅这里就不介绍了。只要面试中能够引导面试官提问这方面的技术并且可以讲的明明白白，已经可以超过大部分的面试者。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;219&quot; data-backw=&quot;292&quot; data-fileid=&quot;100002277&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRl8Vl88XukjGrhjia3xufC7Hwa7IGSwtibHsxsZKGHFVibQfUHZCzAbibiauOthcQEnGsfXTUCeCzluyzqw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;292&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485029&amp;amp;idx=1&amp;amp;sn=81b593816669318ee3203449177f90c9&amp;amp;chksm=fafdeccbcd8a65dd8a1116dd4eee9e9de9c4c8833e64854422d0a8bc57d28d83d8d57e1e936d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;分布式存储系统的一致性-可见性差异&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;分布式存储系统的一致性-可见性差异&lt;/a&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cf8107f5459d5e16ce4d5727d44a5dfe</guid>
<title>浅析 Web 录屏技术方案与实现</title>
<link>https://toutiao.io/k/ol9xtmo</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;👆 &lt;/span&gt;&lt;span&gt; 这是第 &lt;/span&gt;&lt;span&gt;&lt;span&gt;121&lt;/span&gt;&lt;/span&gt;&lt;span&gt; 篇&lt;/span&gt;&lt;span&gt;不掺水的原创&lt;/span&gt;&lt;span&gt;，想要了解更多&lt;/span&gt;&lt;span&gt;，请戳上方蓝色字体：&lt;/span&gt;&lt;span&gt;政采云前端团队&lt;/span&gt;&lt;span&gt; 关注我们吧～&lt;/span&gt;&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;31&quot; data-source-title=&quot;https://www.zoo.team/article/webrtc-screen&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;本文首发于政采云前端团队博客：浅析 Web 录屏技术方案与实现&lt;/p&gt;&lt;/section&gt;&lt;section class=&quot;blockquote_info js_blockquote_source&quot; data-json=&quot;%7B%22type%22%3A%22out%22%2C%22source%22%3A%22url%22%2C%22digest%22%3A%22%3Cp%3E%E6%9C%AC%E6%96%87%E9%A6%96%E5%8F%91%E4%BA%8E%E6%94%BF%E9%87%87%E4%BA%91%E5%89%8D%E7%AB%AF%E5%9B%A2%E9%98%9F%E5%8D%9A%E5%AE%A2%EF%BC%9A%E6%B5%85%E6%9E%90%26nbsp%3BWeb%26nbsp%3B%E5%BD%95%E5%B1%8F%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88%E4%B8%8E%E5%AE%9E%E7%8E%B0%3C%2Fp%3E%22%2C%22digestLen%22%3A31%2C%22text%22%3A%22%22%2C%22article%22%3A%7B%7D%2C%22hasReportOverSize%22%3Afalse%2C%22editorReportData%22%3A%5B%7B%22id%22%3A%22122333%22%2C%22key%22%3A%2276%22%2C%22len%22%3A1%7D%5D%2C%22from%22%3A%22https%3A%2F%2Fwww.zoo.team%2Farticle%2Fwebrtc-screen%22%7D&quot;&gt;&lt;span class=&quot;blockquote_other&quot;&gt;https://www.zoo.team/article/webrtc-screen&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vzEib9IRhZD47xMmwA1zRzQAXHj1ngH9Sder18DCVHJeo9OcSZTaUVibj7kQyftCZZhKOL2yaLCGXibCBjQMCnsicg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着互联网技术飞速发展，网页录屏技术已趋于成熟。例如可将录屏技术运用到在线考试中，实现远程监考、屏幕共享以及录屏等；而在我们开发人员研发过程中，对于部分偶发事件，异常监控系统仅仅只能告知程序出错，而不能清晰的告知错误的复现路径，而录屏技术或许能帮我们定位并复现问题。那么本文将从有感录屏和无感录屏两方面给读者分享一下录屏这项技术，希望可以帮助你对网页录屏有一个初步认识。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;什么是有感录屏？&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有感录屏一般指通过获得用户的授权或者通知用户接下来的操作将会被录制成视频，并且在录制过程中，用户有权关闭中断录屏。即无论在录屏前还是录屏的过程中，用户都始终能够决定录屏能否进行。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;基于 WebRTC 的有感录屏&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的有感录屏方案主要是通过 &lt;strong&gt;WebRTC&lt;/strong&gt; (https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API) 录制。&lt;strong&gt;WebRTC&lt;/strong&gt; 是一套基于音视轨的实时数据流传播的技术方案。由浏览器提供的原生 API &lt;strong&gt;navigator.mediaDevices.getDisplayMedia&lt;/strong&gt; 方法实现提示用户选择和授权捕获展示的内容或窗口，进而将获取 stream (录制的屏幕音视流)。我们可以对 stream 进行转化处理，转成相对应的媒体数据，并将其数据存储。后续需要回溯该次录制内容时，则取出媒体数据进行播放。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体的有感录屏流程如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.27371794871794874&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vzEib9IRhZD47xMmwA1zRzQAXHj1ngH9SfrLp1YVH0tMYKa3QE4FRPMMcxTLAAQibPsZ0x92nwWJfgtgs0XT0FCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1560&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;实现初始化录屏和数据存储&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 &lt;strong&gt;navigator.mediaDevices.getDisplayMedia&lt;/strong&gt; 初始化录屏，触发弹窗获取用户授权，效果图如下所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.43683917640511966&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vzEib9IRhZD47xMmwA1zRzQAXHj1ngH9Srlvouicic7k40qpaAmOA0hIyibicSlAm2BynYkDBXDY5e2bwBoksciazzUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1797&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现 WebRTC 初始化录屏核心代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; tracks = []; &lt;span&gt;// 媒体数据&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; options = {&lt;br/&gt;  mimeType : &lt;span&gt;&quot;video/webm; codecs = vp8&quot;&lt;/span&gt;, &lt;span&gt;// 媒体格式&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; mediaRecorder;&lt;br/&gt;&lt;span&gt;// 初始化请求用户授权监控&lt;/span&gt;&lt;br/&gt;navigator.mediaDevices.getDisplayMedia(constraints).then(&lt;span&gt;(&lt;span&gt;stream&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// 对音视流进行操作&lt;/span&gt;&lt;br/&gt;  startFunc(stream);&lt;br/&gt;});&lt;br/&gt;&lt;span&gt;// 开始录制方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;start&lt;/span&gt;(&lt;span&gt;stream&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 创建 MediaRecorder 的实例对象，对指定的媒体流进行录制&lt;/span&gt;&lt;br/&gt;  mediaRecorder = &lt;span&gt;new&lt;/span&gt; MediaRecorder(stream, options);&lt;br/&gt;  &lt;span&gt;// 当生成媒体流数据时触发该事件，回调传参 event 指本次生成处理的媒体数据&lt;/span&gt;&lt;br/&gt;  mediaRecorder.ondataavailable = &lt;span&gt;&lt;span&gt;event&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;     &lt;span&gt;if&lt;/span&gt;(event?.data?.size &amp;gt; &lt;span&gt;0&lt;/span&gt;){&lt;br/&gt;      tracks.push(event.data); &lt;span&gt;// 存储媒体数据&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  };&lt;br/&gt;  mediaRecorder.start();&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;************开始录制************&quot;&lt;/span&gt;)&lt;br/&gt;};&lt;br/&gt;&lt;span&gt;// 结束录制方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;stop&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  mediaRecorder.stop();&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;************录制结束************&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 定义constraints数据类型&lt;/span&gt;&lt;br/&gt;&lt;span&gt;interface&lt;/span&gt; constraints {&lt;br/&gt;  audio: &lt;span&gt;boolean&lt;/span&gt; | MediaTrackConstraints, &lt;span&gt;// 指定是否请求音轨或者约束轨道属性值的对象&lt;/span&gt;&lt;br/&gt;  video: &lt;span&gt;boolean&lt;/span&gt; | MediaTrackConstraints, &lt;span&gt;// 指定是否请求视频轨道或者约束轨道属性值的对象&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;实现录屏回溯&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;获取该次录屏的媒体数据，可以将其转成 blob 对象，并且生成 blob对象的 url 字符串，再赋值 video.src 中，便可以回放到录制结果，回溯的视频效果如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.30430430430430433&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/vzEib9IRhZD47xMmwA1zRzQAXHj1ngH9SAT74mxO8l2kQ5r5ECK1ZLiaibmdAn6bQ4iad3B8CAq0lMge5T50mWBYXw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;999&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;录屏回溯方法的核心代码如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 回放录制内容&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;replay&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; video = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&quot;video&quot;&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; blob = &lt;span&gt;new&lt;/span&gt; Blob(tracks, {&lt;span&gt;type&lt;/span&gt; : &lt;span&gt;&quot;video/webm&quot;&lt;/span&gt;});&lt;br/&gt;  video.src = &lt;span&gt;window&lt;/span&gt;.URL.createObjectURL(blob);&lt;br/&gt;  video.srcObject = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;  video.controls = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;  video.play();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;实现实时直播功能&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于存储的媒体数据是实时的，因此可以利用该数据实现直播功能。通过给 video.srcObject 赋值媒体流可以实现直播功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现实时直播核心代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 直播&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;live&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; video = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&quot;video&quot;&lt;/span&gt;);&lt;br/&gt;  video.srcObject = &lt;span&gt;window&lt;/span&gt;.stream;&lt;br/&gt;  video.controls = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;  video.play();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;浏览器兼容性&lt;/span&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.888&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/vzEib9IRhZD47xMmwA1zRzQAXHj1ngH9Sw9gpXRibG1iakBsvuAmxk6bdsVibFe63U99BXJIswKgIkCdOBcOrmUGwg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1000&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;什么是无感录屏？&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无感录屏指在用户无感知的情况，对用户在页面上的操作进行录制。实现上与有感录制区别在于，无感录制通常是利用记录页面的 DOM 来进行录制。常见的有 canvas 截图绘制视频和 rrweb 录制等方案。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;canvas 截图绘制视频&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户在浏览页面时，可以通过 canvas 绘制多个 DOM 快照截图，再将多个截图合并成一段录屏视频。但是考虑到假设视频帧数为 30 帧，帧数代表着每秒所需的截图数量，为了视频的流畅和清晰，每张截图为 400 KB ，那么当视频长度为 1 分钟，则需要上传 703.125 MB 的资源，这么大的带宽浪费无疑会造成性能，甚至影响用户体验，不推荐使用，也不在此详细介绍本方案实现。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;rrweb 录制&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;rrweb&lt;/strong&gt; (record and replay the web) 是一个对于 DOM 录制的支持性非常好，利用现代浏览器所提供的强大 API 录制并回放任意 web 界面中的用户操作，能够将页面 DOM 结构通过相应算法高效转换 JSON 数据的开源库。相比较于使用 canvas 绘制录屏，rrweb 在保证录制不掉帧的基础上，让网络传输数据更加快速和轻量化，极大地优化了网络性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;rrweb&lt;/strong&gt; 开源库主要由 &lt;strong&gt;rrweb-snapshot&lt;/strong&gt;、&lt;strong&gt;rrweb&lt;/strong&gt; 和 &lt;strong&gt;rrweb-play&lt;/strong&gt; 三部分组成，并且提供了动作筛选，数据加密、数据压缩、数据切片、屏蔽元素等功能。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.34089191232048377&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vzEib9IRhZD47xMmwA1zRzQAXHj1ngH9Sj1zzDv4icicUx3o7jOMD6hicqprT8VgY2glbG2hbibE0dJbKPlXmmGv7cg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1323&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;rrweb-snapshot&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;rrweb-snapshot&lt;/strong&gt; 提供 &lt;strong&gt;snapshot&lt;/strong&gt; 和 &lt;strong&gt;rebuild&lt;/strong&gt; 两个 API，分别实现生成可序列化虚拟 DOM 快照的数据结构和将其数据结构重建为对应 DOM 节点的两个功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;snapshot&lt;/strong&gt; 将 DOM 及其状态转化为可序列化的数据结构并添加唯一标识 id，使得一个 id 映射对应的一个 DOM 节点，方便后续以增量的方式来操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先需要通过深拷贝 document 生成初始化 DOM 快照。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 深拷贝 document 节点&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; docEl = &lt;span&gt;document&lt;/span&gt;.documentElement.cloneNode(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;// 回放时再将深拷贝的节点挂在回去即可&lt;/span&gt;&lt;br/&gt;&lt;span&gt;document&lt;/span&gt;.replaceChild(docEl, &lt;span&gt;document&lt;/span&gt;.documentElement);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于获取到的 DOM 对象并不是可序列化的，因此仍需要将其转成特定的文本格式（如 JSON）进行传输，否则无法做到远程录制。在实现 DOM 快照可序列化的过程中，还需对数据进行特殊处理：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;将相对路径改成绝对路径；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将页面引用的样式改成内联样式；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;禁止脚本运行，被录制页面中的所有 JavaScript 都不应该被执行。把 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 转成 &lt;code&gt;&amp;lt;noscrpit&amp;gt;&lt;/code&gt; ；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;由于部分表单（如 &lt;code&gt;&amp;lt;input type=&quot;text&quot; /&amp;gt;&lt;/code&gt; ）不会把值暴露在 html 中，故需读取表单的 value 值。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然已经能够获取到全量的 DOM 对象，但是无法将增量快照中被交互的 DOM 节点和现已有的 DOM 节点关联上，所以还需要给 DOM 添加一层映射关系（id =&amp;gt; Node），后续 DOM 节点的更新都通过该 id 来记录并对应到完整的 DOM 节点中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下是初始时获取到的 DOM 节点：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;header&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;header&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过遍历整个 DOM 树，以 Node 节点为单位，给每个遍历到的 Node 都添加了唯一标识 id ，生成全量序列化的 DOM 对象快照 。以下是序列化后的数据结构示意：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;{&lt;br/&gt;  &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;Document&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;childNodes&quot;&lt;/span&gt;: [&lt;br/&gt;    {&lt;br/&gt;      &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;Element&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;tagName&quot;&lt;/span&gt;: &lt;span&gt;&quot;html&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;attributes&quot;&lt;/span&gt;: {},&lt;br/&gt;      &lt;span&gt;&quot;childNodes&quot;&lt;/span&gt;: [&lt;br/&gt;        {&lt;br/&gt;          &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;Element&quot;&lt;/span&gt;,&lt;br/&gt;          &lt;span&gt;&quot;tagName&quot;&lt;/span&gt;: &lt;span&gt;&quot;head&quot;&lt;/span&gt;,&lt;br/&gt;          &lt;span&gt;&quot;attributes&quot;&lt;/span&gt;: {},&lt;br/&gt;          &lt;span&gt;&quot;childNodes&quot;&lt;/span&gt;: [],&lt;br/&gt;          &lt;span&gt;&quot;id&quot;&lt;/span&gt;: &lt;span&gt;3&lt;/span&gt;&lt;br/&gt;        },&lt;br/&gt;        {&lt;br/&gt;          &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;Element&quot;&lt;/span&gt;,&lt;br/&gt;          &lt;span&gt;&quot;tagName&quot;&lt;/span&gt;: &lt;span&gt;&quot;body&quot;&lt;/span&gt;,&lt;br/&gt;          &lt;span&gt;&quot;attributes&quot;&lt;/span&gt;: {},&lt;br/&gt;          &lt;span&gt;&quot;childNodes&quot;&lt;/span&gt;: [&lt;br/&gt;            {&lt;br/&gt;              &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;Text&quot;&lt;/span&gt;,&lt;br/&gt;              &lt;span&gt;&quot;textContent&quot;&lt;/span&gt;: &lt;span&gt;&quot;\n    &quot;&lt;/span&gt;,&lt;br/&gt;              &lt;span&gt;&quot;id&quot;&lt;/span&gt;: &lt;span&gt;5&lt;/span&gt;&lt;br/&gt;            },&lt;br/&gt;            {&lt;br/&gt;              &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;Element&quot;&lt;/span&gt;,&lt;br/&gt;              &lt;span&gt;&quot;tagName&quot;&lt;/span&gt;: &lt;span&gt;&quot;header&quot;&lt;/span&gt;,&lt;br/&gt;              &lt;span&gt;&quot;attributes&quot;&lt;/span&gt;: {},&lt;br/&gt;              &lt;span&gt;&quot;childNodes&quot;&lt;/span&gt;: [&lt;br/&gt;                {&lt;br/&gt;                  &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;Text&quot;&lt;/span&gt;,&lt;br/&gt;                  &lt;span&gt;&quot;textContent&quot;&lt;/span&gt;: &lt;span&gt;&quot;\n    &quot;&lt;/span&gt;,&lt;br/&gt;                  &lt;span&gt;&quot;id&quot;&lt;/span&gt;: &lt;span&gt;7&lt;/span&gt;&lt;br/&gt;                }&lt;br/&gt;              ],&lt;br/&gt;              &lt;span&gt;&quot;id&quot;&lt;/span&gt;: &lt;span&gt;6&lt;/span&gt;&lt;br/&gt;            }&lt;br/&gt;          ],&lt;br/&gt;          &lt;span&gt;&quot;id&quot;&lt;/span&gt;: &lt;span&gt;4&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;      ],&lt;br/&gt;      &lt;span&gt;&quot;id&quot;&lt;/span&gt;: &lt;span&gt;2&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  ],&lt;br/&gt;  &lt;span&gt;&quot;id&quot;&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将 &lt;strong&gt;snapshot&lt;/strong&gt; 记录的初始化快照的数据结构，继而通过递归给每个节点添加属性来重建 DOM ，生成可序列化的 DOM 节点快照。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;rrweb&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;rrweb&lt;/strong&gt; 提供 &lt;strong&gt;record&lt;/strong&gt; 和 &lt;strong&gt;replay&lt;/strong&gt; 两个 API，分别实现记录所有增量数据和将记录的数据按照时间戳回放的两个功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过触发视图的变化和 DOM 结构的改变（如 DOM 节点的删减和属性值的变化）来劫持增量变化数据存入 JSON 对象中，每个增量数据对应一个时间戳，这些数据称之为 Oplog（operations log）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6764295676429568&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vzEib9IRhZD47xMmwA1zRzQAXHj1ngH9Se3zHVKxdSibAUKvibMJLCs0AygibibszO0tdupxG5pGEz3VCbdUdPh60SQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1434&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;视图的变化可通过全局事件监听和事件代理方法收集增量数据，而这些事件大多是和用户的操作行为相关，能够触发这类事件的动作如 DOM 节点或内容的变动、鼠标移动或交互、页面或元素滚动、键盘交互和窗口大小变动。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DOM 结构的改变可以通过浏览器提供的 MutationObserver (https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver) 接口能监视，触发参数回调，获取到本次 DOM 的变动的节点信息，进而对数据进行筛选重组等处理。回调参数的数据结构如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; MutationRecord1: MutationRecordObject[];&lt;br/&gt;&lt;span&gt;interface&lt;/span&gt; MutationRecordObject {&lt;br/&gt;  &lt;span&gt;/**&lt;br/&gt;   * 如果是属性变化，则返回 &quot;attributes&quot;；&lt;br/&gt;   * 如果是 characterData 节点变化，则返回 &quot;characterData&quot;；&lt;br/&gt;   * 如果是子节点树 childList 变化，则返回 &quot;childList&quot;。&lt;br/&gt;  */&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;String&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;// 返回被添加的节点。如果没有节点被添加，则该属性将是一个空的 NodeList。&lt;/span&gt;&lt;br/&gt;  addedNodes: NodeList,&lt;br/&gt;  &lt;span&gt;// 返回被移除的节点。如果没有节点被移除，则该属性将是一个空的 NodeList。&lt;/span&gt;&lt;br/&gt;  removedNodes: NodeList,&lt;br/&gt;  &lt;span&gt;// 返回被修改的属性的属性名，或者 null。&lt;/span&gt;&lt;br/&gt;  attributeName: &lt;span&gt;String&lt;/span&gt; | &lt;span&gt;null&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;// 返回被修改属性的命名空间，或者 null。&lt;/span&gt;&lt;br/&gt;  attributeNamespace: &lt;span&gt;String&lt;/span&gt; | &lt;span&gt;null&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;// 返回被添加或移除的节点之前的兄弟节点，或者 null。&lt;/span&gt;&lt;br/&gt;  previousSibling: Node | &lt;span&gt;null&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;// 返回被添加或移除的节点之后的兄弟节点，或者 null。&lt;/span&gt;&lt;br/&gt;  nextSibling: Node | &lt;span&gt;null&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;/** 返回值取决于 MutationRecord.type。&lt;br/&gt;   * 对于属性 attributes 变化，返回变化之前的属性值。&lt;br/&gt;   * 对于 characterData 变化，返回变化之前的数据。&lt;br/&gt;   * 对于子节点树 childList 变化，返回 null。&lt;br/&gt;  */&lt;/span&gt;&lt;br/&gt;  oldValue: &lt;span&gt;String&lt;/span&gt; | &lt;span&gt;null&lt;/span&gt;,&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;record 收集的 Oplog 数据结构如下图所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; Oplog: OplogObject[];&lt;br/&gt;&lt;span&gt;interface&lt;/span&gt; OplogObject {&lt;br/&gt;  &lt;span&gt;/** 返回值取决于收集的事件类型&lt;br/&gt;   * DomContentLoaded: 0, Load: 1,&lt;br/&gt;   * FullSnapshot: 2, IncrementalSnapshot: 3,&lt;br/&gt;   * Meta: 4, Custom: 5, Plugin: 6&lt;br/&gt;  */&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;Number&lt;/span&gt;,&lt;br/&gt;  data: {&lt;br/&gt;    &lt;span&gt;// 返回添加的节点数据&lt;/span&gt;&lt;br/&gt;    adds: [],&lt;br/&gt;    &lt;span&gt;// 返回修改的节点属性数据&lt;/span&gt;&lt;br/&gt;    attributes: [],&lt;br/&gt;    &lt;span&gt;// 返回移除的节点属性数据&lt;/span&gt;&lt;br/&gt;    removes: [],&lt;br/&gt;    &lt;span&gt;/** 返回值取决于增量数据的增量类型&lt;br/&gt;     * Mutation: 0, MouseMove: 1,&lt;br/&gt;     * MouseInteraction: 2, Scroll: 3,&lt;br/&gt;     * ViewportResize: 4, Input: 5,&lt;br/&gt;     * TouchMove: 6, MediaInteraction: 7,&lt;br/&gt;     * StyleSheetRule: 8, CanvasMutation: 9,&lt;br/&gt;     * Font: 10, Log: 11,&lt;br/&gt;     * Drag: 12, StyleDeclaration: 13&lt;br/&gt;    **/&lt;/span&gt;&lt;br/&gt;    source: &lt;span&gt;Number&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;// 返回当前修改的值，无则不返回&lt;/span&gt;&lt;br/&gt;    text: &lt;span&gt;String&lt;/span&gt; | &lt;span&gt;undefined&lt;/span&gt;,&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;// 当前时间戳&lt;/span&gt;&lt;br/&gt;  timestamp: &lt;span&gt;Number&lt;/span&gt;,&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于初始化的快照数据和增量数据，将其按照对应的时间戳一一回放。由于一开始创建快照时已经禁止了脚本运行，所以可以通过 iframe 作为容器来重建 DOM 全量快照 ，并且通过 sanbox 属性禁止了脚本执行、弹出窗和表单提交之类的操作。把 Oplog 放入操作队列中，按照每个的时间戳先后进行排序，再使用定时器 requestAnimationFrame 回放 Oplog 快照。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;rrweb-player&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为 rrweb 提供一套 UI 控件，提供基于 GUI 的暂停、快进、拖拽至任意时间点播放等功能。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文章从有感和无感两个角度来浅析录屏方案的实现。页面录屏的应用场景场景比较丰富，有感录制常见用于网页线上考试、直播和语音视频通话等实时交互场景，而无感录制则更多应用在重要操作记录、bug 重现场景和产品运营分析用户习惯等场景，二者各有千秋。基于用户数据的安全和敏感，目前政采云倾向采用有感录制进行试点试用，避免引起安全纠纷。在录屏技术方案不断地完善和趋向成熟的同时，我们也应尊重用户的数据安全和隐私，选择更合适自身场景的方案使用。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;rrweb (https://github.com/rrweb-io/rrweb)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何用 JS 实现页面录制与回放 (https://mp.weixin.qq.com/s/kJ4-eGeaByybU_Uk3bw8Sw&lt;/p&gt;&lt;h2&gt;&lt;span&gt;看完两件事&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;如果你觉得这篇内容对你挺有启发，我想邀请你帮我两件小事&lt;/p&gt;&lt;p&gt;1.点个「&lt;strong&gt;在看&lt;/strong&gt;」，让更多人也能看到这篇内容（点了&lt;span&gt;「&lt;/span&gt;&lt;strong&gt;在看&lt;/strong&gt;&lt;span&gt;」，bug -1 😊&lt;/span&gt;）&lt;/p&gt;&lt;section&gt;2.关注公众号「&lt;strong&gt;政采云前端团队&lt;/strong&gt;」，持续为你推送精选好文&lt;/section&gt;&lt;h2&gt;&lt;span&gt;招贤纳士&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;政采云前端团队（ZooTeam），一个年轻富有激情和创造力的前端团队，隶属于政采云产品研发部，Base 在风景如画的杭州。团队现有 50 余个前端小伙伴，平均年龄 27 岁，近 3 成是全栈工程师，妥妥的青年风暴团。成员构成既有来自于阿里、网易的“老”兵，也有浙大、中科大、杭电等校的应届新人。团队在日常的业务对接之外，还在物料体系、工程平台、搭建平台、性能体验、云端应用、数据分析及可视化等方向进行技术探索和实战，推动并落地了一系列的内部技术产品，持续探索前端技术体系的新边界。&lt;/p&gt;&lt;p&gt;如果你想改变一直被事折腾，希望开始能折腾事；如果你想改变一直被告诫需要多些想法，却无从破局；如果你想改变你有能力去做成那个结果，却不需要你；如果你想改变你想做成的事需要一个团队去支撑，但没你带人的位置；如果你想改变既定的节奏，将会是“5 年工作时间 3 年工作经验”；如果你想改变本来悟性不错，但总是有那一层窗户纸的模糊… 如果你相信相信的力量，相信平凡人能成就非凡事，相信能遇到更好的自己。如果你希望参与到随着业务腾飞的过程，亲手推动一个有着深入的业务理解、完善的技术体系、技术创造价值、影响力外溢的前端团队的成长历程，我觉得我们该聊聊。任何时间，等着你写点什么，发给 &lt;code&gt;ZooTeam@cai-inc.com&lt;/code&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;542&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;234&quot; data-ratio=&quot;0.43203125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/vzEib9IRhZD7b2jpsibTsaZxWjfhyfqIpeMmOsdx6heH7KYxYXS1c6eQ30TrnyLyRa0SSs74NUM7BNTK8cu5XoibQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f395d843ee53b13d4bc000c432a461ac</guid>
<title>Executors：为什么阿里不待见我？</title>
<link>https://toutiao.io/k/0kl6hpi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是&lt;code&gt;Excutors&lt;/code&gt;，一个老实的工具类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有个叫老三的程序员在文章 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247488521&amp;amp;idx=1&amp;amp;sn=66b0ae23ef24ba47f4487aa8a3646886&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;要是以前有人这么讲线程池，我早就该明白了！&lt;/a&gt;里挖了一个坑，说要把我介绍给大家认识认识。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我其实挺委屈的，作为一个没得感情，老实干活的工具类，我却上了阿里巴巴的黑名单。他们在一本叫《Java开发手册》的册子里写道：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3006782215523738&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfqFyTjCUZqTyXKjB7K11x61sPlwLgQicoEDia5XrITHZFuMT0m5R6TqBIQo3uG13O8otafE030Pm6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1327&quot;/&gt;&lt;figcaption&gt;禁止使用Excutors&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者画外音：人家为啥给你拉黑，不写的清清楚楚嘛，你有啥可委屈的。而且你这个家伙就是表面看起来老实，活是你干的吗？干活的不都是小老弟&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;。来，我一个个给你数。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1. newFixedThreadPool&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;FixedThreadPool&lt;/code&gt;,是一个固定大小的线程池。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看一下它的源代码实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ExecutorService &lt;span&gt;newFixedThreadPool&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; nThreads)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(nThreads, nThreads,&lt;br/&gt;                                      &lt;span&gt;0L&lt;/span&gt;, TimeUnit.MILLISECONDS,&lt;br/&gt;                                      &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;());&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接调用&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;的构造方法。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;核心线程数&lt;/code&gt;和&lt;code&gt;最大线程数&lt;/code&gt;相同&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用&lt;code&gt;LinkedBlockingQueue&lt;/code&gt;作为任务队列&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;FixedThreadPool&lt;/code&gt;的&lt;code&gt;execute()&lt;/code&gt;运行示意图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5287588294651867&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfqFyTjCUZqTyXKjB7K11x6UPKutFad49aARF0AXxpyGsyvMMvlia6nZaw7yMM0meCq2OPBUM0AUww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;991&quot;/&gt;&lt;figcaption&gt;FixedThreadPool&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整体运行过程：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当前运行线程少于&lt;code&gt;corePoolSize&lt;/code&gt;，则创建新线程执行任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当前运行线程大于&lt;code&gt;corePoolSize&lt;/code&gt;，将任务加入&lt;code&gt;LinkedBlockingQueue&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程池中线程执行完任务后，会循环从&lt;code&gt;LinkedBlockingQueue&lt;/code&gt;中获取任务执行&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为使用无界队列&lt;code&gt;LinkedBlockingQueue&lt;/code&gt;来存储不能执行的任务，所以不会触发拒绝服务策略，可能会导致&lt;code&gt;OOM&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2. newSingleThreadExecutor&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;SingleThreadExecutor&lt;/code&gt;是使用单个线程工作的线程池。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现源码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ExecutorService &lt;span&gt;newSingleThreadExecutor&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; FinalizableDelegatedExecutorService&lt;br/&gt;            (&lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;                                    &lt;span&gt;0L&lt;/span&gt;, TimeUnit.MILLISECONDS,&lt;br/&gt;                                    &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;()));&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接调用&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;的构造方法。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;核心线程数&lt;/code&gt;和&lt;code&gt;最大线程数&lt;/code&gt;都是1&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用&lt;code&gt;LinkedBlockingQueue&lt;/code&gt;作为任务队列&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;SingleThreadExecutor&lt;/code&gt;的运行流程：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.46943231441048033&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfqFyTjCUZqTyXKjB7K11x6LHF8FHB8icygz2XNBpFgTKEBWRYye7eN5bukk2X5Gq7vJ828mh06zPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;916&quot;/&gt;&lt;figcaption&gt;SingleThreadExecutor运行流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当前无运行线程，创建一个线程来执行任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当前有线程运行，将任务加入&lt;code&gt;LinkedBlockingQueue&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程执行完任务后，会循环从&lt;code&gt;LinkedBlockingQueue&lt;/code&gt;中获取任务来执行&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里用了无界队列&lt;code&gt;LinkedBlockingQueue&lt;/code&gt;，同样可能会导致&lt;code&gt;OOM&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3. newCachedThreadPool&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;CachedThreadPool&lt;/code&gt;是一个会根据需要创建新线程的线程池。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现源码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ExecutorService &lt;span&gt;newCachedThreadPool&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(&lt;span&gt;0&lt;/span&gt;, Integer.MAX_VALUE,&lt;br/&gt;                                      &lt;span&gt;60L&lt;/span&gt;, TimeUnit.SECONDS,&lt;br/&gt;                                      &lt;span&gt;new&lt;/span&gt; SynchronousQueue&amp;lt;Runnable&amp;gt;());&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接调用&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;的构造方法。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;核心线程数&lt;/code&gt;为0，&lt;code&gt;最大线程数&lt;/code&gt;是非常大的一个数字&lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用没有容量的&lt;code&gt;SynchronousQueue&lt;/code&gt;作为工作队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;keepAliveTime&lt;/code&gt;设置为60L，空闲线程空闲60秒之后就会被终止&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;CachedThreadPool&lt;/code&gt;的运行流程：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.745928338762215&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfqFyTjCUZqTyXKjB7K11x6B7bEt7VTpjusU8hdoQkBqibfhVq5hibZibfQWQpq7IDXkT3kQWJHntmVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;921&quot;/&gt;&lt;figcaption&gt;CachedThreadPool执行流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果当前有空闲线程，使用空闲线程来执行任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果没有空闲线程，创建一个新线程来执行任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;新建的线程执行完任务后，会执行&lt;code&gt;poll（keepAliveTime，TimeUnit.NANOSECONDS）&lt;/code&gt;,在&lt;code&gt;SynchronousQueue&lt;/code&gt;里等待60s&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里线程池的大小没有限制，可能会无限创建线程，导致&lt;code&gt;OOM&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4. newScheduledThreadPool&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ScheduledThreadPool&lt;/code&gt;是一个具备调度功能的线程池。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现源码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ScheduledExecutorService &lt;span&gt;newScheduledThreadPool&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; corePoolSize)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ScheduledThreadPoolExecutor(corePoolSize);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，这个线程池不太一样，它调用的是&lt;code&gt;ScheduledThreadPoolExecutor&lt;/code&gt;的构造方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;ScheduledThreadPoolExecutor&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; corePoolSize)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(corePoolSize, Integer.MAX_VALUE, &lt;span&gt;0&lt;/span&gt;, NANOSECONDS,&lt;br/&gt;              &lt;span&gt;new&lt;/span&gt; DelayedWorkQueue());&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;最大线程数是&lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;，无限大&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用&lt;code&gt;DelayedWorkQueue&lt;/code&gt;作为任务队列&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ScheduledThreadPoolExecutor&lt;/code&gt;执行任务的流程：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5436991869918699&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfqFyTjCUZqTyXKjB7K11x6mibLlAP7mOPJEBV72Iwj51ZficLrN9kQZxtae49Hnq4wfp9HoNEHVe9g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;984&quot;/&gt;&lt;figcaption&gt;ScheduledThreadPool执行流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要分为两大部分：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;调用&lt;code&gt;scheduleAtFixedRate()&lt;/code&gt;/&lt;code&gt;scheduleWithFixedDelay()&lt;/code&gt;方法，会向&lt;code&gt;DelayQueue&lt;/code&gt;添加一个&lt;code&gt;ScheduledFutureTask&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程池的线程从&lt;code&gt;DelayQueue&lt;/code&gt;中获取&lt;code&gt;ScheduledFutureTask&lt;/code&gt;，然后执行任务。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它同样可以无限创建线程，所以也存在&lt;code&gt;OOM&lt;/code&gt;的风险。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了实现周期性执行任务，&lt;code&gt;ScheduledThreadPoolExecutor&lt;/code&gt;对&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;进行了一些改造[4]：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;ScheduledFutureTask&lt;/code&gt;来作为调度任务的实现&lt;/p&gt;&lt;p&gt;它主要包含了3个成员变量&lt;code&gt;time(任务将要被执行的具体时间)&lt;/code&gt;、&lt;code&gt;sequenceNumber（任务的序号）&lt;/code&gt;、&lt;code&gt;period(任务执行的间隔周期)&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;使用&lt;code&gt;DelayQueue&lt;/code&gt;作为任务队列&lt;/p&gt;&lt;p&gt;&lt;code&gt;DelayQueue&lt;/code&gt;封装了了一个&lt;code&gt;PriorityQueue&lt;/code&gt;，会对对队列中的&lt;code&gt;ScheduledFutureTask&lt;/code&gt;进行排序，排序的优先级time&amp;gt;sequenceNumber。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5269978401727862&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfqFyTjCUZqTyXKjB7K11x6EWd3VEibe74WxVjw46lcUgDAsnOqrtJSqcNZ1oIiaKD9hO5CrkFrjIEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;926&quot;/&gt;&lt;figcaption&gt;ScheduledThreadPoolExecutor执行流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ScheduledThreadPoolExecutor&lt;/code&gt;的任务执行主要分为4步：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;线程池里的&lt;code&gt;线程1&lt;/code&gt;从&lt;code&gt;DelayQueue&lt;/code&gt;中获取已到期的&lt;code&gt;ScheduledFutureTask&lt;/code&gt;（DelayQueue.take()）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;线程1&lt;/code&gt;执行这个&lt;code&gt;ScheduledFutureTask&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;线程1&lt;/code&gt;修改&lt;code&gt;ScheduledFutureTask&lt;/code&gt;的&lt;code&gt;time&lt;/code&gt;变量为下次将要被执行的时间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;线程1&lt;/code&gt;把这个修改&lt;code&gt;time&lt;/code&gt;之后的&lt;code&gt;ScheduledFutureTask&lt;/code&gt;放回&lt;code&gt;DelayQueue&lt;/code&gt;中（DelayQueue.add()）&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Excutors自述：这，这……工具类出的问题不叫bug。虽然我偷懒不干活，还可能会OOM，但我还是一个好工具类，呜呜……&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：是啊，其实Excutors有什么错呢？它只是一个没得感情的工具类，有错的只是不恰当地用它的人。所以，知其然且知其所以然，搞懂原理，灵活应用。我们应该像一个士兵一样，不只是会扣动扳机，还会拆解保养枪械。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;我是三分恶，一个号称能文能武的全栈开发。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;点赞&lt;/strong&gt;、&lt;strong&gt;关注&lt;/strong&gt;不迷路，咱们下期见！&lt;/p&gt;&lt;/blockquote&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;big&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/big&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[1]. 《Java并发编程的艺术》&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[2]. &lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NjI1OTI4Nw==&amp;amp;mid=2247485573&amp;amp;idx=1&amp;amp;sn=d1c7a57cf12a531cdcfb9522be7f1175&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;讲真 这次绝对让你轻松学习线程池&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[3]. 小傅哥 《Java面经手册》&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[4]. 《Java并发编程之美》&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[5]. 阿里巴巴《Java开发手册》&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkwODE5ODM0Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdFLJg0sAOqwHB1mb24icMADUgxm1qZQft5aN3H37NAmQnOvpGB7J9JVHxC6NSiacxbBP1DYdhIAeyA/0?wx_fmt=png&quot; data-nickname=&quot;三分恶&quot; data-alias=&quot;Fighter3FullStack&quot; data-signature=&quot;一个号称能文能武，技术水平和外形匹配的Java程序员。基础、实战、原理、面试，这里都有，关注我，我们一起进步！&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最近建了一个技术交流群，里面大厂大佬云集，技术、面试、生活聊的热火朝天，我还会不定期分享精品技术资料，添加微信&lt;/span&gt;&lt;span&gt;&lt;strong&gt;ThirdFighter&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，拉你入群。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;512&quot; data-backw=&quot;512&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWedCUuwibYJXwr9JSKric9UR2YKhNPVJaiaSUXhKh77gibClibfex2RqLNjh4MqtoLN7qFkczibvmrdvMng/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;512&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>068c45e9eeab01a1a6506c6615f4fd8e</guid>
<title>记一次线上崩溃问题的排查过程</title>
<link>https://toutiao.io/k/u9yvoah</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzk0MzI4OTI1Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHhKgtwWvzaYZodgfpphdA6WWKEMXTn6ImCCCuEzlPKicNBcpzBUyjK1XicWwqIwusqLGpwyyOc87JPQ/0?wx_fmt=png&quot; data-nickname=&quot;高性能架构探索&quot; data-alias=&quot;gaoxingnengjiagouts&quot; data-signature=&quot;85后程序员，现任某互联网公司高级技术专家一职。分享一些工作中的心得，杂谈。聊聊架构，扯扯算法，就酱。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;br/&gt;&lt;section&gt;&lt;span&gt;关注上方&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;公众号&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，回复【&lt;/span&gt;&lt;span&gt;pdf&lt;/span&gt;&lt;span&gt;】，&lt;/span&gt;&lt;span&gt;免费获取计算机经典书籍&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是雨乐！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前几天，突然收到报警，线上服务崩溃，然后自动重启。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于正值双十一期间，业务以稳定为主，线上服务崩溃，这可不是一件小事，赶紧登陆线上服务器，分析原因，迅速解决。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;借助这篇文章，记录下整个崩溃的分析和解决过程。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;收到报警&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上午上班后，正在划水，突然收到邮件报警，如下：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.17757774140752863&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHhjEeQGc3zug9Ghf97icdW89PUocwvNMYtzicOH7qVOMte10uVF6AmR0yKHA2EqmNwaALZL7leGSiaIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2444&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;问题分析&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;马上登录线上服务器，gdb调试堆栈信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;堆栈信息如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#0  0x0000003ab9a324f5 in raise () from /lib64/libc.so.6&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#1  0x0000003ab9a33cd5 in abort () from /lib64/libc.so.6&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#2  0x0000003abcebea8d in __gnu_cxx::__verbose_terminate_handler() () from /usr/lib64/libstdc++.so.6&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#3  0x0000003abcebcbe6 in ?? () from /usr/lib64/libstdc++.so.6&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#4  0x0000003abcebcc13 in std::terminate() () from /usr/lib64/libstdc++.so.6&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#5  0x0000003abcebcd32 in __cxa_throw () from /usr/lib64/libstdc++.so.6&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#6  0x00000000006966bf in Json::throwRuntimeError(std::basic_string&amp;lt;char, std::char_traits&amp;lt;char&amp;gt;, std::allocator&amp;lt;char&amp;gt; &amp;gt; const&amp;amp;) ()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#7  0x0000000000681019 in Json::Reader::readValue() ()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#8  0x000000000068277c in Json::Reader::readArray(Json::Reader::Token&amp;amp;) ()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#9  0x0000000000681152 in Json::Reader::readValue() ()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#10 0x00000000006823a6 in Json::Reader::readObject(Json::Reader::Token&amp;amp;) ()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#11 0x00000000006810f5 in Json::Reader::readValue() ()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#12 0x0000000000680e6e in Json::Reader::parse(char const*, char const*, Json::Value&amp;amp;, bool) ()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#13 0x0000000000680c52 in Json::Reader::parse(std::basic_string&amp;lt;char, std::char_traits&amp;lt;char&amp;gt;, std::allocator&amp;lt;char&amp;gt; &amp;gt; const&amp;amp;, Json::Value&amp;amp;, bool) ()&lt;/span&gt;&lt;br/&gt;......&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面堆栈信息中可以看到在调用Json::Reader::parse后经过Json::Reader::readValue等调用,最后再调用Json::Reader::readValue时调用Json::throwRuntimeError抛出异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看调用Json::throwRuntimeError函数的地方：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;src/lib_json/json_writer.cpp:    throwRuntimeError(&lt;span&gt;&quot;commentStyle must be &#x27;All&#x27; or &#x27;None&#x27;&quot;&lt;/span&gt;);&lt;br/&gt;src/lib_json/json_reader.cpp:  &lt;span&gt;if&lt;/span&gt; (stackDepth_g &amp;gt;= stackLimit_g) throwRuntimeError(&lt;span&gt;&quot;Exceeded stackLimit in readValue().&quot;&lt;/span&gt;);&lt;br/&gt;src/lib_json/json_reader.cpp:  &lt;span&gt;if&lt;/span&gt; (stackDepth_ &amp;gt;= features_.stackLimit_) throwRuntimeError(&lt;span&gt;&quot;Exceeded stackLimit in readValue().&quot;&lt;/span&gt;);&lt;br/&gt;src/lib_json/json_reader.cpp:    &lt;span&gt;if&lt;/span&gt; (name.length() &amp;gt;= (1U&amp;lt;&amp;lt;30)) throwRuntimeError(&lt;span&gt;&quot;keylength &amp;gt;= 2^30&quot;&lt;/span&gt;);&lt;br/&gt;src/lib_json/json_reader.cpp:    throwRuntimeError(errs);&lt;br/&gt;src/lib_json/json_value.cpp:    throwRuntimeError(&lt;br/&gt;src/lib_json/json_value.cpp:    throwRuntimeError(&lt;br/&gt;src/lib_json/json_value.cpp:JSONCPP_NORETURN void throwRuntimeError(JSONCPP_STRING const&amp;amp; msg)&lt;br/&gt;src/lib_json/json_valueiterator.inl:  throwRuntimeError(&lt;span&gt;&quot;ConstIterator to Iterator should never be allowed.&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进入对应的函数&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;bool Reader::&lt;span&gt;&lt;span&gt;readValue&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (stackDepth_g &amp;gt;= stackLimit_g) throwRuntimeError(&lt;span&gt;&quot;Exceeded stackLimit in readValue().&quot;&lt;/span&gt;);&lt;br/&gt;  ++stackDepth_g;&lt;br/&gt;  ... ...&lt;br/&gt;  --stackDepth_g;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; successful;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发现，在满足条件&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;stackDepth_g &amp;gt;= stackLimit_g&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;的时候，会调用throwRuntimeError，那么分析下stackDepth_g和stackLimit_g的声明定义：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;static int const stackLimit_g = 1000;&lt;br/&gt;static int       stackDepth_g = 0; &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题基本明了：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;stackDepth_g是个静态全局变量,线程不安全,而出问题的服务是多线程的&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在此准备吐槽下，笔者使用jsoncpp对象的时候，都是在线程内部一个局部变量，因此不会存在多线程访问同一个局部jsoncpp对象的时候，因此确定就是因为全局变量多线程访问导致的。&lt;span&gt;一个开源的项目，里面竟然有全局变量，这在规范里面是不被允许的&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后谷歌搜索了下大家都有过类似的问题，再次吐槽下。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5413223140495868&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHhjEeQGc3zug9Ghf97icdW89S2gu6t3lBP6aEQJ4huY06ZctrYSITESQzCNGHUdT4TH9VUpyb14ziaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;726&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;问题解决&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解决崩溃问题，首先需要看看是不是使用方式的问题，或者找一个线程安全的接口，再或者用其他库进行替换。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;修改jsoncpp源码&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决线程安全的问题，有两种方案：1、在操作全局变量的时候，加上mutex，这个无非对性能要求很高的业务一个致命打击，为了提高业务性能，所以内部锁都使用其他方式进行了优化，比如mutex使用双buffer方式进行了替换，虽然mutex的一个加锁解锁过程也就100ns。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、将上述全局变量放入Json对象中，这样局部变量就不会存在崩溃现象，但是这种方案存在一个问题，就是改动点很大，且需要大量严格的测试，放弃。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以综合考虑上述两点，决定采用其他更安全可靠的方式来解决线上崩溃问题。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;使用rapidjson&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之所以采用rapidjson，是因为线上几十个服务，大部分都使用rapidjson，只有线上崩溃的这个服务等少数几个服务，因为历史原因，用的jsoncpp。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先介绍下rapidjson，下述内容来自于rapidjson官网:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;RapidJSON 是一个 C++ 的 JSON 解析器及生成器。它的灵感来自 RapidXml。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;RapidJSON 小而全。它同时支持 SAX 和 DOM 风格的 API。SAX 解析器只有约 500 行代码。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;RapidJSON 快。它的性能可与 strlen() 相比。可支持 SSE2/SSE4.2 加速。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;RapidJSON 独立。它不依赖于 BOOST 等外部库。它甚至不依赖于 STL。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;RapidJSON 对内存友好。在大部分 32/64 位机器上，每个 JSON 值只占 16 字节（除字符串外）。它预设使用一个快速的内存分配器，令分析器可以紧凑地分配内存。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;RapidJSON 对 Unicode 友好。它支持 UTF-8、UTF-16、UTF-32 (大端序／小端序)，并内部支持这些编码的检测、校验及转码。例如，RapidJSON 可以在分析一个 UTF-8 文件至 DOM 时，把当中的 JSON 字符串转码至 UTF-16。它也支持代理对（surrogate pair）及 &quot;\u0000&quot;（空字符）。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过rapidjson为了性能，在使用上面需要极其小心。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;笔者之前踩过类似坑，局部字符串赋值给rapidjson对象，结果rapidjson并没有马上使用该局部字符串，而是在最后才会访问局部字符串里面的内容，而此时，局部字符串早已出了作用域，导致rapidjson获取的内容是乱码。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;结语&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在使用开源项目的时候，一定要做好调研，必要的时候，能过一下源码实现(这个有点难😁)，否则很容易入坑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;笔者在使用libcurl作为httpclient的时候，也因为触发了libcurl的一个bug，导致线上崩溃，当时连续通宵了两个晚上，才解决。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一入C++深似海，从此XX是路人。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以候捷在&amp;lt;&amp;lt;STL 源码剖析&amp;gt;&amp;gt;上的一句话作为本文的结束语：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;源码之前，了无秘密。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;共勉。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6484cf17393a5a0cd2c01d36194fa236</guid>
<title>ElasticSearch 进阶之邻近匹配</title>
<link>https://toutiao.io/k/sis6yqe</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entry-inner&quot;&gt;
                                                    
&lt;p&gt;我们在之前的文章中介绍过标准的文本搜索，它会进行各个关键词的搜索，然后根据TF/IDF来计算相关性，最后再返回结果。这样的搜索能够根据我们搜索的关键词是否在相关的文本中存在来进行匹配，但是这还不够，它忽略了关键词之间的关系。本文就来介绍如何加入关键词之间关系的处理。&lt;/p&gt;



&lt;h1&gt;引言&lt;/h1&gt;



&lt;p&gt;我们来看一个例子，现在有下面两个文本：&lt;/p&gt;



&lt;ul&gt;&lt;li&gt;Dog beats the fox.&lt;/li&gt;&lt;li&gt;Fox beats the Dog.&lt;/li&gt;&lt;/ul&gt;



&lt;p&gt;现在我们来搜索fox beats dog，那么这两个文本其实是都可以匹配的，而且两个文本的相关性都是一样的，但是这两个文本的意思其实是相反的，我想我们在搜索的时候应该还是有倾向性希望能够区分他们两个的，比如说搜索fox beats dog的时候希望第二个文本的相关性分数要高一点，搜索dog beats fox的时候希望第一个文本的相关性分数要高一点。下面我们来看几种处理这个问题的方法。&lt;/p&gt;



&lt;h1&gt;短语匹配 （Phrase Matching）&lt;/h1&gt;



&lt;p&gt;短语匹配的思想很简单，就是当我搜索的时候除了每个词都需要匹配，还要求他们之间的位置也是一样的。比如说我们有一个文本”quick brown fox”，在搜索quick fox的时候，就不会相匹配，因为文本中的fox没有紧接在quick的后面。那要做到这一点，是如何实现的呢？&lt;/p&gt;



&lt;p&gt;首先在analyzed的时候就不仅需要列出每一个term，还需要列出相应term在文本中的位置信息，比如上面的文本在analyzed之后的结果如下：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-17.png&quot; alt=&quot;&quot; class=&quot;wp-image-1020&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-17.png 624w, https://donggeitnote.com/wp-content/uploads/2021/10/image-17-300x300.png 300w, https://donggeitnote.com/wp-content/uploads/2021/10/image-17-150x150.png 150w, https://donggeitnote.com/wp-content/uploads/2021/10/image-17-80x80.png 80w, https://donggeitnote.com/wp-content/uploads/2021/10/image-17-320x320.png 320w&quot; sizes=&quot;(max-width: 624px) 100vw, 624px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;我们可以清楚地看到每个term都有一个position的变量来保存它在原文本的位置信息。这个position的信息也是保存在Inverted Index中的，这样在短语匹配的时候就可以使用这些信息来进行判断了。&lt;/p&gt;



&lt;p&gt;当我们使用短语匹配来查询quick fox的时候，只有同时符合下面的情况才认为是匹配的：&lt;/p&gt;



&lt;ol type=&quot;1&quot;&gt;&lt;li&gt;Quick fox两个词必须都在文本中出现。&lt;/li&gt;&lt;li&gt;Fox的位置必须是quick的位置加1.&lt;/li&gt;&lt;/ol&gt;



&lt;h2&gt;Slop的使用&lt;/h2&gt;



&lt;p&gt;很显然上面这种限制太严格了，它要求fox必须在quick后面一个位置。其实我们主观上应该不会要求这么严格，比如说当我们查询quick fox的时候，我们还是希望“quick brown fox”能够被返回，毕竟在这个文本中quick fox都存在，而且相对位置也是一样的，唯一有问题的就是fox是在quick后面第二个，我们可以使用slop参数来进行处理：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-18.png&quot; alt=&quot;&quot; class=&quot;wp-image-1021&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-18.png 624w, https://donggeitnote.com/wp-content/uploads/2021/10/image-18-300x143.png 300w&quot; sizes=&quot;(max-width: 624px) 100vw, 624px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;这里的slop就是说term之间的最大多远的情况我们还是认为他们是匹配的。所谓的多远其实就是你需要移动几次才能让这个查询和文本一样。如下所示：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-19.png&quot; alt=&quot;&quot; class=&quot;wp-image-1022&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-19.png 624w, https://donggeitnote.com/wp-content/uploads/2021/10/image-19-300x83.png 300w&quot; sizes=&quot;(max-width: 624px) 100vw, 624px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;这里我们需要把fox向后移动一个位置就可以精准匹配，所以slop为1就足够了。&lt;/p&gt;



&lt;p&gt;需要注意的有了slop这个参数之后，其实term之间的顺序也是可以变的。比如说我们来看fox quick需要几步能匹配文本：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-20.png&quot; alt=&quot;&quot; class=&quot;wp-image-1023&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-20.png 624w, https://donggeitnote.com/wp-content/uploads/2021/10/image-20-300x106.png 300w&quot; sizes=&quot;(max-width: 624px) 100vw, 624px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;这里我们可以看到它首先把quick移到了位置1，然后把fox移到了位置2，也就是说我们进行一次term的交换其实是需要两个slop的。这样一来当slop设置为3的时候，我们的文本也是可以匹配fox quick的短语搜索。&lt;/p&gt;



&lt;h2&gt;多域搜索&lt;/h2&gt;



&lt;p&gt;我们在之前的文章《&lt;a href=&quot;https://donggeitnote.com/2021/10/02/elasticsearch-multiplesearch/&quot;&gt;ElasticSearch进阶之多域的搜索&lt;/a&gt;》中介绍了什么是多域搜索。这里短语匹配在多域搜索中其实也会存在一个问题，我们来看下面这个例子，我们有下面两个名字：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-21.png&quot; alt=&quot;&quot; class=&quot;wp-image-1024&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-21.png 624w, https://donggeitnote.com/wp-content/uploads/2021/10/image-21-300x59.png 300w&quot; sizes=&quot;(max-width: 624px) 100vw, 624px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;然后当我们搜索“Abraham Lincoln”的时候，它竟然也会返回，这是为什么呢？&lt;/p&gt;



&lt;p&gt;因为我们在analyzed的时候，产生的结果是Abraham位置2，Lincoln位置3，所以在查询的时候即使我们使用短语匹配，还是会认为Lincoln就是在Abraham之后一个位置，这显然不是我们想要的结果。这个问题说白了根源还是上面两个名字和”John Abraham Lincoln Smith”这个长的短语之间没有区别。为了解决这个问题我们可以设置position_offset_gap的值，如下所示：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-22.png&quot; alt=&quot;&quot; class=&quot;wp-image-1025&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-22.png 624w, https://donggeitnote.com/wp-content/uploads/2021/10/image-22-300x141.png 300w, https://donggeitnote.com/wp-content/uploads/2021/10/image-22-520x245.png 520w&quot; sizes=&quot;(max-width: 624px) 100vw, 624px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;Position_offset_gap就是告诉ElasticSearch，对数组里面的不同元素创建position的时候，每个之间加上这个间隔的值。所以这样设置之后我们会得到这个结果：&lt;/p&gt;



&lt;ul&gt;&lt;li&gt;John – 位置1.&lt;/li&gt;&lt;li&gt;Abraham – 位置2.&lt;/li&gt;&lt;li&gt;Lincoln – 位置103.&lt;/li&gt;&lt;li&gt;Smith – 位置104.&lt;/li&gt;&lt;/ul&gt;



&lt;p&gt;这样一来就自然而然解决了刚刚的问题。&lt;/p&gt;



&lt;h2&gt;邻近查询&lt;/h2&gt;



&lt;p&gt;这个时候也许你会问我们该如何设置slop的值比较合理呢？当你问出这个问题的时候，其实内心真实的想法是希望能够匹配到位置符合我们预期的文本，又不会丢失一些位置不是那么靠近的文本。这时候就轮到邻近查询出场了，它不会排除那些位置不符合的文本，而是把越靠近的文本赋予越高的分数，所以当我们按照分数的高低进行排序的时候，就自然而然能得到我们想要的结果。要想得到这个效果很简单就是把slop的值设置比较高，比如50,100之类的。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-23.png&quot; alt=&quot;&quot; class=&quot;wp-image-1026&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-23.png 624w, https://donggeitnote.com/wp-content/uploads/2021/10/image-23-300x137.png 300w&quot; sizes=&quot;(max-width: 624px) 100vw, 624px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;这样一来我们可以看到下面两个文本的结果：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-24.png&quot; alt=&quot;&quot; class=&quot;wp-image-1027&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-24.png 624w, https://donggeitnote.com/wp-content/uploads/2021/10/image-24-300x219.png 300w&quot; sizes=&quot;(max-width: 624px) 100vw, 624px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;第一个文本中quick和dog之间很靠近，所以它的分数就很高，而第二个文本quick和dog之间有很大的距离，所以分数就相对来说比较低。&lt;/p&gt;



&lt;h1&gt;参考邻近查询&lt;/h1&gt;



&lt;p&gt;虽然设置slop到一个比较大的值可以解决位置之间的问题，但是我们来回顾一下短语匹配的两个条件，一个是位置关系，另外一个是所有的term都必须在文本中出现，事实上很多时候，第二个必须所有term都出现的条件是有些苛刻的，比如我们希望只要有部分匹配就可以返回，但是精准匹配返回的分数要高一些，这个时候我们就可以把短语匹配作为一个条件要来提升最后分数的计算，如下所示：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-25.png&quot; alt=&quot;&quot; class=&quot;wp-image-1028&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-25.png 624w, https://donggeitnote.com/wp-content/uploads/2021/10/image-25-300x275.png 300w&quot; sizes=&quot;(max-width: 624px) 100vw, 624px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;这样一来，短语匹配作为一个should的条件，其实就是可以用来调整最后结果的相关性，而不会排除那些没有完全匹配的结果。&lt;/p&gt;



&lt;h1&gt;性能分析&lt;/h1&gt;



&lt;p&gt;短语匹配有个最大的问题就是性能问题， 也是可以理解的，比如说slop等于50的时候，我们需要进行位置和计算的量其实很大，尤其是文本数量很多的情况下，比如几百万的文本，那这个计算其实是很影响性能的。那么如何来提升这里的性能呢？ElasticSearch中引入了以下几个方法：&lt;/p&gt;



&lt;h2&gt;为结果重新打分&lt;/h2&gt;



&lt;p&gt;这个思想很简单，我们使用正常的搜索去进行匹配，但是在返回之前加入短语匹配来重新打分。这个重新打分是发生在每个shard的结果返回之前。这样一来其实需要重新计算数据量就很小，因为你只要处理每个shard的top k的结果就可以了，如下所示，使用rescore来实现：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-26.png&quot; alt=&quot;&quot; class=&quot;wp-image-1029&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/10/image-26.png 624w, https://donggeitnote.com/wp-content/uploads/2021/10/image-26-300x285.png 300w&quot; sizes=&quot;(max-width: 624px) 100vw, 624px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;这里的window_size就是每个shard中top k中的k的值。&lt;/p&gt;



&lt;h2&gt;找到关联词语&lt;/h2&gt;



&lt;p&gt;另外一种常见的改进性能的方法就是把句子中的一些短语先关联起来，比如说我们引言中提到的dog beats the fox，除了进行单独的term处理，它会还会被处理成下面这样：&lt;/p&gt;



&lt;p&gt;[“dog beats”, “beats the”, “the fox”]&lt;/p&gt;



&lt;p&gt;我们称这种单词对为shingles。当然你也可以组成三个或者更多的单词对。&lt;/p&gt;



&lt;p&gt;这样一来当用户搜索dog beats fox的时候，第一个文本的匹配度就自然提高了。当然对dog fox这样的搜索还是没有提升，但是所幸的是现实中大家可能还是会输入一些和文本顺序更加符合的查询条件。这也算是依赖现实而不是理论优化的一种了。&lt;/p&gt;



&lt;h1&gt;总结&lt;/h1&gt;



&lt;p&gt;至此本文就详细介绍了ElasticSearch中的邻近匹配相关的概念，希望大家能有所收获。&lt;/p&gt;
                                                    &lt;nav class=&quot;pagination group&quot;&gt;
                      &lt;/nav&gt;
        &lt;/div&gt;

        
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>