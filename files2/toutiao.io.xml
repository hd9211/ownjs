<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>405f3c9c27cb44e0f9ad2c75c771c3a8</guid>
<title>互联网基建成果，快速实现一个 Clubhouse 要多久</title>
<link>https://toutiao.io/k/1u192lr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近国外的一款基于语音的社交软件clubhouse掀起了一股热潮，尤其是在Eleon Musk的带动下，整个互联网圈内人都在第一时间抢先体验。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不管它为什么会火，肯定不是技术上有什么特别的优势。随着整个互联网技术生态的不断发展，互联网基础建设的不断完善，想快速实现一个产品，还是有很多的方案可以选择。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而今天给大家带来的是Github上的一个clubhouse的开源实现。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3333333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wokNJRf0ytqHoQSU39OwGcLQcOBAfn2alicxKP0qiceP1X6bV4xjMkgZGvOeocgRqvYX2Nrrog6oOwhuzjkozrNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;372&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;NesHouse 是一个基于 Agora、LeanCloud 服务，使用 Alpine.js 、Bulma Css、NES.css 构建的前端项目，这个项目实现了一套基于 NES 风格的 clubhouse，你可以使用 NESHouse 来创建自己的线上直播间，也可以将其分享出去，邀请别人一起参与讨论。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;特性&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;多聊天直播间支持&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;管理员权限&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;多主播同时发言&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;观众申请发言&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;管理员禁言主播&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;生成分享链接&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;界面&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7507163323782235&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wokNJRf0ytqHoQSU39OwGcLQcOBAfn2aIv1WaxUYYW0LsuI34NsBPaLEHJX4ye8lGwK7R0zdO4NGg98g1Q1C6A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;3490&quot;/&gt;&lt;img data-ratio=&quot;0.9211663066954644&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wokNJRf0ytqHoQSU39OwGcLQcOBAfn2aVaUfDWzrhcFad5WUh9OyLx73z020lon9SZ2icwArzwe80Gtrdg9vfIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1852&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;依赖服务&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;LeanCloud 国际版&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Agora.io 声网 +（非必需）Vercel&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;如何使用&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;使用流程&lt;/h4&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;注册一个 LeanCloud 国际账户，并创建一个项目，用于后续的项目配置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;注册一个 Agora 声网账号，并创建一个项目，获取 AppID。&lt;strong&gt;创建项目时请选择调试模式，仅 APPID 鉴权&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从 LeanCloud 的&lt;strong&gt;应用后台&lt;/strong&gt; - &lt;strong&gt;你使用的应用&lt;/strong&gt; - &lt;strong&gt;设置&lt;/strong&gt; - &lt;strong&gt;应用 Keys&lt;/strong&gt; 中找到 &lt;strong&gt;AppID&lt;/strong&gt; 和 &lt;strong&gt;AppKey&lt;/strong&gt;，将其记录下来，以备后用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从 LeanCloud 的&lt;strong&gt;应用后台&lt;/strong&gt; - &lt;strong&gt;你使用的应用&lt;/strong&gt; - &lt;strong&gt;存储&lt;/strong&gt; - &lt;strong&gt;服务设置&lt;/strong&gt; 中启用 &lt;strong&gt;Live Query&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在 LeanCloud 的&lt;strong&gt;应用后台&lt;/strong&gt; - &lt;strong&gt;你使用的应用&lt;/strong&gt; - &lt;strong&gt;存储&lt;/strong&gt; - &lt;strong&gt;结构化数据&lt;/strong&gt; ，并创建一个名为 &lt;strong&gt;RoomUser&lt;/strong&gt; 的 Class。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将上面记录的声网的应用 AppID 和 LeanCloud 的 AppID 和 APPkey 填写到 &lt;code&gt;js/config.js&lt;/code&gt; 顶部的配置中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将修改好的文件部署到你自己的服务器上，并配置域名指向。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;配置说明&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;js/config.js&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;const AVAPPID = &lt;span&gt;&quot;&quot;&lt;/span&gt; // LeanCloud AppID&lt;br/&gt;const AVAPPKEY = &lt;span&gt;&quot;&quot;&lt;/span&gt; // LeanCloud AppKey&lt;br/&gt;const BASEURL = &lt;span&gt;&quot;&quot;&lt;/span&gt; // 最终网页所在的路径，生成的分享链接会基于这个地址产生&lt;br/&gt;const DEFAULT_TEXT = &lt;span&gt;&quot;Please contact &amp;lt;a href=&#x27;mailto:bestony@linux.com&#x27;&amp;gt;bestony@linux.com&amp;lt;/a&amp;gt; to Learn more&quot;&lt;/span&gt; // 页面顶部展示的文字&lt;br/&gt;const AGORAAPPID = &lt;span&gt;&quot;&quot;&lt;/span&gt; // 声网服务的 AppID&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;Demo&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;创建房间: https://neshouse.com/admin.html&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;默认主页: https://neshouse.com/admin.html&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;Demo 使用流程&lt;/h4&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在 域名/admin.html 中输入房间名 &amp;amp; 用户昵称，创建一个新的房间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;点击下方的 &lt;strong&gt;Log in to chat room as Administrator&lt;/strong&gt; 以管理员身份登陆房间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;复制输入框内的链接，分享给你的朋友，邀请他们加入房间。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0c6be8255c5af2f2c376a22207372813</guid>
<title>Flink 的状态数据到底存到哪了？</title>
<link>https://toutiao.io/k/udxt0h1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.075&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/7s1EHEg3rgvQaStImm8DmibYlnqSTfWzL5BqclDC4g28vMgfyMf5S18VCMibnF1C6Jib47XiaIUoQdnm5XUDJpTodQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前看到群里好多同学提问：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Flink 状态存在 heap 中，作业失败下次重启从 State 恢复，是不是数据就丢了？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TM 本地状态恢复跟 Checkpoint 之间有什么关系？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Operator State 是不是只能存在 heap 中？&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.5052083333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/7s1EHEg3rgsiaPogXmN31KzlVTcwgbPkESsKOvh1PStJlDMGmwVMZicUibzuLNVe7AV2dUmNaxguFEgWBsD8aaPmQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;768&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果有类似的疑问，相信本文能让你彻底搞懂 Flink 的状态数据到底存到了哪里。想加群的小伙伴可以在公众号菜单栏右下角联系博主。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;0、结论&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照状态类型进行划分，State 分为 Operator State 和 KeyedState。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论何种 StateBackend，Operator State 在运行期间全部存储在 TM 的内存中。Checkpoint 时，MemoryStateBackend 会将状态数据保存到 JM 的内存中。其他 StateBackend 会将状态数据保存到 hdfs。对应表格：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;StateBackend类型&lt;/th&gt;&lt;th&gt;运行过程中存储位置&lt;/th&gt;&lt;th&gt;Checkpoint存储位置&lt;/th&gt;&lt;th&gt;适用场景&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;memory&lt;/td&gt;&lt;td&gt;TM 内存中&lt;/td&gt;&lt;td&gt;JM 内存中&lt;/td&gt;&lt;td&gt;调试（生产环境严禁使用）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;filesystem&lt;/td&gt;&lt;td&gt;TM 内存中&lt;/td&gt;&lt;td&gt;hdfs&lt;/td&gt;&lt;td&gt;生产环境&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Rocksdb&lt;/td&gt;&lt;td&gt;TM 内存中&lt;/td&gt;&lt;td&gt;hdfs&lt;/td&gt;&lt;td&gt;生产环境&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;KeyedState 的存储表格如下所示：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;StateBackend类型&lt;/th&gt;&lt;th&gt;运行过程中存储位置&lt;/th&gt;&lt;th&gt;Checkpoint存储位置&lt;/th&gt;&lt;th&gt;适用场景&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;memory&lt;/td&gt;&lt;td&gt;TM 内存中&lt;/td&gt;&lt;td&gt;JM 内存中&lt;/td&gt;&lt;td&gt;调试（生产环境严禁使用）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;filesystem&lt;/td&gt;&lt;td&gt;TM 内存中&lt;/td&gt;&lt;td&gt;hdfs&lt;/td&gt;&lt;td&gt;状态较小的场景，性能极高&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Rocksdb&lt;/td&gt;&lt;td&gt;TM 本地的 RocksDB 中&lt;/td&gt;&lt;td&gt;hdfs&lt;/td&gt;&lt;td&gt;大状态场景&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果对表格内容有一些疑惑，可以详细阅读下文。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大多数场景使用的都是 KeyedState，所以先分析 KeyedState 中的数据存储。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1、 keyedState 数据存储&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1 KeyedState 的类型&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;众所周知：Flink 支持三种 StateBackend，分别是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;memory 模式：MemoryStateBackend&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;filesystem 模式：FsStateBackend&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;rocksdb 模式：RocksDBStateBackend&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不要被名字所迷惑，之前看到有同学在群里提问：filesystem 模式（FsStateBackend）会将状态数据存储在 hdfs 上，那读写性能会不会很差呢？是不是线上必须用 memory 模式或 rocksdb 模式呢？如果有这样的疑惑，显然是对 StateBackend 不了解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述问题的答案是这样的：生产环境不能使用 memory 模式，只能使用 filesystem 和 rocksdb 模式，且 filesystem 模式性能极高。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2 StateBackend 的作用&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;StateBackend 在 Flink 中的作用是存储状态数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：计算 pv 的场景，无论当前的 pv 值是 100 还是 500，都需要存储起来。pv 值将会存储在 StateBackend 中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：计算 uv 的场景需要按照 userId 进行去重，必然要将所有的 userId 存储起来。这些 userId 就会存储在 StateBackend 中。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.3 不同的 StateBackend 是如何工作的？&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.3.1 小状态场景，如何提供高性能的状态存储？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些场景，状态数据特别小，所以 StateBackend 将状态数据放在内存中是个不错的选择。小数据量仅占用很少的内存空间，大部分任务都可以提供这些内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;memory 模式（MemoryStateBackend）和 filesystem 模式（FsStateBackend）就是用到了这种思路，将状态数据存储在 TM 的内存中，而且使用类似于 HashMap 的 hash 结构。无论是查询还是写入的时间复杂度都可以达到 O(1)，从而提供了非常高的性能。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.3.2 大状态场景，如何提供高性能的状态存储？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果状态数据比较大，全放到内存中就会占用大量的内存，需要大量的经济成本。而且当状态数据比较大时，可能有一部分数据是热数据，一部分数据是冷数据，冷数据访问频率特别低也没必要全部放到内存中。所以大状态场景，数据全部存储在内存中可能不切合实际。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单的思路热数据放到 TM 内存中，冷数据放到 TM 的磁盘上。热数据放到内存中可以保障提供更高的性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;思路很简单，具体如何落地呢？其实 Flink 也不用重复造轮子，直接嵌入一个数据库即可，将数据库嵌入到 TM 的进程内。这里使用一个成熟的嵌入式数据库有非常大的好处，总结如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;成熟的数据库一般性能都比较强，可以提供非常高的查询和写入性能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;成熟的数据库一般稳定性比较高，不会经常时不时的出现 bug 或出现其他问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;成熟的数据库必然考虑了冷热数据的问题，如果使用数据库 Flink 不用考虑这些事情&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从 0 到 1 打造出一个完全适合 Flink 的高性能状态存储需要非常大的人力成本，所以 Flink 初期先使用业界成熟的数据库是个不错的选择&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是 RocksDBStateBackend 就诞生了。RocksDB 是一个嵌入式、持久化的高性能 KV 存储。Flink 的 RocksDBStateBackend 使用 RocksDB 数据库存储 Flink 的状态数据。RocksDB 会使用内存和 TM 的本地磁盘做为存储介质。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.3.3 状态存储如何保障高可用？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;memory 模式（MemoryStateBackend）和 filesystem 模式（FsStateBackend）会将状态数据存储在 TM 的内存中。rocksdb 模式（RocksDBStateBackend）会将状态数据存储在 TM 本地的 RocksDB 数据库中，也就是存储在 TM 的内存和本地磁盘中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题来了，上述三种模式无论将状态数据存储在内存还是磁盘，其实都是在 TM 本地。如果 TM 所在的机器出现故障，就会有丢状态的问题。也就是分布式系统中常见的单点故障。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Flink 做为一个成熟的流计算引擎，对外宣称可以实现 Exactly Once。为了实现业务上的 Exactly Once，Flink 肯定不能丢数据，也就是状态数据必须保障高可靠性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Flink 依赖 Checkpoint 机制实现了状态数据的高可用。Checkpoint 时，各种 StateBackend 都会进行快照。通俗的来讲，就是将 TM 中的状态数据备份一份到其他存储介质。例如：filesystem 模式（FsStateBackend）在 Checkpoint 时，将 TM 内存中的所有状态数据写一份到 hdfs 上从而保障状态数据的高可用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里就很清晰了：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;任务运行过程中为了保障高性能，所以状态数据存储在 TM 的内存或者磁盘上&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TM 存在单点故障，所以 Checkpoint 定期将 TM 中的状态写入到外部存储介质（例如 hdfs）来保障高可用&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.3.4 Checkpoint 时数据分别存到哪里了？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;memory 模式（MemoryStateBackend）在 Checkpoint 时将状态数据存储在 JM 的内存中，所以仍然存在状态丢失的风险。Flink 官方强调 memory 模式（MemoryStateBackend） 仅适用于调试模式。读到这里相信大家不会在生产环境使用 memory 模式（MemoryStateBackend）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;filesystem 模式（FsStateBackend）在 Checkpoint 时将状态数据存储在文件系统（file system）中，这也是为什么命名为 filesystem 模式（FsStateBackend）。当然这里可以写各种文件系统（file system），例如：HDFS、S3、GFS、NFS、Ceph 等。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注：memory 模式（MemoryStateBackend）和 filesystem 模式（FsStateBackend）在运行过程中的存储结构完全一致，复用的同一套代码（HeapKeyedStateBackend），只是 Checkpoint 时数据写入的位置不同。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;rocksdb 模式（RocksDBStateBackend）在 Checkpoint 时与 filesystem 模式类似，可以将状态数据存储在各种文件系统（file system）中。同时 RocksDB 目前支持全量 Checkpoint 和增量 Checkpoint。后续再分析两者区别。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.4 keyedState 数据存储总结&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;keyedState 支持三种不同的 StateBackend，三种 StateBackend 都要从两个维度去考虑：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;任务运行过程中，StateBackend 将数据存储在哪里？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为了保障高可用，Checkpoint 时StateBackend 将数据存储在哪里？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过一个表格总结一下：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;StateBackend类型&lt;/th&gt;&lt;th&gt;运行过程中存储位置&lt;/th&gt;&lt;th&gt;Checkpoint存储位置&lt;/th&gt;&lt;th&gt;适用场景&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;memory&lt;/td&gt;&lt;td&gt;TM 内存中&lt;/td&gt;&lt;td&gt;JM 内存中&lt;/td&gt;&lt;td&gt;调试（生产环境严禁使用）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;filesystem&lt;/td&gt;&lt;td&gt;TM 内存中&lt;/td&gt;&lt;td&gt;hdfs&lt;/td&gt;&lt;td&gt;状态较小的场景，性能极高&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Rocksdb&lt;/td&gt;&lt;td&gt;TM 本地的 RocksDB 中&lt;/td&gt;&lt;td&gt;hdfs&lt;/td&gt;&lt;td&gt;大状态场景&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2、 Operator State 数据存储&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Flink 支持三种 StateBackend，但三种 StateBackend 上的 Operator State 在运行期间没有任何区别，都存储在内存中（对应代码 DefaultOperatorStateBackend）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常情况下 Operator State 的状态数据量都比较小，所以 Flink 统一都放在了内存中。常见的使用 Operator State 的场景：source offset、buffer 等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Operator State 比较简单，不多介绍了，放一张表格总结一下：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;StateBackend类型&lt;/th&gt;&lt;th&gt;运行过程中存储位置&lt;/th&gt;&lt;th&gt;Checkpoint存储位置&lt;/th&gt;&lt;th&gt;适用场景&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;memory&lt;/td&gt;&lt;td&gt;TM 内存中&lt;/td&gt;&lt;td&gt;JM 内存中&lt;/td&gt;&lt;td&gt;调试（生产环境严禁使用）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;filesystem&lt;/td&gt;&lt;td&gt;TM 内存中&lt;/td&gt;&lt;td&gt;hdfs&lt;/td&gt;&lt;td&gt;生产环境&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Rocksdb&lt;/td&gt;&lt;td&gt;TM 内存中&lt;/td&gt;&lt;td&gt;hdfs&lt;/td&gt;&lt;td&gt;生产环境&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上述表格可以看出，filesystem 和 Rocksdb 模式的 Operator State 没有任何区别。如果要在两者之前做选择，请根据 KeyedState 的大小去做选择。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3、 总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;KeyedState 数据存储总结：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;StateBackend类型&lt;/th&gt;&lt;th&gt;运行过程中存储位置&lt;/th&gt;&lt;th&gt;Checkpoint存储位置&lt;/th&gt;&lt;th&gt;适用场景&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;memory&lt;/td&gt;&lt;td&gt;TM 内存中&lt;/td&gt;&lt;td&gt;JM 内存中&lt;/td&gt;&lt;td&gt;调试（生产环境严禁使用）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;filesystem&lt;/td&gt;&lt;td&gt;TM 内存中&lt;/td&gt;&lt;td&gt;hdfs&lt;/td&gt;&lt;td&gt;状态较小的场景，性能极高&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Rocksdb&lt;/td&gt;&lt;td&gt;TM 本地的 RocksDB 中&lt;/td&gt;&lt;td&gt;hdfs&lt;/td&gt;&lt;td&gt;大状态场景&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Operator State 数据存储总结：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;StateBackend类型&lt;/th&gt;&lt;th&gt;运行过程中存储位置&lt;/th&gt;&lt;th&gt;Checkpoint存储位置&lt;/th&gt;&lt;th&gt;适用场景&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;memory&lt;/td&gt;&lt;td&gt;TM 内存中&lt;/td&gt;&lt;td&gt;JM 内存中&lt;/td&gt;&lt;td&gt;调试（生产环境严禁使用）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;filesystem&lt;/td&gt;&lt;td&gt;TM 内存中&lt;/td&gt;&lt;td&gt;hdfs&lt;/td&gt;&lt;td&gt;生产环境&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Rocksdb&lt;/td&gt;&lt;td&gt;TM 内存中&lt;/td&gt;&lt;td&gt;hdfs&lt;/td&gt;&lt;td&gt;生产环境&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4316ad0c19ab3b038e6f2d26aa217332</guid>
<title>TypeScript 的 Substitutability</title>
<link>https://toutiao.io/k/2k5jqh2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;&lt;img src=&quot;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb4b728e83a34f449f3c6cdd078e6b68%7Etplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Substitutability&lt;/code&gt; 中文含义是 可代替性，这个词我未在 &lt;code&gt;TypeScript&lt;/code&gt; 的语言特性相关文档上看到，百度、谷歌搜索也寥寥无几。仅在[TypeScript FAQ] 找到相关描述。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;有关类型系统的许多答案都提到了可替代性。 这是一个原则，即如果可以使用对象&lt;code&gt;X&lt;/code&gt;代替某些对象&lt;code&gt;Y&lt;/code&gt;，则&lt;code&gt;X&lt;/code&gt;是&lt;code&gt;Y&lt;/code&gt;的子类型。我们通常也说&lt;code&gt;X&lt;/code&gt;可以分配给&lt;code&gt;Y&lt;/code&gt;（这些术语在&lt;code&gt;TypeScript&lt;/code&gt;中的含义略有不同，但是 区别在这里并不重要）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这段描述很好理解，大体就是子类型可以用在父类型出现的地方。但实际涉及的&lt;code&gt;TypeScript&lt;/code&gt;使用场景，和这个词不是很契合，也许是语言的差异，中文含义不便于理解。&lt;/p&gt;

&lt;p&gt;实际 &lt;code&gt;Substitutability&lt;/code&gt; 解决的场景是：&lt;code&gt;TypeScript&lt;/code&gt; 允许 &lt;code&gt;function&lt;/code&gt; 作为回调函数时，入参个数、返回类型可以不符合方法签名。&lt;/p&gt;

&lt;h2&gt;回调 Function 入参比签名少&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;fetchResults&lt;/code&gt; 有一个参数，即回调函数。 该方法从某处获取数据，然后执行回调。 回调的方法签名有两个参数， &lt;code&gt;statusCode&lt;/code&gt; 和&lt;code&gt;results&lt;/code&gt; 。 &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function fetchResults(callback: (statusCode: number, results: number[]) =&amp;gt; void) {
  const results = [1,2,3];
  ...
  callback(200, results); 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们用下面的方式调用 &lt;code&gt;fetchResults&lt;/code&gt;，注意方法签名是不同的，它没有第二个参数 &lt;code&gt;results&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function handler(statusCode: number) {
  // 业务处理
  ...
}

fetchResults(handler); // ✔️
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以正常编译，没有任何错误或警告。 看起来有点奇怪，但细想一下，你一直在这么用。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Array.prototype.forEach&lt;/code&gt;方法签名&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /**
     * Performs the specified action for each element in an array.
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
     * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    forEach(callbackfn: (value: T, index: number, array: T[]) =&amp;gt; void, thisArg?: any): void
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际使用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let items = [1, 2, 3];
items.forEach(arg =&amp;gt; console.log(arg));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在运行时，forEach使用三个参数(value、index、array)调用给定的回调函数，但大多数时候回调函数只使用其中的一个或两个参数。&lt;/p&gt;

&lt;p&gt;那为什么不干脆将forEach 参数声明为可选。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;forEach(callback: (element?: T, index?: number, array?: T[]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果声明为可选，由于回调的提供者不知道调用方何时会传递多少参数，将不得不检查各个参数，这显然不是你想要的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function maybeCallWithArg(callback: (x?: number) =&amp;gt; void) {
    if (Math.random() &amp;gt; 0.5) {
        callback();
    } else {
        callback(42);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;声明非可选，是站在调用者的角度，保证按声明传递参数，可以兼容需要不同个数参数的回调函数；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这么处理的合理性在于，回调函数自身是最了解如何处理入参的，如果它不关心某些入参，它可以安全的忽略。&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;回调返回类型不匹配签名 return void&lt;/h2&gt;

&lt;p&gt;如果函数类型指定返回类型 void，则也接受具有不同的、更具体的返回类型的函数。同样，用前面的例子，这次增加handle的返回类型声明。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function handler(statusCode: number): {age:number}{
  //  业务处理
  ...
  return {&quot;age&quot;: 4};
}

fetchResults(handler); // ✔️
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;fetchResults 接受的回调函数返回类型是void，而这次的handler 返回&lt;code&gt;{age:number}&lt;/code&gt;类型，依然正常编译。&lt;/p&gt;

&lt;p&gt;你依然可以将callback结果赋值给一个变量，但仅仅限于声明语句，其他操作都将编译失败。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function fetchResults(callback: (statusCode: number, results: number[]) =&amp;gt; void) {
  const results = [1,2,3];
  ...
  let didItWork = callback(200, results); // ✔️  1）
  console.log(didItWork); // ✔️
  console.log(didItWork.age) // ❌
  didItWork = {&quot;age&quot;: 4} ; // ❌
}

// 注意虽然编译报错，但不影响最后js执行，Playground 运行结果
[LOG]: {
  &quot;age&quot;: 4
} 
[LOG]: 4 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可能有人困惑既然void类型无法进行其他操作，为什么要允许1）处赋值void类型给变量。TypeScript 1.4语言规范 给出了如下说明：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注意：我们考虑过禁止声明Void类型的变量，因为它们没有用处。 但是，由于允许将Void作为泛型类型或函数的类型参数，因此不允许Void属性或参数是不可行的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;function foo&amp;lt;T&amp;gt;(param:T) {
   let localParam:T = param;
}
foo&amp;lt;number&amp;gt;(3); // ✔️
foo&amp;lt;void&amp;gt;(undefined); // ✔️
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;这么处理的合理性在于，回调函数的调用者通过声明callback 返回void, 它最清楚也可以保证返回值不会被使用。&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c51a771581260fcf09a94aac5b353cac</guid>
<title>小步发布、验收测试和完整团队</title>
<link>https://toutiao.io/k/2z99lmo</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;main class=&quot;post-styles_main__2vaxQ&quot;&gt;&lt;p class=&quot;zh-cn&quot;&gt;在&lt;a href=&quot;https://teobler.com/posts/20210201-agile-business-practice-planning-games&quot;&gt;上一篇文章&lt;/a&gt;中我们花比较大的篇幅介绍了敏捷业务实践中的计划游戏，在这篇文章中我们将介绍介绍生命之环中外围剩下的三个业务实践。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;&lt;img src=&quot;https://teobler-image.s3-us-west-1.amazonaws.com/142240.png&quot; alt=&quot;life-cycle&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;小步发布&quot;&gt;小步发布&lt;/h2&gt;
&lt;p class=&quot;zh-cn&quot;&gt;&lt;img src=&quot;https://teobler-image.s3-us-west-1.amazonaws.com/101624.png&quot; alt=&quot;ci_cd_circle&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;小步发布这一业务实践&lt;strong&gt;建议开发团队应该尽可能频繁地发布软件&lt;/strong&gt;。在敏捷早期，这个时间节点大概是“一到两个月”。现如今，发布周期的目标是无限短，即&lt;strong&gt;持续交付&lt;/strong&gt;：每次代码更改后就将代码发布到生产环境中。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;虽然缩短的是发布周期，但其实小步发布这个实践的&lt;strong&gt;真正目的在于缩短所有周期&lt;/strong&gt;。但是由于源代码管理的历史原因，缩短周期这件事情从根本上就会面临很大的历史惯性。这一切要从软件行业早期开始讲起。&lt;/p&gt;
&lt;h3 id=&quot;纸带打孔时期&quot;&gt;纸带打孔时期&lt;/h3&gt;
&lt;p class=&quot;zh-cn&quot;&gt;在软件行业刚刚兴起的时候，所有的”代码“是储存在打孔纸卡上的。一张纸带可以容纳 80 个字符，代表一行程序。程序本身由这样一张张的纸卡组成，最终整个程序将是一大箱成捆的纸卡。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;&lt;img src=&quot;https://teobler-image.s3-us-west-1.amazonaws.com/110932.jpg&quot; alt=&quot;dakong&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;这些纸卡被存放在柜子里，如果有人想修改代码，这需要签出源代码，在获得所有者的许可后，便可以从柜子里清点出要修改的那部分代码 - 这是真正的签出源代码。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;这时由于你从物理角度获得了源代码，意味着只有你有资格修改这部分代码，其他人都碰不到它。只有等你完成了修改，将源代码存回柜子里，其他人才有机会修改。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;这个时间周期不固定，可能是几天、几周甚至是几个月。&lt;/p&gt;
&lt;h3 id=&quot;磁带时期&quot;&gt;磁带时期&lt;/h3&gt;
&lt;p class=&quot;zh-cn&quot;&gt;&lt;img src=&quot;https://teobler-image.s3-us-west-1.amazonaws.com/111316.jpg&quot; alt=&quot;tape_storage&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;后来随着科技的发展，代码开始存储在磁带上，除了容量更大，也更容易被复制了。此时修改代码变成了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从母带架上取出母带。&lt;/li&gt;
&lt;li&gt;将要编辑的代码从母带上复制到你自己的工作磁带。&lt;/li&gt;
&lt;li&gt;放回母带，其他人可以继续复制。&lt;/li&gt;
&lt;li&gt;将彩色大头钉固定在你正在编辑的模块旁边的签出板上，一个人使用一种单独的颜色(然后人多就会用完所有颜色)。&lt;/li&gt;
&lt;li&gt;在你自己的工作磁带上进行编辑、编译和测试。&lt;/li&gt;
&lt;li&gt;再次取出母带。&lt;/li&gt;
&lt;li&gt;将更改完成的模块从工作磁带赋值回母带中。&lt;/li&gt;
&lt;li&gt;将新的母带放到母带架上。&lt;/li&gt;
&lt;li&gt;从签出板上取回你的大头钉。&lt;/li&gt;
&lt;/ol&gt;
&lt;p class=&quot;zh-cn&quot;&gt;这时的好处是你不再在物理上拥有源代码，这代表着别人可以同时修改不同的模块，但这也就意味着别人可以不遵守约定，偷偷修改你正在修改的模块。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;这时的工作周期有一定的缩短，变成了几个小时、几天或者是几周。&lt;/p&gt;
&lt;h3 id=&quot;磁盘和源代码管理系统的出现&quot;&gt;磁盘和源代码管理系统的出现&lt;/h3&gt;
&lt;p class=&quot;zh-cn&quot;&gt;再后来源代码的存储介质变成了磁盘，但是仍然使用大头钉的方式来标记谁在修改哪一模块的代码。然后真正的源代码管理工具出现了。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;早期的其中一个源代码管理系统 Source Code Control System(SCCS)。SCCS 的行为与签出板一样，将模块以悲观锁(Pessimistic Lock)的方式锁定在磁盘上，防止别人编辑。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;后来 SCCS 被 版本控制系统 RCS(Revision Control System) 取代，然后 RCS 又被并发版本系统 CVS(Concurrent Version System) 所取代。这些工具在进行微小改良的同时本质都没有改变 - 都是使用悲观锁来控制相应模块不发生冲突。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;虽然此时的周期还是不短，但是磁盘允许我们极大地缩小模块的规模。&lt;strong&gt;模块的小型化有效地缩短了周期时间，因为模块越小，保持签出状态进行修改完成的时间就越短。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;subversion&quot;&gt;Subversion&lt;/h3&gt;
&lt;p class=&quot;zh-cn&quot;&gt;Subversion(SVN) 与上述工具不同，其提供了乐观锁。这使得多个开发人员可以同时签出一个模块。SVN 工具会对此进行追踪，并自动将多人的更改合并到模块中。如果有冲突，则要求先解决冲突才允许签入代码。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;这样的流程会大大缩短周期时间，使其缩短至编辑、编译和测试一系列小更改所需的时间。&lt;strong&gt;此时签出时间不在是制约周期时间的因素，主要因素变成了修改紧耦合代码所产生的冲突。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;git&quot;&gt;Git&lt;/h3&gt;
&lt;p class=&quot;zh-cn&quot;&gt;如今我们使用 Git，此时已经没有签出时间这个概念了(当然，除了那些超大型的代码库)。程序员可以在任何时间提交对模块的任何修改。如果这些模块出现了冲突，程序员可以在任何时候来解决冲突。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;充分解耦的小模块和快速的小步提交共同作用，使得周期时间可以缩短至几分钟。在此基础上覆盖以全面、运行快捷、几乎可以测试任何功能的自动化套件，你就具备了持续交付(Continuous Delivery, CD)的条件。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;**小步发布的目的不仅仅是为了缩短发布周期。**为了实现缩短发布周期这个目的，大家就必须使自己的代码充分解耦，同时采用小步快速提交的策略，将自己的修改快速提交到代码库。而为了使得自己的小步修改是可工作的，又要求有一系列的测试套件来保证代码质量。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;而为了缩短发布周期，组织需要打破发布和部署之间的耦合。最终，&lt;strong&gt;“是否要部署”只是一个业务决策，每一次决定部署，都已经变成了一次发布。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;验收测试&quot;&gt;验收测试&lt;/h2&gt;
&lt;p class=&quot;zh-cn&quot;&gt;&lt;img src=&quot;https://teobler-image.s3-us-west-1.amazonaws.com/111608.jpg&quot; alt=&quot;atdd&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;最令人困惑的实践&quot;&gt;最令人困惑的实践&lt;/h3&gt;
&lt;p class=&quot;zh-cn&quot;&gt;验收测试这一敏捷实践的基本思想是：**应该由业务方负责说明需求的规格。**而问题恰恰出在&lt;em&gt;规格说明&lt;/em&gt;上。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;许多业务方认为这个词的意思是：我只需要随便比划两下，用几句含糊不清的话来描述我的需求，开发人员就应该自己能够找到所有的细节。而程序员们又希望业务方能够精确定义系统应该做什么，最好能够描述清楚每一个细节。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;而我们所需要的其实是介于这两个极端之间的关系。规格说明从某种意义上来讲，本质是一种测试，比如：&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;&lt;em&gt;当用户输入有效的用户名和密码，点击登录按钮，系统将跳转到欢迎界面。&lt;/em&gt;&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;这就是一个标准的规格说明，但仔细想想，这也是一个标准的测试用例，并且这个测试用例是可以被自动化的。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;其实这个实践指的是：**只要可行，系统的需求就应该写成自动化测试。**虽然看起来简单，但这个实践是所有敏捷实践中最不被理解、使用最少，也最混乱的实践。下面这几个问题将为你揭晓为什么会有这样的情况：&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;首先是，谁来写这些测试呢？如果按照本节第一句话描述的基本思想来说，既然规格说明是业务方提出来的，那么是不是应该由业务方来写这些测试呢？&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;下一个问题是，大部分业务方其实并不具备编写代码的能力，编写代码不应该是程序员的工作吗？&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;但是如果是程序员来写这些测试的话，他们会以以技术的思维来写，并不会以业务的思维来写。这意味着这些测试除了他们自己谁也看不懂，因为里面充满了技术细节。所以这个问题还是推回给了业务方，应该由他们来编写。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;但是如果由业务方来编写，他们可能采用与团队完全不相符的技术栈，这意味着我们得重写这些测试以符合我们的技术栈。&lt;/p&gt;
&lt;h3 id=&quot;尝试解决&quot;&gt;尝试解决&lt;/h3&gt;
&lt;p class=&quot;zh-cn&quot;&gt;实践混乱，就会催生出一系列尝试解决混乱的工具和方法论。FitNesse、JBehave、SpecFlow 和 Cucumber 等工具就是程序员们开发出来为了解决这些问题的工具。它们尝试将这些自动化测试的技术面和业务面分开。由业务方编写测试的业务端，程序员编写粘合代码将这些测试和被测系统绑定起来。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;虽然梦想是美好的，但是业务方很是不愿意参与进来，比起形式化的语言，他们更希望用人类的语言，来编写这些规格说明。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;于是程序员又做了一步妥协，他们编写测试但希望业务方至少能够去阅读代码形式化的文档，并验证测试是否正确，但业务方更想吧这样的工作交给 QA。&lt;/p&gt;
&lt;h3 id=&quot;行为驱动开发&quot;&gt;行为驱动开发&lt;/h3&gt;
&lt;p class=&quot;zh-cn&quot;&gt;&lt;img src=&quot;https://teobler-image.s3-us-west-1.amazonaws.com/111935.png&quot; alt=&quot;BDD&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;在千禧年之后，丹·诺斯(Dan North) &lt;a href=&quot;https://dannorth.net/introducing-bdd/&quot;&gt;尝试重新定义 TDD&lt;/a&gt;，他称之为 &lt;a href=&quot;https://en.wikipedia.org/wiki/Behavior-driven_development&quot;&gt;BDD&lt;/a&gt;(Behavior-Driven Development, 行为驱动开发)。他的目标是从测试中去掉技术术语，使测试让业务方看起来更讨喜。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;BDD 的支持者建议，业务方可以不写测试，但是希望他们能够以一种形式化的、基于场景的语言(比如 Given-When-Then)来详细描述他们的系统，这样的语言对程序员编写测试也有巨大的价值。&lt;/p&gt;
&lt;h3 id=&quot;合作与实践&quot;&gt;合作与实践&lt;/h3&gt;
&lt;p class=&quot;zh-cn&quot;&gt;既然大家都不愿意一个人完成所有的事情，那如果大家一起来呢？实践的目的没有改变，还是&lt;strong&gt;只要可行，系统的需求就应该写成自动化测试&lt;/strong&gt;。但是方式应该是&lt;strong&gt;业务方编写形式化的测试来描述每个用户故事的行为，开发人员将这些测试自动化。&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;回到最开始的问题，谁来写？答案是业务分析师(BA)和 QA，至于为什么，我们会在稍后解释。他们需要在迭代的前半部分之前完成测试的编写，然后程序员完成故事的开发并将这些测试集成到持续构建(CI)中。只有完成了测试的编写并且代码通过了所有测试，故事才算完成。&lt;/p&gt;
&lt;h4 id=&quot;业务分析师和-qa&quot;&gt;业务分析师和 QA&lt;/h4&gt;
&lt;p class=&quot;zh-cn&quot;&gt;业务分析师负责澄清和理解需求方的需求，然后负责说明功能的乐观途径(happy path)，因为他们需要作为中间人在需求方和程序员之间做大量沟通，没有精力描述所有悲观途径(unhappy path)。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;而 QA 的工作是写出所有悲观途径，他们是既了解业务又拥有很强技术的人。他们能够站在业务和用户的角度找出如何破坏系统的方法，同时他们还能了解程序员的思路，戳穿他们的“偷工减料”。&lt;/p&gt;
&lt;h4 id=&quot;qa&quot;&gt;QA&lt;/h4&gt;
&lt;p class=&quot;zh-cn&quot;&gt;这个实践完全改变了传统 QA 的工作职责，他们不再作为测试人员在项目末期把关，而是在前期定义规格；他们也不再在项目晚期提出关于错漏的反馈，而是提早给开发团队提供输入，预防错漏的发生。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;这意味着 QA 需要承担相对于传统项目更大的压力。为了确保产品的质量，QA 需要在每一个迭代的全期做不同的工作，而不是仅仅在结尾进行测试，他们是系统是否可部署的“批准者”。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;这样做有什么好处呢？&lt;/p&gt;
&lt;h5 id=&quot;减少遗漏测试的可能性&quot;&gt;减少遗漏测试的可能性&lt;/h5&gt;
&lt;p class=&quot;zh-cn&quot;&gt;传统测试人员会在项目尾声才开始测试，这意味着他们会成为项目部署的瓶颈，为了部署，他们需要尽快完成测试工作。同时这样的工作方式会让上游所有的日期推迟都堆到测试身上，假如程序员的工作延迟了一周，测试的工作就就少了一周，因为管理者不会因为程序员的推迟交付多给测试时间，上线日期是几乎不会改变的。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;那么在这样的情况下，QA 会如何测试呢？很简单，加速，不测所有功能，只测试新的需求或者那些改变了的功能，放弃测试没有改变的功能。于是&lt;strong&gt;遗漏开始了&lt;/strong&gt;，全量回归被放弃，期许下次能有时间全量测试，可是&lt;strong&gt;下次往往意味着永不&lt;/strong&gt;。&lt;/p&gt;
&lt;h5 id=&quot;bug数即api&quot;&gt;bug数即API&lt;/h5&gt;
&lt;p class=&quot;zh-cn&quot;&gt;上述问题至少还有补救的办法，另一个将测试工作放在项目尾声的致命问题是，&lt;strong&gt;组织应该如何判断他们做好了自己的工作&lt;/strong&gt;？很简单，发现的bug越多，他们做的就越好。以发现的bug数量来作为QA团队尽职尽责的证据。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;&lt;em&gt;于是，发现 bug 被认为是好事，且在一些偏激的组织内成为了 QA 团队的 kpi。&lt;/em&gt;&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;这样的问题或许在短期内不会致命，但是长此以往，组织内部一定会逐渐虚弱。&lt;/p&gt;
&lt;h4 id=&quot;程序员&quot;&gt;程序员&lt;/h4&gt;
&lt;p class=&quot;zh-cn&quot;&gt;业务分析师和 QA 完成了测试的编写，但是他们并不运行这些测试。这个任务交给了程序员，程序员需要确保它们的代码通过所有的测试。此时形成了一种&lt;strong&gt;开发即测试&lt;/strong&gt;的有趣局面。换句话说，程序员虽然在做开发的工作，其实他们也在做测试的工作，因为他们的代码通过了测试，这些刚实现的功能已经被测试过了。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;这些测试会和开发过程中编写的单元测试一起被加入到持续构建中。每当一个程序员加入了新的模块，服务器会自动运行所有测试，而团队中的所有人都会关注这些运行，我们会在稍后的文章中有更详细的讨论。&lt;/p&gt;
&lt;h2 id=&quot;完整团队&quot;&gt;完整团队&lt;/h2&gt;
&lt;p class=&quot;zh-cn&quot;&gt;&lt;img src=&quot;https://teobler-image.s3-us-west-1.amazonaws.com/112756.jpg&quot; alt=&quot;scrum_team&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;完整团队的事件最初被称为&lt;em&gt;现场客户(On-Site Customer)&lt;/em&gt;。其理念是：&lt;strong&gt;用户和程序员之间的距离越短，交流就越好，开发就越快、越准确&lt;/strong&gt;。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;这里的客户是一个隐喻，指的是理解用户需求并与开发团队共同工作的某个人或团队。在 Scrum 里这个人或团队被称为 产品负责人(Product Owner, PO)，他负责选择故事、设置优先级并及时提供反馈。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;后来这个实践被改名为&lt;strong&gt;完整团队&lt;/strong&gt;。这是为了强调一个团队里不是只有客户和程序员。开发团队不应该由一个个职能部门组成，同一个团队中应该有客户、业务分析师、程序员、测试人员、经理等等。同时这些所有角色应该尽量处于同一个房间中。&lt;strong&gt;这个实践的目的是无限缩短这些角色之间的物理距离，打破只能壁垒。&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;这样可以极大地提高团队效率，消息不用层层传递，有相应的问题直接能够找到对应的角色进行解决，从问题发生、提出到开始讨论只有短短几秒钟。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;而且团队坐在一起总会触发神秘力量。客户可以无意从程序员或测试人员屏幕上立马发现不对的东西；一场激烈讨论中，可能坐在旁边的另外一个角色本来就有正确答案；两个程序员对需求的描述被业务分析师发现与自己的想法不符......&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;需要注意的是，虽然这个实践一直在描述团队的行为，但这的确是一个业务实践，因为这个实践受益最大的是业务，当团队在同一地点时，业务运行会更加流畅。&lt;/p&gt;
&lt;h3 id=&quot;远程办公的今天&quot;&gt;远程办公的今天&lt;/h3&gt;
&lt;p class=&quot;zh-cn&quot;&gt;在今天，日新月异的技术已经让远程办公成为了可能，特别是视频会议的兴起一定程度上弥补了物理上无法坐在一起办公的遗憾，甚至编译器已经让远程结对做到毫无延迟。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;敏捷团队可以分散在各处吗？在之前这个答案是未知的，但经历了2020年的疫情，这个答案大概是肯定的。至少我们团队和我们各个办公室的团队做的都挺好，但这的确&lt;strong&gt;需要付出更多的精力和拿出更多的纪律和规则&lt;/strong&gt;。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;可以肯定的是，这是可行的，但是如果大家都在同一个房间，我们可以做的更好。&lt;/p&gt;
&lt;/main&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>34cfdde4e985712faee9520465e0d36d</guid>
<title>源码剖析 sync.WaitGroup</title>
<link>https://toutiao.io/k/nqxco3o</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;哈喽，大家好，我是&lt;code&gt;asong&lt;/code&gt;，这是我并发编程系列的第三篇文章，上一篇我们一起分析了&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIzMDU0MTA3Nw==&amp;amp;mid=2247484505&amp;amp;idx=1&amp;amp;sn=73ab61b21574d6ed1c11b6a5516888b0&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;code&gt;sync.once&lt;/code&gt;的使用与实现&lt;/a&gt;，今天我们一起来看一看&lt;code&gt;sync.WaitGroup&lt;/code&gt;的使用与实现.&lt;/p&gt;&lt;p&gt;快过年了，这是年前最后一篇推文了，待我积累一下，年后加大力度写干货，在这里先预祝大家新春快乐，身体健康，万事如意！&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是&lt;code&gt;sync.WaitGroup&lt;/code&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官方文档对&lt;code&gt;sync.WatiGroup&lt;/code&gt;的描述是：一个&lt;code&gt;waitGroup&lt;/code&gt;对象可以等待一组协程结束，也就等待一组&lt;code&gt;goroutine&lt;/code&gt;返回。有了&lt;code&gt;sync.Waitgroup&lt;/code&gt;我们可以将原本顺序执行的代码在多个&lt;code&gt;Goroutine&lt;/code&gt;中并发执行，加快程序处理的速度。其实他与&lt;code&gt;java&lt;/code&gt;中的&lt;code&gt;CountdownLatch&lt;/code&gt;，阻塞等待所有任务完成之后再继续执行。我们来看官网给的一个例子，这个例子使用&lt;code&gt;waitGroup&lt;/code&gt;阻塞主进程，并发获取多个&lt;code&gt;URL&lt;/code&gt;，直到完成所有获取：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;sync&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; httpPkg &lt;span&gt;struct&lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(httpPkg)&lt;/span&gt; &lt;span&gt;Get&lt;/span&gt;&lt;span&gt;(url &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; http httpPkg&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; wg sync.WaitGroup&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; urls = []&lt;span&gt;string&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;&quot;http://www.golang.org/&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;http://www.google.com/&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;http://www.somestupidname.com/&quot;&lt;/span&gt;,&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; _, url := &lt;span&gt;range&lt;/span&gt; urls {&lt;br/&gt;  &lt;span&gt;// Increment the WaitGroup counter.&lt;/span&gt;&lt;br/&gt;  wg.Add(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;// Launch a goroutine to fetch the URL.&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(url &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;// Decrement the counter when the goroutine completes.&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; wg.Done()&lt;br/&gt;   &lt;span&gt;// Fetch the URL.&lt;/span&gt;&lt;br/&gt;   http.Get(url)&lt;br/&gt;  }(url)&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;// Wait for all HTTP fetches to complete.&lt;/span&gt;&lt;br/&gt; wg.Wait()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们需要声明一个&lt;code&gt;sync.WaitGroup&lt;/code&gt;对象，在主&lt;code&gt;gorourine&lt;/code&gt;调用&lt;code&gt;Add()&lt;/code&gt;方法设置要等待的&lt;code&gt;goroutine&lt;/code&gt;数量，每一个&lt;code&gt;Goroutine&lt;/code&gt;在运行结束时要调用&lt;code&gt;Done()&lt;/code&gt;方法，同时使用&lt;code&gt;Wait()&lt;/code&gt;方法进行阻塞直到所有的&lt;code&gt;goroutine&lt;/code&gt;完成。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;为什么要用&lt;code&gt;sync.waitGroup&lt;/code&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在日常开发中为了提高接口响应时间，有一些场景需要在多个&lt;code&gt;goroutine&lt;/code&gt;中做一些互不影响的业务，这样可以节省不少时间，但是需要协调多个&lt;code&gt;goroutine&lt;/code&gt;，没有&lt;code&gt;sync.WaitGroup&lt;/code&gt;的时候，我们可以使用通道来解决这个问题，我们把主&lt;code&gt;Goroutine&lt;/code&gt;当成铜锣扛把子a song，把每一个&lt;code&gt;Goroutine&lt;/code&gt;当成一个马仔，&lt;code&gt;asong&lt;/code&gt;管理这些马仔，让这些马仔去收保护费，我今天派10个马仔去收保护费，每一个马仔收好了保护费就在账本上打一个✅，当所有马仔都收好了保护费，账本上就被打满了✅，活全被干完了，很出色，然后酒吧走起，浪一浪，全场的消费松公子买单，写成代码可以这样表示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;exampleImplWaitGroup&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; done := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;{}) &lt;span&gt;// 收10份保护费&lt;/span&gt;&lt;br/&gt; count := &lt;span&gt;10&lt;/span&gt; &lt;span&gt;// 10个马仔&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i:=&lt;span&gt;0&lt;/span&gt;;i &amp;lt; count;i++{&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(i &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    done &amp;lt;- &lt;span&gt;struct&lt;/span&gt; {}{}&lt;br/&gt;   }()&lt;br/&gt;   fmt.Printf(&lt;span&gt;&quot;马仔%d号收保护费\n&quot;&lt;/span&gt;,i)&lt;br/&gt;  }(i)&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i:=&lt;span&gt;0&lt;/span&gt;;i&amp;lt; count;i++{&lt;br/&gt;  &amp;lt;- done&lt;br/&gt;  fmt.Printf(&lt;span&gt;&quot;马仔%d号已经收完保护费\n&quot;&lt;/span&gt;,i)&lt;br/&gt; }&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;所有马仔已经干完活了，开始酒吧消费～&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然这样可以实现，但是我们每次使用都要保证主&lt;code&gt;Goroutine&lt;/code&gt;最后从通道接收的次数需要与之前其他的&lt;code&gt;Goroutine&lt;/code&gt;发送元素的次数相同，实现起来不够优雅，在这种场景下我们就可以选用&lt;code&gt;sync.WaitGroup&lt;/code&gt;来帮助我们实现同步。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;源码剖析&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面我们已经知道&lt;code&gt;sync.waitGroup&lt;/code&gt;的基本使用了，接下来我们就一起看看他是怎样实现的～，只有知其所以然，才能写出更健壮的代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go version: 1.15.3&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们看一下&lt;code&gt;sync.WaitGroup&lt;/code&gt;的结构：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// A WaitGroup must not be copied after first use.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; WaitGroup &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; noCopy noCopy&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 64-bit value: high 32 bits are counter, low 32 bits are waiter count.&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// 64-bit atomic operations require 64-bit alignment, but 32-bit&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// compilers do not ensure it. So we allocate 12 bytes and then use&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// the aligned 8 bytes in them as state, and the other 4 as storage&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// for the sema.&lt;/span&gt;&lt;br/&gt; state1 [&lt;span&gt;3&lt;/span&gt;]&lt;span&gt;uint32&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总共就有两个字段，&lt;code&gt;nocopy&lt;/code&gt;是为了保证该结构不会被进行拷贝，这是一种保护机制，会在后面进行介绍；&lt;code&gt;state1&lt;/code&gt;主要是存储着状态和信号量，这里使用的8字节对齐处理的方式很有意思，我先来一起看看这种处理。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;code&gt;state1&lt;/code&gt;状态和信号量处理&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;state1&lt;/code&gt;这里总共被分配了&lt;code&gt;12&lt;/code&gt;个字节，这里被设计了三种状态：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;其中对齐的&lt;code&gt;8&lt;/code&gt;个字节作为状态，高&lt;code&gt;32&lt;/code&gt;位为计数的数量，低&lt;code&gt;32&lt;/code&gt;位为等待的&lt;code&gt;goroutine&lt;/code&gt;数量&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;其中的&lt;code&gt;4&lt;/code&gt;个字节作为信号量存储&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提供了&lt;code&gt;(wg *WaitGroup) state() (statep *uint64, semap *uint32)&lt;/code&gt;帮助我们从&lt;code&gt;state1&lt;/code&gt;字段中取出他的状态和信号量，为什么要这样设计呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在分析&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIzMDU0MTA3Nw==&amp;amp;mid=2247484475&amp;amp;idx=1&amp;amp;sn=f470d42fee8b9b65fad7b43e57518cfc&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt;和&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIzMDU0MTA3Nw==&amp;amp;mid=2247484529&amp;amp;idx=1&amp;amp;sn=8653947ab70f4d73ff6260965be32460&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Go看源码必会知识之unsafe包&lt;/a&gt;有说到过，64位原子操作需要64位对齐，但是32位编译器不能保证这一点，所以为了保证&lt;code&gt;waitGroup&lt;/code&gt;在&lt;code&gt;32&lt;/code&gt;位平台上使用的话，就必须保证在任何时候，&lt;code&gt;64位&lt;/code&gt;操作不会报错。所以也就不能分成两个字段来写，考虑到字段顺序不同、平台不同，内存对齐也就不同。因此这里采用动态识别当前我们操作的&lt;code&gt;64&lt;/code&gt;位数到底是不是在&lt;code&gt;8&lt;/code&gt;字节对齐的位置上面，我们来分析一下&lt;code&gt;state&lt;/code&gt;方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// state returns pointers to the state and sema fields stored within wg.state1.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(wg *WaitGroup)&lt;/span&gt; &lt;span&gt;state&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;(statep *&lt;span&gt;uint64&lt;/span&gt;, semap *&lt;span&gt;uint32&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;uintptr&lt;/span&gt;(unsafe.Pointer(&amp;amp;wg.state1))%&lt;span&gt;8&lt;/span&gt; == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (*&lt;span&gt;uint64&lt;/span&gt;)(unsafe.Pointer(&amp;amp;wg.state1)), &amp;amp;wg.state1[&lt;span&gt;2&lt;/span&gt;]&lt;br/&gt; } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (*&lt;span&gt;uint64&lt;/span&gt;)(unsafe.Pointer(&amp;amp;wg.state1[&lt;span&gt;1&lt;/span&gt;])), &amp;amp;wg.state1[&lt;span&gt;0&lt;/span&gt;]&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当数组的首地址是处于一个&lt;code&gt;8&lt;/code&gt;字节对齐的位置上时，那么就将这个数组的前&lt;code&gt;8&lt;/code&gt;个字节作为&lt;code&gt;64&lt;/code&gt;位值使用表示状态，后&lt;code&gt;4&lt;/code&gt;个字节作为&lt;code&gt;32&lt;/code&gt;位值表示信号量(&lt;code&gt;semaphore&lt;/code&gt;)。同理如果首地址没有处于&lt;code&gt;8&lt;/code&gt;字节对齐的位置上时，那么就将前&lt;code&gt;4&lt;/code&gt;个字节作为&lt;code&gt;semaphore&lt;/code&gt;，后&lt;code&gt;8&lt;/code&gt;个字节作为&lt;code&gt;64&lt;/code&gt;位数值。画个图表示一下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5035335689045937&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/k5430ljpYPMTBgLCzxHx0PE85G9T929DUa2Yq3kjHDj18c6VH0UyZsuXp8ia6aQHdbtTuffCfeNlOTRmFicqnDqQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;566&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;code&gt;Add()&lt;/code&gt;、&lt;code&gt;Done()&lt;/code&gt;方法&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sync.WaitGroup&lt;/code&gt;提供了&lt;code&gt;Add()&lt;/code&gt;方法增加一个计数器，&lt;code&gt;Done()&lt;/code&gt;方法减掉一个计数，&lt;code&gt;Done()&lt;/code&gt;方法实现比较简单，内部调用的&lt;code&gt;Add()&lt;/code&gt;方法实现的计数器减一操作，也就是增减逻辑都在&lt;code&gt;Add()&lt;/code&gt;方法中，所以我们重点看一下&lt;code&gt;Add()&lt;/code&gt;是如何实现的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(wg *WaitGroup)&lt;/span&gt; &lt;span&gt;Add&lt;/span&gt;&lt;span&gt;(delta &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// 获取状态(Goroutine Counter 和 Waiter Counter)和信号量&lt;/span&gt;&lt;br/&gt; statep, semap := wg.state()&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; race.Enabled {&lt;br/&gt;  _ = *statep &lt;span&gt;// trigger nil deref early&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; delta &amp;lt; &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;// Synchronize decrements with Wait.&lt;/span&gt;&lt;br/&gt;   race.ReleaseMerge(unsafe.Pointer(wg))&lt;br/&gt;  }&lt;br/&gt;  race.Disable()&lt;br/&gt;  &lt;span&gt;defer&lt;/span&gt; race.Enable()&lt;br/&gt; }&lt;br/&gt;  &lt;span&gt;// 原子操作，goroutine counter累加delta&lt;/span&gt;&lt;br/&gt; state := atomic.AddUint64(statep, &lt;span&gt;uint64&lt;/span&gt;(delta)&amp;lt;&amp;lt;&lt;span&gt;32&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;// 获取当前goroutine counter的值(高32位)&lt;/span&gt;&lt;br/&gt; v := &lt;span&gt;int32&lt;/span&gt;(state &amp;gt;&amp;gt; &lt;span&gt;32&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;// 获取当前waiter counter的值(低32位)&lt;/span&gt;&lt;br/&gt; w := &lt;span&gt;uint32&lt;/span&gt;(state)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; race.Enabled &amp;amp;&amp;amp; delta &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; v == &lt;span&gt;int32&lt;/span&gt;(delta) {&lt;br/&gt;  &lt;span&gt;// The first increment must be synchronized with Wait.&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// Need to model this as a read, because there can be&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// several concurrent wg.counter transitions from 0.&lt;/span&gt;&lt;br/&gt;  race.Read(unsafe.Pointer(semap))&lt;br/&gt; }&lt;br/&gt;  &lt;span&gt;// Goroutine counter是不允许为负数的，否则会发生panic&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; v &amp;lt; &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;panic&lt;/span&gt;(&lt;span&gt;&quot;sync: negative WaitGroup counter&quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;  &lt;span&gt;// 当wait的Goroutine不为0时，累加后的counter值和delta相等,说明Add()和Wait()同时调用了,所以发生panic,因为正确的做法是先Add()后Wait()，也就是已经调用了wait()就不允许再添加任务了&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; w != &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; delta &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; v == &lt;span&gt;int32&lt;/span&gt;(delta) {&lt;br/&gt;  &lt;span&gt;panic&lt;/span&gt;(&lt;span&gt;&quot;sync: WaitGroup misuse: Add called concurrently with Wait&quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;  &lt;span&gt;// 正常`Add()`方法后，`goroutine Counter`计数器大于0或者`waiter Counter`计数器等于0时，不需要释放信号量&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; v &amp;gt; &lt;span&gt;0&lt;/span&gt; || w == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;// 能走到这里说明当前Goroutine Counter计数器为0，Waiter Counter计数器大于0, 到这里数据也就是允许发生变动了，如果发生变动了，则出发panic&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; *statep != state {&lt;br/&gt;  &lt;span&gt;panic&lt;/span&gt;(&lt;span&gt;&quot;sync: WaitGroup misuse: Add called concurrently with Wait&quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;// 重置状态，并发出信号量告诉wait所有任务已经完成&lt;/span&gt;&lt;br/&gt; *statep = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; ; w != &lt;span&gt;0&lt;/span&gt;; w-- {&lt;br/&gt;  runtime_Semrelease(semap, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的代码有一部分是&lt;code&gt;race&lt;/code&gt;静态检测，下面的分析会省略这一部分，因为它并不是本文的重点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注释我都添加到对应的代码行上了，你是否都看懂了，没看懂不要紧，因为&lt;code&gt;Add()&lt;/code&gt;是与&lt;code&gt;Wait()&lt;/code&gt;方法一块使用的，所以有些逻辑与&lt;code&gt;wait()&lt;/code&gt;里的逻辑是相互照应的，所以当我们看完&lt;code&gt;wait()&lt;/code&gt;方法的实现在总结一下你们就明白了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;code&gt;Wait()&lt;/code&gt;方法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sync.Wait()&lt;/code&gt;方法会阻塞主&lt;code&gt;Goroutine&lt;/code&gt;直到&lt;code&gt;WaitGroup&lt;/code&gt;计数器变为0。我们一起来看一下&lt;code&gt;Wait()&lt;/code&gt;方法的源码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Wait blocks until the WaitGroup counter is zero.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(wg *WaitGroup)&lt;/span&gt; &lt;span&gt;Wait&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// 获取状态(Goroutine Counter 和 Waiter Counter)和信号量&lt;/span&gt;&lt;br/&gt; statep, semap := wg.state()&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; race.Enabled {&lt;br/&gt;  _ = *statep &lt;span&gt;// trigger nil deref early&lt;/span&gt;&lt;br/&gt;  race.Disable()&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 使用原子操作读取state，是为了保证Add中的写入操作已经完成&lt;/span&gt;&lt;br/&gt;  state := atomic.LoadUint64(statep)&lt;br/&gt;    &lt;span&gt;// 获取当前goroutine counter的值(高32位)&lt;/span&gt;&lt;br/&gt;  v := &lt;span&gt;int32&lt;/span&gt;(state &amp;gt;&amp;gt; &lt;span&gt;32&lt;/span&gt;)&lt;br/&gt;     &lt;span&gt;// 获取当前waiter counter的值(低32位)&lt;/span&gt;&lt;br/&gt;  w := &lt;span&gt;uint32&lt;/span&gt;(state)&lt;br/&gt;    &lt;span&gt;// 如果没有任务，或者任务已经在调用`wait`方法前已经执行完成了，就不用阻塞了&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; v == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;// Counter is 0, no need to wait.&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; race.Enabled {&lt;br/&gt;    race.Enable()&lt;br/&gt;    race.Acquire(unsafe.Pointer(wg))&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;// 使用CAS操作对`waiter Counter`计数器进行+1操作，外面有for循环保证这里可以进行重试操作&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; atomic.CompareAndSwapUint64(statep, state, state+&lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; race.Enabled &amp;amp;&amp;amp; w == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// Wait must be synchronized with the first Add.&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Need to model this is as a write to race with the read in Add.&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// As a consequence, can do the write only for the first waiter,&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// otherwise concurrent Waits will race with each other.&lt;/span&gt;&lt;br/&gt;    race.Write(unsafe.Pointer(semap))&lt;br/&gt;   }&lt;br/&gt;      &lt;span&gt;// 在这里获取信号量，使线程进入睡眠状态，与Add方法中最后的增加信号量相对应，也就是当最后一个任务调用Done方法&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// 后会调用Add方法对goroutine counter的值减到0，就会走到最后的增加信号量&lt;/span&gt;&lt;br/&gt;   runtime_Semacquire(semap)&lt;br/&gt;      &lt;span&gt;// 在Add方法中增加信号量时已经将statep的值设为0了，如果这里不是0，说明在wait之后又调用了Add方法，使用时机不对，触发panic&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; *statep != &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;panic&lt;/span&gt;(&lt;span&gt;&quot;sync: WaitGroup is reused before previous Wait has returned&quot;&lt;/span&gt;)&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; race.Enabled {&lt;br/&gt;    race.Enable()&lt;br/&gt;    race.Acquire(unsafe.Pointer(wg))&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;源码总结&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分了源码，我们可以总结如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Add&lt;/code&gt;方法与&lt;code&gt;wait&lt;/code&gt;方法不可以并发同时调用，&lt;code&gt;Add&lt;/code&gt;方法要在&lt;code&gt;wait&lt;/code&gt;方法之前调用.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Add()&lt;/code&gt;设置的值必须与实际等待的&lt;code&gt;goroutine&lt;/code&gt;个数一致，否则会&lt;code&gt;panic&lt;/code&gt;.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用了&lt;code&gt;wait&lt;/code&gt;方法后，必须要在&lt;code&gt;wait&lt;/code&gt;方法返回以后才能再次重新使用&lt;code&gt;waitGroup&lt;/code&gt;，也就是&lt;code&gt;Wait&lt;/code&gt;没有返回之前不要在调用&lt;code&gt;Add&lt;/code&gt;方法，否则会发生&lt;code&gt;Panic&lt;/code&gt;.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Done&lt;/code&gt; 只是对&lt;code&gt;Add&lt;/code&gt; 方法的简单封装，我们可以向 &lt;code&gt;Add&lt;/code&gt;方法传入任意负数（需要保证计数器非负）快速将计数器归零以唤醒等待的 &lt;code&gt;Goroutine&lt;/code&gt;.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;waitGroup&lt;/code&gt;对象只能有一份，不可以拷贝给其他变量，否则会造成意想不到的&lt;code&gt;Bug&lt;/code&gt;.&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;code&gt;no copy&lt;/code&gt;机制&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前文看&lt;code&gt;waitGroup&lt;/code&gt;结构时，有一个&lt;code&gt;nocopy&lt;/code&gt;字段，为什么要有&lt;code&gt;nocopy&lt;/code&gt;呢？我们先看这样一个例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; User &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Name &lt;span&gt;string&lt;/span&gt;&lt;br/&gt; Info *Info&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Info &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Age &lt;span&gt;int&lt;/span&gt;&lt;br/&gt; Number &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; u := User{&lt;br/&gt;  Name: &lt;span&gt;&quot;asong&quot;&lt;/span&gt;,&lt;br/&gt;  Info: &amp;amp;Info{&lt;br/&gt;   Age: &lt;span&gt;10&lt;/span&gt;,&lt;br/&gt;   Number: &lt;span&gt;24&lt;/span&gt;,&lt;br/&gt;  },&lt;br/&gt; }&lt;br/&gt; u1 := u&lt;br/&gt; u1.Name = &lt;span&gt;&quot;Golang梦工厂&quot;&lt;/span&gt;&lt;br/&gt; u1.Info.Age = &lt;span&gt;30&lt;/span&gt;&lt;br/&gt; fmt.Println(u.Info.Age,u.Name)&lt;br/&gt; fmt.Println(u1.Info.Age,u1.Name)&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 运行结果&lt;/span&gt;&lt;br/&gt;&lt;span&gt;30&lt;/span&gt; asong&lt;br/&gt;&lt;span&gt;30&lt;/span&gt; Golang梦工厂&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结构体&lt;code&gt;User&lt;/code&gt;中有两个字段&lt;code&gt;Name&lt;/code&gt;和&lt;code&gt;Info&lt;/code&gt;，&lt;code&gt;Name&lt;/code&gt;是&lt;code&gt;String&lt;/code&gt;类型，&lt;code&gt;Info&lt;/code&gt;是指向结构体&lt;code&gt;Info&lt;/code&gt;的指针类型，我们首先声明了一个&lt;code&gt;u&lt;/code&gt;变量，对他进行复制拷贝得到变量&lt;code&gt;u1&lt;/code&gt;，在&lt;code&gt;u1&lt;/code&gt;中对两个字段进行改变，可以看到&lt;code&gt;Info&lt;/code&gt;字段发生了更改，而&lt;code&gt;Name&lt;/code&gt;就没发生更改，这就引发了安全问题，如果结构体对象包含指针字段，当该对象被拷贝时，会使得两个对象中的指针字段变得不再安全。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Go&lt;/code&gt;语言中提供了两种&lt;code&gt;copy&lt;/code&gt;检查，一种是在运行时进行检查，一种是通过静态检查。不过运行检查是比较影响程序的执行性能的，Go官方目前只提供了strings.Builder和sync.Cond的runtime拷贝检查机制，对于其他需要nocopy对象类型来说，使用go vet工具来做静态编译检查。运行检查的实现可以通过比较所属对象是否发生变更&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.525&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/k5430ljpYPMTBgLCzxHx0PE85G9T929DPqcYAibk3gOaZtOr2TI55gVia1KCHlBgrvre0ytHe4j9wBwgEGgia9lJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就可以判断，而静态检查是提供了一个&lt;code&gt;nocopy&lt;/code&gt;对象，只要是该对象或对象中存在&lt;code&gt;nocopy&lt;/code&gt;字段，他就实现了&lt;code&gt;sync.Locker&lt;/code&gt;接口, 它拥有Lock()和Unlock()方法，之后，可以通过go vet功能，来检查代码中该对象是否有被copy。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;踩坑事项&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在文章的最后总结一下使用&lt;code&gt;waitGroup&lt;/code&gt;易错的知识点，防止大家再次犯错。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;waitGroup&lt;/code&gt;中计数器的值是不能小于0的，源码中我们就可以看到，一旦小于0就会引发panic。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一定要住注意调用&lt;code&gt;Add&lt;/code&gt;方法与&lt;code&gt;Wait&lt;/code&gt;方法的顺序，不可并发同时调用这两个方法，否则就会引发panic，同时在调用了&lt;code&gt;wait&lt;/code&gt;方法在其没有释放前不要再次调用&lt;code&gt;Add&lt;/code&gt;方法，这样也会引发&lt;code&gt;panic&lt;/code&gt;，&lt;code&gt;waitGroup&lt;/code&gt;是可以复用的，但是需要保证其计数周期的完整性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;WaitGroup&lt;/code&gt;对象不是一个引用类型，通过函数传值的时候需要使用地址，因为&lt;code&gt;Go&lt;/code&gt;语言只有值传递，传递&lt;code&gt;WaitGroup&lt;/code&gt;是值的话，就会导致会发生&lt;code&gt;panic&lt;/code&gt;，看这样一个例子：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; wg := sync.WaitGroup{}&lt;br/&gt; wg.Add(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt; doDeadLock(wg)&lt;br/&gt; wg.Wait()&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;doDeadLock&lt;/span&gt;&lt;span&gt;(wg sync.WaitGroup)&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; wg.Done()&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;do something&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;//运行结果：panic: sync: negative WaitGroup counter&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发生这个问题的原因就是在&lt;code&gt;doDeadLock()&lt;/code&gt;方法中&lt;code&gt;wg&lt;/code&gt;是一个新对象，直接调用&lt;code&gt;Done&lt;/code&gt;方法，计数器就会出现负数，所以引发&lt;code&gt;panic&lt;/code&gt;，为了安全起见，对于这种传结构体的场景一般建议都传指针就好了，基本可以避免一些问题。&lt;/p&gt;&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Add()设置的值必须与实际等待的goroutine个数一致，否则会&lt;code&gt;panic&lt;/code&gt;，很重要的一点，也是很容易出错的地方。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;思考题&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后给大家出一个思考题，下面这段代码会不会发生&lt;code&gt;panic&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; wg := sync.WaitGroup{}&lt;br/&gt; wg.Add(&lt;span&gt;100&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100&lt;/span&gt;; i++ {&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; wg.Done()&lt;br/&gt;   fmt.Println(i)&lt;br/&gt;  }()&lt;br/&gt; }&lt;br/&gt; wg.Wait()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;结尾&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;在最后，祝大家新年快乐，心想事成，万事如意～～～&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;好啦，这篇文章就到这里啦，素质三连（分享、点赞、在看）都是笔者持续创作更多优质内容的动力！&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;创建了一个Golang学习交流群，欢迎各位大佬们踊跃入群，我们一起学习交流。入群方式：加我vx拉你入群，或者公众号获取入群二维码&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;结尾给大家发一个小福利吧，最近我在看[微服务架构设计模式]这一本书，讲的很好，自己也收集了一本PDF，有需要的小伙可以到自行下载。获取方式：关注公众号：[Golang梦工厂]，后台回复：[微服务]，即可获取。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;我翻译了一份GIN中文文档，会定期进行维护，有需要的小伙伴后台回复[gin]即可下载。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;翻译了一份Machinery中文文档，会定期进行维护，有需要的小伙伴们后台回复[machinery]即可获取。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;我是asong，一名普普通通的程序猿，让我们一起慢慢变强吧。欢迎各位的关注，我们下期见~~~&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/k5430ljpYPMTBgLCzxHx0PE85G9T929DWhOUXLOSKsqZcdFwSGPia5tZRIHg8uticVPY9lJTI82Cl23W1EPkhLHw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推荐往期文章：&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>