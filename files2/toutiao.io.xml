<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f51b8bfcd26e79563274022b552b94ea</guid>
<title>五一没地方去？来这里吧！</title>
<link>https://toutiao.io/k/m70wnkv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;我爱程序员&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;developerWorks&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;我们的产品：《码农周刊》 http://manong.io/ 、《开发者头条》 http://toutiao.io/&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>08ef86ecde4a6fd4f549105e553ad41f</guid>
<title>connection reset案例的穿越之旅</title>
<link>https://toutiao.io/k/ut7lfeg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;事情要从周五晚上说起，好学的朋友在群里问我有没有能够通过框架和项目能对IO有深入学习的。我当时正照例刷着电影解说，感受着逻辑的力量。等看到消息时，已经看到其他朋友热心得给出了神回复：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;3.1855072463768117&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9ibYmZwVq4fSlc6gonEZpJGTaubp7Qa2MF1eKicSv7RP7GDcgaRG5qETZpPscvGactrIBIzP8kpKYQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;690&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在我进行了仔细阅读之后，断线一秒钟，之后由衷感叹自己技术不精，没有弄懂问题和回答之间的逻辑关系。于是给出了自己的回复：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通信框架都需要IO知识，服务治理框架、redis和mysql等存储中间件、MQ都有很强的关联。但是一般很少有很强的动力研究的很深。我个人而言，排查生产问题会引出大量想学习的问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;然后群里简短的介绍了一个案例：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;A与B是两个公司的两个服务，A要调用B服务，他们之间可谓万水千山：&lt;/p&gt;&lt;p&gt;A---服务器--F5--交换机1--交换机2--F5--SSL（透传）--F5--交换机--山石防火墙--H3C交换机--思科路由器---专线--网联思科路由器--H3C交换机--思科防火墙--思科交换机--H3C交换机--思科防火墙--F5-SSL-服务器--F5--交换机1--交换机2--F5--SSL--F5--交换机--山石防火墙--H3C交换机--思科路由器---专线--网联思科路由器--H3C交换机--思科防火墙--思科交换机--H3C交换机--思科防火墙--F5--SSL（非透传）--B&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;咱们简化一下问题：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;A请求B，B正常返回结果，但是A反馈收不到。后来B抓包发现在请求还在进行read数据时就收到了connection reset，连接断开。但是并非每笔请求都是如此。而是A有小于30%的概率收不到。而B对接的其他公司却都正常。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在排查日志时发现B收到的请求分成两种，一种是A可以正常收到的，连接是长连接，一种是A不能正常收到的，连接是短连接。但是长连接还是短连接并不是不能正常返回数据的理由。因为数据是分段传输的，每段之间可以灵活采用自己的连接方式，就像传信时，第一段是采用飞鸽传书，第二段是快递员拿到信用快马送到驿站交到仆人手中，第三段是仆人一路小跑将信递交到我手中。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我猛然一惊，这不是穿越剧，而是技术文章。所以放弃长短连接，看看还没有别的线索，终于发现A不能收到的与能收到的相比http header的 X-Forwarded-For 参数中都多出了2个值。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;X-Forwarded-For（XFF）是用来识别通过 HTTP 代理或负载均衡方式连接到 Web 服务器的客户端最原始的 IP 地址的 HTTP 请求头字段。在传输过程中，每一个驿站都有可能通过这个字段打上自己的标记。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;将 XFF 的值拿给专业人士验证，竟然有人在B服务前面的万水千山之上又加了一座秦岭。更准确的说是加了30%个秦岭。B服务前被加上了一层nginx，且已经灰度了30%的流量。这就对应了有接近30%的请求有问题。也解释了为什么会有短连接，因为nginx在默认不设置时采用短连接。但是还不能解释为什么只有A有问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在nginx的日志中发现了lua异常，对于一个lua完全不懂的人果断向百事通大师谷歌求助。但谷歌大师是西域来的，据说见他要翻墙。翻墙不是体力好就更翻得了的，要付费。看着手上唯一个「顺治通宝」，正犹豫之时，又听人说咱们有个国产美人「度娘」在情报方面也很厉害，甚至慢慢在赶超谷歌大师。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我连忙前去请教，得到答复：lua脚本一旦抛出异常，就会中断处理。这就解释了为什么会发生connection reset。nginx抛出异常中断了与上层SSL客户端的连接。SSL又作为服务端感知到了异常，主动发connection reset中断了自己与上层的连接。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这种异常场景最好能复现，但是不懂lua怎么复现，这次咱们要来个大手笔，找到真正的大师求助。于是问题上报到了「编程一生」用户交流群，立即得到了lua可以在线调试的重要线索，问题得到复现：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.27830451756832125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9ibYmZwVq4fSlc6gonEZpJGKEibndNIk5XlRNyogriaSpy5hNOedyOkaHtr6MzZzLVKHVpGu3qicjLicw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1793&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;原来处理请求和响应的lua脚本，里面打印日志时for循环遍历请求和响应的数组，遍历时认为每一项都是一个字符串，A应用在传输过程中，将http header的 XFF 变成了一个数组，lua中数组(table)不能直接强转为字符串，被判断为异常触发reset。这也解释了为什么只有A有问题，因为只有他在传输过程中将原本的字符串转成了数组。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在nginx日志还有一个支线线索是：access日志中显示请求结果是200(正常返回结果)，但是响应的 &lt;span&gt;Content-Length 为0 ！就是说响应为空。看到上面我们可以知道B返回了信息给nginx，nginx异常导致被处理后的响应丢失。出现这个问题的实际不是A一个，还有另外一家。本身B服务请求量很小，没有报出来也很正常。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;从规律上来说：我怀疑可能是commons-httpclient-3.1-rc1版本以下会采用这种策略，因为从请求日志头中看到出现问题的只有两个httpclient版本过来的请求，另外一个是commons-httpclient-3.0-rc3 版本。这里再顺便介绍一下apache各个类型的版本。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Alpha：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Alpha是内部测试版，表示最初的版本，一般不向外部发布。Alpha版会有很多Bug，除非你想去测试最新的功能，否则一般不建议使用。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Beta：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;该版本相对于Alpha版已有了很大的改进，消除了严重的错误，但还是存在着一缺陷，需要经过多次测试来进一步消除。这个阶段的版本会一直加入新的功能。`&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;RC：(Release Candidate)&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Candidate是候选人的意思，用在软件上就是候选版本。Release.Candidate.就是发行候选版本。和Beta版最大的差别在于Beta阶段会一直加入新的功能，但是到了RC版本，几乎就不会加入新的功能了，而主要着重于除错! RC版本是最终发放给用户的最接近正式版的版本，发行后改正bug就是正式版了，就是正式版之前的最后一个测试版。`&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;GA：（general availability）&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;比如：Apache Struts 2 GA这是Apache Struts 2首次发行稳定的版本，GA意味着General Availability，也就是官方开始推荐广泛使用了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Release:&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;该版本意味“最终版本”，在前面版本的一系列测试版之后，终归会有一个正式版本，是最终交付用户使用的一个版本。该版本有时也称为标准版。一般情况下，Release不会以单词形式出现在软件封面上，取而代之的是符号(R)。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;从案例来看，用过老的或者不用稳定版本，当了别人的小白鼠，可以获得很多技术精进的机会。因为你会踩很多其他开发者没有踩过的坑。同时还可以获得头发护理的永久免费：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRl9ibYmZwVq4fSlc6gonEZpJGFP8FXQRwM4qynL7kRayhWZupgKODdicgy3cgVWKMC4qRKnpfU8xaEJA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;最后澄清一下，文章是原创，但是作者不是我，是咱们。有事群里常交流，你们说我来听~&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6595460614152203&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9ibYmZwVq4fSlc6gonEZpJGibx3PNYHFs1LxQ06iagH3wUrLv8be66fPl5HcicQHeKNaYjhgR94YPUdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;749&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong data-brushtype=&quot;text&quot;&gt;编程一生&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;因为公众号平台更改了推送规则，如果不想错过内容，记得读完点一下“在看”，加个“星标”，这样每次新文章推送才会第一时间出现在你的订阅列表里。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;想知道自己错过了哪些更新，可参考我不定期更新的《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247487380&amp;amp;idx=2&amp;amp;sn=4e71d679e2c22f9c5af4ea3abc667b76&amp;amp;chksm=fafde53acd8a6c2c9d2fb5eb83de5e5a2e3f244a57fa275394d9d61a0cdfa154290fe7a21fe8&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;系列文章分类汇总&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;em&gt;&lt;strong&gt;系列文章分类汇总&lt;/strong&gt;&lt;/em&gt;&lt;/a&gt;》。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a9c50de2c98dc9ad5ab552fee94187af</guid>
<title>引入『客户端缓存』，Redis6算是把缓存玩明白了…</title>
<link>https://toutiao.io/k/txajf8j</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哈喽大家好啊，我是没更新就是在家忙着带娃的Hydra。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前面介绍两级缓存的文章中，我们总共给出了4种实现方案，在项目中整合了本地缓存&lt;code&gt;Caffeine&lt;/code&gt;和远程缓存&lt;code&gt;Redis&lt;/code&gt;，将应用的性能从仅适用单独远程缓存的基础上，再次提高了一个层次。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而今天Hydra要和大家分享的技术，在思想上和上面两级缓存有些类似，不过不需要借助其他本地缓存中间件，只使用&lt;code&gt;Redis&lt;/code&gt;自身服务端和客户端就可以实现。这就是&lt;code&gt;Redis6&lt;/code&gt;中的客户端缓存&lt;code&gt;Client-side caching&lt;/code&gt;这一项新特性，它允许将数据缓存在&lt;strong&gt;应用服务端&lt;/strong&gt;以及&lt;strong&gt;远程缓存&lt;/strong&gt;两个位置。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;简介&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端缓存是Redis6众多新特性中比较实用的一项新功能，我们看看官方文档，了解一下它的作用：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;客户端缓存是一种用于创建高性能服务的技术，它可以利用&lt;strong&gt;应用服务器&lt;/strong&gt;上的可用内存（这些服务器通常是一些不同于数据库服务器的节点），在这些应用服务端来直接存储数据库中的一些信息。&lt;/p&gt;&lt;p&gt;与访问数据库等网络服务相比，访问本地内存所需要的时间消耗要少得多，因此这个模式可以大大缩短应用程序获取数据的延迟，同时也能减轻数据库的负载压力。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这，我心想这不是和其他本地缓存Guava、Caffeine啥的一样吗，换汤不换药，都是使用的应用服务的内存罢了。要说有什么好处，可能就是我在项目中能少引入一个中间件了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过，我这点浅薄的猜想，在看完客户端缓存的具体应用模式后，彻底被颠覆了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;两种模式&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在了解了客户端缓存的基本功能后，我们来看看它的两种基本应用模式。Redis的客户端缓存支持被称为&lt;code&gt;tracking&lt;/code&gt;，个人感觉翻译为对key的&lt;strong&gt;追踪&lt;/strong&gt;就很好理解，它具有两种模式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;默认模式，服务端会记录某个客户端具体访问过哪一些&lt;code&gt;key&lt;/code&gt;，当这些&lt;code&gt;key&lt;/code&gt;对应的值发生变化时，会发送失效消息给这些客户端。这个模式会在服务端消耗一些内存，但是发送失效消息的范围，被限制在了客户端存储了的&lt;code&gt;key&lt;/code&gt;的集合范围内&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;广播模式，服务端不会再记录某个客户端访问了哪些&lt;code&gt;key&lt;/code&gt;，因此这个模式不消耗服务端的内存。取而代之的是，客户端需要订阅&lt;code&gt;key&lt;/code&gt;的特定前缀，每当符合这个前缀的&lt;code&gt;key&lt;/code&gt;对应的值发生改变时，客户端都会收到通知消息&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这里，它和我们之前使用的两级缓存之间差异，是不是已经初露端倪了呢？如果还不熟悉两级缓存的架构，那么可以先来看看下面的这张图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4039158810732415&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicbdISYMMsL8iaw6JWTYeElpIfwWIbTXwKx9bO6IQnWHgQ8wJ5GeFicia4uTa60PXcB7R0X2poXJ76PsQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1379&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种架构在理论上看起来不错，但是实际使用起来需要注意的点不少，尤其是在分布式模式下，需要保证各个主机下的一级缓存的一致性问题，回想一下我们原先的解决方案，可以使用redis本身的&lt;strong&gt;发布/订阅&lt;/strong&gt;功能来实现：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4524053224155578&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicbdISYMMsL8iaw6JWTYeElpIJxlOVudq9zMusjqV8y0EaUjWCu7fIXbhm1GYibvGdfP8PgHiaPHZAmpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;977&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而客户端缓存的出现，大大简化了这一过程。我们以&lt;strong&gt;默认模式&lt;/strong&gt;为例，看一下使用了客户端缓存后的操作过程：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5650406504065041&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicbdISYMMsL8iaw6JWTYeElpIuavKHIuHUsqicwelYcT9ovvmgOyDfQ0w9icEVFlZORSLzLTsKA1GADfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;984&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相比原先的发布/订阅模式，我们可以看到明显的优势，使用客户端缓存功能后，我们只需要单纯的修改redis中的数据就可以了，手动处理发布/订阅消息的这一过程可以完全被省略。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;优势&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里，在了解了客户端缓存的基本功能与两种模式后，我们来对比一下，和传统的只使用redis做远程缓存、以及使用整合后的两级缓存相比较，客户端缓存具有什么样的优势。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;当应用的服务端存在缓存时，会直接读取本地缓存，能够减少网络访问上造成的延迟，从而加快访问速度&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;同时也能减少访问redis服务端的次数，降低redis的负载压力&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在分布式环境下，不再需要通过发布订阅来通知其他主机更新本地缓存，来保证数据的一致性。使用客户端缓存后，它所具有的原生的消息通知功能，能很好地支持作废本地缓存，保证之后访问时能取到更新后的新数据&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;误区&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在开始演示客户端缓存的使用之前，我们先来纠正一个误区。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然这个新特性被称为&lt;strong&gt;客户端缓存&lt;/strong&gt;，但是redis本身不提供在应用服务端缓存数据的功能，这个功能要由&lt;strong&gt;访问redis的客户端&lt;/strong&gt;自己去实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说白了，也就是redis服务端只负责通知你，你缓存在应用服务本地的这个key已经作废了，至于你本地如何缓存的这些数据，redis并不关心，也不负责。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;功能演示&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面将通过一些实例来进行演示，本文代码的运行前提条件是你已经装好了&lt;code&gt;Redis6.x&lt;/code&gt;版本，linux环境下可以直接从官网下载后编译安装，windows环境下的安装可以参考 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwMTgzOTQ0Ng==&amp;amp;mid=2247488620&amp;amp;idx=1&amp;amp;sn=0065c23e5055adddbe9ead318a49c9c6&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;手摸手教你在Windows环境下运行Redis6.x&lt;/a&gt; 这篇文章。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;概念上的东西我们也大体了解了，下面我们分别来看一下客户端缓存具体实现的三种模式（至于为什么多了一种，后面再来细说）。在正式开始前，强烈建议大家先花个十几分钟了解一下 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwMTgzOTQ0Ng==&amp;amp;mid=2247489005&amp;amp;idx=1&amp;amp;sn=ef5ceda185c92758e98b36888d53d34d&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Redis6底层的通信协议RESP3&lt;/a&gt;，否则在看到具体的通信内容时可能会存在一些疑问。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先做一下准备工作，通过&lt;code&gt;telnet&lt;/code&gt;连接redis服务，并切换到&lt;code&gt;resp3&lt;/code&gt;协议模式：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;telnet 127.0.0.1 6379&lt;br/&gt;hello 3&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;1、默认模式&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在使用客户端连接到redis服务后，需要先通过指令开启&lt;code&gt;tracking&lt;/code&gt;模式的功能，因为在客户端连接后这个选项是默认关闭的，会无法收到失效类型的&lt;code&gt;push&lt;/code&gt;消息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;开启&lt;/span&gt;&lt;br/&gt;client tracking on&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;关闭&lt;/span&gt;&lt;br/&gt;client tracking off&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当开启&lt;code&gt;tracking&lt;/code&gt;后的默认模式下，redis服务端会记录每个客户端请求过的key，当key对应的值发生变化时，会发送失效信息给客户端。简单总结一下，也就是说这个模式能够生效的&lt;strong&gt;必要前提条件&lt;/strong&gt;有两个：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们还是在&lt;code&gt;telnet&lt;/code&gt;中来模拟一下这个过程，分别启动两个redis客户端，在client1中先执行&lt;code&gt;get&lt;/code&gt;命令后，再在client2对相同的key执行&lt;code&gt;set&lt;/code&gt;操作修改它的值，之后就会在client1中收到&lt;code&gt;push&lt;/code&gt;类型的消息。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9079563182527302&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicbdISYMMsL8iaw6JWTYeElpIBy8dicdc0qhE2HicicW5lmxoLhojOibBaNrjGd06MGsnjoJV6zsHWm5tYQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;641&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;push&lt;/code&gt;类型的消息我们在RESP3中介绍过了，这里简单再唠叨两句：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;br/&gt;invalidate&lt;br/&gt;*1&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;br/&gt;user&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;起始的第一字节&lt;code&gt;&amp;gt;&lt;/code&gt;表示该消息为&lt;code&gt;push&lt;/code&gt;类型，后面消息体中包含了两部分内容，第一部分表示收到的消息类型为&lt;code&gt;invalidate&lt;/code&gt;，也就是作废类型的信息，第二部分则是需要作废的key是&lt;code&gt;user&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，当一个缓存的key到达失效时间导致过期，或是因为到达最大内存，要使用驱逐策略进行驱逐时，也会对客户端发送&lt;code&gt;PUSH&lt;/code&gt;的消息。下面以缓存的key过期为例：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.9145299145299146&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicbdISYMMsL8iaw6JWTYeElpI7zK86c5B5Cp4UGaxy9dULWtAav83AnuYtVLkichLkjTuicQiagHGDcQUw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;351&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，对于单个key来说，这个&lt;code&gt;tracking&lt;/code&gt;消息只会对客户端发送一次，当第二次修改该key所对应的值后，客户端不会再收到&lt;code&gt;tracking&lt;/code&gt;的消息。只有对这个key再执行一次&lt;code&gt;get&lt;/code&gt;命令，之后才会再次收到&lt;code&gt;tracking&lt;/code&gt;消息。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8611544461778471&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicbdISYMMsL8iaw6JWTYeElpImbfxhg4gz6OBUhI48weyQTPicGLHyINMY3BhD2zgDqWyGKNDyOAQNSg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;641&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认模式虽然使用起来简单，但是需要在服务端存储客户端的访问数据，记录哪些key被哪些客户端访问过。如果访问的不是少量的热点数据的话，可能会占用大量redis服务端的内存空间。应对这种情况，可以试一试下面要介绍的广播模式。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2、广播模式&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在广播模式&lt;code&gt;BCAST&lt;/code&gt;下，redis服务端不再记录key的访问情况，而是无差别地向所有开启&lt;code&gt;tracking&lt;/code&gt;广播的客户端发送消息。这样一来，好处就是不需要浪费redis服务端的内存进行记录，但是坏处就是客户端可能会收到过多的消息，其中可能还会包含自己不需要的一些key。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在使用前，需要先通过命令开启广播模式：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;client tracking on bcast&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面，我们通过一个例子来进行广播模式的使用演示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.06396255850234&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicbdISYMMsL8iaw6JWTYeElpIXcUMZBcx6nar5oclMBx9G77jVF5JUbvU63jNrvGMLmciak5kSLOYLCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;641&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到在开启广播模式后，只要在client2中修改了key对应的值，在client1中都会收到作废消息，而不管client1之前在本地是否进行过缓存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且，另外一点和默认模式不同的是，广播模式是能够重复多次收到一个key的失效消息的，因为服务端没有记录，所以只要有key发生了修改，客户端就会收到失效消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候，有的小伙伴可能就要问了，如果我不想收到这么多没用的冗余消息，有没有什么办法进行一下过滤或精简呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是可以的，在广播模式下，客户端可以只关注一些&lt;strong&gt;特定前缀&lt;/strong&gt;的key，表示我只需要接收这些前缀的key，其他的就不要发给我了。命令格式如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;client tracking on bcast prefix myprefix&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再来看一下使用过程的示例：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9547581903276131&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicbdISYMMsL8iaw6JWTYeElpIkB3wc37bHabT5VvXTshZHJWziaAbAvPapfXf5ILlpdPIQKxPwOSiaegw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;641&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，在设置了只关注以&lt;code&gt;order:&lt;/code&gt;作为前缀的key后，成功过滤掉了&lt;code&gt;user&lt;/code&gt;的失效消息。从这个角度来看，也要求了我们在缓存一个类型的数据时，都以相同的单词作为前缀，规范了我们在使用缓存中对key的命名规则。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至于在业务中具体要使用哪种模式，可能更多的需要进行一下权衡。看一下你究竟是能忍受占用更多redis服务端的内存，还是能够忍受收到大量不需要的失效消息。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;3、转发模式&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认模式和广播模式的生效，都要在开启&lt;code&gt;RESP3&lt;/code&gt;协议的前提下，具体原因看过上面的例子大家应该也都清楚了，因为要使用&lt;code&gt;tracking&lt;/code&gt;的话，就必须要借助到&lt;code&gt;RESP3&lt;/code&gt;协议中的新的&lt;code&gt;push&lt;/code&gt;消息类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么如果客户端还是使用的旧版本&lt;code&gt;RESP V2&lt;/code&gt;的话，也想要体验这一功能，应该如何进行改造呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不得不说redis6的开发者想的还是蛮全面的，为了适配&lt;code&gt;RESP V2&lt;/code&gt;，专门设计了一种新的&lt;strong&gt;转发模式&lt;/strong&gt;，允许使用旧版本协议的客户端通过&lt;code&gt;Pub/Sub&lt;/code&gt;发布订阅功能来接收key的失效信息。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.444794952681388&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicbdISYMMsL8iaw6JWTYeElpIdfRS9Jnu0OPqzpeFN3Tqh8L6iaOuLSj3duic243oZxTVvopEFUFpB23A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;951&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面这张图可以看到，转发模式的核心就是redis服务端会将原先&lt;code&gt;push&lt;/code&gt;类型的&lt;code&gt;tracking&lt;/code&gt;信息，转发到订阅了&lt;code&gt;_redis_:invalidate&lt;/code&gt;这一信道的被指定的客户端上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来梳理一下上面的流程，首先在client1需要使用指令开启转发模式：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;client tracking on bcast redirect [client-id]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相对广播模式，多了两个参数，&lt;code&gt;redirect&lt;/code&gt;表示为转发模式，后面的&lt;code&gt;client-id&lt;/code&gt;表示消息要发送给哪一个客户端，客户端的id可以在client2上通过&lt;code&gt;client id&lt;/code&gt;指令获取。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在client2中，则需要订阅指定的信道：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;subscribe _redis_:invalidate&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实说白了，转发模式还是使用的发布订阅功能罢了，只不过redis帮我们解放了双手，把发送消息的工作由自己完成了。整个操作的流程如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8621997471554994&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicbdISYMMsL8iaw6JWTYeElpI0V1QIuzTVQYDBfPq6CZQRqTiaSk1Kpiay83IuDQA8wIqFoEUibWqKsC9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;791&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，client2中收到的消息格式与之前的&lt;code&gt;push&lt;/code&gt;类型消息不同，是一条RESP V2中多条批量回复格式的消息，表示的含义同样是收到的key已经作废掉了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是，虽然说开启转发模式的指令中也带了一个&lt;code&gt;bcast&lt;/code&gt;，但是它和广播模式有着非常大的区别。在转发模式下，&lt;code&gt;key&lt;/code&gt;的作废消息只能被转发到一个客户端上，如果先后执行两条指定转发指令，那么后执行的指令会覆盖前一指令中转发的&lt;code&gt;client-id&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8060965283657917&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zpom4BeZSicbdISYMMsL8iaw6JWTYeElpI3ia7QMXQg1ib5YWibVv4OL6iaaX5VQiaeSYS0uLq05o0ickiabMe4gRHZ4gdw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1181&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这里是不是多少感觉这个转发模式有点鸡肋，毕竟实际的业务场景中很有可能会有多个客户端的存在，只能转发一个实在是有点说不过去了。不过，也有可能作者就是这么设计，留点缺陷，好让大家更快地拥抱&lt;code&gt;RESP3&lt;/code&gt;……&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好啦，到这里客户端缓存的基本理论和使用就介绍的差不多了，不得不说，Redis6的这个新特性确实给了我们眼前一亮的感觉。从这个新特性也可以看出，Redis大有把缓存从服务端的局限中挣脱出来，染指向客户端，一统缓存江湖的意味。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过这个过程应该并不简单，就像我们前面说的，毕竟只有Redis服务端还不够，还需要优秀的客户端进行支持才行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么下一篇文章，我们就来从实战角度，看看如何改造客户端，让&lt;code&gt;client-side caching&lt;/code&gt;能在项目中落地开花。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这次的分享就到这里，我是Hydra，下篇文章再见。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;官方文档：&lt;/p&gt;&lt;p&gt;https://redis.io/docs/manual/client-side-caching/&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9e55c5ec2faf1027147a89e3430125fb</guid>
<title>vector初始化与否导致的巨大性能差异</title>
<link>https://toutiao.io/k/8uzcpmb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzk0MzI4OTI1Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHhKgtwWvzaYZodgfpphdA6WWKEMXTn6ImCCCuEzlPKicNBcpzBUyjK1XicWwqIwusqLGpwyyOc87JPQ/0?wx_fmt=png&quot; data-nickname=&quot;高性能架构探索&quot; data-alias=&quot;gxnjgts&quot; data-signature=&quot;毕业于中国科学技术大学，现任某互联网公司高级技术专家一职。专注于分享干货，硬货，欢迎关注😄&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你好，我是雨乐！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近在优化引擎代码，在优化的过程中发现一个很奇怪的问题，一个简单的对象，存放在std::vector&amp;lt;&amp;gt; v中，如果v定义的时候为每个元素指定初值，那么后面对v中每个元素的写就飞快；相反的，如果v定义的时候，不指定初始值，那么后面对v中元素写操作的时候，就花费大约前一种2-3倍的时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天，借助此文，分享下原因的排查过程。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;问题&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了能够快速说明问题，直接上代码吧，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;chrono&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;functional&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; num = &lt;span&gt;1000000000&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;AdItem&lt;/span&gt;&lt;br/&gt;{&lt;/span&gt;&lt;br/&gt;     AdItem() {}&lt;br/&gt;&lt;br/&gt;     AdItem(&lt;span&gt;int&lt;/span&gt; x, &lt;span&gt;int&lt;/span&gt; y, &lt;span&gt;int&lt;/span&gt; z)&lt;br/&gt;     {&lt;br/&gt;         x_ = x; y_ = y; z_ = z;&lt;br/&gt;     }&lt;/code&gt;&lt;code&gt;&lt;br/&gt;     &lt;span&gt;int&lt;/span&gt; x_;&lt;br/&gt;     &lt;span&gt;int&lt;/span&gt; y_;&lt;br/&gt;     &lt;span&gt;int&lt;/span&gt; z_;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;time_report&lt;/span&gt;&lt;span&gt;(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;std&lt;/span&gt;::function&amp;lt;&lt;span&gt;void&lt;/span&gt;()&amp;gt; &amp;amp;f1, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;std&lt;/span&gt;::function&amp;lt;&lt;span&gt;void&lt;/span&gt;()&amp;gt; &amp;amp;f2)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;auto&lt;/span&gt; start = &lt;span&gt;std&lt;/span&gt;::chrono::high_resolution_clock::now();&lt;br/&gt;   f1();&lt;br/&gt;   &lt;span&gt;auto&lt;/span&gt; end = &lt;span&gt;std&lt;/span&gt;::chrono::high_resolution_clock::now();&lt;br/&gt;   &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;allocation done in &quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::chrono::duration_cast&amp;lt;&lt;span&gt;std&lt;/span&gt;::chrono::milliseconds&amp;gt;(end - start).count() &amp;lt;&amp;lt; &lt;span&gt;&quot;ms&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;endl&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;   start = &lt;span&gt;std&lt;/span&gt;::chrono::high_resolution_clock::now();&lt;br/&gt;   f2();&lt;br/&gt;   end = &lt;span&gt;std&lt;/span&gt;::chrono::high_resolution_clock::now();&lt;br/&gt;   &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;assignment done in &quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::chrono::duration_cast&amp;lt;&lt;span&gt;std&lt;/span&gt;::chrono::milliseconds&amp;gt;(end - start).count() &amp;lt;&amp;lt; &lt;span&gt;&quot;ms&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;endl&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;uninitialized_performance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;vector&lt;/span&gt;&amp;lt;AdItem&amp;gt; v;&lt;br/&gt;  time_report([&amp;amp;v]() { v.reserve(num); },&lt;br/&gt;          [&amp;amp;v]() {&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; num; ++i) {&lt;br/&gt;              v[i] = {i + &lt;span&gt;2&lt;/span&gt;, i + &lt;span&gt;4&lt;/span&gt;, i + &lt;span&gt;6&lt;/span&gt;};&lt;br/&gt;            } });&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;initialized_performance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;vector&lt;/span&gt;&amp;lt;AdItem&amp;gt; v;&lt;br/&gt;  time_report([&amp;amp;v]() { v.assign(num, AdItem{&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;}); },&lt;br/&gt;          [&amp;amp;v]() {&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; num; ++i) {&lt;br/&gt;              v[i] = {i + &lt;span&gt;2&lt;/span&gt;, i + &lt;span&gt;4&lt;/span&gt;, i + &lt;span&gt;6&lt;/span&gt;};&lt;br/&gt;            } });&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;     uninitialized_performance();&lt;br/&gt;     initialized_performance();&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序输出如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;allocation done in 0ms&lt;br/&gt;assignment done in 59ms&lt;br/&gt;allocation done in 46ms&lt;br/&gt;assignment done in 27ms&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论使用&lt;code&gt;-g -O2 -O3&lt;/code&gt;都是一样的效果，执行多次结果仍然一样。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;CPU Cache&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;CPU缓存（CPU Cache）位于CPU与内存之间的临时存储器，它的容量比内存小但交换速度快。在缓存中的数据是内存中的一小部分，但这一小部分是短时间内CPU即将访问的，当CPU调用大量数据时，就可避开内存直接从缓存中调用，从而加快读取速度。&lt;/p&gt;&lt;p&gt;在CPU中加入缓存是一种高效的解决方案，这样整个内存储器（缓存+内存）就变成了既有缓存的高速度，又有内存的大容量的存储系统了。缓存对CPU的性能影响很大，主要是因为CPU的数据交换顺序和CPU与缓存间的带宽引起的。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到结果以后，第一反应是CPU Cache导致，因为占用的内存大小一样，所以怀疑在第二次访问的时候，因为CPU Cache中已经有缓存，所以直接使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了确认是否是因为CPU Cache而导致的性能差异，所以将测试分成两个独立的程序进行，即分别执行&lt;code&gt;uninitialized_performance()&lt;/code&gt;和&lt;code&gt;initialized_performance()&lt;/code&gt;函数，结果与之前的一致，所以&lt;strong&gt;排除CPU Cache的原因&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;perf工具&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;perf是用来进行软件性能分析的工具,可以利用PMU、tracepoint和内核中的特殊计数器来进行性能统计，用来分析内核和应用程序的性能。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;perf stat uninitialized_performance&lt;/code&gt;结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Performance counter stats &lt;span&gt;for&lt;/span&gt; &lt;span&gt;&#x27;uninitialized_performance&#x27;&lt;/span&gt;:&lt;br/&gt;&lt;br/&gt;         47.923956      task-clock (msec)         &lt;span&gt;#    0.985 CPUs utilized&lt;/span&gt;&lt;br/&gt;                 6      context-switches          &lt;span&gt;#    0.125 K/sec&lt;/span&gt;&lt;br/&gt;                 0      cpu-migrations            &lt;span&gt;#    0.000 K/sec&lt;/span&gt;&lt;br/&gt;             1,007      page-faults               &lt;span&gt;#    0.021 M/sec&lt;/span&gt;&lt;br/&gt;        99,354,240      cycles                    &lt;span&gt;#    2.073 GHz                      (83.33%)&lt;/span&gt;&lt;br/&gt;        72,689,011      stalled-cycles-frontend   &lt;span&gt;#   73.16% frontend cycles idle     (83.46%)&lt;/span&gt;&lt;br/&gt;        48,738,086      stalled-cycles-backend    &lt;span&gt;#   49.05% backend cycles idle      (66.66%)&lt;/span&gt;&lt;br/&gt;        98,377,529      instructions              &lt;span&gt;#    0.99  insn per cycle&lt;/span&gt;&lt;br/&gt;                                                  &lt;span&gt;#    0.74  stalled cycles per insn  (83.32%)&lt;/span&gt;&lt;br/&gt;        11,399,060      branches                  &lt;span&gt;#  237.857 M/sec                    (83.39%)&lt;/span&gt;&lt;br/&gt;            19,617      branch-misses             &lt;span&gt;#    0.17% of all branches          (83.16%)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;perf stat initialized_performance&lt;/code&gt;结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;76.092443      task-clock (msec)         &lt;span&gt;#    0.991 CPUs utilized&lt;/span&gt;&lt;br/&gt;                 6      context-switches          &lt;span&gt;#    0.079 K/sec&lt;/span&gt;&lt;br/&gt;                 0      cpu-migrations            &lt;span&gt;#    0.000 K/sec&lt;/span&gt;&lt;br/&gt;             1,007      page-faults               &lt;span&gt;#    0.013 M/sec&lt;/span&gt;&lt;br/&gt;       157,742,162      cycles                    &lt;span&gt;#    2.073 GHz                      (82.94%)&lt;/span&gt;&lt;br/&gt;       110,940,710      stalled-cycles-frontend   &lt;span&gt;#   70.33% frontend cycles idle     (82.96%)&lt;/span&gt;&lt;br/&gt;        72,531,622      stalled-cycles-backend    &lt;span&gt;#   45.98% backend cycles idle      (65.92%)&lt;/span&gt;&lt;br/&gt;       178,142,743      instructions              &lt;span&gt;#    1.13  insn per cycle&lt;/span&gt;&lt;br/&gt;                                                  &lt;span&gt;#    0.62  stalled cycles per insn  (82.99%)&lt;/span&gt;&lt;br/&gt;        31,488,875      branches                  &lt;span&gt;#  413.824 M/sec                    (84.01%)&lt;/span&gt;&lt;br/&gt;            24,309      branch-misses             &lt;span&gt;#    0.08% of all branches          (84.17%)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为perf只能得到整个程序执行期间的变化，而我们实际上需要的是核心部分，看来通过perf得到有用的信息，只能另寻他法。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;源码跟踪&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;截止到现在，上述方案都没能解答本次问题的疑问，只能祭出屠龙刀，看源码了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;未初始化版&lt;/code&gt;调用信息如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;-&amp;gt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;vector&lt;/span&gt;&amp;lt;AdItem, &lt;span&gt;std&lt;/span&gt;::allocator&amp;lt;AdItem&amp;gt; &amp;gt;::&lt;span&gt;vector&lt;/span&gt;&lt;br/&gt;--&amp;gt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;vector&lt;/span&gt;&amp;lt;AdItem, &lt;span&gt;std&lt;/span&gt;::allocator&amp;lt;AdItem&amp;gt; &amp;gt;::_M_default_initialize&lt;br/&gt;---&amp;gt; &lt;span&gt;std&lt;/span&gt;::__uninitialized_default_n_a&amp;lt;AdItem*, &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;, AdItem&amp;gt;&lt;br/&gt;----&amp;gt; &lt;span&gt;std&lt;/span&gt;::__uninitialized_default_n&amp;lt;AdItem*, &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&amp;gt;&lt;br/&gt;-----&amp;gt; &lt;span&gt;std&lt;/span&gt;::__uninitialized_default_n_1&amp;lt;&lt;span&gt;false&lt;/span&gt;&amp;gt;::__uninit_default_n&amp;lt;AdItem*, &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&amp;gt;&lt;br/&gt;------&amp;gt; &lt;span&gt;std&lt;/span&gt;::_Construct(&lt;span&gt;std&lt;/span&gt;::__addressof(*__cur))&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;初始化版&lt;/code&gt;调用信息如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;-&amp;gt; std::vector&amp;lt;AdItem, std::allocator&amp;lt;AdItem&amp;gt; &amp;gt;::vector&lt;br/&gt;--&amp;gt; std::vector&amp;lt;AdItem, std::allocator&amp;lt;AdItem&amp;gt; &amp;gt;::_M_fill_initialize&lt;br/&gt;---&amp;gt; std::__uninitialized_fill_n_a&amp;lt;AdItem*, unsigned long, AdItem, AdItem&amp;gt;&lt;br/&gt;----&amp;gt; std::uninitialized_fill_n&amp;lt;AdItem*, unsigned long, AdItem&amp;gt;&lt;br/&gt;-----&amp;gt; std::__uninitialized_fill_n&amp;lt;&lt;span&gt;false&lt;/span&gt;&amp;gt;::__uninit_fill_n&amp;lt;AdItem*, unsigned long, AdItem&amp;gt;&lt;br/&gt;------&amp;gt; std::_Construct(std::__addressof(*__cur), __x)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上述函数调用信息可以看出，初始化版本和都调用了std::_Construct函数，而该函数通过其名称就能看到，是调用了构造函数对内存块进行构造(底层是用&lt;code&gt;placement new&lt;/code&gt;实现)，得不到我们有用的信息。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;汇编&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们从汇编角度来看下(为了篇幅，去掉了无关紧要的部分以及相同的部分)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;未初始化版本：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;uninitialized_performance():&lt;br/&gt;  mov QWORD PTR [rsp+104], OFFSET FLAT:std::_Function_handler&amp;lt;void (), uninitialized_performance()::{lambda()#2}&amp;gt;::_M_invoke(std::_Any_data const&amp;amp;)&lt;br/&gt;  mov QWORD PTR [rsp+80], rax&lt;br/&gt;  mov QWORD PTR [rsp+96], OFFSET FLAT:std::_Function_base::_Base_manager&amp;lt;uninitialized_performance()::{lambda()#2}&amp;gt;::_M_manager(std::_Any_data&amp;amp;, std::_Any_data const&amp;amp;, std::_Manager_operation)&lt;br/&gt;  mov QWORD PTR [rsp+48], rax&lt;br/&gt;  mov QWORD PTR [rsp+72], OFFSET FLAT:std::_Function_handler&amp;lt;void (), uninitialized_performance()::{lambda()#1}&amp;gt;::_M_invoke(std::_Any_data const&amp;amp;)&lt;br/&gt;  mov QWORD PTR [rsp+64], OFFSET FLAT:std::_Function_base::_Base_manager&amp;lt;uninitialized_performance()::{lambda()#1}&amp;gt;::_M_manager(std::_Any_data&amp;amp;, std::_Any_data const&amp;amp;, std::_Manager_operation)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初始化版本：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;initialized_performance():&lt;br/&gt;  mov QWORD PTR [rsp+64], rsp&lt;br/&gt;  mov QWORD PTR [rsp+88], OFFSET FLAT:std::_Function_handler&amp;lt;void (), initialized_performance()::{lambda()#2}&amp;gt;::_M_invoke(std::_Any_data const&amp;amp;)&lt;br/&gt;  mov QWORD PTR [rsp+80], OFFSET FLAT:std::_Function_base::_Base_manager&amp;lt;initialized_performance()::{lambda()#2}&amp;gt;::_M_manager(std::_Any_data&amp;amp;, std::_Any_data const&amp;amp;, std::_Manager_operation)&lt;br/&gt;  mov QWORD PTR [rsp+32], rsp&lt;br/&gt;  mov QWORD PTR [rsp+56], OFFSET FLAT:std::_Function_handler&amp;lt;void (), initialized_performance()::{lambda()#1}&amp;gt;::_M_invoke(std::_Any_data const&amp;amp;)&lt;br/&gt;  mov QWORD PTR [rsp+48], OFFSET FLAT:std::_Function_base::_Base_manager&amp;lt;initialized_performance()::{lambda()#1}&amp;gt;::_M_manager(std::_Any_data&amp;amp;, std::_Any_data const&amp;amp;, std::_Manager_operation)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上述汇编结果没看到有什么区别，所以排除了语言层面的区别了，尝试从其它方面进行分析。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;lazy allocation&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然源码和汇编都看不出来区别，那么只能从另外一个方向来进行考虑，那就是&lt;code&gt;内存分配&lt;/code&gt;，有没有可能虽然是都调用了new进行内存分配，但是实际上并没有分配呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;记得之前看过一些文章，说是操作系统有个&lt;code&gt;lazy allocation（延迟分配）&lt;/code&gt;机制，即用户调用API进行内存分配的时候，操作系统并不会直接分配给用户这么多内存，而是直到用户真的访问了申请的page时产生一个page falut，然后将这个page真的分配给用户，并重新执行产生page fault的语句。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们使用以下例子进行验证：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;X&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; x_[&lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;24&lt;/span&gt;];&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;auto&lt;/span&gt; x = &lt;span&gt;new&lt;/span&gt; X;&lt;br/&gt;    sleep(&lt;span&gt;100&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后通过&lt;code&gt;htop -p xxx&lt;/code&gt;命令查看信息，如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1244343891402715&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHgicKYkawpGRm5ImNWe1fxhm52j5nVhcJUHnBmhhPuTocLZno0QgiaUsYVYl8dpgnVW4JnN9v7e2yug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;884&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后，我们尝试将代码进行修改如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;X&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; x_[&lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;24&lt;/span&gt;];&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;auto&lt;/span&gt; x = &lt;span&gt;new&lt;/span&gt; X;&lt;br/&gt;    &lt;span&gt;memset&lt;/span&gt;(x-&amp;gt;x_, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;(x-&amp;gt;x_)); &lt;span&gt;// 增加了该句，仅仅为了访问&lt;/span&gt;&lt;br/&gt;    sleep(&lt;span&gt;100&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.07568807339449542&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHgicKYkawpGRm5ImNWe1fxhmt0yOibHHjWmCDM5ejQwyCI39lbKeeq3C0XYUrILQzkUFbJqyAv2ADXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;872&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上述htop的输出信息的&lt;code&gt;RES&lt;/code&gt;块可以看出，第二次调用分配了足够的虚拟内存，这就验证了我们这次的结论，即使使用了new，在真正使用之前是&lt;code&gt;没有被真正的分配虚拟内存&lt;/code&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;Lazy allocation simply means not allocating a resource until it is actually needed.&lt;/strong&gt; This is common with singleton objects, but strictly speaking, any time a resource is allocated as late as possible, you have an example of lazy allocation.&lt;/p&gt;&lt;p&gt;By delaying allocation of a resource until you actually need it, you can &lt;strong&gt;decrease startup time, and even eliminate the allocation entirely if you never actually use the object&lt;/strong&gt;. In contrast, you could pre-allocate a resource you expect to need later, which can make later execution more efficient at the expense of startup time, and also avoids the possibility of the allocation failing later in program execution.&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在，我们从&lt;code&gt;lazy allocation&lt;/code&gt;角度来分析该问题。对于未初始化的vector，该vector申请了一大块内存，operator new只是返回了虚拟地址(此时并未将物理地址与其关联)，当具体访问数据(for循环)的时候，操作系统才会将虚拟地址与物理地址进行关联。而在构造时给初值，算是访问大块连续逻辑空间，操作系统会将虚拟地址与物理地址相关联，这样在后面访问的时候，因为已经访问了一次了，所以会很快。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在源码一节中，我们提到未初始化版本和初始化版本最终分别调用了&lt;code&gt;std::_Construct(std::__addressof(*__cur))&lt;/code&gt;和&lt;code&gt;_Construct(std::__addressof(*__cur), __x)&lt;/code&gt;，下面是其具体实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;未初始化版本：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;template&lt;/span&gt;&amp;lt;&lt;span&gt;typename&lt;/span&gt; _T1, &lt;span&gt;typename&lt;/span&gt;... _Args&amp;gt;&lt;br/&gt;   &lt;span&gt;inline&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;br/&gt;   _Construct(_T1* __p, _Args&amp;amp;&amp;amp;... __args) { &lt;br/&gt;    ::&lt;span&gt;new&lt;/span&gt;(&lt;span&gt;static_cast&lt;/span&gt;&amp;lt;&lt;span&gt;void&lt;/span&gt;*&amp;gt;(__p)) _T1(&lt;span&gt;std&lt;/span&gt;::forward&amp;lt;_Args&amp;gt;(__args)...); &lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初始化版本如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &lt;span&gt;inline&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;br/&gt;   _Construct(_T1* __p, &lt;span&gt;const&lt;/span&gt; _T2&amp;amp; __value) {&lt;br/&gt;     ::&lt;span&gt;new&lt;/span&gt;(&lt;span&gt;static_cast&lt;/span&gt;&amp;lt;&lt;span&gt;void&lt;/span&gt;*&amp;gt;(__p)) _T1(__value);&lt;br/&gt;   }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;std::_Construct是在std::vector&amp;lt;&amp;gt;定义中进行调用的，也就是说都访问了对应的地址，但是为什么区别这么大呢？后面，对示例代码进行了修改：&lt;/p&gt;&lt;section&gt;1、在默认的构造函数中对变量进行了赋值初始化操作&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span/&gt;&lt;span&gt;AdItem(&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;         x_ = 0; y_ = 0; z_ = z;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;2、对构造函数使用default关键字&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt; &lt;span&gt;AdItem(&lt;/span&gt;&lt;span&gt;) = default;&lt;/span&gt;&lt;span/&gt;&lt;/code&gt;&lt;p/&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;修改之后，再次编译，运行，未初始化版本和初始化版本的性能结果基本一致，进一步验证了我们的猜想&lt;/span&gt;&lt;code&gt;lazy allocation&lt;/code&gt;&lt;span&gt;引起的性能差异。&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;结语&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开发过程，就是一个&lt;code&gt;不断采坑&lt;/code&gt;的过程，从一个坑到另一个坑，技术才能成长。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，今天的文章就到这，我们下期见！&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>31be310e12f5148c6efbd2ea28b28bc4</guid>
<title>Golang用proto文件同时生成gRPC和HTTP</title>
<link>https://toutiao.io/k/t6bq5xo</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;strong&gt;&lt;span&gt;这里是Z哥的个人公众号&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;每周五11：45 按时送达&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;当然了，也会时不时加个餐～&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;我的第「224」篇原创敬上&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;大家好，我是Z哥。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;做技术的都知道，程序之间的通讯，常用的方式有两种，RPC 和 HTTP。普遍的共识是系统内部的各个子系统之间的通讯用 RPC，与外部系统之间的通讯用 HTTP。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了避免需要分别编写两套契约文件来生成两套 API（.proto 和 .api），如果能够根据同一份契约文件生成两套 API 的代码就太棒了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Z哥目前所在的公司，rpc 使用的框架是 gRPC，所以自然先想得是，是否能够根据一份 proto 文件，同时生成 gRPC 和 HTTP 的 stub 代码呢。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;网上很快就找到了一个符合要求的框架。相信不少 gopher 们应该也听说过或者正在使用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;46&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;https://github.com/grpc-ecosystem/grpc-gateway&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;框架的原理用一张图即可表达。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6785714285714286&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oB5bd6W6hI3YVXf0Zbucyv7GAQTfuVjCp8knSDvjvU1dKFAWCicc48BNHNtLeH8NJJOIU30l0cibCsyXZ3ZWqgEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1120&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;通过一份 proto 文件，在生成 gRPC 代码的同时生成一个基于 HTTP1.1 + JSON 的反向代理 gateway，如此一来，既可以通过 gRPC 的方式直接调用实际的 server ，也可以通过反向代理中转一次来访问 server。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;具体的使用方式看 github 上的官方教程即可，Z 哥和你主要聊一下其中可能会遇到的卡点。毕竟国内的网络情况你懂的，有些操作可能会遇到一些困难。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;/01  不会科学上网不要用buf/&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;教程里提供了两种来操作，一种是通过基础工具 protoc 来操作，另一种是通过一个基于 protoc 封装的工具 buf 来操作。protoc 可以基于 go mod 来安装，鉴于 go mod 还有国内的镜像站点可以解决访问的困难，建议不会科学上网的小伙伴通过 protoc 来操作，因为你没办法成功安装 buf。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;/02  手动下载 googleapis 的repo/&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;然后，当你定义 gateway 的时候，需要引入一些 google 的 packages，怎么办呢？直接去 github 上下载，具体地址是：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;40&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;https://github.com/googleapis/googleapis&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;如果可以的话，建议把整个仓库都下载下来，否则就单独下载教程里提到的4个文件即可。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;特别要注意的是，在 googleapis/google/目录下缺少的 protobuf 相关文件需要到下面的 repo 里去下载，并且放到 googleapis/google/目录下。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;73&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;https://github.com/protocolbuffers/protobuf/tree/main/src/google/protobuf&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;/03  protoc -I 指定查找目录/&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;官方教程里的 protoc -I . 只会查找当前命令执行所在目录的范围，所以如果你下载的 googlesapi 不存放在当前目录下，则需要增加额外信息指定一下查找目录。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;指定的方式是再增加一个 -I，命令如下（其中第二行就是新增的用于查找 google packages 的目录）：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;protoc&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;-I ./ \&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    -I $GOPATH/src/googleapis\&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    --grpc-gateway_out ./gen/go \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    --grpc-gateway_opt logtostderr=true \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    --grpc-gateway_opt paths=source_relative \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    --grpc-gateway_opt generate_unbound_methods=true \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    your/service/v1/your_service.proto&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果还有其它目录需要查找，那么继续增加 -I 即可。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;好了需要注意的点就是以上3个，官方教程中提到的三个命令可以一起执行，这样便可同时生成 gRPC server、gateway 和 swagger.json ：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;protoc&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;-I ./ \&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    -I $GOPATH/src/googleapis\&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    --go_out ./gen/go/ --go_opt paths=source_relative \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    --go-grpc_out ./gen/go/ --go-grpc_opt paths=source_relative \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    --grpc-gateway_out ./gen/go/  \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    --grpc-gateway_opt logtostderr=true \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    --grpc-gateway_opt paths=source_relative \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    --grpc-gateway_opt generate_unbound_methods=true \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    --openapiv2_out . --openapiv2_opt logtostderr=true \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    your/service/v1/your_service.proto&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;关于一些gRPC-Gateway的其它用法可以参考：&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;46&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;https://grpc-ecosystem.github.io/grpc-gateway/&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;好了，这篇呢，Z哥和你分享了如何用一份 proto 文件同时生成 gRPC 和 HTTP 的 Stub 代码以及 Swagger 文档。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如此不但可以提高效率，还可以避免维护两份不同的契约文件所带来不一致风险，希望对你有所帮助。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;推荐阅读：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;原创不易，如果你觉得这篇文章还不错，就「&lt;/span&gt;&lt;span&gt;&lt;strong&gt;点赞&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;」或者「&lt;span&gt;&lt;strong&gt;在看&lt;/strong&gt;&lt;/span&gt;」一下吧，鼓励我的创作 ：）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;也可以分享我的公众号名片给有需要的朋友们。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU2NzEwMDc4OQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/oB5bd6W6hI1ENbrFbGjEucl1Az92hEuwmUSdaNXxibiaWuO9sLTPHokw00p8ZxAYdIJJJ7FXj77Ts0YoV5KwEKCA/0?wx_fmt=png&quot; data-nickname=&quot;跨界架构师&quot; data-alias=&quot;Zachary_ZF&quot; data-signature=&quot;坚持原创。专注大型互联网技术，涉猎产品、运营。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;如果你有关于软件架构、分布式系统、产品、运营的困惑&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以试试点击「&lt;strong&gt;阅读原文&lt;/strong&gt;」&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>