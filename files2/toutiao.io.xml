<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>b93b512443ed8f91b10007c6fa41f47e</guid>
<title>秋天的第一份 IT 技术周刊 | 码农周刊第 320 期</title>
<link>https://toutiao.io/k/9ew44gv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;issue&quot; id=&quot;readabilityBody&quot;&gt;
        &lt;h1&gt;秋天的第一份 IT 技术周刊 | 码农周刊第 320 期&lt;/h1&gt;
        &lt;h2&gt;码农周刊第320期（2020-09-29）&lt;/h2&gt;
        &lt;p&gt;☞ &lt;a href=&quot;https://weekly.manong.io/bounce?nid=320&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3200&quot; target=&quot;_blank&quot;&gt;秋天的第一份 IT 技术周刊，请查收！&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;a href=&quot;https://weekly.manong.io/bounce?nid=320&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3200&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_320.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;small&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=320&amp;amp;aid=19185&amp;amp;url=https%3A%2F%2Fjinshuju.net%2Ff%2FV7DxN9&quot; target=&quot;_blank&quot;&gt;商务合作&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
        
        &lt;h3 id=&quot;程序设计&quot;&gt;程序设计&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;业界实战&lt;/p&gt;
        
        &lt;p&gt;思考和实践&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;VIP会员专区&quot;&gt;VIP会员专区&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;工作地点：成都 | 薪资：15-30K | 简历投递邮箱：xiexiaofang@huobi.com&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;由 JavaScript 之父 Brendan Eich 与 ES6 规范首席作者 Allen Wirfs-Brock 联合编写，详细记载和解读了自 1995 年语言诞生到 2015 年 ES6 规范制定为止，共计 20 年的 JavaScript 语言演化经历。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;支持 mp4, flv, m3u8 及 rtmp 协议的直播，支持移动端，PC 端。&lt;/p&gt;
        &lt;h3 id=&quot;工具资料&quot;&gt;工具资料&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;利器&lt;/p&gt;
        
        &lt;p&gt;实打实的干货&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;容易踩的坑&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;图文并茂&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;细致分析&lt;/p&gt;
        
        &lt;p&gt;方案和思路&lt;/p&gt;
        
        &lt;p&gt;一些实践和工具&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程语言&quot;&gt;编程语言&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;报告详情&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;深入探讨&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;结合代码&lt;/p&gt;
        &lt;h3 id=&quot;每周独家号推荐&quot;&gt;每周独家号推荐&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;java相关技术分享&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 444692 即可&lt;/p&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 444414 即可&lt;/p&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 435415 即可&lt;/p&gt;
        
        &lt;p&gt;不定期更新一些机器学习算法，方便大家浏览，然后一起学习，一起进步&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 104739 即可&lt;/p&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 99181 即可&lt;/p&gt;
        &lt;h3 id=&quot;每周一书&quot;&gt;每周一书&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;本书深入地讲解了 Go 语言常见特性的内部机制和实现方式，大部分内容源自对 Go 语言源码的分析，并从中提炼出实现原理。欢迎到&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;兑换阅读。&lt;/p&gt;
        &lt;h3 id=&quot;编程之外&quot;&gt;编程之外&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;值得推荐&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;无代码开发平台&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;p&gt;
        &lt;/p&gt;
        
        
        
        
        &lt;div class=&quot;qrcode&quot;&gt;
  &lt;img src=&quot;https://img.toutiao.io/ads/vip_qrcode.png&quot; alt=&quot;Qrcode 258&quot;/&gt;&lt;span&gt;加入码农周刊VIP会员&lt;/span&gt;
&lt;/div&gt;
    &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8afa87ddeecb052b13f84d0492e0bd62</guid>
<title>Java 的强引用、软引用、弱引用、虚引用</title>
<link>https://toutiao.io/k/aqeo426</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;strong&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;工程中用到guava的本地缓存。它底层实现和API接口上使用了强引用、软引用、弱引用。所以温故知新下，也夯实下基础。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;预备知识&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;先来看下GC日志每个字段的含义&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Young GC示例解释&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;[GC (Allocation Failure) [PSYoungGen: 273405K-&amp;gt;20968K(278016K)] 480289K-&amp;gt;473619K(737792K), 0.1090103 secs] [Times: user=0.19 sys=0.27, real=0.11 secs] &lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;解释&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;[GC(产生GC的原因，例子中是由于分配内存失败)  [PSYoungGen: 年轻代回收前空间-&amp;gt;年轻代回收后空间(年轻代总空间)] 堆区的回收前空间-&amp;gt;堆区的回收后空间(堆区的总空间), GC耗时] [Times: 用户空间耗时 系统空间耗时, 实际耗时]&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Full GC示例解释 &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;[Full GC (Ergonomics) [PSYoungGen: 20968K-&amp;gt;20805K(278016K)] [ParOldGen: 452651K-&amp;gt;451654K(864256K)] 473619K-&amp;gt;472460K(1142272K), [Metaspace: 5793K-&amp;gt;5793K(1056768K)], 0.1565987 secs] [Times: user=0.70 sys=0.00, real=0.16 secs] &lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;解释&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;[Full GC (产生GC原因，例子中是由于要放入老年代的对象超过了老年代的剩余空间) [PSYoungGen: -&amp;gt;年轻代回收前空间-&amp;gt;年轻代回收后空间(年轻代总空间)] [ParOldGen: 老年代回收前空间-&amp;gt;老年代回收后空间(老年代总空间)] 堆区的回收前空间-&amp;gt;堆区的回收后空间(堆区的总空间), [Metaspace: 元空间的回收前空间-&amp;gt;元空间的回收后空间(元空间的总空间)],  GC耗时] [Times: 用户空间耗时 系统空间耗时, 实际耗时]&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;创建一个10M的大对象，重写finalize方法。&lt;span&gt;finalize()方法会在对象被回收前调用&lt;/span&gt;，一个对象只有一次被调用的机会。对象可以在这个方法里进行自救，逃过被垃圾回收。Java设计这个方法可以被覆写是为了让有些对象在回收前做一些检查，完成一些前置条件再被垃圾回收。正式代码不建议使用。因为是测试，所以为了验证效果，这里打印GC日志信息。&lt;/p&gt;&lt;pre&gt;   &lt;span&gt;byte&lt;/span&gt;[] &lt;span&gt;bytes &lt;/span&gt;= &lt;span&gt;new byte&lt;/span&gt;[&lt;span&gt;10 &lt;/span&gt;* &lt;span&gt;1024 &lt;/span&gt;* &lt;span&gt;1024&lt;/span&gt;]&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    int &lt;/span&gt;&lt;span&gt;index&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    public &lt;/span&gt;&lt;span&gt;Ref&lt;/span&gt;(&lt;span&gt;int &lt;/span&gt;index) {&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.&lt;span&gt;index &lt;/span&gt;= index&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;}&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public byte&lt;/span&gt;[] &lt;span&gt;getBytes&lt;/span&gt;() {&lt;br/&gt;        &lt;span&gt;return &lt;/span&gt;&lt;span&gt;bytes&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;}&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;public void &lt;/span&gt;&lt;span&gt;finalize&lt;/span&gt;() {&lt;br/&gt;        System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;index &quot; &lt;/span&gt;+ &lt;span&gt;index &lt;/span&gt;+ &lt;span&gt;&quot;&#x27;s &quot; &lt;/span&gt;+ &lt;span&gt;bytes&lt;/span&gt;.&lt;span&gt;length &lt;/span&gt;+ &lt;span&gt;&quot;is going to be GG&quot;&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;}&lt;br/&gt;}&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为了测试，JVM参数统一为-Xms20M -XX:+PrintGCDetails。Xms20M表示堆内存设置最大为20M，-XX:+PrintGCDetails代表打印详细的GC信息。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.27121212121212124&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8BX6jNE4EIJlWcdOVshEOc4PO0LwuH19d9VRabzeL6524srlElTlES8uDQH38tOteHO38ZRd7qMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;660&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;强引用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;先来做个实验(代码已经上传github:https://github.com/xiexiaojing/yuna)&lt;/p&gt;&lt;pre&gt;&lt;span&gt;@Test&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public void  &lt;/span&gt;&lt;span&gt;testRawStrong&lt;/span&gt;() {&lt;br/&gt;    List&amp;lt;Ref&amp;gt; list = Lists.&lt;span&gt;newArrayList&lt;/span&gt;()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    for&lt;/span&gt;(&lt;span&gt;int &lt;/span&gt;i=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;; &lt;/span&gt;i&amp;lt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;; &lt;/span&gt;i++) {&lt;br/&gt;        list.add(&lt;span&gt;new &lt;/span&gt;Ref(i))&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;System.&lt;span&gt;out&lt;/span&gt;.println(list.get(i))&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;}&lt;br/&gt;}&lt;/pre&gt;&lt;p&gt;这段代码由上线的设置可知，由于最大设置20M堆空间，所以很快触发了GC。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5420560747663551&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8BX6jNE4EIJlWcdOVshEOcys5BbW6mNf2VM22RNpUzhicQH4dc5rl1f7vhszq5T6FibEKdNv8FWySQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1498&quot;/&gt;&lt;/p&gt;&lt;p&gt;不过Xmx这个值是建议内存最大使用值。如果内存使用超过这个值，jvm认为还有内存可以使用，也会将对象一直往堆里面放。所以2次GC之后JVM自动扩容了，之后就不再频繁GC。最终用到了满足程序需要的内存。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.29752770673486784&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8BX6jNE4EIJlWcdOVshEOcFVl5HYPNDRe5Z2LLoUnLCwXxxWibdNp5XVRBVO9q7j7EPM12iay0vXpQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1173&quot;/&gt;&lt;/p&gt;&lt;p&gt;强引用是直接new出来调用的对象，大家都知道。由上面实验可知，在系统内存很富裕的情况下，因为强引用内存不能被释放，所以会多申请了很多内存。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;软引用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;软引用会&lt;span&gt;在系统将要发生内存溢出异常之前，将会把这些软引用对象列进回收范围进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用实验说明一下，为了防止JVM自动调整堆大小，我们把堆设置-Xmx200M。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;span&gt;@Test&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public void  &lt;/span&gt;&lt;span&gt;testRawSoft&lt;/span&gt;() {&lt;br/&gt;    List&amp;lt;SoftReference&amp;lt;Ref&amp;gt;&amp;gt; list = Lists.&lt;span&gt;newArrayList&lt;/span&gt;()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    for&lt;/span&gt;(&lt;span&gt;int &lt;/span&gt;i=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;; &lt;/span&gt;i&amp;lt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;; &lt;/span&gt;i++) {&lt;br/&gt;        list.add(&lt;span&gt;new &lt;/span&gt;SoftReference&amp;lt;&amp;gt;(&lt;span&gt;new &lt;/span&gt;Ref(i)))&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;System.&lt;span&gt;out&lt;/span&gt;.println(list.get(i).get())&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;}&lt;br/&gt;}&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;从下面实验结果可以看到数次的 GC之后，内存要撑不住的时候，Ref的软引用对象触发了finalize方法。这意味着它将要被内存回收了。说明GC会引发软引用里对象的内存回收，即使这个软引用本身还被强引用(list调用)着。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5596885813148789&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9Mq8jxswkOiaGFdC9LKfBgEMBWMeuicibVAaxgveYtHbpy4yludiasSxia4h5dKBlhZSqOhiconCqhJ7OA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1156&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最终回收了这些内存也不能避免OOM的结局：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.659963436928702&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9Mq8jxswkOiaGFdC9LKfBgEHjg7CTT4wcEv5zBAGPqYY87gDamQhFk6S7VlcJt2tDcCuRMiaVibG6AQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1094&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;因为软引用通常情况下就是这样，只有内存马上要溢出了才触发它的GC。就好像扁鹊见蔡桓公的时候，蔡桓公的病已经很深了，马上就没救了。所以有了下面弱引用的方法：有病早治。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;弱引用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;弱引用是发生了一次垃圾回收后，既存的弱引用对象就开始回收。通常，一个弱引用对象仅能生存到下一次垃圾回收前。&lt;/p&gt;&lt;p&gt;用实验说明一下，为了防止JVM自动调整堆大小，我们把堆设置-Xmx200M。&lt;/p&gt;&lt;pre&gt;&lt;span&gt;@Test&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public void  &lt;/span&gt;&lt;span&gt;testRawWeak&lt;/span&gt;() {&lt;br/&gt;    List&amp;lt;WeakReference&amp;lt;Ref&amp;gt;&amp;gt; list = Lists.&lt;span&gt;newArrayList&lt;/span&gt;()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    for&lt;/span&gt;(&lt;span&gt;int &lt;/span&gt;i=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;; &lt;/span&gt;i&amp;lt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;; &lt;/span&gt;i++) {&lt;br/&gt;        list.add(&lt;span&gt;new &lt;/span&gt;WeakReference&amp;lt;&amp;gt;(&lt;span&gt;new &lt;/span&gt;Ref(i)))&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;System.&lt;span&gt;out&lt;/span&gt;.println(list.get(i).get())&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;}&lt;br/&gt;}&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;从下面的实验结果可知在发生了一次GC之后，已经生成的软引用对象都都回收了。下一次GC，这中间产生的软引用对象也都被回收了。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.37986577181208053&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9Mq8jxswkOiaGFdC9LKfBgE7XjK6eOTQ3rD47hPAKia413gCBhO1HibM9hxibRl5xVnnxQZ985yheZdg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1490&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;最终，由于GC及时，整个过程没有爆发OOM，平安的结束了。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5738893925657298&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9Mq8jxswkOiaGFdC9LKfBgErrPAZvnTjcGufVGOl1RV3pxGMuXtHBbeOaYzOrZnpB2vshAe01Zttg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1103&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;虚引用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;虚引用也叫幻影引用。任何时候可能被GC回收，就像没有引用一样。&lt;/p&gt;&lt;p&gt;并且他必须和引用队列一起使用，用于跟踪垃圾回收过程，当垃圾回收器回收一个持有虚引用的对象时，在回收对象后，将这个虚引用对象加入到引用队列中，用来通知应用程序垃圾的回收情况。&lt;/p&gt;&lt;p&gt;&lt;span&gt;先来实验一下，从下面结果可看到从一开始取出来就是空对象，基本上刚创建出来就被回收了。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.0977835723598435&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8BX6jNE4EIJlWcdOVshEOcwiaeLBciagSbORicnAYC2pvg6AVftA7aKpyjFK36AK8rQ1ibgUIFadbTgg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;767&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;一个像是从来没有存在过的幻影有什么用呢？Java的Unsafe类和NIO都可以直接访问堆外内存。堆外内存GC管不了，这时候虚引用就排上用场了。我们可以通过引用队列跟踪垃圾回收，做好善后。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;在Guava中使用强软弱引用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;span&gt;@Test&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public void &lt;/span&gt;&lt;span&gt;testStrong&lt;/span&gt;() {&lt;br/&gt;    Cache&amp;lt;Integer&lt;span&gt;, &lt;/span&gt;Ref&amp;gt; cache = CacheBuilder.&lt;span&gt;newBuilder&lt;/span&gt;().expireAfterAccess(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;TimeUnit.&lt;span&gt;DAYS&lt;/span&gt;).build()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    for&lt;/span&gt;(&lt;span&gt;int &lt;/span&gt;i=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;; &lt;/span&gt;i&amp;lt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;; &lt;/span&gt;i++) {&lt;br/&gt;        cache.put(i&lt;span&gt;, new &lt;/span&gt;Ref(i))&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;System.&lt;span&gt;out&lt;/span&gt;.println(cache.getIfPresent(i))&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;}&lt;br/&gt;    System.&lt;span&gt;out&lt;/span&gt;.println(cache.stats().loadSuccessCount())&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Test&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public void &lt;/span&gt;&lt;span&gt;testSoft&lt;/span&gt;() {&lt;br/&gt;    Cache&amp;lt;Integer&lt;span&gt;, &lt;/span&gt;Ref&amp;gt; cache = CacheBuilder.&lt;span&gt;newBuilder&lt;/span&gt;().softValues().build()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    for&lt;/span&gt;(&lt;span&gt;int &lt;/span&gt;i=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;; &lt;/span&gt;i&amp;lt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;; &lt;/span&gt;i++) {&lt;br/&gt;        cache.put(i&lt;span&gt;, new &lt;/span&gt;Ref(i))&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;System.&lt;span&gt;out&lt;/span&gt;.println(cache.getIfPresent(i))&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Test&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public void &lt;/span&gt;&lt;span&gt;testWeak&lt;/span&gt;() {&lt;br/&gt;    Cache&amp;lt;Integer&lt;span&gt;, &lt;/span&gt;Ref&amp;gt; cache = CacheBuilder.&lt;span&gt;newBuilder&lt;/span&gt;().weakKeys().weakValues().build()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    for&lt;/span&gt;(&lt;span&gt;int &lt;/span&gt;i=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;; &lt;/span&gt;i&amp;lt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;; &lt;/span&gt;i++) {&lt;br/&gt;        cache.put(i&lt;span&gt;, new &lt;/span&gt;Ref(i))&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;System.&lt;span&gt;out&lt;/span&gt;.println(cache.getIfPresent(i))&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;}&lt;br/&gt;}&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Guava在没有显示设置强、软、弱引用的情况下默认是强引用。这个结论我没有看任何书，而是通过跟踪源码，debug得到的结论。当显示设置为软引用或者弱引用时，运行时GC触发和对象回收之间的关系和自己手动直接测试的结果是一样的，大家可以动手实践下。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Java的强软弱虚引用被回收的时机不同：强引用是引用被释放才会回收；软引用是没释放，但是快OOM了就会被回收；弱引用是引用没释放，但是发生了GC后就会被回收；虚引用随时会回收，好像没有存在过，但是会有一个队列来跟踪它的垃圾回收情况。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;相关阅读&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>75aed32f35935926e4bf5255fd01bc7a</guid>
<title>[译] GraphQL 初体验，Node.js 构建 GraphQL API 指南</title>
<link>https://toutiao.io/k/kovcdmb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;299&quot; data-ratio=&quot;0.5009765625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AOPiaqWez1sKrh7Hffjoia7y8nrFicmqjPJjviabZLNoR1SvrQW94a1OJHxqXibkWaXKVfiaSdvTbj61IIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;来源：https://blog.heroku.com，作者：CHRIS CASTLE&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在过去的几年中，&lt;span&gt;GraphQL[1]&lt;/span&gt;已经成为一种非常流行的API规范，该规范专注于使客户端（无论客户端是前端还是第三方）的数据获取更加容易。&lt;/span&gt;&lt;/section&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;目录：&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;为什么选择GraphQL？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;定义一个GraphQL schema&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;设置解析器&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;运行服务器&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;性能考量&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Schema最佳实践&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;GraphQL什么时候不合适？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;了解更多&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;section&gt;&lt;span&gt;在传统的基于REST的API方法中，客户端发出请求，而服务器决定响应：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;curl https:&lt;span&gt;//api.heroku.space/users/1&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;id&quot;&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;name&quot;&lt;/span&gt;: &lt;span&gt;&quot;Luke&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;email&quot;&lt;/span&gt;: &lt;span&gt;&quot;luke@heroku.space&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;addresses&quot;&lt;/span&gt;: [&lt;br/&gt;    {&lt;br/&gt;    &lt;span&gt;&quot;street&quot;&lt;/span&gt;: &lt;span&gt;&quot;1234 Rodeo Drive&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;city&quot;&lt;/span&gt;: &lt;span&gt;&quot;Los Angeles&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;country&quot;&lt;/span&gt;: &lt;span&gt;&quot;USA&quot;&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  ]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;但是，在GraphQL中，客户端可以精确地确定其从服务器获取的数据。例如，客户端可能只需要用户名和电子邮件，而不需要任何地址信息：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;curl -X POST https:&lt;span&gt;//api.heroku.space/graphql -d &#x27;&lt;/span&gt;&lt;br/&gt;query {&lt;br/&gt;  user(id: &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;    name&lt;br/&gt;    email&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;data&quot;&lt;/span&gt;:&lt;br/&gt;    {&lt;br/&gt;    &lt;span&gt;&quot;name&quot;&lt;/span&gt;: &lt;span&gt;&quot;Luke&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;email&quot;&lt;/span&gt;: &lt;span&gt;&quot;luke@heroku.space&quot;&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;通过这种新的模式，客户可以通过缩减响应来满足他们的需求，从而向服务器进行更高效的查询。对于单页应用(SPA)或其他前端重度客户端应用，可以通过减少有效载荷大小来加快渲染时间。但是，与任何框架或语言一样，GraphQL也需要权衡取舍。在本文中，我们将探讨使用GraphQL作为API的查询语言的利弊，以及如何开始构建实现。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;为什么选择GraphQL？&lt;/h2&gt;&lt;section&gt;&lt;span&gt;与任何技术决策一样，了解GraphQL为你的项目提供了哪些优势是很重要的，而不是简单地因为它是一个流行词而选择它。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;考虑一个使用API连接到远程数据库的SaaS应用程序。你想要呈现用户的个人资料页面，你可能需要进行一次API &lt;/span&gt;&lt;code&gt;&lt;span&gt;GET&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 调用，以获取有关用户的信息，例如用户名或电子邮件。然后，你可能需要进行另一个API调用以获取有关地址的信息，该信息存储在另一个表中。随着应用程序的发展，由于其构建方式的原因，你可能需要继续对不同位置进行更多的API调用。虽然每一个API调用都可以异步完成，但你也必须处理它们的响应，无论是错误、网络超时，甚至暂停页面渲染，直到收到所有数据。如上所述，这些响应的有效载荷可能超过了渲染你当前页面的需要，而且每个API调用都有网络延迟，总的延迟加起来可能很可观。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;使用GraphQL，你无需进行多个API调用（例如 &lt;/span&gt;&lt;code&gt;&lt;span&gt;GET /user/:id&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;GET /user/:id/addresses&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ），而是进行一次API调用并将查询提交到单个端点：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;query {&lt;br/&gt;  user(id: &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;    name&lt;br/&gt;    email&lt;br/&gt;    addresses {&lt;br/&gt;    street&lt;br/&gt;    city&lt;br/&gt;    country&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;然后，GraphQL仅提供一个端点来查询所需的所有域逻辑。如果你的应用程序不断增长，你会发现自己在你的架构中添加了更多的数据存储——PostgreSQL可能是存储用户信息的好地方，而Redis可能是存储其他种类信息的好地方——对GraphQL端点的一次调用将解决所有这些不同的位置，并以他们所请求的数据响应客户端。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果你不确定应用程序的需求以及将来如何存储数据，则GraphQL在这里也很有用。要修改查询，你只需添加所需字段的名称：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    addresses {&lt;br/&gt;      street&lt;br/&gt;+     apartmentNumber   # new information&lt;br/&gt;      city&lt;br/&gt;      country&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;这极大地简化了随着时间的推移而发展你的应用程序的过程。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;定义一个GraphQL schema&lt;/h2&gt;&lt;section&gt;&lt;span&gt;有各种编程语言的GraphQL服务器实现，但在你开始之前，你需要识别你的业务域中的对象，就像任何API一样。就像REST API可能会使用JSON模式一样，GraphQL使用SDL或Schema定义语言来定义它的模式，这是一种描述GraphQL API可用的所有对象和字段的幂等方式。SDL条目的一般格式如下：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; $OBJECT_TYPE {&lt;br/&gt;  $FIELD_NAME($ARGUMENTS): $FIELD_TYPE&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;让我们以前面的例子为基础，定义一下user和address的条目是什么样子的。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; User {&lt;br/&gt;  name:     &lt;span&gt;String&lt;/span&gt;&lt;br/&gt;  email:    &lt;span&gt;String&lt;/span&gt;&lt;br/&gt;  addresses:   [Address]&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Address {&lt;br/&gt;  street:   &lt;span&gt;String&lt;/span&gt;&lt;br/&gt;  city:     &lt;span&gt;String&lt;/span&gt;&lt;br/&gt;  country:  &lt;span&gt;String&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;user&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 定义了两个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;String&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 字段，分别是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;name&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;email&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ，它还包括一个称为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;addresses&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的字段，它是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Addresses&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 对象的数组。&lt;/span&gt;&lt;code&gt;&lt;span&gt;Addresses&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 还定义了它自己的几个字段。（顺便说一下，GraphQL模式不仅有对象，字段和标量类型，还有更多，你也可以合并接口，联合和参数，以构建更复杂的模型，但本文中不会介绍。）&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们还需要定义一个类型，这是我们GraphQL API的入口点。你还记得，前面我们说过，GraphQL查询是这样的：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;query {&lt;br/&gt;  user(id: &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;    name&lt;br/&gt;    email&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;该 &lt;/span&gt;&lt;code&gt;&lt;span&gt;query&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 字段属于一种特殊的保留类型，称为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Query&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ，这指定了获取对象的主要入口点。（还有用于修改对象的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Mutation&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 类型。）在这里，我们定义了一个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;user&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 字段，该字段返回一个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;User&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 对象，因此我们的架构也需要定义此字段：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;type Query {&lt;br/&gt;  user(id: Int!): User&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;type User { ... }&lt;br/&gt;type Address { ... }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;字段中的参数是逗号分隔的列表，格式为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;$NAME: $TYPE&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;code&gt;&lt;span&gt;!&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 是GraphQL表示该参数是必需的方式，省略表示它是可选的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;根据你选择的语言，将此模式合并到服务器中的过程会有所不同，但通常，将信息用作字符串就足够了。Node.js有 &lt;span&gt;graphql&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt; 包来准备GraphQL模式，但我们将使用 &lt;span&gt;graphql-tools&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt; 包来代替，因为它提供了一些更多的好处。让我们导入该软件包并阅读我们的类型定义，以为将来的开发做准备：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; fs = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;fs&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; { makeExecutableSchema } = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&quot;graphql-tools&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; typeDefs = fs.readFileSync(&lt;span&gt;&quot;schema.graphql&quot;&lt;/span&gt;, {&lt;br/&gt;  &lt;span&gt;encoding&lt;/span&gt;: &lt;span&gt;&quot;utf8&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;flag&lt;/span&gt;: &lt;span&gt;&quot;r&quot;&lt;/span&gt;,&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;设置解析器&lt;/h2&gt;&lt;section&gt;&lt;span&gt;schema设置了构建查询的方式，但建立schema来定义数据模型只是GraphQL规范的一部分。另一部分涉及实际获取数据，这是通过使用解析器完成的，解析器是一个返回字段基础值的函数。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;让我们看一下如何在Node.js中实现解析器。我们的目的是围绕着解析器如何与模式一起操作来巩固概念，所以我们不会围绕着如何设置数据存储来做太详细的介绍。在“现实世界”中，我们可能会使用诸如&lt;span&gt;knex&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;之类的东西建立数据库连接。现在，让我们设置一些虚拟数据：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; users = {&lt;br/&gt;  &lt;span&gt;1&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&quot;Luke&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;email&lt;/span&gt;: &lt;span&gt;&quot;luke@heroku.space&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;addresses&lt;/span&gt;: [&lt;br/&gt;    {&lt;br/&gt;      &lt;span&gt;street&lt;/span&gt;: &lt;span&gt;&quot;1234 Rodeo Drive&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;city&lt;/span&gt;: &lt;span&gt;&quot;Los Angeles&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;country&lt;/span&gt;: &lt;span&gt;&quot;USA&quot;&lt;/span&gt;,&lt;br/&gt;    },&lt;br/&gt;    ],&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;2&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&quot;Jane&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;email&lt;/span&gt;: &lt;span&gt;&quot;jane@heroku.space&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;addresses&lt;/span&gt;: [&lt;br/&gt;    {&lt;br/&gt;      &lt;span&gt;street&lt;/span&gt;: &lt;span&gt;&quot;1234 Lincoln Place&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;city&lt;/span&gt;: &lt;span&gt;&quot;Brooklyn&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;country&lt;/span&gt;: &lt;span&gt;&quot;USA&quot;&lt;/span&gt;,&lt;br/&gt;    },&lt;br/&gt;    ],&lt;br/&gt;  },&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;Node.js中的GraphQL解析器相当于一个Object，key是要检索的字段名，value是返回数据的函数。让我们从初始 &lt;/span&gt;&lt;code&gt;&lt;span&gt;user&lt;/span&gt;&lt;/code&gt;&lt;span&gt;  按id查找的一个简单示例开始:&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; resolvers = {&lt;br/&gt;  &lt;span&gt;Query&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;user&lt;/span&gt;: &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;parent, { id }&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;// 用户查找逻辑&lt;/span&gt;&lt;br/&gt;    },&lt;br/&gt;  },&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;这个解析器需要两个参数：一个代表父的对象（在最初的根查询中，这个对象通常是未使用的），一个包含传递给你的字段的参数的JSON对象。并非每个字段都具有参数，但是在这种情况下，我们将拥有参数，因为我们需要通过用户ID来检索其用户。该函数的其余部分很简单：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; resolvers = {&lt;br/&gt;  &lt;span&gt;Query&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;user&lt;/span&gt;: &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;_, { id }&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; users[id];&lt;br/&gt;    },&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;你会注意到，我们没有明确定义 &lt;/span&gt;&lt;code&gt;&lt;span&gt;User&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 或 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Addresses&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的解析器，&lt;/span&gt;&lt;code&gt;&lt;span&gt;graphql-tools&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 包足够智能，可以自动为我们映射这些。如果我们选择的话，我们可以覆盖这些，但是现在我们已经定义了我们的类型定义和解析器，我们可以建立我们完整的模式：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; schema = makeExecutableSchema({ typeDefs, resolvers });&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;运行服务器&lt;/h2&gt;&lt;section&gt;&lt;span&gt;最后，让我们来运行这个demo吧！因为我们使用的是Express，所以我们可以使用 &lt;span&gt;express-graphql&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt; 包来暴露我们的模式作为端点。该程序包需要两个参数：schema和根value，它有一个可选参数 &lt;/span&gt;&lt;code&gt;&lt;span&gt;graphiql&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，我们将稍后讨论。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;使用GraphQL中间件在你喜欢的端口上设置Express服务器，如下所示：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; express = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&quot;express&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; express_graphql = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&quot;express-graphql&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; app = express();&lt;br/&gt;app.use(&lt;br/&gt;  &lt;span&gt;&quot;/graphql&quot;&lt;/span&gt;,&lt;br/&gt;  express_graphql({&lt;br/&gt;    &lt;span&gt;schema&lt;/span&gt;: schema,&lt;br/&gt;    &lt;span&gt;graphiql&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;  })&lt;br/&gt;);&lt;br/&gt;app.listen(&lt;span&gt;5000&lt;/span&gt;, () =&amp;gt; &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;Express is now live at localhost:5000&quot;&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;将浏览器导航到 http://localhost:5000/graphql，你应该会看到一种IDE界面。在左侧窗格中，你可以输入所需的任何有效GraphQL查询，而在右侧你将获得结果。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这就是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;graphiql: true&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 所提供的：一种方便的方式来测试你的查询，你可能不想在生产环境中公开它，但是它使测试变得容易得多。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;尝试输入上面展示的查询：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;query {&lt;br/&gt;  user(id: &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;    name&lt;br/&gt;    email&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;要探索GraphQL的类型化功能，请尝试为ID参数传递一个字符串而不是一个整数。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;# 这不起作用&lt;br/&gt;query {&lt;br/&gt;  user(id: &lt;span&gt;&quot;1&quot;&lt;/span&gt;) {&lt;br/&gt;    name&lt;br/&gt;    email&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;你甚至可以尝试请求不存在的字段：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;# 这不起作用&lt;br/&gt;query {&lt;br/&gt;  user(id: &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;    name&lt;br/&gt;    zodiac&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;只需用schema表达几行清晰的代码，就可以在客户机和服务器之间建立强类型的契约。这样可以防止你的服务接收虚假数据，并向请求者清楚地表明错误。&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;mpcpc js_editor_cpcad=&quot;&quot; class=&quot;js_cpc_area cpc_iframe&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/cpc_tmpl#1601209294677&quot; data-category_id_list=&quot;48|26|49|1|55|8|47|35|5|31|6|7|24|37|11|50|54|53|52|42|29|43|16|51|36&quot; data-id=&quot;1601209294677&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;性能考量&lt;/h2&gt;&lt;section&gt;&lt;span&gt;尽管GraphQL为你解决了很多问题，但它并不能解决构建API的所有固有问题。特别是缓存和授权这两个方面，只是需要一些预案来防止性能问题。GraphQL规范并没有为实现这两种方法提供任何指导，这意味着构建它们的责任落在了你身上。&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;缓存&lt;/h3&gt;&lt;section&gt;&lt;span&gt;基于REST的API在缓存时不需要过度关注，因为它们可以构建在web的其他部分使用的现有HTTP头策略之上。GraphQL不具有这些缓存机制，这会对重复请求造成不必要的处理负担。考虑以下两个查询：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;query {&lt;br/&gt;  user(id: &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;    name&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;query {&lt;br/&gt;  user(id: &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;    email&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;在没有某种缓存的情况下，只是为了检索两个不同的列，会导致两个数据库查询来获取ID为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;User&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。实际上，由于GraphQL还允许使用别名，因此以下查询有效，并且还执行两次查找：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;query {&lt;br/&gt;  &lt;span&gt;one&lt;/span&gt;: user(id: &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;    name&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;two&lt;/span&gt;: user(id: &lt;span&gt;2&lt;/span&gt;) {&lt;br/&gt;    name&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;第二个示例暴露了如何批处理查询的问题。为了快速高效，我们希望GraphQL以尽可能少的往返次数访问相同的数据库行。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;dataloader&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt;程序包旨在解决这两个问题。给定一个ID数组，我们将一次性从数据库中获取所有这些ID；同样，后续对同一ID的调用也将从缓存中获取该项目。要使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;dataloader&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 来构建这个，我们需要两样东西。首先，我们需要一个函数来加载所有请求的对象。在我们的示例中，看起来像这样：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; DataLoader = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;dataloader&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; batchGetUserById = &lt;span&gt;async&lt;/span&gt; (ids) =&amp;gt; {&lt;br/&gt;   &lt;span&gt;// 在现实生活中，这将是数据库调用&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; ids.map(&lt;span&gt;&lt;span&gt;id&lt;/span&gt; =&amp;gt;&lt;/span&gt; users[id]);&lt;br/&gt;};&lt;br/&gt;&lt;span&gt;// userLoader现在是我们的“批量加载功能”&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; userLoader = &lt;span&gt;new&lt;/span&gt; DataLoader(batchGetUserById);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;这样可以解决批处理的问题。要加载数据并使用缓存，我们将使用对 &lt;/span&gt;&lt;code&gt;&lt;span&gt;load&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法的调用来替换之前的数据查找，并传入我们的用户ID：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; resolvers = {&lt;br/&gt;  &lt;span&gt;Query&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;user&lt;/span&gt;: &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;_, { id }&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; userLoader.load(id);&lt;br/&gt;    },&lt;br/&gt;  },&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;授权&lt;/h3&gt;&lt;section&gt;&lt;span&gt;对于GraphQL来说，授权是一个完全不同的问题。简而言之，它是识别给定用户是否有权查看某些数据的过程。我们可以想象一下这样的场景：经过认证的用户可以执行查询来获取自己的地址信息，但应该无法获取其他用户的地址。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了解决这个问题，我们需要修改解析器函数。除了字段的参数外，解析器还可以访问它的父节点，以及传入的特殊&lt;strong&gt;上下文&lt;/strong&gt;值，这些值可以提供有关当前已认证用户的信息。因为我们知道地址是一个敏感字段，所以我们需要修改我们的代码，使对用户的调用不只是返回一个地址列表，而是实际调用一些业务逻辑来验证请求：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; getAddresses = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;currUser, user&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (currUser.id == user.id) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; user.addresses&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; [];&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; resolvers = {&lt;br/&gt;  &lt;span&gt;Query&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;user&lt;/span&gt;: &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;_, { id }&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; users[id];&lt;br/&gt;    },&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;User&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;addresses&lt;/span&gt;: &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;parentObj, {}, context&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; getAddresses(context.currUser, parentObj);&lt;br/&gt;    },&lt;br/&gt;  },&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;同样，我们不需要为每个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;User&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 字段显式定义一个解析程序，只需定义一个我们要修改的解析程序即可。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;默认情况下，&lt;/span&gt;&lt;code&gt;&lt;span&gt;express-graphql&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 会将当前的&lt;strong&gt;HTTP请求&lt;/strong&gt;作为&lt;strong&gt;上下文&lt;/strong&gt;的值来传递，但在设置服务器时可以更改：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;app.use(&lt;br/&gt;  &lt;span&gt;&quot;/graphql&quot;&lt;/span&gt;,&lt;br/&gt;  express_graphql({&lt;br/&gt;    &lt;span&gt;schema&lt;/span&gt;: schema,&lt;br/&gt;    &lt;span&gt;graphiql&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;context&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;currUser&lt;/span&gt;: user &lt;span&gt;// 当前经过身份验证的用户&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  })&lt;br/&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;Schema最佳实践&lt;/h2&gt;&lt;section&gt;&lt;span&gt;GraphQL规范中缺少的一个方面是缺乏对版本控制模式的指导。随着应用程序的成长和变化，它们的API也会随之变化，很可能需要删除或修改GraphQL字段和对象。但这个缺点也是积极的：通过仔细设计你的GraphQL schema，你可以避免在更容易实现（也更容易破坏）的REST端点中明显的陷阱，如命名的不一致和混乱的关系。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;此外，你应该尽量将业务逻辑与解析器逻辑分开。你的业务逻辑应该是整个应用程序的单一事实来源。在解析器中执行验证检查是很有诱惑力的，但随着模式的增长，这将成为一种难以维持的策略。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;GraphQL什么时候不合适？&lt;/h2&gt;&lt;section&gt;&lt;span&gt;GraphQL不能像REST一样精确地满足HTTP通信的需求。例如，无论查询成功与否，GraphQL仅指定一个状态码——&lt;/span&gt;&lt;code&gt;&lt;span&gt;200 OK&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。在这个响应中会返回一个特殊的错误键，供客户端解析和识别出错的地方，因此，错误处理可能会有些棘手。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;同样，GraphQL只是一个规范，它不会自动解决你的应用程序面临的每个问题。性能问题不会消失，数据库查询不会变得更快，总的来说，你需要重新思考关于你的API的一切：授权、日志、监控、缓存。版本化你的GraphQL API也可能是一个挑战，因为官方规范目前不支持处理中断的变化，这是构建任何软件不可避免的一部分。如果你有兴趣探索GraphQL，你需要投入一些时间来学习如何将其与你的需求进行最佳整合。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;了解更多&lt;/h2&gt;&lt;section&gt;&lt;span&gt;社区围绕这个新范例聚集，并为前端和后端工程师提供了&lt;span&gt;很棒的GraphQL资源列表&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;。前端和后端工程师都可以使用。你也可以通过在&lt;span&gt;官方的游乐场&lt;/span&gt;&lt;sup&gt;[8]&lt;/sup&gt;上提出真实的请求来查看查询和类型是什么样子的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们还有一个&lt;span&gt;Code[ish]播客集&lt;/span&gt;&lt;sup&gt;[9]&lt;/sup&gt;，专门介绍GraphQL的好处和成本。&lt;/span&gt;&lt;/section&gt;&lt;hr/&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0MDIwNTQ1Mg==&amp;amp;mid=2676494703&amp;amp;idx=1&amp;amp;sn=093342b1a624576187ec4a89d033082b&amp;amp;chksm=f362da8cc415539a021116a15dd7fac850140bb67977faca591ee65c0ee37ce03dd2ec13642f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span/&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4255555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/WYoaOn5t0AMNlR4lN4siawiaqWFb36Ct1nfUBczZ8C8xnT7rYrTrVt0PsicskFv7gwkWfam1unKkvJOJUtcFs8xicA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0MDIwNTQ1Mg==&amp;amp;mid=2676494632&amp;amp;idx=1&amp;amp;sn=194e712b6ab369c935cdd5825c022822&amp;amp;chksm=f362dacbc41553dd455d7dd881812181ac4349913e75a231db8b4f6c922168e6d6f69406ed5a&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4255555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/WYoaOn5t0AM3SibO1W18xRgImMuW6R1mZFkbHktRdysys60uJD63tO3jGIMmkvicyt6qsmwSJMPRekLTAVmUtGKQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;福利资料&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;《&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;程序员成长攻略（价值1998）&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;》&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;获取地址&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;密码&lt;/span&gt;&lt;span&gt;请&lt;/span&gt;&lt;span&gt;在公众号中回复关&lt;/span&gt;&lt;span&gt;键字&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;strong&gt;001&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a class=&quot;weapp_text_link js_weapp_entry&quot; data-miniprogram-appid=&quot;wxe43f931b4099b39c&quot; data-miniprogram-path=&quot;__plugin__/wx34345ae5855f892d/pages/productDetail/productDetail?productId=859909&quot; data-miniprogram-nickname=&quot;张张的小铺&quot; href=&quot;&quot; data-miniprogram-type=&quot;text&quot; data-miniprogram-servicetype=&quot;10&quot;&gt;全新2020版Webstorm、IntelliJ IDEA 等Jetbrains全家桶激活&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;关注即送&lt;/span&gt;&lt;span&gt;大礼包&lt;/span&gt;&lt;span&gt;，高价值精品视频课程网盘资料，准能为你节省不少钱！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AOPiaqWez1sKrh7Hffjoia7y8zkhic56DPic8FsoheTZljsrr5rpFMFcp7OgSZoOuuLKdXkWmhKibHia0fQ/0?wx_fmt=png&quot; data-cropx1=&quot;61.29032258064516&quot; data-cropx2=&quot;832.258064516129&quot; data-cropy1=&quot;40.32258064516129&quot; data-cropy2=&quot;443.54838709677415&quot; data-ratio=&quot;0.522697795071336&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/WYoaOn5t0AOPiaqWez1sKrh7Hffjoia7y8JicicRtO0ZCXic07QKNhrTsD8l77Iq50ce0gkxfHSmic7iaLoT3buDYibIRw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;771&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/aVp1YC8UV0fXSy8oK0h6qL36nlWgib6lHDTj0Ykkiab2FufBJIumwMrDEBZ1wHteh6pzsQiaP4007ox4ichic8pNw3Q/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-ratio=&quot;0.1732283464566929&quot; data-w=&quot;635&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;GraphQL: &lt;em&gt;https://graphql.org/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;graphql: &lt;em&gt;https://www.npmjs.com/package/graphql&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;graphql-tools: &lt;em&gt;https://www.npmjs.com/package/graphql-tools&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;knex: &lt;em&gt;https://knexjs.org/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;express-graphql: &lt;em&gt;https://www.npmjs.com/package/express-graphql&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;dataloader: &lt;em&gt;https://github.com/graphql/dataloader&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[7]&lt;/span&gt;&lt;p&gt;很棒的GraphQL资源列表: &lt;em&gt;https://github.com/chentsulin/awesome-graphql&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[8]&lt;/span&gt;&lt;p&gt;官方的游乐场: &lt;em&gt;https://graphql.org/swapi-graphql/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[9]&lt;/span&gt;&lt;p&gt;Code[ish]播客集: &lt;em&gt;https://www.heroku.com/podcasts/codeish/44-graphqls-benefits-and-costs&lt;/em&gt;&lt;span/&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0889ae79a1a2a2a46131e971089a2847</guid>
<title>如何让程序员变得没朋友</title>
<link>https://toutiao.io/k/wpxfdvn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前几天有一个事情让我很无语。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一个两年经验的年轻程序员提离职，和我说一周之后就要去新公司入职，只有一周的交接时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一周？？？按公司要求，提离职需要提前一个月。实话实说，大部分离职交接工作也用不了一个月那么久，但是一周交接也太短了吧，不加班的话只有五个工作日。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;考虑到小伙子来公司时间不长，目前负责的工作也不是很多，我还是同意了一周后离职的要求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这还没完，我同意了离职之后不久，小伙子微信上给我留言，想离职之前把剩余的 3 天年假休完。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当时我在开会，没看到他发的微信。小伙子看我很久也没回复他，估计自己也感觉不好意思，之后又发了一条微信，如果我不同意，他就不休年假了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;会后我看到了微信，第一感觉非常无语，甚至有点生气，WTF。一周离职我还能理解，现在工作不好找，找到一个心仪的公司职位，答应新公司快速入职也就算了。总共只有 5 个工作日交接，其中 3 天你还想请年假，是不是有点过了？你只考虑自己，不考虑现在的团队吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无语归无语，请假就请吧，我也不拒绝了，他心思已经不在了，留着这也没啥好处。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里解释一句，我管理团队不强硬，不存在之前为难他让他一天也不想多待的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对比去年团队里一个核心运维离职，首先人家提离职的时间够早，离职之前的日子里工作依然很敬业，没少加班，很多同事都看不出他是要离职的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最让我感动的是，因为工作交接不顺利，他又和新公司（是个电商大厂）沟通把入职时间生生推迟了 2 周。直到最后交接完离职，他还有很多加班调休和年假没休。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说到这里我还欠这个运维兄弟一顿践行饭，当时因为各种原因没吃成，后面得找机会补上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;真是通过一个事情看清一个人，对于利己主义者，离职说的再见，就是再也不想见。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多程序员工作多年，换了多家公司，在同事中认识的真·朋友却没几个，为什么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序员没朋友，一部分原因是因为他们太闷了，不擅长交往。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，我再来分享几个“让程序员变得没朋友”方法。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方法 1：离职之前删除注释、删除单元测试&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;老板之前经常让我加班，钱还给这么少，还总对我各种不满……老板你不仁休怪我不义，走之前我要把代码里的注释都删掉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后面接手的兄弟对不住了，不过我还会给你留些注释的，我把对老板的吐槽都写在注释里，算是给你提个醒。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有单元测试，走之前也删掉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想想我还是很良心了，没在走之前埋一个 Bug。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只要我埋的深一些、巧妙一些，足够公司喝一壶的。就算 Bug 被公司发现了，我也可以说不是故意的，我就是这个烂水平哪用得着故意埋 Bug。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6770186335403726&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KS4YY5DKEnZiaibJjYHQrnMOunBUxkRHBB7oW1gibEfibUyIYl1xOWHhrb0BM56UkSYNic4aaI3ibxewrAg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;322&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方法 2：不写注释、文档&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面删注释的兄弟，起码还写过注释，我干脆就不写注释。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;别问为什么，问就是我代码写的漂亮，不需要注释。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是我最讨厌那些代码写的烂，还不写注释的同行。比如，前几天我就看到一段代码，写的真是一坨屎，没有注释完全看不懂。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我就往上翻，翻到类的顶部看到作者……原来是我一个月之前写的代码。按说不应该啊，我自己写的咋会看不懂呢？？？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.4216867469879517&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KS4YY5DKEnZiaibJjYHQrnMOuDAp6yxXznWRxJqd5Ox7F8KRiaT02sgLW5icibficWtyicmNqaAzDniajichkg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;332&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对了，还有文档，甭管技术文档还是用户手册，我都不写，我是程序员，天生不会画图，不擅长码字。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尤其是接口文档、用户手册，功能一改，还得改文档，这不是给自己找事情吗？再说了，测试也能写，为啥让我写。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再就是提交 SVN、Git 的时候，还要求写提交的注释说明，事儿真多。还好我有对策，“新功能开发”、“修改错误”、“完善代码”这几句话基本可以搞定一切了。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方法 3：编码之后不自测&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码写好之后，直接甩给测试同事测去吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;什么，测试说我的代码有 Bug，谁写的代码没有 Bug 啊。我自己都测完了，还要测试干啥，测试工作不就不饱和了吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且甭管 Bug 多少，甩给测试的时候，咱们一定要自信，要拍着胸脯说“保证没 Bug”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试抱怨我代码 Bug 多的时候，我反手就是一句“那是因为你们专业，覆盖的太全，我测不了你们那么全”。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方法 4：经常问问题&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我旁边的程序员越来越讨厌了，我刚入职的时候他还是挺好一个人，他工作年头长、经验比我丰富，我经常请教他问题，他基本有问必答，态度也好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;他现在越来越冷淡了，还经常敷衍我，和我说&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;“这个问题我之前告诉你好几遍了”&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;“这个问题你网上搜一下就能解决”&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;“我忙着呢，等会”&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;什么态度！我就不明白了，我不就是问的有点多吗，问的多说明我爱学习、爱沟通啊。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;他说我是伸手党、问的是蠢问题，我还嫌弃他对待新人没耐心、不乐于助人。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;公司程序员又不是就你一个，我找别人问去。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4351378958120531&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KS4YY5DKEnZiaibJjYHQrnMOuTNhoQAh9jG3MVo9PiaTDKLaKN8IGLLbmErELWic11fzb6x6BaWaopCng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;979&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方法 5：随意改接口&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为程序员，我改接口很正常呀。再说也不是我想改，还不是被产品那个傻屌逼得。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我改了接口还需要主动通知你们？影响你们调用，你们发现问题主动来问我呗，干啥非得背地里说我：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“随意改接口，菊花万人捅”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你们也别抱怨接口文档和代码对不上，大哥，都是同行，代码都写不过来，哪有时间把文档维护的那么及时。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0412844036697249&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KS4YY5DKEnZiaibJjYHQrnMOuaH9StYKoB4ibVcw6MI2QEUCCAORAWhzicFyiceG8iado6kdTttFfddpvIw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;218&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方法 6：能实现功能就行&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;能实现功能的代码就够了，别和我说什么程序性能问题，等咱们做的产品火了再说。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没准咱们的产品上线之后见光死，你现在和我说个锤子的性能问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也别说我写的命名不规范，我英语不好，懒得查翻译。据说现在都可以用中文编程了，我正打算试试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也别说我写的代码不优雅、代码乱，我这是代码天生自动混淆。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6151202749140894&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KS4YY5DKEnZiaibJjYHQrnMOubjnEkMZsXibDfx8e4pYcIe4bcRfibAIPdiafBvNic4G1M4d79iaWLy95aAg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;291&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（作者插一句，我曾经调一个 Bug，折腾了整整一天，到最后发现不知道谁把XxxxxServlet中的英文l写成了数字1，我当时心中一万只草泥马路过。）&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方法 7：甩锅&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我是一名前端开发，如果问我前后端分离的最大好处是什么，那就是出现问题之后可以把锅甩给后端开发。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不管是啥问题，先甩锅给后端再说。解决问题不着急，用户怎么可能比我还重要，我必须先声明不是我的责任。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果后端开发能证明不是他们的问题，还可以把锅甩给测试，上线之前你们测试是怎么测试的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总之，出现问题不要慌，先冷静想想问题严不严重，如果严重，再仔细想想怎么把问题推给别人。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“甩自己的锅，让别人背去吧。”&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9790575916230366&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KS4YY5DKEnZiaibJjYHQrnMOuxMNKRTiasNarJGMqLrOo15j4dSmqh8B4Vdu0RWRCnaFzicOFD7saMYHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;382&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方法 8：怼产品经理&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;继续说产品那个傻屌，他看不得我们程序员闲着，有事没事就提各种需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般的需求我也就忍了，但是有的需求太过分了，凭我的实力根本做不出来。遇到这种情况，我必须要怼他，为此我总结了一套话术：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;“你这个功能在其他竞品中没见过，人家不做肯定是有理由的。”&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;“你怎么证明用户需要这个功能。”&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;“又加功能？我们要做减法、要聚焦。”&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;“这个功能太复杂，用户使用门槛太高。”&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;……&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不要以为我不知道有一本书叫《人人都是产品经理》，这本书简直太好了，好就好在没有一本书叫《人人都是程序员》。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7509157509157509&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KS4YY5DKEnZiaibJjYHQrnMOuTgxln4IEDMFIibaadicIIk5Z9R8Soh1Nl19QJXpIWicW04gUhWLXXibiaiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;273&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论如何，一定不能让产品看出来是我不想做。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;顺便再吐槽一下 AB 测试，不知道发明的这个鬼概念，太可恶了，无形中又让我多写了不少代码。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;最后&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;终于快写完了，大家看出来我这是故意反着写的，说反话已经快让我自己分裂了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写的这些，是希望大家注意眼前的小事，别让小事影响自己的未来。每一段工作经历，不管公司大小、时间长短，都希望大家多认识几个朋友，即使离职之后大家还会经常联系、互相帮忙。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至于没有时间观念、说到做不到这些毛病我没写，也不是程序员独有的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至于删库跑路、出售公司数据、代码这些我也没写，这已经不是没有朋友的小事了，而是没有朋友给你送饭的大事了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我旁边的码农二毛预览完这篇之后，说四哥你应该再加一条:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;评论同行发型、发量的程序员没朋友&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果&lt;/span&gt;&lt;span&gt;看完文章觉得有帮助，我希望你可以分享给你的朋友、同事，或者点个在看支持一下。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4411111111111111&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6nbNnibOq5KS4YY5DKEnZiaibJjYHQrnMOuQk1Z5tokLcrdIbPKib3KmdmY43oztWpjL93RgEoMCBZAxOEQoQVEJKg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1800&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e8b35e475831a8bd3861022f63bf56d2</guid>
<title>工具 | 一款高可用，高性能，简单易用的，金融级的分布式事务解决方案</title>
<link>https://toutiao.io/k/3cjyfym</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                              &lt;strong class=&quot;profile_nickname&quot;&gt;开发者头条&lt;/strong&gt;
                              &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;kaifazhetoutiao&lt;/span&gt;
                              &lt;/p&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;程序员分享平台 | 官方应用下载地址：http://toutiao.io/download&lt;/span&gt;
                              &lt;/p&gt;
                              
                          &lt;/div&gt;
                          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>