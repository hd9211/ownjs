<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>917f994a96784b2577afbc1e5ca27a44</guid>
<title>面试官提问三个Go接口的概念，10年gopher竟无言以对</title>
<link>https://toutiao.io/k/xn3xy8i</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;自 Go 1.18后， Go的interface的含义有所变化, 三个新的和Go接口有关的概念很多人还不知道: &lt;strong&gt;&lt;code&gt;type set&lt;/code&gt;&lt;/strong&gt;&lt;span&gt;(类型集合)、&lt;/span&gt;&lt;strong&gt;&lt;code&gt;specific type&lt;/code&gt;&lt;/strong&gt;&lt;span&gt;(特定类型)和&lt;/span&gt;&lt;strong&gt;&lt;code&gt;structural type&lt;/code&gt;&lt;/strong&gt;&lt;span&gt;(结构类型)&lt;/span&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;1 type set (类型集合)&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;type set称之为类型集合，一些关注Go泛型的朋友其实也对此有些了解，它是Go 1.18新增加的一个概念。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Go 1.18之前，Go的接口代表了一组方法的集合(method set),凡是实现了这些方法集合的类型，都被称之为实现了这个接口。Go不像Java语言，需要显示地定义某个类实现某个接口，Go不需要这样，在Go中，只要一个类型实现了某个接口定义的所有方法，它就实现了这个接口，可以赋值给这个接口类型的变量，或者作为这个接口类型的方法的实参或者返回值，这种设计有时候也被叫做&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;code&gt;鸭子类型&lt;/code&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;(duck typing)。只要它走起来像鸭子，叫起来像鸭子，那么它就是鸭子，这是一个很经典的对鸭子类型的描述。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在Go 1.18中，接口不再代表方法的集合了，而是代表类型的集合(type set)。只要某种类型在这个接口的类型集合中，那么我们就说这种类型实现了这个接口。如果这个接口被用作类型约束，那么在这个接口定义的类型集合中的任意一个元素，都可以实例化这个类型参数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，实际上，为了支持接口作为类型约束的扩展，Go语言规范不得不重新定义接口的含义了，这也是类型集合出现的原因。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实，接口的方法集的概念还在 一个接口的方法集是这个接口的类型集合中所有元素的方法集的&lt;/span&gt;&lt;strong&gt;交集&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;本文假定你对Go泛型有了一定的了解。假定你还不了解，那么你必须知道，Go 1.18中接口除了原先的方法元素还，还支持包含类型元素，类型元素可以是某个类型&lt;code&gt;T&lt;/code&gt;、或者是近似类型&lt;code&gt;~T&lt;/code&gt;,或者是它们的联合&lt;code&gt;int|int8|int16|int32|int64|~string&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果一个接口&lt;/span&gt;&lt;code&gt;I&lt;/code&gt;&lt;span&gt;嵌入了另外一个接口&lt;/span&gt;&lt;code&gt;E&lt;/code&gt;&lt;span&gt;,那么&lt;/span&gt;&lt;code&gt;I&lt;/code&gt;&lt;span&gt;的类型集是它显示定义的类型集合和嵌入的接口&lt;/span&gt;&lt;code&gt;E&lt;/code&gt;&lt;span&gt;的类型集合的交集。相当于&lt;/span&gt;&lt;code&gt;E&lt;/code&gt;&lt;span&gt;把接口&lt;/span&gt;&lt;code&gt;I&lt;/code&gt;&lt;span&gt;的类型集收窄了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如何判断一个接口的类型集呢？请遵循下面的原则:&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;一个方法的类型集合是定义这个方法的所有类型，也就是只要某个类型的方法集包含这个方法，那么它就属于这个方法的类型集合&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如接口中有&lt;/span&gt;&lt;code&gt;String() string&lt;/code&gt;&lt;span&gt;这样一个方法，那么所有实现这个方法的类型都属于&lt;/span&gt;&lt;code&gt;String() string&lt;/code&gt;&lt;span&gt;定义的类型集合，比如&lt;/span&gt;&lt;code&gt;net.IP&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;一个非接口类型的类型集合就是只包含这个类型的类型集合&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如&lt;/span&gt;&lt;code&gt;int&lt;/code&gt;&lt;span&gt;的类型集合只包含&lt;/span&gt;&lt;code&gt;int&lt;/code&gt;&lt;span&gt;这样一个元素&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;近似元素&lt;/span&gt;&lt;code&gt;~T&lt;/code&gt;&lt;span&gt;的类型集合是所有底层类型为&lt;/span&gt;&lt;code&gt;T&lt;/code&gt;&lt;span&gt;的所有类型的集合&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如&lt;/span&gt;&lt;code&gt;type MyInt int&lt;/code&gt;&lt;span&gt;中的&lt;/span&gt;&lt;code&gt;MyInt&lt;/code&gt;&lt;span&gt;就属于&lt;/span&gt;&lt;code&gt;~int&lt;/code&gt;&lt;span&gt;的类型集合&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;联合元素&lt;/span&gt;&lt;code&gt;t1|t2|…|tn&lt;/code&gt;&lt;span&gt;的类型集合是这些联合元素类型集合的&lt;strong&gt;并集&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;下面的例子列举了一些类型的集合：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8480278422273781&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vbERicIdYZbDVvSSniabTPBrvSB2JibsxNicDZctsIfB8aGicQJU9463XflXaT0XlGDoahP9q7FoueNbxTiaPqULVT2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;862&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;2 specific type (特定类型) 和 specific type set&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;接口另外一个很重要的概念就是&lt;/span&gt;&lt;code&gt;specific type&lt;/code&gt;&lt;span&gt; (特定类型)&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;只有包含类型元素的接口才定义了特定类型(可能是空的类型)。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果不严格的讲，特定类型是出现在类型元素中定义的那些类型&lt;/span&gt;&lt;code&gt;T&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;~T&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;t1|t2|...|tn&lt;/code&gt;&lt;span&gt;中的&lt;/span&gt;&lt;code&gt;t1&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;t2&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;...&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;tn&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;更准确地说，对于给定的接口&lt;/span&gt;&lt;code&gt;I&lt;/code&gt;&lt;span&gt;，特定类型的集合对应于该接口代表的类型集合&lt;/span&gt;&lt;span&gt;&lt;strong&gt;𝑅&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，这里要求&lt;/span&gt;&lt;span&gt;&lt;strong&gt;𝑅&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;是非空且有限的。否则，如果&lt;/span&gt;&lt;span&gt;&lt;strong&gt;𝑅&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;为空或无限，则接口没有特定类型。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于一个给定的接口、类型元素或者类型，它代表的类型集合&lt;/span&gt;&lt;span&gt;&lt;strong&gt;𝑅&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;定义如下：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对于一个没有任何类型元素的接口，它的&lt;strong&gt;𝑅&lt;/strong&gt;是所有的元素(无限)&lt;br/&gt;所以它没有特定类型&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果一个接口有类型元素，它的&lt;strong&gt;𝑅&lt;/strong&gt;是它的元素代表的类型的交集&lt;br/&gt;至于有没有特定类型要看&lt;strong&gt;𝑅&lt;/strong&gt;是否是非空且有限&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对于一个非接口类型&lt;/span&gt;&lt;code&gt;&lt;span&gt;T&lt;/span&gt;&lt;/code&gt;&lt;span&gt;,或者&lt;/span&gt;&lt;code&gt;&lt;span&gt;~T&lt;/span&gt;&lt;/code&gt;&lt;span&gt;, 它的&lt;strong&gt;𝑅&lt;/strong&gt;是包含类型&lt;/span&gt;&lt;code&gt;&lt;span&gt;T&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的集合&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对于联合元素&lt;/span&gt;&lt;code&gt;&lt;span&gt;t1|t2|…|tn&lt;/span&gt;&lt;/code&gt;&lt;span&gt;, 它的&lt;strong&gt;𝑅&lt;/strong&gt;是这些项代表类型的&lt;strong&gt;并集&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;下面是特定类型的例子:&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.46916299559471364&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vbERicIdYZbDVvSSniabTPBrvSB2JibsxNic4jrgr4X4LBSlYvLqiabpp4QzRICKcNibibDsJ0QRZ1QqZYw6VRibWy6JBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;908&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;span/&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;type set vs specific type set&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;类型集合和特定类型集合还是有区别的，从上面它们的定义可以看出来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;一个接口即使类型为空，它的特定类型集合可能不为空。&lt;/strong&gt;&lt;br/&gt;比如&lt;code&gt;interface{ int; m() }&lt;/code&gt;,它的类型集合是空的(int没有实现m方法)，但是它的特定类型是&lt;code&gt;int&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;一个接口即使有有限的特定类型，它的类型集合也可能是无限的&lt;/strong&gt;&lt;br/&gt;比如&lt;code&gt;interface{ ~int; m() }&lt;/code&gt;,它的特定类型是int，但是它的类型集合确是无限的&lt;span&gt;(任何底层为int并且实现了方法m的类型都属于它的类型集合)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么定义特定类型有什么用呢？&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;特定类型的应用&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;特定类型主要用于判断类型参数是否支持索引, 像&lt;/span&gt;&lt;code&gt;a[x]&lt;/code&gt;这样的类型。&lt;/p&gt;&lt;p&gt;比如一个表达式&lt;code&gt;a[x]&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt;这个实例的类型可能是数组、指向数组的指针、slice、字符串、map。&lt;/p&gt;&lt;p&gt;如果&lt;code&gt;a&lt;/code&gt;的类型是类型参数&lt;code&gt;P&lt;/code&gt;的话，那么我们的代码&lt;code&gt;a[x]&lt;/code&gt;在什么条件下才不会编译出错？&lt;/p&gt;&lt;section&gt;&lt;span&gt;要求的条件就和特定类型有关了：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;P必须有特定类型&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对于P的特定类型的值a，支持&lt;/span&gt;&lt;code&gt;&lt;span&gt;a[x]&lt;/span&gt;&lt;/code&gt;&lt;span&gt;这种索引写法&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;P的所有特定类型必须相同。在这里，string类型的元素类型是byte (&lt;/span&gt;&lt;span&gt;https://github.com/golang/go/issues/49551&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果P的特定类型包含map类型的话，那么它的所有特定类型必须是map,而且所有的key的类型是相同的&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;所以有时候你定义了一个包含map、slice、string的联合元素接口的话，这个接口的实例你不能使用&lt;/span&gt;&lt;code&gt;&lt;span&gt;a[x]&lt;/span&gt;&lt;/code&gt;&lt;span&gt;索引类型，元素的类型都是int&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;a[x]&lt;/span&gt;&lt;/code&gt;&lt;span&gt;是数组、slice、string的索引为x的元素，或者是map类型key为x的元素，a[x]的类型必须相同&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果P的特定类型包含string类型，那么不能给&lt;/span&gt;&lt;code&gt;&lt;span&gt;a[x]&lt;/span&gt;&lt;/code&gt;&lt;span&gt;赋值(字符串是不可变的)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;特定类型还用作类型转化定义上。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于一个变量&lt;/span&gt;&lt;code&gt;x&lt;/code&gt;&lt;span&gt;,如果它的类型是&lt;/span&gt;&lt;code&gt;V&lt;/code&gt;&lt;span&gt;, 要转换成的类型是&lt;/span&gt;&lt;code&gt;T&lt;/code&gt;&lt;span&gt;, 只要满足下面一条，x就可以转换成&lt;/span&gt;&lt;code&gt;T&lt;/code&gt;&lt;span&gt;类型:&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;一句话，是类型参数就满足每一个特定类型，不是类型参数就满足这个类型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，对于类型参数，要调用内&lt;/span&gt;建的函数&lt;code&gt;len&lt;/code&gt;、&lt;code&gt;cap&lt;/code&gt;，必须要求它们的特定类型允许使用这些内建函数。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3 structural type (结构类型)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;一个接口&lt;code&gt;T&lt;/code&gt;要被成为结构化的(&lt;code&gt;structural&lt;/code&gt;),需要满足下面的条件之一:&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;存在一个单一的类型&lt;/span&gt;&lt;code&gt;&lt;span&gt;U&lt;/span&gt;&lt;/code&gt;&lt;span&gt;,它是&lt;/span&gt;&lt;code&gt;&lt;span&gt;T&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的类型集合中的每一个元素相同的底层类型&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;T&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的类型集合只包含chan类型，并且它们的元素类型都是&lt;/span&gt;&lt;code&gt;&lt;span&gt;E&lt;/span&gt;&lt;/code&gt;&lt;span&gt;, 所有的chan的方向包含相同的方向(不一定要求完全相同)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;结构化类型包含一个结构类型，根据上面的条件不同，结构类型可能是:&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;类型&lt;/span&gt;&lt;code&gt;&lt;span&gt;U&lt;/span&gt;&lt;/code&gt;&lt;span&gt;, 或者&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果&lt;/span&gt;&lt;code&gt;&lt;span&gt;T&lt;/span&gt;&lt;/code&gt;&lt;span&gt;只包含双向chan的话，结构类型为&lt;/span&gt;&lt;code&gt;&lt;span&gt;chan E&lt;/span&gt;&lt;/code&gt;&lt;span&gt;,否则可能是&lt;/span&gt;&lt;code&gt;&lt;span&gt;chan&amp;lt;- E&lt;/span&gt;&lt;/code&gt;&lt;span&gt;或者&lt;/span&gt;&lt;code&gt;&lt;span&gt;&amp;lt;-chan E&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;下面是包含结构类型的结构化接口:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.422790202342918&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vbERicIdYZbDVvSSniabTPBrvSB2JibsxNiczWZ5r1jdd7d6C1fVd6sEibAk2fzlqZZEYhLkBGGOmnvrmMcch9bGzrQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;939&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在Go语言规范中，并没有对结构化接口有更多的介绍，如何使用，更多是是它内部获取底层的结构类型，以及做类型检查，比如下面的例子就会报&lt;/span&gt;&lt;code&gt;no structural type&lt;/code&gt;&lt;span&gt;编译错误:&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4534769833496572&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vbERicIdYZbDVvSSniabTPBrvSB2JibsxNicOg7AcbwIVFjyb9DlvH2C3fficJdkBeawWdVsJpAJF50em1ibQFOicFzqQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1021&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面的代码也会报&lt;/span&gt;&lt;code&gt;M has no structural type&lt;/code&gt;&lt;span&gt;编译错误:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;255&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.35798816568047337&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vbERicIdYZbDVvSSniabTPBrvSB2JibsxNicDbRJjuSKpNfTBrLyMvaAAPfoibF2lnIC8NGvwLRHNlIT8EGAt4FLx6g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1014&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如下面大家使用Go泛型的时候常会犯的错误,虽然&lt;/span&gt;&lt;code&gt;[]byte&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;map[int]byte&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;string&lt;/code&gt;&lt;span&gt;都能range,而且key(index)、value类型都一样，但是也会报&lt;/span&gt;&lt;code&gt;R has no structural type&lt;/code&gt;&lt;span&gt;错误:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5991820040899796&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vbERicIdYZbDVvSSniabTPBrvSB2JibsxNicwZKpONEm0tmC8R8VWI9tPzplfs1dAVwRR3iasCL1YZoiaEY1qsnrYKKQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;978&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;END&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;br/&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA4ODg0NDkzOA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/vbERicIdYZbC53rq7PQziczkzCA4pIPx8Xdx2r0a6FgQWEicTOgFNY1KlJD3jSKQKlTiavwTUgHS1HMXza2RYApkDw/0?wx_fmt=png&quot; data-nickname=&quot;GoCN&quot; data-alias=&quot;golangchina&quot; data-signature=&quot;最具规模和生命力的 Go 开发者社区&quot; data-from=&quot;0&quot;/&gt;&lt;span/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;-猜你想看-&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;想要了解Go更多内容，欢迎扫描下方👇 关注 公众号，回复关键词 [实战群]  ,就有机会进群和我们进行交流~&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5763688760806917&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vbERicIdYZbDrrBk1KBPqY1QNI320ZK2IIycDa77FcDQAeAFJRVb240xr8biceh23auy7ZpPibEYXPNOnmfsEewkw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;694&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;分享、在看与点赞，至少我要拥有一个叭~&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img __bg_gif&quot; data-ratio=&quot;0.2106667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/vbERicIdYZbB79dKphkWU3rVKFiaZGWHEic0qXJ8QAeF6XRTLwTCEgUxxiamV13wPv9kMtaqrOtsrVibdHzvYiaxCwgA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;750&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.696&quot; data-type=&quot;gif&quot; data-w=&quot;500&quot; class=&quot;__bg_gif&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/vbERicIdYZbB79dKphkWU3rVKFiaZGWHEicOoCY9eHaUhZY0vkZibusOg9ibjGibicfyjHiaWfkN9QOiclK2DnfLh4KYTLA/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>dcffd5bd2c2e4650e283a575c26ab357</guid>
<title>Kubernetes容器网络及Flannel插件详解</title>
<link>https://toutiao.io/k/o3k9ugf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;h2&gt;&lt;span&gt;1.1.&lt;/span&gt;&lt;span&gt;容器网络基础&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;&lt;shapetype coordsize=&quot;21600,21600&quot; spt=&quot;75&quot; path=&quot;m@4@5l@4@11@9@11@9@5xe&quot; preferrelative=&quot;t&quot; filled=&quot;f&quot; stroked=&quot;f&quot;&gt;&lt;stroke joinstyle=&quot;miter&quot;/&gt;&lt;formulas&gt;&lt;f eqn=&quot;if lineDrawn pixelLineWidth 0&quot;/&gt;&lt;f eqn=&quot;sum @0 1 0&quot;/&gt;&lt;f eqn=&quot;sum 0 0 @1&quot;/&gt;&lt;f eqn=&quot;prod @2 1 2&quot;/&gt;&lt;f eqn=&quot;prod @3 21600 pixelWidth&quot;/&gt;&lt;f eqn=&quot;prod @3 21600 pixelHeight&quot;/&gt;&lt;f eqn=&quot;sum @0 0 1&quot;/&gt;&lt;f eqn=&quot;prod @6 1 2&quot;/&gt;&lt;f eqn=&quot;prod @7 21600 pixelWidth&quot;/&gt;&lt;f eqn=&quot;sum @8 21600 0&quot;/&gt;&lt;f eqn=&quot;prod @7 21600 pixelHeight&quot;/&gt;&lt;f eqn=&quot;sum @10 21600 0&quot;/&gt;&lt;/formulas&gt;&lt;path extrusionok=&quot;f&quot; gradientshapeok=&quot;t&quot; connecttype=&quot;rect&quot;/&gt;&lt;lock aspectratio=&quot;t&quot;/&gt;&lt;/shapetype&gt;&lt;shape type=&quot;#_x0000_t75&quot; filled=&quot;f&quot;&gt;&lt;imagedata title=&quot;image1&quot;/&gt;&lt;/shape&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;554&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;299&quot; data-ratio=&quot;0.5408805031446541&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8Tts2IxBm8slQ4mYeRv1Gyuibf9EAwte5iajOmYTQc6us3TU99jCSso77Iquk36Wc4BhaASjn7vRd6IBcFQTiaOfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1272&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Kubernetes是一个开源容器调度编排引擎，管理大规模容器化应用，采用典型的Master-Worker&lt;/span&gt;&lt;span&gt;主从分布式技术架构&lt;/span&gt;&lt;span&gt;，由&lt;/span&gt;&lt;span&gt;集中式管理节点&lt;/span&gt;&lt;span&gt;（Master Node）,&lt;/span&gt;&lt;span&gt;分布式的工作节点&lt;/span&gt;&lt;span&gt;（Worker Node）组成。向下屏蔽底层差异化的分布式基础设施，以应用为中心构建云计算的基础操作系统能力（即云原生操作系统），面向用户提供云原生时代的云计算的新界面。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其中，Kubernetes网络至关重要，如果管理节点是控制大脑，运行节点是执行载体，那么网络就是将整个容器集群打通形成一个整体的神经网络；与Docker网络相比，Kubernetes网络最大的特点就是让容器组（Pod）拥有自己的身份证，即&lt;/span&gt;&lt;span&gt;独立IP&lt;/span&gt;&lt;span&gt;，实现在任何节点上的Pod都可以互相直接通信，而不需要任何的NAT地址转换；在不做限制时，Pod可以访问任何网络，并且拥有独立的网络栈，集群内部可见地址与外部可见地址保持一致。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在容器网络的具体实现上，Kubernetes通过开放的CNI标准，以插件化方式引入多种容器网络实现，从而支持各种差异化的场景的需求；当前社区比较常见的网络插件主要有&lt;/span&gt;&lt;span&gt;Flannel、Calico、Cilium、OVN&lt;/span&gt;&lt;span&gt;等，每个插件有不同的模式，需要按照实际的场景来选择使用。按照POD通信方式，有同主机的容器通信与跨主机的容器通信两大类型。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;shapetype coordsize=&quot;21600,21600&quot; xmlns:o=&quot;urn:schemas-microsoft-com:office:office&quot; o:spt=&quot;75&quot; path=&quot;m@4@5l@4@11@9@11@9@5xe&quot; o:preferrelative=&quot;t&quot; filled=&quot;f&quot; stroked=&quot;f&quot;&gt;&lt;formulas&gt;&lt;f eqn=&quot;if lineDrawn pixelLineWidth 0&quot;/&gt;&lt;f eqn=&quot;sum @0 1 0&quot;/&gt;&lt;f eqn=&quot;sum 0 0 @1&quot;/&gt;&lt;f eqn=&quot;prod @2 1 2&quot;/&gt;&lt;f eqn=&quot;prod @3 21600 pixelWidth&quot;/&gt;&lt;f eqn=&quot;prod @3 21600 pixelHeight&quot;/&gt;&lt;f eqn=&quot;sum @0 0 1&quot;/&gt;&lt;f eqn=&quot;prod @6 1 2&quot;/&gt;&lt;f eqn=&quot;prod @7 21600 pixelWidth&quot;/&gt;&lt;f eqn=&quot;sum @8 21600 0&quot;/&gt;&lt;f eqn=&quot;prod @7 21600 pixelHeight&quot;/&gt;&lt;f eqn=&quot;sum @10 21600 0&quot;/&gt;&lt;/formulas&gt;&lt;path o:extrusionok=&quot;f&quot; gradientshapeok=&quot;t&quot; o:connecttype=&quot;rect&quot;/&gt;&lt;/shapetype&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;554&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;184&quot; data-ratio=&quot;0.33490566037735847&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8Tts2IxBm8slQ4mYeRv1Gyuibf9EAwte5iaNjT9rGeMviaujdwkVdMtM4dria2SkqkZVlgRdJ9ozH7SWFzH2uHvia9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1272&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;（一）同主机的容器通信&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在kubernetes集群的节点上，会创建一个veth(virtual ethernet）虚拟设备，同时将veth一端插入到容器网络的命名空间中，一端连接到主机上的网桥（linux bridge）。这样在同一主机上的POD通过veth实现IP地址相互通信。网桥也会分配一个IP地址，充当从POD到不同节点的出口流量网关。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;（二）跨主机的容器通信&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在不同主机上运行的容器POD通过IP地址相互通信，需要通过网络插件实现，按照依赖底层的技术大致可以分为Overlay模式，路由模式，Underlay模式三大类：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;shapetype coordsize=&quot;21600,21600&quot; xmlns:o=&quot;urn:schemas-microsoft-com:office:office&quot; o:spt=&quot;75&quot; path=&quot;m@4@5l@4@11@9@11@9@5xe&quot; o:preferrelative=&quot;t&quot; filled=&quot;f&quot; stroked=&quot;f&quot;&gt;&lt;formulas&gt;&lt;f eqn=&quot;if lineDrawn pixelLineWidth 0&quot;/&gt;&lt;f eqn=&quot;sum @0 1 0&quot;/&gt;&lt;f eqn=&quot;sum 0 0 @1&quot;/&gt;&lt;f eqn=&quot;prod @2 1 2&quot;/&gt;&lt;f eqn=&quot;prod @3 21600 pixelWidth&quot;/&gt;&lt;f eqn=&quot;prod @3 21600 pixelHeight&quot;/&gt;&lt;f eqn=&quot;sum @0 0 1&quot;/&gt;&lt;f eqn=&quot;prod @6 1 2&quot;/&gt;&lt;f eqn=&quot;prod @7 21600 pixelWidth&quot;/&gt;&lt;f eqn=&quot;sum @8 21600 0&quot;/&gt;&lt;f eqn=&quot;prod @7 21600 pixelHeight&quot;/&gt;&lt;f eqn=&quot;sum @10 21600 0&quot;/&gt;&lt;/formulas&gt;&lt;path o:extrusionok=&quot;f&quot; gradientshapeok=&quot;t&quot; o:connecttype=&quot;rect&quot;/&gt;&lt;/shapetype&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;554&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;221&quot; data-ratio=&quot;0.4025157232704403&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8Tts2IxBm8slQ4mYeRv1Gyuibf9EAwte5gYxebdslpbTbQRvgerG73cZUqJfGGSZEkyGjVX3iaeHajORv84DScCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1272&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;①　&lt;/span&gt;&lt;span&gt;Overlay模式&lt;/span&gt;&lt;span&gt;是在二层或三层网络之上再构建起来一个独立的网络，这个网络通常会有自己独立的IP地址空间、交换或者路由的实现。VXLAN协议是目前最流行的Overlay网络隧道协议之一，显著优势就是灵活，对底层网络没有侵入性。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;②　&lt;/span&gt;&lt;span&gt;路由模式&lt;/span&gt;&lt;span&gt;放弃了跨主机容器在L2的连通性，而专注于通过路由协议提供容器在L3的通信方案；&lt;/span&gt;&lt;span&gt;路由模式&lt;/span&gt;&lt;span&gt;更易于集成到现在的数据中心的基础设施之上，便捷地连接容器和主机，并在报文过滤和隔离方面有着更好的扩展能力及更精细的控制模型。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;③　&lt;/span&gt;&lt;span&gt;Underlay模式&lt;/span&gt;&lt;span&gt;是借助驱动程序将宿主机的底层网络接口直接暴露给容器使用的一种网络构建技术，较为常见的解决方案有MAC VLAN、IP VLAN和直接路由等。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;1.2.Flannel网络插件&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;Flannel是由go语言开发，是一种基于overlay网络的跨主机容器网络插件。Flannel插件为集群中所有节点重新规划IP地址的分配规则，使得不同节点上的容器能够在同一个子网内，且IP地址不重复，实现不同节点上的容器通过内网IP直接通信。Flannel目前支持udp、vxlan、host-gw、aws-vpc、gce和alloc路由等多种灵活模式。但Flannel缺少必要的安全隔离，Qos等能力，适合常见简单，安全隔离要求较低的场景。以下是Flannel三种模式比较：&lt;/span&gt;&lt;/section&gt;&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot;&gt;&lt;section&gt;&lt;span&gt;模式&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot;&gt;&lt;section&gt;&lt;span&gt;底层网络要求&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot;&gt;&lt;section&gt;&lt;span&gt;实现模式&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot;&gt;&lt;section&gt;&lt;span&gt;封包/解包&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot;&gt;&lt;section&gt;&lt;span&gt;overlay网络&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot;&gt;&lt;section&gt;&lt;span&gt;转发效率&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot;&gt;&lt;section&gt;&lt;span&gt;Flannel UDP&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot;&gt;&lt;section&gt;&lt;span&gt;三层网络&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot;&gt;&lt;section&gt;&lt;span&gt;overlay&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot;&gt;&lt;section&gt;&lt;span&gt;用户态&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot;&gt;&lt;section&gt;&lt;span&gt;三层&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot;&gt;&lt;section&gt;&lt;span&gt;低&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot;&gt;&lt;section&gt;&lt;span&gt;Flannel VXLAN&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot;&gt;&lt;section&gt;&lt;span&gt;三层网络&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot;&gt;&lt;section&gt;&lt;span&gt;overlay&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot;&gt;&lt;section&gt;&lt;span&gt;内核态&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot;&gt;&lt;section&gt;&lt;span&gt;二层&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot;&gt;&lt;section&gt;&lt;span&gt;中&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot;&gt;&lt;section&gt;&lt;span&gt;Flannel host-gw&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot;&gt;&lt;section&gt;&lt;span&gt;二层网络&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot;&gt;&lt;section&gt;&lt;span&gt;路由&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot;&gt;&lt;section&gt;&lt;span&gt;无&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot;&gt;&lt;section&gt;&lt;span&gt;三层&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot;&gt;&lt;section&gt;&lt;span&gt;高&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;section&gt;&lt;span&gt;在Flannel VXLAN模式时，插件会在kubernetes集群的每个节点上创建vxlan设备与路由表。发往不同主机上容器数据包都会通过vxlan设备，封装成UDP数据发往目的地；在目的主机上，封装的UDP数据包会被解压并路由到目标POD。但是具体到POD如何分配IP，以及整个容器生命周期过程中CNI插件与其他组件怎么交互配合，是一个相当复杂的过程，本文通过Flannel插件，以及容器运行时Containerd，详细的说明容器网络运行的全过程。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;1.3.Kubelet、Container Runtime和CNI插件&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;1.3.1.Pod IP地址分配机制&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;当节点首次向集群注册时，nodeipam作为选项传递给kube-controller-manager的--controllers参数，控制器就会从集群CIDR（集群网络的IP范围）中为每个节点分配一个专用子网（podCIDR）。由于节点子网podCIDR保证不会重复，所以在为节点POD分配的IP地址也确保了唯一；如果需要更改节点的podCIDR，可以通过取消注册节点再重新注册实现。使用以下命令列出节点的podCIDR：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;shell&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;$ kubectl get no-o json | jq &#x27;.spec.podCIDR&#x27;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;10.244.0.0/24&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;1.3.2.Pod启动时网络配置过程&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;&lt;shapetype coordsize=&quot;21600,21600&quot; xmlns:o=&quot;urn:schemas-microsoft-com:office:office&quot; o:spt=&quot;75&quot; path=&quot;m@4@5l@4@11@9@11@9@5xe&quot; o:preferrelative=&quot;t&quot; filled=&quot;f&quot; stroked=&quot;f&quot;&gt;&lt;formulas&gt;&lt;f eqn=&quot;if lineDrawn pixelLineWidth 0&quot;/&gt;&lt;f eqn=&quot;sum @0 1 0&quot;/&gt;&lt;f eqn=&quot;sum 0 0 @1&quot;/&gt;&lt;f eqn=&quot;prod @2 1 2&quot;/&gt;&lt;f eqn=&quot;prod @3 21600 pixelWidth&quot;/&gt;&lt;f eqn=&quot;prod @3 21600 pixelHeight&quot;/&gt;&lt;f eqn=&quot;sum @0 0 1&quot;/&gt;&lt;f eqn=&quot;prod @6 1 2&quot;/&gt;&lt;f eqn=&quot;prod @7 21600 pixelWidth&quot;/&gt;&lt;f eqn=&quot;sum @8 21600 0&quot;/&gt;&lt;f eqn=&quot;prod @7 21600 pixelHeight&quot;/&gt;&lt;f eqn=&quot;sum @10 21600 0&quot;/&gt;&lt;/formulas&gt;&lt;path o:extrusionok=&quot;f&quot; gradientshapeok=&quot;t&quot; o:connecttype=&quot;rect&quot;/&gt;&lt;/shapetype&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;554&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;284&quot; data-ratio=&quot;0.5141287284144427&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8Tts2IxBm8slQ4mYeRv1Gyuibf9EAwte5C57qt2ccHcCKRcnMHFUT08eUlnXaSvTImCxQA3hZMgBLSyes5nY3wQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1274&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当一个POD被调度到节点时，会有很多初始化操作，以下是网络配置相关的配置及初始化过程详细步骤：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;①　POD被调度到容器集群的某个节点上&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;②　节点的kubelet通过调用CRI插件来创建POD&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;③　CRI插件创建POD Sandbox ID与POD网络命名空间&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;④　CRI插件通过POD网络命名空间和POD Sandbox ID来调用CNI插件&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;⑤　CNI插件配置POD网络，调用顺序从Flannel CNI插件，Bridge CNI 插件到主机IPAM CNI 插件，最后返回POD IP地址。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;⑥　创建Pause容器，并将其添加第三步创建的POD的网络命名空间&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;⑦　Kubelet调用CRI插件拉取应用容器镜像&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;⑧　容器运行时containerd拉取应用容器镜像&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;⑨　Kubelet调用CRI插件来启动应用容器&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;⑩　&lt;/span&gt;&lt;span&gt;CRI插件调用容器运行时containerd来启动和配置在pod cgroup和namespaces中的应用容器。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;1.3.3.CRI插件与CNI插件的交互&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;在POD初始化过程中，CRI插件会调用CNI插件来完成对POD网络的配置。CNI网络插件都会在kubernetes节点上安装配置代理，并附带CNI配置，然后CRI插件通过该配置来确定要调用那个CNI插件。CNI配置文件的位置默认值为/etc/cni/net.d/&lt;config-file&gt;，可以自定义配置。同时在每个节点上都会有CNI插件，CNI插件位置默认值为/opt/cni/bin，也可以自定义配置。在containerd作为容器运行时，CNI配置和CNI插件二进制文件的路径可以在containerd配置的[plugins.&quot;io.containerd.grpc.v1.cri&quot;.cni]中指定。&lt;/config-file&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于Flannel插件，Flanneld作为Flannel守护进程，通常安装在 kubernetes集群的节点上，而install-cni作为init容器，在每个节点上创建 CNI配置文件-/etc/cni/net.d/10-flannel.conflist。Flanneld创建vxlan设备，从API-SERVER获取并监听POD网络元数据。在创建POD时，为整个集群中的所有POD分配路由，通过路由实现POD IP地址相互通信。CRI插件与CNI插件之间的交互如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;shapetype coordsize=&quot;21600,21600&quot; xmlns:o=&quot;urn:schemas-microsoft-com:office:office&quot; o:spt=&quot;75&quot; path=&quot;m@4@5l@4@11@9@11@9@5xe&quot; o:preferrelative=&quot;t&quot; filled=&quot;f&quot; stroked=&quot;f&quot;&gt;&lt;formulas&gt;&lt;f eqn=&quot;if lineDrawn pixelLineWidth 0&quot;/&gt;&lt;f eqn=&quot;sum @0 1 0&quot;/&gt;&lt;f eqn=&quot;sum 0 0 @1&quot;/&gt;&lt;f eqn=&quot;prod @2 1 2&quot;/&gt;&lt;f eqn=&quot;prod @3 21600 pixelWidth&quot;/&gt;&lt;f eqn=&quot;prod @3 21600 pixelHeight&quot;/&gt;&lt;f eqn=&quot;sum @0 0 1&quot;/&gt;&lt;f eqn=&quot;prod @6 1 2&quot;/&gt;&lt;f eqn=&quot;prod @7 21600 pixelWidth&quot;/&gt;&lt;f eqn=&quot;sum @8 21600 0&quot;/&gt;&lt;f eqn=&quot;prod @7 21600 pixelHeight&quot;/&gt;&lt;f eqn=&quot;sum @10 21600 0&quot;/&gt;&lt;/formulas&gt;&lt;path o:extrusionok=&quot;f&quot; gradientshapeok=&quot;t&quot; o:connecttype=&quot;rect&quot;/&gt;&lt;/shapetype&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;554&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;296&quot; data-ratio=&quot;0.5369496855345912&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8Tts2IxBm8slQ4mYeRv1Gyuibf9EAwte5WiaekKyjoKHFKrb7dItIS5WAnEyd2xUic727ltSPl9lr7G06kicz1tB6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1272&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;①　Kubelet通过CRI插件调用容器运行时&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;②　CRI插件通过CNI配置文件调用CNI插件，为POD创建网络命名空间，网络命名空间在/var/run/netns/文件下&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;③　Flannel CNI插件配置和调用Bridge CNI plugin&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;④　Bridge CNI插件在主机上创建cniO网桥，并创建了veth对，一端插入容器网络命名空间，另一端连接到cniO网桥。然后调用已配置的IPAM 插件。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;⑤　host-local IPAM插件返回容器的IP地址和网关（cniO桥作为容器的网关），将IP地址分配给POD，桥接插件将网关IP地址分配给cniO桥接。所有分配的IP地址都存储在本地磁盘上的/var/lib/cni/networks/cni0/目录下。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;1.3.4.CNI插件间的交互&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;&lt;shapetype coordsize=&quot;21600,21600&quot; xmlns:o=&quot;urn:schemas-microsoft-com:office:office&quot; o:spt=&quot;75&quot; path=&quot;m@4@5l@4@11@9@11@9@5xe&quot; o:preferrelative=&quot;t&quot; filled=&quot;f&quot; stroked=&quot;f&quot;&gt;&lt;formulas&gt;&lt;f eqn=&quot;if lineDrawn pixelLineWidth 0&quot;/&gt;&lt;f eqn=&quot;sum @0 1 0&quot;/&gt;&lt;f eqn=&quot;sum 0 0 @1&quot;/&gt;&lt;f eqn=&quot;prod @2 1 2&quot;/&gt;&lt;f eqn=&quot;prod @3 21600 pixelWidth&quot;/&gt;&lt;f eqn=&quot;prod @3 21600 pixelHeight&quot;/&gt;&lt;f eqn=&quot;sum @0 0 1&quot;/&gt;&lt;f eqn=&quot;prod @6 1 2&quot;/&gt;&lt;f eqn=&quot;prod @7 21600 pixelWidth&quot;/&gt;&lt;f eqn=&quot;sum @8 21600 0&quot;/&gt;&lt;f eqn=&quot;prod @7 21600 pixelHeight&quot;/&gt;&lt;f eqn=&quot;sum @10 21600 0&quot;/&gt;&lt;/formulas&gt;&lt;path o:extrusionok=&quot;f&quot; gradientshapeok=&quot;t&quot; o:connecttype=&quot;rect&quot;/&gt;&lt;/shapetype&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;554&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;445&quot; data-ratio=&quot;0.8035982008995503&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8Tts2IxBm8slQ4mYeRv1Gyuibf9EAwte5zSaE3bwn6IJ0YtcejkdwLRnA3hdLnMUsypU1Wvaj9XVGYNicyKJws4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1334&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;CNI插件配置POD网络，调用顺序从Flannel CNI插件，Bridge CNI 插件到主机IPAM CNI 插件，最后返回POD IP地址。详情如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;①　&lt;/span&gt;&lt;span&gt;Flannel CNI插件&lt;/span&gt;&lt;span&gt;：Containerd CRI插件使用CNI配置文件- /etc/cni/net.d/10-flannel.conflist调用Flannel CNI插件：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ruby&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;$ cat /etc/cni/net.d/&lt;span class=&quot;code-snippet__number&quot;&gt;10&lt;/span&gt;-flannel.conflist{  &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;name&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;cni0&quot;&lt;/span&gt;,  &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;plugins&quot;&lt;/span&gt;: [    {      &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;type&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;flannel&quot;&lt;/span&gt;,      &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;delegate&quot;&lt;/span&gt;: {       &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;ipMasq&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;,        &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;hairpinMode&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;,        &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;isDefaultGateway&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;      }    }  ]}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当Flanneld启动时，会从API-SERVER获取podCIDR和其他与网络相关的详细信息，并存储在 -/run/flannel/subnet.env文件中：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ini&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;FLANNEL_NETWORK=10.244.0.0/16 &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;FLANNEL_SUBNET=10.244.0.1/24&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;FLANNEL_MTU=1450 &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;FLANNEL_IPMASQ=false&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Flannel CNI插件使用/run/flannel/subnet.env中的信息来配置和调用网桥CNI插件。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;②　&lt;/span&gt;&lt;span&gt;Bridge CNI插件：&lt;/span&gt;&lt;span&gt;Flannel CNI插件调用Bridge CNI插件，配置如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;json&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &quot;name&quot;: &quot;cni0&quot;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &quot;type&quot;: &quot;bridge&quot;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &quot;mtu&quot;: 1450,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &quot;ipMasq&quot;: false,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &quot;isGateway&quot;: true,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &quot;ipam&quot;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &quot;type&quot;: &quot;host-local&quot;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &quot;subnet&quot;: &quot;10.244.0.0/24&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首次调用Bridge CNI插件时，会创建一个linux网桥，并在配置文件中指定“名称”：“cni0”。然后为每一个POD创建veth对，veth对一端位于容器的网络命名空间中，另一端连接到主机网络的网桥上，使用 Bridge CNI插件，主机上的所有容器都连接到主机网络的网桥上。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;配置veth对后，Bridge插件调用主机本地IPAM CNI插件，可以在CNI config CRI插件中配置使用具体IPAM 插件。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;③　&lt;/span&gt;&lt;span&gt;主机本地 IPAM CNI 插件：&lt;/span&gt;&lt;span&gt;Bridge CNI插件使用以下配置调用主机本地 IPAM CNI 插件：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;json&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &quot;name&quot;: &quot;cni0&quot;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &quot;ipam&quot;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &quot;type&quot;: &quot;host-local&quot;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &quot;subnet&quot;: &quot;10.244.0.0/24&quot;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &quot;dataDir&quot;: &quot;/var/lib/cni/networks&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Host-local IPAM（IP地址管理）插件从子网返回容器的IP地址，并将分配的IP本地存储在主机上dataDir下指定的目录下- /var/lib/cni/networks/&lt;ip&gt;。/var/lib/cni/networks/&lt;ip&gt;文件包含分配 IP 的容器 ID。&lt;/ip&gt;&lt;/ip&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;调用时，主机本地IPAM 插件返回以下结果：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;json&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &quot;ip4&quot;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &quot;ip&quot;: &quot;10.244.4.2&quot;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &quot;gateway&quot;: &quot;10.244.4.3&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &quot;dns&quot;: {}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;1.4.&lt;/span&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;总体来说，容器网络是Kubernetes最复杂部分，同时也是设计精华所在，通过CNI标准开放，根据实际需求实现不同的CNI来满足差异化的需求，尤其是与底层基础云能力深度集成的场景，每个云厂商都有实现各自高效的网络插件。整个容器网络大致从以下三个方面理解：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先，在整体设计上，让POD有唯一的IP地址，通过为每个节点分配一个子网，从而保证节点为POD分配的IP地址，在整个集群内部不会重复。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其次，在容器网络是实现上，通过CNI将容器网络标准与具体实现解耦分类，通过插件引入不同的容器网络插件。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最后，在容器POD创建时，通过Kubelet，CRI插件，以及CNI插件相互配合，实现容器POD网络配置及初始化。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;shapetype coordsize=&quot;21600,21600&quot; xmlns:o=&quot;urn:schemas-microsoft-com:office:office&quot; o:spt=&quot;75&quot; path=&quot;m@4@5l@4@11@9@11@9@5xe&quot; o:preferrelative=&quot;t&quot; filled=&quot;f&quot; stroked=&quot;f&quot;&gt;&lt;formulas&gt;&lt;f eqn=&quot;if lineDrawn pixelLineWidth 0&quot;/&gt;&lt;f eqn=&quot;sum @0 1 0&quot;/&gt;&lt;f eqn=&quot;sum 0 0 @1&quot;/&gt;&lt;f eqn=&quot;prod @2 1 2&quot;/&gt;&lt;f eqn=&quot;prod @3 21600 pixelWidth&quot;/&gt;&lt;f eqn=&quot;prod @3 21600 pixelHeight&quot;/&gt;&lt;f eqn=&quot;sum @0 0 1&quot;/&gt;&lt;f eqn=&quot;prod @6 1 2&quot;/&gt;&lt;f eqn=&quot;prod @7 21600 pixelWidth&quot;/&gt;&lt;f eqn=&quot;sum @8 21600 0&quot;/&gt;&lt;f eqn=&quot;prod @7 21600 pixelHeight&quot;/&gt;&lt;f eqn=&quot;sum @10 21600 0&quot;/&gt;&lt;/formulas&gt;&lt;path o:extrusionok=&quot;f&quot; gradientshapeok=&quot;t&quot; o:connecttype=&quot;rect&quot;/&gt;&lt;/shapetype&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8Tts2IxBm8slQ4mYeRv1Gyuibf9EAwte5NXJUtpebRg3MKSOHD3wHMYoU5RsY2PJCmhQrnqTASqXcmFOPZvPfqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;238&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;关注“巨子嘉”，巨子出品，必属精品&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>12abf24c44139672e98ccc2aaa13fb39</guid>
<title>InnoDB 对 Buffer Pool 的奇思妙想</title>
<link>https://toutiao.io/k/5hfac2o</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;本文读完需&lt;span&gt;&lt;strong&gt;9&lt;/strong&gt;&lt;/span&gt;分钟，速读仅需&lt;span&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;/span&gt;分钟。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.025936599423631124&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibqicBWEiaFhaUkEs3YhX1fKvaBcTc3V7YooNTGXoXQEGE8V3BGstZA0g9OpLlWicaefuM0zBUvxG3mPIlLdP7vnYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;694&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;前言&lt;br/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;大家好，我是阿星，又跟大家见面了。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信很多小伙伴在面试中都被问过「为什么要用缓存？」，大部分人都是回答：「减少数据库的磁盘&lt;code&gt;IO&lt;/code&gt;压力」。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是&lt;code&gt;MySQL&lt;/code&gt;真的有如此不堪吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每次增删改查都要去走磁盘&lt;code&gt;IO&lt;/code&gt;吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天就聊聊&lt;code&gt;InnoDB&lt;/code&gt;对&lt;code&gt;Buffer Pool&lt;/code&gt;的奇思妙想。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Buffer Pool&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先梳理出问题，再思考如何解决问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设我们就是&lt;code&gt;InnoDB&lt;/code&gt;，我们要如何去解决磁盘&lt;code&gt;IO&lt;/code&gt;问题？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个简单，做缓存就好了，所以&lt;code&gt;MySQL&lt;/code&gt;需要申请一块内存空间，这块内存空间称为&lt;code&gt;Buffer Pool&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;223&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.39901477832512317&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzibSg1dO1RTZY5uYMEsAgSzrwsV4W0iagzHRStB22JelLrTX4miaicVNyMG8OSAHG0KWrsoMica6nvvug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;609&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Buffer Pool&lt;/code&gt;是申请下来了，但是&lt;code&gt;Buffer Pool&lt;/code&gt;里面放什么，要怎么规划？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;缓存页&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;MySQL&lt;/code&gt;数据是以页为单位，每页默认&lt;code&gt;16KB&lt;/code&gt;，称为数据页，在&lt;code&gt;Buffer Pool&lt;/code&gt;里面会划分出若干&lt;strong&gt;个缓存页&lt;/strong&gt;与数据页对应。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;479&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.857849196538937&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzibSg1dO1RTZY5uYMEsAgSz7UHKNLm8PaWmBEVHGJFxI7ib2JzsIETgtwpPxltetKVn3hs91ZXSn9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;809&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;感觉还少了点什么，我们如何知道缓存页对应那个数据页呢？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;描述数据&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所有还需要缓存页的元数据信息，可以称为&lt;strong&gt;描述数据&lt;/strong&gt;，它与缓存页一一对应，包含一些所属表空间、数据页的编号、&lt;code&gt;Buffer Pool&lt;/code&gt;中的地址等等。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;484&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.8679950186799502&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzibSg1dO1RTZY5uYMEsAgSzpjGX3qfibNtulxQCjAMkTibvH3sKko21up0rjn4hRM8v3icrKQQvTN6CQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;803&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后续对数据的增删改查都是在&lt;code&gt;Buffer Pool&lt;/code&gt;里操作&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;查询：从磁盘加载到缓存，后续直接查缓存&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;插入：直接写入缓存&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;更新删除：缓存中存在直接更新，不存在加载数据页到缓存更新&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能有小伙伴担心，&lt;code&gt;MySQL&lt;/code&gt;宕机了，数据不就全丢了吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个不用担心，因为&lt;code&gt;InnoDB&lt;/code&gt;提供了&lt;code&gt;WAL&lt;/code&gt;技术（Write-Ahead Logging），通过&lt;code&gt;redo log&lt;/code&gt;让&lt;code&gt;MySQL&lt;/code&gt;拥有了崩溃恢复能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再配合空闲时，会有异步线程做缓存页刷盘，保证数据的持久性与完整性。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;486&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.8702770780856424&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzibSg1dO1RTZY5uYMEsAgSzVadY8m1MQ7KtjFzy5sEAdpLKIblbDQIEiauM7sKUUB5Emo3khh69uGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;794&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不能理解&lt;code&gt;redo log&lt;/code&gt;是如何恢复数据的，可以看看阿星前面两篇文章&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，直接更新数据的缓存页称为&lt;strong&gt;脏页&lt;/strong&gt;，缓存页刷盘后称为&lt;strong&gt;干净页&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;Free链表&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;MySQL&lt;/code&gt;数据库启动时，按照设置的&lt;code&gt;Buffer Pool&lt;/code&gt;大小，去找操作系统申请一块内存区域，作为&lt;code&gt;Buffer Pool&lt;/code&gt;（&lt;strong&gt;假设申请了512MB&lt;/strong&gt;）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;申请完毕后，会按照默认缓存页的&lt;code&gt;16KB&lt;/code&gt;以及对应的&lt;code&gt;800Byte&lt;/code&gt;的描述数据，在&lt;code&gt;Buffer Pool&lt;/code&gt;中划分出来一个一个的缓存页和它们对应的描述数据。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;426&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.762945914844649&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzibSg1dO1RTZY5uYMEsAgSzISr1h07a3KOvFYFOPlEALTBRicfCTX2RHemYVHeLnVdGLKsVj3H1PGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;869&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;MySQL&lt;/code&gt;运行起来后，会不停的执行增删改查，需要从磁盘读取一个一个的数据页放入&lt;code&gt;Buffer Pool&lt;/code&gt;对应的缓存页里，把数据缓存起来，以后就可以在内存里执行增删改查。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;602&quot; data-backw=&quot;558&quot; data-ratio=&quot;1.0785070785070785&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzibSg1dO1RTZY5uYMEsAgSzYKwkB2bGugr1cTbe6YJztxrzwvwaZWkfWyN4mmhFhVia5lhU4qYVP6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;777&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这个过程必然涉及一个问题，&lt;strong&gt;哪些缓存页是空闲的&lt;/strong&gt;？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决这个问题，我们使用链表结构，把空闲缓存页的&lt;strong&gt;描述数据&lt;/strong&gt;放入链表中，这个链表称为&lt;code&gt;free&lt;/code&gt;链表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对&lt;code&gt;free&lt;/code&gt;链表我们要做如下设计&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;196&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.3504442250740375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzibSg1dO1RTZY5uYMEsAgSzwic43rpiawNO5ntkqpmymPK4ddYwgAIB1z173rD1vtzMuibMWicNkBibV2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1013&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终呈现出来的，是由空闲缓存页的&lt;strong&gt;描述数据&lt;/strong&gt;组成的&lt;code&gt;free&lt;/code&gt;链表。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;505&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.9044481054365733&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzibSg1dO1RTZY5uYMEsAgSzW4KseSdGVoLm0DqrYC6N0kkW1ls2lOjdaibhFiaNr5MqD4Qbo6sQibAsA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;607&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了&lt;code&gt;free&lt;/code&gt;链表之后，我们只需要从&lt;code&gt;free&lt;/code&gt;链表获取一个&lt;strong&gt;描述数据&lt;/strong&gt;，就可以获取到对应的缓存页。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;426&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.7628318584070797&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzibSg1dO1RTZY5uYMEsAgSzf4zVDNmqbKDXbl45VE4C9fRl7uLMlfibraBSQrl6Vyp8V8AYVmgdia3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1130&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;往&lt;strong&gt;描述数据&lt;/strong&gt;与&lt;strong&gt;缓存页&lt;/strong&gt;写入数据后，就将该&lt;strong&gt;描述数据&lt;/strong&gt;移出&lt;code&gt;free&lt;/code&gt;链表。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;缓存页哈希表&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据页是缓存进去了，但是又一个问题来了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下次查询数据时，如何在&lt;code&gt;Buffer Pool&lt;/code&gt;里快速定位到对应的缓存页呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;难道需要一个&lt;strong&gt;非空闲的描述数据&lt;/strong&gt;链表，再通过&lt;strong&gt;表空间号+数据页编号&lt;/strong&gt;遍历查找吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样做也可以实现，但是效率不太高，时间复杂度是&lt;code&gt;O(N)&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;194&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.34835566382460414&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzibSg1dO1RTZY5uYMEsAgSz247HiaLyA5PGruyldYCAZ7TA5mZSqKAlwS3MbpKeVE7FNaoWiav55BYQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;821&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们可以换一个结构，使用哈希表来缓存它们间的映射关系，时间复杂度是&lt;code&gt;O(1)&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;220&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.3940345368916798&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzibSg1dO1RTZY5uYMEsAgSzdaQ9TAP6m07jrcMAMGh8pUw8Hzlj1HBZ8XMrOXZfoicfIEoQ227KU2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;637&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;表空间号+数据页号&lt;/strong&gt;，作为一个&lt;code&gt;key&lt;/code&gt;，然后缓存页的地址作为&lt;code&gt;value&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每次加载数据页到空闲缓存页时，就写入一条映射关系到&lt;strong&gt;缓存页哈希表&lt;/strong&gt;中。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;413&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.7392739273927392&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzibSg1dO1RTZY5uYMEsAgSzPfxia6zvzUqI4SJD9PpSVavh5sEFF0HGkdR9gAWNA1Ooa3G3QYeouIw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1212&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后续的查询，就可以通过&lt;strong&gt;缓存页哈希表&lt;/strong&gt;路由定位了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;Flush链表&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还记得之前有说过「&lt;strong&gt;空闲时会有异步线程做缓存页刷盘，保证数据的持久性与完整性&lt;/strong&gt;」吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新问题来了，难道每次把&lt;code&gt;Buffer Pool&lt;/code&gt;里所有的缓存页都刷入磁盘吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然不能这样做，磁盘&lt;code&gt;IO&lt;/code&gt;开销太大了，应该把&lt;strong&gt;脏页&lt;/strong&gt;刷入磁盘才对（更新过的缓存页）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可是我们怎么知道，那些缓存页是&lt;strong&gt;脏页&lt;/strong&gt;？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很简单，参照&lt;code&gt;free&lt;/code&gt;链表，弄个&lt;code&gt;flush&lt;/code&gt;链表出来就好了，只要缓存页被更新，就将它的&lt;strong&gt;描述数据&lt;/strong&gt;加入&lt;code&gt;flush&lt;/code&gt;链表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对&lt;code&gt;flush&lt;/code&gt;链表我们要做如下设计&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;新增&lt;code&gt;flush&lt;/code&gt;基础节点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;描述数据添加&lt;code&gt;flush&lt;/code&gt;节点指针&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;200&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.3584905660377358&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzibSg1dO1RTZY5uYMEsAgSz2k4gicPfHicSqcHqeTtFGH9Pb7n1Wxo0pRETAZJtszz9xhd3kULstz1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1007&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终呈现出来的，是由更新过数据的缓存页&lt;strong&gt;描述数据&lt;/strong&gt;组成的&lt;code&gt;flush&lt;/code&gt;链表。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;527&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.9451114922813036&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzibSg1dO1RTZY5uYMEsAgSz79jHx0d2xicwGHvdAFZlckSdwgoMWHbFTjwml1HmbVwcUrzFTJCTonA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;583&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后续异步线程都从&lt;code&gt;flush&lt;/code&gt;链表刷缓存页，当&lt;code&gt;Buffer Pool&lt;/code&gt;内存不足时，也会优先刷&lt;code&gt;flush&lt;/code&gt;链表里的缓存页。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;LRU链表&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前看来&lt;code&gt;Buffer Pool&lt;/code&gt;的功能已经比较完善了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;452&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.8096885813148789&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzibSg1dO1RTZY5uYMEsAgSzg2yibXsUFugyX1h0ZT1ct5ec4hWeqcUdlKEOHf9ic9Cc2EBIUXIvia4lA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1156&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是仔细思考下，发现还有一个问题没处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;MySQL&lt;/code&gt;数据库随着系统的运行会不停的把磁盘上的数据页加载到空闲的缓存页里去，因此&lt;code&gt;free&lt;/code&gt;链表中的空闲缓存页会越来越少，直到没有，最后磁盘的数据页无法加载。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;326&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.5849731663685152&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzibSg1dO1RTZY5uYMEsAgSzMcVVTk5SXaNgUppwdYRrXjE3bzFSg4vZeU8C5MdXukUicSzAItmEKqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1118&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决这个问题，我们需要淘汰缓存页，腾出空闲缓存页。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可是我们要优先淘汰那些缓存页？总不能一股脑直接全部淘汰吧？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里就要借鉴&lt;code&gt;LRU&lt;/code&gt;算法思想，把最少使用的缓存页淘汰（命中率低），提供&lt;code&gt;LRU&lt;/code&gt;链表出来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对&lt;code&gt;LRU&lt;/code&gt;链表我们要做如下设计&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;188&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.33724340175953077&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzibSg1dO1RTZY5uYMEsAgSzOMdrlAGb7xNyibq6GrZicDsJbjg5P0HvRJnxENdZnD3icNC6bia1RBK5ZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1023&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现思路也很简单，只要是查询或修改过缓存页，就把该缓存页的描述数据放入链表头部，也就说近期访问的数据一定在链表头部。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;165&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.296086508753862&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzibSg1dO1RTZY5uYMEsAgSz7baibQA3lUtkbvibOctreMl8wK21DBuTWvqfL12hSO3lwliajicAlZdA1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1942&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当&lt;code&gt;free&lt;/code&gt;链表为空的时候，直接淘汰&lt;code&gt;LRU&lt;/code&gt;链表尾部缓存页即可。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;LRU链表优化&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;麻雀虽小五脏俱全，基本&lt;code&gt;Buffer Pool&lt;/code&gt;里与缓存页相关的组件齐全了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;428&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.7663551401869159&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzibSg1dO1RTZY5uYMEsAgSzW0ToicMUfI2CjMJ6dsZcy3VvXF1RsWbQOIkmdB6LqqBib0G55ia7Tu1ng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1284&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是缓存页淘汰这里还有点问题，如果仅仅只是使用&lt;code&gt;LRU&lt;/code&gt;链表的机制，有两个场景会让&lt;strong&gt;热点数据&lt;/strong&gt;被淘汰。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;预读机制是指&lt;code&gt;MySQL&lt;/code&gt;加载数据页时，可能会把它相邻的数据页一并加载进来（局部性原理）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样会带来一个问题，预读进来的数据页，其实我们没有访问，但是它却排在前面。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;280&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.5011210762331838&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzibSg1dO1RTZY5uYMEsAgSz9YnRHPpZBwCgics3UXVibtZdGOJnUfrvkdU2bmMZW0NPhUSj27P37vwg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;892&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正常来说，淘汰缓存页时，应该把这个预读的淘汰，结果却把尾部的淘汰了，这是不合理的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们接着来看第二个场景全表扫描，如果&lt;strong&gt;表数据量大&lt;/strong&gt;，大量的数据页会把空闲缓存页用完。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终&lt;code&gt;LRU&lt;/code&gt;链表前面都是全表扫描的数据，之前频繁访问的热点数据全部到队尾了，淘汰缓存页时就把&lt;strong&gt;热点数据页&lt;/strong&gt;给淘汰了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;262&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.46986607142857145&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzibSg1dO1RTZY5uYMEsAgSzN6rP6mMyb4Xm77xaq6uFMuibExtlXiaYt1PS3GSFWhLnB6wyXt8CMXoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;896&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决上述的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们需要给&lt;code&gt;LRU&lt;/code&gt;链表做冷热数据分离设计，把&lt;code&gt;LRU&lt;/code&gt;链表按一定比例，分为冷热区域，热区域称为&lt;code&gt;young&lt;/code&gt;区域，冷区域称为&lt;code&gt;old&lt;/code&gt;区域。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;以7:3为例，young区域70%，old`区域30%&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;178&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.31882202304737517&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzibSg1dO1RTZY5uYMEsAgSzk1DKfvTzGyQVv6ZKWmR7cFRSFy3B2VWNqksred9hUjw7vWic1iayUMjA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1562&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图所示，数据页第一次加载进缓存页的时候，是先放入冷数据区域的头部，如果1秒后再次访问缓存页，则会移动到热区域的头部。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就保证了&lt;strong&gt;预读机制&lt;/strong&gt;与&lt;strong&gt;全表扫描&lt;/strong&gt;加载的数据都在链表队尾。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;young&lt;/code&gt;区域其实还可以做一个小优化，为了防止&lt;code&gt;young&lt;/code&gt;区域节点频繁移动到表头。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;young&lt;/code&gt;区域前面&lt;code&gt;1/4&lt;/code&gt;被访问不会移动到链表头部，只有后面的&lt;code&gt;3/4&lt;/code&gt;被访问了才会。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;记住是按照某个比例将&lt;code&gt;LRU&lt;/code&gt;链表分成两部分，不是某些节点固定是&lt;code&gt;young&lt;/code&gt;区域的，某些节点固定是&lt;code&gt;old&lt;/code&gt;区域的，随着程序的运行，某个节点所属的区域也可能发生变化。&lt;/p&gt;&lt;/blockquote&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;小结&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实&lt;code&gt;MySQL&lt;/code&gt;就是这样实现&lt;code&gt;Buffer Pool&lt;/code&gt;缓存页的，只不过它里面的链表全&lt;strong&gt;是双向链表&lt;/strong&gt;，阿星这里偷个懒，但是不影响理解思路。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读到这里，我相信大家对&lt;code&gt;Buffer Pool&lt;/code&gt;缓存页有了深刻的认知，也知道从一个增删改查开始，如何缓存数据、定位缓存、缓存刷盘、缓存淘汰。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里留问题给大家思考，&lt;code&gt;Free、Flush、LRU&lt;/code&gt;这三个链表之间的联系，随着&lt;code&gt;MySQL&lt;/code&gt;一直在运行，它们会产生怎样的联动。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;MySQL好文推荐&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非常感谢各位小哥哥小姐姐们能看到这里，原创不易，文章有帮助可以关注、点个赞、分享与评论，都是支持（莫要白嫖）！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;愿你我都能奔赴在各自想去的路上，我们下篇文章见。&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAwMDg2OTAxNg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nziaXQQjkzSxQkAmbFAzI9BLo4UHedGwVNmDuNZa8BvPSOI7V8ibNdHXFt89c7xrY9YvibafERPUubtQ/0?wx_fmt=png&quot; data-nickname=&quot;程序猿阿星&quot; data-alias=&quot;cxyax1993&quot; data-signature=&quot;一起成长进阶！专注技术原理、源码，通过图解方式输出技术，这里将会分享操作系统、计算机网络、Java、分布式、数据库等精品原创文章&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6279fed585000fce1605e307b2f45d69</guid>
<title>Antlr一个领域语言利器——入门篇</title>
<link>https://toutiao.io/k/tj64vev</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;  Antlr（Another Tool for Language Recognition）为开源的语法分析器，可以将输入的内容自动生成语法树；开发者可以使用它自定义自己的领域语言，只需创建语法规则文件，使用Antlr根据该规则文件生成相对应的类，再这些类的基础上我们可以用于实现自己的功能;Antlr4为Antlr的最新版本目前看到的基本也是Antlr4；&lt;br/&gt;  这些类主要包括两个方面的内容：1、实现了对输入的内容进行词法分析（Lexer）部分；2、根据词法构建出对应的语法树（Syntax Tree）；&lt;br/&gt;  &lt;strong&gt;使用场景：&lt;/strong&gt;1、领域特定语言；2、文本解析；3、算术运算等等；在各类开源框架中也都有看到Antlr4的身影，如Hive、Spark、Presto、Hibernate 等等；&lt;/p&gt;&lt;h3&gt;Antlr4基础语法&lt;/h3&gt;&lt;h4&gt;1、语法基本格式&lt;/h4&gt;&lt;pre highlighted=&quot;true&quot; has-selection=&quot;true&quot;&gt;&lt;code&gt;&lt;span&gt;//声明语法头，生成的Java类将使用此前缀，必须与xx.g4文件同名&lt;/span&gt;&lt;br/&gt;grammar Name; &lt;br/&gt;&lt;span&gt;options&lt;/span&gt; {}   &lt;span&gt;//选项：语言选，输出选项等；项 &lt;/span&gt;&lt;br/&gt;lnaguage&lt;span&gt;=&lt;/span&gt;Java;output&lt;span&gt;=&lt;/span&gt;AST      &lt;br/&gt;import &lt;span&gt;...&lt;/span&gt; ;  &lt;span&gt;//如g4文件过大可拆分，使用import引入&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;tokens&lt;/span&gt; {&lt;span&gt;...&lt;/span&gt;}  &lt;span&gt;//为那些没有关联词法规则的grammar定义tokens类型&lt;/span&gt;&lt;br/&gt;&lt;span&gt;channels&lt;/span&gt; {&lt;span&gt;...&lt;/span&gt;} &lt;span&gt;// 词法分析时才可定义&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@&lt;/span&gt;&lt;span&gt;actionName&lt;/span&gt; {&lt;span&gt;...&lt;/span&gt;}   &lt;span&gt;//动作：可将目标语言嵌入到g4中，有可调用对应外部代码&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//规则，此语法文件所定义的规则，分为词法规则与语法规则&lt;/span&gt;&lt;br/&gt;规则；&lt;br/&gt;rule1&lt;br/&gt;&lt;span&gt;...&lt;/span&gt;&lt;br/&gt;ruleN&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;三个基本动作：&lt;/h4&gt;&lt;h4&gt;@header { package co.linx.test.antlr; }&lt;/h4&gt;&lt;p&gt;此动作可在运行脚本后，所生成的类中自动带上包路径，不用手动移动。&lt;/p&gt;&lt;h4&gt;@members {}&lt;/h4&gt;&lt;p&gt;将代码中变量或方法注入到recognizer类中&lt;/p&gt;&lt;h4&gt;@after {System.out.println(&quot;after matching rule;&quot;);}&lt;/h4&gt;&lt;h4&gt;规则：&lt;/h4&gt;&lt;p&gt;词法规则（lexer）：以大写字母开头，用于词法分析；&lt;br/&gt;语法规则（parser）：以小写字母开头，用于语法分析，字符串与lexer组合匹配分析句子；&lt;br/&gt;以 : 开始 ; 结束，用 | 分隔对多规则分隔&lt;/p&gt;&lt;h3&gt;2、简单示例&lt;/h3&gt;&lt;p&gt;+匹配前一个匹配项最少一次， * 匹配前一个匹配项0次或多次 ?可选 ~ 取反&lt;/p&gt;&lt;pre highlighted=&quot;true&quot;&gt;&lt;code&gt;grammar Hello;&lt;br/&gt;init  :&lt;span&gt;&#x27;hello&#x27;&lt;/span&gt; ID ;          &lt;span&gt;// parser. 匹配关键字&#x27;hello&#x27;后⾯跟⼀个ID&lt;/span&gt;&lt;br/&gt;ID :[a-z]+ ;             &lt;span&gt;// lexer. 匹配⼩写字母组成的ID&lt;/span&gt;&lt;br/&gt;WS :[ \t\r\n]+ -&amp;gt; skip ;   &lt;span&gt;//lexer. 系统级规则匹配时跳过空格、tabs、换⾏符&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;一个Antlr4计算器&lt;/h3&gt;&lt;h4&gt;1、语法文件：&lt;/h4&gt;&lt;pre highlighted=&quot;true&quot; has-selection=&quot;true&quot;&gt;&lt;code&gt;grammar Calc;&lt;br/&gt;&lt;br/&gt;prog : &lt;span&gt;stat&lt;/span&gt;+;&lt;br/&gt;&lt;span&gt;stat&lt;/span&gt;: &lt;span&gt;expr&lt;/span&gt; NEWLINE          &lt;span&gt;# printExpr&lt;/span&gt;&lt;br/&gt;| ID &lt;span&gt;&#x27;=&#x27;&lt;/span&gt; &lt;span&gt;expr&lt;/span&gt; NEWLINE   &lt;span&gt;# assign&lt;/span&gt;&lt;br/&gt;| NEWLINE               &lt;span&gt;# blank&lt;/span&gt;&lt;br/&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;expr&lt;/span&gt;: &lt;span&gt;expr&lt;/span&gt; op=(&lt;span&gt;&#x27;*&#x27;&lt;/span&gt;|&lt;span&gt;&#x27;/&#x27;&lt;/span&gt;) &lt;span&gt;expr&lt;/span&gt;    &lt;span&gt;# MulDiv&lt;/span&gt;&lt;br/&gt;| &lt;span&gt;expr&lt;/span&gt; op=(&lt;span&gt;&#x27;+&#x27;&lt;/span&gt;|&lt;span&gt;&#x27;-&#x27;&lt;/span&gt;) &lt;span&gt;expr&lt;/span&gt;        &lt;span&gt;# AddSub&lt;/span&gt;&lt;br/&gt;| INT                           &lt;span&gt;# int&lt;/span&gt;&lt;br/&gt;| ID                            &lt;span&gt;# id&lt;/span&gt;&lt;br/&gt;| &lt;span&gt;&#x27;(&#x27;&lt;/span&gt; &lt;span&gt;expr&lt;/span&gt; &lt;span&gt;&#x27;)&#x27;&lt;/span&gt;                  &lt;span&gt;# parens&lt;/span&gt;&lt;br/&gt;;&lt;br/&gt;MUL : &lt;span&gt;&#x27;*&#x27;&lt;/span&gt; ; // assigns token name to &lt;span&gt;&#x27;*&#x27;&lt;/span&gt; used above &lt;span&gt;in&lt;/span&gt; grammar&lt;br/&gt;DIV : &lt;span&gt;&#x27;/&#x27;&lt;/span&gt; ;&lt;br/&gt;ADD : &lt;span&gt;&#x27;+&#x27;&lt;/span&gt; ;&lt;br/&gt;SUB : &lt;span&gt;&#x27;-&#x27;&lt;/span&gt; ;&lt;br/&gt;ID : [a-zA-Z]+ ;&lt;br/&gt;INT : [0-9]+ ;&lt;br/&gt;NEWLINE:&lt;span&gt;&#x27;\r&#x27;&lt;/span&gt;? &lt;span&gt;&#x27;\n&#x27;&lt;/span&gt; ;&lt;br/&gt;DELIMITER : &lt;span&gt;&#x27;;&#x27;&lt;/span&gt;;&lt;br/&gt;WS : [ \t]+ -&amp;gt; skip;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  可使用Maven插件、IDEA插件、或Antlr4自带命令行工具生成相关词法、语法分析器类；&lt;br/&gt;  Antlr4提供了两种方式可以访问语法树：观察者模式、访问者模式；&lt;/p&gt;&lt;p&gt;  &lt;strong&gt;观察者模式：&lt;/strong&gt; 通过结点监听触发处理方法，无需定义遍历语法树顺序，动作与文法解耦，处理时需通过自定义map存储中间结果,继承：XXXBaseListener类实现；&lt;br/&gt;  &lt;strong&gt;访问者模式：&lt;/strong&gt; 主动遍历语法树，动作与文法解耦，visitor访问节点时有返回值，无需定义map存储中间结果，继承：XXXBaseVisitor类实现；&lt;/p&gt;&lt;h3&gt;2、实现计算逻辑&lt;/h3&gt;&lt;p&gt;  这里使用访问者模式实现计算器，继承：CalcBaseVisitor类，重写visitMulDiv与visitAddSub方法实现：加减乘除计算逻辑；&lt;/p&gt;&lt;pre highlighted=&quot;true&quot;&gt;&lt;code&gt;&lt;span&gt;@Override&lt;/span&gt; &lt;br/&gt;&lt;span&gt;public&lt;/span&gt; Integer visitMulDiv(CalcParser.MulDivContext ctx) {&lt;br/&gt;    Integer left = ctx.expr(&lt;span&gt;0&lt;/span&gt;).accept(&lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;    Integer right = ctx.expr(&lt;span&gt;1&lt;/span&gt;).accept(&lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (ctx.op.getType() == CalcParser.MUL){&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; left * right;&lt;br/&gt;    }&lt;span&gt;else&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; left / right;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;@Override&lt;/span&gt; &lt;br/&gt;&lt;span&gt;public&lt;/span&gt; Integer visitAddSub(CalcParser.AddSubContext ctx) {&lt;br/&gt;    Integer left = ctx.expr(&lt;span&gt;0&lt;/span&gt;).accept(&lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;    Integer right = ctx.expr(&lt;span&gt;1&lt;/span&gt;).accept(&lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (ctx.op.getType() == CalcParser.ADD){&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; left + right;&lt;br/&gt;    }&lt;span&gt;else&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; left - right;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;3、使用该语法树计算器&lt;/h3&gt;&lt;pre highlighted=&quot;true&quot;&gt;&lt;code&gt;&lt;span&gt;CharStream&lt;/span&gt; &lt;span&gt;input&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; CharStreams.fromString(&lt;span&gt;&quot;22*3+12\r\n&quot;&lt;/span&gt;);&lt;br/&gt;CalcLexer lexer=&lt;span&gt;new&lt;/span&gt; &lt;span&gt;CalcLexer&lt;/span&gt;(input);&lt;br/&gt;&lt;span&gt;CommonTokenStream&lt;/span&gt; &lt;span&gt;tokens&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;CommonTokenStream&lt;/span&gt;(lexer);&lt;br/&gt;&lt;span&gt;CalcParser&lt;/span&gt; &lt;span&gt;parser&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;CalcParser&lt;/span&gt;(tokens);&lt;br/&gt;&lt;span&gt;ParseTree&lt;/span&gt; &lt;span&gt;tree&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; parser.prog(); &lt;span&gt;// parse&lt;/span&gt;&lt;br/&gt;EvalVisitor vt=&lt;span&gt;new&lt;/span&gt; &lt;span&gt;EvalVisitor&lt;/span&gt;();&lt;br/&gt;System.out.printf(&lt;span&gt;&quot;%s\n&quot;&lt;/span&gt;, vt.visit(tree));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  Antlr的实现可不只是计算器这种小玩意，我们通常有多个数据源，在没有统一的查询入口的时候通常只能打开各个客户端工具进行查询，有了Antlr我们可以很方便的实现一种称之为：XQL的语言，可实现通过XQL就可查询Kafka、Redis、MySQL、文件（csv、json、parquet）等数据源的数据；&lt;br/&gt;  通过Antlr实现的统一XQL查询引擎：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9445910290237467&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mGZDOXnuCWzCEcsqh3fdprC5Rhwd0Bibia6meW94ibhdLibhiavML9D4x3SUDIvkMyXoECEDiaQuJ3TjjgMy17Gzicelw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;379&quot;/&gt;&lt;/p&gt;&lt;p&gt;参考资料：&lt;br/&gt;Antlr4&lt;br/&gt;语法规则&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                          
              &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f8028b4fcba6fdffdceecadd411cf538</guid>
<title>欢迎加入读者圈子，一起交流！</title>
<link>https://toutiao.io/k/mv211dm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;&lt;strong&gt;欢迎加入读者圈子，一起交流！&lt;br/&gt;↓↓↓&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;307&quot; data-ratio=&quot;0.5493333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavich3VaNkKeiaAwUhz7TQbQmic4fFsr58X9PAYleYzxqc1K1vZjeBoZDMUsmia0xH67EQYINGRvNOtLmA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;圈子剧透&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、600+圈子成员，以中高级程序员为主，更有架构师、CTO坐镇交流；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、1000+优质主题，数十G独家资料，每日分享，精挑细选；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、全年52期专属邮件周报，让你轻松掌握业界资讯、技术干货，提升认知水平；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、全年52本好书共读，让你花最少的时间，获取更好的知识；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;心动不如行动，赶快加入吧！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>