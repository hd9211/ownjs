<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>fae532b3c3603114df73d958063ce428</guid>
<title>2021 年马上就要结束了！抓紧啦！</title>
<link>https://toutiao.io/k/rf8ezjy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>93887cb775cc51ff106ab47da79786f9</guid>
<title>Python调用Prometheus监控数据并计算</title>
<link>https://toutiao.io/k/x6qjuel</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;h2&gt;Prometheus是什么&lt;/h2&gt;

&lt;p&gt;Prometheus是一套开源监控系统和告警为一体，由go语言(golang)开发，是监控+报警+时间序列数
据库的组合。适合监控docker容器。因为kubernetes(k8s)的流行带动其发展。&lt;/p&gt;

&lt;h3&gt;Prometheus的主要特点&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;多维度&lt;a href=&quot;https://prometheus.io/docs/concepts/data_model/&quot;&gt;数据模型&lt;/a&gt;，由指标名称和键/值对标识的时间序列数据。&lt;/li&gt;
&lt;li&gt;作为一个时间序列数据库，其采集的数据会以文件的形式存储在本地中。&lt;/li&gt;
&lt;li&gt;灵活的查询语言，&lt;a href=&quot;https://prometheus.io/docs/prometheus/latest/querying/basics/&quot;&gt;PromQL&lt;/a&gt;(Prometheus Query Language)函数式查询语言。&lt;/li&gt;
&lt;li&gt;不依赖分布式存储，单个服务器节点是自治的。&lt;/li&gt;
&lt;li&gt;以HTTP方式，通过pull模型拉取时间序列数据。&lt;/li&gt;
&lt;li&gt;也可以通过&lt;a href=&quot;https://prometheus.io/docs/instrumenting/pushing/&quot;&gt;中间网关&lt;/a&gt;支持push模型。&lt;/li&gt;
&lt;li&gt;通过服务发现或者静态配置，来发现目标服务对象。&lt;/li&gt;
&lt;li&gt;支持多种多样的图表和界面展示。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Prometheus原理架构图&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/canhui/picture/raw/master/2021/images/image-20211202173238726.png&quot; alt=&quot;image-20211202173238726&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;Prometheus基础概念&lt;/h2&gt;

&lt;h3&gt;什么是时间序列数据&lt;/h3&gt;

&lt;p&gt;时间序列数据(TimeSeries Data) : 按照时间顺序记录系统、设备状态变化的数据被称为时序数据。&lt;/p&gt;

&lt;p&gt;应用的场景很多，如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;无人驾驶运行中记录的经度，纬度，速度，方向，旁边物体距离等。&lt;/li&gt;
&lt;li&gt;某一个地区的各车辆的行驶轨迹数据。&lt;/li&gt;
&lt;li&gt;传统证券行业实时交易数据。&lt;/li&gt;
&lt;li&gt;实时运维监控数据等。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;时间序列数据特点：&lt;/p&gt;



&lt;h3&gt;什么是targets(目标)&lt;/h3&gt;

&lt;p&gt;Prometheus 是一个监控平台，它通过抓取监控目标(targets)上的指标 HTTP 端点来从这些目标收集指标。&lt;/p&gt;

&lt;p&gt;安装完Prometheus Server端之后，第一个targets就是它本身。&lt;/p&gt;

&lt;p&gt;具体可以参考&lt;a href=&quot;https://prometheus.io/docs/introduction/first_steps/&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;什么是metrics(指标)&lt;/h3&gt;

&lt;p&gt;Prometheus存在多种不同的监控指标(Metrics)，在不同的场景下应该要选择不同的Metrics。&lt;/p&gt;

&lt;p&gt;Prometheus的merics类型有四种，分别为Counter、Gauge、Summary、Histogram。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Counter：只增不减的计数器&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Gauge：可增可减的仪表盘&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Histogram：分析数据分布情况&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;Summary：使用较少&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;简单了解即可，暂不需要深入理解。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;通过浏览器访问&lt;code&gt;http://被监控端IP:9100(被监控端口)/metrics&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;就可以查到node_exporter在被监控端收集的监控信息&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;什么是PromQL(函数式查询语言)&lt;/h3&gt;

&lt;p&gt;Prometheus内置了一个强大的数据查询语言PromQL。 通过PromQL可以实现对监控数据的查询、聚合。&lt;/p&gt;

&lt;p&gt;同时PromQL也被应用于数据可视化(如Grafana)以及告警当中。&lt;/p&gt;

&lt;p&gt;通过PromQL可以轻松回答以下问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在过去一段时间中95%应用延迟时间的分布范围？&lt;/li&gt;
&lt;li&gt;预测在4小时后，磁盘空间占用大致会是什么情况？&lt;/li&gt;
&lt;li&gt;CPU占用率前5位的服务有哪些？(过滤)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;具体查询细节可以参考官方。&lt;/p&gt;

&lt;h3&gt;如何监控远程Linux主机&lt;/h3&gt;

&lt;p&gt;安装Prometheus组件其实很简单，下载包--解压--后台启动运行即可，不做具体演示。&lt;/p&gt;

&lt;p&gt;在远程linux主机(被监控端)上安装node_exporter组件，可看&lt;a href=&quot;https://prometheus.io/download/&quot;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/canhui/picture/raw/master/2021/images/image-20211203114053559.png&quot; alt=&quot;image-20211203114053559&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下载解压后，里面就一个启动命令&lt;code&gt;node_exporter&lt;/code&gt;，直接启动即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nohup /usr/local/node_exporter/node_exporter &amp;gt;/dev/null 2&amp;gt;&amp;amp;1 &amp;amp;
lsof -i:9100
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;nohup：如果直接启动node_exporter的话，终端关闭进程也会随之关闭，这个命令帮你解决问题。&lt;/p&gt;

&lt;h2&gt;Prometheus HTTP API&lt;/h2&gt;

&lt;p&gt;Prometheus 所有稳定的 HTTP API 都在 &lt;code&gt;/api/v1&lt;/code&gt; 路径下。当我们有数据查询需求时，可以通过查询 API 请求监控数据，提交数据可以使用 &lt;a href=&quot;https://prometheus.io/docs/practices/remote_write/&quot;&gt;remote write&lt;/a&gt; 协议或者 &lt;a href=&quot;https://prometheus.io/docs/practices/pushing/&quot;&gt;Pushgateway&lt;/a&gt; 的方式。&lt;/p&gt;

&lt;h3&gt;支持的 API&lt;/h3&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;API&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;说明&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;需要认证&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;方法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;/api/v1/query&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;查询接口&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;是&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;GET/POST&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;/api/v1/query_range&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;范围查询&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;是&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;GET/POST&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;/api/v1/series&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;series 查询&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;是&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;GET/POST&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;/api/v1/labels&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;labels 查询&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;是&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;GET/POST&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;/api/v1/label/&lt;label_name&gt;/values&lt;/label_name&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;label value 查询&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;是&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;GET&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;/api/v1/prom/write&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;remote write 数据提交&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;是&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;remote write&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;Pushgateway&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;pushgateway 数据提交&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;是&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;SDK&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;h3&gt;认证方法&lt;/h3&gt;

&lt;p&gt;默认开启认证，因此所有的接口都需要认证，且所有的认证方式都支持 Bearer Token和 Basic Auth。&lt;/p&gt;

&lt;p&gt;调用接口的时候，我们需要携带Basic Auth请求头的认证，否则会出现401。&lt;/p&gt;

&lt;h4&gt;Bearer Token&lt;/h4&gt;

&lt;p&gt;Bearer Token 随着实例产生而生成，可以通过控制台进行查询。了解 Bearer Token 更多信息，请参见 &lt;a href=&quot;https://swagger.io/docs/specification/authentication/bearer-authentication/&quot;&gt;Bearer Authentication&lt;/a&gt;。&lt;/p&gt;

&lt;h4&gt;Basic Auth&lt;/h4&gt;

&lt;p&gt;Basic Auth 兼容原生 Prometheus Query 的认证方式，用户名为用户的 APPID，密码为 bearer token（实例产生时生成），可以通过控制台进行查询。了解 Basic Auth 更多信息，请参见 &lt;a href=&quot;https://swagger.io/docs/specification/authentication/basic-authentication/&quot;&gt;Basic Authentication&lt;/a&gt;。&lt;/p&gt;

&lt;h3&gt;数据返回格式&lt;/h3&gt;

&lt;p&gt;所有 API 的响应数据格式都为 JSON。每一次成功的请求会返回 &lt;code&gt;2xx&lt;/code&gt; 状态码。&lt;/p&gt;

&lt;p&gt;无效的请求会返回一个包含错误对象的 JSON 格式数据，同时也将包含一个如下表格的状态码：&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;状态码&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;401&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;认证失败&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;400&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;当参数缺失或错误时返回无效的请求状态码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;422&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;当一个无效的表达式无法被指定时 (RFC4918)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;503&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;当查询不可用或者被取消时返回服务不可用状态码&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;无效请求响应返回模板如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
&quot;status&quot;: &quot;success&quot; | &quot;error&quot;,
&quot;data&quot;: &amp;lt;data&amp;gt;,
 // 当 status 状态为 error 时，下面的数据将被返回
&quot;errorType&quot;: &quot;&amp;lt;string&amp;gt;&quot;,
&quot;error&quot;: &quot;&amp;lt;string&amp;gt;&quot;,
 // 当执行请求时有警告信息时，该字段将被填充返回
&quot;warnings&quot;: [&quot;&amp;lt;string&amp;gt;&quot;]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;数据写入&lt;/h3&gt;

&lt;p&gt;运维过程不需要对数据进行写入，所以暂时不深入理解。&lt;/p&gt;

&lt;p&gt;有兴趣的同学可以看看&lt;a href=&quot;https://prometheus.io/docs/instrumenting/pushing/#pushing-metrics&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;监控数据查询&lt;/h3&gt;

&lt;p&gt;当我们有数据查询需求时，可以通过查询 API 请求监控数据。&lt;/p&gt;



&lt;pre&gt;&lt;code&gt;GET /api/v1/query
POST /api/v1/query
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查询参数：&lt;/p&gt;

&lt;p&gt;​ query= &lt;string&gt;: Prometheus：查询表达式。&lt;/string&gt;&lt;/p&gt;

&lt;p&gt;​ time= &lt;rfc3339 unix_timestamp=&quot;&quot;&gt;： 时间戳， 可选。&lt;/rfc3339&gt;&lt;/p&gt;

&lt;p&gt;​ timeout= &lt;duration&gt;：检测超时时间， 可选。 默认由 &lt;code&gt;-query.timeout&lt;/code&gt; 参数指定。&lt;/duration&gt;&lt;/p&gt;



&lt;p&gt;查询当前状态为up的监控主机：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -u &quot;appid:token&quot; &#x27;http://IP:PORT/api/v1/query?query=up&#x27;
&lt;/code&gt;&lt;/pre&gt;



&lt;pre&gt;&lt;code&gt;GET /api/v1/query_range
POST /api/v1/query_range
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据时间范围查询需要的数据，这也是我们用得最多的场景，&lt;/p&gt;

&lt;p&gt;这时我们需要用到 &lt;code&gt;/api/v1/query_range&lt;/code&gt; 接口，示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl &#x27;http://localhost:9090/api/v1/query_range?query=up&amp;amp;start=2015-07-01T20:10:30.781Z&amp;amp;end=2015-07-01T20:11:00.781Z&amp;amp;step=15s&#x27;
{
   &quot;status&quot; : &quot;success&quot;,
   &quot;data&quot; : {
      &quot;resultType&quot; : &quot;matrix&quot;,
      &quot;result&quot; : [
         {
            &quot;metric&quot; : {
               &quot;__name__&quot; : &quot;up&quot;,
               &quot;job&quot; : &quot;prometheus&quot;,
               &quot;instance&quot; : &quot;localhost:9090&quot;
            },
            &quot;values&quot; : [
               [ 1435781430.781, &quot;1&quot; ],
               [ 1435781445.781, &quot;1&quot; ],
               [ 1435781460.781, &quot;1&quot; ]
            ]
         },
         {
            &quot;metric&quot; : {
               &quot;__name__&quot; : &quot;up&quot;,
               &quot;job&quot; : &quot;node&quot;,
               &quot;instance&quot; : &quot;localhost:9091&quot;
            },
            &quot;values&quot; : [
               [ 1435781430.781, &quot;0&quot; ],
               [ 1435781445.781, &quot;0&quot; ],
               [ 1435781460.781, &quot;1&quot; ]
            ]
         }
      ]
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;什么是Grafana&lt;/h2&gt;

&lt;p&gt;Grafana是一个开源的度量分析和可视化工具，可以通过将采集的数据分析、查询，&lt;/p&gt;

&lt;p&gt;然后进行可视化的展示，并能实现报警。&lt;/p&gt;

&lt;p&gt;网址: &lt;a href=&quot;https://grafana.com/&quot;&gt;https://grafana.com/&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;使用Grafana连接Prometheus&lt;/h3&gt;

&lt;p&gt;连接不再做具体演示，操作思路如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在Grafana服务器上安装，下载地址：&lt;a href=&quot;https://grafana.com/grafana/download&quot;&gt;https://grafana.com/grafana/download&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;浏览器&lt;code&gt;http://grafana服务器IP:3000&lt;/code&gt;登录，默认账号密码都是admin，就可以登陆了。&lt;/li&gt;
&lt;li&gt;把Prometheus服务器收集的数据做为一个数据源添加到Grafana，得到Prometheus数据。&lt;/li&gt;
&lt;li&gt;然后为添加好的数据源做图形显示，最后在dashboard就可以查看到。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;操作流程不难，就不讲解重点，后面正式开始上查询脚本。&lt;/p&gt;

&lt;h2&gt;工作使用场景&lt;/h2&gt;

&lt;p&gt;工作中需要通过CPU、内存生成资源利用率报表，可以通过Prometheus的API写一个Python脚本。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/canhui/picture/raw/master/2021/images/image-20211229154759297.png&quot; alt=&quot;image-20211229154759297&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可通过API获取数据，然后再进行数据排序、过滤、运算、聚合，最后写入Mysql数据库。&lt;/p&gt;

&lt;h3&gt;CPU峰值计算&lt;/h3&gt;



&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;def get_cpu_peak(self):
    &quot;&quot;&quot;
        CPU取最近一周所有数值，再排序取最高的值,TOP1
        :return: {&#x27;IP&#x27; : value}
        &quot;&quot;&quot;
    # 拼接URL
    pre_url = self.server_ip + &#x27;/api/v1/query_range?query=&#x27;
    expr = &#x27;100 - (avg by(instance) (irate(node_cpu_seconds_total{mode=&quot;idle&quot;}[5m])) * 100) &#x27; \
    &#x27;&amp;amp;start=%s&amp;amp;end=%s&amp;amp;step=300&#x27; % (self.time_list[0], self.time_list[-1] - 1)
    url = pre_url + expr
    # print(url)

    result = {}
    # 请求URL后将Json数据转为字典对象
    res = json.loads(requests.post(url=url, headers=self.headers).content.decode(&#x27;utf8&#x27;, &#x27;ignore&#x27;))
    # print(data)

    # 循环取出字典里每个IP的values，排序取最高值，最后存入result字典
    for da in res.get(&#x27;data&#x27;).get(&#x27;result&#x27;):
        values = da.get(&#x27;values&#x27;)
        cpu_values = [float(v[1]) for v in values]  # 取出数值并存入列表
        # 取出IP并消除端口号
        ip = da.get(&#x27;metric&#x27;).get(&#x27;instance&#x27;)
        ip = ip[:ip.index(&#x27;:&#x27;)] if &#x27;:&#x27; in ip else ip
        # if ip == &#x27;10.124.58.181&#x27;:
        #     print (ip)
        # cpu_peak = round(sorted(cpu_values, reverse=True)[0], 2)
        cpu_peak = sorted(cpu_values, reverse=True)[0]
        # 取出IP和最高值之后，写入字典
        result[ip] = cpu_peak

        # print(result)
        return result
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;CPU均值计算&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;取最近一周CPU每一天的TOP20除以20得到当时忙时平均值，
再将7天平均值的和除以n，得到时间范围内忙时平均值。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;def get_cpu_average(self):
    &quot;&quot;&quot;
        CPU忙时平均值：取最近一周CPU数据，每一天的TOP20除以20得到忙时平均值；
        再将一周得到的忙时平均值相加，再除以7，得到时间范围内一周的忙时平均值。
        :return:
        &quot;&quot;&quot;
    cpu_average = {}
    for t in range(len(self.time_list)):
        if t + 1 &amp;lt; len(self.time_list):
            start_time = self.time_list[t]
            end_time = self.time_list[t + 1]
            # print(start_time, end_time)
            # 拼接URL
            pre_url = server_ip + &#x27;/api/v1/query_range?query=&#x27;
            expr = &#x27;100 - (avg by(instance) (irate(node_cpu_seconds_total{mode=&quot;idle&quot;}[5m])) * 100) &#x27; \
            &#x27;&amp;amp;start=%s&amp;amp;end=%s&amp;amp;step=300&#x27; % (start_time, end_time - 1)
            url = pre_url + expr
            # print(url)
            # 请求接口数据
            data = json.loads(requests.post(url=url, headers=self.headers).content.decode(&#x27;utf8&#x27;, &#x27;ignore&#x27;))

            for da in data.get(&#x27;data&#x27;).get(&#x27;result&#x27;):   # 循环拿到result数据
                values = da.get(&#x27;values&#x27;)
                cpu_load = [float(v[1]) for v in values]    # 循环拿到values里面的所有值
                ip = da.get(&#x27;metric&#x27;).get(&#x27;instance&#x27;)       # 拿到instance里面的ip
                ip = ip[:ip.index(&#x27;:&#x27;)] if &#x27;:&#x27; in ip else ip    # 去除个别后面带的端口号
                # avg_cup_load = sum(sorted(cpu_load, reverse=True)[:20]) / 20
                # 取top20% 再除以20%，得出top20%的平均值
                # avg_cup_load = round(sum(sorted(cpu_load, reverse=True)[:round(len(cpu_load) * 0.2)]) / round(len(cpu_load) * 0.2), 2)
                # 倒序后取前面20%除以个数，得到前20%的平均值
                avg_cup_load = sum(sorted(cpu_load, reverse=True)[:round(len(cpu_load) * 0.2)]) / round(len(cpu_load) * 0.2)
                # print(avg_cup_load)
                # 将计算后的数据以ip为key写入字典
                if cpu_average.get(ip):
                    cpu_average[ip].append(avg_cup_load)
                    else:
                        cpu_average[ip] = [avg_cup_load]

                        # 每日top20的平均值累加，共7天的再除以7
                        for k, v in cpu_average.items():
                            # cpu_average[k] = round(sum(v) / 7, 2)
                            cpu_average[k] = sum(v)

                            # print(cpu_average)
                            return cpu_average
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;内存峰值计算&lt;/h3&gt;



&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;def get_mem_peak(self):
    &quot;&quot;&quot;
        内存单台峰值：取7天内存最高峰值TOP1
        :return: 7天内存使用率最高峰值
        &quot;&quot;&quot;
    pre_url = self.server_ip + &#x27;/api/v1/query_range?query=&#x27;
    # expr = &#x27;(node_memory_MemTotal_bytes - (node_memory_MemFree_bytes+node_memory_Buffers_bytes+node_memory_Cached_bytes )) / node_memory_MemTotal_bytes * 100&amp;amp;start=%s&amp;amp;end=%s&amp;amp;step=300&#x27; % (start_time, end_time)
    # 字符太长会导致报错，所以这里进行拆分字段计算
    expr_MenTotal = &#x27;node_memory_MemTotal_bytes&amp;amp;start=%s&amp;amp;end=%s&amp;amp;step=300&#x27; % (self.time_list[0], self.time_list[-1] - 1)
    expr_MemFree = &#x27;node_memory_MemFree_bytes&amp;amp;start=%s&amp;amp;end=%s&amp;amp;step=300&#x27; % (self.time_list[0], self.time_list[-1] - 1)
    expr_Buffers = &#x27;node_memory_Buffers_bytes&amp;amp;start=%s&amp;amp;end=%s&amp;amp;step=300&#x27; % (self.time_list[0], self.time_list[-1] - 1)
    expr_Cached = &#x27;node_memory_Cached_bytes&amp;amp;start=%s&amp;amp;end=%s&amp;amp;step=300&#x27; % (self.time_list[0], self.time_list[-1] - 1)

    result = {}
    # 循环分别取出总内存、可用内存、Buffer块、缓存块四个字段
    for ur in expr_MenTotal, expr_MemFree, expr_Buffers, expr_Cached:
        url = pre_url + ur
        data = json.loads(requests.post(url=url, headers=self.headers).content.decode(&#x27;utf8&#x27;, &#x27;ignore&#x27;))
        ip_dict = {}
        # 循环单个字段所有值
        for da in data.get(&#x27;data&#x27;).get(&#x27;result&#x27;):
            ip = da.get(&#x27;metric&#x27;).get(&#x27;instance&#x27;)
            ip = ip[:ip.index(&#x27;:&#x27;)] if &#x27;:&#x27; in ip else ip
            # if ip != &#x27;10.124.53.12&#x27;:
            #     continue
            if ip_dict.get(ip):     # 过滤重复的ip，重复ip会导致计算多次
                # print(&quot;重复ip：%s&quot; % (ip))
                continue
                values = da.get(&#x27;values&#x27;)
                # 将列表里的值转为字典方便计算
                values_dict = {}
                for v in values:
                    values_dict[str(v[0])] = v[1]
                    # 标记ip存在
                    ip_dict[ip] = True
                    # 建立列表追加字典
                    if result.get(ip):
                        result[ip].append(values_dict)
                        else:
                            result[ip] = [values_dict]

                            # print(result)
                            # 对取出的四个值进行计算，得出峰值
                            for ip, values in result.items():
                                values_list = []
                                for k, v in values[0].items():
                                    try:
                                        values_MenTotal = float(v)
                                        values_MemFree = float(values[1].get(k, 0))
                                        values_Buffers = float(values[2].get(k, 0)) if values[2] else 0
                                        values_Cached = float(values[3].get(k, 0)) if values[3] else 0
                                        # 如果是0，不参与计算
                                        if values_MemFree==0.0 or values_Buffers==0.0 or values_Cached==0.0:
                                            continue
                                            # values_list.append(round((values_MenTotal - (values_MemFree + values_Buffers + values_Cached)) / values_MenTotal * 100, 2))
                                            # 合并后计算，得出列表
                                            values_list.append((values_MenTotal - (values_MemFree + values_Buffers + values_Cached)) / values_MenTotal * 100)
                                            # 对得出结果进行排序
                                            result[ip] = sorted(values_list, reverse=True)[0]
                                            except Exception as e:
                                                # print(values[0])
                                                logging.exception(e)

                                                # print(result)
                                                return result
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;内存均值计算&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;先取出7天的日期，根据多条链接循环取出每天数据，排序value取top20除以20，最终7天数据再除以7&lt;/li&gt;
&lt;/ul&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;def get_mem_average(self):
    &quot;&quot;&quot;
        内存忙时平均值：先取出7天的日期，根据多条链接循环取出每天数据，排序value取top20除以20，最终7天数据再除以7
        :return:
        &quot;&quot;&quot;
    avg_mem_util = {}
    for t in range(len(self.time_list)):
        if t + 1 &amp;lt; len(self.time_list):
            start_time = self.time_list[t]
            end_time = self.time_list[t + 1]
            # 根据多条链接循环取出每天数据
            pre_url = self.server_ip + &#x27;/api/v1/query_range?query=&#x27;
            # expr = &#x27;(node_memory_MemTotal_bytes - (node_memory_MemFree_bytes+node_memory_Buffers_bytes+node_memory_Cached_bytes )) / node_memory_MemTotal_bytes * 100&amp;amp;start=%s&amp;amp;end=%s&amp;amp;step=300&#x27; % (start_time, end_time)
            expr_MenTotal = &#x27;node_memory_MemTotal_bytes&amp;amp;start=%s&amp;amp;end=%s&amp;amp;step=600&#x27; % (start_time, end_time - 1)
            expr_MemFree = &#x27;node_memory_MemFree_bytes&amp;amp;start=%s&amp;amp;end=%s&amp;amp;step=600&#x27; % (start_time, end_time - 1)
            expr_Buffers = &#x27;node_memory_Buffers_bytes&amp;amp;start=%s&amp;amp;end=%s&amp;amp;step=600&#x27; % (start_time, end_time - 1)
            expr_Cached = &#x27;node_memory_Cached_bytes&amp;amp;start=%s&amp;amp;end=%s&amp;amp;step=600&#x27; % (start_time, end_time - 1)

            result = {}
            # 循环取出四个字段
            for ur in expr_MenTotal, expr_MemFree, expr_Buffers, expr_Cached:
                url = pre_url + ur
                data = json.loads(requests.post(url=url, headers=self.headers).content.decode(&#x27;utf8&#x27;, &#x27;ignore&#x27;))
                ip_dict = {}
                # 循环单个字段所有值
                for da in data.get(&#x27;data&#x27;).get(&#x27;result&#x27;):
                    ip = da.get(&#x27;metric&#x27;).get(&#x27;instance&#x27;)
                    ip = ip[:ip.index(&#x27;:&#x27;)] if &#x27;:&#x27; in ip else ip
                    if ip_dict.get(ip):
                        # print(&quot;重复ip：%s&quot; % (ip))
                        continue
                        values = da.get(&#x27;values&#x27;)
                        # 将列表里的值转为字典方便计算
                        values_dict = {}
                        for v in values:
                            values_dict[str(v[0])] = v[1]
                            # 标记ip存在
                            ip_dict[ip] = True
                            # 建立列表追加字典
                            if result.get(ip):
                                result[ip].append(values_dict)
                                else:
                                    result[ip] = [values_dict]

                                    # print(result)
                                    for ip, values in result.items():
                                        values_list = []

                                        for k, v in values[0].items():
                                            try:
                                                values_MenTotal = float(v)
                                                values_MemFree = float(values[1].get(k, 0)) if values[1] else 0
                                                values_Buffers = float(values[2].get(k, 0)) if values[2] else 0
                                                values_Cached = float(values[3].get(k, 0)) if values[3] else 0
                                                if values_MemFree == 0.0 or values_Buffers == 0.0 or values_Cached == 0.0:
                                                    continue
                                                    value_calc = (values_MenTotal - (values_MemFree + values_Buffers + values_Cached)) / values_MenTotal * 100
                                                    if value_calc != float(0):
                                                        values_list.append(value_calc)
                                                        except Exception as e:
                                                            print(values[0])
                                                            # logging.exception(e)
                                                            continue
                                                            # 排序value取top20除以20
                                                            # avg_mem = round(sum(sorted(values_list, reverse=True)[:round(len(values_list) * 0.2)]) / round(len(values_list) * 0.2), 2)
                                                            try:
                                                                avg_mem = sum(sorted(values_list, reverse=True)[:round(len(values_list) * 0.2)]) / round(len(values_list) * 0.2)
                                                                except Exception as e:
                                                                    avg_mem = 0
                                                                    logging.exception(e)

                                                                    if avg_mem_util.get(ip):
                                                                        avg_mem_util[ip].append(avg_mem)
                                                                        else:
                                                                            avg_mem_util[ip] = [avg_mem]

                                                                            # 最终7天数据再除以7
                                                                            for k, v in avg_mem_util.items():
                                                                                # avg_mem_util[k] = round(sum(v) / 7, 2)
                                                                                avg_mem_util[k] = sum(v)

                                                                                return avg_mem_util
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;导出excel&lt;/h3&gt;



&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;def export_excel(self, export):
    &quot;&quot;&quot;
        将采集到的数据导出excel
        :param export: 数据集合
        :return:
        &quot;&quot;&quot;
    try:
        # 将字典列表转换为DataFrame
        pf = pd.DataFrame(list(export))
        # 指定字段顺序
        order = [&#x27;ip&#x27;, &#x27;cpu_peak&#x27;, &#x27;cpu_average&#x27;, &#x27;mem_peak&#x27;, &#x27;mem_average&#x27;, &#x27;collector&#x27;]
        pf = pf[order]
        # 将列名替换为中文
        columns_map = {
            &#x27;ip&#x27;: &#x27;ip&#x27;,
            &#x27;cpu_peak&#x27;: &#x27;CPU峰值利用率&#x27;,
            &#x27;cpu_average&#x27;: &#x27;CPU忙时平均峰值利用率&#x27;,
            &#x27;mem_peak&#x27;: &#x27;内存峰值利用率&#x27;,
            &#x27;mem_average&#x27;: &#x27;内存忙时平均峰值利用率&#x27;,
            &#x27;collector&#x27;: &#x27;来源地址&#x27;
        }
        pf.rename(columns=columns_map, inplace=True)
        # 指定生成的Excel表格名称
        writer_name = self.Host + &#x27;.xlsx&#x27;
        writer_name.replace(&#x27;:18600&#x27;, &#x27;&#x27;)
        # print(writer_name)
        file_path = pd.ExcelWriter(writer_name.replace(&#x27;:18600&#x27;, &#x27;&#x27;))
        # 替换空单元格
        pf.fillna(&#x27; &#x27;, inplace=True)
        # 输出
        pf.to_excel(file_path, encoding=&#x27;utf-8&#x27;, index=False)
        # 保存表格
        file_path.save()
        except Exception as e:
            print(e)
            logging.exception(e)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为机房需要保留数据方便展示，后面改造成采集直接入库mysql。&lt;/p&gt;

&lt;p&gt;---- 钢铁知识库 &lt;a href=&quot;mailto:648403020@qq.com&quot;&gt;648403020@qq.com&lt;/a&gt; 2021.12.29&lt;/p&gt;

&lt;h2&gt;写在最后&lt;/h2&gt;

&lt;p&gt;以上简单介绍了Prometheus架构、基础概念、API使用，以及Python调用Prometheus的API部分示例，完整代码也已经上传，需要自取或联系即可。&lt;/p&gt;

&lt;p&gt;下载链接：
&lt;a href=&quot;https://download.csdn.net/download/u011463397/72150839&quot;&gt;https://download.csdn.net/download/u011463397/72150839&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;参考链接：&lt;/h2&gt;

&lt;p&gt;Prometheus操作指南：&lt;a href=&quot;https://github.com/yunlzheng/prometheus-book&quot;&gt;https://github.com/yunlzheng/prometheus-book&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;官方查询API：&lt;a href=&quot;https://prometheus.io/docs/prometheus/latest/querying/api/&quot;&gt;https://prometheus.io/docs/prometheus/latest/querying/api/&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>dec87875647dcc835d2013c9b724a57c</guid>
<title>如何把 MySQL 备份验证性能提升 10 倍</title>
<link>https://toutiao.io/k/ev38ug2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post_content markdown&quot;&gt;&lt;p&gt;JuiceFS 非常适合用来做 MySQL 物理备份，具体使用参考我们的官方文档&lt;a href=&quot;https://juicefs.com/docs/zh/backup_mysql_in_juicefs.html&quot;&gt;[1]&lt;/a&gt;。最近有个客户在测试时反馈，备份验证的数据准备（&lt;code&gt;xtrabackup --prepare&lt;/code&gt;）过程非常慢。我们借助 JuiceFS 提供的性能分析工具做了分析，快速发现性能瓶颈，通过不断调整 XtraBackup 的参数和 JuiceFS 的挂载参数，在一个小时内将时间缩短到原先的 1/10。本文将我们性能分析和优化的过程记录分享下来，给大家分析和优化 IO 性能提供参考。&lt;/p&gt;&lt;h3 id=&quot;0-数据准备&quot;&gt;0. 数据准备&lt;/h3&gt;&lt;p&gt;我们通过 SysBench&lt;a href=&quot;https://dev.mysql.com/downloads/benchmarks.html&quot;&gt;[2]&lt;/a&gt; 工具生成一个大小 11GiB 左右的单表数据库，数据库表的 partition 设置成 10。为了模拟一个正常的数据库读写场景，通过 SysBench 以秒 50 个请求的压力访问数据库，在该压力下数据库对数据盘造成的写数据在 8~10MiB/s 范围内。通过下列命令将数据库备份到 JuiceFS 上。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# xtrabackup --backup --target-dir=/jfs/base/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了保证每次数据准备操作的数据完全一样，使用 JuiceFS 的快照（snapshot）功能基于 &lt;code&gt;/jfs/base&lt;/code&gt; 目录生成快照 &lt;code&gt;/jfs/base_snapshot/&lt;/code&gt;。每一次操作前都会将前一次数据准备操作过的数据删掉重新生成一个新的快照。&lt;/p&gt;&lt;h3 id=&quot;1-使用默认参数&quot;&gt;1. 使用默认参数&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# ./juicefs mount volume-demoz /jfs

#  time xtrabackup --prepare --apply-log-only --target-dir=/jfs/base_snapshot
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行总耗时62秒。&lt;/p&gt;&lt;p&gt;JuiceFS支持导出操作日志 oplog，并能对 oplog 进行可视化展示。在执行 &lt;code&gt;xtrabackup --prepare&lt;/code&gt;操作之前我们新开一个终端连接到该服务器，在命令行输入&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# cat /jfs/.oplog &amp;gt; oplog.txt
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;开始搜集 oplog 日志，然后执行 &lt;code&gt;xtrabackup --prepare&lt;/code&gt; 操作，操作结束后将 oplog.txt 下载到本地，上传到 JuiceFS 提供的 oplog 分析页面：&lt;a href=&quot;https://juicefs.com/oplog/&quot;&gt;https://juicefs.com/oplog/&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;我们将 oplog &lt;a href=&quot;https://juicefs.com/tracing/61a53ce2f680e661f78035013e1651f1&quot;&gt;进行可视化展示&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;这里先大致介绍下这个图中各种元素含义。我们的一条 oplog 中包含了时间戳，线程 ID，文件系统操作函数（read, write, fsync, flush 等），操作持续的时间等。左侧数字表示线程 ID，横轴表示时间，不同类型操作用不同颜色标记。&lt;/p&gt;&lt;p&gt;我们把局部图像放大，不同颜色代表不同类型的操作就一目了然。&lt;/p&gt;&lt;p&gt;排除掉与本次操作无关的几个线程。在数据准备过程中有 4 个线程负责读，5 个线程负责写数据，读写在时间上都是重叠的。&lt;/p&gt;&lt;h3 id=&quot;2-增大-xtrabackup-的内存缓冲区&quot;&gt;2. 增大 XtraBackup 的内存缓冲区&lt;/h3&gt;&lt;p&gt;参考 XtraBackup 官方文档&lt;a href=&quot;https://www.percona.com/doc/percona-xtrabackup/2.4/backup_scenarios/full_backup.html&quot;&gt;[3]&lt;/a&gt;，数据准备是使用内嵌的 InnoDB 在备份数据集上执行故障修复（crash recovery）的过程。&lt;/p&gt;&lt;p&gt;使用 &lt;code&gt;--use-memory&lt;/code&gt;&lt;a href=&quot;https://www.percona.com/doc/percona-xtrabackup/2.4/xtrabackup_bin/xbk_option_reference.html&quot;&gt;[4]&lt;/a&gt; 选项增大内嵌 InnoDB 的内存缓冲区大小，默认 100MB，我们增大到 4GB。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# time xtrabackup --prepare --use-memory=4G --apply-log-only --target-dir=/jfs/base_snapshot
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行时间降到了33秒。&lt;/p&gt;&lt;p&gt;将 oplog &lt;a href=&quot;https://juicefs.com/tracing/6db615529e75ae267bba782dc828cc71&quot;&gt;可视化展示&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;可以看到读写不重叠了 ，将数据读到内存处理完成后写入文件系统。&lt;/p&gt;&lt;h3 id=&quot;3-增大-xtrabackup-读线程数&quot;&gt;3. 增大 XtraBackup 读线程数&lt;/h3&gt;&lt;p&gt;通过增大缓冲区将时间缩短了一半，整个读的过程耗时依然比较明显。我们看到每个读线程基本都是跑满的状态，我们尝试增加更多的读线程。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# time xtrabackup --prepare --use-memory=4G --innodb-file-io-threads=16 --innodb-read-io-threads=16 --apply-log-only --target-dir=/jfs/base_snapshot
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行时间降到了23秒，将 oplog &lt;a href=&quot;https://juicefs.com/tracing/18b7eb7c826a18c510fbcc9d0f118dd0&quot;&gt;可视化展示&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;读线程已经增加到了 16 个（默认 4 个），读操作降到 7 秒左右。&lt;/p&gt;&lt;h3 id=&quot;4-juicefs-启用异步写&quot;&gt;4. JuiceFS 启用异步写&lt;/h3&gt;&lt;p&gt;上一步我们极大的优化了读操作时间，现在写过程消耗的时间就比较明显了。通过分析 oplog，发现写操作中&lt;strong&gt;fsync&lt;/strong&gt;是不能并行的，因此增大写线程数并不能提升写的效率，在实际操作过程中我们也通过增大写线程数验证了这一点，这里就不赘述了。分析 oplog 对同一个文件（相同文件描述符）的写操作的参数（偏移，写数据大小），发现有大量的随机写操作，我们可以在挂载 JuiceFS 时启用 &lt;code&gt;--writeback&lt;/code&gt; 选项，写数据时先写本地盘，再异步写到对象存储。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# ./juicefs mount --writeback volume-demoz /jfs
# time xtrabackup --prepare --use-memory=4G --innodb-file-io-threads=16 --innodb-read-io-threads=16 --apply-log-only --target-dir=/jfs/base_snapshot
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;时间降到了 11.8 秒，将 oplog &lt;a href=&quot;https://juicefs.com/tracing/517024b32b7f3620dd5cc0989de83133&quot;&gt;可视化展示&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;写过程已经降到 1.5 秒左右。&lt;/p&gt;&lt;p&gt;我们看到读线程读操作依然比较密集，我们尝试持续增加读线程数，InnoDB 读线程数最大为 64，我们直接调成 64。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# time xtrabackup --prepare --use-memory=4G --innodb-file-io-threads=64 --innodb-read-io-threads=64 --apply-log-only --target-dir=/jfs/base_snapshot
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行时间 11.2 秒，相比之前基本没变化，将 oplog &lt;a href=&quot;https://juicefs.com/tracing/7c74b6ea895333cfa15dc75f9fdd0473&quot;&gt;可视化展示&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;我们看到，读线程读操作已经比较稀疏了，应该是线程读的数据之间有依赖关系，导致不能完全并行化，已经不能通过提升线程数压缩读过程的时间了。&lt;/p&gt;&lt;h3 id=&quot;5-增大-juicefs-的磁盘缓存&quot;&gt;5. 增大 JuiceFS 的磁盘缓存&lt;/h3&gt;&lt;p&gt;在上一步中，我们通过提升读线程数来提升读过程的效率已经到顶了，只能通过降低读数据的延迟来减少读过程时间。&lt;/p&gt;&lt;p&gt;JuiceFS 在读操作处理上提供了预读和缓存加速能力，我们接下来尝试通过增大 JuiceFS 的本地缓存来降低读操作的延迟。&lt;/p&gt;&lt;p&gt;将 JuiceFS 的本地缓存由高效云盘换成 SSD 云盘，并将缓存大小由 1G 改成 10G。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# ./juicefs mount --writeback volume-demoz --cache-size=10000 --cache-dir=/data/jfsCache /jfs

# time xtrabackup --prepare --use-memory=4G --innodb-file-io-threads=64 --innodb-read-io-threads=64 --apply-log-only --target-dir=/jfs/base_snapshot
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行时间降到了 6.9 秒，将 oplog &lt;a href=&quot;https://juicefs.com/tracing/efcf8223a00dcca0e3619343676c2728&quot;&gt;可视化展示&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;通过提升缓存性能和增大缓存空间进一步减少了读操作耗时。&lt;/p&gt;&lt;p&gt;到此我们总结一下，我们通过分析 oplog，不断寻找可以优化的点，将整个数据准备过程一步步从 62 秒降到 6.9 秒，效果通过下图更直观的展示。&lt;/p&gt;&lt;h3 id=&quot;6-增大数据库数据量&quot;&gt;6. 增大数据库数据量&lt;/h3&gt;&lt;p&gt;以上的操作都是针对 11G 这样一个比较小的数据集不断调整参数进行优化得到一个很好的结果。作为对比，我们以同样的方式生成一个 115G 左右的 partition 为10的单表数据库。在 SysBench 持续每秒 50 个请求情况下，执行备份操作。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# time xtrabackup --prepare --use-memory=4G --innodb-file-io-threads=64 --innodb-read-io-threads=64 --apply-log-only --target-dir=/jfs/base_snapshot
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个过程耗时 74 秒，将 oplog &lt;a href=&quot;https://juicefs.com/tracing/18ce933faa4e99a13e9b0695a9ae66bc&quot;&gt;可视化展示&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;我们看到，读和写还是分开的。&lt;/p&gt;&lt;p&gt;在数据量增大10倍左右，相应的准备时间也增大到10倍。这是因为备份（&lt;code&gt;xtrabackup --backup&lt;/code&gt;）过程所需的时间扩大到 10 倍，在 SysBench 对数据库压力不变的情况下，备份过程中产生的 xtrabackup_logfile 也是原先的 10 倍。数据准备是要把 xtrabackup_logfile 中的所有数据更新合并到数据文件中，可见即使数据规模增大了 10 倍，但更新单条日志的时间基本不变。从上图也可以验证这一点，数据规模增大后，准备过程仍然是分成了读数据和写数据这两个明显的过程，说明设定的 4GB 的缓冲区大小仍然是够用的，整个过程仍然可以在内存中完成然后更新到文件系统。&lt;/p&gt;&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;&lt;p&gt;我们使用 SysBench 这个相对简单的工具构造初始数据，持续给数据库一定数据更新的压力模拟数据备份时数据库运行场景。使用 JuiceFS 的 oplog 来观察 XtraBackup 在数据准备过程中访问备份数据的读写特点，调整 XtraBackup 和 JuiceFS 的参数来不断优化数据准备过程的效率。&lt;/p&gt;&lt;p&gt;在实际生产场景中，情况比我们 SysBench 模拟要复杂得多，我们上面的线性关系不一定严格成立，但是我们通过分析 oplog 快速发现可以优化的点，进而不断调整 XtraBackup 和 JuiceFS 的缓存和并发的思路是通用的。&lt;/p&gt;&lt;p&gt;整个调参过程耗时 1 小时左右，oplog 分析工具在这个过程中发挥了很大的作用，帮助我们快速定位系统性能瓶颈，从而针对性地调整参数做优化，也希望这个 oplog 分析功能也能帮助大家快速定位和分析遇到的性能问题。&lt;/p&gt;&lt;h3 id=&quot;参考文档&quot;&gt;参考文档&lt;/h3&gt;&lt;p&gt;[1]: 基于 JuiceFS 的 MySQL 备份、验证和恢复方案： &lt;a href=&quot;https://juicefs.com/docs/zh/backup_mysql_in_juicefs.html&quot;&gt;https://juicefs.com/docs/zh/backup_mysql_in_juicefs.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;[2]: SysBench: &lt;a href=&quot;https://dev.mysql.com/downloads/benchmarks.html&quot;&gt;https://dev.mysql.com/downloads/benchmarks.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;[3]: XtraBackup全量备份： &lt;a href=&quot;https://www.percona.com/doc/percona-xtrabackup/2.4/backup_scenarios/full_backup.html&quot;&gt;https://www.percona.com/doc/percona-xtrabackup/2.4/backup_scenarios/full_backup.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;[4]: XtraBackup命令行选项： &lt;a href=&quot;https://www.percona.com/doc/percona-xtrabackup/2.4/xtrabackup_bin/xbk_option_reference.html&quot;&gt;https://www.percona.com/doc/percona-xtrabackup/2.4/xtrabackup_bin/xbk_option_reference.html&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>28c405697daf02ddefcf457910c009dc</guid>
<title>画架构图的神器</title>
<link>https://toutiao.io/k/4773s9p</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;fieldset&gt;&lt;section data-brushtype=&quot;text&quot;&gt;架构师（JiaGouX）&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;我们都是架构师！&lt;br/&gt;架构未来，你来不来？&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/fieldset&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAwNjQwNzU2NQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/sXiaukvjR0RCNb3RYsCgx02T4J55ia2SnemY7uJHsDChxq6jAibbATlIKDgzLxz0zekXWjblzCDcL86AjbMNp02Tg/0?wx_fmt=png&quot; data-nickname=&quot;架构师&quot; data-alias=&quot;JiaGouX&quot; data-signature=&quot;架构师云集，三高（高可用、高性能、高稳定）架构、大数据、机器学习、Java架构、系统架构、大规模分布式架构、人工智能等的架构讨论交流，以及结合互联网技术的架构调整，大规模架构实战分享。欢迎有想法、乐于分享的架构师交流学习。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看过我以往文章的小伙伴可能会发现，我的大部分文章都有很多配图。我的文章风格是图文相结合，更便于大家理解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近有很多小伙伴发私信问我：文章中的图是用什么工具画的。他们觉得我画的图风格挺小清新的，能够让人眼前一亮。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先上几张图让大家看看效果：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7021996615905245&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEcQeQVeSPhd00alFgESSqkDNsO0rWriam0JoiccWGEP4ewJdibk25nZZiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1182&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.513677811550152&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBESNLJibcUXjyxw8wBM9S04knvpJRWzxGQzQcYATR48MicUtbTHKkGax4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1316&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4361525704809287&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBExhcMHxwz8Qq45Q2sJeBBTxLtWGRaaFHkRbHLicrPn8ZVKnObEiaKMxkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1206&quot;/&gt;说实话，问我的人太多了，我真的没法一个个回复。同时问我的人多，也恰恰说明了这个工具的优秀。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天特地写一篇介绍画图工具的文章，给有需要的朋友一个参考。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 用什么画的图？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于画流程图的工具，之前大家用得比较多的可能是：&lt;code&gt;visio&lt;/code&gt;和&lt;code&gt;process on&lt;/code&gt;了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;visio&lt;/code&gt;是微软的一款画图软件，需要在电脑上安装，正版软件是付费的，但网上也可以搜到很多破解版。它是我用过的最早的画流程图工具了，后面使用mac电脑办公之后，就没有用过它了，之前觉得它跨电脑办公有点不方便。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;process on&lt;/code&gt;是一款免费在线画图工具，功能非常强大。除了常规的各种流程图之外，对于思维导图支持也非常友好。但有个缺点是只能免费保存最近9张图，想保留更多的图，需要付费升级。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面的两款画图工具，说到底还是收费的，对于喜欢白嫖的我们来说，有点无法接受。那么，有没有一款免费、在线、功能强大的画流程图的工具呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：有，可以使用：&lt;code&gt;diagrams&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，我文章中的图都是用&lt;code&gt;diagrams&lt;/code&gt;画出来的，也可以叫它：&lt;code&gt;draw.io&lt;/code&gt;，它已经成为了我画图首选工具。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这款画图工具的官网地址是：https://app.diagrams.net/，它的前身是：https://draw.io/。这两个url都能访问。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时它也提供了离线版的画图软件，大家可以自己下载diagrams的安装软件，不过有个坏处是它是收费的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，我用的最多的还是在线版的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 如何进入画图界面？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面已经知道，我的文章都是用&lt;code&gt;diagrams&lt;/code&gt;画流程图的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如何进入diagrams的画图界面呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在浏览器上输入diagrams的官网地址，我平时喜欢输入：&lt;code&gt;https://draw.io/&lt;/code&gt;，因为它比较好记。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一次访问的时候有点慢，因为它要初始化一些东西。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2803819444444444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEkicr9pN4EjtlBrLhFveOKiawBA7NZN0to7h7d08apyjvJz7CuwSLibLCQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2304&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，会弹出一个窗口，让我们选择画的图，需要保存到哪里。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48214285714285715&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEz6LoWib1bdic6VXFiaXYyP0lJtZY9hwU0959MFVMRyOCp22aZLCFFSzzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2464&quot;/&gt;它主要支持四种：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;OneDrive：即云&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Device：即设备&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Github&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Gitlab&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我目前为了图方便，用的最多的是&lt;code&gt;Device&lt;/code&gt;，它可以把画的图保存到本地电脑，也可以从本地电脑导入已有的图。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实如果可以的话，把图保存到&lt;code&gt;Github&lt;/code&gt;，也是个不错的选择。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，会弹出一个窗口，让你选择是Create New Diagram（创建新流程图），还是选择Open Existing Diagram（打开已有的流程图）。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7270471464019851&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBESZhribz7pkaq82baW6iaYnb27QE16vR5CLLHvJqultLNhC70zGDxN31w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;806&quot;/&gt;我们第一次进来，当然是选择创建新流程图了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后，进入了画流程图的主界面：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5746388443017657&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBE6yxHRaA0VhHxKurYQ3t7Y1d6oATeaD2ibibZgL1lxxqt6a9swiaQnNMlQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2492&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3 画图界面的组成部分&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;diagrams的工作界面主要是由以下几个部分组成：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5211155378486055&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEdYwF3yvNND7Qxkm97LZ2W079xic5VzuVU73ozAZQia8T4rA4SicDyyM6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2510&quot;/&gt;此外，在这里顺便说一句，如果你想修改流程图名称的话，可以双击左上角的：&lt;code&gt;Untitled Diagram.drawio&lt;/code&gt;这几个字，会弹出如下窗口：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.38235294117647056&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEaSJ3tFGJ0OpyJYCibudZL736yskF1rl2ezw3eNcuicWrFUngdnxZwqiaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;816&quot;/&gt;在这个窗口中可以修改流程图的名称和文件类型，默认是&lt;code&gt;.drawio&lt;/code&gt;格式的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面用一张图总结一下，diagrams的工作界面主要组成部分：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7270788912579957&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEUZzzvjNiaicf6LFmHibuZTb2Iouia8dGLwbrSZXJGuuQtQq3ORFxADcKzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;938&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.1 菜单栏&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.11148648648648649&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEMiaKwpoRmxicKG3H09elk4dxGqAmOghCQOG3r3DHArJbrQ6tTrqBLC5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;592&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;File&lt;/code&gt;菜单：包含了一系列的文件操作，包括：新建、打开文件、打开最近的文件、保存文件、另存为文件、分享文件、重命名、拷贝文件、导入、导出、打印、关闭等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Edit&lt;/code&gt;菜单：包含了一系列工作区的操作，包括：回退、撤回、剪切、复制、粘贴、删除、查找、替换、编辑、编辑属性、选择、全选等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;View&lt;/code&gt;菜单：包含了一系列的视图操作，包括：恢复默认布局、大纲视图、图层、标签、网格、滚动条、全屏等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Arrange&lt;/code&gt;菜单：包含了一系列图形排列操作，包含：在前面、在后面、插入图形、对齐等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Extras&lt;/code&gt;菜单：包含了一系列额外的操作，包含：主题、展开、收缩、插件、编辑画图区、配置等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Help&lt;/code&gt;菜单：主要包含一系列全局的操作，包含：搜索、快捷键、关于等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.2 工具栏&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.02857142857142857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBE7528BHib30X3v53TI2IZL7fhPETiabuP803sm5WnFgXDxE5EVxCkVMibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2450&quot;/&gt;工具栏中包含了一些常用的功能，比如：图片尺寸、放大、缩小、退回、撤销、删除、在前、在后、背景色、字体颜色、连接、阴影、添加表格、添加图形、全屏、展开、收缩等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些功能真的太实用了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.3 左边图形区&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个区域可以选择我们画图时，需要的图形，默认有这7类图形。&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;1066&quot; data-backw=&quot;426&quot; data-ratio=&quot;2.5023474178403755&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEhpZOib4Nmfj6kgDMcFo3jNfy2nPsYfWSeIicP9PODU2K6RkRNCI7GqPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;426&quot;/&gt;如果不满足要求，可以点击 More Shapes 按钮，选择更多类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.739568345323741&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEhNNAoyh3nTtsThQde1HLlXw7ozIibVzSnr6socA0cGDt2wwlGBouY1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1390&quot;/&gt;上图中我另外加了&lt;code&gt;IOS&lt;/code&gt;类的图形。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我个人喜欢使用&lt;code&gt;General&lt;/code&gt;类的图形：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.7208121827411167&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBE0Wm1lb7mrxKaQhAicFu7tav8qmywMovZ8sphbWn6yVbibhSzEvNlmyJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;394&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;里面常用的图形都有，画一般的流程图是够用的。当然你也可以根据个人喜欢，选择更多的类型画图。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.4 画图区&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6675257731958762&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEmnCP8AoM9dnhbKI8oNrB8BKPnUZic1EoADIFt4OW0wokNgveAZVbzng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1552&quot;/&gt;画图区是最重要的地方了，你的流程图是在这片区域完成的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以在左边的图形区选择好图形之后，用鼠标拖到画图区。也可以直接在画图区复制已有的图形。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还可以加网格：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5284653465346535&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBE63d8GR4EVibKM6yvoMSeibVm4EwIbaEOJpKjELjjMbU4I2so8KL2GrHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1616&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;右键空白的地方，会出现一些操作选项：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9698492462311558&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBE4AXjicv7EWaicbJSBwn4XU0Np31XJ5TKVmfoXoGpNrRNMrgKoG2ibia12Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;796&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;右键某个具体图形，会出现一些图形相关的选项：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2914691943127963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBETmAzsHLaXdcIcQUU97GHAyVUfMp6o6EnpSAPrAXqibOa3VFxqD5ibbEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;844&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.5 右边样式区&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.9958333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEMGxGicRBdDxKxThGMVOXcbDJtqlvxP8OELrz9CgvB0oXGpcrFzMfKnw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;480&quot;/&gt;右边样式区可以说是diagrams的灵魂。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;选择的图形，在画图区默认是这样的：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4981949458483754&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEoE4aibg7hv82N12zGycZQcgIiaAZm9y8mMFwgiapFzcpMBPQIl5sk7LQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;一眼看过去，显得非常单调。但如果在右边样式区，我加了一些样式之后，图形马上变得不一样了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5981554677206851&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEukaBHqX4lRUIpQOdh51vV2fX0PRedu66fVb1icrKPPCHzicEJWL4Curw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1518&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于文本样式也有挺多功能可以设置的：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5431606905710491&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEPxjjibSXOgF7zGlLBmLXh5UAg5svf7lfz3LNqnal3ZLwwYHNUxHfw8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1506&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.6 底部&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.05672823218997362&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEseqOogg5tHGPRrD16A2NrRWUhro0jcO1gSqL5icvqDHwLicDHIoicqfsQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1516&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;底部主要展示的是每页的名称。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点击左侧三个点：&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;422&quot; data-backw=&quot;438&quot; data-ratio=&quot;0.9634703196347032&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEJF9XiaACQqqWGYkR6FEP8Xib4kBCdDLYXlD7FiaQH0LSJyTDic6xa9SNjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;438&quot;/&gt;可以切换、插入、删除和重命名页面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;点击右侧的加号：&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.09336099585062241&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEDDRebca26ZSVDGIjWiaErmofVNMPWPliacrjKxVpJFQHvKzSjxFYsprg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;964&quot;/&gt;&lt;span&gt;可以立刻新增页面。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们每次画图需要在某个页面上操作。&lt;/span&gt;&lt;span&gt;但如果你需要画的图很多，可以使用页进行归类，方面今后维护。&lt;/span&gt;&lt;span&gt;不太建议，一页上画的图太多，不然画图时会非常卡。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文主要介绍了diagrams画图工具，它是一款免费的在线画图工具，也叫做draw.io。它的功能非常强大，包括：菜单栏、工具栏、左边图形区、画图区、右边样式区、底部等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时还介绍了如何进入画图区。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然本文只是抛砖引玉，给大家介绍了diagrams的一小部分功能。它的强大之处，需要大家自己多动手摸索。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面用一张图给大家展示一下，我是如何使用diagrams画图的：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47346938775510206&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBETZ3yDdsUI1XpZEHlPX7IHhHaGg3iaCzcBvTHRNdIvmEEqy6U65FQmVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2450&quot;/&gt;好了，今天的内容先分享到这里，我们下期再见。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果大家觉得这个工具不错，或者看了我的分享有些收获的话，请帮我点个在看。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;如喜欢本文，请点击右上角，把文章分享到朋友圈&lt;/span&gt;&lt;br/&gt;&lt;span&gt;如有想了解学习的技术点，请留言给若飞安排分享&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;·END·&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;相关阅读：&lt;/strong&gt;&lt;/p&gt;&lt;hr/&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools-id=&quot;23409&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;作者：苏三呀    &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;来源：苏三说技术&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;版权申明：&lt;/span&gt;&lt;span&gt;内容来源网络，版权归原创者所有。&lt;/span&gt;&lt;span&gt;除非无法确认，我们都会标明作者及出处，如有侵权烦请告知，我们会立即删除并表示歉意。&lt;/span&gt;&lt;span&gt;谢谢!&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;article ng-controller=&quot;EntryCtrl&quot; ui-lightbox=&quot;&quot;&gt;&lt;section ng-bind-html=&quot;postContentTrustedHtml&quot;&gt;&lt;section data-id=&quot;702&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong data-brushtype=&quot;text&quot;&gt;架构师&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;我们都是架构师！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img border=&quot;0&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/sXiaukvjR0RB58TtkIHwhn4lpsqLnZgian9d5tr1BibP7XpibGTFFib1nq9YuYq209XZUEfCOqMzepDOBbN9KD9wMSg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot; data-width=&quot;200px&quot; height=&quot;&quot; opacity=&quot;&quot; title=&quot;&quot; vspace=&quot;0&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;strong&gt;关注&lt;/strong&gt;架构师(JiaGouX)，添加“星标”&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;获取每天技术干货，一起成为牛逼架构师&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;技术群请&lt;/strong&gt;&lt;strong&gt;加若飞：&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;1321113940 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;进架构师群&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;投稿、合作、版权等邮箱：&lt;strong&gt;&lt;span&gt;admin@137x.com&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/article&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>376661be7566de185a9cf11996a9ed4f</guid>
<title>这种本机网络 IO 方法，性能可以翻倍！</title>
<link>https://toutiao.io/k/jcfcs30</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;span&gt;在本机网络 IO 中，我们讲到过基于普通 socket 的本机网络通信过程中，其实在内核工作流上并没有节约太多的开销。&lt;/span&gt;&lt;span&gt;该走的系统调用、协议栈、邻居系统、设备驱动（虽然说对于本机网络 loopback 设备来说只是一个软件虚拟的东东）全都走了一遍。&lt;/span&gt;&lt;span&gt;其工作过程如下图:&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.848816029143898&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqr5dxehUyQGUfk69ibqFibVMYBNJiclZk13tB111axoKtso0QfeeZMKPrLohFlPoNBAGTzhviay28ibicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;549&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;那么我们今天来看另外一种本机网络 IO 通信方式 —— Unix Domain Socket。看看这种方式在性能开销上和基于 127.0.0.1 的本机网络 IO 有没有啥差异呢。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本文中，我们将分析 Unix Domain Socket 的内部工作原理。你将理解为什么这种方式的性能比 127.0.0.1 要好很多。最后我们还给出了实际的性能测试对比数据。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;相信你已经迫不及待了，别着急，让我们一一展开细说！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 使用方法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Unix Domain Socket（后面统一简称 UDS） 使用起来和传统的 socket 非常的相似。区别点主要有两个地方需要关注。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在创建 socket 的时候，普通的 socket 第一个参数 family 为 AF_INET， 而 UDS 指定为 AF_UNIX 即可。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Server 的标识不再是 IP 和 端口，而是一个路径，例如 /dev/shm/fpm-cgi.sock。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其实在平时我们使用 UDS 并不一定需要去写一段代码，很多应用程序都支持在本机网络 IO 的时候配置。例如在 Nginx 中，如果要访问的本机 fastcgi 服务是以 UDS 方式提供服务的话，只需要在配置文件中配置这么一行就搞定了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;fastcgi_pass&lt;/span&gt; unix:/dev/shm/fpm-cgi.sock;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果 对于一个 UDS 的 server 来说，它的代码示例大概结构如下，大家简单了解一下。只是个示例不一定可运行。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; fd = socket(AF_UNIX, SOCK_STREAM, &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;char&lt;/span&gt; *socket_path = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;./server.sock&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__built_in&quot;&gt;strcpy&lt;/span&gt;(serun.sun_path, socket_path); &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   bind(fd, serun, ...);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   listen(fd, &lt;span class=&quot;code-snippet__number&quot;&gt;128&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      conn = accept(fd, ...);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      read(conn, ...);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      write(conn, ...);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;基于 UDS 的 client 也是和普通 socket 使用方式差不太多，创建一个 socket，然后 connect 即可。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;perl&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; main(){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   sock = &lt;span class=&quot;code-snippet__keyword&quot;&gt;socket&lt;/span&gt;(AF_UNIX, SOCK_STREAM, &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;connect&lt;/span&gt;(sockfd, ...)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 连接过程&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总的来说，基于 UDS 的连接过程比 inet 的 socket 连接过程要简单多了。客户端先创建一个自己用的 socket，然后调用 connect 来和服务器建立连接。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 connect 的时候，会申请一个新 socket 给 server 端将来使用，和自己的 socket 建立好连接关系以后，就放到服务器正在监听的 socket 的接收队列中。这个时候，服务器端通过 accept 就能获取到和客户端配好对的新 socket 了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总的 UDS 的连接建立流程如下图。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.166270783847981&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqr5dxehUyQGUfk69ibqFibVMNB1r0ZJF5FRQNwMx6SJnUuN1NmM29TVDWlRibkCXuEIaYRGMkeAvibcA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;421&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;内核源码中最重要的逻辑在 connect 函数中，我们来简单展开看一下。unix 协议族中定义了这类 socket 的所有方法，它位于 net/unix/af_unix.c 中。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;proto_ops&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;unix_stream_ops&lt;/span&gt; = {&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   .family = PF_UNIX,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   .owner = THIS_MODULE,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   .bind =  unix_bind,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   .connect = unix_stream_connect,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   .socketpair = unix_socketpair,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   .listen = unix_listen,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; };&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们找到 connect 函数的具体实现，unix_stream_connect。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;unix_stream_connect&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; socket *sock, &lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; sockaddr *uaddr,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; addr_len, &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; flags&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; sockaddr_un *sunaddr = (&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; sockaddr_un *)uaddr;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   newsk = unix_create1(sock_net(sk), NULL);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   skb = sock_wmalloc(newsk, &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;, GFP_KERNEL);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   unix_peer(newsk) = sk;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   newsk-&amp;gt;sk_state  = TCP_ESTABLISHED;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   newsk-&amp;gt;sk_type  = sk-&amp;gt;sk_type;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   sk-&amp;gt;sk_state = TCP_ESTABLISHED;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   unix_peer(sk) = newsk;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   __skb_queue_tail(&amp;amp;other-&amp;gt;sk_receive_queue, skb);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;要&lt;/span&gt;&lt;span&gt;的连接操作都是在这个函数中完成的。&lt;/span&gt;&lt;span&gt;和我们平常所见的 TCP 连接建立过程，这个连接过程简直是太简单了。&lt;/span&gt;&lt;span&gt;没有三次握手，也没有全连接队列、半连接队列，更没有啥超时重传。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;直接就是将两个 socket 结构体中的指针互相指向对方就行了。就是 unix_peer(newsk) = sk 和 unix_peer(sk) = newsk 这两句。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;define&lt;/span&gt; unix_peer(sk) (unix_sk(sk)-&amp;gt;peer)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当关联关系建立好之后，通过 __skb_queue_tail 将 skb 放到服务器的接收队列中。注意这里的 skb 里保存着新 socket 的指针，因为服务进程通过 accept 取出这个 skb 的时候，就能获取到和客户进程中 socket 建立好连接关系的另一个 socket。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;怎么样，UDS 的连接建立过程是不是很简单！？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3. 发送过程&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;看完了连接建立过程，我们再来看看基于 UDS 的数据的收发。这个收发过程一样也是非常的简单。发送方是直接将数据写到接收方的接收队列里的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5492700729927007&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqr5dxehUyQGUfk69ibqFibVMbUcIFoJibcDKRgIMeZqWiaV9gIjBYZicJPhBjib2W3ibmqrhzlHmHT3jmyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;548&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们从 send 函数来看起。send 系统调用的源码位于文件 net/socket.c 中。在这个系统调用里，内部其实真正使用的是 sendto 系统调用。它只干了两件简单的事情，&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第一是在内核中把真正的 socket 找出来，在这个对象里记录着各种协议栈的函数地址。第二是构造一个 struct msghdr 对象，把用户传入的数据，比如 buffer地址、数据长度啥的，统统都装进去. 剩下的事情就交给下一层，协议栈里的函数 inet_sendmsg 了，其中 inet_sendmsg 函数的地址是通过 socket 内核对象里的 ops 成员找到的。大致流程如图。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6823956442831216&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqr5dxehUyQGUfk69ibqFibVMghJ9jR02cFjY2FoJFpsN8yZsYibSPSHpS2hIOxXYExNkVfTkRLY8zSg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;551&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在进入到协议栈 inet_sendmsg 以后，内核接着会找到 socket 上的具体协议发送函数。对于 Unix Domain Socket 来说，那就是 unix_stream_sendmsg。我们来看一下这个函数。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;unix_stream_sendmsg&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; kiocb *kiocb, &lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; socket *sock,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          &lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; msghdr *msg, size_t len&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   skb = sock_alloc_send_skb(sk, size, msg-&amp;gt;msg_flags&amp;amp;MSG_DONTWAIT,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &amp;amp;err);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   err = memcpy_fromiovec(skb_put(skb, size), msg-&amp;gt;msg_iov, size);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; sock *other = NULL;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   other = unix_peer(sk);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   skb_queue_tail(&amp;amp;other-&amp;gt;sk_receive_queue, skb);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   other-&amp;gt;sk_data_ready(other, size);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;和复杂的 TCP 发送接收过程相比，这里的发送逻辑简单简单到令人发指。申请一块内存（skb），把数据拷贝进去。根据 socket 对象找到另一端，直接把 skb 给放到对端的接收队列里了。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接收函数主题是 unix_stream_recvmsg，这个函数中只需要访问它自己的接收队列就行了，源码就不展示了。所以在本机网络 IO 场景里，基于 Unix Domain Socket 的服务性能上肯定要好一些的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;4. 性能对比&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了验证 Unix Domain Socket 到底比基于 127.0.0.1 的性能好多少，我做了一个性能测试。在网络性能对比测试，最重要的两个指标是延迟和吞吐。我从 Github 上找了个好用的测试源码：https://github.com/rigtorp/ipc-bench。我的测试环境是一台 4 核 CPU，8G 内存的 KVM 虚机。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在延迟指标上，对比结果如下图。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3431818181818182&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqr5dxehUyQGUfk69ibqFibVM1X83FjHgcKPXoicpOStLm3vprwoH3tuhia91l2oibfmAOUhpCFjUaHlCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;880&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;可见在小包（100 字节）的情况下，UDS 方法的“网络” IO 平均延迟只有 2707 纳秒，而基于 TCP（访问 127.0.0.1）的方式下延迟高达 5690 纳秒。耗时整整是前者的两倍。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在包体达到 100 KB 以后，UDS 方法延迟 24 微秒左右（1 微秒等于 1000 纳秒），TCP 是 32 微秒，仍然高一截。这里低于 2 倍的关系了，是因为当包足够大的时候，网络协议栈上的开销就显得没那么明显了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;再来看看吞吐效果对比。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.27355072463768115&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqr5dxehUyQGUfk69ibqFibVMtaHJ8KD0jPibiaqiaYXSuWn4NNNhgEIwU9xsib8XxtMBibzHwn4z5eRHTNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1104&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在小包的情况下，带宽指标可以达到 854 M，而基于 TCP 的 IO 方式下只有 386 M。数据就解读到这里。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;5. 总结&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本文分析了基于 Unix Domain Socket 的连接创建、以及数据收发过程。其中数据收发的工作过程如下图。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5492700729927007&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqr5dxehUyQGUfk69ibqFibVMbUcIFoJibcDKRgIMeZqWiaV9gIjBYZicJPhBjib2W3ibmqrhzlHmHT3jmyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;548&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;相对比本机网络 IO 通信过程上，它的工作过程要清爽许多。其中 127.0.0.1 工作过程如下图。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.848816029143898&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqr5dxehUyQGUfk69ibqFibVMYBNJiclZk13tB111axoKtso0QfeeZMKPrLohFlPoNBAGTzhviay28ibicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;549&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们也对比了 UDP 和 TCP 两种方式下的延迟和性能指标。在包体不大于 1KB 的时候，UDS 的性能大约是 TCP 的两倍多。所以，在本机网络 IO 的场景下，如果对性能敏感，建议你使用 Unix Domain Socket。&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;1、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651503617&amp;amp;idx=2&amp;amp;sn=b3772575e9c93a2959f7657fb431533b&amp;amp;chksm=bd25d07e8a525968711b2e13e80259d166154662c8f1d88c3fe3b5134ef02936f695020e8765&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;为什么网络 I/O 会被阻塞？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;为什么网络 I/O 会被阻塞？&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651497617&amp;amp;idx=2&amp;amp;sn=48766564aea1c4896a837de00f8a4bc6&amp;amp;chksm=bd25c8ee8a5241f8a286f5889d78a5da11aa39658399ec0646557f82c9cfb3fa01b56405d6e0&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;36 张图详解 DNS ：网络世界的导航&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;36 张图详解 DNS ：网络世界的导航&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651495718&amp;amp;idx=1&amp;amp;sn=f07fe55b05ba5866caf50e381c4bfe2c&amp;amp;chksm=bd25f1598a52784fa7d28df312e4e29e2a22d4e1defb68df5cd41e7d2b5369560dcb8a318e3e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;25 张图，一万字，拆解 Linux 网络包发送过程&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;25 张图，一万字，拆解 Linux 网络包发送过程&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关注「ImportNew」，提升Java技能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9166666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;点赞和在看就是最大的支持&lt;/span&gt;&lt;span&gt;❤️&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>