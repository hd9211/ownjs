<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>e43c7524ea1c76416be8f6c871bee336</guid>
<title>关于 JWT Token 自动续期的解决方案</title>
<link>https://toutiao.io/k/aszm22z</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前后端分离的开发模式下，前端用户登录成功后后端服务会给用户颁发一个jwt token。前端(如vue)在接收到jwt token后会将token存储到LocalStorage中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后续每次请求都会将此token放在请求头中传递到后端服务，后端服务会有一个过滤器对token进行拦截校验，校验token是否过期，如果token过期则会让前端跳转到登录页面重新登录。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为jwt token中一般会包含用户的基本信息，为了保证token的安全性，一般会将token的过期时间设置的比较短。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这样又会导致前端用户需要频繁登录（token过期），甚至有的表单比较复杂，前端用户在填写表单时需要思考较长时间，等真正提交表单时后端校验发现token过期失效了不得不跳转到登录页面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果真发生了这种情况前端用户肯定是要骂人的，用户体验非常不友好。本篇内容就是在前端用户无感知的情况下实现token的自动续期，避免频繁登录、表单填写内容丢失情况的发生。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;实现原理&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jwt token自动续期的实现原理如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;登录成功后将用户生成的 &lt;code&gt;jwt token&lt;/code&gt; 作为key、value存储到cache缓存里面 (这时候key、value值一样)，将缓存有效期设置为 token有效时间的2倍。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当该用户再次请求时，通过后端的一个 &lt;code&gt;jwt Filter&lt;/code&gt; 校验&lt;strong&gt;前端token&lt;/strong&gt;是否是有效token，如果&lt;strong&gt;前端token&lt;/strong&gt;无效表明是非法请求，直接抛出异常即可；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;根据规则取出cache token，判断cache token是否存在，此时主要分以下几种情况：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;cache token 不存在&lt;br/&gt;这种情况表明该用户账户空闲超时，返回用户信息已失效，请重新登录。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;cache token 存在，则需要&lt;strong&gt;使用jwt工具类验证该cache token 是否过期超时&lt;/strong&gt;，不过期无需处理。&lt;br/&gt;过期则表示该用户一直在操作只是token失效了，后端程序会给token对应的key映射的value值重新生成jwt token并覆盖value值，该缓存生命周期重新计算。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;实现逻辑的核心原理：&lt;/strong&gt;前端请求Header中设置的token保持不变，校验有效性以缓存中的token为准。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;代码实现（伪码）&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;登录成功后给用户签发token，并设置token的有效期&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;...&lt;br/&gt;SysUser sysUser = userService.getUser(username,password);&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt; !== sysUser){&lt;br/&gt;    String token = JwtUtil.sign(sysUser.getUsername(), &lt;br/&gt;sysUser.getPassword());&lt;br/&gt;}&lt;br/&gt;...&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String &lt;span&gt;sign&lt;/span&gt;&lt;span&gt;(String username, String secret)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//设置token有效期为30分钟&lt;/span&gt;&lt;br/&gt; Date date = &lt;span&gt;new&lt;/span&gt; Date(System.currentTimeMillis() + &lt;span&gt;30&lt;/span&gt; * &lt;span&gt;60&lt;/span&gt; * &lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt; &lt;span&gt;//使用HS256生成token,密钥则是用户的密码&lt;/span&gt;&lt;br/&gt; Algorithm algorithm = Algorithm.HMAC256(secret);&lt;br/&gt; &lt;span&gt;// 附带username信息&lt;/span&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; JWT.create().withClaim(&lt;span&gt;&quot;username&quot;&lt;/span&gt;, username).withExpiresAt(date).sign(algorithm);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;将token存入redis，并设定过期时间，将redis的过期时间设置成token过期时间的两倍&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Sting tokenKey = &lt;span&gt;&quot;sys:user:token&quot;&lt;/span&gt; + token;&lt;br/&gt;redisUtil.set(tokenKey, token);&lt;br/&gt;redisUtil.expire(tokenKey, &lt;span&gt;30&lt;/span&gt; * &lt;span&gt;60&lt;/span&gt; * &lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;过滤器校验token，校验token有效性&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doFilter&lt;/span&gt;&lt;span&gt;(ServletRequest req, ServletResponse res, FilterChain chain)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException, ServletException &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//从header中获取token&lt;/span&gt;&lt;br/&gt; String token = httpServletRequest.getHeader(&lt;span&gt;&quot;token&quot;&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt; == token){&lt;br/&gt;  &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&lt;span&gt;&quot;illegal request，token is necessary!&quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;    &lt;span&gt;//解析token获取用户名&lt;/span&gt;&lt;br/&gt; String username = JwtUtil.getUsername(token);&lt;br/&gt; &lt;span&gt;//根据用户名获取用户实体，在实际开发中从redis取&lt;/span&gt;&lt;br/&gt; User user = userService.findByUser(username);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt; == user){&lt;br/&gt;  &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&lt;span&gt;&quot;illegal request，token is Invalid!&quot;&lt;/span&gt;)&lt;br/&gt;    }&lt;br/&gt; &lt;span&gt;//校验token是否失效，自动续期&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt;(!refreshToken(token,username,user.getPassword())){&lt;br/&gt;  &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&lt;span&gt;&quot;illegal request，token is expired!&quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt; ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;实现token的自动续期&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;refreshToken&lt;/span&gt;&lt;span&gt;(String token, String userName, String passWord)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; Sting tokenKey = &lt;span&gt;&quot;sys:user:token&quot;&lt;/span&gt; + token ;&lt;br/&gt; String cacheToken = String.valueOf(redisUtil.get(tokenKey));&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (StringUtils.isNotEmpty(cacheToken)) {&lt;br/&gt;  &lt;span&gt;// 校验token有效性，注意需要校验的是缓存中的token&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!JwtUtil.verify(cacheToken, userName, passWord)) {&lt;br/&gt;   String newToken = JwtUtil.sign(userName, passWord);&lt;br/&gt;   &lt;span&gt;// 设置超时时间&lt;/span&gt;&lt;br/&gt;   redisUtil.set(tokenKey, newToken) ;&lt;br/&gt;   redisUtil.expire(tokenKey, &lt;span&gt;30&lt;/span&gt; * &lt;span&gt;60&lt;/span&gt; * &lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;...&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;verify&lt;/span&gt;&lt;span&gt;(String token, String username, String secret)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// 根据密码生成JWT效验器&lt;/span&gt;&lt;br/&gt;  Algorithm algorithm = Algorithm.HMAC256(secret);&lt;br/&gt;  JWTVerifier verifier = JWT.require(algorithm).withClaim(&lt;span&gt;&quot;username&quot;&lt;/span&gt;, username).build();&lt;br/&gt;  &lt;span&gt;// 效验TOKEN&lt;/span&gt;&lt;br/&gt;  DecodedJWT jwt = verifier.verify(token);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt; } &lt;span&gt;catch&lt;/span&gt; (Exception exception) {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文中jwt的相关操作是基于 &lt;code&gt;com.auth0.java-jwt&lt;/code&gt; 实现，大家可以通过阅读原文获取 &lt;code&gt;JwtUtil&lt;/code&gt; 工具类。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jwt token实现逻辑的核心原理是 &lt;strong&gt;前端请求Header中设置的token保持不变，校验有效性以缓存中的token为准，千万不要直接校验Header中的token&lt;/strong&gt;。实现原理部分大家好好体会一下，思路比实现更重要！&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b0e217de265eb5a8ce47eb7ed217a042</guid>
<title>Apache Pulsar 与 Kafka 在金融场景下的性能对比分析</title>
<link>https://toutiao.io/k/3bktoh2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>19d22d107731f82377f4ef0960ad5327</guid>
<title>B站面试之旅</title>
<link>https://toutiao.io/k/sf65rqv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;blockquote&gt;&lt;p&gt;此次B站服务端开发面试之旅可谓惊险，不过通过对大部分面试题套路的掌握，不出意外还是拿下了，下面我们来看看这些骚题是不是常见的不能再常见的了。这些面试题看了就能面上？当然不是，只是通过这些题让自己知道所欠缺的是什么，以及可以去看看哪些资料。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;&lt;span&gt;1 操作系统相关&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;当一个线程在获取锁的时候，如果这个锁已经被其他线程获取，那么这个线程不会破门而入，而是&lt;strong&gt;循环等待&lt;/strong&gt;，但是嗷嗷待哺，需要不断地嗷嗷叫判断锁是否被成功获取，直到获取到锁才会退出循环。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;自旋锁通常会出现哪些问题?&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;如果某个线程拿着锁死不放手，其他线程没法拿到这把锁，只好等待获取锁的线程进入循环等待的状态，等待不是睡觉，还是会消耗CPU，等待久了就会导致CPU的使用率太高。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;那么自旋锁和其他锁到底有啥不同？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;从线程状态来看，自旋锁的状态是运行-运行-运行。而非自旋锁的状态是运行---阻塞---运行，所以自旋锁会更高效。&lt;/p&gt;&lt;p&gt;不管是什么锁，都是为了实现&lt;strong&gt;保护共享资源&lt;/strong&gt;而提出的一种锁机制，都是为了对某项资源的互斥使用。对于互斥锁而言，如果资源已经被占用，那么资源的申请者只会进入睡眠的状态。而自旋锁不会引起调用者睡眠，而是一直循环在那里查看该自旋锁的保持着是否已经释放了锁。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;那么在Java中如何去实现一个自旋锁&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SpinLock&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; AtomicReference&amp;lt;Thread&amp;gt; cas = &lt;span&gt;new&lt;/span&gt; AtomicReference&amp;lt;Thread&amp;gt;();&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;lock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Thread current = Thread.currentThread();&lt;br/&gt;        &lt;span&gt;// 利用CAS&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (!cas.compareAndSet(&lt;span&gt;null&lt;/span&gt;, current)) {&lt;br/&gt;            &lt;span&gt;// DO &lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;unlock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Thread current = Thread.currentThread();&lt;br/&gt;        cas.compareAndSet(current, &lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上段代码中，方法lock利用的CAS，当线程A获取锁的时候，成功获取不会进入while循环。如果此时线程A没有释放锁，当线程B来获取锁的时候，由于不满足CAS，就会进入whilei循环，不断判断是否满足CAS，直到线程A调用unlock释放。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;自旋锁有哪些优点？&lt;/p&gt;&lt;/blockquote&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;因为运行在用户态，没有上下文的&lt;strong&gt;线程状态切换&lt;/strong&gt;，线程一直处于active，减少了不必要的上下文切换，从而执行速度较快&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;因为非自旋锁在没有获取锁的情况下会进入&lt;strong&gt;阻塞状态&lt;/strong&gt;，从而进入内核态，此时就需要线程的上下文切换，因为阻塞后进入内核调度状态，会导致用户态和内核态之间的切换，影响锁的性能。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;首先将IO模型给安排一遍，然后把自己很熟悉的IO模型详细说一波并介绍出应用场景，这个装的X就算比较完美，具体的非常详细的在下一篇文章，这里简要说一波。这一部分在上一篇详细阐述过&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;阻塞IO&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;我们知道在调用某个函数的时候无非就是两种情况，要么&lt;strong&gt;马上返回&lt;/strong&gt;，然后根据返回值进行接下来的业务处理。当在使用&lt;strong&gt;阻塞IO&lt;/strong&gt;的时候，应用程序会被无情的&lt;strong&gt;挂起&lt;/strong&gt;，等待内核完成操作，因为此时的内核可能将CPU时间切换到了其他需要的进程中，在我们的应用程序看来感觉被卡主(阻塞)了。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/NdsdouZwicacibdCicBgewiaoQPQTTlTOO7KEGZ2uonJyH7iaAYxWMznG6avwoicAy99aWrJzsia8qIh993ibqsiaIA0M1A/640?wx_fmt=png&quot; data-type=&quot;png&quot; title=&quot;阻塞IO&quot; data-ratio=&quot;0.487962962962963&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;阻塞IO&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;非阻塞IO&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;当使用非阻塞函数的时候，和阻塞IO类比，内核会立即返回，返回后获得足够的CPU时间继续做其他的事情。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/NdsdouZwicacibdCicBgewiaoQPQTTlTOO7KZYiaPCH5oa0KJ99veEWoQkYcia5n6Ws4liaUeoRPjZUDPBvlhvX8D0HDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; title=&quot;非阻塞&quot; data-ratio=&quot;0.6712962962962963&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;非阻塞&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;IO复用模型&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;当使用fgets等待标准输入的时候，如果此时套接字有数据但不能读出。IO多路复用意味着可以将标准输入、套接字等都当做IO的一路，任何一路IO有事件发生，都将通知相应的应用程序去处理相应的IO事件，在我们看来就反复&lt;strong&gt;同时&lt;/strong&gt;可以处理多个事情。这就是&lt;strong&gt;IO复用&lt;/strong&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/NdsdouZwicacibdCicBgewiaoQPQTTlTOO7KbaY8JibcqwZSpBZyK4MhvjOib6p2XDUhXibhiaemVYYz0pjjNHWZNsEwqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; title=&quot;IO复用&quot; data-ratio=&quot;0.6712962962962963&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;IO复用&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;信号驱动IO&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;在信号驱动式 I/O 模型中，应用程序使用套接口进行信号驱动 I/O，并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个 SIGIO 信号，可以在信号处理函数中调用 I/O 操作函数处理数据。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/NdsdouZwicacibdCicBgewiaoQPQTTlTOO7K1viaUlvmmzcUmrUUOq0qrS0xbPibM6gSYA4VtMlZCSyHZuY7jFXRAXNg/640?wx_fmt=png&quot; data-type=&quot;png&quot; title=&quot;信号驱动&quot; data-ratio=&quot;0.6712962962962963&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;信号驱动&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;异步IO&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;用程序告知内核启动某个操作，并让内核在整个操作（包括将数据从内核拷贝到应用程序的缓冲区）完成后通知应用程序。那么和信号驱动有啥不一样?&lt;/p&gt;&lt;/blockquote&gt;&lt;figure&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/NdsdouZwicacibdCicBgewiaoQPQTTlTOO7KWsfTiatmjFRS9kMLSKQlY3qpnicrn4xe5qVbdcHRWHc9UtpJ3heCXibnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; title=&quot;异步IO&quot; data-ratio=&quot;0.6712962962962963&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;异步IO&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote&gt;&lt;p&gt;这里一样的套路，先说出两者的用途，然后两者的优缺点。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;select的缺点&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;select返回的是含有整个句柄的数组，应用程序需要遍历整个数组才能发现哪些句柄发生了事件&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;select的触发方式是&lt;strong&gt;水平触发&lt;/strong&gt;，应用程序如果没有完成对一个已经就绪的文件描述符进行IO操作，那么之后每次select调用还是会将这些文件描述符通知进程&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;内核 / 用户空间内存拷贝问题，select每次都会改变内核中的句柄数据结构集，因而每次select调用时都需要从用户空间向内核空间复制所有的句柄数据结构，产生巨大的开销&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;单个进程能够监视的文件描述符的数量&lt;strong&gt;存在最大限制&lt;/strong&gt;，通常是1024，当然可以更改数量&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;epoll实现&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;epoll在内核中会维护一个&lt;strong&gt;红黑树&lt;/strong&gt;和一个&lt;strong&gt;双向链表&lt;/strong&gt;，红黑树存放通过epoll_ctl方法向epoll对象中添加进来的事件，所以不需要每次调用epoll_wait都全量复制所有的事件结构。双向链表存放就绪的事件，所有添加到epoll中的事件都会与设备(网卡)驱动程序建立回调关系，也就是说，当相应的事件发生时会调用这个回调方法，这个回调方法在内核中叫ep_poll_callback,它会将发生的事件添加到rdlist双链表中。调用epoll_wait就会直接返回链表中的就绪事件，效率高。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;select适合少量活跃连接，一般几千。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;epoll适合大量不太活跃的连接。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;乐观锁和悲观锁了解吗？&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;&lt;p&gt;这个问题延伸的问题会很多，比如线程安全，CAS原理，优缺点等。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;啥是悲观和乐观，咋们面试的时候不得乐观一些。想给面试来一波官方解释，然后大白话解释一波就差不多了。&lt;/p&gt;&lt;p&gt;官方：悲观锁是总是假设最坏的情况，每次那数据都认为别人会修改它，所以每次去那数据都要上锁，这样别人去拿这个数据就会阻塞。乐观锁就不一样了，总是觉得一切都是最好的安排，每次拿数据都认为别人不会修改，所以也就不上锁，但是在更新的时候会判断这个期间别人有没有更新这个数据。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;缓存穿透&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;一般来说，缓存系统会通过key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。这个时候如果一些恶意的请求到来，就会故意查询不存在的key,当某一时刻的请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;如何避免？&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存。对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该bitmap过滤。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;缓存雪崩&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;如何避免？&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期。&lt;/p&gt;&lt;p&gt;不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2 redis相关&lt;/span&gt;&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;如果是后端/服务端面试的同学，怎么说都的去找一本redis书来看看，其出现的概率只有那么大了，切记切记。看看B站问了哪几个问题。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;能说不了解吗，就算是没有听说过，咋们也可以来一句：“不好意思面试官，这一块还不怎么深入，但是从字面意思来理解巴拉巴拉”，不至于一脸懵逼。下面我们看看redis的缓存策略&lt;/p&gt;&lt;p&gt;Redis中通过maxmemory参数来设定内存的使用上限，如果Redis所使用内存超过设定的最大值，那么会根据配置文件中的策略选取要删除的key来删除，从而留出新的键值空间。主要的六种淘汰key策略&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;volatile-lru&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;在键空间中设置过期时间，移除哪些最近最少使用的key，占着茅坑不拉屎的key&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;allkeys-lru&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;移除最近最少使用的key&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&quot;3&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;volatile-random&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;在键空间中设置过期时间，随机移除一个key&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&quot;4&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;allkeys-random&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;随机移除一个key&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&quot;5&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;noeviction&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;当内存使用达到阀值的时候，所有引起申请内存的命令会报错；&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;ok，现在知道了需要淘汰哪些key，那我们如何去淘汰这些key&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;定时删除&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;很简单，设置一个闹钟，闹钟响了就删除即可。这种方式对于内存来说还是比较友好，内存不需要啥额外的操作，直接通过定时器就可保证尽快的删除。对于CPU来说就有点麻烦了，如果过期键比较多，那么定时器也就多，这删除操作就会占用太多的CPU资源&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;惰性删除&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;每次从键空间获取键的时候检查键的过期时间，如果过期了，删除完事。&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&quot;3&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;定期删除&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;每隔一段时间就去数据库检查，删除过期的键&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;这种方案是定时删除和惰性删除的中和方法，既通过限制删除操作执行的时长来减少对CPU时间的影响，也能减少内存的浪费。但是难点在于间隔时长需要根据业务情况而定。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;3 mysql&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;InnoDB中的行锁是通过索引上的索引项实现，主要特点是，只有通过索引条件检索数据，InnoDB才会使用行级锁，否则InnoDB将使用表锁。&lt;/p&gt;&lt;p&gt;这里注意，在Mysql中，行级锁不是锁记录而是锁索引。索引又分为主键索引和非主键索引两种。如果在一条语句中操作了非主键索引，Mysql会锁定该非主键索引，再锁定相关的主键索引。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;了解过间隙锁吗？间隙锁的加锁范围是怎么确定的？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;了解B+树吗？B+树什么时候会出现结点分裂？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;&lt;p&gt;这个回答在上一篇的B+树已经详细说了。这里简述一下&lt;/p&gt;&lt;/blockquote&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;将已满结点进行分裂，将已满节点后M/2节点生成一个新节点，将新节点的第一个元素指向父节点。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;父节点出现已满，将父节点继续分裂。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;一直分裂，如果根节点已满，则需要分类根节点，此时树的高度增加。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;事务还没执行完数据库挂了，重启的时候会发生什么？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;undo日志和redo日志分别是干嘛的？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;redo log重做日志是InnDB存储引擎层的，用来保证事务安全。在事务提交之前，每个修改操作都会记录变更后的数据，保存的是物理日志-数据，防止发生故障的时间点，有脏页未写入磁盘，在重启mysql的时候，根据redo log进行重做从而达到事务的持久性&lt;/p&gt;&lt;p&gt;undo log回滚日志保存了事务发生之前的数据的一个版本，可以用于回滚，同时也提供多版本并发控制下的读。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;细说太多了，几个大写字母代表啥，这几个大写字母又是如何关联起来完事。细问再深究&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;首先应该知道binlog是一个二进制文件，记录所有增删改操作，节点之间的复制都会依靠binlog来完成。从底层原理来说，binlog有三个模式&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;模式1--row模式&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;每一行的数据被修改就会记录在日志中，然后在slave段对相同的数据进行修改。比如说&quot;update xx where id in(1,2,3,4,5)&quot;，使用此模式就会记录5条记录&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;模式2--statement模式&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;修改数据的sql会记录到master的binlog中。slave在复制的时候sql thread会解析成和原来maseter端执行过的相同的sql在此执行&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&quot;3&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;模式3--mixed模式&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;mixed模式即混合模式，Mysql会根据执行的每一条具体sql区分对待记录的日志形式。那么binlog的主从同步流程到底是咋样的&lt;/p&gt;&lt;/blockquote&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6884735202492211&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/NdsdouZwicacibdCicBgewiaoQPQTTlTOO7KOuvWnlbZxFNcYUFVP1fDZDjdWYiccPO4icoNcgbNHq7gibxjP4JYXtN3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;963&quot; title=&quot;binlog同步&quot;/&gt;&lt;figcaption&gt;binlog同步&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;流程简述：&lt;/p&gt;&lt;p&gt;Master执行完增删改操作后都会记录binlog日志,当需要同步的时候会主动通知slave节点，slave收到通知后使用IO THREAD主动去master读取binlog写入&lt;code&gt;relay&lt;/code&gt;日志(中转日志),然后使 SQL THREAD完成对relay日志的解析然后入库操作,完成同步。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;4 基本数据结构&lt;/span&gt;&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;他的主要特点是链表中的最后一个节点的指针域指向头结点，整个链表形成一个环。&lt;strong&gt;&lt;em&gt;*这里*&lt;/em&gt;循环链表判断链表结束的标志是，判断尾节点是不是指向头结点&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;思考这个问题的时候，我们不凡复习下不错的二分查找，它依赖数组随机访问的特性，其查找时间复杂度为O(log n)。如果我们将元素放入链表中，二分查找还好使吗？这就是今天和大家分享的跳表&lt;/p&gt;&lt;p&gt;&lt;strong&gt;理解跳表&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;假设使用单链表存储n个元素，其中元素有序如下图所示&lt;/p&gt;&lt;/blockquote&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.03438185808339429&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/NdsdouZwicacibdCicBgewiaoQPQTTlTOO7KJ2bJRxxOibH7coHlKajgNXnxml2r8Lz8ZqFdTxkne2l8ictm3icFgfKxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1367&quot; title=&quot;一级索引&quot;/&gt;&lt;figcaption&gt;一级索引&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;从链表中查找一个元素，自然从头开始遍历找到需要查找的元素，此时的时间复杂度为O(n)。那采用什么方法可以提高查询的效率呢？问就是加索引，如何加，我们从这部分数据中抽取几个元素出来作为单独的一个链表，如下图所示]&lt;/p&gt;&lt;p&gt;假设此时咋们查找元素16，首先一级索引处寻找，当找到元素14的时候，下一个节点的值为18，意味着我们寻找的数在这两个数的中间。此时直接从14节点指针下移到下面的原始链表中，继续遍历，正好下一个元素就是我们寻找的16。好了，我们小结一下，如果从原始链表中寻找元素16，需要遍历比较8次，如果通过索引链表寻找我们只需要5次即可。&lt;/p&gt;&lt;figure&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/NdsdouZwicacibdCicBgewiaoQPQTTlTOO7KSqjzcAVOiayUP2ibFo5u33kje6JWIjqqplDKfPt9dicEbHzf8MK9Ovhbw/640?wx_fmt=png&quot; data-type=&quot;png&quot; title=&quot;在这里插入图片描述&quot; data-ratio=&quot;0.06666666666666667&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;在这里插入图片描述&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;我们继续查找元素16，此时比较次数变为4次。这样看来，加一层索引查找的次数就变少，如果有n个元素到底有多少索引？&lt;/p&gt;&lt;p&gt;假设我们按照每两个结点就抽出一个结点作为上一层的索引节点，第一层所以节点个数n/2，第二层为n/4,第x级索引的结点个数是第x-1级索引的结点个数的1/2，那第x级索引结点的个数就是n/(2^x)。假设索引有y级，我们可以得到n/(2^y)=2，从而求得y=log2n-1。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;这么多索引是不是就很浪费内存嘞？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;假设原始链表大小为n，那第一级索引大约有 n/2 个结点，第二级索引大约有 n/4 个结点，以此类推，每上升一级就减少一半，直到剩下 2 个结点。如果我们把每层索引的结点数写出来，就是一个等比数列。这几级索引的结点总和就是 n/2+n/4+n/8…+8+4+2=n-2 。所以，跳表的空间复杂度是 O(n) 。那还能不能降低一些呢。机智的你应该就考虑到假设每三个结点抽取一个节点作为索引链表的节点。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;跳表与二叉查找树&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;两者其查找的时间复杂度均为O(logn) ，那跳表还有哪些优势？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;先看二叉查找树，&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1.3130929791271346&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/NdsdouZwicacibdCicBgewiaoQPQTTlTOO7KHtgG6fVHP6CJBqaWb9yibIibuBa6mjYGIwFaLqVcDnfOcqzHMAyic63ibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;527&quot; title=&quot;特殊二叉查找树&quot;/&gt;&lt;figcaption&gt;特殊二叉查找树&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;这种结构会导致二叉查找树的查找效率变为 O(n),。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;跳表与红黑树&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;说实话，红黑树确实比较复杂，面试的时候让你写红黑树，你就给他大嘴巴子？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;红黑树需要通过左右旋的方式去维持树大小平衡。而跳表是通过随机函数来维护前面提到的 “ 平衡性 ” 。当我们往跳表中插入数据的时候，我们可以选择同时将这个数据插入到部分索引层中。如何选择加入哪些索引层呢？&lt;br/&gt;我们通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K ，那我们就将这个结点添加到第一级到第 K 级这 K 级索引中。当我们往跳表中插入数据的时候，我们可以选择同时将这个数据插入到部分索引层中。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Redis中的有序集合采用了跳表的方式来实现，其实还采用了散列表等数据结构进行融合。它在插入，删除等都有比较快的速度，虽然红黑树也可以做到，但是红黑树对于按照区间查找数据这个操作，跳表可以做到 O(logn) 的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;看的技术博客多了，这就是唠嗑。比如说，看看小贱一天天BB的文章，哈哈哈哈哈&lt;/p&gt;&lt;p&gt;面试官：我擦，尼玛说的这个我都关注了，难怪我问啥你都能说个一二三。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;5 总结&lt;/span&gt;&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;请记下以下几点:&lt;/p&gt;&lt;/blockquote&gt;&lt;figure&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/NdsdouZwicacibdCicBgewiaoQPQTTlTOO7KmPvB9hkDLZYVqa22P3vU1dlRVl5K8M6K62TJJBM48yP68tGjRKJdpg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; title=&quot;img&quot; data-ratio=&quot;0.6174496644295302&quot; data-w=&quot;298&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;hr/&gt;&lt;p&gt;唠嗑&lt;/p&gt;&lt;p&gt;为了方便大家沟通交流，资源共享。小蓝准备创建一个面试交流群，让正在面试或即将面试的小伙伴能够一起沟通交流，当然群里也会不定期的发发小红包，群里不会存在任何的广告。欢迎有兴趣的小伙伴加入。加群方式扫描下方二维码，备注加群即可&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1.1742738589211619&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/NdsdouZwicacibdCicBgewiaoQPQTTlTOO7K71iamz2KkAO4MBnLQndC1icliczxibc1aYLGB3QfZMw6vnibZriccuntaKvA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;241&quot; title=&quot;在这里插入图片描述&quot;/&gt;&lt;figcaption&gt;私人微信&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;我是小蓝，一个专为大家分享面试经验的蓝人。如果觉得文章不错或者对你有点帮助，感谢分享给你的朋友，也可在下方给小蓝给个&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;在看&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;，这对小蓝非常重要，谢谢你们，下期再会。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;往期回顾&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>af77b8f380b52075f664ea073aa153be</guid>
<title>关于前端框架的另类思考</title>
<link>https://toutiao.io/k/3723ww9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot;&gt;&lt;p&gt;halo 大家好，我是 132，我决定还是写一篇文章再来谈论前端框架，这次我们换一个角度，我们不谈函数式，不谈各种机制的优劣，我们从最原始的角度去讨论框架的各个机制&lt;/p&gt;&lt;p&gt;这里面有一些「另类」的观点，改变一个人尤其是框架作者的认知是非常困难的，这种改变只能靠自己，我写这篇文章只是为了阐述我的观点，而不是让任何人拥有同样的观点&lt;/p&gt;&lt;p&gt;&lt;b&gt;web 平台的性能瓶颈不在于 dom 操作&lt;/b&gt;&lt;/p&gt;&lt;p&gt;大家在纷纷引入 vdom 的同时，基本认知是「性能瓶颈在于 dom 操作，diff 算法是用来减少 dom 操作的」&lt;/p&gt;&lt;p&gt;这种认知当然是非常错误的，因为实际上我们的电脑越来越高配，浏览器性能越来越好，就现代浏览器来说，你操作十万个 dom 也就几秒钟的事情，根本谈不上「性能瓶颈」&lt;/p&gt;&lt;p&gt;所以拼命优化 diff 算法是一种钻牛角尖的行为，因为你的优化都是毫秒级别，意义小的可怜&lt;/p&gt;&lt;p&gt;&lt;b&gt;web 平台的性能瓶颈在于线程阻塞&lt;/b&gt;&lt;/p&gt;&lt;p&gt;线程阻塞，也就是 js 线程阻塞 UI 线程，io 线程阻塞 js 线程&lt;/p&gt;&lt;p&gt;这种瓶颈是真的会卡到你怀疑人生的，一旦造成了线程阻塞，就会卡的不要不要的&lt;/p&gt;&lt;p&gt;所以单纯对 web 平台来说，diff 算法的意义很小，还不如没有呢，dom 操作的成本真的很低&lt;/p&gt;&lt;p&gt;但是线程阻塞的问题不是你通过算法就能解决的&lt;/p&gt;&lt;p&gt;所以才有了 fre/react 的时间切片和可恢复异常，它们解决的是瓶颈问题&lt;/p&gt;&lt;p&gt;&lt;b&gt;vdom diff 的真正作用&lt;/b&gt;&lt;/p&gt;&lt;p&gt;很好，大家都知道了，web 平台做 diff 意义不大&lt;/p&gt;&lt;p&gt;很多框架作者此时就会出来说「权衡」，我们要的不是 diff 的性能，而是 vdom 的抽象层次，diff 只是权衡后的结果&lt;/p&gt;&lt;p&gt;这么说也没什么错，vdom 确实是一种很好的抽象机制，diff 提升性能也是不做白不做&lt;/p&gt;&lt;p&gt;但却不是必要的，所以 web 平台才有了一堆 without vdom 的框架，比如 litelement，svelte，他们放弃 vdom 的时候，都阐述了「为什么不需要 vdom」&lt;/p&gt;&lt;p&gt;但 vdom 其实是有用的，我们要说另一个平台&lt;/p&gt;&lt;p&gt;&lt;b&gt;RN 平台的性能瓶颈在于线程通信&lt;/b&gt;&lt;/p&gt;&lt;p&gt;其实这才是 vdom diff 产生的刚需，我们线程通信，说白了就是将操作指令，发送到另一个线程&lt;/p&gt;&lt;p&gt;但是线程通信的成本很高，所以我们需要考虑，1. 减少通信次数 2. 减少通信体积&lt;/p&gt;&lt;p&gt;vdom diff 就是干这个，他们经过 diff 最终产生「最小的 dom 操作指令」，然后发送给另一个线程&lt;/p&gt;&lt;p&gt;之所以可以这么做是因为，RN 的 js runtime 不值钱，就是你可以浪费 js 引擎的性能，去交换线程通信的成本&lt;/p&gt;&lt;p&gt;所以大家经常说 vdom 跨端，实际上是用来干这个的，当然 ssr 是另外一回事&lt;/p&gt;&lt;p&gt;&lt;b&gt;小程序平台的 runtime 也尤为珍贵&lt;/b&gt;&lt;/p&gt;&lt;p&gt;小程序很特殊，它不仅有线程通信，还有 webview，导致它其实两方面的性能都是瓶颈，不仅仅是线程通信是平静，实际上 js runtime 也很值钱&lt;/p&gt;&lt;p&gt;比如，&lt;a href=&quot;https://zhuanlan.zhihu.com/p/164457006&quot; class=&quot;internal&quot;&gt;胖总：Vue 性能优化 - 去除 VNode&lt;/a&gt; 这篇文章就干过类似的事情&lt;/p&gt;&lt;p&gt;所以很明显，小程序底层框架&lt;/p&gt;&lt;ol&gt;&lt;li&gt;vdom 不合适，因为小程序的 js 的 runtime 也是瓶颈所在，浪费不起&lt;/li&gt;&lt;li&gt;线程通信的平静依旧存在，我们仍然需要得到最小指令&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;那怎么办呢？没办法咯，我们只能用电脑的性能去换 runtime 和线程通信的性能了&lt;/p&gt;&lt;p&gt;&lt;b&gt;通过编译手段得到最小的 dom 指令&lt;/b&gt;&lt;/p&gt;&lt;p&gt;这里就不得不提到一些编译型框架了，比如 svelte，svelte 的本质其实就是通过变异，编译出来一些带有条件判断的代码，进而更小的操作 dom&lt;/p&gt;&lt;p&gt;它牺牲的是编译期间的性能（也就是用户电脑的性能）和生成的 js 代码量&lt;/p&gt;&lt;p&gt;这个思路是很 ok 的，也可以说是最适合小程序的平台的思路&lt;/p&gt;&lt;p&gt;当然大家肯定会说，为什么 taro/nanachi 这种，也是编译思路，还不是被淘汰了，其实不能这么说，他们的编译只是个表面功夫，完全触碰不到瓶颈本身&lt;/p&gt;&lt;p&gt;&lt;b&gt;所谓权衡&lt;/b&gt;&lt;/p&gt;&lt;p&gt;权衡这俩字，快被框架作者们用吐了，但其实权衡分两种&lt;/p&gt;&lt;ol&gt;&lt;li&gt;先做，再编理由瞎扯&lt;/li&gt;&lt;li&gt;先搞懂是什么，再研究怎么做&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;举个例子，fre 是先搞了时间切片，然后我写了这篇文章，说时间切片才是 web 平台的瓶颈所在，属于前者&lt;/p&gt;&lt;p&gt;但如果让我现在去写一个小程序框架，我不会用 fre，因为经过很多思考，我认为 vdom 不合适，fre 也不合适，这就属于后者&lt;/p&gt;&lt;p&gt;判断力永远都是一个人的事，我觉得真的不能当傻子，任何框架作者说的话，都是好坏参半，等你自己写框架了，就能参破了&lt;/p&gt;&lt;p&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/p&gt;&lt;p&gt;这篇不是 fre 的广告帖，如果我加入一家公司，负责小程序架构，我会再写一个更合适的框架，而不是无脑地组合各种机制，无脑的用一个框架，跨各种端&lt;/p&gt;&lt;p&gt;现在的前端世界很糟糕，大家都在瞎搞，缺少了很多思考&lt;/p&gt;&lt;p&gt;其实一个框架有没有人用，火不火根本没所谓，至少对我来说没什么所谓&lt;/p&gt;&lt;p&gt;我写框架只是我的判断力驱使我这么做，我无法改变别人的认知，只好自己写一个出来&lt;/p&gt;&lt;p&gt;以上，不喜勿喷呀&lt;/p&gt;&lt;p/&gt;&lt;p/&gt;&lt;p/&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>101094a7f07ff427d9e59f066c7a8011</guid>
<title>漫谈《信号与系统》</title>
<link>https://toutiao.io/k/i52vwi2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0OQS8ricbxnVQqASFzefvR32rLcS8lltzDDTonw9zQicYyxlKia5my176ibGgcVc7LoHvxwQZKHcE865nLnN0sgSdg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.23387096774193547&quot; data-w=&quot;620&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很通俗地介绍《信号与系统》的一篇文章，我就喜欢这种通俗易懂的介绍高深原理的文章，看到一上来就大段的公式就特别头疼。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;第一课 什么是卷积 卷积有什么用 什么是傅利叶变换 什么是拉普拉斯变换&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;引子&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很多朋友和我一样，工科电子类专业，学了一堆信号方面的课，什么都没学懂，背了公式考了试，然后毕业了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;先说&quot;卷积有什么用&quot;这个问题。(有人抢答，&quot;卷积&quot;是为了学习&quot;信号与系统&quot;这门课的后续章节而存在的。我大吼一声，把他拖出去枪毙！)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;讲一个故事:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;张三刚刚应聘到了一个电子产品公司做测试人员，他没有学过&quot;信号与系统&quot;这门课程。一天，他拿到了一个产品，开发人员告诉他，产品有一个输入端，有一个输出端，有限的输入信号只会产生有限的输出。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后，经理让张三测试当输入sin(t)(t&amp;lt;1秒)信号的时候(有信号发生器)，该产品输出什么样的波形。张三照做了，花了一个波形图。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&quot;很好！&quot;经理说。然后经理给了张三一叠A4纸: &quot;这里有几千种信号，都用公式说明了，输入信号的持续时间也是确定的。你分别测试以下我们产品的输出波形是什么吧！&quot;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这下张三懵了，他在心理想&quot;上帝，帮帮我把，我怎么画出这些波形图呢?&quot;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;于是上帝出现了: &quot;张三，你只要做一次测试，就能用数学的方法，画出所有输入波形对应的输出波形&quot;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上帝接着说:&quot;给产品一个脉冲信号，能量是1焦耳，输出的波形图画出来！&quot;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;张三照办了，&quot;然后呢?&quot;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上帝又说，&quot;对于某个输入波形，你想象把它微分成无数个小的脉冲，输入给产品，叠加出来的结果就是你的输出波形。你可以想象这些小脉冲排着队进入你的产品，每个产生一个小的输出，你画出时序图的时候，输入信号的波形好像是反过来进入系统的。&quot;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;张三领悟了:&quot; 哦，输出的结果就积分出来啦！感谢上帝。这个方法叫什么名字呢?&quot;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上帝说:&quot;叫卷积！&quot;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从此，张三的工作轻松多了。每次经理让他测试一些信号的输出结果，张三都只需要在A4纸上做微积分就是提交任务了！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;----------------------------------------&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;张三愉快地工作着，直到有一天，平静的生活被打破。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经理拿来了一个小的电子设备，接到示波器上面，对张三说: &quot;看，这个小设备产生的波形根本没法用一个简单的函数来说明，而且，它连续不断的发出信号！不过幸好，这个连续信号是每隔一段时间就重复一次的。张三，你来测试以下，连到我们的设备上，会产生什么输出波形！&quot;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;张三摆摆手:&quot;输入信号是无限时长的，难道我要测试无限长的时间才能得到一个稳定的，重复的波形输出吗?&quot;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经理怒了:&quot;反正你给我搞定，否则炒鱿鱼！&quot;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;张三心想:&quot;这次输入信号连公式都给出出来，一个很混乱的波形；时间又是无限长的，卷积也不行了，怎么办呢?&quot;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;及时地，上帝又出现了:&quot;把混乱的时间域信号映射到另外一个数学域上面，计算完成以后再映射回来&quot;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&quot;宇宙的每一个原子都在旋转和震荡，你可以把时间信号看成若干个震荡叠加的效果，也就是若干个可以确定的，有固定频率特性的东西。&quot;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&quot;我给你一个数学函数f，时间域无限的输入信号在f域有限的。时间域波形混乱的输入信号在f域是整齐的容易看清楚的。这样你就可以计算了&quot;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&quot;同时，时间域的卷积在f域是简单的相乘关系，我可以证明给你看看&quot;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&quot;计算完有限的程序以后，取f(-1)反变换回时间域，你就得到了一个输出波形，剩下的就是你的数学计算了！&quot;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;张三谢过了上帝，保住了他的工作。后来他知道了，f域的变换有一个名字，叫做傅利叶，什么什么... ...&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;----------------------------------------&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再后来，公司开发了一种新的电子产品，输出信号是无限时间长度的。这次，张三开始学拉普拉斯了......&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;后记:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不是我们学的不好，是因为教材不好，老师讲的也不好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很欣赏Google的面试题: 用3句话像老太太讲清楚什么是数据库。这样的命题非常好，因为没有深入的理解一个命题，没有仔细的思考一个东西的设计哲学，我们就会陷入细节的泥沼: 背公式，数学推导，积分，做题；而没有时间来回答&quot;为什么要这样&quot;。做大学老师的做不到&quot;把厚书读薄&quot;这一点，讲不出哲学层面的道理，一味背书和翻讲 ppt，做着枯燥的数学证明，然后责怪&quot;现在的学生一代不如一代&quot;，有什么意义吗?&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;第二课 到底什么是频率 什么是系统?&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这一篇，我展开的说一下傅立叶变换F。注意，傅立叶变换的名字F可以表示频率的概念(freqence)，也可以包括其他任何概念，因为它只是一个概念模型，为了解决计算的问题而构造出来的(例如时域无限长的输入信号，怎么得到输出信号)。我们把傅立叶变换看一个C语言的函数，信号的输出输出问题看为IO 的问题，然后任何难以求解的x-&amp;gt;y的问题都可以用x-&amp;gt;f(x)-&amp;gt;f-1(x)-&amp;gt;y来得到。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. 到底什么是频率?&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个基本的假设: 任何信息都具有频率方面的特性，音频信号的声音高低，光的频谱，电子震荡的周期，等等，我们抽象出一个件谐振动的概念，数学名称就叫做频率。想象在x-y 平面上有一个原子围绕原点做半径为1匀速圆周运动，把x轴想象成时间，那么该圆周运动在y轴上的投影就是一个sin(t)的波形。相信中学生都能理解这个。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么，不同的频率模型其实就对应了不同的圆周运动速度。圆周运动的速度越快，sin(t)的波形越窄。频率的缩放有两种模式&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(a) 老式的收音机都是用磁带作为音乐介质的，当我们快放的时候，我们会感觉歌唱的声音变得怪怪的，调子很高，那是因为&quot;圆周运动&quot;的速度增倍了，每一个声音分量的sin(t)输出变成了sin(nt)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(b) 在CD/计算机上面快放或满放感觉歌手快唱或者慢唱，不会出现音调变高的现象：因为快放的时候采用了时域采样的方法，丢弃了一些波形，但是承载了信息的输出波形不会有宽窄的变化；满放时相反，时域信号填充拉长就可以了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. F变换得到的结果有负数/复数部分，有什么物理意义吗?&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;解释: F变换是个数学工具，不具有直接的物理意义，负数/复数的存在只是为了计算的完整性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3. 信号与系统这们课的基本主旨是什么?&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于通信和电子类的学生来说，很多情况下我们的工作是设计或者OSI七层模型当中的物理层技术，这种技术的复杂性首先在于你必须确立传输介质的电气特性，通常不同传输介质对于不同频率段的信号有不同的处理能力。以太网线处理基带信号，广域网光线传出高频调制信号，移动通信，2G和3G分别需要有不同的载频特性。那么这些介质(空气，电线，光纤等)对于某种频率的输入是否能够在传输了一定的距离之后得到基本不变的输入呢? 那么我们就要建立介质的频率相应数学模型。同时，知道了介质的频率特性，如何设计在它上面传输的信号才能大到理论上的最大传输速率?----这就是信号与系统这们课带领我们进入的一个世界。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然，信号与系统的应用不止这些，和香农的信息理论挂钩，它还可以用于信息处理(声音，图像)，模式识别，智能控制等领域。如果说，计算机专业的课程是数据表达的逻辑模型，那么信号与系统建立的就是更底层的，代表了某种物理意义的数学模型。数据结构的知识能解决逻辑信息的编码和纠错，而信号的知识能帮我们设计出码流的物理载体(如果接受到的信号波形是混乱的，那我依据什么来判断这个是1还是0? 逻辑上的纠错就失去了意义)。在工业控制领域，计算机的应用前提是各种数模转换，那么各种物理现象产生的连续模拟信号(温度，电阻，大小，压力，速度等) 如何被一个特定设备转换为有意义的数字信号，首先我们就要设计一个可用的数学转换模型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4. 如何设计系统?&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;设计物理上的系统函数(连续的或离散的状态)，有输入，有输出，而中间的处理过程和具体的物理实现相关，不是这们课关心的重点(电子电路设计?)。信号与系统归根到底就是为了特定的需求来设计一个系统函数。设计出系统函数的前提是把输入和输出都用函数来表示(例如sin(t))。分析的方法就是把一个复杂的信号分解为若干个简单的信号累加，具体的过程就是一大堆微积分的东西，具体的数学运算不是这门课的中心思想。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;那么系统有那些种类呢?&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(a) 按功能分类: 调制解调(信号抽样和重构)，叠加，滤波，功放，相位调整，信号时钟同步，负反馈锁相环，以及若干子系统组成的一个更为复杂的系统----你可以画出系统流程图，是不是很接近编写程序的逻辑流程图? 确实在符号的空间里它们没有区别。还有就是离散状态的数字信号处理(后续课程)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(b) 按系统类别划分，无状态系统，有限状态机，线性系统等。而物理层的连续系统函数，是一种复杂的线性系统。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;5. 最好的教材?&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;符号系统的核心是集合论，不是微积分，没有集合论构造出来的系统，实现用到的微积分便毫无意义----你甚至不知道运算了半天到底是要作什么。以计算机的观点来学习信号与系统，最好的教材之一就是&amp;lt;&amp;lt;Structure
 and Interpretation of Signals and Systems&amp;gt;&amp;gt;，作者是UC Berkeley的Edward
 A.Lee and Pravin Varaiya----先定义再实现，符合人类的思维习惯。国内的教材通篇都是数学推导，就是不肯说这些推导是为了什么目的来做的，用来得到什么，建设什么，防止什么；不去从认识论和需求上讨论，通篇都是看不出目的的方法论，本末倒置了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;第三课 抽样定理是干什么的&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.举个例子，打电话的时候，电话机发出的信号是PAM脉冲调幅，在电话线路上传的不是话音，而是话音通过信道编码转换后的脉冲序列，在收端恢复语音波形。那么对于连续的说话人语音信号，如何转化成为一些列脉冲才能保证基本不失真，可以传输呢? 很明显，我们想到的就是取样，每隔M毫秒对话音采样一次看看电信号振幅，把振幅转换为脉冲编码，传输出去，在收端按某种规则重新生成语言。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么，问题来了，每M毫秒采样一次，M多小是足够的? 在收端怎么才能恢复语言波形呢?&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于第一个问题，我们考虑，语音信号是个时间频率信号(所以对应的F变换就表示时间频率)把语音信号分解为若干个不同频率的单音混合体(周期函数的复利叶级数展开，非周期的区间函数，可以看成补齐以后的周期信号展开，效果一样)，对于最高频率的信号分量，如果抽样方式能否保证恢复这个分量，那么其他的低频率分量也就能通过抽样的方式使得信息得以保存。如果人的声音高频限制在3000Hz，那么高频分量我们看成sin(3000t)，这个sin函数要通过抽样保存信息，可以看为:
 
对于一个周期，波峰采样一次，波谷采样一次，也就是采样频率是最高频率分量的2倍(奈奎斯特抽样定理)，我们就可以通过采样信号无损的表示原始的模拟连续信号。这两个信号一一对应，互相等价。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于第二个问题，在收端，怎么从脉冲序列(梳装波形)恢复模拟的连续信号呢?
 首先，我们已经肯定了在频率域上面的脉冲序列已经包含了全部信息，但是原始信息只在某一个频率以下存在，怎么做? 
我们让输入脉冲信号I通过一个设备X，输出信号为原始的语音O，那么I(*)X=O，这里(*)表示卷积。时域的特性不好分析，那么在频率域 
F(I)*F(X)=F(O)相乘关系，这下就很明显了，只要F(X)是一个理想的，低通滤波器就可以了(在F域画出来就是一个方框)，它在时间域是一个钟型函数(由于包含时间轴的负数部分，所以实际中不存在)，做出这样的一个信号处理设备，我们就可以通过输入的脉冲序列得到几乎理想的原始的语音。在实际应用中，我们的抽样频率通常是奈奎斯特频率再多一点，3k赫兹的语音信号，抽样标准是8k赫兹。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 再举一个例子，对于数字图像，抽样定理对应于图片的分辨率----抽样密度越大，图片的分辨率越高，也就越清晰。如果我们的抽样频率不够，信息就会发生混叠----网上有一幅图片，近视眼戴眼镜看到的是爱因斯坦，摘掉眼睛看到的是梦露----因为不带眼睛，分辨率不够(抽样频率太低)，高频分量失真被混入了低频分量，才造成了一个视觉陷阱。在这里，图像的F变化，对应的是空间频率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;话说回来了，直接在信道上传原始语音信号不好吗? 模拟信号没有抗干扰能力，没有纠错能力，抽样得到的信号，有了数字特性，传输性能更佳。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;什么信号不能理想抽样? 时域有跳变，频域无穷宽，例如方波信号。如果用有限带宽的抽样信号表示它，相当于复利叶级数取了部分和，而这个部分和在恢复原始信号的时候，在不可导的点上面会有毛刺，也叫吉布斯现象。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. 为什么傅立叶想出了这么一个级数来? 这个源于西方哲学和科学的基本思想: 正交分析方法。例如研究一个立体形状，我们使用x,y,z三个互相正交的轴: 任何一个轴在其他轴上面的投影都是0。这样的话，一个物体的3视图就可以完全表达它的形状。同理，信号怎么分解和分析呢? 用互相正交的三角函数分量的无限和：这就是傅立叶的贡献。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;入门第四课 傅立叶变换的复数 小波&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;说的广义一点，&quot;复数&quot;是一个&quot;概念&quot;，不是一种客观存在。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;什么是&quot;概念&quot;? 一张纸有几个面? 两个，这里&quot;面&quot;是一个概念，一个主观对客观存在的认知，就像&quot;大&quot;和&quot;小&quot;的概念一样，只对人的意识有意义，对客观存在本身没有意义(康德: 纯粹理性的批判)。把纸条的两边转一下相连接，变成&quot;莫比乌斯圈&quot;，这个纸条就只剩下一个&quot;面&quot;了。概念是对客观世界的加工，反映到意识中的东西。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数的概念是这样被推广的: 什么数x使得x^2=-1? 实数轴显然不行，(-1)*(-1)=1。那么如果存在一个抽象空间，它既包括真实世界的实数，也能包括想象出来的x^2=-1，那么我们称这个想象空间为&quot;复数域&quot;。那么实数的运算法则就是复数域的一个特例。为什么1*(-1)=-1? +-符号在复数域里面代表方向，-1就是&quot;向后，转!&quot;这样的命令，一个1在圆周运动180度以后变成了-1，这里，直线的数轴和圆周旋转，在复数的空间里面被统一了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此，(-1)*(-1)=1可以解释为&quot;向后转&quot;+&quot;向后转&quot;=回到原地。那么复数域如何表示x^2=-1呢? 很简单，&quot;向左转&quot;，&quot;向左转&quot;两次相当于&quot;向后转&quot;。由于单轴的实数域(直线)不包含这样的元素，所以复数域必须由两个正交的数轴表示--平面。很明显，我们可以得到复数域乘法的一个特性，就是结果的绝对值为两个复数绝对值相乘，旋转的角度=两个复数的旋转角度相加。高中时代我们就学习了迪莫弗定理。为什么有这样的乘法性质? 不是因为复数域恰好具有这样的乘法性质(性质决定认识)，而是发明复数域的人就是根据这样的需求去弄出了这么一个复数域(认识决定性质)，是一种主观唯心主义的研究方法。为了构造x^2=-1，我们必须考虑把乘法看为两个元素构成的集合: 乘积和角度旋转。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为三角函数可以看为圆周运动的一种投影，所以，在复数域，三角函数和乘法运算(指数)被统一了。我们从实数域的傅立叶级数展开入手，立刻可以得到形式更简单的，复数域的，和实数域一一对应的傅立叶复数级数。因为复数域形式简单，所以研究起来方便----虽然自然界不存在复数，但是由于和实数域的级数一一对应，我们做个反映射就能得到有物理意义的结果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么傅立叶变换，那个令人难以理解的转换公式是什么含义呢? 我们可以看一下它和复数域傅立叶级数的关系。什么是微积分，就是先微分，再积分，傅立叶级数已经作了无限微分了，对应无数个离散的频率分量冲击信号的和。傅立叶变换要解决非周期信号的分析问题，想象这个非周期信号也是一个周期信号: 只是周期为无穷大，各频率分量无穷小而已(否则积分的结果就是无穷)。那么我们看到傅立叶级数，每个分量常数的求解过程，积分的区间就是从T变成了正负无穷大。而由于每个频率分量的常数无穷小，那么让每个分量都去除以f，就得到有值的数----所以周期函数的傅立叶变换对应一堆脉冲函数。同理，各个频率分量之间无限的接近，因为f很小，级数中的f，2f，3f之间几乎是挨着的，最后挨到了一起，和卷积一样，这个复数频率空间的级数求和最终可以变成一个积分式：傅立叶级数变成了傅立叶变换。注意有个概念的变化：离散的频率，每个频率都有一个&quot;权&quot;值，而连续的F域，每个频率的加权值都是无穷小(面积=0)，只有一个频率范围内的&quot;频谱&quot;才对应一定的能量积分。频率点变成了频谱的线。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此傅立叶变换求出来的是一个通常是一个连续函数，是复数频率域上面的可以画出图像的东西? 那个根号2Pai又是什么? 它只是为了保证正变换反变换回来以后，信号不变。我们可以让正变换除以2，让反变换除以Pi，怎么都行。慢点，怎么有&quot;负数&quot;的部分，还是那句话，是数轴的方向对应复数轴的旋转，或者对应三角函数的相位分量，这样说就很好理解了。有什么好处? 我们忽略相位，只研究&quot;振幅&quot;因素，就能看到实数频率域内的频率特性了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们从实数(三角函数分解)-&amp;gt;复数(e和Pi)-&amp;gt;复数变换(F)-&amp;gt;复数反变换(F-1)-&amp;gt;复数(取幅度分量)-&amp;gt; 实数，看起来很复杂，但是这个工具使得，单从实数域无法解决的频率分析问题，变得可以解决了。两者之间的关系是: 傅立叶级数中的频率幅度分量是a1-an,b1-bn，这些离散的数表示频率特性，每个数都是积分的结果。而傅立叶变换的结果是一个连续函数: 对于f域每个取值点a1-aN(N=无穷)，它的值都是原始的时域函数和一个三角函数(表示成了复数)积分的结果----这个求解和级数的表示形式是一样的。不过是把N个离散的积分式子统一为了一个通用的，连续的积分式子。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;复频域，大家都说画不出来，但是我来画一下！因为不是一个图能够表示清楚的。我用纯中文来说:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 画一个x,y轴组成的平面，以原点为中心画一个圆(r=1)。再画一条竖直线: (直线方程x=2)，把它看成是一块挡板。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 想象，有一个原子，从(1,0)点出发，沿着这个圆作逆时针匀速圆周运动。想象太阳光从x轴的复数方向射向x轴的正数方向，那么这个原子运动在挡板(x=2)上面的投影，就是一个简协震动。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. 再修改一下，x=2对应的不是一个挡板，而是一个打印机的出纸口，那么，原子运动的过程就在白纸上画下了一条连续的sin(t)曲线!&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面3条说明了什么呢? 三角函数和圆周运动是一一对应的。如果我想要sin(t+x)，或者cos(t)这种形式，我只需要让原子的起始位置改变一下就可以了：也就是级坐标的向量，半径不变，相位改变。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;傅立叶级数的实数展开形式，每一个频率分量都表示为AnCos(nt)+BnSin(nt)，我们可以证明，这个式子可以变成 sqr(An^2+Bn^2)sin(nt+x)这样的单个三角函数形式，那么：实数值对(An,Bn)，就对应了二维平面上面的一个点，相位x对应这个点的相位。实数和复数之间的一一对应关系便建立起来了，因此实数频率唯一对应某个复数频率，我们就可以用复数来方便的研究实数的运算：把三角运算变成指数和乘法加法运算。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;-------------------------------------------------------------------------&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是，F变换仍然是有限制的(输入函数的表示必须满足狄义赫立条件等)，为了更广泛的使用&quot;域&quot;变换的思想来表示一种&quot;广义&quot;的频率信息，我们就发明出了拉普拉斯变换，它的连续形式对应F变换，离散形式就成了Z变换。离散信号呢? 离散周期函数的F级数，项数有限，离散非周期函数(看为周期延拓以后仍然是离散周期函数)，离散F级数，仍然项数有限。离散的F变换，很容易理解---- 连续信号通过一个周期采样滤波器，也就是频率域和一堆脉冲相乘。时域取样对应频域周期延拓。为什么? 反过来容易理解了，时域的周期延拓对应频率域的一堆脉冲。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;两者的区别：FT[f(t)]=从负无穷到正无穷对[f(t)exp(-jwt)]积分
 LT[f(t)]=从零到正无穷对[f(t)exp(-st)]积分 (由于实际应用，通常只做单边Laplace变换，即积分从零开始) 
具体地，在Fourier积分变换中，所乘因子为exp(-jwt)，此处，-jwt显然是为一纯虚数；而在laplace变换中，所乘因子为exp(-st)，其中s为一复数：s=D+jw,jw是为虚部，相当于Fourier变换中的jwt，而D则是实部，作为衰减因子，这样就能将许多无法作Fourier变换的函数（比如exp(at),a&amp;gt;0）做域变换。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而Z变换，简单地说，就是离散信号(也可以叫做序列)的Laplace变换，可由抽样信号的Laplace变换导出。ZT[f(n)]=从n为负无穷到正无穷对[f(n)Z^(-n)]求和。Z域的物理意义:
 由于值被离散了，所以输入输出的过程和花费的物理时间已经没有了必然的关系(t只对连续信号有意义)，所以频域的考察变得及其简单起来，我们把 
(1,-1,1,-1,1,-1)这样的基本序列看成是数字频率最高的序列，他的数字频率是1Hz(数字角频率2Pi)，其他的数字序列频率都是N分之 
1Hz，频率分解的结果就是0-2Pi角频率当中的若干个值的集合，也是一堆离散的数。由于时频都是离散的，所以在做变换的时候，不需要写出冲击函数的因子&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;离散傅立叶变换到快速傅立叶变换----由于离散傅立叶变换的次数是O(N^2)，于是我们考虑把离散序列分解成两两一组进行离散傅立叶变换，变换的计算复杂度就下降到了O(NlogN)，再把计算的结果累加O(N)，这就大大降低了计算复杂度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再说一个高级话题: 小波。在实际的工程应用中，前面所说的这些变换大部分都已经被小波变换代替了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;什么是小波？先说什么是波：傅立叶级数里面的分量，sin/cos函数就是波，sin(t)/cos(t)经过幅度的放缩和频率的收紧，变成了一系列的波的求和，一致收敛于原始函数。注意傅立叶级数求和的收敛性是对于整个数轴而言的，严格的。不过前面我们说了，实际应用FFT的时候，我们只需要关注部分信号的傅立叶变换然后求出一个整体和就可以了，那么对于函数的部分分量，我们只需要保证这个用来充当砖块的&quot;波函数&quot;，在某个区间(用窗函数来滤波)内符合那几个可积分和收敛的定义就可以了，因此傅立叶变换的&quot;波&quot;因子，就可以不使用三角函数，而是使用一系列从某些基本函数构造出来的函数族，只要这个基本函数符合那些收敛和正交的条件就可以了。怎么构造这样的基本函数呢？sin(t)被加了方形窗以后，映射到频域是一堆无穷的散列脉冲，所以不能再用三角函数了。我们要得到频率域收敛性好的函数族，能覆盖频率域的低端部分。说的远一点，如果是取数字信号的小波变换，那么基础小波要保证数字角频率是最大的 2Pi。利用小波进行离频谱分析的方法，不是像傅立叶级数那样求出所有的频率分量，也不是向傅立叶变换那样看频谱特性，而是做某种滤波，看看在某种数字角频率的波峰值大概是多少。可以根据实际需要得到如干个数字序列。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们采用(0,f),(f,2f),(2f,4f)这样的倍频关系来考察函数族的频率特性，那么对应的时间波形就是倍数扩展(且包含调制---所以才有频谱搬移)的一系列函数族。频域是窗函数的基本函数，时域就是钟形函数。当然其他类型的小波，虽然频率域不是窗函数，但是仍然可用：因为小波积分求出来的变换，是一个值，例如(0,f)里包含的总能量值，(f,2f)里面包含的总能量值。所以即使频域的分割不是用长方形而是其他的图形，对于结果来说影响不大。同时，这个频率域的值，它的分辨率密度和时域小波基函数的时间分辨率是冲突的(时域紧频域宽，时域宽频域紧)，所以设计的时候受到海森堡测不准原理的制约。Jpeg2000压缩就是小波：因为时频都是局部的，变换结果是数值点而不是向量，所以，计算复杂度从FFT的O(NlgN)下降到了O(N)，性能非常好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;END&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;关注微信公众号『面包板社区』，&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;后台回复&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&quot;技术关键词&quot;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，&lt;span&gt;领取300 G&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;学习资料包&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;（&lt;/span&gt;&lt;strong&gt;已有170个技术关键词，如：&lt;/strong&gt;电源、电机、嵌入式、信号系统、模电、华为、电子学、电路、c语言...）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;扫码关注@面包板社区&lt;br/&gt;每天学点电子技术&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xML2GYBfTfloaROzlOgdT1N9uCfxklonD8rwbvbPG1BkElFX7UL3mibsbPjARWXqV0K7kpDca03klqLzPZglROQ/640?wx_fmt=jpeg&quot; data-cropx1=&quot;15.725714285714286&quot; data-cropx2=&quot;328.2742857142857&quot; data-cropy1=&quot;13.76&quot; data-cropy2=&quot;326.30857142857144&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;313&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xML2GYBfTfmxI03HZNv0qBu5CULoEEFLEOc02iacRNKywQRq9BnTkuJ7QHvQTukEwUQzSLfNicXjOrSZ5sSn2nUQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;#推荐阅读#&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;▼&lt;/span&gt;点阅读原文，下载&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;《提高篇C语言核心技术》&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>