<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>62d56bf908b707331fe0e0aafc0d3b32</guid>
<title>有赞 TCP 网络编程最佳实践</title>
<link>https://toutiao.io/k/a7bxrhs</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section class=&quot;post-content&quot;&gt;
&lt;h1 id=&quot;&quot;&gt;概述&lt;/h1&gt;

&lt;p&gt;本文是根据有赞中间件团队多年的TCP网络编程实践经验总结而来，目的是为了避免应用因各种网络异常而出现各种非预期行为，从而造成非预期的影响，影响系统稳定性与可靠性。&lt;/p&gt;

&lt;p&gt;本文不会涉及TCP的各个基础知识点，主要是总结一些TCP网络编程实践中可能碰到的一些问题，以及相应的经过实践验证的解决方案等。虽然本文档很多细节主要是针对于Linux系统，不过，大部分建议适合于所有系统。&lt;/p&gt;

&lt;p&gt;本文共总结了&lt;strong&gt;16&lt;/strong&gt;项建议，下面逐一进行介绍。&lt;/p&gt;

&lt;h1 id=&quot;1so_reuseaddr&quot;&gt;1. 服务端监听设置SO_REUSEADDR选项&lt;/h1&gt;

&lt;p&gt;当我们重启服务端程序的时候可能会碰到“address already in use”这样的报错信息，即地址已被使用，导致程序无法快速成功重启。老的进程关闭退出了，为什么还会报地址已被使用呢？&lt;/p&gt;

&lt;p&gt;我们先来理解如下两点：  &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;TCP连接主动关闭方存在持续2MSL的&lt;code&gt;TIME_WAIT&lt;/code&gt;状态；  &lt;/li&gt;
&lt;li&gt;TCP连接由是由四元组&amp;lt;本地地址，本地端口，远程地址，远程端口&amp;gt;来确定的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们先简单回顾一下TCP连接关闭过程中的&lt;code&gt;TIME_WAIT&lt;/code&gt;状态，如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/content/images/2021/05/tcp_close.png&quot; align=&quot;center&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（图片来源：&lt;a href=&quot;https://en.wikipedia.org/wiki/Transmission_Control_Protocol&quot;&gt;Wikipedia&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;TIME_WAIT存在的意义主要有两点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;维护连接状态，使TCP连接能够可靠地关闭。如果连接主动关闭端发送的最后一条ACK丢失，连接被动关闭端会重传FIN报文。因此，主动关闭方必须维持连接状态，以支持收到重传的FIN后再次发送ACK。如果没有&lt;code&gt;TIME_WAIT&lt;/code&gt;，并且最后一个ACK丢失，那么此时被动关闭端还会处于&lt;code&gt;LAST_ACK&lt;/code&gt;一段时间，并等待重传；如果此时主动关闭方又立即创建新TCP连接且恰好使用了相同的四元组，连接会创建失败，会被对端重置。  &lt;/li&gt;
&lt;li&gt;等待网络中所有此连接老的重复的、走失的报文消亡，避免此类报文对新的相同四元组的TCP连接造成干扰，因为这些报文的序号可能恰好落在新连接的接收窗口内。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;因为每个TCP报文最大存活时间为MSL，一个往返最大是2*MSL，所以&lt;code&gt;TIME_WAIT&lt;/code&gt;需要等待2MSL。&lt;/p&gt;

&lt;p&gt;当进程关闭时，进程会发起连接的主动关闭，连接最后会进入&lt;code&gt;TIME_WAIT&lt;/code&gt;状态。当新进程bind监听端口时，就会报错，因为有对应本地端口的连接还处于&lt;code&gt;TIME_WAIT&lt;/code&gt;状态。&lt;/p&gt;

&lt;p&gt;实际上，只有当新的TCP连接和老的TCP连接四元组完全一致，且老的迷走的报文序号落在新连接的接收窗口内时，才会造成干扰。为了使用&lt;code&gt;TIME_WAIT&lt;/code&gt;状态的端口，现在大部分系统的实现都做了相关改进与扩展：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;新连接SYN告知的初始序列号，要求一定要比&lt;code&gt;TIME_WAIT&lt;/code&gt;状态老连接的序列号大，可以一定程度保证不会与老连接的报文序列号重叠。&lt;/li&gt;
&lt;li&gt;开启TCP &lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc6191&quot;&gt;timestamps扩展选项&lt;/a&gt;后，新连接的时间戳要求一定要比&lt;code&gt;TIME_WAIT&lt;/code&gt;状态老连接的时间戳大，可以保证老连接的报文不会影响新连接。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此，在开启了TCP timestamps扩展选项的情况下（&lt;code&gt;net.ipv4.tcp_timestamps = 1&lt;/code&gt;），可以放心的设置&lt;code&gt;SO_REUSEADDR&lt;/code&gt;选项，支持程序快速重启。&lt;/p&gt;

&lt;p&gt;注意不要与&lt;code&gt;net.ipv4.tcp_tw_reuse&lt;/code&gt;系统参数混淆，该参数仅在客户端调用connect创建连接时才生效，可以使用&lt;code&gt;TIME_WAIT&lt;/code&gt;状态超过1秒的端口（防止最后一个ACK丢失）；而&lt;code&gt;SO_REUSEADDR&lt;/code&gt;是在bind端口时生效，一般用于服务端监听时，可以使用本地非&lt;code&gt;LISTEN&lt;/code&gt;状态的端口（另一个端口也必须设置&lt;code&gt;SO_REUSEADDR&lt;/code&gt;），不仅仅是&lt;code&gt;TIME_WAIT&lt;/code&gt;状态端口。&lt;/p&gt;

&lt;h1 id=&quot;2&quot;&gt;2. 建立并遵守应用监听端口规范&lt;/h1&gt;

&lt;p&gt;每个应用、每个通信协议要有固定统一的监听端口，便于在公司内部形成共识，降低协作成本，提升运维效率。如对于一些网络ACL控制，规范统一的端口会给运维带来极大的便利。&lt;/p&gt;

&lt;p&gt;应用监听端口不能在&lt;code&gt;net.ipv4.ip_local_port_range&lt;/code&gt;区间内，这个区间是操作系统用于本地端口号自动分配的（bind或connect时没有指定端口号），Linux系统默认值为[32768, 60999]。现在一个应用服务器实例（无论是VM还是K8S Pod等），本地不仅仅会包含应用进程自身，还可能会包括监控采集、sidecar代理等进程。如果选了&lt;code&gt;net.ipv4.ip_local_port_range&lt;/code&gt;这个范围内的端口作为监听端口，你的应用进程启动前，对应的端口很可能已经被自动分配给其他进程的TCP连接，就会导致监听端口绑定失败，从而导致进程启动失败；当然，如果已经分配的端口设置了&lt;code&gt;SO_REUSEADDR&lt;/code&gt;也不会导致你的应用监听端口绑定失败，但这些临时端口一般都不会设置&lt;code&gt;SO_REUSEADDR&lt;/code&gt;。如果确实有需求监听&lt;code&gt;net.ipv4.ip_local_port_range&lt;/code&gt;区间内的端口（如保留三方系统的默认端口），可以设置&lt;code&gt;net.ipv4.ip_local_reserved_ports&lt;/code&gt;系统参数进行预留，预留的端口不会被自动分配出去；但这样会给运维增加系统的交付难度，所以，一般不建议这样做。&lt;/p&gt;

&lt;p&gt;有赞的&lt;code&gt;net.ipv4.ip_local_port_range&lt;/code&gt;系统值设置为[9000, 65535]，并且对所有类型的应用、通信协议监听端口都进行了统一规范，监听端口都小于9000。&lt;/p&gt;

&lt;h1 id=&quot;3&quot;&gt;3. 应用服务端口与管理端口分离&lt;/h1&gt;

&lt;p&gt;服务端口即业务请求的处理端口，管理端口为框架或应用的管理请求处理端口（如服务注册上线、下线）。以Spring Boot为例，应用端口对应&lt;code&gt;server.port&lt;/code&gt;，管理端口对应&lt;code&gt;management.port&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;应用的服务端口与管理端口分离有如下意义：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;避免业务请求与管理请求互相影响，如线程池等。&lt;/li&gt;
&lt;li&gt;更好地进行权限管理、ACL控制等。管理端口一般可以控制应用的核心行为，需要进行严格的权限管理、ACL控制，比如通过防火墙仅允许特定IP访问管理端口等。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有赞线上曾经碰到过一个问题：一个Dubbo业务应用提供HTTP服务和Dubbo服务，HTTP服务端口与HTTP管理端口是同一个，该应用的一个实例因内部逻辑问题发生了死锁，造成请求阻塞超时，但这时服务注册的健康保活线程仍然正常，所以该异常服务实例还是在线的，客户端仍在发送请求到该实例。这时想将该实例进行服务注册下线操作但保留进程以便排查问题，但由于业务线程阻塞导致HTTP线程池所有线程阻塞，进而导致管理模块无线程可处理HTTP服务注册下线请求，最终无法正常下线。有赞Dubbo框架已经对应用服务端口与管理端口进行了分离，并进行了线程池隔离，避免再出现类似的问题。当然，熔断等其他机制也有助于应对个别实例异常问题，这里我们主要关注端口分离问题。&lt;/p&gt;

&lt;h1 id=&quot;4&quot;&gt;4. 建立连接设置超时时间&lt;/h1&gt;

&lt;p&gt;网络拥塞、IP不可达、握手队列满时，都可能会导致建立连接阻塞与超时，为了避免不可控的阻塞时间对应用造成难以预知的影响，建议在建立连接时设置超时时间，进行超时控制。如果没有主动进行设置，超时时间是由系统默认行为进行控制的，而系统的默认行为肯定是无法满足所有应用场景的。（注：握手队列满时，如果设置了系统参数&lt;code&gt;net.ipv4tcp_abort_on_overflow&lt;/code&gt;，连接会立刻被重置）&lt;/p&gt;

&lt;p&gt;我们看一下系统默认是如何控制连接建立超时时间的？&lt;/p&gt;

&lt;p&gt;TCP三次握手的第一个SYN报文没有收到ACK，系统会自动对SYN报文进行重试，最大重试次数由系统参数&lt;code&gt;net.ipv4.tcp_syn_retries&lt;/code&gt;控制，默认值为6。初始RTO为1s，如果一直收不到SYN ACK，依次等待1s、2s、4s、8s、16s、32s发起重传，最后一次重传等待64s后放弃，最终在127s后才会返回ETIMEOUT超时错误。&lt;/p&gt;

&lt;p&gt;建议根据整个公司的业务场景，调整&lt;code&gt;net.ipv4.tcp_syn_retries&lt;/code&gt;系统参数进行兜底。有赞将该参数设为3，即最大15s左右可返回超时错误。&lt;/p&gt;

&lt;h1 id=&quot;5&quot;&gt;5. 使用应用层心跳对连接进行健康检查&lt;/h1&gt;

&lt;p&gt;当TCP连接有异常时，我们需要尽快感知到，然后进行相应的异常处理与恢复。对于FIN或RST这种连接关闭、重置场景，应用层是可以快速感知到的。但是对于对端机器掉电、网线脱落、网络设备异常等造成的假连接，如果没有特殊措施，应用层很长时间都感知不到。&lt;/p&gt;

&lt;p&gt;提到网络异常检测，大家可能首先想到的是TCP Keepalive。系统TCP Keepalive相关的三个参数为&lt;code&gt;net.ipv4.tcp_keepalive_time&lt;/code&gt;、&lt;code&gt;net.ipv4.tcp_keepalive_intvl&lt;/code&gt;、&lt;code&gt;net.ipv4.tcp_keepalive_probes&lt;/code&gt;，默认值分别为7200s、75s、9，即如果7200s没有收到对端的数据，就开始发送TCP Keepalive报文，如果75s内，没有收到响应，会继续重试，直到重试9次都失败后，返回应用层错误信息。&lt;/p&gt;

&lt;p&gt;为什么需要实现应用层的心跳检查呢？系统的TCP Keepalive满足不了需求吗？是的，系统的TCP Keepalive只能作为一个最基本的防御方案，而满足不了高稳定性、高可靠性场景的需求。原因有如下几点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;TCP Keepalive是扩展选项，不一定所有的设备都支持；&lt;/li&gt;
&lt;li&gt;TCP Keepalive报文可能被设备特意过滤或屏蔽，如运营商设备；&lt;/li&gt;
&lt;li&gt;TCP Keepalive无法检测应用层状态，如进程阻塞、死锁、TCP缓冲区满等情况；&lt;/li&gt;
&lt;li&gt;TCP Keepalive容易与TCP重传控制冲突，从而导致失效。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于TCP状态无法反应应用层状态问题，这里稍微介绍几个场景。第一个是TCP连接成功建立，不代表对端应用感知到了该连接，因为TCP三次握手是内核中完成的，虽然连接已建立完成，但对端可能根本没有Accept；因此，一些场景仅通过TCP连接能否建立成功来判断对端应用的健康状况是不准确的，这种方案仅能探测进程是否存活。另一个是，本地TCP写操作成功，但数据可能还在本地写缓冲区中、网络链路设备中、对端读缓冲区中，并不代表对端应用读取到了数据。&lt;/p&gt;

&lt;p&gt;这里重点解释一下TCP KeepAlive与TCP重传的冲突问题。Linux系统通过&lt;code&gt;net.ipv4.tcp_retries2&lt;/code&gt;参数控制TCP的超时重传次数，即影响TCP超时时间。初始RTO为&lt;code&gt;TCP_RTO_MIN&lt;/code&gt;（200ms），RTO进行指数退让，最大RTO为&lt;code&gt;TCP_RTO_MAX&lt;/code&gt;（2min），&lt;code&gt;net.ipv4.tcp_retries2&lt;/code&gt;默认为15，大概924.6s超时。详细重传次数、RTO、超时时间关系，如下表所示。&lt;/p&gt;

&lt;table border=&quot;1&quot;&gt;  
&lt;tr&gt;  
&lt;th&gt;重传次数&lt;/th&gt;  
&lt;th&gt;RTO（毫秒）&lt;/th&gt;  
&lt;th colspan=&quot;2&quot;&gt;总超时时间&lt;/th&gt;  
&lt;/tr&gt;  
&lt;tr&gt; &lt;td&gt; 1&lt;/td&gt; &lt;td&gt;   200&lt;/td&gt; &lt;td&gt;  0.2 秒&lt;/td&gt; &lt;td&gt;0.0 分钟&lt;/td&gt;  
&lt;/tr&gt;&lt;tr&gt; &lt;td&gt; 2&lt;/td&gt; &lt;td&gt;   400&lt;/td&gt; &lt;td&gt;  0.6 秒&lt;/td&gt; &lt;td&gt;0.0 分钟&lt;/td&gt;  
&lt;/tr&gt;&lt;tr&gt; &lt;td&gt; 3&lt;/td&gt; &lt;td&gt;   800&lt;/td&gt; &lt;td&gt;  1.4 秒&lt;/td&gt; &lt;td&gt;0.0 分钟&lt;/td&gt;  
&lt;/tr&gt;&lt;tr&gt; &lt;td&gt; 4&lt;/td&gt; &lt;td&gt;  1600&lt;/td&gt; &lt;td&gt;  3.0 秒&lt;/td&gt; &lt;td&gt;0.1 分钟&lt;/td&gt;  
&lt;/tr&gt;&lt;tr&gt; &lt;td&gt; 5&lt;/td&gt; &lt;td&gt;  3200&lt;/td&gt; &lt;td&gt;  6.2 秒&lt;/td&gt; &lt;td&gt;0.1 分钟&lt;/td&gt;  
&lt;/tr&gt;&lt;tr&gt; &lt;td&gt; 6&lt;/td&gt; &lt;td&gt;  6400&lt;/td&gt; &lt;td&gt; 12.6 秒&lt;/td&gt; &lt;td&gt;0.2 分钟&lt;/td&gt;  
&lt;/tr&gt;&lt;tr&gt; &lt;td&gt; 7&lt;/td&gt; &lt;td&gt; 12800&lt;/td&gt; &lt;td&gt; 25.4 秒&lt;/td&gt; &lt;td&gt;0.4 分钟&lt;/td&gt;  
&lt;/tr&gt;&lt;tr&gt; &lt;td&gt; 8&lt;/td&gt; &lt;td&gt; 25600&lt;/td&gt; &lt;td&gt; 51.0 秒&lt;/td&gt; &lt;td&gt;0.9 分钟&lt;/td&gt;  
&lt;/tr&gt;&lt;tr&gt; &lt;td&gt; 9&lt;/td&gt; &lt;td&gt; 51200&lt;/td&gt; &lt;td&gt;102.2 秒&lt;/td&gt; &lt;td&gt;1.7 分钟&lt;/td&gt;  
&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;10&lt;/td&gt; &lt;td&gt;102400&lt;/td&gt; &lt;td&gt;204.6 秒&lt;/td&gt; &lt;td&gt;3.4 分钟&lt;/td&gt;  
&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;11&lt;/td&gt; &lt;td&gt;120000&lt;/td&gt; &lt;td&gt;324.6 秒&lt;/td&gt; &lt;td&gt;5.4 分钟&lt;/td&gt;  
&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;12&lt;/td&gt; &lt;td&gt;120000&lt;/td&gt; &lt;td&gt;444.6 秒&lt;/td&gt; &lt;td&gt;7.4 分钟&lt;/td&gt;  
&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;13&lt;/td&gt; &lt;td&gt;120000&lt;/td&gt; &lt;td&gt;564.6 秒&lt;/td&gt; &lt;td&gt;9.4 分钟&lt;/td&gt;  
&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;14&lt;/td&gt; &lt;td&gt;120000&lt;/td&gt; &lt;td&gt;684.6 秒&lt;/td&gt; &lt;td&gt;11.4 分钟&lt;/td&gt;  
&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;15&lt;/td&gt; &lt;td&gt;120000&lt;/td&gt; &lt;td&gt;804.6 秒&lt;/td&gt; &lt;td&gt;13.4 分钟&lt;/td&gt;  
&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;16&lt;/td&gt; &lt;td&gt;120000&lt;/td&gt; &lt;td&gt;924.6 秒&lt;/td&gt; &lt;td&gt;15.4 分钟&lt;/td&gt;  
&lt;/tr&gt;  
&lt;/table&gt;

&lt;p&gt;如果TCP发送缓冲区中有数据未发送成功，TCP会进行超时重传，而不会触发TCP Keepalive。也就是说，即使应用设置了很小的TCP Keepalive参数，如time=10s、interval=10s、probes=3，在&lt;code&gt;net.ipv4.tcp_retries2&lt;/code&gt;默认配置下，可能还是一直等到15min左右才能感知到网络异常。可能有的人不理解为什么Keepalive会被重传干扰，其实这里就是个优先级的问题。TCP最大重传次数的作用高于Keepalive参数的作用，未达到最大重传次数，不会向应用层报告网络错误信息。如果Keepalive不受重传影响，同样也会对关注重传的人造成干扰，比如为什么还没达到最大重传次数就放弃重传并关闭连接了？我们可以通过&lt;code&gt;netstat -ot&lt;/code&gt;或&lt;code&gt;ss -ot&lt;/code&gt;命令查看当前连接的计时器信息。&lt;/p&gt;

&lt;p&gt;建议根据实际情况调低&lt;code&gt;net.ipv4.tcp_retries2&lt;/code&gt;参数。RFC 1122建议对应的超时时间不低于100s，即至少为8，有赞系统该参数默认为10。&lt;/p&gt;

&lt;p&gt;因此，想实现一个网络健壮的应用，应用层心跳必不可少。对于&lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc7540#section-6.7&quot;&gt;HTTP2&lt;/a&gt;、&lt;a href=&quot;https://github.com/grpc/grpc/blob/master/doc/keepalive.md&quot;&gt;gRPC&lt;/a&gt;、&lt;a href=&quot;https://dubbo.apache.org/zh/docs/v2.7/dev/implementation/#%E5%8D%8F%E8%AE%AE%E5%A4%B4%E7%BA%A6%E5%AE%9A&quot;&gt;Dubbo&lt;/a&gt;等协议都支持心跳，如果是基于这些协议开发的应用，可以直接使用这些协议的特性来实现应用层心跳。&lt;/p&gt;

&lt;p&gt;实现应用层心跳需要考虑如下点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;心跳间隔不能太小也不能太大。间隔太小心可能会对轻微抖动过于敏感，造成过度反应，反而会影响稳定性，同时也有一定的性能开销；间隔太大会导致异常检测延迟比较高。可以严格地定期发送心跳，也可以一段时间内没有收到对端数据才发起心跳。建议心跳间隔为5s~20s。&lt;/li&gt;
&lt;li&gt;设置连续失败阈值，避免瞬间抖动造成误判等。建议连续失败阈值为2~5。&lt;/li&gt;
&lt;li&gt;不要使用独立的TCP连接进行心跳检查，因为不同连接的网络路径、TCP缓冲区等都不同，无法真实反映业务通信连接的真实状态。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;6&quot;&gt;6. 连接重连需要增加退让与窗口抖动&lt;/h1&gt;

&lt;p&gt;当网络异常恢复后，大量客户端可能会同时发起TCP重连及进行应用层请求，可能会造成服务端过载、网络带宽耗尽等问题，从而导致客户端连接与请求处理失败，进而客户端触发新的重试。如果没有退让与窗口抖动机制，该状况可能会一直持续下去，很难快速收敛。&lt;/p&gt;

&lt;p&gt;建议增加指数退让，如1s、2s、4s、8s...，同时必须限制最大退让时间（如64s），否则重试等待时间可能越来越大，同样导致无法快速收敛。同时，为了降低大量客户端同时建连并请求，也需要增加窗口抖动，窗口大小可以与退让等待时间保持一致，如:
nextRetryWaitTime = backOffWaitTime + rand(0.0, 1.0) * backOffWaitTime。&lt;/p&gt;

&lt;p&gt;在进行网络异常测试或演练时，需要把网络异常时间变量考虑进来，因为不同的时长，给应用带来的影响可能会完全不同。&lt;/p&gt;

&lt;h1 id=&quot;7&quot;&gt;7. 服务端需要限制最大连接数&lt;/h1&gt;

&lt;p&gt;一个服务端口，理论上能接收的最大TCP连接数是多少呢？TCP四元组中的服务端IP、服务端端口已经固定了，理论上的上限就是客户端可用IP数量*客户端可用端口数量。去除一些IP分类、端口保留等细节，理论上限就是2^32 * 2 ^16 = 2^48。&lt;/p&gt;

&lt;p&gt;当然，目前现实中肯定达不到理论上限的瓶颈。一个TCP socket所关联的主要资源有内存缓冲区、文件描述符等，因此，实际限制主要取决于系统内存大小与文件描述符数量限制。&lt;/p&gt;

&lt;p&gt;服务端限制最大连接数，主要有两个目的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;避免服务过载导致CPU、内存耗尽；&lt;/li&gt;
&lt;li&gt;避免文件描述符耗尽。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每个TCP连接的socket都占用一个FD，每个进程以及整个系统的FD数量都是有限制的。Linux系统下，通过&lt;code&gt;ulimit -n&lt;/code&gt;可以查看单个用户的进程运行打开的FD最大数量，通过&lt;code&gt;cat /proc/sys/fs/file-max&lt;/code&gt;可以查看所有进程运行打开的最大FD数量，如果不符合应用的需求，那就需要进行相应的调整。&lt;/p&gt;

&lt;p&gt;达到FD上限会有什么影响呢？首先，肯定是无法接收新TCP连接了；其次，除了TCP连接占用的FD外，你的应用肯定还有内部场景占用或需要分配新的FD，比如日志文件发生轮转创建新日志文件时，如果日志文件创建失败，对于依赖本地存储的应用（如KV、MQ等存储型应用），就导致服务不可用了。所以，要在系统限制的基础上，根据应用的特性预留一定数量的FD，而不能把所有的FD都给客户端TCP连接使用。&lt;/p&gt;

&lt;p&gt;有赞在线上压测时，一个应用就碰到过类似的一个问题。压测期间，压力比较高，导致磁盘IO压力增高，请求处理延迟增高，导致客户端超时。客户端发现超时关闭连接，创建新连接重试，但此时服务端由于IO阻塞带来的延迟并未能够及时回收连接关闭（CLOSE_WAIT）的socket以及FD，导致FD消耗越来越多，最终导致FD耗尽，新日志文件创建失败，而该应用又是存储类型应用，强依赖于日志落盘，最终导致服务不可用。&lt;/p&gt;

&lt;p&gt;除了服务端限制最大连接数外，如果应用有对应的客户端SDK，最好也在客户端SDK也做一层保护。&lt;/p&gt;

&lt;h1 id=&quot;8&quot;&gt;8. 尽量不要依赖中心化四层负载均衡器&lt;/h1&gt;

&lt;p&gt;LVS是一个经典的中心化四层负载均衡解决方案，也有各种云厂商提供的类似LVS的产品，原理大多是一致的。它们的优点这里我们就不谈了。使用该类方案可能会面临如下问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;每次应用伸缩容，需要变更后端实例列表配置，运维成本高、风险高；&lt;/li&gt;
&lt;li&gt;中心化的组件可伸缩性较差，容易触达瓶颈，如网络带宽瓶颈等；&lt;/li&gt;
&lt;li&gt;中心化的组件可用性较差，一旦负载均衡器出问题，整个服务受影响；&lt;/li&gt;
&lt;li&gt;四层健康检查对后端实例异常不敏感，无法进行应用层健康检查；&lt;/li&gt;
&lt;li&gt;负载均衡器的拆分、迁移对应用影响较大，需要应用配合更新配置、发布等，使用成本较高；&lt;/li&gt;
&lt;li&gt;负载均衡器会可能丢弃一段时间内没有通信的空闲连接，给应用带来非预期的影响；&lt;/li&gt;
&lt;li&gt;客户端访问服务端需经过负载均衡器中转，可能对RT有一定影响。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;建议通过分布式的动态服务注册与发现以及客户端负载均衡来替代中心化负载均衡方案，如微服务架构中的服务注册、服务发现、负载均衡等解决方案。&lt;/p&gt;

&lt;p&gt;在不得不使用中心化负载均衡器的场景下，也需要注意以下问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;注意选择合适的负载均衡算法，避免长连接分布不均衡。比如，如果选择了轮询负载均衡算法，正常情况下各个后端实例的连接数是均衡的，但当某个实例重启后，该实例的连接断开后，客户端会发起重连，重连就大概率转移其他实例上，导致最近启动的实例连接数较少，最早启动的实例连接数较多。可以考虑最少连接数负载均衡，长连接增加TTL限制等。&lt;/li&gt;
&lt;li&gt;注意空闲超时，超时后负载均衡器可能不会给两端发送Close或Reset信号，从而导致无法通信的假连接，如果客户端与服务端双方都没有心跳、空闲超时等，假连接会一直存在，占用系统资源；应用层或TCP层的健康检查周期需要小于负载均衡器的空闲超时。&lt;/li&gt;
&lt;li&gt;注意摘除后端实例时保证平滑，如果直接移除后端实例，可能不会给两端发送Close或Reset信号，从而导致无法通信的假连接，且客户端和服务端无法及时感知到。一般先将实例权重调整为0，保证新连接不再分配到该实例，然后等待已有的连接释放，最后再完全移除后端实例。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有赞线上环境曾多次碰到过LVS引起的相关问题，也正在研发分布式的四层代理。&lt;/p&gt;

&lt;h1 id=&quot;9close_wait&quot;&gt;9. 警惕大量CLOSE_WAIT&lt;/h1&gt;

&lt;p&gt;先介绍曾经碰到的一个问题。线上环境告警提示有服务器发生较高的TCP重传，经抓包分析重传包都是FIN包，且目标IP已不存在。查看连接状态发现大量&lt;code&gt;CLOSE_WAIT&lt;/code&gt;状态连接。该问题并不是一直持续，时有时无。经过对应用日志与应用代码分析，发现某个场景应用读取到EOF时，未关闭本地socket。进一步分析，原因是客户端应用是K8S部署的，发布后，旧实例下线，作为客户端发起主动关闭连接，并且旧实例的IP很快会被回收；服务端未关闭的socket，在几分钟后GC时（Go语言应用）才会进行socket回收关闭操作，但此时，客户端IP已不存在，因此，最后一个FIN报文不断重传，一直到超过最大重传次数，从而问题恢复。等到再次有客户端应用发布时，又会出现。该问题对于没有GC机制的编程语言开发的应用，可能会造成更严重的后果，socket不断泄露，导致FD耗尽、内存耗尽等问题。&lt;/p&gt;

&lt;p&gt;因此，一定要警惕大量CLOSE_WAIT状态连接的出现，这种情况出现时，首先要排除一些相关代码。同时，开发过程中，一定要注意正确关闭socket，通过一些语言特性进行兜底处理，如Go语言的&lt;code&gt;defer&lt;/code&gt;，Java语言的&lt;code&gt;try...catch...finally&lt;/code&gt;，C++语言的&lt;code&gt;RAII&lt;/code&gt;机制等。&lt;/p&gt;

&lt;h1 id=&quot;10ttl&quot;&gt;10. 合理设置长连接TTL&lt;/h1&gt;

&lt;p&gt;长连接减少了像短连接频繁建立连接的开销，包括三次握手开销、慢启动开销等。但也有一定的弊端：长连接的持续时间过长，可能会导致一些负载均衡问题，以及其他一些长时间难以收敛的问题。比如LVS场景，随着后端应用实例的重启，对于一些负载均衡算法（如轮询），会导致最新启动的实例连接数最少，最早启动的实例连接数最多。对于一些客户端负载均衡方案，当只需要连接后端集群中的一个节点时，长连接也会出现类似的问题，比如类似Etcd watch的场景。有赞内部有很多使用Etcd的场景，早期运维每次变更Etcd集群的时候都特别谨慎，避免连接的不均衡。&lt;/p&gt;

&lt;p&gt;有赞中间件团队规定任何应用的TCP长连接TTL不能超过2小时。当然，这已经是一个很保守的时长了，建议根据应用场景，合理设置TTL。&lt;/p&gt;

&lt;h1 id=&quot;11dns&quot;&gt;11. 通过域名访问服务需定期解析DNS&lt;/h1&gt;

&lt;p&gt;DNS是一种服务发现机制，应用通过配置DNS访问其他服务，本意是为了解决其他服务实例IP变动带来的影响，但如果处理不当还是会有问题。通过域名访问其他服务时，需要定时更新域名解析，如果解析有更新，则需要重新建立连接，避免后端实例迁移（IP有变化）时导致难以收敛。千万不要只在应用启动的时候进行一次域名解析，这种情况在DNS变更后想实现快速收敛，只能重启或发布所有相关应用了。一些语言内置了DNS相关的实现，需要注意对应的一些参数以及行为是否符合预期。&lt;/p&gt;

&lt;p&gt;另外，某些应用提供了获取最新集群成员列表的接口，如Etcd、Redis，这样即使客户端启动的时候只进行一次域名解析，只要定期从服务端同步服务集群的成员列表也能支持服务端集群成员的动态变化。&lt;/p&gt;

&lt;h1 id=&quot;12&quot;&gt;12. 降低网络读写系统调用次数&lt;/h1&gt;

&lt;p&gt;当我们调用read/write系统函数从socket读写数据时，每次调用都至少进行两次用户态与内核态的上下文切换，成本比较高。针对该问题，一般有两种优化思路：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用读写缓冲区；读数据时，先一次性从socket读入缓冲区，然后再按需要分次从缓冲区读取；写数据时，先分次写入缓冲区，缓冲区满时或所有写操作完成时，一次性写入socket。&lt;/li&gt;
&lt;li&gt;当不方便将数据合并到连续内存时，使用readv/writev一次性读取/写入多段内存数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于批量写操作还有一个优点，就是可以避免&lt;a href=&quot;https://en.wikipedia.org/wiki/Nagle%27s_algorithm&quot;&gt;Nagle算法&lt;/a&gt;带来的延迟（一般也不建议开启Nagle算法）。假如当前写缓冲区中没有数据，我们先通过write写4个字节，这时TCP协议栈将其发送出去，然后再通过write写96个字节，这时，由于前面发送了一个报文，还没有收到ACK，并且当前可发送数据未达到MSS，Nagle算法不允许继续发送报文，必须等到前一个报文的ACK回来才能继续发送数据，大大降低了吞吐量并且提高了延迟。如果接收端开启了&lt;a href=&quot;https://en.wikipedia.org/wiki/TCP_delayed_acknowledgment&quot;&gt;延迟ACK&lt;/a&gt;，影响更大。&lt;/p&gt;

&lt;p&gt;因此，应该尽量批量读写网络数据，以提升性能。&lt;/p&gt;

&lt;h1 id=&quot;13tcp&quot;&gt;13. 谨慎设置TCP缓冲区大小&lt;/h1&gt;

&lt;p&gt;一般来说我们不需要更改TCP默认缓冲区大小，如果我们确实有需求设置，也需要谨慎考虑与评估。&lt;/p&gt;

&lt;p&gt;TCP缓冲区大小设置为多少合适呢？我们知道，TCP 的传输速度，受制于发送窗口与接收窗口大小，以及网络传输能力。其中，两个窗口由缓冲区大小决定，如果缓冲区大小与网络传输能力匹配，那么缓冲区的利用率就是最高的。&lt;/p&gt;

&lt;p&gt;带宽时延积（缩写为 BDP，&lt;a href=&quot;https://en.wikipedia.org/wiki/Bandwidth-delay_product&quot;&gt;Bandwidth-delay Product&lt;/a&gt;）是用来描述网络传输能力的。如最大带宽是 100MB/s、网络时延是 10ms 时，客户端到服务端之间的网络一共可以存放 100MB/s * 0.01s = 1MB 的字节，这个 1MB 是带宽与时延的乘积，也就是带宽时延积。这 1MB 字节存在于飞行中的 TCP 报文，它们就在网络线路、路由器等网络设备上。如果飞行报文超过了 1MB，就一定会让网络过载，最终导致丢包。&lt;/p&gt;

&lt;p&gt;由于发送缓冲区决定了发送窗口的上限，而发送窗口又决定了已发送但未确认的飞行报文的上限，因此，发送缓冲区不能超过带宽时延积，因为超出的部分没有办法用于有效的网络传输，且飞行字节大于带宽时延积还会导致丢包，从而触发网络拥塞避免；而且，缓冲区也不能小于带宽时延积，否则无法发挥出高速网络的价值。&lt;/p&gt;

&lt;p&gt;总结而言：缓冲区太小，会降低TCP吞吐量，无法高效利用网络带宽，导致通信延迟升高；缓冲区太大，会导致TCP连接内存占用高以及受限于带宽时延积的瓶颈，从而造成内存浪费。如果缓冲区过小，如2K，还可能会导致&lt;a href=&quot;https://en.wikipedia.org/wiki/TCP_congestion_control#Fast_retransmit&quot;&gt;快速重传&lt;/a&gt;无法生效，因为未确认的报文可能最多只有2个，不会出现3个重复的ACK。&lt;/p&gt;

&lt;p&gt;Linux系统是可以根据系统状态自动调节缓冲区大小的，相关参数由&lt;code&gt;net.ipv4.tcp_wmem&lt;/code&gt;和&lt;code&gt;net.ipv4.tcp_rmem&lt;/code&gt;控制，参数是一个3元组&lt;min default=&quot;&quot; max=&quot;&quot;&gt;，即最大值、初始默认值、最大值。但如果在 socket 上直接设置 SO&lt;em&gt;SNDBUF 或者 SO&lt;/em&gt;RCVBUF，这样会关闭缓冲区的系统动态调整功能，这样操作前务必要进行充分的评估。 &lt;br/&gt;
因此，除非非常明确自己的需求，以及进行充分的评估与验证，否则，不要轻易设置TCP缓冲区大小。&lt;/min&gt;&lt;/p&gt;

&lt;h1 id=&quot;14&quot;&gt;14. 网络相关参数支持灵活配置&lt;/h1&gt;

&lt;p&gt;当应用可能有多种部署环境、部署场景时，需要根据使用场景、网络环境等因素，调整合适的网络相关参数。LAN和WAN的网络状况差别很大，会涉及到诸多参数的调整。&lt;/p&gt;

&lt;p&gt;比如对于有赞的服务代理组件&lt;a href=&quot;https://tech.youzan.com/service-meshzai-you-zan-de-shi-jian-yu-fa-zhan/&quot;&gt;Tether&lt;/a&gt;，既有数据中心内的sidecar部署场景，又有跨公网的网关部署场景，这时就需要按需调整对应的参数，否则难以适应不同的网络环境。如连接超时、读写超时、健康检查超时、健康检查失败阈值等都应该支持灵活配置。&lt;/p&gt;

&lt;h1 id=&quot;15&quot;&gt;15. 合理设置连接池大小&lt;/h1&gt;

&lt;p&gt;对于不同类型的协议，连接池的设计也不同。我们将协议是否支持连接多路复用划分为两类：非多路复用协议和多路复用协议。非多路复用协议，一个连接发送请求后，必须等待响应返回后，该连接才能发送新的请求，如HTTP1.1、Redis等；多路复用协议，支持同一个连接同时发送多个请求，如HTTP2、gRPC、Dubbo等。&lt;/p&gt;

&lt;p&gt;我们先看一下非多路复用协议如何设置连接池大小。连接池涉及到的参数一般有：最小连接数、最大连接数、最大空闲时间、连接获取超时时间、连接获取超时重试次数等。应用与连接池主要交互逻辑如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/content/images/2021/05/conn_pool-1.png&quot; align=&quot;center&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们主要讨论最小连接数和最大连接数。之所以不是固定连接数，是因为流量有高峰、有低谷；固定连接数太小，流量高峰期容易导致请求等待时间过长；固定连接数太大，流量低谷期容易造成资源浪费。因此，最小连接数对应的就是流量低谷期连接数多少为合适，最大连接数对应的就是流量高峰期连接数多少为合适，也就是连接数与流量大小是相关的。除了流量大小，还需要考虑请求RT，即每个请求占用连接的时间。所需要的连接数其实就是请求并发数，这里我们可以利用著名的利特尔法则（&lt;a href=&quot;https://en.wikipedia.org/wiki/Little%27s_law&quot;&gt;Little&#x27;s law&lt;/a&gt;）来计算，&lt;em&gt;L=λW&lt;/em&gt;，在该场景即：并发数 = 请求QPS * 请求RT。比如流量低谷期请求QPS为100，请求RT为0.05s，则并发数为5，所需连接数为5；流量高峰期请求QPS为500，请求RT为0.1s，则并发数为50，所需连接数为50。这类问题其实与&lt;a href=&quot;https://en.wikipedia.org/wiki/Queueing_theory&quot;&gt;排队论&lt;/a&gt;相关，不过我们这里不做过多讨论，如果有更复杂的需求场景，可以参考更多排队论相关资料。&lt;/p&gt;

&lt;p&gt;接下来我们继续看一下多路复用协议如何设置连接池大小。连接池涉及到的参数一般有：最小连接数、最大连接数、单连接并发请求数高水位、单连接并发请求数低水位。当单连接并发请求数高于高水位时，如果连接池未达到最大连接数，进行连接池扩容，创建连接；当单连接并发请求数低于低水位时，如果连接池未达到最小连接数，进行连接池缩容，释放连接（释放过程需要做到平滑）。由于每个请求不独占连接，请求是可以选择任意连接的，所以这里也面临负载均衡的问题，需要尽可能的确保每个连接上的处理中的请求数接近平均值。一般使用最少请求数负载均衡，但最少请求数负载均衡时间复杂度可能比较高，最简单的实现需要扫描整个连接池。我们可以使用其近似的优化实现，随机选择两个连接，选择Pending请求数少的连接；为了更加近似最少请求，可以选择3个、5个，甚至更多个连接，取其中Pending请求数最少的连接。&lt;/p&gt;

&lt;h1 id=&quot;16&quot;&gt;16. 完善网络指标监控&lt;/h1&gt;

&lt;p&gt;需要对各个关键网络指标进行监控与告警，包括但不限于：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;TCP连接建立失败数&lt;/li&gt;
&lt;li&gt;TCP报文重传率&lt;/li&gt;
&lt;li&gt;TCP各个状态连接数（尤其是&lt;code&gt;ESTABLISHED&lt;/code&gt;、&lt;code&gt;TIME_WAIT&lt;/code&gt;、&lt;code&gt;CLOSE_WAIT&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;TCP主动关闭连接数&lt;/li&gt;
&lt;li&gt;TCP被动关闭连接数&lt;/li&gt;
&lt;li&gt;连接健康检查失败数&lt;/li&gt;
&lt;li&gt;系统及进程FD使用数&lt;/li&gt;
&lt;li&gt;连接池大小 &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果能尽早发现这些指标的异常，那么就可以尽快发现问题，从而降低问题影响面。&lt;/p&gt;

&lt;h1 id=&quot;&quot;&gt;总结&lt;/h1&gt;

&lt;p&gt;本文根据有赞TCP网络编程实践经验总结了&lt;strong&gt;16&lt;/strong&gt;项建议，希望能够在TCP网络编程方面帮助大家提升应用的健壮性、可靠性，减少线上问题与故障。&lt;/p&gt;

&lt;h1 id=&quot;&quot;&gt;参考资料&lt;/h1&gt;



&lt;p&gt;`&lt;/p&gt;
                    &lt;p class=&quot;break-line&quot;&gt;欢迎关注我们的公众号&lt;/p&gt;
                    &lt;img src=&quot;https://tech.youzan.com/static_image/coder_qrcode.png&quot;/&gt;
&lt;/section&gt;

&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e2586e331331cbe96dd5c877e0c4d200</guid>
<title>多年老 C++ 程序员在静态数组这里翻船了</title>
<link>https://toutiao.io/k/xrkhat1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg5ODI2MTEwNg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/RNfZGZNpL1ApdamSCLJUhObeTmib5J7icNXWMw4fdEgv9HqGu5kc787JKMyVEJB65TFNO7l5b1UTKeMZHnao2T8A/0?wx_fmt=png&quot; data-nickname=&quot;cpp加油站&quot; data-alias=&quot;xy13640954449&quot; data-signature=&quot;专注分享linux下c/c++开发经验，做有质量和温度的公众号&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;事情的起因&lt;/span&gt;&lt;br/&gt;&lt;/h4&gt;&lt;p&gt;事情是这样子滴，有一次我在代码评审的时候，发现有同事想使用运行时才能够获取到的值，去改变一个静态数组的元素个数，我当时就很诧异，因为我心里知道这样是不可行的，静态数组的元素个数在编译时就需要是固定不变的，一般只能是常量或者宏定义，否则编译就不能通过。&lt;/p&gt;&lt;p&gt;但是当时我提出来以后，把原因说了，包括写出这个代码的人和另外一位同事都没理解，弄得我有点怀疑自己了，难道是我搞错了？&lt;/p&gt;&lt;p&gt;我左思右想，最后我写了下面的代码来证实一下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt; &lt;span&gt;std&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;get&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; size = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;please input a num:&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;cin&lt;/span&gt; &amp;gt;&amp;gt; size;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; size;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; size = &lt;span&gt;1000&lt;/span&gt;;&lt;br/&gt;    size = get();&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; arr[size] = {&lt;span&gt;0&lt;/span&gt;};&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;arr&#x27;s size is &quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;sizeof&lt;/span&gt;(arr)/&lt;span&gt;sizeof&lt;/span&gt;(arr[&lt;span&gt;0&lt;/span&gt;]) &amp;lt;&amp;lt; &lt;span&gt;endl&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我打心底认为，这段程序肯定是编译不通过的，但是结果打脸了。编译后执行显示如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;please&lt;/span&gt; input a num:&lt;span&gt;10000&lt;/span&gt;&lt;br/&gt;arr&lt;span&gt;&#x27;s size is 10000&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不仅编译通过了，而且数组大小还在运行时修改了，可是我明明定义的是一个静态数组呀，而且就算我这里不给size赋初始值1000，结果也还是一样的。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;探索的过程&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;简直是见了鬼了，我把代码看了又看，认为是我代码写错了，但是这么简单的一段代码，我不可能写错呀。后来我突然想到，会不会是有了新的语法？&lt;/p&gt;&lt;p&gt;因为我现在的gcc编译器，大家都知道是7.1.0的版本，基本上连c++17都能支持了，我就试了一下之前保留的gcc4.1.2的版本，结果报错啦，如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;test.cpp: In function ‘int main()’:&lt;br/&gt;test.cpp:15: 错误：可变大小的对象 ‘arr’ 不能被初始化&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以很显然，我的记忆没有错误，之前静态数组的元素个数它就必须是个不可变的，否则编译就会出错。&lt;/p&gt;&lt;p&gt;然后我又看了下生产上用的编译器，是gcc4.8.5的版本，它也是支持c++11的，难道这个新的特性是c++11支持的吗？然后我去cppreference把c++11的新特性从头到尾翻了一遍，并没有对这个修改有说明，并且网上搜索，所有的文章都在说c和c++想使用变长数组，就必须要使用动态数组，我一度陷入了僵局，但是我并没有死心，继续探索。&lt;/p&gt;&lt;p&gt;后来我忽然想到，假如不是c++的新特性，那是不是c语言的新特性呢，想到这里，我把代码做了如下修改：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;get&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; size = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;please input a num:&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;scanf&lt;/span&gt;(&lt;span&gt;&quot;%d&quot;&lt;/span&gt;, &amp;amp;size);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; size;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; size = &lt;span&gt;1000&lt;/span&gt;;&lt;br/&gt;    size = get();&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; arr[size] = {&lt;span&gt;0&lt;/span&gt;};&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;arr&#x27;s size is %d\n&quot;&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;(arr)/&lt;span&gt;sizeof&lt;/span&gt;(arr[&lt;span&gt;0&lt;/span&gt;]));&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后直接使用gcc命令编译，而没有使用g++，结果跟上面那段代码是一模一样的，到这里我大致上就明白了，这就是c语言里面的新特性。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;欣喜的找到了结果&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;最后我在cppreference这个链接里面看到了对于c99的说明：&lt;/p&gt;&lt;blockquote&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;新特性：&lt;em&gt;Bool 、 long long 、 stdint.h 、 inttypes.h 、 restrict 、复合字面量、&lt;strong&gt;变长度数组&lt;/strong&gt;、伸缩数组成员、指派初始化器、 fenv.h 、变参数宏、复数、 &lt;strong&gt;func&lt;/strong&gt; 、十六进制浮点格式（ %a ）、 lconv 的货币格式化、 isblank 、窄与宽字符串字面量的连接、枚举的尾逗号、类函数宏的空参数、 STDC&lt;/em&gt;* pragma 、 va_copy 、 tmpnam 的空返回、 setvbuf 中的空指针、 printf 的 hh 与 ll 长度指定符、 snprintf 、 _Exit 、 tgmath.h 、仿 POSIX strftime 说明符&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;来自 C++ ：inline 、声明与代码混合、 for 循环的 init 子句中的声明、 &lt;code&gt;&lt;strong&gt;//&lt;/strong&gt;&lt;/code&gt; 注释、源代码中的通用字符名&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;移除隐式函数声明和隐式 int&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;p&gt;看看，是不是明确说明了新特性是变长度数组，并且是c语言99年的标准，有点灯下黑了，以后如果再看到有人说c语言和c++的静态数组都只支持固定长度，要想变长就必须要使用malloc和new，就可以唾弃一下啦。&lt;/p&gt;&lt;p&gt;另外有一点需要注意的是，如果我们的场景真的是需要使用固定大小的数组，那么最好使用常量和宏定义，再不然，就使用c++11里面新增加的array。&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg5ODI2MTEwNg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/RNfZGZNpL1ApdamSCLJUhObeTmib5J7icNXWMw4fdEgv9HqGu5kc787JKMyVEJB65TFNO7l5b1UTKeMZHnao2T8A/0?wx_fmt=png&quot; data-nickname=&quot;cpp加油站&quot; data-alias=&quot;xy13640954449&quot; data-signature=&quot;专注分享linux下c/c++开发经验，做有质量和温度的公众号&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;好了，有关我和静态数组的故事就介绍到这里了，因为没有留言功能，如果有问题需要咨询的，可以通过公众号菜单【联系作者】获取作者联系方式进行咨询哈。&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>54ffd743b3c8368d91e1fa853d9a2473</guid>
<title>比特币白皮书：价值的组合与分割</title>
<link>https://toutiao.io/k/5a35q81</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;136101&quot;&gt;&lt;section data-style-type=&quot;1&quot; data-tools=&quot;新媒体排版&quot; data-id=&quot;8359&quot;&gt;&lt;section data-css=&quot;background-color:#fcf8e3;border-color:#faebcc;border-radius: 4px;color:#8a6d3b;margin:10px auto;padding: 15px&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上一章，我们讨论了白皮书中的&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzIxNzM2NDY1MQ==&amp;amp;mid=2247483966&amp;amp;idx=1&amp;amp;sn=2d17a757dda67c8df09561a7ef1f4079&amp;amp;chksm=97fba3faa08c2aec5c4160040d6936a0aedef7cc5a67b642f5f253e2c6846e419f183cc3fc7c&amp;amp;token=246838499&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;简化的支付确认(Simplified Payment Verification)&lt;/a&gt;，这一章，我们来介绍比特币白皮书中的价值的组合与分割(Combining and Splitting Value)。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;
&lt;/section&gt;&lt;p&gt;&lt;span&gt; &lt;span&gt;原文：&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;136101&quot;&gt;&lt;section data-style-type=&quot;1&quot; data-tools=&quot;新媒体排版&quot; data-id=&quot;8359&quot;&gt;&lt;section data-css=&quot;background-color:#fcf8e3;border-color:#faebcc;border-radius: 4px;color:#8a6d3b;margin:10px auto;padding: 15px&quot;&gt;&lt;p&gt;&lt;span&gt;Although it would be possible to handle coins individually, it would be unwieldy to make a
separate transaction for every cent in a transfer. To allow value to be split and combined,
transactions contain multiple inputs and outputs. Normally there will be either a single input
from a larger previous transaction or multiple inputs combining smaller amounts, and at most two
outputs: one for the payment, and one returning the change, if any, back to the sender. &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6210191082802548&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTPibibpfB754ZwPd3iabF8UGBfO3O3uaWMEXZRjKYpc7GfTq7wicEQYGDiaTuNX0My6c5uiaDred6agicEaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;628&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;It should be noted that fan-out, where a transaction depends on several transactions, and those
transactions depend on many more, is not a problem here. There is never the need to extract a
complete standalone copy of a transaction&#x27;s history.&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;
&lt;/section&gt;&lt;p&gt;&lt;span&gt; 翻译：&lt;/span&gt;&lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;136101&quot;&gt;&lt;section data-style-type=&quot;1&quot; data-tools=&quot;新媒体排版&quot; data-id=&quot;8359&quot;&gt;&lt;section data-css=&quot;background-color:#fcf8e3;border-color:#faebcc;border-radius: 4px;color:#8a6d3b;margin:10px auto;padding: 15px&quot;&gt;&lt;p&gt;&lt;span&gt;虽然可以单个单个地对电子货币进行处理，但是对于每一枚电子货币单独发起一次交易将是一种笨拙的办法。为了使得价值易于组合与分割，交易被设计为可以纳入多个输入和输出。一般而言是某次价值较大的前次交易构成的单一输入，或者由某几个价值较小的前次交易共同构成的并行输入，但是输出最多只有两个：一个用于支付，另一个用于找零（如有）。 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8986928104575164&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTPibibpfB754ZwPd3iabF8UGBfKW31gicTOcKickg88ZKm5eGJBJvib8DKTjpKLc4QtENicY4QRepP507lOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;612&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;需要指出的是，当一笔交易依赖于之前的多笔交易时，这些交易又各自依赖于多笔交易，但这并不存在任何问题。因为这个工作机制并不需要展开检验之前发生的所有交易历史。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;在这一部分中描述文字不多，也比较好理解，它其实是讲述了比特币网络中UTXO模型&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;148422&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt; 01 &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;  &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;绕不开的UTXO&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;UTXO(UnspentTransactionOutput)，指的是未花费的交易输出，我们可以理解成未被花费的状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在传统的交易中，账户余额是由中心化机构记录在数据库中，数据库中记录着不同的账户的余额，而在&lt;strong&gt;&lt;span&gt;UTXO&lt;/span&gt;模型&lt;/strong&gt;中记录的则是&lt;strong&gt;交易的过程&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如在银行，A账户有10元，B账户有20元，A转给B 3元，A还剩下7元，B还剩下23元，这里显示的是结果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3092436974789916&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNiagicCt2AXFoib1GX2mzEcxYvGvTStTnJ3zsNjWkXNCHgDnnCGMcmufWV6Z4JRgibbI2ozT2M2xnEcA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1190&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而在UTXO模型中是怎样体现交易过程的呢？&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如A有10个BTC，B有20个BTC，A要转给B 3个BTC，过程是这样的：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1）A会转3个BTC给B&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2）A会&lt;span&gt;转&lt;/span&gt;7个BTC给A&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;是的，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;我没有写错&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，A不但给B转了，A也给自己转了一次。其中，A最开始的10个BTC，就是&lt;span&gt;未花费的交易输出(因为他未花费，所以才能向B转账)。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9781021897810219&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNiagicCt2AXFoib1GX2mzEcxYk9ibXrgbn9H6SDSFFnCIe2JEwDLZcUZvl01gS4ea6pm0pfZY8bxAjXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;274&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为UTXO是比特币交易里&lt;strong&gt;不可拆分的基本单元结构(转账时必须全部花费，多余的转给自己)&lt;/strong&gt;，一个交易中可以有多个输入，代表比特币来源，是前序交易的输出UTXO；可以有多个输出，代表比特币去向，&lt;span&gt;是后序交易的输入UTXO&lt;/span&gt;。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.56&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNiagicCt2AXFoib1GX2mzEcxYISfHGicTSLUOMLJXxFCtrZahm17af2VDibzQGtXhuViacOPcibEpZDsqbw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们在&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzIxNzM2NDY1MQ==&amp;amp;mid=2247483928&amp;amp;idx=1&amp;amp;sn=e9052211a73bd821bb0d26017d5cbf2b&amp;amp;chksm=97fba3dca08c2aca7c4f93f4b159ce0a86ec11aa1f1f6815a6dfd503c204d7a7ba854c3de44b&amp;amp;token=246838499&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《比特币白皮书-激励》&lt;/span&gt;&lt;/a&gt;&lt;span&gt;一章中得知，比特币来源于&lt;strong&gt;币基交易&lt;/strong&gt;，币基交易就像铸币厂一样生产着比特币，并将比特币流入市场。可以说币基交易是所有比特币最初的&lt;span&gt;“未花费输出”UTXO&lt;/span&gt;，每笔交易的输入都是来自于上笔关联交易中所得到的“未花费输出”UTXO，而交易输出则意味着比特币的新的所有者拥有了这笔比特币，并且没有花费。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;相关的交易形成了一个链条，&lt;strong&gt;&lt;span&gt;链头&lt;/span&gt;是币基交易&lt;/strong&gt;，所有的比特币都来源于前N笔交易的UTXO，它们就像接龙一样，一个接着一个，完成了比特币的流转，而&lt;strong&gt;链尾一定是当前未花费的交易输出UTXO&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1967821782178218&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNiagicCt2AXFoib1GX2mzEcxYq3hJSLxEw3zvxY1iaguicr0K7vF7EkfrnXrwjYiayXIbEAVVSMsIbGqdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1616&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;148422&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt; 02 &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;  继续挖坑&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/section&gt;&lt;p&gt;&lt;span&gt;我相信，一定有人和我有着同样的疑问：UTXO模型设计的如此反人类，中本聪为什么要把简单的账户体系设计的这么复杂？ &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我曾在某论坛上看到，有人怀疑中本聪不是地球人，因为他的很多设计不符合人类的可读性，可能在他自己的星球这样做是合情合理的。不过，比特币网络从运行之初到现在，没有出现任何问题，说明，UTXO模型在比特币网络上是成功的。&lt;br/&gt;由于这一部分在白皮书中没有过多的描述UTXO，因此我会在后面的章节详细的讲解UTXO，敬请期待。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;期待您的点评、分享、关注、在看，您的鼓励是我写作的最大动力！&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;136101&quot;&gt;&lt;section data-style-type=&quot;1&quot; data-tools=&quot;新媒体排版&quot; data-id=&quot;8359&quot;&gt;&lt;section data-css=&quot;background-color:#fcf8e3;border-color:#faebcc;border-radius: 4px;color:#8a6d3b;margin:10px auto;padding: 15px&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;这一章&lt;/span&gt;，我们讨论了白皮书中的&lt;span&gt;价值的组合与分割(Combining and Splitting Value)&lt;/span&gt;，下一章，我们来介绍比特币白皮书中的隐私(&lt;span&gt;Privacy&lt;/span&gt;)。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考文献：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;《Bitcoin: A Peer-to-Peer Electronic Cash System》 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://bitcoin.org/bitcoin.pdf&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;《比特币白皮书：一种点对点的电子现金系统》&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f0a7902417f53f109740723f92409604</guid>
<title>Go 凭什么不支持三元运算符？</title>
<link>https://toutiao.io/k/pt0q5vx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是煎鱼。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个很多其他语言工程师转 Go 语言的时间节点，这就难免不论一番比较。其中一个经典的运算上的就是 “三元运算符”：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4231578947368421&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4iaLoqX7Cp17TQxQoFTpy8O00pcccIsAX9egvSvp65icA1gKpNLsYsT6z7ic7JjEWm5Uvib9gnEux4YFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;950&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么 Go 语言不支持三元运算符，Go 不支持三元运算符就是设计的不好，是历史在开倒车吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天就由煎鱼来和大家一起摸索为什么。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;三元运算符是什么&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;三元运算符，在典型的数学意义上，或者从解析器的角度来看，是一个需要三个参数的运算符。而我们日常中，最常见的是二元运算符：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;x + y&lt;br/&gt;x / y&lt;br/&gt;x * y&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一元运算符：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;-a&lt;br/&gt;~b&lt;br/&gt;!c&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以及今天的男主角 “三元运算符”。在 C/C++ 等多种语言中，我们可以根据条件声明和初始化变量的习惯来选择性使用三元条件运算符：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; index = val &amp;gt; &lt;span&gt;0&lt;/span&gt; ? val : -val&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Go 使用三元运算符&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想在 Go 语言里也使用三元运算符时，发现居然没有...想要实现与上面相同的代码段的方式似乎只能：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; index &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; val &amp;gt; &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;    index = val&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    index = -val&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看上去十分的冗余，不够简洁。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;为什么 Go 没有三元运算符&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么 Go 没有 &lt;code&gt;?:&lt;/code&gt; 操作符，没有的话，官方推荐的方式是怎么样的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 Go FAQ 我们可以得知：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3413566739606127&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4iaLoqX7Cp17TQxQoFTpy8O0gNQ6eO8iawGYcficfzEIfMTZeYexzAxicr0lSxTmx2dapOKjS0iashcmiaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1828&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 官方就是推荐我们使用前面提到的方式来替代，并且明确了如下态度：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Go 中没有 &lt;code&gt;?:&lt;/code&gt; 的原因是语言的设计者看到这个操作经常被用来创建难以理解的复杂表达式。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在替代方案上，if-else 形式虽然较长，但无疑是更清晰的。一门语言只需要一个条件控制流结构。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整体来讲，Go 语言的设计者是为了考虑&lt;strong&gt;可读性&lt;/strong&gt;拒绝了实现三元运算符，&quot;less is more.&quot; 也是标榜台词了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;社区争议&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 语言的一些点与众不同，基本是大家皆知的。无论是 if err != nil，又或是本次的三元运算符，要大家用 if-else 替代：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; expr {&lt;br/&gt;    n = trueVal&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    n = falseVal&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;反对和同意&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;反对&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此有社区小伙伴给出了反对，基本分为如下几类：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;认为 if-else 也有以类似情况能被滥用，设计者的理由不够充分，认为是 “借口”。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;认为三元运算符的 “丑陋” 问题，是开发者的编码问题，而不是语言问题。三元在各种语言中很常见，它们是正常的，Go 语言也应该要有。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;认为用 if-else 替代三元运算符也很麻烦，让开发者多读了 3-4 行和额外的缩进级别。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;同意&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;认可这个决策的也有不少，为此给出了大量的真实工程案例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般来讲，我们用三元运算符是希望这么用：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;cond ? true_value : false_value&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可能见过这么用：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;cond ? value_a + value_b : value_c * value_d&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还见过这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;(((cond_a ? val_one) : cond_b) ? val_two) : val_three&lt;br/&gt;&lt;br/&gt;cond_a ? (val_one : (cond_b ? (val_two : val_three)))&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还能嵌套三元运算符：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;int a = cond_a ? val_one :&lt;br/&gt;    cond_b ? val_two :&lt;br/&gt;    cond_c ? val_three : val_four;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也能出现可读性更差的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;void rgb_to_lightness_(&lt;br/&gt;  const double re, const double gr, const double bl, double &amp;amp;li)&lt;br/&gt;{&lt;br/&gt;  li=((re &amp;lt; gr) ? ((gr &amp;lt; bl) ? bl : gr) : ((re &amp;lt; bl) ? bl : re) +&lt;br/&gt;                            (gr &amp;lt; re)&lt;br/&gt;                          ? ((bl &amp;lt; gr) ? bl : gr)&lt;br/&gt;                          : ((bl &amp;lt; re) ? bl : re)) / 2.0;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说白了就是真实的代码工程中，大家见到过大量三元运算符滥用的场景，纷纷给出了大量的难理解的例子，让大家困扰不堪。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这篇文章中，首先针对 “三元运算符” 做了基本的介绍。紧接着根据 Go 语言不支持三元的态度进行了说明，且面向社区的争议我们分为了正反方面的基本诠释。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上一个简单的 &lt;code&gt;?:&lt;/code&gt; 既整洁又实用，但是没有很好又高效的办法方法可以防止丑陋的嵌套，也就是排除可读性的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在真实的业务工程中，常常能看到一个三元运算符，&lt;strong&gt;一开始只是很简单。后面嵌套越加越深，逻辑越写越复杂，从而带来了许多维护上的问题&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给大家抛出如下问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;你认为 Go 语言是否要有三元运算符呢？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果要有，复杂嵌套的三元运算符又如何考虑呢？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;欢迎大家在评论区留言和交流 ：）&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;参考&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;What is the idiomatic Go equivalent of C&#x27;s ternary operator?&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;What is the reasoning behind Go not having a ternary conditional operator?&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Should Go have a Ternary Operator? Or was it left out intentionally?&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;We don&#x27;t need a ternary operator&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUxMDI4MDc1NA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4iac2xQZIq5icSiaTepuae8zLIUMiaxibbUM8ic735ewo6e89GRtjGbUBlgNYibwCjAicglQcvz6dCQ6yTKOw/0?wx_fmt=png&quot; data-nickname=&quot;脑子进煎鱼了&quot; data-alias=&quot;eddycjy&quot; data-signature=&quot;分享计算机基础、Go 语言、微服务架构和系统设计；著有图书《Go 语言编程之旅》。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;关注煎鱼，吸取他的知识 👆&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.07106598984771574&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/486RHs1WbcgGib6o96dHbvGUGGwPicd8wusUGH1cXR29tM4bO0lNzialzkQhvU6m5ZUdaKibmcF2OQayjMe9Bia6iaXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;394&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;你好，我是煎鱼。高一折腾过前端，参加过国赛拿了奖，大学搞过 PHP。现在整 Go，在公司负责微服务架构等相关工作推进和研发。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;从大学开始靠自己赚生活费和学费，到出版 Go 畅销书《Go 语言编程之旅》，再到获得 GOP（Go 领域最有观点专家）荣誉，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxMDI4MDc1NA==&amp;amp;mid=2247483854&amp;amp;idx=1&amp;amp;sn=ec422fbf4d846975f2930ddeb5e81373&amp;amp;chksm=f9041493ce739d85a4b987eece14da627206cdad798f645cc770868312e4a22b6df24804f186&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;点击蓝字查看我的出书之路&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;点击蓝字查看我的出书之路&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;日常分享高质量文章，输出 Go 面试、工作经验、架构设计，&lt;span&gt;加微信拉读者交流群，记得点赞！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>97ef15b62e7bb34b05a16e20fdb12f84</guid>
<title>要将 RocketMQ 中台化，有点小激动</title>
<link>https://toutiao.io/k/wxygtif</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3529480&quot; data-style-type=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3356876&quot; data-style-type=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzIwMDY0Nzk2Mw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/WRLYshvT39ykfC4Jy6mnxuibX6vJOmVCNF49BAQXbX3dKVmHVjpF89LmQhvdd6GbaQAbwrKSeaMu3Q41SnmOpxA/0?wx_fmt=png&quot; data-nickname=&quot;猿天地&quot; data-alias=&quot;cxytiandi&quot; data-signature=&quot;猿天地由《Spring Cloud微服务-全栈技术与案例解析》, 《Spring Cloud微服务 入门 实战与进阶》作者尹吉欢创建。 资深Java技术专家和微服务技术专家，在Spring Cloud和微服务方面有丰富的经验。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3335002&quot; data-style-type=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;本文字数：&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;4223&lt;/strong&gt;&lt;/span&gt;字&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;预计阅读时间：&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;13&lt;/strong&gt;&lt;/span&gt;分钟&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一、RocketMQ简介&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;RocketMQ是一个高可用、高性能、高可靠的分布式消息队列，相对于kafka更适合处理业务系统之间的消息。&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;它具有很多特性，例如：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;发布订阅&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;顺序、事务、定时消息&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;消息堆积、重试，回溯等等&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;它通过&lt;strong&gt;同步刷盘&lt;/strong&gt;和&lt;strong&gt;同步双写&lt;/strong&gt;等技术手段来实现高可靠，保证如下情况消息不丢：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;可恢复性故障：broker或OS crash等&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;不可恢复性故障：磁盘损坏等&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;它采用多项技术优化来满足性能要求：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;顺序IO&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;PageCache和mmap&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;内存预热和锁定&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;异步提交和刷盘&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;堆外内存缓冲等等&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所以，它的本质决定的其架构一定是复杂的，参考RocketMQ官方架构图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.415158371040724&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qMicvibdvl7p0SJow0NBbJD1dCJibMdeGHzTPlvHG9a4687r8XBAvff8vwRfBSdM7Hr1liawGaHFIxz9hmlHlfzPnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;884&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里不再介绍各个组件的含义，可以参考RocketMQ架构设计。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;RocketMQ经过阿里多年双十一的检验，其稳定性不言而喻。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可作为搜狐视频的消息中台，还需要很长一段路要走，为什么这么说呢？&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;二、运维之痛&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;早在2014年我们就引入了RocketMQ作为消息中间件，其附带了基本的命令行工具。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但是命令行运维此等庞然大物会让人感到力不从心，好在社区提供了一个web控制台：RocketMQ-Console。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在初期，简单的控制台已经能满足基本的需求。但是随着各个业务逐渐接入，需求也纷至沓来。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们在RocketMQ-Console的修修补补已经无法满足了，主要体现在如下几点：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;从业务方的角度：&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;偏重运维，一般业务用户不关心集群的数据和状态，无法聚焦。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;使用起来繁琐，且直接操作集群，易误操作。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;没有监控预警功能。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;无法满足业务用户的需求，包括但不限于：&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;一些隐性问题无法解决。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;从管理员维度：&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;无用户概念，任何人都能直接操作集群，易误操作且比较危险。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;无集群管理功能，日常更新或机器替换需要手动部署，非常耗时、麻烦且易出错。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;无相关数据统计，监控，预警等，往往有问题不能及时发现。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;另外，RocketMQ有一些潜在约定、使用规范、最佳实践、bug或优化等等，用文档说明也无济于事。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所以与其写文档不如将经验和实践转换为产品，能够更好的服务于业务及运维集群，于是MQCloud应运而生。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;三、MQCloud诞生&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;先看一下MQCloud的定位：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.8294930875576036&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qMicvibdvl7p0SJow0NBbJD1dCJibMdeGHzJFlGqCxk4nQ1cKeibhNibdFyG8wa51nu3m5qQPJE5Ac7K6ZocroiaiaIow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;434&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;它是集客户端SDK，监控预警，集群运维于一体的一站式服务平台。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MQCloud的系统架构如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5965417867435159&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qMicvibdvl7p0SJow0NBbJD1dCJibMdeGHz2lib5kWiaGRYoU20pZ9GR609a6TmEpTNOBicP0By7zfKjjNib1R6mfjNyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;694&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下面来分别说明一下MQCloud如何解决上面提到的痛点。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;业务端和运维端分离，使业务用户只聚焦于业务数据。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了实现这个目的，引入了用户，资源两大维度。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;针对用户和资源加以控制，使不同的用户只聚焦于自己的数据。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4650145772594752&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qMicvibdvl7p0SJow0NBbJD1dCJibMdeGHzC6kfL8emhO1Q2bPd2PQK5YMIJIUInftribaIDYUyuJpFORdEMVz6woQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;686&quot;/&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;/&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;对于生产者来说，他关心的是topic配置，消息的发送数据，谁在消费等等问题，这样只对他展示相应的数据即可；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;对于消费者来说，只关心消费状况，有没有堆积，消费失败等情况；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;对于管理员来说，可以进行部署，监控，统一配置，审批等日常运维；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;清晰明了的操作&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;通过对不同角色展示不同的视图，使用户可以进行的操作一目了然。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;规范和安全&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了保障集群操作的安全性和规范性，所有的操作都会以申请单的形式进入后台审批系统，管理员来进行相关审批，安全性大大提升。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;多维的数据统计和监控预警&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;MQCloud核心功能之一就是&lt;strong&gt;监控&lt;/strong&gt;，要想做监控，必须先做统计，为了更好的知道RocketMQ集群的运行状况，MQCloud做了大量的统计工作，主要包括如下几项：&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;每分钟topic的生产流量：用于绘制topic生产流量图及监控预警。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;每分钟消费者流量：用于绘制消费流量图及监控预警。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;每10分钟topic生产流量：用于按照流量展示topic排序。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;每分钟broker生产、消费流量：用于绘制broker生产消费流量图。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;每分钟broker集群生产、消费流量：用于绘制broker集群的生产流量图。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;每分钟生产者百分位耗时、异常统计：以ip维度绘制每个生产者的耗时流量图及监控预警。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;机器的cpu，内存，io，网络流量，网络连接等统计：用于服务器的状况图和监控预警。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;下面来分别介绍每项统计是如何收集的：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;每分钟topic的生产流量&lt;/span&gt;&lt;span&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;此数据来自于RocketMQ broker端BrokerStatsManager，其提供了统计功能，统计项如下：&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;TOPIC_PUT_NUMS：某topic消息生产条数，向某个topic写入消息成功才算&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;写入成功包括四种状态：PUT_OK，FLUSH_DISK_TIMEOUT，FLUSH_SLAVE_TIMEOUT，SLAVE_NOT_AVAILABLE&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;TOPIC_PUT_SIZE：某topic消息生产大小，向某个topic写入消息成功才算&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;RocketMQ实现的统计逻辑较为精巧，这里做简单描述，首先介绍几个对象：&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;StatsItemSet主要字段及方法如下：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;ConcurrentMap&amp;lt;String/* statsKey */, StatsItem&amp;gt; statsItemTable; // statsKey&amp;lt;-&amp;gt;StatsItem&lt;br/&gt;// 针对某个数据项进行记录&lt;br/&gt;public void addValue(final String statsKey, final int incValue, final int incTimes) {&lt;br/&gt;    StatsItem statsItem = this.getAndCreateStatsItem(statsKey);&lt;br/&gt;    statsItem.getValue().addAndGet(incValue);&lt;br/&gt;    statsItem.getTimes().addAndGet(incTimes);&lt;br/&gt;}&lt;br/&gt;// 获取并创建StatsItem&lt;br/&gt;public StatsItem getAndCreateStatsItem(final String statsKey) {&lt;br/&gt;    StatsItem statsItem = this.statsItemTable.get(statsKey);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (null == statsItem) {&lt;br/&gt;        statsItem = new StatsItem(this.statsName, statsKey);&lt;br/&gt;        this.statsItemTable.put(statsKey, statsItem);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; statsItem;&lt;br/&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;StatsItem主要字段及方法如下：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;AtomicLong value; // 统计数据：比如消息条数，消息大小&lt;br/&gt;AtomicLong &lt;span&gt;times&lt;/span&gt;; // 次数&lt;br/&gt;LinkedList&amp;lt;CallSnapshot&amp;gt; csListMinute; // 每分钟快照数据&lt;br/&gt;LinkedList&amp;lt;CallSnapshot&amp;gt; csListHour; // 每小时快照数据&lt;br/&gt;LinkedList&amp;lt;CallSnapshot&amp;gt; csListDay; // 每天快照数据&lt;br/&gt;// 分钟采样&lt;br/&gt;public void &lt;span&gt;samplingInSeconds&lt;/span&gt;() {&lt;br/&gt;    synchronized (csListMinute) {&lt;br/&gt;        csListMinute.add(new CallSnapshot(System.currentTimeMillis(), times.get(), value.get()));&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (csListMinute.size() &amp;gt; 7) {&lt;br/&gt;            csListMinute.removeFirst();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;// 小时采样&lt;br/&gt;public void &lt;span&gt;samplingInMinutes&lt;/span&gt;() {&lt;br/&gt;  // ...代码省略&lt;br/&gt;}&lt;br/&gt;// 天采样&lt;br/&gt;public void &lt;span&gt;samplingInHour&lt;/span&gt;() {&lt;br/&gt;  // ...代码省略&lt;br/&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;CallSnapshot主要字段如下：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;long &lt;span&gt;times&lt;/span&gt;; // 次数快照&lt;br/&gt;long value; // 统计数据快照&lt;br/&gt;long timestamp; //快照时间戳&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;上面三个对象如何配合进行数据统计呢？举个例子，比如统计topic名字为test_topic的消息生产大小：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;只要进行类似如下调用即可：&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;StatsItemSet.addValue(&lt;span&gt;&quot;test_topic&quot;&lt;/span&gt;, 123125123, 1)&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;即表示发送了1次消息到test_topic，消息大小为123125123。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;那如何进行数据采样呢？StatsItemSet内置了定时任务，比如其每10秒调用一次StatsItem.samplingInSeconds()。这样StatsItem就会持有60秒的数据，类似如下结构：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.8214285714285714&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qMicvibdvl7p0SJow0NBbJD1dCJibMdeGHzKRIOibrLJDo0L1qNArl0KgnQcfZojMwb4fwFIP6qG4nlNZN7joqIyuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;224&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;那么，最后一个10秒的快照 - 第一个10秒的快照 = 当前60秒的数据，根据时间戳差值可以得到耗时。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;类似，小时数据每10分钟进行一次快照，类似如下结构：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.8340807174887892&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qMicvibdvl7p0SJow0NBbJD1dCJibMdeGHza5XeafpKbYK8mH17tOnMv9I2WQqfGOleEbDwI9KBwHUCkwa1m15Sjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;223&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;天数据每1小时进行一次快照，类似如下结构：&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.88&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qMicvibdvl7p0SJow0NBbJD1dCJibMdeGHzzdT5MZQBR202tBZ3IoIJteFPo7ibGfiaeSrDH4d5eYgzwbzicNFicOXcIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;225&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;MQCloud每分钟遍历查询集群下所有broker来查询RocketMQ统计好的分钟数据，然后进行存储。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;每分钟消费者流量&lt;/span&gt;&lt;span&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;与每分钟topic的生产流量一样，也采用RocketMQ统计好的数据。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;每10分钟topic生产流量&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;采用数据库已经统计好的每分钟topic流量进行累加，统计出10分钟流量。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;每分钟broker生产、消费流量&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;由于统计1.每分钟topic的生产流量和2.每分钟消费者流量时是跟broker交互获取的，所以知道broker ip，故直接按照broker维度存储一份数据即可。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;每分钟broker集群生产、消费流量&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;采用4.每分钟broker生产、消费流量数据，按照集群求和即可。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;每分钟生产者百分位耗时、异常统计&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;由于RocketMQ并没有提供生产者的流量统计（&lt;em&gt;只提供了topic，但是并不知道每个生产者的情况&lt;/em&gt;），所以MQCloud实现了对生产者数据进行统计（&lt;em&gt;通过RocketMQ的回调钩子实现&lt;/em&gt;）:&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5135135135135135&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qMicvibdvl7p0SJow0NBbJD1dCJibMdeGHzUQGQOffrRmSxvz3a0CibTRph80dg4Rz6J7TjVuBrRY3l9h4HD95DuFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;370&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;主要统计如下信息：&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;客户端ip-&amp;gt;broker ip&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;发送消息耗时&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;消息数量&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;发送异常&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;统计完成后，定时发送到MQCloud进行存储，并做实时监控和展示。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;关于统计部分有一点说明，一般耗时统计有最大，最小和平均值，而通常99%(即99%的请求耗时都低于此数值)的请求的耗时情况才能反映真实响应情况。99%请求耗时统计最大的问题是如何控制内存占用，因为需要对某段时间内所有的耗时做排序后才能统计出这段时间的99%的耗时状况。而对于流式数据做这样的统计是有一些算法和数据结构的，例如t-digest，但是MQCloud采用了非精确的但是较为简单的分段统计的方法，具体如下：&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;创建一个按照最大耗时预哈希的时间跨度不同的&lt;strong&gt;耗时分段数组&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;优点：此种分段方法占用内存是固定的，比如最大耗时如果为3500ms，那么只需要空间大小为96的数组即可&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;缺点：分段精度需要提前设定好，且不可更改&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;第一段：耗时范围0ms~10ms，时间跨度为1ms。&lt;/span&gt;&lt;/p&gt;&lt;figure/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3888888888888889&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qMicvibdvl7p0SJow0NBbJD1dCJibMdeGHzZcatctS2UfVONfOOEfUf797wnDcEiaVLjds8Rh9WxsAZ6xXPvNFhaiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;288&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;第二组：耗时范围11ms~100ms，时间跨度5ms。&lt;/span&gt;&lt;/p&gt;&lt;figure/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.1958762886597938&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qMicvibdvl7p0SJow0NBbJD1dCJibMdeGHzR2yvhwWUW16ZpS9S5icMM4RKM8yNnIia95u1eoR51YnBwW7027tsYeDg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;582&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;第三组：耗时范围101ms~3500ms，时间跨度50ms。&lt;/span&gt;&lt;/p&gt;&lt;figure/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.19420783645655879&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qMicvibdvl7p0SJow0NBbJD1dCJibMdeGHzhHyAA22ZQp7XvSyMa084hrsYt4QdjXpiaMDG9962mot1HFSkvlicXxmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;587&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;优点：此种分段方法占用内存是固定的，比如最大耗时如果为3500ms，那么只需要空间大小为96的数组即可&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;缺点：分段精度需要提前设定好，且不可更&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;针对上面的分段数组，创建一个大小对应的AtomicLong的&lt;strong&gt;计数数组&lt;/strong&gt;，支持并发统计：&lt;/span&gt;&lt;/p&gt;&lt;figure/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.1035031847133758&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qMicvibdvl7p0SJow0NBbJD1dCJibMdeGHzl9OjoRB8w3YrqzEMUC6ZxBQVCvcdRYVWVo0kfFaJu37WDflvqHZE9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;628&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;耗时统计时，计算耗时对应的&lt;strong&gt;耗时分段数组&lt;/strong&gt;下标，然后调用&lt;strong&gt;计数数组&lt;/strong&gt;进行统计即可，参考下图：&lt;/span&gt;&lt;/p&gt;&lt;figure/&gt;&lt;p&gt;&lt;span&gt;这样，从&lt;strong&gt;计数数组&lt;/strong&gt;就可以得到实时耗时统计，类似如下：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.47393364928909953&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qMicvibdvl7p0SJow0NBbJD1dCJibMdeGHzOehickUaVOONbZwAicVNUQibxfqo9gwnCMRvJswPIJWfdkjxCQxibaibzfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;633&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;例如某次耗时为18ms，首先找到它所属的区间，即归属于[16~20]ms之间，对应的数组下标为12。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;根据第一步找到的数组下标12，获取对应的计数数组下标12。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;获取对应的计数器进行+1操作，即表示18ms发生了一次调用。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;这样，从&lt;strong&gt;计数数组&lt;/strong&gt;就可以得到实时耗时统计，类似如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.22869955156950672&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qMicvibdvl7p0SJow0NBbJD1dCJibMdeGHzRvSS8OscNM7zQ5ZW4piciavazNhmP2APqEBaUmw1jicSia5ToxqicNibO1Kg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;669&quot;/&gt;&lt;/p&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;然后定时采样任务会每分钟对&lt;strong&gt;计数数组&lt;/strong&gt;进行快照，产生如下&lt;strong&gt;耗时数据&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;&lt;figure/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.15970149253731344&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qMicvibdvl7p0SJow0NBbJD1dCJibMdeGHzLfbnGbKAmfMlDaNwmiayz8SVfbqNtb5OicN9icYY3lhKHkEodia7v2AWzQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;670&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;由于上面的&lt;strong&gt;耗时数据&lt;/strong&gt;天然就是排好序的，可以很容易计算99%、90%、平均耗时等数据了。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;另外提一点，由于RocketMQ 4.4.0新增的trace功能也使用hook来实现，与MQCloud的统计有冲突，MQCloud已经做了兼容。&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;em&gt;Trace和统计是两种维度，trace反映的是消息从生产-&amp;gt;存储-&amp;gt;消费的流程，而MQCloud做的是针对生产者状况的统计，有了这些统计数据，才可以做到生产耗时情况展示，生产异常情况预警等功能。&lt;/em&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;机器统计&lt;/span&gt;&lt;span&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于集群状况收集主要采用了将nmon自动放置到/tmp目录，定时采用ssh连接到机器执行nmon命令，解析返回的数据，然后进行存储。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面这些工作就为监控和预警奠定了坚实的数据基础。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;单独定制的客户端&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7945205479452054&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qMicvibdvl7p0ciasIFmiba0qb9GMVqy7UJjbqd2KYtPpWAOeZdeExszsCe7EqkTRMH3TvToplbTuAwFxJoT3oyXxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;365&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;针对客户端的一些需求，mq-client在rocketmq-client的基础上进行了开发定制：&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;多集群支持&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;MQCloud储存了生产者、消费者和集群的关系，通过路由适配，客户端可以自动路由到目标集群上，使客户端对多集群透明。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;trace&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过搭建单独的trace集群和定制客户端，使trace数据能够发往独立的集群，防止影响主集群。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;序列化&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过集成不同的序列化机制，配合MQCloud，客户端无需关心序列化问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前支持的序列化为protobuf和json，并且通过类型检测支持在线修改序列化方式。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;流控&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过提供令牌桶和漏桶限流机制，自动开启流控机制，防止消息洪峰冲垮业务端。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;隔离降级&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用hystrix提供隔离降级策略，使业务端在broker故障时可以避免拖累。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;埋点监控&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过对客户端数据进行统计，收集，在MQCloud里进行监控，使客户端任何风吹草动都能及时得知。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;规范问题&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过编码保障，使某些约定，规范和最佳实践得以实现。包括但不限于：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;命名规范&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;消费组全局唯一，防止重复导致消费问题&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;重试消息跳过&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;安全关闭等等&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;更完善的重试机制&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;自动化运维&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;部署&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;手动部署一台broker实例没什么问题，但是当实例变多时，手动部署极易出错且耗时耗力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;MQCloud提供了一套自动化部署机制，并支持配置模板功能，支持一键部署。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;机器运维&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;MQCloud提供了一整套机器的运维机制，包括上下线，机器状况收集、监控、预警等等，大大提升了生产力。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;安全性加固&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;一、开启管理员权限&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;RocketMQ从4.4.0开始支持ACL，但是默认没有开启，也就是&lt;strong&gt;任何人使用管理工具或API就可以直接操纵线上集群&lt;/strong&gt;。但是开启ACL对现有业务影响太大，针对这种情况MQCloud进行专门定制。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;借鉴RocketMQ ACL机制，只针对RocketMQ管理员操作加固权限校验：&lt;/span&gt;&lt;/p&gt;&lt;figure/&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;2.4474885844748857&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qMicvibdvl7p0ciasIFmiba0qb9GMVqy7UJjC9CzOuQMEu46jn26NgMCaptAEmmZzcgqaG3Dn5k3UW2j19mth7MgCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;219&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;并且支持自定义和热加载管理员请求码，使得非法操作RocketMQ集群成为不可能，安全性大大提升。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;二、broker通信加固&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;broker同步数据代码由于没有校验，存在安全隐患，只要连接master监听的slave通信端口，发送数据大于8个字节，就可能导致同步偏移量错误，代码如下：&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;if&lt;/span&gt; ((this.byteBufferRead.position() - this.processPostion) &amp;gt;= 8) {&lt;br/&gt;  int pos = this.byteBufferRead.position() - (this.byteBufferRead.position() % 8);&lt;br/&gt;  long readOffset = this.byteBufferRead.getLong(pos - 8);&lt;br/&gt;  this.processPostion = pos;&lt;br/&gt;  HAConnection.this.slaveAckOffset = readOffset;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (HAConnection.this.slaveRequestOffset &amp;lt; 0) {&lt;br/&gt;      HAConnection.this.slaveRequestOffset = readOffset;&lt;br/&gt;      log.info(&lt;span&gt;&quot;slave[&quot;&lt;/span&gt; + HAConnection.this.clientAddr + &lt;span&gt;&quot;] request offset &quot;&lt;/span&gt; + readOffset);&lt;br/&gt;  }&lt;br/&gt;  HAConnection.this.haService.notifyTransferSome(HAConnection.this.slaveAckOffset);&lt;br/&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;MQCloud通过验证数据首包的策略，保障了通信的安全性。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;目前MQCloud运维规模如下：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;服务器：50台+&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;集群：5个+&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;topic：700个+&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;生产消费消息量/日：4亿条+&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;生产消费消息大小/日：400G+&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;MQCloud在充分考虑和吸收实际业务的需求后，以各个角色聚焦为核心，以全面监控为目标，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以满足各业务端需求为己任，在不断地发展和完善。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在MQCloud逐渐成熟之后，秉承着服务于社区和吸收更多经验的理念，我们开放了源代码。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;四、开源之路&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;开放源代码说不难也不难，说难也难。为什么这么说？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不难就是因为代码已经有了，只是换个仓库而已。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;而难点就是需要进行抽象设计，剥离不能开源的代码（内部模块，代码，地址等等）。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;经过设计和拆分，MQCloud于18年开源了，从第一个版本release到现在已经过去两年了，&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;期间随着更新迭代大大小小一共release了20多个版本。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其中不但包含功能更新、bug修复、wiki说明等，而且每个大版本都经过详细的测试和内部的运行。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;之后很多小伙伴跃跃欲试，来试用它，并提出一些建议和意见，我们根据反馈来进一步完善它。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们将一直遵循我们的目标，坚定的走自己的开源之路：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;为业务提供可监控，可预警，可满足其各种需求的稳定的MQ服务。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;积累MQ领域经验，将经验转化为产品，更好的服务业务。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;后台回复 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;学习资料&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;span&gt;领取学习视频&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-mpa-template-id=&quot;112&quot; data-mpa-category=&quot;quote&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.511002444987775&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WRLYshvT39zWmaics1nAAwT4NCD77uDcf6vcXE1DAHybibTY0V3XDmf4YX1q9qYibIwz9xmRVTkEvTjP87gaKEZrQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;818&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如有收获，点个在看，诚挚感谢&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>