<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>66b6f89cb243de9f9900eb88ed52dcd9</guid>
<title>趣谈IO多路复用的本质</title>
<link>https://toutiao.io/k/j4nqhbc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p id=&quot;js_tags&quot; class=&quot;article-tag__list single-tag__wrp js_single js_wx_tap_highlight wx_tap_card&quot; data-len=&quot;1&quot; role=&quot;link&quot; aria-labelledby=&quot;js_article-tag-card__left js_a11y_comma js_article-tag-card__right&quot;&gt;
                                            
                                                                                    &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__left&quot; class=&quot;article-tag-card__left&quot;&gt;
                                    &lt;span class=&quot;article-tag-card__title&quot;&gt;收录于话题&lt;/span&gt;
                                    &lt;span class=&quot;article-tag__item-wrp no-active js_tag&quot; data-url=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUzNjAxODg4MQ==&amp;amp;action=getalbum&amp;amp;album_id=2155317684974993409#wechat_redirect&quot; data-tag_id=&quot;&quot; data-album_id=&quot;2155317684974993409&quot; data-tag_source=&quot;4&quot;&gt;
                                        &lt;span class=&quot;article-tag__item&quot;&gt;#网络通信&lt;/span&gt;
                                    &lt;/span&gt;
                                &lt;/span&gt;
                                &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__right&quot; class=&quot;article-tag-card__right&quot;&gt;15个&lt;/span&gt;
                                                                                        &lt;/p&gt;

                
                                
                
                

                
                                                                

                
                                


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486564&amp;amp;idx=1&amp;amp;sn=07ae2b4f11ceedb029f6351e3d67c2dc&amp;amp;chksm=fafde6cacd8a6fdc9f5b0ce668bcc7b57655f3cb3c427152ae70cf9f96bb6a6b778689e74dc4&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《轻松搞懂5种IO模型》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《轻松搞懂5种IO模型》&lt;/a&gt;中，我发起了一个投票。&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;vote_area&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;答案是【同步IO多路复用】。目前，60%的朋友答对了。原因这里解释一下。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;同步和异步的概念&lt;/span&gt;区别&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;同步：线程自己去获取结果。(一个线程)&lt;/p&gt;&lt;p&gt;异步：线程自己不去获取结果，而由其他线程送结果。(至少两个线程)&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;异步执行如下图所示，除非不需要知道结果，否则一般会有一个回调方法。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6081632653061224&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlibwAicyibKwptvaTrLpel9o7xt7uXTkFdFoPwoZdMWodV4Mic1JwZFDZo26aS8tKQUYaeJSN2eHcY9Pw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;490&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;IO多路复用的本质&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为了彻底理解IO多路复用是同步还是异步，咱们探究一下IO多路复用的本质。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;I/O多路复用，复用的IO监听等待这条路。实际上就是用select/poll/epoll监听多个io对象，当io对象有变化（有数据）的时候就通知用户进程。好处就是单个进程可以处理多个socket。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;select/poll/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于每一个socket，一般都设置成为non-blocking，但是，整个用户的process其实是一直被阻塞的。只不过process是被select这个函数阻塞，而不是被socket IO给阻塞。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7582644628099173&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlibwAicyibKwptvaTrLpel9o7x60ehaqKgCXiciadN6g65vhRgJRnwyv1BU2cLzMiaDbricyZbwxnnuDjBcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;484&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;I/O多路复用的流程如上图所示：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;（1）当用户进程调用了select，那么整个进程会被阻塞；&lt;/p&gt;&lt;p&gt;（2）而同时，内核会“监视”所有select负责的socket；&lt;/p&gt;&lt;p&gt;（3）当任何一个socket中的数据准备好了，select就会返回；&lt;/p&gt;&lt;p&gt;（4）这个时候用户进程再调用read/accept/write操作，做一些数据从内核拷贝到用户进程这样的事情。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486330&amp;amp;idx=1&amp;amp;sn=e85e201059c1c5575481e03531b06212&amp;amp;chksm=fafde1d4cd8a68c235ef3cbed83bf0b6ac3a80052c0a492d8c2a217006cf4fa530f2f74f01c3&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;文件描述符&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;文件描述符&lt;/a&gt;（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;事实上，I/O 多路复用有时候性能比同步阻塞IO还更差一些。因为这里需要使用两个系统调用(select 和 recvfrom)，而同步阻塞IO只调用了一个系统调用(recvfrom)。但是，用select的优势在于它可以同时处理多个连接。所以，如果处理的连接数不是很高的话，可能延迟还更大。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;打个比方：行军打仗讲究粮草先行。诸葛亮比较牛，他打仗只带少量粮草，其他靠敌军送。这天他又派了暗探去查看敌军粮草的守卫情况。如果敌人守备松懈，则趁机偷粮。如果这个暗探只偷一袋粮食，那效率最高的是不是他看到敌军守备松懈就直接进去偷粮（同步阻塞IO）？但是他要偷的是十万大军的粮食，那他就要先回去汇报一声：“守备松懈啦”。然后百人小分队一起去把粮草偷出来(I/O 多路复用)。当然啦，以诸葛亮的一贯作风而言，最后他还得放一把火。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;暗探在同步阻塞模式下，打探敌情也是他，偷粮也是他。在诸葛亮团队中，暗探在打探敌情时最终暗探是第一个获取到结果的。暗探在偷粮时也是第一个自己知道结果的。（同步）&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;暗探在I/O 多路复用模式下，打探敌情也是他，偷粮是百人小分队。在诸葛亮团队中，暗探在打探敌情时最终执行者暗探是第一个获取到结果的。百人小分队在偷粮时也是百人小分队自己先知道结果的。（同步）&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;综上，IO多路复用是同步的。&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fa52abf8e53395559098ffea71ed99e1</guid>
<title>基于.NET 制作一个气象站 IoT 应用</title>
<link>https://toutiao.io/k/8ajh0b4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;点击“&lt;strong&gt;阅读原文&lt;/strong&gt;”获得最佳阅读体验。&lt;/p&gt;&lt;p&gt;和单片机不同，使用 Linux 开发板、现成的传感器套件以及合适的后端技术几乎可以做成任何东西。为了更好的整合前面章节介绍的内容，本文将制作一个简单的气象站（也许叫环境信息收集装置更合适），至于为何选择制作一个气象站，因为难度不高制作不复杂，并且温湿度传感器花费较低的价格即可获得，可以以低廉的价格换取一个 cool stuff。本文将使用 .NET 6 编写一个控制台应用程序，通过本文你可以学到：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;I2C &lt;code&gt;I2cDevice&lt;/code&gt; 类的使用；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;摄像头设备 &lt;code&gt;VideoDevice&lt;/code&gt; 类的使用；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;Iot.Device.Bindings&lt;/code&gt; NuGet 包的使用；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;时序数据库 &lt;code&gt;TimescaleDB&lt;/code&gt; 的简单使用；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;Quartz&lt;/code&gt; 定时任务的使用；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在控制台应用中进行依赖注入；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;使用 &lt;code&gt;Docker&lt;/code&gt; 拉取镜像、部署应用。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;硬件需求&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;电路&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;准备工作&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;配置 TimescaleDB 数据库&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;安装摄像头的依赖库&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;编写代码&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;项目结构&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;项目依赖&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数据库上下文与实体类&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;配置文件&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;初始化与依赖注入配置&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;配置定时任务&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;部署应用&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;后续工作&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-line=&quot;11&quot;&gt;&lt;span&gt;硬件需求&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;名称&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;th&gt;数量&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Orange Pi Zero&lt;/td&gt;&lt;td&gt;Linux 开发板&lt;/td&gt;&lt;td&gt;x1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;BME280&lt;/td&gt;&lt;td&gt;提供温度、湿度以及气压数据&lt;/td&gt;&lt;td&gt;x1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;USB 摄像头&lt;/td&gt;&lt;td&gt;提供环境图像&lt;/td&gt;&lt;td&gt;x1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;杜邦线&lt;/td&gt;&lt;td&gt;传感器与开发板的连接线&lt;/td&gt;&lt;td&gt;若干&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p data-line=&quot;20&quot;&gt;&lt;span&gt;电路&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5233333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/09LgVyNibqhH2FckWjFMxMuNuFmq5eCwX7El5KF7GSsqcuIaw1kXOLdfy96n45hwUVcsYNL3PY2y0kNwwibTiciaWA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot;/&gt;&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;传感器&lt;/th&gt;&lt;th&gt;接口&lt;/th&gt;&lt;th&gt;开发板接口&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;BME280&lt;/td&gt;&lt;td&gt;SDA&lt;/td&gt;&lt;td&gt;TWI0_SDA (Pin 3)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;SCL&lt;/td&gt;&lt;td&gt;TWI0_SCK (Pin 5)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;VCC&lt;/td&gt;&lt;td&gt;5V (Pin 4)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;GND&lt;/td&gt;&lt;td&gt;GND (Pin 6)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;USB 摄像头&lt;/td&gt;&lt;td&gt;USB&lt;/td&gt;&lt;td&gt;USB&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p data-line=&quot;32&quot;&gt;&lt;span&gt;准备工作&lt;/span&gt;&lt;/p&gt;&lt;p data-line=&quot;34&quot;&gt;&lt;span&gt;配置 TimescaleDB 数据库&lt;/span&gt;&lt;/p&gt;&lt;p&gt;TimescaleDB 是一款基于 PostgreSQL 插件的时序数据库。考虑到收集的环境数据是按时间进行索引，并且数据基本上都是插入，没有更新的需求，因此选用了时序数据库作为数据存储。TimescaleDB 是 PostgreSQL 的一款插件，可以通过先安装 PostgreSQL 之后再安装插件的形式部署 TimescaleDB，这里直接使用 TimescaleDB 的 Docker 镜像进行部署。&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;拉取 TimescaleDB 镜像：&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;&quot;&gt;&lt;code&gt;docker pull timescale/timescaledb:latest-pg14&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;创建卷，用于持久化数据库数据：&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;&quot;&gt;&lt;code&gt;docker volume create tsdb_data&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;运行镜像，端口映射为 &lt;code&gt;54321&lt;/code&gt;，密码配置为弱密码 &lt;code&gt;@Passw0rd&lt;/code&gt;：&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;&quot;&gt;&lt;code&gt;docker run -d --name timescaledb -p 54321:5432 --restart=always -e POSTGRES_PASSWORD=&#x27;@Passw0rd&#x27; -e TZ=&#x27;Asia/Shanghai&#x27; -e ALLOW_IP_RANGE=0.0.0.0/0 -v tsdb_data:/var/lib/postgresql timescale/timescaledb:latest-pg14&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;4&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;使用熟悉的数据库管理工具（如 Navicat）创建数据库 &lt;code&gt;WeatherMetrics&lt;/code&gt;：&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;sql&quot;&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;DATABASE&lt;/span&gt; &lt;span&gt;&quot;WeatherMetrics&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;WITH&lt;/span&gt; OWNER &lt;span&gt;=&lt;/span&gt; postgres ENCODING &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&#x27;UTF8&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; metrics (&lt;br/&gt;   &lt;span&gt;time&lt;/span&gt; &lt;span&gt;TIMESTAMP&lt;/span&gt; WITHOUT &lt;span&gt;TIME&lt;/span&gt; ZONE &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;&#x27;now()&#x27;&lt;/span&gt;,&lt;br/&gt;   device_id &lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;,&lt;br/&gt;   weather_type &lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;,&lt;br/&gt;   temperature &lt;span&gt;DECIMAL&lt;/span&gt;(&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;,&lt;br/&gt;   humidity &lt;span&gt;DECIMAL&lt;/span&gt;(&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;,&lt;br/&gt;   pressure &lt;span&gt;DECIMAL&lt;/span&gt;(&lt;span&gt;8&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;,&lt;br/&gt;   image_base64 &lt;span&gt;TEXT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;br/&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;SELECT&lt;/span&gt; create_hypertable(&lt;span&gt;&#x27;metrics&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;time&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;time&lt;/code&gt; 表示采集数据的时间，&lt;code&gt;device_id&lt;/code&gt; 记录采集设备的 id，&lt;code&gt;weather_type&lt;/code&gt; 记录从心知天气获取的天气名，&lt;code&gt;temperature&lt;/code&gt; 记录传感器获取的温度，&lt;code&gt;humidity&lt;/code&gt; 记录传感器获取的湿度，&lt;code&gt;pressure&lt;/code&gt; 记录传感器获取的气压，&lt;code&gt;image_base64&lt;/code&gt; 记录摄像头采集的图像。&lt;/p&gt;&lt;p&gt;&lt;span&gt;💡 提示&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在数据库中存储任何字符类型以外的数据都是愚蠢的，这里是为了演示，并且只是低分辨率的图像。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;超表（hypertable）是 TimescaleDB 的一个重要概念，由若干个块（chunks）组成，将超表中的数据按照时间列（即 &lt;code&gt;metrics&lt;/code&gt; 表中的 &lt;code&gt;time&lt;/code&gt; 字段）分成若干个块存储，而使用 PostgreSQL 层面上的表（table）实现 SQL 接口的暴露，因此使用 &lt;code&gt;create_hypertable()&lt;/code&gt; 将表转换为超表。上面创建的 &lt;code&gt;metrics&lt;/code&gt; 表并不是真正意义上的表，表中不存在主键字段，而是类似视图（view）一样的抽象结构。&lt;/p&gt;&lt;h3&gt;安装摄像头的依赖库&lt;/h3&gt;&lt;p&gt;VideoDevice 类是使用 PInvoke 操作实现的，依赖于 Video for Linux 2（V4L2），因此还需要安装 V4L2 工具：&lt;/p&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;&quot;&gt;&lt;code&gt;sudo apt install v4l-utils&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;实现时还引用了 &lt;code&gt;System.Drawing&lt;/code&gt; NuGet 包，因此还需要安装 &lt;code&gt;System.Drawing&lt;/code&gt; 的前置依赖：&lt;/p&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;&quot;&gt;&lt;code&gt;sudo apt install libc6-dev libgdiplus libx11-dev&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-line=&quot;88&quot;&gt;&lt;span&gt;编写代码&lt;/span&gt;&lt;/p&gt;&lt;p&gt;项目地址：https://github.com/ZhangGaoxing/weather-metrics&lt;/p&gt;&lt;p data-line=&quot;92&quot;&gt;&lt;span&gt;项目结构&lt;/span&gt;&lt;/p&gt;&lt;p&gt;创建一个控制台应用和类库，项目结构如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6391509433962265&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/09LgVyNibqhH2FckWjFMxMuNuFmq5eCwX7T4XfKTXr6w9oKfdGF6YSrMfDVGKYe5aspGNx71pvibmR3sUNL4Ok4g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;424&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;项目依赖&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;WeatherMetrics.ConsoleApp&lt;/code&gt; 添加如下 NuGet 包引用：&lt;/p&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;xml&quot;&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;ItemGroup&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;PackageReference &lt;span&gt;Include&lt;/span&gt;&lt;span&gt;&lt;span&gt;=&quot;&lt;/span&gt;Iot.Device.Bindings&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;Version&lt;/span&gt;&lt;span&gt;&lt;span&gt;=&quot;&lt;/span&gt;2.0.0&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;PackageReference &lt;span&gt;Include&lt;/span&gt;&lt;span&gt;&lt;span&gt;=&quot;&lt;/span&gt;Microsoft.Extensions.Configuration.Json&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;Version&lt;/span&gt;&lt;span&gt;&lt;span&gt;=&quot;&lt;/span&gt;6.0.0&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;PackageReference &lt;span&gt;Include&lt;/span&gt;&lt;span&gt;&lt;span&gt;=&quot;&lt;/span&gt;Microsoft.Extensions.DependencyInjection&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;Version&lt;/span&gt;&lt;span&gt;&lt;span&gt;=&quot;&lt;/span&gt;6.0.0&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;PackageReference &lt;span&gt;Include&lt;/span&gt;&lt;span&gt;&lt;span&gt;=&quot;&lt;/span&gt;Newtonsoft.Json&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;Version&lt;/span&gt;&lt;span&gt;&lt;span&gt;=&quot;&lt;/span&gt;13.0.1&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;PackageReference &lt;span&gt;Include&lt;/span&gt;&lt;span&gt;&lt;span&gt;=&quot;&lt;/span&gt;Quartz&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;Version&lt;/span&gt;&lt;span&gt;&lt;span&gt;=&quot;&lt;/span&gt;3.3.3&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;PackageReference &lt;span&gt;Include&lt;/span&gt;&lt;span&gt;&lt;span&gt;=&quot;&lt;/span&gt;System.Device.Gpio&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;Version&lt;/span&gt;&lt;span&gt;&lt;span&gt;=&quot;&lt;/span&gt;2.0.0&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;ItemGroup&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;WeatherMetrics.Models&lt;/code&gt; 添加如下 NuGet 包引用：&lt;/p&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;xml&quot;&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;ItemGroup&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;PackageReference &lt;span&gt;Include&lt;/span&gt;&lt;span&gt;&lt;span&gt;=&quot;&lt;/span&gt;Npgsql.EntityFrameworkCore.PostgreSQL&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;Version&lt;/span&gt;&lt;span&gt;&lt;span&gt;=&quot;&lt;/span&gt;6.0.3&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;ItemGroup&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p data-line=&quot;121&quot;&gt;&lt;span&gt;数据库上下文与实体类&lt;/span&gt;&lt;/p&gt;&lt;p&gt;TimescaleDB 本质上就是一个 PostgreSQL 数据库，因此数据库访问使用 Npgsql 驱动。首先添加实体类 &lt;code&gt;Metrics.cs&lt;/code&gt;：&lt;/p&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;csharp&quot;&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Metrics&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;    [&lt;span&gt;Column&lt;/span&gt;(&lt;span&gt;&quot;time&quot;&lt;/span&gt;)]&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;DateTime&lt;/span&gt; Time { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } &lt;span&gt;=&lt;/span&gt; DateTime.Now;&lt;br/&gt;&lt;br/&gt;    [&lt;span&gt;Column&lt;/span&gt;(&lt;span&gt;&quot;device_id&quot;&lt;/span&gt;)]&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; DeviceId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }&lt;br/&gt;&lt;br/&gt;    [&lt;span&gt;Column&lt;/span&gt;(&lt;span&gt;&quot;weather_type&quot;&lt;/span&gt;)]&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; WeatherType { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }&lt;br/&gt;&lt;br/&gt;    [&lt;span&gt;Column&lt;/span&gt;(&lt;span&gt;&quot;temperature&quot;&lt;/span&gt;)]&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; Temperature { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }&lt;br/&gt;&lt;br/&gt;    [&lt;span&gt;Column&lt;/span&gt;(&lt;span&gt;&quot;humidity&quot;&lt;/span&gt;)]&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; Humidity { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }&lt;br/&gt;&lt;br/&gt;    [&lt;span&gt;Column&lt;/span&gt;(&lt;span&gt;&quot;pressure&quot;&lt;/span&gt;)]&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; Pressure { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }&lt;br/&gt;&lt;br/&gt;    [&lt;span&gt;Column&lt;/span&gt;(&lt;span&gt;&quot;image_base64&quot;&lt;/span&gt;)]&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ImageBase64 { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }&lt;br/&gt;}&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;接着添加数据库上下文 &lt;code&gt;WeatherContext.cs&lt;/code&gt;：&lt;/p&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;csharp&quot;&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;WeatherContext&lt;/span&gt; : &lt;span&gt;DbContext&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; _connectString;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;WeatherContext&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt; connectString)&lt;br/&gt;    {&lt;br/&gt;        _connectString &lt;span&gt;=&lt;/span&gt; connectString;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;OnConfiguring&lt;/span&gt;(&lt;span&gt;DbContextOptionsBuilder&lt;/span&gt; optionsBuilder)&lt;br/&gt;    {&lt;br/&gt;        AppContext.&lt;span&gt;SetSwitch&lt;/span&gt;(&lt;span&gt;&quot;Npgsql.EnableLegacyTimestampBehavior&quot;&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;        optionsBuilder.&lt;span&gt;UseNpgsql&lt;/span&gt;(_connectString);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;OnModelCreating&lt;/span&gt;(&lt;span&gt;ModelBuilder&lt;/span&gt; modelBuilder)&lt;br/&gt;    {&lt;br/&gt;        modelBuilder.&lt;span&gt;Entity&lt;span&gt;&amp;lt;&lt;/span&gt;Metrics&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;()&lt;br/&gt;            .&lt;span&gt;ToTable&lt;/span&gt;(&lt;span&gt;&quot;metrics&quot;&lt;/span&gt;)&lt;br/&gt;            .&lt;span&gt;HasNoKey&lt;/span&gt;();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;这里使用了一个传递数据库连接字符串的构造函数，连接字符串从 &lt;code&gt;appsettings.json&lt;/code&gt; 文件中读取。由于 &lt;code&gt;metrics&lt;/code&gt; 表是无主键的，还需要使用 &lt;code&gt;HasNoKey()&lt;/code&gt; 进行标记。EF Core 由于使用了实体跟踪，因此无法对无主键的表进行修改，只能通过执行 SQL 的方式插入数据，在 &lt;code&gt;Metrics.cs&lt;/code&gt; 中新增方法：&lt;/p&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;csharp&quot;&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; &lt;span&gt;Insert&lt;/span&gt;(&lt;span&gt;DbContext&lt;/span&gt; context, &lt;span&gt;Metrics&lt;/span&gt; metrics)&lt;br/&gt;{&lt;br/&gt;   &lt;span&gt;int&lt;/span&gt; row &lt;span&gt;=&lt;/span&gt; context.Database.&lt;span&gt;ExecuteSqlRaw&lt;/span&gt;(&lt;span&gt;&quot;INSERT INTO metrics VALUES ({0}, {1}, {2}, {3}, {4}, {5}, {6})&quot;&lt;/span&gt;, metrics.Time, metrics.DeviceId, metrics.WeatherType, metrics.Temperature, metrics.Humidity, metrics.Pressure, metrics.ImageBase64);&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; row &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;⚠️ 警告&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;请不要在 SQL 中使用字符串内插。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;配置文件&lt;/h3&gt;&lt;p&gt;在 &lt;code&gt;appsettings.json&lt;/code&gt; 中添加如下内容：&lt;/p&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;json&quot;&gt;{&lt;br/&gt;  &lt;span&gt;// 数据库连接字符串 &lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&quot;ConnectionString&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;Server=localhost;Port=54321;Database=WeatherMetrics;User Id=postgres;Password=@Passw0rd;&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;// 定时任务设置&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&quot;QuartzCron&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;0 0/1 * * * ? *&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;// 心知天气的配置&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&quot;Xinzhi&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;&quot;Key&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;Location&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;34.24:117.16&quot;&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/pre&gt;&lt;p data-line=&quot;208&quot;&gt;&lt;span&gt;初始化与依赖注入配置&lt;/span&gt;&lt;/p&gt;&lt;p&gt;新建一个静态类 &lt;code&gt;AppConfig&lt;/code&gt;，用于保存依赖注入的 &lt;code&gt;ServiceProvider&lt;/code&gt; 变量：&lt;/p&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;csharp&quot;&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;AppConfig&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;IServiceProvider&lt;/span&gt; ServiceProvider { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }&lt;br/&gt;}&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;在 &lt;code&gt;Program.cs&lt;/code&gt; 中添加初始化代码：&lt;/p&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;csharp&quot;&gt;&lt;span&gt;// 读取配置文件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; config &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;ConfigurationBuilder&lt;/span&gt;()&lt;br/&gt;    .&lt;span&gt;AddJsonFile&lt;/span&gt;(&lt;span&gt;&quot;appsettings.json&quot;&lt;/span&gt;)&lt;br/&gt;    .&lt;span&gt;Build&lt;/span&gt;();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 实例化数据库上下文&lt;/span&gt;&lt;br/&gt;&lt;span&gt;using&lt;/span&gt; &lt;span&gt;WeatherContext&lt;/span&gt; context &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;WeatherContext&lt;/span&gt;(config[&lt;span&gt;&quot;ConnectionString&quot;&lt;/span&gt;]);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 配置 I2C，实例化传感器&lt;/span&gt;&lt;br/&gt;&lt;span&gt;I2cConnectionSettings&lt;/span&gt; i2cSettings &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;I2cConnectionSettings&lt;/span&gt;(busId: &lt;span&gt;0&lt;/span&gt;, deviceAddress: Bmx280Base.SecondaryI2cAddress);&lt;br/&gt;&lt;span&gt;using&lt;/span&gt; &lt;span&gt;I2cDevice&lt;/span&gt; i2c &lt;span&gt;=&lt;/span&gt; I2cDevice.&lt;span&gt;Create&lt;/span&gt;(i2cSettings);&lt;br/&gt;&lt;span&gt;using&lt;/span&gt; &lt;span&gt;Bme280&lt;/span&gt; bme &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Bme280&lt;/span&gt;(i2c);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 实例化摄像头&lt;/span&gt;&lt;br/&gt;&lt;span&gt;VideoConnectionSettings&lt;/span&gt; videoSettings &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;VideoConnectionSettings&lt;/span&gt;(busId: &lt;span&gt;0&lt;/span&gt;, captureSize: (&lt;span&gt;640&lt;/span&gt;, &lt;span&gt;480&lt;/span&gt;));&lt;br/&gt;&lt;span&gt;using&lt;/span&gt; &lt;span&gt;VideoDevice&lt;/span&gt; video &lt;span&gt;=&lt;/span&gt; VideoDevice.&lt;span&gt;Create&lt;/span&gt;(videoSettings);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 配置依赖注入&lt;/span&gt;&lt;br/&gt;AppConfig.ServiceProvider &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;ServiceCollection&lt;/span&gt;()&lt;br/&gt;    .&lt;span&gt;AddSingleton&lt;/span&gt;(config)&lt;br/&gt;    .&lt;span&gt;AddSingleton&lt;/span&gt;(context)&lt;br/&gt;    .&lt;span&gt;AddSingleton&lt;/span&gt;(bme)&lt;br/&gt;    .&lt;span&gt;AddSingleton&lt;/span&gt;(video)&lt;br/&gt;    .&lt;span&gt;BuildServiceProvider&lt;/span&gt;();&lt;br/&gt;&lt;/pre&gt;&lt;p data-line=&quot;246&quot;&gt;&lt;span&gt;配置定时任务&lt;/span&gt;&lt;/p&gt;&lt;p&gt;定时任务通过 &lt;code&gt;appsettings.json&lt;/code&gt; 中的 &lt;code&gt;QuartzCron&lt;/code&gt; 字段设置。Cron 表达式分为 7 个部分，从左至右分别代表：Seconds、Minutes、Hours、DayofMonth、Month、DayofWeek 以及 Year。&lt;code&gt;*&lt;/code&gt; 出现的部分表示任意值都会触发定时任务，&lt;code&gt;/&lt;/code&gt; 左侧表示触发的起始时间，右侧表示触发间隔，以 &lt;code&gt;appsettings.json&lt;/code&gt; 中的为例，表示从每小时的第 0 分开始触发，每一分钟触发一次。&lt;/p&gt;&lt;p&gt;新建 &lt;code&gt;MetricsJob&lt;/code&gt; 类，用于实现定时任务：&lt;/p&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;csharp&quot;&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;MetricsJob&lt;/span&gt; : &lt;span&gt;IJob&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;Task&lt;/span&gt; &lt;span&gt;Execute&lt;/span&gt;(&lt;span&gt;IJobExecutionContext&lt;/span&gt; context)&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Task.&lt;span&gt;Run&lt;/span&gt;(&lt;span&gt;async&lt;/span&gt; () &lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;br/&gt;        {&lt;br/&gt;            &lt;span&gt;// TODO：在此处实现定时任务&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;// 需要完成传感器的读取，心知天气的请求，数据库的插入&lt;/span&gt;&lt;br/&gt;        });&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/pre&gt;&lt;p data-line=&quot;265&quot;&gt;&lt;span&gt;传感器的读取&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在 &lt;code&gt;MetricsJob&lt;/code&gt; 类中添加方法：&lt;/p&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;csharp&quot;&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;Metrics&lt;/span&gt; &lt;span&gt;GetMetrics&lt;/span&gt;()&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;// 获取依赖注入的 Bme280 对象&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;Bme280&lt;/span&gt; bme &lt;span&gt;=&lt;/span&gt; (Bme280)AppConfig.ServiceProvider.&lt;span&gt;GetService&lt;/span&gt;(&lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;Bme280&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 设置传感器的电源模式&lt;/span&gt;&lt;br/&gt;    bme.&lt;span&gt;SetPowerMode&lt;/span&gt;(Bmx280PowerMode.Normal);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 设置读取精度&lt;/span&gt;&lt;br/&gt;    bme.PressureSampling &lt;span&gt;=&lt;/span&gt; Sampling.UltraHighResolution;&lt;br/&gt;    bme.TemperatureSampling &lt;span&gt;=&lt;/span&gt; Sampling.UltraHighResolution;&lt;br/&gt;    bme.HumiditySampling &lt;span&gt;=&lt;/span&gt; Sampling.UltraHighResolution;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 读取数据&lt;/span&gt;&lt;br/&gt;    bme.&lt;span&gt;TryReadPressure&lt;/span&gt;(&lt;span&gt;out&lt;/span&gt; &lt;span&gt;UnitsNet&lt;span&gt;.&lt;/span&gt;Pressure&lt;/span&gt; p);&lt;br/&gt;    bme.&lt;span&gt;TryReadTemperature&lt;/span&gt;(&lt;span&gt;out&lt;/span&gt; &lt;span&gt;UnitsNet&lt;span&gt;.&lt;/span&gt;Temperature&lt;/span&gt; t);&lt;br/&gt;    bme.&lt;span&gt;TryReadHumidity&lt;/span&gt;(&lt;span&gt;out&lt;/span&gt; &lt;span&gt;UnitsNet&lt;span&gt;.&lt;/span&gt;RelativeHumidity&lt;/span&gt; h);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 传感器休眠&lt;/span&gt;&lt;br/&gt;    bme.&lt;span&gt;SetPowerMode&lt;/span&gt;(Bmx280PowerMode.Sleep);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Metrics&lt;/span&gt;&lt;br/&gt;    {&lt;br/&gt;        DeviceId &lt;span&gt;=&lt;/span&gt; Dns.&lt;span&gt;GetHostName&lt;/span&gt;(),&lt;br/&gt;        Temperature &lt;span&gt;=&lt;/span&gt; Math.&lt;span&gt;Round&lt;/span&gt;(t.DegreesCelsius, &lt;span&gt;2&lt;/span&gt;),&lt;br/&gt;        Humidity &lt;span&gt;=&lt;/span&gt; Math.&lt;span&gt;Round&lt;/span&gt;(h.Percent, &lt;span&gt;2&lt;/span&gt;),&lt;br/&gt;        Pressure &lt;span&gt;=&lt;/span&gt; Math.&lt;span&gt;Round&lt;/span&gt;(p.Pascals, &lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;    };&lt;br/&gt;}&lt;br/&gt;&lt;/pre&gt;&lt;p data-line=&quot;300&quot;&gt;&lt;span&gt;摄像头捕获图像&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在 &lt;code&gt;MetricsJob&lt;/code&gt; 类中添加方法：&lt;/p&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;csharp&quot;&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; &lt;span&gt;GetImage&lt;/span&gt;()&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;VideoDevice&lt;/span&gt; video &lt;span&gt;=&lt;/span&gt; (VideoDevice)AppConfig.ServiceProvider.&lt;span&gt;GetService&lt;/span&gt;(&lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;VideoDevice&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[]&lt;/span&gt;&lt;/span&gt; image &lt;span&gt;=&lt;/span&gt; video.&lt;span&gt;Capture&lt;/span&gt;();&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; Convert.&lt;span&gt;ToBase64String&lt;/span&gt;(image);&lt;br/&gt;}&lt;br/&gt;&lt;/pre&gt;&lt;p data-line=&quot;313&quot;&gt;&lt;span&gt;心知天气 API 请求&lt;/span&gt;&lt;/p&gt;&lt;p&gt;通过请求心知天气 API 获得当前位置的天气名称，需要提前在 https://www.seniverse.com/api 申请 API Key。在 &lt;code&gt;MetricsJob&lt;/code&gt; 类中添加方法：&lt;/p&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;csharp&quot;&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;Task&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;GetXinzhiWeatherAsync&lt;/span&gt;()&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;IConfigurationRoot&lt;/span&gt; config &lt;span&gt;=&lt;/span&gt; (IConfigurationRoot)AppConfig.ServiceProvider.&lt;span&gt;GetService&lt;/span&gt;(&lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;IConfigurationRoot&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;using&lt;/span&gt; &lt;span&gt;HttpClient&lt;/span&gt; client &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;HttpClient&lt;/span&gt;();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt;&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;var&lt;/span&gt; json &lt;span&gt;=&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; client.&lt;span&gt;GetStringAsync&lt;/span&gt;(&lt;span&gt;$&quot;https://api.seniverse.com/v3/weather/now.json?key=&lt;/span&gt;{config[&lt;span&gt;&quot;Xinzhi:Key&quot;&lt;/span&gt;]}&lt;span&gt;&amp;amp;location=&lt;/span&gt;{config[&lt;span&gt;&quot;Xinzhi:Location&quot;&lt;/span&gt;]}&lt;span&gt;&amp;amp;language=zh-Hans&amp;amp;unit=c&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;)JsonConvert.&lt;span&gt;DeserializeObject&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dynamic&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;(json).results[&lt;span&gt;0&lt;/span&gt;].now.text;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;catch&lt;/span&gt; (&lt;span&gt;Exception&lt;/span&gt;)&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;.Empty;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/pre&gt;&lt;p data-line=&quot;335&quot;&gt;&lt;span&gt;完善定时任务&lt;/span&gt;&lt;/p&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;csharp&quot;&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Task&lt;/span&gt; &lt;span&gt;Execute&lt;/span&gt;(&lt;span&gt;IJobExecutionContext&lt;/span&gt; context)&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; Task.&lt;span&gt;Run&lt;/span&gt;(&lt;span&gt;async&lt;/span&gt; () &lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;var&lt;/span&gt; metrics &lt;span&gt;=&lt;/span&gt; &lt;span&gt;GetMetrics&lt;/span&gt;();&lt;br/&gt;        metrics.WeatherType &lt;span&gt;=&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; &lt;span&gt;GetXinzhiWeatherAsync&lt;/span&gt;();&lt;br/&gt;        metrics.ImageBase64 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;GetImage&lt;/span&gt;();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;WeatherContext&lt;/span&gt; context &lt;span&gt;=&lt;/span&gt; (WeatherContext)AppConfig.ServiceProvider.&lt;span&gt;GetService&lt;/span&gt;(&lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;WeatherContext&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;        Metrics.&lt;span&gt;Insert&lt;/span&gt;(context, metrics);&lt;br/&gt;    });&lt;br/&gt;}&lt;br/&gt;&lt;/pre&gt;&lt;p data-line=&quot;353&quot;&gt;&lt;span&gt;创建定时任务触发器&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在 &lt;code&gt;Program.cs&lt;/code&gt; 中添加：&lt;/p&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;csharp&quot;&gt;&lt;span&gt;// 创建一个触发器&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; trigger &lt;span&gt;=&lt;/span&gt; TriggerBuilder.&lt;span&gt;Create&lt;/span&gt;()&lt;br/&gt;    .&lt;span&gt;WithCronSchedule&lt;/span&gt;(config[&lt;span&gt;&quot;QuartzCron&quot;&lt;/span&gt;])&lt;br/&gt;    .&lt;span&gt;Build&lt;/span&gt;();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 创建任务&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; jobDetail &lt;span&gt;=&lt;/span&gt; JobBuilder.&lt;span&gt;Create&lt;span&gt;&amp;lt;&lt;/span&gt;MetricsJob&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;()&lt;br/&gt;    .&lt;span&gt;WithIdentity&lt;/span&gt;(&lt;span&gt;&quot;job&quot;&lt;/span&gt;, &lt;span&gt;&quot;group&quot;&lt;/span&gt;)&lt;br/&gt;    .&lt;span&gt;Build&lt;/span&gt;();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 绑定调度器&lt;/span&gt;&lt;br/&gt;&lt;span&gt;ISchedulerFactory&lt;/span&gt; factory &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;StdSchedulerFactory&lt;/span&gt;();&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; scheduler &lt;span&gt;=&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; factory.&lt;span&gt;GetScheduler&lt;/span&gt;();&lt;br/&gt;&lt;span&gt;await&lt;/span&gt; scheduler.&lt;span&gt;ScheduleJob&lt;/span&gt;(jobDetail, trigger);&lt;br/&gt;&lt;span&gt;await&lt;/span&gt; scheduler.&lt;span&gt;Start&lt;/span&gt;();&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;这样一个一分钟采集一次数据的简易气象站就完成了。&lt;/p&gt;&lt;h2&gt;部署应用&lt;/h2&gt;&lt;p data-line=&quot;378&quot;&gt;&lt;span&gt;发布到文件&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;切换到 &lt;code&gt;WeatherMetrics.ConsoleApp&lt;/code&gt; 项目运行发布命令：&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;&quot;&gt;&lt;code&gt;dotnet publish -c release -r linux-arm&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;将发布后的文件通过 FTP 等方式复制到 Linux 开发板；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;为 &lt;code&gt;WeatherMetrics.ConsoleApp&lt;/code&gt; 文件增加可执行权限&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;&quot;&gt;&lt;code&gt;sudo chmod +x WeatherMetrics.ConsoleApp&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;4&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;运行程序&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;&quot;&gt;&lt;code&gt;sudo ./WeatherMetrics.ConsoleApp&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-line=&quot;394&quot;&gt;&lt;span&gt;打包 Docker 镜像&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;查看 TimescaleDB 容器的 IP，并修改 &lt;code&gt;appsettings.json&lt;/code&gt; 的数据库连接字符串：&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;&quot;&gt;&lt;code&gt;docker inspect -f &#x27;{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}&#x27; timescaledb&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;在项目的根目录中创建 &lt;code&gt;Dockerfile&lt;/code&gt;，并将整个项目复制到 Linux 开发板中：&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;Dockerfile&quot;&gt;&lt;span&gt;FROM&lt;/span&gt; mcr.microsoft.com/dotnet/core/sdk:6.0-focal-arm32v7 &lt;span&gt;AS&lt;/span&gt; build&lt;br/&gt;&lt;span&gt;WORKDIR&lt;/span&gt; /app&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# publish app&lt;/span&gt;&lt;br/&gt;&lt;span&gt;COPY&lt;/span&gt; src .&lt;br/&gt;&lt;span&gt;WORKDIR&lt;/span&gt; /app/WeatherMetrics.ConsoleApp&lt;br/&gt;&lt;span&gt;RUN&lt;/span&gt; dotnet restore&lt;br/&gt;&lt;span&gt;RUN&lt;/span&gt; dotnet publish -c release -r linux-arm -o out&lt;br/&gt;&lt;br/&gt;&lt;span&gt;## run app&lt;/span&gt;&lt;br/&gt;&lt;span&gt;FROM&lt;/span&gt; mcr.microsoft.com/dotnet/core/runtime:6.0-focal-arm32v7 &lt;span&gt;AS&lt;/span&gt; runtime&lt;br/&gt;&lt;span&gt;WORKDIR&lt;/span&gt; /app&lt;br/&gt;&lt;span&gt;COPY&lt;/span&gt; &lt;span&gt;--from&lt;/span&gt;=&lt;span&gt;build&lt;/span&gt; /app/WeatherMetrics.ConsoleApp/out ./&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# install native dependencies&lt;/span&gt;&lt;br/&gt;&lt;span&gt;RUN&lt;/span&gt; apt update &amp;amp;&amp;amp; &lt;span&gt;\&lt;/span&gt;&lt;br/&gt;    apt install -y --allow-unauthenticated v4l-utils libc6-dev libgdiplus libx11-dev&lt;br/&gt;&lt;br/&gt;&lt;span&gt;ENTRYPOINT&lt;/span&gt; [&lt;span&gt;&quot;dotnet&quot;&lt;/span&gt;, &lt;span&gt;&quot;WeatherMetrics.ConsoleApp.dll&quot;&lt;/span&gt;]&lt;br/&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;切换到项目目录，构建镜像：&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;&quot;&gt;&lt;code&gt;docker build -t weather-metrics -f Dockerfile .&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;4&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;运行镜像：&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;&quot;&gt;&lt;code&gt;docker run --rm -it --device /dev/video0 --device /dev/i2c-0 weather-metrics&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;后续工作&lt;/h2&gt;&lt;p&gt;程序运行一段时间后，使用标准的 SQL 查询一下数据：&lt;/p&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;sql&quot;&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; metrics&lt;br/&gt;&lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; &lt;span&gt;time&lt;/span&gt; &lt;span&gt;DESC&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4608788853161844&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/09LgVyNibqhH2FckWjFMxMuNuFmq5eCwX5tLxPr0n0sibK1DShJnVQYcia8uTnS7OBP4GlgSnv3BXIy0pvW24JefA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;933&quot;/&gt;&lt;/p&gt;&lt;p&gt;硬件是软件的基础，对收集到的数据后续可以使用其他技术进行处理，比如可以使用 ASP.NET 编写 WEB 应用对数据进行展示，或者可以使用 ML.NET 构建机器学习模型对天气进行预测等等。&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2cdcb18e957a7d43c408bcf2acf5d76e</guid>
<title>5种全局ID生成方式、优缺点及改进方案</title>
<link>https://toutiao.io/k/lutdvsl</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section class=&quot;mp_profile_iframe_wrp&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUyMzM2ODUwMA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/hs540iaTKoaIWQB73gicJGTicpAjbSjAjic3d4ytEoiaArkWw6hKMqicPSXrpd4FquTTdStuMoILtqGHS222lIQlh1mg/0?wx_fmt=png&quot; data-nickname=&quot;逆锋起笔&quot; data-alias=&quot;readdot&quot; data-signature=&quot;全网最新编程视频教程、大佬们推荐的 pdf 学习资料，全部免费分享！来到这里，你不懂程序都难。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;em&gt;来源：blog.csdn.net/LZ15932161597/&lt;/em&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;em&gt;article/details/113397226&lt;/em&gt;&lt;/span&gt;&lt;em/&gt;&lt;/h3&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;文章目录&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;全局唯一id介绍&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;常见全局唯一id生成策略&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据库自增长序列或字段生成id&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;UUID&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Redis生成ID&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;zookeeper生成ID&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Twitter的snowflake算法&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;全局唯一id介绍&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;系统唯一id是我们在设计阶段常常遇到的问题。在复杂的分布式系统中，几乎都需要对大量的数据和消息进行唯一标识。在设计初期，我们需要考虑日后数据量的级别，如果可能会对数据进行分库分表，那么就需要有一个全局唯一id来标识一条数据或记录。生成唯一id的策略有多种，但是每种策略都有它的适用场景、优点以及局限性。&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;全局唯一id特点:&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;全局唯一性：不能出现重复的ID号，既然是唯一标识，这是最基本的要求；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;趋势递增：在MySQL InnoDB引擎中使用的是聚集索引，由于多数RDBMS使用B-tree的数据结构来存储索引数据，在主键的选择上面我们应该尽量使用有序的主键保证写入性能；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;单调递增：保证下一个ID一定大于上一个ID，例如事务版本号、IM增量消息、排序等特殊需求；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;信息安全：如果ID是连续的，恶意用户的扒取工作就非常容易做了，直接按照顺序下载指定URL即可；如果是订单号就更危险了，竞对可以直接知道我们一天的单量。所以在一些应用场景下，会需要ID无规则、不规则；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;高可用性：同时除了对ID号码自身的要求，业务还对ID号生成系统的可用性要求极高，想象一下，如果ID生成系统瘫痪，这就会带来一场灾难。所以不能有单点故障；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;分片支持：可以控制ShardingId。比如某一个用户的文章要放在同一个分片内，这样查询效率高，修改也容易；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;长度适中。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;常见全局唯一id生成策略&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0144927536231885&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbuetyac8TibKV83bfb1DPqbpylO4wiasKEPywftUK3Y8vTgeM6g6ZLO5ibzs7ZXpbZesGXV45EGGvoPCg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;276&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;1、数据库自增长序列或字段生成id&lt;/h3&gt;&lt;section&gt;最常见的一种生成id方式。利用数据库本身来进行设置，在全数据库内保持唯一。&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;【优点】&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;非常简单。利用现有数据库系统的功能实现，成本小，代码简单，性能可以接受。ID号单调递增。可以实现一些对ID有特殊要求的业务，比如对分页或者排序结果这类需求有帮助。&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;【缺点】&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;强依赖DB。不同数据库语法和实现不同，数据库迁移的时候、多数据库版本支持的时候、或分表分库的时候需要处理，会比较麻烦。当DB异常时整个系统不可用，属于致命问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;单点故障。在单个数据库或读写分离或一主多从的情况下，只有一个主库可以生成。有单点故障的风险。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据一致性问题。配置主从复制可以尽可能的增加可用性，但是数据一致性在特殊情况下难以保证。主从切换时的不一致可能会导致重复发号。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;难于扩展。在性能达不到要求的情况下，比较难于扩展。ID发号性能瓶颈限制在单台MySQL的读写性能。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;【部分优化方案】&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;针对主库单点， 如果有多个Master库，则每个Master库设置的起始数字不一样，步长一样，可以是Master的个数。比如：Master1 生成的是 &lt;code&gt;1,4,7,10&lt;/code&gt;，Master2生成的是&lt;code&gt;2,5,8,11&lt;/code&gt; Master3生成的是 &lt;code&gt;3,6,9,12&lt;/code&gt;。这样就可以有效生成集群中的唯一ID，也可以大大降低ID生成数据库操作的负载。&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2、UUID&lt;/h3&gt;&lt;section&gt;常见的生成id方式，利用程序生成。&lt;/section&gt;&lt;section&gt;UUID (&lt;code&gt;Universally Unique Identifier&lt;/code&gt;) 的目的，是让分布式系统中的所有元素，都能有唯一的辨识资讯，而不需要透过中央控制端来做辨识资讯的指定。如此一来，每个人都可以建立不与其它人冲突的 UUID。在这样的情况下，就不需考虑数据库建立时的名称重复问题。&lt;/section&gt;&lt;section&gt;UUID的标准形式包含32个16进制数字，以连字号分为五段，形式为8-4-4-4-12的36个字符，示例：&lt;code&gt;550e8400-e29b-41d4-a716-446655440000&lt;/code&gt;，到目前为止业界一共有5种方式生成UUID。&lt;/section&gt;&lt;section&gt;在Java中我们可以直接使用下面的API生成UUID:&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;UUID uuid  =  UUID.randomUUID(); String s = UUID.randomUUID().toString();&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;【优点】&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;非常简单，本地生成，代码方便，API调用方便。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;性能非高。生成的id性能非常好，没有网络消耗，基本不会有性能问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;全球唯一。在数据库迁移、系统数据合并、或者数据库变更的情况下，可以 从容应对。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;【缺点】&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;存储成本高&lt;/strong&gt;。UUID太长，16字节128位，通常以36长度的字符串表示，很多场景不适用。如果是海量数据库，就需要考虑存储量的问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;信息不安全&lt;/strong&gt;。基于MAC地址生成UUID的算法可能会造成MAC地址泄露，这个漏洞曾被用于寻找梅丽莎病毒的制作者位置。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;不适用作为主键&lt;/strong&gt;，ID作为主键时在特定的环境会存在一些问题，比如做DB主键的场景下，UUID就非常不适用。UUID往往是使用字符串存储，查询的效率比较低。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;UUID是无序的&lt;/strong&gt;。不是单调递增的，而现阶段主流的数据库主键索引都是选用的B+树索引，对于无序长度过长的主键插入效率比较低。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;传输数据量大&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;不可读&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;【部分优化方案】&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;为了解决UUID不可读&lt;/strong&gt;， 可以使用UUID to Int64的方法 。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;为了解决UUID无序的问题&lt;/strong&gt;， NHibernate在其主键生成方式中提供了Comb算法（combined guid/timestamp）。保留GUID的10个字节，用另6个字节表示GUID生成的时间（DateTime）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;3、Redis生成ID&lt;/h3&gt;&lt;section&gt;当使用数据库来生成ID性能不够要求的时候，我们可以尝试使用Redis来生成ID。这主要依赖于Redis是单线程的，所以也可以用生成全局唯一的ID。可以用Redis的原子操作 INCR和INCRBY来实现。&lt;/section&gt;&lt;section&gt;可以使用Redis集群来获取更高的吞吐量。假如一个集群中有5台Redis。可以初始化每台Redis的值分别是1,2,3,4,5，然后步长都是5。各个Redis生成的ID为：&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;A：1,6,11,16,21&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;B：2,7,12,17,22&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;C：3,8,13,18,23&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;D：4,9,14,19,24&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;E：5,10,15,20,25&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;这个负载到哪台机器上需要提前设定好，未来很难做修改。但是3-5台服务器基本能够满足，都可以获得不同的ID。步长和初始值一定需要事先设定好。使用Redis集群也可以防止单点故障的问题。&lt;/section&gt;&lt;section&gt;比较适合使用Redis来生成日切流水号。比如订单号=日期+当日自增长号。可以每天在Redis中生成一个Key，使用INCR进行累加。&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;【优点】&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;不依赖于数据库，灵活方便，且性能优于数据库。。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数字ID天然排序，对分页或者需要排序的结果很有帮助。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;【缺点】&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果系统中没有Redis，还需要引入新的组件，增加系统复杂度。。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;需要编码和配置的工作量比较大。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Redis单点故障，影响序列服务的可用性。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;4、zookeeper生成ID&lt;/h3&gt;&lt;section&gt;zookeeper主要通过其znode数据版本来生成序列号，可以生成32位和64位的数据版本号，客户端可以使用这个版本号来作为唯一的序列号。&lt;/section&gt;&lt;section&gt;很少会使用zookeeper来生成唯一ID。主要是由于需要依赖zookeeper，并且是多步调用API，如果在竞争较大的情况下，需要考虑使用分布式锁。因此，性能在高并发的分布式环境下，也不甚理想。&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;5、Twitter的snowflake算法&lt;/h3&gt;&lt;section&gt;snowflake(雪花算法)是Twitter开源的分布式ID生成算法，结果是一个long型的ID。这种方案把64-bit分别划分成多段，分开来标示机器、时间等。如图：&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.24666666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbuetyac8TibKV83bfb1DPqbpyrEpK1vDShZ7abmibjib2AcPrFeKE3jbsua07TYfxib1VyeBN6Twk4Io4g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。具体实现的代码可以参看github。&lt;/section&gt;&lt;section&gt;snowflake算法可以根据自身项目的需要进行一定的修改。比如估算未来的数据中心个数，每个数据中心的机器数以及统一毫秒可以能的并发数来调整在算法中所需要的bit数。&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;【优点】&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;稳定性高&lt;/strong&gt;，不依赖于数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;灵活方便&lt;/strong&gt;，可以根据自身业务特性分配bit位。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;单机上ID单调自增&lt;/strong&gt;，毫秒数在高位，自增序列在低位，整个ID都是趋势递增的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;【缺点】&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ID可能不是全局递增。在单机上是递增的，但是由于涉及到分布式环境，每台机器上的时钟不可能完全同步，也许有时候也会出现不是全局递增的情况。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;逆锋起笔&lt;/code&gt;是一个专注于程序员圈子的技术平台，你可以收获&lt;code&gt;最新技术动态&lt;/code&gt;、&lt;code&gt;最新内测资格&lt;/code&gt;、&lt;code&gt;BAT等大厂大佬的经验&lt;/code&gt;、&lt;code&gt;增长自身&lt;/code&gt;、&lt;code&gt;学习资料&lt;/code&gt;、&lt;code&gt;职业路线&lt;/code&gt;、&lt;code&gt;赚钱思维&lt;/code&gt;，微信搜索&lt;code&gt;逆锋起笔&lt;/code&gt;关注！&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMzM2ODUwMA==&amp;amp;mid=2247494531&amp;amp;idx=1&amp;amp;sn=5f653e3020136677c184b13454915cbb&amp;amp;chksm=fa3f0ad8cd4883ce0fd590f33a798a750284b13f0ae6f6b367dc0588382c068b37f52deeac2d&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;黑客破解 APP 常用工具，低调低调！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMzM2ODUwMA==&amp;amp;mid=2247494510&amp;amp;idx=1&amp;amp;sn=9d8f297ca1a18da61f8beffaf46c03b2&amp;amp;chksm=fa3f0a35cd488323f2223777d7cd013e03f4e98c1db341786bb889e8f44e83b1815f5aa246e5&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;一些恶心的代码片段（20 个 if ？）&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMzM2ODUwMA==&amp;amp;mid=2247494494&amp;amp;idx=1&amp;amp;sn=dcd7cc0a8e57572dcaae6548a9dc8feb&amp;amp;chksm=fa3f0a05cd4883133128896ca2a19b15f0ef72484cb7428e6c4c18f4e2db374f23e75c2e58eb&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;为什么 HTTPS 是安全的？&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMzM2ODUwMA==&amp;amp;mid=2247494493&amp;amp;idx=2&amp;amp;sn=0a8c5777a83b3a8e258fbc87cf99a5a1&amp;amp;chksm=fa3f0a06cd488310cc0d0f14d9ba2c67b676a2869bed0df3c1c5c32dfeda2c0b973c1d7f46df&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;API 快速开发平台设计思考&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMzM2ODUwMA==&amp;amp;mid=2247494531&amp;amp;idx=2&amp;amp;sn=b030a3c7543578ad35d47eb84c27b485&amp;amp;chksm=fa3f0ad8cd4883ce4eebd4fb66e0242e472764efc340dcd2ce6c104825bbf8c30fe1a8819226&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;2021 编程语言排行：C#飙升，Python蝉联榜首&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hs540iaTKoaKPniafc8icFWanFqBKibEfLvQn0HKtribhibtAgbxicQUVLllQW86vsQuM0sx6DDkSPf1Ez43hlI6kX6WA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3ac9c6e7f8703fdfabdd9897dd591e08</guid>
<title>14 个写 Java 的习惯</title>
<link>https://toutiao.io/k/5ws6d6j</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;（给&lt;/span&gt;&lt;span&gt;ImportNew&lt;/span&gt;&lt;span&gt;加星标，提高Java技能）&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;strong&gt;&lt;span&gt;1. 定义配置文件信息&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;有时候我们为了统一管理会把一些变量放到 yml 配置文件中&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;例如&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3208791208791209&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIM57fLcJcvxLIicUD5iaDNY2Sjx4FFTia4NsXb3VWL9cMC9xUafKTc4J7xniaDoKjSJ0UdEicwPdwB1zAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;910&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;用 @ConfigurationProperties 代替 @Value&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;使用方法&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;定义对应字段的实体&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;@Data&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;// 指定前缀&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;@ConfigurationProperties&lt;/span&gt;(prefix = &lt;span&gt;&quot;developer&quot;&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;public class DeveloperProperty {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; &lt;span&gt;website&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; &lt;span&gt;qq&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; &lt;span&gt;phoneNumber&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;@Data&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;// 指定前缀&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;@ConfigurationProperties&lt;/span&gt;(prefix = &lt;span&gt;&quot;developer&quot;&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;public class DeveloperProperty {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; &lt;span&gt;website&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; &lt;span&gt;qq&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; &lt;span&gt;phoneNumber&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;使用时注入这个bean&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@&lt;/span&gt;&lt;span&gt;&lt;span&gt;RestController&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;@RequiredArgsConstructor&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;public class PropertyController {&lt;br mpa-from-tpl=&quot;t&quot;/&gt; &lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;DeveloperProperty&lt;/span&gt; &lt;span&gt;developerProperty&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt; &lt;br mpa-from-tpl=&quot;t&quot;/&gt;    @&lt;span&gt;GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/property&quot;&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;Object&lt;/span&gt; &lt;span&gt;index&lt;/span&gt;() {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;       &lt;span&gt;return&lt;/span&gt; &lt;span&gt;developerProperty&lt;/span&gt;&lt;span&gt;.getName&lt;/span&gt;();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2. 用@RequiredArgsConstructor代替@Autowired&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们都知道注入一个 bean 有三种方式哦（set 注入, 构造器注入, 注解注入），Spring 推荐我们使用构造器的方式注入 Bean&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们来看看上段代码编译完之后的样子&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4108527131782946&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIM57fLcJcvxLIicUD5iaDNY2SER5M0hvfdqyeORtbItfbXQlPxc9OibNosG4pI4DRz21DJdGXibCrV6ww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1290&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;RequiredArgsConstructor：lombok提供&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;3.代码模块化&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;阿里巴巴 Java 开发手册中说到每个方法的代码不要超过 50 行（我没记错的话），&lt;/span&gt;&lt;span&gt;在实际的开发中我们要善于拆分自己的接口或方法, 做到一个方法只处理一种逻辑, 说不定以后某个功能就用到了, 拿来即用。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIM57fLcJcvxLIicUD5iaDNY2SRsaCOESPtAdNzfwiaGLDiaDbPErvazjMKjI3IibSyp506PymIwgRGRSVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;4. 抛异常而不是返回&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;在写业务代码的时候，经常会根据不同的结果返回不同的信息，尽量减少返回，会显得代码比较乱&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;反例&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4554183813443073&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIM57fLcJcvxLIicUD5iaDNY2Soibh95jDDhI5HFYx5lEXtw5qB1j7o4vJLXlNRsONJvLHavdibgHk4Siag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1458&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;正例&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2386634844868735&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIM57fLcJcvxLIicUD5iaDNY2SQcNPia4YCdMhMQlp2WK8Lcomialnyia8OUQgSbhgf95yWqp8dKriatqibsA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1676&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;5. 减少不必要的db&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;尽可能的减少对数据库的查询&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;举例子&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;删除一个服务（已下架或未上架的才能删除），&lt;/span&gt;&lt;span&gt;之前有看别人写的代码，会先根据id查询该记录，然后做一些判断&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;反例&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.20039880358923232&quot; data-type=&quot;png&quot; data-w=&quot;2006&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIM57fLcJcvxLIicUD5iaDNY2S1NEeEPYKsCVluxWfoZAAcktH2IJJeqfIEiaqCuvng9BcaRkm0cYknKA/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;正例&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.21201413427561838&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIM57fLcJcvxLIicUD5iaDNY2SK1WLPpVg1KyQ6goItfPfibks0UIkvbLHh3ibRnLShJmL9d1JQy5f4kiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1698&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;6. 不要返回 null&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;反例&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23821339950372208&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIM57fLcJcvxLIicUD5iaDNY2SUL9TOEOkaNgavBh1brO59SUTbQ6adhUwOlDTpHHjtQn6xoSWcLliaQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1612&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;正例&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.21216407355021216&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIM57fLcJcvxLIicUD5iaDNY2SsAGfBYuqE2sTfxnRaIA72SgpPB789ZGh0ZXJ5C94CxmXgAOyxtibM9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1414&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;别处调用方法时，避免不必要的空指针&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;7. if else&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;不要太多了if else if，&lt;/span&gt;&lt;span&gt;可以试试策略模式代替&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;8. 减少controller业务代码&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;业务代码尽量放到service层进行处理，后期维护起来也好操作而且美观&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;反例&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.629500580720093&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIM57fLcJcvxLIicUD5iaDNY2SQ359DsaYwzzqlTLgMgsiciadrHjMmRiagrdPpdYDYT7ic8icLEFnKGAia7oA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1722&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;正例&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7547169811320755&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIM57fLcJcvxLIicUD5iaDNY2SMib75lRgJiaAxxSAgdDAibmc99iadYjns249tRVfnic0Xzqlq4Kia74E9qSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1590&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;9. 利用好Idea&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;目前为止市面上的企业基本都用idea作为开发工具了吧&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;举一个小例子&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;idea会对我们的代码进行判断，提出合理的建议&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;例如：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.19953051643192488&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIM57fLcJcvxLIicUD5iaDNY2S1iaD62Nons7lbmlVmDKNmNDob68Hwic1v1OGzPsFZ6N04iangWV0htyeg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1704&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;它推荐我们用lanbda的形式代替，&lt;/span&gt;&lt;span&gt;点击replace&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.13197278911564625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIM57fLcJcvxLIicUD5iaDNY2Ssibr83Vp5xXGcMPZYTW02v4RHyV0lIQ0iazhS8Im81crkV3ibsX8s6bxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1470&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;10. 阅读源码&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;一定要养成阅读源码的好习惯包括优秀的开源项目GitHub上stars:&amp;gt;1000, 会从中学好好多知识包括其对代码的设计思想以及高级API，面试加分（好多面试官习惯问源码相关的知识）&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;11. 设计模式&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;23种设计模式，要尝试代码中运用设计模式思想，写出的代码即规范又美观还高大上哈哈。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;12. 拥抱新知识&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;像我们这种工作年限少的程序员，我觉得要多学习自己认知之外的知识，不能每天crud，有机会就多用用有点难度的知识，没有机会（项目较传统），可以自己下班多些相关demo练习&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;13. 基础问题&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;map遍历&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;HashMap&amp;lt;&lt;span&gt;String&lt;/span&gt;, &lt;span&gt;String&lt;/span&gt;&amp;gt; map = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        map.put(&lt;span&gt;&quot;name&quot;&lt;/span&gt;, &lt;span&gt;&quot;du&quot;&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;String&lt;/span&gt; key : map.keySet()) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;String&lt;/span&gt; value = map.get(key);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        }&lt;br mpa-from-tpl=&quot;t&quot;/&gt; &lt;br mpa-from-tpl=&quot;t&quot;/&gt;        map.forEach((k, v) -&amp;gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt; &lt;br mpa-from-tpl=&quot;t&quot;/&gt;        });&lt;br mpa-from-tpl=&quot;t&quot;/&gt; &lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;// 推荐&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;Map&lt;/span&gt;.Entry&amp;lt;&lt;span&gt;String&lt;/span&gt;, &lt;span&gt;String&lt;/span&gt;&amp;gt; entry : map.entrySet()) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt; &lt;br mpa-from-tpl=&quot;t&quot;/&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;optional 判空&lt;/strong&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;//获取子目录列表&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;List&lt;/span&gt;&amp;lt;CatalogueTreeNode&amp;gt; getChild(String pid) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;if&lt;/span&gt; (V.isEmpty(pid)) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            pid = BasicDic.TEMPORARY_DIRECTORY_ROOT;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        CatalogueTreeNode node = treeNodeMap.get(pid);&lt;br mpa-from-tpl=&quot;t&quot;/&gt; &lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; Optional.ofNullable(node)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                .map(CatalogueTreeNode::getChild)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                .orElse(Collections.emptyList());&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;递归&lt;/strong&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;大数据量的递归时，避免在递归方法里new对象，可以试试把对象当作方法参数进行传递使用&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;注释&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;类 接口方法 注解 较复杂的方法 注释都要写而且要写清楚, 有时候写注释不是给别人看的 而是给自己看的&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;14. 判断元素是否存在&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;hashSet 而不是 list，&lt;/span&gt;&lt;span&gt;list 判断一个元素是否存在的代码&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;ArrayList&amp;lt;String&amp;gt; &lt;span&gt;list&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br mpa-from-tpl=&quot;t&quot;/&gt; &lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;// 判断a是否在list中&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt; &lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;list&lt;/span&gt;.size(); i++)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;       &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;a&quot;&lt;/span&gt;.equals(elementData[i]))&lt;br mpa-from-tpl=&quot;t&quot;/&gt;          &lt;span&gt;return&lt;/span&gt; i;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;由此可见其复杂度为On，&lt;/span&gt;&lt;span&gt;而hashSet底层采用hashMap作为数据结构进行存储，元素都放到map的key（即链表中）&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;HashSet&amp;lt;String&amp;gt; &lt;span&gt;set&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;();&lt;br mpa-from-tpl=&quot;t&quot;/&gt; &lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;// 判断a是否在set中&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt; &lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;int&lt;/span&gt; index = hash(a);&lt;br mpa-from-tpl=&quot;t&quot;/&gt; &lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;return&lt;/span&gt; getNode(index) != &lt;span&gt;null&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;由此可见其复杂度为O1。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/code&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;75&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;span&gt;转自：国涛1998&lt;/span&gt;&lt;br/&gt;&lt;span&gt;来源：https://blog.csdn.net/weixin_44912855/article/details/120866194&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-recommend-type=&quot;list-title&quot; data-recommend-tid=&quot;6&quot; data-mpa-template=&quot;t&quot; data-mid=&quot;&quot; data-from=&quot;yb-recommend&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;1、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651509934&amp;amp;idx=1&amp;amp;sn=554e76ef40f383f9af6b4fcd19c202b5&amp;amp;chksm=bd25b8d18a5231c7b8e66058b57bf7c3cfe6174c8db2e2d9ce57c86698f46ab48a67488c2ca2&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;重磅！Elasticsearch 8 正式发布！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;重磅！Elasticsearch 8 正式发布！&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651509896&amp;amp;idx=1&amp;amp;sn=a6c6ece605144f9f37d8a3b1485057d1&amp;amp;chksm=bd25b8f78a5231e1a153a9527e87ead642f55420a659e467468abeff6882d94d08f25bb67c2f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;AlphaCode 惊世登场！编程版“阿法狗”悄悄参赛，击败一半程序员&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;AlphaCode 惊世登场！编程版“阿法狗”悄悄参赛，击败一半程序员&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651509893&amp;amp;idx=1&amp;amp;sn=d639efbb6fde49d3620646e433150f7b&amp;amp;chksm=bd25b8fa8a5231ecb5ffc3f81a40ecbc3479dbb6e1a5b8f7dc0fbb322da81b6b39ca2c4477ae&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;20 个超级使用的 Java 8 Stream，玩转集合的筛选、归约、分组、聚合&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;20 个超级使用的 Java 8 Stream，玩转集合的筛选、归约、分组、聚合&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关注「ImportNew」，提升Java技能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9166666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点赞和在看就是最大的支持❤️&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>25a31254816055550fda984e89cd2c01</guid>
<title>如何设计一个复杂的业务系统？从对领域设计、云原生、微服务、中台的理解开始</title>
<link>https://toutiao.io/k/b1alegj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                                    


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;&lt;span&gt;点击上方“朱小厮的博客”，选择“&lt;/span&gt;&lt;span&gt;设为星标”&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;后台回复&quot;&lt;/span&gt;&lt;span&gt;书&lt;/span&gt;&lt;span&gt;&quot;，获取&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;后台回复“&lt;span&gt;k8s&lt;/span&gt;”，可领取k8s资料&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU0MzQ5MDA0Mw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/HV4yTI6PjbIm3eMcgbiaMpZBnqgDlw12kDd4RryiaCBL8OWyCyjH9iagqMyOD12iaLksDlsaqUPrTV5czdUb0l2FlQ/0?wx_fmt=png&quot; data-nickname=&quot;朱小厮的博客&quot; data-alias=&quot;hiddenkafka&quot; data-signature=&quot;著有畅销书：《深入理解Kafka》和《RabbitMQ实战指南》。公众号主要用来分享Java技术栈、Golang技术栈、消息中间件（如Kafka、RabbitMQ）、存储、大数据以及通用型技术架构等相关的技术。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;01&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;3&quot; mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:395&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;如何解决复杂业务设计&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;Aliware&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;软件架构设计本身就是一个复杂的事情，但其实业界已有一个共识，那就是“通过组件化完成关注点的分离从而降低局部复杂度”。其实现在我们用的无论是容器、中间件、消息、数据库等，在某种意义上都是组件化的产物。这样的好处是在不同的系统里可以复用。在云原生兴起的今天，以通用的、组件化的服务形式更容易为我们所用，所以说现在如果还不享用云原生技术红利，那你就会被时代抛弃。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;285&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.493167701863354&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/qdzZBE73hWtsrEPCdSI9vkQBF1UPq1yCYl9XicZrNgtsnWAqD3fUGL8bCMFocoIWyib1icLEaUIlZ7TdgdA5dFGFQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1610&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;云原生满足非功能性质量需求&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;云原生在技术上能够最大程度的解决众多非功能性质量和技术需求（如上图），那作为一个企业级应用架构，自然会把专注点转移到业务应用功能性设计本身上来。现在来说对于一个复杂业务架构进行设计，我们要想做到又快又好，无非是两种情况：一是架构师本身对业务理解很深、能力超强、炉火纯青；二是原有的业务系统本身模型清晰，足够的“高内聚低耦合”，可以快速在其基础之上分析业务变化形成新的业务架构设计。我们应该追求的是第二种情况，这也就意味着从一开始的企业级模型建设，就要对模型设计、业务流程仔细对待，只有做到基础扎实，才能有后面的“快速迭代”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们再回到架构设计的本质，即为什么我们要在代码实现前做设计。设计首先是要解决问题的复杂度。于是有人做了一个架构，交给了一个团队去实现，很快发现实现的架构和设计完全是两回事。当然原因很明确——缺少了交流和沟通；其次是要建立团队协作沟通的共识。即使我们做好了一个团队都达成共识的架构设计，大家都兢兢业业把设计变成了现实，一个长期困扰软件行业的问题出现了，需求总是在变化，无论预先设计如何“精确”，总是发现下一个坑就在不远处，结果往往是情况越来越糟糕，也就是我们常说的架构“腐化”了，最后大家不得不接受重写。这些经历让我们逐步明确了软件架构设计的实质是通过核心问题的分离降低复杂度，并让系统能够更快地响应外界业务的变化，并且使得系统能够持续演进。在遇到变化时不需要从头开始，保证实现成本得到有效控制。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，我觉得从架构设计角度，以下三点是最为关键的：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;让我们的模型、组件和业务划分尽量靠近变化的本质，比如对于一般电商系统来说，就是用户、商品、交易、支付等，这样的划分能够让我们将变化“隔离”在一定的范围(业务模块)内，从而帮助我们有效减少改变点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;设计上，业务模型内部是高内聚，模型之间是低耦合，即各自完成的业务是相对独立的，不会因为一方掉线而牵连另外一方，比如商品推荐功能挂掉了，但是交易和支付业务应该继续正常提供服务，可能提示用户暂时无法提供推荐服务，或者干脆降级为兜底策略。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;模型、组件在业务上尽可能是复用的，正是这样的复用才成就了今天的互联网级架构，我们不会每做一个电商系统都从零做起。而被“复用”最多的业务模块显然会重点设计和运营，成为核心业务模块。当然架构上这样的电商系统必然也会比较健壮。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面的三点毫无疑问都指向了业务，从业务出发、面向业务变化是我们现代架构设计成功的关键，所以说复杂业务架构设计的核心实质是保证面对业务变化时我们能够有足够快的响应能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;02&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;3&quot; mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:395&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;领域设计&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;Aliware&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h1&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;前面说了业务软件开发的常见病：从一个小的项目不断开发演化变成一个大型业务系统，但随着新需求的不断增加，最终演变成了开发团队的噩梦。而这些噩梦大部分是源于软件的概念完整性（“概念完整性”一词来源于软件工程的经典著作《人月神话》）遭到了破坏。这些业务代码可能是一代又一代的开发人员各行其道的堆叠起来的（我们又称之为“屎山”），而这个过程中没人有意识的去维护软件的概念完整性。而 DDD 领域设计，特别是 DDD 提供的战略建模层面的概念，是维护软件概念完整性的良药。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“技术服务于业务、业务驱动技术”是目前大部分人的共识，尤其是对商业公司而言。而 DDD 领域设计主张在软件设计中把业务领域本身作为关注的焦点（换句话说就是软件开发人员要懂业务）非常符合这种思想；并且，DDD 提供了切实可行的面对复杂业务软件设计的解决方法，这也是我非常提倡作为一个架构师去深入学习和讨论 DDD 领域设计的相关知识。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;01&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;战略建模&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;在战略层面，DDD 非常强调对业务问题的分析和分解，通过识别核心问题来降低问题的复杂度。DDD 在战略层面维护模型的概念完整性的方法，最重要的两个概念就是界限上下文（Bounded Context）和防腐层（Anti-Corruption Layer）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于界限上下文的定义，随便一本讲 DDD 的书上都会详细讲解，这里我只想分享一下自己的一些理解。这时，有人会问：界限上下文多大才能合适呢，划分上下文有没有可以遵循的规则呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;划分上下文的规则，无非就是放之四海而皆准的“高内聚、低耦合”，这么说可能还是太虚。其实真正让大家感到纠结的是，不知如何切分的那些东西之间所存在的关联，有的甚至干脆都纳入到一个上下文里。其实，我认为与其关注上下文的“大小”，不如关注模型的“质量”，关注概念的完整性是不是容易被破坏。我觉得，判断大小是不是合适，要结合应用开发团队的能力，看开发团队能在多大的一个范围内掌控软件的概念完整性。只要是开发团队没有问题，这个范围就算再大也都是可以的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果开发团队的水平在业界属于上游，那么维护上下文的范围往往是很大的；一些公司开发团队的水平参差不齐，所以在项目的实施过程中，可能需要划分相对小的上下文，尽可能减少“屎山”的不断堆积。 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;界限上下文需要时刻保护好自己所维护的边界，以及边界内概念的完整性，这时需要将某个上下文的概念转化为另一个上下文概念的地方就叫做“防腐层”。防腐层的实现有很多种，典型的比如作为适配器 Adaptor 来实现，另外广义上讲，Gateway 也是一个典型性的防腐层组件，当然，防腐层的代码和其他内部业务模型之间要存在明显的物理边界（当然不一定说要把防腐层作为一个个独立部署的进程），至少我们可以考虑把防腐层作为一个独立的类库来进行构建和维护，阿里内部的比如星环、其实就是这个思路。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;313&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5422222222222223&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWtsrEPCdSI9vkQBF1UPq1yCs5ibicsLRAb9sZsNuv0NPKa0ntEFibUwloNJSz2zVSp2fD5oIE0C3LvuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;675&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个典型的防腐层的设计&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;02&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;战术建模&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DDD 在战术上最核心的概念就是实体和聚合，为了更好的理解什么是聚合、聚合根、聚合内部实体，下面举例说明一下。想象一下一个电商系统的订单相关的模型，我们可能会得到订单 Order、订单头 OrderHeader、订单行项 OrderItem 三个相互关联的概念：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;一个叫做 Order 的聚合。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;这个订单聚合的聚合根是一个叫做 OrderHeader 的实体，实体 OrderHeader 的 ID 叫做 OrderId（订单号）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;通过 OrderHeader 实体，我们可以访问 OrderItem 实体的一个聚合。OrderItem 这个实体的局部 ID 叫做 ProductId（产品 ID）。因为业务善变不允许在同一个订单的不同订单项内出现同一个产品，所以我们可以选择产品 ID 作为订单项的局部 ID。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“聚合是数据修改的单元”，基于这个原则，我们可以做到“聚合内强一致、聚合外最终一致”，比如，我们可以不能接受一个订单内的所有订单项的金额之和不等于订单头的总金额，我们就必须把订单头和订单行项这两个实体划分到同一个聚合内。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们不妨先看一下《实现领域驱动设计》一书中对聚合设计原则的描述，原文是有点不太好理解的，我来稍微解释一下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在一致性边界内建模真正的不变条件。聚合用来封装真正的不变性，而不是简单地将对象组合在一起。聚合内有一套不变的业务规则，各实体和值对象按照统一的业务规则运行，实现对象数据的一致性，边界之外的任何东西都与该聚合无关，这就是聚合能实现业务高内聚的原因。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;尽量设计小的聚合。如果聚合设计得过大，聚合会因为包含过多的实体，导致实体之间的管理过于复杂，高频操作时会出现并发冲突或者数据库锁，最终导致系统可用性变差。而小聚合设计则可以降低由于业务过大导致聚合重构的可能性，让领域模型更能适应业务的变化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;通过唯一标识引用其它聚合。聚合之间是通过关联外部聚合根 ID 的方式引用，而不是直接对象引用的方式。外部聚合的对象放在聚合边界内管理，容易导致聚合的边界不清晰，也会增加聚合之间的耦合度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在边界之外使用最终一致性。聚合内数据强一致性，而聚合之间数据最终一致性。在一次事务中，最多只能更改一个聚合的状态。如果一次业务操作涉及多个聚合状态的更改，应采用领域事件的方式异步修改相关的聚合，实现聚合之间的解耦（相关内容我会在领域事件部分详解）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;通过应用层实现跨聚合的服务调用。为实现微服务内聚合之间的解耦，以及未来以聚合为单位的微服务组合和拆分，应避免跨聚合的领域服务调用和跨聚合的数据库表关联。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面的这些原则是 DDD 的一些通用的设计原则，还是那句话：“适合自己的才是最好的。”在系统设计过程时，你一定要考虑项目的具体情况，如果面临使用的便利性、高性能要求、技术能力缺失和全局事务管理等影响因素，这些原则也并不是不能突破的，总之一切以解决实际问题为出发点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DDD 领域建模通常采用类似事件风暴，一般通过用例分析、场景分析和用户旅程分析等方法，通过头脑风暴列出所有可能的业务行为和事件，然后找出产生这些行为的领域对象，并梳理领域对象之间的关系，找出聚合根，找出与聚合根业务紧密关联的实体和值对象，再将聚合根、实体和值对象组合，构建聚合。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;电商系统大家都比较熟悉了，而且关于电商业务来说有许多比较成熟的模型可以直接借鉴；那下面我们以另外一个场景-保险投保业务为例，看一下聚合的构建过程主要都包括哪些步骤，当然这个例子我是从其他的学习资料里看到的，比较典型，可以当作示例来进行说明：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;316&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5473441108545035&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWtsrEPCdSI9vkQBF1UPq1yC7ebK5Q1x7gEgRPtAjGCt1ZqfXKIuqz23frprZW9FNasajhsjcJVUJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;866&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;保险投保业务简单示例（From 学习资料）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;第一步：采用用例分析或事件风暴等方法，根据业务行为，梳理出在过程中发生这些行为的所有的实体和值对象，比如投保单、标的、客户、被保人等等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;第二步：从众多实体中选出适合作为对象管理者的根实体，也就是聚合根。判断一个实体是否是聚合根，上一章也说过，你可以结合以下场景分析：是否有独立的生命周期？是否有全局唯一 ID？是否可以创建或修改其它对象？是否有专门的模块来管这个实体。图中的聚合根分别是投保单和客户实体。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;第三步：根据上一章说的设计聚合的原则，找出与聚合根关联的所有紧密依赖的实体和值对象。构建出一个包含一个聚合根、多个实体和值对象的对象集合，这个集合就是聚合。在图中我们构建了客户和投保这两个聚合。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;第四步：在聚合内根据聚合根、实体和值对象的依赖关系，画出对象的引用和依赖模型。这里需要说明一下：投保人和被保人的数据，是通过关联客户 ID 从客户聚合中获取的，在投保聚合里它们是投保单的值对象，这些值对象的数据是客户的冗余数据，即使未来客户聚合的数据发生了变更，也不会影响投保单的值对象数据。从图中我们还可以看出实体之间的引用关系，比如在投保聚合里投保单聚合根引用了报价单实体，报价单实体则引用了报价规则子实体。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;第五步：多个聚合根据业务语义和上下文一起划分到同一个限界上下文内。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那以上就是一个聚合诞生的完整过程了。&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/h1&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;03&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;3&quot; mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:395&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;不同场景下的领域建模策略&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;Aliware&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h1&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;由于企业内情况千差万别，发展历程也不一样，有遗留单体系统的微服务改造，也有全新未知领域的业务建模和系统设计，还有遗留系统局部优化的情况。不同场景下，领域建模的策略也会有差异。下面我们就分几类场景来看看如何进行领域建模。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;01&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;新建系统&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;新建系统对于复杂的业务领域，领域可能需要多级拆分后才能开始领域建模。领域拆分为子域，甚至子域还需要进一步拆分。比如：保险它需要拆分为承保、理赔、收付费和再保等子域，承保子域再拆分为投保、保单管理等子子域。复杂领域如果不做进一步细分，由于问题域太大，领域建模的工程量会非常浩大。你不太容易通过事件风暴，完成一个很大的领域建模，即使勉强完成，效果也不一定好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于复杂领域，我们可以分三步来完成领域建模和微服务设计。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;拆分子域建立领域模型，根据业务领域的特点，参考流程节点边界或功能聚合模块等边界因素。结合领域专家和项目团队的讨论，将领域逐级分解为大小合适的子域，针对子域采用事件风暴，划分聚合和限界上下文，初步确定子域内的领域模型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;领域模型微调梳理领域内所有子域的领域模型，对各子域领域模型进行微调。微调的过程重点考虑不同领域模型中聚合的重组。同步考虑领域模型和聚合的边界，服务以及事件之间的依赖关系，确定最终的领域模型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;微服务的设计和拆分根据领域模型和微服务拆分原则，完成微服务的拆分和设计。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;02&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;单体遗留系统&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;如果我们面对的是一个单体遗留系统，只需要将部分功能独立为微服务，而其余仍为单体，整体保持不变，比如将面临性能瓶颈的模块拆分为微服务。我们只需要将这一特定功能，理解为一个简单子领域，参考简单领域建模的方式就可以了。在微服务设计中，我们还要考虑新老系统之间服务和业务的兼容，必要时可引入防腐层。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;04&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;3&quot; mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:395&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;云原生时代下的挑战&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;Aliware&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h1&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;随着云原生技术的兴起，现在企业级架构就更加的云化，而云化的架构风格有了新的关注点：弹性边界。弹性边界是一个云原生企业级应用架构的核心概念，它指把弹性作为最优先的考虑要素而划定的系统边界，决定了我们是否能够充分发挥云原生平台的全部能力。于是我们就需要新的方法来弥补以前业务模型的不足，以满足新的云原生化的需要。现在可以说，微服务基本上就是以云原生架构作为基础，而在固定弹性的平台上使用微服务架构，有极高的实施成本。可以说，云原生实际上就应该是微服务的前置条件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在云原生时代，我们需要将弹性作为首要考虑的因素，纳入建模的考量。那么弹性边界，就是我们划分系统的重要依据。而且，我们还需要考虑弹性边界间的依赖关系，尽量避免弹性耦合。对于业务建模来说，为了配合云原生时代的架构，我觉得要做到如下几点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;确立一种模型结构能够反映弹性边界，而这时候需要考虑不同弹性边界的原则来划分界限上下文；如果两个上下文明显具有不同的弹性诉求，那就应该拆分。而如果具有一致的弹性诉求，可以考虑先不拆。那这个时候拆分微服务到底能多“微”呢？简单说就是“微”到能够更好的利用弹性来控制成本的大小。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;从异步模型的视角，去优化业务逻辑；典型就是 MQ 消息队列系统，由于有 broker，所以生产者和消费者不必在同一时间都保持可用性以及相同的吞吐量，而且生产者也不需要马上等到回复。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;位置的松耦合：典型就是服务注册中心，消费端完全不需要直接知道提供端的具体位置，而都通过注册中心来查找服务来访问。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在弹性边界切分业务上下文时，同一个弹性边界内部维护业务强一致性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在异步调用产生中间态异常时，需要维护业务最终一致性。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/h1&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;05&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;3&quot; mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:395&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;不要忽视组织结构的影响&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;Aliware&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h1&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;“康威定律”告诉我们，组织结构会决定团队沟通的结构，也会决定产品的结构。对组织结构的梳理，在需求调研的时候会经常做。如果是信息收集而言，业务架构设计在这里并没有什么特殊之处。区别在于，业务架构的目标是企业级的能力规划，希望能够突破壁垒、形成合力。正是这个原因，组织结构对业务架构设计的反作用力也是很大的，企业级数字化转型方案要与组织结构相匹配，否则落地的时候会困难重重。可以说，部门利益是做企业级架构的最大障碍之一，跨越这个障碍也是对架构师的能力的要求之一。当然，有些情况下，没有更好的解决方案时，不动也是一种选择。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以我的经验，这种问题没有特别好的办法，无非是两种：一是有超强能力者主导，在最高层的支持下，强力推进这种决策，但是企业越大，尤其是以业务为主导地位的企业中，这种结构就愈难形成；二是加强企业内部的业务架构人员的能力和数量（最好各个部门都有类似的角色），让这些企业机构人员以合作伙伴的方式全程参与到项目中，在项目的实施过程中搭建起协作网络，提升决策效率，才能使组织结构不再是企业数字化转型的瓶颈。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;06&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;3&quot; mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:395&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;SOA-微服务-中台：妥协的艺术&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;Aliware&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h1&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;多年前，这些传统的大型 ERP 业务软件，其实都是在一个很大的范围内维护业务概念的完整性。一个 ERP 安装完毕后，数据库有七八百张表（也就是七八百个实体）处于同一个界限上下文之内。但是这些 ERP 在这样一个巨大的界限上下文内仍然很好的维护了业务概念的完整性，实在令人敬佩。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然而实现它非常困难，但是破坏它却非常容易。一套 ERP 定制项目实施下来，数据库里可能又多了几百张表，更不用说不规范的命名看起来千奇百怪。这些厂商的 ERP 实施顾问和开发人员，夜以继日的维护这个庞大的“屎山”。我们不能让这些庞大的“单体应用”无限制的增长，于是我们又一次祭起了“分而治之”的大旗。想 SOA 这样的软件组件化技术给我们提供了拆分的工具。我们把一个大的界限上下文按照利于拆分成几个相对来说小一些的界限上下文；在物理上，我们把一个大的单体应用拆分成若干服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一般来说，我们会让服务的物理边界和界限上下文的领域边界基本堆砌，一个界限上下文对一个或多个可以独立部署的服务应用，服务应用包含了界限上下文的核心业务逻辑的实现。SOA 的服务组件的物理边界给服务间的调用增加了一些困难，这就使得开饭人员简化对象之间的关系，编写更加“高内聚、低耦合”的代码。当服务组件不多的时候，构建防腐层的工作量也不会很大，我们只要处理好组件之间的代码即成就好了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是，我们的架构师和开发人员太喜欢“分而治之”了，微服务的广泛使用甚至说是滥用，让我们看很多微服务真的是很“微”，几乎是一个 DDD 的聚合就可以对应一个可以独立部署的微服务。这样的微服务单单靠本身做不了太多的业务，这就需要更多更多的微服务“聚合”起来一起才能对外提供业务服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然，微服务技术基础设施的发展也为服务之间的调用提供了更多的便利，跨越微服务的边界成为了常态；这个时候，业务开发人员区分“同一个上下文内的服务调用”和“上下文之间的防腐层”就要时刻保持头脑清醒，这时候的界限上下文和微服务的物理边界往往很难对齐，这就必然增加了维护每个界限上下文概念完整性的难度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;既然维护一个个“微小”的独立的界限上下文概念完整性越来愈难，那么我们干脆将它们再聚合起来吧？将它们融合到一个大小适度的界限上下文，那这就是所谓的企业级业务架构，也就是我们现在说的业务中台，最终目的可以说想要获得“企业级”的大和谐。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以在一定程度上讲，软件工程就是妥协的艺术，是“中庸之道”。我们要不要中台，要大的中台，不管企业的大小，都应该结合自身的业务目标以及拥有的资源，在“维护更大范围的概念完整性”和“维护更多的防腐层代码”之间做出平衡，那这也是一个企业级架构师所要做的最核心的事情之一。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们团队这些年确实做了一些“业务中台方法论”的积累和实践，并且在一些项目中做了实践，当然其中最灵魂的部分之一还是前面说的领域设计。以前很多人说 DDD 领域设计乃至业务中台方法论最难的就是没有一个合适的工具或者平台来实践，今天其实阿里开源的 COLA 以及内部使用的星环、BizWorks 都是很好的工具和平台。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;07&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;3&quot; mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:395&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;结语&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;Aliware&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h1&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;企业级应用架构是在不断的演进和迭代，但是我始终感觉企业应用架构的形成过程是在一种看起来科学的方法论下，但是又不完全科学的过程中实现的。仔细想一下，做软件架构的其实很羡慕做建筑架构的，因为建筑架构有严谨的力学基础作为基座，有很多可以精确计算的东西，而软件架构却没有多少可以精确计算出来的成分，所以，前面说的“不断的妥协”不失是一种可行的设计思路和设计艺术；其实这也应验了那句“没有银弹”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于时间仓促，有些内容简单带过，有些本应该结合实例来说明的地方在本文中也简略而过，后面有时间的话我会结合更多的实际案例来对本文说的观点进行补充。也希望本文能够激发大家一起对目前云原生时代的企业级应用架构设计的思考和讨论，相互学习，共同进步。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;来源：阿里巴巴中间件&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.06323529411764706&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tibrg3AoIJTtc9JAwPTOa96Mg7vSgZu3opdloACN6fZDnqV75oyibHDr7siaIXmcQddIbTNGtcFr6ibYnUtRfq9Weg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;680&quot; title=&quot;分割线 卡通&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;想知道更多？&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;扫&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;描下面的二维码关注我&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.4165784832451499&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HV4yTI6PjbIcs5MZX8niaYh7DEowjuLobqETwibzea3Va3nlRECh6kPt68KSYte97k600ZibjGtbxuanDtMkEkOeA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2835&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;后台回复&quot;&lt;/span&gt;&lt;span&gt;技术&lt;/span&gt;&lt;span&gt;&quot;，加入技术群&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;后台回复“&lt;/span&gt;&lt;span&gt;k8s&lt;/span&gt;&lt;span&gt;”，可领取k8s资料&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;【精彩推荐】&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>