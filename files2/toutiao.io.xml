<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>ad5745381a9c1b7947750066369392e2</guid>
<title>困在内卷里的工程师 | 码农周刊第 322 期</title>
<link>https://toutiao.io/k/mb7u8g0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;issue&quot; id=&quot;readabilityBody&quot;&gt;
        &lt;h1&gt;困在内卷里的工程师 | 码农周刊第 322 期&lt;/h1&gt;
        &lt;h2&gt;码农周刊第322期（2020-10-21）&lt;/h2&gt;
        &lt;p&gt;☞ &lt;a href=&quot;https://weekly.manong.io/bounce?nid=322&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3220&quot; target=&quot;_blank&quot;&gt;薪资翻番如何实现？程序员的涨薪秘诀&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;a href=&quot;https://weekly.manong.io/bounce?nid=322&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3220&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_321.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;small&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=322&amp;amp;aid=19185&amp;amp;url=https%3A%2F%2Fjinshuju.net%2Ff%2FV7DxN9&quot; target=&quot;_blank&quot;&gt;商务合作&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
        
        &lt;h3 id=&quot;程序设计&quot;&gt;程序设计&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;业界实战&lt;/p&gt;
        
        &lt;p&gt;实战经验&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;VIP会员专区&quot;&gt;VIP会员专区&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;工作地点：成都 | 薪资：15-30K | 简历投递邮箱：xiexiaofang@huobi.com&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;功能强大、配置简单、完全开源。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;第三代 AI 发展的思路是把第一代的知识驱动和第二代的数据驱动结合起来，通过利用知识、数据、算法和算力等 4 个要素，构造更强大的 AI……&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;斯坦福教授、Tcl 语言发明者 John Ousterhout 的著作《A Philosophy of Software Design》，自出版以来，好评如潮。&lt;/p&gt;
        &lt;h3 id=&quot;工具资料&quot;&gt;工具资料&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;实战经验&lt;/p&gt;
        
        &lt;p&gt;适合新手&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;试试吧&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;图文并茂&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;代码示例&lt;/p&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程语言&quot;&gt;编程语言&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;实用&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;一步步教你&lt;/p&gt;
        
        &lt;p&gt;代码示例&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        &lt;h3 id=&quot;每周独家号推荐&quot;&gt;每周独家号推荐&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 448635 即可&lt;/p&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 429587 即可&lt;/p&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 412364 即可&lt;/p&gt;
        
        &lt;p&gt;编程、成长、正能量！&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 381811 即可&lt;/p&gt;
        
        &lt;p&gt;分享Go语言相关内容&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 133906 即可&lt;/p&gt;
        &lt;h3 id=&quot;每周一书&quot;&gt;每周一书&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=322&amp;amp;aid=20030&amp;amp;url=https%3A%2F%2Fitem.jd.com%2F12972072.html&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/book_322.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程之外&quot;&gt;编程之外&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;欢迎讨论&lt;/p&gt;
        
        &lt;p&gt;部分适用于百度&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;p&gt;
        &lt;/p&gt;
        
        
        
        
        &lt;div class=&quot;qrcode&quot;&gt;
  &lt;img src=&quot;https://img.toutiao.io/ads/vip_qrcode.png&quot; alt=&quot;Qrcode 258&quot;/&gt;&lt;span&gt;加入码农周刊VIP会员&lt;/span&gt;
&lt;/div&gt;
    &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>620dbcf6bc07e39731ab98599ad7cc50</guid>
<title>MySQL 8 和 PostgreSQL 10 功能对比</title>
<link>https://toutiao.io/k/jlhc45y</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在MySQL 8和PostgreSQL 10已经发布，现在是重新审视两个主要的开源关系数据库如何相互竞争的好时机。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这些版本之前，一般的看法是，虽然Postgres在功能集及血统方面更胜一筹，但MySQL在大规模并发读/写操作方面进行了更多的大规模测试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是随着最新版本的发布，两者之间的差距已大大缩小。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;功能对比&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面看一下通常我们认为比较&lt;code&gt;时髦&lt;/code&gt;的功能。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;特征&lt;/th&gt;&lt;th&gt;MySQL8&lt;/th&gt;&lt;th&gt;PostgreSQL10&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;「查询和分析」&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;通用表达式(CTEs)&lt;/td&gt;&lt;td&gt;✔ New&lt;/td&gt;&lt;td&gt;✔&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;视窗功能&lt;/td&gt;&lt;td&gt;✔ New&lt;/td&gt;&lt;td&gt;✔&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;「数据类型」&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;支持JSON&lt;/td&gt;&lt;td&gt;✔ Improved&lt;/td&gt;&lt;td&gt;✔&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;GIS / SRS&lt;/td&gt;&lt;td&gt;✔ Improved&lt;/td&gt;&lt;td&gt;✔&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;全文搜索&lt;/td&gt;&lt;td&gt;✔&lt;/td&gt;&lt;td&gt;✔&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;「扩展性」&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;逻辑复制&lt;/td&gt;&lt;td&gt;✔&lt;/td&gt;&lt;td&gt;✔ New&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;半同步复制&lt;/td&gt;&lt;td&gt;✔&lt;/td&gt;&lt;td&gt;✔ New&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;声明式分区&lt;/td&gt;&lt;td&gt;✔&lt;/td&gt;&lt;td&gt;✔ New&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;过去常常说MySQL最适合在线交易，而PostgreSQL最适合分析过程，但是现在不再是如此局面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通用表达式（CTEs）和窗口函数一直是多数人选择PostgreSQL的主要原因。但是现在，在同一个表中&lt;code&gt;employees&lt;/code&gt;引用对表进行递归遍历&lt;code&gt;boss_id&lt;/code&gt;，或者在排序结果中找到中间值（或50％百分位数），在MySQL上不再是问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PostgreSQL上的复制缺乏配置灵活性，这是Uber转向MySQL的原因。但是现在有了逻辑复制，可以通过使用更新版本的Postgres创建副本并切换到该副本来实现零停机时间升级。截断大型时序事件表中的陈旧分区也容易得多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在功能方面，两个数据库现在彼此相同。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二者有什么区别？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在有一个问题就是，我们到底是选择MySQL还是PostgreSQL，那选择的原因又是什么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「生态系统」&lt;/strong&gt;就是这些因素之一。MySQL拥有一个强大的生态系统，其中包含MariaDB，Percona，Galera等变体，以及InnoDB以外的其他存储引擎，但它们也可能令人不知所措。Postgres的高端选项有限，但是随着最新版本引入的新功能，这种情况将会改变。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「治理」&lt;/strong&gt;是另一个因素。每个人都在担心甲骨文（或最初为SUN）收购MySQL时，他们会毁了该产品，但过去十年来情况并非如此。实际上，收购后发展加速。Postgres在工作治理和协作社区方面拥有悠久的历史。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「体系结构的基本原理」&lt;/strong&gt;不会经常更改，但是值得值得我们回顾。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;特征&lt;/th&gt;&lt;th&gt;MySQL8&lt;/th&gt;&lt;th&gt;PostgreSQL10&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;架构&lt;/td&gt;&lt;td&gt;单进程&lt;/td&gt;&lt;td&gt;多进程&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;并发&lt;/td&gt;&lt;td&gt;多线程&lt;/td&gt;&lt;td&gt;fork(2)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;表结构&lt;/td&gt;&lt;td&gt;聚合索引&lt;/td&gt;&lt;td&gt;Heap(堆)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;页面压缩&lt;/td&gt;&lt;td&gt;透明&lt;/td&gt;&lt;td&gt;TOAST&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;更新&lt;/td&gt;&lt;td&gt;就地/回滚Segments&lt;/td&gt;&lt;td&gt;仅追加/ Hot&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;垃圾回收&lt;/td&gt;&lt;td&gt;清除线程&lt;/td&gt;&lt;td&gt;自动回收进程&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Transaction Log&lt;/td&gt;&lt;td&gt;REDO Log (WAL)&lt;/td&gt;&lt;td&gt;WAL&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Replication Log&lt;/td&gt;&lt;td&gt;Separate (Binlog)&lt;/td&gt;&lt;td&gt;WAL&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;进程对比线程&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当Postgres fork一个子进程来建立连接时，每个连接最多需要10 MB的空间。与MySQL的“每次连接线程”模型相比，内存压力更大，后者在64位平台上，线程的默认堆栈大小为 256KB。（当然，线程局部排序缓冲区等可以使此开销的重要性降低，即使可以忽略不计，但仍然如此。）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即使写时复制会与父进程一起保存一些共享的，不变的内存状态，但是当您有1000个以上的并发连接时，作为基于进程的体系结构的基本开销会增加负担，并且它可能是最重要的开销之一能力计划的因素。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，如果您在30台服务器上运行Rails应用程序，其中每台服务器具有16个CPU内核和32个Unicorn worker，则您有960个连接。在所有应用程序中，可能只有不到0.1％会达到这个规模，但这是需要牢记的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;聚合索引对比堆(Heap)表&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;聚合索引是其中行被直接嵌入主键的B树结构内的表结构。（非聚合）堆(Heap)是规则表结构，其中填充了与索引分开的数据行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用聚合索引时，当您通过主键查找记录时，单个I / O将检索整行，而非聚集索引始终通过遵循引用至少需要两个I / O。由于外键引用和联接将触发主键查找，因此影响可能很大，这将占查询的绝大多数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;聚合索引的理论缺点是，在使用次级索引进行查询时，遍历树节点的次数是您首先遍历次级索引，然后遍历聚合索引（也是一棵树）的两倍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，考虑到现代惯例，将自动递增的整数作为主键[1]（称为代理键），几乎总是希望拥有聚合索引。如果您要执行很多操作&lt;code&gt;ORDER BY id&lt;/code&gt;来检索最新（或最旧）的N条记录，那就更是如此，我认为这适用于大多数记录。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Postgres不支持聚合索引，而MySQL（InnoDB）不支持堆(Heap)。但是，无论哪种方式，如果您有大量内存，则差异应该很小。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;页面结构和压缩&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Postgres和MySQL都具有基于页面的物理存储（8KB和16KB）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PostgreSQL物理存储简介&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5765625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qQ8WOWzXr36JSibzJFh4Pn9COfHLzMv3nTTpj3Iq9ZqLPI2F1Y7ReXuEumEB3jMC1eoGjIZTg7ZqXm2JVaVcGmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;页面结构看起来像上图所示。它包含一些标题，我们将在这里不进行介绍，但是它们包含有关页面的元数据。标头后面的项目是一个数组标识符，由&lt;code&gt;(offset, length)&lt;/code&gt;指向元组或数据行的对组成。请记住，在Postgres中，可以通过这种方式将同一记录的多个版本存储在同一页面中。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7300672430355427&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qQ8WOWzXr36JSibzJFh4Pn9COfHLzMv3nY4L6PMgsiaNvOvfLM71icZ7M5hNF6SBN9sd5BTUfyhtjxhPypDTIlkoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2082&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL的表空间结构与Oracle的表空间结构相似，它具有段，范围，页和行的多个层次结构层。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它还为UNDO提供了一个单独的部分，称为“回退部分”。与Postgres不同，MySQL将在同一区域保留同一记录的多个版本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在两个数据库上，一行必须适合一个页面，这意味着一行必须小于8KB。（MySQL的页面中必须至少包含2行，巧合的是16KB / 2 = 8KB）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么当列中有一个大的JSON对象时会发生什么？&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.67421875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qQ8WOWzXr36JSibzJFh4Pn9COfHLzMv3n65icr2zZow3bBVop8pJ6KvpFj9vJHoxD0c5QFMu6uPWlU3azicG6J1KA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Postgres使用TOAST（专用的影子表存储）。当且仅当选择行和列时，才会拉出大对象。换句话说，大量的黑盒子不会污染您宝贵的缓存。它还支持对TOASTed对象的压缩。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于高端SSD存储供应商Fusion-io的贡献，MySQL具有称为“ 透明页面压缩”的更高级功能。它是专门为与SSD配合使用而设计的，固态硬盘的写入量与设备的寿命直接相关。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL上的压缩不仅适用于页面外的大对象，而且适用于所有页面。它是通过在稀疏文件中使用打孔来实现的，稀疏文件受ext4或btrfs等现代文件系统支持。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有关更多详细信息，请参阅：通过FusionIO上的新MariaDB页面压缩显着提高性能&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;更新的开销&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;UPDATE&lt;/code&gt;是经常遗漏但对性能有重大影响并且可能是最具争议的主题的另一个功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也是Uber放弃&lt;code&gt;Postgres&lt;/code&gt;的另一个原因，这激起了许多Postgres拥护者的反驳。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;MySQL可能适合Uber，但不适合您&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;PostgreSQL对Uber的回应（PDF）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两者都是MVCC数据库，可保留多个版本的数据以进行隔离。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为此，Postgres将旧数据保留在堆中直到VACUUMed，而MySQL将旧数据移动到称为回滚段的单独区域。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Postgres上，当您尝试更新时，必须复制整行以及指向该行的索引条目。部分原因是Postgres不支持聚集索引，因此从索引引用的行的物理位置不会被逻辑键抽象出来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决此问题，Postgres使用仅堆元组（HOT）尽可能不更新索引。但是，如果更新足够频繁（或者如果一个元组很大），则元组的历史记录很容易从8KB的页面大小中流出，跨越多个页面并限制了功能的有效性。修剪和/或碎片整理的时间取决于试探法。此外，将fillfactor设置为小于100会降低空间效率—这是在表创建时就不必担心的艰难折衷。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个限制甚至更深了。由于索引元组没有有关事务的任何信息，因此直到9.2 以前一直不可能支持仅索引扫描。它是所有主要数据库（包括MySQL，Oracle，IBM DB2和Microsoft SQL Server）支持的最古老，最重要的优化方法之一。但是即使使用最新版本，当有大量的UPDATE设置Visibility Map中的脏位时，Postgres也不能完全支持仅索引扫描，而在不需要时经常选择Seq扫描。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在MySQL上，更新发生在原地，旧行数据存放在称为回滚段的单独区域中。结果是您不需要VACUUM，提交非常快，而回滚相对较慢，这对于大多数用例来说是一个较好的折衷方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它也足够聪明，可以尽快清除历史记录。如果将事务的隔离级别设置为&lt;strong&gt;「READ-COMMITTED」&lt;/strong&gt;或更低，则在语句完成时将清除历史记录。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;交易历史记录的大小不会影响主页。碎片是没有问题的。因此，MySQL的整体性能更好，更可预测。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;垃圾回收&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Postgres上的VACUUM非常昂贵，因为它可以在主堆区域中工作，从而造成直接的资源征用。感觉就像编程语言中的垃圾回收一样-它会妨碍您并让您随意暂停。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为具有数十亿条记录的表配置自动清空仍然是一个挑战。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对MySQL的清除也可能很繁重，但是由于它在单独的回滚段中使用专用线程运行，因此不会以任何方式对读取并发产生不利影响。即使使用默认设置，膨胀的回滚段也不太可能使您减速。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个拥有数十亿条记录的繁忙表不会导致MySQL的历史记录膨胀，并且诸如存储文件大小和查询性能之类的事情几乎是可以预测和稳定的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;日志和复制&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Postgres有一个唯一的交易历史事实来源，称为Write Ahead Log（WAL）。它也用于复制，称为逻辑复制的新功能可以将二进制内容实时解码为更易消化的逻辑语句，从而可以对数据进行精细控制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL维护两个单独的日志：1. 用于崩溃恢复的InnoDB特定重做日志，以及2. 用于复制和增量备份的二进制日志。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与Oracle一样，InnoDB上的重做日志是免维护的循环缓冲区，不会随着时间的推移而增长，只能在启动时以固定大小创建。这种设计可确保在物理设备上保留连续的连续区域，从而提高性能。重做日志越大，性能越好，但要从崩溃中恢复时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Postgres中添加了新的复制功能后，我称之为平局。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;TL和DR&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;令人惊讶的是，事实证明，普遍的看法仍然成立。MySQL最适合在线交易，而PostgreSQL最适合仅追加分析过程，例如数据仓库。[2]&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正如我们在本文中看到的，Postgres的绝大多数复杂性源于其仅附加的，过度冗余的堆体系结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Postgres的未来版本可能需要对其存储引擎进行重大改进。您不必完全相信我的话- 官方Wiki上已经讨论了它，这表明是时候从InnoDB那里获取一些好主意了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一次又一次地说MySQL正在追赶Postgres，但是这次，潮流已经改变了。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;顺便说一句，UUID作为主键是一个可怕的想法-密码随机性是完全&lt;strong&gt;「设计用来杀死」&lt;/strong&gt;参考位置的，因此会降低性能。↩︎&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当我说Postgres非常适合分析时，我是说真的。如果您不了解TimescaleDB，它是PostgreSQL之上的包装器，可让您每秒插入100万条记录，每服务器100+十亿行。疯狂的事情。难怪亚马逊为什么选择PostgreSQL作为Redshift的基础。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b3b49259d0146b8b598c96660900c212</guid>
<title>一道关于 json 和 slice 的题难倒了 80% 的人</title>
<link>https://toutiao.io/k/2mapo63</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;昨天在 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzAxMTA4Njc0OQ==&amp;amp;mid=2651442371&amp;amp;idx=1&amp;amp;sn=e59aea7a9ccf5ac14fd825231d2850ae&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Go语言爱好者周刊：第 65 期&lt;/a&gt; 刊首语发了一道题，以下代码输出什么？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;encoding/json&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; AutoGenerated &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Age   &lt;span&gt;int&lt;/span&gt;    &lt;span&gt;`json:&quot;age&quot;`&lt;/span&gt;&lt;br/&gt; Name  &lt;span&gt;string&lt;/span&gt; &lt;span&gt;`json:&quot;name&quot;`&lt;/span&gt;&lt;br/&gt; Child []&lt;span&gt;int&lt;/span&gt;  &lt;span&gt;`json:&quot;child&quot;`&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; jsonStr1 := &lt;span&gt;`{&quot;age&quot;: 14,&quot;name&quot;: &quot;potter&quot;, &quot;child&quot;:[1,2,3]}`&lt;/span&gt;&lt;br/&gt; a := AutoGenerated{}&lt;br/&gt; json.Unmarshal([]&lt;span&gt;byte&lt;/span&gt;(jsonStr1), &amp;amp;a)&lt;br/&gt; aa := a.Child&lt;br/&gt; fmt.Println(aa)&lt;br/&gt; jsonStr2 := &lt;span&gt;`{&quot;age&quot;: 12,&quot;name&quot;: &quot;potter&quot;, &quot;child&quot;:[3,4,5,7,8,9]}`&lt;/span&gt;&lt;br/&gt; json.Unmarshal([]&lt;span&gt;byte&lt;/span&gt;(jsonStr2), &amp;amp;a)&lt;br/&gt; fmt.Println(aa)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结果 80% 的人都答错了。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5464025026068822&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UzjmETLXwBYtTWwqviah2L1DrJlBHpLV5xX0laUib3bruIjPbHAPMUMhwpVAQh1VKUZTTqxLFNGHaubYLxRgvYgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;959&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结果为什么是 [1 2 3] [3 4 5] 呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这道题涉及到两个知识点：&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1、json 解析&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于 json.Unmarshal 的文档，不少人可能没认真看。借此机会正好一起看下。https://docs.studygolang.com/pkg/encoding/json/#Unmarshal。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Unmarshal 解析 JSON 编码的数据，并将结果存入 v 指向的值。如果 v 为 nil 或不是指针，则 Unmarshal 返回 InvalidUnmarshalError。&lt;/p&gt;&lt;p&gt;Unmarshal 和 Marshal 做相反的操作，必要时申请 map、slice 或指针，有如下的附加规则：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;为了将 JSON 数据解码写入一个指针，Unmarshal 首先处理 JSON 数据为 JSON 字面值 null 的情况。此时，Unmarshal 会将指针设置为 nil。否则，Unmarshal 会将 JSON 数据解码为指针所指向的值。如果指针为 nil，则 Unmarshal 为其分配一个新值并使指针指向它。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;为了将 JSON 数据解码为实现 Unmarshaler 接口的值，Unmarshal 调用该值的 UnmarshalJSON 方法，包括当输入为 JSON  null 时。否则，如果该值实现 encoding.TextUnmarshaler 且输入是带引号的 JSON 字符串，则 Unmarshal 会使用该字符串的未加引号形式来调用该值的 UnmarshalText 方法。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;要将 json 数据解码写入一个结构体，函数会匹配输入对象的键和 Marshal 使用的键（结构体字段名或者它的标签指定的键名），优先选择精确的匹配，但也接受大小写不敏感的匹配；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;为了将 JSON 数据解码到结构中，Unmarshal 将传入的对象键与 Marshal 使用的键（结构字段名称或其 Tag）进行匹配，希望使用精确匹配，但还接受不区分大小写的匹配。默认情况下，没有相应结构字段的对象键将被忽略（有关替代方法，请参见 Decoder.DisallowUnknownFields）。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;要将 JSON 数据解码写入一个接口类型值，Unmarshal 将其中之一存储在接口值中：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Bool                   对应JSON布尔类型&lt;br/&gt;float64                对应JSON数字类型&lt;br/&gt;string                 对应JSON字符串类型&lt;br/&gt;[]interface{}          对应JSON数组&lt;br/&gt;map[string]interface{} 对应JSON对象&lt;br/&gt;nil                    对应JSON的null&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;要将一个 JSON 数组解码到切片（slice）中，Unmarshal 将切片长度重置为零，然后将每个元素 append 到切片中。特殊情况，如果将一个空的 JSON 数组解码到一个切片中，Unmarshal 会用一个新的空切片替换该切片。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;为了将 JSON 数组解码为 Go 数组，Unmarshal 将 JSON 数组元素解码为对应的 Go 数组元素。如果 Go 数组长度小于 JSON 数组，则其他 JSON 数组元素将被丢弃。如果 JSON 数组长度小于 Go 数组，则将其他 Go 数组元素会设置为零值。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;要将 JSON 对象解码到 map 中，Unmarshal 首先要建立将使用的 map。如果 map 为零，Unmarshal 会分配一个新 map。否则，Unmarshal 会重用现有 map，保留现有条目（item）。然后，Unmarshal 将来自 JSON 对象的键/值对存储到 map 中。map 的键类型必须是任意字符串类型、整数或实现了 json.Unmarshaler 或 encoding.TextUnmarshaler 接口的类型。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果 JSON 值不适用于给定的目标类型，或者 JSON 数字写入目标类型时溢出，则 Unmarshal 会跳过该字段并尽最大可能完成解析。如果没有遇到更多的严重错误，则 Unmarshal 返回一个 UnmarshalTypeError 来描述最早的此类错误。但无法确保有问题的字段之后的所有其余字段都将被解析到目标对象中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;JSON 的 null 值解码为 Go 的接口、指针、切片时会将它们设为 nil，因为 null 在 JSON 里一般表示“不存在”。因此将 JSON null 解码到任何其他 Go 类型中不会影响该值，并且不会产生任何错误。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;解析带引号的字符串时，无效的 UTF-8 或无效的 UTF-16 不会被视为错误。而是将它们替换为 Unicode 字符 U+FFFD。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;跟此题相关的是下面这点：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;要将一个 JSON 数组解码到切片（slice）中，Unmarshal 将切片长度重置为零，然后将每个元素 append 到切片中。特殊情况，如果将一个空的 JSON 数组解码到一个切片中，Unmarshal 会用一个新的空切片替换该切片。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此第一次解析时，a.Child 是 [1 2 3]，aa 自然也是 [1 2 3]。第二次解析时，a.Child 的长度会被重置为 0，也就说里面的值会被重置（比如 a.Child = a.Child[:0]），然后将 3,4,5,7,8,9 一个个 append 到 a.Child 中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而 append 操作可能会涉及到底层数组的扩容：当原来的容量不足时，会进行扩容。怎么扩容的呢？目前的版本（Go1.15.x）按照如下规则扩容：（扩容规则依赖具体实现，不同版本可能不一样）&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Get element of array, growing if necessary.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; v.Kind() == reflect.Slice {&lt;br/&gt;  &lt;span&gt;// Grow slice if necessary&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; i &amp;gt;= v.Cap() {&lt;br/&gt;    newcap := v.Cap() + v.Cap()/&lt;span&gt;2&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; newcap &amp;lt; &lt;span&gt;4&lt;/span&gt; {&lt;br/&gt;      newcap = &lt;span&gt;4&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    newv := reflect.MakeSlice(v.Type(), v.Len(), newcap)&lt;br/&gt;    reflect.Copy(newv, v)&lt;br/&gt;    v.Set(newv)&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; i &amp;gt;= v.Len() {&lt;br/&gt;    v.SetLen(i + &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;初始容量最小为 4；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;之后按照容量的一半扩容，所以容量是 4、6、9、13、19...&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有人问上题为什么 aa 的容量是 4，这里正好解释了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，第一次解析，aa.Child 是：[1 2 3]，cap = 4。第二次解析，aa.Child 先被重置，之后将 3,4,5,7,8,9 一个个 append，最后 aa.Child 是：[3 4 5 6 7 8 9], cap = 6。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2、slice&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是能从 json Unmarshal 文档能学到的相关知识。接下来关键在于 slice。关于 slice 的知识，网上很多教程，这里只讲解和该题相关的内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）aa := a.Child 意味着什么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先看 a.Child 的内部结构。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.766859344894027&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UzjmETLXwBYtTWwqviah2L1DrJlBHpLV53Xmic8IGuVekdgdRGWT24FPqGoMavgWcwYWZ2iaHykZwJl2SCpUCRjwg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;519&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;赋值给 aa 后呢？aa 和 a.Child 共用底层数组。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.8854748603351955&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UzjmETLXwBYtTWwqviah2L1DrJlBHpLV5hZJlR2iaLAFliatPO4O9AibprzIicNrRlkAYaHzYQkVjsQVC98tnSjBOlQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;716&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有引入一个小知识点，aa := a.Child 后，以下代码输出的两个地址是一样的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;fmt.Printf(&lt;span&gt;&quot;%p,%p\n&quot;&lt;/span&gt;, a.Child, aa)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它们输出的都是底层数组的地址，这里一定要注意。通过它们，你可以验证底层数组扩容了（地址变了，表明扩容了）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果要输出 slice 本身的地址，应该这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;fmt.Printf(&lt;span&gt;&quot;%p,%p\n&quot;&lt;/span&gt;, &amp;amp;a.Child, &amp;amp;aa)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2）执行第二次 json 解析后&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据上文的讲解，底层数组从索引 0 位置开始依次被 3、4、5、7 填充。因为 aa 的 len 是 3，所以即使底层数组变成了 3、4、5、7，aa 看到却是 3、4、5。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当再继续解析时，底层数组容量不够，因此进行扩容，cap 变成 6，将原底层数组的元素拷贝一份到新的数组中。所以最后 a.Child 的底层数组是这个新的底层数组：[3 4 5 7 8 9]，cap = 6。而 aa 的底层数组还是原来的。最后的内部表示是这样的。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.8854748603351955&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UzjmETLXwBYtTWwqviah2L1DrJlBHpLV5KG03nI7Wzqrsbn2oT8ayE4vOqtHOEl0SVx5VERWv6FKS1XnOsVIfdg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;716&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3、小结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结起来两点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;json 解析的规则，文档上明确说明了；（有人评论说跟 json 没关系，但我觉得很多人根本不知道 json 对这块是怎么处理的，正因为有这样的处理，才引出了 slice 扩容的问题）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;slice 内部表示和 append 导致扩容。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;希望你已经彻底掌握了以上知识点。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e8d6bede780edcd3f66c3bf316b51e5d</guid>
<title>Java 即时编译器原理解析及实践</title>
<link>https://toutiao.io/k/bv3fy59</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一、导读&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;常见的编译型语言如C++，通常会把代码直接编译成CPU所能理解的机器码来运行。而Java为了实现“一次编译，处处运行”的特性，把编译的过程分成两部分，首先它会先由javac编译成通用的中间形式——字节码，然后再由解释器逐条将字节码解释为机器码来执行。所以在性能上，Java通常不如C++这类编译型语言。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;为了优化Java的性能 ，JVM在解释器之外引入了即时（&lt;/span&gt;&lt;span&gt;Just In Time&lt;/span&gt;&lt;span&gt;）编译器：当程序运行时，解释器首先发挥作用，代码可以直接执行。随着时间推移，即时编译器逐渐发挥作用，把越来越多的代码编译优化成本地代码，来获取更高的执行效率。解释器这时可以作为编译运行的降级手段，在一些不可靠的编译优化出现问题时，再切换回解释执行，保证程序可以正常运行。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;即时编译器&lt;/span&gt;&lt;span&gt;极大地提高了Java程序的运行速度，而且跟静态编译相比，即时编译器可以选择性地编译热点代码，省去了很多编译时间，也节省很多的空间。目前，即时编译器已经非常成熟了，在性能层面甚至可以和编译型语言相比。不过在这个领域，大家依然在不断探索如何结合不同的编译方式，使用更加智能的手段来提升程序的运行速度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二、Java的执行过程&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Java的执行过程整体可以分为两个部分，第一步由javac将源码编译成字节码，在这个过程中会进行词法分析、语法分析、语义分析，编译原理中这部分的编译称为前端编译。接下来无需编译直接逐条将字节码解释执行，在解释执行的过程中，虚拟机同时对程序运行的信息进行收集，在这些信息的基础上，编译器会逐渐发挥作用，它会进行后端编译——把字节码编译成机器码，但不是所有的代码都会被编译，只有被JVM认定为的热点代码，才可能被编译。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;怎么样才会被认为是热点代码呢？JVM中会设置一个阈值，当方法或者代码块的在一定时间内的调用次数超过这个阈值时就会被编译，存入codeCache中。当下次执行时，再遇到这段代码，就会从codeCache中读取机器码，直接执行，以此来提升程序运行的性能。整体的执行过程大致如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7006172839506173&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWW0Pl9GwlqxF1Gt4I5qP3iclV2pPZ05cFWDT9icqibGloNNXyjiaCb59VRthLE01sEyEOLcNiahWWJtng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;648&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1. JVM中的编译器&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;JVM中集成了两种编译器，Client Compiler和Server Compiler，它们的作用也不同。Client Compiler注重启动速度和局部的优化，Server Compiler则更加关注全局的优化，性能会更好，但由于会进行更多的全局分析，所以启动速度会变慢。两种编译器有着不同的应用场景，在虚拟机中同时发挥作用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Client Compiler&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;HotSpot VM带有一个Client Compiler  C1编译器。这种编译器启动速度快，但是性能比较Server Compiler来说会差一些。C1会做三件事：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Server Compiler&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Server Compiler主要关注一些编译耗时较长的全局优化，甚至会还会根据程序运行的信息进行一些不可靠的激进优化。这种编译器的启动时间长，适用于长时间运行的后台程序，它的性能通常比Client Compiler高30%以上。目前，Hotspot虚拟机中使用的Server Compiler有两种：C2和Graal。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;C2 Compiler&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在Hotspot VM中，默认的Server Compiler是C2编译器。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;C2编译器在进行编译优化时，会使用一种控制流与数据流结合的图数据结构，称为Ideal Graph。Ideal Graph表示当前程序的数据流向和指令间的依赖关系，依靠这种图结构，某些优化步骤（&lt;/span&gt;&lt;span&gt;尤其是涉及浮动代码块的那些优化步骤&lt;/span&gt;&lt;span&gt;）变得不那么复杂。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Ideal Graph的构建是在解析字节码的时候，根据字节码中的指令向一个空的Graph中添加节点，Graph中的节点通常对应一个指令块，每个指令块包含多条相关联的指令，JVM会利用一些优化技术对这些指令进行优化，比如Global Value Numbering、常量折叠等，解析结束后，还会进行一些死代码剔除的操作。生成Ideal Graph后，会在这个基础上结合收集的程序运行信息来进行一些全局的优化，这个阶段如果JVM判断此时没有全局优化的必要，就会跳过这部分优化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;无论是否进行全局优化，Ideal Graph都会被转化为一种更接近机器层面的MachNode Graph，最后编译的机器码就是从MachNode Graph中得的，生成机器码前还会有一些包括寄存器分配、窥孔优化等操作。关于Ideal Graph和各种全局的优化手段会在后面的章节详细介绍。Server Compiler编译优化的过程如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1.0498177399756987&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWW0Pl9GwlqxF1Gt4I5qP3ic7iaxGao0fj8icXibz5wmwQFIvvUCuFQ5nsDYJ6ia03T8PP7dzIlBpFVb0Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;823&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Graal Compiler&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;从JDK 9开始，Hotspot VM中集成了一种新的Server Compiler，Graal编译器。相比C2编译器，Graal有这样几种关键特性：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Graal编译器可以通过Java虚拟机参数&lt;/span&gt;&lt;span&gt;-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler&lt;/span&gt;&lt;span&gt;启用。当启用时，它将替换掉HotSpot中的C2编译器，并响应原本由C2负责的编译请求。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2. 分层编译&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在Java 7以前，需要研发人员根据服务的性质去选择编译器。对于需要快速启动的，或者一些不会长期运行的服务，可以采用编译效率较高的C1，对应参数-client。长期运行的服务，或者对峰值性能有要求的后台服务，可以采用峰值性能更好的C2，对应参数-server。Java 7开始引入了分层编译的概念，它结合了C1和C2的优势，追求启动速度和峰值性能的一个平衡。分层编译将JVM的执行状态分为了五个层次。五个层级分别是：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;profiling就是收集能够反映程序执行状态的数据。其中最基本的统计数据就是方法的调用次数，以及循环回边的执行次数。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;通常情况下，C2代码的执行效率要比C1代码的高出30%以上。C1层执行的代码，按执行效率排序从高至低则是1层&amp;gt;2层&amp;gt;3层。这5个层次中，1层和4层都是终止状态，当一个方法到达终止状态后，只要编译后的代码并没有失效，那么JVM就不会再次发出该方法的编译请求的。服务实际运行时，JVM会根据服务运行情况，从解释执行开始，选择不同的编译路径，直到到达终止状态。下图中就列举了几种常见的编译路径：&lt;/span&gt;&lt;/p&gt;&lt;img data-ratio=&quot;0.7879490150637312&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWW0Pl9GwlqxF1Gt4I5qP3ic3b6TKNdQYePIGYiaIDWyLeeEibonoHeWDiatFicLfGyobrmsibHgSjP4ciaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;863&quot; title=&quot;&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;图中第①条路径，代表编译的一般情况，热点方法从解释执行到被3层的C1编译，最后被4层的C2编译。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果方法比较小（&lt;/span&gt;&lt;span&gt;比如Java服务中常见的getter/setter方法&lt;/span&gt;&lt;span&gt;），3层的profiling没有收集到有价值的数据，JVM就会断定该方法对于C1代码和C2代码的执行效率相同，就会执行图中第②条路径。在这种情况下，JVM会在3层编译之后，放弃进入C2编译，直接选择用1层的C1编译运行。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在C1忙碌的情况下，执行图中第③条路径，在解释执行过程中对程序进行profiling ，根据信息直接由第4层的C2编译。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;前文提到C1中的执行效率是1层&amp;gt;2层&amp;gt;3层，第3层一般要比第2层慢35%以上，所以在C2忙碌的情况下，执行图中第④条路径。这时方法会被2层的C1编译，然后再被3层的C1编译，以减少方法在3层的执行时间。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果编译器做了一些比较激进的优化，比如分支预测，在实际运行时发现预测出错，这时就会进行反优化，重新进入解释执行，图中第⑤条执行路径代表的就是反优化。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;总的来说，C1的编译速度更快，C2的编译质量更高，分层编译的不同编译路径，也就是JVM根据当前服务的运行情况来寻找当前服务的最佳平衡点的一个过程。从JDK 8开始，JVM默认开启分层编译。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3. 即时编译的触发&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;Java虚拟机根据方法的调用次数以及循环回边的执行次数来触发即时编译。循环回边是一个控制流图中的概念，程序中可以简单理解为往回跳转的指令，比如下面这段代码：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;循环回边&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;nlp&lt;/span&gt;&lt;span&gt;(Object obj)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; sum = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;200&lt;/span&gt;; i++) {&lt;br/&gt;    sum += i;&lt;br/&gt;  }&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;上面这段代码经过编译生成下面的字节码。其中，偏移量为18的字节码将往回跳至偏移量为4的字节码中。在解释执行时，每当运行一次该指令，Java虚拟机便会将该方法的循环回边计数器加1。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;字节码&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;nlp&lt;/span&gt;&lt;span&gt;(java.lang.Object)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    Code:&lt;br/&gt;       &lt;span&gt;0&lt;/span&gt;: iconst_0&lt;br/&gt;       &lt;span&gt;1&lt;/span&gt;: istore_1&lt;br/&gt;       &lt;span&gt;2&lt;/span&gt;: iconst_0&lt;br/&gt;       &lt;span&gt;3&lt;/span&gt;: istore_2&lt;br/&gt;       &lt;span&gt;4&lt;/span&gt;: iload_2&lt;br/&gt;       &lt;span&gt;5&lt;/span&gt;: sipush        &lt;span&gt;200&lt;/span&gt;&lt;br/&gt;       &lt;span&gt;8&lt;/span&gt;: if_icmpge     &lt;span&gt;21&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;11&lt;/span&gt;: iload_1&lt;br/&gt;      &lt;span&gt;12&lt;/span&gt;: iload_2&lt;br/&gt;      &lt;span&gt;13&lt;/span&gt;: iadd&lt;br/&gt;      &lt;span&gt;14&lt;/span&gt;: istore_1&lt;br/&gt;      &lt;span&gt;15&lt;/span&gt;: iinc          &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;18&lt;/span&gt;: &lt;span&gt;goto&lt;/span&gt;          &lt;span&gt;4&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;21&lt;/span&gt;: &lt;span&gt;return&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;在即时编译过程中，编译器会识别循环的头部和尾部。上面这段字节码中，循环体的头部和尾部分别为偏移量为11的字节码和偏移量为15的字节码。编译器将在循环体结尾增加循环回边计数器的代码，来对循环进行计数。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;当方法的调用次数和循环回边的次数的和，超过由参数&lt;/span&gt;&lt;span&gt;-XX:CompileThreshold&lt;/span&gt;&lt;span&gt;指定的阈值时（&lt;/span&gt;&lt;span&gt;使用C1时，默认值为1500；使用C2时，默认值为10000&lt;/span&gt;&lt;span&gt;），就会触发即时编译。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;开启分层编译的情况下，&lt;/span&gt;&lt;span&gt;-XX:CompileThreshold&lt;/span&gt;&lt;span&gt;参数设置的阈值将会失效，触发编译会由以下的条件来判断：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;分层编译触发条件公式&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;i &amp;gt; TierXInvocationThreshold &lt;span&gt;* s || (i &amp;gt; TierXMinInvocationThreshold *&lt;/span&gt; s  &amp;amp;&amp;amp; i + b &amp;gt; TierXCompileThreshold * s) &lt;br/&gt;i为调用次数，b是循环回边次数&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;上述满足其中一个条件就会触发即时编译，并且JVM会根据当前的编译方法数以及编译线程数动态调整系数s。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、编译优化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;即时编译器会对正在运行的服务进行一系列的优化，包括字节码解析过程中的分析，根据编译过程中代码的一些中间形式来做局部优化，还会根据程序依赖图进行全局优化，最后才会生成机器码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. 中间表达形式（Intermediate Representation）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在编译原理中，通常把编译器分为前端和后端，前端编译经过词法分析、语法分析、语义分析生成中间表达形式（&lt;/span&gt;&lt;span&gt;Intermediate Representation，以下称为IR&lt;/span&gt;&lt;span&gt;），后端会对IR进行优化，生成目标代码。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;Java字节码就是一种IR，但是字节码的结构复杂，字节码这样代码形式的IR也不适合做全局的分析优化。现代编译器一般采用图结构的IR，静态单赋值（&lt;/span&gt;&lt;span&gt;Static Single Assignment，SSA&lt;/span&gt;&lt;span&gt;）IR是目前比较常用的一种。这种IR的特点是每个变量只能被赋值一次，而且只有当变量被赋值之后才能使用。举个例子：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;SSA IR&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;Plain&lt;/span&gt; Text&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;a&lt;/span&gt; = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;a&lt;/span&gt; = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;b&lt;/span&gt; = a;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;上述代码中我们可以轻易地发现a = 1的赋值是冗余的，但是编译器不能。传统的编译器需要借助数据流分析，从后至前依次确认哪些变量的值被覆盖掉。不过，如果借助了SSA IR，编译器则可以很容易识别冗余赋值。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上面代码的SSA IR形式的伪代码可以表示为：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;SSA IR&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;Plain&lt;/span&gt; Text&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;a_1&lt;/span&gt; = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;a_2&lt;/span&gt; = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;b_1&lt;/span&gt; = a_2;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;由于SSA IR中每个变量只能赋值一次，所以代码中的a在SSA IR中会分成a_1、a_2两个变量来赋值，这样编译器就可以很容易通过扫描这些变量来发现a_1的赋值后并没有使用，赋值是冗余的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;除此之外，SSA IR对其他优化方式也有很大的帮助，例如下面这个死代码删除（&lt;/span&gt;&lt;span&gt;Dead Code Elimination&lt;/span&gt;&lt;span&gt;）的例子：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;DeadCodeElimination&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DeadCodeElimination{&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; b = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;2&lt;/span&gt; &amp;gt; &lt;span&gt;1&lt;/span&gt;){&lt;br/&gt;    a = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt;{&lt;br/&gt;    b = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;add&lt;/span&gt;(a,b)&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;可以得到SSA IR伪代码：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DeadCodeElimination&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;a_1 = 2;&lt;br/&gt;b_1 = 0&lt;br/&gt;if true:&lt;br/&gt;  a_2 = 1;&lt;br/&gt;&lt;span&gt;else&lt;/span&gt;&lt;br/&gt;  b_2 = 2;&lt;br/&gt;add(a,b)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;编译器通过执行字节码可以发现 b_2 赋值后不会被使用，else分支不会被执行。经过死代码删除后就可以得到代码：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;DeadCodeElimination&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DeadCodeElimination{&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; b = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;add&lt;/span&gt;(a,b)&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;我们可以将编译器的每一种优化看成一个图优化算法，它接收一个IR图，并输出经过转换后的IR图。编译器优化的过程就是一个个图节点的优化串联起来的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;C1中的中间表达形式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;前文提及C1编译器内部使用高级中间表达形式HIR，低级中间表达形式LIR来进行各种优化，这两种IR都是SSA形式的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;HIR是由很多基本块（&lt;/span&gt;&lt;span&gt;Basic Block&lt;/span&gt;&lt;span&gt;）组成的控制流图结构，每个块包含很多SSA形式的指令。基本块的结构如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;2.33206106870229&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWW0Pl9GwlqxF1Gt4I5qP3icribibsfvm5ue8Y0wzc0tSCw9IOGu173aoQ8lYOUlajWcQhHynMgdMJRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;262&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;其中，predecessors表示前驱基本块（&lt;/span&gt;&lt;span&gt;由于前驱可能是多个，所以是BlockList结构，是多个BlockBegin组成的可扩容数组&lt;/span&gt;&lt;span&gt;）。同样，successors表示多个后继基本块BlockEnd。除了这两部分就是主体块，里面包含程序执行的指令和一个next指针，指向下一个执行的主体块。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;从字节码到HIR的构造最终调用的是GraphBuilder，GraphBuilder会遍历字节码构造所有代码基本块储存为一个链表结构，但是这个时候的基本块只有BlockBegin，不包括具体的指令。第二步GraphBuilder会用一个ValueStack作为操作数栈和局部变量表，模拟执行字节码，构造出对应的HIR，填充之前空的基本块，这里给出简单字节码块构造HIR的过程示例，如下所示：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;字节码构造HIR&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;        字节码                     &lt;span&gt;Local&lt;/span&gt; &lt;span&gt;Value&lt;/span&gt;             &lt;span&gt;operand&lt;/span&gt; &lt;span&gt;stack&lt;/span&gt;              &lt;span&gt;HIR&lt;/span&gt;&lt;br/&gt;      5: &lt;span&gt;iload_1&lt;/span&gt;                  &lt;span&gt;[i1,i2]&lt;/span&gt;                 &lt;span&gt;[i1]&lt;/span&gt;&lt;br/&gt;      6: &lt;span&gt;iload_2&lt;/span&gt;                  &lt;span&gt;[i1,i2]&lt;/span&gt;                 &lt;span&gt;[i1,i2]&lt;/span&gt;   &lt;br/&gt;                                  ................................................   &lt;span&gt;i3&lt;/span&gt;: &lt;span&gt;i1&lt;/span&gt; * &lt;span&gt;i2&lt;/span&gt;&lt;br/&gt;      7: &lt;span&gt;imul&lt;/span&gt;                                   &lt;br/&gt;      8: &lt;span&gt;istore_3&lt;/span&gt;                 &lt;span&gt;[i1,i2，i3]&lt;/span&gt;              &lt;span&gt;[i3]&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;可以看出，当执行iload_1时，操作数栈压入变量i1，执行iload_2时，操作数栈压入变量i2，执行相乘指令imul时弹出栈顶两个值，构造出HIR i3 : i1 * i2，生成的i3入栈。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;C1编译器优化大部分都是在HIR之上完成的。当优化完成之后它会将HIR转化为LIR，LIR和HIR类似，也是一种编译器内部用到的IR，HIR通过优化消除一些中间节点就可以生成LIR，形式上更加简化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Sea-of-Nodes IR&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;C2编译器中的Ideal Graph采用的是一种名为Sea-of-Nodes中间表达形式，同样也是SSA形式的。它最大特点是去除了变量的概念，直接采用值来进行运算。为了方便理解，可以利用IR可视化工具Ideal Graph Visualizer（&lt;/span&gt;&lt;span&gt;IGV&lt;/span&gt;&lt;span&gt;），来展示具体的IR图。比如下面这段代码：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;example&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;foo&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; count)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; sum = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; count; i++) {&lt;br/&gt;    sum += i;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; sum;&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;对应的IR图如下所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.9210526315789473&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWW0Pl9GwlqxF1Gt4I5qP3ic1ga2DUCnWQNgz9VibaF1WFvEFDjYZIrxHrJIkd92Y5TMQK0ZFNkXVcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1368&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;图中若干个顺序执行的节点将被包含在同一个基本块之中，如图中的B0、B1等。B0基本块中0号Start节点是方法入口，B3中21号Return节点是方法出口。红色加粗线条为控制流，蓝色线条为数据流，而其他颜色的线条则是特殊的控制流或数据流。被控制流边所连接的是固定节点，其他的则是浮动节点（&lt;/span&gt;&lt;span&gt;浮动节点指只要能满足数据依赖关系，可以放在不同位置的节点，浮动节点变动的这个过程称为Schedule&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种图具有轻量级的边结构。图中的边仅由指向另一个节点的指针表示。节点是Node子类的实例，带有指定输入边的指针数组。这种表示的优点是改变节点的输入边很快，如果想要改变输入边，只要将指针指向Node，然后存入Node的指针数组就可以了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;依赖于这种图结构，通过收集程序运行的信息，JVM可以通过Schedule那些浮动节点，从而获得最好的编译效果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Phi And Region Nodes&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;Ideal Graph是SSA IR。由于没有变量的概念，这会带来一个问题，就是不同执行路径可能会对同一变量设置不同的值。例如下面这段代码if语句的两个分支中，分别返回5和6。此时，根据不同的执行路径，所读取到的值很有可能不同。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;example&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; x)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt;(x == &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;    a = &lt;span&gt;5&lt;/span&gt;;&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    a = &lt;span&gt;6&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; a;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;为了解决这个问题，就引入一个Phi Nodes的概念，能够根据不同的执行路径选择不同的值。于是，上面这段代码可以表示为下面这张图：&lt;/span&gt;&lt;/section&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1.473851030110935&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWW0Pl9GwlqxF1Gt4I5qP3icexApOhsHqhLzRGKE7FnCOYlydicj6Cww6Gcx4PLGgh5DWwQyK7qTTmA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;631&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;Phi Nodes中保存不同路径上包含的所有值，Region Nodes根据不同路径的判断条件，从Phi Nodes取得当前执行路径中变量应该赋予的值，带有Phi节点的SSA形式的伪代码如下：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Phi  Nodes&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; x)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  a_1 = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt;(x == &lt;span&gt;1&lt;/span&gt;){&lt;br/&gt;    a_2 = &lt;span&gt;5&lt;/span&gt;;&lt;br/&gt;  }&lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    a_3 = &lt;span&gt;6&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  a_4 = Phi(a_2,a_3);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; a_4;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Global Value Numbering&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Global Value Numbering（&lt;/span&gt;&lt;span&gt;GVN&lt;/span&gt;&lt;span&gt;） 是一种因为Sea-of-Nodes变得非常容易的优化技术 。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;GVN是指为每一个计算得到的值分配一个独一无二的编号，然后遍历指令寻找优化的机会，它可以发现并消除等价计算的优化技术。如果一段程序中出现了多次操作数相同的乘法，那么即时编译器可以将这些乘法合并为一个，从而降低输出机器码的大小。如果这些乘法出现在同一执行路径上，那么GVN还将省下冗余的乘法操作。在Sea-of-Nodes中，由于只存在值的概念，因此GVN算法将非常简单：即时编译器只需判断该浮动节点是否与已存在的浮动节点的编号相同，所输入的IR节点是否一致，便可以将这两个浮动节点归并成一个。比如下面这段代码：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;GVN&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;a&lt;/span&gt; = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;b&lt;/span&gt; = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;c&lt;/span&gt; = a + b;&lt;br/&gt;&lt;span&gt;d&lt;/span&gt; = a + b;&lt;br/&gt;&lt;span&gt;e&lt;/span&gt; = d;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;GVN会利用Hash算法编号，计算a = 1时，得到编号1，计算b = 2时得到编号2，计算c = a + b时得到编号3，这些编号都会放入Hash表中保存，在计算d = a + b时，会发现a + b已经存在Hash表中，就不会再进行计算，直接从Hash表中取出计算过的值。最后的e = d也可以由Hash表中查到而进行复用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以将GVN理解为在IR图上的公共子表达式消除（&lt;/span&gt;&lt;span&gt;Common Subexpression Elimination，CSE&lt;/span&gt;&lt;span&gt;）。两者区别在于，GVN直接比较值的相同与否，而CSE是借助词法分析器来判断两个表达式相同与否。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2. 方法内联&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;方法内联，是指在编译过程中遇到方法调用时，将目标方法的方法体纳入编译范围之中，并取代原方法调用的优化手段。JIT大部分的优化都是在内联的基础上进行的，方法内联是即时编译器中非常重要的一环。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;Java服务中存在大量getter/setter方法，如果没有方法内联，在调用getter/setter时，程序执行时需要保存当前方法的执行位置，创建并压入用于getter/setter的栈帧、访问字段、弹出栈帧，最后再恢复当前方法的执行。内联了对 getter/setter的方法调用后，上述操作仅剩字段访问。在C2编译器 中，方法内联在解析字节码的过程中完成。当遇到方法调用字节码时，编译器将根据一些阈值参数决定是否需要内联当前方法的调用。如果需要内联，则开始解析目标方法的字节码。比如下面这个示例（&lt;/span&gt;&lt;span&gt;来源于网络&lt;/span&gt;&lt;span&gt;）：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;方法内联的过程&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; boolean flag = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; value0 = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; value1 = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;foo&lt;/span&gt;(&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;value&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; result = bar(flag);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (result != &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;value&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;bar&lt;/span&gt;(&lt;span&gt;boolean flag&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; flag ? value0 : value1;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;bar方法的IR图：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6045340050377834&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWW0Pl9GwlqxF1Gt4I5qP3icAD2zAcYkjMDXv4TjdiaIen8FhcyFCgkBTvibZTAjLIWBtGRRVE2Vakfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;794&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;内联后的IR图：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1.4987531172069826&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWW0Pl9GwlqxF1Gt4I5qP3ic4MMtHkX6CSP9NPs2OncYic0n1WRJjK74eiaiakzVe7AwKPzKvEojdEcYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;802&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;内联不仅将被调用方法的IR图节点复制到调用者方法的IR图中，还要完成其他操作。&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;被调用方法的参数替换为调用者方法进行方法调用时所传入参数。上面例子中，将bar方法中的1号P(0)节点替换为foo方法3号LoadField节点。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;调用者方法的IR图中，方法调用节点的数据依赖会变成被调用方法的返回。如果存在多个返回节点，会生成一个Phi节点，将这些返回值聚合起来，并作为原方法调用节点的替换对象。图中就是将8号==节点，以及12号Return节点连接到原5号Invoke节点的边，然后指向新生成的24号Phi节点中。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果被调用方法将抛出某种类型的异常，而调用者方法恰好有该异常类型的处理器，并且该异常处理器覆盖这一方法调用，那么即时编译器需要将被调用方法抛出异常的路径，与调用者方法的异常处理器相连接。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;方法内联的条件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;编译器的大部分优化都是在方法内联的基础上。所以一般来说，内联的方法越多，生成代码的执行效率越高。但是对于即时编译器来说，内联的方法越多，编译时间也就越长，程序达到峰值性能的时刻也就比较晚。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以通过虚拟机参数&lt;/span&gt;&lt;span&gt;-XX:MaxInlineLevel&lt;/span&gt;&lt;span&gt;调整内联的层数，以及1层的直接递归调用（&lt;/span&gt;&lt;span&gt;可以通过虚拟机参数&lt;/span&gt;&lt;span&gt;-XX:MaxRecursiveInlineLevel&lt;/span&gt;&lt;span&gt;调整&lt;/span&gt;&lt;span&gt;）。一些常见的内联相关的参数如下表所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4533333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWW0Pl9GwlqxF1Gt4I5qP3iceiaIwIicqeSK0wsy8oxCX0ECSBT6kJtWWyqnP0xic68helTxCm1NT5U3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1350&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;虚函数内联&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;内联是JIT提升性能的主要手段，但是虚函数使得内联是很难的，因为在内联阶段并不知道他们会调用哪个方法。例如，我们有一个数据处理的接口，这个接口中的一个方法有三种实现add、sub和multi，JVM是通过保存虚函数表Virtual Method Table（&lt;/span&gt;&lt;span&gt;以下称为VMT&lt;/span&gt;&lt;span&gt;）存储class对象中所有的虚函数，class的实例对象保存着一个VMT的指针，程序运行时首先加载实例对象，然后通过实例对象找到VMT，通过VMT找到对应方法的地址，所以虚函数的调用比直接指向方法地址的classic call性能上会差一些。很不幸的是，Java中所有非私有的成员函数的调用都是虚调用。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;C2编译器已经足够智能，能够检测这种情况并会对虚调用进行优化。比如下面这段代码例子：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;virtual call&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SimpleInliningTest&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;        VirtualInvokeTest obj = &lt;span&gt;new&lt;/span&gt; VirtualInvokeTest();&lt;br/&gt;        VirtualInvoke1 obj1 = &lt;span&gt;new&lt;/span&gt; VirtualInvoke1();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100000&lt;/span&gt;; i++) {&lt;br/&gt;            invokeMethod(obj);&lt;br/&gt;            invokeMethod(obj1);&lt;br/&gt;        }&lt;br/&gt;        Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;invokeMethod&lt;/span&gt;&lt;span&gt;(VirtualInvokeTest obj)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        obj.methodCall();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;VirtualInvokeTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;methodCall&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;virtual call&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;VirtualInvoke1&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;VirtualInvokeTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;methodCall&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;super&lt;/span&gt;.methodCall();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;经过JIT编译器优化后，进行反汇编得到下面这段汇编代码：&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; &lt;span&gt;0x0000000113369d37&lt;/span&gt;: callq  &lt;span&gt;0x00000001132950a0&lt;/span&gt;  ; OopMap{off=&lt;span&gt;476&lt;/span&gt;}&lt;br/&gt;                                                ;*invokevirtual methodCall  &lt;span&gt;//代表虚调用&lt;/span&gt;&lt;br/&gt;                                                ; - SimpleInliningTest::invokeMethod@&lt;span&gt;1&lt;/span&gt; (line &lt;span&gt;18&lt;/span&gt;)&lt;br/&gt;                                                ;   {optimized virtual_call}  &lt;span&gt;//虚调用已经被优化&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;可以看到JIT对methodCall方法进行了虚调用优化optimized virtual_call。经过优化后的方法可以被内联。但是C2编译器的能力有限，对于多个实现方法的虚调用就“无能为力”了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;比如下面这段代码，我们增加一个实现：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;多实现的虚调用&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SimpleInliningTest&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;        VirtualInvokeTest obj = &lt;span&gt;new&lt;/span&gt; VirtualInvokeTest();&lt;br/&gt;        VirtualInvoke1 obj1 = &lt;span&gt;new&lt;/span&gt; VirtualInvoke1();&lt;br/&gt;        VirtualInvoke2 obj2 = &lt;span&gt;new&lt;/span&gt; VirtualInvoke2();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100000&lt;/span&gt;; i++) {&lt;br/&gt;            invokeMethod(obj);&lt;br/&gt;            invokeMethod(obj1);&lt;br/&gt;        invokeMethod(obj2);&lt;br/&gt;        }&lt;br/&gt;        Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;invokeMethod&lt;/span&gt;&lt;span&gt;(VirtualInvokeTest obj)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        obj.methodCall();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;VirtualInvokeTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;methodCall&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;virtual call&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;VirtualInvoke1&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;VirtualInvokeTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;methodCall&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;super&lt;/span&gt;.methodCall();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;VirtualInvoke2&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;VirtualInvokeTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;methodCall&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;super&lt;/span&gt;.methodCall();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;经过反编译得到下面的汇编代码：&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&lt;span&gt;0x000000011f5f&lt;/span&gt;0a37: callq  &lt;span&gt;0x000000011f4fd&lt;/span&gt;2e0  ; OopMap{off=&lt;span&gt;28&lt;/span&gt;}&lt;br/&gt;                                                ;*invokevirtual methodCall  &lt;span&gt;//代表虚调用&lt;/span&gt;&lt;br/&gt;                                                ; - SimpleInliningTest::invokeMethod@&lt;span&gt;1&lt;/span&gt; (line &lt;span&gt;20&lt;/span&gt;)&lt;br/&gt;                                                ;   {virtual_call}  &lt;span&gt;//虚调用未被优化&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;可以看到多个实现的虚调用未被优化，依然是virtual_call。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Graal编译器针对这种情况，会去收集这部分执行的信息，比如在一段时间，发现前面的接口方法的调用add和sub是各占50%的几率，那么JVM就会在每次运行时，遇到add就把add内联进来，遇到sub的情况再把sub函数内联进来，这样这两个路径的执行效率就会提升。在后续如果遇到其他不常见的情况，JVM就会进行去优化的操作，在那个位置做标记，再遇到这种情况时切换回解释执行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3. 逃逸分析&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;逃逸分析是“一种确定指针动态范围的静态分析，它可以分析在程序的哪些地方可以访问到指针”。Java虚拟机的即时编译器会对新建的对象进行逃逸分析，判断对象是否逃逸出线程或者方法。即时编译器判断对象是否逃逸的依据有两种：&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;对象是否被存入堆中（&lt;/span&gt;&lt;span&gt;静态字段或者堆中对象的实例字段&lt;/span&gt;&lt;span&gt;），一旦对象被存入堆中，其他线程便能获得该对象的引用，即时编译器就无法追踪所有使用该对象的代码位置。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对象是否被传入未知代码中，即时编译器会将未被内联的代码当成未知代码，因为它无法确认该方法调用会不会将调用者或所传入的参数存储至堆中，这种情况，可以直接认为方法调用的调用者以及参数是逃逸的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;逃逸分析通常是在方法内联的基础上进行的，即时编译器可以根据逃逸分析的结果进行诸如锁消除、栈上分配以及标量替换的优化。下面这段代码的就是对象未逃逸的例子：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;pulbic &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Example&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;      example();&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;example&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;      Foo foo = &lt;span&gt;new&lt;/span&gt; Foo();&lt;br/&gt;      Bar bar = &lt;span&gt;new&lt;/span&gt; Bar();&lt;br/&gt;      bar.setFoo(foo);&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Foo&lt;/span&gt; {&lt;/span&gt;}&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Bar&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Foo foo;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setFoo&lt;/span&gt;&lt;span&gt;(Foo foo)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.foo = foo;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;在这个例子中，创建了两个对象foo和bar，其中一个作为另一个方法的参数提供。该方法setFoo()存储对收到的Foo对象的引用。如果Bar对象在堆上，则对Foo的引用将逃逸。但是在这种情况下，编译器可以通过逃逸分析确定Bar对象本身不会对逃逸出example()的调用。这意味着对Foo的引用也不能逃逸。因此，编译器可以安全地在栈上分配两个对象。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;锁消除&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在学习Java并发编程时会了解锁消除，而锁消除就是在逃逸分析的基础上进行的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果即时编译器能够证明锁对象不逃逸，那么对该锁对象的加锁、解锁操作没就有意义。因为线程并不能获得该锁对象。在这种情况下，即时编译器会消除对该不逃逸锁对象的加锁、解锁操作。实际上，编译器仅需证明锁对象不逃逸出线程，便可以进行锁消除。由于Java虚拟机即时编译的限制，上述条件被强化为证明锁对象不逃逸出当前编译的方法。不过，基于逃逸分析的锁消除实际上并不多见。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;栈上分配&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们都知道Java的对象是在堆上分配的，而堆是对所有对象可见的。同时，JVM需要对所分配的堆内存进行管理，并且在对象不再被引用时回收其所占据的内存。如果逃逸分析能够证明某些新建的对象不逃逸，那么JVM完全可以将其分配至栈上，并且在new语句所在的方法退出时，通过弹出当前方法的栈桢来自动回收所分配的内存空间。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;这样一来，我们便无须借助垃圾回收器来处理不再被引用的对象。不过Hotspot虚拟机，并没有进行实际的栈上分配，而是使用了标量替换这一技术。所谓的标量，就是仅能存储一个值的变量，比如Java代码中的基本类型。与之相反，聚合量则可能同时存储多个值，其中一个典型的例子便是Java的对象。编译器会在方法内将未逃逸的聚合量分解成多个标量，以此来减少堆上分配。下面是一个标量替换的例子：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;标量替换&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Example&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;@AllArgsConstructor&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Cat&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; age;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; weight;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;example&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    Cat cat = &lt;span&gt;new&lt;/span&gt; Cat(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;);&lt;br/&gt;    addAgeAndWeight(cat.age,Cat.weight);&lt;br/&gt;  }&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;经过逃逸分析，cat对象未逃逸出example()的调用，因此可以对聚合量cat进行分解，得到两个标量age和weight，进行标量替换后的伪代码：&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Example&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;@AllArgsConstructor&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Cat&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; age;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; weight;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;example&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; age = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; weight = &lt;span&gt;10&lt;/span&gt;;&lt;br/&gt;    addAgeAndWeight(age,weight);&lt;br/&gt;  }&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;部分逃逸分析&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;部分逃逸分析也是Graal对于概率预测的应用。通常来说，如果发现一个对象逃逸出了方法或者线程，JVM就不会去进行优化，但是Graal编译器依然会去分析当前程序的执行路径，它会在逃逸分析基础上收集、判断哪些路径上对象会逃逸，哪些不会。然后根据这些信息，在不会逃逸的路径上进行锁消除、栈上分配这些优化手段。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4. Loop Transformations&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在文章中介绍C2编译器的部分有提及到，C2编译器在构建Ideal Graph后会进行很多的全局优化，其中就包括对循环的转换，最重要的两种转换就是循环展开和循环分离。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;循环展开&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;循环展开是一种循环转换技术，它试图以牺牲程序二进制码大小为代价来优化程序的执行速度，是一种用空间换时间的优化手段。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;循环展开通过减少或消除控制程序循环的指令，来减少计算开销，这种开销包括增加指向数组中下一个索引或者指令的指针算数等。如果编译器可以提前计算这些索引，并且构建到机器代码指令中，那么程序运行时就可以不必进行这种计算。也就是说有些循环可以写成一些重复独立的代码。比如下面这个循环：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;循环展开&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;loopRolling&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;200&lt;/span&gt;;i++){&lt;br/&gt;    &lt;span&gt;delete&lt;/span&gt;(i);  &lt;br/&gt;  }&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;上面的代码需要循环删除200次，通过循环展开可以得到下面这段代码：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;循环展开&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;loopRolling&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;200&lt;/span&gt;;i+=&lt;span&gt;5&lt;/span&gt;){&lt;br/&gt;    &lt;span&gt;delete&lt;/span&gt;(i);&lt;br/&gt;    &lt;span&gt;delete&lt;/span&gt;(i+&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;delete&lt;/span&gt;(i+&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;delete&lt;/span&gt;(i+&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;delete&lt;/span&gt;(i+&lt;span&gt;4&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;这样展开就可以减少循环的次数，每次循环内的计算也可以利用CPU的流水线提升效率。当然这只是一个示例，实际进行展开时，JVM会去评估展开带来的收益，再决定是否进行展开。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;循环分离&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;循环分离也是循环转换的一种手段。它把循环中一次或多次的特殊迭代分离出来，在循环外执行。举个例子，下面这段代码：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;循环分离&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;10&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;10&lt;/span&gt;;i++){&lt;br/&gt;  b[i] = x[i] + x[a];&lt;br/&gt;  a = i;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;可以看出这段代码除了第一次循环a = 10以外，其他的情况a都等于i-1。所以可以把特殊情况分离出去，变成下面这段代码：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;循环分离&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;b[&lt;span&gt;0&lt;/span&gt;] = x[&lt;span&gt;0&lt;/span&gt;] + &lt;span&gt;10&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;;i&amp;lt;&lt;span&gt;10&lt;/span&gt;;i++){&lt;br/&gt;  b[i] = x[i] + x[i&lt;span&gt;-1&lt;/span&gt;];&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;这种等效的转换消除了在循环中对a变量的需求，从而减少了开销。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;5. 窥孔优化与寄存器分配&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;前文提到的窥孔优化是优化的最后一步，这之后就会程序就会转换成机器码，窥孔优化就是将编译器所生成的中间代码（&lt;/span&gt;&lt;span&gt;或目标代码&lt;/span&gt;&lt;span&gt;）中相邻指令，将其中的某些组合替换为效率更高的指令组，常见的比如强度削减、常数合并等，看下面这个例子就是一个强度削减的例子：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;强度削减&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;y1&lt;/span&gt;=x1*&lt;span&gt;3&lt;/span&gt;  经过强度削减后得到  y1=(x1&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;)+x1&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;编译器使用移位和加法削减乘法的强度，使用更高效率的指令组。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;寄存器分配也是一种编译的优化手段，在C2编译器中普遍的使用。它是通过把频繁使用的变量保存在寄存器中，CPU访问寄存器的速度比内存快得多，可以提升程序的运行速度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;寄存器分配和窥孔优化是程序优化的最后一步。经过寄存器分配和窥孔优化之后，程序就会被转换成机器码保存在codeCache中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、实践&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;即时编译器情况复杂，同时网络上也很少有实战经验，以下是我们团队的一些调整经验。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;1. 编译相关的重要参数&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;-XX:+TieredCompilation&lt;/span&gt;&lt;span&gt;：开启分层编译，JDK8之后默认开启&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;-XX:+CICompilerCount=N&lt;/span&gt;&lt;span&gt;：编译线程数，设置数量后，JVM会自动分配线程数，C1:C2 = 1:2&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;-XX:TierXBackEdgeThreshold&lt;/span&gt;&lt;span&gt;：OSR编译的阈值&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;-XX:TierXMinInvocationThreshold&lt;/span&gt;&lt;span&gt;：开启分层编译后各层调用的阈值&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;-XX:TierXCompileThreshold&lt;/span&gt;&lt;span&gt;：开启分层编译后的编译阈值&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;-XX:ReservedCodeCacheSize&lt;/span&gt;&lt;span&gt;：codeCache最大大小&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;-XX:InitialCodeCacheSize&lt;/span&gt;&lt;span&gt;：codeCache初始大小&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;-XX:TierXMinInvocationThreshold&lt;/span&gt;&lt;span&gt;是开启分层编译的情况下，触发编译的阈值参数，当方法调用次数大于由参数&lt;/span&gt;&lt;span&gt;-XX:TierXInvocationThreshold&lt;/span&gt;&lt;span&gt;指定的阈值乘以系数，或者当方法调用次数大于由参数&lt;/span&gt;&lt;span&gt;-XX:TierXMINInvocationThreshold&lt;/span&gt;&lt;span&gt;指定的阈值乘以系数，并且方法调用次数和循环回边次数之和大于由参数&lt;/span&gt;&lt;span&gt;-XX:TierXCompileThreshold&lt;/span&gt;&lt;span&gt;指定的阈值乘以系数时，便会触发X层即时编译。分层编译开启下会乘以一个系数，系数根据当前编译的方法和编译线程数确定，降低阈值可以提升编译方法数，一些常用但是不能编译的方法可以编译优化提升性能。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;由于编译情况复杂，JVM也会动态调整相关的阈值来保证JVM的性能，所以不建议手动调整编译相关的参数。除非一些特定的Case，比如codeCache满了停止了编译，可以适当增加codeCache大小，或者一些非常常用的方法，未被内联到，拖累了性能，可以调整内敛层数或者内联方法的大小来解决。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2. 通过JITwatch分析编译日志&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过增加&lt;/span&gt;&lt;span&gt;-XX:+UnlockDiagnosticVMOptions -XX:+PrintCompilation -XX:+PrintInlining -XX:+PrintCodeCache -XX:+PrintCodeCacheOnCompilation -XX:+TraceClassLoading -XX:+LogCompilation -XX:LogFile=LogPath&lt;/span&gt;&lt;span&gt;参数可以输出编译、内联、codeCache信息到文件。但是打印的编译日志多且复杂很难直接从其中得到信息，可以使用JITwatch的工具来分析编译日志。JITwatch首页的Open Log选中日志文件，点击Start就可以开始分析日志。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.624702380952381&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWW0Pl9GwlqxF1Gt4I5qP3icCZP92Z1iaDFXa1hozjqbicHvMVgDBv8vFVvTriap4ia5uxr4eB0ia3AyXag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3360&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;br/&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6050595238095238&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWW0Pl9GwlqxF1Gt4I5qP3iclwz3co5ZqeCVePmDWib6ib3Ykq4Ku89AWZMz7p8iaHiaamqxlFNic7SVnpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3360&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;如上图所示，区域1中是整个项目Java Class包括引入的第三方依赖；区域2是功能区Timeline以图形的形式展示JIT编译的时间轴，Histo是直方图展示一些信息，TopList里面是编译中产生的一些对象和数据的排序，Cache是空闲codeCache空间，NMethod是Native方法，Threads是JIT编译的线程；区域3是JITwatch对日志分析结果的展示，其中Suggestions中会给出一些代码优化的建议，举个例子，如下图中：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.11354166666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWW0Pl9GwlqxF1Gt4I5qP3ic9Ql9Tbia4ibDjq8aibFxIt7bWpXGIjZeFGWX9ThXs5BUv6Il6e168Jpcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;我们可以看到在调用ZipInputStream的read方法时，因为该方法没有被标记为热点方法，同时又“太大了”，导致无法被内联到。使用&lt;/span&gt;&lt;span&gt;-XX:CompileCommand&lt;/span&gt;&lt;span&gt;中inline指令可以强制方法进行内联，不过还是建议谨慎使用，除非确定某个方法内联会带来不少的性能提升，否则不建议使用，并且过多使用对编译线程和codeCache都会带来不小的压力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;区域3中的-Allocs和-Locks逃逸分析后JVM对代码做的优化，包括栈上分配、锁消除等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3. 使用Graal编译器&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于JVM会去根据当前的编译方法数和编译线程数对编译阈值进行动态的调整，所以实际服务中对这一部分的调整空间是不大的，JVM做的已经足够多了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了提升性能，在服务中尝试了最新的Graal编译器。只需要使用&lt;/span&gt;&lt;span&gt;-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler&lt;/span&gt;&lt;span&gt;就可以启动Graal编译器来代替C2编译器，并且响应C2的编译请求，不过要注意的是，Graal编译器与ZGC不兼容，只能与G1搭配使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;前文有提到过，Graal是一个用Java写的即时编译器，它从Java 9开始便被集成自JDK中，作为实验性质的即时编译器。Graal编译器就是脱身于GraalVM，GraalVM是一个高性能的、支持多种编程语言的执行环境。它既可以在传统的 OpenJDK上运行，也可以通过AOT（&lt;/span&gt;&lt;span&gt;Ahead-Of-Time&lt;/span&gt;&lt;span&gt;）编译成可执行文件单独运行，甚至可以集成至数据库中运行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;前文提到过数次，Graal的优化都基于某种假设（&lt;/span&gt;&lt;span&gt;Assumption&lt;/span&gt;&lt;span&gt;）。当假设出错的情况下，Java虚拟机会借助去优化（&lt;/span&gt;&lt;span&gt;Deoptimization&lt;/span&gt;&lt;span&gt;）这项机制，从执行即时编译器生成的机器码切换回解释执行，在必要情况下，它甚至会废弃这份机器码，并在重新收集程序profile之后，再进行编译。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这些中激进的手段使得Graal的峰值性能要好于C2，而且在Scale、Ruby这种语言Graal表现更加出色，Twitter目前已经在服务中大量的使用Graal来提升性能，企业版的GraalVM使得Twitter服务性能提升了22%。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;使用Graal编译器后性能表现&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在我们的线上服务中，启用Graal编译后，TP9999从60ms -&amp;gt; 50ms ，下降10ms，下降幅度达16.7%。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;运行过程中的峰值性能会更高。可以看出对于该服务，Graal编译器带来了一定的性能提升。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Graal编译器的问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Graal编译器的优化方式更加激进，因此在启动时会进行更多的编译，Graal编译器本身也需要被即时编译，所以服务刚启动时性能会比较差。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;考虑的解决办法&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：JDK 9开始提供工具jaotc，同时GraalVM的Native Image都是可以通过静态编译，极大地提升服务的启动速度的方式，但是GraalVM会使用自己的垃圾回收，这是一种很原始的基于复制算法的垃圾回收，相比G1、ZGC（&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651752559&amp;amp;idx=1&amp;amp;sn=c720b67e93db1885d72dab8799bba78c&amp;amp;chksm=bd1251228a65d834db610deb2ce55003e0fc1f90793e84873096db19027936f6add301242545&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;新一代垃圾回收器ZGC的探索与实践&lt;/a&gt;）这些优秀的新型垃圾回收器，它的性能并不好。同时GraalVM对Java的一些特性支持也不够，比如基于配置的支持，比如反射就需要把所有需要反射的类配置一个JSON文件，在大量使用反射的服务，这样的配置会是很大的工作量。我们也在做这方面的调研。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;五、总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文主要介绍了JIT即时编译的原理以及在美团一些实践的经验，还有最前沿的即时编译器的使用效果。作为一项解释型语言中提升性能的技术，JIT已经比较成熟了，在很多语言中都有使用。对于Java服务，JVM本身已经做了足够多，但是我们还应该不断深入了解JIT的优化原理和最新的编译技术，从而弥补JIT的劣势，提升Java服务的性能，不断追求卓越。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;六、参考文献&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[1]《深入理解Java虚拟机》&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[2]《Proceedings of the Java™ Virtual Machine Research and Technology Symposium》Monterey, California, USA April 23–24, 2001&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[3]《Visualization of Program Dependence Graphs》 Thomas Würthinger&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[4]《深入拆解Java虚拟机》 郑宇迪&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[5] &lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzIxMTI0NzcyMQ==&amp;amp;mid=2650932520&amp;amp;idx=1&amp;amp;sn=e1d50389631eb91959aafef24d359bbc&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;JIT的Profile神器JITWatch&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;JIT的Profile神器JITWatch&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;七、作者简介&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;珩智，昊天，薛超，均来自美团AI平台/搜索与NLP部。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2b8134fb64bccd2e1ac61ea508cdfda4</guid>
<title>Flink State 误用之痛，竟然 90% 以上的 Flink 开发都不懂</title>
<link>https://toutiao.io/k/8nbizua</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/7s1EHEg3rgvQaStImm8DmibYlnqSTfWzL5BqclDC4g28vMgfyMf5S18VCMibnF1C6Jib47XiaIUoQdnm5XUDJpTodQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.075&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文主要讨论一个问题：ValueState 中存 Map 与 MapState 有什么区别？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不懂这两者的区别，而且使用 ValueState 中存大对象，生产环境很可能会出现以下问题：&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1、 结论&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从性能和 TTL 两个维度来描述区别。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;性能&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;RocksDB 场景，MapState 比 ValueState 中存 Map 性能高很多&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;生产环境强烈推荐使用 MapState，不推荐 ValueState 中存大对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ValueState 中存大对象很容易使 CPU 打满&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;Heap State 场景，两者性能类似&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;TTL&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Flink 中 State 支持设置 TTL&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;MapState 的 TTL 是基于 UK 级别的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ValueState 的 TTL 是基于整个 key 的&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;举一反三&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;能使用 ListState 的场景，不要使用 ValueState 中存 List。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大佬们已经把 MapState 和 ListState 性能都做了很多优化，高性能不香吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;下文会详细分析 ValueState 和 MapState 底层的实现原理，通过分析原理得出上述结论。&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2、 State 中要存储哪些数据&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ValueState 会存储 key、namespace、value，缩写为 &amp;lt;K, N, V&amp;gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MapState 会存储 key、namespace、userKey、userValue，缩写为 &amp;lt;K, N, UK, UV&amp;gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解释一下上述这些名词&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Key&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ValueState 和 MapState 都是 KeyedState，也就是 keyBy 后才能使用 ValueState 和 MapState。所以 State 中肯定要保存 key。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：按照 app 进行 keyBy，总共有两个 app，分别是：app1 和 app2。那么状态存储引擎中肯定要存储 app1 或 app2，用于区分当前的状态数据到底是 app1 的还是 app2 的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的 app1、app2 也就是所说的 key。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Namespace&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Namespace 用于区分窗口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设需要统计 app1 和 app2 每个小时的 pv 指标，则需要使用小时级别的窗口。状态引擎为了区分 app1 在 7 点和 8 点的 pv 值，就必须新增一个维度用来标识窗口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Flink 用 Namespace 来标识窗口，这样就可以在状态引擎中区分出 app1 在 7 点和 8 点的状态信息。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Value、UserKey、UserValue&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ValueState 中存储具体的状态值。也就是上述例子中对应的 pv 值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MapState 类似于 Map 集合，存储的是一个个 KV 键值对。为了与 keyBy 的 key 进行区分，所以 Flink 中把 MapState 的 key、value 分别叫 UserKey、UserValue。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面讲述状态引擎是如何存储这些数据的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3、 StateBackend 中是如何存储和读写 State 数据的&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Flink 支持三种 StateBackend，分别是：MemoryStateBackend、FsStateBackend 和 RocksDBStateBackend。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中 MemoryStateBackend、FsStateBackend 两种 StateBackend 在任务运行期间都会将 State 存储在内存中，两者在 Checkpoint 时将快照存储的位置不同。RocksDBStateBackend 在任务运行期间将 State 存储在本地的 RocksDB 数据库中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以下文将 MemoryStateBackend、FsStateBackend 统称为 heap 模式，RocksDBStateBackend 称为 RocksDB 模式。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1 Heap 模式 ValueState 和 MapState 是如何存储的&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Heap 模式表示所有的状态数据都存储在 TM 的堆内存中，所有的状态都存储的原始对象，不会做序列化和反序列化。（注：Checkpoint 的时候会涉及到序列化和反序列化，数据的正常读写并不会涉及，所以这里先不讨论。）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Heap 模式下，无论是 ValueState 还是 MapState 都存储在 &lt;code&gt;CopyOnWriteStateMap&amp;lt;K, N, V&amp;gt;&lt;/code&gt; 中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;key 、 Namespace 分别对应 CopyOnWriteStateMap 的 K、N。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ValueState 的 value 对应 CopyOnWriteStateMap 的 V。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MapState 将会把整个 Map 作为 CopyOnWriteStateMap 的 V，相当于 Flink 引擎创建了一个 HashMap 用于存储 MapState 的 KV 键值对。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体 CopyOnWriteStateMap 是如何实现的，可以参考《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkxOTE3MDU5MQ==&amp;amp;mid=2247484334&amp;amp;idx=1&amp;amp;sn=1aafab741bfd0e2e72652a4b459579c7&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;万字长文详解 Flink 中的 CopyOnWriteStateTable&lt;/a&gt;》。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;回到正题：Heap 模式下，ValueState 中存 Map 与 MapState 有什么区别？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;heap 模式下没有区别。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ValueState 中存 Map，相当于用户手动创建了一个 HashMap 当做 V 放到了状态引擎中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而 MapState 是 Flink 引擎帮用户创建了一个 HashMap 当做 V 放到了状态引擎中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以实质上 ValueState 中存 Map 与 MapState 都是一样的，存储结构都是  &lt;code&gt;CopyOnWriteStateMap&amp;lt;K, N, HashMap&amp;gt;&lt;/code&gt; 。区别在于 ValueState 是用户手动创建 HashMap，MapState 是 Flink 引擎创建 HashMap。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2 RocksDB 模式 ValueState 和 MapState 是如何存储的&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RocksDB 模式表示所有的状态数据存储在 TM 本地的 RocksDB 数据库中。RocksDB 是一个 KV 数据库，且所有的 key 和 value 都是 byte 数组。所以无论是 ValueState 还是 MapState，存储到 RocksDB 中都必须将对象序列化成二进制当前 kv 存储在 RocksDB 中。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2.1 ValueState 如何映射成 RocksDB 的 kv&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ValueState 有 key、namespace、value 需要存储，所以最简单的思路：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;将 ValueState 的 key 序列化成 byte 数组&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将 ValueState 的 namespace 序列化成 byte 数组&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将两个 byte 数组拼接起来做为 RocksDB 的 key&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将 ValueState 的 value 序列化成 byte 数组做为 RocksDB 的 value&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后就可以写入到 RocksDB 中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查询数据也用相同的逻辑：将 key 和 namespace 序列化后拼接起来作为 RocksDB 的 key，去 RocksDB 中进行查询，查询到的 byte 数组进行反序列化就得到了 ValueState 的 value。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是 RocksDB 模式下，ValueState 的读写流程。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2.2 MapState 如何映射成 RocksDB 的 kv&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MapState 有 key、namespace、userKey、userValue 需要存储，所以最简单的思路：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;将 MapState 的 key 序列化成 byte 数组&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将 MapState 的 namespace 序列化成 byte 数组&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将 MapState 的 userKey 序列化成 byte 数组&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将三个 byte 数组拼接起来做为 RocksDB 的 key&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将 MapState 的 value 序列化成 byte 数组做为 RocksDB 的 value&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后就可以写入到 RocksDB 中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查询数据也用相同的逻辑：将 key、namespace、userKey 序列化后拼接起来作为 RocksDB 的 key，去 RocksDB 中进行查询，查询到的 byte 数组进行反序列化就得到了 MapState 的 userValue。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是 RocksDB 模式下，MapState 的读写流程。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3 RocksDB 模式下，ValueState 中存 Map 与 MapState 有什么区别？&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3.1 假设 Map 集合有 100 个 KV 键值对，具体两种方案会如何存储数据？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ValueState 中存 Map，Flink 引擎会把整个 Map 当做一个大 Value，存储在 RocksDB 中。对应到 RocksDB 中，100 个 KV 键值对的 Map 集合会序列化成一个 byte 数组当做 RocksDB 的 value，存储在 RocksDB 的 1 行数据中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MapState 会根据 userKey，将 100 个 KV 键值对分别存储在 RocksDB 的 100 行中。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3.2 修改 Map 中的一个 KV 键值对的流程&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ValueState 的情况，虽然要修改 Map 中的一个 KV 键值对，但需要将整个 Map 集合从 RocksDB 中读出来。具体流程如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;将  key、namespace 序列化成 byte 数组，生成 RocksDB 的 key&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从 RocksDB 读出 key 对应 value 的 byte 数组&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将 byte 数组反序列化成整个 Map&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;堆内存中修改 Map 集合&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将 Map 集合写入到 RocksDB 中，需要将整个 Map 集合序列化成 byte 数组，再写入&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MapState 的情况，要修改 Map 中的一个 KV 键值对，根据 key、namespace、userKey 即可定位到要修改的那一个 KV 键值对。具体流程如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;将  key、namespace、userKey 序列化成 byte 数组，生成 RocksDB 的 key&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从 RocksDB 读出 key 对应 value 的 byte 数组&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将 byte 数组反序列化成 userValue&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;堆内存中修改 userValue 的值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将 userKey、userValue 写入到 RocksDB 中，需要先序列化，再写入&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3.3 结论&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要修改 Map 中的一个 KV 键值对：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果使用 ValueState 中存 Map，则每次修改操作需要序列化反序列化整个 Map 集合，每次序列化反序列大对象会非常耗 CPU，很容易将 CPU 打满。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果使用 MapState，每次修改操作只需要序列化反序列化 userKey 那一个 KV 键值对的数据，效率较高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举一反三：其他使用 ValueState、value 是大对象且 value 频繁更新的场景，都容易将 CPU 打满。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：ValueState 中存储的位图，如果每条数据都需要更新位图，则可能导致 CPU 被打满。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了便于理解，上述忽略了一些实现细节，下面补充一下：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.4 直接拼接 key 和 namespace 可能导致 RocksDB 的 key 冲突&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设 ValueState 中有两个数据：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;key1 序列化后的二进制为 0x112233， namespace1 序列化后的二进制为0x4455&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;key2 序列化后的二进制为 0x1122， namespace2 序列化后的二进制为0x334455&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两个数据对应的 RocksDB key 都是 0x1122334455，这样的话，两个不同的 key、namespace 映射到 RocksDB 中变成了相同的数据，无法做区分。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;解决方案：&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 key 和 namespace 中间写入 key 的 byte 数组长度，在 namespace 后写入 namespace 的 byte 长度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写入这两个长度就不可能出现 key 冲突了，具体为什么，读者可以自行思考。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.5 RocksDB 的 key 中还会存储 KeyGroupId&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对 KeyGroup 不了解的同学可以参考《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkxOTE3MDU5MQ==&amp;amp;mid=2247484339&amp;amp;idx=1&amp;amp;sn=c83b5fc85f6abadaa7ac94f08c571b31&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Flink 源码：从 KeyGroup 到 Rescale&lt;/a&gt;》，加上 KeyGroupId 也比较简单。只需要修改 RocksDB key 的拼接方式，在序列化 key 和 namespace 之前，先序列化 KeyGroupId 即可。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. State TTL 简述&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Flink 中 TTL 的实现，都是将用户的 value 封装了一层，具体参考下面的 TtlValue 类：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TtlValue&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Serializable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;@Nullable&lt;/span&gt;&lt;br/&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; T userValue;&lt;br/&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; lastAccessTimestamp;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TtlValue 类中有两个字段，封装了用户的 value 且有一个时间戳字段，这个时间戳记录了这条数据写入的时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果开启了 TTL，则状态中存储的 value 就是 TtlValue 对象。时间戳字段也会保存到状态引擎中，之后查询数据时，就可以通过该时间戳判断数据是否过期。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ValueState 将 value 封装为 TtlValue。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MapState 将 userValue 封装成 TtlValue。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ListState 将 element 封装成 TtlValue。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ValueState 中存 Map 与 MapState 有什么区别？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果 ValueState 中存 Map，则整个 Map 被当做 value，只维护一个时间戳。所以要么整个 Map 过期，要么都不过期。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MapState 中如果存储了 100 个 KV 键值对，则 100 个 KV 键值对都会存储各自的时间戳。因此每个 KV 键值对的 TTL 是相互独立的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5. 总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文从实现原理详细分析了 ValueState 中存 Map 与 MapState 有什么区别？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从性能和 TTL 两个维度来描述两者的区别。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;性能&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;RocksDB 场景，MapState 比 ValueState 中存 Map 性能高很多，ValueState 中存大对象很容易使 CPU 打满&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Heap State 场景，两者性能类似&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;TTL&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Flink 中 State 支持设置 TTL，TTL 只是将时间戳与 userValue 封装起来。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;MapState 的 TTL 是基于 UK 级别的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ValueState 的 TTL 是基于整个 key 的&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;扩展：其实 ListState 的数据映射到 RocksDB 比较复杂，用到了 RocksDB 的 merge 特性，比较有意思，有兴趣的同学可以阅读 RocksDB wiki《Merge Operator Implementation》，链接：https://github.com/facebook/rocksdb/wiki/Merge-Operator-Implementation&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;博主新创建了《大数据技术交流群》，感兴趣的同学可以扫码加博主微信，拉你进群学习交流。&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/7s1EHEg3rgsmXx11qCaLHq7aiaRDIlbiaVM2j6AAbH30FJndMQDicHFyGfCzAq9Z5xW4r5rxHEw2sJMVeofBZXX9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;20&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/7iahLicCzg1mdVS0ACMRbz2vFS7eftEgCTpBEunXPoICGJyXyhozAxj0YFtBupQlaZibKl2kz6clULiasPARBvGmXQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;430&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>