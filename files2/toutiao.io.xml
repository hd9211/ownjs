<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f8028b4fcba6fdffdceecadd411cf538</guid>
<title>欢迎加入读者圈子，一起交流！</title>
<link>https://toutiao.io/k/mtrqmru</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;&lt;strong&gt;欢迎加入读者圈子，一起交流！&lt;br/&gt;↓↓↓&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;307&quot; data-ratio=&quot;0.5493333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavich3VaNkKeiaAwUhz7TQbQmic4fFsr58X9PAYleYzxqc1K1vZjeBoZDMUsmia0xH67EQYINGRvNOtLmA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;圈子剧透&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、600+圈子成员，以中高级程序员为主，更有架构师、CTO坐镇交流；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、1000+优质主题，数十G独家资料，每日分享，精挑细选；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、全年52期专属邮件周报，让你轻松掌握业界资讯、技术干货，提升认知水平；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、全年52本好书共读，让你花最少的时间，获取更好的知识；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;心动不如行动，赶快加入吧！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f0aabe75dc08dfc39a6687f55bbd3a6b</guid>
<title>异步编程指北</title>
<link>https://toutiao.io/k/k2ezpp7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：michaeywang，腾讯 IEG 运营开发工程师&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;同步、异步，并发、并行、串行，这些名词在我们的开发中会经常遇到，这里对异步编程做一个详细的归纳总结，希望可以对这方面的开发有一些帮助。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.997229916897507&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauOU3MiafJjWoUFmu0xNSBoxa7rZUyzDKsLgdgLo9kawVhtJAy0QicQ3akSUaLChic9ic5ZXj3UxnLXDQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1083&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1 几个名词的概念&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多任务的时候，才会遇到的情况，如：同步、异步，并发、并行。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.1 理清它们的基本概念&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并发：多个任务在同一个时间段内同时执行，如果是单核心计算机，CPU 会不断地切换任务来完成并发操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并行：多任务在同一个时刻同时执行，计算机需要有多核心，每个核心独立执行一个任务，多个任务同时执行，不需要切换。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同步：多任务开始执行，任务 A、B、C 全部执行完成后才算是结束。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;异步：多任务开始执行，只需要主任务 A 执行完成就算结束，主任务执行的时候，可以同时执行异步任务 B、C，主任务 A 可以不需要等待异步任务 B、C 的结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并发、并行，是逻辑结构的设计模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同步、异步，是逻辑调用方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;串行是同步的一种实现，就是没有并发，所有任务一个一个执行完成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并发、并行是异步的 2 种实现方式。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2 举一个例子&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7344461305007587&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauOU3MiafJjWoUFmu0xNSBoxyB5k2fZT54ETVng4YrGKDSN9Vic8ukVZJ4DmEXmGwdl8FooGCGlIYug/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;659&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你的朋友在广州，但是有 2 辆小汽车在深圳，需要你帮忙把这 2 辆小汽车送到广州去。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同步的方式，你先开一辆小汽车到广州，然后再坐火车回深圳，再开另外一辆小汽车去广州。这是串行的方法，2 辆车需要的时间也就更长了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;异步的方式，你开一辆小汽车从深圳去广州，同时请一个代驾把另外一辆小汽车从深圳开去广州。这也就是并行方法，两个人两辆车，可以同时行驶，速度很快。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并发的方式，你一个人，先开一辆车走 500 米，停车跑回来，再开另外一辆车前行 1000 米，停车再跑回来，循环从深圳往广州开。并发的方式，你可以把 2 辆车一块送到朋友手里，但是过程还是很辛苦的。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.3 思考问题&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你找一家汽车托运公司，把 2 辆车一起托运到广州。这种方式是同步、异步，并发、并行的哪种情况呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2 并发/并行执行会遇到的问题&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1 问题 1：并发的任务数量控制&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauOU3MiafJjWoUFmu0xNSBoxvNBv9I1BnM4bVEPSCRek7ibjt6sLUicxTgeicnk8bC5NmmNOacBtkjbGg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设：某个接口的并发请求会达到 1 万的 qps，所以对接口的性能、响应时长都要求很高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接口内部又有大量 redis、mysql 数据读写，程序中还有很多处理逻辑。如果接口内的所有逻辑处理、数据调用都是串行化，那么单个请求耗时可能会超过 100ms，为了性能优化，就会把数据读取的部分与逻辑计算的部分分开来考虑和实现，能够独立的部分单独剥离出来作为异步任务来执行，这样就把串行化的耗时优化为并发执行，充分利用多核计算机的性能，减少单个接口请求的耗时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设的数据具体化，如：这个接口的数据全部是可以独立获取(支持并发)，需要读取来自不同数据结构的 redis 共 10 个，读取不同数据表的数据共 10 个。那么一次请求，数据获取就会启动 10 个 redis 读取任务，10 个 mysql 读取任务。每秒钟 1 万接口请求，会有 10 万个 redis 读取任务和 10 万个 mysql 读取任务。这 21 万的并发任务，在一秒钟内由 16/32 核的后端部署单机来完成，虽然在同一时刻的任务数量不一定会是 21 万(速度快的话会少于 21 万，如果处理速度慢，出现请求积压拥堵，会超过 21 万)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候，会遇到的瓶颈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;内存，如果每个任务需要 500k 内存，那么 210k*0.5M=210*0.5G=105G.&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CPU，任务调度，像 golang 的协程可能开销还小一些，如果是 java 的线程调度，操作系统会因为调度而空转。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网络，每次数据读取 5k，那么 200k&lt;em&gt;5k=200&lt;/em&gt;5M=1G.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;端口，端口号最多能分配出来 65536 个，明显不够用了。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;数据源，redis 可以支持 10 万 qps 的请求，但是 mysql 就难以支持 10 万 qps 了。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面可能出现的瓶颈中，通过计算机资源扩容可以解决大部分问题，比如：部署 50 个后端实例，每个实例只需要应对 200 的 qps，压力就小了很多。对于数据源，mysql 可以有多个 slave 来支持只读的请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，如果接口的并发量更大呢？或者某个/某些数据源读取出现异常，需要重试，或者出现拥堵，接口响应变慢，任务数量也就会出现暴增，后端服务的各方面瓶颈又会随之出现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，我们需要特别注意和关心后端开启的异步任务数量，要做好异常情况的防范，及时中断掉拥堵/超时的任务，&lt;strong&gt;避免任务暴增导致整个服务不可用&lt;/strong&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2 思考问题&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你要如何应对这类并发任务暴增的情况呢？如何提前预防？如何及时干预呢？&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.3 问题 2：共享数据的读写顺序和依赖关系&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;共享数据的并发读写，是并发编程中的老大难问题，如：读写脏数据，旧数据覆盖新数据等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而数据的依赖关系，也就决定了任务的执行先后顺序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了避免共享数据的竞争读写，为了保证任务的先后关系，就需要用到锁、队列等手段，这时候，并发的过程又被部分的拉平为串行化执行。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.4 举个例子&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7616361071932299&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauOU3MiafJjWoUFmu0xNSBoxxNDAfL4jyFxSWOyv9ajJpyQ5ZYCBr8S1XWRjIacslt2qToiaE6aGTWg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1418&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://www.ticketmaster.com/eastern-conf-semis-tbd-at-boston-boston-massachusetts/event/01005C6AA5531A90&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;NBA 季后赛，去现场看球，要抢购球票，体育馆最多容纳 1 万人(1 万张球票)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;体育馆不同距离、不同位置的票，价格和优惠都不相同。有单人位、有双人位，也有 3、4 人位。你约着朋友共 10 个人去看球，要买票，要选位置。这时候抢票就会很尴尬，因为位置连着的可能会被别人抢走，同时买的票越多，与人冲突的概率就越大，会导致抢票特别困难。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时，这个系统的开发也很头大，抢购(秒杀)的并发非常大，预计在开始的一秒钟会超过 10 万人同时进来，再加上刷票的机器人，接口请求量可能瞬间达到 100 万的 QPS。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;较简单的实现方式&lt;/strong&gt;，所有的请求都异步执行，订单全部进入消息队列，下单马上响应处理中，请等待。然后，后端程序再从消息队列中串行化处理每一个订单，把出现冲突的订单直接报错，这样，估计 1 秒钟可以处理 1000 个订单，10 秒钟可以处理 1 万个订单。考虑订单的冲突问题，1 万张球票的 9000 张可能在 30 秒内卖出去，此时只处理了 3 万个订单，第一秒钟进来的 100 万订单已经在消息队列中堆积，又有 30 秒钟的新订单进来，需要很久才可以把剩下的 1000 张球票卖出去啊。同理，下单的用户需要等待太久才知道自己的订单结果，这个过程轮询的请求也会很多很多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;换一种方案，不使用队列串行化处理订单&lt;/strong&gt;，直接并发的处理每一个订单。那么处理流程中的数据都需要梳理清楚。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1 针对每一个用户的请求加锁，避免同一个用户的重入；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2 每一个/组座位预生成一个 key:0，默认 0 说明没有下单；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3 预估平均每一个订单包含 2 个/组座位，需要更新 2 个座位 key；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4 下单的时候给座位 key 执行 INCR key 数字递增操作，只有返回 1 的订单才是成功，其他都是失败；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5 如果同一个订单中的座位 key 有冲突的情况下，需要回滚成功 key(INCR key = 1)重置(SET key 0);&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;6 订单成功/失败，处理完成后，去掉用户的请求锁；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;7 订单数据入库到 mysql(消息队列，避免 mysql 成为瓶颈);&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;综上，需要用到 1 个锁(2 次操作)，平均 2 个座位 key(每个座位号 1-2 次操作)，这里只有 2 个座位 key 可以并发更新。为了让 redis 不成为数据读写的瓶颈(超过 100w 的 QPS 写操作)，不能使用单实例模式，而要使用 redis 集群，使用由 10-20 个 redis 实例组成的集群，来支持这么高的 redis 数据读写。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;算上 redis 数据读写、参数、异常、逻辑处理，一个请求大概耗时 10ms 左右，单核至少可以支持 100 并发，由于这里有大量 IO 处理，后端服务可以支持的并发可以更高些，预计单核 200 并发，16 核就可以支持 3200 并发。总共需要支持 100 万并发，预计需要 312 台后端服务器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方案比队列的方案需要的服务器资源更多，但是用户的等待时间很短，体验就好很多。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.5 思考问题&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际情况会是怎样呢？会有 10 万人同时抢票吗？会有 100 万的超高并发吗？订票系统真的会准备 300 多台服务器来应对抢票吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3 状态处理：忽略结果&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0940919037199124&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauOU3MiafJjWoUFmu0xNSBox0Kbz8zXyNJsZ1o5TVnZLJMrUCnfJ9icenGphm54Nv0BtvkdiaQ8icypAg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;457&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1 使用场景和案例&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用场景，主流程之外的异步任务，可能重要程度不高，或者处理的复杂度太高，有时候会忽略异步任务的处理结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;案例 1：异步的数据上报、数据存储/计算/统计/分析。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;案例 2：模板化创建服务，有很多个任务，有前后关联任务，也有相互独立任务，有些执行速度很慢，有些任务失败后也可以手动重试来修复。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;忽略结果的情况，就会遇到下面的问题。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2 问题 1：数据一致性&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看下案例 1 的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;异步的日志上报，是否成功发送到服务端呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;异步的指标数据上报，是否正确汇总统计和发送到服务端呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;异步的任务，数据发送到消息队列，是否被后端应用程序消费呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务端是否正常存储和处理完成呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果因为网络原因，因为并发量太大导致服务负载问题，因为程序 bug 的原因，导致数据没能正确上报和处理，这时候的数据不一致、丢失的问题，就会难以及时排查和事后补发。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果在本地完整记录一份数据，以备数据审查，又要考虑高并发高性能的瓶颈，毕竟本地日志读写性能受到磁盘速度的影响，性能会很差。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.3 问题 2：功能可靠性&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看下案例 2 的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建服务的过程中，有创建代码仓库、开启日志采集和自定义镜像中心，CI/CD 等耗时很长的任务。这里开启日志采集和自定义镜像中心如果出现异常，对整个服务的运行没有影响，而且开发者发现问题后也可以自己手动操作下，再次开启日志采集和自定义镜像功能。所以在模板化处理中，这些异步处理任务就没有关注任务的状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么问题就很明显，模板化创建服务的过程中，是不能保证全部功能都正常执行完成的，会有部分功能可能有异常，而且也没有提示和后续指引。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然模板化创建服务的程序，也可以把全部任务的状态都检查结果，只是会增加一些处理的复杂度和难度。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.4 思考问题&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际开发中，有遇到类似上面的两个案例吗？你会如何处理呢？所有的异步任务，都会检查状态结果吗？为什么呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4 状态处理：结果返回&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.1 使用场景和案例&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大部分的异步任务对于状态结果还是很关注的，比如：后续的处理逻辑或者任务依赖某个异步任务，或者异步任务非常重要，需要把结果返回给请求方。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;案例 1：模板化创建服务的过程中，需要异步创建服务的 git 代码仓库，还要给仓库添加成员、webhook、初始化代码等。整个过程全部串行化作为一个任务的话，耗时会比较长。可以把创建服务的 git 代码仓库作为一个异步任务，然后得到成功的结果后再异步的发起添加成员、加 webhook、初始化代码等任务。同时，这里的 CI/CD 有配置相关，有执行相关，整个过程也很长，CD 部署成功之后才可以开启日志采集等配置，所以也需要关注 CD 部署的结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;案例 2：各种 webhook、callback 接口和方法，就是基于回调的方式，如：golang 中的 channel 通知，工蜂中的代码 push 等 webhook，监控告警中的 callback 等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;案例 3：发布订阅模式，如引入消息队列服务，主程序把数据发送给消息队列，异步任务订阅相应的主题然后处理。处理完成后也可以把结果再发送给消息队列，或者把结果发送给主调程序的接口，或者等待主调程序来查询结果，当然也可能是上面的忽略结果的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上可以总结出来，对于异步任务的状态处理，需要关注结果的话，有两种主要的方法，分别是：轮询查询和等待回调。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.2 方法 1：轮询查询&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.40265120132560067&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauOU3MiafJjWoUFmu0xNSBox6dftTxnl5e9EQicfaDO6bGJkibialmrR4FDgF6UvDcdSvKdI0upZXZz0w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1207&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的案例 1 中，模板化创建服务的过程很慢，所以整个功能都是异步的，用户大概要等待 10s 左右才知道最后的结果。所以，用户在创建服务之后，浏览器会不断轮询服务端接口，看看创建服务的结果，各个步骤的处理结果，服务配置是否都成功完成了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类似的功能实现应该有很多，比如：服务构建、部署、创建镜像仓库、抢购买票等，把任务执行和任务结果通过异步的方式强制分离开，用户可以等待，但是不用停留在当前任务中持续等待，而是可以去做别的事情，随时回来关注下这个任务的处理结果就好了。大部分执行时间很长的任务都会放到异步线程中执行，用户关注结果的话，就可以通过查询的方式来获取结果，程序自动来返回结果的话，就可以用到轮询查询了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;局限性 1：频率和实时性&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;轮询的方式延时可能会比较高，因为跟定时器的间隔时间有关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;局限性 2：增加请求压力&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为轮询，要不断地请求服务端，所以对后端的请求压力也会比较大。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.3 方法 2：通知回调&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5806451612903226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauOU3MiafJjWoUFmu0xNSBoxBfjM0iarXnKNlMKxOYMRaA2ibyMDMSpB1qhY7ic2ztDtzsaCU1o5WRibuw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;341&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;等待回调几乎是实时的，处理有结果返回就马上通过回调通知到主程序/用户，那么效率和体验上就会好很多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这里也有一个前提要求，回调的时候，主程序必须还在运行，否则回调也就没有了主体，也就无效了。所以要求主程序需要持续等待异步任务的回调，不能过早的退出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般程序中使用异步任务，需要得到任务状态的结果，使用等待回调的情况更多一些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;特别注意 1：等待超时&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;等待的时间，一般不能是无限长，这样容易造成某些异常情况下的任务爆炸，内存泄露。所以需要对异步任务设置一个等待超时，过期后就要中断任务了，也就不能通过回调来得到结果了，直接认为是任务异常了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;特别注意 2：异常情况&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当主程序在等待异步任务的回调时，如果异步任务自身有异常，无法成功执行，也无法完成回调的操作，那么主程序也就无法得到想要的结果，也不知道任务状态的结果是成功还是失败，这时候也就会遇到上面等待超时的情况了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;特别注意 3：回调地狱&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 nodejs 异步编程的时候，所有的 io 操作都是异步回调，于是就很容易陷入 N 层的回调，代码就会变得异常丑陋和难以维护。于是就出现了很多的异步编程框架/模式，像：Promise,Generator,async/await 等。这里不做过多讲解。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.4 思考问题&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际工作中，还有哪些地方需要处理异步任务的状态结果返回呢？除了轮询和回调，还有其他的方法吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5 异常处理&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同步的程序，处理异常情况，在 java 中只需要一个 try catch 就可以捕获到全部的异常。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.1 重点 1：分别做异常处理&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;异步的程序，try catch 只能捕获到当前主程序的异常，主程序中的异步线程是无法被捕获的。这时候，就需要针对异步线程中的异步任务也要单独进行 try catch 捕获异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 golang 中，开启协程，还是需要在异步任务的 defer 方法中，加入一个 recover() ，以避免没有处理的异常导致整个进程的 panic。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.2 重点 2：异常结果的记录，查询或者回调&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们把异步任务中的异常情况都处理好了，不会导致异步线程把整个进程整奔溃了，那么还有问题，怎么把异常的结果返回给主进程。这就涉及到上面的状态处理了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果可以忽略结果，那么只需要写一下错误日志就好了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果需要处理状态，那就要记录下异常信息或者通知回调给到主进程。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.3 思考问题&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际工作中，你会对所有的可能异常情况都做相应的处理吗？异常结果，都是怎么处理的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6 典型场景和思考&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面已经讲到一些案例，总结下来的典型场景有如下几种&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;6.1 订阅发布模式，消息队列&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;6.2 慢请求，耗时长的任务&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;6.3 高并发、高性能要求时的多任务处理&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;6.4 不确定执行的时间点，触发器&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;人脑(单核)不擅长异步思考，电脑(多核)却更适合。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;编程的时候，是人脑适配电脑，还是电脑服务人脑？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在大部分的编程中，大家都只需要考虑同步的方式来写代码逻辑。少部分时候，就要考虑使用异步的方式。而且，有很多的开发框架、类库已经把异步处理封装，可以简化异步任务的开发和调试工作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，对于开发者来说，默认还是同步方式思考和开发，当不得不使用异步的时候，才会考虑异步的方式。毕竟让人脑适配电脑，这个过程还是有些困难的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_live_iframe&quot; data-pluginname=&quot;videosnap&quot; data-headimgurl=&quot;https://wx.qlogo.cn/finderhead/I7awtksbibjQe7RZAy84xESOBAfIZ8xQ9ApXt4uTe8po/0&quot; data-username=&quot;v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder&quot; data-nickname=&quot;腾讯程序员&quot; data-desc=&quot;将在06月01日 19:30 直播&quot; data-intro=&quot;从代码小妹到战略女精英 ：女程序员的寻梦之旅&quot; data-noticeid=&quot;finderlivenotice-v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder-1652417934358061-1352449116&quot; data-type=&quot;live&quot;/&gt;&lt;/section&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe videosnap_video_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAAJdALmwIFFwAAAAstQy6ubaLX4KHWvLEZgBPE3KJYZCFwFNuDzNPgMIvTwqTuae_sJAvxWMpNF95a&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=rjD5jyTuFrIpZ2ibE8T7Ym3K77SEULgkiaFtAMAvnQFnwJIH45X3fmgZnhMmIRB5VfOYPcWTS8mlUibyzexQVRODRJHdHPQJxHZXEUjib3OCkAia9bFd8cd5ONg&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SZ&amp;amp;idx=1&amp;amp;m=&amp;amp;scene=0&amp;amp;token=x5Y29zUxcibDLHhVDXmosYwGtTF2SCWgTcrD21Cfz4PgtD0vYjqhv9LfUHObTeIZ6QdWeXk7xntk&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/I7awtksbibjQe7RZAy84xESOBAfIZ8xQ9ApXt4uTe8po/0&quot; data-username=&quot;v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder&quot; data-nickname=&quot;腾讯程序员&quot; data-desc=&quot;回想起出发前的场景，真的像做了一场热血的梦...&amp;#10;&amp;#10;&quot; data-nonceid=&quot;5900535609353475142&quot; data-type=&quot;video&quot; data-width=&quot;1920&quot; data-height=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>37e0247cde8ab0732b6f4800ee4c2728</guid>
<title>某些情况下，合理使用指针将大大提升程序的运行效率</title>
<link>https://toutiao.io/k/zophsom</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;h2&gt;&lt;span&gt;&lt;strong&gt;1. 避免在循环中造成不必要的数组空指针检查&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;目前官方标准 Go 编译器实现中存在一些缺陷（v1.18）。其中之一是 一些 nil 数组指针检查没有被移出循环。这里有一个例子来体现这个缺陷。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;// unnecessary-checks.go&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;package pointers&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import &quot;testing&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;const N = 1000&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;var a [N]int&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;//go:noinline&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;func g0(a *[N]int) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  for i := range a {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    a[i] = i // line 12&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;//go:noinline&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;func g1(a *[N]int) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  _ = *a // line 18&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  for i := range a {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    a[i] = i // line 20&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;func Benchmark_g0(b *testing.B) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  for i := 0; i &amp;lt; b.N; i++ { g0(&amp;amp;a) }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;func Benchmark_g1(b *testing.B) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  for i := 0; i &amp;lt; b.N; i++ { g1(&amp;amp;a) }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;让我们用 &lt;code&gt;-S&lt;/code&gt; 编译选项来运行此基准测试，得到的输出结果如下（省略了不感兴趣的输出）：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;$ go test -bench=. -gcflags=-S unnecessary-checks.go&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;0x0004 00004 (unnecessary-checks.go:12)  TESTB  AL, (AX)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;0x0006 00006 (unnecessary-checks.go:12)  MOVQ  CX, (AX)(CX*8)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;0x0000 00000 (unnecessary-checks.go:18)  TESTB  AL, (AX)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;0x0002 00002 (unnecessary-checks.go:18)  XORL  CX, CX&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;0x0004 00004 (unnecessary-checks.go:19)  JMP  13&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;0x0006 00006 (unnecessary-checks.go:20)  MOVQ  CX, (AX)(CX*8)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Benchmark_g0-4  517.6 ns/op&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Benchmark_g1-4  398.1 ns/op&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;从输出结果中，我们可以发现 &lt;code&gt;g1&lt;/code&gt; 实现比 &lt;code&gt;g0&lt;/code&gt; 实现更高效。即使 &lt;code&gt;g1&lt;/code&gt; 的实现多了一行代码（第 18 行）。为什么会这样？输出的汇编指令回答了这个问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在 &lt;code&gt;g0&lt;/code&gt; 实现中，&lt;code&gt;TESTB&lt;/code&gt; 指令生成在在循环内，而在 &lt;code&gt;g1&lt;/code&gt; 实现中，&lt;code&gt;TESTB&lt;/code&gt; 指令生成在循环外。 &lt;code&gt;TESTB&lt;/code&gt; 指令用于检查参数 &lt;code&gt;a&lt;/code&gt; 是否是一个空指针。对于这种特定情况，检查一次就足够了。多出来的这一行代码避免了编译器实现中的缺陷。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这里有第三种实现，其性能与 &lt;code&gt;g1&lt;/code&gt; 的实现一样高效。第三种实现方式使用了一个从数组指针参数派生出来的切片。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;//go:noinline&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;func g2(x *[N]int) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  a := x[:]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  for i := range a {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    a[i] = i&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;请注意该缺陷可能在未来的编译器版本中被修补。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;同时请注意，如果这三个函数实现可以内联，那么基准测试结果将产生很大变化。这就是为什么这里使用 &lt;code&gt;//go:noinline&lt;/code&gt; 编译器指示的原因。（然而，我们应该知道的是，在Go 工具链 v1.18 之前，&lt;code&gt;//go:noinline&lt;/code&gt; 编译器指示在这里实际上是不必要的，因为 包含 &lt;code&gt;for-range&lt;/code&gt; 循环的函数从 Go 工具链 v1.18 以前是不可内内联的）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;2. 数组指针是一个结构体字段的情况&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果一个数组指针为一个结构体字段的情况，情况会稍微有点复杂。下面代码中的 &lt;code&gt;_ = *t.a&lt;/code&gt; 一行无法避开上述编译器缺陷。例如，在下面的代码中，&lt;code&gt;f1&lt;/code&gt; 函数和 &lt;code&gt;f0&lt;/code&gt; 函数的性能差异很小。(事实上，如果在 &lt;code&gt;f1&lt;/code&gt; 函数的循环内产生了一条 &lt;code&gt;NOP&lt;/code&gt; 指令，那它可能更慢。）&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;type T struct {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  a *[N]int&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;//go:noinline&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;func f0(t *T) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  for i := range t.a {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    t.a[i] = i&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;//go:noinline&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;func f1(t *T) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  _ = *t.a&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  for i := range t.a {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    t.a[i] = i&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;欲将数组空指针检查移出循环，&lt;/p&gt;&lt;p&gt;我们应该把 &lt;code&gt;t.a&lt;/code&gt; 字段复制到一个局部变量，然后采用上面介绍的技巧：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;//go:noinline&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;func f3(t *T) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  a := t.a&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  _ = *a&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  for i := range a {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    a[i] = i&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;或者简单地从数组指针字段中派生出一个切片：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;//go:noinline&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;func f4(t *T) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  a := t.a[:]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  for i := range a {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    a[i] = i&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;基准测试结果：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Benchmark_f0-4  622.9 ns/op&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Benchmark_f1-4  637.4 ns/op&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Benchmark_f2-4  511.3 ns/op&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Benchmark_f3-4  390.1 ns/op&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Benchmark_f4-4  387.6 ns/op&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;基准结果验证了我们上面的结论。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;注意，基准结果中提到的 &lt;code&gt;f2&lt;/code&gt; 函数声明为&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;//go:noinline&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;func f2(t *T) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  a := t.a&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  for i := range a {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    a[i] = i&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;code&gt;f2&lt;/code&gt; 实现没有 &lt;code&gt;f3&lt;/code&gt; 和 &lt;code&gt;f4&lt;/code&gt; 实现快，但它比 &lt;code&gt;f0&lt;/code&gt; 和 &lt;code&gt;f1&lt;/code&gt; 实现快。不过，那是 另一个故事。&lt;/p&gt;&lt;p&gt;如果数组指针字段的元素在循环中不被修改（而仅被读取），那么 &lt;code&gt;f1&lt;/code&gt; 实现与 &lt;code&gt;f3&lt;/code&gt; 和 &lt;code&gt;f4&lt;/code&gt; 实现性能相当。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我的个人观点是，对于大多数情况，我们应该尝试使用切片方式（ &lt;code&gt;f4&lt;/code&gt; 实现）来获得最佳性能， 因为通常来说，官方标准 Go 编译器对切片的优化要比对数组的优化做得好。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;3. 避免在循环中进行不必要的解引用&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;某些时候，当前的官方标准 Go 编译器（v1.18） 没有聪明到以最优化的方式生成汇编指令。我们不得不以另一种方式写代码以获得最佳性能。例如，在下面的代码中，&lt;code&gt;f&lt;/code&gt; 函数的性能比 &lt;code&gt;g&lt;/code&gt; 函数差得多。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;// avoid-indirects_test.go&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;package pointers&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import &quot;testing&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;func f(sum *int, s []int) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  for _, v := range s { // line 7&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    *sum += v // line 8&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;func g(sum *int, s []int) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  var n = 0&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  for _, v := range s { // line 14&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    n += v // line 15&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  *sum = n&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;var s = make([]int, 1024)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;var r int&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;func Benchmark_f(b *testing.B) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  for i := 0; i &amp;lt; b.N; i++ {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    f(&amp;amp;r, s)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;func Benchmark_g(b *testing.B) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  for i := 0; i &amp;lt; b.N; i++ {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    g(&amp;amp;r, s)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;基准测试结果（省略了不感兴趣的文字）：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;$ go test -bench=. -gcflags=-S avoid-indirects_test.go&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;0x0009 00009 (avoid-indirects_test.go:8)  MOVQ  (AX), SI&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;0x000c 00012 (avoid-indirects_test.go:8)  ADDQ  (BX)(DX*8), SI&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;0x0010 00016 (avoid-indirects_test.go:8)  MOVQ  SI, (AX)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;0x0013 00019 (avoid-indirects_test.go:7)  INCQ  DX&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;0x0016 00022 (avoid-indirects_test.go:7)  CMPQ  CX, DX&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;0x0019 00025 (avoid-indirects_test.go:7)  JGT  9&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;0x000b 00011 (avoid-indirects_test.go:14)  MOVQ  (BX)(DX*8), DI&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;0x000f 00015 (avoid-indirects_test.go:14)  INCQ  DX&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;0x0012 00018 (avoid-indirects_test.go:15)  ADDQ  DI, SI&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;0x0015 00021 (avoid-indirects_test.go:14)  CMPQ  CX, DX&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;0x0018 00024 (avoid-indirects_test.go:14)  JGT  11&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Benchmark_f-4  3024 ns/op&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Benchmark_g-4   566.6 ns/op&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;输出的汇编指令显示指针 &lt;code&gt;sum&lt;/code&gt; 在 &lt;code&gt;f&lt;/code&gt; 函数的循环中被解引用。解引用操作是一个内存操作。对于 &lt;code&gt;g&lt;/code&gt; 函数，解引用操作发生在循环外， 而为循环产生的指令只处理寄存器。CPU 指令处理寄存器的速度比处理内存要快得多。这就是为什么 &lt;code&gt;g&lt;/code&gt; 函数比 &lt;code&gt;f&lt;/code&gt; 函数的性能好得多原因。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于这种特定情况，另一种高性能实现是将指针参数移出函数体：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;func h(s []int) int {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  var n = 0&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  for _, v := range s {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    n += v&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  return n&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;func use_h(s []int) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  var sum = new(int)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  *sum = h(s)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre/&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;本文&lt;span data-raw-text=&quot;首&quot; data-textnode-index-1653212144131=&quot;20&quot; data-index-1653212144131=&quot;418&quot; class=&quot;character hover&quot;&gt;首发&lt;/span&gt;在&lt;span data-raw-text=&quot;微&quot; data-textnode-index-1653212144131=&quot;20&quot; data-index-1653212144131=&quot;421&quot; class=&quot;character hover&quot;&gt;微&lt;/span&gt;信&lt;strong&gt;Go 101&lt;/strong&gt;公众号，欢迎各位转载本文。&lt;strong&gt;Go 101&lt;/strong&gt;公众号将不定期发表一些原创短文，包含Go语言中的事&lt;span data-raw-text=&quot;实&quot; data-textnode-index-1653212144131=&quot;24&quot; data-index-1653212144131=&quot;473&quot; class=&quot;character hover&quot;&gt;实&lt;/span&gt;、细节&lt;span&gt;和技巧&lt;/span&gt;等。有意&lt;span data-raw-text=&quot;关&quot; data-textnode-index-1653212144131=&quot;26&quot; data-index-1653212144131=&quot;484&quot; class=&quot;character hover&quot;&gt;关&lt;/span&gt;注者请扫描下面的二维码。&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU4Mjg4NTc3Nw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/gAQwzEkgfIkkdhX0LrNvxibHTJ2V2JmkH6tPb7WnC03dbn81rV7bgto66NTwX4iag6icWpXcexmCJJC6GibFzld9AQ/0?wx_fmt=png&quot; data-nickname=&quot;Go 101&quot; data-alias=&quot;golang101&quot; data-signature=&quot;Go语言相关原创文章发布。主要包括各种事实、细节和技巧。&quot; data-from=&quot;1&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;关于更多Go语言编程中的事实、细节和技巧，请访问《Go语言101》官方网站 https://gfw.go101.org （可点击下面的原文链接直接访问）或者项目地址 https://github.com/golang101/golang101。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为新开的微信公众号不再支持留言，所以若有问题，可到上述&lt;span&gt;项目中创建一个issue留言交流。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                          
              &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b74d88bf8724c4069d308f155744488c</guid>
<title>干货 | 从B站爬虫到 Elastic 可视化视频合集</title>
<link>https://toutiao.io/k/snawsjq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;section class=&quot;channels_iframe_wrp&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe videosnap_video_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAAfAQzL-7nsAAAAAstQy6ubaLX4KHWvLEZgBPE4oNgcHw1efmDzNPgMIv-4B7Lcn70J9WryCOztj2f&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=rjD5jyTuFrIpZ2ibE8T7YmwgiahniaXswqzYahRr9Ea3ex5n4yfflVyYxHMT18n00QllPUiaeCzbSgLv5h0h4DHIATgTyJUxn1A7d15Mew3WHp6pEVhlsRRKyA&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SH&amp;amp;idx=1&amp;amp;m=&amp;amp;scene=0&amp;amp;token=AxricY7RBHdUkc43u5PmDRR7g2bmuFyy29Uz79qibZPicUwVHDGYOSVQ3ibZdadGJXiceWtum4icFBPbU&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/a18XcQ1EBBhLcAU1x3iaqO2AceHZAiakvOqDVaHMLvNEiaE8AUibAGaic3Q/0&quot; data-username=&quot;v2_060000231003b20faec8c4e38d19c2ddce06ea3db077e8ac25f188434ec8eb8354a9a76ad672@finder&quot; data-nickname=&quot;铭毅天下&quot; data-desc=&quot;#Elasticsearch #Kibana @铭毅天下 &quot; data-nonceid=&quot;11281884118827442105&quot; data-type=&quot;video&quot; data-width=&quot;1920&quot; data-height=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe videosnap_video_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAA2K4kO759-gAAAAstQy6ubaLX4KHWvLEZgBPE6IN4dzMkfvmDzNPgMItRoyAU8UnrcDE3nx_Z-Oij&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=rjD5jyTuFrIpZ2ibE8T7YmwgiahniaXswqz5po73algdO8hfE9Njb4SkmXblPIXibr9nBZ0dJySPm3OSENudiavpj6kicnajqGqvp4ZppUL9hAvs2icc1kmytFOwg&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SH&amp;amp;idx=1&amp;amp;m=&amp;amp;scene=0&amp;amp;token=AxricY7RBHdUkc43u5PmDRaznrj3icdZQ9cWjOicknkUvAxjEuRZEvb4sDxXjvclQ81dqiassUF8QMI&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/a18XcQ1EBBhLcAU1x3iaqO2AceHZAiakvOqDVaHMLvNEiaE8AUibAGaic3Q/0&quot; data-username=&quot;v2_060000231003b20faec8c4e38d19c2ddce06ea3db077e8ac25f188434ec8eb8354a9a76ad672@finder&quot; data-nickname=&quot;铭毅天下&quot; data-desc=&quot;#Elasticsearch #kibana @铭毅天下&amp;#10;&amp;#10;&quot; data-nonceid=&quot;16811333583274478262&quot; data-type=&quot;video&quot; data-width=&quot;1920&quot; data-height=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe videosnap_video_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAAO3MAZMUttQAAAAstQy6ubaLX4KHWvLEZgBPE4YNUG0pDf_mDzNPgMIsLAnbHo3qiNz2ANQvDnUdc&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=rjD5jyTuFrIpZ2ibE8T7YmwgiahniaXswqz4GFhAdZ4MlRIj9s1WuYfuOlhfMRnopEYnlyBVJeraN9yI9FPUOo51VXcA8bR7d7DtqKibeWbsulW9HlZ5j36TDw&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SH&amp;amp;idx=1&amp;amp;m=&amp;amp;scene=0&amp;amp;token=x5Y29zUxcibD9HbTsjDpWm6KUS7z2FIeQMrvRVcyicpfTlTNnu9Q9LYcfibJPuG5hOdsMiadvkzIalk&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/a18XcQ1EBBhLcAU1x3iaqO2AceHZAiakvOqDVaHMLvNEiaE8AUibAGaic3Q/0&quot; data-username=&quot;v2_060000231003b20faec8c4e38d19c2ddce06ea3db077e8ac25f188434ec8eb8354a9a76ad672@finder&quot; data-nickname=&quot;铭毅天下&quot; data-desc=&quot;#Elasticsearch #kibana @铭毅天下 &quot; data-nonceid=&quot;7492430063572354090&quot; data-type=&quot;video&quot; data-width=&quot;1920&quot; data-height=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe videosnap_video_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAAE1w6XVpBlwAAAAstQy6ubaLX4KHWvLEZgBPEtIMIX1YQfPmDzNPgMIvzu7o2MtdF7Ef7FmxeXiAp&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=rjD5jyTuFrIpZ2ibE8T7YmwgiahniaXswqzAC2QLhHyhdrzDk5btjicxW22hDPfUMegfafM5gGOQq1TxobahZgZdlN8wVg0WibLTGLrWzzeLbBKPib6ZmrwfLohg&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SH&amp;amp;idx=1&amp;amp;m=&amp;amp;scene=0&amp;amp;token=AxricY7RBHdUkc43u5PmDRXiccEIfyGxsHAyAYQWCbJYXHqstabQHZLkHu4nWcGPandicj8S6U36OA&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/a18XcQ1EBBhLcAU1x3iaqO2AceHZAiakvOqDVaHMLvNEiaE8AUibAGaic3Q/0&quot; data-username=&quot;v2_060000231003b20faec8c4e38d19c2ddce06ea3db077e8ac25f188434ec8eb8354a9a76ad672@finder&quot; data-nickname=&quot;铭毅天下&quot; data-desc=&quot;#Elasticsearch #kibana @铭毅天下 &quot; data-nonceid=&quot;9409591396328212293&quot; data-type=&quot;video&quot; data-width=&quot;1920&quot; data-height=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe videosnap_video_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAAPGMSILYduwAAAAstQy6ubaLX4KHWvLEZgBPEh4MwEEQRfPmDzNPgMIsE4coXq_n0Gh5RDr2NwuJx&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=rjD5jyTuFrIpZ2ibE8T7YmwgiahniaXswqzxAaQmwewHIZplxXV9LuaGHHyuwwsly7WYqjmHFEeoHiaFmXGX2onjBdKiaXjCQw38C8e6X0JkKicSSgIEG1Hy3HNg&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SH&amp;amp;idx=1&amp;amp;m=&amp;amp;scene=0&amp;amp;token=AxricY7RBHdUkc43u5PmDRX1VmljaLmiaIlibVGq8BUibOAyfDjiaIn6436StlmhbYfQAogOjz3rBmAM&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/a18XcQ1EBBhLcAU1x3iaqO2AceHZAiakvOqDVaHMLvNEiaE8AUibAGaic3Q/0&quot; data-username=&quot;v2_060000231003b20faec8c4e38d19c2ddce06ea3db077e8ac25f188434ec8eb8354a9a76ad672@finder&quot; data-nickname=&quot;铭毅天下&quot; data-desc=&quot;#Elasticsearch #kibana @铭毅天下 &quot; data-nonceid=&quot;17762315084389680378&quot; data-type=&quot;video&quot; data-width=&quot;1920&quot; data-height=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.公众号：铭毅天下Elasticsearch——中国最大的 Elastic 非官方技术公众号&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.博客：elastic.blog.csdn.net——访问量550万+&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.知识星球：死磕Elasticsearch（中国Elastic认证工程师的半壁江山都出自本星球）——http://t.cn/RmwM3N9&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4.VX：elastic6，欢迎留言交流！ &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5.&lt;/span&gt;&lt;span&gt;B站：&lt;/span&gt;&lt;span&gt;https://space.bilibili.com/471049389&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>536ac6d882b7bbdb3e8387c5cbc36b8f</guid>
<title>Web Components-LitElement 实践</title>
<link>https://toutiao.io/k/h5l3gtd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Google 在 2011 年首次正式提出 Web Components 组件化概念时，它主要依赖三个技术：Custom Element、Shadow Dom、HTML Templates。直到 2015 年 Google 才真正投入生产进行使用，那时其他浏览器厂商还没有大规模支持这个特性，应用起来存在很大的兼容问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这期间，Angular、React 和 Vue 三大框架崛起，并且都有“组件化”这个功能，也形成了各自的生态圈，但都与框架强关联。由于这个原因，开发者对于 Web Components 的呼声一直是只增不减。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直到今天，由于各大浏览器厂商的支持并结合 polyfills，在使用 Web Components 时，兼容性已经不是问题，开发者开始积极探索并实践 Web Components 技术。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何更好地应用 Web Components 技术呢？有轻便的框架可以简化原生较为复杂的写法吗？那么我们来看看 LitElement 做了什么，能不能让 Web Components 变得更好用些。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;回顾&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过阅读上篇文章《如何基于 Web Components 封装 UI 组件库》(https://juejin.cn/post/7096265630466670606)，我们掌握了原生 Web Components 的一些内容，包括：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;三要素和生命周期；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;基本的组件通信，包括如何利用 observedAttributes 属性监听和 attributeChangedCallback 生命周期获取最新属性和通过 CustomEvent 抛出自定义事件来模拟实现状态的“双向绑定”；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何设计组件库；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何在原生、React 和 Vue 中优雅地使用我们封装的组件。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但使用 Web Components 的原生写法确实存在一些不简洁的地方：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;属性监听：observedAttributes API 需要结合 attributeChangedCallback 生命周期，写起来代码量大；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;组件通信时传入复杂数据类型：只能通过 stringify 后的 attribute 传递，特殊对象格式如 Date，Function 等传递起来会非常复杂，和现在的组件库能力上相比功能会比较弱，使用场景相对单一；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;组件通信时双向绑定：需要结合自定义事件，写法会比较复杂。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了更丰富的开发场景和更好的开发体验，LitElement 把以上问题进行了归纳转化，即：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如何响应 reactive properties的变化，并应用到 UI 上。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何解决模板语法。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它用了两个核心库来解决这个问题，分别是 lit-element 和 lit-html。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;LitElement介绍&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;基本内容&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Lit 的核心是一个组件基类，它提供响应式、scoped 样式和一个小巧、快速且富有表现力的声明性模板系统，且支持 TypeScript 类型声明。Lit 在开发过程中不需要编译或构建，几乎可以在无工具的情况下使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道 HTMLElement 是浏览器内置的类，LitElement 基类则是 HTMLElement 的子类，因此 Lit 组件继承了所有标准 HTMLElement 属性和方法。更具体来说，LitElement 继承自 ReactiveElement，后者实现了响应式属性，而后者又继承自 HTMLElement。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5578947368421052&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sticlevzdTIAyM2Y1YCjwVCYvUvxBMU3SNrq3ymNqmJfn5F5ojCU0B2Q0wbp4GbY6hwYpRhavg6uicyPvt5iayY8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;665&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建 Lit 组件还涉及许多概念，我们一一了解。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;定义一个组件&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Lit 组件作为 Custom Element 的实现，并在浏览器中注册。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原生的写法主要是继承 HTMLElement 类并重写它的方法。而 LitElement 框架则是基于 HTMLElement 类二次封装了 LitElement 类，它将很多的写法通过一些语法糖的封装变得更简单了，极大地简化了这些代码。开发者只需继承 LitElement 类开发自己的组件然后通过浏览器原生方法 customElements.define 注册即可。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LitButton&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;LitElement&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;/* ... */&lt;/span&gt;  }&lt;br/&gt;customElements.define(&lt;span&gt;&#x27;lit-button&#x27;&lt;/span&gt;, LitButton);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当定义一个 Lit 组件时，就是定义了一个自定义 HTML 元素。因此，可以像使用任何内置元素一样使用新元素。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;lit-button type=&lt;span&gt;&quot;primary&quot;&lt;/span&gt;&amp;gt;&amp;lt;&lt;span&gt;/lit-button&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;渲染&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;组件具有 render 方法，该方法被调用以渲染组件的内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然 Lit 模板看起来像字符串插值，但 Lit 解析并创建一次静态 HTML，然后只更新表达式中需要更改的值。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LitButton&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;LitElement&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;/* ... */&lt;/span&gt;&lt;br/&gt; &lt;br/&gt; render() {&lt;br/&gt;    &lt;span&gt;// 使用模板字符串，可以包含表达式&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; html`&lt;span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;slot&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;btnText&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;slot&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    `&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常，组件的 render() 方法返回单个 TemplateResult 对象（与 html 标记函数返回的类型相同）。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;TemplateResult对象：是 lit-html 接收模板字符串并经过它的 html 标记函数处理得到的一个纯值对象。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，它可以返回 Lit 可以渲染的任何内容，包括：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;primitive 原始类型值，如字符串、数字或布尔值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;由 html 函数创建的 TemplateResult 对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DOM 节点。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;任何受支持类型的数组或可迭代对象。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;响应式 properties&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;DOM 中 property 与 attribute 的区别：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;attribute 是 HTML 标签上的特性，可以理解为标签属性，它的值只能够是 String 类型，并且会自动添加同名 DOM 属性作为 property 的初始值；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;property 是 DOM 中的属性，是 JavaScript 里的对象，有同名 attribiute 标签属性的 property 属性值的改变也并不会同步引起 attribute 标签属性值的改变；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Lit 组件接收标签属性 attribute 并将其状态存储为 JavaScript 的 class 字段属性或 properties。响应式 properties 是可以在更改时触发响应式更新周期、重新渲染组件以及可选地读取或重新写入 attribute 的属性。每一个 properties 属性都可以配置它的选项对象。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LitButton&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;LitElement&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;// 在静态属性类字段中声明属性，Lit 会处理为响应式属性&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;static&lt;/span&gt; properties = {&lt;br/&gt;    &lt;span&gt;type&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;String&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;reflect&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;/*...其他选项属性...*/&lt;/span&gt;&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;other&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;Object&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  };&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;/* ... */&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的选项对象可以具有以下属性：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;attribute：表示是否与 property 关联，或者 attribute 关联属性的自定义名称。默认值：true，表示 property 会与标签属性 attribute 进行关联。如果设置为 false，则下面的 converter 转换器、reflect 反射和 type 类型选项将被忽略。主要用来将 attribute 与 property 建立关联。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;type：在将 String 类型的 attribute 转换为 property 时，Lit 的默认属性转换器会将 String 类型解析为给定的类型。将 property 反映到 attribute 时反之亦然。如果设置了 converter 转换器，则将此字段传递给转换器。如果未指定类型，则默认转换器将其视为 String 类型。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;converter：用于在 attribute 和 property 之间转换的自定义转换器。如果未指定，则使用默认属性转换器。主要用来决定 attribute 与 property 确定建立关联后如何进行数据转换，毕竟 attribute 只能是 String 类型而 property 却是可以自定义的类型，默认属性转换器则是依据 property 配置的 type 选项进行目标类型的转换。上例中表示接受的 other 属性的 attribute 后会序列化为目标 Object 类型。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;hasChanged：每当设置属性时调用的函数以确定属性是否已更改，并应触发更新。如果未指定，LitElement 将使用严格的不等式检查 &lt;code&gt;(newValue !== oldValue)&lt;/code&gt; 来确定属性值是否已更改。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;reflect：property 属性值是否反映回关联的 attribute 属性。默认值：false，即 property 的改变不会主动引起 attribute 的改变。上例中表示接收 type 组件属性 properties 的改动会同步到对应 attribute 标签属性上。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;state：设置为 true 以将 property 属性声明为内部 state。内部 state 的改变也会触发更新，就像响应式属性 property，但 Lit 不会为其生成 attribute 属性，用户不应从组件外部访问它。这些属性应标记为 private 或 protected。还建议使用前导下划线 (_) 之类的约定来标识  JavaScript 用户的 private 或 protected 属性。可以为 state 内部状态指定的唯一选项是 hasChanged 函数。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;省略选项对象或指定一个空的选项对象等效于为所有选项指定默认值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，Lit 为每个响应式属性生成一个 getter/setter 对。当响应式属性发生变化时，组件会安排更新。Lit 也会自动应用 super 类声明的属性选项。除非需要更改选项，否则不需要重新声明该属性。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;样式&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;组件模板被渲染到它的 shadow root。添加到组件的样式会自动作用于 shadow root，并且只会影响组件 shadow root 中的元素。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Shadow DOM 为样式提供了强大的封装。如果 Lit 没有使用 Shadow DOM，则必须非常小心不要意外地为组件之外的元素设置样式，无论是组件的父组件还是子组件。这可能涉及编写冗长而繁琐的类名。通过使用 Shadow DOM，Lit 确保编写的任何选择器仅适用于 Lit 组件的 shadow root 中的元素。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以使用标记的模板 css 函数在静态 styles 类字段中定义 scoped 样式。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LitButton&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;LitElement&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;// 使用纯 CSS 为组件定义 scoped 样式&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;static&lt;/span&gt; styles = css`&lt;span&gt;&lt;br/&gt;    &lt;span&gt;.lit-button&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;display&lt;/span&gt;: inline-block;&lt;br/&gt;      &lt;span&gt;padding&lt;/span&gt;: &lt;span&gt;4px&lt;/span&gt; &lt;span&gt;20px&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;font-size&lt;/span&gt;: &lt;span&gt;14px&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;line-height&lt;/span&gt;: &lt;span&gt;1.5715&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;font-weight&lt;/span&gt;: &lt;span&gt;400&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;border&lt;/span&gt;: &lt;span&gt;1px&lt;/span&gt; solid &lt;span&gt;#1890ff&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;border-radius&lt;/span&gt;: &lt;span&gt;2px&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;background-color&lt;/span&gt;: &lt;span&gt;#1890ff&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;color&lt;/span&gt;: &lt;span&gt;#fff&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;box-shadow&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt; &lt;span&gt;2px&lt;/span&gt; &lt;span&gt;#00000004&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;cursor&lt;/span&gt;: pointer;&lt;br/&gt;    }&lt;br/&gt;  `&lt;/span&gt;;&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;/* ... */&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3354908306364617&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sticlevzdTIAyM2Y1YCjwVCYvUvxBMU3S7sPJkTQUXwJUvsz6LnACicy3icEyvlXlmibLtVBibYdBRQPVt4CYWeWBMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1854&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图同样应用了 lit-button 样式，但样式只对 shodow root 中的部分起作用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;静态 styles 类字段的值可以是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;单个标记的模板文字。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;static&lt;/span&gt; styles = css`&lt;span&gt;...`&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;一组标记的模板文字。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;static&lt;/span&gt; styles = [ css`&lt;span&gt;...`&lt;/span&gt;, css`&lt;span&gt;...`&lt;/span&gt;];&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，styles 也支持在样式中使用表达式、使用语句、继承父类样式、共享样式、使用 unicode  escapes 以及在模板 template 中使用样式等功能。Lit 也提供了两个指令，classMap 和 styleMap，可以方便地在 HTML 模板中条件式的应用 class 和 style。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; {LitElement, html, css} &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;lit&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; {classMap} &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;lit/directives/class-map.js&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; {styleMap} &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;lit/directives/style-map.js&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LitButton&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;LitElement&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;static&lt;/span&gt; properties = {&lt;br/&gt;    &lt;span&gt;classes&lt;/span&gt;: {},&lt;br/&gt;    &lt;span&gt;styles&lt;/span&gt;: {},&lt;br/&gt;  };&lt;br/&gt;  &lt;span&gt;static&lt;/span&gt; styles = css`&lt;span&gt;&lt;br/&gt;   &lt;span&gt;.lit-button&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;display&lt;/span&gt;: inline-block;&lt;br/&gt;      &lt;span&gt;padding&lt;/span&gt;: &lt;span&gt;4px&lt;/span&gt; &lt;span&gt;20px&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;font-size&lt;/span&gt;: &lt;span&gt;14px&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;line-height&lt;/span&gt;: &lt;span&gt;1.5715&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;font-weight&lt;/span&gt;: &lt;span&gt;400&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;border&lt;/span&gt;: &lt;span&gt;1px&lt;/span&gt; solid &lt;span&gt;#1890ff&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;border-radius&lt;/span&gt;: &lt;span&gt;2px&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;background-color&lt;/span&gt;: &lt;span&gt;#1890ff&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;color&lt;/span&gt;: &lt;span&gt;#fff&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;box-shadow&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt; &lt;span&gt;2px&lt;/span&gt; &lt;span&gt;#00000004&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;cursor&lt;/span&gt;: pointer;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;.someclass&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;color&lt;/span&gt;: &lt;span&gt;#000&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;.anotherclass&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;font-size&lt;/span&gt;: &lt;span&gt;16px&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;  `&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;super&lt;/span&gt;();&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.classes = {&lt;span&gt;&#x27;lit-button&#x27;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;someclass&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;anotherclass&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;};&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.styles = {&lt;span&gt;fontFamily&lt;/span&gt;: &lt;span&gt;&#x27;Roboto&#x27;&lt;/span&gt;};&lt;br/&gt;  }&lt;br/&gt;  render() {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; html`&lt;span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;/span&gt;&lt;/span&gt;&lt;span&gt;${classMap(&lt;span&gt;this&lt;/span&gt;.classes)}&lt;/span&gt;&lt;span&gt; &lt;span&gt;style&lt;/span&gt;=&lt;/span&gt;&lt;span&gt;${styleMap(&lt;span&gt;this&lt;/span&gt;.styles)}&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;slot&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;btnText&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;slot&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    `&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;customElements.define(&lt;span&gt;&#x27;lit-button&#x27;&lt;/span&gt;, LitButton);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;生命周期&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Lit 组件可以继承原生的自定义元素生命周期方法。但如果需要使用自定义元素生命周期方法，确保调用 super 类的生命周期，以保证父子组件生命周期的一致。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;标准的自定义组件生命周期&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;constructor()：创建元素时调用。适用于执行必须在第一次更新之前完成的一次性初始化任务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;connectedCallback()：在将组件添加到文档的 DOM 时调用。适用于仅在元素连接到文档时才发生的任务。其中最常见的是将事件侦听器添加到元素节点。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;disconnectedCallback()：当组件从文档的 DOM 中移除时调用，用于移除对元素的引用。比如移除添加到元素节点的事件侦听器。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;attributeChangedCallback()：当元素的 observedAttributes 之一更改时调用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;adoptedCallback()：当组件移动到新文档时调用。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;connectedCallback() {&lt;br/&gt;  &lt;span&gt;super&lt;/span&gt;.connectedCallback()&lt;br/&gt;  addEventListener(&lt;span&gt;&#x27;keydown&#x27;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;._handleKeydown);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;disconnectedCallback() {&lt;br/&gt;  &lt;span&gt;super&lt;/span&gt;.disconnectedCallback()&lt;br/&gt;  &lt;span&gt;window&lt;/span&gt;.removeEventListener(&lt;span&gt;&#x27;keydown&#x27;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;._handleKeydown);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了标准的自定义元素生命周期之外，Lit 组件还实现了响应式更新周期。Lit 异步执行更新，因此属性更改是批处理的，如果在请求更新后但在更新开始之前发生了更多属性更改，则所有更改都将在同一个更新中进行。当响应式 prpperties 属性发生变化或显式调用 requestUpdate() 方法时，将触发响应更新周期，它会将更改呈现给 DOM。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;响应式更新周期&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一阶段：触发更新&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;haschanged()：在设置响应式属性时隐式调用。默认情况下 hasChanged() 会进行严格的相等性检查，如果返回 true，则会安排更新。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;requestUpdate()：调用 requestUpdate() 来安排显式更新。如果需要在与属性无关的内容发生更改时更新和呈现元素，将很有用。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;connectedCallback() {&lt;br/&gt;  &lt;span&gt;super&lt;/span&gt;.connectedCallback();&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;._timerInterval = setInterval(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.requestUpdate(), &lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;disconnectedCallback() {&lt;br/&gt;  &lt;span&gt;super&lt;/span&gt;.disconnectedCallback();&lt;br/&gt;  clearInterval(&lt;span&gt;this&lt;/span&gt;._timerInterval);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二阶段：执行更新&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;shouldUpdate()：调用以确定是否需要更新周期。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;willUpdate()：在 update() 之前调用以计算更新期间所需的值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;update()：调用以更新组件的 DOM。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;render()：由 update() 调用，并应实现返回用于渲染组件 DOM 的可渲染结果（例如 TemplateResult）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三阶段：完成更新&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;firstUpdated()：在组件的 DOM 第一次更新后调用，紧接在调用 updated() 之前。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;updated()：每当组件的更新完成并且元素的 DOM 已更新和呈现时调用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;updateComplete()：updateComplete Promise 在元素完成更新时更新为 resolved 状态。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其他：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;performUpdate()：调用 performUpdate() 以立即处理挂起的更新。这通常不需要，但在需要同步更新的极少数情况下可以这样做。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;hasUpdated()：如果组件至少更新过一次，则 hasUpdated 属性返回 true。仅当组件尚未更新时，才可以在任何生命周期方法中使用 hasUpdated 来执行工作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;getUpdateComplete()：在执行 updateComplete 之前等待其他条件执行完成。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整个流程图示如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.236192714453584&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sticlevzdTIAyM2Y1YCjwVCYvUvxBMU3S0RxNFpibYtTqxnySfKqDGzQVAPoFrOzesrwepBicS52GVLf2kfmth6qg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;851&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;了解了基本的概念和内容，如果你做过任何现代的、基于组件的 Web 开发，你应该对 Lit 的系列概念和用法感到似曾相识并且容易上手。下面通过一些案例了解 LitElement 的其他特性。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;传入复杂数据类型&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于复杂数据的处理，为什么会存在这个问题，根本原因还是因为 attribute 标签属性值只能是 String 类型，其他类型需要进行序列化。在 LitElement 中，只需要在父组件模板的属性值前使用(.)操作符，这样子组件内部 properties 就可以正确序列化为目标类型。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 父组件-复杂数据类型&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt; &lt;span&gt;import&lt;/span&gt; { html, LitElement } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;lit&#x27;&lt;/span&gt;;&lt;br/&gt; &lt;span&gt;import&lt;/span&gt; &lt;span&gt;&#x27;./person&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LitComplex&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;LitElement&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;super&lt;/span&gt;();&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.person= {&lt;span&gt;&#x27;name&#x27;&lt;/span&gt;:&lt;span&gt;&#x27;cai&#x27;&lt;/span&gt;};&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.friends = [{&lt;span&gt;&#x27;name&#x27;&lt;/span&gt;:&lt;span&gt;&#x27;zheng&#x27;&lt;/span&gt;},{&lt;span&gt;&#x27;name&#x27;&lt;/span&gt;:&lt;span&gt;&#x27;yun&#x27;&lt;/span&gt;}];&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;   render() {&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; html`&lt;span&gt;&lt;br/&gt;     &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;复杂数据类型&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&amp;lt;&lt;span&gt;lit-person&lt;/span&gt; &lt;span&gt;.person&lt;/span&gt;=&lt;/span&gt;&lt;/span&gt;&lt;span&gt;${&lt;span&gt;this&lt;/span&gt;.person}&lt;/span&gt;&lt;span&gt; &lt;span&gt;.friends&lt;/span&gt;=&lt;/span&gt;&lt;span&gt;${&lt;span&gt;this&lt;/span&gt;.friends}&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;lit-person&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;     `&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; customElements.define(&lt;span&gt;&#x27;lit-complex&#x27;&lt;/span&gt;, LitComplex);&lt;br/&gt;&lt;br/&gt; &lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; LitComplex;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 基础组件&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt; &lt;span&gt;import&lt;/span&gt; { html, LitElement } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;lit&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LitPerson&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;LitElement&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;static&lt;/span&gt; properties = {&lt;br/&gt;     &lt;span&gt;person&lt;/span&gt;: {&lt;br/&gt;       &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;Object&lt;/span&gt;&lt;br/&gt;     },&lt;br/&gt;     &lt;span&gt;friends&lt;/span&gt;: {&lt;br/&gt;       &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;Array&lt;/span&gt;,&lt;br/&gt;     },&lt;br/&gt;     &lt;span&gt;date&lt;/span&gt;: {&lt;br/&gt;       &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;Date&lt;/span&gt;,&lt;br/&gt;     }&lt;br/&gt;   }&lt;br/&gt;&lt;br/&gt;   firstUpdated() {&lt;br/&gt;     &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;this&lt;/span&gt;.person &lt;span&gt;instanceof&lt;/span&gt; &lt;span&gt;Object&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.friends &lt;span&gt;instanceof&lt;/span&gt; &lt;span&gt;Array&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.date &lt;span&gt;instanceof&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;); &lt;br/&gt;     &lt;span&gt;// true true true&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;&lt;br/&gt;   render() {&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; html`&lt;span&gt;&lt;br/&gt;     &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;${&lt;span&gt;this&lt;/span&gt;.person.name}&lt;/span&gt;&lt;span&gt;有&lt;/span&gt;&lt;span&gt;${&lt;span&gt;this&lt;/span&gt;.friends.length}&lt;/span&gt;&lt;span&gt;个朋友&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;     `&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; customElements.define(&lt;span&gt;&#x27;lit-person&#x27;&lt;/span&gt;, LitPerson);&lt;br/&gt;&lt;br/&gt; &lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; LitPerson;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样可以支持各种类型数据的传递使用。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;数据的双向绑定&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 数据绑定- father&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt; &lt;span&gt;import&lt;/span&gt; { html, LitElement } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;lit&#x27;&lt;/span&gt;;&lt;br/&gt; &lt;span&gt;import&lt;/span&gt; &lt;span&gt;&#x27;./lit-input&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LitInputFather&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;LitElement&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;static&lt;/span&gt; properties = {&lt;br/&gt;    &lt;span&gt;data&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;String&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;super&lt;/span&gt;();&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.data = &lt;span&gt;&#x27;default&#x27;&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  render() {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; html`&lt;span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;lit-input&lt;/span&gt; &lt;span&gt;value&lt;/span&gt;=&lt;/span&gt;&lt;/span&gt;&lt;span&gt;${&lt;span&gt;this&lt;/span&gt;.data}&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;lit-input&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    `&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;customElements.define(&lt;span&gt;&#x27;lit-input-father&#x27;&lt;/span&gt;, LitInputFather);&lt;br/&gt;&lt;br/&gt; &lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; LitInputFather;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 数据绑定&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt; &lt;span&gt;import&lt;/span&gt; { html, LitElement } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;lit&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LitInput&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;LitElement&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;static&lt;/span&gt; properties = {&lt;br/&gt;     &lt;span&gt;value&lt;/span&gt;: {&lt;br/&gt;       &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;String&lt;/span&gt;,&lt;br/&gt;       &lt;span&gt;reflect&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;     }&lt;br/&gt;   }&lt;br/&gt;&lt;br/&gt;   change = &lt;span&gt;(&lt;span&gt;e&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;     &lt;span&gt;this&lt;/span&gt;.value = e.target.value;&lt;br/&gt;   }&lt;br/&gt;&lt;br/&gt;   render() {&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; html`&lt;span&gt;&lt;br/&gt;     &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;输入：&lt;span&gt;&amp;lt;&lt;span&gt;input&lt;/span&gt; &lt;span&gt;value&lt;/span&gt;=&lt;/span&gt;&lt;/span&gt;&lt;span&gt;${&lt;span&gt;this&lt;/span&gt;.value}&lt;/span&gt;&lt;span&gt; @&lt;span&gt;input&lt;/span&gt;=&lt;/span&gt;&lt;span&gt;${&lt;span&gt;this&lt;/span&gt;.change}&lt;/span&gt;&lt;span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;     `&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; customElements.define(&lt;span&gt;&#x27;lit-input&#x27;&lt;/span&gt;, LitInput);&lt;br/&gt;&lt;br/&gt; &lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; LitInput;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里子组件接收了父组件的 value 属性，默认值设为了 &lt;code&gt;&#x27;default&#x27;&lt;/code&gt;，在子组件内通过监听输入事件更新了 value 值，因为 value 属性配置了 reflect 为 true，即可将属性值的改变反映回关联的 attribute 属性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图：input 组件默认值为 &lt;code&gt;&#x27;default&#x27;&lt;/code&gt;并在紧接着输入&lt;code&gt;&#x27;123&#x27;&lt;/code&gt;后，组件的标签属性 value 同时发生了变化。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.31587301587301586&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sticlevzdTIAyM2Y1YCjwVCYvUvxBMU3S2Z2Hm9k7g8kH02cVibGAyfg3qTqY2kCjS54Giaa0kT4hRanNB7stI7pA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1260&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时在父组件通过获取子组件的 attribute 即可获得子组件同步改动的值。以此实现数据的双向绑定，但 LitElement 本身是单向的数据流。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;指令使用&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;指令是可以通过自定义表达式呈现方式来扩展 Lit 的函数。Lit 包含许多内置指令，可帮助满足各种渲染需求：以组件缓存为例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在更改模板而不是丢弃 DOM 时缓存渲染的 DOM。在大型模板之间频繁切换时，可以使用此指令优化渲染性能。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * cache 内置指令使用&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt; &lt;span&gt;import&lt;/span&gt; {LitElement, html} &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;lit&#x27;&lt;/span&gt;;&lt;br/&gt; &lt;span&gt;import&lt;/span&gt; {cache} &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;lit/directives/cache.js&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LitCache&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;LitElement&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;static&lt;/span&gt; properties = {&lt;br/&gt;    &lt;span&gt;show&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;data&lt;/span&gt;: {},&lt;br/&gt;  };&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;super&lt;/span&gt;();&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.data = {&lt;br/&gt;      &lt;span&gt;detail&lt;/span&gt;: &lt;span&gt;&#x27;detail&#x27;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;sumary&lt;/span&gt;: &lt;span&gt;&#x27;sumary&#x27;&lt;/span&gt;&lt;br/&gt;    };&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  detailView = &lt;span&gt;(&lt;span&gt;data&lt;/span&gt;) =&amp;gt;&lt;/span&gt; html`&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;${data.detail}&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;`&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  summaryView = &lt;span&gt;(&lt;span&gt;data&lt;/span&gt;) =&amp;gt;&lt;/span&gt; html`&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;${data.sumary}&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;`&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  changeTab = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.show = !&lt;span&gt;this&lt;/span&gt;.show;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  render() {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; html`&lt;span&gt;${cache(&lt;span&gt;this&lt;/span&gt;.show&lt;br/&gt;      ? &lt;span&gt;this&lt;/span&gt;.detailView(&lt;span&gt;this&lt;/span&gt;.data)&lt;br/&gt;      : &lt;span&gt;this&lt;/span&gt;.summaryView(&lt;span&gt;this&lt;/span&gt;.data)&lt;br/&gt;    )}&lt;/span&gt;&lt;span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;button&lt;/span&gt; @&lt;span&gt;click&lt;/span&gt;=&lt;/span&gt;&lt;/span&gt;&lt;span&gt;${&lt;span&gt;this&lt;/span&gt;.changeTab}&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;切换&lt;span&gt;&amp;lt;/&lt;span&gt;button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    `&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;customElements.define(&lt;span&gt;&#x27;lit-cache&#x27;&lt;/span&gt;, LitCache);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个例子在模板中使用了语句表达式，再通过 click 事件切换组件时展示不同的模板内容；引入了 cache 指令函数，实现了 DOM 的缓存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;LitElement 内置了大量的指令函数可以使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，它还有丰富的 Mixins 和 Decoratrs 等内容值得细细学习，在此不再做过多展开。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总的来说，LitElement 在 Web Components 开发方面有着很多比原生的优势，它具有以下特点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;简单：在 Web Components 标准之上构建，Lit 添加了响应式、声明性模板和一些周到的功能，减少了模板文件。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;快速：更新速度很快，因为 Lit 会跟踪 UI 的动态部分，并且只在底层状态发生变化时更新那些部分——无需重建整个虚拟树并将其与 DOM 的当前状态进行比较。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;轻便：Lit 的压缩后大小约为 5 KB，有助于保持较小的包大小并缩短加载时间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;高扩展性：lit-html 基于标记的 template，它结合了 ES6 中的模板字符串语法，使得它无需预编译、预处理，就能获得浏览器原生支持，并且扩展能力强。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;兼容良好：对浏览器兼容性非常好，对主流浏览器都能有非常好的支持。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结合这些点，基本可以满足项目开发中的大部分场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是关于 LitElement 介绍的主要内容，更多内容可以前往官网学习了解，文中案例地址可以在此获得 (https://github.com/CYLpursuit/lit-element-ui)，同时推荐安装  lit-plugin (https://marketplace.visualstudio.com/items?itemName=runem.lit-plugin) VS Code 插件来更好的预览和改动代码。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;尾声&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道，W3C 仿照 jQuery 的 $ 函数，实现了 &lt;code&gt;querySelector()&lt;/code&gt; 和 &lt;code&gt;querySelectorAll()&lt;/code&gt; 方法并逐渐取代了 jQuery 快速选择 DOM 元素的功能，加速了 jQuery 的没落，带着前端迈向了新的阶段。那么随着 Web Components 的不断发展，它会取代现有的前端框架吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现阶段来看，还并不会，因为 Web Components 与各前端框架之间的关系是“共存”而非互斥，两者可以完美地互补。虽然前端框架 React 和 Vue 中组件化是其中非常重要的功能，但它们还有页面路由，数据绑定，模块化，CSS 预处理器，虚拟 DOM，Diff 算法以及各种庞大的生态等功能。而 Web components 所解决的仅仅是组件化这么一项功能。不论是 React 还是 Vue，从它们的官方文档有关于 Web Components 的说明中，都可以更好帮助我们理解它们与 Web Components 之间的关系。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;UI组件库&lt;/h1&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;shoelace (https://shoelace.style/)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Wired Elements (https://wiredjs.com/)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;UI5 Web Components (https://sap.github.io/ui5-webcomponents/playground/getting-started)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Kor (https://kor-ui.com/introduction/welcome)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;参考资料&lt;/h1&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;WebComponents | MDN (https://developer.mozilla.org/en-US/docs/Web/Web_Components)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;webcomponents/polyfills | Github (https://github.com/webcomponents/polyfills)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LitElement | 官方文档 (https://lit.dev/docs/components/overview/)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>