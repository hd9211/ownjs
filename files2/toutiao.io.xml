<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f29ccfc0fd636fe259d8a3e4a35f3158</guid>
<title>Kafka 知识体系保姆级教程宝典</title>
<link>https://toutiao.io/k/j5iauc2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU4NjgzNzk4MQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/CWCpl8m0oQC18panFv8VgOcQGCz2HKrUBayxrxsYu5OH4OpSvEaqSFkmunggw6JIYWRoavAfypwxjh1pdfUzng/0?wx_fmt=png&quot; data-nickname=&quot;大鱼的数据人生&quot; data-alias=&quot;dayu_data&quot; data-signature=&quot;我是大鱼先生，CDO，跟你分享有关数据的一切！&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本文目录&lt;/strong&gt;：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一、消息队列&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    Apache Pulsar&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    Pulsar 与 Kafka 对比&lt;/span&gt;&lt;br/&gt;&lt;span&gt;二、Kafka基础&lt;/span&gt;&lt;br/&gt;&lt;span&gt;三、Kafka架构及组件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;四、Kafka集群操作&lt;/span&gt;&lt;br/&gt;&lt;span&gt;五、Kafka的JavaAPI操作&lt;/span&gt;&lt;br/&gt;&lt;span&gt;六、Kafka中的数据不丢失机制&lt;/span&gt;&lt;br/&gt;&lt;span&gt;七、Kafka配置文件说明&lt;/span&gt;&lt;br/&gt;&lt;span&gt;八、CAP理论&lt;/span&gt;&lt;br/&gt;&lt;span&gt;九、Kafka中的CAP机制&lt;/span&gt;&lt;br/&gt;&lt;span&gt;十、Kafka监控及运维&lt;/span&gt;&lt;br/&gt;&lt;span&gt;十一、Kafka大厂面试题&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka 涉及的知识点如下图所示，本文将逐一讲解：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100005512&quot; data-ratio=&quot;0.7422680412371134&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zGGzGV7dic4RFlmib8eNeMBrszmibvxTqWwwNvia5h4EVst6jjWOBg8dSxtMEA3ab0Grq0VicicmR8ViaSUw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1164&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本文档参考了关于 Kafka 的官网及其他众多资料整理而成，为了整洁的排版及舒适的阅读，对于模糊不清晰的图片及黑白图片进行重新绘制成了高清彩图&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文超长，在公众号查看可能不太方便，我已将此文制作成&lt;strong&gt;带目录的PDF版&lt;/strong&gt;，&lt;span&gt;获取本文PDF版，请扫下方二维码&lt;/span&gt;&lt;strong&gt;&lt;span&gt;加我微信，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;备注：&lt;/span&gt;&lt;strong&gt;&lt;span&gt;kafka&lt;/span&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/ZubDbBye0zHibH35eBLrUxfBopVT5jlNovE7nEFc3KTWFcfZ1vIrSapuY270lsicYuRB66Nh24XS64D29ia3TTm6Q/0?wx_fmt=jpeg&quot; data-cropx1=&quot;39.03114186851211&quot; data-cropx2=&quot;910.726643598616&quot; data-cropy1=&quot;271.5916955017301&quot; data-cropy2=&quot;1073.356401384083&quot; data-fileid=&quot;100005510&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9196326061997704&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/ZubDbBye0zE6jg8pGqTM8bodQoPTqicfQUcAzbIQl9RmicTcXT7ecVRuEV0ZeicTU9nbpb0ggJhUc15E5Ly7OE5OA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;871&quot;/&gt;&lt;/p&gt;&lt;p&gt;我会将你拉进大数据群，&lt;strong&gt;三万字Kafka吐血宝典&lt;/strong&gt;会统一发到群里！&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;2&quot; data-backw=&quot;578&quot; data-fileid=&quot;100005511&quot; data-ratio=&quot;0.0030211480362537764&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/cZV2hRpuAPia3RFX6Mvw06kePJ7HbmI7b35o17yNJx4WHYPSQj280IElEicRPq2CviaJe8fjL2AeadmIjARqVZWnw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;662&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一、消息队列&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1. 消息队列的介绍&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息（Message）是指在应用之间传送的数据，消息可以非常简单，比如只包含文本字符串，也可以更复杂，可能包含嵌入对象。消息队列（Message Queue）是一种应用间的通信方式，消息发送后可以立即返回，有消息系统来确保信息的可靠专递，消息发布者只管把消息发布到MQ中而不管谁来取，消息使用者只管从MQ中取消息而不管谁发布的，这样发布者和使用者都不用知道对方的存在。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2. 消息队列的应用场景&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息队列在实际应用中包括如下四个场景：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;应用耦合&lt;/strong&gt;：多应用间通过消息队列对同一消息进行处理，避免调用接口失败导致整个过程失败；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;异步处理&lt;/strong&gt;：多应用对消息队列中同一消息进行处理，应用间并发处理消息，相比串行处理，减少处理时间；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;限流削峰&lt;/strong&gt;：广泛应用于秒杀或抢购活动中，避免流量过大导致应用系统挂掉的情况；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;消息驱动的系统&lt;/strong&gt;：系统分为消息队列、消息生产者、消息消费者，生产者负责产生消息，消费者(可能有多个)负责对消息进行处理；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面详细介绍上述四个场景以及消息队列如何在上述四个场景中使用：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;异步处理&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体场景：用户为了使用某个应用，进行注册，系统需要发送注册邮件并验证短信。对这两个操作的处理方式有两种：串行及并行。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;串行方式：新注册信息生成后，先发送注册邮件，再发送验证短信；&lt;img data-fileid=&quot;100005513&quot; data-ratio=&quot;0.10351966873706005&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zGGzGV7dic4RFlmib8eNeMBrssI6j96xINSEibdBKGwoqxExDIxJE9sAKmAqt3FXorx20V5bx7p3epSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;966&quot;/&gt;&lt;/p&gt;&lt;p&gt;在这种方式下，需要最终发送验证短信后再返回给客户端。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;并行处理：新注册信息写入后，由发短信和发邮件并行处理；&lt;img data-fileid=&quot;100005509&quot; data-ratio=&quot;0.27647058823529413&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zGGzGV7dic4RFlmib8eNeMBrsibBcYiaxdqxiahyFJ3rqVJwvFuP3cIiaM1riaiaYGiaw18mZMT4kfibnS76h6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;680&quot;/&gt;&lt;/p&gt;&lt;p&gt;在这种方式下，发短信和发邮件 需处理完成后再返回给客户端。假设以上三个子系统处理的时间均为50ms，且不考虑网络延迟，则总的处理时间：&lt;/p&gt;&lt;p&gt;串行：50+50+50=150ms&lt;br/&gt;并行：50+50 = 100ms&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;若使用消息队列：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100005515&quot; data-ratio=&quot;0.23529411764705882&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zGGzGV7dic4RFlmib8eNeMBrsrjKArW9ibQZIOhH7022G0VXy5K9hOms4tBFnXRGoAy85sibRNdAsicjZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;765&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在写入消息队列后立即返回成功给客户端，则总的响应时间依赖于写入消息队列的时间，而写入消息队列的时间本身是可以很快的，基本可以忽略不计，因此总的处理时间相比串行提高了2倍，相比并行提高了一倍；&lt;/p&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;应用耦合&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体场景：用户使用QQ相册上传一张图片，人脸识别系统会对该图片进行人脸识别，一般的做法是，服务器接收到图片后，图片上传系统立即调用人脸识别系统，调用完成后再返回成功，如下图所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该方法有如下缺点：&lt;img data-fileid=&quot;100005514&quot; data-ratio=&quot;0.18706697459584296&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zGGzGV7dic4RFlmib8eNeMBrsh4EuoNGD2KdwYhyR3WeO7ibNYlXq14HkAVvqy5nnUedMpFzEnHmkib4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;433&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;人脸识别系统被调失败，导致图片上传失败；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;延迟高，需要人脸识别系统处理完成后，再返回给客户端，即使用户并不需要立即知道结果；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;图片上传系统与人脸识别系统之间互相调用，需要做耦合；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;若使用消息队列：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100005517&quot; data-ratio=&quot;0.13153961136023917&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zGGzGV7dic4RFlmib8eNeMBrsdSaibJyZycjIYJ9OlJJmKmCnvSZ2W9QPddWR1l9B3f38t1JG8K79DCQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;669&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端上传图片后，图片上传系统将图片信息如uin、批次写入消息队列，直接返回成功；而人脸识别系统则定时从消息队列中取数据，完成对新增图片的识别。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时图片上传系统并不需要关心人脸识别系统是否对这些图片信息的处理、以及何时对这些图片信息进行处理。事实上，由于用户并不需要立即知道人脸识别结果，人脸识别系统可以选择不同的调度策略，按照闲时、忙时、正常时间，对队列中的图片信息进行处理。&lt;/p&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;限流削峰&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体场景：购物网站开展秒杀活动，一般由于瞬时访问量过大，服务器接收过大，会导致流量暴增，相关系统无法处理请求甚至崩溃。而加入消息队列后，系统可以从消息队列中取数据，相当于消息队列做了一次缓冲。&lt;img data-fileid=&quot;100005516&quot; data-ratio=&quot;0.12398042414355628&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zGGzGV7dic4RFlmib8eNeMBrs4icL29Xlb93zu2wcsEoCibOg0jOjjsLLicptAbAPRbsllKOgsJLaeicH3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;613&quot;/&gt;该方法有如下优点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;请求先入消息队列，而不是由业务处理系统直接处理，做了一次缓冲,极大地减少了业务处理系统的压力；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;队列长度可以做限制，事实上，秒杀时，后入队列的用户无法秒杀到商品，这些请求可以直接被抛弃，返回活动已结束或商品已售完信息；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4.&lt;strong&gt;消息驱动的系统&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体场景：用户新上传了一批照片，人脸识别系统需要对这个用户的所有照片进行聚类，聚类完成后由对账系统重新生成用户的人脸索引(加快查询)。这三个子系统间由消息队列连接起来，前一个阶段的处理结果放入队列中，后一个阶段从队列中获取消息继续处理。&lt;img data-fileid=&quot;100005518&quot; data-ratio=&quot;0.07767857142857143&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zGGzGV7dic4RFlmib8eNeMBrs2uStLAzhMULz9DJ6JaRP2LDY20E1eTUvczHsgOMuotpUqY05TdwkXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1120&quot;/&gt;该方法有如下优点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;避免了直接调用下一个系统导致当前系统失败；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;每个子系统对于消息的处理方式可以更为灵活，可以选择收到消息时就处理，可以选择定时处理，也可以划分时间段按不同处理速度处理；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3. 消息队列的两种模式&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息队列包括两种模式，点对点模式（point to point， queue）和发布/订阅模式（publish/subscribe，topic）&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1) 点对点模式&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点对点模式下包括三个角色：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;消息队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;发送者 (生产者)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;接收者（消费者）&lt;img data-fileid=&quot;100005519&quot; data-ratio=&quot;0.15719063545150502&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zGGzGV7dic4RFlmib8eNeMBrscwAoPJaezrpO6A2lq6Kbd6nPMnwib6Z3Lm82GpRPvIl02po7eH4FNZg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;598&quot;/&gt;消息发送者生产消息发送到queue中，然后消息接收者从queue中取出并且消费消息。消息被消费以后，queue中不再有存储，所以消息接收者不可能消费到已经被消费的消息。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点对点模式特点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;每个消息只有一个接收者（Consumer）(即一旦被消费，消息就不再在消息队列中)；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;发送者和接发收者间没有依赖性，发送者发送消息之后，不管有没有接收者在运行，都不会影响到发送者下次发送消息；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;接收者在成功接收消息之后需向队列应答成功，以便消息队列删除当前接收的消息；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2) 发布/订阅模式&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发布/订阅模式下包括三个角色：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;角色主题（Topic）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;发布者(Publisher)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;订阅者(Subscriber)&lt;img data-fileid=&quot;100005520&quot; data-ratio=&quot;0.30390492359932086&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zGGzGV7dic4RFlmib8eNeMBrspwvOF768B5WQ0l11Xp7DeSDiafe3kx7qk5HsTAaUkhfoibgL7TKE2afQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;589&quot;/&gt;发布者将消息发送到Topic，系统将这些消息传递给多个订阅者。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发布/订阅模式特点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;每个消息可以有多个订阅者；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;发布者和订阅者之间有时间上的依赖性。针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为了消费消息，订阅者需要提前订阅该角色主题，并保持在线运行；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;4. 常用的消息队列介绍&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1) RabbitMQ&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RabbitMQ 2007年发布，是一个在AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2) ActiveMQ&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ActiveMQ是由Apache出品，ActiveMQ 是一个完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现。它非常快速，支持多种语言的客户端和协议，而且可以非常容易的嵌入到企业的应用环境中，并有许多高级功能。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3) RocketMQ&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RocketMQ出自 阿里公司的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一些改进，消息可靠性上比 Kafka 更好。RocketMQ在阿里集团被广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理等。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4) Kafka&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Apache Kafka是一个分布式消息发布订阅系统。它最初由LinkedIn公司基于独特的设计实现为一个分布式的提交日志系统( a distributed commit log)，，之后成为Apache项目的一部分。Kafka系统快速、可扩展并且可持久化。它的分区特性，可复制和可容错都是其不错的特性。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;5. Pulsar&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Apahce Pulasr是一个企业级的发布-订阅消息系统，最初是由雅虎开发，是下一代云原生分布式消息流平台，集消息、存储、轻量化函数式计算为一体，采用计算与存储分离架构设计，支持多租户、持久化存储、多机房跨区域数据复制，具有强一致性、高吞吐、低延时及高可扩展性等流数据存储特性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 非常灵活：它既可以应用于像 Kafka 这样的分布式日志应用场景，也可以应用于像 RabbitMQ 这样的纯消息传递系统场景。它支持多种类型的订阅、多种交付保证、保留策略以及处理模式演变的方法，以及其他诸多特性。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. Pulsar 的特性&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;内置多租户&lt;/strong&gt;：不同的团队可以使用相同的集群并将其隔离，解决了许多管理难题。它支持隔离、身份验证、授权和配额；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;多层体系结构&lt;/strong&gt;：Pulsar 将所有 topic 数据存储在由 Apache BookKeeper 支持的专业数据层中。存储和消息传递的分离解决了扩展、重新平衡和维护集群的许多问题。它还提高了可靠性，几乎不可能丢失数据。另外，在读取数据时可以直连 BookKeeper，且不影响实时摄取。例如，可以使用 Presto 对 topic 执行 SQL 查询，类似于 KSQL，但不会影响实时数据处理；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;虚拟 topic&lt;/strong&gt;：由于采用 n 层体系结构，因此对 topic 的数量没有限制，topic 及其存储是分离的。用户还可以创建非持久性 topic；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;N 层存储&lt;/strong&gt;：Kafka 的一个问题是，存储费用可能变高。因此，它很少用于存储&quot;冷&quot;数据，并且消息经常被删除，Apache Pulsar 可以借助分层存储自动将旧数据卸载到 Amazon S3 或其他数据存储系统，并且仍然向客户端展示透明视图；Pulsar 客户端可以从时间开始节点读取，就像所有消息都存在于日志中一样；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. Pulsar 存储架构&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 的多层架构影响了存储数据的方式。&lt;strong&gt;Pulsar 将 topic 分区划分为分片（segment），然后将这些分片存储在 Apache BookKeeper 的存储节点上，以提高性能、可伸缩性和可用性&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100005522&quot; data-ratio=&quot;0.8537037037037037&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zGGzGV7dic4RFlmib8eNeMBrsmr8Rywib8GEM8luwEfe90f7LR0bEFAfLY28ukq4FibMxvpmjK1Sp18SQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 的无限分布式日志以分片为中心，借助扩展日志存储（通过 Apache BookKeeper）实现，内置分层存储支持，因此分片可以均匀地分布在存储节点上。由于与任一给定 topic 相关的数据都不会与特定存储节点进行捆绑，因此很容易替换存储节点或缩扩容。另外，集群中最小或最慢的节点也不会成为存储或带宽的短板。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 架构能实现&lt;strong&gt;分区管理，负载均衡&lt;/strong&gt;，因此使用 Pulsar 能够快速扩展并达到高可用。这两点至关重要，所以 Pulsar 非常适合用来构建关键任务服务，如金融应用场景的计费平台，电子商务和零售商的交易处理系统，金融机构的实时风险控制系统等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过性能强大的 Netty 架构，数据从 producers 到 broker，再到 bookie 的转移都是零拷贝，不会生成副本。这一特性对所有流应用场景都非常友好，因为数据直接通过网络或磁盘进行传输，没有任何性能损失。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. Pulsar 消息消费&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 的消费模型采用了流拉取的方式。流拉取是长轮询的改进版，不仅实现了单个调用和请求之间的零等待，还可以提供双向消息流。通过流拉取模型，Pulsar 实现了端到端的低延迟，这种低延迟比所有现有的长轮询消息系统（如 Kafka）都低。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;6. Kafka与Pulsar对比&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. Pulsar 的主要优势：&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;更多功能：Pulsar Function、多租户、Schema registry、n 层存储、多种消费模式和持久性模式等；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;更大的灵活性：3 种订阅类型（独占，共享和故障转移），用户可以在一个订阅上管理多个 topic；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;易于操作运维：架构解耦和 n 层存储；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;与 Presto 的 SQL 集成，可直接查询存储而不会影响 broker；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;借助 n 层自动存储选项，可以更低成本地存储；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. Pulsar 的劣势&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 并不完美，Pulsar 也存在一些问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;相对缺乏支持、文档和案例；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;n 层体系结构导致需要更多组件：BookKeeper；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;插件和客户端相对 Kafka 较少;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;云中的支持较少，Confluent 具有托管云产品。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 什么时候应该考虑 Pulsar&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;同时需要像 RabbitMQ 这样的队列和 Kafka 这样的流处理程序；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;需要易用的地理复制；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;实现多租户，并确保每个团队的访问权限；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;需要长时间保留消息，并且不想将其卸载到另一个存储中；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;需要高性能，基准测试表明 Pulsar 提供了更低的延迟和更高的吞吐量；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;总之，Pulsar还比较新，社区不完善，用的企业比较少，网上有价值的讨论和问题的解决比较少，远没有Kafka生态系统庞大，且用户量非常庞大，目前Kafka依旧是大数据领域消息队列的王者！所以我们还是以Kafka为主！&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;7. 其他消息队列与Kafka对比&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100005521&quot; data-ratio=&quot;1.0239596469104666&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zGGzGV7dic4RFlmib8eNeMBrsZY4KVy3MCiboj9sP8yiabEq3sAdm5Rt6y0mqIDEPoeUJ4D7oSo67M9VA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;793&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二、Kafka基础&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1. kafka的基本介绍&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官网：http://kafka.apache.org/&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;kafka是最初由linkedin公司开发的，使用scala语言编写，kafka是一个分布式，分区的，多副本的，多订阅者的日志系统（分布式MQ系统），可以用于搜索日志，监控日志，访问日志等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka is a distributed,partitioned,replicated commit logservice。它提供了类似于JMS的特性，但是在设计实现上完全不同，此外它并不是JMS规范的实现。kafka对消息保存时根据Topic进行归类，发送消息者成为Producer,消息接受者成为Consumer,此外kafka集群有多个kafka实例组成，每个实例(server)成为broker。无论是kafka集群，还是producer和consumer都依赖于zookeeper来保证系统可用性集群保存一些meta信息。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2. kafka的好处&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;可靠性&lt;/strong&gt;：分布式的，分区，复本和容错的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;可扩展性&lt;/strong&gt;：kafka消息传递系统轻松缩放，无需停机。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;耐用性&lt;/strong&gt;：kafka使用分布式提交日志，这意味着消息会尽可能快速的保存在磁盘上，因此它是持久的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;性能&lt;/strong&gt;：kafka对于发布和定于消息都具有高吞吐量。即使存储了许多TB的消息，他也爆出稳定的性能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;kafka非常快&lt;/strong&gt;：保证零停机和零数据丢失。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3. 分布式的发布与订阅系统&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;apache kafka是一个分布式发布-订阅消息系统和一个强大的队列，可以处理大量的数据，并使能够将消息从一个端点传递到另一个端点，kafka适合离线和在线消息消费。kafka消息保留在磁盘上，并在集群内复制以防止数据丢失。kafka构建在zookeeper同步服务之上。它与apache和spark非常好的集成，应用于实时流式数据分析。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;4. kafka的主要应用场景&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 指标分析&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;kafka 通常用于操作监控数据。这设计聚合来自分布式应用程序的统计信息，   以产生操作的数据集中反馈&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 日志聚合解决方法&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;kafka可用于跨组织从多个服务器收集日志，并使他们以标准的格式提供给多个服务器。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 流式处理&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;流式处理框架（spark，storm，ﬂink）重主题中读取数据，对齐进行处理，并将处理后的数据写入新的主题，供 用户和应用程序使用，kafka的强耐久性在流处理的上下文中也非常的有用。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三、Kafka架构及组件&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1. kafka架构&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100005523&quot; data-ratio=&quot;0.8027972027972028&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zGGzGV7dic4RFlmib8eNeMBrsbMLB2TRlk1ybweWxbML5iaMXPRiaw6pnVKzFar4ePBJGFMlMoXRGKE5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;715&quot;/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;生产者API&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;允许应用程序发布记录流至一个或者多个kafka的主题（topics）。&lt;/p&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;消费者API&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;允许应用程序订阅一个或者多个主题，并处理这些主题接收到的记录流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3。&lt;strong&gt;StreamsAPI&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;允许应用程序充当流处理器（stream processor），从一个或者多个主题获取输入流，并生产一个输出流到一个或 者多个主题，能够有效的变化输入流为输出流。&lt;/p&gt;&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;ConnectAPI&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;允许构建和运行可重用的生产者或者消费者，能够把kafka主题连接到现有的应用程序或数据系统。例如：一个连接到关系数据库的连接器可能会获取每个表的变化。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100005527&quot; data-ratio=&quot;0.5698924731182796&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zGGzGV7dic4RFlmib8eNeMBrshV2MOJ1dEUcvh0uXeT49pdXiajfNibKFk92TMmdq8ibSzHUrSvkOkpbLg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;651&quot;/&gt;&lt;figcaption&gt;Kafka 架构&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注：&lt;strong&gt;在Kafka 2.8.0 版本，移除了对Zookeeper的依赖，通过KRaft进行自己的集群管理&lt;/strong&gt;，使用Kafka内部的Quorum控制器来取代ZooKeeper，因此用户第一次可在完全不需要ZooKeeper的情况下执行Kafka，这不只节省运算资源，并且也使得Kafka效能更好，还可支持规模更大的集群。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;过去Apache ZooKeeper是Kafka这类分布式系统的关键，ZooKeeper扮演协调代理的角色，所有代理服务器启动时，都会连接到Zookeeper进行注册，当代理状态发生变化时，Zookeeper也会储存这些数据，在过去，ZooKeeper是一个强大的工具，但是毕竟ZooKeeper是一个独立的软件，使得Kafka整个系统变得复杂，因此官方决定使用内部Quorum控制器来取代ZooKeeper。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这项工作从去年4月开始，而现在这项工作取得部分成果，用户将可以在2.8版本，在没有ZooKeeper的情况下执行Kafka，官方称这项功能为&lt;strong&gt;Kafka Raft元数据模式（KRaft）&lt;/strong&gt;。在KRaft模式，过去由Kafka控制器和ZooKeeper所操作的元数据，将合并到这个新的Quorum控制器，并且在Kafka集群内部执行，当然，如果使用者有特殊使用情境，Quorum控制器也可以在专用的硬件上执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好，说完在新版本中移除zookeeper这个事，咱们在接着聊kafka的其他功能：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;kafka支持消息持久化，消费端是主动拉取数据，消费状态和订阅关系由客户端负责维护，&lt;strong&gt;消息消费完后，不会立即删除，会保留历史消息&lt;/strong&gt;。因此支持多订阅时，消息只会存储一份就可以。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;broker&lt;/strong&gt;：kafka集群中包含一个或者多个服务实例（节点），这种服务实例被称为broker（一个broker就是一个节点/一个服务器）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;topic&lt;/strong&gt;：每条发布到kafka集群的消息都属于某个类别，这个类别就叫做topic；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;partition&lt;/strong&gt;：partition是一个物理上的概念，每个topic包含一个或者多个partition；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;segment&lt;/strong&gt;：一个partition当中存在多个segment文件段，每个segment分为两部分，.log文件和 .index 文件，其中 .index 文件是索引文件，主要用于快速查询， .log 文件当中数据的偏移量位置；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;producer&lt;/strong&gt;：消息的生产者，负责发布消息到 kafka 的 broker 中；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;consumer&lt;/strong&gt;：消息的消费者，向 kafka 的 broker 中读取消息的客户端；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;consumer group&lt;/strong&gt;：消费者组，每一个 consumer 属于一个特定的 consumer group（可以为每个consumer指定 groupName）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;.log&lt;/strong&gt;：存放数据文件；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;.index&lt;/strong&gt;：存放.log文件的索引数据。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2. Kafka 主要组件&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. producer（生产者）&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;producer主要是用于生产消息，是kafka当中的消息生产者，生产的消息通过topic进行归类，保存到kafka的broker里面去。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. topic（主题）&lt;span/&gt;&lt;/h4&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;kafka将消息以topic为单位进行归类；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;topic特指kafka处理的消息源（feeds of messages）的不同分类；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;topic是一种分类或者发布的一些列记录的名义上的名字。kafka主题始终是支持多用户订阅的；也就是说，一 个主题可以有零个，一个或者多个消费者订阅写入的数据；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在kafka集群中，可以有无数的主题；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;生产者和消费者消费数据一般以主题为单位。更细粒度可以到分区级别。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. partition（分区）&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;kafka当中，topic是消息的归类，一个topic可以有多个分区（partition），每个分区保存部分topic的数据，所有的partition当中的数据全部合并起来，就是一个topic当中的所有的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个broker服务下，可以创建多个分区，broker数与分区数没有关系；&lt;br/&gt;在kafka中，每一个分区会有一个编号：编号从0开始。&lt;br/&gt;&lt;strong&gt;每一个分区内的数据是有序的，但全局的数据不能保证是有序的。&lt;/strong&gt;（有序是指生产什么样顺序，消费时也是什么样的顺序）&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. consumer（消费者）&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;consumer是kafka当中的消费者，主要用于消费kafka当中的数据，消费者一定是归属于某个消费组中的。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5. consumer group（消费者组）&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消费者组由一个或者多个消费者组成，&lt;strong&gt;同一个组中的消费者对于同一条消息只消费一次&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个消费者都属于某个消费者组，如果不指定，那么所有的消费者都属于默认的组。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个消费者组都有一个ID，即group ID。组内的所有消费者协调在一起来消费一个订阅主题( topic)的所有分区(partition)。当然，&lt;strong&gt;每个分区只能由同一个消费组内的一个消费者(consumer)来消费&lt;/strong&gt;，可以由不同的&lt;strong&gt;消费组&lt;/strong&gt;来消费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;partition数量决定了每个consumer group中并发消费者的最大数量&lt;/strong&gt;。如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100005526&quot; data-ratio=&quot;0.5381114903299203&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zGGzGV7dic4RFlmib8eNeMBrsicnKGthYXmSDkzcnTbBQ3ickGpic0ibFibL6lnhzcgT46dsEBW9oBIdyicEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;879&quot;/&gt;&lt;figcaption&gt;示例 1&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上面左图所示，如果只有两个分区，即使一个组内的消费者有4个，也会有两个空闲的。&lt;br/&gt;如上面右图所示，有4个分区，每个消费者消费一个分区，并发量达到最大4。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在来看如下一幅图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100005528&quot; data-ratio=&quot;0.4882108183079057&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zGGzGV7dic4RFlmib8eNeMBrsX9VwMMGEpLoy3Md7ibKXc4mdu4LOVotVq8LuicBpu3AuicDaTkD89bfHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;721&quot;/&gt;&lt;figcaption&gt;示例 2&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图所示，不同的消费者组消费同一个topic，这个topic有4个分区，分布在两个节点上。左边的 消费组1有两个消费者，每个消费者就要消费两个分区才能把消息完整的消费完，右边的 消费组2有四个消费者，每个消费者消费一个分区即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;总结下kafka中分区与消费组的关系&lt;/strong&gt;：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消费组：由一个或者多个消费者组成，同一个组中的消费者对于同一条消息只消费一次。&lt;strong&gt;某一个主题下的分区数，对于消费该主题的同一个消费组下的消费者数量，应该小于等于该主题下的分区数&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如：某一个主题有4个分区，那么消费组中的消费者应该小于等于4，而且最好与分区数成整数倍 124 这样。&lt;strong&gt;同一个分区下的数据，在同一时刻，不能同一个消费组的不同消费者消费&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结：&lt;strong&gt;分区数越多，同一时间可以有越多的消费者来进行消费，消费数据的速度就会越快，提高消费的性能&lt;/strong&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6. partition replicas（分区副本）&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;kafka 中的分区副本如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100005525&quot; data-ratio=&quot;0.33852140077821014&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zGGzGV7dic4RFlmib8eNeMBrsjCFgxqspd4mCxFKbuDbHuDavuNhlTGWxftM1PLpQ8wJHO9TUFmHNZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;771&quot;/&gt;&lt;figcaption&gt;kafka 分区副本&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;副本数&lt;/strong&gt;（replication-factor）：控制消息保存在几个broker（服务器）上，一般情况下副本数等于broker的个数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个broker服务下，不可以创建多个副本因子。&lt;strong&gt;创建主题时，副本因子应该小于等于可用的broker数&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;副本因子操作以分区为单位的。每个分区都有各自的主副本和从副本；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主副本叫做leader，从副本叫做 follower（在有多个副本的情况下，kafka会为同一个分区下的所有分区，设定角色关系：一个leader和N个 follower），&lt;strong&gt;处于同步状态的副本叫做in-sync-replicas(ISR)&lt;/strong&gt;;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;follower通过拉的方式从leader同步数据。&lt;strong&gt;消费者和生产者都是从leader读写数据，不与follower交互&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;副本因子的作用：让kafka读取数据和写入数据时的可靠性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;副本因子是包含本身，同一个副本因子不能放在同一个broker中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果某一个分区有三个副本因子，就算其中一个挂掉，那么只会剩下的两个中，选择一个leader，但不会在其他的broker中，另启动一个副本（因为在另一台启动的话，存在数据传递，只要在机器之间有数据传递，就会长时间占用网络IO，kafka是一个高吞吐量的消息系统，这个情况不允许发生）所以不会在另一个broker中启动。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果所有的副本都挂了，生产者如果生产数据到指定分区的话，将写入不成功。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;lsr表示：当前可用的副本。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7. segment文件&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个partition当中由多个segment文件组成，每个segment文件，包含两部分，一个是 .log 文件，另外一个是 .index 文件，其中 .log 文件包含了我们发送的数据存储，.index 文件，记录的是我们.log文件的数据索引值，以便于我们加快数据的查询速度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;索引文件与数据文件的关系&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然它们是一一对应成对出现，必然有关系。索引文件中元数据指向对应数据文件中message的物理偏移地址。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如索引文件中 3,497 代表：数据文件中的第三个message，它的偏移地址为497。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再来看数据文件中，Message 368772表示：在全局partiton中是第368772个message。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注：segment index file 采取稀疏索引存储方式，减少索引文件大小，通过mmap（内存映射）可以直接内存操作，稀疏索引为数据文件的每个对应message设置一个元数据指针，它比稠密索引节省了更多的存储空间，但查找起来需要消耗更多的时间。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;.index 与 .log 对应关系如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100005524&quot; data-ratio=&quot;0.6421845574387948&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zGGzGV7dic4RFlmib8eNeMBrsu7WAQrKsoRSH2R0ZYia3XzN97327yRzfLTw1FtffpS3HuZAKhYcaBLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;531&quot;/&gt;&lt;figcaption&gt;.index 与 .log&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图左半部分是索引文件，里面存储的是一对一对的key-value，其中key是消息在数据文件（对应的log文件）中的编号，比如“1,3,6,8……”，
分别表示在log文件中的第1条消息、第3条消息、第6条消息、第8条消息……&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么为什么在index文件中这些编号不是连续的呢？这是因为index文件中并没有为数据文件中的每条消息都建立索引，而是采用了稀疏存储的方式，每隔一定字节的数据建立一条索引。这样避免了索引文件占用过多的空间，从而可以将索引文件保留在内存中。但缺点是没有建立索引的Message也不能一次定位到其在数据文件的位置，从而需要做一次顺序扫描，但是这次顺序扫描的范围就很小了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;value 代表的是在全局partiton中的第几个消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以索引文件中元数据 3,497 为例，其中3代表在右边log数据文件中从上到下第3个消息，
497表示该消息的物理偏移地址（位置）为497(也表示在全局partiton表示第497个消息-顺序写入特性)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;log日志目录及组成&lt;/strong&gt;kafka在我们指定的log.dir目录下，会创建一些文件夹；名字是 （主题名字-分区名） 所组成的文件夹。在（主题名字-分区名）的目录下，会有两个文件存在，如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;索引文件&lt;/span&gt;&lt;br/&gt;00000000000000000000.index&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;日志内容&lt;/span&gt;&lt;br/&gt;00000000000000000000.log&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在目录下的文件，会根据log日志的大小进行切分，.log文件的大小为1G的时候，就会进行切分文件；如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;-rw-r--r--. 1 root root 389k  1月  17  18:03   00000000000000000000.index&lt;br/&gt;-rw-r--r--. 1 root root 1.0G  1月  17  18:03   00000000000000000000.log&lt;br/&gt;-rw-r--r--. 1 root root  10M  1月  17  18:03   00000000000000077894.index&lt;br/&gt;-rw-r--r--. 1 root root 127M  1月  17  18:03   00000000000000077894.log&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在kafka的设计中，将offset值作为了文件名的一部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;segment文件命名规则&lt;/strong&gt;：partion全局的第一个segment从0开始，后续每个segment文件名为上一个全局 partion的最大offset（偏移message数）。数值最大为64位long大小，20位数字字符长度，没有数字就用 0 填充。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过索引信息可以快速定位到message。通过index元数据全部映射到内存，可以避免segment File的IO磁盘操作；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过索引文件稀疏存储，可以大幅降低index文件元数据占用空间大小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;稀疏索引：为了数据创建索引，但范围并不是为每一条创建，而是为某一个区间创建；好处：就是可以减少索引值的数量。不好的地方：找到索引区间之后，要得进行第二次处理。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8. message的物理结构&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生产者发送到kafka的每条消息，都被kafka包装成了一个message&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;message 的物理结构如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100005529&quot; data-ratio=&quot;0.6385542168674698&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zGGzGV7dic4RFlmib8eNeMBrs21W5YLqzcmylFgu5ROib8uHhvEqRWYycnNGqzgDUaPOfXJZI8lIXhmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;581&quot;/&gt;&lt;figcaption&gt;.index 与 .log&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以生产者发送给kafka的消息并不是直接存储起来，而是经过kafka的包装，每条消息都是上图这个结构，只有最后一个字段才是真正生产者发送的消息数据。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;四、Kafka集群操作&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1. 创建topic&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建一个名字为test的主题， 有三个分区，有两个副本：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;bin/kafka-topics.sh --create --zookeeper node01:2181 --replication-factor 2 --partitions 3 --topic test&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2. 查看主题命令&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看kafka当中存在的主题：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;bin/kafka-topics.sh  --list --zookeeper node01:2181,node02:2181,node03:2181&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3. 生产者生产数据&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;模拟生产者来生产数据:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;bin/kafka-console-producer.sh --broker-list node01:9092,node02:9092,node03:9092 --topic test&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;4. 消费者消费数据&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行以下命令来模拟消费者进行消费数据:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;bin/kafka-console-consumer.sh --from-beginning --topic test  --zookeeper node01:2181,node02:2181,node03:2181&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;5. 运行describe  topics命令&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行以下命令运行describe查看topic的相关信息:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;bin/kafka-topics.sh --describe --zookeeper node01:2181 --topic test&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结果说明：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是输出的解释。第一行给出了所有分区的摘要，每个附加行提供有关一个分区的信息。由于我们只有一个分 区用于此主题，因此只有一行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“leader”是负责给定分区的所有读取和写入的节点。每个节点将成为随机选择的分区部分的领导者。（因为在kafka中 如果有多个副本的话，就会存在leader和follower的关系，表示当前这个副本为leader所在的broker是哪一个）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“replicas”是复制此分区日志的节点列表，无论它们是否为领导者，或者即使它们当前处于活动状态。（所有副本列表0,1,2）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“isr”是“同步”复制品的集合。这是副本列表的子集，该列表当前处于活跃状态并且已经被领导者捕获。（可用的列表数）&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;6. 增加topic分区数&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行以下命令可以增加topic分区数:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;bin/kafka-topics.sh --zookeeper zkhost:port --alter --topic topicName --partitions 8&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;7. 增加配置&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;动态修改kakfa的配置:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;bin/kafka-topics.sh --zookeeper node01:2181 --alter --topic test --config flush.messages=1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;8. 删除配置&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;动态删除kafka集群配置:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;bin/kafka-topics.sh --zookeeper node01:2181 --alter --topic test --delete-config flush.messages&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;9.  删除topic&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前删除topic在默认情况下知识打上一个删除的标记，在重新启动kafka后才删除。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果需要立即删除，则需要在
server.properties中配置：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;delete.topic.enable=true&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后执行以下命令进行删除topic:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;kafka-topics.sh --zookeeper zkhost:port --delete --topic topicName&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;五、Kafka的JavaAPI操作&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1. 生产者代码&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;使用生产者，生产数据&lt;/strong&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt;* 订单的生产者代码，&lt;br/&gt;*/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;OrderProducer&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;/* 1、连接集群，通过配置文件的方式&lt;br/&gt;* 2、发送数据-topic:order，value&lt;br/&gt;*/&lt;/span&gt;&lt;br/&gt;Properties props = &lt;span&gt;new&lt;/span&gt; Properties(); props.put(&lt;span&gt;&quot;bootstrap.servers&quot;&lt;/span&gt;, &lt;span&gt;&quot;node01:9092&quot;&lt;/span&gt;); props.put(&lt;span&gt;&quot;acks&quot;&lt;/span&gt;, &lt;span&gt;&quot;all&quot;&lt;/span&gt;);&lt;br/&gt;props.put(&lt;span&gt;&quot;retries&quot;&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;props.put(&lt;span&gt;&quot;batch.size&quot;&lt;/span&gt;, &lt;span&gt;16384&lt;/span&gt;);&lt;br/&gt;props.put(&lt;span&gt;&quot;linger.ms&quot;&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;props.put(&lt;span&gt;&quot;buffer.memory&quot;&lt;/span&gt;, &lt;span&gt;33554432&lt;/span&gt;); &lt;br/&gt;props.put(&lt;span&gt;&quot;key.serializer&quot;&lt;/span&gt;,&lt;br/&gt;&lt;span&gt;&quot;org.apache.kafka.common.serialization.StringSerializer&quot;&lt;/span&gt;); &lt;br/&gt;props.put(&lt;span&gt;&quot;value.serializer&quot;&lt;/span&gt;,&lt;br/&gt;&lt;span&gt;&quot;org.apache.kafka.common.serialization.StringSerializer&quot;&lt;/span&gt;);&lt;br/&gt; KafkaProducer&amp;lt;String, String&amp;gt; kafkaProducer = &lt;span&gt;new&lt;/span&gt; KafkaProducer&amp;lt;String, String&amp;gt;&lt;br/&gt;(props);&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;1000&lt;/span&gt;; i++) {&lt;br/&gt;&lt;span&gt;// 发送数据 ,需要一个producerRecord对象,最少参数 String topic, V value kafkaProducer.send(new ProducerRecord&amp;lt;String, String&amp;gt;(&quot;order&quot;, &quot;订单信&lt;/span&gt;&lt;br/&gt;息！&lt;span&gt;&quot;+i));&lt;br/&gt;Thread.sleep(100);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;kafka当中的数据分区&lt;/strong&gt;:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;kafka生产者发送的消息，都是保存在broker当中，我们可以自定义分区规则，决定消息发送到哪个partition里面去进行保存
查看ProducerRecord这个类的源码，就可以看到kafka的各种不同分区策略&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;kafka当中支持以下四种数据的分区方式：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//第一种分区策略，如果既没有指定分区号，也没有指定数据key，那么就会使用轮询的方式将数据均匀的发送到不同的分区里面去&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//ProducerRecord&amp;lt;String, String&amp;gt; producerRecord1 = new ProducerRecord&amp;lt;&amp;gt;(&quot;mypartition&quot;, &quot;mymessage&quot; + i);&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//kafkaProducer.send(producerRecord1);&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//第二种分区策略 如果没有指定分区号，指定了数据key，通过key.hashCode  % numPartitions来计算数据究竟会保存在哪一个分区里面&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//注意：如果数据key，没有变化   key.hashCode % numPartitions  =  固定值  所有的数据都会写入到某一个分区里面去&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//ProducerRecord&amp;lt;String, String&amp;gt; producerRecord2 = new ProducerRecord&amp;lt;&amp;gt;(&quot;mypartition&quot;, &quot;mykey&quot;, &quot;mymessage&quot; + i);&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//kafkaProducer.send(producerRecord2);&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//第三种分区策略：如果指定了分区号，那么就会将数据直接写入到对应的分区里面去&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//  ProducerRecord&amp;lt;String, String&amp;gt; producerRecord3 = new ProducerRecord&amp;lt;&amp;gt;(&quot;mypartition&quot;, 0, &quot;mykey&quot;, &quot;mymessage&quot; + i);&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// kafkaProducer.send(producerRecord3);&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//第四种分区策略：自定义分区策略。如果不自定义分区规则，那么会将数据使用轮询的方式均匀的发送到各个分区里面去&lt;/span&gt;&lt;br/&gt;  kafkaProducer.send(&lt;span&gt;new&lt;/span&gt; ProducerRecord&amp;lt;String, String&amp;gt;(&lt;span&gt;&quot;mypartition&quot;&lt;/span&gt;,&lt;span&gt;&quot;mymessage&quot;&lt;/span&gt;+i));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;自定义分区策略&lt;/strong&gt;:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;KafkaCustomPartitioner&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Partitioner&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;configure&lt;/span&gt;&lt;span&gt;(Map&amp;lt;String, ?&amp;gt; configs)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;partition&lt;/span&gt;&lt;span&gt;(String topic, Object arg1, &lt;span&gt;byte&lt;/span&gt;[] keyBytes, Object arg3, &lt;span&gt;byte&lt;/span&gt;[] arg4, Cluster cluster)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  List&amp;lt;PartitionInfo&amp;gt; partitions = cluster.partitionsForTopic(topic);&lt;br/&gt;     &lt;span&gt;int&lt;/span&gt; partitionNum = partitions.size();&lt;br/&gt;  Random random = &lt;span&gt;new&lt;/span&gt; Random();&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; partition = random.nextInt(partitionNum);&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; partition;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;close&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;br/&gt; }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;主代码中添加配置&lt;/strong&gt;:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;kafkaProducer&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;//1、准备配置文件&lt;/span&gt;&lt;br/&gt;     Properties props = &lt;span&gt;new&lt;/span&gt; Properties();&lt;br/&gt;     props.put(&lt;span&gt;&quot;bootstrap.servers&quot;&lt;/span&gt;, &lt;span&gt;&quot;node01:9092,node02:9092,node03:9092&quot;&lt;/span&gt;);&lt;br/&gt;     props.put(&lt;span&gt;&quot;acks&quot;&lt;/span&gt;, &lt;span&gt;&quot;all&quot;&lt;/span&gt;);&lt;br/&gt;     props.put(&lt;span&gt;&quot;retries&quot;&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;     props.put(&lt;span&gt;&quot;batch.size&quot;&lt;/span&gt;, &lt;span&gt;16384&lt;/span&gt;);&lt;br/&gt;     props.put(&lt;span&gt;&quot;linger.ms&quot;&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;     props.put(&lt;span&gt;&quot;buffer.memory&quot;&lt;/span&gt;, &lt;span&gt;33554432&lt;/span&gt;);&lt;br/&gt;     props.put(&lt;span&gt;&quot;partitioner.class&quot;&lt;/span&gt;, &lt;span&gt;&quot;cn.itcast.kafka.partitioner.KafkaCustomPartitioner&quot;&lt;/span&gt;);&lt;br/&gt;     props.put(&lt;span&gt;&quot;key.serializer&quot;&lt;/span&gt;, &lt;span&gt;&quot;org.apache.kafka.common.serialization.StringSerializer&quot;&lt;/span&gt;);&lt;br/&gt;     props.put(&lt;span&gt;&quot;value.serializer&quot;&lt;/span&gt;, &lt;span&gt;&quot;org.apache.kafka.common.serialization.StringSerializer&quot;&lt;/span&gt;);&lt;br/&gt;     &lt;span&gt;//2、创建KafkaProducer&lt;/span&gt;&lt;br/&gt;     KafkaProducer&amp;lt;String, String&amp;gt; kafkaProducer = &lt;span&gt;new&lt;/span&gt; KafkaProducer&amp;lt;String, String&amp;gt;(props);&lt;br/&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;100&lt;/span&gt;;i++){&lt;br/&gt;         &lt;span&gt;//3、发送数据&lt;/span&gt;&lt;br/&gt;         kafkaProducer.send(&lt;span&gt;new&lt;/span&gt; ProducerRecord&amp;lt;String, String&amp;gt;(&lt;span&gt;&quot;testpart&quot;&lt;/span&gt;,&lt;span&gt;&quot;0&quot;&lt;/span&gt;,&lt;span&gt;&quot;value&quot;&lt;/span&gt;+i));&lt;br/&gt;     }&lt;br/&gt;&lt;br/&gt;  kafkaProducer.close();&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2. 消费者代码&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;消费必要条件&lt;/strong&gt;:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消费者要从kafka  Cluster进行消费数据，必要条件有以下四个:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;地址：&lt;code&gt;bootstrap.servers=node01:9092&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;序列化：&lt;code&gt;key.serializer=org.apache.kafka.common.serialization.StringSerializer value.serializer=org.apache.kafka.common.serialization.StringSerializer&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;主题（topic）：需要制定具体的某个topic（order）即可。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;消费者组：&lt;code&gt;group.id=test&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1) 自动提交offset&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消费完成之后，自动提交offset：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt;* 消费订单数据--- javaben.tojson&lt;br/&gt;*/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;OrderConsumer&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;// 1\连接集群&lt;/span&gt;&lt;br/&gt;Properties props = &lt;span&gt;new&lt;/span&gt; Properties(); props.put(&lt;span&gt;&quot;bootstrap.servers&quot;&lt;/span&gt;, &lt;span&gt;&quot;hadoop-01:9092&quot;&lt;/span&gt;); props.put(&lt;span&gt;&quot;group.id&quot;&lt;/span&gt;, &lt;span&gt;&quot;test&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//以下两行代码 ---消费者自动提交offset值 &lt;/span&gt;&lt;br/&gt;props.put(&lt;span&gt;&quot;enable.auto.commit&quot;&lt;/span&gt;, &lt;span&gt;&quot;true&quot;&lt;/span&gt;); &lt;br/&gt;props.put(&lt;span&gt;&quot;auto.commit.interval.ms&quot;&lt;/span&gt;,  &lt;span&gt;&quot;1000&quot;&lt;/span&gt;);&lt;br/&gt;props.put(&lt;span&gt;&quot;key.deserializer&quot;&lt;/span&gt;, &lt;span&gt;&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;&lt;/span&gt;);&lt;br/&gt;props.put(&lt;span&gt;&quot;value.deserializer&quot;&lt;/span&gt;, &lt;span&gt;&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;&lt;/span&gt;);&lt;br/&gt;KafkaConsumer&amp;lt;String, String&amp;gt; kafkaConsumer = &lt;span&gt;new&lt;/span&gt; KafkaConsumer&amp;lt;String, String&amp;gt;&lt;br/&gt;(props);&lt;br/&gt;&lt;span&gt;//   2、发送数据 发送数据需要，订阅下要消费的topic。order kafkaConsumer.subscribe(Arrays.asList(&quot;order&quot;)); &lt;/span&gt;&lt;br/&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;ConsumerRecords&amp;lt;String, String&amp;gt; consumerRecords = kafkaConsumer.poll(&lt;span&gt;100&lt;/span&gt;);&lt;span&gt;// jdk queue offer插入、poll获取元素。blockingqueue put插入原生， take获取元素&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (ConsumerRecord&amp;lt;String, String&amp;gt; record : consumerRecords) { System.out.println(&lt;span&gt;&quot;消费的数据为：&quot;&lt;/span&gt; + record.value());&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2) 手动提交offset&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果Consumer在获取数据后，需要加入处理，数据完毕后才确认offset，需要程序来控制offset的确认。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关闭自动提交确认选项：&lt;code&gt;props.put(&quot;enable.auto.commit&quot;, &quot;false&quot;);&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;手动提交offset值：&lt;code&gt;kafkaConsumer.commitSync();&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完整代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Properties props = &lt;span&gt;new&lt;/span&gt; Properties(); &lt;br/&gt;props.put(&lt;span&gt;&quot;bootstrap.servers&quot;&lt;/span&gt;, &lt;span&gt;&quot;localhost:9092&quot;&lt;/span&gt;); &lt;br/&gt;props.put(&lt;span&gt;&quot;group.id&quot;&lt;/span&gt;, &lt;span&gt;&quot;test&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;//关闭自动提交确认选项&lt;/span&gt;&lt;br/&gt;props.put(&lt;span&gt;&quot;enable.auto.commit&quot;&lt;/span&gt;, &lt;span&gt;&quot;false&quot;&lt;/span&gt;); &lt;br/&gt;props.put(&lt;span&gt;&quot;key.deserializer&quot;&lt;/span&gt;,&lt;br/&gt;&lt;span&gt;&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;&lt;/span&gt;); &lt;br/&gt;props.put(&lt;span&gt;&quot;value.deserializer&quot;&lt;/span&gt;,&lt;br/&gt;&lt;span&gt;&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;&lt;/span&gt;); &lt;br/&gt;KafkaConsumer&amp;lt;String, String&amp;gt; consumer = &lt;span&gt;new&lt;/span&gt; KafkaConsumer&amp;lt;&amp;gt;(props); consumer.subscribe(Arrays.asList(&lt;span&gt;&quot;test&quot;&lt;/span&gt;));&lt;br/&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; minBatchSize = &lt;span&gt;200&lt;/span&gt;;&lt;br/&gt;List&amp;lt;ConsumerRecord&amp;lt;String, String&amp;gt;&amp;gt; buffer = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(); &lt;br/&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;ConsumerRecords&amp;lt;String, String&amp;gt; records = consumer.poll(&lt;span&gt;100&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (ConsumerRecord&amp;lt;String, String&amp;gt; record : records) {&lt;br/&gt;buffer.add(record);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (buffer.size() &amp;gt;= minBatchSize) { &lt;br/&gt;insertIntoDb(buffer);&lt;br/&gt;&lt;span&gt;// 手动提交offset值&lt;/span&gt;&lt;br/&gt;consumer.commitSync(); &lt;br/&gt;buffer.clear();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3) 消费完每个分区之后手动提交offset&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的示例使用commitSync将所有已接收的记录标记为已提交。在某些情况下，可能希望通过明确指定偏移量来更好地控制已提交的记录。在下面的示例中，我们在完成处理每个分区中的记录后提交偏移量:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;while&lt;/span&gt;(running) {&lt;br/&gt;ConsumerRecords&amp;lt;String, String&amp;gt; records = consumer.poll(Long.MAX_VALUE); &lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (TopicPartition partition : records.partitions()) {&lt;br/&gt;List&amp;lt;ConsumerRecord&amp;lt;String, String&amp;gt;&amp;gt; partitionRecords = records.records(partition);&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (ConsumerRecord&amp;lt;String, String&amp;gt; record : partitionRecords) { System.out.println(record.offset() + &lt;span&gt;&quot;: &quot;&lt;/span&gt; + record.value());&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;long&lt;/span&gt; lastOffset = partitionRecords.get(partitionRecords.size() -&lt;span&gt;1&lt;/span&gt;).offset();&lt;br/&gt;consumer.commitSync(Collections.singletonMap(partition, &lt;span&gt;new&lt;/span&gt; OffsetAndMetadata(lastOffset + &lt;span&gt;1&lt;/span&gt;)));&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;} &lt;span&gt;finally&lt;/span&gt; { consumer.close();}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意事项&lt;/strong&gt;：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提交的偏移量应始终是应用程序将读取的下一条消息的偏移量。因此，在调用commitSync（偏移量）时，应该在最后处理的消息的偏移量中添加一个。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4) 指定分区数据进行消费&lt;span/&gt;&lt;/h4&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果进程正在维护与该分区关联的某种本地状态（如本地磁盘上的键值存储），那么它应该只获取它在磁盘上维护的分区的记录。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果进程本身具有高可用性，并且如果失败则将重新启动（可能使用YARN，Mesos或AWS工具等集群管理框 架，或作为流处理框架的一部分）。在这种情况下，Kafka不需要检测故障并重新分配分区，因为消耗过程将在另一台机器上重新启动。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Properties props = &lt;span&gt;new&lt;/span&gt; Properties(); props.put(&lt;span&gt;&quot;bootstrap.servers&quot;&lt;/span&gt;, &lt;span&gt;&quot;localhost:9092&quot;&lt;/span&gt;); props.put(&lt;span&gt;&quot;group.id&quot;&lt;/span&gt;, &lt;span&gt;&quot;test&quot;&lt;/span&gt;); &lt;br/&gt;props.put(&lt;span&gt;&quot;enable.auto.commit&quot;&lt;/span&gt;, &lt;span&gt;&quot;true&quot;&lt;/span&gt;);&lt;br/&gt; props.put(&lt;span&gt;&quot;auto.commit.interval.ms&quot;&lt;/span&gt;, &lt;span&gt;&quot;1000&quot;&lt;/span&gt;); &lt;br/&gt;props.put(&lt;span&gt;&quot;key.deserializer&quot;&lt;/span&gt;,&lt;br/&gt;&lt;span&gt;&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;&lt;/span&gt;); &lt;br/&gt;props.put(&lt;span&gt;&quot;value.deserializer&quot;&lt;/span&gt;,&lt;br/&gt;&lt;span&gt;&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;&lt;/span&gt;); &lt;br/&gt;KafkaConsumer&amp;lt;String, String&amp;gt; consumer = &lt;span&gt;new&lt;/span&gt; KafkaConsumer&amp;lt;&amp;gt;(props);&lt;br/&gt;&lt;span&gt;//consumer.subscribe(Arrays.asList(&quot;foo&quot;,  &quot;bar&quot;));&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//手动指定消费指定分区的数据---start &lt;/span&gt;&lt;br/&gt;String topic = &lt;span&gt;&quot;foo&quot;&lt;/span&gt;;&lt;br/&gt;TopicPartition partition0 = &lt;span&gt;new&lt;/span&gt; TopicPartition(topic, &lt;span&gt;0&lt;/span&gt;); &lt;br/&gt;TopicPartition partition1 = &lt;span&gt;new&lt;/span&gt; TopicPartition(topic, &lt;span&gt;1&lt;/span&gt;); consumer.assign(Arrays.asList(partition0,  partition1));&lt;br/&gt;&lt;span&gt;//手动指定消费指定分区的数据---end&lt;/span&gt;&lt;br/&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;ConsumerRecords&amp;lt;String, String&amp;gt; records = consumer.poll(&lt;span&gt;100&lt;/span&gt;); &lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (ConsumerRecord&amp;lt;String, String&amp;gt; record : records)&lt;br/&gt;System.out.printf(&lt;span&gt;&quot;offset = %d, key = %s, value = %s%n&quot;&lt;/span&gt;, record.offset(), record.key(), record.value());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意事项&lt;/strong&gt;：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;要使用此模式，只需使用要使用的分区的完整列表调用assign（Collection），而不是使用subscribe订阅主题。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;主题与分区订阅只能二选一。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5) 重复消费与数据丢失&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说明：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;已经消费的数据对于kafka来说，会将消费组里面的oﬀset值进行修改，那什么时候进行修改了？是在数据消费 完成之后，比如在控制台打印完后自动提交；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;提交过程：是通过kafka将oﬀset进行移动到下个message所处的oﬀset的位置。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;拿到数据后，存储到hbase中或者mysql中，如果hbase或者mysql在这个时候连接不上，就会抛出异常，如果在处理数据的时候已经进行了提交，那么kafka伤的oﬀset值已经进行了修改了，但是hbase或者mysql中没有数据，这个时候就会出现数据丢失。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4.什么时候提交oﬀset值？在Consumer将数据处理完成之后，再来进行oﬀset的修改提交。默认情况下oﬀset是 自动提交，需要修改为手动提交oﬀset值。&lt;/p&gt;&lt;ol start=&quot;5&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果在处理代码中正常处理了，但是在提交oﬀset请求的时候，没有连接到kafka或者出现了故障，那么该次修 改oﬀset的请求是失败的，那么下次在进行读取同一个分区中的数据时，会从已经处理掉的oﬀset值再进行处理一 次，那么在hbase中或者mysql中就会产生两条一样的数据，也就是数据重复。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6) consumer消费者消费数据流程&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;流程描述&lt;/strong&gt;：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Consumer连接指定的Topic partition所在leader broker，采用pull方式从kafkalogs中获取消息。对于不同的消费模式，会将offset保存在不同的地方
官网关于high level  API  以及low  level  API的简介：http://kafka.apache.org/0100/documentation.html#impl_consumer&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;高阶API（High Level API）&lt;/strong&gt;：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;kafka消费者高阶API简单；隐藏Consumer与Broker细节；相关信息保存在zookeeper中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/* create a connection to the cluster */&lt;/span&gt;&lt;br/&gt;ConsumerConnector connector = Consumer.create(consumerConfig);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;ConsumerConnector&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt;This method is used to get a list of KafkaStreams, which are iterators over&lt;br/&gt;MessageAndMetadata objects from which you can obtain messages and their&lt;br/&gt;associated metadata (currently only topic).&lt;br/&gt;Input: a map of &amp;lt;topic, #streams&amp;gt;&lt;br/&gt;Output: a map of &amp;lt;topic, list of message streams&amp;gt;&lt;br/&gt;*/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; Map&amp;lt;String,List&amp;lt;KafkaStream&amp;gt;&amp;gt; createMessageStreams(Map&amp;lt;String,Int&amp;gt; topicCountMap);&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt;You can also obtain a list of KafkaStreams, that iterate over messages&lt;br/&gt;from topics that match a TopicFilter. (A TopicFilter encapsulates a&lt;br/&gt;whitelist or a blacklist which is a standard Java regex.)&lt;br/&gt;*/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;KafkaStream&amp;gt; &lt;span&gt;createMessageStreamsByFilter&lt;/span&gt;&lt;span&gt;( TopicFilter topicFilter, &lt;span&gt;int&lt;/span&gt; numStreams)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;/* Commit the offsets of all messages consumed so far. */&lt;/span&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;commitOffsets&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/* Shut down the connector */&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;shutdown&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;说明&lt;/strong&gt;：大部分的操作都已经封装好了，比如：当前消费到哪个位置下了，但是不够灵活（工作过程推荐使用）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;低级API(Low Level API)&lt;/strong&gt;:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;kafka消费者低级API非常灵活；需要自己负责维护连接Controller Broker。保存offset，Consumer Partition对应关系：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SimpleConsumer&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/* Send fetch request to a broker and get back a set of messages. */&lt;/span&gt; &lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; ByteBufferMessageSet &lt;span&gt;fetch&lt;/span&gt;&lt;span&gt;(FetchRequest request)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/* Send a list of fetch requests to a broker and get back a response set. */&lt;/span&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; MultiFetchResponse &lt;span&gt;multifetch&lt;/span&gt;&lt;span&gt;(List&amp;lt;FetchRequest&amp;gt; fetches)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt;&lt;br/&gt;Get a list of valid offsets (up to maxSize) before the given time.&lt;br/&gt;The result is a list of offsets, in descending order.&lt;br/&gt;&lt;span&gt;@param&lt;/span&gt; time: time in millisecs,&lt;br/&gt;if set to OffsetRequest$.MODULE$.LATEST_TIME(), get from the latest&lt;br/&gt;offset available. if set to OffsetRequest$.MODULE$.EARLIEST_TIME(), get from the earliest&lt;br/&gt;&lt;br/&gt;available. public long[] getOffsetsBefore(String topic, int partition, long time, int maxNumOffsets);&lt;br/&gt;&lt;br/&gt;* offset&lt;br/&gt;*/&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;说明&lt;/strong&gt;：没有进行包装，所有的操作有用户决定，如自己的保存某一个分区下的记录，你当前消费到哪个位置。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3. kafka Streams API开发&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;需求&lt;/strong&gt;：使用StreamAPI获取test这个topic当中的数据，然后将数据全部转为大写，写入到test2这个topic当中去。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第一步&lt;/strong&gt;：创建一个topic&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;node01服务器使用以下命令来常见一个 topic 名称为test2：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;bin/kafka-topics.sh --create  --partitions 3 --replication-factor 2 --topic test2 --zookeeper node01:2181,node02:2181,node03:2181&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第二步&lt;/strong&gt;：开发StreamAPI&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;StreamAPI&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Properties props = &lt;span&gt;new&lt;/span&gt; Properties();&lt;br/&gt;        props.put(StreamsConfig.APPLICATION_ID_CONFIG, &lt;span&gt;&quot;wordcount-application&quot;&lt;/span&gt;);&lt;br/&gt;        props.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, &lt;span&gt;&quot;node01:9092&quot;&lt;/span&gt;);&lt;br/&gt;        props.put(StreamsConfig.KEY_SERDE_CLASS_CONFIG, Serdes.String().getClass());&lt;br/&gt;        props.put(StreamsConfig.VALUE_SERDE_CLASS_CONFIG, Serdes.String().getClass());&lt;br/&gt;        KStreamBuilder builder = &lt;span&gt;new&lt;/span&gt; KStreamBuilder();&lt;br/&gt;        builder.stream(&lt;span&gt;&quot;test&quot;&lt;/span&gt;).mapValues(line -&amp;gt; line.toString().toUpperCase()).to(&lt;span&gt;&quot;test2&quot;&lt;/span&gt;);&lt;br/&gt;        KafkaStreams streams = &lt;span&gt;new&lt;/span&gt; KafkaStreams(builder, props);&lt;br/&gt;        streams.start();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行上述代码，监听获取 &lt;strong&gt;test&lt;/strong&gt; 中的数据，然后转成大写，将结果写入 &lt;strong&gt;test2&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第三步&lt;/strong&gt;：生产数据&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;node01执行以下命令，向test这个topic当中生产数据:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;bin/kafka-console-producer.sh --broker-list node01:9092,node02:9092,node03:9092 --topic test&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第四步&lt;/strong&gt;：消费数据&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;node02执行一下命令消费test2这个topic当中的数据:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;bin/kafka-console-consumer.sh --from-beginning  --topic test2 --zookeeper node01:2181,node02:2181,node03:2181&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;六、Kafka中的数据不丢失机制&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1. 生产者生产数据不丢失&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;发送消息方式&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生产者发送给kafka数据，可以采用&lt;strong&gt;同步方式&lt;/strong&gt;或&lt;strong&gt;异步方式&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;同步方式&lt;/strong&gt;：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发送一批数据给kafka后，等待kafka返回结果：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;生产者等待10s，如果broker没有给出ack响应，就认为失败。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;生产者重试3次，如果还没有响应，就报错.&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;异步方式&lt;/strong&gt;：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发送一批数据给kafka，只是提供一个回调函数：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;先将数据保存在生产者端的buffer中。buffer大小是2万条 。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;满足数据阈值或者数量阈值其中的一个条件就可以发送数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;发送一批数据的大小是500条。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注：如果broker迟迟不给ack，而buffer又满了，开发者可以设置是否直接清空buffer中的数据。&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ack机制（确认机制）&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生产者数据发送出去，需要服务端返回一个确认码，即ack响应码；ack的响应有三个状态值0,1，-1&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;0：生产者只负责发送数据，不关心数据是否丢失，丢失的数据，需要再次发送&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1：partition的leader收到数据，不管follow是否同步完数据，响应的状态码为1&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;-1：所有的从节点都收到数据，响应的状态码为-1&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如果broker端一直不返回ack状态，producer永远不知道是否成功；producer可以设置一个超时时间10s，超过时间认为失败。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2. broker中数据不丢失&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在broker中，保证数据不丢失主要是通过副本因子（冗余），防止数据丢失。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3. 消费者消费数据不丢失&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在消费者消费数据的时候，只要每个消费者记录好offset值即可，就能保证数据不丢失。也就是需要我们自己维护偏移量(offset)，可保存在 Redis 中。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;文章首发于公众号：五分钟学大数据，深度钻研大数据技术&lt;span/&gt;&lt;/h4&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;七、Kafka配置文件说明&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Server.properties配置文件说明&lt;/strong&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;broker的全局唯一编号，不能重复&lt;/span&gt;&lt;br/&gt;broker.id=0&lt;br/&gt;&lt;span&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span&gt;用来监听链接的端口，producer或consumer将在此端口建立连接&lt;/span&gt;&lt;br/&gt;port=9092&lt;br/&gt;&lt;span&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span&gt;处理网络请求的线程数量&lt;/span&gt;&lt;br/&gt;num.network.threads=3&lt;br/&gt;&lt;span&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span&gt;用来处理磁盘IO的线程数量&lt;/span&gt;&lt;br/&gt;num.io.threads=8&lt;br/&gt;&lt;span&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span&gt;发送套接字的缓冲区大小&lt;/span&gt;&lt;br/&gt;socket.send.buffer.bytes=102400&lt;br/&gt;&lt;span&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span&gt;接受套接字的缓冲区大小&lt;/span&gt;&lt;br/&gt;socket.receive.buffer.bytes=102400&lt;br/&gt;&lt;span&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span&gt;请求套接字的缓冲区大小&lt;/span&gt;&lt;br/&gt;socket.request.max.bytes=104857600&lt;br/&gt;&lt;span&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span&gt;kafka运行日志存放的路径&lt;/span&gt;&lt;br/&gt;log.dirs=/export/data/kafka/&lt;br/&gt;&lt;span&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span&gt;topic在当前broker上的分片个数&lt;/span&gt;&lt;br/&gt;num.partitions=2&lt;br/&gt;&lt;span&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span&gt;用来恢复和清理data下数据的线程数量&lt;/span&gt;&lt;br/&gt;num.recovery.threads.per.data.dir=1&lt;br/&gt;&lt;span&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span&gt;segment文件保留的最长时间，超时将被删除&lt;/span&gt;&lt;br/&gt;log.retention.hours=168&lt;br/&gt;&lt;span&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span&gt;滚动生成新的segment文件的最大时间&lt;/span&gt;&lt;br/&gt;log.roll.hours=1&lt;br/&gt;&lt;span&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span&gt;日志文件中每个segment的大小，默认为1G&lt;/span&gt;&lt;br/&gt;log.segment.bytes=1073741824&lt;br/&gt;&lt;span&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span&gt;周期性检查文件大小的时间&lt;/span&gt;&lt;br/&gt;log.retention.check.interval.ms=300000&lt;br/&gt;&lt;span&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span&gt;日志清理是否打开&lt;/span&gt;&lt;br/&gt;log.cleaner.enable=true&lt;br/&gt;&lt;span&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span&gt;broker需要使用zookeeper保存meta数据&lt;/span&gt;&lt;br/&gt;zookeeper.connect=zk01:2181,zk02:2181,zk03:2181&lt;br/&gt;&lt;span&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span&gt;zookeeper链接超时时间&lt;/span&gt;&lt;br/&gt;zookeeper.connection.timeout.ms=6000&lt;br/&gt;&lt;span&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span&gt;partion buffer中，消息的条数达到阈值，将触发flush到磁盘&lt;/span&gt;&lt;br/&gt;log.flush.interval.messages=10000&lt;br/&gt;&lt;span&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span&gt;消息buffer的时间，达到阈值，将触发flush到磁盘&lt;/span&gt;&lt;br/&gt;log.flush.interval.ms=3000&lt;br/&gt;&lt;span&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span&gt;删除topic需要server.properties中设置delete.topic.enable=&lt;span&gt;true&lt;/span&gt;否则只是标记删除&lt;/span&gt;&lt;br/&gt;delete.topic.enable=true&lt;br/&gt;&lt;span&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span&gt;此处的host.name为本机IP(重要),如果不改,则客户端会抛出:Producer connection to localhost:9092 unsuccessful 错误!&lt;/span&gt;&lt;br/&gt;host.name=kafka01&lt;br/&gt;&lt;br/&gt;advertised.host.name=192.168.140.128&lt;br/&gt;&lt;br/&gt;producer生产者配置文件说明&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;指定kafka节点列表，用于获取metadata，不必全部指定&lt;/span&gt;&lt;br/&gt;metadata.broker.list=node01:9092,node02:9092,node03:9092&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 指定分区处理类。默认kafka.producer.DefaultPartitioner，表通过key哈希到对应分区&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;partitioner.class=kafka.producer.DefaultPartitioner&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 是否压缩，默认0表示不压缩，1表示用gzip压缩，2表示用snappy压缩。压缩后消息中会有头来指明消息压缩类型，故在消费者端消息解压是透明的无需指定。&lt;/span&gt;&lt;br/&gt;compression.codec=none&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 指定序列化处理类&lt;/span&gt;&lt;br/&gt;serializer.class=kafka.serializer.DefaultEncoder&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果要压缩消息，这里指定哪些topic要压缩消息，默认empty，表示不压缩。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;compressed.topics=&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span&gt; 设置发送数据是否需要服务端的反馈,有三个值0,1,-1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 0: producer不会等待broker发送ack &lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1: 当leader接收到消息之后发送ack &lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -1: 当所有的follower都同步消息成功后发送ack. &lt;/span&gt;&lt;br/&gt;request.required.acks=0 &lt;br/&gt;&lt;span&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span&gt; 在向producer发送ack之前,broker允许等待的最大时间 ，如果超时,broker将会向producer发送一个error ACK.意味着上一次消息因为某种原因未能成功(比如follower未能同步成功) &lt;/span&gt;&lt;br/&gt;request.timeout.ms=10000&lt;br/&gt;&lt;span&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span&gt; 同步还是异步发送消息，默认“sync”表同步，&lt;span&gt;&quot;async&quot;&lt;/span&gt;表异步。异步可以提高发送吞吐量,&lt;/span&gt;&lt;br/&gt;也意味着消息将会在本地buffer中,并适时批量发送，但是也可能导致丢失未发送过去的消息&lt;br/&gt;producer.type=sync&lt;br/&gt;&lt;span&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span&gt; 在async模式下,当message被缓存的时间超过此值后,将会批量发送给broker,默认为5000ms&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 此值和batch.num.messages协同工作.&lt;/span&gt;&lt;br/&gt;queue.buffering.max.ms = 5000&lt;br/&gt;&lt;span&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span&gt; 在async模式下,producer端允许buffer的最大消息量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 无论如何,producer都无法尽快的将消息发送给broker,从而导致消息在producer端大量沉积&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 此时,如果消息的条数达到阀值,将会导致producer端阻塞或者消息被抛弃，默认为10000&lt;/span&gt;&lt;br/&gt;queue.buffering.max.messages=20000&lt;br/&gt;&lt;span&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span&gt; 如果是异步，指定每次批量发送数据量，默认为200&lt;/span&gt;&lt;br/&gt;batch.num.messages=500&lt;br/&gt;&lt;span&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span&gt; 当消息在producer端沉积的条数达到&lt;span&gt;&quot;queue.buffering.max.meesages&quot;&lt;/span&gt;后 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 阻塞一定时间后,队列仍然没有enqueue(producer仍然没有发送出任何消息) &lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 此时producer可以继续阻塞或者将消息抛弃,此timeout值用于控制&lt;span&gt;&quot;阻塞&quot;&lt;/span&gt;的时间 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -1: 无阻塞超时限制,消息不会被抛弃 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 0:立即清空队列,消息被抛弃 &lt;/span&gt;&lt;br/&gt;queue.enqueue.timeout.ms=-1&lt;br/&gt;&lt;span&gt;&lt;br/&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span&gt; 当producer接收到error ACK,或者没有接收到ACK时,允许消息重发的次数 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 因为broker并没有完整的机制来避免消息重复,所以当网络异常时(比如ACK丢失) &lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 有可能导致broker接收到重复的消息,默认值为3.&lt;/span&gt;&lt;br/&gt;message.send.max.retries=3&lt;br/&gt;&lt;span&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span&gt; producer刷新topic metada的时间间隔,producer需要知道partition leader的位置,以及当前topic的情况 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 因此producer需要一个机制来获取最新的metadata,当producer遇到特定错误时,将会立即刷新 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; (比如topic失效,partition丢失,leader失效等),此外也可以通过此参数来配置额外的刷新机制，默认值600000 &lt;/span&gt;&lt;br/&gt;topic.metadata.refresh.interval.ms=60000&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;consumer消费者配置详细说明&lt;/strong&gt;:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; zookeeper连接服务器地址&lt;/span&gt;&lt;br/&gt;zookeeper.connect=zk01:2181,zk02:2181,zk03:2181&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; zookeeper的session过期时间，默认5000ms，用于检测消费者是否挂掉&lt;/span&gt;&lt;br/&gt;zookeeper.session.timeout.ms=5000&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;当消费者挂掉，其他消费者要等该指定时间才能检查到并且触发重新负载均衡&lt;/span&gt;&lt;br/&gt;zookeeper.connection.timeout.ms=10000&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 指定多久消费者更新offset到zookeeper中。注意offset更新时基于time而不是每次获得的消息。一旦在更新zookeeper发生异常并重启，将可能拿到已拿到过的消息&lt;/span&gt;&lt;br/&gt;zookeeper.sync.time.ms=2000&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;指定消费 &lt;/span&gt;&lt;br/&gt;group.id=itcast&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当consumer消费一定量的消息之后,将会自动向zookeeper提交offset信息 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 注意offset信息并不是每消费一次消息就向zk提交一次,而是现在本地保存(内存),并定期提交,默认为&lt;span&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;auto.commit.enable=true&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 自动更新时间。默认60 * 1000&lt;/span&gt;&lt;br/&gt;auto.commit.interval.ms=1000&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当前consumer的标识,可以设定,也可以有系统生成,主要用来跟踪消息消费情况,便于观察&lt;/span&gt;&lt;br/&gt;conusmer.id=xxx &lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 消费者客户端编号，用于区分不同客户端，默认客户端程序自动产生&lt;/span&gt;&lt;br/&gt;client.id=xxxx&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 最大取多少块缓存到消费者(默认10)&lt;/span&gt;&lt;br/&gt;queued.max.message.chunks=50&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当有新的consumer加入到group时,将会reblance,此后将会有partitions的消费端迁移到新  的consumer上,如果一个consumer获得了某个partition的消费权限,那么它将会向zk注册 &lt;span&gt;&quot;Partition Owner registry&quot;&lt;/span&gt;节点信息,但是有可能此时旧的consumer尚没有释放此节点, 此值用于控制,注册节点的重试次数. &lt;/span&gt;&lt;br/&gt;rebalance.max.retries=5&lt;br/&gt;&lt;span&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span&gt; 获取消息的最大尺寸,broker不会像consumer输出大于此值的消息chunk 每次feth将得到多条消息,此值为总大小,提升此值,将会消耗更多的consumer端内存&lt;/span&gt;&lt;br/&gt;fetch.min.bytes=6553600&lt;br/&gt;&lt;span&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span&gt; 当消息的尺寸不足时,server阻塞的时间,如果超时,消息将立即发送给consumer&lt;/span&gt;&lt;br/&gt;fetch.wait.max.ms=5000&lt;br/&gt;socket.receive.buffer.bytes=655360&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果zookeeper没有offset值或offset值超出范围。那么就给个初始的offset。有smallest、largest、anything可选，分别表示给当前最小的offset、当前最大的offset、抛异常。默认largest&lt;/span&gt;&lt;br/&gt;auto.offset.reset=smallest&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 指定序列化处理类&lt;/span&gt;&lt;br/&gt;derializer.class=kafka.serializer.DefaultDecoder&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;八、CAP理论&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1. 分布式系统当中的CAP理论&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分布式系统（distributed system）正变得越来越重要，大型网站几乎都是分布式的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分布式系统的最大难点，就是各个节点的状态如何同步。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决各个节点之间的状态同步问题，在1998年，由加州大学的计算机科学家 Eric Brewer 提出分布式系统的三个指标，分别是:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;Consistency：一致性&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;Availability：可用性&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;Partition tolerance：分区容错性&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Eric Brewer 说，这三个指标不可能同时做到。最多只能同时满足其中两个条件，这个结论就叫做 CAP 定理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;CAP理论是指：分布式系统中，一致性、可用性和分区容忍性最多只能同时满足两个&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一致性：Consistency&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;通过某个节点的写操作结果对后面通过其它节点的读操作可见&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果更新数据后，并发访问情况下后续读操作可立即感知该更新，称为强一致性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果允许之后部分或者全部感知不到该更新，称为弱一致性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;若在之后的一段时间（通常该时间不固定）后，一定可以感知到该更新，称为最终一致性&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可用性：Availability&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;任何一个没有发生故障的节点必须在有限的时间内返回合理的结果&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分区容错性：Partition tolerance&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;部分节点宕机或者无法与其它节点通信时，各分区间还可保持分布式系统的功能&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般而言，都要求保证分区容忍性。所以在CAP理论下，更多的是需要在可用性和一致性之间做权衡。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100005530&quot; data-ratio=&quot;0.7837837837837838&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zGGzGV7dic4RFlmib8eNeMBrsPZKOnneQeNDBVtH2oK4QYxtDHWprhljiacFSRWQuF4ypibQQMfkUVQwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;444&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2. Partition tolerance&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先看 Partition tolerance，中文叫做&quot;分区容错&quot;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大多数分布式系统都分布在多个子网络。每个子网络就叫做一个区（partition）。分区容错的意思是，区间通信可能失败。比如，一台服务器放在中国，另一台服务器放在美国，这就是两个区，它们之间可能无法通信。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100005531&quot; data-ratio=&quot;0.7964824120603015&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zGGzGV7dic4RFlmib8eNeMBrsZW6GzC2k12ibBEgVpHBQm52DPwZ8CQNfvpaB7pdUwrHk155RIzy4y7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;398&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图中，G1 和 G2 是两台跨区的服务器。G1 向 G2 发送一条消息，G2 可能无法收到。系统设计的时候，必须考虑到这种情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般来说，分区容错无法避免，因此可以认为 CAP 的 P 总是存在的。即永远可能存在分区容错这个问题&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3. Consistency&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Consistency 中文叫做&quot;一致性&quot;。意思是，写操作之后的读操作，必须返回该值。举例来说，某条记录是 v0，用户向 G1 发起一个写操作，将其改为 v1。&lt;img data-fileid=&quot;100005532&quot; data-ratio=&quot;0.7938144329896907&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zGGzGV7dic4RFlmib8eNeMBrsiaAHPAmTkHia1hj4ibwtRLYx2uwBAAIrOPSSP010X0qiaz9KzQ15n3WCMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;388&quot;/&gt;接下来，用户的读操作就会得到 v1。这就叫一致性。&lt;img data-fileid=&quot;100005533&quot; data-ratio=&quot;0.9116809116809117&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zGGzGV7dic4RFlmib8eNeMBrsfeJsVcpgJ5St5KYQmroHHqIf8TwvTk0RrC3e4b0YiazQaHicvA5u7HuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;351&quot;/&gt;问题是，用户有可能向 G2 发起读操作，由于 G2 的值没有发生变化，因此返回的是 v0。G1 和 G2 读操作的结果不一致，这就不满足一致性了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100005534&quot; data-ratio=&quot;0.49206349206349204&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zGGzGV7dic4RFlmib8eNeMBrsrolAqBBl5vVNLPW46HAHQJQmWnx79ZrdFpEvTXGonKiaiaAo8X5QxuHg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;693&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了让 G2 也能变为 v1，就要在 G1 写操作的时候，让 G1 向 G2 发送一条消息，要求 G2 也改成 v1。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100005538&quot; data-ratio=&quot;0.8789625360230547&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zGGzGV7dic4RFlmib8eNeMBrsnb0uxiaoJ0h1xRF3fX9ibeyUuAyXnNO3Qhiaoms3DlhYiadE11ASnRRTYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;347&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样的话，用户向 G2 发起读操作，也能得到 v1。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100005535&quot; data-ratio=&quot;0.8068783068783069&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zGGzGV7dic4RFlmib8eNeMBrslftfFBIFlptUPptGEpLL33pXoDoiaRlI0TW13YKTLnjOrXbWNPhuh1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;378&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;4. Availability&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Availability 中文叫做&quot;可用性&quot;，意思是只要收到用户的请求，服务器就必须给出回应。用户可以选择向 G1 或 G2 发起读操作。不管是哪台服务器，只要收到请求，就必须告诉用户，到底是 v0 还是 v1，否则就不满足可用性。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;九、Kafka中的CAP机制&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;kafka是一个分布式的消息队列系统，既然是一个分布式的系统，那么就一定满足CAP定律，那么在kafka当中是如何遵循CAP定律的呢？kafka满足CAP定律当中的哪两个呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;kafka满足的是CAP定律当中的CA，其中Partition  tolerance通过的是一定的机制尽量的保证分区容错性&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;其中C表示的是数据一致性。A表示数据可用性&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;kafka首先将数据写入到不同的分区里面去，每个分区又可能有好多个副本，数据首先写入到leader分区里面去，读写的操作都是与leader分区进行通信，保证了数据的一致性原则，也就是满足了Consistency原则。然后kafka通过分区副本机制，来保证了kafka当中数据的可用性。但是也存在另外一个问题，就是副本分区当中的数据与leader当中的数据存在差别的问题如何解决，这个就是Partition tolerance的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;kafka为了解决Partition tolerance的问题，使用了ISR的同步策略，来尽最大可能减少Partition tolerance的问题&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个leader会维护一个ISR（a set of in-sync replicas，基本同步）列表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ISR列表主要的作用就是决定哪些副本分区是可用的，也就是说可以将leader分区里面的数据同步到副本分区里面去，决定一个副本分区是否可用的条件有两个：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;replica.lag.time.max.ms=10000     副本分区与主分区心跳时间延迟&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;replica.lag.max.messages=4000    副本分区与主分区消息同步最大差&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;produce 请求被认为完成时的确认值：&lt;code&gt;request.required.acks=0&lt;/code&gt;。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ack=0：producer不等待broker同步完成的确认，继续发送下一条(批)信息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ack=1（默认）：producer要等待leader成功收到数据并得到确认，才发送下一条message。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ack=-1：producer得到follwer确认，才发送下一条数据。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;十、Kafka监控及运维&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在开发工作中，消费在Kafka集群中消息，数据变化是我们关注的问题，当业务前提不复杂时，我们可以使用Kafka 命令提供带有Zookeeper客户端工具的工具，可以轻松完成我们的工作。随着业务的复杂性，增加Group和 Topic，那么我们使用Kafka提供命令工具，已经感到无能为力，那么Kafka监控系统目前尤为重要，我们需要观察 消费者应用的细节。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1. kafka-eagle概述&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了简化开发者和服务工程师维护Kafka集群的工作有一个监控管理工具，叫做 Kafka-eagle。这个管理工具可以很容易地发现分布在集群中的哪些topic分布不均匀，或者是分区在整个集群分布不均匀的的情况。它支持管理多个集群、选择副本、副本重新分配以及创建Topic。同时，这个管理工具也是一个非常好的可以快速浏览这个集群的工具，&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2. 环境和安装&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 环境要求&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要安装jdk，启动zk以及kafka的服务&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 安装步骤&lt;span/&gt;&lt;/h4&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;下载源码包&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;kafka-eagle官网：http://download.kafka-eagle.org/&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以从官网上面直接下载最细的安装包即可kafka-eagle-bin-1.3.2.tar.gz这个版本即可&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码托管地址：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://github.com/smartloli/kafka-eagle/releases&lt;/p&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;解压&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们选择将kafak-eagle安装在第三台。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接将kafka-eagle安装包上传到node03服务器的/export/softwares路径下，然后进行解压
node03服务器执行一下命令进行解压。&lt;/p&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;准备数据库&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;kafka-eagle需要使用一个数据库来保存一些元数据信息，我们这里直接使用msyql数据库来保存即可，在node03服务器执行以下命令创建一个mysql数据库即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进入mysql客户端:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;create&lt;/span&gt; &lt;span&gt;database&lt;/span&gt; eagle;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;修改kafak-eagle配置文件&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行以下命令修改kafak-eagle配置文件:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;vim system-config.properties&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;修改为如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;kafka.eagle.zk.cluster.alias=cluster1,cluster2&lt;br/&gt;cluster1.zk.list=node01:2181,node02:2181,node03:2181&lt;br/&gt;cluster2.zk.list=node01:2181,node02:2181,node03:2181&lt;br/&gt;&lt;br/&gt;kafka.eagle.driver=com.mysql.jdbc.Driver&lt;br/&gt;kafka.eagle.url=jdbc:mysql://node03:3306/eagle&lt;br/&gt;kafka.eagle.username=root&lt;br/&gt;kafka.eagle.password=123456&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;5&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;配置环境变量&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;kafka-eagle必须配置环境变量，node03服务器执行以下命令来进行配置环境变量: &lt;code&gt;vim /etc/profile&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;export KE_HOME=/opt//kafka-eagle-bin-1.3.2/kafka-eagle-web-1.3.2&lt;br/&gt;export PATH=:$KE_HOME/bin:$PATH&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;修改立即生效，执行: &lt;code&gt;source /etc/profile&lt;/code&gt;&lt;/p&gt;&lt;ol start=&quot;6&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;启动kafka-eagle&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行以下界面启动kafka-eagle：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;cd kafka-eagle-web-1.3.2/bin&lt;br/&gt;chmod u+x ke.sh&lt;br/&gt;./ke.sh start&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;7&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;主界面&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;访问kafka-eagle&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;http://node03:8048/ke/account/signin?/ke/&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户名：admin&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;密码：123456&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100005536&quot; data-ratio=&quot;0.4666666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/ZubDbBye0zGGzGV7dic4RFlmib8eNeMBrsX0T4ibR6W61wyMRlViavDDMwt9Nzn0CRw9ZhTW3Far0sABjWHiba8S6Fg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;十一、Kafka大厂面试题&lt;/span&gt;&lt;/h2&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 为什么要使用 kafka？&lt;span/&gt;&lt;/h4&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;缓冲和削峰：上游数据时有突发流量，下游可能扛不住，或者下游没有足够多的机器来保证冗余，kafka在中间可以起到一个缓冲的作用，把消息暂存在kafka中，下游服务就可以按照自己的节奏进行慢慢处理。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;解耦和扩展性：项目开始的时候，并不能确定具体需求。消息队列可以作为一个接口层，解耦重要的业务流程。只需要遵守约定，针对数据编程即可获取扩展能力。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;冗余：可以采用一对多的方式，一个生产者发布消息，可以被多个订阅topic的服务消费到，供多个毫无关联的业务使用。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;健壮性：消息队列可以堆积请求，所以消费端业务即使短时间死掉，也不会影响主要业务的正常进行。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;异步通信：很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. Kafka消费过的消息如何再消费？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;kafka消费消息的offset是定义在zookeeper中的，如果想重复消费kafka的消息，可以在redis中自己记录offset的checkpoint点（n个），当想重复消费消息时，通过读取redis中的checkpoint点进行zookeeper的offset重设，这样就可以达到重复消费消息的目的了&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. kafka的数据是放在磁盘上还是内存上，为什么速度会快？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;kafka使用的是磁盘存储。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;速度快是因为：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;顺序写入：因为硬盘是机械结构，每次读写都会寻址-&amp;gt;写入，其中寻址是一个“机械动作”，它是耗时的。所以硬盘 “讨厌”随机I/O， 喜欢顺序I/O。为了提高读写硬盘的速度，Kafka就是使用顺序I/O。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Memory Mapped Files（内存映射文件）：64位操作系统中一般可以表示20G的数据文件，它的工作原理是直接利用操作系统的Page来实现文件到物理内存的直接映射。完成映射之后你对物理内存的操作会被同步到硬盘上。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Kafka高效文件存储设计：Kafka把topic中一个parition大文件分成多个小文件段，通过多个小文件段，就容易定期清除或删除已经消费完文件，减少磁盘占用。通过索引信息可以快速定位
message和确定response的 大     小。通过index元数据全部映射到memory（内存映射文件），
可以避免segment file的IO磁盘操作。通过索引文件稀疏存储，可以大幅降低index文件元数据占用空间大小。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注&lt;/strong&gt;：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Kafka解决查询效率的手段之一是将数据文件分段，比如有100条Message，它们的offset是从0到99。假设将数据文件分成5段，第一段为0-19，第二段为20-39，以此类推，每段放在一个单独的数据文件里面，数据文件以该段中 小的offset命名。这样在查找指定offset的
Message的时候，用二分查找就可以定位到该Message在哪个段中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为数据文件建 索引数据文件分段 使得可以在一个较小的数据文件中查找对应offset的Message 了，但是这依然需要顺序扫描才能找到对应offset的Message。为了进一步提高查找的效率，Kafka为每个分段后的数据文件建立了索引文件，文件名与数据文件的名字是一样的，只是文件扩展名为.index。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. Kafka数据怎么保障不丢失？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分三个点说，一个是生产者端，一个消费者端，一个broker端。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;生产者数据的不丢失&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;kafka的ack机制：在kafka发送数据的时候，每次发送消息都会有一个确认反馈机制，确保消息正常的能够被收到，其中状态有0，1，-1。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是同步模式：&lt;br/&gt;ack设置为0，风险很大，一般不建议设置为0。即使设置为1，也会随着leader宕机丢失数据。所以如果要严格保证生产端数据不丢失，可设置为-1。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是异步模式：&lt;br/&gt;也会考虑ack的状态，除此之外，异步模式下的有个buffer，通过buffer来进行控制数据的发送，有两个值来进行控制，时间阈值与消息的数量阈值，如果buffer满了数据还没有发送出去，有个选项是配置是否立即清空buffer。可以设置为-1，永久阻塞，也就数据不再生产。异步模式下，即使设置为-1。也可能因为程序员的不科学操作，操作数据丢失，比如kill -9，但这是特别的例外情况。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注：&lt;br/&gt;ack=0：producer不等待broker同步完成的确认，继续发送下一条(批)信息。&lt;br/&gt;ack=1（默认）：producer要等待leader成功收到数据并得到确认，才发送下一条message。&lt;br/&gt;ack=-1：producer得到follwer确认，才发送下一条数据。&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;消费者数据的不丢失&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过offset commit 来保证数据的不丢失，kafka自己记录了每次消费的offset数值，下次继续消费的时候，会接着上次的offset进行消费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而offset的信息在kafka0.8版本之前保存在zookeeper中，在0.8版本之后保存到topic中，即使消费者在运行过程中挂掉了，再次启动的时候会找到offset的值，找到之前消费消息的位置，接着消费，由于 offset 的信息写入的时候并不是每条消息消费完成后都写入的，所以这种情况有可能会造成重复消费，但是不会丢失消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;唯一例外的情况是，我们在程序中给原本做不同功能的两个consumer组设置
KafkaSpoutConfig.bulider.setGroupid的时候设置成了一样的groupid，这种情况会导致这两个组共享同一份数据，就会产生组A消费partition1，partition2中的消息，组B消费partition3的消息，这样每个组消费的消息都会丢失，都是不完整的。为了保证每个组都独享一份消息数据，groupid一定不要重复才行。&lt;/p&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;kafka集群中的broker的数据不丢失&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个broker中的partition我们一般都会设置有replication（副本）的个数，生产者写入的时候首先根据分发策略（有partition按partition，有key按key，都没有轮询）写入到leader中，follower（副本）再跟leader同步数据，这样有了备份，也可以保证消息数据的不丢失。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5. 采集数据为什么选择kafka？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;采集层 主要可以使用Flume, Kafka等技术。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Flume：Flume 是管道流方式，提供了很多的默认实现，让用户通过参数部署，及扩展API.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka：Kafka是一个可持久化的分布式的消息队列。Kafka 是一个非常通用的系统。你可以有许多生产者和很多的消费者共享多个主题Topics。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相比之下,Flume是一个专用工具被设计为旨在往HDFS，HBase发送数据。它对HDFS有特殊的优化，并且集成了Hadoop的安全特性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，Cloudera 建议如果数据被多个系统消费的话，使用kafka；如果数据被设计给Hadoop使用，使用Flume。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6. kafka 重启是否会导致数据丢失？&lt;span/&gt;&lt;/h4&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;kafka是将数据写到磁盘的，一般数据不会丢失。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;但是在重启kafka过程中，如果有消费者消费消息，那么kafka如果来不及提交offset，可能会造成数据的不准确（丢失或者重复消费）。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7. kafka 宕机了如何解决？&lt;span/&gt;&lt;/h4&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;先考虑业务是否受到影响&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;kafka 宕机了，首先我们考虑的问题应该是所提供的服务是否因为宕机的机器而受到影响，如果服务提供没问题，如果实现做好了集群的容灾机制，那么这块就不用担心了。&lt;/p&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;节点排错与恢复&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想要恢复集群的节点，主要的步骤就是通过日志分析来查看节点宕机的原因，从而解决，重新恢复节点。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8. 为什么Kafka不支持读写分离？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Kafka 中，生产者写入消息、消费者读取消息的操作都是与 leader 副本进行交互的，从 而实现的是一种&lt;strong&gt;主写主读&lt;/strong&gt;的生产消费模型。Kafka 并不支持&lt;strong&gt;主写从读&lt;/strong&gt;，因为主写从读有 2 个很明显的缺点:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;数据一致性问题：数据从主节点转到从节点必然会有一个延时的时间窗口，这个时间 窗口会导致主从节点之间的数据不一致。某一时刻，在主节点和从节点中 A 数据的值都为 X， 之后将主节点中 A 的值修改为 Y，那么在这个变更通知到从节点之前，应用读取从节点中的 A 数据的值并不为最新的 Y，由此便产生了数据不一致的问题。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;延时问题：类似 Redis 这种组件，数据从写入主节点到同步至从节点中的过程需要经历 网络→主节点内存→网络→从节点内存 这几个阶段，整个过程会耗费一定的时间。而在 Kafka 中，主从同步会比 Redis 更加耗时，它需要经历 网络→主节点内存→主节点磁盘→网络→从节 点内存→从节点磁盘 这几个阶段。对延时敏感的应用而言，主写从读的功能并不太适用。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而kafka的&lt;strong&gt;主写主读&lt;/strong&gt;的优点就很多了：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;可以简化代码的实现逻辑，减少出错的可能;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将负载粒度细化均摊，与主写从读相比，不仅负载效能更好，而且对用户可控;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;没有延时的影响;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在副本稳定的情况下，不会出现数据不一致的情况。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;9. kafka数据分区和消费者的关系？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个分区只能由同一个消费组内的一个消费者(consumer)来消费，可以由不同的消费组的消费者来消费，同组的消费者则起到并发的效果。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;10. kafka的数据offset读取流程&lt;span/&gt;&lt;/h4&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;连接ZK集群，从ZK中拿到对应topic的partition信息和partition的Leader的相关信息&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;连接到对应Leader对应的broker&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;consumer将⾃自⼰己保存的offset发送给Leader&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Leader根据offset等信息定位到segment（索引⽂文件和⽇日志⽂文件）&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;根据索引⽂文件中的内容，定位到⽇日志⽂文件中该偏移量量对应的开始位置读取相应⻓长度的数据并返回给consumer&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;11. kafka内部如何保证顺序，结合外部组件如何保证消费者的顺序？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;kafka只能保证partition内是有序的，但是partition间的有序是没办法的。爱奇艺的搜索架构，是从业务上把需要有序的打到同⼀个partition。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;12. Kafka消息数据积压，Kafka消费能力不足怎么处理？&lt;span/&gt;&lt;/h4&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果是Kafka消费能力不足，则可以考虑增加Topic的分区数，并且同时提升消费组的消费者数量，消费者数=分区数。（两者缺一不可）&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果是下游的数据处理不及时：提高每批次拉取的数量。批次拉取数据过少（拉取数据/处理时间&amp;lt;生产速度），使处理的数据小于生产的数据，也会造成数据积压。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;13.  Kafka单条日志传输大小&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;kafka对于消息体的大小默认为单条最大值是1M但是在我们应用场景中, 常常会出现一条消息大于1M，如果不对kafka进行配置。则会出现生产者无法将消息推送到kafka或消费者无法去消费kafka里面的数据, 这时我们就要对kafka进行以下配置：server.properties&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;replica.fetch.max.bytes: 1048576  broker可复制的消息的最大字节数, 默认为1M&lt;br/&gt;message.max.bytes: 1000012   kafka 会接收单个消息size的最大限制， 默认为1M左右&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意：message.max.bytes必须小于等于replica.fetch.max.bytes，否则就会导致replica之间数据同步失败。&lt;/strong&gt;&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h4&gt;&lt;ol start=&quot;4&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;100006123&quot; data-ratio=&quot;0.10789473684210527&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/CWCpl8m0oQBeWQ9Jf4ZVoJhYiaLHh2ThtV3ew4p7kZrjoU6nYAY1a3qGJVjHFP7r4MjehMzASG3IyTvubhq5Mqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;380&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU4NjgzNzk4MQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/CWCpl8m0oQC18panFv8VgOcQGCz2HKrUBayxrxsYu5OH4OpSvEaqSFkmunggw6JIYWRoavAfypwxjh1pdfUzng/0?wx_fmt=png&quot; data-nickname=&quot;大鱼的数据人生&quot; data-alias=&quot;dayu_data&quot; data-signature=&quot;我是大鱼先生，CDO，跟你分享有关数据的一切！&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;ol start=&quot;4&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;100006122&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.10789473684210527&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBvelVDaaECmibKwBQzYWNl0pS95nEJT8H5pQa2Fhibgic3gLcIfeweqeqmgVyOdCjyQfmzYyeD41ViaKw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;380&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;100006124&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.1085714285714285&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBvelVDaaECmibKwBQzYWNl0piakr9hOHIQcIp7IdxCN9prg55iaUYNuicpLlPLvBhQyQ5SYWnzMibau76A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;525&quot;/&gt;&lt;/p&gt;&lt;/ol&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;100006121&quot; data-ratio=&quot;0.10789473684210527&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/CWCpl8m0oQCwoia1icXCvsgbMTPscibtQIVX3XibXERZo3RhhjBPVEPksoDZI4fia734jHWq3YX71Eo9JDACCyqHF1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;380&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU4NjgzNzk4MQ==&amp;amp;mid=2247488817&amp;amp;idx=1&amp;amp;sn=1a1da3aa65c591df3f80d036c1b25eb6&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU4NjgzNzk4MQ==&amp;amp;mid=2247489725&amp;amp;idx=1&amp;amp;sn=3e84c609ee091ef27b573bb2a6b78425&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;五万字 | Hive知识体系保姆级教程&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU4NjgzNzk4MQ==&amp;amp;mid=2247489523&amp;amp;idx=1&amp;amp;sn=a7dfea0e4039e505ceb671ae3128098e&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Hive SQL迁移Spark SQL在网易传媒的实践&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU4NjgzNzk4MQ==&amp;amp;mid=2247489490&amp;amp;idx=1&amp;amp;sn=f1a50adef406f9d89906a484188783c3&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;聊聊 Kafka： Kafka 为啥这么快？&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU4NjgzNzk4MQ==&amp;amp;mid=2247489461&amp;amp;idx=1&amp;amp;sn=5140911ecd5d37df0682d86014475d61&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;数仓中指标-标签，维度-度量，自然键-代理键等常见的概念术语解析&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU4NjgzNzk4MQ==&amp;amp;mid=2247489397&amp;amp;idx=1&amp;amp;sn=f3ff5dada1539ff06c2e01dc752c4d15&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;啥都复用不了，还谈什么狗屁中台！&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU4NjgzNzk4MQ==&amp;amp;mid=2247489337&amp;amp;idx=1&amp;amp;sn=9c606165da521f2d50c8ba7068bd664c&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;一文读懂Hive底层数据存储格式（好文收藏）&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU4NjgzNzk4MQ==&amp;amp;mid=2247489139&amp;amp;idx=1&amp;amp;sn=1cdb3be84bee26546eee0f581a59a5ae&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;数据中台的原罪 by 大鱼先生&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU4NjgzNzk4MQ==&amp;amp;mid=2247489109&amp;amp;idx=1&amp;amp;sn=b53be0e09ea328468ff7487a71f55ebc&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Elasticsearch疯狂的技术体系全解&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;点击左下角“&lt;/span&gt;&lt;span&gt;&lt;strong&gt;阅读原文&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;”查看更多精彩文章，后台回复【&lt;span&gt;&lt;strong&gt;&lt;span&gt;加群&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;】申请加入万人&lt;/span&gt;&lt;span&gt;&lt;strong&gt;数据学习&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;社群&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;100006125&quot; data-ratio=&quot;0.4168987929433612&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/CWCpl8m0oQC3kCFvcnJqRQ38A5DabuORHXoPiclkfYyFbc3o4AyRsz3x15BbWS184eX232bBxcGVBdK71YbGIEg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1077&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;🧐&lt;/span&gt;&lt;strong&gt;分享、点赞、在看&lt;/strong&gt;&lt;span&gt;，给个&lt;/span&gt;&lt;strong&gt;3连击&lt;/strong&gt;&lt;span&gt;呗！&lt;/span&gt;&lt;strong&gt;👇&lt;/strong&gt;&lt;/p&gt;&lt;/ol&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6d8f0b77f9a3efd4351fa827e75d60db</guid>
<title>深入理解函数式编程</title>
<link>https://toutiao.io/k/uhgv3gc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;1&quot; data-url=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485878&amp;amp;idx=1&amp;amp;sn=41b8847a0b7e472ab2bb48f9ee843376&amp;amp;chksm=fafde318cd8a6a0e17e4226d48e37e60093a7fe38bf466172de5fb79d43fa96cf050ae35958d&amp;amp;token=1582779346&amp;amp;lang=zh_CN#rd&quot; data-author-name=&quot;编程一生&quot; data-content-utf8-length=&quot;15&quot; data-source-title=&quot;架构之思-分析那些深入骨髓的设计原则&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;函数式编程是对行为进行抽象。&lt;/p&gt;&lt;/section&gt;&lt;section class=&quot;blockquote_info js_blockquote_source&quot; data-json=&quot;%7B%22type%22%3A%22inner%22%2C%22source%22%3A%22url%22%2C%22digest%22%3A%22%3Cp%3E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%98%AF%E5%AF%B9%E8%A1%8C%E4%B8%BA%E8%BF%9B%E8%A1%8C%E6%8A%BD%E8%B1%A1%E3%80%82%E2%80%8B%3C%2Fp%3E%22%2C%22digestLen%22%3A15%2C%22text%22%3A%22%22%2C%22article%22%3A%7B%22title%22%3A%22%E6%9E%B6%E6%9E%84%E4%B9%8B%E6%80%9D-%E5%88%86%E6%9E%90%E9%82%A3%E4%BA%9B%E6%B7%B1%E5%85%A5%E9%AA%A8%E9%AB%93%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%22%2C%22url%22%3A%22https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzUzNjAxODg4MQ%3D%3D%26mid%3D2247485878%26idx%3D1%26sn%3D41b8847a0b7e472ab2bb48f9ee843376%26chksm%3Dfafde318cd8a6a0e17e4226d48e37e60093a7fe38bf466172de5fb79d43fa96cf050ae35958d%26token%3D1582779346%26lang%3Dzh_CN%23rd%22%2C%22nickname%22%3A%22%E7%BC%96%E7%A8%8B%E4%B8%80%E7%94%9F%22%2C%22authorName%22%3A%22%E7%BC%96%E7%A8%8B%E4%B8%80%E7%94%9F%22%7D%2C%22hasReportOverSize%22%3Afalse%2C%22editorReportData%22%3A%5B%7B%22id%22%3A%22122333%22%2C%22key%22%3A%2275%22%2C%22len%22%3A1%7D%2C%7B%22id%22%3A%22122333%22%2C%22key%22%3A%2276%22%2C%22len%22%3A1%7D%2C%7B%22id%22%3A%22122333%22%2C%22key%22%3A%2277%22%2C%22len%22%3A1%7D%2C%7B%22id%22%3A%22122333%22%2C%22key%22%3A%2278%22%2C%22len%22%3A1%7D%5D%7D&quot;&gt;&lt;span class=&quot;blockquote_biz&quot;&gt;编程一生，公众号：编程一生&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485878&amp;amp;idx=1&amp;amp;sn=41b8847a0b7e472ab2bb48f9ee843376&amp;amp;chksm=fafde318cd8a6a0e17e4226d48e37e60093a7fe38bf466172de5fb79d43fa96cf050ae35958d&amp;amp;token=1582779346&amp;amp;lang=zh_CN#rd&quot; class=&quot;blockquote_article&quot;&gt;架构之思-分析那些深入骨髓的设计原则&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;这句话比较难理解，换句话来说：函数式编程是给自己的对象整容，有可能整的和原来差不多，也有可能整的看起来判若两人，但是只能处理这个对象，不会对函数外的其他数据产生影响。&lt;/p&gt;&lt;p&gt;函数式编程又结合了lambda表达式和stream API。有些朋友反馈说：函数式编程可读性不好；还有些朋友反馈说：函数式编程比较难debug。你们说的都对，但是有解决的办法，看完这篇文章就明白了。&lt;/p&gt;&lt;p&gt;文章整体大纲如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;198&quot; data-backw=&quot;578&quot; data-fileid=&quot;100002259&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3436385255648038&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9a8SfucgtOoib1icLibUYdu4x386xibYE9iafCJnRagNJ9D0rNv7zWACXICCErNAgYP6jbJOdYnFK9Rhg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;841&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;lambda表达式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;lambda表达式的本质是匿名内部类&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;先来看一个例子：杜甫的《登高》写的好，被称为千古律诗之首。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100002262&quot; data-ratio=&quot;1.3426666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRl9a8SfucgtOoib1icLibUYdu4xiaHDNseM5iaHZGg6yeo6rbDvjicbebd0osiaXNCnrAV3IhovfCaSuxyJfQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;我从十几岁的时候开始就一直在想这首诗怎么不押韵：渚清沙白鸟飞回，高中老师讲过古语里“回”念huai，这就压上韵了。但是潦倒新停浊酒杯的杯在古语或者古语方言里念bai吗？直到如今我还是没有考证到是否是这样。我就当它是念bai吧。&lt;/p&gt;&lt;p&gt;这首诗我最喜欢的四句，渲染磅礴的气势都含了数字：万里、百年、无边、不尽。我突发奇想：让电脑来给这四句排排序吧。于是我写了下面的程序：&lt;/p&gt;&lt;pre&gt;&lt;span&gt;public void &lt;/span&gt;&lt;span&gt;sortDengGao&lt;/span&gt;() {&lt;br/&gt;    List&amp;lt;String&amp;gt; list = Lists.&lt;span&gt;newArrayList&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;无边落木萧萧下&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;不尽长江滚滚来&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;万里悲秋常作客&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;百年多病独登台&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;list.sort(&lt;span&gt;new &lt;/span&gt;Comparator&amp;lt;String&amp;gt;() {&lt;br/&gt;        &lt;span&gt;@Override&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;public int &lt;/span&gt;&lt;span&gt;compare&lt;/span&gt;(String o1&lt;span&gt;, &lt;/span&gt;String o2) {&lt;br/&gt;            &lt;span&gt;return &lt;/span&gt;o1.substring(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;).compareTo(o2.substring(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;))&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;}&lt;br/&gt;    })&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;System.&lt;span&gt;out&lt;/span&gt;.println(list)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;}&lt;/pre&gt;&lt;p&gt;我鼠标点在new Comparator上，提示我匿名内部类可以用lambda代替：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100002263&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.46489859594383776&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9a8SfucgtOoib1icLibUYdu4x6TJMRicXibSuWfmkRnaKbgDfstjwjMmpRq55d2RURsPBdH3J3icAcMAtg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;641&quot;/&gt;&lt;/p&gt;&lt;p&gt;使用Alt+Enter快捷键，我回车一下，结果变成了这样：&lt;/p&gt;&lt;pre&gt;&lt;span&gt;public void &lt;/span&gt;&lt;span&gt;sortDengGao&lt;/span&gt;() {&lt;br/&gt;    List&amp;lt;String&amp;gt; list = Lists.&lt;span&gt;newArrayList&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;无边落木萧萧下&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;不尽长江滚滚来&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;万里悲秋常作客&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;百年多病独登台&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;list.sort((o1&lt;span&gt;, &lt;/span&gt;o2) -&amp;gt; o1.substring(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;).compareTo(o2.substring(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;)))&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;System.&lt;span&gt;out&lt;/span&gt;.println(list)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;}&lt;/pre&gt;&lt;p&gt;当然还可以再执行一次Alt+Enter还原回来。&lt;/p&gt;&lt;p&gt;匿名内部类和lambda表达式既然可以使用快捷键相互转换，那就说明他们本质上是一个东西。这样就好理解了：在jdk1.8之前，通过匿名内部类访问局部变量必须要加final关键字，jdk1.8之后不需要显示的加final关键字但实际上还是需要被访问的变量不可变。这就对应了函数式编程不会对函数外的其他数据产生影响。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;lambda表达式的省略规则&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;lambda表达式核心是(对于匿名内部类)采用可推导可省略的原则。所以有些朋友反馈说：函数式编程可读性不好。因为它做了省略，如果对原本被省略的匿名内部类不熟悉，阅读就会麻烦些。还有一点哈，编写代码注意换行哈：&lt;/p&gt;&lt;pre&gt;list.stream().sorted((o1&lt;span&gt;, &lt;/span&gt;o2) -&amp;gt; o1.substring(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;).compareTo(o2.substring(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;))).close()&lt;span&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;这段代码一个方法用一行是不是好看一些：&lt;/p&gt;&lt;pre&gt;list.stream()&lt;br/&gt;        .sorted((o1&lt;span&gt;, &lt;/span&gt;o2) -&amp;gt; o1.substring(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;).compareTo(o2.substring(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;)))&lt;br/&gt;        .close()&lt;span&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;lambda表达式是对匿名内部类的下面三点做了省略：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;stream API&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;stream API就是运用fluent风格的一个特例&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;对fluent风格不熟悉的强烈建议看看我之前的这篇&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247484645&amp;amp;idx=1&amp;amp;sn=f86183a5a248a03adf8d8da3452b79fe&amp;amp;chksm=fafdee4bcd8a675d2335942673334f188e7826c39fe24314f91a5151d78c1554527ca612beb8&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《代码荣辱观-以运用风格为荣，以随意编码为耻》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《代码荣辱观-以运用风格为荣，以随意编码为耻》&lt;/a&gt;。这篇文章逻辑清晰，语言诙谐，比喻恰当，专治不明白。&lt;/p&gt;&lt;p&gt;这里只举个简单的例子：StringBuilder一般是这样使用的：&lt;/p&gt;&lt;pre&gt;&lt;span&gt;new &lt;/span&gt;StringBuilder().append(&lt;span&gt;1&lt;/span&gt;).append(&lt;span&gt;2&lt;/span&gt;).toString()&lt;span&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;这是典型的fluent风格。咱们来看它包含几部分：&lt;/p&gt;&lt;p&gt;第一部分：new StringBuffer()构造一个特定对象&lt;/p&gt;&lt;p&gt;第二部分：append()对这个对象本身做处理，可以多次调用，每次都返回它本身&lt;/p&gt;&lt;p&gt;第三部分：toString()结束处理&lt;/p&gt;&lt;p&gt;再来看这个stream API的例子：&lt;/p&gt;&lt;pre&gt;list.stream()&lt;br/&gt;        .sorted((o1&lt;span&gt;, &lt;/span&gt;o2) -&amp;gt; o1.substring(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;).compareTo(o2.substring(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;)))&lt;br/&gt;        .close()&lt;span&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;第一部分：.stream()构造一个特定对象&lt;/p&gt;&lt;p&gt;第二部分：sorted()对这个对象本身做处理，可以多次调用，每次都返回它本身&lt;/p&gt;&lt;p&gt;第三部分：close()结束处理&lt;/p&gt;&lt;p&gt;是不是一毛一样！stream API就是运用fluent风格的一个特例，如此而已。所以我们要关注的点只是.stream()构造的特定对象Stream给我提供了怎么的功能，达到了号称比sql还简单、还强大的功能。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一分钟理解MapReduce&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;MapReduce现在流行于大数据中的概念，本质上是为了解决对于数据的并行计算方法明明本质上都是采用分治法，但是缺少高层并行编程模型，程序员需要自行指定存储、计算、分发等任务的问题。MapReduce借鉴了&lt;strong&gt;&lt;span&gt;Lisp函数式语言&lt;/span&gt;&lt;/strong&gt;中的思想，用map和reduce两个函数提供了高层的并发编程模型的抽象。&lt;/p&gt;&lt;p&gt;直白点说就是提供了一个计算手脚架，照着这个架子做开发就可以了。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;380&quot; data-backw=&quot;578&quot; data-fileid=&quot;100002252&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6578657865786579&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9a8SfucgtOoib1icLibUYdu4xPDWFicIoVd447ibuf3uppQ1N09Sc5eFZEBAun9vNmPWjuBO3rNdpujwg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;909&quot;/&gt;&lt;/p&gt;&lt;p&gt;上面图中可以看到map的主要功能是把数据分成小块进行计算，reduce是将小块计算结果进行合并。在stream API中map和reduce功能也是一样的。举个例子：&lt;/p&gt;&lt;h1&gt;&lt;span/&gt;&lt;/h1&gt;&lt;pre&gt;&lt;span&gt;public void &lt;/span&gt;&lt;span&gt;mapReduceDengGao&lt;/span&gt;() {&lt;br/&gt;    List&amp;lt;String&amp;gt; list = Lists.&lt;span&gt;newArrayList&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;无边落木萧萧下&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;不尽长江滚滚来&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;万里悲秋常作客&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;百年多病独登台&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;String result = list.stream()&lt;br/&gt;            .map(word-&amp;gt;word+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&lt;br/&gt;            .reduce((a&lt;span&gt;,&lt;/span&gt;b)-&amp;gt;a+&lt;span&gt;&quot;&quot;&lt;/span&gt;+b)&lt;br/&gt;            .get()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;System.&lt;span&gt;out&lt;/span&gt;.println(result)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;}&lt;/pre&gt;&lt;p&gt;上面函数先用map方法把list每个元素都进行了处理：后面加换行符。然后用reduce方法对数据合并计算：合并为一个字符串。大数据的MapReduce也就是干了这！&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;用Intellij对stream API做debug&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;有些朋友反馈说：函数式编程比较难debug。stream trace了解一下。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100002253&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8446745562130178&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9a8SfucgtOoib1icLibUYdu4xLw3BK07RmRLLSsMk82hsLZerhkbJsdb32wUkscxTFLYT2FsvFrCnfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;676&quot;/&gt;&lt;/p&gt;&lt;p&gt;首先在steam API的地方打上断点。当运行到断点处，点击上面红色框框里那个图标，之后会弹出一个框，但是可能一开始没有数据，提示正在计算，稍等一会之后stream的每一步调用结果都可以看到啦：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100002254&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5134370579915134&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9a8SfucgtOoib1icLibUYdu4xgH6Y2SuYvV89o8EdqL45cdOzSyibW0sfe6ZwXUZWticotDOTeh3qGvibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;707&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;函数式编程的优势：&lt;/p&gt;&lt;p&gt;代码可读性高，上面已经讲过了，因为简洁明了。&lt;/p&gt;&lt;p&gt;大数据量下处理集合效率高，这个主要是指因为函数式编程功能内聚，JVM优化时去掉了多余的锁。像上面MapReduce那段讲的，采用分治法，使用并行流的话内部做了很好的多线程处理。&lt;/p&gt;&lt;p&gt;消灭嵌套地狱嘛，看看下面箭头形代码：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100002267&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.83&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9a8SfucgtOoib1icLibUYdu4xUH5HsFiczRJsxqrvvp8us2iaNMZxicD3n78M0GhfYKpWOPGWg5nF64qdw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;用函数式编程效果是这样的，好看不好看不好说，起码sonar静态检查能过：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;272&quot; data-backw=&quot;498&quot; data-fileid=&quot;100002266&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5461847389558233&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9a8SfucgtOoib1icLibUYdu4xtqQsuP8dVrzEekaOnt71fTFCU3eoA5NAas59JptzrzXTRze15V1b8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;498&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7eff83bc31681277aed14c13a2d7d244</guid>
<title>业务重构时用事件驱动模式</title>
<link>https://toutiao.io/k/rqswjqj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h3 cid=&quot;n2&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;前言&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n3&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;需求：当新用户注册时，需要给用户发放各种礼品、积分、短信、邀请人奖励等。&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n4&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;常见写法&lt;/span&gt;&lt;/h4&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; cid=&quot;n5&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n7&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;直接将上述后续操作堆到注册方法里，搞的注册方法又臭又长；当有其他注册如app注册、小程序注册、第三方注册时，然后将同样的发放逻辑复制的到处都是，可读性、维护性极差&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n9&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;优化：可以将发放逻辑抽成一个方法，然后供调用，这个应该是最常用的；&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n10&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;但随着业务的扩张，可能不止普通用户、还有承包商、供应商等。可能都已经是不同的表了，他们也有不同的发放逻辑。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n11&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;然后发放逻辑建好几个方法，将之前的逻辑复制过去改一改；最后这个发放逻辑就会变得很臃肿难以维护。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n13&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;再优化：可以套用事件驱动模式肢解该逻辑，当然也可以不使用。一切都要从业务出发，业务不复杂就完全没必要使用。因为不管用到什么设计模式都会建好多个类，虽然在单个类里维护性很强，但找起来可能不方便、整体使用还是不如直接调用方便。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n14&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;em&quot;&gt;&lt;em&gt;就是说不能为了使用设计模式而使用设计模式&lt;/em&gt;&lt;/span&gt;&lt;span md-inline=&quot;comment&quot; spellcheck=&quot;false&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 cid=&quot;n15&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;设计模式优势&lt;/span&gt;&lt;/h4&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; cid=&quot;n16&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n18&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;一般来说使用设计模式可以提高代码的三性：&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; cid=&quot;n19&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n21&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;提高代码的可重用性&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n23&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;提高代码的可读性&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n25&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;提高代码的可靠性&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;h4 cid=&quot;n26&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;事件驱动模式处理&lt;/span&gt;&lt;/h4&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n27&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n29&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;事件源：用户&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n31&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;事件：用户注册&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n33&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;事件监听器：监听到用户注册时调用奖励发放功能&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 cid=&quot;n34&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;步骤&lt;/span&gt;&lt;/h3&gt;&lt;h4 cid=&quot;n35&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;1. 建UserRegisterEvent类继承ApplicationEvent&lt;/span&gt;&lt;/h4&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;java&quot; cid=&quot;n36&quot; mdtype=&quot;fences&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt; &lt;span&gt;* 用户注册事件&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt; &lt;span&gt;*&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt; &lt;span&gt;* @author MinWeikai&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt; &lt;span&gt;* @date 2021-11-01 17:42:33&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt; &lt;span&gt;*/&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserRegisterEvent&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;ApplicationEvent&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span cm-text=&quot;&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;User&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span cm-text=&quot;&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;UserRegisterEvent&lt;/span&gt;(&lt;span&gt;Object&lt;/span&gt; &lt;span&gt;source&lt;/span&gt;, &lt;span&gt;User&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;super&lt;/span&gt;(&lt;span&gt;source&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;this&lt;/span&gt;.&lt;span&gt;user&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span cm-text=&quot;&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;User&lt;/span&gt; &lt;span&gt;getUser&lt;/span&gt;() {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span cm-text=&quot;&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setUser&lt;/span&gt;(&lt;span&gt;User&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;this&lt;/span&gt;.&lt;span&gt;user&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;h4 cid=&quot;n37&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;2. 用户注册事件发布&lt;/span&gt;&lt;/h4&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;java&quot; cid=&quot;n38&quot; mdtype=&quot;fences&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt; &lt;span&gt;* 用户注册事件发布&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt; &lt;span&gt;*&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt; &lt;span&gt;* @author MinWeikai&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt; &lt;span&gt;* @date 2021-11-01 17:45:06&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt; &lt;span&gt;*/&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserRegisterEventPublisher&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ApplicationEventPublisherAware&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span cm-text=&quot;&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;ApplicationEventPublisher&lt;/span&gt; &lt;span&gt;applicationEventPublisher&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span cm-text=&quot;&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setApplicationEventPublisher&lt;/span&gt;(&lt;span&gt;ApplicationEventPublisher&lt;/span&gt; &lt;span&gt;applicationEventPublisher&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;this&lt;/span&gt;.&lt;span&gt;applicationEventPublisher&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;applicationEventPublisher&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span cm-text=&quot;&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;publish&lt;/span&gt;(&lt;span&gt;User&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;this&lt;/span&gt;.&lt;span&gt;applicationEventPublisher&lt;/span&gt;.&lt;span&gt;publishEvent&lt;/span&gt;(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;UserRegisterEvent&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;user&lt;/span&gt;));&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;h4 cid=&quot;n39&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;3. 用户注册事件监听&lt;/span&gt;&lt;/h4&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;java&quot; cid=&quot;n40&quot; mdtype=&quot;fences&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt; &lt;span&gt;* 用户注册事件监听&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt; &lt;span&gt;*&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt; &lt;span&gt;* @author MinWeikai&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt; &lt;span&gt;* @date 2021-11-01 17:43:09&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt; &lt;span&gt;*/&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;@Slf4j&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserRegisterEventListener&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ApplicationListener&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;UserRegisterEvent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span cm-text=&quot;&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    &lt;span&gt;@SneakyThrows&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onApplicationEvent&lt;/span&gt;(&lt;span&gt;UserRegisterEvent&lt;/span&gt; &lt;span&gt;userRegisterEvent&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;User&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;userRegisterEvent&lt;/span&gt;.&lt;span&gt;getUser&lt;/span&gt;();&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;log&lt;/span&gt;.&lt;span&gt;info&lt;/span&gt;(&lt;span&gt;&quot;用户：[{}] 进行了注册，开始发放奖励&quot;&lt;/span&gt;, &lt;span&gt;user&lt;/span&gt;.&lt;span&gt;getName&lt;/span&gt;());&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;Thread&lt;/span&gt;.&lt;span&gt;sleep&lt;/span&gt;(&lt;span&gt;1000&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;log&lt;/span&gt;.&lt;span&gt;info&lt;/span&gt;(&lt;span&gt;&quot;执行发放奖品&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;Thread&lt;/span&gt;.&lt;span&gt;sleep&lt;/span&gt;(&lt;span&gt;1000&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;log&lt;/span&gt;.&lt;span&gt;info&lt;/span&gt;(&lt;span&gt;&quot;执行发放积分&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;Thread&lt;/span&gt;.&lt;span&gt;sleep&lt;/span&gt;(&lt;span&gt;1000&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;log&lt;/span&gt;.&lt;span&gt;info&lt;/span&gt;(&lt;span&gt;&quot;执行发送短信&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;Thread&lt;/span&gt;.&lt;span&gt;sleep&lt;/span&gt;(&lt;span&gt;1000&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;log&lt;/span&gt;.&lt;span&gt;info&lt;/span&gt;(&lt;span&gt;&quot;新用户奖励发放完成&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;h4 cid=&quot;n41&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;4. 测试执行&lt;/span&gt;&lt;/h4&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;java&quot; cid=&quot;n42&quot; mdtype=&quot;fences&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt; &lt;span&gt;* @author MinWeikai&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt; &lt;span&gt;* @date 2021-11-01 17:45:43&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt; &lt;span&gt;*/&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;@RunWith&lt;/span&gt;(&lt;span&gt;SpringRunner&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;@SpringBootTest&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserRegisterEventPublisherTest&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;UserRegisterEventPublisher&lt;/span&gt; &lt;span&gt;userRegisterEventPublisher&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span cm-text=&quot;&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    &lt;span&gt;@Test&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;publish&lt;/span&gt;() &lt;span&gt;throws&lt;/span&gt; &lt;span&gt;InterruptedException&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;User&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;User&lt;/span&gt;();&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;user&lt;/span&gt;.&lt;span&gt;setName&lt;/span&gt;(&lt;span&gt;&quot;君莫笑&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;userRegisterEventPublisher&lt;/span&gt;.&lt;span&gt;publish&lt;/span&gt;(&lt;span&gt;user&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;Thread&lt;/span&gt;.&lt;span&gt;sleep&lt;/span&gt;(&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;h4 cid=&quot;n43&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;5. 当有其他监听者时，如邀请人奖励发放&lt;/span&gt;&lt;/h4&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;java&quot; cid=&quot;n44&quot; mdtype=&quot;fences&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt; &lt;span&gt;* 用户注册事件邀请人监听&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt; &lt;span&gt;*&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt; &lt;span&gt;* @author MinWeikai&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt; &lt;span&gt;* @date 2021-11-01 17:43:09&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt; &lt;span&gt;*/&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;@Slf4j&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserRegisterEventInviterListener&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ApplicationListener&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;UserRegisterEvent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span cm-text=&quot;&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    &lt;span&gt;@SneakyThrows&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onApplicationEvent&lt;/span&gt;(&lt;span&gt;UserRegisterEvent&lt;/span&gt; &lt;span&gt;userRegisterEvent&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;User&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;userRegisterEvent&lt;/span&gt;.&lt;span&gt;getUser&lt;/span&gt;();&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;log&lt;/span&gt;.&lt;span&gt;info&lt;/span&gt;(&lt;span&gt;&quot;用户：[{}] 进行了注册，开始发放邀请人奖励&quot;&lt;/span&gt;, &lt;span&gt;user&lt;/span&gt;.&lt;span&gt;getName&lt;/span&gt;());&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;Thread&lt;/span&gt;.&lt;span&gt;sleep&lt;/span&gt;(&lt;span&gt;1000&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;log&lt;/span&gt;.&lt;span&gt;info&lt;/span&gt;(&lt;span&gt;&quot;邀请人奖励发放完成&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;p cid=&quot;n45&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;监听同一事件对象，业务代码相对解耦&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n46&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;原理&lt;/span&gt;&lt;/h3&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; cid=&quot;n47&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n49&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;点这个方法进去applicationEventPublisher.publishEvent&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;java&quot; cid=&quot;n50&quot; mdtype=&quot;fences&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;publishEvent&lt;/span&gt;(&lt;span&gt;Object&lt;/span&gt; &lt;span&gt;event&lt;/span&gt;, &lt;span&gt;@Nullable&lt;/span&gt; &lt;span&gt;ResolvableType&lt;/span&gt; &lt;span&gt;eventType&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span&gt;Assert&lt;/span&gt;.&lt;span&gt;notNull&lt;/span&gt;(&lt;span&gt;event&lt;/span&gt;, &lt;span&gt;&quot;Event must not be null&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span cm-text=&quot;&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span&gt;// Decorate event as an ApplicationEvent if necessary&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span&gt;ApplicationEvent&lt;/span&gt; &lt;span&gt;applicationEvent&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt; &lt;span&gt;instanceof&lt;/span&gt; &lt;span&gt;ApplicationEvent&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span&gt;applicationEvent&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; (&lt;span&gt;ApplicationEvent&lt;/span&gt;) &lt;span&gt;event&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span&gt;applicationEvent&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;PayloadApplicationEvent&lt;/span&gt;&lt;span&gt;&amp;lt;&amp;gt;&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;event&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;eventType&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span&gt;eventType&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; ((&lt;span&gt;PayloadApplicationEvent&lt;/span&gt;&lt;span&gt;&amp;lt;?&amp;gt;&lt;/span&gt;) &lt;span&gt;applicationEvent&lt;/span&gt;).&lt;span&gt;getResolvableType&lt;/span&gt;();&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span cm-text=&quot;&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span&gt;// Multicast right now if possible - or lazily once the multicaster is initialized&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.&lt;span&gt;earlyApplicationEvents&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.&lt;span&gt;earlyApplicationEvents&lt;/span&gt;.&lt;span&gt;add&lt;/span&gt;(&lt;span&gt;applicationEvent&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;            &lt;span&gt;// !! 主要看这里面 !!&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span&gt;getApplicationEventMulticaster&lt;/span&gt;().&lt;span&gt;multicastEvent&lt;/span&gt;(&lt;span&gt;applicationEvent&lt;/span&gt;, &lt;span&gt;eventType&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span cm-text=&quot;&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span&gt;// Publish event via parent context as well...&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.&lt;span&gt;parent&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.&lt;span&gt;parent&lt;/span&gt; &lt;span&gt;instanceof&lt;/span&gt; &lt;span&gt;AbstractApplicationContext&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;((&lt;span&gt;AbstractApplicationContext&lt;/span&gt;) &lt;span&gt;this&lt;/span&gt;.&lt;span&gt;parent&lt;/span&gt;).&lt;span&gt;publishEvent&lt;/span&gt;(&lt;span&gt;event&lt;/span&gt;, &lt;span&gt;eventType&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.&lt;span&gt;parent&lt;/span&gt;.&lt;span&gt;publishEvent&lt;/span&gt;(&lt;span&gt;event&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n52&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;获取事件的监听器执行&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;java&quot; cid=&quot;n53&quot; mdtype=&quot;fences&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;multicastEvent&lt;/span&gt;(&lt;span&gt;final&lt;/span&gt; &lt;span&gt;ApplicationEvent&lt;/span&gt; &lt;span&gt;event&lt;/span&gt;, &lt;span&gt;@Nullable&lt;/span&gt; &lt;span&gt;ResolvableType&lt;/span&gt; &lt;span&gt;eventType&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span&gt;ResolvableType&lt;/span&gt; &lt;span&gt;type&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; (&lt;span&gt;eventType&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; &lt;span&gt;?&lt;/span&gt; &lt;span&gt;eventType&lt;/span&gt; : &lt;span&gt;resolveDefaultEventType&lt;/span&gt;(&lt;span&gt;event&lt;/span&gt;));&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;// 如果初始化异步任务，就会异步执行每个监听器，否则就是同步执行&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span&gt;Executor&lt;/span&gt; &lt;span&gt;executor&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;getTaskExecutor&lt;/span&gt;();&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;//  此处根据事件对象获取它的所有监听器&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;ApplicationListener&lt;/span&gt;&lt;span&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span&gt;listener&lt;/span&gt; : &lt;span&gt;getApplicationListeners&lt;/span&gt;(&lt;span&gt;event&lt;/span&gt;, &lt;span&gt;type&lt;/span&gt;)) {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;executor&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span&gt;executor&lt;/span&gt;.&lt;span&gt;execute&lt;/span&gt;(() &lt;span&gt;-&amp;gt;&lt;/span&gt; &lt;span&gt;invokeListener&lt;/span&gt;(&lt;span&gt;listener&lt;/span&gt;, &lt;span&gt;event&lt;/span&gt;));&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span&gt;invokeListener&lt;/span&gt;(&lt;span&gt;listener&lt;/span&gt;, &lt;span&gt;event&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n55&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;执行UserRegisterEventListener实现的接口&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;java&quot; cid=&quot;n56&quot; mdtype=&quot;fences&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;@SuppressWarnings&lt;/span&gt;({&lt;span&gt;&quot;rawtypes&quot;&lt;/span&gt;, &lt;span&gt;&quot;unchecked&quot;&lt;/span&gt;})&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doInvokeListener&lt;/span&gt;(&lt;span&gt;ApplicationListener&lt;/span&gt; &lt;span&gt;listener&lt;/span&gt;, &lt;span&gt;ApplicationEvent&lt;/span&gt; &lt;span&gt;event&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span&gt;// 最后就是这里去执行UserRegisterEventListener实现的接口&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span&gt;listener&lt;/span&gt;.&lt;span&gt;onApplicationEvent&lt;/span&gt;(&lt;span&gt;event&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (&lt;span&gt;ClassCastException&lt;/span&gt; &lt;span&gt;ex&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span&gt;String&lt;/span&gt; &lt;span&gt;msg&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;ex&lt;/span&gt;.&lt;span&gt;getMessage&lt;/span&gt;();&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;msg&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; &lt;span&gt;||&lt;/span&gt; &lt;span&gt;matchesClassCastMessage&lt;/span&gt;(&lt;span&gt;msg&lt;/span&gt;, &lt;span&gt;event&lt;/span&gt;.&lt;span&gt;getClass&lt;/span&gt;())) {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span&gt;// Possibly a lambda-defined listener which we could not resolve the generic event type for&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span&gt;// -&amp;gt; let&#x27;s suppress the exception and just log a debug message.&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span&gt;Log&lt;/span&gt; &lt;span&gt;logger&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;LogFactory&lt;/span&gt;.&lt;span&gt;getLog&lt;/span&gt;(&lt;span&gt;getClass&lt;/span&gt;());&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;logger&lt;/span&gt;.&lt;span&gt;isTraceEnabled&lt;/span&gt;()) {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span&gt;logger&lt;/span&gt;.&lt;span&gt;trace&lt;/span&gt;(&lt;span&gt;&quot;Non-matching event type for listener: &quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;listener&lt;/span&gt;, &lt;span&gt;ex&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;ex&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;    &lt;/span&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p cid=&quot;n57&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h3 cid=&quot;n58&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;异步&lt;/span&gt;&lt;/h3&gt;&lt;h4 cid=&quot;n59&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;1. 怎么异步使用监听器&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n60&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;可以自己注入一个SimpleApplicationEventMulticaster类，给里面设置上线程即可&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;java&quot; cid=&quot;n61&quot; mdtype=&quot;fences&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt; &lt;span&gt;* 自己注入SimpleApplicationEventMulticaster，设置执行线程&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt; &lt;span&gt;*&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt; &lt;span&gt;* @author MinWeikai&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt; &lt;span&gt;* @date 2021/11/3 10:35&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt; &lt;span&gt;*/&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;MySimpleApplicationEventMulticaster&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;ThreadPoolTaskExecutor&lt;/span&gt; &lt;span&gt;taskExecutor&lt;/span&gt;() {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;ThreadPoolTaskExecutor&lt;/span&gt; &lt;span&gt;taskExecutor&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;ThreadPoolTaskExecutor&lt;/span&gt;();&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;taskExecutor&lt;/span&gt;.&lt;span&gt;setAllowCoreThreadTimeOut&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;taskExecutor&lt;/span&gt;.&lt;span&gt;setCorePoolSize&lt;/span&gt;(&lt;span&gt;5&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;taskExecutor&lt;/span&gt;.&lt;span&gt;setMaxPoolSize&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;taskExecutor&lt;/span&gt;.&lt;span&gt;setRejectedExecutionHandler&lt;/span&gt;(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;ThreadPoolExecutor&lt;/span&gt;.&lt;span&gt;DiscardOldestPolicy&lt;/span&gt;());&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;taskExecutor&lt;/span&gt;.&lt;span&gt;setThreadFactory&lt;/span&gt;(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;CustomizableThreadFactory&lt;/span&gt;(&lt;span&gt;&quot;MySimpleApplicationEventMulticaster-pool-&quot;&lt;/span&gt;));&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;taskExecutor&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span cm-text=&quot;&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;SimpleApplicationEventMulticaster&lt;/span&gt; &lt;span&gt;applicationEventMulticaster&lt;/span&gt;(&lt;span&gt;@Qualifier&lt;/span&gt;(&lt;span&gt;&quot;taskExecutor&quot;&lt;/span&gt;) &lt;span&gt;ThreadPoolTaskExecutor&lt;/span&gt; &lt;span&gt;taskExecutor&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;SimpleApplicationEventMulticaster&lt;/span&gt; &lt;span&gt;multicaster&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;SimpleApplicationEventMulticaster&lt;/span&gt;();&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;multicaster&lt;/span&gt;.&lt;span&gt;setTaskExecutor&lt;/span&gt;(&lt;span&gt;taskExecutor&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;multicaster&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span cm-text=&quot;&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;p cid=&quot;n62&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h3 cid=&quot;n63&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;总结&lt;/span&gt;&lt;/h3&gt;&lt;h4 cid=&quot;n64&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;优点&lt;/span&gt;&lt;/h4&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; cid=&quot;n65&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n67&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;从以上步骤中可以看到事件对象、事件发布、事件监听器代码相对解耦&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n69&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;当有新的业务时如邀请人事件监听，只需要添加一个事件监听器即可，无需修改原有代码。减少对现有业务的影响，相对扩展性较好&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n71&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;可以更容易开发和维护不可预知的服务或异步服务&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 cid=&quot;n72&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;缺点&lt;/span&gt;&lt;/h4&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; cid=&quot;n73&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n75&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;同一事件的监听器尽量放在同一目录，有可能会出现同一事件的不同监听器散落在不同的模块中，增加业务逻辑的复杂度&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 cid=&quot;n76&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;代码&lt;/span&gt;&lt;/h3&gt;&lt;blockquote cid=&quot;n77&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n78&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;link&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;上述代码路径 https://gitee.com/mwk719/principle_and_design/tree/master/src/main/java/com/minwk/construct/design/event&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>550e050e57f9ec84af6b63cc4a9f0eee</guid>
<title>深入理解 Git submodules</title>
<link>https://toutiao.io/k/a3oq32t</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;blockquote&gt;&lt;p&gt;&lt;em&gt;DRY原则是程序世界的基本原则之一，我们每个人在工作中都不可避免的会复用别人的代码，有可能是某个开源项目，也有可能是公司里其他团队提供的模块。Git是最流行的现代化代码版本控制工具，为了支持模块的复用，Git引入了submodule的概念，通过这篇文章，你会理解什么是git submodule以及在项目中如何应用。原文：Understanding and Working with Submodules in Git&lt;span&gt;[1]&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;大部分现代软件项目都需要依赖于他人的工作，当别人已经实现了一个很好的解决方案，就不需要再浪费时间再去实现一遍。因此很多项目都会以库或模块的形式使用第三方代码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Git是世界上最流行的版本控制系统，它提供了一种优雅、健壮的方式管理这些依赖关系。Git的“submodule”概念允许我们引用和管理第三方库，同时保持与我们自己的代码清晰的隔离。&lt;/p&gt;&lt;p&gt;在本文中，您将了解到为什么Git中的submodule能起作用、它的底层逻辑是什么以及它是如何工作的。&lt;/p&gt;&lt;h1&gt;保持代码独立&lt;/h1&gt;&lt;p&gt;为了弄清楚为什么Git的submodule很有价值，让我们先看一个没有submodule的例子。当我们需要引用第三方代码（比如开源库）的时候，最简单的办法是从GitHub下载代码，然后将其保存到自己的项目中。虽然这么做可以很快解决问题，但这么做非常丑陋，原因如下：&lt;/p&gt;&lt;p&gt;软件开发中“将不同的东西分开”的一般规则是有原因的。当然，在自己的项目中管理第三方代码也需要这样，而Git submodule的概念正是针对这些情况而设计的。&lt;/p&gt;&lt;p&gt;当然，submodule并不是解决这类问题的唯一方法，我们还可以使用许多现代语言和框架提供的各种“包管理器”系统，选择哪种依赖管理方法并没有绝对的对错之分。&lt;/p&gt;&lt;p&gt;不过，Git的submodule体系架构有以下几个优点：&lt;/p&gt;&lt;h1&gt;Git Submodule到底是什么&lt;/h1&gt;&lt;p&gt;Git中的submodule实际上只是标准的Git repository。并没有什么花哨的创新，就只是我们现在都很熟悉的Git repository而已。这也是submodule的一项优势：它们十分健壮、方便直接，因为从技术角度来说，没有任何新东西在里面，并且经过了大量现场测试的考验。&lt;/p&gt;&lt;p&gt;使Git repository成为submodule的唯一原因是它被放在了另一个父Git repository中。&lt;/p&gt;&lt;p&gt;除此之外，Git submodule仍然是一个功能完整的repository：我们可以执行所有常规的Git操作——从修改文件，一直到commit、pull和push，在submodule中都可以实现。&lt;/p&gt;&lt;h1&gt;添加一个Submodule&lt;/h1&gt;&lt;p&gt;让我们举一个典型的例子，假设我们想要向项目中添加一个第三方库，在我们获取任何代码之前，需要先创建一个单独的文件夹，作为第三方库存储的路径：&lt;/p&gt;&lt;p&gt;&lt;span aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ mkdir lib&lt;br/&gt;$ cd lib&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在，我们准备将一些第三方代码以submodule的方式注入到项目中，下面假设我们需要一个小小的“时区转换器”JavaScript库：&lt;/p&gt;&lt;p&gt;&lt;span aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ git submodule &lt;span&gt;add&lt;/span&gt; https&lt;span&gt;:&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;github&lt;span&gt;.&lt;/span&gt;com&lt;span&gt;/&lt;/span&gt;spencermountain&lt;span&gt;/&lt;/span&gt;spacetime&lt;span&gt;.&lt;/span&gt;git&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当我们运行这个命令时，Git开始将repository作为submodule克隆到我们的项目中:&lt;/p&gt;&lt;p&gt;&lt;span aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Cloning into &#x27;carparts-website/lib/spacetime&#x27;...&lt;br/&gt;remote: Enumerating objects: 7768, done.&lt;br/&gt;remote: Counting objects: 100% (1066/1066), done.&lt;br/&gt;remote: Compressing objects: 100% (445/445), done.&lt;br/&gt;remote: Total 7768 (delta 615), reused 975 (delta 588), pack-reused 6702&lt;br/&gt;Receiving objects: 100% (7768/7768), 4.02 MiB | 7.78 MiB/s, done.&lt;br/&gt;Resolving deltas: 100% (5159/5159), done.&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;看一下工作区文件夹，我们可以看到库文件实际上已经加到项目里了。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.8333333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0VTfjhRHQlS4147t1dE3CHEmRBu0VlXmSRypU0UPhhvoMicDWIMpjU353b20gNT6nibjbRCM7FNwwUg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;660&quot;/&gt;&lt;/p&gt;&lt;p&gt;你可能会问：“那有什么区别呢？”。毕竟，第三方库的文件都在这里，就像我们复制粘贴它们一样。关键的区别在于它们包含在自己的Git repository中！如果我们只是下载一些文件，将它们扔到我们的项目中，然后提交它们——就像我们项目中的其他文件一样——它们将成为同一个Git repository的一部分。然而，submodule可以确保库文件不会“泄漏”到主项目的repository中。&lt;/p&gt;&lt;p&gt;让我们看看还发生了什么：在主项目的根文件夹中创建了一个新的&lt;code&gt;.gitmodules&lt;/code&gt;文件，下面是这个文件的内容：&lt;/p&gt;&lt;p&gt;&lt;span aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;[&lt;/span&gt;submodule &lt;span&gt;&quot;lib/spacetime&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;br/&gt;  path &lt;span&gt;=&lt;/span&gt; lib&lt;span&gt;/&lt;/span&gt;spacetime&lt;br/&gt;  url &lt;span&gt;=&lt;/span&gt; https&lt;span&gt;:&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;github&lt;span&gt;.&lt;/span&gt;com&lt;span&gt;/&lt;/span&gt;spencermountain&lt;span&gt;/&lt;/span&gt;spacetime&lt;span&gt;.&lt;/span&gt;git&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个&lt;code&gt;.gitmodules&lt;/code&gt;文件是Git用来跟踪项目中的submodule的几个配置之一，另一个是&lt;code&gt;.git/config&lt;/code&gt;，它的结尾被添加了下面的配置：&lt;/p&gt;&lt;p&gt;&lt;span aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;[&lt;/span&gt;submodule &lt;span&gt;&quot;lib/spacetime&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;br/&gt;  url &lt;span&gt;=&lt;/span&gt; https&lt;span&gt;:&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;github&lt;span&gt;.&lt;/span&gt;com&lt;span&gt;/&lt;/span&gt;spencermountain&lt;span&gt;/&lt;/span&gt;spacetime&lt;span&gt;.&lt;/span&gt;git&lt;br/&gt;  active &lt;span&gt;=&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后，Git还在内部的&lt;code&gt;.git/modules&lt;/code&gt;文件夹中保存了每个子模块的&lt;code&gt;.git&lt;/code&gt;仓库的副本。&lt;/p&gt;&lt;p&gt;你不需要记住所有这些技术细节。可以看到，Git submodule的内部维护是相当复杂的，因此请记住：&lt;span&gt;千万不要手工修改Git子模块的配置！&lt;/span&gt;如果你想移动、删除或以其他方式操作子模块，请不要手动尝试。要么使用适当的Git命令，要么使用像“Tower”&lt;span&gt;[2]&lt;/span&gt;这样的Git桌面GUI，它们会处理这些细节。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.7141666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0VTfjhRHQlS4147t1dE3CHECTQ85JBWh6svM6LHVGMC7jYH9Qa8WBicqQiaV3EAicM1Z8dLlEa7ghzNw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1200&quot;/&gt;&lt;/p&gt;&lt;p&gt;现在我们已经添加了子模块，让我们看看主项目的状态：&lt;/p&gt;&lt;p&gt;&lt;span aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ git status&lt;br/&gt;On branch master&lt;br/&gt;Changes to be committed&lt;span&gt;:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;(&lt;/span&gt;use &lt;span&gt;&quot;git restore --staged &amp;lt;file&amp;gt;...&quot;&lt;/span&gt; to unstage&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;new&lt;/span&gt; file&lt;span&gt;:&lt;/span&gt;   &lt;span&gt;.&lt;/span&gt;gitmodules&lt;br/&gt;  &lt;span&gt;new&lt;/span&gt; file&lt;span&gt;:&lt;/span&gt;   lib&lt;span&gt;/&lt;/span&gt;spacetime&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如您所见，Git将添加submodule视为与其他任何更改一样的更改。因此，我们必须像其他任何更改一样提交此次更改：&lt;/p&gt;&lt;p&gt;&lt;span aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ git commit &lt;span&gt;-&lt;/span&gt;m &lt;span&gt;&quot;Add timezone converter library as a submodule&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1&gt;克隆一个含有submodule的项目&lt;/h1&gt;&lt;p&gt;在上面的示例中，我们向现有的Git repository添加了一个新的submodule。但是，反过来，当我们需要克隆一个已经包含submodule的仓库时，又会怎么样呢？&lt;/p&gt;&lt;p&gt;如果我们执行普通的&lt;code&gt;git clone &amp;lt;remote-URL&amp;gt;&lt;/code&gt;，将会下载主项目，但任何submodule文件夹都是空的！这再次生动的证明了submodle文件是独立的，不包含在它们的父仓库中。&lt;/p&gt;&lt;p&gt;在这种情况下，要在克隆了父仓库之后填充submodule，可以简单地执行&lt;code&gt;git submodule update --init --recursive&lt;/code&gt;。不过更好的方法是在调用&lt;code&gt;git clone&lt;/code&gt;时直接添加&lt;code&gt;--recurse-submodules&lt;/code&gt;选项。&lt;/p&gt;&lt;h1&gt;使用特定版本&lt;/h1&gt;&lt;p&gt;在普通的Git仓库中，我们通过使用&lt;code&gt;git checkout &amp;lt;branchname&amp;gt;&lt;/code&gt;或者在Git 2.23引入的&lt;code&gt;git switch &amp;lt;branchname&amp;gt;&lt;/code&gt;，告诉git当前活动的分支是什么。当在这个分支上进行新的提交时，HEAD指针会自动移动到最近的提交。理解这一点很重要——因为Git submodule的工作方式不太一样！&lt;/p&gt;&lt;p&gt;在submodule中，我们总是签出一个特定的版本——而不是一个分支！即使在submodule中执行&lt;code&gt;git checkout main&lt;/code&gt;这样的命令，在后台，也只会把该分支上当前最新的提交记录下来，而不会改变分支本身的内容。&lt;/p&gt;&lt;p&gt;这并不是系统错误，而是有意设计的。考虑一下：当我们引用第三方库时，希望完全控制在主项目中使用的确切代码。当库的维护者发布一个新版本（这当然很好），我们不一定希望这个新版本立马被应用到项目中，因为我们还不知道这些新的更改是否会破坏我们的项目！&lt;/p&gt;&lt;p&gt;如果想知道项目中的子模块使用的是什么版本，可以在主项目中查看以下信息：&lt;/p&gt;&lt;p&gt;&lt;span aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ git submodule status&lt;br/&gt;   ea703a7d557efd90ccae894db96368d750be93b6 lib&lt;span&gt;/&lt;/span&gt;spacetime &lt;span&gt;(&lt;/span&gt;&lt;span&gt;6.16&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面显示了&lt;code&gt;lib/spacetime&lt;/code&gt;子模块当前签出的版本，它还告诉我们这个版本是基于一个名为“6.16.3”的tag。在Git中处理submodule时，经常会使用tag。&lt;/p&gt;&lt;p&gt;要是我们希望submodule使用tag为“6.14.0”的旧版本。首先，我们必须更改目录，以便在子模块的上下文中执行Git命令。然后，我们可以基于tag执行git checkout：&lt;/p&gt;&lt;p&gt;&lt;span aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ cd lib&lt;span&gt;/spacetime/&lt;/span&gt;&lt;br/&gt;$ git checkout &lt;span&gt;6.14&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Previous&lt;/span&gt; &lt;span&gt;HEAD&lt;/span&gt; position was ea703a7 &lt;span&gt;Merge&lt;/span&gt; pull request &lt;span&gt;#301 from spencermountain/dev&lt;/span&gt;&lt;br/&gt;&lt;span&gt;HEAD&lt;/span&gt; is now at &lt;span&gt;7&lt;/span&gt;f78d50 &lt;span&gt;Merge&lt;/span&gt; pull request &lt;span&gt;#268 from spencermountain/dev&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果我们回到主项目，再次执行&lt;code&gt;git submodule status&lt;/code&gt;，我们会看到：&lt;/p&gt;&lt;p&gt;&lt;span aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ cd &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;br/&gt;$ git submodule status&lt;br/&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;f78d50156ae1205aa50675ddede81a61a45fade lib&lt;span&gt;/&lt;/span&gt;spacetime &lt;span&gt;(&lt;/span&gt;&lt;span&gt;6.14&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;仔细看一下输出：SHA-1哈希值前面的小&lt;code&gt;+&lt;/code&gt;符号告诉我们，submodule的版本与当前存储在父仓库中的版本不同。由于我们刚刚更改了已签出的版本，因此这是正常的。&lt;/p&gt;&lt;p&gt;在主项目中调用&lt;code&gt;git status&lt;/code&gt;也会告诉我们这个事实：&lt;/p&gt;&lt;p&gt;&lt;span aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ git status&lt;br/&gt;On branch master&lt;br/&gt;Changes not staged &lt;span&gt;for&lt;/span&gt; commit&lt;span&gt;:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;(&lt;/span&gt;&lt;span&gt;use&lt;/span&gt; &lt;span&gt;&quot;git add &amp;lt;file&amp;gt;...&quot;&lt;/span&gt; to update what will &lt;span&gt;be&lt;/span&gt; committed&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;(&lt;/span&gt;&lt;span&gt;use&lt;/span&gt; &lt;span&gt;&quot;git restore &amp;lt;file&amp;gt;...&quot;&lt;/span&gt; to discard changes &lt;span&gt;in&lt;/span&gt; working directory&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;  modified&lt;span&gt;:&lt;/span&gt;   lib&lt;span&gt;/&lt;/span&gt;&lt;span&gt;spacetime&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;new commits&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到，Git认为移动submodule的指针和其他变化一样：如果我们保存这个改动，就必须提交到仓库里：&lt;/p&gt;&lt;p&gt;&lt;span aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ git commit &lt;span&gt;-&lt;/span&gt;m &lt;span&gt;&quot;Changed checked out revision in submodule&quot;&lt;/span&gt;&lt;br/&gt;$ git push&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1&gt;更新Git Submodule&lt;/h1&gt;&lt;p&gt;在上面的步骤中，是我们移动了submodule指针：我们选择签出一个不同的修订，提交它，并将它推送到团队的远程仓库中。但如果我们的一个同事更改了submodule的修订——可能是因为子模块发布了一个有趣的新版本，而我们决定在项目中使用它（当然是在彻底测试之后……）。&lt;/p&gt;&lt;p&gt;我们在主项目中做一个简单的&lt;code&gt;git pull&lt;/code&gt;——我们可能会经常这么做——从共享远程仓库中获得新的更改：&lt;/p&gt;&lt;p&gt;&lt;span aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ git pull&lt;br/&gt;From https&lt;span&gt;:&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;github&lt;span&gt;.&lt;/span&gt;com&lt;span&gt;/&lt;/span&gt;gntr&lt;span&gt;/&lt;/span&gt;git&lt;span&gt;-&lt;/span&gt;crash&lt;span&gt;-&lt;/span&gt;course&lt;br/&gt;   d86f6e0&lt;span&gt;..&lt;/span&gt;055333e  main       &lt;span&gt;-&amp;gt;&lt;/span&gt; origin&lt;span&gt;/&lt;/span&gt;main&lt;br/&gt;Updating d86f6e0&lt;span&gt;..&lt;/span&gt;055333e&lt;br/&gt;Fast&lt;span&gt;-&lt;/span&gt;forward&lt;br/&gt;   lib&lt;span&gt;/&lt;/span&gt;spacetime &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;1&lt;/span&gt; file changed&lt;span&gt;,&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;insertion&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;deletion&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;倒数第二行表示子模块中的某些内容已被更改，让我们仔细看看：&lt;/p&gt;&lt;p&gt;&lt;span aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ git submodule status&lt;br/&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;f78d50156ae1205aa50675ddede81a61a45fade lib&lt;span&gt;/&lt;/span&gt;spacetime &lt;span&gt;(&lt;/span&gt;&lt;span&gt;6.14&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我相信你还记得那个小&lt;code&gt;+&lt;/code&gt;号：它表示submodule指针被移动了！要将本地签出的版本更新为我们的团队成员选择的“官方”版本，可以运行&lt;code&gt;update&lt;/code&gt;命令：&lt;/p&gt;&lt;p&gt;&lt;span aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ git submodule update lib&lt;span&gt;/&lt;/span&gt;spacetime &lt;br/&gt;&lt;span&gt;Submodule&lt;/span&gt; path &lt;span&gt;&#x27;lib/spacetime&#x27;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;checked&lt;/span&gt; &lt;span&gt;out&lt;/span&gt; &lt;span&gt;&#x27;5e3d70a88180879ae0222b6929551c41c3e5309e&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;好了！我们签出了主项目仓库中记录的submodule版本！&lt;/p&gt;&lt;h1&gt;在工作中使用Git Submodule&lt;/h1&gt;&lt;p&gt;我们已经介绍了使用Git submodule的基本概念，其他工作流程是相当标准的。&lt;/p&gt;&lt;p&gt;例如，&lt;span&gt;检查子模块中新的更改&lt;/span&gt;的工作方式与其他任何Git repository类似：在submodule repository中运行&lt;code&gt;git fetch&lt;/code&gt;命令，如果你确实想要使用这些更新，可能会接着执行类似&lt;code&gt;git pull origin main&lt;/code&gt;的命令。&lt;/p&gt;&lt;p&gt;如果是自己管理的内部代码库，那也可能需要&lt;span&gt;在子模块中进行更改&lt;/span&gt;。可以像处理任何其他Git仓库一样处理submodule：可以进行更改、提交更改、推送更改等等。&lt;/p&gt;&lt;h1&gt;使用Git的全部功能&lt;/h1&gt;&lt;p&gt;在表面简单的命令下面，Git提供了很强大的功能。但是它的许多高级工具——比如Git submodule——并不为人所知。这么多开发人员错过了很多强大的东西，这真是太遗憾了！&lt;/p&gt;&lt;p&gt;如果你想深入了解其他一些先进的Git技术，强烈推荐一个免费短视频合集：“Advanced Git Kit”&lt;span&gt;[3]&lt;/span&gt;，你可以学到Reflog、Interactive Rebase、Cherry-Picking，甚至分支策略等主题。&lt;/p&gt;&lt;p&gt;祝你成为一个更好的开发者！&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;References:&lt;/span&gt;&lt;br/&gt;[1] https://www.sitepoint.com/git-submodules-introduction/&lt;br/&gt;[2] https://www.git-tower.com/?utm_source=sitepoint&amp;amp;utm_medium=guestpost&amp;amp;utm_campaign=git-submodules&lt;br/&gt;[3] https://www.git-tower.com/learn/git/advanced-git-kit?utm_source=sitepoint&amp;amp;utm_medium=guestpost&amp;amp;utm_campaign=git-submodules&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;你好，我是俞凡，在Motorola做过研发，现在在Mavenir做技术工作，对通信、网络、后端架构、云原生、DevOps、CICD、区块链、AI等技术始终保持着浓厚的兴趣，平时喜欢阅读、思考，相信持续学习、终身成长，欢迎一起交流学习。&lt;br/&gt;微信公众号：DeepNoMind&lt;/p&gt;&lt;/blockquote&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8a14d96237cbc8e97b893f805ac68d9c</guid>
<title>醒图基于数据驱动的性能防劣化实践</title>
<link>https://toutiao.io/k/0wj0ju2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000879&quot; data-height=&quot;163&quot; data-ratio=&quot;0.18757192174913695&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3fqDBTibjogz3SaibwOTvoBxiaibUWzJGOBVYqS4gMAqSgSv9KiaMIIiaV0tFOefbII6zxX3Z03aJD0McGfzsymN70Cw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;869&quot; data-width=&quot;869&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;零 、醒图的性能窘境&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;醒图业务流量急剧上升，发展速度很快；醒图模板功能上线后，激发了广大创作者的创作热情，也为产品运营提供更丰富的抓手。在APP版本高速迭代之际，随着DAU提升与后期发布模板功能逐步开放，丰富多样的玩法也对性能测试提出了新的挑战：&lt;/span&gt;&lt;/p&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;底层模块升级或重构，需要回归的场景非常多，怎么能快速知道众多场景的性能指标是否有劣化趋势？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;今天又上了几百个新模版，但昨天的前天的大前天的模板还有待审核的，人工性能回归速度远远跟不上模版的发布速度，捉鸡啊&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;每个模板对应的素材都不一样，有人脸的有人体的，素材和模版的交叉验证工作量好大啊&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;每次新发一个Release版本，都需要对核心场景进行性能回归&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;目前常用的基于UI或其他方式执行的性能测试，并不适用于醒图的性能验收方式&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1&gt;&lt;br/&gt;&lt;/h1&gt;&lt;h1&gt;&lt;span&gt;一 、 Easy 简单易上手的性能解法&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;基于以上背景，eTest针对醒图这种需要对多种素材和多种模版进行交叉测试的场景设计了一种基于数据驱动的性能防劣化解决方案，覆盖安卓、iOS主流机型，高效、实时定位APP性能、模板劣化问题。提供丰富的测试报告反馈用户测试结果、性能报告、设备分析；还可以通过点击测试截图，查看错误日志，还原测试过程。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;1.1. 迭代模型&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;结合研发的版本迭代周期模型，我们提供了一套简单易上手的解决方案。遵从版本研发-自动化测试-结果分析-性能优化的研发迭代流程，开发完成版本研发后，QA同学可以使用提前准备好的测试素材（包括图片、场景等），手动启动一次自动化测试，也可以选择每天定期对测试包进行测试，自动化测试执行完成后，eTest会结合历史基准版本结果和QA同学预先配置好的规则红线进行结果分析，对于不符合预期的测试结果进行分级并生成测试报告，QA同学根据测试报告进行分析并将发现的问题反馈给开发进行性能优化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000877&quot; data-height=&quot;492&quot; data-ratio=&quot;0.7058823529411765&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3fqDBTibjogz3SaibwOTvoBxiaibUWzJGOBVorZv7acQKwicfNQOvHmNFLmpfuEroI4fBgJtsAXMlZicB01JdOe2jLJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;697&quot; data-width=&quot;697&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如上图所示，醒图的性能自动化流程主要分为以下几步：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、版本研发：&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;开发同学按照日常迭代节奏进行版本研发，用户可以在eTest自动化测试平台上按Release包、CommitId或指定版本生成对应的测试包进行测试；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、素材管理：&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;用户可以提前在eTest自动化测试平台准备好测试用例（即有测试图片和测试场景的测试用例），用户可以使用分类对以上测试素材进行分类管理，并通过分类选择批量自动生成基准测试用例，便于后续启动自动化时使用；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、自动化：&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;用户可以选择手动或定期启动，任务启动后，eTest自动化测试平台会根据任务启动时的配置，将任务分配给对应的Jenkins/云构建服务进行执行，自动化测试worker再根据任务配置使用相应的测试机进行测试；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4、结果处理：&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;自动化任务执行完成后，会将收集到的原始性能数据上报到eTest自动化测试平台，eTest自动化测试平台再根据历史基准版本的测试结果 和由用户事先配置好的规则红线，对测试结果进行分级，生成测试报告&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;5、测试报告：&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;任务执行完成后，eTest自动化测试平台会生成一份包含测试包信息、基准版本比较和性能结果分级的报告，方便用户进行劣化分析；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;6、监控告警：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;任务执行完成后，会将任务结果通过飞书告知任务创建人。&lt;/span&gt;&lt;strong/&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;1.2. 执行流程&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;了解了醒图的性能自动化整体模型之后，接下来详细介绍一下具体的自动化执行流程，如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000881&quot; data-height=&quot;1186&quot; data-ratio=&quot;0.494991652754591&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3fqDBTibjogz3SaibwOTvoBxiaibUWzJGOBV6YQUfIBiaqpKXeex5EDPRbe0M0YKX4c5UyWvuFJtIZHoKJ2vUtVDN8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2396&quot; data-width=&quot;2396&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当用户出发启动任务之后，eTest会根据启动任务时传入的配置参数，生成相应的子任务（安装包打包、申请测试机、性能自动化），并在上游任务执行完毕后，自动串行调用下一任务。在安装包打包阶段，打包子任务会判断当前版本的包是否已经打包过了，如果已经打包过了，则会跳过打包阶段，直接返回包信息；否则进入打包流程。在申请测试机阶段，会根据用户在启动任务时选择的资源池进行申请占用，如果有其他任务正占用了资源，则会持续等待直到资源释放。当其他前置任务结束后，会开始执行性能自动化测试任务，性能自动化子任务会先将打包阶段的安装包安装到执行机上，然后获取指定用例集进行执行，最终上报结果，由服务端进行结果处理和入库。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;1.3. 基础功能&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;h6&gt;&lt;span&gt;测试机管理&lt;/span&gt;&lt;/h6&gt;&lt;/li&gt;&lt;li&gt;&lt;h6&gt;&lt;span&gt;素材&amp;amp;场景管理&lt;/span&gt;&lt;/h6&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;多层级设置，管理方便&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;可根据业务需求灵活添加测试场景&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;h6&gt;&lt;span&gt;生成用例&lt;/span&gt;&lt;/h6&gt;&lt;/li&gt;&lt;li&gt;&lt;h6&gt;&lt;span&gt;启动任务&lt;/span&gt;&lt;/h6&gt;&lt;/li&gt;&lt;li&gt;&lt;h6&gt;&lt;span&gt;查看报告&lt;/span&gt;&lt;/h6&gt;&lt;/li&gt;&lt;li&gt;&lt;h6&gt;&lt;span&gt;任务结果及时反馈&lt;/span&gt;&lt;/h6&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1&gt;&lt;br/&gt;&lt;/h1&gt;&lt;h1&gt;&lt;span&gt;二、Efficiency 有效的性能效果&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;2.1. 执行效率&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;eTest自动化测试平台支持将一个自动化任务分为多个阶段，阶段间按顺序串行执行，一个流程内可以并行执行多个子任务。如下图所示，一个性能自动化任务分为两个阶段，分别为打包阶段和自动化执行阶段。在打包阶段，可以并行执行多个版本的打包任务，也可以执行多个平台的打包任务。在自动化执行阶段，当依赖的上游打包任务完成之后，则会开始申请测试机器，并执行相应的自动化任务。因为灵活的任务编排方式和并串行执行方式，可以灵活地调度测试任务资源，达到提高执行效率的目的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000880&quot; data-height=&quot;936&quot; data-ratio=&quot;0.4469914040114613&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3fqDBTibjogz3SaibwOTvoBxiaibUWzJGOBVdQkicBvDmNuSMTl4681d65aUqII1ZQXkhjUBFaaFpIzkqUqsFdzZHPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2094&quot; data-width=&quot;2094&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;eTest的执行效率提升不仅体现在灵活的任务调度上，也体现在独立的打包服务上。我们摒弃在传统流水线上增加打包任务的方式，而是将打包过程服务化，提供通用的打包接口，支持流水线通过不同的参数调用接口触发打包任务，打包完成后则返回结果包。统一进行包管理，简化了打包流程，支持不同的自动化任务使用。同时打包服务会进行去重判定，如果多个打包任务实际上是针对相同版本或者代码进行打包的话，打包服务会进行去重，仅进行一次打包即可满足多个打包任务的需求，后续相同的打包请求也会直接使用已有包，这大大减少了安装包的打包次数和耗时。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000878&quot; data-height=&quot;144&quot; data-ratio=&quot;0.1978021978021978&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3fqDBTibjogz3SaibwOTvoBxiaibUWzJGOBVaNnvjiclerKfzBz9XAia8bXiczBrOts5m1hXmSk7N4ajMX2QWTnEkaTiaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;728&quot; data-width=&quot;728&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在近214次打包任务中，有138次打包任务命中了去重策略，命中率高达64.5%，平均节省执行时间34.7分钟。另外，打包服务将所有自动化打包任务整体迁移到ies jenkins平台，解决平台以及机器不稳定导致的jenkins整体崩溃，从之前的2次/周降为0次。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;2.2. 节省人力，提升人效&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;根据醒图测试同学的反馈，目前醒图性能自动化测试在新版本回归、重大重构回归和单功能场景回归等测试场景均能显著减少测试人力投入。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000886&quot; data-height=&quot;112&quot; data-ratio=&quot;0.19112627986348124&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3fqDBTibjogz3SaibwOTvoBxiaibUWzJGOBVDpBYkY4WUULauZ8QcI9CPj1ibootw1DpE1Y0znhDGfOoeibzwznHttug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;586&quot; data-width=&quot;586&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;2.3. 发现典型问题&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;案例：**优化需求，应用全功能模板内存有明显增长&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;问题说明：Android 使用全功能模板后内存比线上大接近100M&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;醒图导入4k图片后，应用全功能模板，稳定后内存比线上接近大100M&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;问题原因：painter坐标系统重构需求，多生成一些纹理未及时释放，同时导致了卡顿的场景&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;br/&gt;&lt;/h1&gt;&lt;h1&gt;&lt;span&gt;三、Elastic 灵活可配的自动化&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;3.1. 测试物料统一管理，用例生成灵活可配&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;图片素材和自动化场景均可以根据分类进行灵活地区分；在新建用例时，根据分类选定一类素材和场景，进行批量生产基准用例；进而选用多个用例形成一个测试用例集，供测试执行使用。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;3.2. 规则条件高度自定义，关联用例精度可控&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;用户可以根据不同的性能指标，配置对应的分级判定条件以及版本对比条件，然后对多个指标的判定条件进行组合配置，生成对应的规则。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;例如：我们可以为内存峰值这个性能指标配置不同的告警条件，当相对对比版本内存峰值超过20时，则认为不符合预期，并详细设置了不同阈值对应的级别关系。当我们设置了条件，则可以根据条件设置不同的规则。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于以上条件和规则的设定，我们可以对基准用例设置整个用例级别的告警规则，也可以针对某个场景操作设置告警规则。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;3.3. 执行流程可灵活编排，增删节点可按需调整&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;eTest自动化测试流程支持测试任务灵活编排子任务节点，可以根据任务需要，进行任务节点的增删，灵活适配不同的自动化测试场景。&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;br/&gt;&lt;/h1&gt;&lt;h1&gt;&lt;span&gt;四、Enormous 无限可能的自动化体系&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;eTest自动化测试平台所有的自动化任务执行流程都是基于如下图所示的通用任务workflow体系。启动方式可以是由用户手动触发、定时任务触发或者其他方式通过接口触发等，当启动任务后，eTest则会根据传入的配置参数生成一个Job任务，并由Job任务指定的多个Process阶段生成对应的Task子任务。Task子任务可以自由灵活地进行串行或并行的编排，最后由eTest自动化测试平台的任务调度模块统一控制任务的调度与执行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000885&quot; data-height=&quot;892&quot; data-ratio=&quot;0.39857015192135836&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3fqDBTibjogz3SaibwOTvoBxiaibUWzJGOBVj5TvzcNqa7QSneufgIkicZDCdOsiaY1pjhmNZp6mIfnSk6rlhhIbcTsw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2238&quot; data-width=&quot;2238&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于以上任务调度流程，我们可以根据业务需求任意编排自动化任务的执行阶段，复用其他自动化任务。同时我们也可以对每个阶段的服务进行深入挖掘，例如，我们在基础的图片场景管理功能上，进一步提供了批量生成基准用例的功能（如下图）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000884&quot; data-height=&quot;318&quot; data-ratio=&quot;0.496875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3fqDBTibjogz3SaibwOTvoBxiaibUWzJGOBVnWtiaEwWib5454gBVCc5EznibPJiaREU5EMiaE51LcClmnszAia32o2YkNgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot; data-width=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们将原本功能单一的自动化任务逐一丰富功能，逐步深入挖掘体验提升点，最终提供完整的测试自动化服务。如下图所示，我们基于基础的性能自动化任务，增加自动化性能指标分析和规则管理，整合所有测试资源，为醒图量身定制了一套完整的性能自动化服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000882&quot; data-height=&quot;355&quot; data-ratio=&quot;0.44154228855721395&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3fqDBTibjogz3SaibwOTvoBxiaibUWzJGOBVmQNxIvaKxhbiatmI9hRYIHicsoOkJPdgmT7bCxeic30gNib9gkkGxZutZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;804&quot; data-width=&quot;804&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当前的自动化体系，除了已经接入醒图业务之外，也正在适配轻颜和剪映的性能防劣化应用。而适配成本也很低，只需要捋清楚各个业务自动化执行的数据素材和用例生成规则即可以完成服务端的适配；而自动化执行方面，则需要在客户端适配用例生成的协议，驱动用例执行并收集性能数据进行上报。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000883&quot; data-height=&quot;287&quot; data-ratio=&quot;0.5694444444444444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3fqDBTibjogz3SaibwOTvoBxiaibUWzJGOBVu9Z90GQDLtfy2u9mTP3B5phwUbyRGVTPxSUia3tI9Rt3r26xnhFOwbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;504&quot; data-width=&quot;504&quot;/&gt;&lt;/p&gt;&lt;h1/&gt;&lt;h1&gt;&lt;br/&gt;&lt;/h1&gt;&lt;h1&gt;&lt;span&gt;终&lt;/span&gt;&lt;span/&gt;&lt;span&gt;、结语&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;eTest自动化测试平台针对醒图的性能测试需求，设计了一套基于数据的性能自动化解决方案。主要围绕着醒图的性能自动化测试流程，补充了测试物料管理的相关功能和规则配置管理功能，提供了完整的性能自动化解决方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;加入我们&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;字节跳动互娱研发效能团队，互娱研发负责抖音、抖音火山版、剪映、FaceU、轻颜、直播、音乐等多款明星产品的研发，目前，抖音日活（DAU）已经突破 6 亿。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;研发效能团队主打服务化+智能化，旨在通过工具平台+算法，赋能互娱的各个业务场景，团队职能包括但不限于提升研发效能，保证内容质量，优化用户体验，保障业务安全等。团队拥有算法，工程（前端、后台以及客户端）、数据（大数据、DA）、产品、测试等多种职能岗位，可以高效自闭环进行智能平台产品的设计研发，具有多个公司级影响力的智能化平台产品成功落地经验。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;团队发展迅速，年轻富有朝气，注重技术氛围建设，积极参与国内外各顶尖行业技术会议，输出高质量技术专利和相关论文，工作 Base 地有深圳、杭州、广州、北京多地可选。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;加入我们，让你的每一行代码都能服务亿万用户。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;简历投递邮箱：iesep@bytedance.com；邮件标题：姓名 - 职能/技术栈 - 研发效能。&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>