<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>b93b512443ed8f91b10007c6fa41f47e</guid>
<title>秋天的第一份 IT 技术周刊 | 码农周刊第 320 期</title>
<link>https://toutiao.io/k/9ew44gv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;issue&quot; id=&quot;readabilityBody&quot;&gt;
        &lt;h1&gt;秋天的第一份 IT 技术周刊 | 码农周刊第 320 期&lt;/h1&gt;
        &lt;h2&gt;码农周刊第320期（2020-09-29）&lt;/h2&gt;
        &lt;p&gt;☞ &lt;a href=&quot;https://weekly.manong.io/bounce?nid=320&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3200&quot; target=&quot;_blank&quot;&gt;秋天的第一份 IT 技术周刊，请查收！&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;a href=&quot;https://weekly.manong.io/bounce?nid=320&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3200&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_320.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;small&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=320&amp;amp;aid=19185&amp;amp;url=https%3A%2F%2Fjinshuju.net%2Ff%2FV7DxN9&quot; target=&quot;_blank&quot;&gt;商务合作&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
        
        &lt;h3 id=&quot;程序设计&quot;&gt;程序设计&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;业界实战&lt;/p&gt;
        
        &lt;p&gt;思考和实践&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;VIP会员专区&quot;&gt;VIP会员专区&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;工作地点：成都 | 薪资：15-30K | 简历投递邮箱：xiexiaofang@huobi.com&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;由 JavaScript 之父 Brendan Eich 与 ES6 规范首席作者 Allen Wirfs-Brock 联合编写，详细记载和解读了自 1995 年语言诞生到 2015 年 ES6 规范制定为止，共计 20 年的 JavaScript 语言演化经历。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;支持 mp4, flv, m3u8 及 rtmp 协议的直播，支持移动端，PC 端。&lt;/p&gt;
        &lt;h3 id=&quot;工具资料&quot;&gt;工具资料&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;利器&lt;/p&gt;
        
        &lt;p&gt;实打实的干货&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;容易踩的坑&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;图文并茂&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;细致分析&lt;/p&gt;
        
        &lt;p&gt;方案和思路&lt;/p&gt;
        
        &lt;p&gt;一些实践和工具&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程语言&quot;&gt;编程语言&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;报告详情&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;深入探讨&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;结合代码&lt;/p&gt;
        &lt;h3 id=&quot;每周独家号推荐&quot;&gt;每周独家号推荐&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;java相关技术分享&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 444692 即可&lt;/p&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 444414 即可&lt;/p&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 435415 即可&lt;/p&gt;
        
        &lt;p&gt;不定期更新一些机器学习算法，方便大家浏览，然后一起学习，一起进步&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 104739 即可&lt;/p&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 99181 即可&lt;/p&gt;
        &lt;h3 id=&quot;每周一书&quot;&gt;每周一书&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;本书深入地讲解了 Go 语言常见特性的内部机制和实现方式，大部分内容源自对 Go 语言源码的分析，并从中提炼出实现原理。欢迎到&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;兑换阅读。&lt;/p&gt;
        &lt;h3 id=&quot;编程之外&quot;&gt;编程之外&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;值得推荐&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;无代码开发平台&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;p&gt;
        &lt;/p&gt;
        
        
        
        
        &lt;div class=&quot;qrcode&quot;&gt;
  &lt;img src=&quot;https://img.toutiao.io/ads/vip_qrcode.png&quot; alt=&quot;Qrcode 258&quot;/&gt;&lt;span&gt;加入码农周刊VIP会员&lt;/span&gt;
&lt;/div&gt;
    &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bde832b7e7d856cf90275bb2f3e8331a</guid>
<title>45 张图庖丁解牛 18 种 Queue，你知道几种？</title>
<link>https://toutiao.io/k/fvryjlb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在讲&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwMjI0ODk0NA==&amp;amp;mid=2451944303&amp;amp;idx=1&amp;amp;sn=6fc5a3198e4216eed667a26648028b71&amp;amp;chksm=8d1c4af0ba6bc3e6c5b4638c8e33deac79f8646343a03ba44e10dcb14a0eeb7095f437e9c554&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《集合的线程不安全》&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《21张图讲解集合的线程不安全》&lt;/a&gt;那一篇，我留了一个彩蛋，就是&lt;span&gt;&lt;strong&gt;Queue（队列）&lt;/strong&gt;&lt;/span&gt;还没有讲，这次我们重点来看看Java中的Queue家族，总共涉及到&lt;strong&gt;18&lt;/strong&gt;种Queue。这篇恐怕是市面上&lt;span&gt;&lt;strong&gt;最全最细&lt;/strong&gt;&lt;/span&gt;讲解Queue的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本篇主要内容如下：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9628712871287128&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJhNWArwClvXEychM1SLu16haahZJutLlwmmNLdlICS0mOCst9z1SZYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;808&quot;/&gt;&lt;figcaption&gt;本篇主要内容&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;帮你总结好的阻塞队列：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8221830985915493&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJk9SYIaS9gMG3vSJeTVaZJ0rRQp4d1dbgU5YlrQXsM2Ha5z02bnYAZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;568&quot;/&gt;&lt;figcaption&gt;18种Queue总结&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一、Queue自我介绍&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3476764199655766&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJZwicYhUaj40hMochInxf003SmMGtLQb5afaOZ0juicy2PT5ESicpYKw7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;581&quot;/&gt;&lt;figcaption&gt;队列原理图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1 Queue自我介绍&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;hi，大家好，我的英文名叫&lt;code&gt;Queue&lt;/code&gt;，中文名叫&lt;code&gt;队列&lt;/code&gt;，无论现实生活中还是计算机的世界中，我都是一个很重要的角色哦~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我是一种&lt;code&gt;数据结构&lt;/code&gt;，大家可以把我想象成一个数组，元素从我的一头进入、从另外一头出去，称为FIFO原则（先进先出原则）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我还有两个亲兄弟：&lt;code&gt;List&lt;/code&gt;（列表）、&lt;code&gt;Set&lt;/code&gt;（集），他们都是&lt;code&gt;Collection&lt;/code&gt;的儿子，我还有一个远房亲戚：&lt;code&gt;Map&lt;/code&gt;（映射）。他们都是&lt;code&gt;java.util&lt;/code&gt;包这个大家庭的成员哦~&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2 现实生活中的场景&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;海底捞排号等位（先排号的优先进餐厅）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;邮政员寄送信件（信箱是队列）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.3 计算机世界中的场景&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;消息队列 RabbitMQ&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;UDP协议（接收端将消息存放在队列中，从队列中读取数据）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二、高屋建瓴，纵览全局&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;18种队列分为三大类：&lt;/strong&gt; 接口、抽象类、普通类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;弄清楚下面的继承实现关系对后面理解18种队列有很大帮助。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4917946003176284&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJibwxGsgkDzdicE71NGtiaYTurP4uq2TvvOytNDEYzxvreJ2UKUI8q8SUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1889&quot;/&gt;&lt;figcaption&gt;18个Queue的继承实现关系图&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Queue&lt;/code&gt;接口&lt;strong&gt;继承&lt;/strong&gt; &lt;code&gt;Collection&lt;/code&gt;接口，&lt;code&gt;Collection&lt;/code&gt;接口&lt;strong&gt;继承&lt;/strong&gt;  &lt;code&gt;Iterable&lt;/code&gt;接口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;BlockingQueue&lt;/code&gt;接口、&lt;code&gt;Deque&lt;/code&gt;接口 &lt;strong&gt;继承&lt;/strong&gt; &lt;code&gt;Queue&lt;/code&gt;接口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;AbstractQueue&lt;/code&gt;抽象类&lt;strong&gt;实现&lt;/strong&gt; &lt;code&gt;Queue&lt;/code&gt;接口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;BlockingDeque&lt;/code&gt;接口、&lt;code&gt;TransferQueue&lt;/code&gt;接口&lt;strong&gt;继承&lt;/strong&gt; &lt;code&gt;BlockingQueue&lt;/code&gt;接口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;BlockingDeque&lt;/code&gt;接口继承&lt;code&gt;Deque&lt;/code&gt;接口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;LinkedBlockingDeque&lt;/code&gt;类&lt;strong&gt;实现&lt;/strong&gt; &lt;code&gt;BlockingDeque&lt;/code&gt;接口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;LinkedTransferQueue&lt;/code&gt;类接口&lt;strong&gt;实现&lt;/strong&gt; &lt;code&gt;TransferQueue&lt;/code&gt;接口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;LinkedList&lt;/code&gt;类、&lt;code&gt;ArrayDeque&lt;/code&gt;类、&lt;code&gt;ConcurrentLinkedDeque&lt;/code&gt;类&lt;strong&gt;实现&lt;/strong&gt; 了&lt;code&gt;Deque&lt;/code&gt;接口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ArrayBlockingQueue&lt;/code&gt;类、&lt;code&gt;LinkendBlockingQueue&lt;/code&gt;类、&lt;code&gt;LinkedBlockingDeque&lt;/code&gt;类、&lt;code&gt;LinkedTransferQueue&lt;/code&gt;类、&lt;code&gt;SynchronousQueue&lt;/code&gt;类、&lt;code&gt;PriorityBlockQueue&lt;/code&gt;类、&lt;code&gt;DelayQueue类&lt;/code&gt;&lt;strong&gt;继承&lt;/strong&gt; 了&lt;code&gt;AbstractQueue&lt;/code&gt;抽象类和&lt;strong&gt;实现&lt;/strong&gt;了BlockingQueue接口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;PriorityQueue&lt;/code&gt;类和&lt;code&gt;ConcurrentLinkedQueue&lt;/code&gt;类&lt;strong&gt;继承&lt;/strong&gt; 了&lt;code&gt;AbstractQueue&lt;/code&gt;抽象类&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Deque：全称Double-Ended queue，表示双端队列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;类实现接口，用implements&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;接口继承接口，用 extends&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;类继承类，用extends&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三、万物归宗Queue接口&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 深入理解Queue接口的本质&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Queue接口是一种Collection，被设计用于处理之前临时保存在某处的元素。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;除了基本的Collection操作之外，队列还提供了额外的插入、提取和检查操作。每一种操作都有两种形式：如果操作失败，则抛出一个异常；如果操作失败，则返回一个特殊值（null或false，取决于是什么操作）。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;队列通常是以FIFO（先进先出）的方式排序元素，但是这不是必须的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;只有优先级队列可以根据提供的比较器对元素进行排序或者是采用正常的排序。无论怎么排序，队列的头将通过调用remove()或poll()方法进行移除。在FIFO队列种，所有新的元素被插入到队尾。其他种类的队列可能使用不同的布局来存放元素。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;每个Queue必须指定排序属性。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 Queue接口的核心方法&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总共有3组方法，每一组方法对应两个方法。如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.47738693467336685&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJLhZBYql2pbJmya4wqficx8OPibDUPYwQEicadiaJWPhoz8fczkkH8BlnCQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;398&quot;/&gt;&lt;figcaption&gt;Queue的核心方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;动作&lt;/th&gt;&lt;th&gt;抛异常&lt;/th&gt;&lt;th&gt;返回特殊值&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Insert&lt;/td&gt;&lt;td&gt;add(e)&lt;/td&gt;&lt;td&gt;offer(e)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Remove&lt;/td&gt;&lt;td&gt;remove()&lt;/td&gt;&lt;td&gt;poll&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Examine&lt;/td&gt;&lt;td&gt;element()&lt;/td&gt;&lt;td&gt;peek()&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;（1）比如&lt;code&gt;添加（Insert）&lt;/code&gt;元素的动作，会有两种方式：&lt;code&gt;add(e)&lt;/code&gt;和&lt;code&gt;offer(e)&lt;/code&gt;。如果调用add(e)方法时，添加失败，则会&lt;code&gt;抛异常&lt;/code&gt;，而如果调用的是offer(e)方法失败时，则会&lt;code&gt;返回false&lt;/code&gt;。offer方法用于异常是正常的情况下使用，比如在有界队列中，优先使用offer方法。假如队列满了，不能添加元素，offer方法返回false，这样我们就知道是队列满了，而不是去handle运行时抛出的异常。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;（2）同理，移除（Remove）元素的动作，队列为空时，remove方法抛异常，而poll返回null。如果移除头部的元素成功，则返回移除的元素。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;（3）同理，检测（Examine）元素的动作，返回头部元素（最开始加入的元素），但不删除元素， 如果队列为空，则element()方法抛异常，而peek()返回false。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;（4）Queue接口没有定义阻塞队列的方法，这些方法在BlockQueue接口中定义了。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;（5）Queue实现类通常不允许插入null元素，尽管一些实现类比如LinkedList不禁止插入null，但是还是不建议插入null，因为null也被用在poll方法的特殊返回值，以说明队列不包含元素。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;四、双端可用Deque接口&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.1 深入理解Deque接口的原理&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.33224043715846996&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJ8MLQ9wiaulv3bYib3zOLuvnfbFnkgrFB8fkriaHqFTN2ntuWOFLWlsWvw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;915&quot;/&gt;&lt;figcaption&gt;双端队列Deque&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（1）Deque概念：&lt;/strong&gt; 支持两端元素插入和移除的线性集合。名称&lt;code&gt;deque&lt;/code&gt;是双端队列的缩写，通常发音为&lt;code&gt;deck&lt;/code&gt;。大多数实现Deque的类，对它们包含的元素的数量没有固定的限制的，支持有界和无界。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（2）Deque方法说明：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2430406852248394&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJ7VI8ibWPsGfZpsUnuSFc2hNNI7B3zzdjLZtbRMJVlHKcVv5vLl9FBlQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;934&quot;/&gt;&lt;figcaption&gt;Deque方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;该列表包含包含访问deque两端元素的方法，提供了插入，移除和检查元素的方法。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;这些方法种的每一种都存在两种形式：如果操作失败，则会抛出异常，另一种方法返回一个特殊值（null或false，取决于具体操作）。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;插入操作的后一种形式专门设计用于容量限制的Deque实现，大多数实现中，插入操作不能失败，所以可以用插入操作的后一种形式。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Deque接口扩展了Queue接口，当使用deque作为队列时，作为FIFO。元素将添加到deque的末尾，并从头开始删除。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;作为FIFO时等价于Queue的方法如下表所示：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;img data-ratio=&quot;0.68&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJxX9R0yafxvXwyEBIB4rrib2jadpUefEHicqkiaat5U9zrA5cyXibG8MAlg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;450&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如Queue的add方法和Deque的addLast方法等价。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Deque也可以用作LIFO（后进先出）栈，这个接口优于传统的Stack类。当作为栈使用时，元素被push到deque队列的头，而pop也是从队列的头pop出来。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Stack（栈）的方法正好等同于Deque的如下方法：&lt;/p&gt;&lt;img data-ratio=&quot;0.4048140043763676&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJroxMuwzueQmTSuNEQQaShTCbAElicDW4XIWG7SaXwtEBPvIYLdIGNcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;457&quot;/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：peek方法不论是作为栈还是队列，都是从队列的检测队列的头，返回最先加入的元素。比如第一次put 100，第二次put 200，则peek返回的是100。如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.27247191011235955&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJ3LF89TibshJvvIP8oxB1dlc0ic1tJzkia6GGibZ876pbe1rkh4MicHxbeCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;712&quot;/&gt;&lt;figcaption&gt;示例代码&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.1 哪些类实现了Deque接口&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;LinkedList类&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ArrayDeque类&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ConcurrentLinkedDeque类&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingDeque类&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2 哪些类继承了Deque接口&lt;span/&gt;&lt;/h3&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;五、队列骨架AbstractQueue抽象类&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.1  深入理解AbstractQueue抽象类&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AbstractQueue是一个抽象类，继承了Queue接口，提供了一些Queue操作的骨架实现。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJ2G9kCia1e7kyZwhzd0zt1TOiaUzWSuQ4iaZDsfX4hVIiciaSJhsU1MjCucw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;432&quot;/&gt;&lt;figcaption&gt;AbstractQueue的方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法add、remove、element方法基于offer、poll和peek。也就是说如果不能正常操作，则抛出异常。我们来看下AbstactQueue是怎么做到的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(E e)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (offer(e))&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&lt;span&gt;&quot;Queue full&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; E &lt;span&gt;remove&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    E x = poll();&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (x != &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; x;&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NoSuchElementException();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; E &lt;span&gt;element&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    E x = peek();&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (x != &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; x;&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NoSuchElementException();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果继承AbstractQueue抽象类则必须保证offer方法不允许null值插入。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2 哪些类继承了AbstractQueue抽象类&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ArrayBlockingQueue&lt;/code&gt;类、&lt;code&gt;LinkendBlockingQueue&lt;/code&gt;类、&lt;code&gt;LinkedBlockingDeque&lt;/code&gt;类、&lt;code&gt;LinkedTransferQueue&lt;/code&gt;类、&lt;code&gt;SynchronousQueue&lt;/code&gt;类、&lt;code&gt;PriorityBlockQueue&lt;/code&gt;类、&lt;code&gt;DelayQueue类&lt;/code&gt;&lt;strong&gt;继承&lt;/strong&gt; 了&lt;code&gt;AbstractQueue&lt;/code&gt;抽象类&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;PriorityQueue&lt;/code&gt;类和&lt;code&gt;ConcurrentLinkedQueue&lt;/code&gt;类&lt;strong&gt;继承&lt;/strong&gt; 了&lt;code&gt;AbstractQueue&lt;/code&gt;抽象类&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;六、阻塞缓冲BlockingQueue接口&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.1 宏观来看BlockingQueue（阻塞队列）&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.43462897526501765&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJqnaw8XAaeRAcAro3oBsdRJ9jJurTk1reGiaswo8ygXEHxLlbvQjqECw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;566&quot;/&gt;&lt;figcaption&gt;阻塞队列满了的情况&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.33223684210526316&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJPN2K0wCQK8JicbZwicCWWB1P7iaicWickQQpfDm5BnAdNyw1HCBn2abMaWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;608&quot;/&gt;&lt;figcaption&gt;阻塞队列为空的情况&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）BlockingQueue（阻塞队列）也是一种队列，支持阻塞的插入和移除方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）阻塞的插入：当队列满时，队列会阻塞插入元素的线程，直到队列不满。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（4）阻塞的移除：当队列为空，获取元素的线程会等待队列变为非空。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（5）应用场景：生产者和消费者，生产者线程向队列里添加元素，消费者线程从队列里移除元素，阻塞队列时获取和存放元素的容器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（6）为什么要用阻塞队列：生产者生产和消费者消费的速率不一样，需要用队列来解决速率差问题，当队列满了或空的时候，则需要阻塞生产或消费动作来解决队列满或空的问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.2 案例解析&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程A往阻塞队列（Blocking Queue）中&lt;code&gt;添加&lt;/code&gt;元素，而线程B从阻塞队列中&lt;code&gt;移除&lt;/code&gt;元素。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;当阻塞队列为空的时候&lt;/strong&gt; （一个元素都没有），则从队列中获取元素的操作将会被阻塞。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;生活中的案例：去海底捞吃火锅的时候，早上8点没人来吃火锅，所以需要等客人过来。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;翻译成线程：现在没有元素需要添加，而且阻塞队列为空，所以线程B不需要从队列中拿元素出来，所以线程B获取元素的操作被阻塞了。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;当阻塞队列满了的时候&lt;/strong&gt; （所有位置都放有元素），则从队列中添加元素的操作将会被阻塞。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;生活中的案例：去海底捞吃火锅的时候，人太多了，需要排号，等其他桌空出来了才能进去。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;翻译成线程：线程A往阻塞队列中添加元素，将队列填满了，线程B现在正在忙，无法拿出队列中的元素，所以阻塞队列没有地方再放元素了，这个时候线程A添加元素的操作就被阻塞了&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.3 操刀BlockingQueue接口&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;BlockingQueue接口的10个核心方法：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.264935064935065&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJTx6DnvptfKQWLJvicgKze5mmJ4ahicOZdV9dFN2eFm6YcECEzSotVXkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;385&quot;/&gt;&lt;figcaption&gt;继承的方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;10个核心方法总结如下：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4692218350754936&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJ3gcghRqzJ1yE6VxxNLK5Op0jIKpDPwZCRPiaSLQmia1sW9e7JzaGyJxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;861&quot;/&gt;&lt;figcaption&gt;BlockingQueue接口的10个核心方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有三大类操作：插入、移除、检查。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;插入有四种方法：&lt;/strong&gt; add、offer、put、offer超时版。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;IllegalStateException&lt;/code&gt; - 队列满了&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ClassCastException&lt;/code&gt; - 添加的元素类型不匹配&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;NullPointerException&lt;/code&gt; - 添加的元素为null&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt; - 添加的元素某些属性不匹配&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;add方法特别之处用于添加失败时抛出异常，共有四种异常：&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;offer方法特别之处用于添加失败时只返回false&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;put方法特别之处用于当阻塞队列满时，生产者如果往队列里put元素，则队列会一直阻塞生产者线程，直到队列可用或者响应中断退出&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;offer超时方法特别之处用于当阻塞队列满时，生产者如果往队列里面插入元素，队列会阻塞生产者线程一段时间，如果超过了指定时间，生产者线程会退出，并返回false。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;移除有四种方法：&lt;/strong&gt; remove、poll、take、poll超时版&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;NoSuchElementException&lt;/code&gt; - 如果这个队列是空的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;remove方法特别之处用于移除失败时抛出异常&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;poll方法特别之处用于移除失败时返回null&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;take方法特别之处用于当阻塞队列为空时，消费者线程如果从队列里面移除元素，则队列会一直阻塞消费者线程，直到队列不为空&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;poll超时方法特别之处用于当阻塞队列空时，消费者如果从队列里面删除元素，则队列会一直阻塞消费者线程，如果超过了指定时间，消费者线程会退出，并返回null&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;检查有两种方法：&lt;/strong&gt; element、peek&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;element方法用于检测头部元素的存在性，如果队列为空，则抛出异常，否则返回头部元素。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;peek方法用于检测头部元素的存在性，如果队列为空，返回特殊值null，否则返回头部的元素。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.4 BlockingQueue通过什么来阻塞插入和移除的？&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当往队列里插入一个元素时，如果队列不可用，那么阻塞生产者主要通过LockSupport. park（this）来实现。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;park这个方法会阻塞当前线程，只有以下4种情况中的一种发生时，该方法才会返回。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;与park对应的unpark执行或已经执行时。“已经执行”是指unpark先执行，然后再执行park的情况。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程被中断时。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;等待完time参数指定的毫秒数时。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;异常现象发生时，这个异常现象没有任何原因。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.5 哪些类继承了BlockingQueue接口？&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;BlockingDeque接口 - 双端阻塞队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TransferQueue接口 - 传输队列&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.6 哪些类实现了BlockingQueue接口？&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ArrayBlockingQueue类 - 由数组构成的有界阻塞队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingQueue类 - 由链表构成的有界阻塞队列，界限默认大小为Integer.MAX_Value（2^31-1），值非常大，相当于无界。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingDeque类 - 由链表构成的双向阻塞队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LinkedTransferQueue类 - 由链表构成的无界阻塞队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SynchronousQueue类 - 不存储元素的阻塞队列，只有一个元素进行数据传递。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LinkedTransferQueue类 - 由链表构成的无界阻塞TransferQueue队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DelayQueue类 - 使用优先级队列实现的延迟无界阻塞队列&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.6 BlockingQueue接口继承了哪些接口&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;BlockingQueue接口继承了Queue接口，可作为队列使用&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;七、双端阻塞BlockingDeque接口&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.1 从原理图上理解BlockDeque&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;BlockQueue满了，两端的Take操作被阻塞&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3497142857142857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJu0Jg2A69ic93bxxdFjpsLsFIguhbK9Ke82mqjiaswzzwK2xXicZicVUAQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;875&quot;/&gt;&lt;figcaption&gt;BlockingDeque满了&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;BlockQueue为空，两端的Take操作被阻塞&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.38426453819840367&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJAiabUoZo3H9L6zP16Zeq6139w2jxIcnU7ZeE7bcfug0UFbo0iaLbj8OQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;877&quot;/&gt;&lt;figcaption&gt;BlockQueue为空&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.2 BlockingDeque接口方法&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是阻塞队列&lt;code&gt;BlockingQueue&lt;/code&gt;和双向队列&lt;code&gt;Deque&lt;/code&gt;接口的结合。有如下方法：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.425&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJqO622N0N9UqV3AXvbJ2PDYIaCiahWq1OYibGaZ8n0MqeoicibPXPd3QHrg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;figcaption&gt;BlockingDeque接口方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尝试执行以下方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;LinkedBlockingDeque queue = &lt;span&gt;new&lt;/span&gt; LinkedBlockingDeque();&lt;br/&gt;queue.addFirst(&lt;span&gt;&quot;test1&quot;&lt;/span&gt;);&lt;br/&gt;queue.addFirst(&lt;span&gt;300&lt;/span&gt;);&lt;br/&gt;queue.addLast(&lt;span&gt;&quot;400&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后队列中的元素顺序如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;300, test1, 400。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先添加了test1放到队列的头部，然后在头部的前面放入300，所以300在最前面，成为头部，然后将400放入队列的尾部，所以最后的结果是300, test1, 400。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4056737588652482&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJ6oonNqOfibNa8YwtexzxUzXPgFDtfVLehI0yFCt1zQl7NoT4MdOTtPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;705&quot;/&gt;&lt;figcaption&gt;队列种的元素&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.3 BlockDeque和BlockQueue的对等方法&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9040767386091128&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJdvRsiaEcrAbBsgbZW0dq7nB1JJj8Me072ic4m71emBpauL6IXpIpHesQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;417&quot;/&gt;&lt;figcaption&gt;BlockDeque和BlockQueue的对等方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.4 BlockingDeque的特点&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;线程安全。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不允许使用null元素。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;无界和有界都可以。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.5 BlockingDeque接口继承了哪些接口？&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Queue接口，具有队列的功能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Deque接口，具有双端队列的功能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;BlockingQueue接口，可作为阻塞队列使用&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.6 哪些类实现了BlockDeque接口？&lt;span/&gt;&lt;/h3&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;八、使命必达TransferQueue接口&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8.1 Transfer怎么理解？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果有消费者正在获取元素，则将队列中的元素传递给消费者。如果没有消费者，则等待消费者消费。我把它称作使命必达队列，必须将任务完成才能返回。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8.2 生活中的案例&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;针对TransferQueue的transfer方法&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;圆通快递员要将小明的2个快递送货到门，韵达快递员也想将小明的2个快递送货到门。小明一次只能拿一个，快递员必须等小明拿了一个后，才能继续给第二个。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;针对TransferQueue的tryTransfer方法&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;圆通快递员要将小明的2个快递送货到门，韵达快递员也想将小明的2个快递送货到门。发现小明不在家，就把快递直接放到菜鸟驿站了。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;针对TransferQueue的tryTransfer超时方法&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;圆通快递员要将小明的2个快递送货到门，韵达快递员也想将小明的2个快递送货到门。发现小明不在家，于是先等了5分钟，发现小明还没有回来，就把快递直接放到菜鸟驿站了。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8.3 TransferQueue的原理解析&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;transfer(E e)&lt;/code&gt;&lt;/p&gt;&lt;p&gt;原理如下图所示：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1.1124807395993837&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJHichW8Licd6XGq1yuzqVshsJ5bZz5iclmEjtNPSPEL4licLI7kN8OKMXvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;649&quot;/&gt;&lt;figcaption&gt;transfer方法的原理&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;原理图解释：生产者线程Producer Thread尝试将元素B传给消费者线程，如果没有消费者线程，则将元素B放到尾节点。并且生产者线程等待元素B被消费。当元素B被消费后，生产者线程返回。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果当前有消费者正在等待接收元素（消费者通过take方法或超时限制的poll方法时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果没有消费者等待接收元素，transfer方法会将元素放在队列的tail（尾）节点，并等到该元素被消费者消费了才返回。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;tryTransfer(E e)&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;试探生产者传入的元素是否能直接传给消费者。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果没有消费者等待接收元素，则返回false。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;和transfer方法的区别是，无论消费者是否接收，方法立即返回。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;tryTransfer(E e, long timeout, TimeUnit unit)&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;带有时间限制的tryTransfer方法。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;试图把生产者传入的元素直接传给消费者。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果没有消费者消费该元素则等待指定的时间再返回。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果超时了还没有消费元素，则返回false。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果在超时时间内消费了元素，则返回true。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;getWaitingConsumerCount()&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;获取通过BlockingQueue.take()方法或超时限制poll方法等待接受元素的消费者数量。近似值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;返回等待接收元素的消费者数量。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;hasWaitingConsumer()&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;获取是否有通过BlockingQueue.tabke()方法或超时限制poll方法等待接受元素的消费者。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;返回true则表示至少有一个等待消费者。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8.3 TransferQueue接口继承了哪些接口？&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;BlockingQueue接口，可作为阻塞队列使用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Queue接口，可作为队列使用&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8.4 哪些类实现了TransferQueue接口？&lt;span/&gt;&lt;/h3&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;九、优先由你PriorityQueue类&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;9.1 理解PriorityQueue类&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2513020833333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJTcwqRggrf6iaIosrWcyFECoksV0icLMMuic2EpowLF4wWSaq0wOpDiauUw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;768&quot;/&gt;&lt;figcaption&gt;本应该按照升序排序&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.40618955512572535&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJ5zW3eJWFWe4bqiaud3ysVKjK6nD4e9bhaWOSChp3En8Xj07saMBokmA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;517&quot;/&gt;&lt;figcaption&gt;按照自定义优先级排序&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;PriorityQueue是一个支持优先级的无界阻塞队列。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;默认自然顺序升序排序。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;可以通过构造参数Comparator来对元素进行排序。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;PriorityQueue&lt;/span&gt;&lt;span&gt;(Comparator&amp;lt;? &lt;span&gt;super&lt;/span&gt; E&amp;gt; comparator)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;     &lt;span&gt;this&lt;/span&gt;(DEFAULT_INITIAL_CAPACITY, comparator);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;自定义实现comapreTo()方法来指定元素排序规则。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; Comparator&amp;lt;? &lt;span&gt;super&lt;/span&gt; E&amp;gt; comparator() {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; comparator;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;不允许插入null元素。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实现PriorityQueue接口的类，不保证线程安全，除非是PriorityBlockingQueue。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;PriorityQueue的迭代器不能保证以任何特定顺序遍历元素，如果需要有序遍历，请考虑使用&lt;code&gt;Arrays.sort(pq.toArray)&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;进列(&lt;code&gt;offer&lt;/code&gt;、&lt;code&gt;add&lt;/code&gt;)和出列（ &lt;code&gt;poll&lt;/code&gt;、&lt;code&gt;remove()&lt;/code&gt;）的时间复杂度O(log(n))。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;remove(Object) 和 contains(Object)的算法时间复杂度O(n)。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;peek、element、size的算法时间复杂度为O(1)。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;9.2 PriorityQueue类继承了哪些类？&lt;span/&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;9.2 PriorityQueue类实现了哪些接口？&lt;span/&gt;&lt;/h3&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;十、双向链表LinkedList类&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;10.1 LinkedList的结构&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;LinkedList实现了List和Deque接口，所以是一种双链表结构，可以当作堆栈、队列、双向队列使用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个双向列表的每一个元素都有三个整数值：元素、向后的节点链接、向前的节点链接&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4586709886547812&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJKmXvYjJLMscqianGo1L4esvfux0WQJB49X2G0IWRRaviaNF9d8ZgibRHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;617&quot;/&gt;&lt;figcaption&gt;LinkedList的结构&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看下节点类Node&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt;&amp;lt;&lt;span&gt;E&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    E item; &lt;span&gt;//元素&lt;/span&gt;&lt;br/&gt;    Node&amp;lt;E&amp;gt; next; &lt;span&gt;//向后的节点链接&lt;/span&gt;&lt;br/&gt;    Node&amp;lt;E&amp;gt; prev; &lt;span&gt;//向前的节点链接&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    Node(Node&amp;lt;E&amp;gt; prev, E element, Node&amp;lt;E&amp;gt; next) {&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.item = element;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.next = next;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.prev = prev;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;10.2 与ArrayList的区别&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;1.LinkedList的增加和删除效率相对较高，而查找和修改的效率相对较低。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;2.以下情况建议使用ArrayList&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;频繁访问列表中的一个元素。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;只在列表的首尾添加元素。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;3.以下情况建议使用LinkedList&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;频繁地在列表开头、中间、末尾添加和删除元素。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;需要通过循环迭代来访问列表中的元素。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;10.3 LinkedList不是线程安全的&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;LinkedList不是线程安全的，所以可以使用如下方式保证线程安全。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List list = Collections.synchronizedList(&lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;10.4 LinkedList的家庭成员关系&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;LinkedList 继承了 AbstractSequentialList 类。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;LinkedList 实现了 Queue 接口，可作为队列使用。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;LinkedList 继承了 AbstractQueue抽象类，具有队列的功能。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;LinkedList 实现了 List 接口，可进行列表的相关操作。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;LinkedList 实现了 Deque 接口，可作为双向队列使用。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;LinkedList 实现了 Cloneable 接口，可实现克隆。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;LinkedList 实现了 java.io.Serializable 接口，即可支持序列化，能通过序列化去传输。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;十一、并发安全ConcurrentLinkedQueue类&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;11.1 理解ConcurrentLinkedQueue&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.29554655870445345&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJEiaia1ZAyqIo9wdTIHSMwz086HxMSR9Pk8kr5ryOXocdOGBXYOyBgmXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1235&quot;/&gt;&lt;figcaption&gt;ConcurrentLinkedQueue原理&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ConcurrentLinked是由链表结构组成的线程安全的先进先出无界队列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当多线程要共享访问集合时，ConcurrentLinkedQueue是一个比较好的选择。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不允许插入null元素&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持非阻塞地访问并发安全的队列，不会抛出ConcurrentModifiationException异常。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;size方法不是准确的，因为在统计集合的时候，队列可能正在添加元素，导致统计不准。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;批量操作addAll、removeAll、retainAll、containsAll、equals和toArray不保证原子性（操作不可分割）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;添加元素happen-before其他线程移除元素。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用法如下：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ConcurrentLinkedQueue queue = &lt;span&gt;new&lt;/span&gt; ConcurrentLinkedQueue();&lt;br/&gt;BuildingBlockWithName buildingBlock = &lt;span&gt;new&lt;/span&gt; BuildingBlockWithName(&lt;span&gt;&quot;三角形&quot;&lt;/span&gt;, &lt;span&gt;&quot;A&quot;&lt;/span&gt;);&lt;br/&gt;concurrentLinkedQueue.add(buildingBlock);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;11.2 ConcurrentLinkedQueue类继承了哪些类？&lt;span/&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;11.3 ConcurrentLinkedQueue类实现了哪些接口？&lt;span/&gt;&lt;/h3&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;十二、双向数组ArrayDeque类&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3778538812785388&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJMmrib4dwnWGTsygrFwTWibVUrswCHBI2QgUwZ8iaSl8RQ4cGKlR90ib2iaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;876&quot;/&gt;&lt;figcaption&gt;ArrayDeque原理图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;12.1 理解ArrayDeque&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;由数组组成的双端队列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;没有容量限制，根据需要扩容。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不是线程安全的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;禁止插入null元素。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当用作栈时，比栈速度快，当用作队列时，速度比LinkList快。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;大部分方法的算法时间复杂度为O(1)。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;remove、removeFirstOccurrence、removeLastOccurrence、contains、remove 和批量操作的算法时间复杂度O(n)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;12.2 使用方法&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建一个ArrayDeque，往arrayDeque队尾添加元素。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ArrayDeque arrayDeque = &lt;span&gt;new&lt;/span&gt; ArrayDeque();&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;50&lt;/span&gt;; i++) {&lt;br/&gt;    arrayDeque.add(buildingBlock); &lt;span&gt;// add方法等价于addLast方法&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;12.3 ArrayDeque实现了哪些接口&lt;span/&gt;&lt;/h3&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;十三、双向并发ConcurrentLinkedDeque类&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;13.1 理解ConcurrentLinkedDeque类&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.31805555555555554&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJ9xj2FHI5oYumlvYFMqTqrl0HZ4pSU16GKmTE05BRVjrwNFkxgJ6ZPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1440&quot;/&gt;&lt;figcaption&gt;ConcurrentLinkedDeque原理图&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;由链表结构组成的双向无界阻塞队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;插入、删除和访问操作可以并发进行，线程安全的类&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不允许插入null元素&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在并发场景下，计算队列的大小是不准确的，因为计算时，可能有元素加入队列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;批量操作addAll、removeAll、retainAll、containsAll、equals和toArray不保证原子性（操作不可分割）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;13.2 ConcurrentLinkedDeque使用示例&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建两个积木：三角形、四边形，然后添加到队列：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;BuildingBlockWithName buildingBlock1 = &lt;span&gt;new&lt;/span&gt; BuildingBlockWithName(&lt;span&gt;&quot;三角形&quot;&lt;/span&gt;, &lt;span&gt;&quot;A&quot;&lt;/span&gt;);&lt;br/&gt;BuildingBlockWithName buildingBlock2 = &lt;span&gt;new&lt;/span&gt; BuildingBlockWithName(&lt;span&gt;&quot;四边形&quot;&lt;/span&gt;, &lt;span&gt;&quot;B&quot;&lt;/span&gt;);&lt;br/&gt;ConcurrentLinkedDeque concurrentLinkedDeque = &lt;span&gt;new&lt;/span&gt; ConcurrentLinkedDeque();&lt;br/&gt;concurrentLinkedDeque.addFirst(buildingBlock1);&lt;br/&gt;concurrentLinkedDeque.addLast(buildingBlock2);&lt;br/&gt;&lt;span&gt;//结果：顺序：三角形、四边形&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;13.3 ConcurrentLinkedDeque实现了哪些接口&lt;span/&gt;&lt;/h3&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;十四、数组阻塞ArrayBlockingQueue类&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;14.1 理解ArrayBlockingQueue&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7349768875192604&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJ4AelrbnDcEVoibNIKYw2v7b7FfnjMbYWKuicPlXm1TjbfJ2eZTvRsgicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;649&quot;/&gt;&lt;figcaption&gt;ArrayBlockingQueuey原理图&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ArrayBlockingQueue是一个用数组实现的有界阻塞队列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;队列慢时插入操作被阻塞，队列空时，移除操作被阻塞。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;按照先进先出（FIFO）原则对元素进行排序。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;默认不保证线程公平的访问队列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;公平访问队列：按照阻塞的先后顺序访问队列，即先阻塞的线程先访问队列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;非公平性是对先等待的线程是非公平的，当队列可用时，阻塞的线程都可以争夺访问队列的资格。有可能先阻塞的线程最后才访问访问队列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;公平性会降低吞吐量。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;14.2 ArrayBlockingQueue使用示例&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建两个积木：三角形、四边形，然后添加到队列：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;BuildingBlockWithName buildingBlock1 = &lt;span&gt;new&lt;/span&gt; BuildingBlockWithName(&lt;span&gt;&quot;三角形&quot;&lt;/span&gt;, &lt;span&gt;&quot;A&quot;&lt;/span&gt;);&lt;br/&gt;BuildingBlockWithName buildingBlock2 = &lt;span&gt;new&lt;/span&gt; BuildingBlockWithName(&lt;span&gt;&quot;四边形&quot;&lt;/span&gt;, &lt;span&gt;&quot;B&quot;&lt;/span&gt;);&lt;br/&gt;ArrayBlockingQueue arrayBlockingQueue = &lt;span&gt;new&lt;/span&gt; ArrayBlockingQueue(&lt;span&gt;100&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;arrayBlockingQueue.add(buildingBlock1);&lt;br/&gt;arrayBlockingQueue.add(buildingBlock2);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;14.3 ArrayBlockQueue实现了哪些接口&lt;span/&gt;&lt;/h3&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;十五、链表阻塞LinkedBlockingQueue类&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;15.1 理解LinkedBlockingQueue&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.502906976744186&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJ52Nwoq0ticKZDgBHXwCC1rrweeTm36fsXzu2tqKF2c80rrK4xdMbK1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1032&quot;/&gt;&lt;figcaption&gt;LinkedBlockingQueue原理&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingQueue具有单链表和有界阻塞队列的功能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;队列慢时插入操作被阻塞，队列空时，移除操作被阻塞。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;默认和最大长度为Integer.MAX_VALUE，相当于无界(值非常大：2^31-1)。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;15.2 LinkedBlockingQueue使用示例&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;LinkedList linkedList1 = &lt;span&gt;new&lt;/span&gt; LinkedList();&lt;br/&gt;linkedList1.add(&lt;span&gt;&quot;A&quot;&lt;/span&gt;);&lt;br/&gt;linkedList1.add(&lt;span&gt;&quot;B&quot;&lt;/span&gt;);&lt;br/&gt;linkedList1.add(&lt;span&gt;&quot;C&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;15.3 LinkedBlockingQueue的应用场景&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;吞吐量通常要高于ArrayBlockingQueue。创建线程池时，参数runnableTaskQueue（任务队列），用于保存等待执行的任务的阻塞队列可以选择LinkedBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;15.4 LinkedBlockingQueue实现了哪些接口&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingQueue继承了 BlockingQueue类，可作为阻塞队列使用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingQueue继承了 AbstractQueue抽象类，具有队列的功能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingQueue实现了 java.io.Serializable 接口，即可支持序列化，能通过序列化去传输。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;十六、双向阻塞LinkedBlockingDeque类&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;16.1 理解LinkedBlockingDeque类&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5433422698838248&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJUO5lMaTjDSMYJR8jqF6a8usvYR83tVtgMHicRqialNUOIqPyFypFJyicw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1119&quot;/&gt;&lt;figcaption&gt;LinkedBlockingDeque原理图&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;由链LinkedBlockingDeque = 阻塞队列+链表+双端访问&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程安全。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;多线程同时入队时，因多了一端访问入口，所以减少了一半的竞争。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;默认容量大小为Integer.MAX_VALUE。可指定容量大小。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;16.2 LinkedBlockingDeque的应用场景&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;LinkedBlockingDeque可以用在“工作窃取“模式中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;工作窃取算法&lt;/code&gt;：某个线程比较空闲，从其他线程的工作队列中的队尾窃取任务来帮忙执行。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;16.3 LinkedBlockingDeque实现了哪些接口&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingDeque继承了 BlockingDeque类，可作为阻塞队列使用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingDeque继承了 AbstractQueue抽象类，具有队列的功能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingDeque实现了 java.io.Serializable 接口，即可支持序列化，能通过序列化去传输。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;十七、链表阻塞LinkedTransferQueue类&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;17.1 理解LinkedTransferQueue类&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8032608695652174&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJnuEia8W6DDz933PxpIibNqficRq8X2BvNXenMZaDiaw3DZWB7gvr0UoaCQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;920&quot;/&gt;&lt;figcaption&gt;LinkedTransferQueue原理图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;LinkedTransferQueue = 阻塞队列+链表结构+TransferQueue&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前我们讲“使命必达TransferQueue接口时&lt;strong&gt;已经介绍过了TransferQueue接口&lt;/strong&gt; ，所以LinkedTransferQueue接口跟它相似，只是加入了阻塞插入和移除的功能，以及结构是链表结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前的TransferQueue也讲到了3个案例来说明TransferQueue的原理，大家可以回看TransferQueue。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;17.2 LinkedTransferQueue接口比其他阻塞队列多了5个方法&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;transfer(E e)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;tryTransfer(E e)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;tryTransfer(E e, long timeout, TimeUnit unit)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;getWaitingConsumerCount()&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;hasWaitingConsumer()&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;17.3 LinkedTransferQueue代码示例&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;创建一个LinkedTransferQueue，生产者1 依次往队列中添加 A、B、C&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5511450381679389&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJzic0OgKOb0PGhzpkWvLPdlk7UULKw5catOfQnCMm29xbCcH9vHRWBng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;655&quot;/&gt;&lt;figcaption&gt;生产者1 依次往队列中添加 A、B、C&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5583941605839416&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJQMia0eDcicAuEhAfvPlQSlSjn9BKcreqro9J3ia0tt7SPz1N4GKPjbktg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;548&quot;/&gt;&lt;figcaption&gt;生产者2 依次往队列中添加 D、E、F&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;消费者依次从队列首部开始消费元素，每次消费前，先sleep 2s，来演示transfer方法是否进行了等待。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9723926380368099&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJTJYFibiaqtLNDECfEkHg2Zk1zzkEIlQJcaVKvtR1v3Nx7kWN7iaNskfVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;652&quot;/&gt;&lt;figcaption&gt;消费者消费元素&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;生产者&lt;span&gt;1&lt;/span&gt;     transfer A &lt;br/&gt;生产者&lt;span&gt;2&lt;/span&gt;     transfer D &lt;br/&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;s后...&lt;br/&gt;  &lt;br/&gt;消费者      take A&lt;br/&gt;生产者&lt;span&gt;1&lt;/span&gt;     put B &lt;br/&gt; &lt;br/&gt;&lt;span&gt;2&lt;/span&gt;s后...&lt;br/&gt;     &lt;br/&gt;消费者      take D&lt;br/&gt;生产者&lt;span&gt;2&lt;/span&gt;     transfer E &lt;br/&gt;    &lt;br/&gt;&lt;span&gt;2&lt;/span&gt;s后...&lt;br/&gt;  &lt;br/&gt;消费者      take B&lt;br/&gt;生产者&lt;span&gt;1&lt;/span&gt;     transfer C &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）首先生产者线程1和2 调用transfer方法来传输A和D，发现没有消费者线程接收，所以被阻塞。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）消费者线程过了2s后将A拿走了，然后生产者1 被释放继续执行，传输元素B，发现又没有消费者消费，所以进行了等待。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）消费者线程过了2s后，将排在队列首部的D元素拿走，生产者2继续往下执行，传输元素E，发现没有消费者，所以进行了等待。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（4）消费者线程过了2s后，将排在队列首部的B元素拿走，生产者1传输C元素，等待消费者拿走。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（5）消费者不再消费了，所以生产者1和生产者2都被阻塞了，元素C和，元素E都没有被拿走，而且生产者2的F元素还没有开始传输，因为在等待元素D被拿走。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（6）看下队列里面确实有C和E元素，而且E排在队列的首部。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3099787685774947&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJpyZN59TpEbAz3fVWVF9I2iaibdlVbCypZ2MFI9ShP1Ap5TLhdzSzR82g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;471&quot;/&gt;&lt;figcaption&gt;队列里面的元素&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;17.4 LinkedTransferQueue实现了哪些接口&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingDeque继承了 BlockingQeque类，可作为阻塞队列使用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingDeque继承了 AbstractQueue抽象类，具有队列的功能。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;十八、传球好手SynchronousQueue类&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;18.1 理解SynchronousQueue类&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3333333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJ6zTDxpibX2gqloNEdHILkibMVpfiacObUMGxV3RHVZ5Ou42nVwpFEvqjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;810&quot;/&gt;&lt;figcaption&gt;SynchronousQueue原理图&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;我称SynchronousQueue为”传球好手“。想象一下这个场景：小明抱着一个篮球想传给小花，如果小花没有将球拿走，则小明是不能再拿其他球的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;SynchronousQueue负责把生产者产生的数据传递给消费者线程。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;SynchronousQueue本身不存储数据，调用了put方法后，队列里面也是空的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;每一个put操作必须等待一个take操作完成，否则不能添加元素。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;适合传递性场景。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;性能高于ArrayBlockingQueue和LinkedBlockingQueue。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;18.2 SynchronousQueue示例&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们创建了两个线程，一个线程用于生产，一个线程用于消费&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.587378640776699&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJLhibG0DhicSTdXTiaohQ3axf7ibEsXKI8W2ibPjiaKFcJDT1unibdoCibbS1WA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;618&quot;/&gt;&lt;figcaption&gt;生产的线程依次put A、B、C三个值&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;消费线程使用take来消费阻塞队列中的内容，每次消费前，等待5秒&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.151291512915129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJccAiaDxjRjEND19qvu7LxwJPBq5icG2zq2icJn8jOGkA5f807RxicSYEPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;542&quot;/&gt;&lt;figcaption&gt;消费线程每隔5s调用take方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;t1     put A &lt;br/&gt;t2     take A &lt;br/&gt;&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;秒后...&lt;br/&gt;&lt;br/&gt;t1     put B &lt;br/&gt;t2     take B &lt;br/&gt;&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;秒后...&lt;br/&gt;&lt;br/&gt;t1     put C &lt;br/&gt;t2     take C &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小结：说明生产线程执行put第一个元素&quot;A&quot; 操作后，需要等待消费者线程take完“A”后，才能继续往下执行代码。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;18.1 SynchronousQueue应用场景&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;吞吐量通常要高于LinkedBlockingQueue。创建线程池时，参数runnableTaskQueue（任务队列），用于保存等待执行的任务的阻塞队列可以选择SynchronousQueue。静态工厂方法Executors.newCachedThreadPool()使用了这个队列&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;18.2 SynchronousQueue和LinkedTransferQueue的区别&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;SynchronousQueue 不存储元素，而LinkedTransferQueue存储元素。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SynchronousQueue 队列里面没有元素，而LinkedTransferQueue可以有多个存储在队列等待传输。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LinkedTransferQueue还支持若传输不了，则丢到队列里面去。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LinkedTransferQueue还支持若超过一定时间传输不了，则丢到队列里面去。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;十九、优先级阻塞PriorityBlockingQueue类&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;19.1 理解PriorityBlockQueue类&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5834333733493398&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJv5KNjwGPMD1vcFKu1LQ1pCiaAQARA1icReSHTNCHo2QDic3kUpxDe022Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;833&quot;/&gt;&lt;figcaption&gt;PriorityBlockQueue的原理图&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;PriorityBlockQueue = PriorityQueue + BlockingQueue&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;之前我们也讲到了PriorityQueue的原理，支持对元素排序。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;元素默认自然排序。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以自定义CompareTo()方法来指定元素排序规则。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以通过构造函数构造参数Comparator来对元素进行排序。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;19.2 PriorityBlockQueue实现了哪些接口&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingQueue继承了 BlockingQueue接口，可作为阻塞队列使用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingQueue继承了 AbstractQueue抽象类，具有队列的功能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingQueue实现了 java.io.Serializable 接口，即可支持序列化，能通过序列化去传输。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二十、延时阻塞DelayQueue类&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;20.1 理解DelayQueue&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5750736015701668&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJV6rM80dYpyq576annxX1MbRC67ERbDEdFLRT9fDyeWavoJ0zYPjuTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1019&quot;/&gt;&lt;figcaption&gt;DelayQueue原理图&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;DelayQueue = Delayed + BlockingQueue。队列中的元素必须实现Delayed接口。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DelayQueue&lt;/span&gt;&amp;lt;&lt;span&gt;E&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Delayed&lt;/span&gt;&amp;gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractQueue&lt;/span&gt;&amp;lt;&lt;span&gt;E&lt;/span&gt;&amp;gt;&lt;br/&gt;    &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;BlockingQueue&lt;/span&gt;&amp;lt;&lt;span&gt;E&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在创建元素时，可以指定多久可以从队列中获取到当前元素。只有在延时期满才能从队列中获取到当前元素。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;20.2 源码解析&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;offer&lt;/span&gt;&lt;span&gt;(E e, &lt;span&gt;long&lt;/span&gt; timeout, TimeUnit unit)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; offer(e);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;获取元素的方法poll需要等待延时时间过了才能获取到元素&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (first == &lt;span&gt;null&lt;/span&gt; || first.getDelay(NANOSECONDS) &amp;gt; &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;else&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; q.poll();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5941043083900227&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJpdu4xyQQfQw7VlejFelbv6XeicsWK4Igiaiac1oDmMlSicOLtKvfXGb34g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;441&quot;/&gt;&lt;figcaption&gt;poll方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;20.3 应用场景&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;缓存系统的设计：可以用DelayQueue保存缓存元素的有效期。然后用一个线程循环的查询DelayQueue队列，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;定时任务调度：使用DelayQueue队列保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行。比如Java中的TimerQueue就是使用DelayQueue实现的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;20.4 DelayQueue实现了哪些接口&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;DelayQueue实现了 BlockingQueue接口，可作为阻塞队列使用&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一篇&lt;span&gt;花了很多心思&lt;/span&gt;在上面，看&lt;strong&gt;官方英文文档、画原理图、写demo代码，排版&lt;/strong&gt;。这恐怕是市面上&lt;strong&gt;&lt;span&gt;最全最细&lt;/span&gt;&lt;/strong&gt;讲解Queue的。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>36012aa4c43ba490dabc1e594e3dc85d</guid>
<title>VSCode 多进程架构和插件加载原理</title>
<link>https://toutiao.io/k/4mlkrsi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot;&gt;&lt;h2&gt;前言&lt;/h2&gt;&lt;p&gt;上周我在公司做了一个VSCode的分享，反响不是很好。内容坡度大，没有深入浅出。所以这一次我会更加详细的介绍细节，希望网上的同学看完之后有所收获。&lt;/p&gt;&lt;h2&gt;先提出三个问题&lt;/h2&gt;&lt;p&gt;1、为什么我打开VSCode，会打开N多个进程？&lt;/p&gt;&lt;p&gt;2、为什么我的全局搜索能用，但单个文件内的代码搜索却卡住了？&lt;/p&gt;&lt;p&gt;3、VSCode插件装多了会不会影响性能？&lt;/p&gt;&lt;p&gt;这些问题在本文都将得到解决。&lt;/p&gt;&lt;h2&gt;目录&lt;/h2&gt;&lt;p&gt;本文分为4个部分。&lt;/p&gt;&lt;p&gt;1、VSCode简介&lt;/p&gt;&lt;p&gt;2、多进程架构详解&lt;/p&gt;&lt;p&gt;3、最简单的插件&lt;/p&gt;&lt;p&gt;4、源码解析&lt;/p&gt;&lt;h2&gt;VSCode简介&lt;/h2&gt;&lt;blockquote&gt; 本文都是基于VSCode 1.47.3 的版本。&lt;br/&gt; &lt;/blockquote&gt;&lt;ul&gt;&lt;li&gt;作者，Erich Gamma，Eclipse 架构师，《设计模式》经典书籍，妥妥的业内大佬。&lt;/li&gt;&lt;li&gt;关键词：免费、开源、轻量级、编辑器、跨平台、多语言、Git开箱即用、插件扩展。这里提一下扩平台，VSCode支持Mac、Windows、Linux、Web。&lt;/li&gt;&lt;li&gt;体量：前端大型项目，总代码量100万，其中60万TypeScript代码（cloc工具统计）&lt;/li&gt;&lt;li&gt;技术：&lt;b&gt;Electron&lt;/b&gt;、TypeScript、Monaco、xTerm、&lt;b&gt;LSP（Language Server Protocol）&lt;/b&gt;、&lt;b&gt;DAP（Debug Adapter Protocol）&lt;/b&gt;。我们将会着重介绍加粗的3个内容。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;时间线&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ef3ffa7ff9db90ac811d1be55df3bf39_b.jpg&quot; data-rawwidth=&quot;1632&quot; data-rawheight=&quot;924&quot; data-size=&quot;normal&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-ef3ffa7ff9db90ac811d1be55df3bf39_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-rawwidth=&quot;1632&quot; data-rawheight=&quot;924&quot; data-size=&quot;normal&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-ef3ffa7ff9db90ac811d1be55df3bf39_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-ef3ffa7ff9db90ac811d1be55df3bf39_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我第一次使用VSCode是2016年底，一个PHP同事和我说，VSCode写PHP真好用，随即我就被安利了。果然最好的语言就是要用最好的编辑器。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Electron&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-8a5bacf2aea4a8b0bf43bccdc6decca6_b.jpg&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-8a5bacf2aea4a8b0bf43bccdc6decca6_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-8a5bacf2aea4a8b0bf43bccdc6decca6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-8a5bacf2aea4a8b0bf43bccdc6decca6_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;LSP&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-29503440c846432313d90cb245229120_b.jpg&quot; data-rawwidth=&quot;1162&quot; data-rawheight=&quot;538&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-29503440c846432313d90cb245229120_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-rawwidth=&quot;1162&quot; data-rawheight=&quot;538&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-29503440c846432313d90cb245229120_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-29503440c846432313d90cb245229120_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;语言服务协议，编程语言需要为编辑器实现一些常用的功能，比如hover效果，代码提示（intelligence），代码诊断（diagnostics）等功能，每个编辑器都有一套自己的规则。 从图中我们可以看出，左边为编程语言，右边为编辑器。没有LSP之前，编程语言和编辑器之间是多对多的关系，这种复杂性为 n^2 。但是引入LSP之后，就变成了一对多的关系，主流编辑器都采用同一个协议规则，而编程语言只需要面向语言服务协议编写功能即可，这像不像面向接口编程。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-258470ddf304577fcc920bc3c656730c_b.jpg&quot; data-rawwidth=&quot;1197&quot; data-rawheight=&quot;516&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-258470ddf304577fcc920bc3c656730c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-rawwidth=&quot;1197&quot; data-rawheight=&quot;516&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-258470ddf304577fcc920bc3c656730c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-258470ddf304577fcc920bc3c656730c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这是一张HTML语言服务协议和PHP语言服务协议的图，PHP和HTML实现了这种服务，而客户端通过JSON RPC这种远程调用，在VSCode插件进程内初始化这些语言服务。（语言服务运行在插件进程内）。&lt;/p&gt;&lt;p&gt;想了解如何自定义一个语言服务，可以看一下这篇文章&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//blog.csdn.net/lusing/article/details/90755702&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;vscode插件快餐教程(7) - 从头开始写一个完整的lsp工程 &lt;/a&gt;&lt;/p&gt;&lt;p&gt;DAP&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-1703f4edd8ab0dcc99e74853570f8923_b.jpg&quot; data-rawwidth=&quot;1214&quot; data-rawheight=&quot;998&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-1703f4edd8ab0dcc99e74853570f8923_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-rawwidth=&quot;1214&quot; data-rawheight=&quot;998&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-1703f4edd8ab0dcc99e74853570f8923_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-1703f4edd8ab0dcc99e74853570f8923_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;调试适配器协议&lt;/p&gt;&lt;p&gt;它其实和LSP很像，所有的编程语言都公用一个调试界面，只需要实现DAP这个协议即可。&lt;/p&gt;&lt;h2&gt;多进程架构详解&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e5767697b4372a19103f3413c0113108_b.jpg&quot; data-rawwidth=&quot;1648&quot; data-rawheight=&quot;1018&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-e5767697b4372a19103f3413c0113108_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-rawwidth=&quot;1648&quot; data-rawheight=&quot;1018&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-e5767697b4372a19103f3413c0113108_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-e5767697b4372a19103f3413c0113108_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;1、主进程（Main），一个 Electron 应用只有一个主进程。创建 GUI 相关的接口只由主进程来调用。&lt;/p&gt;&lt;p&gt;2、渲染进程（Renderer），每一个工作区（workbench）对应一个进程，同时是BrowserWindow实例。一个Electron项目可以有多个渲染进程。&lt;/p&gt;&lt;p&gt;3、插件进程（Extension），fork了渲染进程，每个插件都运行在一个NodeJS宿主环境中，即插件间共享进程。VSCode规定，插件不允许直接访问UI，这和Atom不同。&lt;/p&gt;&lt;p&gt;4、Debug进程，一个特殊的插件进程。&lt;/p&gt;&lt;p&gt;5、Search进程，搜索是密集型任务，单独占用一个进程。&lt;/p&gt;&lt;p&gt;6、进程之间通过IPC、RPC进行通信，这个后面会介绍。&lt;/p&gt;&lt;p&gt;7、LSP和DAP像两座桥梁，连接起语言和调试服务，它们都运行在插件进程中。&lt;/p&gt;&lt;p&gt;因为VSCode基于Electron，Electron基于chromium，所以进程和浏览器架构十分相似。&lt;/p&gt;&lt;h2&gt;进程间通信&lt;/h2&gt;&lt;p&gt;&lt;b&gt;IPC&lt;/b&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;nx&quot;&gt;electron&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ipcRenderer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;s2&quot;&gt;&quot;sendMessageFromRendererProcesses&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;s2&quot;&gt;&quot;渲染进程向主进程发送异步消息&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;electron&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ipcMain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;sendMessageFromRendererProcesses&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;sendMessageFromMainProcesses&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;回应异步消息：&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;VSCode的IPC通信是基于Electron，进程间可以双向通信，并且支持同步异步通信。&lt;/p&gt;&lt;p&gt;&lt;b&gt;RPC&lt;/b&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;BrowserWindow&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;electron&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;remote&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;win&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;BrowserWindow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;width&lt;/span&gt;: &lt;span class=&quot;kt&quot;&gt;800&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;height&lt;/span&gt;: &lt;span class=&quot;kt&quot;&gt;600&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;win&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;loadURL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;https://github.com&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里是渲染进程直接调用Electron的远程模块，重新初始化一个界面BrowserWindow，并且打开一个页面，地址为&lt;code&gt;https://github.com&lt;/code&gt;。RPC一般用于单向调用，如渲染进程调用主进程。&lt;/p&gt;&lt;p&gt;&lt;b&gt;小结&lt;/b&gt;&lt;/p&gt;&lt;p&gt;1、多进程架构，实现了视图与逻辑分离。&lt;/p&gt;&lt;p&gt;2、基于接口编程（LSP、DAP），规范了扩展功能。&lt;/p&gt;&lt;p&gt;3、插件进程，单独开启一个进程。不影响启动速度，不影响主进程和渲染进程，不能直接改变UI样式。缺点，UI可扩展性差，优点，带来了统一的视觉效果和交互风格。&lt;/p&gt;&lt;h2&gt;最简单的插件&lt;/h2&gt;&lt;p&gt;下面是官方的一个搭建插件的教程&lt;/p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//code.visualstudio.com/api/get-started/your-first-extension&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic1.zhimg.com/v2-dc8335c668dc4edf2695a6da12c2b6c4_180x120.jpg&quot; data-image-width=&quot;1012&quot; data-image-height=&quot;506&quot; class=&quot;LinkCard LinkCard--hasImage&quot;&gt;&lt;span class=&quot;LinkCard-backdrop&quot;/&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;Your First Extension&lt;/span&gt;&lt;span class=&quot;LinkCard-meta&quot;&gt;&lt;span&gt;​&lt;svg class=&quot;Zi Zi--InsertLink&quot; fill=&quot;currentColor&quot; viewbox=&quot;0 0 24 24&quot;&gt;&lt;path d=&quot;M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;code.visualstudio.com&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-imageCell&quot;&gt;&lt;img class=&quot;LinkCard-image LinkCard-image--horizontal&quot; alt=&quot;图标&quot; src=&quot;https://pic1.zhimg.com/v2-dc8335c668dc4edf2695a6da12c2b6c4_180x120.jpg&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;npm install -g yo generate-code
yo code
code ./helloworld&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后我们就生成了一个VSCode插件，目录如下，我和一个普通的前端项目没啥区别。我们只需要关心&lt;code&gt;package.json&lt;/code&gt;和&lt;code&gt;extension.ts&lt;/code&gt;。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;package.json&lt;/b&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&quot;engines&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&quot;vscode&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;^1.47.0&quot;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;s2&quot;&gt;&quot;activationEvents&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;onLanguage:java&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;onCommand:java.show.references&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;onCommand:java.show.implementations&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;onCommand:java.open.output&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;onCommand:java.open.serverLog&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;onCommand:java.execute.workspaceCommand&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;onCommand:java.projectConfiguration.update&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;workspaceContains:pom.xml&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;workspaceContains:build.gradle&quot;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;有两个关键字，engines指VSCode兼容版本，activationEvents表示触发事件。onLanguage为语言为java时，输入命令onCommand:java.show.references（通过cmd + p可进入输入命令界面），或者工作区中包含pom.xml文件，这些都会加载插件。插件的加载机制是懒加载，只有触发了指定事件才会加载。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;extension.ts&lt;/b&gt;&lt;/p&gt;&lt;p&gt;extension里导出一个activate函数，表示当插件被激活时执行函数内的内容。Demo里注册了一个命令到VSCode的context上下文中，且当执行&lt;code&gt;hellworld&lt;/code&gt;这个命令时，会弹出一个提示语，我们将提示语由Hello World 改为了 Hello VS Code。&lt;/p&gt;&lt;p&gt;VSCode能自动实现插件项目，我们按F5即可进入调试模式，下面是一个输出提示语的视频。&lt;/p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://www.zhihu.com/zvideo/1294950108916887552&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://zhstatic.zhihu.com/assets/zhihu/editor/zhihu-card-default.svg&quot; class=&quot;LinkCard LinkCard--hasImage&quot;&gt;&lt;span class=&quot;LinkCard-backdrop&quot;/&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;知乎视频&lt;/span&gt;&lt;span class=&quot;LinkCard-meta&quot;&gt;&lt;span&gt;​&lt;svg class=&quot;Zi Zi--InsertLink&quot; fill=&quot;currentColor&quot; viewbox=&quot;0 0 24 24&quot;&gt;&lt;path d=&quot;M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;www.zhihu.com&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-imageCell&quot;&gt;&lt;img class=&quot;LinkCard-image LinkCard-image--square&quot; alt=&quot;图标&quot; src=&quot;https://zhstatic.zhihu.com/assets/zhihu/editor/zhihu-card-default.svg&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h2&gt;源码解析&lt;/h2&gt;&lt;p&gt;源码解析分为4大块。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;目录结构&lt;/li&gt;&lt;li&gt;源码调试&lt;/li&gt;&lt;li&gt;工作台（WorkBench）加载&lt;/li&gt;&lt;li&gt;插件（Extension）加载&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;目录结构&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b367d5e51146312885847df1f573a609_b.jpg&quot; data-rawwidth=&quot;1578&quot; data-rawheight=&quot;1138&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-b367d5e51146312885847df1f573a609_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-rawwidth=&quot;1578&quot; data-rawheight=&quot;1138&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-b367d5e51146312885847df1f573a609_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-b367d5e51146312885847df1f573a609_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;上图分为上下两块内容，上面是VSCode外层的目录结构。下面为VSCode内部组织代码的规则，以base目录为例，它包含了个模块，vs目录下的其他模块，code、editor也是按照这个规则。&lt;/p&gt;&lt;h2&gt;源码调试&lt;/h2&gt;&lt;p&gt;项目的搭建比较简单，可以直接看官方的教程，&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/microsoft/vscode/wiki/How-to-Contribute&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;How to Contribute&lt;/a&gt;。Mac的话主要一下Python版本和NodeJS脚本。&lt;/p&gt;&lt;p&gt;&lt;b&gt;web版启动&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;桌面版启动&lt;/b&gt;&lt;/p&gt;&lt;p&gt;本文讲的内容都是桌面版，启动完成之后，我们可以看到VSCode给我们提供的源码调试工具，OSS。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9d54e2a15b1e06e6c0a0f8f443e28b74_b.jpg&quot; data-rawwidth=&quot;824&quot; data-rawheight=&quot;316&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-9d54e2a15b1e06e6c0a0f8f443e28b74_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-rawwidth=&quot;824&quot; data-rawheight=&quot;316&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-9d54e2a15b1e06e6c0a0f8f443e28b74_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-9d54e2a15b1e06e6c0a0f8f443e28b74_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;调试模式&lt;/b&gt;&lt;/p&gt;&lt;p&gt;调试模式和桌面启动有所不同，我们直接在VSCode里打开源码项目，进入调试面板，先Launch VS Code，然后就可以选择是调试主进程、渲染进程还是插件进程。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0565315a78665cc0347637403218afc9_b.jpg&quot; data-rawwidth=&quot;1536&quot; data-rawheight=&quot;1064&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-0565315a78665cc0347637403218afc9_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-rawwidth=&quot;1536&quot; data-rawheight=&quot;1064&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-0565315a78665cc0347637403218afc9_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-0565315a78665cc0347637403218afc9_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;查看所有进程&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-41d28594e400bfb151f8526e22afc70f_b.jpg&quot; data-rawwidth=&quot;1786&quot; data-rawheight=&quot;506&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-41d28594e400bfb151f8526e22afc70f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-rawwidth=&quot;1786&quot; data-rawheight=&quot;506&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-41d28594e400bfb151f8526e22afc70f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-41d28594e400bfb151f8526e22afc70f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;启动完成之后，通过命令行查看进程情况，上面我截取了插件进程相关的信息。如果是源码情况下，关键词就是OSS Helper。我们正常使用VSCode，就可以用关键词Code Helper查看进程相关情况。&lt;/p&gt;&lt;p&gt;&lt;b&gt;进程类型介绍&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-90e6d1eaa274a700c2b1e4fe46078876_b.jpg&quot; data-rawwidth=&quot;1692&quot; data-rawheight=&quot;898&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-90e6d1eaa274a700c2b1e4fe46078876_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-rawwidth=&quot;1692&quot; data-rawheight=&quot;898&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-90e6d1eaa274a700c2b1e4fe46078876_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-90e6d1eaa274a700c2b1e4fe46078876_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这是VSCode进程的类型，--type就是VSCode启动进程时识别进程类型的标识。有渲染进程，插件进程，GPU进程，可关闭，Watcher进程，和Webpack的Watch有些相似，都是监控文件变化的，搜索进程。插件是由渲染进程fork出来的，且一般情况插件共享一个进程，Debug进程比较特殊，它单独占用一个进程。&lt;/p&gt;&lt;h2&gt;源码之加载工作台&lt;/h2&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// src/main.js
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// 获取缓存文件目录地址和语言配置，用AMD Loader加载真正主入口
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;protocol&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;electron&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;once&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;ready&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;onReady&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;onReady() {&lt;/span&gt;
 &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;cachedDataDir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;nlsConfig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Promise&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;all&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;nodeCachedDataDir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ensureExists&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;resolveNlsConfiguration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;startup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;cachedDataDir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;nlsConfig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;startup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;cachedDataDir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;nlsConfig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;kr&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;./bootstrap-amd&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;vs/code/electron-main/main&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// src/vs/code/electron-main/main.ts
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// 创建服务，初始化编辑器实例
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;code&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;CodeMain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;CodeMain&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;main() {&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;startUp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kr&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;startup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;args&lt;/span&gt;: &lt;span class=&quot;kt&quot;&gt;ParsedArgs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Promise&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;instantiationService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;instanceEnvironment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;environmentService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;createServices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bufferLogService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;instantiationService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;createInstance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;CodeApplication&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;mainIpcServer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;instanceEnvironment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;startup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;VSCode初始化实例的方式比较特殊，采用的是依赖注入的模式，关于VSCod依赖注入的文章，可以看腾讯同学写的文章，&lt;a href=&quot;https://zhuanlan.zhihu.com/p/96902077&quot; class=&quot;internal&quot;&gt;vscode 源码解析 - 依赖注入 &lt;/a&gt;。&lt;/p&gt;&lt;blockquote&gt;// 打开一个窗口 &lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// src/vs/code/electron-main/app.ts
class CodeApplication extends Disposable {
  async startup(): Promise&amp;lt;void&amp;gt; {
    const appInstantiationService = await this.createServices(machineId, sharedProcess, sharedProcessReady);

    const windows = appInstantiationService.invokeFunction((accessor) =&amp;gt;
      this.openFirstWindow(accessor, electronIpcServer, sharedProcessClient)
    );
  }

  private openFirstWindow(accessor: ServicesAccessor, electronIpcServer: ElectronIPCServer, sharedProcessClient: Promise&amp;lt;Client&amp;lt;string&amp;gt;&amp;gt;): ICodeWindow[] {
    const windowsMainService = this.windowsMainService = accessor.get(IWindowsMainService);
    return windowsMainService.open({
      context: OpenContext.API,
      cli: { ...environmentService.args },
      forceEmpty: true,
      gotoLineMode: true
    });
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;// 打开浏览器窗口，并加载配置&lt;br/&gt;// src/vs/platform/windows/electron-main/windowsMainService.ts &lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;kr&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;WindowsMainService&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Disposable&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;IWindowsMainService&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;open() {&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;doOpen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;doOpen() {&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;openInBrowserWindow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;openInBrowserWindow() {&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;createdWindow&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;instantiationService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;createInstance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;CodeWindow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;extensionDevelopmentPath&lt;/span&gt;: &lt;span class=&quot;kt&quot;&gt;configuration.extensionDevelopmentPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;isExtensionTestHost&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!!&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;configuration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;extensionTestsPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;doOpenInBrowserWindow() {&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;configuration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 加载页面
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;// src/vs/code/electron-main/window.ts&lt;br/&gt;// this._win 为 BrowserWindow 对象，是electron一个模块 &lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;class CodeWindow extends Disposable {
  load() {
    this._win.loadURL(this.getUrl(configuration));
  }

  private getUrl() {
    let configUrl = this.doGetUrl(config);
    return configUrl;
  }

  private doGetUrl(config: object): string {
    // 打开 VSCode 的工作台，也就是 workbench
    return `${require.toUrl(
      &quot;vs/code/electron-browser/workbench/workbench.html&quot;
    )}?config=${encodeURIComponent(JSON.stringify(config))}`;
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;src/vs/code/electron-browser/workbench/workbench.html&lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;html&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;body&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;aria-label&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;

  &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- Init Bootstrap Helpers --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;script&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;../../../../bootstrap.js&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;script&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;script&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;../../../../vs/loader.js&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;script&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;script&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;../../../../bootstrap-window.js&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;script&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;

  &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- Startup via workbench.js --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;script&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;workbench.js&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;script&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;html&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;源码之插件加载&lt;/h2&gt;&lt;blockquote&gt;src/vs/code/electron-browser/workbench/workbench.js &lt;br/&gt;加载桌面插件，加载插件服务&lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;bootstrapWindow.load(
  [
    &quot;vs/workbench/workbench.desktop.main&quot;,
    &quot;vs/nls!vs/workbench/workbench.desktop.main&quot;,
    &quot;vs/css!vs/workbench/workbench.desktop.main&quot;,
  ],
  (workbench, configuration) =&amp;gt; {
    // …
  }
);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;src/vs/workbench/workbench.desktop.main.ts&lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;import &quot;vs/workbench/services/extensions/electron-browser/extensionService&quot;;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;src/vs/workbench/services/extensions/electron-browser/extensionService.ts &lt;br/&gt;监听生命周期钩子，实例化 ExtensionHostManager&lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;kr&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ExtensionService&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;AbstractExtensionService&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;IExtensionService&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_lifecycleService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;when&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;LifecyclePhase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Ready&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// reschedule to ensure this runs after restoring viewlets, panels, and editors
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;        &lt;span class=&quot;nx&quot;&gt;runWhenIdle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_initialize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/*max delay*/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kr&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_initialize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Promise&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_startExtensionHosts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kr&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_startExtensionHosts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isInitialStart&lt;/span&gt;: &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;initialActivationEvents&lt;/span&gt;: &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[])&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// extensionHosts 为LocalProcessExtensionHost、RemoteExtensionHost、WebWorkerExtensionHost。
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;      &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;extensionHosts&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_createExtensionHosts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isInitialStart&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;extensionHosts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;forEach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;extensionHost&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;processManager&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_instantiationService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;createInstance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ExtensionHostManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;extensionHost&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;initialActivationEvents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;src/vs/workbench/services/extensions/common/extensionHostManager.ts&lt;br/&gt;fork渲染进程，并加载 extensionHostProcess&lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;class ExtensionHostManager extends Disposable {
  constructor() {
      this._proxy = this._extensionHost.start()!.then();
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;src/vs/workbench/services/extensions/electron-browser/localProcessExtensionHost.ts&lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;class LocalProcessExtensionHost implements IExtensionHost {
  public start(): Promise&amp;lt;IMessagePassingProtocol&amp;gt; | null {
    // ...
    const opts = {
      env: objects.mixin(objects.deepClone(process.env), {
        // 加载插件进程
        AMD_ENTRYPOINT: &#x27;vs/workbench/services/extensions/node/extensionHostProcess&#x27;,
      }),
    }

    // Run Extension Host as fork of current process
    this._extensionHostProcess = fork(getPathFromAmdModule(require, &#x27;bootstrap-fork&#x27;), [&#x27;--type=extensionHost&#x27;], opts);
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;src/vs/workbench/services/extensions/node/extensionHostProcess.ts&lt;br/&gt;插件进程的入口，同时开启插件激活逻辑&lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;import { startExtensionHostProcess } from &quot;vs/workbench/services/extensions/node/extensionHostProcessSetup&quot;;
startExtensionHostProcess().catch((err) =&amp;gt; console.log(err));&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;src/vs/workbench/services/extensions/node/extensionHostProcessSetup.ts&lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;export async function startExtensionHostProcess(): Promise&amp;lt;void&amp;gt; {
    const extensionHostMain = new ExtensionHostMain(
        renderer.protocol,
        initData,
        hostUtils,
        uriTransformer
    );
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;src/vs/workbench/services/extensions/common/extensionHostMain.ts&lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;export class ExtensionHostMain {
  constructor() {
    // must call initialize *after* creating the extension service
        // because `initialize` itself creates instances that depend on it
        this._extensionService = instaService.invokeFunction(accessor =&amp;gt; accessor.get(IExtHostExtensionService));
        this._extensionService.initialize();
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;src/vs/workbench/api/node/extHost.services.ts&lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;import { ExtHostExtensionService } from &#x27;vs/workbench/api/node/extHostExtensionService&#x27;;

// 注册插件服务
registerSingleton(IExtHostExtensionService, ExtHostExtensionService);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;src/vs/workbench/api/node/extHostExtensionService.ts&lt;br/&gt;继承了抽象类，AbstractExtHostExtensionService&lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;export class ExtHostExtensionService extends AbstractExtHostExtensionService {

}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;src/vs/workbench/api/common/extHostExtensionService.ts&lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;abstract class AbstractExtHostExtensionService extends Disposable {
  constructor() {
    this._activator = new ExtensionsActivator();
  }

  // 根据activationEvent事件名激活插件
  private _activateByEvent(activationEvent: string, startup: boolean): Promise&amp;lt;void&amp;gt; {
    return this._activator.activateByEvent(activationEvent, startup);
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;整体的流程图如下&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f5c2ba69281ee1c3d04a01cc6572fbc4_b.jpg&quot; data-rawwidth=&quot;1784&quot; data-rawheight=&quot;912&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-f5c2ba69281ee1c3d04a01cc6572fbc4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-rawwidth=&quot;1784&quot; data-rawheight=&quot;912&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-f5c2ba69281ee1c3d04a01cc6572fbc4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-f5c2ba69281ee1c3d04a01cc6572fbc4_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;1、VSCode使用了哪些技术，TS、Electron、Monaco、LSP、DAP。&lt;/p&gt;&lt;p&gt;2、多进程架构（记住图即可）。&lt;/p&gt;&lt;p&gt;3、从一个Hello World插件入手。&lt;/p&gt;&lt;p&gt;4、源码解析，从加载工作区，到开启插件进程，最后激活插件。&lt;/p&gt;&lt;h2&gt;参考文献&lt;/h2&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d9605aef72e0b5d41eb28469e2c866ce</guid>
<title>信息物理系统中的安全控制算法</title>
<link>https://toutiao.io/k/sgo0jvm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsWeVa3uH5PnFOop5GajBtKXFbib6Y6WfXR8n6f0xhx57oj7tHgHD6ia67upvv05rNeZxoGsVU1DMFUg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;span title=&quot;&quot; opera-tn-ra-cell=&quot;_$.pages:0.layers:0.comps:24.title1&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;  莫一林&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;现任清华大学自动化系副教授。他于2007年在清华大学自动化系获得学士学位，2012年于美国卡内基梅隆大学电子与计算机工程系获得博士学位。加入清华大学之前，他曾于卡内基梅隆大学，加州理工学院进行博士后研究。2015年他加入了新加坡南洋理工大学电子与电机工程学院，任助理教授，2018年返回清华大学自动化系任职。目前担任控制领域顶级期刊Automatica的Associate Editor。他的主要研究方向包括控制系统安全与网络化控制系统，及其在智能电网、机器人与无人驾驶领域的应用。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;中文讲的“安全”，其实基本上包含了英文中的两重含义，一个是Safety，一个是Security。&lt;/span&gt;&lt;span&gt;信息物理系统中的安全问题主要是指Security，也就是说，如果有人想要攻击你，在这种情况下，怎么能够保证系统的正常运行？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;信息物理系统&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“信息物理系统”，这个词大概是2006年由美国的National Science Foundation（&lt;/span&gt;&lt;span&gt;美国国家科学基金会&lt;/span&gt;&lt;span&gt;）最开始提出来的。信息物理系统本质上来说是Computation（&lt;/span&gt;&lt;span&gt;计算&lt;/span&gt;&lt;span&gt;）、Communication（&lt;/span&gt;&lt;span&gt;通讯&lt;/span&gt;&lt;span&gt;）、Control（&lt;/span&gt;&lt;span&gt;控制&lt;/span&gt;&lt;span&gt;）三C的融合，把三个C互相之间结合起来，嵌入到一个物理世界当中，从而能够使得整个系统更好地感知或者控制物理世界。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如，无人驾驶就是一个信息物理系统，因为无人驾驶本身是有一个物理的实体，有很多传感器来收集数据，这些数据经过通讯上传到计算机或者云上面，同时车和车之间可能还有通讯，然后去做感知、去做导航，再反馈到无人车的执行单元，最后反馈到物理空间。这些过程既包括了计算，也包括了控制的一些问题。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5753768844221105&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWeVa3uH5PnFOop5GajBtKXXwWdlJ3pT3hAXKyGD15rv1NMIctqfpWib9t3lqlk3ckJ9DdrcjFlgUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;796&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;其实，信息物理系统是一个很大的概念。之前大家说安全，其实更多的是想到计算机安全或者网络安全，现在更多的是手机这类智能设备的安全。但是，信息物理系统安全为什么现在被提上了议程？这其中主要的原因是传统的控制系统，比如汽车内部的通讯是通过CANBUS实现的，这样的通讯本质上来说是一个独立的、专用的网络，并不和其他网络产生任何的连接。所以在这种情况下，就很难去大规模地攻击这样一个系统。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;信息物理系统的安全威胁&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是，现在智能化逐渐成为了一种趋势，而且智能化的一个核心的事情，就是要使用很多新兴的感知和网络的技术，实现万物互联。在这种背景下，就会产生非常多的问题，因为所有东西都联网了，那么系统受到攻击的可能性就放大了很多。在这种情况下，怎么保证整个系统的稳定性或者说维护系统正常运行，这是一个很大的挑战。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.746031746031746&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWeVa3uH5PnFOop5GajBtKX24tanUR0qYFE5xPZfMY7XZEeJ914mDLCohPsCOviclvRLjS911aLBibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;567&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;上图是我们之前说的智能家居的一个示意图。智能家居希望人们可以通过比如手机App去控制家里的电器，但是一旦家里的电器都上网之后，智能家居控制系统的安全就会变得非常重要，如果当一个攻击者可以操纵成千上万个家庭电器的话，这就可能带来非常严重的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们实验室从2010年前就开始做信息物理系统安全方面的研究。当时，有黑客设计了“震网病毒”，它的目标是伊朗用来提纯铀235的离心机。“震网病毒”破坏了伊朗上千台的离心机，最后对伊朗核计划造成了很大的损害。这也算是一个利用“信息战”成功带来破坏的一个例子。也是因为这个事情，让我们把信息物理系统的安全问题迅速提上了日程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;震网病毒&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“震网病毒”的例子属于国家行为，可能比较少见，现在针对一般信息物理系统的攻击行为也越来越多。比如2016年，美国机构的报告就指出，全年一共有290多次针对美国工业控制系统的攻击，覆盖了制造业、通讯、能源等多个行业。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.46949602122015915&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWeVa3uH5PnFOop5GajBtKX2LHISt1fLviaoMNn3Wv3R4HcjJS4icYGxgvM2VuDKrMsm4slicrW68Neg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;754&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;攻击有很多种类型，先说比较常见的。如果系统联网，可以通过网络去侵入系统；即使系统没有联网，那么还有一些方式方法，比如像“震网病毒”的例子，是通过U盘一层一层带进去的。这些方式都能造成很大的破坏。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我觉得比较值得关注的是第二个问题，一般做控制或者这种背景的研究人员，很多时候对计算机安全并不是特别有经验，那么开发的系统就可能会存在很多的漏洞。甚至有很多软件的开发者自己都不知道自己的系统有漏洞，但是黑客就可以发现你的漏洞。比如说像“震网病毒”的例子，伊朗不知道系统有问题，但黑客有内部资料，发现这个系统有问题，然后就利用这种漏洞去侵入了伊朗的系统。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大家比较担心的一个事情就是现在的系统变得越来越复杂，比如一辆车可能有几百个ECU（&lt;/span&gt;&lt;span&gt;Electronic Control Unit&lt;/span&gt;&lt;span&gt;），一个波音787可能有上百万个零件，这上百万零件中的70%都是外包出去的，而一级外包商可能再外包给二级、三级，最后整个供应链就变得很复杂，这相当于是全球生产，最后汇集到西雅图去装配。那么在这个过程中，怎么保证装到系统上的每一个零件都是安全的，这也是一个值得思考的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;黑客攻击汽车系统&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实，在传统的汽车信息物理系统当中，漏洞还是有很多的。比如2015年有一个比较著名的事件，有两个黑客（&lt;/span&gt;&lt;span&gt;这两个人应该只是研究者，并不是真的想要搞破坏&lt;/span&gt;&lt;span&gt;）通过攻击克莱斯勒吉普的一款车，入侵了这辆车的显示信息，就是所谓的implementation，还包括一些娱乐系统，然后通过这个系统，进入车内部的网络来控制这个车，比如说方向、控制刹车，甚至包括安全气囊等等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有人可能会说，像你们碰到这些问题，在计算机里面也都有，而且已经研究了很长时间了，为什么还要单独提这样一个概念，这个信息物理系统安全中到底有什么新的东西吗？我觉得这个核心价值在于：传统的研究主要都是在所谓的Cyber Physical System。而信息物理系统，它的核心的是说那些有“物理”的系统，那么这个物理系统就带来了很多的挑战。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先，从传统上来说，如果一个计算机受到攻击，最差的情况，也就是将这个计算机关闭就结束了。但是如果是一个高速行驶的车，无法将它直接关闭，只能让它缓慢地停下来，但是停下来这件事情本身因为有物理系统的参与，所以就不是一个简单的事情。而对于无人机来说，甚至都不能让它停下来，必须让它以一定的速度去飞，因为如果是固定翼无人机，停下来就可能意味着坠毁，所以在这个过程中，物理系统带来了很多的挑战。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外一个问题是，我们不一定能够让物理系统停下来，比如说如果一个电网受到攻击，那么我们希望能够尽可能把被攻击的地方隔离出来，而不是要让整个地区比如北京市出现停电。这个意思就是说，在系统受到攻击的时候，要让这个系统还能带着“伤”去运行，而不是一旦有一点风吹草动就需要重启，这个也是一个很大的问题。最后，这些物理系统其实都需要非常高的可靠性，比如对飞机来说，我们之前跟波音做过一些项目，他们要求放上飞机的任何东西都需要经过鉴定，必须保证飞机有极高的可靠性，要远远高于杀毒软件要能检测出99%病毒的这种可靠性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很多传统的信息安全方法，都是一个所谓的Best of Effort Approach，就是说，尽可能地提供能提供的最好的服务，但是并不能给出特别多的保证，因为对于一些需要非常高可靠性的系统，即便存在很小的可能也许就隐藏着一个很大的威胁。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;为&lt;span&gt;信息物理系统&lt;/span&gt;构建“护城河”&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在信息物理系统里面，为了保证这个系统的安全，我们需要保证这个系统有非常高的可靠性。其实，任何一个单一的方法都是很难完成这个目标的，我们需要是一个多层的防御机制，它就像一个城堡一样，外面还有一个护城河，中间有一个城墙，里面还有一个城墙，必须要层层地设防，只有这样才能解决这个问题。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.470873786407767&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWeVa3uH5PnFOop5GajBtKXebSWvSJl9snqeibULPUYJrjB5f4FFFY2ucsW6Eb4CajcgWyDoFnZ9rA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;824&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;我觉得这其中有几个比较关键的点，比如Prevention、 Detection、 Resiliency 、Recovery。其中，Prevention就是怎么防止别人进来，那么这个地方可能是需要更好的防火墙，比如说杀毒软件等等这些东西。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然，我们不可能百分之百地把别人都挡在系统之外，如果有人进来了之后，我们就需要去检测这个系统到底有没有被入侵，包括在一个大的系统怎么去定位哪几个部分被入侵了，这就是所谓的Detection。另外，我们设计一个系统，需要考虑到一定的Resiliency，比如说有一个汽车上面有一个零件坏了，这个系统就完蛋了，那么这个系统就不是很有韧性，所以系统能不能带“伤”运行，也是一个需要考虑的因素。最后，当发现这个系统出现问题之后，我们可能就会需要有一个所谓的恢复过程，比如重启等等手段。整体来说，我觉得要通过很多方面，通过多层防御来保证信息物理系统的安全。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;信息物理系统中的安全控制算法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;今天，我想给大家讲一讲我们在信息物理系统做的一些比较初步的工作，主要讲两个方面：一个是检测，一个是韧性。首先，从控制这个方式来说，怎么去思考信息物理系统安全性这个问题？当然，并不是说控制就能够彻底解决这个问题，还是需要一个多层的防御。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;控制&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;控制，到底能给我们带来什么? 以离线设计系统为例，首先我们可以通过控制找到这个系统关键的部件，然后对这些部件做额外的冗余设计。在这个系统没有上线之前，我们可以对系统做一些可控、可观的分析，进而提升系统本身的韧性；上线之后，我们可以利用传统的方法如故障诊断，当然这里就变成了入侵诊断和入侵定位的问题。此外，我们还可以做一些鲁棒控制，保证系统的控制器在有攻击情况下依然能够容错。最后还有一个问题，一个大的系统想要让它更安全，我们到底应该先加固哪个地方？这都是控制可以提供给我们的一些东西。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;检测&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来，我主要讲一下关于检测的问题，我们也是受到“震网病毒”例子的启发之后开始做了相关的研究。“震网病毒”是2010年被发现的，从计算机的角度来说，它是一个很复杂的、很难防御的病毒。但是从控制角度来说，它的策略其实相当简单。离心机本身是一个类似于快速旋转东西，如果想要毁坏离心机，那就需要让它转的比原本设定的转速快很多，但是如果只是让它转的特别快的话，由于整个系统有传感器，传感器就会发现离心机转速太快，从而触发报警，报警之后就会有技术人员前来检查，整个过程并不能对这个系统造成很大破坏。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是，“震网病毒”采取的一个策略是先不去攻击这个系统，而是在这个系统正常运行的时候，记录下它的传感器输出是什么情况（&lt;/span&gt;&lt;span&gt;比如说离心机的转速&lt;/span&gt;&lt;span&gt;）。为了很好地说明问题，我们假设离心机每秒1000转，“震网病毒”就记录了很多这样的数据。然后，当真正开始去攻击系统的时候，震网病毒就会把它记录的数据做一个重放，就是说把整个系统的转速调到比如2000转的时候，会使用之前正常的数据去替换异常数据，那么系统操作员看到依然是正常的转速，就不会察觉这个系统已经出现问题了。比如在一些警匪片中，匪徒会去把他们想要抢劫的地方的监控视频的影像做一个重放，比如用前一天没有异常的影像去覆盖掉抢劫的影像，跟“震网病毒”的策略很类似，在信息安全领域也是比较常见的“重放”攻击。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5145530145530145&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWeVa3uH5PnFOop5GajBtKXsdicichnBeO0ZcN2MwIzAricfSUuC3LhiaGxZj4iabVHJamPyZhDfG5T0Tg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;962&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;大家可以简单地看一下这个系统的框图，比如说我们做一个离心机或者一个其他的物理系统，需要做控制。那么我们使用传感器去监测这个系统，传感器的输出会给一个估计器，对于无人驾驶来说，可能这个应该叫感知，而不能简单地叫估计，因为它的功能可能会更复杂。但不管怎样的系统，我们都需要通过一个这样的东西，对收集到的信息做一个处理，然后得到系统的状态，再根据状态来设计系统的控制，最后反馈给物理系统。估计器可能还会输出一些信息传递到故障检测器里面，然后故障检测器会检测收到的信息y(k)是不是有问题，大概就是这样的一个系统。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6827661909989023&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWeVa3uH5PnFOop5GajBtKXvYajaiazPOUiakhDFR7swX0Utt1X03k8icl7vwZ11aEd3DddvcNnFJaPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;911&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;对于攻击来说，也分成了两个阶段，第一阶段攻击者先不去修改系统控制这一部分，只是被动的去记录一些传感器的信号。当记录足够多的传感器信号之后，进入第二阶段，开始去修改系统的控制信号，修改这个信号的同时，攻击者还要做的另外一件事，就是要把系统的传感器的这一边给断开，从而把传感器的真实数据替换成之前记录的正常数据。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5029411764705882&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWeVa3uH5PnFOop5GajBtKXwNRicNMz6QDeia0IP6yI3GsO14DiaSYGyYFQXibBOF2ibBkXpJdBXE9TibSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1020&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;由于系统本身是有故障检测器的，所以最原始的系统在设计的时候根本没有考虑安全性，没有考虑是否能检测出来所谓的“重放”攻击。事实上，“重放”攻击并不是总是有效的，我们发现有一些系统可以检测到“重放”攻击，而有一些系统是不能检测的。如上图所示，Y轴表示检测器报警的概率，报警概率最大值是1。整个系统的重放是在时刻零开始，那么作为第一个系统，也就是蓝线标记的系统，我们可以看到在重放开始的时候，它有一个比较短暂的损害过程，就是说这个时候报警的概率有一些，但是也不是特别高，然后很快报警概率就缩减到一个接近于0的值；而第二个系统，也就是红线标记的系统，我们发现它的报警概率随着“重放”变得越来越高，最后会趋向于1。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5903257650542941&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWeVa3uH5PnFOop5GajBtKXSUONVIR9cCcYCTia0uPVks2ibJkxXsbjPVJNUFomSkFm0l7jlFpRAGGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1013&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;但是，很多系统跟蓝线标记的系统一样，没有办法检测出“重放”攻击。那就可能会陷入一个问题，攻击者会背着系统的操作人员在系统里面做一些手脚。针对这种问题，我们设计了一种主动检测的方法。刚才所说的检测是被动的检测，通过收集很多的传感器的信息，然后去看传感器的信息是不是和这个系统本身模型是相符合的。但这个方法存在一个很大的问题，比如控制离心机，它的转速就一直是1000转，那么当传感器告诉我们转速是1000转时，事实上这个传感器从某种角度来说就没有给我们任何信息，因为系统控制的很好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们的想法是能否可以不把系统控制得这么好，我们主动在控制信号中加一个扰动信号，也可以叫做水印信号。这就是说水印信号是藏在真实的控制信号中的一个比较小的噪声。如果我们的系统没有受到攻击的话，那么这个噪声就会被传感器监测到，然后进入估计器，估计器能够在传感器输出的信号中识别这个噪声。当系统遭遇了“重放”攻击，因为系统的这个噪声是完全随机的，那么传感器里面的随机信号跟现在接收到的随机信号就对应不上，因为现在接受到的随机信号是之前的信号“重放”过来的。因此，我们可以通过添加一个这样小的扰动的方式去刺激这个系统，然后让这个系统对这个小的扰动产生一个响应，这样我们就可以去检测出这个系统到底有没有出问题了。我们称这种方式为主动检测方式，主动地去激励系统，而不是被动的去收集信息。其实，这个方法也跟计算机科学领域所说的Challenge-Response比较相似，通过给这个系统一个Challenge，然后这个系统就要返回Response，这样就能感知到整个系统、整个控制回路是不是都是完好无损的。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.641051567239636&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWeVa3uH5PnFOop5GajBtKXYdwrtafB6ctyYPzdDiakZAoicUeYpEktjCrEiaHxYb3Tm7MbvicTiavZDmQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;989&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;上图是我们做的一些实验的结果。针对的是一个非常简单的系统，大家可以认为这个是噪声的能力，我们发现随着加的能量越高，检测的概率会变得越高。我们大概的处理思路就是这样的，后面会有一些技术的问题，比如说加个扰动信号进去之后，系统的控制就没那么好，这产生代价会有多大？代价和检测性能之间会存在什么样的关系？其中的Trade Off到底应该怎么样去做权衡？我们可以把它看成一个类似于优化的问题，然后我们可以去做一个求解。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4911417322834646&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWeVa3uH5PnFOop5GajBtKXA7ERYyVanPyhUZ6C0DNp1TDK6Oka0Ik2b310zgmneyV20anh2n0TyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1016&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;事实上，我们现在做的这些设计都是基于模型已知的，因为做系统控制通常来说大部分都是假设系统模型已知的。目前，基于数据的方式越来越流行了，我们也尝试去做了一些数据驱动的实验。其中我们需要作一些简单的假设，比如系统本身是稳定的，我们知道x到底有几维，其他具体的参数假设是未知的。然后我们可以去做一些数据驱动的方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;想法也很简单，就是我们要在这个地方加一个随机信号，加了这个随机信号，这个系统会产生一些刺激，产生这些刺激之后，我们就可以通过输入和输出的关系来对系统内部的具体参数做一些推断。关于最好的信号具体应该怎么加？检测装置应该怎么去做？这些属于具体的细节，在这里我就不展开仔细讲了。下面是我们针对化工领域常用的TEP系统做的一个仿真。虚线是我们在没有模型知识的情况下，通过数据学习了水印信号和检测器的最优设计，得到的检测器的输出。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看到，跟有模型的实线吻合得非常好。另外，这个系统在100时刻收到了“重放”攻击，可以看到我们的水印方法可以有效地检测到攻击。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.650200267022697&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWeVa3uH5PnFOop5GajBtKXn327YeaUG2aicu8gBtAYxHSltPw2ibXAlYBVhmNhWQPgCia5rK1j3yZXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;749&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;算法设计&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面我想讲的是一个有韧性的算法到底应该怎么去设计。这里讲的也是一个非常简单的问题，类似于一个简单的状态估计的问题。比如说自动驾驶的汽车里面有很多传感器都可以给这个车做定位，比如雷达、GPS、IMU、视觉传感器，那么我们应该怎么把这个东西给融合起来，这就是一个很传统的状态估计的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是一个非常简化模型，有很多传感器，每一个传感器都在测量一个叫做状态的东西，这个状态是记做x，传感器的测量值记做z。当然这里指的是一个简化的线性高斯模型，就是说测量值是真实状态的一个线性函数加上一定的噪声。比如说最简单的例子：有三个传感器，这三个传感器都在测量位置，这个位置在这里假设它是一个一维的信号，三个传感器都在测量位置，都带有一些噪声。这种情况下融合的规律很简单，就是求这三个测量值的平均值，也可以证明在很多意义下是最大似然，或者是最小均方误差的一个估计，这些都不是很很难。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是问题是，如果针对这样的一个估计器，假设有一个传感器存在很大的问题，比如说有一个传感器它可能特别大或者特别小，就会把整体的估计值带偏，那么这就会产生一个非常严重的后果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然这个问题也可以说非常简单，因为这三个传感器都在测量同样的内容，就知道这三个传感器的测量值应该是接近的，如果其中有一个跟另外两个之间差距很大，那么我们就可以认为这个传感器是存在问题的，就可以把它剔除出去。这其实是一种叫做坏数据检测的想法，就是把跟其他数据不匹配的数据给剔除掉，这样的做法感觉上是比较简单，但是其实也不是那么简单。因为这个模型是一个非常简单的模型，就是三个传感器都在测一个同样的东西、同样的状态，因此可以说如果有一个跟其他两个差得很多，就是这个传感器有问题。但是假设我们在测不同的状态，比如说有的传感器在测这个房间的温度，有的在测走廊的温度，有的在测另一个房间的温度，那么它们之间的数据怎样叫做匹配，怎样叫做不匹配，这个问题就变得很复杂了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再比如说，无人驾驶车的GPS和雷达都在测位置，但是两个位置可能是在不同时间测的，假如这个传感器告诉我现在在这里，而另外一个传感器告诉我说下一个时刻在那里，这种情况下判断这两个数据到底匹配不匹配，这个就是一个很复杂的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此，我们这个地方的想法是能否可以不用这种坏数据检测的方法，因为使用坏数据检测，首先必须要定义什么叫数据匹配。实际上，定义的一般的方法，也是先做一个状态估计，然后通过状态估计去算残差，再通过残差去确定数据是不是匹配，而我们想直接把一个好的状态估计计算出来。所以这里我们考虑这样的一个问题，z是一个真实的传感器的估计值，我们认为这个估计值等于状态的一个线性函数加上一个噪声，可能会有一些传感器受到攻击，那么要额外在这真实的估计值上加上一个攻击项。z里面既有噪声也有攻击，噪声一般考虑是一个比较小的数，比如像高斯可能有一个固定的方差，它不会特别大，但是噪声会影响到所有的传感器。而作为攻击来讲，我们认为攻击和噪声不一样，攻击可能是一个任意值，也就是说它可能很大也可能很小，但是这个攻击只能影响有限的传感器，比如整个系统里面有10个传感器，可能只有1个受到攻击，如果10个都受到攻击，当然这个系统基本上就完蛋了，所以一般只有一小部分传感器受到攻击，然后在这种情况下，我们到底应该怎么去解决这个问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们提出利用凸优化的方法去求解这个问题，大概想法是：每一个传感器的测量值，当然这个测量值可能是受到攻击之后的值，假设这个系统既没有攻击也没有噪声的话，那么应该是等于。但是，因为有可能有攻击，也有可能有噪声，所以这个东西肯定是不相等的，就认为它是第个传感器的残差，肯定不是等于0的。那么在这种情况下，我们希望找到一个很好的x让残差尽可能小，就是希望去最小化这样一个残差的函数。我们在这里假设是凸的，同时它是对称的、非负的。事实上也可以证明有很多种的估计器，都可以写成这种形式，比如说刚才我们说的最小二乘估计器。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们可以再看一些例子，比如有这样的一个问题，还是跟刚才完全一样，有三个传感器都在监测状态，然后同时有一些噪声，然后假设有一个传感器可能会受到攻击。在这种情况下，如果去优化平方的话，肯定是有问题的，因为平方得出来的是说你的状态估计应该是平均值，平均值本身是不太稳定的。但是你不去优化平方和而是优化绝对值的和，那么这样的话你的估计就会是一个中位数，中位数就是说去掉最大、去掉最小，中间的那个数，那么这样的话，应该是一个比较好的结果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过这个东西，我们就可以得到类似于一个安全估计的一个充分条件，就是说你需要保证两件事情，当然这个是从数学上来说比较简单的想法。就是说首先每一个人所能产生的力必须是一个有限的，这个力其实本质上来说就是斜率，就是说它的最大的斜率必须是有限的。然后，另外就是说，你任何P个人所产生的力一定要小于剩下的人所产生的力，因为在这里我假设有P个人可能是有问题的，这样的话P个人会有问题的话，不会把整个系统给带跑，大概是这样。当然，反过来你可以证明这两个条件也是必要的。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4043977055449331&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWeVa3uH5PnFOop5GajBtKXicCyib7jDBbk24cZicpIXuRgS2HXgHibepsDaIfqZe450c0icibM1LrW0aSg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1046&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;当然，我们后面还做了很多关于动态系统的，因为时间可能不太多，这里就不展开了。2015年到2018年期间，我在新加坡，当时我们接了新加坡国防部一个关于自动驾驶的项目，他们也是比较关心自动驾驶中的安全问题，这里给大家展示的是我们在一个仿真系统上做的一些东西。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;问题是这样的，现在系统里面一共是有三个用于定位的传感器：IMU、雷达、GPS。其中，这条黄色的线是GPS告诉我的位置，大家可以看到GPS逐渐偏移真实的位置，这个原因是因为我们在这个系统里面加了一个GPS的欺骗工具。这种工具也是比较常见，之前也有过伊朗通过GPS欺骗攻击，捕获了美国的一个无人机，因为那个无人机认为它已经飞到一个安全的地方，就降落了，但是其实那个地方是伊朗的占领区，然后它就被捕获了。因为GPS信号是一个单方向，通讯员其实是没有办法去确认GPS信号是不是真的，所以如果我们有一个发射器，发射一个更强的信号，把真实的GPS信号压过去，那么在这种情况下你得到GPS就是错的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这张图是我们采用传统的信息融合方式EKF把IMU、雷达、GPS做一个融合，粉色的是我们做了一个融合的信息。这个时候，你也可以看到粉色线的已经偏出去了，最后偏的有两米左右这个距离，就大概偏出了一个车道，就因为 GPS的信号被人劫持了。这张图是我们后面加了一些安全的设计结果，会发现当你偏得比较小的时候，你是没有办法检测出来到底是由噪声引起还是由攻击引起的。但是，如果当GPS偏非常大的时候，我们在这个地方就可以发现GPS信号是有问题的，然后我们就会把三个传感器融合变成只用雷达和IMU两个传感器去做融合。这样的一个效果，就等于说已经检测出来GPS有问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;今天讲的Technical的东西比较多，主要就是想跟大家聊一聊信息物理系统的安全，因为安全本身就是一个挺重要的问题。其次，从控制的角度来说，我们对这一方面的东西有一些自己的思考，可能跟传统的计算机方向相比，大家思考的方式可能也不是特别一样。&lt;/span&gt;&lt;span&gt;但是我依然觉得，最终的一个解决方案应该是很多学科共同去协作配合，然后产生一个多层、多种角度、多种手段这样一个防御机制。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我今天主要讲的一个是入侵检测，一个是状态估计这样的两个问题。事实上这个理念单纯从控制角度来说也面临很多的挑战，现在这个领域大概也就是10年左右才能有一些成果，但是我觉得还是要多多学习。我希望做的一些东西，能够给真实的信息物理系统提供一些额外的安全保障。感谢大家。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>abcddc3404323497a17217ef58058df2</guid>
<title>微保的 Serverless 云函数实践之路</title>
<link>https://toutiao.io/k/weh95rw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;Markdown__Wrapper-sbgo4h-0 kKEhyL markdown-body&quot;&gt;&lt;p&gt;&lt;img src=&quot;https://img.serverlesscloud.cn/2020928/1601285206848-00.jpg&quot;/&gt;      &lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#%E8%83%8C%E6%99%AF&quot; aria-label=&quot;背景 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;背景&lt;/h2&gt;
&lt;p&gt;微保前端架构在业务发展中，根据业务、团队、开发等实际情况，不断进化调整。本文将具体介绍微保前端的架构演进过程，以及团队最终选择使用腾讯云 Serverless 技术支撑前端架构的原因。&lt;/p&gt;
&lt;p&gt;微保团队使用 Serverless 技术的主要应用场景：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;前端开发同学，应用在BFF层，目前接入的有小程序，H5 页面。&lt;/li&gt;
&lt;li&gt;数据组同学，面向的风控和推荐算法应用，做计算使用。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;微保架构-v1&quot;&gt;&lt;a href=&quot;#%E5%BE%AE%E4%BF%9D%E6%9E%B6%E6%9E%84-v1&quot; aria-label=&quot;微保架构 v1 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;微保架构 v1&lt;/h2&gt;
&lt;p&gt;早期，团队使用经典的前后分离架构，前端开发与后端开发通过接口进行合作。&lt;/p&gt;
&lt;p&gt;合作流程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.serverlesscloud.cn/2020928/1601285210728-01.jpg&quot;/&gt;            &lt;/p&gt;
&lt;p&gt;毫无疑问，前后端分离的架构有比较显著的优势：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 前后端开发解耦&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.serverlesscloud.cn/2020928/1601285212842-02.jpg&quot;/&gt;            &lt;/p&gt;

&lt;p&gt;前后端分别设计与实现自己的错误监控和告警系统，前端对页面脚本错误进行捕获，上报至日志平台，经过日志处理工具，设置告警机制，将错误信息推送至相应的开发人员。&lt;/p&gt;

&lt;p&gt;前后端分离后，前端可以使用更为便捷的框架以及基于这些框架的基础UI组件，大大提升开发效率。另外，前端开发也会基于业务的特点，提取业务专属的公共组件，所有组件化的沉淀，都是对生产效率的提升。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 部署解耦&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;前端项目中有大量的静态文件，包括 html、css、js、图片、视频等，将这些文件部署在 CDN 上，充分利用现有云服务的CDN能力，既能提升资源访问的速度又能保证资源访问的稳定性，尤其是在高并发的场景下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更加快捷的 CI/CD ，前端的编译过程可以非常简单地接入 CI/CD&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在前后端耦合的时代，前后端的统一部署相互依赖，分开部署后，可以针对前端项目以gitlab的repo 级别来做相应的 CI/CD。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;然而，&lt;/strong&gt; 前后分离的架构对于业务早期的快速发展非常有效，而且在团队规模较小的时候，前后端开发人员合作固定，彼此对于对方的开发习惯、性格较熟，因此跨角色沟通的问题并不突出。但随着团队规模和业务规模持续扩大，这个架构模式给团队带来的副作用慢慢浮出水面。实践中，遇到的几个比较明显的问题，如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 前后端协作耦合慢慢成为开发效率提升的瓶颈。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.serverlesscloud.cn/2020928/1601285216810-03.jpg&quot;/&gt;            &lt;/p&gt;
&lt;p&gt;团队规模与业务规模的扩大，意味着合作的人员变多、接口的复杂度也会相应增加。&lt;/p&gt;
&lt;p&gt;早期专人专项大家彼此的开发习惯也熟悉，对业务也都比较熟悉，因此业务接口参数的调整沟通成本较低。但随着业务规模和团队成员扩充，在各种跨业务合作时就会有人碰到不习惯阅读proto，或有些复杂业务需要花费大量时间阅读proto文档，或前后端反复沟通接口调用时参数的具体含义等问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 页面渲染效率较差&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.serverlesscloud.cn/2020928/1601285219013-04.jpg&quot;/&gt;            &lt;/p&gt;
&lt;p&gt;以产品详情页为例，页面的渲染需要请求至少5个后端接口，然后再对数据进行组装和处理。这不仅增加了小程序端的代码体积，页面渲染的速度也是被拉低了。&lt;/p&gt;
&lt;p&gt;即使在前端页面对接口进行并行访问，但数据的整合逻辑依然会非常复杂。小程序作为微保主要的产品承载形态，代码量巨大，几近达到微信规定的代码上限，这种对于代码的增加随着业务增长也是一个隐形的风险。&lt;/p&gt;
&lt;h2 id=&quot;微保架构-v2&quot;&gt;&lt;a href=&quot;#%E5%BE%AE%E4%BF%9D%E6%9E%B6%E6%9E%84-v2&quot; aria-label=&quot;微保架构 v2 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;微保架构 v2&lt;/h2&gt;
&lt;p&gt;鉴于上述前后端合作模式中的痛点，团队对架构再次进行优化，原则是业务“前”移、核心下沉。在前期的各种业务支撑中，团队已经有了一些业务中台的沉淀，比如投保服务、续保服务、保单服务等。&lt;/p&gt;
&lt;p&gt;中间层的引入让团队的开发效率进一步得到提升，前端对于业务的把控力及页面性能优化的操作空间也大大加强。不管是从团队的敏捷性、还是应用的体验，都有不错的改善，比如以下几个方面：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 前后端流程上的耦合大大减小，角色责任的专一性逐步形成&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基于一部分后端服务能力的积累，比如保单相关的需求，在需求评审及开发过程中，只需要前端开发同学参加即可。前端开发同学与业务产品沟通业务逻辑，在api市场或服务文档查询相应的服务能力，完成业务开发。同时对于团队逐步开展业务中台化、前端组件化大有助益，整个架构对于丰富多变的业务需求的响应更敏捷。&lt;/p&gt;
&lt;p&gt;2&lt;strong&gt;. 渲染层对后端的服务进行聚合，减少页面请求&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.serverlesscloud.cn/2020928/1601285222648-05.jpg&quot;/&gt;            &lt;/p&gt;
&lt;p&gt;不管是H5网页还是小程序页面，均只需跟中间层打交道，前端开发人员根据业务的诉求，自行对接口进行聚合，端上只需要1个请求就可以开始渲染页面。接口聚合之前，产品详情页面的显示需要请求5个接口，平均的接口请求耗时为120ms左右，聚合后，通过中间层来请求5个内网接口，避免端与服务的多次连接耗时。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 中间层对数据进行加工，大大减少小程序端的逻辑代码量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;之前在小程序端的数据整合代码，有些复杂的逻辑，可以交给中间层处理，这些代码的节省对于业务持续增长时会越来越体现出价值。以年金产品详情页为例，数据在中间层聚合能够节省10KB的体积。&lt;/p&gt;
&lt;p&gt;中间层的引入是对生产力的进一步解放，但基于一个巨型 app 的 node 中间层，在后期的运维中也暴露出一些问题。中间层的应用部署在2台CVM机器上，有其先天的一些不足：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 应对尖峰流量的冲击能力差&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;微保经常会有一些运营和投放需求，这些事件都会导致瞬间的大流量打入，CVM的扩容相对滞后。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. App级别的部署与发布&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;中间层不断积累业务代码，整个应用线性增长，每次部署与发布都是巨石应用的发布，部署效率低、风险高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 前端开发人员在开发、测试环境中需要自己在机器上查阅日志和服务操作，提高了普及的门槛。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;微保架构-v3&quot;&gt;&lt;a href=&quot;#%E5%BE%AE%E4%BF%9D%E6%9E%B6%E6%9E%84-v3&quot; aria-label=&quot;微保架构 v3 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;微保架构 v3&lt;/h2&gt;
&lt;p&gt;基于上面的这些限制，团队开始关注新的技术，加州大学伯克利分校计算机科学 Riselab 团队的实验室研究室提出：Serverless 是云计算的下一个浪潮。国内各大厂商也都开始布局 Serverless ，腾讯云 Serverless 团队是国内比较早在这方面进行部署的团队，技术已经非常成熟，在新东方、蘑菇街、哔哩哔哩、TP-link 等数百家企业成功落地实践。&lt;/p&gt;
&lt;p&gt;通过调研了解到腾讯云 Serverless 云函数的优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;强大的扩所容能力，特别适合应对流量洪峰，且性能稳定。&lt;/li&gt;
&lt;li&gt;每个函数都是单独运行、单独部署、单独伸缩的，用户上传代码后即可自动部署，提升了独立开发和迭代的速度。&lt;/li&gt;
&lt;li&gt;云函数提供精细的日志记录，可方便地查看函数的运行状况，并对代码进行调试、测试和审计；支持相关的监控指标上报，能快速了解函数的整体运行概况，也可自定义云函数的监控指标。&lt;/li&gt;
&lt;li&gt;精确到 1ms 计费规则，只对正在运行的函数计费。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;综上，基本解决了架构 v2 中面临的问题，可以说是省时省力。经过团队整体评估，我们决定使用腾讯云 Serverless 云函数进行架构的进一步调整。调整后的角色合作流程示意图，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.serverlesscloud.cn/2020928/1601285231734-06.jpg&quot;/&gt;            &lt;/p&gt;
&lt;p&gt;C 端的请求发至云函数 API 网关，网关转发请求至相应的云函数实例，云函数再向后请求服务的网关。整个链条上最大的变化是将云函数取代了node app，成为中间层的技术形态。&lt;/p&gt;
&lt;p&gt;使用云函数替换掉 node app，背后的考量有以下几方面，也基本是针对 node app 实践中遇到的一些问题去加以解决：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 自动扩缩容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;开发者不需要专门去配置，云函数可以自己根据请求量在函数层级水平扩展，正常情况下，一个空的云函数（运行时间 50 ms），300 个并发，压测可以达到 6000+ 的 qps，应对日常的高并发需求基本没什么问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 函数级别的开发与部署&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个云函数对应一个 gitlab 的项目，函数开发与发布都是围绕单个项目进行 CI/CD，高效、安全。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 按需收费&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于金融模式下的流量特点，大部分情况下请求量较少，云函数的使用可以避免稳定的资源投入，空闲情况下费用大大减少。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 简单的运维管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;开发者不需要在服务器上自己维护服务和查阅日志，通过云函数的配套工具轻松管理函数、查阅日志，也可以根据自己的诉求设置告警机制。&lt;/p&gt;
&lt;h2 id=&quot;微保使用-serverless-技术的总体架构&quot;&gt;&lt;a href=&quot;#%E5%BE%AE%E4%BF%9D%E4%BD%BF%E7%94%A8-serverless-%E6%8A%80%E6%9C%AF%E7%9A%84%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84&quot; aria-label=&quot;微保使用 serverless 技术的总体架构 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;微保使用 Serverless 技术的总体架构&lt;/h2&gt;
&lt;p&gt;微保每一次架构的调整，都致力于让各种研发角色的职责更为单一、内聚，角色间更加解耦。但这种调整也需要有配套的工具，其中的 trade-off 需要根据短期成本和长期利益来衡量。腾讯云Servelrss 云函数很好的支持了本次架构的重新调整。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.serverlesscloud.cn/2020928/1601285234546-07.jpg&quot;/&gt;            &lt;/p&gt;
&lt;h2 id=&quot;落地中的问题和解决办法&quot;&gt;&lt;a href=&quot;#%E8%90%BD%E5%9C%B0%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95&quot; aria-label=&quot;落地中的问题和解决办法 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;落地中的问题和解决办法&lt;/h2&gt;
&lt;p&gt;使用腾讯云 Serverless 过程中也不免遇到问题。&lt;/p&gt;
&lt;p&gt;例如，公司有自建 es 集群，所有日志都会放在es里面，但是云函数的日志无法直接放入我们es里面，只能存入腾讯云的 cls，这个对于我们后期日志分析， 告警都不好处理。通过调研腾讯云cls， 发现里面有个挺好用的功能，可以日志投递到 kafka，在通过监听 kafka，我们将日志成功存入我们的 es, 且时延保证在秒级。&lt;/p&gt;
&lt;p&gt;另一个日志规范问题, 日志的规范关乎后期日志分析、告警， 但是实际处理中发现日志的元数据信息较少， 比如我们有版本 tag，云函数绑定了 cmdb 相关信息，这些都希望在日志中打印出来, 后面我们发现云函数有个别名字段。我们在云函数中发现一个别名字段, 通过扩展了一下这个字段，填入了更多信息， 例如版本、cmdb 相关信息，这样在日志里面相关信息也会体现出来。&lt;/p&gt;
&lt;p&gt;关于使用腾讯云 Serverless 技术在风控和推荐算法应用的介绍会在之后的文章为大家详细展开，敬请期待！&lt;/p&gt;
&lt;hr/&gt;
&lt;hr/&gt;
&lt;p id=&quot;scf-deploy-iframe-or-md&quot;/&gt;
&lt;hr/&gt;
&lt;p&gt;欢迎访问：&lt;a href=&quot;https://serverlesscloud.cn/&quot;&gt;Serverless 中文网&lt;/a&gt;，您可以在 &lt;a href=&quot;https://serverlesscloud.cn/best-practice&quot;&gt;最佳实践&lt;/a&gt; 里体验更多关于 Serverless 应用的开发！&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>