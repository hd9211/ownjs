<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>7bb5dc239eb520e0e9c5db353a7277c0</guid>
<title>基于 SSD 的 Kafka 应用层缓存架构设计与实现</title>
<link>https://toutiao.io/k/ddgxe6s</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Kafka在美团数据平台的现状&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Kafka出色的I/O优化以及多处异步化设计，相比其他消息队列系统具有更高的吞吐，同时能够保证不错的延迟，十分适合应用在整个大数据生态中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前在美团数据平台中，Kafka承担着数据缓冲和分发的角色。如下图所示，业务日志、接入层Nginx日志或线上DB数据通过数据采集层发送到Kafka，后续数据被用户的实时作业消费、计算，或经过数仓的ODS层用作数仓生产，还有一部分则会进入公司统一日志中心，帮助工程师排查线上问题。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.41265822784810124&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVAdicJRUBj8KwCvHatqvHiaRtGzzcw4wLkEEZxESSxtPmB8MYnp56BlXK8AhloPBsa9TAAHUZFzJVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1185&quot; title=&quot;image&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;目前美团线上Kafka规模：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;集群规模&lt;/strong&gt;：节点数达6000+，集群数100+。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;集群承载&lt;/strong&gt;：Topic数6万+，Partition数41万+。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;处理的消息规模&lt;/strong&gt;：目前每天处理消息总量达8万亿，峰值流量为1.8亿条/秒&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;提供的服务规模&lt;/strong&gt;：目前下游实时计算平台运行了3万+作业，而这其中绝大多数的数据源均来自Kafka。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Kafka线上痛点分析&amp;amp;核心目标&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当前Kafka支撑的实时作业数量众多，单机承载的Topic和Partition数量很大。这种场景下很容易出现的问题是：同一台机器上不同Partition间竞争PageCache资源，相互影响，导致整个Broker的处理延迟上升、吞吐下降。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来，我们将结合Kafka读写请求的处理流程以及线上统计的数据来分析一下Kafka在线上的痛点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;原理分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3009543285616905&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVAdicJRUBj8KwCvHatqvHiaRiahyVOTy5wOZK18BRmL100C0CEicoRJQpKib32Ct2REyKUiaLmFBcPLRbw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2934&quot; title=&quot;Kafka处理读写流程的示意图&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;Kafka处理读写流程的示意图&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;对于Produce请求&lt;/strong&gt;：Server端的I/O线程统一将请求中的数据写入到操作系统的PageCache后立即返回，当消息条数到达一定阈值后，Kafka应用本身或操作系统内核会触发强制刷盘操作（&lt;/span&gt;&lt;span&gt;如左侧流程图所示&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;对于Consume请求&lt;/strong&gt;：主要利用了操作系统的ZeroCopy机制，当Kafka Broker接收到读数据请求时，会向操作系统发送sendfile系统调用，操作系统接收后，首先试图从PageCache中获取数据（&lt;/span&gt;&lt;span&gt;如中间流程图所示&lt;/span&gt;&lt;span&gt;）；如果数据不存在，会触发缺页异常中断将数据从磁盘读入到临时缓冲区中（&lt;/span&gt;&lt;span&gt;如右侧流程图所示&lt;/span&gt;&lt;span&gt;），随后通过DMA操作直接将数据拷贝到网卡缓冲区中等待后续的TCP传输。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;综上所述，Kafka对于单一读写请求均拥有很好的吞吐和延迟。处理写请求时，数据写入PageCache后立即返回，数据通过异步方式批量刷入磁盘，既保证了多数写请求都能有较低的延迟，同时批量顺序刷盘对磁盘更加友好。处理读请求时，实时消费的作业可以直接从PageCache读取到数据，请求延迟较小，同时ZeroCopy机制能够减少数据传输过程中用户态与内核态的切换，大幅提升了数据传输的效率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但当同一个Broker上同时存在多个Consumer时，就可能会由于多个Consumer竞争PageCache资源导致它们同时产生延迟。下面我们以两个Consumer为例详细说明：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.34381270903010036&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVAdicJRUBj8KwCvHatqvHiaRSXgRCGewYMeRUW42fg84zBESxASFPx1ZXca6FtxiafMdvLgIjve1pdg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2990&quot; title=&quot;image&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;如上图所示，Producer将数据发送到Broker，PageCache会缓存这部分数据。当所有Consumer的消费能力充足时，所有的数据都会从PageCache读取，全部Consumer实例的延迟都较低。此时如果其中一个Consumer出现消费延迟（&lt;/span&gt;&lt;span&gt;图中的Consumer Process2&lt;/span&gt;&lt;span&gt;），根据读请求处理流程可知，此时会触发磁盘读取，在从磁盘读取数据的同时会预读部分数据到PageCache中。当PageCache空间不足时，会按照LRU策略开始淘汰数据，此时延迟消费的Consumer读取到的数据会替换PageCache中实时的缓存数据。后续当实时消费请求到达时，由于PageCache中的数据已被替换掉，会产生预期外的磁盘读取。这样会导致两个后果：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;消费能力充足的Consumer消费时会失去PageCache的性能红利。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;多个Consumer相互影响，预期外的磁盘读增多，HDD负载升高。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;我们针对HDD的性能和读写并发的影响做了梯度测试，如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.37355371900826445&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVAdicJRUBj8KwCvHatqvHiaRD5Ib5jGoLUDW4a9ot8zsgNH6bFr9h42Bbuic21RxYWYG5tcRnygrn3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1210&quot; title=&quot;image&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;可以看到，随着读并发的增加，HDD的IOPS和带宽均会明显下降，这会进一步影响整个Broker的吞吐以及处理延迟。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;线上数据统计&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前Kafka集群TP99流量在170MB/s，TP95流量在100MB/s，TP50流量为50-60MB/s；单机的PageCache平均分配为80GB，取TP99的流量作为参考，在此流量以及PageCache分配情况下，PageCache最大可缓存数据时间跨度为80*1024/170/60 = 8min，可见当前Kafka服务整体对延迟消费作业的容忍性极低。该情况下，一旦部分作业消费延迟，实时消费作业就可能会受到影响。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同时，我们统计了线上实时作业的消费延迟分布情况，延迟范围在0-8min（&lt;/span&gt;&lt;span&gt;实时消费&lt;/span&gt;&lt;span&gt;）的作业只占80%，说明目前存在线上存在20%的作业处于延迟消费的状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;痛点分析总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总结上述的原理分析以及线上数据统计，目前线上Kafka存在如下问题：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;实时消费与延迟消费的作业在PageCache层次产生竞争，导致实时消费产生非预期磁盘读。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;传统HDD随着读并发升高性能急剧下降。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;线上存在20%的延迟消费作业。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;按目前的PageCache空间分配以及线上集群流量分析，Kafka无法对实时消费作业提供稳定的服务质量保障，该痛点亟待解决。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;预期目标&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据上述痛点分析，我们的预期目标为保证实时消费作业不会由于PageCache竞争而被延迟消费作业影响，保证Kafka对实时消费作业提供稳定的服务质量保障。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;解决方案&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;为什么选择SSD&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据上述原因分析可知，解决目前痛点可从以下两个方向来考虑：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;消除实时消费与延迟消费间的PageCache竞争，如：让延迟消费作业读取的数据不回写PageCache，或增大PageCache的分配量等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在HDD与内存之间加入新的设备，该设备拥有比HDD更好的读写带宽与IOPS。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;对于第一个方向，由于PageCache由操作系统管理，若修改其淘汰策略，那么实现难度较为复杂，同时会破坏内核本身对外的语义。另外，内存资源成本较高，无法进行无限制的扩展，因此需要考虑第二个方向。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;SSD目前发展日益成熟，相较于HDD，SSD的IOPS与带宽拥有数量级级别的提升，很适合在上述场景中当PageCache出现竞争后承接部分读流量。我们对SSD的性能也进行了测试，结果如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.37225042301184436&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVAdicJRUBj8KwCvHatqvHiaRPMovoEs7eSn7Y5GmpJiaDsAPcpGVk1TqscB3cItribicNDA8JMtu8hpag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1182&quot; title=&quot;image&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;从图中可以发现，随着读取并发的增加，SSD的IOPS与带宽并不会显著降低。通过该结论可知，我们可以使用SSD作为PageCache与HDD间的缓存层。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;架构决策&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在引入SSD作为缓存层后，下一步要解决的关键问题包括PageCache、SSD、HDD三者间的数据同步以及读写请求的数据路由等问题，同时我们的新缓存架构需要充分匹配Kafka引擎读写请求的特征。本小节将介绍新架构如何在选型与设计上解决上述提到的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Kafka引擎在读写行为上具有如下特性：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据的消费频率随时间变化，越久远的数据消费频率越低。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;每个分区（&lt;/span&gt;&lt;span&gt;Partition&lt;/span&gt;&lt;span&gt;）只有Leader提供读写服务。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对于一个客户端而言，消费行为是线性的，数据并不会重复消费。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;下文给出了两种备选方案，下面将对两种方案给出我们的选取依据与架构决策。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;备选方案一：基于操作系统内核层实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前开源的缓存技术有FlashCache、BCache、DM-Cache、OpenCAS等，其中BCache和DM-Cache已经集成到Linux中，但对内核版本有要求，受限于内核版本，我们仅能选用FlashCache/OpenCAS。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下图所示，FlashCache以及OpenCAS二者的核心设计思路类似，两种架构的核心理论依据为“数据局部性”原理，将SSD与HDD按照相同的粒度拆成固定的管理单元，之后将SSD上的空间映射到多块HDD层的设备上（&lt;/span&gt;&lt;span&gt;逻辑映射or物理映射&lt;/span&gt;&lt;span&gt;）。在访问流程上，与CPU访问高速缓存和主存的流程类似，首先尝试访问Cache层，如果出现CacheMiss，则会访问HDD层，同时根据数据局部性原理，这部分数据将回写到Cache层。如果Cache空间已满，会通过LRU策略替换部分数据。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7563805104408353&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVAdicJRUBj8KwCvHatqvHiaReQwGrfKRgPuU9ToFo3OABOIHRoQdyyhibonNaLuVBUPfMCuYb5fs6jA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;862&quot; title=&quot;image&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;FlashCache/OpenCAS提供了四种缓存策略：WriteThrough、WriteBack、WriteAround、WriteOnly。由于第四种不做读缓存，这里我们只看前三种。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;写入：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;WriteThrough&lt;/strong&gt;：数据写操作在写入SSD的同时会写入到后端存储。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;WriteBack&lt;/strong&gt;：数据写操作仅写入SSD即返回，由缓存策略flush到后台存储。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;WriteAround&lt;/strong&gt;：数据写入操作直接写入后端存储，同时SSD对应的缓存会失效。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;读取：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.2796967144060657&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVAdicJRUBj8KwCvHatqvHiaRegQhoON6oLuBVFTViaIxD0Uicbw7tQ9OCzGdXLa78mzb5FFYqh6ZiaFZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1187&quot; title=&quot;image&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;更多详细实现细节，极大可参见这二者的官方文档：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;备选方案二：Kafka应用内部实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上文提到的第一类备选方案中，核心的理论依据“数据局部性”原理与Kafka的读写特性并不能完全吻合，“数据回刷”这一特性依然会引入缓存空间污染问题。同时，上述架构基于LRU的淘汰策略也与Kafka读写特性存在矛盾，在多Consumer并发消费时，LRU淘汰策略可能会误淘汰掉一些近实时数据，导致实时消费作业出现性能抖动。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可见，备选方案一并不能完全解决当前Kafka的痛点，需要从应用内部进行改造。整体设计思路如下，将数据按照时间维度分布在不同的设备中，近实时部分的数据缓存在SSD中，这样当出现PageCache竞争时，实时消费作业从SSD中读取数据，保证实时作业不会受到延迟消费作业影响。下图展示了基于应用层实现的架构处理读请求的流程：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1.1413427561837455&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVAdicJRUBj8KwCvHatqvHiaRu0epfXrXPaJBJUUtBn0vGxVpocbdhibpicGXkqUZeN6EsQPg3TE33TJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;566&quot; title=&quot;image&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;当消费请求到达Kafka Broker时，Kafka Broker直接根据其维护的消息偏移量（&lt;/span&gt;&lt;span&gt;Offset&lt;/span&gt;&lt;span&gt;）和设备的关系从对应的设备中获取数据并返回，并且在读请求中并不会将HDD中读取的数据回刷到SSD，防止出现缓存污染。同时访问路径明确，不会由于Cache Miss而产生的额外访问开销。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下表对不同候选方案进行了更加详细的对比：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;561&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;303&quot; data-ratio=&quot;0.36758563074352546&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVAdicJRUBj8KwCvHatqvHiaRhibER96kiaCFoiaAwDBjoAUibCWOr16OiaN5ibwvI3Qy1UzkicVReicUQic3H7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2394&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最终，结合与Kafka读写特性的匹配度，整体工作量等因素综合考虑，我们采用Kafka应用层实现这一方案，因为该方案更贴近Kafka本身读写特性，能更加彻底地解决Kafka的痛点。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;新架构设计&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;概述&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据上文对Kafka读写特性的分析，我们给出应用层基于SSD的缓存架构的设计目标：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;依据上述目标，我们给出应用层基于SSD的Kafka缓存架构实现：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Kafka中一个Partition由若干LogSegment构成，每个LogSegment包含两个索引文件以及日志消息文件。一个Partition的若干LogSegment按Offset（&lt;/span&gt;&lt;span&gt;相对时间&lt;/span&gt;&lt;span&gt;）维度有序排列。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4403948367501898&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVAdicJRUBj8KwCvHatqvHiaRuZnaonkG8bP8UQC07gOUj8uA9HYcYkbYpEx5FojWNVRqkA1avibicOYQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2634&quot; title=&quot;image&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;根据上一小节的设计思路，我们首先将不同的LogSegment标记为不同的状态，如图所示（&lt;/span&gt;&lt;span&gt;图中上半部分&lt;/span&gt;&lt;span&gt;）按照时间维度分为OnlyCache、Cached以及WithoutCache三种常驻状态。而三种状态的转换以及新架构对读写操作的处理如图中下半部分所示，其中标记为OnlyCached状态的LogSegment只存储在SSD上，后台线程会定期将Inactive（&lt;/span&gt;&lt;span&gt;没有写流量&lt;/span&gt;&lt;span&gt;）的LogSegment同步到SSD上，完成同步的LogSegment被标记为Cached状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后，后台线程将会定期检测SSD上的使用空间，当空间达到阈值时，后台线程将会按照时间维度将距离现在最久的LogSegment从SSD中移除，这部分LogSegment会被标记为WithoutCache状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于写请求而言，写入请求依然首先将数据写入到PageCache中，满足阈值条件后将会刷入SSD。对于读请求（&lt;/span&gt;&lt;span&gt;当PageCache未获取到数据时&lt;/span&gt;&lt;span&gt;），如果读取的offset对应的LogSegment的状态为Cached或OnlyCache，则数据从SSD返回（&lt;/span&gt;&lt;span&gt;图中LC2-LC1以及RC1&lt;/span&gt;&lt;span&gt;），如果状态为WithoutCache，则从HDD返回（&lt;/span&gt;&lt;span&gt;图中LC1&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于Follower副本的数据同步，可根据Topic对延迟以及稳定性的要求，通过配置决定写入到SSD还是HDD。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;关键优化点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上文介绍了基于SSD的Kafka应用层缓存架构的设计概要以及核心设计思路，包括读写流程、内部状态管理以及新增后台线程功能等。本小节将介绍该方案的关键优化点，这些优化点均与服务的性能息息相关。主要包括LogSegment同步以及Append刷盘策略优化，下面将分别进行介绍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;LogSegment同步&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;LogSegment同步是指将SSD上的数据同步到HDD上的过程，该机制在设计时主要有以下两个关键点：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;同步的方式&lt;/strong&gt;：同步方式决定了HDD上对SSD数据的可见时效性，从而会影响故障恢复以及LogSegment清理的及时性。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;同步限速&lt;/strong&gt;：LogSegment同步过程中通过限速机制来防止同步过程中对正常读写请求造成影响&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;同步方式&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于LogSegment的同步方式，我们给出了三种备选方案，下表列举了三种方案的介绍以及各自的优缺点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;561&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;276&quot; data-ratio=&quot;0.3095623987034036&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVAdicJRUBj8KwCvHatqvHiaRYeT8B6R1z4iaSb98oKibJQ9yYpNPYJqRm6FOYT2m3v4oicuw1dGCQyF1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2468&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最终，我们对一致性维护代价、实现复杂度等因素综合考虑，选择了后台同步Inactive的LogSegment的方式。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;同步限速&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;LogSegment同步行为本质上是设备间的数据传输，会同时在两个设备上产生额外的读写流量，占用对应设备的读写带宽。同时，由于我们选择了同步Inactive部分的数据，需要进行整段的同步。如果在同步过程中不加以限制会对服务整体延迟造成较大的影响，主要表现在下面两个方面：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于上述两点，我们需要在LogSegment同步过程中增加限速机制，总体的限速原则为在不影响正常读写请求延迟的情况下尽可能快速地进行同步。因为同步速度过慢会导致SSD数据无法被及时清理而最终被写满。同时为了可以灵活调整，该配置也被设置为单Broker粒度的配置参数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;日志追加刷盘策略优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了同步问题，数据写入过程中的刷盘机制同样影响服务的读写延迟。该机制的设计不仅会影响新架构的性能，对原生Kafka同样会产生影响。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下图展示了单次写入请求的处理流程：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1.2668810289389068&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVAdicJRUBj8KwCvHatqvHiaRFl1qRZon1kSCsgQaBCGUCNicfxgoBBHGEaA8eHDia2jqicLUEO4k5EsQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;622&quot; title=&quot;image&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;在Produce请求处理流程中，首先根据当前LogSegment的位置与请求中的数据信息确定是否需要滚动日志段，随后将请求中的数据写入到PageCache中，更新LEO以及统计信息，最后根据统计信息确定是否需要触发刷盘操作，如果需要则通过&lt;/span&gt;&lt;code&gt;&lt;span&gt;fileChannel.force&lt;/span&gt;&lt;/code&gt;&lt;span&gt;强制刷盘，否则请求直接返回。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在整个流程中，除日志滚动与刷盘操作外，其他操作均为内存操作，不会带来性能问题。日志滚动涉及文件系统的操作，目前，Kafka中提供了日志滚动的扰动参数，防止多个Segment同时触发滚动操作给文件系统带来压力。针对日志刷盘操作，目前Kafka给出的机制是以固定消息条数触发强制刷盘（&lt;/span&gt;&lt;span&gt;目前线上为50000&lt;/span&gt;&lt;span&gt;），该机制只能保证在入流量一定时，消息会以相同的频率刷盘，但无法限制每次刷入磁盘的数据量，对磁盘的负载无法提供有效的限制。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下图所示，为某磁盘在午高峰时间段write_bytes的瞬时值，在午高峰时间段，由于写入流量的上升，在刷盘过程中会产生大量的毛刺，而毛刺的值几乎接近磁盘最大的写入带宽，这会使读写请求延迟发生抖动。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.26706586826347306&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVAdicJRUBj8KwCvHatqvHiaRicpy8y8jx2qSBbMic0upia5icyYW12icSicjZakicqpICjl7LCGXqe4yqiaJhA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1670&quot; title=&quot;image&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;针对该问题，我们修改了刷盘的机制，将原本的按条数限制修改为按实际刷盘的速率限制，对于单个Segment，刷盘速率限制为2MB/s。该值考虑了线上实际的平均消息大小，如果设置过小，对于单条消息较大的Topic会过于频繁的进行刷新，在流量较高时反而会加重平均延迟。目前该机制已在线上小范围灰度，右图展示了灰度后同时间段对应的write_bytes指标，可以看到相比左图，数据刷盘速率较灰度前明显平滑，最高速率仅为40MB/s左右。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于SSD新缓存架构，同样存在上述问题，因此在新架构中，在刷盘操作中同样对刷盘速率进行了限制。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;方案测试&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;测试目标&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;测试场景描述&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;测试内容及重点关注指标&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Case1: 仅有延迟消费时，观察集群的生产和消费性能。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;重点关注的指标：写耗时、读耗时，通过这2个指标体现出读写延迟。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;命中率指标：HDD读取量、HDD读取占比（&lt;/span&gt;&lt;span&gt;HDD读取量/读取总量&lt;/span&gt;&lt;span&gt;）、SSD读取命中率，通过这3个指标体现出SSD缓存的命中率。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Case2: 存在延迟消费时，观察实时消费的性能。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;重点指标：实时作业的SLA（&lt;/span&gt;&lt;span&gt;服务质量&lt;/span&gt;&lt;span&gt;）的5个不同时间区域的占比情况。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;测试结果&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;从单Broker请求延迟角度看：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在刷盘机制优化前，SSD新缓存架构在所有场景下，较其他方案都具有明显优势。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.20342034203420342&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVAdicJRUBj8KwCvHatqvHiaR3UIRyjv1FHyYX7zN7PGtbNs4DWgp8CjMkcLX2eRYSkj9Gahiay5RwJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2222&quot; title=&quot;image&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;刷盘机制优化后，其余方案在延迟上服务质量有提升，在较小流量下由于Flush机制的优化，新架构与其他方案的优势变小。当单节点写入流量较大时（&lt;/span&gt;&lt;span&gt;大于170MB&lt;/span&gt;&lt;span&gt;）优势明显。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.20448430493273542&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVAdicJRUBj8KwCvHatqvHiaRatp2XvQyicWBicAKOWUjia0qHCbsP9UZOiaZkCXh6baj5O4NlxhhNlTCQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2230&quot; title=&quot;image&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;从延迟作业对实时作业的影响方面看：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;新缓存架构在测试所涉及的所有场景中，延迟作业都不会对实时作业产生影响，符合预期。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6305007587253414&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVAdicJRUBj8KwCvHatqvHiaR27DucjrKIthes1WI7pPBuNC2JKbaR801EBtTFSdiadKcibc6XKD4ic3Gg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2636&quot; title=&quot;image&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结与未来展望&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Kafka在美团数据平台承担统一的数据缓存和分发的角色，针对目前由于PageCache互相污染、进而引发PageCache竞争导致实时作业被延迟作业影响的痛点，我们基于SSD自研了Kafka的应用层缓存架构。本文主要介绍Kafka新架构的设计思路以及与其他开源方案的对比。与普通集群相比，新缓存架构具备非常明显的优势：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;降低读写耗时&lt;/strong&gt;：比起普通集群，新架构集群读写耗时降低80%。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;实时消费不受延迟消费的影响&lt;/strong&gt;：比起普通集群，新架构集群实时读写性能稳定，不受延时消费的影响。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;目前，这套缓存架构优已经验证完成，正在灰度阶段，未来也优先部署到高优集群。其中涉及的代码也将提交给Kafka社区，作为对社区的回馈，也欢迎大家跟我们一起交流。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;作者简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;世吉，仕禄，均为美团数据平台工程师。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e3b3d310876aa43699af04f402fd28f8</guid>
<title>武汉知名 IT 公司大盘点</title>
<link>https://toutiao.io/k/pntjinj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很快，就要到中国传统意义上的年末了，很多人都在盘算着拿完年终奖，寻找新的出处。关于选择的话题，在&amp;lt;&amp;lt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3NTQyMzEzNQ==&amp;amp;mid=2247486167&amp;amp;idx=1&amp;amp;sn=c796512e317f623e4346bc501b02a3ec&amp;amp;chksm=eb044027dc73c931cc9c013e6b93e905abf9bd371134f0d99e54a8211d8f0edd49ae7133f235&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;在二线城市做程序员是怎样的一种体验&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;在二线城市做程序员是怎样的一种体验&lt;/a&gt;&amp;gt;&amp;gt;这篇文章中我建议毕业生尽量选择一线城市。但如果你已经在外打拼了几年，发现自己并不是那个天选之子，在一线城市房价高企的现状下，安身立命都成问题，那不妨考虑回到二线城市发展。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于武汉这样的二线城市，有没有前景，我前几年写了一篇文章《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3NTQyMzEzNQ==&amp;amp;mid=2247484575&amp;amp;idx=1&amp;amp;sn=44142dbe400ac70777de74d7882f05b8&amp;amp;chksm=eb044e6fdc73c77929b648b660a889af7d5441ffd186c01e9c9b5d7dae805ce0a4a99a6d0edd&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;看了北京住房公积金贷款新政，心疼北京的朋友们！&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;看了北京住房公积金贷款新政，心疼北京的朋友们！&lt;/a&gt;》，尬吹了一把武汉，今天把这篇文章翻出来，里面的观点依然不过时。因为我这么多年来一直呆在武汉，其它二线城市并不了解，所以这里只聊武汉的 IT 环境。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章盘点一下武汉的 IT 企业，但需要注意的是，我只是收集了武汉的一些知名 IT 公司的情况，至于公司好不好，值不值得进，仁者见仁智者见智，不做跳槽选择参考。以下排名不分先后，如果漏掉了什么信息，也欢迎留言探讨。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;华为武汉研究所&lt;span/&gt;&lt;/h4&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5842592592592593&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibQ4mtgHYXv41Uy5CbbZPhBtex9oAUiaDazpClm8ED687ZyE4Nthuo1lkeKI88ricGVTRgehPtCxxuRCX5hGMibY8Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;谈到 IT 企业，绕不开的公司就是华为，而谈到武汉的 IT 企业，更不能避开华为。因为华为的能量太大了：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，它拉高了武汉整个武汉 IT 的薪资水平。当年华为武汉研究所开张，在武汉疯狂挖人，特别是烽火通信，后来实在受不了，还往湖北省政府告状。我身边很多同事就去了华为。华为舍得开工资，招人又多，前些年很容易进，逼得武汉的 IT 企业提高待遇。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其次，它抬高了武汉的房价。目前，华为附近的楼盘价格已经接近两万，要知道那里离武汉的边缘-光谷广场还有十几公里。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，它也将加班文化带到武汉，我的一些前同事都说那边加班非常严重，经常干到晚上11点。但有些前同事没去核心部门，就觉得很轻松，比如工具部门，给研发提供开发工具、测试工具之类的，没有压力，但钱也比哪些做手机终端的部门少。我在里面短暂呆过一段时间，做预研方面的工作，就觉得非常轻松。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;华为武研所开始做接入网、光网之类的通信产品，后来随着规模扩大（万人规模），产品线非常丰富。去年因为美国制裁，受到一些影响，现在没以前那么容易进。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作地点：光谷东光谷八路，目前有11号地铁线路经过。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;腾讯武汉研发中心&lt;span/&gt;&lt;/h4&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6659722222222222&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibQ4mtgHYXv41Uy5CbbZPhBtex9oAUiaDagEcnVJ38d2QZlxDERZHegYOjGpj7u1RfcrnLdeknarEpaOyBzYbVyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1440&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;腾讯是互联网行业的翘楚，在武汉建了一栋非常豪华的腾讯大楼。在大楼建好之前，租了写字楼办公，就在我们公司的楼上，我去面试过，也拿到了 offer ，后来因为一些原因没去。那个时候它们在做一款叫做&lt;strong&gt;Q立方&lt;/strong&gt;的产品，最后好像没成功。我认识的几个前同事后来也从里面出来了，后来做什么，不是很清楚，大家可以看看腾讯的招聘信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;武汉这边招聘，最后签约的是腾讯的全资子公司，不过全资子公司应该只是公司运作上的需要，开发人员不用太担心。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作地点：武汉市江夏区腾讯大道1号，有一次骑行经过那里，离主城区还是有些远，四环线以外。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;小米武汉研发中心&lt;span/&gt;&lt;/h4&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7510431154381085&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibQ4mtgHYXv41Uy5CbbZPhBtex9oAUiaDaUg7pKxwiaCw7YHaYr9cicQzkpibf7QibKXVqo48v0v8AUiaPtDK06HweRHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1438&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;雷军是武大毕业，也是湖北人，所以小米武汉研发中心的投入也很大，大楼已经完工。目前这边并没有做手机相关的产品，主要是人工智能、语音识别等方面的，以后规模扩大可能会有更多的产品线。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作地点：光谷东光谷四路，位处光谷中心城核心区域。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;金山软件（武汉）总部&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也是雷军系的公司。2017年11月，金山团队进驻光谷金融港办公。2019年7月，金山部分团队入驻光谷软件园。2020年6月，金山软件（武汉）总部项目正式启动，总投资40亿元。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;金山软件（武汉）总部位于光谷中央生态大走廊，总建筑面积约3.12万平方米，将建设金山办公信创服务中心、国际业务研发和运营总部、金山云数字医疗总部、金山世游全国美术中心、全球游戏发行中心等项目。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;未来5年内，金山软件（武汉）总部员工有望达到3000人，其中80%以上为高端研发人员。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作地点：目前在光谷软件园和金融港这边，以后会搬到高新四路。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;字节跳动武汉研发中心&lt;span/&gt;&lt;/h4&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.683&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibQ4mtgHYXv41Uy5CbbZPhBtex9oAUiaDaGKbnqGBMlI6xjAhG3bEdZic4KH57fvKcYicNI1XKZRgYu4KJjeupuNHg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;字节跳动进军武汉，没盖研发大楼，租的是我家对面的一栋写字楼 - 保利国际中心。字节跳动这几年发展迅猛，今日头条、抖音、西瓜视频等产品，已经是国民级的产品。如果能加入，发展前景应该不错。（去应聘过，结果被拒，：(）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作地点：光谷，关山大道保利国际中心，关山大道很堵车，没有地铁，只有有轨电车，最好在附近买房子。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;海康威视武汉研发中心&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;海康威视在安防领域无疑具有统治地位，已经被美国盯上，上了制裁名单。海康威视武汉研发中心规模很大，远远就可以看到其在软件园的招牌。据说，其待遇不算很高，当然那是相比互联网公司、通信公司而言。加班应该是比较多的，散步经过软件园，它们的办公室永远灯火通明。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作地点：光谷，关山大道光谷软件园。可以上 https://talent.hikvision.com/home/socity/index 了解招聘岗位。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;中兴武汉研发中心&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;中兴其实在华为之前就进入武汉了，但一直不温不火，没在武汉掀起什么风浪。可能规模很小，规模大概只有几百人，周围很多人甚至不知道中兴在武汉建了研究所。武研所主要3大业务块，电源，波分，消费电子。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作地点：光谷，华师园路6号。可以上 https://job.zte.com.cn/ 看看有哪些岗位。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;烽火&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;武汉本土企业，烽火背靠武汉邮科院，在光纤通信方面有一定的实力，不过这些年一直被华为、中心压制。旗下有烽火科技、烽火通信、烽火网络、虹信、光迅等公司，在华为、中兴这些公司没进入武汉之前，一直是武汉 IT 人的首选。其收入虽然比不上华为、中兴，但工作轻松一大截，甚至有人在华为工作几年后又跳回&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作地点：有好几个地点，远的在高新四路，近的在珞喻路吴家湾。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;科大讯飞&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;科大讯飞在前几年人工智能热火之前很牛，其主要产品就是语音输入，随着百度、阿里、腾讯等互联网企业杀入这个领域，科大讯飞也面临产品单一，竞争力不够的问题。前几年传闻要在武汉建立一个很大的研发中心，最近没啥动静。不过其技术实力还是很强，有志于人工智能方向的同学值得考虑一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作地点：：目前在光谷的关山大道355号光谷新世界，以后是否有新的研发大楼，还不确定。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;旷视科技&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说起旷视科技，可能好多人不知道，但提起 face++ ，从事人工智能方面的同学应该不陌生。公司依托深度学习方面的积累，产品向个人物联网、城市物联网和供应链物联网等方向扩展。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作地点：光谷东，光谷七路未来科技城F区F1栋&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;联发科武汉研发中心&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;手机芯片的重要厂商之一，进入武汉很早，2010年就成立了联发科软件（武汉）有限公司。主要为平板电脑、蓝光播放器、数字电视等提供集成电路设计方案，后期又新增车载电子、智能家居相关芯片设计业务布局。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作地点：光谷，金融港一期A4座&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;武汉兆芯集成电路有限公司&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;兆芯是成立于2013年的国资控股公司，总部位于上海张江，在北京、西安、武汉、深圳等地设有研发中心和分支机构。公司同时掌握CPU、GPU、芯片组三大核心技术，具备三大核心芯片及相关IP设计研发能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;兆芯和烽火差不多都算是国企，工作相对轻松，是一个不错的选择。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作地点：光谷，软件园&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;斗鱼&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;曾经直播领域数一数二的公司，武汉本土互联网企业，可惜未能成为独角兽，2020年，斗鱼被虎牙直播合并。目前直播面临短视频的挑战，日子没那么好过了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作地点：光谷，软件园&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;卷皮网&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;卷皮网是我的校友创建的，学校周年庆还特意介绍了这家公司，主要从事电商折扣之类的业务，前几年在公汽车身上还能经常看到它们的广告，现在已经比较少见了。我没用过它家的产品，周围也没有朋友在里面，不好评价。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作地点：光谷，软件园&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;精伦电子&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我毕业后工作的第一家公司，曾经公话领域的老大，也是全国第一家以全自然人发起的上市公司。不过随着手机的冲击，再也难以找回往日辉煌。这些年一直在艰难转型。目前主要从事智慧校园、身份证识别终端、工业缝纫机、智能电网等方面产品的研发。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作地点：光谷，关南工业园。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;武汉天喻&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我工作的第二家公司，由其前身华中软件公司改制而成，主要股东华中科技大学产业集团等。是以智能卡、数据安全及相关的附件产品、增值服务为主营业务的高新技术企业。后来又成立了天喻通信、天喻教育等子公司，疫情期间，武汉中小学的网上教学系统就是选择它家的产品。今天查了一下天喻通信的股权结构，发现当时没走的同事都进入股东之列，有时坚持也有意想不到的收获。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作地点：光谷，华工科技园&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;华工科技&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;华工科技曾经是A股科技第一股，是华中地区第一批由高校产业重组上市的高科技公司，下面有华工图像、正源光子、华工激光、高理电子、武汉法利莱等骨干企业。主要从事激光器、激光加工设备及成套设备、激光全息综合防伪标识及包装材料、敏感电子元器件、光通信器件与模块等技术与产品的研究、开发、生产与销售。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作地点：光谷，华工科技产业园&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;360武汉研发中心&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;360企业安全武汉研发中心成立于2016年6月份，是360企业安全集团在北京总部外建立的首批两个研发中心之一。当前的业务方向覆盖网络安全大数据、网站安全、安全服务等领域，涉及产品研发、安全研究和安全服务等多个岗位。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作地点：光谷，光谷大道当代梦工场&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;风行在线&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;武汉本地企业，其产品风行播放器有一定的知名度，公司经营范围包括计算机软件、嵌入式系统软件、手机软件、网络技术研究等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作地点：光谷，金融港&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为个人资历有限，周围朋友圈也不是那么广，所以上面的名单只是武汉 IT 企业的一小部分，信息难免疏漏，欢迎各位朋友补充、指正。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你还可以看：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibQ4mtgHYXv50C2zJtfH5icNbOicm63Mwia4EaZdIJtQDz9rJLxS6LBsVgWJXtbJIFBaAH2nzu7tBEic76fFUEphPjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5cc1fdfa497aab9f7abcac3a84e39df9</guid>
<title>工具 | 滴滴开源的一站式 Apache Kafka 集群指标监控与运维管控平台</title>
<link>https://toutiao.io/k/jz2zdk9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;大家好，我是周刊菌。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以下内容选自「码农周刊 VIP 会员」圈子，每日更新，精彩不断&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;1111&quot; data-ratio=&quot;1.744&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavicWpQhTALEcfH5yHp9JpjJKwUiccPiaGkVvHEnObRGhQKIibNVJJ0Og8UFbqONp2L6LPfqJHeVUK7Aug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;「码农周刊 VIP 会员」推出 38 周啦！感谢亲们的大力支持！第 038 期「码农周刊 VIP 会员专属邮件周报」已发送完毕，请注意查收。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;告诉大家一个好消息&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：已有数位上市公司 CTO 低调订阅了我们的「码农周刊 VIP 会员专属邮件周报」，感谢肯定！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;255&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;255&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;300&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/t8lpVibticjQ7PeUupLzwuuAibicnrRNxKcfCY7fIva78efKsUzANlCCAeuSQEGkGm34rKkzNRpzy6IiaiaHmBNA6DcA/640?wx_fmt=jpeg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;「码农周刊 VIP 会员」是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;简介版&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;码农周刊 VIP 会员 = 全年 52 期「VIP 会员专属邮件周报」 + 只限 VIP 会员加入的交流圈子 + 大厂「内推机会」 + N 多福利&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;详细版&lt;/span&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点击「阅读原文」即可查看详细介绍&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;码农周刊 VIP 新年特惠&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;原价 365 元/年&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;，现价仅需 108 元！&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;全年 52 期「VIP 会员专属邮件周报」&lt;br/&gt;只限 VIP 会员加入的交流圈子&lt;br/&gt;大厂「内推机会」&lt;br/&gt;N 多福利，你值得拥有！&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;CTO 们邀请你加入码农周刊 VIP，升职加薪不再难！&lt;br/&gt;↓↓↓&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;31&quot; data-cropselx2=&quot;291&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;350&quot; data-ratio=&quot;1.0857487922705313&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNav9LRTqibic3sUoh5tv76OXCpNTWbZ0gCYsFDShjwfRVvM157WDel2cr2dy5ghjxDCCwRc2Mu8bgehnA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;828&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>607150c1c773b46bf7f32e027d76cdc5</guid>
<title>Spring 中的 IoC 容器</title>
<link>https://toutiao.io/k/p1pqb8m</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;概述&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 Java 后端开发而言，Spring 框架的重要性不言而喻。而 Spring 中最核心的无非就是 IoC 和 AOP。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相关的概念不再赘述，网上可以找到很多对它们的介绍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里想说的是，IoC 只是一种设计思想，它的原理在不同语言有多种实现，同一种语言也有多个产品，Spring 是 Java 语言实现中最著名的一个。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;刚开始接触 IoC 这个概念的时候对这些不是太清楚，以为是 Spring 独有的，后面发现并不是。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多小伙伴平时的工作中只知道怎么去用，但不知道 Spring 是如何实现 IoC 的。本文以及接下来的几篇文章打算从源码的角度研究和分析一下 Spring IoC 的实现原理（AOP 要不要写后面再看心情吧）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为爱好学习的猿媛们，怎么能只知其一、不知其二呢？而且面试还是很有可能问到的哦。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Spring IoC 总览&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;描述&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring IoC 主要是通过一系列的「容器」来实现的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;起初对「容器」这个概念不是很理解：听起来「容器」像是装东西的，但它究竟装的是什么东西、怎么装的呢？似乎还是有些抽象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实可以把「容器」类比成生活中常见的物品，比如水杯。水杯装的什么？当然是水。Spring 的 IoC 容器呢？装的就是 Java 对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring 中的容器主要可以分为两个系列：BeanFactory 系列和 ApplicationContext 系列。前者是最基本的容器，而后者是功能比较丰富的容器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用水杯来打比方：可以认为 BeanFactory 只是一个最简单、最原始的水杯（甚至连把手都没有），而 ApplicationContext 是比较高级的水杯，比如有把手的水杯，或者保温杯等更高级的水杯。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;继承结构&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;BeanFactory 的主要接口继承结构如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.27890625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ophTb90oYCTZuia9heym7zkbOc2Y6mS848Qt94iawPXfKdZaWVAYqJDekBzpufgic7kBvLd5Omn4oNCwY2fhibeW0A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ApplicationContext 的主要接口继承结构如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.20703125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ophTb90oYCTZuia9heym7zkbOc2Y6mS84J4lxDkXK6RtMt8EunSuRAT5MnGMuUf6bPcVthLgFOAGicNkLeicnq3AA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到 ApplicationContext 接口也继承自 BeanFactory。本来就是嘛！再高级的水杯它不还是个水杯？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那我们平时用的是哪种呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然是高级的咯！有了法拉利，还要什么自行车！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ApplicationContext 的几个主要实现类，以及它们相对完整的继承结构如下（好像稍微有点复杂，其实看看就行，这几个图都是 Intellij  IDEA 自动生成的，有兴趣也可以自己去搞一下）：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.36484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ophTb90oYCTZuia9heym7zkbOc2Y6mS84T0fsvNo7LV3ibTdtuUHYVFScUVP4mf6JT9EibWMVtKcJ4ianwdQUu5tuw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ApplicationContext 比较常用的几个实现类有：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ClassPathApplicationContext&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;FileSystemXmlApplicationContext&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;XmlWebApplicationContext&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;AnnotationConfigApplicationContext&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;AnnotationConfigWebApplicationContext&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面以 ClassPathApplicationContext 为例进行分析（其实这几个实现类的原理都是类似的）。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;代码演练&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;两个普通 Java 类&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;准备两个普通的 Java 类如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Person&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; id;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String name;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Dog pet;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;// 省略了 getter、setter、toString 方法    &lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Dog&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; age;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Person owner;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 省略了 getter、setter、toString 方法&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Spring 配置文件&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 classpath 目录下创建一个 Spring 的配置文件 application-ioc.xml，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;beans&lt;/span&gt; &lt;span&gt;xmlns&lt;/span&gt;=&lt;span&gt;&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;br/&gt;       &lt;span&gt;xmlns:xsi&lt;/span&gt;=&lt;span&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;br/&gt;       &lt;span&gt;xsi:schemaLocation&lt;/span&gt;=&lt;span&gt;&quot;http://www.springframework.org/schema/beans&lt;br/&gt;       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;bean&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;person&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;com.jaxer.spring.ioc.Person&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;property&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;pet&quot;&lt;/span&gt; &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;&quot;dog&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;bean&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;bean&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;dog&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;com.jaxer.spring.ioc.Dog&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;property&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;age&quot;&lt;/span&gt; &lt;span&gt;value&lt;/span&gt;=&lt;span&gt;&quot;1&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;property&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;owner&quot;&lt;/span&gt; &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;&quot;person&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;bean&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;beans&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;PS: 这里悄悄埋了一个伏笔，就是常见的循环依赖问题，后面再来填坑。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;测试类&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;IocTests&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test01&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ApplicationContext context = &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&lt;span&gt;&quot;application-ioc.xml&quot;&lt;/span&gt;);&lt;br/&gt;        System.out.println(context.getBean(&lt;span&gt;&quot;person&quot;&lt;/span&gt;));&lt;br/&gt;        System.out.println(context.getBean(&lt;span&gt;&quot;dog&quot;&lt;/span&gt;));&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/*&lt;br/&gt; * 输出结果：&lt;br/&gt; *  Person{id=12, name=&#x27;Jack-12&#x27;}&lt;br/&gt; *  Dog{age=1}&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个例子比较简单，看起来我们把配置文件交给了 ClassPathXmlApplicationContext，就能从它那里拿到 Person 和 Dog 的对象，那它究竟做了什么呢？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;IoC 相关流程和类&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring IoC 的实现其实还是有些复杂的，当初看了好几遍还是云里雾里（可能是我智商不够）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在分析实现原理之前，先大概了解下它的主要流程（先整体后局部，不是嘛？）。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;主要流程&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是以水杯来做对比。如果我们想从水杯中取水，主要流程如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;找到水源在哪里&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;把水装到杯子里&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从水杯中取水&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring IoC 容器跟这个过程是类似的。如果我们想从 Spring IoC 容器获取 Java 对象，那么：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;找到对象在哪里（在哪里呢？扎心了）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;把对象放入 IoC 容器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从 IoC 容器获取对象&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;哈哈，这里忽然想起了把大象放到冰箱有几个步骤，是不是有点像？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这三个步骤可以用 Spring 的术语描述如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Resource 定位&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;BeanDefinition 的载入和注册&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;依赖注入&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring IoC 容器把它管理的对象称为 Bean，定义 Bean 的原始信息称为 Resource，BeanDefinition 是 Spring 内部保存对象定义的数据结构（就像 JVM 类加载后，方法区保存的类型信息那样）。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Resource 定位&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Resource&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Resource 是 Spring 对用户定义 Bean 文件的统一封装。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如 FileSystemResource、ClassPathResource 等，有木有跟相应的 ApplicationContext 对应起来？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.278125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ophTb90oYCTZuia9heym7zkbOc2Y6mS84EQicjzvhVnUSicn576UlsWYVRb6KOqibWgbwbMgcd2ic5kR3rCAUoHpnbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ResourceLoader&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了读取 Resource，Spring 还设计了 ResourceLoader，可真是个暖心 boy，不得不说 Spring 把面向对象（OOP）的设计思想表现的淋漓尽致，这只不过是冰山一角。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ResourceLoader 常见实现类的继承结构如下：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.24375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ophTb90oYCTZuia9heym7zkbOc2Y6mS843P9QbdeMvPVUpKuYmL4NEia5d4nNpkXibibWnf3nibJJLSvSkaULwFrHRg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;BeanDefinition 的载入、注册&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所谓的载入，其实就是把 Resource 中的内容解析出来，转换成 Spring 内部定义的数据结构 BeanDefinition。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如上面的 application-ioc.xml 文件，配置了我们定义的 Java 类型信息，Spring 要读取和解析该文件，并把类信息转换为 BeanDefinition。是不是有点像 JVM 的类加载？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;BeanDefinition 的常见实现类和继承结构如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4453125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ophTb90oYCTZuia9heym7zkbOc2Y6mS84CL4MtpO0Fa2RaZu0OPbqh6al0XIx8r9ZLMZmnMo07ZZhAMgkqnG6zg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与之对应呢，BeanDefinition 也有 BeanDefinitionReader：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.24375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ophTb90oYCTZuia9heym7zkbOc2Y6mS843P9QbdeMvPVUpKuYmL4NEia5d4nNpkXibibWnf3nibJJLSvSkaULwFrHRg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;BeanDefinition 的注册其实比较简单，就是把前面已经载入的 BeanDefinition 注册到注册中心 BeanDefinitionRegistry。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直白一点，其实就是把 BeanDefinition 放入注册中心的 Map 中。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;依赖注入&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实就是从 Spring IoC 容器获取对象的过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个过程说起来简单，其实还是有些复杂的……后面再慢慢聊。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小结&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文先从整体上介绍 Spring IoC 以及主要接口的继承体系，后面再进一步分析它的实现原理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;啊啊啊！写到这里脑汁又被挤干净了……需要一段时间才能恢复元气。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5555555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_gif/ophTb90oYCR6eOZrkKMnznEahtiajNrSAicJDk24paw3VDzbZRLXgyibXWEuZ4qhuSgXoeFaqj1gpV96gVpZCHc7g/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;639&quot;/&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3fa17b34bc3f7f7b1d9bba2b9433040a</guid>
<title>JDK 8 升级 JDK 11 过程记录</title>
<link>https://toutiao.io/k/s6qi3p7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article class=&quot;markdown-body mt-4&quot;&gt;
        &lt;h2 id=&quot;1引言&quot;&gt;1、引言&lt;/h2&gt;
&lt;p&gt;最新版本Java15都出来了，很多小伙伴还在使用Java8，当然JDK15不是长期支持版本，最新的长期支持版本是Java11，而下一个长期支持版本要等到2021年9月发布的Java17。最近把内部几个系统从Java8升级到了Java11，升级过程还是比较简单的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blogpic.chekuspace.com/511fe63b5eaccd32fa74df869f5f38f8.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Java11的新特性如下，最兴奋的功能是ZGC，相关资料请其他文档&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blogpic.chekuspace.com/1494279-20191105151813720-564529856.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注：以下教程基于Maven配置&lt;/p&gt;
&lt;h2 id=&quot;2准备工作&quot;&gt;2、准备工作&lt;/h2&gt;
&lt;p&gt;下载openjdk，这里推荐使用华为镜像：&lt;a href=&quot;https://mirrors.huaweicloud.com/java/jdk/11.0.2+9/&quot;&gt;https://mirrors.huaweicloud.com/java/jdk/11.0.2+9/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然后导入到Idea中：&lt;/p&gt;
&lt;p&gt;打开Project Structure，以此点击SDKs--&amp;gt; 加号 --&amp;gt; Add JDK 选择目录添加，当然也可以选第一个Download JDK直接添加，不过笔者网络不好没下下来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blogpic.chekuspace.com/image-20201114205403927.png&quot; alt=&quot;image-20201114205403927&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;3编译器支持&quot;&gt;3、编译器支持&lt;/h2&gt;
&lt;p&gt;Maven支持Java11的的最低版本是3.5.4（该版本以后可以不用升级）&lt;/p&gt;
&lt;p&gt;编译插件支持，设置完成后刷新Idea，会自动将当前项目设置成JDK11&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; &amp;lt;plugin&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.8.1&amp;lt;/version&amp;gt;
     &amp;lt;configuration&amp;gt;
         &amp;lt;source&amp;gt;11&amp;lt;/source&amp;gt;
         &amp;lt;target&amp;gt;11&amp;lt;/target&amp;gt;
     &amp;lt;/configuration&amp;gt;
 &amp;lt;/plugin&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;4依赖升级&quot;&gt;4、依赖升级&lt;/h2&gt;
&lt;h3 id=&quot;1额外依赖的的jar包&quot;&gt;（1）额外依赖的的jar包&lt;/h3&gt;
&lt;p&gt;Java11中将一些包从标准JDK中移除，不引用可能会导致项目报错，&lt;/p&gt;
&lt;h4 id=&quot;resource-注解支持&quot;&gt;@Resource 注解支持:&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
   &amp;lt;groupId&amp;gt;javax.annotation&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;javax.annotation-api&amp;lt;/artifactId&amp;gt;
   &amp;lt;version&amp;gt;1.3.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;jaxb支持&quot;&gt;jaxb支持：&lt;/h4&gt;
&lt;p&gt;JDK9以后的版本，模块化的概念去除了JAXB（默认没有加载），需做接入声明。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!--  jdk11 jaxb模块引用 start  --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.glassfish.jaxb&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;jaxb-runtime&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.3.2&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;javax.xml.bind&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;jaxb-api&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.sun.xml.bind&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;jaxb-impl&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.3.0&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.glassfish.jaxb&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;jaxb-runtime&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.3.0&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;javax.activation&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;activation&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.1.1&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--  jdk11 jaxb模块引用 end  --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;2项目中可能用到的jar包&quot;&gt;（2）项目中可能用到的jar包&lt;/h3&gt;
&lt;h3 id=&quot;lombok&quot;&gt;Lombok：&lt;/h3&gt;
&lt;p&gt;首先把现在项目中所有的lombok依赖排除掉，通过Idea Maven Helper插件搜索：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blogpic.chekuspace.com/473527222.png&quot; alt=&quot;473527222&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后引入lombok最新版本：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.18.14&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;jacoco支持&quot;&gt;Jacoco支持：&lt;/h4&gt;
&lt;p&gt;升级到最新版本，最低要求0.8.0&lt;/p&gt;
&lt;p&gt;如果是用mavan plugin方式引入，修改pom.xml文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;plugin&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.jacoco&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;jacoco-maven-plugin&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;0.8.6&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/plugin&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果是javaagent方式引入，从官网下载最新的包：&lt;a href=&quot;https://www.eclemma.org/jacoco/&quot;&gt;https://www.eclemma.org/jacoco/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里下载的是0.8.6.zip，解压开使用里面的/lib/jacocoagent.jar文件即可，JVM参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-javaagent:${WORK_PATH}/jacocoagent.jar=output=tcpserver,port=6300,address=*&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;5jvm日志参数&quot;&gt;5、JVM日志参数&lt;/h2&gt;
&lt;p&gt;java11中将很多日志参数去掉了，比如以下日志参数失效：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GC_LOG=&quot;-XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -XX:+PrintAdaptiveSizePolicy \
            -XX:+PrintGCApplicationStoppedTime -XX:+PrintHeapAtGC -XX:+PrintStringTableStatistics -XX:+PrintTenuringDistribution -Xloggc:$LOG_PATH/gc.log -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=30 -XX:GCLogFileSize=50M&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;新的jvm参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GC_LOG=&quot;-Xlog:gc:$LOG_PATH/gc.log&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;6idea可能会遇到的问题排查&quot;&gt;6、IDEA可能会遇到的问题排查&lt;/h2&gt;
&lt;p&gt;常见的问题是引入了JDK11，但是编译器不支持Java11新语法，解决方案如下：&lt;/p&gt;
&lt;p&gt;打开Preferences,配置Java Compiler中的Java版本号&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blogpic.chekuspace.com/image-20201114211447417.png&quot; alt=&quot;image-20201114211447417&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果还不行，则打开Project Structure配置project和module的版本号，module的版本号理论上配置了maven compiler插件，会自动刷新&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blogpic.chekuspace.com/image-20201114211706680.png&quot; alt=&quot;image-20201114211706680&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blogpic.chekuspace.com/image-20201114211810739.png&quot; alt=&quot;image-20201114211810739&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;6结语&quot;&gt;6、结语&lt;/h2&gt;
&lt;p&gt;至此，JDK8升级JDK11就完成了，你还遇到过什么问题，欢迎留言讨论&lt;/p&gt;
&lt;p&gt;Enjoy~&lt;/p&gt;
&lt;p&gt;关注作者二维码，第一时间获取最新文章&lt;br/&gt;
&lt;img src=&quot;https://blogpic.chekuspace.com/%E4%BA%8C%E7%BB%B4%E7%A0%81_1605583601793.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

    &lt;/article&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>