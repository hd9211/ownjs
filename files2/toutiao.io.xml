<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>d82b3112b8fffa5bb22b7572ea30a579</guid>
<title>也许你该找个人聊聊？</title>
<link>https://toutiao.io/k/1qrbh71</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d1b0615f57ff3caae40456f6cd14f61f</guid>
<title>[推荐] 字节的分布式链路追踪实践，教科书式的搭建指南</title>
<link>https://toutiao.io/k/t6j66db</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;可观测性的三大基础数据是 Metrics / Log / Trace。说到这三大件，可能大家会想到当需要监控变化趋势和配置告警时就去用 Metrics；当需要细查问题时去查 log；对于微服务数量较多的系统，还得有 Trace，Trace 也可以看做一种标准结构化的 log，记录了很多固定字段，例如上下游调用关系和耗时，查看上下游调用关系或者请求耗时在链路各节点上的分布可以查看 Trace。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;263&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.46296296296296297&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8YGTBb1uYDiaUica5v0wQiaMIfWr660Gs6Xiaw2LDNX8dWWIAlWa0FnY3rEGt2s3WWYic5dia5KVHzKMKOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是如果带着孤立的观点去用这些数据的话，数据的价值会大大降低。&lt;/span&gt;&lt;span&gt;举例一个常见的场景，通过 Metrics 得知某服务 SLA 降低，错误率上升，怎么去排查根因呢？&lt;/span&gt;&lt;span&gt;先去找错误日志吧，可是我看到的错误日志是不是真的和这个错误率上升有关系呢？&lt;/span&gt;&lt;span&gt;得翻翻代码看看这些错误日志都是哪里打出来的，代表什么意思。&lt;/span&gt;&lt;span&gt;再去找找有没有错误 Trace？&lt;/span&gt;&lt;span&gt;找出来的 Trace 也不太确定是不是和这个错误率上升有关系，还是得看代码确认下。&lt;/span&gt;&lt;span&gt;终于通过一行行的代码和数据比对，确认到这个错误是下一层服务返回给我的，把那个服务的负责人拉进来一起排查吧，然后这个群越拉越大，更多的人被拖进来一层一层地查下去，最终定位到是某个底层服务上线了一个变更导致 Panic，错误层层向上传播导致服务 SLA 降低。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个过程很不美好，需要工程师理解每一项数据的底层逻辑，才能充分利用它们去解决具体问题。而在复杂的大规模微服务系统中，没有单个工程师能够做到熟悉每一个微服务的底层逻辑，因此复杂微服务系统的排障和观测往往是一项有挑战的困难工作。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;如果所有微服务的监控数据都是遵循统一模型和语义规范并且天生高度关联的呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在软件系统中，每秒钟有无数的 Context 在流动。这些 Context 可能是一个实时在线请求，也可能是一个异步处理任务。每个 Context 都会在多个微服务节点中持续传播才能最终完成。所有的监控数据（包括 Metric, Log 等）都源自于某一个 Context。Trace 就是这个 Context 的数据载体，通过标准化的数据模型，记录 Context 在多个微服务中的全部执行过程，并沿途关联上此 Context 上发生的所有事件（包括 Metric, Log 等）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再回到刚才那个 Case，当我们对某个 Metric 波动发生兴趣时，可以直接将造成此波动的 Trace 关联检索出来，然后查看这些 Trace 在各个微服务中的所有执行细节，发现是底层某个微服务在执行请求过程中发生了 Panic，这个错误不断向上传播导致了服务对外 SLA 下降。如果可观测平台做得更完善一些，将微服务的变更事件数据也呈现出来，那么一个工程师就可以快速完成整个排障和根因定位的过程，甚至不需要人，通过机器就可以自动完成整个排障和根因定位过程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;307&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5407407407407407&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8YGTBb1uYDiaUica5v0wQiaMIfVvYvZyhfLKmYIEzhmQKrnC84KP6OIWjicQn5u9TpqlzKQM4KOU5v5qQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Trace 不仅仅是用来查看耗时分布甘特图的工具，&lt;/span&gt;&lt;strong&gt;也是海量监控数据的 Context 链接纽带。&lt;/strong&gt;&lt;span&gt;基于可靠关联的 Metric / Trace / Log 数据，也构建出强大的可观测性能力，回答监控排障、SLO 调优、架构梳理、流量估算、智能化故障归因等众多复杂问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Trace 的采集以及跨服务进程的 Context 传递一般是由微服务框架等基础设施自动完成的，但是要实现最佳效果也需要所有研发工程师的理解和配合。研发工程师在编码的过程中应当有意识地在所有代码执行过程中持续传递 Context。比如在 Golang 中，context.Context 需要在所有函数调用中作为参数持续传递；在 Java 中，一般默认用 Threadlocal 作为 Context 的存储载体，但是如果有多线程或者异步的场景，则需要开发者自行对 Context 进行显式的传递，否则上下文就断了，难以实现有效的追踪和监控。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6e9be37f8f8983d177ba5a753442d609</guid>
<title>[推荐] 优惠券系统架构设计与实践</title>
<link>https://toutiao.io/k/q6yzp5j</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;一、业务背景&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;优惠券是电商常见的营销手段，具有灵活的特点，既可以作为促销活动的载体，也是重要的引流入口。优惠券系统是vivo商城营销模块中一个重要组成部分，早在15年vivo商城还是单体应用时，优惠券就是其中核心模块之一。随着商城的发展及用户量的提升，优惠券做了服务拆分，成立了独立的优惠券系统，提供通用的优惠券服务。目前，优惠券系统覆盖了优惠券的4个核心要点：创、发、用、计。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;“创”&lt;/strong&gt;指优惠券的创建，包含各种券规则和使用门槛的配置。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;“发”&lt;/strong&gt;指优惠券的发放，优惠券系统提供了多种发放优惠券的方式，满足针对不同人群的主动发放和被动发放。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;“用”&lt;/strong&gt;指优惠券的使用，包括正向购买商品及反向退款后的优惠券回退。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;“计”&lt;/strong&gt;指优惠券的统计，包括优惠券的发放数量、使用数量、使用商品等数据汇总。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;vivo商城优惠券系统除了提供常见的优惠券促销玩法外，还以优惠券的形式作为其他一些活动或资产的载体，比如手机类商品的保值换新、内购福利、与外部广告商合作发放优惠券等。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;以下为vivo商城优惠券部分场景的展示：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.03828125&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6NTK2KoQqMmNOPalPdthCwCbXROn2MOJh0C88eZwj3pt9vII8q6IFNP46eEyxpvwcgldISUWB4CA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;二、系统架构及变迁&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;优惠券最早和商城耦合在一个系统中。随着vivo商城的不断发展，营销活动力度加大，优惠券使用场景增多，优惠券系统逐渐开始“力不从心”，暴露了很多问题：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为了解决以上问题，19年优惠券系统进行了系统独立，提供通用的优惠券服务，独立后的系统架构如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.91953125&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6NTK2KoQqMmNOPalPdthCwKZvt05yFAHJoibzla0Oib7tyMd4RWNCzvGIa6IeWjXfL4s6rNWRuEbrw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;优惠券系统独立迁移方案&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;如何将优惠券从商城系统迁移出来，并兼容已对接的业务方和历史数据，也是一大技术挑战。系统迁移有两种方案：停机迁移和不停机迁移。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们采用的是不停机迁移方案：&lt;/p&gt;&lt;blockquote data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;58&quot; data-source-title=&quot;&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;静态数据：优惠券后台生成的数据，与用户无关。&lt;/p&gt;&lt;p&gt;动态数据：与用户有关的优惠券数据，含用户领取的券、券和订单的关系数据等。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;配置当前数据库开关为单写，即优惠券数据写入商城库（旧库）。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;优惠券系统上线，通过脚本迁移静态数据。迁完后，验证静态数据迁移准确性。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;配置当前数据库开关为双写，即线上数据同时写入商城库和优惠券新库。此时服务提供的数据源依旧是商城库。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;迁移动态数据。迁完后，验证动态数据迁移准确性。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;切换数据源，服务提供的数据源切换到新库。验证服务是否正确，出现问题时，切换回商城数据源。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;关闭双写，优惠券系统迁移完成。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;迁移后优惠券系统请求拓扑图如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5453125&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6NTK2KoQqMmNOPalPdthCwJb9uvPAk35Z0p3icicFjpDUOibjtMcV9p3S5HZR2WQEXCsibS1a3zOoI3Q/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;三、系统设计&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.1 优惠券分库分表&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;随着优惠券发放量越来越大，单表已经达到瓶颈。为了支撑业务的发展，综合考虑，对用户优惠券数据进行分库分表。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关键字：技术选型、分库分表因子&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;分库分表有成熟的开源方案，这里不做过多介绍。参考之前项目经验，采用了公司中间件团队提供的自研框架。原理是引入自研的MyBatis的插件，根据自定义的路由策略计算不同的库表后缀，定位至相应的库表。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;用户优惠券与用户id关联，并且用户id是贯穿整个系统的重要字段，因此使用用户id作为分库分表的路由因子。这样可以保证同一个用户路由至相同的库表，既有利于数据的聚合，也方便用户数据的查询。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;假设共分N个库M个表，分库分表的路由策略为：&lt;/p&gt;&lt;blockquote data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;72&quot; data-source-title=&quot;&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;库后缀databaseSuffix = hash(userId) / M %N&lt;/p&gt;&lt;p&gt;表后缀tableSuffix = hash(userId) % M&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.76171875&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6NTK2KoQqMmNOPalPdthCwn8kTU7upWnE5HT0qQGt9JML4yGM2FO10oxDO2QicmUpY5pwnrbdgvkg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.2 优惠券发放方式设计&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;为满足各种不同场景的发券需求，优惠券系统提供三种发券方式：&lt;strong&gt;统一领券接口&lt;/strong&gt;、&lt;strong&gt;后台定向发券&lt;/strong&gt;、&lt;strong&gt;券码兑换发放&lt;/strong&gt;。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;3.2.1 统一领券接口&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;保证领券校验的准确性&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;领券时，需要严格校验优惠券的各种属性是否满足：比如领取对象、各种限制条件等。其中，比较关键的是库存和领取数量的校验。因为在高并发的情况下，需保证数量校验的准确性，不然很容易造成用户超领。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;存在这样的场景：A用户连续发起两次领取券C的请求，券C限制每个用户领取一张。第一次请求通过了领券数量的校验，在用户优惠券未落库的情况下，如果不做限制，第二次请求也会通过领券数量的校验。这样A用户会成功领取两张券C，造成超领。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为了解决这个问题，优惠券采用的是分布式锁方案，分布式锁的实现依赖于Redis。在校验用户领券数量前先尝试获取分布式锁，优惠券发放成功后释放锁，保证用户领取同一张券时不会出现超领。上面这种场景，用户第一次请求成功获取分布式锁后，直至第一次请求成功释放已获取的分布式锁或超时释放，不然用户第二次请求会获取分布式锁失败，这样保证A用户只会成功领取一张。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;库存扣减&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;领券要进行库存扣减，常见库存扣减方案有两种：&lt;/p&gt;&lt;p&gt;&lt;strong/&gt;&lt;/p&gt;&lt;blockquote data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;197&quot; data-source-title=&quot;&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;方案一：&lt;/strong&gt;数据库扣减。&lt;/section&gt;&lt;section&gt;扣减库存时，直接更新数据库中库存字段。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;该方案的&lt;strong&gt;优点&lt;/strong&gt;是简单便捷，查验库存时直接查库即可获取到实时库存。且有数据库事务保证，不用考虑数据丢失和不一致的问题。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;缺点&lt;/strong&gt;也很明显，主要有两点：&lt;/section&gt;&lt;section&gt;1）库存是数据库中的单个字段，在更新库存时，所有的请求需要等待行锁。一旦并发量大了，就会有很多请求阻塞在这里，导致请求超时，进而系统雪崩。&lt;/section&gt;&lt;section&gt;2）频繁请求数据库，比较耗时，且会大量占用数据库连接资源。&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong/&gt;&lt;/p&gt;&lt;blockquote data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;121&quot; data-source-title=&quot;&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;方案二：&lt;/strong&gt;基于redis实现库存扣减操作。&lt;/section&gt;&lt;section&gt;将库存放到缓存中，利用redis的incrby特性来扣减库存。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;该方案的&lt;strong&gt;优点&lt;/strong&gt;是突破数据库的瓶颈，速度快，性能高。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;缺点&lt;/strong&gt;是系统流程会比较复杂，而且需要考虑缓存丢失或宕机数据恢复的问题，容易造成库存数据不一致。&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;从优惠券系统当前及可预见未来的流量峰值、系统维护性、实用性上综合考虑，优惠券系统采用了方案一的改进方案。改进方案是将单库存字段分散成多库存字段，分散数据库的行锁，减少并发量大的情况数据库的行锁瓶颈。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.64609375&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6NTK2KoQqMmNOPalPdthCwZITOHPTeUaIibEGYKsjHGaO8fGzkNsLicwowDyX3lY2qO0mWFIMXyicUg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;库存数更新后，会将库存平均分配成M份，初始化更新到库存记录表中。用户领券，随机选取库存记录表中已分配的某一库存字段（共M个）进行更新，更新成功即为库存扣减成功。同时，定时任务会定期同步已领取的库存数。相比方案一，该方案突破了数据库单行锁的瓶颈限制，且实现简单，不用考虑数据丢失和不一致的问题。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;一键领取多张券&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在对接的业务方的领券场景中，存在用户一键领取多张券的情形。因此统一领券接口需要支持用户一键领券，除了领取同一券模板的多张，也支持领取不同券模板的多张。一般来说，一键领取多张券指领取不同券模板的多张。在实现过程中，需要注意以下几点：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1）如何保证性能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;领取多张券，如果每张券分别进行校验、库存扣减、入库，那么接口性能的瓶颈卡在券的数量上，数量越多，性能直线下降。那么在券数量多的情况下，怎么保证高性能呢？主要采取两个措施：&lt;/p&gt;&lt;blockquote data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;175&quot; data-source-title=&quot;&quot;&gt;&lt;section&gt;&lt;section&gt;a. &lt;strong&gt;批量操作&lt;/strong&gt;。&lt;/section&gt;&lt;section&gt;从发券流程来看，瓶颈在于券的入库。领券是实时的（异步的话，不能实时将券发到用户账户下，影响到用户的体验还有券的转化率），券越多，入库时与数据库的IO次数越多，性能越差。批量入库可以保证与数据库的IO的次数只有一次，不受券的数量影响。如上所述，用户优惠券数据做了分库分表，同一用户的优惠券资产保存在同一库表中，因此同一用户可实现批量入库。&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;blockquote data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;38&quot; data-source-title=&quot;&quot;&gt;&lt;section&gt;&lt;section&gt;b. &lt;strong&gt;限制单次领券数量&lt;/strong&gt;。&lt;/section&gt;&lt;section&gt;设置阀值，超出数量后，直接返回，保证系统在安全范围内。&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2）保证高并发情况下，用户不会超领&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;假如用户在商城发起请求，一键领取A/B/C/D四张券，同时活动系统给用户发放券A，这两个领券请求是同时的。其中，券A限制了每个用户只能领取一张。按照前述采用分布式锁保证校验的准确性，两次请求的分布式锁的key分别为：&lt;/p&gt;&lt;blockquote data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;33&quot; data-source-title=&quot;&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;用户id+A_id+B_id+C_id+D_id&lt;/p&gt;&lt;p&gt;用户id+A_id&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这种情况下，两次请求的分布式锁并没有发挥作用，因为锁key是不同，数量校验依旧存在错误的可能性。为避免批量领券过程中用户超领现象的发生，在批量领券过程中，对分布锁的获取进行了改造。上例一键领取A/B/C/D四张券，需要批量获取4个分布式锁，锁key为：&lt;/p&gt;&lt;blockquote data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;36&quot; data-source-title=&quot;&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;用户id+A_id&lt;/p&gt;&lt;p&gt;用户id+B_id&lt;/p&gt;&lt;p&gt;用户id+C_id&lt;/p&gt;&lt;p&gt;用户id+D_id&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;获取其中任何一个锁失败，即表明此时该用户正在领取其中某一张券，需要自旋等待（在超时时间内）。获取所有的分布式锁成功，才可以进行下一步。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;接口幂等性&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;统一领券接口需保证幂等性（幂等性：用户对于同一操作发起的一次请求或者多次请求的结果是一致的）。在网络超时、异常情况下，领券结果没有及时返回，业务方会进行领券重试。如果接口不保证幂等性，会造成超发。幂等性的实现有多种方案，优惠券系统利用数据库的唯一索引来保证幂等。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;领券最早是不支持幂等性的，表设计没有考虑幂等性。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;那么&lt;strong&gt;第一个需要考虑的问题：在哪个表来添加唯一索引呢？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;无非两种方案：现有的表或者新建表。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第二个考虑的问题：怎么兼容历史数据和业务方？&lt;/strong&gt;历史数据增加了唯一字段，需要填入唯一值，不然无法添加唯一索引。我们采用脚本刷数据的方式，构造唯一值并刷新到每一行历史数据中。优惠券已对接的业务方没有传入唯一编码，针对这种情况，优惠券侧生成唯一编码作为替代，保证兼容性。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;3.2.2 定向发券&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;定向发券用于运营在后台针对特定人群进行发券。定向发券可以弥补用户主动领券，人群覆盖不精准、覆盖面不广的问题。通过定向发券，可以精准覆盖特定人群，提高下单转化率。在大促期间，大范围人群的定向发券还可以承载活动push和降价促销双重任务。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;定向发券主要在于人群的圈选和发券流程的设计，整体流程如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.81875&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6NTK2KoQqMmNOPalPdthCwNLJgCfVjmdibfNwcMCHYH8OEvsqUu8Db19zpnCTVCfV002asLiclHybw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;定向发券不同于用户主动领券，定向发券的量通常会很大（亿级）。为了支撑大批量的定向发券，定向发券做了一些优化：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1）去除事务&lt;/strong&gt;。事务逻辑过重，对于定向发券来说没必要。发券失败，记录失败的券，保证失败可以重试。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2）轻量化校验&lt;/strong&gt;。定向发券限制了券类型，通过限制配置的方式规避需严格校验属性的配置。不同于用户主动领券校验逻辑的冗长，定向发券的校验非常轻量，大大提升发券性能。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3）批量插入&lt;/strong&gt;。批量券插入减少数据库IO次数，消除数据库瓶颈，提升发券速度。定向发券是针对不同的用户，用户优惠券做了分库分表，为了实现批量插入，需要在内存中先计算出不同用户对应的库表后缀，数据归集后再批量插入，最多插入M次，M为库表总个数。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4）核心参数可动态配置&lt;/strong&gt;。比如单次发券数量，单次读库数量，发给消息中心的消息体包含的用户数量等，可以控制定向发券的峰值速度和平均速度。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;3.2.3 券码兑换&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;站外营销券的发放方式与其他券不同，通过券码进行兑换。券码由后台导出，通过短信或者活动的方式发放到用户，用户根据券码兑换后获取相应的券。券码的组成有一定的规则，在规则的基础上要保证安全性，这种安全性主要是券码校验的准确性，防止已兑换券码的再次兑换和无效券码的恶意兑换。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.3 精细化营销能力设计&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;通过标签组合配置的方式，优惠券提供精细化营销的能力，以实现优惠券的千人千面。标签可分为准实时和实时，值得注意的是，一些实时的标签的处理需要前提条件，比如地区属性需要用户授权。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;优惠券的精准触达：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6686746987951807&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;996&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6NTK2KoQqMmNOPalPdthCwB6lRo0XACE1vr3xics8dA6QLpneDIUFxuP1fGj3iaYfgYXa84MR2SYIQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.4 券和商品之间的关系&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;优惠券的使用需要和商品关联，可关联所有商品，也可以关联部分商品。为了灵活性地满足运营对于券关联商品的配置，优惠券系统有两种关联方式：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;119&quot; data-source-title=&quot;&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;a. 黑名单。&lt;/p&gt;&lt;p&gt;可用商品 = 全部商品 - 黑名单商品。&lt;/p&gt;&lt;p&gt;黑名单适用于券的可使用商品范围比较广这种情况，全部商品排除掉黑名单商品就是券的可使用范围。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;b. 白名单。&lt;/p&gt;&lt;p&gt;可用商品 = 白名单商品。&lt;/p&gt;&lt;p&gt;白名单适用于券的可使用商品范围比较小这种情况，直接配置券的可使用商品。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;除此以外，还有超级黑名单的配置，黑名单和白名单只对单个券有效，超级黑名单对所有券有效。当前优惠券系统提供商品级的关联，后续优惠券会支持商品分类维度的关联，分类维度 + 商品维度可以更灵活地关联优惠券和商品。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.5 高性能保证&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;优惠券对接系统多，存在高流量场景，优惠券对外提供接口需保证高性能和高稳定性。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;多级缓存&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;为了提升查询速度，减轻数据库的压力，同时为了应对瞬时高流量带来热点key的场景（比如发布会直播结束切换流量至特定商品商详页、热点活动商品商详页都会给优惠券系统带来瞬时高流量），优惠券采用了多级缓存的方式。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.628125&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6NTK2KoQqMmNOPalPdthCwnu8K8v2LhBtySIYKMD4FzEaecfhPs9tQfFCZFOA5FkiaxCFz5I4fUibA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;数据库读写分离&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;优惠券除了上述所说的分库分表外，在此基础上还做了读写分离操作。主库负责执行数据更新请求，然后将数据变更实时同步到所有从库，用从库来分担查询请求，解决数据库写入影响查询的问题。主从同步存在延迟，正常情况下延迟不超过1ms，优惠券的领取或状态变更存在一个耗时的过程，主从延迟对于用户来说无感知。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9698630136986301&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1095&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6NTK2KoQqMmNOPalPdthCwiabPvOLmgm9WzmMoCwQicKNp1JXiaia4lG3X8ibG8Nw64H8SeOSsBX5r9jw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;依赖外部接口隔离熔断&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;优惠券内部依赖了第三方的系统，为了防止因为依赖方服务不可用，产生连锁效应，最终导致优惠券服务雪崩的事情发生，优惠券对依赖外部接口做了隔离和熔断。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;用户维度优惠券字段冗余&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;查询用户相关的优惠券数据是优惠券最频繁的查询操作之一，用户优惠券数据做了分库分表，在查询时无法关联券规则表进行查询，为了减少IO次数，用户优惠券表中冗余了部分券规则的字段。优惠券规则表字段较多，冗余的字段不能很多，要在性能和字段数之间做好平衡。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;四、总结及展望&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;最后对优惠券系统进行一个总结：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;展望：目前优惠券系统主要服务于vivo商城，未来我们希望将优惠券能力开放，为内部其他业务方提供通用一体化的优惠券平台。&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;往期推荐：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;技术琐话 &lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;以分布式设计、架构、体系思想为基础，兼论研发相关的点点滴滴，不限于代码、质量体系和研发管理。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzIxMzEzMjM5NQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/nhlGsolibOWF3auwD2unWLZHOt6TeCJ1iboL4Po7ickwKsibk7WgicbkOxG7wibMw8ZsSMQtDpR9D3OsF2RKibxKN00Xg/0?wx_fmt=png&quot; data-nickname=&quot;技术琐话&quot; data-alias=&quot;TheoryPractice&quot; data-signature=&quot;最干货的java+分布式技术公众号，兼及研发管理。本号专家阵容：蚂蚁金服右军、NETSTARS CTO陈斌、江苏百瑞赢李伟山、前蚂蚁金服高级技术专家张翔、美团高级技术专家杨彪等。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f768b9882ec0974b24b5ad1ccd135cbf</guid>
<title>[推荐] 优雅整洁的 Java 代码命名技巧，风之极·净化</title>
<link>https://toutiao.io/k/abc8vou</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;&lt;span&gt;可能是最全的命名规范，建议收藏，文末抽奖福利。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.562962962962963&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/EoJib2tNvVtdsxhk6iazHH8Yfoyz95eLhOqLCsQcKbVL29Wx3PibOSxseYoKnI7zcXibn7tP2Z07yvLJBevtx4s4sw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;合格的程序员不仅仅是让代码跑起来，而是要做到代码整洁，只满足为了能让编译器通过编译，机器能跑就行而写代码的程序会算不上开发者，码农都不算。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好的命名能体现出代码的特征，含义或者是用途，让阅读者可以根据名称的含义快速厘清程序的脉络。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本篇分享如下代码命名套路来提高我们代码命名：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;勿模糊，准确达意&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;避免误导&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;做有意义的区分&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;结合上下文简化名称&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用可搜索、易读的名称&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;包命名规范&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;类名与方法名规范&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;混乱的代价&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我相信每个程序员都被某些人的垃圾代码恶心过，导致开发进度被严重延缓、性能差劲、bug 多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每次新增和修改代码如履薄冰，我们只有对那堆腐朽的代码了然于胸才敢修改。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着时间推移，团队生产力下降，所有人都抵触这个项目，对其束手无策。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新手不熟悉原来的场景和设计，不知道如何修改才符合实际意图，导致更容易出现混乱。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，开发团队产生了抵触心理并造反了，再也无法忍受在这个垃圾代码基础上做开发，而管理层不愿意投入资源重新设计。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;一个优秀的开发者应该时刻保持代码整洁，无关 deadline。&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;为什么会写出垃圾代码呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有的人可能会说，需求变化违背了最初的设计、排期太紧没法干好......&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，这是一种不专业的托词。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推进进度是产品经理他们该干的，虽然痴迷于进度，但是多数产品经理也会期望有良好的可拓展代码以便应对市场变换莫测的需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;连海誓山盟的爱情都会变，又如何做到需求不会改变呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们比他们更加重视代码质量，才能应对变化的需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;保护代码持续整洁优雅是每个优秀开发者都应该遵守的原则。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;混乱的代码只会拖慢未来的开发进度，唯一加快进度的方法：&lt;strong&gt;始终尽可能保持代码优雅整洁&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好比医生在做手术之前要先消毒，你说消毒太耗时间了，直接拿刀子整吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为专业的医生你会照做么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;作为专业的程序员，我们要了解代码变坏的风险并坚持保持代码质量。&lt;/strong&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是整洁代码&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码质量评判需要综合各种因素得到的，我们并不能从单一的维度去评判。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如代码可读性好，但是空间与时间复杂度高，这并不能算得上是好代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好的代码应该具备：&lt;strong&gt;易拓展和维护、简洁（只做好一件事）、可复用性强（没有重复代码）、能快速写出单元测试。可读性强、没有副作用（做了名称以外的工作）。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5455974842767296&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EoJib2tNvVtdsxhk6iazHH8Yfoyz95eLhOM9Vh4F4vDIOmzZVvpYYtqNlJfnI9yRMzvSR4Hb7EGNj6wEWAqBnicZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;636&quot;/&gt;*&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;易拓展和维护&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在不破坏原来的代码设计下，可以简单快速的修改和添加代码实现功能拓展。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单地说就是预留了拓展点，将新代码放在设计的可拓展点，不会因为新增一个功能而改动大量原始代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;对修改关闭，对拓展开放，开闭原则。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于开发而言，我们维护旧代码的时间超过新项目新代码的时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码的可维护性就变得很重要，也就是说代码分层清晰、模块划分精当，满足高内聚低耦合、抽象出合理的接口，面向接口编程就意味着有较好的可维护性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样的代码，熟悉他的资深工程师会觉得很容易维护，而新人因为不熟悉代码，不懂设计模式而无法理解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，易拓展具有主观性，我们需要提高基础技能才有资格说代码是否易拓展和维护。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;只做好一件事&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单一职责：每个函数、每个类、每个模块只专注于一件事。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不要设计大而全的类或者函数，我们需要将他们拆分成更细粒度功能更加单一的类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它不会隐藏设计者的意图，干净利落的抽象和直截了当的控制语句。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们应该让每个函数每行代码简单、逻辑清晰。这样的话，类依赖和被依赖的类也会变少，减少耦合度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是，也不能拆分太细，否则就会破坏内聚性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;高手，就是用最简单的方法去解决复杂问题。&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;没有重复代码&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在开发过程中，我们应该尽可能抽象出「变与不变」，复用已经存在的代码，不要写重复的代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如运用「封装、继承、抽象、多态」特性，代码封装成模块，隐藏变化的细节，暴露不变的接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把业务与非业务的代码逻辑分析，抽象成通用的框架、工具类等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如应用模板方法设计模式将不变的算法逻辑框架定义出来，把变化的点延迟到子类重写。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;能快速写成单元测试&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码的可测试性差，比较难写单元测试，那基本上就能说明代码设计得有问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;试想下，如果一个类大而全，有一个方法依赖了十几个外部对象才能完成工作，耦合严重。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当你在编写单元测试的时候，需要 mock 十几个依赖对象和数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那说明这个代码糟透了，需要合理拆分和设计。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;可读性强&lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;软件设计大师 Martin Fowler 说过：「Any fool can write code that a computer can understand. Good programmers write code that humans can understand.」&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;翻译成中文就是：&quot;任何二货都会编写计算机能跑的代码。优秀的程序员能够编写人能够理解的代码。”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而可读性就会涉及到编码规范、命名、注释、函数职责是否单一、长度是否精简。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;有数据显示读代码的时间与写代码的时间比例超过 10：1，并且编写当前代码的难度，取决于读周边代码的难度。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我认为可读性强是最重要的一点。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;高质量命名套路&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开发过程后命名随处可见，我们给变量、方法、参数、类、包命名。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而命名的好坏会影响我们的可读性，我们不妨从命名作为切入口来写好代码。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;勿模糊，准确达意&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在开发过程中，一旦发现更好的名称，就换掉旧的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个变量、方法、或者类的名称应该展示出它该有的功能。根据名字我们能知道它能做什么事情，如何使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如果一个名称需要大量注释来补充避免使用者跳坑，那就是糟糕的名字。&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;变量名体现出该字段作用，比如  &lt;code&gt;LocalDate now = LocaDate.now();&lt;/code&gt;  now 标识当前时间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;防止出现让人模糊无法理解，必须还要依据大量上下文才能理解的代码。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不要使用魔术。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;反例 1 ：使用魔数&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 从数据库获取列表&lt;/span&gt;&lt;br/&gt;List&amp;lt;String&amp;gt; buyerList = dao.getList();&lt;br/&gt;buyerList.forEach(x -&amp;gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= &lt;span&gt;5&lt;/span&gt;; i++) {&lt;br/&gt;  processedBuyerList.add(String.format(&lt;span&gt;&quot;%s,%s&quot;&lt;/span&gt;, i, x));&lt;br/&gt; }&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你会疑问，为啥索引是从 1 开始？为啥 &amp;lt;= 5。除此之外， i 与 1 极其相似，难以区分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正确的方式应该使用实际含义的名字让人理解这么写的目的，否则维护的人将痛苦不堪。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;反例 2：使用生僻字，又臭又长&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;UltimateAssociatedSubjectRunBatchServiceImpl&lt;/code&gt;，当我们看到这样的类名，是不是不知道怎么读，也不知道如何搜索和定位，更不知道到底表达的意思是什么，可能命这个名字的人还以为准确表达，其实是“王大妈的裹脚布，又臭又长”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原本的业务含义是：执行关联主体任务相关业务类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;鉴于此，我们第一步要避免使用生僻字，可以命名为&lt;code&gt;LinkSubjectServiceImpl&lt;/code&gt; ，清晰简单的表达出关联主体的业务逻辑都在该类。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;不要误导&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽量&lt;strong&gt;不要使用不同之处较小&lt;/strong&gt;的名称，这样让他人无法一眼区分两个名称是啥意思。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：函数 &lt;code&gt;deleteIndex&lt;/code&gt; 和函数&lt;code&gt;deleteIndexEx&lt;/code&gt;，这两个函数名区别很小了，加之函数 &lt;code&gt;deleteIndexEx&lt;/code&gt;后面&lt;code&gt;Ex&lt;/code&gt;还是缩写，也不知道是什么意思，所以他人只能去看函数内容才能明白两者的区别。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;XYZStringHandler&lt;/code&gt;与 &lt;code&gt;XYZStringStorage&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;UserController&lt;/code&gt;与 &lt;code&gt;UserInfoController&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让人抓狂，他们到底是一个东西还是不同的？差别在哪？没有两年脑血栓写不出这样的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;反例 3：名不副实&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是一个生成文件并提供下载功能的接口。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;downloadExcel&lt;/span&gt;&lt;span&gt;(HttpServletResponse response)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; List&amp;lt;File&amp;gt; files = listFile();&lt;br/&gt; String fileName = System.currentTimeMillis() + &lt;span&gt;&quot;.zip&quot;&lt;/span&gt;;&lt;br/&gt; DownloadZip.downLoadFiles(files, filePath);&lt;br/&gt; DownloadZip.fileDownload(response, filePath, fileName);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们会疑惑，&lt;code&gt;downLoadFiles&lt;/code&gt; 与 &lt;code&gt;fileDownload&lt;/code&gt; 到底有啥区别？为啥要调用两次。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种真的是十年脑血栓才写得出来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;downLoadFiles&lt;/code&gt; 的功能是创建将 files 打包成 zip 文件，而  &lt;code&gt;fileDownload&lt;/code&gt;则是把指定的文件输出给浏览器下载。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以 &lt;code&gt;downLoadFiles&lt;/code&gt; 应该命名为 &lt;code&gt;createZipFile&lt;/code&gt;用于合理区分避免误人子弟。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;做有意义的区分&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;getActiveOrder();&lt;br/&gt;getActiveOrderInfo();&lt;br/&gt;getActiveOrderData();&lt;br/&gt;getActiveOrders();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面都是废话命名，别人你怎么知道到底该调用那个方法？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哪个表示订单明细？还是历史订单，还是全部订单查询，废话是另一种没有意义的区分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;名称不同，意思却无差别。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Order、OrderInfo、OrderData&lt;/code&gt;，他们名称相同 ，意思却无差别，属于&lt;strong&gt;毫无意义的废话&lt;/strong&gt;。如果缺少明确约定，变量&lt;code&gt;moneyAmount&lt;/code&gt;就与&lt;code&gt;money&lt;/code&gt;没区别。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Variable&lt;/code&gt;一词永远不应当出现在变量名中。&lt;code&gt;Table&lt;/code&gt;一词永远不应当出现在表名中。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;结合上下文简化名称&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Order&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; String orderNum;&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; String orderCreateTime;&lt;br/&gt;  &lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如 &lt;code&gt;Order&lt;/code&gt;类，在该上下文中，没必要给每个成员变量重复添加 order 这个前缀单词，直接命名为 &lt;code&gt;createTime&lt;/code&gt;、&lt;code&gt;num&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为我们可以借助 &lt;code&gt;Order&lt;/code&gt; 这个上下文来获取信息。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Order order = &lt;span&gt;new&lt;/span&gt; Order();&lt;br/&gt;order.getCreateTime();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;名称易读、可搜索&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可读指的是不要使用一些生僻字，难以发音的单词。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可搜索是便于利用 IED 的自动补全和搜索功能，能根据我们的命名规范快速定位想要找的类或者方法等。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;可读&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;名称读不出来，在讨论的时候就好像是一个沙雕。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哎，那个「treeNewBeeAxibaKula」类是什么作用？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;听到这样的名字尴尬癌都犯了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用一些生僻字，犹如「王大妈的裹脚布，又长又臭」，没有两年脑血栓写不出这样的垃圾代码。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;可搜索&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;IED 很智能，当我们输入 「Hash」的时候，会列举出所有 Hash 相关的类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;命名的时候最好符合项目命名习惯，列表数据查询大家使用 listXXX，你就不要用 queryXXX，统一命名规范，很重要。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;包命名&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;包名&lt;/strong&gt;统一使用&lt;strong&gt;小写&lt;/strong&gt;，&lt;strong&gt;点分隔符&lt;/strong&gt;之间有且仅有一个自然语义的英文单词或者多个单词自然连接到一块（如 springframework，deepspace 不需要使用任何分割）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;包名的构成可以分为以下几四部分【前缀】 【发起者名】【项目名】【模块名】。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;以下表格授权于「Java 填坑笔记」&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的前缀可以分为以下几种：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;前缀名&lt;/th&gt;&lt;th&gt;例&lt;/th&gt;&lt;th&gt;含义&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;indi（或onem ）&lt;/td&gt;&lt;td&gt;indi.发起者名.项目名.模块名.……&lt;/td&gt;&lt;td&gt;个体项目，指个人发起，但非自己独自完成的项目，可公开或私有项目，copyright主要属于发起者。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;pers&lt;/td&gt;&lt;td&gt;pers.个人名.项目名.模块名.……&lt;/td&gt;&lt;td&gt;个人项目，指个人发起，独自完成，可分享的项目，copyright主要属于个人&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;priv&lt;/td&gt;&lt;td&gt;priv.个人名.项目名.模块名.……&lt;/td&gt;&lt;td&gt;私有项目，指个人发起，独自完成，非公开的私人使用的项目，copyright属于个人。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;team&lt;/td&gt;&lt;td&gt;team.团队名.项目名.模块名.……&lt;/td&gt;&lt;td&gt;团队项目，指由团队发起，并由该团队开发的项目，copyright属于该团队所有&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;顶级域名&lt;/td&gt;&lt;td&gt;com.公司名.项目名.模块名.……&lt;/td&gt;&lt;td&gt;公司项目，copyright由项目发起的公司所有&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;类名&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;类名使用大驼峰命名形式&lt;/strong&gt;，应该使用&lt;strong&gt;名词或者名词短语&lt;/strong&gt;，比如：Customer、Account。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;避免使用 Manager、Processor 等动词。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接口名除了用名词和名词短语以外，还可以使用形容词或形容词短语，如 Cloneable，Callable 等，表示实现该接口的类有某种功能或能力。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;属性&lt;/th&gt;&lt;th&gt;约束&lt;/th&gt;&lt;th&gt;例&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;抽象类&lt;/td&gt;&lt;td&gt;Abstract 或者 Base 开头&lt;/td&gt;&lt;td&gt;BaseUserService&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;枚举类&lt;/td&gt;&lt;td&gt;Enum 作为后缀&lt;/td&gt;&lt;td&gt;GenderEnum&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;工具类&lt;/td&gt;&lt;td&gt;Utils作为后缀&lt;/td&gt;&lt;td&gt;StringUtils&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;异常类&lt;/td&gt;&lt;td&gt;Exception结尾&lt;/td&gt;&lt;td&gt;RuntimeException&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;接口实现类&lt;/td&gt;&lt;td&gt;接口名+ ImpI 或者 前缀接口名 + 接口名&lt;/td&gt;&lt;td&gt;UserService + UserServiceImpl、IUserService + UserService&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;领域模型相关&lt;/td&gt;&lt;td&gt;/DO/DTO/VO/DAO&lt;/td&gt;&lt;td&gt;正例：UserDAO 反例：UserDo， UserDao&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;设计模式相关类&lt;/td&gt;&lt;td&gt;Builder，Factory等&lt;/td&gt;&lt;td&gt;当使用到设计模式时，需要使用对应的设计模式作为后缀，如ThreadFactory&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;处理特定功能的&lt;/td&gt;&lt;td&gt;Handler，Predicate, Validator&lt;/td&gt;&lt;td&gt;表示处理器，校验器，断言，这些类工厂还有配套的方法名如handle，predicate，validate&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;测试类&lt;/td&gt;&lt;td&gt;Test结尾&lt;/td&gt;&lt;td&gt;UserServiceTest， 表示用来测试UserService类的&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;方法名&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法命名一般为&lt;strong&gt;动词或动词短语&lt;/strong&gt;，与参数或参数名共同组成动宾短语，即动词 + 名词。一个好的函数名一般能通过名字直接获知该函数实现什么样的功能。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;布尔返回值的方法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注：Prefix-前缀，Suffix-后缀，Alone-单独使用&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;位置&lt;/th&gt;&lt;th&gt;单词&lt;/th&gt;&lt;th&gt;意义&lt;/th&gt;&lt;th&gt;例&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;is&lt;/td&gt;&lt;td&gt;对象是否符合期待的状态&lt;/td&gt;&lt;td&gt;isValid&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;can&lt;/td&gt;&lt;td&gt;对象&lt;strong&gt;能否执行&lt;/strong&gt;所期待的动作&lt;/td&gt;&lt;td&gt;canRemove&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;should&lt;/td&gt;&lt;td&gt;调用方执行某个命令或方法是&lt;strong&gt;好还是不好&lt;/strong&gt;,&lt;strong&gt;应不应该&lt;/strong&gt;，或者说&lt;strong&gt;推荐还是不推荐&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;shouldMigrate&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;has&lt;/td&gt;&lt;td&gt;对象&lt;strong&gt;是否持有&lt;/strong&gt;所期待的数据和属性&lt;/td&gt;&lt;td&gt;hasObservers&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;needs&lt;/td&gt;&lt;td&gt;调用方&lt;strong&gt;是否需要&lt;/strong&gt;执行某个命令或方法&lt;/td&gt;&lt;td&gt;needsMigrate&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;按需执行的方法&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;位置&lt;/th&gt;&lt;th&gt;单词&lt;/th&gt;&lt;th&gt;意义&lt;/th&gt;&lt;th&gt;例&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Suffix&lt;/td&gt;&lt;td&gt;IfNeeded&lt;/td&gt;&lt;td&gt;需要的时候执行，不需要的时候什么都不做&lt;/td&gt;&lt;td&gt;drawIfNeeded&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;might&lt;/td&gt;&lt;td&gt;同上&lt;/td&gt;&lt;td&gt;mightCreate&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;try&lt;/td&gt;&lt;td&gt;尝试执行，失败时抛出异常或是返回errorcode&lt;/td&gt;&lt;td&gt;tryCreate&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Suffix&lt;/td&gt;&lt;td&gt;OrDefault&lt;/td&gt;&lt;td&gt;尝试执行，失败时返回默认值&lt;/td&gt;&lt;td&gt;getOrDefault&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Suffix&lt;/td&gt;&lt;td&gt;OrElse&lt;/td&gt;&lt;td&gt;尝试执行、失败时返回实际参数中指定的值&lt;/td&gt;&lt;td&gt;getOrElse&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;force&lt;/td&gt;&lt;td&gt;强制尝试执行。error抛出异常或是返回值&lt;/td&gt;&lt;td&gt;forceCreate, forceStop&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;用来检查的方法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;单词&lt;/th&gt;&lt;th&gt;意义&lt;/th&gt;&lt;th&gt;例&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;ensure&lt;/td&gt;&lt;td&gt;检查是否为期待的状态，不是则抛出异常或返回error code&lt;/td&gt;&lt;td&gt;ensureCapacity&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;validate&lt;/td&gt;&lt;td&gt;检查是否为正确的状态，不是则抛出异常或返回error code&lt;/td&gt;&lt;td&gt;validateInputs&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;异步相关方法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;位置&lt;/th&gt;&lt;th&gt;单词&lt;/th&gt;&lt;th&gt;意义&lt;/th&gt;&lt;th&gt;例&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;blocking&lt;/td&gt;&lt;td&gt;线程阻塞方法&lt;/td&gt;&lt;td&gt;blockingGetUser&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Suffix&lt;/td&gt;&lt;td&gt;InBackground&lt;/td&gt;&lt;td&gt;执行在后台的线程&lt;/td&gt;&lt;td&gt;doInBackground&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Suffix&lt;/td&gt;&lt;td&gt;Async&lt;/td&gt;&lt;td&gt;异步方法&lt;/td&gt;&lt;td&gt;sendAsync&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Suffix&lt;/td&gt;&lt;td&gt;Sync&lt;/td&gt;&lt;td&gt;对应已有异步方法的同步方法&lt;/td&gt;&lt;td&gt;sendSync&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix or Alone&lt;/td&gt;&lt;td&gt;schedule&lt;/td&gt;&lt;td&gt;Job和Task放入队列&lt;/td&gt;&lt;td&gt;schedule, scheduleJob&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix or Alone&lt;/td&gt;&lt;td&gt;post&lt;/td&gt;&lt;td&gt;同上&lt;/td&gt;&lt;td&gt;postJob&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix or Alone&lt;/td&gt;&lt;td&gt;execute&lt;/td&gt;&lt;td&gt;执行异步方法（注：我一般拿这个做同步方法名）&lt;/td&gt;&lt;td&gt;execute, executeTask&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix or Alone&lt;/td&gt;&lt;td&gt;start&lt;/td&gt;&lt;td&gt;同上&lt;/td&gt;&lt;td&gt;start, startJob&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix or Alone&lt;/td&gt;&lt;td&gt;cancel&lt;/td&gt;&lt;td&gt;停止异步方法&lt;/td&gt;&lt;td&gt;cancel, cancelJob&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix or Alone&lt;/td&gt;&lt;td&gt;stop&lt;/td&gt;&lt;td&gt;同上&lt;/td&gt;&lt;td&gt;stop, stopJob&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;回调方法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;位置&lt;/th&gt;&lt;th&gt;单词&lt;/th&gt;&lt;th&gt;意义&lt;/th&gt;&lt;th&gt;例&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;on&lt;/td&gt;&lt;td&gt;事件发生时执行&lt;/td&gt;&lt;td&gt;onCompleted&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;before&lt;/td&gt;&lt;td&gt;事件发生前执行&lt;/td&gt;&lt;td&gt;beforeUpdate&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;pre&lt;/td&gt;&lt;td&gt;同上&lt;/td&gt;&lt;td&gt;preUpdate&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;will&lt;/td&gt;&lt;td&gt;同上&lt;/td&gt;&lt;td&gt;willUpdate&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;after&lt;/td&gt;&lt;td&gt;事件发生后执行&lt;/td&gt;&lt;td&gt;afterUpdate&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;post&lt;/td&gt;&lt;td&gt;同上&lt;/td&gt;&lt;td&gt;postUpdate&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;did&lt;/td&gt;&lt;td&gt;同上&lt;/td&gt;&lt;td&gt;didUpdate&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;should&lt;/td&gt;&lt;td&gt;确认事件是否可以发生时执行&lt;/td&gt;&lt;td&gt;shouldUpdate&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;操作对象生命周期的方法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;单词&lt;/th&gt;&lt;th&gt;意义&lt;/th&gt;&lt;th&gt;例&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;initialize&lt;/td&gt;&lt;td&gt;初始化。也可作为延迟初始化使用&lt;/td&gt;&lt;td&gt;initialize&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;pause&lt;/td&gt;&lt;td&gt;暂停&lt;/td&gt;&lt;td&gt;onPause ，pause&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;stop&lt;/td&gt;&lt;td&gt;停止&lt;/td&gt;&lt;td&gt;onStop，stop&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;abandon&lt;/td&gt;&lt;td&gt;销毁的替代&lt;/td&gt;&lt;td&gt;abandon&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;destroy&lt;/td&gt;&lt;td&gt;同上&lt;/td&gt;&lt;td&gt;destroy&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;dispose&lt;/td&gt;&lt;td&gt;同上&lt;/td&gt;&lt;td&gt;dispose&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.7 与集合操作相关的方法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;单词&lt;/th&gt;&lt;th&gt;意义&lt;/th&gt;&lt;th&gt;例&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;contains&lt;/td&gt;&lt;td&gt;是否持有与指定对象相同的对象&lt;/td&gt;&lt;td&gt;contains&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;add&lt;/td&gt;&lt;td&gt;添加&lt;/td&gt;&lt;td&gt;addJob&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;append&lt;/td&gt;&lt;td&gt;添加&lt;/td&gt;&lt;td&gt;appendJob&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;insert&lt;/td&gt;&lt;td&gt;插入到下标n&lt;/td&gt;&lt;td&gt;insertJob&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;put&lt;/td&gt;&lt;td&gt;添加与key对应的元素&lt;/td&gt;&lt;td&gt;putJob&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;remove&lt;/td&gt;&lt;td&gt;移除元素&lt;/td&gt;&lt;td&gt;removeJob&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;enqueue&lt;/td&gt;&lt;td&gt;添加到队列的最末位&lt;/td&gt;&lt;td&gt;enqueueJob&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;dequeue&lt;/td&gt;&lt;td&gt;从队列中头部取出并移除&lt;/td&gt;&lt;td&gt;dequeueJob&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;push&lt;/td&gt;&lt;td&gt;添加到栈头&lt;/td&gt;&lt;td&gt;pushJob&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;pop&lt;/td&gt;&lt;td&gt;从栈头取出并移除&lt;/td&gt;&lt;td&gt;popJob&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;peek&lt;/td&gt;&lt;td&gt;从栈头取出但不移除&lt;/td&gt;&lt;td&gt;peekJob&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;find&lt;/td&gt;&lt;td&gt;寻找符合条件的某物&lt;/td&gt;&lt;td&gt;findById&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;与数据相关的方法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;单词&lt;/th&gt;&lt;th&gt;意义&lt;/th&gt;&lt;th&gt;例&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;create&lt;/td&gt;&lt;td&gt;新创建&lt;/td&gt;&lt;td&gt;createAccount&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;new&lt;/td&gt;&lt;td&gt;新创建&lt;/td&gt;&lt;td&gt;newAccount&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;from&lt;/td&gt;&lt;td&gt;从既有的某物新建，或是从其他的数据新建&lt;/td&gt;&lt;td&gt;fromConfig&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;to&lt;/td&gt;&lt;td&gt;转换&lt;/td&gt;&lt;td&gt;toString&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;update&lt;/td&gt;&lt;td&gt;更新既有某物&lt;/td&gt;&lt;td&gt;updateAccount&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;load&lt;/td&gt;&lt;td&gt;读取&lt;/td&gt;&lt;td&gt;loadAccount&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;fetch&lt;/td&gt;&lt;td&gt;远程读取&lt;/td&gt;&lt;td&gt;fetchAccount&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;delete&lt;/td&gt;&lt;td&gt;删除&lt;/td&gt;&lt;td&gt;deleteAccount&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;remove&lt;/td&gt;&lt;td&gt;删除&lt;/td&gt;&lt;td&gt;removeAccount&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;save&lt;/td&gt;&lt;td&gt;保存&lt;/td&gt;&lt;td&gt;saveAccount&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;store&lt;/td&gt;&lt;td&gt;保存&lt;/td&gt;&lt;td&gt;storeAccount&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;commit&lt;/td&gt;&lt;td&gt;保存&lt;/td&gt;&lt;td&gt;commitChange&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;apply&lt;/td&gt;&lt;td&gt;保存或应用&lt;/td&gt;&lt;td&gt;applyChange&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;clear&lt;/td&gt;&lt;td&gt;清除数据或是恢复到初始状态&lt;/td&gt;&lt;td&gt;clearAll&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;reset&lt;/td&gt;&lt;td&gt;清除数据或是恢复到初始状态&lt;/td&gt;&lt;td&gt;resetAll&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;成对出现的动词&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;单词&lt;/th&gt;&lt;th&gt;意义&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;get获取&lt;/td&gt;&lt;td&gt;set 设置&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;add 增加&lt;/td&gt;&lt;td&gt;remove 删除&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;create 创建&lt;/td&gt;&lt;td&gt;destory 移除&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;start 启动&lt;/td&gt;&lt;td&gt;stop 停止&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;open 打开&lt;/td&gt;&lt;td&gt;close 关闭&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;read 读取&lt;/td&gt;&lt;td&gt;write 写入&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;load 载入&lt;/td&gt;&lt;td&gt;save 保存&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;create 创建&lt;/td&gt;&lt;td&gt;destroy 销毁&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;begin 开始&lt;/td&gt;&lt;td&gt;end 结束&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;backup 备份&lt;/td&gt;&lt;td&gt;restore 恢复&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;import 导入&lt;/td&gt;&lt;td&gt;export 导出&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;split 分割&lt;/td&gt;&lt;td&gt;merge 合并&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;inject 注入&lt;/td&gt;&lt;td&gt;extract 提取&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;attach 附着&lt;/td&gt;&lt;td&gt;detach 脱离&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;bind 绑定&lt;/td&gt;&lt;td&gt;separate 分离&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;view 查看&lt;/td&gt;&lt;td&gt;browse 浏览&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;edit 编辑&lt;/td&gt;&lt;td&gt;modify 修改&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;select 选取&lt;/td&gt;&lt;td&gt;mark 标记&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;copy 复制&lt;/td&gt;&lt;td&gt;paste 粘贴&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;undo 撤销&lt;/td&gt;&lt;td&gt;redo 重做&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;insert 插入&lt;/td&gt;&lt;td&gt;delete 移除&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;add 加入&lt;/td&gt;&lt;td&gt;append 添加&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;clean 清理&lt;/td&gt;&lt;td&gt;clear 清除&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;index 索引&lt;/td&gt;&lt;td&gt;sort 排序&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;find 查找&lt;/td&gt;&lt;td&gt;search 搜索&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;increase 增加&lt;/td&gt;&lt;td&gt;decrease 减少&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;play 播放&lt;/td&gt;&lt;td&gt;pause 暂停&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;launch 启动&lt;/td&gt;&lt;td&gt;run 运行&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;compile 编译&lt;/td&gt;&lt;td&gt;execute 执行&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;debug 调试&lt;/td&gt;&lt;td&gt;trace 跟踪&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;observe 观察&lt;/td&gt;&lt;td&gt;listen 监听&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;build 构建&lt;/td&gt;&lt;td&gt;publish 发布&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;input 输入&lt;/td&gt;&lt;td&gt;output 输出&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;encode 编码&lt;/td&gt;&lt;td&gt;decode 解码&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;encrypt 加密&lt;/td&gt;&lt;td&gt;decrypt 解密&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;compress 压缩&lt;/td&gt;&lt;td&gt;decompress 解压缩&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;pack 打包&lt;/td&gt;&lt;td&gt;unpack 解包&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;parse 解析&lt;/td&gt;&lt;td&gt;emit 生成&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;connect 连接&lt;/td&gt;&lt;td&gt;disconnect 断开&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;send 发送&lt;/td&gt;&lt;td&gt;receive 接收&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;download 下载&lt;/td&gt;&lt;td&gt;upload 上传&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;refresh 刷新&lt;/td&gt;&lt;td&gt;synchronize 同步&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;update 更新&lt;/td&gt;&lt;td&gt;revert 复原&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;lock 锁定&lt;/td&gt;&lt;td&gt;unlock 解锁&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;check out 签出&lt;/td&gt;&lt;td&gt;check in 签入&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;submit 提交&lt;/td&gt;&lt;td&gt;commit 交付&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;push 推&lt;/td&gt;&lt;td&gt;pull 拉&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;expand 展开&lt;/td&gt;&lt;td&gt;collapse 折叠&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;begin 起始&lt;/td&gt;&lt;td&gt;end 结束&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;start 开始&lt;/td&gt;&lt;td&gt;finish 完成&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;enter 进入&lt;/td&gt;&lt;td&gt;exit 退出&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;abort 放弃&lt;/td&gt;&lt;td&gt;quit 离开&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;obsolete 废弃&lt;/td&gt;&lt;td&gt;depreciate 废旧&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;collect 收集&lt;/td&gt;&lt;td&gt;aggregate 聚集&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;命名目的都是为了让代码和工程师进行对话，增强代码的可读性，可维护性。优秀的代码往往能够见名知意。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家在工作中是否有遇到一些垃圾命名的代码呢？&lt;strong&gt;&lt;span&gt;欢迎留言&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651508541&amp;amp;idx=1&amp;amp;sn=551a5034a7f374d8ed3da25327bccca4&amp;amp;chksm=bd25a3428a522a5458b3148a80ec26ac3b454a563034bb88694839bed796d2d3212f105b82d1&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;还在用策略模式解决 if-else？Map+函数式接口方法才是YYDS！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;还在用策略模式解决 if-else？Map+函数式接口方法才是YYDS！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651503297&amp;amp;idx=2&amp;amp;sn=5f19e03d6b86789b3b28af5cee97d1e9&amp;amp;chksm=bd25d6be8a525fa8b8d16745d3454ddc4aa562571964d88eb9fd4e2cb274f8a9ae806bf0b3d5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;一个 HashMap 跟面试官扯了半个小时&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;一个 HashMap 跟面试官扯了半个小时&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651508534&amp;amp;idx=1&amp;amp;sn=dbe47cc505ca306c80db884fae973b46&amp;amp;chksm=bd25a3498a522a5fb4c338276bfd8af8699618e0e93c76aea2a11090cd7968e4ff07074a9c93&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;阿里二面：main 方法可以继承吗？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;阿里二面：main 方法可以继承吗？&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关注「ImportNew」，提升Java技能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9166666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;点赞和在看就是最大的支持&lt;/span&gt;&lt;span&gt;❤️&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2129e986567a087d07170d093ddd2966</guid>
<title>[推荐] Redis 很屌，不懂使用规范就糟蹋了</title>
<link>https://toutiao.io/k/lpnakbk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;这可能是最中肯的 Redis 使用规范了&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;码哥，昨天我被公司 Leader 批评了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我在单身红娘婚恋类型互联网公司工作，在双十一推出下单就送女朋友的活动。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;谁曾想，凌晨 12 点之后，用户量暴增，出现了一个技术故障，用户无法下单，当时老大火冒三丈！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过查找发现 Redis 报 &lt;code&gt;Could not get a resource from the pool&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;获取不到连接资源，并且集群中的单台 Redis 连接量很高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是各种更改最大连接数、连接等待数，虽然报错信息频率有所缓解，但还是&lt;strong&gt;持续报错&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后来经过线下测试，发现存放 Redis 中的&lt;strong&gt;字符数据很大，平均 1s 返回数据&lt;/strong&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;码哥，可以分享下使用 Redis 的规范么？我想做一个唯快不破的真男人！&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 使用规范围绕如下几个纬度展开：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;键值对使用规范；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;命令使用规范；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据保存规范；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;运维规范。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;键值对使用规范&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有两点需要注意：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;好的 &lt;code&gt;key&lt;/code&gt; 命名，才能提供可读性强、可维护性高的 key，便于定位问题和寻找数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;value&lt;/code&gt;要避免出现 &lt;code&gt;bigkey&lt;/code&gt;、选择高效的序列化和压缩、使用对象共享池、选择高效恰当的数据类型（可参考《Redis 实战篇：巧用数据类型实现亿级数据统计》）。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;key 命名规范&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;规范的 &lt;code&gt;key&lt;/code&gt;命名，在遇到问题的时候能够方便定位。Redis 属于 没有 &lt;code&gt;Scheme&lt;/code&gt;的 &lt;code&gt;NoSQL&lt;/code&gt;数据库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以要靠规范来建立其 &lt;code&gt;Scheme&lt;/code&gt; 语意，就好比根据不同的场景我们建立不同的数据库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;敲黑板&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把「业务模块名」作为前缀（好比数据库 &lt;code&gt;Scheme&lt;/code&gt;），通过「冒号」分隔，再加上「具体业务名」。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样我们就可以通过 &lt;code&gt;key&lt;/code&gt; 前缀来区分不同的业务数据，清晰明了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结起来就是：「业务名:表名:id」&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我们要统计公众号属于技术类型的博主「码哥字节」的粉丝数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;set&lt;/span&gt; 公众号:技术类:码哥字节 100000&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;码哥，key 太长的话有什么问题么？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;key 是字符串，底层的数据结构是 &lt;code&gt;SDS&lt;/code&gt;，SDS 结构中会包含字符串长度、分配空间大小等元数据信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;字符串长度增加，SDS 的元数据也会占用更多的内存空间。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以当字符串太长的时候，我们可以采用适当缩写的形式。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;不要使用 bigkey&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;码哥，我就中招了，导致报错获取不到连接。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;因为 Redis 是单线程执行读写指令，如果出现&lt;code&gt;bigkey&lt;/code&gt; 的读写操作就会阻塞线程，降低 Redis 的处理效率。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;bigkey&lt;/code&gt;包含两种情况：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;键值对的 &lt;code&gt;value&lt;/code&gt;很大，比如 &lt;code&gt;value&lt;/code&gt;保存了 &lt;code&gt;2MB&lt;/code&gt;的 &lt;code&gt;String&lt;/code&gt;数据；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;键值对的 &lt;code&gt;value&lt;/code&gt;是集合类型，元素很多，比如保存了 5 万个元素的 &lt;code&gt;List&lt;/code&gt; 集合。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然 Redis 官方说明了 &lt;code&gt;key&lt;/code&gt;和&lt;code&gt;string&lt;/code&gt;类型 &lt;code&gt;value&lt;/code&gt;限制均为&lt;code&gt;512MB&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;防止网卡流量、慢查询，&lt;code&gt;string&lt;/code&gt;类型控制在&lt;code&gt;10KB&lt;/code&gt;以内，&lt;code&gt;hash、list、set、zset&lt;/code&gt;元素个数不要超过 5000。&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;码哥，如果业务数据就是这么大咋办？比如保存的是《金瓶梅》这个大作。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还可以通过 &lt;code&gt;gzip&lt;/code&gt; 数据压缩来减小数据大小:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 使用gzip压缩字符串&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String &lt;span&gt;compress&lt;/span&gt;&lt;span&gt;(String str)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (str == &lt;span&gt;null&lt;/span&gt; || str.length() == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; str;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; (ByteArrayOutputStream out = &lt;span&gt;new&lt;/span&gt; ByteArrayOutputStream();&lt;br/&gt;    GZIPOutputStream gzip = &lt;span&gt;new&lt;/span&gt; GZIPOutputStream(out)) {&lt;br/&gt;        gzip.write(str.getBytes());&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;        e.printStackTrace();&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; sun.misc.BASE64Encoder().encode(out.toByteArray());&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 使用gzip解压缩&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String &lt;span&gt;uncompress&lt;/span&gt;&lt;span&gt;(String compressedStr)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (compressedStr == &lt;span&gt;null&lt;/span&gt; || compressedStr.length() == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; compressedStr;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;byte&lt;/span&gt;[] compressed = &lt;span&gt;new&lt;/span&gt; sun.misc.BASE64Decoder().decodeBuffer(compressedStr);;&lt;br/&gt;    String decompressed = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; (ByteArrayOutputStream out = &lt;span&gt;new&lt;/span&gt; ByteArrayOutputStream();&lt;br/&gt;    ByteArrayInputStream in = &lt;span&gt;new&lt;/span&gt; ByteArrayInputStream(compressed);&lt;br/&gt;    GZIPInputStream ginzip = &lt;span&gt;new&lt;/span&gt; GZIPInputStream(in);) {&lt;br/&gt;        &lt;span&gt;byte&lt;/span&gt;[] buffer = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;1024&lt;/span&gt;];&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; offset = -&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; ((offset = ginzip.read(buffer)) != -&lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;            out.write(buffer, &lt;span&gt;0&lt;/span&gt;, offset);&lt;br/&gt;        }&lt;br/&gt;        decompressed = out.toString();&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;        e.printStackTrace();&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; decompressed;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;集合类型&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果集合类型的元素的确很多，我们可以将一个大集合拆分成多个小集合来保存。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;使用高效序列化和压缩方法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了节省内存，我们可以使用高效的序列化方法和压缩方法去减少 &lt;code&gt;value&lt;/code&gt;的大小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;protostuff&lt;/code&gt;和 &lt;code&gt;kryo&lt;/code&gt;这两种序列化方法，就要比 &lt;code&gt;Java&lt;/code&gt;内置的序列化方法效率更高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述的两种序列化方式虽然省内存，但是序列化后都是二进制数据，可读性太差。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常我们会序列化成 &lt;code&gt;JSON&lt;/code&gt;或者 &lt;code&gt;XML&lt;/code&gt;，为了避免数据占用空间大，我们可以使用压缩工具（snappy、 gzip）将数据压缩再存到 Redis 中。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;使用整数对象共享池&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 内部维护了 0 到 9999 这 1 万个整数对象，并把这些整数作为一个共享池使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即使大量键值对保存了 0 到 9999 范围内的整数，在 Redis 实例中，其实只保存了一份整数对象，可以节省内存空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是，有两种情况是不生效的：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Redis 中设置了 &lt;code&gt;maxmemory&lt;/code&gt;，而且启用了 &lt;code&gt;LRU&lt;/code&gt;策略（&lt;code&gt;allkeys-lru 或 volatile-lru 策略&lt;/code&gt;），那么，整数对象共享池就无法使用了。&lt;/p&gt;&lt;blockquote&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;这是因为 LRU 需要统计每个键值对的使用时间，如果不同的键值对都复用一个整数对象就无法统计了。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果集合类型数据采用 ziplist 编码，而集合元素是整数，这个时候，也不能使用共享池。&lt;/p&gt;&lt;blockquote&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;因为 ziplist 使用了紧凑型内存结构，判断整数对象的共享情况效率低。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;命令使用规范&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有的命令的执行会造成很大的性能问题，我们需要格外注意。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;生产禁用的指令&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 是单线程处理请求操作，如果我们执行一些涉及大量操作、耗时长的命令，就会严重阻塞主线程，导致其它请求无法得到正常处理。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;KEYS：该命令需要对 Redis 的全局哈希表进行全表扫描，严重阻塞 Redis 主线程；&lt;/p&gt;&lt;blockquote&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;应该使用 SCAN 来代替，分批返回符合条件的键值对，避免主线程阻塞。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;FLUSHALL：删除 Redis 实例上的所有数据，如果数据量很大，会严重阻塞 Redis 主线程；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;FLUSHDB，删除当前数据库中的数据，如果数据量很大，同样会阻塞 Redis 主线程。&lt;/p&gt;&lt;blockquote&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;加上 ASYNC 选项，让 FLUSHALL，FLUSHDB 异步执行。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们也可以直接禁用，用&lt;code&gt;rename-command&lt;/code&gt;命令在配置文件中对这些命令进行重命名，让客户端无法使用这些命令。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;慎用 MONITOR 命令&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MONITOR 命令会把监控到的内容持续写入输出缓冲区。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果线上命令的操作很多，输出缓冲区很快就会溢出了，这就会对 Redis 性能造成影响，甚至引起服务崩溃。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，除非十分需要监测某些命令的执行（例如，Redis 性能突然变慢，我们想查看下客户端执行了哪些命令）我们才使用。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;慎用全量操作命令&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如获取集合中的所有元素（HASH 类型的 hgetall、List 类型的 lrange、Set 类型的 smembers、zrange 等命令）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些操作会对整个底层数据结构进行全量扫描 ，导致阻塞 Redis 主线程。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;码哥，如果业务场景就是需要获取全量数据咋办？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有两个方式可以解决：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;使用 &lt;code&gt;SSCAN、HSCAN&lt;/code&gt;等命令分批返回集合数据；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;把大集合拆成小集合，比如按照时间、区域等划分。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数据保存规范&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;冷热数据分离&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然 Redis 支持使用 RDB 快照和 AOF 日志持久化保存数据，但是，这两个机制都是用来提供数据可靠性保证的，并不是用来扩充数据容量的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不要什么数据都存在 Redis，应该作为缓存保存&lt;strong&gt;热数据&lt;/strong&gt;，这样既可以充分利用 Redis 的高性能特性，还可以把宝贵的内存资源用在服务热数据上。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;业务数据隔离&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不要将不相关的数据业务都放到一个 Redis 中。一方面避免业务相互影响，另一方面避免单实例膨胀，并能在故障时降低影响面，快速恢复。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;设置过期时间&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在数据保存时，我建议你根据业务使用数据的时长，设置数据的过期时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写入 Redis 的数据会一直占用内存，如果数据持续增多，就可能达到机器的内存上限，造成内存溢出，导致服务崩溃。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;控制单实例的内存容量&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;建议设置在 2~6 GB 。这样一来，无论是 RDB 快照，还是主从集群进行数据同步，都能很快完成，不会阻塞正常请求的处理。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;防止缓存雪崩&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;避免集中过期 key 导致缓存雪崩。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;码哥，什么是缓存雪崩？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当某一个时刻出现大规模的缓存失效的情况，那么就会导致大量的请求直接打在数据库上面，导致数据库压力巨大，如果在高并发的情况下，可能瞬间就会导致数据库宕机。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;运维规范&lt;/span&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;使用 Cluster 集群或者哨兵集群，做到高可用；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实例设置最大连接数，防止过多客户端连接导致实例负载过高，影响性能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不开启 AOF 或开启 AOF 配置为每秒刷盘，避免磁盘 IO 拖慢 Redis 性能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设置合理的 repl-backlog，降低主从全量同步的概率&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设置合理的 slave client-output-buffer-limit，避免主从复制中断情况发生。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;根据实际场景设置合适的内存淘汰策略。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用连接池操作 Redis。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU0OTE4MzYzMw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk55KKLFaGCDRURMvFtPXf9fZXJOHOFsA3Ye8Qbibf3qHLkBQNpdjicAVpPf2T03EcakjAFbwqicjXSibXA/0?wx_fmt=png&quot; data-nickname=&quot;架构师社区&quot; data-alias=&quot;devabc&quot; data-signature=&quot;架构师社区，专注分享架构师技术干货，架构师行业秘闻，汇集各类奇妙好玩的架构师话题和流行的架构师动向！&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>