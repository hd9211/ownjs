<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>3ca34d4329b4a3246ca681130982e124</guid>
<title>一款前端性能监控系统</title>
<link>https://toutiao.io/k/r0ghwnu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;大家好，我是周刊菌。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4Njk2NDAzMA==&amp;amp;mid=2660215615&amp;amp;idx=2&amp;amp;sn=844e0251c92fa230434af84b6e49d5d9&amp;amp;chksm=84bba96eb3cc2078f8bf59ced9b7909530f69cb94e8c5405f7d05fb731e4711b7362bdf7b6c0&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;加入「码农周刊VIP会员」，一起牛起来！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;以下内容选自「码农周刊 VIP 会员」圈子，每日更新，精彩不断&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;1014&quot; data-ratio=&quot;1.512&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/t8lpVibticjQ5akDVbyFRcrK98pUqmWkBP3UyVjfABXJ8IMtbjJpPheS8YXJia8nUP5WhOtib1dEUaBD4lOfZjs1Pw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;码农周刊是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;码农周刊是一份专为广大程序员、编程爱好者们打造的 IT 技术周刊。每周发送。&lt;br/&gt;2013 年 9 月 12 日创刊至今，已发送 300 多期，订阅用户超 20 万。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;专业、简单、有用&lt;/span&gt;&lt;span&gt;，是我们一直坚持的办刊宗旨。一路走来，我们见证了不少订阅用户从编程新手进阶成了高级程序员、架构师、CTO……&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2020 年 4 月，为了给用户提供更优质的服务，我们推出了「&lt;/span&gt;&lt;span&gt;码农周刊VIP会员&lt;/span&gt;&lt;span&gt;」服务。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你与 BAT 技术大牛，只差一份「码农周刊VIP会员」的距离！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;VIP会员特权&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 52 期码农周刊VIP会员&lt;span&gt;专属邮件周报&lt;/span&gt;，让你及时掌握技术动向；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 只限VIP会员加入的&lt;span&gt;交流圈子&lt;/span&gt;，让你与技术大牛切磋学习；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. VIP会员独享的&lt;span&gt;工作机会&lt;/span&gt;，为你介绍好公司的好机会；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 更多会员特权，持续更新……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如何加入「码农周刊VIP会员」？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1. 微信扫描下方二维码，加入码农周刊VIP会员知识星球。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;促销期间，一年仅需 108 元！平均一天花费不到 3 毛！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;34&quot; data-cropselx2=&quot;356&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;425&quot; data-ratio=&quot;1.0857487922705313&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/t8lpVibticjQ6h6x4EnYInRLic6PibFNWw4zSv28rAxcJu9dumVJF03PwHGOWxOzeJKIsydVa7UJuTo4jOjrct9NZw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;828&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 加入码农周刊VIP会员知识星球后，客服会联系您，请留意知识星球内的私信。&lt;br/&gt;3. 客服向您发送码农周刊VIP会员欢迎邮件，开启您的码农周刊VIP会员之旅。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;心动不如心动，赶快订阅吧！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>796d9392b2ae1d4250f31d460e843428</guid>
<title>Android 性能优化：从卡顿和 ANR 来彻底理解内存泄露原理和优化</title>
<link>https://toutiao.io/k/dje4uo8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;JAVA程序，因为有垃圾回收机制，应该没有内存泄露。我们已经知道了，如果某个对象，从根节点可到达，也就是存在从根节点到该对象的引用链，那么该对象是不会被 GC 回收的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果说这个对象已经不会再被使用到了，是无用的，我们依然持有他的引用的话，就会造成内存泄漏，例如 一个长期在后台运行的线程持有 Activity 的引用，这个时 候 Activity 执行了 onDestroy 方法，那么这个 Activity 就是从根节点可到达并且无用的对象， 这个 Activity 对象就是泄漏的对象，给这个对象分配的内存将无法被回收。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果我们的java运行很久,而这种内存泄露不断的发生，最后就没内存可用了。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;当然java的，内存泄漏和C/C++是不一样的。如果java程序完全结束后，它所有的对象就都不可达了，系统就可以对他们进行垃圾回收，它的内存泄露仅仅限于它本身，而不会影响整个系统的。C/C++的内存泄露就比较糟糕了，它的内存泄露是系统级，即使该C/C++程序退出，它的泄露的内存也无法被系统回收，永远不可用了，除非重启机器。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;我们这篇文章就开始对Android内存泄露进行总结；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一、Android内存泄露介绍&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、什么是内存泄露？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;内存泄漏（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;内存泄漏缺陷具有隐蔽性、积累性的特征，比其他内存非法访问错误更难检测。因为内存泄漏的产生原因是内存块未被释放，属于遗漏型缺陷而不是过错型缺陷。此外，内存泄漏通常不会直接产生可观察的错误症状，而是逐渐积累，降低系统整体性能，极端的情况下可能使系统崩溃；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Android的一个应用程序的内存泄露对别的应用程序影响不大。为了能够使得Android应用程序安全且快速的运行，Android的每个应用程序都会使用一个专有的Dalvik虚拟机实例来运行，它是由Zygote服务进程孵化出来的，也就是说每个应用程序都是在属于自己的进程中运行的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Android为不同类型的进程分配了不同的内存使用上限，如果程序在运行过程中出现了内存泄漏的而造成应用进程使用的内存超过了这个上限，则会被系统视为内存泄漏，从而被kill掉，这使得仅仅自己的进程被kill掉，而不会影响其他进程（如果是system_process等系统进程出问题的话，则会引起系统重启）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、内存泄露的危害&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;用户对单次的内存泄漏并没有什么感知，但是当泄漏积累到内存都被消耗完，就会导致卡顿，甚至崩溃；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;gc回收频繁 造成应用卡顿ANR：&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;当内存不足的时候,gc会主动回收没用的内存.但是,内存回收也是需要时间的.&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;内存回收和gc回收垃圾资源之间高频率交替的执行.就会产生内存抖动.&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;很多数据就会污染内存堆，马上就会有许多GCs启动，由于这一额外的内存压力，也会产生突然增加的运算造成卡顿现象，&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;任何线程的任何操作都会需要暂停，等待GC操作完成之后，其他操作才能够继续运行,所以垃圾回收运行的次数越少，对性能的影响就越少；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3、内存泄漏的原因&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;①内存空间使用完毕后没有被回收，就会导致内存泄漏。虽然Java有垃圾回收机制，但是Java中任然存在很多造成内存泄漏的代码逻辑，垃圾回收器会回收掉大部分的内存空间，&lt;/span&gt;&lt;span&gt;但是有一些内存空间还保持着引用，但是在逻辑上已经不会再用到的对象，这时候垃圾回收器就很无能为力，不能回收它们，比如：&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;span&gt;②Android（Java）平台的内存泄漏是指没用的对象资源与GC Roots之间保持可达路径，导致系统无法进行回收；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.6013363028953229&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kyDL16ViavhFpiafRZPpfGqjDkYQ2VCRjHERrPNDHicPnxUE1bRYYxhXjYtPPKmP4G4jxqZTGNhFzMej1ae3fhUFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;898&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.6347826086956522&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kyDL16ViavhFpiafRZPpfGqjDkYQ2VCRjHemMMOXfuCV5rdibtvdwlpLahicOw0bSLtwZhkgaasGQGAQRVofkPibZ1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;920&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;③那么从栈中弹出的对象将不会被当作垃圾回收，即使程序不再使用栈中的这些队象，他们也不会回收，因为栈中仍然保存这对象的引用，俗称过期引用，这个内存泄露很隐蔽；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二、检测内存泄露检测工具 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;①Memory Monitor&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.6206415620641562&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kyDL16ViavhFpiafRZPpfGqjDkYQ2VCRjHkWlmsFsFcouu0Xiak74tVmaNapDoE6n9prqQO4YdP6tW2Vug70YPTGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;717&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;位于 Android Monitor 中，该工具可以：&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;方便的显示内存使用和 GC 情况&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;快速定位卡顿是否和 GC 有关&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;快速定位 Crash 是否和内存占用过高有关&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;快速定位潜在的内存泄露问题（内存占用一直在增长）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;但是不能准确的定位问题&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;②Allocation Tracker&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该工具用途：&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;可以定位代码中分配的对象类型、大小、时间、线程、堆栈等信息&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;可以定位内存抖动问题&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;配合 Heap Viewer 定位内存泄露问题（可以找出来泄露的对象是在哪创建的等等）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;使用方法：在 Memory Monitor 中有个 Start Allocation Tracking 按钮即可开始跟踪 在点击停止跟踪后会显示统计结果。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;③Heap Viewer&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该工具用于：&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;④LeakCanary&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;dependencies {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  debugImplementation &#x27;com.squareup.leakcanary:leakcanary-android:1.6.3&#x27;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  releaseImplementation &#x27;com.squareup.leakcanary:leakcanary-android-no-op:1.6.3&#x27;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  // Optional, if you use support library fragments:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  debugImplementation &#x27;com.squareup.leakcanary:leakcanary-support-fragment:1.6.3&#x27;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;直接在Application中使用，然后运行APP就会自动检测，检测到会在另一个APP上通知，显示详情&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public class ExampleApplication extends Application {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  @Override public void onCreate() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    super.onCreate();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if (LeakCanary.isInAnalyzerProcess(this)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      // This process is dedicated to LeakCanary for heap analysis.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      // You should not init your app in this process.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      return;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    LeakCanary.install(this);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // Normal app init code...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;三、常见的内存泄露场景详解&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.单例导致内存泄露&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;单例模式在Android开发中会经常用到，但是如果使用不当就会导致内存泄露。因为单例的静态特性使得它的生命周期同应用的生命周期一样长，如果一个对象已经没有用处了，但是单例还持有它的引用，那么在整个应用程序的生命周期它都不能正常被回收，从而导致内存泄露。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public class AppSettings {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    private static volatile AppSettings singleton;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    private Context mContext;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    private AppSettings(Context context) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        this.mContext = context;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    public static AppSettings getInstance(Context context) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        if (singleton == null) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            synchronized (AppSettings.class) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                if (singleton == null) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    singleton = new AppSettings(context);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        return singleton;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;像上面代码中这样的单例，如果我们在调用getInstance(Context context)方法的时候传入的context参数是Activity、Service等上下文，就会导致内存泄露。以Activity为例，当我们启动一个Activity，并调用getInstance(Context context)方法去获取AppSettings的单例，传入Activity.this作为context，这样AppSettings类的单例sInstance就持有了Activity的引用，当我们退出Activity时，该Activity就没有用了，但是因为sIntance作为静态单例（在应用程序的整个生命周期中存在）会继续持有这个Activity的引用，导致这个Activity对象无法被回收释放，这就造成了内存泄露。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了避免这样单例导致内存泄露，我们可以将context参数改为全局的上下文：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;private AppSettings(Context context) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        this.mContext = context.getApplicationContext();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.静态变量导致内存泄漏&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;静态变量存储在方法区，它的生命周期从类加载开始，到整个进程结束。一旦静态变量初始化后，它所持有的引用只有等到进程结束才会释放。比如下面这样的情况，在Activity中为了避免重复的创建info，将sInfo作为静态变量：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public class MainActivity2 extends AppCompatActivity {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    public static Info sInfo;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    @Override&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    protected void onCreate(Bundle savedInstanceState) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        super.onCreate(savedInstanceState);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        sInfo = new Info(this);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    class Info {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        private Context mContext;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        public Info(Context context) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            this.mContext = context;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Info作为Activity的静态成员，并且持有Activity的引用，但是sInfo作为静态变量，生命周期肯定比Activity长。所以当Activity退出后，sInfo仍然引用了Activity，Activity不能被回收，这就导致了内存泄露。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在Android开发中，静态持有很多时候都有可能因为其使用的生命周期不一致而导致内存泄露，所以我们在新建静态持有的变量的时候需要多考虑一下各个成员之间的引用关系，并且尽量少地使用静态持有的变量，以避免发生内存泄露。当然，我们也可以在适当的时候讲静态量重置为null，使其不再持有引用，这样也可以避免内存泄露。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.非静态内部类导致内存泄露&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;非静态内部类（包括匿名内部类）默认就会持有外部类的引用，当非静态内部类对象的生命周期比外部类对象的生命周期长时，就会导致内存泄露。非静态内部类导致的内存泄露在Android开发中有一种典型的场景就是使用Handler，很多开发者在使用Handler是这样写的：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public class MainActivity2 extends AppCompatActivity {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    @Override&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    protected void onCreate(Bundle savedInstanceState) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        super.onCreate(savedInstanceState);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        start();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    private void start() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Message message = Message.obtain();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        message.what = 1;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        mHandler.sendMessage(message);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    private Handler mHandler = new Handler() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        @Override&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        public void handleMessage(Message msg) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            super.handleMessage(msg);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            if (msg.what == 1) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                //doNothing&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    };&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;也许有人会说，mHandler并未作为静态变量持有Activity引用，生命周期可能不会比Activity长，应该不一定会导致内存泄露呢，显然不是这样的！熟悉Handler消息机制的都知道，mHandler会作为成员变量保存在发送的消息msg中，即msg持有mHandler的引用，而mHandler是Activity的非静态内部类实例，即mHandler持有Activity的引用，那么我们就可以理解为msg间接持有Activity的引用。msg被发送后先放到消息队列MessageQueue中，然后等待Looper的轮询处理（MessageQueue和Looper都是与线程相关联的，MessageQueue是Looper引用的成员变量，而Looper是保存在ThreadLocal中的）。那么当Activity退出后，msg可能仍然存在于消息对列MessageQueue中未处理或者正在处理，那么这样就会导致Activity无法被回收，以致发生Activity的内存泄露。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通常在Android开发中如果要使用内部类，但又要规避内存泄露，一般都会采用静态内部类+弱引用的方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;MyHandler mHandler;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public static class MyHandler extends Handler {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        private WeakReference&amp;lt;Activity&amp;gt; mActivityWeakReference;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        public MyHandler(Activity activity) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            mActivityWeakReference = new WeakReference&amp;lt;&amp;gt;(activity);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        @Override&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        public void handleMessage(Message msg) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            super.handleMessage(msg);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;mHandler通过弱引用的方式持有Activity，当GC执行垃圾回收时，遇到Activity就会回收并释放所占据的内存单元。这样就不会发生内存泄露了。上面的做法确实避免了Activity导致的内存泄露，发送的msg不再已经没有持有Activity的引用了，但是msg还是有可能存在消息队列MessageQueue中，所以更好的是在Activity销毁时就将mHandler的回调和发送的消息给移除掉。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; @Override&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    protected void onDestroy() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        super.onDestroy();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        mHandler.removeCallbacksAndMessages(null);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;非静态内部类造成内存泄露还有一种情况就是使用Thread或者AsyncTask。要避免内存泄露的话还是需要像上面Handler一样使用静态内部类+弱应用的方式（代码就不列了，参考上面Hanlder的正确写法）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.未取消注册或回调导致内存泄露&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如我们在Activity中注册广播，如果在Activity销毁后不取消注册，那么这个刚播会一直存在系统中，同上面所说的非静态内部类一样持有Activity引用，导致内存泄露。因此注册广播后在Activity销毁后一定要取消注册。在注册观察则模式的时候，如果不及时取消也会造成内存泄露。比如使用Retrofit+RxJava注册网络请求的观察者回调，同样作为匿名内部类持有外部引用，所以需要记得在不用或者销毁的时候取消注册。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;5.Timer和TimerTask导致内存泄露&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Timer和TimerTask在Android中通常会被用来做一些计时或循环任务，比如实现无限轮播的ViewPager：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;private void stopTimer(){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        if(mTimer!=null){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            mTimer.cancel();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            mTimer.purge();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            mTimer = null;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        if(mTimerTask!=null){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            mTimerTask.cancel();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            mTimerTask = null;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    @Override&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    protected void onDestroy() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        super.onDestroy();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        stopTimer();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当我们Activity销毁的时，有可能Timer还在继续等待执行TimerTask，它持有Activity的引用不能被回收，因此当我们Activity销毁的时候要立即cancel掉Timer和TimerTask，以避免发生内存泄漏。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;6.集合中的对象未清理造成内存泄露&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个比较好理解，如果一个对象放入到ArrayList、HashMap等集合中，这个集合就会持有该对象的引用。当我们不再需要这个对象时，也并没有将它从集合中移除，这样只要集合还在使用（而此对象已经无用了），这个对象就造成了内存泄露。并且如果集合被静态引用的话，集合里面那些没有用的对象更会造成内存泄露了。所以在使用集合时要及时将不用的对象从集合remove，或者clear集合，以避免内存泄漏。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;7.资源未关闭或释放导致内存泄露&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在使用IO、File流或者Sqlite、Cursor等资源时要及时关闭。这些资源在进行读写操作时通常都使用了缓冲，如果不及时关闭，这些缓冲对象就会一直被占用而得不到释放，以致发生内存泄露。因此我们在不需要使用它们的时候就及时关闭，以便缓冲能及时得到释放，从而避免内存泄露。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;8.属性动画造成内存泄露&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;动画同样是一个耗时任务，比如在Activity中启动了属性动画（ObjectAnimator），但是在销毁的时候，没有调用cancle方法，虽然我们看不到动画了，但是这个动画依然会不断地播放下去，动画引用所在的控件，所在的控件引用Activity，这就造成Activity无法正常释放。因此同样要在Activity销毁的时候cancel掉属性动画，避免发生内存泄漏。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;9.WebView造成内存泄露&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于WebView的内存泄露，因为WebView在加载网页后会长期占用内存而不能被释放，因此我们在Activity销毁后要调用它的destory()方法来销毁它以释放内存。另外在查阅WebView内存泄露相关资料时看到这种情况：Webview下面的Callback持有Activity引用，造成Webview内存无法释放，即使是调用了Webview.destory()等方法都无法解决问题（Android5.1之后）。最终的解决方案是：在销毁WebView之前需要先将WebView从父容器中移除，然后再销毁WebView。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对于生命周期比Activity长的对象（单例），要避免直接引用Activity的context，可以考虑使用ApplicationContext，静态变量不使用时及时置空；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Handler持有的引用最好使用弱引用，在Activity被释放的时候要记得清空Message，取消Handler对象的Runnable；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;非静态内部类、非静态匿名内部类会自动持有外部类的引用，为避免内存泄露，可以考虑把内部类声明为静态的；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;广播接收器、EventBus等的使用过程中，注册/反注册应该成对使用，但凡有注册的都应该有反注册；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;不再使用的资源对象Cursor、File、Bitmap等要记住正确关闭；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;集合里面的东西有加入就应该对应有相应的删除。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;属性动画及时取消，注意webview内存泄漏问题&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9d20855e5fbef7471f442b076b6b1efe</guid>
<title>[译] [论文] XDP：在操作系统内核中实现快速、可编程包处理 (ACM, 2018)</title>
<link>https://toutiao.io/k/2tzrm4e</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post&quot;&gt;
  
  &lt;h1 class=&quot;postTitle&quot;&gt;[译] [论文] XDP (eXpress Data Path)：在操作系统内核中实现快速、可编程包处理（ACM，2018）&lt;/h1&gt;
  &lt;p class=&quot;meta&quot;&gt;Published at 2021-08-01 | Last Update 2021-08-01&lt;/p&gt;

  
  
  &lt;h3 id=&quot;译者序&quot;&gt;译者序&lt;/h3&gt;

&lt;p&gt;本文翻译自 2018 年 ACM &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoNEXT&lt;/code&gt; 大会上的一篇文章：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;&quot;&gt;The eXpress Data Path: Fast Programmable Packet Processing in the Operating System Kernel&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;作者阵容豪华，包括来自 Cilium 的 Daniel Borkmann、John Fastabend 等。&lt;/p&gt;

&lt;p&gt;论文引用信息：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Toke Høiland-Jørgensen, Jesper Dangaard Brouer, Daniel Borkmann, John
Fastabend, Tom Herbert, David Ahern, and David Miller. 2018. The eXpress
Data Path: Fast Programmable Packet Processing in the Operating System
Kernel. In CoNEXT ’18: International Conference on emerging Networking
EXperiments and Technologies, December 4–7, 2018, Heraklion, Greece. ACM,
New York, NY, USA, 13 pages. https://doi.org/10.1145/3281411.3281443&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;由于译者水平有限，本文不免存在遗漏或错误之处。如有疑问，请查阅原文。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;以下是译文。&lt;/p&gt;

&lt;hr/&gt;



&lt;hr/&gt;

&lt;h1 id=&quot;摘要&quot;&gt;摘要&lt;/h1&gt;

&lt;p&gt;近些年业界流行通过&lt;strong&gt;&lt;mark&gt;内核旁路&lt;/mark&gt;&lt;/strong&gt;（kernel bypass）的方式实现
&lt;strong&gt;&lt;mark&gt;可编程的包处理过程&lt;/mark&gt;&lt;/strong&gt;（programmable packet processing）。实现方式是
将网络硬件完全交由某个专门的&lt;strong&gt;&lt;mark&gt;用户空间应用&lt;/mark&gt;&lt;/strong&gt;（userspace application）
接管，从而避免&lt;strong&gt;&lt;mark&gt;内核和用户态上下文切换&lt;/mark&gt;&lt;/strong&gt;的昂贵性能开销。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;内核收包时，&lt;strong&gt;&lt;mark&gt;硬中断（Interrupt）和软中断（SoftIRQ）&lt;/mark&gt;&lt;/strong&gt;相关的逻辑，见：
&lt;a href=&quot;/blog/tuning-stack-rx-zh/&quot;&gt;(译) Linux 网络栈监控和调优：接收数据（2016）&lt;/a&gt;。
译注。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;但是，操作系统被旁路（绕过）之后，它的&lt;strong&gt;&lt;mark&gt;应用隔离（application isolation）
和安全机制（security mechanisms）&lt;/mark&gt;&lt;/strong&gt;就都失效了；一起失效的还有各种经过已经
充分测试的&lt;strong&gt;&lt;mark&gt;配置、部署和管理工具&lt;/mark&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;为解决这个问题，我们提出一种&lt;strong&gt;&lt;mark&gt;新的可编程包处理方式&lt;/mark&gt;&lt;/strong&gt;：eXpress Data Path (XDP)。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;XDP 提供了一个&lt;strong&gt;&lt;mark&gt;仍然基于操作系统内核&lt;/mark&gt;&lt;/strong&gt;的安全执行环境，在&lt;strong&gt;&lt;mark&gt;设备驱动上下文&lt;/mark&gt;&lt;/strong&gt;
（device driver context）中执行，可用于定制各种包处理应用。&lt;/li&gt;
  &lt;li&gt;XDP 是&lt;strong&gt;&lt;mark&gt;主线内核（mainline Linux kernel）的一部分&lt;/mark&gt;&lt;/strong&gt;，与现有的内核
网络栈（kernel’s networking stack）完全兼容，二者协同工作。&lt;/li&gt;
  &lt;li&gt;XDP 应用（application）通过 C 等高层语言编写，然后编译成特定字节码；出于安
全考虑，内核会首先对这些字节码执行静态分析，然后再将它们翻译成
&lt;strong&gt;&lt;mark&gt;处理器原生指令&lt;/mark&gt;&lt;/strong&gt;（native instructions）。&lt;/li&gt;
  &lt;li&gt;测试结果显示，XDP 能达到 &lt;strong&gt;&lt;mark&gt;24Mpps/core&lt;/mark&gt;&lt;/strong&gt; 的处理性能。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为展示 XDP 灵活的编程模型，本文还将给出&lt;strong&gt;&lt;mark&gt;三个程序示例&lt;/mark&gt;&lt;/strong&gt;，&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;layer-3 routing（&lt;strong&gt;&lt;mark&gt;三层路由转发&lt;/mark&gt;&lt;/strong&gt;）&lt;/li&gt;
  &lt;li&gt;inline DDoS protection（&lt;strong&gt;&lt;mark&gt;DDoS 防护&lt;/mark&gt;&lt;/strong&gt;）&lt;/li&gt;
  &lt;li&gt;layer-4 load balancing（&lt;strong&gt;&lt;mark&gt;四层负载均衡&lt;/mark&gt;&lt;/strong&gt;）&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;1-引言&quot;&gt;1 引言&lt;/h1&gt;

&lt;p&gt;软件实现高性能包处理的场景，对每个包的处理耗时有着极高的要求。通用目的操作系统中
的网络栈&lt;strong&gt;&lt;mark&gt;更多是针对灵活性的优化&lt;/mark&gt;&lt;/strong&gt;，这意味着它们&lt;strong&gt;&lt;mark&gt;花在每个包上
的指令太多了&lt;/mark&gt;&lt;/strong&gt;，不适合网络高吞吐的场景。&lt;/p&gt;

&lt;p&gt;因此，随后出现了一些专门用于包处理的软件开发工具，例如 Data Plane Development
Kit (DPDK) [16]。这些工具一般都会&lt;strong&gt;&lt;mark&gt;完全绕过内核&lt;/mark&gt;&lt;/strong&gt;，将网络硬件直接交
给用户态的网络应用，并&lt;strong&gt;&lt;mark&gt;需要独占一个或多个 CPU&lt;/mark&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;11-现有方案kernel-bypass存在的问题&quot;&gt;1.1 现有方案（kernel bypass）存在的问题&lt;/h2&gt;

&lt;p&gt;内核旁路方式可以显著提升性能，但缺点也很明显：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;mark&gt;很难与现有系统集成&lt;/mark&gt;&lt;/strong&gt;；&lt;/li&gt;
  &lt;li&gt;上层应用必须要将内核中已经&lt;strong&gt;&lt;mark&gt;非常成熟的模块在用户态重新实现一遍&lt;/mark&gt;&lt;/strong&gt;，例如路由表、高层协议栈等；&lt;/li&gt;
  &lt;li&gt;最坏的情况下，这种包处理应用只能工作在一个完全隔绝的环境，因为内核提供的&lt;strong&gt;&lt;mark&gt;常见工具和部署方式在这种情况下都不可用了&lt;/mark&gt;&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;导致系统越来越复杂，而且&lt;strong&gt;&lt;mark&gt;破坏了操作系统内核在把控的安全边界&lt;/mark&gt;&lt;/strong&gt;。
在基础设施逐渐迁移到 Kubernetes/Docker 等&lt;strong&gt;&lt;mark&gt;容器环境的背景下，这一点显得尤其严重&lt;/mark&gt;&lt;/strong&gt;，
因为在这种场景下，&lt;strong&gt;&lt;mark&gt;内核担负着资源抽象和隔离的重任&lt;/mark&gt;&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;12-新方案给内核网络栈添加可编程能力&quot;&gt;1.2 新方案：给内核网络栈添加可编程能力&lt;/h2&gt;

&lt;p&gt;对此，本文提供了另一种解决方案：给内核网络栈添加可编程能力。这使得我们能在
&lt;strong&gt;&lt;mark&gt;兼容各种现有系统、复用已有网络基础设施&lt;/mark&gt;&lt;/strong&gt;的前提下，仍然实现高速包处理。
这个框架称为 XDP，&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;XDP 定义了一个&lt;strong&gt;&lt;mark&gt;受限的执行环境&lt;/mark&gt;&lt;/strong&gt;（a limited execution environment），运行在一个
&lt;strong&gt;&lt;mark&gt;eBPF 指令虚拟机&lt;/mark&gt;&lt;/strong&gt;中。eBPF 是 BSD Packet Filter (BPF) [37] 的扩展。&lt;/li&gt;
  &lt;li&gt;XDP 程序运行在&lt;strong&gt;&lt;mark&gt;内核上下文中&lt;/mark&gt;&lt;/strong&gt;，此时&lt;strong&gt;&lt;mark&gt;内核自身都还没有接触到包数据&lt;/mark&gt;&lt;/strong&gt;（
before the kernel itself touches the packet data），这使得我们能在网卡收到包后
&lt;strong&gt;&lt;mark&gt;最早能处理包的位置&lt;/mark&gt;&lt;/strong&gt;，做一些自定义数据包处理（包括重定向）。&lt;/li&gt;
  &lt;li&gt;内核在&lt;strong&gt;&lt;mark&gt;加载（load）时执行静态校验&lt;/mark&gt;&lt;/strong&gt;，以确保用户提供的 XDP 程序的安全。&lt;/li&gt;
  &lt;li&gt;之后，程序会被&lt;strong&gt;&lt;mark&gt;动态编译成原生机器指令&lt;/mark&gt;&lt;/strong&gt;（native machine instructions），以获得高性能。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;XDP 已经在过去的几个内核 release 中逐渐合并到内核，但在本文之前，还没有关于 XDP 系统的
完整架构介绍。本文将对 XDP 做一个高层介绍。&lt;/p&gt;

&lt;h2 id=&quot;13-新方案xdp的优点&quot;&gt;1.3 新方案（XDP）的优点&lt;/h2&gt;

&lt;p&gt;我们的测试结果显示 XDP 能取得 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;24Mpps/core&lt;/code&gt; 的处理性能，这虽然与 DPDK 还有差距，
但相比于后者这种 kernel bypass 的方式，XDP 有非常多的优势。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;本文是 2018 年的测试结果，更新的一些性能（及场景）对比可参考
&lt;a href=&quot;/blog/advanced-bpf-kernel-features-for-container-age-zh/&quot;&gt;(译) 为容器时代设计的高级 eBPF 内核特性（FOSDEM, 2021）&lt;/a&gt;。
译注。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;具体地，XDP：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;与内核网络栈协同工作，&lt;strong&gt;&lt;mark&gt;将硬件的控制权完全留在内核范围内&lt;/mark&gt;&lt;/strong&gt;。带来的好处：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;&lt;mark&gt;保持了内核的安全边界&lt;/mark&gt;&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;无需对网络配置或管理工具做任何修改&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;mark&gt;无需任何特殊硬件特性&lt;/mark&gt;&lt;/strong&gt;，任何有 Linux 驱动的网卡都可以支持，
现有的驱动只需做一些修改，就能支持 XDP hooks。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;可以选择性地&lt;strong&gt;&lt;mark&gt;复用内核网络栈&lt;/mark&gt;&lt;/strong&gt;中的现有功能，例如路由表或 TCP/IP
协议栈，在保持配置接口不变的前提下，加速关键性能路径（critical performance paths）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;保证 eBPF 指令集和 XDP 相关的编程接口（API）的稳定性。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;与常规 socket 层交互时，&lt;strong&gt;&lt;mark&gt;没有从用户态将包重新注入内核的昂贵开销&lt;/mark&gt;&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;mark&gt;对应用透明&lt;/mark&gt;&lt;/strong&gt;。这创造了一些新的部署场景/方式，例如直接在应用所
在的服务器上部署 DoS 防御（而非中心式/网关式 DoS 防御）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;mark&gt;服务不中断的前提下动态重新编程&lt;/mark&gt;&lt;/strong&gt;（dynamically re-program），
  这意味着可以按需加入或移除功能，而不会引起任何流量中断，也能动态响应系统其他部分的的变化。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;mark&gt;无需预留专门的 CPU 做包处理&lt;/mark&gt;&lt;/strong&gt;，这意味着 CPU 功耗与流量高低直接相关，更节能。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;14-本文组织结构&quot;&gt;1.4 本文组织结构&lt;/h2&gt;

&lt;p&gt;接下来的内容介绍 XDP 的设计，并做一些性能分析。结构组织如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Section 2 介绍相关工作；&lt;/li&gt;
  &lt;li&gt;Section 3 介绍 XDP 系统的设计；&lt;/li&gt;
  &lt;li&gt;Section 4 做一些性能分析；&lt;/li&gt;
  &lt;li&gt;Section 5 提供了几个真实 XDP 场景的程序例子；&lt;/li&gt;
  &lt;li&gt;Section 6 讨论 XDP 的未来发展方向；&lt;/li&gt;
  &lt;li&gt;Section 7 总结。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;2-相关工作&quot;&gt;2 相关工作&lt;/h1&gt;

&lt;p&gt;XDP 当然不是第一个支持可编程包处理的系统 —— 这一领域在过去几年发展势头良好，
并且趋势还在持续。业内已经有了几种可编程包处理框架，以及基于这些框架的新型应用，包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;mark&gt;单一功能的应用&lt;/mark&gt;&lt;/strong&gt;，如 switching [47], routing [19], named-based forwarding [28], classification [48], caching [33] or traffic generation [14]。&lt;/li&gt;
  &lt;li&gt;更加&lt;strong&gt;&lt;mark&gt;通用、且高度可定制的包处理解决方案&lt;/mark&gt;&lt;/strong&gt;，能够处理从多种源收来的数据包 [12, 20, 31, 34, 40, 44]。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;要基于通用（Common Off The Shelf，COTS）硬件实现高性能包处理，就必须解决
&lt;strong&gt;&lt;mark&gt;网卡（NIC）和包处理程序之间&lt;/mark&gt;&lt;/strong&gt;的所有瓶颈。由于&lt;strong&gt;&lt;mark&gt;性能瓶颈主要来源于内核和用户态应用之
间的接口&lt;/mark&gt;&lt;/strong&gt;（系统调用开销非常大，另外，内核功能丰富，但也非常复杂），
低层（low-level）框架必须通过这样或那样的方式来降低这些开销。&lt;/p&gt;

&lt;p&gt;现有的一些框架通过几种不同的方式实现了高性能，XDP 构建在其中一些技术之上。
接下来对 XDP 和它们的异同做一些比较分析。&lt;/p&gt;

&lt;h2 id=&quot;21-用户态轮询-vs-xdp&quot;&gt;2.1 用户态轮询 vs. XDP&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;DPDK [16] 可能是使用最广泛的高性能包处理框架。它最初只支持 Intel 网卡，后来逐
步扩展到其他厂商的网卡。DPDK 也称作内核旁路框架（kernel bypass framework），
因为它将网络硬件的控制权从内核转移到了用户态的网络应用，完全避免了内核-用户态
之间的切换开销。&lt;/li&gt;
  &lt;li&gt;与 DPDK 类似的还有 PF_RING ZC module [45] 和 hardware-specific Solarflare OpenOnload [24]。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在现有的所有框架中，&lt;strong&gt;&lt;mark&gt;内核旁路方式性能是最高的&lt;/mark&gt;&lt;/strong&gt; [18]；但如引言中指
出，这种方式&lt;strong&gt;&lt;mark&gt;在管理、维护和安全方面都存在不足&lt;/mark&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;XDP 采用了一种与内核旁路截然相反的方式：相比于将网络硬件的控制权上移到用户空间，
XDP 将&lt;strong&gt;&lt;mark&gt;性能攸关的包处理操作直接放在内核中，在操作系统的网络栈之前执行&lt;/mark&gt;&lt;/strong&gt;。&lt;/p&gt;



&lt;h2 id=&quot;22-内核模块-vs-xdp&quot;&gt;2.2 内核模块 vs. XDP&lt;/h2&gt;

&lt;p&gt;在 XDP 之前，以内核模块（kernel module）方式实现包处理功能&lt;strong&gt;&lt;mark&gt;代价非常高&lt;/mark&gt;&lt;/strong&gt;，
因为程序执行出错时可能会导致整个系统崩溃，而且内核的内部 API 也会随着时间发生变化。
因此也就不难理解为什么只有很少的系统采用了这种方式。其中做的比较好包括&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;mark&gt;虚拟交换机&lt;/mark&gt;&lt;/strong&gt; Open vSwitch [44]&lt;/li&gt;
  &lt;li&gt;Click [40]&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;mark&gt;虚拟机路由器&lt;/mark&gt;&lt;/strong&gt; Contrail [41]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这几个系统都支持灵活的配置，适用于多种场景，取得比较小的平摊代价。&lt;/p&gt;

&lt;p&gt;XDP 通过：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;提供一个安全的执行环境，以及内核社区支持，提供与那些暴露到用户空间一样稳定的内核 API&lt;/p&gt;

    &lt;p&gt;极大地降低了那些&lt;strong&gt;&lt;mark&gt;将处理过程下沉到内核的应用&lt;/mark&gt;&lt;/strong&gt;（applications of moving processing into the kernel）的成本。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;此外，XDP 程序&lt;strong&gt;&lt;mark&gt;也能够完全绕过内核网络栈&lt;/mark&gt;&lt;/strong&gt;（completely bypass），
  与在内核网络栈中做 hook 的传统内核模块相比，性能也更高。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;XDP 除了能将处理过程下沉到内核以获得最高性能之外，还支持&lt;strong&gt;&lt;mark&gt;在程序中执行重定向&lt;/mark&gt;&lt;/strong&gt;
 （redirection）操作，完全绕过内核网络栈，将包送到特殊类型的用户空间 socket；
 甚至能工作在 zero-copy 模式，进一步降低开销。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;这种模式与 Netmap [46] 和 PF_RING [11] 方式类似，但后者是在没有完全绕过内
核的情况下，通过降低从网络设备到用户态应用（network device to userspace
application）之间的传输开销，实现高性能包处理。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;内核模块方式的另一个例子是 Packet I/O engine，这是 PacketShader [19] 的组成部分，
后者专用于 Arrakis [43] and ClickOS [36] 之类的特殊目的操作系统。&lt;/p&gt;

&lt;h2 id=&quot;23-可编程硬件-vs-xdp&quot;&gt;2.3 可编程硬件 vs. XDP&lt;/h2&gt;

&lt;p&gt;可编程硬件设备也是一种实现高性能包处理的方式。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一个例子是 NetFPGA [32]，通过对它暴露的 API 进行编程，能够在这种基于 FPGA 的专
用设备上运行任何包处理任务。&lt;/li&gt;
  &lt;li&gt;P4 编程语言 [7] 致力于&lt;strong&gt;&lt;mark&gt;将这种可编程能力扩展到更广泛的包处理硬件上&lt;/mark&gt;&lt;/strong&gt;
（巧合的是，它还包括了一个 XDP backend [51]）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;某种意义上来说，&lt;strong&gt;&lt;mark&gt;XDP 可以认为是一种 offload 方式&lt;/mark&gt;&lt;/strong&gt;：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;性能敏感的处理逻辑下放到网卡驱动中，以提升性能；&lt;/li&gt;
  &lt;li&gt;其他的处理逻辑仍然走内核网络栈；&lt;/li&gt;
  &lt;li&gt;如果没有用到内核 helper 函数，那整个 XDP 程序都可以 offload 到网卡（目前
Netronome smart-NICs [27] 已经支持）。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;24-小结&quot;&gt;2.4 小结&lt;/h2&gt;

&lt;p&gt;XDP 提供了一种高性能包处理方式，与已有方式相比，在性能、与现有系统的集成、灵活性
等方面取得了更好的平衡。&lt;/p&gt;

&lt;p&gt;接下来介绍 XDP 是如何取得这种平衡的。&lt;/p&gt;

&lt;h1 id=&quot;3-xdp-设计&quot;&gt;3 XDP 设计&lt;/h1&gt;

&lt;p&gt;XDP 的设计理念：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;高性能包处理，&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;mark&gt;集成到操作系统内核（kernel）并与之协同工作&lt;/mark&gt;&lt;/strong&gt;，同时，&lt;/li&gt;
  &lt;li&gt;确保系统其它部分的&lt;strong&gt;&lt;mark&gt;安全性（safety）和完整性（integrity）&lt;/mark&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这种与内核的深度集成显然会&lt;strong&gt;&lt;mark&gt;给设计带来一些限制&lt;/mark&gt;&lt;/strong&gt;，在 XDP 组件合并到
Linux 的过程中，我们也收到了许多来自社区的反馈，促使我们不断调整 XDP 的设计，但
这些设计反思不在本文讨论范围之内。&lt;/p&gt;

&lt;h2 id=&quot;30-xdp-系统架构&quot;&gt;3.0 XDP 系统架构&lt;/h2&gt;

&lt;p&gt;图 1 描绘了整个 XDP 系统，四个主要组成部分：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;&lt;mark&gt;XDP driver hook&lt;/mark&gt;&lt;/strong&gt;：XDP 程序的主入口，在网卡收到包执行。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;mark&gt;eBPF virtual machine&lt;/mark&gt;&lt;/strong&gt;：执行 XDP 程序的字节码，以及对字节码执行 JIT 以提升性能。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;mark&gt;BPF maps&lt;/mark&gt;&lt;/strong&gt;：内核中的 key/value 存储，作为图中各系统的主要通信通道。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;mark&gt;eBPF verifier&lt;/mark&gt;&lt;/strong&gt;：加载程序时对其执行静态验证，以确保它们不会导致内核崩溃。&lt;/li&gt;
&lt;/ol&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/xdp-paper-2018/1.png&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;Fig 1. XDP 与 Linux 网络栈的集成。这里只画了 ingress 路径，以免图过于复杂。&lt;/p&gt;

&lt;p&gt;上图是 ingress 流程。网卡收到包之后，&lt;strong&gt;&lt;mark&gt;在处理包数据（packet data）之前，会先执行 main XDP hook 中的 eBPF 程序&lt;/mark&gt;&lt;/strong&gt;。
这段程序可以选择：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;&lt;mark&gt;丢弃（drop）&lt;/mark&gt;&lt;/strong&gt;这个包；或者&lt;/li&gt;
  &lt;li&gt;通过当前网卡将包再&lt;strong&gt;&lt;mark&gt;发送（send）&lt;/mark&gt;&lt;/strong&gt;出去；或者&lt;/li&gt;
  &lt;li&gt;将包&lt;strong&gt;&lt;mark&gt;重定向（redirect）&lt;/mark&gt;&lt;/strong&gt;到其他网络接口（包括虚拟机的虚拟网卡），或者通过 AF_XDP socket 重定向到用户空间；或者&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;mark&gt;放行（allow）&lt;/mark&gt;&lt;/strong&gt;这个包，如果后面没有其他原因导致的 drop，这个包就会进入常规的内核网络栈。&lt;/p&gt;

    &lt;p&gt;如果是这种情况，也就是放行包进入内核网络栈，那接下来在将包放到发送队列之前（before packets are queued for transmission），
 还有一个能执行 BPF 程序的地方：&lt;strong&gt;&lt;mark&gt;TC BPF hook&lt;/mark&gt;&lt;/strong&gt;。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;更多信息，可参考
&lt;a href=&quot;/blog/on-getting-tc-classifier-fully-programmable-zh/&quot;&gt;(译) [论文] 迈向完全可编程 tc 分类器（cls_bpf）（NetdevConf，2016）&lt;/a&gt;。
译注。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;此外，图 1 中还可以看出，不同的 eBPF 程序之间、eBPF 程序和用户空间应用之间，都能够&lt;strong&gt;&lt;mark&gt;通过 BPF maps 进行通信&lt;/mark&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;31-xdp-driver-hook&quot;&gt;3.1 XDP driver hook&lt;/h2&gt;

&lt;h3 id=&quot;在设备驱动中执行无需上下文切换&quot;&gt;在设备驱动中执行，无需上下文切换&lt;/h3&gt;

&lt;p&gt;XDP 程序在网络设备驱动中执行，网络设备&lt;strong&gt;&lt;mark&gt;每收到一个包，程序就执行一次&lt;/mark&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;相关代码实现为一个&lt;strong&gt;&lt;mark&gt;内核库函数&lt;/mark&gt;&lt;/strong&gt;（library function），因此程序直接
在设备驱动中执行，&lt;strong&gt;&lt;mark&gt;无需切换到用户空间上下文&lt;/mark&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;在软件最早能处理包的位置执行性能最优&quot;&gt;在软件最早能处理包的位置执行，性能最优&lt;/h3&gt;

&lt;p&gt;回到上面图 1 可以看到：程序在网卡收到包之后&lt;strong&gt;&lt;mark&gt;最早能处理包的位置&lt;/mark&gt;&lt;/strong&gt;
执行 —— 此时&lt;strong&gt;&lt;mark&gt;内核还没有为包分配 &lt;code&gt;struct sk_buff&lt;/code&gt; 结构体&lt;/mark&gt;&lt;/strong&gt;，
也没有执行任何解析包的操作。&lt;/p&gt;

&lt;h3 id=&quot;xdp-程序典型执行流&quot;&gt;XDP 程序典型执行流&lt;/h3&gt;

&lt;p&gt;下图是一个典型的 XDP 程序执行流：&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/xdp-paper-2018/2.png&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;Fig 2. 典型 XDP 程序的执行流。&lt;/p&gt;

&lt;p&gt;网卡收到一个包时，XDP 程序依次执行：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;mark&gt;提取&lt;/mark&gt;&lt;/strong&gt;包头中的信息（例如 IP、MAC、Port、Proto 等），&lt;/p&gt;

    &lt;p&gt;执行到程序时，系统会传递给它一个上下文对象（context object）作为&lt;strong&gt;&lt;mark&gt;参赛&lt;/mark&gt;&lt;/strong&gt;
 （即 &lt;strong&gt;&lt;mark&gt;&lt;code&gt;struct xdp_md *ctx&lt;/code&gt;&lt;/mark&gt;&lt;/strong&gt;，后面有例子），其中包括了指向原
 始包数据的指针，以及描述这个包是从哪个网卡的哪个接口接收上来的等元数据字段。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;读取或更新一些资源的&lt;strong&gt;&lt;mark&gt;元信息&lt;/mark&gt;&lt;/strong&gt;（例如更新统计信息）；&lt;/p&gt;

    &lt;p&gt;解析包数据之后，XDP 程序可以读取 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ctx&lt;/code&gt; 中的包元数据（&lt;strong&gt;&lt;mark&gt;packet metadata&lt;/mark&gt;&lt;/strong&gt;）
 字段，例如从哪个网卡的哪个接口收上来的（ifindex）。除此之外，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ctx&lt;/code&gt; 对象还允许
 程序访问与包数据毗邻的一块&lt;strong&gt;&lt;mark&gt;特殊内存区域（cb, control buffer）&lt;/mark&gt;&lt;/strong&gt;，
 在包穿越整个系统的过程中，可以将自定义的数据塞在这里。&lt;/p&gt;

    &lt;p&gt;除了 per-packet metadata，XDP 程序还可以通过 BPF map 定义和访问自己的&lt;strong&gt;&lt;mark&gt;持久数据&lt;/mark&gt;&lt;/strong&gt;
 ，以及&lt;strong&gt;&lt;mark&gt;通过各种 helper 函数访问内核基础设施&lt;/mark&gt;&lt;/strong&gt;。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;BPF map 使 BPF 程序能与系统的其他部分之间通信；&lt;/li&gt;
      &lt;li&gt;Helpers 使 BPF 程序能&lt;strong&gt;&lt;mark&gt;利用到某些已有的内核功能&lt;/mark&gt;&lt;/strong&gt;（例如路由表），
而&lt;strong&gt;&lt;mark&gt;无需穿越整个内核网络栈&lt;/mark&gt;&lt;/strong&gt;。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果有需要，对这个包进行 &lt;strong&gt;&lt;mark&gt;rewrite header&lt;/mark&gt;&lt;/strong&gt; 操作，&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;&lt;mark&gt;程序能修改包数据的任何部分，包括添加或删除包头&lt;/mark&gt;&lt;/strong&gt;。这使得
 XDP 程序能执行封装/接封装操作，以及重写（rewrite）地址字段然后转发等操作。&lt;/p&gt;

    &lt;p&gt;内核 helper 函数各有不同用途，例如修改一个包之后，计算新的校验和（checksum）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;进行最后的&lt;strong&gt;&lt;mark&gt;判决&lt;/mark&gt;&lt;/strong&gt;（verdict），确定接下来对这个包执行什么操作；&lt;/p&gt;

    &lt;p&gt;判决结果包括：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;三种简单返回码：丢弃这个包、通过接收时的网卡将包重新发送出去、允许这个包进入内核网络栈；&lt;/li&gt;
      &lt;li&gt;第四种返回码 redirect：允许 XDP 程序&lt;strong&gt;&lt;mark&gt;指定网卡、CPU、用户态 socket&lt;/mark&gt;&lt;/strong&gt; 等，将包重定向过去。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;strong&gt;&lt;mark&gt;重定向功能的用途&lt;/mark&gt;&lt;/strong&gt;：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;将原始包通过另一个&lt;strong&gt;&lt;mark&gt;网卡&lt;/mark&gt;&lt;/strong&gt;（包括虚拟机的虚拟网卡）发送出去；&lt;/li&gt;
      &lt;li&gt;转发给指定 &lt;strong&gt;&lt;mark&gt;CPU&lt;/mark&gt;&lt;/strong&gt; 做进一步处理；&lt;/li&gt;
      &lt;li&gt;转发给 &lt;strong&gt;&lt;mark&gt;AF_XDP 类型的 socket&lt;/mark&gt;&lt;/strong&gt; 做进一步处理；&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;这些不同的路径，在图 1 对应的是几条实线。&lt;/p&gt;

    &lt;p&gt;将&lt;strong&gt;&lt;mark&gt;重定向判决（verdict）与重定向目标（target）分开&lt;/mark&gt;&lt;/strong&gt;，使得重定向目标类型很容易扩展；
 另外，由于&lt;strong&gt;&lt;mark&gt;重定向参数（目标）是通过 BPF map 查询的&lt;/mark&gt;&lt;/strong&gt;，因此无需修
 改 XDP 程序，就能动态修改重定向目标。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;程序还能通过&lt;strong&gt;&lt;mark&gt;尾调用&lt;/mark&gt;&lt;/strong&gt;（tail call），将控制权交给另一个 XDP 程序；
通过这种方式，可以将一个大程序拆分成几个逻辑上的小程序（例如，根据 IPv4/IPv6）。&lt;/p&gt;

&lt;p&gt;由于 XDP 程序可包含任意指令，因此前三步（读取包数据、处理元数据、重写包数据）
&lt;strong&gt;&lt;mark&gt;顺序可以是任意的，而且支持多层嵌套&lt;/mark&gt;&lt;/strong&gt;。
但实际中为了获得高性能，大部分情况下还是将执行结构组织成这顺序的三步。&lt;/p&gt;

&lt;h2 id=&quot;32-ebpf-虚拟机&quot;&gt;3.2 eBPF 虚拟机&lt;/h2&gt;

&lt;p&gt;XDP 程序在 Extended BPF (eBPF) 虚拟机中执行。
eBPF 是早期 BSD packet filter (BPF) [37] 的扩展，后者在过去的几十年中广泛
应用于各种包处理工具。&lt;/p&gt;

&lt;p&gt;BPF 使用 &lt;strong&gt;&lt;mark&gt;基于寄存器的&lt;/mark&gt;&lt;/strong&gt;（register-based） virtual machine 来描述
&lt;strong&gt;&lt;mark&gt;过滤动作&lt;/mark&gt;&lt;/strong&gt;（filtering actions）。&lt;/p&gt;

&lt;p&gt;（其他几段，略）。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;这一小节的内容有些已经过滤，限于篇幅，描述也并不全面。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;更多关于 eBPF 虚拟机和指令架构的内容，可参考：
&lt;a href=&quot;/blog/cilium-bpf-xdp-reference-guide-zh/&quot;&gt;&lt;strong&gt;&lt;mark&gt;(译) Cilium：BPF 和 XDP 参考指南（2021）&lt;/mark&gt;&lt;/strong&gt;&lt;/a&gt;
译注。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;eBPF 虚拟机支持动态加载（loading）和重加载（re-loading）程序，&lt;strong&gt;&lt;mark&gt;内核管理所有 BPF
程序的生命周期&lt;/mark&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;33-bpf-maps&quot;&gt;3.3 BPF maps&lt;/h2&gt;

&lt;p&gt;eBPF 程序在触发内核事件时执行（例如，触发 XDP 程序执行的，是收包事件）。
程序每次执行时，初始状态都是相同的（即程序是无状态的），它们&lt;strong&gt;&lt;mark&gt;无法直接访问&lt;/mark&gt;&lt;/strong&gt;
内核中的持久存储（BPF map）。为此，内核提供了访问 BPF map 的 helper 函数。&lt;/p&gt;

&lt;p&gt;BPF map 是 key/value 存储，&lt;strong&gt;&lt;mark&gt;在加载 eBPF 程序时定义&lt;/mark&gt;&lt;/strong&gt;（defined upon loading an eBPF program）。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;BPF map 的类型和一些细节实现，可参考：&lt;/p&gt;

  

  &lt;p&gt;译注。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;用途：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;持久存储。例如一个 eBPF 程序每次执行时，都会从里面获取上一次的状态。&lt;/li&gt;
  &lt;li&gt;用于协调两个或多个 eBPF 程序。例如一个往里面写数据，一个从里面读数据。&lt;/li&gt;
  &lt;li&gt;用于用户态程序和内核 eBPF 程序之间的通信。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;34-ebpf-verifier&quot;&gt;3.4 eBPF verifier&lt;/h2&gt;

&lt;h3 id=&quot;唯一加载入口bpf-系统调用&quot;&gt;唯一加载入口：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bpf()&lt;/code&gt; 系统调用&lt;/h3&gt;

&lt;p&gt;由于 eBPF 代码直接&lt;strong&gt;&lt;mark&gt;运行在内核地址空间&lt;/mark&gt;&lt;/strong&gt;，因此它能直接访问 —— 也可
能是破坏 —— 任何内存。为防止这种情况发生，内核规定&lt;strong&gt;&lt;mark&gt;只能通过唯一入口（
&lt;code&gt;bpf()&lt;/code&gt; 系统调用）加载 BPF 程序&lt;/mark&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;加载 BPF 程序时，位于内核中的校验器首先会对字节码程序进行静态分析，以确保&lt;/p&gt;



&lt;h3 id=&quot;校验器工作原理two-pass-dag&quot;&gt;校验器工作原理：two-pass DAG&lt;/h3&gt;

&lt;p&gt;校验器的工作原理：首先根据&lt;strong&gt;&lt;mark&gt;程序的控制流&lt;/mark&gt;&lt;/strong&gt;构建一个有向无环图（DAG），
然后对 DAG 执行如下校验：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;首先，对 DAG 进行一次&lt;strong&gt;&lt;mark&gt;深度优先搜索&lt;/mark&gt;&lt;/strong&gt;（depth-first search），以
确保它是无环的（acyclic），例如，没有循环，也不包含不支持或无法执行到的指令。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;然后，再扫描一遍，这次会&lt;strong&gt;&lt;mark&gt;遍历 DAG 的所有可能路径&lt;/mark&gt;&lt;/strong&gt;。这次扫描的目的是：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;确保程序的&lt;strong&gt;&lt;mark&gt;内存访问&lt;/mark&gt;&lt;/strong&gt;都是安全的，&lt;/li&gt;
      &lt;li&gt;调用 &lt;strong&gt;&lt;mark&gt;helper 函数&lt;/mark&gt;&lt;/strong&gt;时传的&lt;strong&gt;&lt;mark&gt;参数类型&lt;/mark&gt;&lt;/strong&gt;是对的。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;程序执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;load&lt;/code&gt; 或 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;call&lt;/code&gt; 指令时，如果参数不合法，就会在这里被拒绝。参数合法
  性是通过在&lt;strong&gt;&lt;mark&gt;程序执行期间跟踪所有寄存器和栈变量的状态&lt;/mark&gt;&lt;/strong&gt;（states of
  registers and stack variables）来实现的。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;内存越界和空指针检查职责上移到程序自身开发者&quot;&gt;内存越界和空指针检查：职责上移到程序自身/开发者&lt;/h3&gt;

&lt;p&gt;这种跟踪寄存器状态的机制是为了&lt;strong&gt;&lt;mark&gt;在无法预知内存边界的情况下，仍然确保程序
的内存访问不会越界&lt;/mark&gt;&lt;/strong&gt;。无法预知内存边界是因为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;包的大小是不固定的；&lt;/li&gt;
  &lt;li&gt;map 的内容也无法提前预知，因此也无法判断一次 map 查找操作是否会成功。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为解决这个问题，校验器会检查&lt;strong&gt;&lt;mark&gt;已加载的程序自身是否会做如下检查&lt;/mark&gt;&lt;/strong&gt;：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;解引用指针前做了内存边界检查，&lt;/li&gt;
  &lt;li&gt;查询 map 之前是检查了 map 指针是否为空。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这种方式将处理逻辑中的安全检查和遇到错误时如何处理的控制权都
&lt;strong&gt;&lt;mark&gt;交给了 BPF 程序的编写者&lt;/mark&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;跟踪数据访问操作和值范围&quot;&gt;跟踪数据访问操作和值范围&lt;/h3&gt;

&lt;p&gt;为跟踪数据访问，校验器会跟踪&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;&lt;mark&gt;数据类型&lt;/mark&gt;&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;mark&gt;指针偏置&lt;/mark&gt;&lt;/strong&gt;（pointer offsets）&lt;/li&gt;
  &lt;li&gt;所有&lt;strong&gt;&lt;mark&gt;寄存器的可能值范围&lt;/mark&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;程序开始时，&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;mark&gt;R1&lt;/mark&gt;&lt;/strong&gt; 寄存器中存储的是指向 context metadata 的指针（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;struct xdp_md *ctx&lt;/code&gt;）,&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;mark&gt;R10&lt;/mark&gt;&lt;/strong&gt; 是栈指针（stack pointer），&lt;/li&gt;
  &lt;li&gt;其他所有寄存器都是未初始化状态。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;接下来程序每执行一步，寄存器状态就会更新一次。当寄存器中存入一个新值时，这个寄存器
还会继承与这个值相关的状态变量（inherits the state variables from the source of the value）。&lt;/p&gt;

&lt;p&gt;算术操作会影响标量类型的值的范围（value ranges of scalar types），以及指针类型的 offset。
可能的最大范围（max possible range）存储在&lt;strong&gt;&lt;mark&gt;状态变量&lt;/mark&gt;&lt;/strong&gt;中，例如往寄存器中 load 一个字节时，
这个寄存器的可能值范围就设置为 0~255。指令图（instruction graph）中的
&lt;strong&gt;&lt;mark&gt;各逻辑分支就会根据操作结果更新寄存器状态&lt;/mark&gt;&lt;/strong&gt;。例如，比较操作 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R1 &amp;gt; 10&lt;/code&gt;，&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;校验器在一个分支 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if R1 &amp;gt; 10&lt;/code&gt; 中会将 R1 最小值设为 11，&lt;/li&gt;
  &lt;li&gt;在另一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;else&lt;/code&gt; 分支中将其最大值设为 10。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;不同类型数据的校验信息来源source-of-truth&quot;&gt;不同类型数据的校验信息来源（source of truth）&lt;/h3&gt;

&lt;p&gt;利用状态变量中存储的范围信息，&lt;strong&gt;&lt;mark&gt;校验器就能预测每个 load 指令能访问的所有
内存范围&lt;/mark&gt;&lt;/strong&gt;，确保它执行的都是合法内存访问。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;对于&lt;strong&gt;&lt;mark&gt;包数据（packet data）&lt;/mark&gt;&lt;/strong&gt;的访问，会与 context 对象中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data_end&lt;/code&gt; 变量做比较；&lt;/li&gt;
  &lt;li&gt;对于 &lt;strong&gt;&lt;mark&gt;BPF map 中获取的值&lt;/mark&gt;&lt;/strong&gt;，或用到 map 定义中声明的 data size 信息；&lt;/li&gt;
  &lt;li&gt;对于&lt;strong&gt;&lt;mark&gt;栈上存储的值&lt;/mark&gt;&lt;/strong&gt;，会检查状态变量中记录的值范围；&lt;/li&gt;
  &lt;li&gt;对于&lt;strong&gt;&lt;mark&gt;指针算术操作&lt;/mark&gt;&lt;/strong&gt;（pointer arithmetic）还会施加额外的限制，指针通常不能被转换成整形值。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;只要校验器无法证明某个操作是安全，该 &lt;strong&gt;&lt;mark&gt;BPF 程序在加载时（load time）就会被拒绝&lt;/mark&gt;&lt;/strong&gt;。
除此之外，校验器还会利用范围信息确保内存的对齐访问（enforce aligned memory access）。&lt;/p&gt;

&lt;h3 id=&quot;校验器的目的&quot;&gt;校验器的目的&lt;/h3&gt;

&lt;p&gt;需要说明的是，校验器的目的是&lt;strong&gt;&lt;mark&gt;避免将内核内部（the internals of the kernel
）暴露给恶意或有缺陷的 eBPF 程序&lt;/mark&gt;&lt;/strong&gt;，而非确保程序中函数的实现已经是最高效的。&lt;/p&gt;

&lt;p&gt;换句话说，如果 XDP 程序中处理逻辑过多，也可能会导致机器变慢
；如果代码写的有问题，也可能会破坏包数据。&lt;strong&gt;&lt;mark&gt;出于这些原因，加载 BPF 程序需要
管理员权限&lt;/mark&gt;&lt;/strong&gt;（root）。避免这些 bug 的责任在程序员，但选择将哪些程序加载
到系统的权限在管理员。&lt;/p&gt;

&lt;h2 id=&quot;35-xdp-程序示例&quot;&gt;3.5 XDP 程序示例&lt;/h2&gt;

&lt;p&gt;下面是一个简单的 XDP 程序，展示了前面介绍的一些特性。
程序会解析包数据，判断如果是 UDP 包，直接交换源和目的 MAC 地址，然后将包从相同网卡再发送回去，&lt;/p&gt;

&lt;p&gt;虽然这是一个非常简单的例子，但真实世界中的 XDP 程序用到的组件和特性，这里基本都具备了。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 从内核 BPF 代码示例 xdp2_kern.c 修改而来。&lt;/span&gt;

&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 用于统计包数&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bpf_map_def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SEC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;maps&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rxcnt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;     &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BPF_MAP_TYPE_PERCPU_ARRAY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;     &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key_size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;// IP 协议类型，即 IPv4/IPv6&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;     &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value_size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 包数&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;     &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max_entries&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 直接操作包数据（direct packet data access），交换 MAC 地址&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;swap_src_dst_mac&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt;     &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;short&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;13&lt;/span&gt;     &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;short&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;14&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;dst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;17&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;18&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;19&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parse_ipv4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u64&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nh_off&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data_end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;21&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iphdr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iph&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nh_off&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;22&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iph&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data_end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;23&lt;/span&gt;         &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iph&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;protocol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;25&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;26&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;27&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SEC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;xdp1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// marks main eBPF program entry point&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;28&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xdp_prog1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xdp_md&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;29&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;     &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data_end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data_end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt;     &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ethhdr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eth&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;XDP_DROP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;33&lt;/span&gt;     &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u16&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h_proto&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u64&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nh_off&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ipproto&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;34&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;35&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;nh_off&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;36&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nh_off&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data_end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;37&lt;/span&gt;         &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;38&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;39&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;h_proto&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eth&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h_proto&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;40&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;41&lt;/span&gt;     &lt;span class=&quot;cm&quot;&gt;/* check VLAN tag; could be repeated to support double-tagged VLAN */&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h_proto&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;htons&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ETH_P_8021Q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h_proto&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;htons&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ETH_P_8021AD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;43&lt;/span&gt;         &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vlan_hdr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vhdr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;44&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;45&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;vhdr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nh_off&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;46&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;nh_off&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vlan_hdr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;47&lt;/span&gt;         &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nh_off&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data_end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;48&lt;/span&gt;             &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;49&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;h_proto&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vhdr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h_vlan_encapsulated_proto&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;     &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;51&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;52&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h_proto&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;htons&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ETH_P_IP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;53&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;ipproto&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parse_ipv4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nh_off&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data_end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;54&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h_proto&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;htons&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ETH_P_IPV6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;55&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;ipproto&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parse_ipv6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nh_off&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data_end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;56&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;57&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;ipproto&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;58&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;59&lt;/span&gt;     &lt;span class=&quot;cm&quot;&gt;/* lookup map element for ip protocol, used for packet counter */&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;60&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bpf_map_lookup_elem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rxcnt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ipproto&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;61&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;62&lt;/span&gt;         &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;63&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;64&lt;/span&gt;     &lt;span class=&quot;cm&quot;&gt;/* swap MAC addrs for UDP packets, transmit out this interface */&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;65&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ipproto&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IPPROTO_UDP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;66&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;swap_src_dst_mac&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;67&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;rc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;XDP_TX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;68&lt;/span&gt;     &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;69&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;70&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;具体地：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;定义了一个 BPF map 存储统计信息。用户态程序可以 poll 这个 map 来获取统计信息。&lt;/li&gt;
  &lt;li&gt;context 对象 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;struct xdp_md *ctx&lt;/code&gt; 中有包数据的 start/end 指针，可用于&lt;strong&gt;&lt;mark&gt;直接访问包数据&lt;/mark&gt;&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;将数据指针和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data_end&lt;/code&gt; 比较，确保内存访问不会越界。&lt;/li&gt;
  &lt;li&gt;程序必须自己解析包，包括 VLAN headers 等东西。&lt;/li&gt;
  &lt;li&gt;直接通过指针（direct packet data access）&lt;strong&gt;&lt;mark&gt;修改包头&lt;/mark&gt;&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;内核提供的 map lookup helper。这是程序中&lt;strong&gt;&lt;mark&gt;唯一的真实函数调用&lt;/mark&gt;&lt;/strong&gt;；其他函数都是内联，包括 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;htons()&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;最终针对这个包的判决通过程序返回值传递给调用方。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;将这段程序安装到网卡接口上时，它首先会被编译成 eBPF 字节码，然后经受校验器检查。
这里的检查项包括：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;无循环操作；程序大小（指令数量）；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;mark&gt;访问包数据之前，做了内存边界检查&lt;/mark&gt;&lt;/strong&gt;；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;mark&gt;传递给 map lookup 函数的参数，类型与 map 定义相匹配&lt;/mark&gt;&lt;/strong&gt;；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;mark&gt;map lookup 的返回值（value 的内存地址）在使用之前，检查了是否为 NULL&lt;/mark&gt;&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;36-小结&quot;&gt;3.6 小结&lt;/h2&gt;

&lt;p&gt;XDP 系统由四个主要部分组成：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;XDP device driver hook：网卡收到包之后直接运行；&lt;/li&gt;
  &lt;li&gt;eBPF 虚拟机：执行 XDP 程序（以及内核其他模块加载的 BPF 程序）；&lt;/li&gt;
  &lt;li&gt;BPF maps：使不同 BPF 程序之间、BPF 程序与用户空间应用之间能够通信；&lt;/li&gt;
  &lt;li&gt;eBPF verifier：确保程序不包含任何可能会破坏内核的操作。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这四部分加在一起，创造了一个编写自定义包处理应用的强大环境，它能加速包处理的关键
路径，同时还与内核及现有基础设施密切集成。&lt;/p&gt;

&lt;p&gt;接下来看一下 XDP 应用的性能。&lt;/p&gt;

&lt;h1 id=&quot;4-性能评估&quot;&gt;4 性能评估&lt;/h1&gt;

&lt;p&gt;DPDK 是目前性能最高的包处理框架 [18]，因此本文将 XDP 与 DPDK 及 Linux 内核网络
栈的性能做一个对比。测试机器环境：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CPU：一块 hexa-core Intel Xeon E5-1650 v4 CPU running at 3.60GHz，
  支持 Intel Data Direct I/O (DDIO) 技术，网络硬件通过 DMA 能直接将包放到 CPU 缓存。&lt;/li&gt;
  &lt;li&gt;关闭超线性（Hyperthreading）。&lt;/li&gt;
  &lt;li&gt;网卡：两块 &lt;strong&gt;&lt;mark&gt;Mellanox ConnectX-5 Ex VPI dual-port 100Gbps&lt;/mark&gt;&lt;/strong&gt;，mlx5 驱动。&lt;/li&gt;
  &lt;li&gt;内核：&lt;strong&gt;&lt;mark&gt;Linux 4.18&lt;/mark&gt;&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;使用基于 DPDK 的 TRex packet generator [9] 生成测试流量。所有测试脚本位于 [22]。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在测试中，我们主要关心三个 metric：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;直接弃包（packet drop）性能。&lt;/p&gt;

    &lt;p&gt;为展示最高的包处理性能，我们将用最简单的操作 —— &lt;strong&gt;&lt;mark&gt;丢弃接收到的包&lt;/mark&gt;&lt;/strong&gt; —— 来测试。
  这个测试能有效测量系统的整体开销，也是&lt;strong&gt;&lt;mark&gt;真正的包处理应用能达到的性能上限&lt;/mark&gt;&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CPU 使用量。&lt;/p&gt;

    &lt;p&gt;如引言中指出，XDP 的优点之一是 CPU 使用量与流量大小是正相关的，而无需预留专
  门的 CPU 给它用。我们通过测量 CPU 利用率随网络负载的变化来量化这个指标。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;包转发性能。&lt;/p&gt;

    &lt;p&gt;转发的复杂性要更高一些，例如，涉及到与多块网卡的交互、重写二层头等等。
  这里会将转发延迟也考虑进去。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们已经验证，使用 MTU（1500 字节）包时，我们的系统&lt;strong&gt;&lt;mark&gt;单核就能达到线速（100 Gbps）,
而且 CPU 有 50% 是空闲的&lt;/mark&gt;&lt;/strong&gt;。显然，真正的挑战在于 PPS，而非带宽，其他一些测试也已经指出了这一点 [46]。
出于这个原因，我们用最小包（64 字节）测试，衡量指标是 PPS。&lt;/p&gt;

&lt;p&gt;对于 XDP 和 Linux 内核网络栈的测试，由于它们没有显式指定某些 CPU 来处理网络包的方式，因此我们通过配置硬件
RSS（Receive Side Scaling）来讲流量定向到指定 CPU。&lt;/p&gt;

&lt;p&gt;对网卡、内核的一些配置调优，见代码仓库 [22]。&lt;/p&gt;

&lt;h2 id=&quot;41-直接弃包packet-drop性能&quot;&gt;4.1 直接弃包（packet drop）性能&lt;/h2&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/xdp-paper-2018/3.png&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;Fig 3. 直接弃包（packet drop）性能。DPDK 需要预留一个 CPU 运行控制任务，因此只剩下 5 个 CPU 做包处理。&lt;/p&gt;

&lt;p&gt;上图是性能与 CPU 数量的关系。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;XDP 基准性能是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;24Mpps/core&lt;/code&gt;，DPDK 是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;43.5Mpps/core&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;二者在分别达到各自的峰值之前，PPS 都是随 CPU 数量线性增长的。&lt;/li&gt;
  &lt;li&gt;最终&lt;strong&gt;&lt;mark&gt;全局性能受限于 PCI 总线&lt;/mark&gt;&lt;/strong&gt;，启用 PCI descriptor
compression（在 CPU cycles 和 PCI 总线带宽之间取舍）之后，能达到 115Mpps。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;再看图中 Linux 网络栈在两种配置下的性能：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;通过 &lt;strong&gt;&lt;mark&gt;iptables 的 raw table&lt;/mark&gt;&lt;/strong&gt; 丢弃流量，这是 &lt;strong&gt;&lt;mark&gt;Linux 网络栈中最早能丢弃包的地方&lt;/mark&gt;&lt;/strong&gt;；&lt;/li&gt;
  &lt;li&gt;通过 &lt;strong&gt;&lt;mark&gt;conntrack（连接跟踪）模块&lt;/mark&gt;&lt;/strong&gt;，这个模块的&lt;strong&gt;&lt;mark&gt;开销非常大&lt;/mark&gt;&lt;/strong&gt;，但在很多 Linux 发行版中都是默认开启的。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;conntrack 模式达到了 1.8Mpps/core，raw 模式是 4.8Mpps/core
；这两种模式&lt;strong&gt;&lt;mark&gt;均未达到硬件瓶颈&lt;/mark&gt;&lt;/strong&gt;。
最终的性能，&lt;strong&gt;&lt;mark&gt;XDP 比常规网络栈的最快方式快了 5 倍&lt;/mark&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;Linux raw mode test 中，我们还测量了 XDP 程序不丢弃包，而是更新包数统计然后将包
送到内核网络栈的场景。
这种情况下，XDP &lt;strong&gt;&lt;mark&gt;单核的处理性能会下降到 4.5Mpps/core，有 13.3ns 处理延迟&lt;/mark&gt;&lt;/strong&gt;。
图中并未给出这个测试结果，因为这个开销太小了。&lt;/p&gt;

&lt;h2 id=&quot;42-cpu-usage&quot;&gt;4.2 CPU Usage&lt;/h2&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/xdp-paper-2018/4.png&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;Fig 4. 直接弃包（packet drop）场景下的 CPU 利用率。&lt;/p&gt;

&lt;p&gt;用系统提供的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mpstat&lt;/code&gt; 命令测量 CPU 利用率。结果如图 4 。&lt;/p&gt;



&lt;h2 id=&quot;43-包转发性能&quot;&gt;4.3 包转发性能&lt;/h2&gt;

&lt;p&gt;这个测试中，转发应用执行非常简单的 MAC 地址重写：&lt;strong&gt;&lt;mark&gt;直接交换源和目的 MAC 地址，然后转发&lt;/mark&gt;&lt;/strong&gt;。
这是转发场景下最精简的步骤了，因此结果代表了所有真实转发应用的性能上限。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;图中包括了同网卡转发和不同网卡转发（&lt;strong&gt;&lt;mark&gt;XDP 程序返回码不同&lt;/mark&gt;&lt;/strong&gt;）的结果。&lt;/li&gt;
  &lt;li&gt;DPDK 示例程序只支持通过另一个网卡转发，因此这里只列出了这种情况下的性能。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;mark&gt;Linux 网络栈不支持这种极简转发模式&lt;/mark&gt;&lt;/strong&gt;（minimal forwarding mode），需要设置完整的
桥接或路由查找（bridging or routing lookup）才能转发包；路由查找是非常耗时的
，由于其他几种应用并没有这一步，因此结果直接对比是没意义的。因此这里略去了
Linux 网络栈的结果。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;转发吞吐pps&quot;&gt;转发吞吐（pps）&lt;/h3&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/xdp-paper-2018/5.png&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;Fig 5. 转发性能。&lt;mark&gt;在同一网卡接口上收发会占用同一 PCI port 的带宽&lt;/mark&gt;，
这意味着在 70Mpps XDP same-nic 组就已经达到了 PCI 总线的瓶颈&lt;/p&gt;

&lt;p&gt;如图 5 所示，性能随 CPU 数量线性扩展，直到达到全局性能瓶颈。
XDP 在同网卡转发的性能远高于 DPDK 异网卡性能，原因是&lt;strong&gt;&lt;mark&gt;内存处理方式不同&lt;/mark&gt;&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;mark&gt;packet buffer 是设备驱动分配的，与接收接口（receiving interface）相关联&lt;/mark&gt;&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;因此，异网卡场景下，当包转发到另一个接口时，memory buffer 需要还给与之关联的接口。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;转发延迟&quot;&gt;转发延迟&lt;/h3&gt;

&lt;p align=&quot;center&quot;&gt;表 1. 转发延迟。机器网卡的两个接口直连，在转发速率分别为 100pps 和 1Mpps 的条件下，持续 50s 测量端到端延迟&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/xdp-paper-2018/table-1.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;mark&gt;高 pps 场景下，XDP 的延迟已经接近 DPDK&lt;/mark&gt;&lt;/strong&gt;。但在低 pps 场景下，XDP
延迟比 DPDK 大的多，原因是 &lt;strong&gt;&lt;mark&gt;XDP 是基于中断的&lt;/mark&gt;&lt;/strong&gt;，中断处理时间（
interrupt processing time）此时占大头；而 DPDK 是轮询模式，延迟相对比较固定。&lt;/p&gt;

&lt;h2 id=&quot;44-讨论xdp-性能与-dpdk-还有差距的原因&quot;&gt;4.4 讨论：XDP 性能与 DPDK 还有差距的原因&lt;/h2&gt;

&lt;h3 id=&quot;xdp-未做底层代码优化&quot;&gt;XDP 未做底层代码优化&lt;/h3&gt;

&lt;p&gt;上一节已经看到，XDP 相比于常规 Linux 网络栈性能有了显著提升。但对于大部分 XDP
场景来说，性能还是与 DPDK 有差距。我们认为，这是&lt;strong&gt;&lt;mark&gt;主要是因为 DPDK 做了相当多的底层
代码优化&lt;/mark&gt;&lt;/strong&gt;。举个例子来解释，考虑 packet drop 例子：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;XDP 24Mpps/core，对应 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;41.6ns/packet&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;DPDK 43.5Mpps，对应 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;22.9ns/packet&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;多出来的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;18.7ns&lt;/code&gt; 在我们的 3.6GHz 机器上对应 67 个时钟周期。因此，很显然
&lt;strong&gt;&lt;mark&gt;每个很小的优化在这里都会产生很大的影响&lt;/mark&gt;&lt;/strong&gt;。例如，我们测量出在测试
机器上，&lt;strong&gt;&lt;mark&gt;每次函数调用需要 1.3ns&lt;/mark&gt;&lt;/strong&gt;。 mlx5 驱动处理每个包都有 10 次
函数调用，总计就是 13ns。&lt;/p&gt;

&lt;h3 id=&quot;通用目的操作系统首要目标更好的扩展和配置而非极致性能&quot;&gt;通用目的操作系统，首要目标：更好的扩展和配置，而非极致性能&lt;/h3&gt;

&lt;p&gt;另外，在 Linux 这样的&lt;strong&gt;&lt;mark&gt;通用目的操作系统&lt;/mark&gt;&lt;/strong&gt;中，某些开销是不可避免的，
因为设备驱动或子系统的组织方式是&lt;strong&gt;&lt;mark&gt;为了实现更好的扩展和配置，而非极致性能&lt;/mark&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;但是，我们认为有些优化还是有必要的。例如，我们尝试&lt;strong&gt;&lt;mark&gt;将内核中与测试网卡无关的 DMA 函数调用删掉&lt;/mark&gt;&lt;/strong&gt;，
这样将前面提到的 10 个函数调用降低到了 6 个，测试结果显示这将&lt;strong&gt;&lt;mark&gt;单核性能提升到了 29Mpps/core&lt;/mark&gt;&lt;/strong&gt;。
依此推测的话，将另外 6 个函数调用也优化掉，能将 XDP 的性能提升到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;37.6Mpps&lt;/code&gt;。
实际上我们不可能将 6 个全部去掉，但去掉其中几个，再加上一些其他优化，我
们相信 XDP 和 DPDK 的性能差距将越来越小。&lt;/p&gt;

&lt;p&gt;其他驱动的测试结果也是类似的，例如 i40e driver for 40 Gbps Intel cards。&lt;/p&gt;

&lt;p&gt;基于以上讨论，我们相信未来 XDP 与 DPDK 的性能差距将越来越小。&lt;/p&gt;

&lt;p&gt;另一方面，考虑到 XDP 在灵活性和与内核集成方面的优势，
XDP 已经是很多实际场景中的非常有竞争力的方式。下文给出几个例子。&lt;/p&gt;

&lt;h1 id=&quot;5-真实场景使用案例&quot;&gt;5 真实场景使用案例&lt;/h1&gt;

&lt;p&gt;本节给出三个例子来具体展示 XDP 在真实世界中的应用。
这几个案例都是&lt;strong&gt;&lt;mark&gt;已经真实在用的&lt;/mark&gt;&lt;/strong&gt;，但本文出于解释目的，将使用简化的版本。
同时也建议读者参考 [38]，后者是独立的文章，介绍使用 XDP 解决实际工作中网络服务所面临的一些挑战。&lt;/p&gt;

&lt;p&gt;本节目的是展示真实 XDP 方案的可行性，因此不会将重点放在与业界最新的实现做详尽性能对比上。
我们会拿常规的 Linux 内核网络栈的性能作为 baseline，来对比 XDP 应用的性能。&lt;/p&gt;

&lt;h2 id=&quot;51-案例一软件路由software-routing&quot;&gt;5.1 案例一：软件路由（software routing）&lt;/h2&gt;

&lt;h3 id=&quot;内核数据平面--控制平面birdfrr&quot;&gt;内核数据平面 &amp;amp; 控制平面（BIRD/FRR）&lt;/h3&gt;

&lt;p&gt;Linux 内核实现了一个功能完整的路由表，作为&lt;strong&gt;&lt;mark&gt;数据平面&lt;/mark&gt;&lt;/strong&gt;，支持&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;policy routing&lt;/li&gt;
  &lt;li&gt;source-specific routing&lt;/li&gt;
  &lt;li&gt;multipath load balancing, and more.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于&lt;strong&gt;&lt;mark&gt;控制平面&lt;/mark&gt;&lt;/strong&gt;，Bird [10] 或 FRR [17] 这样的路由守护进程（
routing daemons）实现了多种路由控制平面协议。Linux 提供的这套生态系统功能如此丰富
，因此再在另一个包处理框架中&lt;strong&gt;&lt;mark&gt;重新实现一套类似的路由栈代价将非常高&lt;/mark&gt;&lt;/strong&gt;，
更实际的方式是对 Linux 内核的数据平面进行优化。&lt;/p&gt;

&lt;h3 id=&quot;xdp直接查询内核路由表并转发&quot;&gt;XDP：直接查询内核路由表并转发&lt;/h3&gt;

&lt;p&gt;XDP 非常适合做这件事情，尤其是它提供了一个 helper 函数，&lt;strong&gt;&lt;mark&gt;能从 XDP 程序中直接查询内核路由表&lt;/mark&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果查询成功，会&lt;strong&gt;&lt;mark&gt;返回 egress interface 和下一跳 MAC 地址&lt;/mark&gt;&lt;/strong&gt;，
XDP 程序&lt;strong&gt;&lt;mark&gt;利用这些信息足够将包立即转发出去&lt;/mark&gt;&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;如果下一跳 MAC 还是未知的（因为之前还没进行过 neighbour lookup），XDP 程序就
能&lt;strong&gt;&lt;mark&gt;将包传给内核网络栈，后者会解析 neighbor 地址&lt;/mark&gt;&lt;/strong&gt;，这样随后的包
就能直接被 XDP 程序转发了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;测试xdp-routing--全球-bgp-路由表&quot;&gt;测试：XDP routing + 全球 BGP 路由表&lt;/h3&gt;

&lt;p&gt;为展示 XDP 路由的性能，我们用 Linux 内核代码中的 XDP routing 例子 [1]，与常规 Linux 内核网络栈的性能做对比。
两组测试：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;路由表中只有一条路由；&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;路由表中有从 routeviews.org 中 dump 而来的&lt;strong&gt;&lt;mark&gt;全球 BGP 路由表&lt;/mark&gt;&lt;/strong&gt;（global BGP routing table）。
  &lt;strong&gt;&lt;mark&gt;包含 752,138 条路由&lt;/mark&gt;&lt;/strong&gt;。随机生成 4000 个目的 IP 地址，以确保能充分利用到这种路由表。&lt;/p&gt;

    &lt;p&gt;如果目的 IP 地址少于 4000 个，实际用到的路由表部分会较小，能够保存在 CPU 缓存中，使得结果不准确。
 增大 IP 数量至 4000 个以上，不会对转发性能造成影响，但可以&lt;strong&gt;&lt;mark&gt;避免缓存导致的结果不准&lt;/mark&gt;&lt;/strong&gt;问题。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于两组测试，下一跳 MAC 地址都是与我们的发送网卡直接相关的接口的地址。&lt;/p&gt;

&lt;h3 id=&quot;性能25x&quot;&gt;性能：2.5x&lt;/h3&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/xdp-paper-2018/6.png&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;Fig 6. 软件路由的性能。由于性能随核数线性增加，这里只给出单核的结果。&lt;/p&gt;

&lt;p&gt;测试结果如上图所示。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;full table lookup 性能提升了 2.5 倍；&lt;/li&gt;
  &lt;li&gt;smaller routing table 组，提升了 3 倍。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这说明，&lt;strong&gt;&lt;mark&gt;XDP 路由程序 + 单核 + 10Gbps 网卡&lt;/mark&gt;&lt;/strong&gt; 的软硬件配置，就能
&lt;strong&gt;&lt;mark&gt;处理整张全球 BGP 路由表&lt;/mark&gt;&lt;/strong&gt;（保守估计每个包平均 300 字节）。&lt;/p&gt;

&lt;h2 id=&quot;52-案例二inline-dos-mitigation&quot;&gt;5.2 案例二：Inline DoS Mitigation&lt;/h2&gt;

&lt;p&gt;DoS 攻击还是像瘟疫一样纠缠着互联网，现在通常的方式是：通过已经入侵的大量设备发起分布式（DDoS）攻击。&lt;/p&gt;

&lt;p&gt;有了 XDP 之后，我们能&lt;strong&gt;&lt;mark&gt;直接在应用服务器&lt;/mark&gt;&lt;/strong&gt;（application servers）上
&lt;strong&gt;&lt;mark&gt;部署包过滤程序来防御此类攻击&lt;/mark&gt;&lt;/strong&gt;（inline DoS mitigation），
&lt;strong&gt;&lt;mark&gt;无需修改应用代码&lt;/mark&gt;&lt;/strong&gt;。如果应用是部署在虚拟机里，那 XDP 程序还可以
部署在宿主机（hypervisor）上，这样单个程序就能保护机器上所有的虚拟机。&lt;/p&gt;

&lt;h3 id=&quot;模拟-cloudflare-防御架构&quot;&gt;模拟 Cloudflare 防御架构&lt;/h3&gt;

&lt;p&gt;为展示工作原理，我们用 XDP 作为过滤机制，&lt;strong&gt;&lt;mark&gt;模拟 Cloudflare 的 DDoS 防御架构&lt;/mark&gt;&lt;/strong&gt; [6]。
他们的 Gatebot architecture ，首先在各 PoP 点机器上采样，然后统一收起来做分析，
根据分析结果生成防御规则。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;mark&gt;防御规则的形式&lt;/mark&gt;&lt;/strong&gt;是对包数据（payload）进行一系列简单检查，
能直接编译成 eBPF 代码然后分发到 PoP 点的所有服务器上。这里说的代码是 XDP 程序
，它会将匹配到规则的所有流量丢弃，同时将统计信息更新到 BPF map。&lt;/p&gt;

&lt;h3 id=&quot;程序逻辑&quot;&gt;程序逻辑&lt;/h3&gt;

&lt;p&gt;为验证这种方案的性能，我们编写一个 XDP 程序，它&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;解析包头，执行一些简单验证。对每个包：执行四次读取操作，以解析外层包头。&lt;/li&gt;
  &lt;li&gt;将符合攻击特性的流量丢弃。具体：&lt;strong&gt;&lt;mark&gt;丢弃 UDP + 特定端口的流量&lt;/mark&gt;&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;将其他流量&lt;strong&gt;&lt;mark&gt;通过 CPU redirect 方式重定向给另一个 CPU&lt;/mark&gt;&lt;/strong&gt; 做进一步处理；&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;性能&quot;&gt;性能&lt;/h3&gt;

&lt;p&gt;我们用 netperf 做性能压测 [26]。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;用 netperf TCP round-trip benchmark，单个 TCP 连接来回小的 request/reply，统计 transactions/second。&lt;/p&gt;

    &lt;p&gt;模拟的是&lt;strong&gt;&lt;mark&gt;交互式应用&lt;/mark&gt;&lt;/strong&gt;，例如小的远程过程调用（RPC）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;实验在单核上进行，模拟多个流量（正常流量+攻击流量）竞争同一物理资源的场景。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 &lt;strong&gt;&lt;mark&gt;beseline 35K 业务 TPS&lt;/mark&gt;&lt;/strong&gt;（transactions per second）基础上，打少量
UDP 流量作为攻击流量。逐渐加大攻击流量，观察 TPS 的变化。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/xdp-paper-2018/7.png&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;Fig 7. DDoS 性能。业务吞吐（TPS）随攻击流量的变化。&lt;/p&gt;

&lt;p&gt;结果如上图所示，&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;没有 XDP 的一组，性能急剧下降：攻击流量在 3Mpps 时性能减半，3.5Mpps 时基本跌零；&lt;/li&gt;
  &lt;li&gt;有 XDP 程序的一组，攻击流量达到 19.5Mpps 之前，业务吞吐保持在 28.5K TPS 以上，过了这个临界点性能才开始急剧下降。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上结果表明，XDP 防御 DDoS 攻击在实际中是完全可行的，单核就能轻松处理 10Gbps 的、都是最小包（minimum-packet）的 DoS 流量。
这种 DDoS 防御的部署更加灵活，无需硬件或应用做任何改动。&lt;/p&gt;

&lt;h2 id=&quot;53-案例三负载均衡load-balancing&quot;&gt;5.3 案例三：负载均衡（load balancing）&lt;/h2&gt;

&lt;h3 id=&quot;facebook-katran&quot;&gt;Facebook Katran&lt;/h3&gt;

&lt;p&gt;负载均衡的场景，我们用 Facebook 开源的 Katran 作为例子 [15]。
Katran 的工作原理是对外通告服务的 IP，这样目标是这个 IP 的流量就会被路由到 XDP 实现的负载均衡器。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;负载均衡器对包头（source packet header）进行&lt;strong&gt;&lt;mark&gt;哈希&lt;/mark&gt;&lt;/strong&gt;，以此选择目标应用服务器。&lt;/li&gt;
  &lt;li&gt;然后将对包进行&lt;strong&gt;&lt;mark&gt;封装&lt;/mark&gt;&lt;/strong&gt;（encap），发送给应用服务器；&lt;/li&gt;
  &lt;li&gt;应用服务器&lt;strong&gt;&lt;mark&gt;解封装&lt;/mark&gt;&lt;/strong&gt;（decap），处理请求，然后直接将回包发给客户端（DSR 模式）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在这个过程中，XDP 程序负责哈希、封装以及将包从接收网卡再发出去的任务。
配置信息存储在 BPF map 中，整个封装逻辑是完全在 eBPF 中实现的。&lt;/p&gt;

&lt;h3 id=&quot;性能-1&quot;&gt;性能&lt;/h3&gt;

&lt;p&gt;为测试性能，我们给 Katran XDP 程序配置几个固定的目标机器。
对照组是 IPVS，它是 Linux 内核的一部分。性能如表 2 所示，随 CPU 数量线性增长，
XDP 比 IPVS 性能高 4.3 倍。&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;表 2. 负载均衡器性能（Mpps）&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/xdp-paper-2018/table-1.png&quot;/&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;配置：1 VIP/core, 100 DstIPs/VIP.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;6-xdp-的未来方向&quot;&gt;6 XDP 的未来方向&lt;/h1&gt;

&lt;p&gt;XDP 已经能用于解决真实问题，但作为 Linux 内核的一部分，XDP 还在快速开发过程中。&lt;/p&gt;

&lt;h2 id=&quot;61-ebpf-程序的限制&quot;&gt;6.1 eBPF 程序的限制&lt;/h2&gt;

&lt;p&gt;前面提到，加载到 eBPF 虚拟机的程序必须保证其安全性（不会破坏内核），因此对 eBPF
程序作了一下限制，归结为两方面：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;确保程序会终止：在实现上是通过禁止循环和限制程序的最大指令数（max size of the program）；&lt;/li&gt;
  &lt;li&gt;确保内存访问的安全：通过 3.4 小结介绍的寄存器状态跟踪（register state tracking）来实现。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;校验逻辑偏保守&quot;&gt;校验逻辑偏保守&lt;/h3&gt;

&lt;p&gt;由于&lt;strong&gt;&lt;mark&gt;校验器的首要职责是保证内核的安全&lt;/mark&gt;&lt;/strong&gt;，因此其&lt;strong&gt;&lt;mark&gt;校验逻辑比较保守&lt;/mark&gt;&lt;/strong&gt;，
凡是它不能证明为安全的，一律都拒绝。有时这会导致假阴性（&lt;strong&gt;&lt;mark&gt;false negatives&lt;/mark&gt;&lt;/strong&gt;），
即某些实际上是安全的程序被拒绝加载；这方面在持续改进。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;校验器的错误提示也已经更加友好，以帮助开发者更快定位问题。&lt;/li&gt;
  &lt;li&gt;近期已经支持了 BPF 函数调用（function calls）。&lt;/li&gt;
  &lt;li&gt;正在计划支持有限循环（bounded loops）。&lt;/li&gt;
  &lt;li&gt;正在提升校验器效率，以便处理更大的 BPF 程序。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;缺少标准库&quot;&gt;缺少标准库&lt;/h3&gt;

&lt;p&gt;相比于用户空间 C 程序，eBPF 程序的另一个限制是缺少标准库，包括
&lt;strong&gt;&lt;mark&gt;内存分配、线程、锁&lt;/mark&gt;&lt;/strong&gt;等等库。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;内核的生命周期和执行上下文管理（life cycle and execution context management
）部分地弥补了这一不足，（例如，加载的 XDP 程序会为每个收到的包执行），&lt;/li&gt;
  &lt;li&gt;内核提供的 helper 函数也部分地弥补了一不足。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;一个网卡接口只能-attach-一个-xdp-程序&quot;&gt;一个网卡接口只能 attach 一个 XDP 程序&lt;/h3&gt;

&lt;p&gt;这个限制其实也是可以&lt;strong&gt;&lt;mark&gt;绕过&lt;/mark&gt;&lt;/strong&gt;的：将 XDP 程序组织成程序数组，通过尾
调用，根据包上下文在程序之间跳转，或者是将几个程序做 chaining。&lt;/p&gt;

&lt;h2 id=&quot;62-用户体验和调试&quot;&gt;6.2 用户体验和调试&lt;/h2&gt;

&lt;p&gt;XDP 程序运行在内核，因此常规的用户空间 debug 工具是用不了的，但&lt;strong&gt;&lt;mark&gt;内核自带的
debug 和 introspection 功能是可以用在 XDP （及其他 eBPF 程序）上的&lt;/mark&gt;&lt;/strong&gt;。
包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;tracepoints and kprobes [13]&lt;/li&gt;
  &lt;li&gt;performance counters that are part of the perf subsystem [42]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;但不熟悉内核生态系统的开发者可能会对这些工具感到非常陌生，难以使用。因此，也出
现了一些更方便普通开发者的工具，包括 BCC [50]、bpftool [8]、libbpf 函数库 [30]
等等。&lt;/p&gt;

&lt;h2 id=&quot;63-驱动支持&quot;&gt;6.3 驱动支持&lt;/h2&gt;

&lt;p&gt;设备要支持 XDP，需要&lt;strong&gt;&lt;mark&gt;实现内核核心网络栈暴露出的一个 API&lt;/mark&gt;&lt;/strong&gt;。
写作本文时 Linux 4.18 已经有 12 种驱动支持 XDP，包括了大部分高速网卡。
最新列表见 [2]。&lt;/p&gt;

&lt;p&gt;随着 XDP 系统的不断成熟，&lt;strong&gt;&lt;mark&gt;核心代码逐渐上移到内核中，驱动需要维护的代码越
来越少&lt;/mark&gt;&lt;/strong&gt;。例如，redirection action 支持新的 target 时，无需驱动做任何改动。&lt;/p&gt;

&lt;p&gt;最后，对于那些&lt;strong&gt;&lt;mark&gt;不支持 XDP 的驱动&lt;/mark&gt;&lt;/strong&gt;，内核提供了
&lt;strong&gt;&lt;mark&gt;Generic XDP&lt;/mark&gt;&lt;/strong&gt; feature [39]，这是软件实现的 XDP，性能会低一些，
在实现上就是将 XDP 的执行上移到了核心网络栈（core networking stack）。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;XDP 在内核收包函数 &lt;strong&gt;&lt;mark&gt;receive_skb() 之前&lt;/mark&gt;&lt;/strong&gt;，&lt;/p&gt;
  &lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/ebpf-datapath-in-cilium/dp-highlight-receive-skb.png&quot;/&gt;&lt;/p&gt;

  &lt;p&gt;Generic XDP 在 &lt;strong&gt;&lt;mark&gt;receive_skb() 之后&lt;/mark&gt;&lt;/strong&gt;，&lt;/p&gt;
  &lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/ebpf-datapath-in-cilium/dp-highlight-gxdp.png&quot;/&gt;&lt;/p&gt;

  &lt;p&gt;更多关于 Generic XDP，可参考参考：
&lt;a href=&quot;/blog/understanding-ebpf-datapath-in-cilium-zh/&quot;&gt;(译) 深入理解 Cilium 的 eBPF 收发包路径（datapath）（KubeCon, 2019）&lt;/a&gt;。
译注。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;64-性能提升&quot;&gt;6.4 性能提升&lt;/h2&gt;

&lt;p&gt;XDP 和 DPDK 之间还有一些性能差距，一些改进工作正在进行中：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;驱动代码 micro-optimisations&lt;/li&gt;
  &lt;li&gt;删除核心 XDP 代码中的非必要操作&lt;/li&gt;
  &lt;li&gt;通过批处理平摊处理开销&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;65-qos-和-rate-transitions&quot;&gt;6.5 QoS 和 Rate Transitions&lt;/h2&gt;

&lt;p&gt;当前，XDP 还没有任何 QoS 机制。
尤其是，如果对端已经过载（例如两端的网络速度或特性不匹配），XDP 程序是收不到任何背压（back-pressure）的，&lt;/p&gt;

&lt;p&gt;虽然 XDP 中缺少 QoS，但 Linux 内核网络栈中却有很多业界最佳的 
Active Queue Management (AQM) 特性和
packet scheduling algorithms [23]。
这些特性中，部分并不适用于 XDP，但我们相信能够
以一种对包处理应用完全透明的方式，选择其中部分集成到 XDP。
我们计划对这一方向进行更深入研究。&lt;/p&gt;

&lt;h2 id=&quot;66-加速传输层协议&quot;&gt;6.6 加速传输层协议&lt;/h2&gt;

&lt;p&gt;我们已经证明  XDP 能在保留操作系统原有功能的前提下，集成到操作系统中，实现高速包数据。&lt;/p&gt;

&lt;p&gt;目前的 XDP 还是用于&lt;strong&gt;&lt;mark&gt;无状态包处理&lt;/mark&gt;&lt;/strong&gt;（stateless packet processing）
，如果将这个模型&lt;strong&gt;&lt;mark&gt;扩展到有状态传输层协议&lt;/mark&gt;&lt;/strong&gt;（stateful transport
protocols），例如 TCP，它能给依赖可靠/有状态传输的应用提供类似的性能提升。&lt;/p&gt;

&lt;p&gt;实际上，已经有一些研究证明，相比于操作系统的协议栈，accelerated transport
protocols 能显著提升性能[5, 25, 35, 52]。其中的一个解决方案 [52] 表明，在保留内
核 TCP 协议栈的的前提下，原始包处理性能（raw packet processing）存在巨大的提升
空间。&lt;/p&gt;

&lt;p&gt;XDP 非常适用于这种场景，目前也已经有一些关于如何实现的初步讨论 [21]，
虽然离实际使用还很远，但仍然是一个令人振奋的、扩展 XDP 系统 scope 的方向。&lt;/p&gt;

&lt;h2 id=&quot;67-内核-用户空间零拷贝zero-copy-to-userspace&quot;&gt;6.7 内核-用户空间零拷贝（zero-copy to userspace）&lt;/h2&gt;

&lt;p&gt;3.1 小节提到，XDP 程序能将数据包重定向到用户空间应用（userspace application）打
开的特殊类型 socket。这可以用于加速&lt;strong&gt;&lt;mark&gt;客户端和服务端在同一台机器&lt;/mark&gt;&lt;/strong&gt;
的网络密集型应用（network-heavy applications running on the local machine）。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;更多信息可参考：
&lt;a href=&quot;/blog/socket-acceleration-with-ebpf-zh/&quot;&gt;(译) 利用 ebpf sockmap/redirection 提升 socket 性能（2020）&lt;/a&gt;。
这里使用的是 BPF 而非 XDP，但核心原理是一样的，只是程序执行的位置（hook）不同。
译注。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;但在目前的实现中，这种方式在底层仍然需要拷贝包数据，因此性能会打折扣。&lt;/p&gt;

&lt;p&gt;目前已经有工作在进行，通过 AF_XDP 实现真正的数据零拷贝。但这项工作需要
&lt;strong&gt;&lt;mark&gt;对网络设备的内存处理过程有一些限制&lt;/mark&gt;&lt;/strong&gt;，因此需要设备驱动的显式支持。
第一个支持这个功能的 patch 已经合并到 &lt;strong&gt;&lt;mark&gt;4.19&lt;/mark&gt;&lt;/strong&gt; 内核，更多驱动的支持
正在添加中。初步的性能测试结果还是很乐观的，显示能达到 20Mpps/core 的内核到用户
空间传递（transfer）速度。&lt;/p&gt;

&lt;h2 id=&quot;68-xdp-作为基础构建模块xdp-as-a-building-block&quot;&gt;6.8 XDP 作为基础构建模块（XDP as a building block）&lt;/h2&gt;

&lt;p&gt;正如 DPDK 用于高层包处理框架的底层构建模块（例如 [31]），XDP 有望成为高层应用的运行时环境
（runtime environment for higher-level applications）。&lt;/p&gt;

&lt;p&gt;实际上，我们看到一些基于 XDP 的应用和框架已经出现了。包括&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Cilium security middle-ware [3]&lt;/li&gt;
  &lt;li&gt;Suricata network monitor [4]&lt;/li&gt;
  &lt;li&gt;Open vSwitch [49]&lt;/li&gt;
  &lt;li&gt;P4-to-XDP compiler project [51]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;甚至还有人尝试将 XDP 作为 DPDK 的一种底层驱动 [53]。&lt;/p&gt;

&lt;h1 id=&quot;7-总结&quot;&gt;7 总结&lt;/h1&gt;

&lt;p&gt;本文描述了 XDP，一个安全、快速、可编程、集成到操作系统内核的包处理框架。
测试结果显示，XDP 能提供 24Mpps/core 的高处理性能，这一数字虽然与基于 kernel
bypass 的 DPDK 仍有差距，但提供了其他一些非常有竞争力的优势：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;兼容内核安全和管理框架（kernel bypass 方式在 bypass 内核网络栈的同时，也将安全和设备管理等这些极其重要的基础设施 bypass 了）；&lt;/li&gt;
  &lt;li&gt;兼容内核网络栈，可选择性利用内核已有的基础设施和功能；&lt;/li&gt;
  &lt;li&gt;提供与内核 API 一样稳定的编程接口；&lt;/li&gt;
  &lt;li&gt;对应用完全透明；&lt;/li&gt;
  &lt;li&gt;更新、替换程序的过程不会引起服务中断；&lt;/li&gt;
  &lt;li&gt;无需专门硬件，无需独占 CPU 等资源。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;相比于 kernel bypass 这种非此即彼、完全绕开内核的方式，我们相信 XDP 有更广阔的的应用前景。
Facebook、Cloudflare 等公司实际落地的 XDP 应用，更加增强了我们的这种信心。&lt;/p&gt;

&lt;p&gt;最后，XDP 系统还在快速发展，前面也列出了一些正在未来可能会做的开发/优化工作。&lt;/p&gt;

&lt;h1 id=&quot;致谢&quot;&gt;致谢&lt;/h1&gt;

&lt;p&gt;XDP has been developed by the Linux networking community for
a number of years, and the authors would like to thank everyone
who has been involved. In particular,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Alexei Starovoitov has been instrumental in the development of the eBPF VM and verifier;&lt;/li&gt;
  &lt;li&gt;Jakub Kicinski has been a driving force behind XDP hardware offloading and the bpftool utility;&lt;/li&gt;
  &lt;li&gt;Björn Töpel and Magnus Karlsson have been leading the AF_XDP and userspace zero-copy efforts.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We also wish to extend our thanks to the anonymous reviewers,
and to our shepherd Srinivas Narayana, for their helpful comments.&lt;/p&gt;

&lt;h1 id=&quot;参考文献&quot;&gt;参考文献&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;[1] David Ahern. 2018. XDP forwarding example. https://elixir.bootlin.com/linux/ v4.18-rc1/source/samples/bpf/xdp_fwd_kern.c&lt;/li&gt;
  &lt;li&gt;[2] Cilium Authors. 2018. BPF and XDP Reference Guide. https://cilium.readthedocs.io/en/latest/bpf/&lt;/li&gt;
  &lt;li&gt;[3] Cilium Authors. 2018. Cilium software. https://github.com/cilium/cilium&lt;/li&gt;
  &lt;li&gt;[4] Suricata authors. 2018. Suricata - eBPF and XDP. https://suricata.readthedocs.io/en/latest/capture-hardware/ebpf-xdp.html&lt;/li&gt;
  &lt;li&gt;[5] Adam Belay, George Prekas, Ana Klimovic, Samuel Grossman, Christos Kozyrakis, and Edouard Bugnion. 2014. IX: A protected dataplane operating system for high throughput and low latency. In Proceedings of the 11th USENIX Symposium on Operating System Design and Implementation (OSDI ’14). USENIX.&lt;/li&gt;
  &lt;li&gt;[6] Gilberto Bertin. 2017. XDP in practice: integrating XDP in our DDoS mitigation pipeline. In NetDev 2.1 - The Technical Conference on Linux Networking.&lt;/li&gt;
  &lt;li&gt;[7] Pat Bosshart, Dan Daly, Glen Gibb, Martin Izzard, Nick McKeown, Jennifer Rexford, Cole Schlesinger, Dan Talayco, Amin Vahdat, George Varghese, et al.  2014. P4: Programming protocol-independent packet processors. ACM SIGCOMM Computer Communication Review 44, 3 (2014).&lt;/li&gt;
  &lt;li&gt;[8] bpftool authors. 2018. bpftool manual. https://elixir.bootlin.com/linux/v4.18-rc1/source/tools/bpf/bpftool/Documentation/bpftool.rst&lt;/li&gt;
  &lt;li&gt;[9] Cisco. 2018. TRex Traffic Generator. https://trex-tgn.cisco.com/&lt;/li&gt;
  &lt;li&gt;[10] CZ.nic. 2018. BIRD Internet Routing Daemon. https://bird.network.cz/&lt;/li&gt;
  &lt;li&gt;[11] Luca Deri. 2009. Modern packet capture and analysis: Multi-core, multi-gigabit, and beyond. In the 11th IFIP/IEEE International Symposium on Integrated Network Management (IM).&lt;/li&gt;
  &lt;li&gt;[12] Mihai Dobrescu, Norbert Egi, Katerina Argyraki, Byung-Gon Chun, Kevin Fall, Gianluca Iannaccone, Allan Knies, Maziar Manesh, and Sylvia Ratnasamy. 2009.  RouteBricks: exploiting parallelism to scale software routers. In Proceedings of the ACM SIGOPS 22nd symposium on Operating systems principles. ACM.&lt;/li&gt;
  &lt;li&gt;[13] Linux documentation authors. 2018. Linux Tracing Technologies. https://www.kernel.org/doc/html/latest/trace/index.html&lt;/li&gt;
  &lt;li&gt;[14] Paul Emmerich, Sebastian Gallenmüller, Daniel Raumer, Florian Wohlfart, and Georg Carle. 2015. Moongen: A scriptable high-speed packet generator. In Proceedings of the 2015 Internet Measurement Conference. ACM.&lt;/li&gt;
  &lt;li&gt;[15] Facebook. 2018. Katran source code repository. https://github.com/facebookincubator/katran&lt;/li&gt;
  &lt;li&gt;[16] Linux Foundation. 2018. Data Plane Development Kit. https://www.dpdk.org/&lt;/li&gt;
  &lt;li&gt;[17] The Linux Foundation. 2018. FRRouting. https://frrouting.org/&lt;/li&gt;
  &lt;li&gt;[18] Sebastian Gallenmüller, Paul Emmerich, Florian Wohlfart, Daniel Raumer, and Georg Carle. 2015. Comparison of Frameworks for High-Performance Packet IO. In Proceedings of the Eleventh ACM/IEEE Symposium on Architectures for Networking and Communications Systems (ANCS ’15). IEEE Computer Society, 29–38.&lt;/li&gt;
  &lt;li&gt;[19] Sangjin Han, Keon Jang, KyoungSoo Park, and Sue Moon. 2010. PacketShader: a GPU-accelerated software router. In ACM SIGCOMM Computer Communication Review, Vol. 40. ACM.&lt;/li&gt;
  &lt;li&gt;[20] Sangjin Han, Scott Marshall, Byung-Gon Chun, and Sylvia Ratnasamy. 2012.  MegaPipe: ANewProgramming Interface for Scalable Network I/O. In Proceedings of the 8th USENIX Symposium on Operating Systems Design and Implementation (OSDI ’12).&lt;/li&gt;
  &lt;li&gt;[21] Tom Herbert. 2016. Initial thoughts on TXDP. https://www.spinics.net/lists/ netdev/msg407537.html&lt;/li&gt;
  &lt;li&gt;[22] Toke Høiland-Jørgensen, Jesper Dangaard Brouer, Daniel Borkmann, John Fastabend, Tom Herbert, David Ahern, and David Miller. 2018. XDP-paper online appendix. https://github.com/tohojo/xdp-paper&lt;/li&gt;
  &lt;li&gt;[23] Toke Høiland-Jørgensen, Per Hurtig, and Anna Brunstrom. 2015. The Good, the Bad and the WiFi: Modern AQMs in a residential setting. Computer Networks 89 (Oct. 2015).&lt;/li&gt;
  &lt;li&gt;[24] Solarflare Communications Inc. 2018. OpenOnload. https://www.openonload.org/&lt;/li&gt;
  &lt;li&gt;[25] EunYoung Jeong, ShinaeWoo, Muhammad Asim Jamshed, Haewon Jeong, Sunghwan Ihm, Dongsu Han, and KyoungSoo Park. 2014. mTCP: a Highly Scalable User-level TCP Stack for Multicore Systems.. In Proceedings of the 11th USENIX Symposium on Networked Systems Design and Implementation (NSDI ’14), Vol. 14. 489–502.&lt;/li&gt;
  &lt;li&gt;[26] Rick Jones. 2018. Netperf. Open source benchmarking software. http://www.  netperf.org/&lt;/li&gt;
  &lt;li&gt;[27] Jakub Kicinski and Nic Viljoen. 2016. eBPF/XDP hardware offload to SmartNICs.  In NetDev 1.2 - The Technical Conference on Linux Networking.&lt;/li&gt;
  &lt;li&gt;[28] Davide Kirchner, Raihana Ferdous, Renato Lo Cigno, Leonardo Maccari, Massimo Gallo, Diego Perino, and Lorenzo Saino. 2016. Augustus: a CCN router for programmable networks. In Proceedings of the 3rd ACM Conference on Information- Centric Networking. ACM.&lt;/li&gt;
  &lt;li&gt;[29] Chris Lattner and Vikram Adve. 2004. LLVM: A compilation framework for lifelong program analysis &amp;amp; transformation. In Proceedings of the international symposium on Code generation and optimization: feedback-directed and runtime optimization. IEEE Computer Society.&lt;/li&gt;
  &lt;li&gt;[30] libbpf authors. 2018. libbpf source code. https://elixir.bootlin.com/linux/v4.18-rc1/source/tools/lib/bpf&lt;/li&gt;
  &lt;li&gt;[31] Leonardo Linguaglossa, Dario Rossi, Salvatore Pontarelli, Dave Barach, Damjan Marjon, and Pierre Pfister. 2017. High-speed software data plane via vectorized packet processing. Technical Report. Telecom ParisTech.&lt;/li&gt;
  &lt;li&gt;[32] John W Lockwood, Nick McKeown, Greg Watson, Glen Gibb, Paul Hartke, Jad Naous, Ramanan Raghuraman, and Jianying Luo. 2007. NetFPGA–an open platform for gigabit-rate network switching and routing. In IEEE International Conference on Microelectronic Systems Education. IEEE.&lt;/li&gt;
  &lt;li&gt;[33] Rodrigo B Mansilha, Lorenzo Saino, Marinho P Barcellos, Massimo Gallo, Emilio Leonardi, Diego Perino, and Dario Rossi. 2015. Hierarchical content stores in high-speed ICN routers: Emulation and prototype implementation. In Proceedings of the 2nd ACM Conference on Information-Centric Networking. ACM.&lt;/li&gt;
  &lt;li&gt;[34] Tudor Marian, Ki Suh Lee, and Hakim Weatherspoon. 2012. NetSlices: scalable multi-core packet processing in user-space. In Proceedings of the eighth ACM/IEEE symposium on Architectures for networking and communications systems. ACM.&lt;/li&gt;
  &lt;li&gt;[35] Ilias Marinos, Robert NM Watson, and Mark Handley. 2014. Network stack specialization for performance. In ACM SIGCOMM Computer Communication Review, Vol. 44. ACM, 175–186.&lt;/li&gt;
  &lt;li&gt;[36] Joao Martins, Mohamed Ahmed, Costin Raiciu, Vladimir Olteanu, Michio Honda, Roberto Bifulco, and Felipe Huici. 2014. ClickOS and the art of network function virtualization. In Proceedings of the 11th USENIX Conference on Networked Systems Design and Implementation. USENIX Association.&lt;/li&gt;
  &lt;li&gt;[37] Steven McCanne and Van Jacobson. 1993. The BSD Packet Filter: A New Architecture for User-level Packet Capture. In USENIX winter, Vol. 93.&lt;/li&gt;
  &lt;li&gt;[38] Sebastiano Miano, Matteo Bertrone, Fulvio Risso, Massimo Tumolo, and Mauricio Vásquez Bernal. 2018. &lt;strong&gt;&lt;mark&gt;Creating Complex Network Service with eBPF: Experience and Lessons Learned&lt;/mark&gt;&lt;/strong&gt;. In IEEE International Conference on High Performance Switching and Routing.&lt;/li&gt;
  &lt;li&gt;[39] David S. Miller. 2017. Generic XDP. https://git.kernel.org/torvalds/c/ b5cdae3291f7&lt;/li&gt;
  &lt;li&gt;[40] Robert Morris, Eddie Kohler, John Jannotti, and M Frans Kaashoek. 1999. The Click modular router. ACM SIGOPS Operating Systems Review 33, 5 (1999).&lt;/li&gt;
  &lt;li&gt;[41] Juniper Networks. 2018. Juniper Contrail Virtual Router. https://github.com/Juniper/contrail-vrouter&lt;/li&gt;
  &lt;li&gt;[42] perf authors. 2018. perf: Linux profiling with performance counters. https://perf.wiki.kernel.org/index.php/Main_Page&lt;/li&gt;
  &lt;li&gt;[43] Simon Peter, Jialin Li, Irene Zhang, Dan RK Ports, Doug Woos, Arvind Krishnamurthy, Thomas Anderson, and Timothy Roscoe. 2016. Arrakis: The operating system is the control plane. ACM Transactions on Computer Systems (TOCS) 33, 4 (2016).&lt;/li&gt;
  &lt;li&gt;[44] Ben Pfaff, Justin Pettit, Teemu Koponen, Ethan J Jackson, Andy Zhou, Jarno Rajahalme, Jesse Gross, Alex Wang, Joe Stringer, Pravin Shelar, et al. 2015. The Design and Implementation of Open vSwitch. In Proceedings of the 12th USENIX Symposium on Networked Systems Design and Implementation (NSDI ’15).&lt;/li&gt;
  &lt;li&gt;[45] Ntop project. 2018. PF_RING ZC (Zero Copy). https://www.ntop.org/products/ packet-capture/pf_ring/pf_ring-zc-zero-copy/&lt;/li&gt;
  &lt;li&gt;[46] Luigi Rizzo. 2012. Netmap: a novel framework for fast packet I/O. In 21st USENIX Security Symposium (USENIX Security 12).&lt;/li&gt;
  &lt;li&gt;[47] Luigi Rizzo and Giuseppe Lettieri. 2012. Vale, a switched ethernet for virtual machines.  In Proceedings of the 8th international conference on Emerging networking experiments and technologies. ACM.&lt;/li&gt;
  &lt;li&gt;[48] Pedro M Santiago del Rio, Dario Rossi, Francesco Gringoli, Lorenzo Nava, Luca Salgarelli, and Javier Aracil. 2012. Wire-speed statistical classification of network traffic on commodity hardware. In Proceedings of the 2012 Internet Measurement Conference. ACM.&lt;/li&gt;
  &lt;li&gt;[49] William Tu. 2018. [ovs-dev] AF_XDP support for OVS. https://mail.openvswitch.  org/pipermail/ovs-dev/2018-August/351295.html&lt;/li&gt;
  &lt;li&gt;[50] IO Visor. 2018. BCC BPF Compiler Collection. https://www.iovisor.org/ technology/bcc&lt;/li&gt;
  &lt;li&gt;[51] VMWare. 2018. p4c-xdp. https://github.com/vmware/p4c-xdp [52] Kenichi Yasukata, Michio Honda, Douglas Santry, and Lars Eggert. 2016.  StackMap: Low-Latency Networking with the OS Stack and Dedicated NICs.  In 2016 USENIX Annual Technical Conference (USENIX ATC 16). USENIX Association, 43–56.&lt;/li&gt;
  &lt;li&gt;[53] Qi Zhang. 2018. [dpdk-dev] PMD driver for AF_XDP. http://mails.dpdk.org/ archives/dev/2018-February/091502.html&lt;/li&gt;
&lt;/ul&gt;


  
  
&lt;/div&gt;


          

      &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>916053b271e070695eab859b991c0397</guid>
<title>图文并茂地聊聊 ReentrantReadWriteLock 的位运算</title>
<link>https://toutiao.io/k/f6e7ggq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是阿星，欢迎来到&lt;code&gt;Java&lt;/code&gt;并发编程系列第六篇&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt;基础，今天我们来聊一聊读写状态的设计。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我相信不少读者，在看&lt;code&gt;JDK&lt;/code&gt;源码时，会看到位运算代码，可能有些人和阿星一样是转行的，缺乏计算机相关的基础知识，看的是一头雾水。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/23OQmC1ia8nykwymiaCmxWDDibG9upZoV8eiaVYPG5ibrG1rTbMIbo8cvZgvOVo7Mplmql2JKelLZRger3EBKbkQH7Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;导致有些人直接被劝退，也有些人选择理解字面上的意思，细节跳过。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是一颗疑惑的种子在我们心中埋了下来「&lt;strong&gt;为什么使用位运算就能达到这样的效果？&lt;/strong&gt;」。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;恰好&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt;读写状态的设计用到了位运算，我们以此来展开今天的话题。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一段位运算代码&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来到&lt;code&gt;ReentrantReadWriteLock.Sync&lt;/code&gt;内部类，发现了这段代码（&lt;strong&gt;后面以&lt;code&gt;RRW&lt;/code&gt;简称&lt;/strong&gt;）&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;        &lt;br/&gt;&lt;span&gt;//偏移位数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SHARED_SHIFT = &lt;span&gt;16&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//读锁计数基本单位&lt;/span&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SHARED_UNIT = (&lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; SHARED_SHIFT);&lt;br/&gt;&lt;span&gt;//读锁、写锁可重入最大数量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MAX_COUNT = (&lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; SHARED_SHIFT) - &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//获取低16位的条件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; EXCLUSIVE_MASK = (&lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; SHARED_SHIFT) - &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//获取读锁重入数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;sharedCount&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; c)&lt;/span&gt;    &lt;/span&gt;{ &lt;span&gt;return&lt;/span&gt; c &amp;gt;&amp;gt;&amp;gt; SHARED_SHIFT; }&lt;br/&gt;&lt;span&gt;//获取写锁重入数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;exclusiveCount&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; c)&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;return&lt;/span&gt; c &amp;amp; EXCLUSIVE_MASK; }&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的这些位运算代码是用来干嘛的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为&lt;code&gt;RRW&lt;/code&gt;的中的&lt;code&gt;int&lt;/code&gt;整型变量&lt;code&gt;state&lt;/code&gt;要同时维护读锁、写锁两种状态，所以&lt;code&gt;RRW&lt;/code&gt;的是通过&lt;strong&gt;高低位切割&lt;/strong&gt;来实现。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.46440677966101696&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nykwymiaCmxWDDibG9upZoV8eByfbUsNUPuqUVKPSK2LlAhriaOvfHNoiccHQSf2832aoLmdfk1pK2wibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;885&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;int&lt;/code&gt;占&lt;code&gt;4&lt;/code&gt;个字节，一个字节&lt;code&gt;8&lt;/code&gt;位，总共&lt;code&gt;32&lt;/code&gt;位，切割一下，高&lt;code&gt;16&lt;/code&gt;位表示读，低&lt;code&gt;16&lt;/code&gt;位表示写。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样做的好处就是节约资源，就像现实中老板把你一个人当两个人用是一样的道理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;讲到这里，大家也明白了，上面的位运算代码就是完成&lt;strong&gt;高低位切割&lt;/strong&gt;的。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;读锁位运算&lt;/span&gt;&lt;/h1&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//偏移位数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SHARED_SHIFT = &lt;span&gt;16&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//读锁计数基本单位&lt;/span&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SHARED_UNIT = (&lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; SHARED_SHIFT);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读锁使用高&lt;code&gt;16&lt;/code&gt;位，每次获取读锁成功&lt;code&gt;+1&lt;/code&gt;，所以读锁计数基本单位是&lt;code&gt;1&lt;/code&gt;的高&lt;code&gt;16&lt;/code&gt;位，即&lt;code&gt;1&lt;/code&gt;左移&lt;code&gt;16&lt;/code&gt;位（&lt;code&gt;1 &amp;lt;&amp;lt; 16&lt;/code&gt;）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4066147859922179&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nykwymiaCmxWDDibG9upZoV8ediaLfax9fyJ1ahIlfqH4RPMaufp0SAUmebu57mJTiccqdJFsuPGicCic2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1028&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;1&lt;/code&gt;左移&lt;code&gt;16&lt;/code&gt;位等于&lt;code&gt;65536&lt;/code&gt;，每次获取读锁成功都&lt;code&gt;+65536&lt;/code&gt;，这时有读者跳出来问，不是&lt;code&gt;+1&lt;/code&gt;嘛，怎么变成&lt;code&gt;+65536&lt;/code&gt;了，这不对啊。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;别急别急，看看下面这段代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//偏移位数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SHARED_SHIFT = &lt;span&gt;16&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//获取读锁重入数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;sharedCount&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; c)&lt;/span&gt;    &lt;/span&gt;{ &lt;span&gt;return&lt;/span&gt; c &amp;gt;&amp;gt;&amp;gt; SHARED_SHIFT; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面&lt;code&gt;sharedCount&lt;/code&gt;函数通过位运算是做无符号右移&lt;code&gt;16&lt;/code&gt;位获取读锁的重入数，为什么可以获取到呢？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.39068825910931176&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nykwymiaCmxWDDibG9upZoV8ecYmzt2RQcCmQKKaLUqVA6c3dZQfClKTG31ibubjMDsUO4BfBfslcy1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;988&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阿星原地向前走&lt;code&gt;16&lt;/code&gt;步，再后退&lt;code&gt;16&lt;/code&gt;步，又回到原点，&lt;code&gt;1&lt;/code&gt;左移&lt;code&gt;16&lt;/code&gt;位等于&lt;code&gt;65536&lt;/code&gt;，&lt;code&gt;65536&lt;/code&gt;右移&lt;code&gt;16&lt;/code&gt;位等于&lt;code&gt;1&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我们获取到了&lt;code&gt;3&lt;/code&gt;次读锁，就是&lt;code&gt;65536 * 3 = 196608&lt;/code&gt;，转换下公式就是&lt;code&gt;3&lt;/code&gt;左移&lt;code&gt;16&lt;/code&gt;位等于&lt;code&gt;196608&lt;/code&gt;，&lt;code&gt;196608&lt;/code&gt;右移&lt;code&gt;16&lt;/code&gt;位等于&lt;code&gt;3&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然我们每次获取到读锁都会&lt;code&gt;+65536&lt;/code&gt;，但是获取读锁时会做右移&lt;code&gt;16&lt;/code&gt;位，所以效果和&lt;code&gt;+1&lt;/code&gt;是一样。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;写锁位运算&lt;/span&gt;&lt;/h1&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//偏移位数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SHARED_SHIFT = &lt;span&gt;16&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//获取低16位的条件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; EXCLUSIVE_MASK = (&lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; SHARED_SHIFT) - &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//获取写锁重入数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;exclusiveCount&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; c)&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;return&lt;/span&gt; c &amp;amp; EXCLUSIVE_MASK; }&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;剩下的写锁就非常简单，获取低&lt;code&gt;16&lt;/code&gt;位不用左右移动，只要把高&lt;code&gt;16&lt;/code&gt;位全部补&lt;code&gt;0&lt;/code&gt;即可。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4642507345739471&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nykwymiaCmxWDDibG9upZoV8eHDSSt5icianAaoF3dzUpDjACTuuIruTYbhA1sAWmFuTZeso1icrcwSLMQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1021&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反推一下，因为不需要左右移动，其实就和正常的数字一样，只不过因为高&lt;code&gt;16&lt;/code&gt;位补&lt;code&gt;0&lt;/code&gt;，导致数值范围在&lt;code&gt;0~65535&lt;/code&gt;，也就是说写锁获取成功直接&lt;code&gt;+1&lt;/code&gt;就好了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.20534458509142053&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nykwymiaCmxWDDibG9upZoV8eGBSTacYSkOY494ItEZKiaPDxMYl0oJAKP3kBzx1kqnG6fVckGIkTKSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;711&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们目光转到&lt;code&gt;EXCLUSIVE_MASK&lt;/code&gt;变量，&lt;code&gt;1&lt;/code&gt;右移&lt;code&gt;16&lt;/code&gt;位后&lt;code&gt;-1&lt;/code&gt;，得到&lt;code&gt;65535&lt;/code&gt;，&lt;code&gt;65535&lt;/code&gt;的二进制就是&lt;code&gt;111111111111111&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在来看&lt;code&gt;exclusiveCount&lt;/code&gt;函数，该函数内做了位运算&lt;code&gt;&amp;amp;&lt;/code&gt;，&lt;code&gt;&amp;amp;&lt;/code&gt;又称&quot;&lt;strong&gt;与&lt;/strong&gt;&quot;运算。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&quot;&lt;strong&gt;与&lt;/strong&gt;&quot;运算是两个二进制，每位数运算，运算规则如下&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如果相对应位都是1，则结果为1，否则为0&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能有些读者大大还是不太明白，下面放张图&lt;code&gt;16&lt;/code&gt;位二进制&quot;&lt;strong&gt;与&lt;/strong&gt;&quot;运算图&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5050377833753149&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nykwymiaCmxWDDibG9upZoV8eicHWoDaric4ibhw2Ol0mAiauYWM5QkoiaCqjiaDdpsf3lcGPBxX6sRj9QZTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;794&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们发现&quot;&lt;strong&gt;与&lt;/strong&gt;&quot;运算时，只要有一方为&lt;code&gt;0&lt;/code&gt;，那结果一定是&lt;code&gt;0&lt;/code&gt;，所以为了切割低&lt;code&gt;16&lt;/code&gt;位，可以使用&lt;code&gt;&amp;amp;&lt;/code&gt;来完成。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.1882716049382716&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nykwymiaCmxWDDibG9upZoV8exKFmYyCcbXXG4jPe6UpWX2fkA0eH2SrgXoh1ZXOrYoYWY6EC1axHbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1296&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上图可以看出，&lt;code&gt;EXCLUSIVE_MASK&lt;/code&gt;高&lt;code&gt;16&lt;/code&gt;位都是&lt;code&gt;0&lt;/code&gt;，低&lt;code&gt;16&lt;/code&gt;位都是&lt;code&gt;1&lt;/code&gt;，和它&lt;code&gt;&amp;amp;&lt;/code&gt;的变量，高&lt;code&gt;16&lt;/code&gt;位全部会变成&lt;code&gt;0&lt;/code&gt;，低&lt;code&gt;16&lt;/code&gt;位全部保留下来，最终达到获取低&lt;code&gt;16&lt;/code&gt;位效果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;c &amp;amp; EXCLUSIVE_MASK&lt;/code&gt;，假设&lt;code&gt;c&lt;/code&gt;是&lt;code&gt;1&lt;/code&gt;，&lt;code&gt;&amp;amp;&lt;/code&gt;的过程如下图&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.22013034033309195&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nykwymiaCmxWDDibG9upZoV8eteqiaKxxy2zr01yGytQgLDCEuVLycXuhXDArSRRIYiaKZGLFAlMCBdPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1381&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样看可能没太大感觉，我们把数值调大点，假设&lt;code&gt;c&lt;/code&gt;是&lt;code&gt;65536&lt;/code&gt;和&lt;code&gt;65537&lt;/code&gt;，&lt;code&gt;&amp;amp;&lt;/code&gt;的过程如下图&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5193409742120344&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nykwymiaCmxWDDibG9upZoV8edY58tHo1EuwDibv897K10H6nGQygDcIaNTDZG49agI0WyZc9Zko3evQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1396&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在有感觉了吧，&lt;code&gt;c&lt;/code&gt;的高&lt;code&gt;16&lt;/code&gt;位都会变成&lt;code&gt;0&lt;/code&gt;，低&lt;code&gt;16&lt;/code&gt;位会原样保留，最终达到获取低&lt;code&gt;16&lt;/code&gt;位效果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;EXCLUSIVE_MASK&lt;/code&gt;范围在&lt;code&gt;0~65535&lt;/code&gt;，所以&lt;code&gt;c&lt;/code&gt;的范围也不会超过&lt;code&gt;0~65535&lt;/code&gt;，因为超过了也会通过&lt;code&gt;&amp;amp; EXCLUSIVE_MASK&lt;/code&gt;回到&lt;code&gt;0~65535&lt;/code&gt;。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;提个问题&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;「&lt;strong&gt;阿星&lt;/strong&gt;」：&lt;code&gt;int&lt;/code&gt;如何实现序列化与反序列化？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;「&lt;strong&gt;萌新&lt;/strong&gt;」：好家伙，我直接用&lt;code&gt;Integer&lt;/code&gt;就好了，父类&lt;code&gt;Number&lt;/code&gt;实现了序列化接口&lt;code&gt;Serializable&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;「&lt;strong&gt;阿星&lt;/strong&gt;」：不使用&lt;code&gt;Serializable&lt;/code&gt;，自己手写一个呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;「&lt;strong&gt;萌新&lt;/strong&gt;」：啊，这。。。。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了让大家更好的消化之前的内容，阿星手把手带大家实现&lt;code&gt;int&lt;/code&gt;与字节的互转。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.23111510791366907&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nykwymiaCmxWDDibG9upZoV8eTdukxib9lRLnJsN57T1ibFiciaWSpYic42uBN5YaCaictzCBV3EylibVPXibkg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1112&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;int&lt;/code&gt;占&lt;code&gt;4&lt;/code&gt;个字节，一个字节&lt;code&gt;8&lt;/code&gt;位，总共&lt;code&gt;32&lt;/code&gt;位。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;int转byte数组&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;思路很简单，我们只需要从右往左按&lt;code&gt;8&lt;/code&gt;位一个一个截取，再存储到&lt;code&gt;byte&lt;/code&gt;数组里面，代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] intToBytes(&lt;span&gt;int&lt;/span&gt; n) {&lt;br/&gt;        &lt;span&gt;//长度4字节的数组&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;byte&lt;/span&gt;[] buf = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;4&lt;/span&gt;];&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; buf.length; i++) {&lt;br/&gt;            &lt;span&gt;//循环右移动8位，存储到数组中&lt;/span&gt;&lt;br/&gt;            buf[i] = (&lt;span&gt;byte&lt;/span&gt;) (n &amp;gt;&amp;gt; (&lt;span&gt;8&lt;/span&gt; * i));&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; buf;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;过程图如下&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.860381861575179&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nykwymiaCmxWDDibG9upZoV8e2OEmVniaP7mSI4AuLoDgzPnJX2H0mtvD6cmam4Orib1hAWiaQ0NYcSRRA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;838&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;byte数组转int&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们从&lt;code&gt;int&lt;/code&gt;转换成了&lt;code&gt;byte[]&lt;/code&gt;，现在要从&lt;code&gt;byte[]&lt;/code&gt;转换成&lt;code&gt;int&lt;/code&gt;，代码如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;bytesToInt&lt;/span&gt;&lt;span&gt;(&lt;span&gt;byte&lt;/span&gt;[] buf)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; buf[&lt;span&gt;0&lt;/span&gt;] &amp;amp; &lt;span&gt;0xff&lt;/span&gt;&lt;br/&gt;            | ((buf[&lt;span&gt;1&lt;/span&gt;] &amp;lt;&amp;lt; &lt;span&gt;8&lt;/span&gt;) &amp;amp; &lt;span&gt;0xff00&lt;/span&gt;)&lt;br/&gt;            | ((buf[&lt;span&gt;2&lt;/span&gt;] &amp;lt;&amp;lt; &lt;span&gt;16&lt;/span&gt;) &amp;amp; &lt;span&gt;0xff0000&lt;/span&gt;)&lt;br/&gt;            | ((buf[&lt;span&gt;3&lt;/span&gt;] &amp;lt;&amp;lt; &lt;span&gt;24&lt;/span&gt;) &amp;amp; &lt;span&gt;0xff000000&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码中涉及到了&quot;&lt;strong&gt;左移、与、或&lt;/strong&gt;&quot;位运算，&lt;strong&gt;左移&lt;/strong&gt;和&lt;strong&gt;与&lt;/strong&gt;我们前面都说了，还有一个&lt;strong&gt;或&lt;/strong&gt;，&lt;strong&gt;或&lt;/strong&gt;和&lt;strong&gt;与&lt;/strong&gt;一样，只是运算规则不同，&lt;strong&gt;或&lt;/strong&gt;的运算规则如下&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如果相对应位都是 0，则结果为 0，否则为 1&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;0xff&lt;/code&gt;的二进制是&lt;code&gt;11111111&lt;/code&gt;，&lt;code&gt;0xff&lt;/code&gt;后面每追加&lt;code&gt;2&lt;/code&gt;个&lt;code&gt;0&lt;/code&gt;，效果等于左移&lt;code&gt;8&lt;/code&gt;位，依次类推，所以我们最终是利用&lt;code&gt;&amp;lt;&amp;lt;、|、&amp;amp;、0xff&lt;/code&gt;来还原。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;过程图如下&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.7016460905349795&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nykwymiaCmxWDDibG9upZoV8e35VWYdEYCTBYzZnrbCF1ErfdfGmTujA8IMZcfthd3MV1EjsEevKgiaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1458&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt;中读写状态公用一个状态，巧妙的利用高低位来节约资源，在整个实现过程中，使用了位运算来做高低位切割。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;历史好文推荐&lt;/span&gt;&lt;/h1&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;关于我&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里是阿星，一个热爱技术的Java程序猿，公众号  &lt;strong&gt;「程序猿阿星」&lt;/strong&gt; 里将会定期分享操作系统、计算机网络、Java、分布式、数据库等精品原创文章，2021，与您在 Be Better 的路上共同成长！。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5763888888888888&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/23OQmC1ia8nykwymiaCmxWDDibG9upZoV8e5Qfw5lAfCiawAwhp3M07Jr9WqnOZRtX9KYM0l3ibmxcWSjt6mK73N96w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;288&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非常感谢各位小哥哥小姐姐们能看到这里，原创不易，文章有帮助可以关注、点个赞、分享与评论，都是支持（莫要白嫖）！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;愿你我都能奔赴在各自想去的路上，我们下篇文章见&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bab406b67996e6ef32053a7cd9a2af74</guid>
<title>聊聊如何根据环境动态指定 feign 调用服务名</title>
<link>https://toutiao.io/k/7yze5jo</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/O1vpibItUIJV1iblpZ8SUcHFUVqA2RcyrlYdjDVTuhRbbmLrtRsibYenrldcSte4cBicRabicxARsjickFo4g59MyICQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;40&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;点击上方&lt;span data-mid=&quot;&quot;&gt;蓝字&lt;/span&gt;关注我们&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;01&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;前段时间和朋友聊天，他说他部门老大给他提了一个需求，这个需求的背景是这样，他们开发环境和测试环境共用一套eureka，服务提供方的serviceId加环境后缀作为区分，比如用户服务其开发环境serviceId为user_dev,测试环境为user_test。每次服务提供方发布的时候，会根据环境变量，自动变更serviceId。&lt;/p&gt;&lt;p&gt;消费方feign调用时，直接通过&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;@&lt;span&gt;FeignClient&lt;/span&gt;(&lt;span&gt;name&lt;/span&gt; = &lt;span&gt;&quot;user_dev&quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;来进行调用，因为他们是直接把feignClient的name直接写死在代码里，导致他们每次发版到测试环境时，要手动改name，比如把user_dev改成user_test，这种改法在服务比较少的情况下，还可以接受，一旦服务一多，就容易改漏，导致本来该调用测试环境的服务提供方，结果跑去调用开发环境的提供方。&lt;/p&gt;&lt;p&gt;他们的老大给他提的需求是，消费端调用需要&lt;strong&gt;自动&lt;/strong&gt;根据环境调用到相应环境的服务提供方。&lt;/p&gt;&lt;p&gt;下面就介绍朋友通过百度搜索出来的几种方案，以及后面我帮朋友实现的另一种方案&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;02&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;方案&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.03428571428571429&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Zo04aoPGhhftaGG0yuEeaxw97HRiaFa8WJW7libBkFeicrPny8KnvKmeezoNnqicGdpWHkOm3eGAIXwGohqRuZ6S6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;方案一：通过feign拦截器+url改造&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.03428571428571429&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/py7L4cx8wYvBYkElUsqDz94g2u3uiaKibfK2IkLjMkEBKezINP2n0PyX4GwcXC1vl0K8KWnITP6HhjIuhyUBIXbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span data-mid=&quot;&quot;&gt;01&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;在API的URI上做一下特殊标记&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@FeignClient&lt;/span&gt;(name = &lt;span&gt;&quot;feign-provider&quot;&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;public interface FooFeignClient {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(value = &lt;span&gt;&quot;//feign-provider-$env/foo/{username}&quot;&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    String foo(&lt;span&gt;@PathVariable&lt;/span&gt;(&lt;span&gt;&quot;username&quot;&lt;/span&gt;) String username);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;这边指定的URI有两点需要注意的地方&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span data-mid=&quot;&quot;&gt;02&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;在RequestInterceptor中查找到特殊的变量标记并替换&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;@Configuration&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;InterceptorConfig&lt;/span&gt; {&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    @Autowired&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; Environment environment;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    @&lt;span&gt;Bean&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;public&lt;/span&gt; RequestInterceptor &lt;span&gt;cloudContextInterceptor&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RequestInterceptor() {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            @Override&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; apply(RequestTemplate &lt;span&gt;template&lt;/span&gt;) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                String url = &lt;span&gt;template&lt;/span&gt;.url();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                &lt;span&gt;if&lt;/span&gt; (url.contains(&lt;span&gt;&quot;$env&quot;&lt;/span&gt;)) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                    url = url.replace(&lt;span&gt;&quot;$env&quot;&lt;/span&gt;, route(&lt;span&gt;template&lt;/span&gt;));&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                    System.out.println(url);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                    &lt;span&gt;template&lt;/span&gt;.uri(url);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                &lt;span&gt;if&lt;/span&gt; (url.startsWith(&lt;span&gt;&quot;//&quot;&lt;/span&gt;)) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                    url = &lt;span&gt;&quot;http:&quot;&lt;/span&gt; + url;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                    &lt;span&gt;template&lt;/span&gt;.target(url);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                    &lt;span&gt;template&lt;/span&gt;.uri(&lt;span&gt;&quot;&quot;&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;&lt;span&gt;private&lt;/span&gt; CharSequence &lt;span&gt;route&lt;/span&gt;&lt;span&gt;(RequestTemplate &lt;span&gt;template&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                &lt;span&gt;// TODO 你的路由算法在这里&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                &lt;span&gt;return&lt;/span&gt; environment.getProperty(&lt;span&gt;&quot;feign.env&quot;&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        };&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;这种方案是可以实现，但是朋友没有采纳，因为朋友的项目已经是上线的项目，通过改造url，成本比较大。就放弃了&lt;/p&gt;&lt;p&gt;该方案由博主&lt;strong&gt;无级程序员&lt;/strong&gt;提供，下方链接是他实现该方案的链接&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span data-mid=&quot;&quot;/&gt;&lt;span data-mid=&quot;&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;https://blog.csdn.net/weixin_45357522/article/details/104020061&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span data-mid=&quot;&quot;/&gt;&lt;span data-mid=&quot;&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.03428571428571429&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Zo04aoPGhhftaGG0yuEeaxw97HRiaFa8WJW7libBkFeicrPny8KnvKmeezoNnqicGdpWHkOm3eGAIXwGohqRuZ6S6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;方案二:重写RouteTargeter&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.03428571428571429&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/py7L4cx8wYvBYkElUsqDz94g2u3uiaKibfK2IkLjMkEBKezINP2n0PyX4GwcXC1vl0K8KWnITP6HhjIuhyUBIXbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span data-mid=&quot;&quot;&gt;01&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;API的URL中定义一个特殊的变量标记，形如下&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@FeignClient&lt;/span&gt;(name = &lt;span&gt;&quot;feign-provider-env&quot;&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;public interface FooFeignClient {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(value = &lt;span&gt;&quot;/foo/{username}&quot;&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    String foo(&lt;span&gt;@PathVariable&lt;/span&gt;(&lt;span&gt;&quot;username&quot;&lt;/span&gt;) String username);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span data-mid=&quot;&quot;&gt;02&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;以HardCodedTarget为基础，实现Targeter&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RouteTargeter&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Targeter&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; Environment environment;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;RouteTargeter&lt;/span&gt;&lt;span&gt;(Environment environment)&lt;/span&gt;&lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;       &lt;span&gt;this&lt;/span&gt;.environment = environment;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    } &lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;/**&lt;br mpa-from-tpl=&quot;t&quot;/&gt;   * 服务名以本字符串结尾的，会被置换为实现定位到环境&lt;br mpa-from-tpl=&quot;t&quot;/&gt;   */&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String CLUSTER_ID_SUFFIX = &lt;span&gt;&quot;env&quot;&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;@Override&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;T &lt;span&gt;target&lt;/span&gt;&lt;span&gt;(FeignClientFactoryBean factory, Builder feign, FeignContext context,&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      HardCodedTarget&amp;lt;T&amp;gt; target)&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;return&lt;/span&gt; feign.target(&lt;span&gt;new&lt;/span&gt; RouteTarget&amp;lt;&amp;gt;(target));&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RouteTarget&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Target&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    Logger log = LoggerFactory.getLogger(getClass());&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; Target&amp;lt;T&amp;gt; realTarget;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;RouteTarget&lt;/span&gt;&lt;span&gt;(Target&amp;lt;T&amp;gt; realTarget)&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;super&lt;/span&gt;();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;this&lt;/span&gt;.realTarget = realTarget;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Class&amp;lt;T&amp;gt; &lt;span&gt;type&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;return&lt;/span&gt; realTarget.type();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;name&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;return&lt;/span&gt; realTarget.name();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;url&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      String url = realTarget.url();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;if&lt;/span&gt; (url.endsWith(CLUSTER_ID_SUFFIX)) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        url = url.replace(CLUSTER_ID_SUFFIX, locateCusterId());&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        log.debug(&lt;span&gt;&quot;url changed from {} to {}&quot;&lt;/span&gt;, realTarget.url(), url);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;return&lt;/span&gt; url;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;/**&lt;br mpa-from-tpl=&quot;t&quot;/&gt;     * &lt;span&gt;@return&lt;/span&gt; 定位到的实际单元号&lt;br mpa-from-tpl=&quot;t&quot;/&gt;     */&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; String &lt;span&gt;locateCusterId&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;// TODO 你的路由算法在这里&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;return&lt;/span&gt; environment.getProperty(&lt;span&gt;&quot;feign.env&quot;&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Request &lt;span&gt;apply&lt;/span&gt;&lt;span&gt;(RequestTemplate input)&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;if&lt;/span&gt; (input.url().indexOf(&lt;span&gt;&quot;http&quot;&lt;/span&gt;) != &lt;span&gt;0&lt;/span&gt;) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        input.target(url());&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;return&lt;/span&gt; input.request();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span data-mid=&quot;&quot;&gt;03&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;使用自定义的Targeter实现代替缺省的实现&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Bean&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; RouteTargeter &lt;span&gt;getRouteTargeter&lt;/span&gt;&lt;span&gt;(Environment environment)&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RouteTargeter(environment);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该方案适用于spring-cloud-starter-openfeign为3.0版本以上，3.0版本以下得额外加&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;repositories&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;repository&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;id&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-milestones&lt;span&gt;&amp;lt;/&lt;span&gt;id&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;Spring Milestones&lt;span&gt;&amp;lt;/&lt;span&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;url&lt;/span&gt;&amp;gt;&lt;/span&gt;https://repo.spring.io/milestone&lt;span&gt;&amp;lt;/&lt;span&gt;url&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;repository&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;repositories&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;Targeter 这个接口在3.0之前的包是属于package范围，因此没法直接继承。朋友的springcloud版本相对比较低，后面基于系统稳定性的考虑，就没有贸然升级springcloud版本。因此这个方案朋友也没采纳&lt;/p&gt;&lt;p&gt;该方案仍然由博主&lt;strong&gt;无级程序员&lt;/strong&gt;提供，下方链接是他实现该方案的链接&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span data-mid=&quot;&quot;/&gt;&lt;span data-mid=&quot;&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;https://blog.csdn.net/weixin_45357522/article/details/106745468&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span data-mid=&quot;&quot;/&gt;&lt;span data-mid=&quot;&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.03428571428571429&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Zo04aoPGhhftaGG0yuEeaxw97HRiaFa8WJW7libBkFeicrPny8KnvKmeezoNnqicGdpWHkOm3eGAIXwGohqRuZ6S6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;方案三：使用FeignClientBuilder&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.03428571428571429&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/py7L4cx8wYvBYkElUsqDz94g2u3uiaKibfK2IkLjMkEBKezINP2n0PyX4GwcXC1vl0K8KWnITP6HhjIuhyUBIXbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;这个类的作用如下&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br mpa-from-tpl=&quot;t&quot;/&gt; * A builder for creating Feign clients without using the {&lt;span&gt;@link&lt;/span&gt; FeignClient} annotation.&lt;br mpa-from-tpl=&quot;t&quot;/&gt; * &amp;lt;p&amp;gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt; * This builder builds the Feign client exactly like it would be created by using the&lt;br mpa-from-tpl=&quot;t&quot;/&gt; * {&lt;span&gt;@link&lt;/span&gt; FeignClient} annotation.&lt;br mpa-from-tpl=&quot;t&quot;/&gt; *&lt;br mpa-from-tpl=&quot;t&quot;/&gt; * &lt;span&gt;@author&lt;/span&gt; Sven Döring&lt;br mpa-from-tpl=&quot;t&quot;/&gt; */&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;他的功效是和@FeignClient是一样的，因此就可以通过手动编码的方式&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span data-mid=&quot;&quot;&gt;01&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;编写一个feignClient工厂类&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DynamicFeignClientFactory&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; FeignClientBuilder feignClientBuilder;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;DynamicFeignClientFactory&lt;/span&gt;&lt;span&gt;(ApplicationContext appContext)&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;this&lt;/span&gt;.feignClientBuilder = &lt;span&gt;new&lt;/span&gt; FeignClientBuilder(appContext);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; T &lt;span&gt;getFeignClient&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; Class&amp;lt;T&amp;gt; type, String serviceId)&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.feignClientBuilder.forType(type, serviceId).build();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span data-mid=&quot;&quot;&gt;02&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;编写API实现类&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BarFeignClient {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; DynamicFeignClientFactory&amp;lt;BarService&amp;gt; dynamicFeignClientFactory;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${feign.env}&quot;&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; env;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; bar(&lt;span&gt;@PathVariable&lt;/span&gt;(&lt;span&gt;&quot;username&quot;&lt;/span&gt;) &lt;span&gt;String&lt;/span&gt; username){&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        BarService barService = dynamicFeignClientFactory.getFeignClient(BarService.class,getBarServiceName());&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; barService.bar(username);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; getBarServiceName(){&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;feign-other-provider-&quot;&lt;/span&gt; + env;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;本来朋友打算使用这种方案了，最后没采纳，原因后面会讲。&lt;/p&gt;&lt;p&gt;该方案由博主&lt;strong&gt;lotern&lt;/strong&gt;提供，下方链接为他实现该方案的链接&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span data-mid=&quot;&quot;/&gt;&lt;span data-mid=&quot;&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;https://my.oschina.net/kaster/blog/4694238&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span data-mid=&quot;&quot;/&gt;&lt;span data-mid=&quot;&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.03428571428571429&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Zo04aoPGhhftaGG0yuEeaxw97HRiaFa8WJW7libBkFeicrPny8KnvKmeezoNnqicGdpWHkOm3eGAIXwGohqRuZ6S6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;方案四：feignClient注入到spring之前，修改FeignClientFactoryBean&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.03428571428571429&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/py7L4cx8wYvBYkElUsqDz94g2u3uiaKibfK2IkLjMkEBKezINP2n0PyX4GwcXC1vl0K8KWnITP6HhjIuhyUBIXbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;实现核心逻辑&lt;/strong&gt;：在feignClient注入到spring容器之前，变更name&lt;/p&gt;&lt;p&gt;如果有看过spring-cloud-starter-openfeign的源码的朋友，应该就会知道openfeign通过FeignClientFactoryBean中的getObject()生成具体的客户端。因此我们在getObject托管给spring之前，把name换掉&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span data-mid=&quot;&quot;&gt;01&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;在API定义一个特殊变量来占位&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@FeignClient&lt;/span&gt;(name = &lt;span&gt;&quot;feign-provider-env&quot;&lt;/span&gt;,path = EchoService.INTERFACE_NAME)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;EchoFeignClient&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;EchoService&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;span&gt; env为特殊变量占位符&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span data-mid=&quot;&quot;&gt;02&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;通过spring后置器处理FeignClientFactoryBean的name&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FeignClientsServiceNameAppendBeanPostProcessor&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;BeanPostProcessor&lt;/span&gt;, &lt;span&gt;ApplicationContextAware&lt;/span&gt; , &lt;span&gt;EnvironmentAware&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; ApplicationContext applicationContext;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; Environment environment;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; AtomicInteger atomicInteger = &lt;span&gt;new&lt;/span&gt; AtomicInteger();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@SneakyThrows&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;postProcessAfterInitialization&lt;/span&gt;&lt;span&gt;(Object bean, String beanName)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; BeansException &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;if&lt;/span&gt;(atomicInteger.getAndIncrement() == &lt;span&gt;0&lt;/span&gt;){&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            String beanNameOfFeignClientFactoryBean = &lt;span&gt;&quot;org.springframework.cloud.openfeign.FeignClientFactoryBean&quot;&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            Class beanNameClz = Class.forName(beanNameOfFeignClientFactoryBean);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            applicationContext.getBeansOfType(beanNameClz).forEach((feignBeanName,beanOfFeignClientFactoryBean)-&amp;gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                    setField(beanNameClz,&lt;span&gt;&quot;name&quot;&lt;/span&gt;,beanOfFeignClientFactoryBean);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                    setField(beanNameClz,&lt;span&gt;&quot;url&quot;&lt;/span&gt;,beanOfFeignClientFactoryBean);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                    e.printStackTrace();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                System.out.println(feignBeanName + &lt;span&gt;&quot;--&amp;gt;&quot;&lt;/span&gt; + beanOfFeignClientFactoryBean);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            });&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setField&lt;/span&gt;&lt;span&gt;(Class clazz, String fieldName, Object obj)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception&lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        Field field = ReflectionUtils.findField(clazz, fieldName);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;if&lt;/span&gt;(Objects.nonNull(field)){&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            ReflectionUtils.makeAccessible(field);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            Object value = field.get(obj);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;if&lt;/span&gt;(Objects.nonNull(value)){&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                value = value.toString().replace(&lt;span&gt;&quot;env&quot;&lt;/span&gt;,environment.getProperty(&lt;span&gt;&quot;feign.env&quot;&lt;/span&gt;));&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                ReflectionUtils.setField(field, obj, value);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setEnvironment&lt;/span&gt;&lt;span&gt;(Environment environment)&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;this&lt;/span&gt;.environment = environment;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setApplicationContext&lt;/span&gt;&lt;span&gt;(ApplicationContext applicationContext)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; BeansException &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;this&lt;/span&gt;.applicationContext = applicationContext;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; 这边不能直接用FeignClientFactoryBean.class，因为FeignClientFactoryBean这个类的权限修饰符是default。因此得用反射。&lt;/p&gt;&lt;p&gt;其次只要是在bean注入到spring IOC之前提供的扩展点，都可以进行FeignClientFactoryBean的name替换，不一定得用BeanPostProcessor&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span data-mid=&quot;&quot;&gt;03&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;使用import注入&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Retention&lt;/span&gt;(RetentionPolicy.RUNTIME)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;@Target&lt;/span&gt;(ElementType.TYPE)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;@Documented&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;@Import&lt;/span&gt;(FeignClientsServiceNameAppendEnvConfig.class)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;public &lt;span&gt;@interface&lt;/span&gt; EnableAppendEnv2FeignServiceName {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span data-mid=&quot;&quot;&gt;04&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;在启动类上加上@EnableAppendEnv2FeignServiceName&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;03&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;后面朋友采用了第四种方案，主要这种方案相对其他三种方案改动比较小。&lt;/p&gt;&lt;p&gt;第四种方案朋友有个不解的地方，为啥要用import，直接在spring.factories配置自动装配，这样就不用在启动类上@EnableAppendEnv2FeignServiceName&lt;br/&gt;不然启动类上一堆@Enable看着恶心，哈哈。&lt;/p&gt;&lt;p&gt;我给的答案是开了一个显眼的@Enable，是为了让你更快知道我是怎么实现，他的回答是那还不如你直接告诉我怎么实现就好。我竟然无言以对。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;04&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;demo链接&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;https://github.com/lyb-geek/springboot-learning/tree/master/springboot-feign-servicename-route&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.025936599423631124&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibqicBWEiaFhaUkEs3YhX1fKvaBcTc3V7YooNTGXoXQEGE8V3BGstZA0g9OpLlWicaefuM0zBUvxG3mPIlLdP7vnYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;694&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>