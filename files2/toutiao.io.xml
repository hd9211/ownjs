<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>439d191b0f2b207cf79e985d5458f4ce</guid>
<title>什么是真正的程序员？| 码农周刊第 323 期</title>
<link>https://toutiao.io/k/v08ikpz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;issue&quot; id=&quot;readabilityBody&quot;&gt;
        &lt;h1&gt;什么是真正的程序员？| 码农周刊第 323 期&lt;/h1&gt;
        &lt;h2&gt;码农周刊第323期（2020-10-28）&lt;/h2&gt;
        &lt;p&gt;☞ &lt;a href=&quot;https://weekly.manong.io/bounce?nid=323&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3230&quot; target=&quot;_blank&quot;&gt;薪资翻番如何实现？程序员的涨薪秘诀&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;a href=&quot;https://weekly.manong.io/bounce?nid=323&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3230&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_321.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;small&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=323&amp;amp;aid=19185&amp;amp;url=https%3A%2F%2Fjinshuju.net%2Ff%2FV7DxN9&quot; target=&quot;_blank&quot;&gt;商务合作&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
        
        &lt;h3 id=&quot;程序设计&quot;&gt;程序设计&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;业界实战&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;VIP会员专区&quot;&gt;VIP会员专区&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;工作地点：成都 | 薪资：15-30K | 简历投递邮箱：xiexiaofang@huobi.com&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;适合入门&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;该框架由阿里云机器学习 PAI 团队研发，让自然语言处理场景的模型预训练和迁移学习开发与部署更加简单和高效。&lt;/p&gt;
        &lt;h3 id=&quot;工具资料&quot;&gt;工具资料&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;硬核&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;论文笔记&lt;/p&gt;
        
        &lt;p&gt;系列文章&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;因子分解机算法&lt;/p&gt;
        
        &lt;p&gt;深入讲解&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;Yahoo 开源的 Kafka 集群管理平台&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;更多可能&lt;/p&gt;
        
        &lt;p&gt;实战经验&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程语言&quot;&gt;编程语言&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;源码分析&lt;/p&gt;
        
        &lt;p&gt;一个 Android Jetpack 扩展库&lt;/p&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;一步步教你&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;倾向于使用 Less 或 Stylus&lt;/p&gt;
        &lt;h3 id=&quot;每周独家号推荐&quot;&gt;每周独家号推荐&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;这里有最接地气的架构师一线实战经验、核心技能的分享。运营和产品的总结。以及一些个人的深度思考。&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 268968 即可&lt;/p&gt;
        
        &lt;p&gt;GO PHP JS 一网打尽&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 146415 即可&lt;/p&gt;
        
        &lt;p&gt;分享技术，专注程序员成长&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 137785 即可&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;Coding虽易，debug不易....&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 98777 即可&lt;/p&gt;
        
        &lt;p&gt;专注分享Java实战技术、Java基础原理、微服务实战技术、分布式系统架构&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 22887 即可&lt;/p&gt;
        &lt;h3 id=&quot;每周一书&quot;&gt;每周一书&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;本书为对基本概率论感兴趣的读者以及之前未接触过此方向的人提供了一个坚实的基础。通过对话的方式和详细的数学推导，在迷人的风格和信息丰富的讨论上取得了平衡。欢迎到&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;兑换阅读。&lt;/p&gt;
        &lt;h3 id=&quot;编程之外&quot;&gt;编程之外&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;真实&lt;/p&gt;
        
        &lt;p&gt;值得思考&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;p&gt;
        &lt;/p&gt;
        
        
        
        
        &lt;div class=&quot;qrcode&quot;&gt;
  &lt;img src=&quot;https://img.toutiao.io/ads/vip_qrcode.png&quot; alt=&quot;Qrcode 258&quot;/&gt;&lt;span&gt;加入码农周刊VIP会员&lt;/span&gt;
&lt;/div&gt;
    &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>82f2cb1ca9eadc85ddf2773073692552</guid>
<title>DevOps 视角的前后端分离与实战</title>
<link>https://toutiao.io/k/k4sds4w</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                              &lt;strong class=&quot;profile_nickname&quot;&gt;腾云 CODING&lt;/strong&gt;
                              &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;微信号&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;coding_net&lt;/span&gt;
                              &lt;/p&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;功能介绍&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;CODING 提供给企业用户全套 DevOps 研发管理工具，包括项目管理，代码托管，持续集成，制品管理等功能，有效提高软件研发团队的代码质量和交付速度。&lt;/span&gt;
                              &lt;/p&gt;
                              
                          &lt;/div&gt;
                          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>046175068ffef38fbfd0f7dd84e3520d</guid>
<title>gRPC 初探与简单使用</title>
<link>https://toutiao.io/k/sekzpby</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.0374331550802138&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gf7zJ2NXUibEatLJbcDLrEklG7PpIJibibEZ243hQfTYAOnUKKO8WJGtNK0FtNOyibfohow3qklfpW5e7l6y8hXefA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;748&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;01&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;概念&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 gRPC 中，客户端应用程序可以直接在另一台计算机上的服务器应用程序上调用方法，就好像它是本地对象一样，从而使您更轻松地创建分布式应用程序和服务。与许多 RPC 系统一样，gRPC 围绕定义服务的思想，指定可通过其参数和返回类型远程调用的方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;gRPC 可以将 protocol buffers 用作其接口定义语言（IDL）和其基础消息交换格式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;service HelloService {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  rpc SayHello (HelloRequest) returns (HelloResponse);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;message HelloRequest {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  string greeting = 1;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;message HelloResponse {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  string reply = 1;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;02&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;gRPC 架构&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在服务器端，服务器实现此接口并运行 gRPC 服务器以处理客户端调用。在客户端，客户端具有一个存根（在某些语言中仅称为客户端），提供与服务器相同的方法。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4203125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gf7zJ2NXUibFTaTlpc0v4MiaG523h6CrVg4JLOJQf7yj1SEhLSyiakmdTPphXhpH1y9FPIpic5z7AlYYTvliaGDN9Hg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;从 Google 内部的服务器到您自己的计算机，gRPC 客户端和服务器都可以在各种环境中运行并相互通信，并且可以使用 gRPC 支持的任何语言编写。因此，例如，您可以使用 Go，Python 或 Ruby 的客户端轻松地用 Java 创建gRPC 服务器。此外，最新的 Google API 的接口将具有 gRPC 版本，可让您轻松地在应用程序中内置 Google 功能。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;关于 protocol buffers，可以阅读⎡&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4Mjc1NTMyOQ==&amp;amp;mid=2247483968&amp;amp;idx=1&amp;amp;sn=e899a0efca008b6d490b01fe203feb89&amp;amp;chksm=9f81a82ea8f621382190cbee9dc49260290a176bf3a6275c5b78824adb59ae40915c6ad2f63d&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Protobuf - 更小、更快、更简单的交互式数据语言&lt;/a&gt;⎦，此处不再赘述。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;gRPC 可以定义四种服务方法：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;1. 一元 RPC，客户端向服务器发送单个请求并获得单个响应，就像普通函数调用一样。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;rpc SayHello(HelloRequest) returns (HelloResponse);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;2. 服务器流式 RPC，客户端在其中向服务器发送请求，并获取流以读取回一系列消息。客户端从返回的流中读取，直到没有更多消息为止。gRPC 保证单个 RPC 调用中的消息顺序。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;3. 客户端流式RPC，客户端在其中编写一系列消息，然后再次使用提供的流将它们发送到服务器。客户端写完消息后，它将等待服务器读取消息并返回响应。gRPC再次保证了在单个RPC调用中的消息顺序。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;4. 双向流式RPC，双方都使用读写流发送一系列消息。这两个流是独立运行的，因此客户端和服务器可以按照自己喜欢的顺序进行读写：例如，服务器可以在写响应之前等待接收所有客户端消息，或者可以先读取消息再写入消息，或其他一些读写组合。每个流中的消息顺序都会保留。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;rpc BidiHello(stream HelloRequest) returns (stream HelloResponse);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;使用API&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;从 .proto 文件中的服务定义开始，gRPC 提供了protocol buffers 编译器插件，这些插件可生成客户端和服务器端代码。gRPC 用户通常在客户端调用这些 API，并在服务器端实现相应的 API。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;在服务器端，服务器实现服务声明的方法，并运行 gRPC 服务器来处理客户端调用。gRPC 基础结构解码传入的请求，执行服务方法，并对服务响应进行编码。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在客户端，客户端具有一个称为 stub 的本地对象（对于某些语言，首选术语是 client），该对象实现与服务相同的方法。然后，客户端可以只在本地对象上调用这些方法，将调用的参数包装在适当的 protocol buffers消息类型中- gRPC 再将请求发送到服务器并返回服务器的 protocol buffers 响应之后进行查找。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;同步与异步&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;阻塞的同步 RPC 调用直到从服务器收到响应为止是最接近 RPC 所追求的过程调用抽象的近似方法。另一方面，网络本质上是异步的，因此在许多情况下能够启动 RPC 而不阻塞当前线程很有用。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;03&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;RPC 生命周期&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;一元 RPC &lt;/span&gt;&lt;/strong&gt;- &lt;span&gt;最简单的 RPC 类型，其中客户端发送单个请求并返回单个响应。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;客户端调用存根方法后，会通知服务器已使用该调用的客户端元数据，方法名称和指定的期限（如果适用）来调用 RPC。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;然后，服务器可以立即发送自己的初始元数据（必须在发送任何响应之前发送），或者等待客户端的请求消息。首先发生的是特定于应用程序的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;服务器收到客户的请求消息后，它将完成创建和填充响应所必需的一切工作。然后将响应（如果成功）连同状态详细信息（状态代码和可选状态消息）以及可选尾随元数据一起返回（如果成功）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果响应状态为 OK，则客户端将获得响应，从而在客户端完成呼叫。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;服务器流式 RPC&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;服务器流式 RPC 与一元 RPC 相似，不同之处在于服务器响应客户端的请求返回消息流。发送所有消息后，服务器的状态详细信息（状态代码和可选状态消息）和可选尾随元数据将发送到客户端。这样就完成了服务器端的处理。客户端收到所有服务器的消息后即完成。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;客户端流式 RPC&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;客户端流式 RPC 与一元 RPC 相似，不同之处在于客户端将消息流发送到服务器而不是单个消息。服务器以一条消息（以及其状态详细信息和可选的尾随元数据）作为响应，通常（但不一定）是在它收到所有客户端的消息之后。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;双向流式RPC&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在双向流式 RPC 中，调用由客户端调用方法启动，服务器接收客户端元数据，方法名称和期限。服务器可以选择发回其初始元数据，也可以等待客户端开始流式传输消息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;客户端和服务器端流处理是特定于应用程序的。由于两个流是独立的，因此客户端和服务器可以按任何顺序读取和写入消息。例如，服务器可以等到收到客户端的所有消息后再写消息，或者服务器和客户端可以打“ping-pong” – 服务器收到请求，然后发回响应，然后客户端发送基于响应的另一个请求，依此类推。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;截止时间 / 超时&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;gRPC 允许客户端指定在 RPC 因 DEADLINE_EXCEEDED 错误终止之前，他们愿意等待 RPC 完成多长时间。在服务器端，服务器可以查询以查看特定的RPC 是否超时，或者还剩下多少时间来完成 RPC。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;指定期限或超时是特定于语言的：某些语言 API 按照超时（时间长度）工作，而某些语言 API 按照期限（固定时间点）工作，并且可能有也可能没有默认期限。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;RPC 终止&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 gRPC 中，客户端和服务器均对呼叫成功进行独立和本地确定，其结论可能不匹配。这意味着，例如，您可能拥有一个在服务器端成功完成 RPC 的RPC（“我已经发送了所有响应！”），但是在客户端却失败了（“响应在我的截止日期之后到达！”）。服务器也有可能在客户端发送所有请求之前决定完成。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;取消 RPC&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;客户端或服务器都可以随时取消 RPC。取消操作会立即终止 RPC，因此不再进行任何工作。并且取消之前所做的更改不会回滚。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;元数据&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;元数据是以键值对列表的形式提供的有关特定 RPC 调用的信息（例如身份验证详细信息），其中键是字符串，值通常是字符串，但可以是二进制数据。元数据对于 gRPC 本身是不透明的-它允许客户端向服务器提供与调用相关的信息，反之亦然。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对元数据的访问取决于语言。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;通道&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;gRPC 通道提供到指定主机和端口上的 gRPC 服务器的连接。创建客户端存根时使用。客户可以指定通道参数来修改 gRPC 的默认行为，例如打开或关闭消息压缩。通道具有状态，包括已连接和空闲。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;gRPC 如何处理关闭通道取决于语言。某些语言还允许查询通道状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;04&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Golang 语言中的 gPRC&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;准备工作&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;简单示例&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;RPC 应用的开发流程：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;编写.proto文件。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;使用 protoc 编译.proto文件，生成.go文件。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;编写服务器端代码。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;编写客户端代码。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;示例代码：&lt;/p&gt;&lt;p&gt;限于篇幅，示例代码可以点击「阅读原文」链接，访问 Github 阅读示例代码中只包含一元 RPC 和双向流 RPC。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.5405405405405406&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gf7zJ2NXUibHrBBNc13c09hsck0LRuBWagGRXUlOPE7Nto7kj7M5peJTpdZlgatE5HwOkQibCPDOjUC0FfcboIbA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;370&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;参考资料：&lt;/p&gt;&lt;p&gt;https://grpc.io/docs/&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;推荐阅读：&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4Mjc1NTMyOQ==&amp;amp;mid=2247483968&amp;amp;idx=1&amp;amp;sn=e899a0efca008b6d490b01fe203feb89&amp;amp;chksm=9f81a82ea8f621382190cbee9dc49260290a176bf3a6275c5b78824adb59ae40915c6ad2f63d&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Protobuf - 更小、更快、更简单的交互式数据语言&lt;/a&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e1d1c21d6e0c2ecdb8b9967e3c6e33c4</guid>
<title>Flink 面试题大全</title>
<link>https://toutiao.io/k/nrw0wqs</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section data-id=&quot;91525&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;概述&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;2019 年是大数据实时计算领域最不平凡的一年，2019 年 1 月阿里巴巴 Blink （内部的 Flink 分支版本）开源，大数据领域一夜间从 Spark 独步天下走向了两强争霸的时代。Flink 因为其天然的流式计算特性以及强大的处理性能成为炙手可热的大数据处理框架。&lt;/section&gt;&lt;section&gt;时至今日，Flink 已经发展到 1.9 版本，在大数据开发领域，面试中对于 Flink 的考察已经是大数据开发求职者必须面对的，本文结合自己作为面试官过程中的经验详细总结了近 50 个关于 Flink 的面试考察点。&lt;/section&gt;&lt;section&gt;在本文中，分为以下几个部分：&lt;/section&gt;&lt;section&gt;第一部分：Flink 中的核心概念和基础篇，包含了 Flink 的整体介绍、核心概念、算子等考察点。&lt;/section&gt;&lt;section&gt;第二部分：Flink 进阶篇，包含了 Flink 中的数据传输、容错机制、序列化、数据热点、反压等实际生产环境中遇到的问题等考察点。&lt;/section&gt;&lt;section&gt;第三部分：Flink 源码篇，包含了 Flink 的核心代码实现、Job 提交流程、数据交换、分布式快照机制、Flink SQL 的原理等考察点。&lt;/section&gt;&lt;h2&gt;第一部分：Flink 中的核心概念和基础考察&lt;/h2&gt;&lt;section&gt;&lt;span&gt;一、 简单介绍一下 Flink&lt;/span&gt;&lt;/section&gt;&lt;section&gt;Flink 是一个框架和分布式处理引擎，用于对无界和有界数据流进行有状态计算。并且 Flink 提供了数据分布、容错机制以及资源管理等核心功能。&lt;/section&gt;&lt;section&gt;&lt;span&gt;Flink提供了诸多高抽象层的API以便用户编写分布式任务：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;DataSet API， 对静态数据进行批处理操作，将静态数据抽象成分布式的数据集，用户可以方便地使用Flink提供的各种操作符对分布式数据集进行处理，支持Java、Scala和Python。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;DataStream API，对数据流进行流处理操作，将流式的数据抽象成分布式的数据流，用户可以方便地对分布式数据流进行各种操作，支持Java和Scala。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Table API，对结构化数据进行查询操作，将结构化数据抽象成关系表，并通过类SQL的DSL对关系表进行各种查询操作，支持Java和Scala。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;此外，Flink 还针对特定的应用领域提供了领域库，例如：&lt;/span&gt;&lt;span&gt; Flink ML，Flink 的机器学习库，提供了机器学习Pipelines API并实现了多种机器学习算法。&lt;/span&gt;&lt;span&gt; Gelly，Flink 的图计算库，提供了图计算的相关API及多种图计算算法实现。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;根据官网的介绍，Flink 的特性包含：&lt;/section&gt;&lt;pre&gt;&lt;section&gt;&lt;code&gt;支持高吞吐、低延迟、高性能的流处理&lt;br/&gt;支持带有事件时间的窗口 （Window） 操作&lt;br/&gt;支持有状态计算的 Exactly-once 语义&lt;br/&gt;支持高度灵活的窗口 （Window） 操作，支持基于 time、&lt;span&gt;count&lt;/span&gt;、session 以及 data-driven 的窗口操作&lt;br/&gt;支持具有 Backpressure 功能的持续流模型&lt;br/&gt;支持基于轻量级分布式快照（Snapshot）实现的容错&lt;br/&gt;一个运行时同时支持 Batch &lt;span&gt;on&lt;/span&gt; Streaming 处理和 Streaming 处理&lt;br/&gt;Flink 在 JVM 内部实现了自己的内存管理&lt;br/&gt;支持迭代计算&lt;br/&gt;支持程序自动优化：避免特定情况下 Shuffle、排序等昂贵操作，中间结果有必要进行缓存&lt;br/&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;二、 Flink 相比传统的 Spark Streaming 有什么区别?&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这个问题是一个非常宏观的问题，因为两个框架的不同点非常之多。&lt;/span&gt;&lt;span&gt;但是在面试时有非常重要的一点一定要回答出来：&lt;/span&gt;&lt;span&gt;Flink 是标准的实时处理引擎，基于事件驱动。而 Spark Streaming 是微批（Micro-Batch）的模型。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;下面我们就分几个方面介绍两个框架的主要区别：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1. 架构模型&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Spark Streaming 在运行时的主要角色包括：&lt;/span&gt;&lt;span&gt;Master、Worker、Driver、Executor，Flink 在运行时主要包含：&lt;/span&gt;&lt;span&gt;Jobmanager、Taskmanager和Slot。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2. 任务调度&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Spark Streaming 连续不断的生成微小的数据批次，构建有向无环图DAG，Spark Streaming 会依次创建 DStreamGraph、JobGenerator、JobScheduler。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Flink 根据用户提交的代码生成 StreamGraph，经过优化生成 JobGraph，然后提交给 JobManager进行处理，JobManager 会根据 JobGraph 生成 ExecutionGraph，ExecutionGraph 是 Flink 调度最核心的数据结构，JobManager 根据 ExecutionGraph 对 Job 进行调度。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3. 时间机制&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Spark Streaming 支持的时间机制有限，只支持&lt;span&gt;处理时间&lt;/span&gt;。&lt;/span&gt;&lt;span&gt; Flink 支持了流处理程序在时间上的三个定义：&lt;/span&gt;&lt;span&gt;&lt;span&gt;处理时间、事件时间、注入时间&lt;/span&gt;。&lt;/span&gt;&lt;span&gt;同时也支持 &lt;span&gt;watermark&lt;/span&gt; 机制来处理滞后数据。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4. 容错机制&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于 Spark Streaming 任务，我们可以设置 checkpoint，然后假如发生故障并重启，我们可以从上次 checkpoint 之处恢复，但是这个行为只能使得数据不丢失，可能会重复处理，不能做到恰好一次处理语义。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Flink 则使用两阶段提交协议来解决这个问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;三、 Flink 的组件栈有哪些？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;根据 Flink 官网描述，Flink 是一个分层架构的系统，每一层所包含的组件都提供了特定的抽象，用来服务于上层组件。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UdK9ByfMT2OKoDp7OuQQE0fccQQrNYXMcQyfq7HzfuHWQBXAt6RZn9Vz7zpFhYNdZxd4WkwicJictWlCBJHe1JOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.5915492957746479&quot; data-w=&quot;781&quot;/&gt;&lt;/p&gt;&lt;section&gt;图片来源于：https://flink.apache.org&lt;/section&gt;&lt;section&gt;自下而上，每一层分别代表：Deploy 层：该层主要涉及了Flink的部署模式，在上图中我们可以看出，Flink 支持包括local、Standalone、Cluster、Cloud等多种部署模式。Runtime 层：Runtime层提供了支持 Flink 计算的核心实现，比如：支持分布式 Stream 处理、JobGraph到ExecutionGraph的映射、调度等等，为上层API层提供基础服务。API层：API 层主要实现了面向流（Stream）处理和批（Batch）处理API，其中面向流处理对应DataStream API，面向批处理对应DataSet API，后续版本，Flink有计划将DataStream和DataSet API进行统一。Libraries层：该层称为Flink应用框架层，根据API层的划分，在API层之上构建的满足特定应用的实现计算框架，也分别对应于面向流处理和面向批处理两类。面向流处理支持：CEP（复杂事件处理）、基于SQL-like的操作（基于Table的关系操作）；面向批处理支持：FlinkML（机器学习库）、Gelly（图处理）。&lt;/section&gt;&lt;section&gt;&lt;span&gt;四、Flink 的运行必须依赖 Hadoop组件吗？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;Flink可以完全独立于Hadoop，在不依赖Hadoop组件下运行。但是做为大数据的基础设施，Hadoop体系是任何大数据框架都绕不过去的。Flink可以集成众多Hadooop 组件，例如Yarn、Hbase、HDFS等等。例如，Flink可以和Yarn集成做资源调度，也可以读写HDFS，或者利用HDFS做检查点。&lt;/section&gt;&lt;section&gt;&lt;span&gt;五、你们的Flink集群规模多大？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;大家注意，这个问题看起来是问你实际应用中的Flink集群规模，其实还隐藏着另一个问题：Flink可以支持多少节点的集群规模？&lt;/section&gt;&lt;section&gt;在回答这个问题时候，可以将自己生产环节中的集群规模、节点、内存情况说明，同时说明部署模式（一般是Flink on Yarn），除此之外，用户也可以同时在小集群（少于5个节点）和拥有 TB 级别状态的上千个节点上运行 Flink 任务。&lt;/section&gt;&lt;section&gt;&lt;span&gt;六、Flink的基础编程模型了解吗？&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UdK9ByfMT2OKoDp7OuQQE0fccQQrNYXMSv9LzyFwiahRxVS0U49iaH6vEhvNw8HOlbK4ibW787pThGMicydQ2atypA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.7835703001579779&quot; data-w=&quot;633&quot;/&gt;&lt;/p&gt;&lt;section&gt;上图是来自Flink官网的运行流程图。通过上图我们可以得知，Flink 程序的基本构建是数据输入来自一个 Source，Source 代表数据的输入端，经过 Transformation 进行转换，然后在一个或者多个Sink接收器中结束。数据流（stream）就是一组永远不会停止的数据记录流，而转换（transformation）是将一个或多个流作为输入，并生成一个或多个输出流的操作。执行时，Flink程序映射到 streaming dataflows，由流（streams）和转换操作（transformation operators）组成。&lt;/section&gt;&lt;section&gt;&lt;span&gt;七、Flink集群有哪些角色？各自有什么作用？&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UdK9ByfMT2OKoDp7OuQQE0fccQQrNYXM5dFneFZCBXORRSiaicl4vPnVRH57iaOvBjrwHq8QicXZ5oRcUjpoa2M4WA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.72375&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;section&gt;Flink 程序在运行时主要有 TaskManager，JobManager，Client三种角色。其中JobManager扮演着集群中的管理者Master的角色，它是整个集群的协调者，负责接收Flink Job，协调检查点，Failover 故障恢复等，同时管理Flink集群中从节点TaskManager。&lt;/section&gt;&lt;section&gt;TaskManager是实际负责执行计算的Worker，在其上执行Flink Job的一组Task，每个TaskManager负责管理其所在节点上的资源信息，如内存、磁盘、网络，在启动的时候将资源的状态向JobManager汇报。&lt;/section&gt;&lt;section&gt;Client是Flink程序提交的客户端，当用户提交一个Flink程序时，会首先创建一个Client，该Client首先会对用户提交的Flink程序进行预处理，并提交到Flink集群中处理，所以Client需要从用户提交的Flink程序配置中获取JobManager的地址，并建立到JobManager的连接，将Flink Job提交给JobManager。&lt;/section&gt;&lt;section&gt;&lt;span&gt;八、说说 Flink 资源管理中 Task Slot 的概念&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UdK9ByfMT2OKoDp7OuQQE0fccQQrNYXMPRlFygGWuGo0rcibAfNOYSe4NGUmlSqictx9ZuJia3CANxicuSSicpyzdKA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.37875&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;section&gt;在Flink架构角色中我们提到，TaskManager是实际负责执行计算的Worker，TaskManager 是一个 JVM 进程，并会以独立的线程来执行一个task或多个subtask。为了控制一个 TaskManager 能接受多少个 task，Flink 提出了 Task Slot 的概念。&lt;/section&gt;&lt;section&gt;简单的说，TaskManager会将自己节点上管理的资源分为不同的Slot：固定大小的资源子集。这样就避免了不同Job的Task互相竞争内存资源，但是需要主要的是，Slot只会做内存的隔离。没有做CPU的隔离。&lt;/section&gt;&lt;section&gt;&lt;span&gt;九、说说 Flink 的常用算子？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;Flink 最常用的常用算子包括：Map：DataStream → DataStream，输入一个参数产生一个参数，map的功能是对输入的参数进行转换操作。Filter：过滤掉指定条件的数据。KeyBy：按照指定的key进行分组。Reduce：用来进行结果汇总合并。Window：窗口函数，根据某些特性将每个key的数据进行分组（例如：在5s内到达的数据）&lt;/section&gt;&lt;section&gt;&lt;span&gt;十、说说你知道的Flink分区策略？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;什么要搞懂什么是分区策略。分区策略是用来决定数据如何发送至下游。目前 Flink 支持了8中分区策略的实现。&lt;/section&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UdK9ByfMT2OKoDp7OuQQE0fccQQrNYXM5XRH2ypxAAGkwt1iaJKelpYVC9jq2sMGaFFiaMH0X87KZcb6H3qkXBZA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.12625&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;section&gt;上图是整个Flink实现的分区策略继承图：&lt;/section&gt;&lt;section&gt;&lt;span&gt;GlobalPartitioner&lt;/span&gt; 数据会被分发到下游算子的第一个实例中进行处理。&lt;/section&gt;&lt;section&gt;&lt;span&gt;ShufflePartitioner&lt;/span&gt; 数据会被随机分发到下游算子的每一个实例中进行处理。&lt;/section&gt;&lt;section&gt;&lt;span&gt;RebalancePartitioner&lt;/span&gt; 数据会被循环发送到下游的每一个实例中进行处理。&lt;/section&gt;&lt;section&gt;&lt;span&gt;RescalePartitioner&lt;/span&gt; 这种分区器会根据上下游算子的并行度，循环的方式输出到下游算子的每个实例。这里有点难以理解，假设上游并行度为2，编号为A和B。下游并行度为4，编号为1，2，3，4。那么A则把数据循环发送给1和2，B则把数据循环发送给3和4。假设上游并行度为4，编号为A，B，C，D。下游并行度为2，编号为1，2。那么A和B则把数据发送给1，C和D则把数据发送给2。&lt;/section&gt;&lt;section&gt;&lt;span&gt;BroadcastPartitioner&lt;/span&gt; 广播分区会将上游数据输出到下游算子的每个实例中。适合于大数据集和小数据集做Jion的场景。&lt;/section&gt;&lt;section&gt;&lt;span&gt;ForwardPartitioner&lt;/span&gt; ForwardPartitioner 用于将记录输出到下游本地的算子实例。它要求上下游算子并行度一样。简单的说，ForwardPartitioner用来做数据的控制台打印。&lt;/section&gt;&lt;section&gt;&lt;span&gt;KeyGroupStreamPartitioner&lt;/span&gt; Hash分区器。会将数据按 Key 的 Hash 值输出到下游算子实例中。&lt;/section&gt;&lt;section&gt;&lt;span&gt;CustomPartitionerWrapper&lt;/span&gt; 用户自定义分区器。需要用户自己实现Partitioner接口，来定义自己的分区逻辑。例如：&lt;/section&gt;&lt;pre&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;classCustomPartitionerimplementsPartitioner&amp;lt;String&amp;gt; &lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;publicintpartition&lt;span&gt;(String key, int numPartitions)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;          &lt;span&gt;switch&lt;/span&gt; (key){&lt;br/&gt;              &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;1&quot;&lt;/span&gt;:&lt;br/&gt;                  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;              &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;2&quot;&lt;/span&gt;:&lt;br/&gt;                  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;              &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;3&quot;&lt;/span&gt;:&lt;br/&gt;                  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;;&lt;br/&gt;              &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;                  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;;&lt;br/&gt;          }&lt;br/&gt;      }&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;十一、Flink的并行度了解吗？Flink的并行度设置是怎样的？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Flink中的任务被分为多个并行任务来执行，其中每个并行的实例处理一部分数据。&lt;/span&gt;&lt;span&gt;这些并行实例的数量被称为并行度。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们在实际生产环境中可以从四个不同层面设置并行度：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;需要注意的优先级：&lt;/span&gt;&lt;span&gt;算子层面&amp;gt;环境层面&amp;gt;客户端层面&amp;gt;系统层面。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;十二、Flink的Slot和parallelism有什么区别？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;官网上十分经典的图：&lt;/section&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UdK9ByfMT2OKoDp7OuQQE0fccQQrNYXMVgSHLMa8pGKcpdLLQpyXlwQFZ0CX4cfsHUutONt2DsqyTdLrn6aL9Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.375&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;section&gt;slot是指taskmanager的并发执行能力，假设我们将 taskmanager.numberOfTaskSlots 配置为3 那么每一个 taskmanager 中分配3个 TaskSlot, 3个 taskmanager 一共有9个TaskSlot。&lt;/section&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UdK9ByfMT2OKoDp7OuQQE0fccQQrNYXMVhqjdpLSJTia5qQp8dzAb5KZTBMKmLKCnJfuibNkaicMJqYTeHqrb1New/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.29375&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;section&gt;parallelism是指taskmanager实际使用的并发能力。假设我们把 parallelism.default 设置为1，那么9个 TaskSlot 只能用1个，有8个空闲。&lt;/section&gt;&lt;section&gt;&lt;span&gt;十三、Flink有没有重启策略？说说有哪几种？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Flink 实现了多种重启策略。&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;固定延迟重启策略（Fixed Delay Restart Strategy）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;故障率重启策略（Failure Rate Restart Strategy）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;没有重启策略（No Restart Strategy）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Fallback重启策略（Fallback Restart Strategy）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;十四、用过Flink中的分布式缓存吗？如何使用？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Flink实现的分布式缓存和Hadoop有异曲同工之妙。&lt;/span&gt;&lt;span&gt;目的是在本地读取文件，并把他放在 taskmanager 节点中，防止task重复拉取。&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;section&gt;&lt;code&gt;val env = ExecutionEnvironment.getExecutionEnvironment&lt;br/&gt;&lt;br/&gt;// register &lt;span&gt;a&lt;/span&gt; &lt;span&gt;file&lt;/span&gt; from HDFS&lt;br/&gt;env.registerCachedFile(&lt;span&gt;&quot;hdfs:///path/to/your/file&quot;&lt;/span&gt;, &lt;span&gt;&quot;hdfsFile&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;// register &lt;span&gt;a&lt;/span&gt; local &lt;span&gt;executable&lt;/span&gt; &lt;span&gt;file&lt;/span&gt; (script, &lt;span&gt;executable&lt;/span&gt;, ...)&lt;br/&gt;env.registerCachedFile(&lt;span&gt;&quot;file:///path/to/exec/file&quot;&lt;/span&gt;, &lt;span&gt;&quot;localExecFile&quot;&lt;/span&gt;, true)&lt;br/&gt;&lt;br/&gt;// define your program &lt;span&gt;and&lt;/span&gt; &lt;span&gt;execute&lt;/span&gt;&lt;br/&gt;...&lt;br/&gt;val inpu&lt;span&gt;t:&lt;/span&gt; DataSet[String] = ...&lt;br/&gt;val resul&lt;span&gt;t:&lt;/span&gt; DataSet[Integer] = &lt;span&gt;input&lt;/span&gt;.&lt;span&gt;map&lt;/span&gt;(&lt;span&gt;new&lt;/span&gt; MyMapper())&lt;br/&gt;...&lt;br/&gt;env.&lt;span&gt;execute&lt;/span&gt;()&lt;br/&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;十五、说说Flink中的广播变量，使用时需要注意什么？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;我们知道Flink是并行的，计算过程可能不在一个 Slot 中进行，那么有一种情况即：当我们需要访问同一份数据。那么Flink中的广播变量就是为了解决这种情况。&lt;/section&gt;&lt;section&gt;我们可以把广播变量理解为是一个公共的共享变量，我们可以把一个dataset 数据集广播出去，然后不同的task在节点上都能够获取到，这个数据在每个节点上只会存在一份。&lt;/section&gt;&lt;section&gt;&lt;span&gt;十六、说说Flink中的窗口？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;来一张官网经典的图：&lt;/section&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UdK9ByfMT2OKoDp7OuQQE0fccQQrNYXMyJVRJPiaXBOe9VrPRZYqSKnb7EoPkFZ6ljB5ZJf7I4v5A6TveWNDDwA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.6175&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;section&gt;Flink 支持两种划分窗口的方式，按照time和count。如果根据时间划分窗口，那么它就是一个time-window 如果根据数据划分窗口，那么它就是一个count-window。&lt;/section&gt;&lt;section&gt;flink支持窗口的两个重要属性（size和interval）&lt;/section&gt;&lt;section&gt;如果size=interval,那么就会形成tumbling-window(无重叠数据) 如果size&amp;gt;interval,那么就会形成sliding-window(有重叠数据) 如果size&amp;lt; interval, 那么这种窗口将会丢失数据。比如每5秒钟，统计过去3秒的通过路口汽车的数据，将会漏掉2秒钟的数据。&lt;/section&gt;&lt;section&gt;&lt;span&gt;通过组合可以得出四种基本窗口：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;time-tumbling-window 无重叠数据的时间窗口，设置方式举例：&lt;/span&gt;&lt;span&gt;timeWindow(Time.seconds(5))&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;time-sliding-window 有重叠数据的时间窗口，设置方式举例：&lt;/span&gt;&lt;span&gt;timeWindow(Time.seconds(5), Time.seconds(3))&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;count-tumbling-window无重叠数据的数量窗口，设置方式举例：&lt;/span&gt;&lt;span&gt;countWindow(5)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;count-sliding-window 有重叠数据的数量窗口，设置方式举例：&lt;/span&gt;&lt;span&gt;countWindow(5,3)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;十七、说说Flink中的状态存储？&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;Flink在做计算的过程中经常需要存储中间状态，来避免数据丢失和状态恢复。选择的状态存储策略不同，会影响状态持久化如何和 checkpoint 交互。&lt;/section&gt;&lt;section&gt;Flink提供了三种状态存储方式：MemoryStateBackend、FsStateBackend、RocksDBStateBackend。&lt;/section&gt;&lt;section&gt;&lt;span&gt;十八、Flink 中的时间有哪几类&lt;/span&gt;&lt;/section&gt;&lt;section&gt;Flink 中的时间和其他流式计算系统的时间一样分为三类：事件时间，摄入时间，处理时间三种。&lt;/section&gt;&lt;section&gt;如果以 EventTime 为基准来定义时间窗口将形成EventTimeWindow,要求消息本身就应该携带EventTime。如果以 IngesingtTime 为基准来定义时间窗口将形成 IngestingTimeWindow,以 source 的systemTime为准。如果以 ProcessingTime 基准来定义时间窗口将形成 ProcessingTimeWindow，以 operator 的systemTime 为准。&lt;/section&gt;&lt;section&gt;&lt;span&gt;十九、Flink 中水印是什么概念，起到什么作用？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Watermark 是 Apache Flink 为了处理 EventTime 窗口计算提出的一种机制, 本质上是一种时间戳。&lt;/span&gt;&lt;span&gt; 一般来讲Watermark经常和Window一起被用来处理乱序事件。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;二十、Flink Table &amp;amp; SQL 熟悉吗？TableEnvironment这个类有什么作用&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;TableEnvironment是Table API和SQL集成的核心概念。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这个类主要用来：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;二十、Flink SQL的实现原理是什么？是如何实现 SQL 解析的呢？&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;首先大家要知道 Flink 的SQL解析是基于Apache Calcite这个开源框架。&lt;/section&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UdK9ByfMT2OKoDp7OuQQE0fccQQrNYXMFEU6zxQCVb1AjPC2aOPh9nwLQhqvAntXFA5eKuZVZibJBibefNCRjiavw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.63125&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;基于此，一次完整的SQL解析过程如下：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;用户使用对外提供Stream SQL的语法开发业务应用&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;用calcite对StreamSQL进行语法检验，语法检验通过后，转换成calcite的逻辑树节点；&lt;/span&gt;&lt;span&gt;最终形成calcite的逻辑计划&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;采用Flink自定义的优化规则和calcite火山模型、启发式模型共同对逻辑树进行优化，生成最优的Flink物理计划&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对物理计划采用janino codegen生成代码，生成用低阶API DataStream 描述的流应用，提交到Flink平台执行&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;第二部分：Flink 面试进阶篇&lt;/h2&gt;&lt;section&gt;&lt;span&gt;一、Flink是如何支持批流一体的？&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UdK9ByfMT2OKoDp7OuQQE0fccQQrNYXMyAoEBdQjAFLPIdOzImibKDS521iakbT5nokTm1etxOw0ZLoeAE0d5pRg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.79625&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;section&gt;本道面试题考察的其实就是一句话：Flink的开发者认为批处理是流处理的一种特殊情况。批处理是有限的流处理。Flink 使用一个引擎支持了DataSet API 和 DataStream API。&lt;/section&gt;&lt;section&gt;&lt;span&gt;二、Flink是如何做到高效的数据交换的？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;在一个Flink Job中，数据需要在不同的task中进行交换，整个数据交换是有 TaskManager 负责的，TaskManager 的网络组件首先从缓冲buffer中收集records，然后再发送。Records 并不是一个一个被发送的，二是积累一个批次再发送，batch 技术可以更加高效的利用网络资源。&lt;/section&gt;&lt;section&gt;&lt;span&gt;三、Flink是如何做容错的？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;Flink 实现容错主要靠强大的CheckPoint机制和State机制。Checkpoint 负责定时制作分布式快照、对程序中的状态进行备份；State 用来存储计算过程中的中间状态。&lt;/section&gt;&lt;section&gt;&lt;span&gt;四、Flink 分布式快照的原理是什么？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;Flink的分布式快照是根据Chandy-Lamport算法量身定做的。简单来说就是持续创建分布式数据流及其状态的一致快照。&lt;/section&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UdK9ByfMT2OKoDp7OuQQE0fccQQrNYXMDlHuFjGJ2TJRMSKamciaqEPDkVqu1m39ko56CnU3DEqiblXDkzuBnx6w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.32375&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;section&gt;核心思想是在 input source 端插入 barrier，控制 barrier 的同步来实现 snapshot 的备份和 exactly-once 语义。&lt;/section&gt;&lt;section&gt;&lt;span&gt;五、Flink 是如何保证Exactly-once语义的？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Flink通过实现两阶段提交和状态保存来实现端到端的一致性语义。&lt;/span&gt;&lt;span&gt; 分为以下几个步骤：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;开始事务（beginTransaction）创建一个临时文件夹，来写把数据写入到这个文件夹里面&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;预提交（preCommit）将内存中缓存的数据写入文件并关闭&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;正式提交（commit）将之前写完的临时文件放入目标目录下。&lt;/span&gt;&lt;span&gt;这代表着最终的数据会有一些延迟&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;丢弃（abort）丢弃临时文件&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;若失败发生在预提交成功后，正式提交前。&lt;/span&gt;&lt;span&gt;可以根据&lt;/span&gt;状态来提交预提交的数据，也可删除预提交的数据。&lt;/section&gt;&lt;section&gt;&lt;span&gt;六、Flink 的 kafka 连接器有什么特别的地方？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;Flink源码中有一个独立的connector模块，所有的其他connector都依赖于此模块，Flink 在1.9版本发布的全新kafka连接器，摒弃了之前连接不同版本的kafka集群需要依赖不同版本的connector这种做法，只需要依赖一个connector即可。&lt;/section&gt;&lt;section&gt;&lt;span&gt;七、说说 Flink的内存管理是如何做的?&lt;/span&gt;&lt;/section&gt;&lt;section&gt;Flink 并不是将大量对象存在堆上，而是将对象都序列化到一个预分配的内存块上。此外，Flink大量的使用了堆外内存。如果需要处理的数据超出了内存限制，则会将部分数据存储到硬盘上。Flink 为了直接操作二进制数据实现了自己的序列化框架。&lt;/section&gt;&lt;section&gt;&lt;span&gt;理论上Flink的内存管理分为三部分：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Network Buffers：&lt;/span&gt;&lt;span&gt;这个是在TaskManager启动的时候分配的，这是一组用于缓存网络数据的内存，每个块是32K，默认分配2048个，可以通过“taskmanager.network.numberOfBuffers”修改&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Memory Manage pool：&lt;/span&gt;&lt;span&gt;大量的Memory Segment块，用于运行时的算法（Sort/Join/Shuffle等），这部分启动的时候就会分配。&lt;/span&gt;&lt;span&gt;下面这段代码，根据配置文件中的各种参数来计算内存的分配方法。&lt;/span&gt;&lt;span&gt;（heap or off-heap，这个放到下节谈），内存的分配支持预分配和lazy load，默认懒加载的方式。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;User Code，这部分是除了Memory Manager之外的内存用于User code和TaskManager本身的数据结构。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;八、说说 Flink的序列化如何做的?&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;Java本身自带的序列化和反序列化的功能，但是辅助信息占用空间比较大，在序列化对象时记录了过多的类信息。&lt;/section&gt;&lt;section&gt;Apache Flink摒弃了Java原生的序列化方法，以独特的方式处理数据类型和序列化，包含自己的类型描述符，泛型类型提取和类型序列化框架。&lt;/section&gt;&lt;section&gt;&lt;span&gt;TypeInformation 是所有类型描述符的基类。&lt;/span&gt;&lt;span&gt;它揭示了该类型的一些基本属性，并且可以生成序列化器。&lt;/span&gt;&lt;span&gt;TypeInformation 支持以下几种类型：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;BasicTypeInfo: 任意Java 基本类型或 String 类型&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;BasicArrayTypeInfo: 任意Java基本类型数组或 String 数组&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;WritableTypeInfo: 任意 Hadoop Writable 接口的实现类&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;TupleTypeInfo: 任意的 Flink Tuple 类型(支持Tuple1 to Tuple25)。&lt;/span&gt;&lt;span&gt;Flink tuples 是固定长度固定类型的Java Tuple实现&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;CaseClassTypeInfo: 任意的 Scala CaseClass(包括 Scala tuples)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;PojoTypeInfo: 任意的 POJO (Java or Scala)，例如，Java对象的所有成员变量，要么是 public 修饰符定义，要么有 getter/setter 方法&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;GenericTypeInfo: 任意无法匹配之前几种类型的类&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;针对前六种类型数据集，Flink皆可以自动生成对应的TypeSerializer，能非常高效地对数据集进行序列化和反序列化。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;九、 Flink中的Window出现了数据倾斜，你有什么解决办法？&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;window产生数据倾斜指的是数据在不同的窗口内堆积的数据量相差过多。&lt;/span&gt;&lt;span&gt;本质上产生这种情况的原因是数据源头发送的数据量速度不同导致的。&lt;/span&gt;&lt;span&gt;出现这种情况一般通过两种方式来解决：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;十、 Flink中在使用聚合函数 GroupBy、Distinct、KeyBy 等函数时出现数据热点该如何解决？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;数据倾斜和数据热点是所有大数据框架绕不过去的问题。&lt;/span&gt;&lt;span&gt;处理这类问题主要从3个方面入手：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;例如一个假设订单场景，北京和上海两个城市订单量增长几十倍，其余城市的数据量不变。&lt;/span&gt;&lt;span&gt;这时候我们在进行聚合的时候，北京和上海就会出现数据堆积，我们可以单独数据北京和上海的数据。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;把热key进行拆分，比如上个例子中的北京和上海，可以把北京和上海按照地区进行拆分聚合。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Flink 1.9.0 SQL(Blink Planner) 性能优化中一项重要的改进就是升级了微批模型，即 MiniBatch。&lt;/span&gt;&lt;span&gt;原理是缓存一定的数据后再触发处理，以减少对State的访问，从而提升吞吐和减少数据的输出量。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;十一、Flink任务延迟高，想解决这个问题，你会如何入手？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在Flink的后台任务管理中，我们可以看到Flink的哪个算子和task出现了反压。&lt;/span&gt;&lt;span&gt;最主要的手段是资源调优和算子调优。&lt;/span&gt;&lt;span&gt;资源调优即是对作业中的Operator的并发数（parallelism）、CPU（core）、堆内存（heap_memory）等参数进行调优。&lt;/span&gt;&lt;span&gt;作业参数调优包括：&lt;/span&gt;&lt;span&gt;并行度的设置，State的设置，checkpoint的设置。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;十二、Flink是如何处理反压的？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Flink 内部是基于 producer-consumer 模型来进行消息传递的，Flink的反压设计也是基于这个模型。&lt;/span&gt;&lt;span&gt;Flink 使用了高效有界的分布式阻塞队列，就像 Java 通用的阻塞队列（BlockingQueue）一样。&lt;/span&gt;&lt;span&gt;下游消费者消费变慢，上游就会受到阻塞。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;十三、Flink的反压和Strom有哪些不同？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Storm 是通过监控 Bolt 中的接收队列负载情况，如果超过高水位值就会将反压信息写到 Zookeeper ，Zookeeper 上的 watch 会通知该拓扑的所有 Worker 都进入反压状态，最后 Spout 停止发送 tuple。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Flink中的反压使用了高效有界的分布式阻塞队列，下游消费变慢会导致发送端阻塞。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;二者最大的区别是Flink是逐级反压，而Storm是直接从源头降速。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;十四、 Operator Chains（算子链）这个概念你了解吗？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了更高效地分布式执行，Flink会尽可能地将operator的subtask链接（chain）在一起形成task。&lt;/span&gt;&lt;span&gt;每个task在一个线程中执行。&lt;/span&gt;&lt;span&gt;将operators链接成task是非常有效的优化：&lt;/span&gt;&lt;span&gt;它能减少线程之间的切换，减少消息的序列化/反序列化，减少数据在缓冲区的交换，减少了延迟的同时提高整体的吞吐量。&lt;/span&gt;&lt;span&gt;这就是我们所说的算子链。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;十五、 Flink什么情况下才会把Operator chain在一起形成算子链？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;两个operator chain在一起的的条件：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;上下游的并行度一致&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;下游节点的入度为1 （也就是说下游节点没有来自其他节点的输入）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;上下游节点都在同一个 slot group 中（下面会解释 slot group）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;下游节点的 chain 策略为 ALWAYS（可以与上下游链接，map、flatmap、filter等默认是ALWAYS）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;上游节点的 chain 策略为 ALWAYS 或 HEAD（只能与下游链接，不能与上游链接，Source默认是HEAD）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;两个节点间数据分区方式是 forward（参考理解数据流的分区）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;用户没有禁用 chain&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;十六、 说说Flink1.9的新特性？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;十七、消费kafka数据的时候，如何处理脏数据？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;可以在处理前加一个fliter算子，将不符合规则的数据过滤出去。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;第三部分：Flink 面试源码篇&lt;/h2&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;一、Flink Job的提交流程 &lt;/span&gt;用户提交的Flink Job会被转化成一个DAG任务运行，分别是：&lt;/span&gt;&lt;span&gt;StreamGraph、JobGraph、ExecutionGraph，Flink中JobManager与TaskManager，JobManager与Client的交互是基于Akka工具包的，是通过消息驱动。&lt;/span&gt;&lt;span&gt;整个Flink Job的提交还包含着ActorSystem的创建，JobManager的启动，TaskManager的启动和注册。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;二、Flink所谓&quot;三层图&quot;结构是哪几个&quot;图&quot;？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一个Flink任务的DAG生成计算图大致经历以下三个过程：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;StreamGraph 最接近代码所表达的逻辑层面的计算拓扑结构，按照用户代码的执行顺序向StreamExecutionEnvironment添加StreamTransformation构成流式图。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;JobGraph 从StreamGraph生成，将可以串联合并的节点进行合并，设置节点之间的边，安排资源共享slot槽位和放置相关联的节点，上传任务所需的文件，设置检查点配置等。&lt;/span&gt;&lt;span&gt;相当于经过部分初始化和优化处理的任务图。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;ExecutionGraph 由JobGraph转换而来，包含了任务具体执行所需的内容，是最贴近底层实现的执行图。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;三、JobManger在集群中扮演了什么角色？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;JobManager 负责整个 Flink 集群任务的调度以及资源的管理，从客户端中获取提交的应用，然后根据集群中 TaskManager 上 TaskSlot 的使用情况，为提交的应用分配相应的 TaskSlot 资源并命令 TaskManager 启动从客户端中获取的应用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;JobManager 相当于整个集群的 Master 节点，且整个集群有且只有一个活跃的 JobManager ，负责整个集群的任务管理和资源管理。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;JobManager 和 TaskManager 之间通过 Actor System 进行通信，获取任务执行的情况并通过 Actor System 将应用的任务执行情况发送给客户端。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;同时在任务执行的过程中，Flink JobManager 会触发 Checkpoint 操作，每个 TaskManager 节点 收到 Checkpoint 触发指令后，完成 Checkpoint 操作，所有的 Checkpoint 协调过程都是在 Fink JobManager 中完成。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当任务完成后，Flink 会将任务执行的信息反馈给客户端，并且释放掉 TaskManager 中的资源以供下一次提交任务使用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;四、JobManger在集群启动过程中起到什么作用？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;JobManager的职责主要是接收Flink作业，调度Task，收集作业状态和管理TaskManager。&lt;/span&gt;&lt;span&gt;它包含一个Actor，并且做如下操作：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;RegisterTaskManager: 它由想要注册到JobManager的TaskManager发送。&lt;/span&gt;&lt;span&gt;注册成功会通过AcknowledgeRegistration消息进行Ack。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;SubmitJob: 由提交作业到系统的Client发送。&lt;/span&gt;&lt;span&gt;提交的信息是JobGraph形式的作业描述信息。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;CancelJob: 请求取消指定id的作业。&lt;/span&gt;&lt;span&gt;成功会返回CancellationSuccess，否则返回CancellationFailure。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;UpdateTaskExecutionState: 由TaskManager发送，用来更新执行节点(ExecutionVertex)的状态。&lt;/span&gt;&lt;span&gt;成功则返回true，否则返回false。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;RequestNextInputSplit: TaskManager上的Task请求下一个输入split，成功则返回NextInputSplit，否则返回null。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;JobStatusChanged：&lt;/span&gt;&lt;span&gt; 它意味着作业的状态(RUNNING, CANCELING, FINISHED,等)发生变化。&lt;/span&gt;&lt;span&gt;这个消息由ExecutionGraph发送。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;五、TaskManager在集群中扮演了什么角色？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;TaskManager 相当于整个集群的 Slave 节点，负责具体的任务执行和对应任务在每个节点上的资源申请和管理。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;客户端通过将编写好的 Flink 应用编译打包，提交到 JobManager，然后 JobManager 会根据已注册在 JobManager 中 TaskManager 的资源情况，将任务分配给有资源的 TaskManager节点，然后启动并运行任务。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;TaskManager 从 JobManager 接收需要部署的任务，然后使用 Slot 资源启动 Task，建立数据接入的网络连接，接收数据并开始数据处理。&lt;/span&gt;&lt;span&gt;同时 TaskManager 之间的数据交互都是通过数据流的方式进行的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;可以看出，Flink 的任务运行其实是采用多线程的方式，这和 MapReduce 多 JVM 进行的方式有很大的区别，Flink 能够极大提高 CPU 使用效率，在多个任务和 Task 之间通过 TaskSlot 方式共享系统资源，每个 TaskManager 中通过管理多个 TaskSlot 资源池进行对资源进行有效管理。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;六、TaskManager在集群启动过程中起到什么作用？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;TaskManager的启动流程较为简单：&lt;/span&gt;&lt;span&gt; 启动类：&lt;/span&gt;&lt;span&gt;org.apache.flink.runtime.taskmanager.TaskManager 核心启动方法 ：&lt;/span&gt;&lt;span&gt; selectNetworkInterfaceAndRunTaskManager 启动后直接向JobManager注册自己，注册完成后，进行部分模块的初始化。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;七、Flink 计算资源的调度是如何实现的？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;TaskManager中最细粒度的资源是Task slot，代表了一个固定大小的资源子集，每个TaskManager会将其所占有的资源平分给它的slot。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;通过调整 task slot 的数量，用户可以定义task之间是如何相互隔离的。&lt;/span&gt;&lt;span&gt;每个 TaskManager 有一个slot，也就意味着每个task运行在独立的 JVM 中。&lt;/span&gt;&lt;span&gt;每个 TaskManager 有多个slot的话，也就是说多个task运行在同一个JVM中。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;而在同一个JVM进程中的task，可以共享TCP连接（基于多路复用）和心跳消息，可以减少数据的网络传输，也能共享一些数据结构，一定程度上减少了每个task的消耗。&lt;/span&gt;&lt;span&gt; 每个slot可以接受单个task，也可以接受多个连续task组成的pipeline，如下图所示，FlatMap函数占用一个taskslot，而key Agg函数和sink函数共用一个taskslot：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UdK9ByfMT2OKoDp7OuQQE0fccQQrNYXMgSf0RBtFFwETL4Oq5xy3wId4baJGCtM0ibe6oCxgGAeIEBib5Kib8O74A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.35125&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;八、简述Flink的数据抽象及数据交换过程？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Flink 为了避免JVM的固有缺陷例如java对象存储密度低，FGC影响吞吐和响应等，实现了自主管理内存。&lt;/span&gt;&lt;span&gt;MemorySegment就是Flink的内存抽象。&lt;/span&gt;&lt;span&gt;默认情况下，一个MemorySegment可以被看做是一个32kb大的内存块的抽象。&lt;/span&gt;&lt;span&gt;这块内存既可以是JVM里的一个byte[]，也可以是堆外内存（DirectByteBuffer）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在MemorySegment这个抽象之上，Flink在数据从operator内的数据对象在向TaskManager上转移，预备被发给下个节点的过程中，使用的抽象或者说内存对象是Buffer。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对接从Java对象转为Buffer的中间对象是另一个抽象StreamRecord。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;九、Flink 中的分布式快照机制是如何实现的？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Flink的容错机制的核心部分是制作分布式数据流和操作算子状态的一致性快照。&lt;/span&gt;&lt;span&gt; 这些快照充当一致性checkpoint，系统可以在发生故障时回滚。&lt;/span&gt;&lt;span&gt; Flink用于制作这些快照的机制在“分布式数据流的轻量级异步快照”中进行了描述。&lt;/span&gt;&lt;span&gt; 它受到分布式快照的标准Chandy-Lamport算法的启发，专门针对Flink的执行模型而定制。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UdK9ByfMT2OKoDp7OuQQE0fccQQrNYXM0DcyyS7succVwHWDLEDZc6bG21yrG1I4kSLWnRebVdy7foc5IWT7tA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.30618401206636503&quot; data-w=&quot;663&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;barriers在数据流源处被注入并行数据流中。&lt;/span&gt;&lt;span&gt;快照n的barriers被插入的位置（我们称之为Sn）是快照所包含的数据在数据源中最大位置。&lt;/span&gt;&lt;span&gt;例如，在Apache Kafka中，此位置将是分区中最后一条记录的偏移量。&lt;/span&gt;&lt;span&gt; 将该位置Sn报告给checkpoint协调器（Flink的JobManager）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;然后barriers向下游流动。&lt;/span&gt;&lt;span&gt;当一个中间操作算子从其所有输入流中收到快照n的barriers时，它会为快照n发出barriers进入其所有输出流中。&lt;/span&gt;&lt;span&gt; 一旦sink操作算子（流式DAG的末端）从其所有输入流接收到barriers n，它就向checkpoint协调器确认快照n完成。&lt;/span&gt;&lt;span&gt;在所有sink确认快照后，意味快照着已完成。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一旦完成快照n，job将永远不再向数据源请求Sn之前的记录，因为此时这些记录（及其后续记录）将已经通过整个数据流拓扑，也即是已经被处理结束。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;十、简单说说FlinkSQL的是如何实现的？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Flink 将 SQL 校验、SQL 解析以及 SQL 优化交给了Apache Calcite。&lt;/span&gt;&lt;span&gt;Calcite 在其他很多开源项目里也都应用到了，譬如 Apache Hive, Apache Drill, Apache Kylin, Cascading。&lt;/span&gt;&lt;span&gt;Calcite 在新的架构中处于核心的地位，如下图所示。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UdK9ByfMT2OKoDp7OuQQE0fccQQrNYXMFY0dSU2hAUq4DiceqIcOpB1BgibvPw3sE2BnCU3zWVBtqwpsjgdP0xpw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.6460587326120556&quot; data-w=&quot;647&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;构建抽象语法树的事情交给了 Calcite 去做。&lt;/span&gt;&lt;span&gt;SQL query 会经过 Calcite 解析器转变成 SQL 节点树，通过验证后构建成 Calcite 的抽象语法树（也就是图中的 Logical Plan）。&lt;/span&gt;&lt;span&gt;另一边，Table API 上的调用会构建成 Table API 的抽象语法树，并通过 Calcite 提供的 RelBuilder 转变成 Calcite 的抽象语法树。&lt;/span&gt;&lt;span&gt;然后依次被转换成逻辑执行计划和物理执行计划。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在提交任务后会分发到各个 TaskManager 中运行，在运行时会使用 Janino 编译器编译代码后运行。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;--end--&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;扫描下方二维码&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;添加好友，备注【&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;交流群&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;】&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;拉你到学习路线和资源丰富的交流群&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.0037037037037038&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/W5ic5oJ9K6NIVt837iblHR65hQafEE29ia1HE3z19iaZthwgcMhkiaEcxSkycZJYBPAVagvibdZICavZ5ovvScz8Wibuw/640?wx_fmt=jpeg&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c6c48f0b7cee176078b86632a7a550ea</guid>
<title>React hooks 最佳实践（更新中）</title>
<link>https://toutiao.io/k/azz9nmu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94785&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-bcless=&quot;darken&quot; data-brushtype=&quot;text&quot;&gt;导语&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;随着目前需求更新的节奏越来越快，我们目前更多时候原因使用 function component 来代替类的写法，在 hooks 推出之后，我们也可以完全使用 function component 来代替类的写法；但是俗话说的好，没有什么东西是十全十美的，在本次整理总结 hooks 库的过程中，有体验到 hooks 带来的体验提升，同时也存在对比类生命周期写法中不足的地方。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;98953&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;01&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;React hooks的思想&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先对于原先的类组件而言，最好的思想是封装，我们使用的constructor、componentDidMount都是继承自React的方法，这样做相对于hooks来说的好处是，我们的每一个组件对于我们来说都是可预见的，这样我们在写每个组件的时候也都是在这个思路上进行开发的，很显然，这样一种方式带来的不便就是我们每个组件的开发成本太高，组件其中如果有涉及到某个生命周期的逻辑，我们也不便将它抽离出来复用。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;使用 hooks 彻底改变了上面这种模式 —— 将一个生命周期钩子的集合变成了一个从头到尾即插即用的模式，从某种意义上来说，我们的组件设计更加灵活了。&lt;/span&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;98953&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;02&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;基本原则&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;1.尽量设计简单的hooks&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;hooks 设计的初衷就是为了使开发更加快捷简便，因此在使用hooks 的时候，我们不应该吝啬使用较多的hooks，例如我们处理不同状态对应不同逻辑的时候，按照写class的逻辑，我们经常会在一个生命周期函数里写下多个逻辑，并用if区分；在写hooks的时候，因为没有shouldComponentUpdate这类的生命周期函数，我们应该将他们分离开，将他们写在不同的useEffect里或者用不同的useCallback包起来，所依赖的变量，也要尽可能的与逻辑相关联，这样可以尽可能的避免性能损耗和bug的产出。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;2.注意hooks内部的逻辑&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;主要是官网提到的两个原则https://reactjs.org/docs/hooks-rules.html#explanation，这里涉及到hooks的一个很重要的概念就是顺序（order），在每次我们定义钩子函数的时候，react都会按照顺序将他们存在一个“栈”中，类似&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.30820610687022904&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCsQibve1IKbRnDys56FdibNCqkhlTaYbrzZsibSzNiaU5SOzLy9fzEn5UJ6LjxCWPiaXicpcsVIU6roeezA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1048&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果这时候，我们进行了某种操作，将其中一个钩子函数放到了if语句中，例如我们将firstName设置为仅在初次渲染，那么会造成这种情况：第一次渲染的时候正常，但是在第二次渲染的时候，执行到的第一个钩子函数是：&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;lastName&lt;span&gt;,&lt;/span&gt; setLastName&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;useState&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&lt;span&gt;&#x27;yeyung&#x27;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;这时候，react会去执行顶层的栈中的方法，也就是我们后续的操作都往前挪了一位。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3516699410609037&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCsQibve1IKbRnDys56FdibNCqibHicRicjEuOpJkbicO2GXkjGSBz4c2PQ1ZhEX1kb0hibib5mbBaGhXwRWZg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1018&quot;/&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;98953&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;03&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;初始化&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;通常情况，我们使用 useState 来创建一个带有状态的变量，这个钩子函数返回一个状态变量和一个setter，当我们调用setter函数的时候，render函数会重新执行；这里有一个常见的问题，使用多个state或者合并成一个state？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这个问题的产生来自于编写useSetState的时候所做的思考，按照之前写class的经验，显然将所有状态写在一起更加方便也更加好管理，但是，显然hooks并不是class，事实上，这里的setter函数的机制也和setState不一样，setState是把更新的字段合并到 this.state 中，而hooks中的setter则是直接替换，所以如果我们这里将所有的状态变量放在一个state中，显然违背了更方便维护的初衷。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是也并不是将state分离的越细越好，看一下这个例子: &lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;left&lt;span&gt;,&lt;/span&gt; setLeft&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;useState&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;right&lt;span&gt;,&lt;/span&gt; setRight&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;useState&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;el&lt;span&gt;.&lt;/span&gt;&lt;span&gt;addEventListener&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&#x27;mousemove&#x27;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;e&lt;/span&gt; &lt;span&gt;=&amp;gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt; setLeft&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;e&lt;span&gt;.&lt;/span&gt;offsetX&lt;span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt; setRight&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;e&lt;span&gt;.&lt;/span&gt;offsetY&lt;span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;})&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;我们需要在鼠标操作的时候修改位置，这时候还将 left 和 right 分开处理显得很没必要，因为我们同时修改两个值的概率远大于只修改一个值的概率，那么这个时候我们就可以把他们写在一起:&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;position&lt;span&gt;,&lt;/span&gt; setPosition&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;useState&lt;/span&gt;&lt;span&gt;({&lt;/span&gt;&lt;br/&gt; left&lt;span&gt;:&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt; right&lt;span&gt;:&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;})&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;总结下来就是，如果我们两个或多个值是经常同时修改的，那么我们把它们写在一起是更加方便的，反之，则拆分开来。&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;98953&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;04&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;清理操作&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这里涉及到的钩子函数是useEffect，按照官方文档的介绍，useEffect可以看作componentDidMount, componentDidUpdate, and componentWillUnmount的集合，DidMount和DidUpdate很常用到，这里主要说一下作为componentWillUnmount的用法。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在useClickOut中，我们有为document添加事件，显然这个事件我们需要在组件卸载的时候将其同样卸载，这里的做法是在useEffect的return中执行卸载函数，关于这一部分的用法，官网有完整的介绍：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;React会在组件卸载和&lt;/span&gt;&lt;span&gt;依赖状态变化重新执行callback之前&lt;/span&gt;&lt;span&gt;的时候执行useEffect中callback返回的函数，为什么？因为effects会在每一次重新渲染的时候执行不止一次，所以，理所当然的也会清理掉之前的effects。这里需要注意的是，无论是卸载操作，还是callback操作都是在组件return之后才执行的。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;98953&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;05&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;减少重复渲染&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;React.memo&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这个方法的作用类似于class中的 shouldComponentUpdate，不同的是shouldComponentUpdate同样会比较state的不同，但是React.memo只会比较props，其比较的规则也很简单，它会比较前后两次的props，以判断是否重新渲染，但是这其中其实存在很大的隐患，有些博主并不建议使用React.memo，但我觉得，只要遵循一下几个原则，React.memo 确实可以很大程度上节约渲染时间，特别是现在都使用redux，经常需要避免其他state的更新导致当前组件更新。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;性能优化时，组件更新的条件需要比较详细的计算，一般需要添加的条件包括基本类型，对象类型适当进行深度比较，函数类型依情况看可能变更的部分，使整个函数，还仅仅是几个参数，如果无法确定，那么最好直接使用PureComponent或者React.memo。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;useMemo&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;useMemo通常用来记录一些值，首先了解一下useMemo的使用场景；&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;1.存储一些开销很大的变量，避免每次render都重新计算；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.特定记录一些不想要变化的值；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于2，直接用就可以了，关于1，我们就应该以情况来判定是否使用了，看一下下面这个场景：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; value &lt;span&gt;=&lt;/span&gt; &lt;span&gt;useMemo&lt;/span&gt;&lt;span&gt;(()&lt;/span&gt; &lt;span&gt;=&amp;gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;massiveCompute&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;deps&lt;span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;},&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;deps&lt;span&gt;]);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;是否使用useMemo取决于：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;massiveComoute的操作是否真的大到影响性能；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;deps的数据类型，如果是对象或者数组，那么使用useMemo是没有意义，甚至增加了一次比较还影响了性能；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1&gt;&lt;span&gt;UseEffect与ComponentDidMount 的对比&lt;/span&gt;&lt;/h1&gt;&lt;section&gt;&lt;span&gt;在官方文档中，有提到 useEffect 可以实现各种生命周期的mock，但事实上，hooks与各种生命周期函数存在机制上的差别，如果笼统的将其和生命周期画上等号，那么在后续的理解上可能会出现偏差。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;具体的区别可以参考useEffect is not the new ComponentDidMount，下面会结合开发过程中遇到的问题来简要说明。&lt;/span&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;98953&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;06&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;运行时机&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先对于 componentDidMount 而言，在初次进入的时候，如果我们在 componentDidMount 中进行state操作，是会造成两次渲染的，分别是在 componentDidMount 之前和之后，在这之后，浏览器只会渲染最后一次 render 渲染以避免闪屏，也就是 componentDidMount 实际上是会在浏览器绘制之前执行；但是对于 useEffect，虽然同样会造成第二次渲染，但是第二次渲染是在浏览器绘制之后再次执行的，这样的影响也是会造成闪屏。注意 useEffect 是在每次组件 return 之后才会执行一次。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;对状态时机捕获的区别&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;思考 componentDidMount 的一种应用场景，componentDidMount 中进行一个异步操作，在异步操作 resolve 之后，如果打印此时的 state，我们会得到什么样的结果？具体的代码可以查看 longResolve with ComponentDidMount。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上面的例子中，我们在异步操作进行的过程中，如果改变 state 的值，最后在异步操作完成，打印对应 state 的时候，我们得到的结果其实就是改变后最新的结果。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;同样的例子，如果用 useEffect 代替 ComponentDidMount 会如何？查看 longResolve with useEffect。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们可以发现，无论我们在异步操作的过程中如何改变 state 的值，最后打印的时候都是最初的值或者说异步操作开始定义的时候的 state 的值。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;为什么会这样？&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;如果我们在 hooks 的例子中修改一下代码，在 useEffect 的 deps 中加入 count，我们可以更好的理解其中的原因&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; useEffect&lt;/span&gt;&lt;span&gt;(()&lt;/span&gt; &lt;span&gt;=&amp;gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;   longResolve&lt;/span&gt;&lt;span&gt;().&lt;/span&gt;&lt;span&gt;then&lt;/span&gt;&lt;span&gt;(()&lt;/span&gt; &lt;span&gt;=&amp;gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;     console&lt;span&gt;.&lt;/span&gt;&lt;span&gt;log&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;count&lt;span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;});&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;},&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;count&lt;span&gt;]);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;这时候，我们点击 n 次，这里的函数也会执行 n 次，因此，我们可以把 useEffect 的机制理解为，当 deps 中的数值改变时，我们 useEffect 都会把回调函数推到执行队列中，这样，函数中使用的值也很显然是保存时的值了。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;setInterval&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;在编写 useInterval 的时候，就遇到了这个问题，如果像在 class 中的处理一样，那么我们做的就是直接在 useEffect 中写 interval 的逻辑：&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;useEffect&lt;/span&gt;&lt;span&gt;(()&lt;/span&gt; &lt;span&gt;=&amp;gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;const&lt;/span&gt; id &lt;span&gt;=&lt;/span&gt; &lt;span&gt;setInterval&lt;/span&gt;&lt;span&gt;(()&lt;/span&gt; &lt;span&gt;=&amp;gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;     setCount&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;count &lt;span&gt;+&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;},&lt;/span&gt; &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;()&lt;/span&gt; &lt;span&gt;=&amp;gt;&lt;/span&gt; &lt;span&gt;clearInterval&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;id&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;},&lt;/span&gt; &lt;span&gt;[])&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;这样带来的结果是，count首先从0 -&amp;gt; 1，然后就一直不变了，原因跟上面说的一样，解决办法是在 deps 中添加对应的依赖变量 -&amp;gt; count，有可能我们会担心造成死循环，因为我们同时在改变依赖的变量，但考虑到 setInterval 本来就是一个无限循环的操作，所以这里并没有问题，同时，这里我们应该理解到的是，只要我们在useEffect中使用到了某个变量，那么就有必要添加它到 deps 中，如果代码出现了死循环，那么我们应该考虑是不是我们的内部逻辑出现了问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;值得提出来的是，setter函数还有另一种写法，我们不需要在 deps 中添加变量&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;useEffect&lt;/span&gt;&lt;span&gt;(()&lt;/span&gt; &lt;span&gt;=&amp;gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;const&lt;/span&gt; id &lt;span&gt;=&lt;/span&gt; &lt;span&gt;setInterval&lt;/span&gt;&lt;span&gt;(()&lt;/span&gt; &lt;span&gt;=&amp;gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;// When we pass a function, React calls that function with the current&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;// state and whatever we return becomes the new state.&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;   setCount&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;count&lt;/span&gt; &lt;span&gt;=&amp;gt;&lt;/span&gt; count &lt;span&gt;+&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;},&lt;/span&gt; &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;()&lt;/span&gt; &lt;span&gt;=&amp;gt;&lt;/span&gt; &lt;span&gt;clearInterval&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;id&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;},&lt;/span&gt; &lt;span&gt;[])&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;98953&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;07&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;React默认hooks原理分析&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;useMemo&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;首先说明一下 useMemo的作用，useMemo 可以用来保存一个存储值，这个值只会在 deps 改变的时候重新计算，在保存某些大计算量的值的时候经常会用到；接下来看一看React是如何实现这个功能的。&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;function&lt;/span&gt; useMemo&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;nextCreate&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;()&lt;/span&gt; &lt;span&gt;=&amp;gt;&lt;/span&gt; &lt;span&gt;T&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; deps&lt;span&gt;:&lt;/span&gt; &lt;span&gt;Array&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;mixed&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;T&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;  currentlyRenderingComponent &lt;span&gt;=&lt;/span&gt; &lt;span&gt;resolveCurrentlyRenderingComponent&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;&lt;br/&gt;  workInProgressHook &lt;span&gt;=&lt;/span&gt; &lt;span&gt;createWorkInProgressHook&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; nextDeps &lt;span&gt;=&lt;/span&gt; deps &lt;span&gt;===&lt;/span&gt; &lt;span&gt;undefined&lt;/span&gt; &lt;span&gt;?&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; &lt;span&gt;:&lt;/span&gt; deps&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;workInProgressHook &lt;span&gt;!==&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; prevState &lt;span&gt;=&lt;/span&gt; workInProgressHook&lt;span&gt;.&lt;/span&gt;memoizedState&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;prevState &lt;span&gt;!==&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;nextDeps &lt;span&gt;!==&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; prevDeps &lt;span&gt;=&lt;/span&gt; prevState&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;areHookInputsEqual&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;nextDeps&lt;span&gt;,&lt;/span&gt; prevDeps&lt;span&gt;))&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;return&lt;/span&gt; prevState&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;__DEV__&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    isInHookUserCodeInDev &lt;span&gt;=&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; nextValue &lt;span&gt;=&lt;/span&gt; &lt;span&gt;nextCreate&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;__DEV__&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    isInHookUserCodeInDev &lt;span&gt;=&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;  workInProgressHook&lt;span&gt;.&lt;/span&gt;memoizedState &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;nextValue&lt;span&gt;,&lt;/span&gt; nextDeps&lt;span&gt;];&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; nextValue&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;首先理解这里的一些全局变量的含义，&lt;/span&gt;&lt;code&gt;&lt;span&gt;workInProgressHook&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 表示当前正在运行的 hooks 是否是 re-render 的hooks，这里第一次的 if 判断就表示如果当前不是第一次渲染，那么 useMemo 会拿到两次 deps 去做比较，如果相等，就直接返回缓存中的状态；如果是第一次渲染，或者两次 deps 不想等，那么 useMemo 会重新执行一遍 callback，并将值赋给对应的缓存。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;useReducer &amp;amp; useState&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;useReducer 和 useState 本质上是一个原理，虽然我们平时会使用 useState 更多，但事实上 useState 是 useReducer 的封装；下面，对 useReducer 的实现原理做一下梳理；useReducer 可以分为初次渲染和re-render两种，首先看一下初次渲染的情况；&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;__DEV__&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;  isInHookUserCodeInDev &lt;span&gt;=&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; initialState&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;reducer &lt;span&gt;===&lt;/span&gt; basicStateReducer&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// Special case for `useState`.&lt;/span&gt;&lt;br/&gt;  initialState &lt;span&gt;=&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;typeof&lt;/span&gt; initialArg &lt;span&gt;===&lt;/span&gt; &lt;span&gt;&#x27;function&#x27;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;?&lt;/span&gt; &lt;span&gt;((&lt;/span&gt;initialArg&lt;span&gt;:&lt;/span&gt; &lt;span&gt;any&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;()&lt;/span&gt; &lt;span&gt;=&amp;gt;&lt;/span&gt; &lt;span&gt;S&lt;/span&gt;&lt;span&gt;)()&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;:&lt;/span&gt; &lt;span&gt;((&lt;/span&gt;initialArg&lt;span&gt;:&lt;/span&gt; &lt;span&gt;any&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;S&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;  initialState &lt;span&gt;=&lt;/span&gt;&lt;br/&gt;    init &lt;span&gt;!==&lt;/span&gt; &lt;span&gt;undefined&lt;/span&gt; &lt;span&gt;?&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;initialArg&lt;span&gt;)&lt;/span&gt; &lt;span&gt;:&lt;/span&gt; &lt;span&gt;((&lt;/span&gt;initialArg&lt;span&gt;:&lt;/span&gt; &lt;span&gt;any&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;S&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;__DEV__&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;  isInHookUserCodeInDev &lt;span&gt;=&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;workInProgressHook&lt;span&gt;.&lt;/span&gt;memoizedState &lt;span&gt;=&lt;/span&gt; initialState&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; queue&lt;span&gt;:&lt;/span&gt; UpdateQueue&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;workInProgressHook&lt;span&gt;.&lt;/span&gt;queue &lt;span&gt;=&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;  last&lt;span&gt;:&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;  dispatch&lt;span&gt;:&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;});&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; dispatch&lt;span&gt;:&lt;/span&gt; Dispatch&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;queue&lt;span&gt;.&lt;/span&gt;dispatch &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;dispatchAction&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;bind&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;  currentlyRenderingComponent&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;  queue&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;any&lt;/span&gt;&lt;span&gt;));&lt;/span&gt;&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;workInProgressHook&lt;span&gt;.&lt;/span&gt;memoizedState&lt;span&gt;,&lt;/span&gt; dispatch&lt;span&gt;];&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;从最熟悉的返回值看起，我们都很清楚，useState（useReducer）返回一个数组，0、1的index分别为 state 和 dispatch，首先看一下 state，这里的 state 在初次渲染的时候直接是等于我们传入给 useReducer 的参数的（useReducer 可以多传一个 init 函数，用于接收初始 state 作为参数，并返回对应 state）；重点是这里 dispatch 的处理，这里有一个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;dispatchAction&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法，这个方法的作用是将更新方法存放到一个以 queue 作为 key 的 Map 中，关于 &lt;/span&gt;&lt;code&gt;&lt;span&gt;dispatchAction&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的源代码和具体作用：&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;function&lt;/span&gt; dispatchAction&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;br/&gt;  componentIdentity&lt;span&gt;:&lt;/span&gt; Object&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;  queue&lt;span&gt;:&lt;/span&gt; UpdateQueue&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;  action&lt;span&gt;:&lt;/span&gt; &lt;span&gt;A&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;componentIdentity &lt;span&gt;===&lt;/span&gt; currentlyRenderingComponent&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    didScheduleRenderPhaseUpdate &lt;span&gt;=&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; update&lt;span&gt;:&lt;/span&gt; Update&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;      action&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;      next&lt;span&gt;:&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;};&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;renderPhaseUpdates &lt;span&gt;===&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;      renderPhaseUpdates &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Map&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; firstRenderPhaseUpdate &lt;span&gt;=&lt;/span&gt; renderPhaseUpdates&lt;span&gt;.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;queue&lt;span&gt;);&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;firstRenderPhaseUpdate &lt;span&gt;===&lt;/span&gt; &lt;span&gt;undefined&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;      renderPhaseUpdates&lt;span&gt;.&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;queue&lt;span&gt;,&lt;/span&gt; update&lt;span&gt;);&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;br/&gt;&lt;/span&gt;      // 这里的处理是当我们连续调用 dispatch 的时候，我们将 update 追加到已有的队列后面，而不是另起一个&lt;br/&gt;      // 队列，这里在下次执行的时候可以将同步执行的 dispatch 合并到一个队列中，到时候也可以统一更新&lt;br/&gt;      &lt;span&gt;let&lt;/span&gt; lastRenderPhaseUpdate &lt;span&gt;=&lt;/span&gt; firstRenderPhaseUpdate&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;while&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;lastRenderPhaseUpdate&lt;span&gt;.&lt;/span&gt;next &lt;span&gt;!==&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        lastRenderPhaseUpdate &lt;span&gt;=&lt;/span&gt; lastRenderPhaseUpdate&lt;span&gt;.&lt;/span&gt;next&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;      lastRenderPhaseUpdate&lt;span&gt;.&lt;/span&gt;next &lt;span&gt;=&lt;/span&gt; update&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;dispatchAction 是一个渲染阶段的更新，将其隐藏在一个惰性创建的 queue -&amp;gt; 更新链表 中（renderPhaseUpdates）。在此渲染结束后，我们将重新启动并将隐藏的更新应用到正在进行的工作钩子（work-in-process）上。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;dispatchAction&lt;/span&gt;&lt;/code&gt;&lt;span&gt;有接收三个参数，分别为&lt;/span&gt;&lt;code&gt;&lt;span&gt;componentIdentity&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，&lt;/span&gt;&lt;code&gt;&lt;span&gt;queue&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，&lt;/span&gt;&lt;code&gt;&lt;span&gt;action&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 这里使用了bind进行了绑定，所以action 参数就是在调用 dispatch 的时候传入的参数。至此，一次 useState 初始化完成，其实我们可以发现，我们在调用 dispatch 时，具体的操作其实并不是修改 state 的值，而是将对应的 action（或者说修改的值）追加到一个队列中，当重复渲染计算到 useState 时，再去从这个全局队列中执行对应的更新；下面看一下重复渲染时的情况，给出当重复渲染时 useReducer 中的逻辑：&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// This is a re-render. Apply the new render phase updates to the previous&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// current hook.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; queue&lt;span&gt;:&lt;/span&gt; UpdateQueue&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;workInProgressHook&lt;span&gt;.&lt;/span&gt;queue&lt;span&gt;:&lt;/span&gt; &lt;span&gt;any&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; dispatch&lt;span&gt;:&lt;/span&gt; Dispatch&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;queue&lt;span&gt;.&lt;/span&gt;dispatch&lt;span&gt;:&lt;/span&gt; &lt;span&gt;any&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;renderPhaseUpdates &lt;span&gt;!==&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// Render phase updates are stored in a map of queue -&amp;gt; linked list&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; firstRenderPhaseUpdate &lt;span&gt;=&lt;/span&gt; renderPhaseUpdates&lt;span&gt;.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;queue&lt;span&gt;);&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;firstRenderPhaseUpdate &lt;span&gt;!==&lt;/span&gt; &lt;span&gt;undefined&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    renderPhaseUpdates&lt;span&gt;.&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;queue&lt;span&gt;);&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; newState &lt;span&gt;=&lt;/span&gt; workInProgressHook&lt;span&gt;.&lt;/span&gt;memoizedState&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; update &lt;span&gt;=&lt;/span&gt; firstRenderPhaseUpdate&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;do&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// Process this render phase update. We don&#x27;t have to check the&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// priority because it will always be the same as the current&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// render&#x27;s.&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; action &lt;span&gt;=&lt;/span&gt; update&lt;span&gt;.&lt;/span&gt;action&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;__DEV__&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        isInHookUserCodeInDev &lt;span&gt;=&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;      newState &lt;span&gt;=&lt;/span&gt; &lt;span&gt;reducer&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;newState&lt;span&gt;,&lt;/span&gt; action&lt;span&gt;);&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;__DEV__&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        isInHookUserCodeInDev &lt;span&gt;=&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;      update &lt;span&gt;=&lt;/span&gt; update&lt;span&gt;.&lt;/span&gt;next&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt; &lt;span&gt;while&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;update &lt;span&gt;!==&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    workInProgressHook&lt;span&gt;.&lt;/span&gt;memoizedState &lt;span&gt;=&lt;/span&gt; newState&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;newState&lt;span&gt;,&lt;/span&gt; dispatch&lt;span&gt;];&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;workInProgressHook&lt;span&gt;.&lt;/span&gt;memoizedState&lt;span&gt;,&lt;/span&gt; dispatch&lt;span&gt;];&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;首先，如果 &lt;/span&gt;&lt;code&gt;&lt;span&gt;renderPhaseUpdates&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 为 null，说明这次更新之前都没有过 dispatch 的调用，这时候直接按原值返回；如果 &lt;/span&gt;&lt;code&gt;&lt;span&gt;renderPhaseUpdates&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 不为 null，说明之前有过 dispatch 调用，但是这个更新是全局的，所以其实 hooks 也不知道具体是什么触发了更新，这时候根据queue 去之前存储的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;renderPhaseUpdates&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中取对应的更新方法，如果取到了，说明这次更新之前有调用过 dispatch，这时候更新的操作是一个 do-while 循环，这里的逻辑对应到 &lt;/span&gt;&lt;code&gt;&lt;span&gt;dispatchAction&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的队列建立逻辑 - 会把多个 updater 合并到一个队列中，所以这里一个 do -while 循环一次性执行所有的 updater，注意这里的注释和逻辑，也就是说如果我们在一系列的 dispatch 中都直接对 state 的值修改，这里的修改实际上只保留了最后一次修改，但是如果传入的是回调函数例如 &lt;/span&gt;&lt;code&gt;&lt;span&gt;setState((state) =&amp;gt; state + 1)&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 那么是可以拿到最新的 state 值的，因为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;newState&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 每次都变了。&lt;/span&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;95248&quot;&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section&gt;&lt;img class=&quot;__bg_gif&quot; data-ratio=&quot;0.9861751152073732&quot; data-type=&quot;gif&quot; data-w=&quot;217&quot; data-width=&quot;100%&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xsw6Lt5pDCu5fmibeKicBjM3FM4jEIIev9JIuj1Yrn63LibYiaFW1nftYEicUhuiaJelkBZ4iaq0icNxSpiaUEXTqUcbIlA/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;us-3390337&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;&lt;span data-raw-text=&quot;I&quot; data-textnode-index=&quot;136&quot; data-index=&quot;2992&quot; class=&quot;character&quot;&gt;I&lt;/span&gt;&lt;span data-raw-text=&quot;M&quot; data-textnode-index=&quot;136&quot; data-index=&quot;2993&quot; class=&quot;character&quot;&gt;M&lt;/span&gt;&lt;span data-raw-text=&quot;W&quot; data-textnode-index=&quot;136&quot; data-index=&quot;2994&quot; class=&quot;character&quot;&gt;W&lt;/span&gt;&lt;span data-raw-text=&quot;e&quot; data-textnode-index=&quot;136&quot; data-index=&quot;2995&quot; class=&quot;character&quot;&gt;e&lt;/span&gt;&lt;span data-raw-text=&quot;b&quot; data-textnode-index=&quot;136&quot; data-index=&quot;2996&quot; class=&quot;character&quot;&gt;b&lt;/span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;136&quot; data-index=&quot;2997&quot; class=&quot;character&quot;&gt; &lt;/span&gt;&lt;span data-raw-text=&quot;团&quot; data-textnode-index=&quot;136&quot; data-index=&quot;2998&quot; class=&quot;character&quot;&gt;团&lt;/span&gt;&lt;span data-raw-text=&quot;队&quot; data-textnode-index=&quot;136&quot; data-index=&quot;2999&quot; class=&quot;character&quot;&gt;队&lt;/span&gt;&lt;span data-raw-text=&quot;隶&quot; data-textnode-index=&quot;136&quot; data-index=&quot;3000&quot; class=&quot;character&quot;&gt;隶&lt;/span&gt;&lt;span data-raw-text=&quot;属&quot; data-textnode-index=&quot;136&quot; data-index=&quot;3001&quot; class=&quot;character&quot;&gt;属&lt;/span&gt;&lt;span data-raw-text=&quot;腾&quot; data-textnode-index=&quot;136&quot; data-index=&quot;3002&quot; class=&quot;character&quot;&gt;腾&lt;/span&gt;&lt;span data-raw-text=&quot;讯&quot; data-textnode-index=&quot;136&quot; data-index=&quot;3003&quot; class=&quot;character&quot;&gt;讯&lt;/span&gt;&lt;span data-raw-text=&quot;公&quot; data-textnode-index=&quot;136&quot; data-index=&quot;3004&quot; class=&quot;character&quot;&gt;公&lt;/span&gt;&lt;span data-raw-text=&quot;司&quot; data-textnode-index=&quot;136&quot; data-index=&quot;3005&quot; class=&quot;character&quot;&gt;司&lt;/span&gt;&lt;span data-raw-text=&quot;，&quot; data-textnode-index=&quot;136&quot; data-index=&quot;3006&quot; class=&quot;character&quot;&gt;，&lt;/span&gt;&lt;span data-raw-text=&quot;是&quot; data-textnode-index=&quot;136&quot; data-index=&quot;3007&quot; class=&quot;character&quot;&gt;是&lt;/span&gt;&lt;span data-raw-text=&quot;国&quot; data-textnode-index=&quot;136&quot; data-index=&quot;3008&quot; class=&quot;character&quot;&gt;国&lt;/span&gt;&lt;span data-raw-text=&quot;内&quot; data-textnode-index=&quot;136&quot; data-index=&quot;3009&quot; class=&quot;character&quot;&gt;内&lt;/span&gt;&lt;span data-raw-text=&quot;最&quot; data-textnode-index=&quot;136&quot; data-index=&quot;3010&quot; class=&quot;character&quot;&gt;最&lt;/span&gt;&lt;span data-raw-text=&quot;专&quot; data-textnode-index=&quot;136&quot; data-index=&quot;3011&quot; class=&quot;character&quot;&gt;专&lt;/span&gt;&lt;span data-raw-text=&quot;业&quot; data-textnode-index=&quot;136&quot; data-index=&quot;3012&quot; class=&quot;character&quot;&gt;业&lt;/span&gt;&lt;span data-raw-text=&quot;的&quot; data-textnode-index=&quot;136&quot; data-index=&quot;3013&quot; class=&quot;character&quot;&gt;的&lt;/span&gt;&lt;span data-raw-text=&quot;前&quot; data-textnode-index=&quot;136&quot; data-index=&quot;3014&quot; class=&quot;character&quot;&gt;前&lt;/span&gt;&lt;span data-raw-text=&quot;端&quot; data-textnode-index=&quot;136&quot; data-index=&quot;3015&quot; class=&quot;character&quot;&gt;端&lt;/span&gt;&lt;span data-raw-text=&quot;团&quot; data-textnode-index=&quot;136&quot; data-index=&quot;3016&quot; class=&quot;character&quot;&gt;团&lt;/span&gt;&lt;span data-raw-text=&quot;队&quot; data-textnode-index=&quot;136&quot; data-index=&quot;3017&quot; class=&quot;character&quot;&gt;队&lt;/span&gt;&lt;span data-raw-text=&quot;之&quot; data-textnode-index=&quot;136&quot; data-index=&quot;3018&quot; class=&quot;character&quot;&gt;之&lt;/span&gt;&lt;span data-raw-text=&quot;一&quot; data-textnode-index=&quot;136&quot; data-index=&quot;3019&quot; class=&quot;character&quot;&gt;一&lt;/span&gt;&lt;span data-raw-text=&quot;。&quot; data-textnode-index=&quot;136&quot; data-index=&quot;3020&quot; class=&quot;character&quot;&gt;。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;us-3390337&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span data-raw-text=&quot;我&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3021&quot; class=&quot;character&quot;&gt;我&lt;/span&gt;&lt;span data-raw-text=&quot;们&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3022&quot; class=&quot;character&quot;&gt;们&lt;/span&gt;&lt;span data-raw-text=&quot;专&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3023&quot; class=&quot;character&quot;&gt;专&lt;/span&gt;&lt;span data-raw-text=&quot;注&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3024&quot; class=&quot;character&quot;&gt;注&lt;/span&gt;&lt;span data-raw-text=&quot;前&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3025&quot; class=&quot;character&quot;&gt;前&lt;/span&gt;&lt;span data-raw-text=&quot;端&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3026&quot; class=&quot;character&quot;&gt;端&lt;/span&gt;&lt;span data-raw-text=&quot;领&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3027&quot; class=&quot;character&quot;&gt;领&lt;/span&gt;&lt;span data-raw-text=&quot;域&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3028&quot; class=&quot;character&quot;&gt;域&lt;/span&gt;&lt;span data-raw-text=&quot;多&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3029&quot; class=&quot;character&quot;&gt;多&lt;/span&gt;&lt;span data-raw-text=&quot;年&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3030&quot; class=&quot;character&quot;&gt;年&lt;/span&gt;&lt;span data-raw-text=&quot;，&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3031&quot; class=&quot;character&quot;&gt;，&lt;/span&gt;&lt;span data-raw-text=&quot;负&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3032&quot; class=&quot;character&quot;&gt;负&lt;/span&gt;&lt;span data-raw-text=&quot;责&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3033&quot; class=&quot;character&quot;&gt;责&lt;/span&gt;&lt;span data-raw-text=&quot;过&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3034&quot; class=&quot;character&quot;&gt;过&lt;/span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;137&quot; data-index=&quot;3035&quot; class=&quot;character&quot;&gt; &lt;/span&gt;&lt;span data-raw-text=&quot;Q&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3036&quot; class=&quot;character&quot;&gt;Q&lt;/span&gt;&lt;span data-raw-text=&quot;Q&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3037&quot; class=&quot;character&quot;&gt;Q&lt;/span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;137&quot; data-index=&quot;3038&quot; class=&quot;character&quot;&gt; &lt;/span&gt;&lt;span data-raw-text=&quot;资&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3039&quot; class=&quot;character&quot;&gt;资&lt;/span&gt;&lt;span data-raw-text=&quot;料&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3040&quot; class=&quot;character&quot;&gt;料&lt;/span&gt;&lt;span data-raw-text=&quot;、&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3041&quot; class=&quot;character&quot;&gt;、&lt;/span&gt;&lt;span data-raw-text=&quot;Q&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3042&quot; class=&quot;character&quot;&gt;Q&lt;/span&gt;&lt;span data-raw-text=&quot;Q&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3043&quot; class=&quot;character&quot;&gt;Q&lt;/span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;137&quot; data-index=&quot;3044&quot; class=&quot;character&quot;&gt; &lt;/span&gt;&lt;span data-raw-text=&quot;注&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3045&quot; class=&quot;character&quot;&gt;注&lt;/span&gt;&lt;span data-raw-text=&quot;册&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3046&quot; class=&quot;character&quot;&gt;册&lt;/span&gt;&lt;span data-raw-text=&quot;、&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3047&quot; class=&quot;character&quot;&gt;、&lt;/span&gt;&lt;span data-raw-text=&quot;Q&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3048&quot; class=&quot;character&quot;&gt;Q&lt;/span&gt;&lt;span data-raw-text=&quot;Q&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3049&quot; class=&quot;character&quot;&gt;Q&lt;/span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;137&quot; data-index=&quot;3050&quot; class=&quot;character&quot;&gt; &lt;/span&gt;&lt;span data-raw-text=&quot;群&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3051&quot; class=&quot;character&quot;&gt;群&lt;/span&gt;&lt;span data-raw-text=&quot;等&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3052&quot; class=&quot;character&quot;&gt;等&lt;/span&gt;&lt;span data-raw-text=&quot;亿&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3053&quot; class=&quot;character&quot;&gt;亿&lt;/span&gt;&lt;span data-raw-text=&quot;级&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3054&quot; class=&quot;character&quot;&gt;级&lt;/span&gt;&lt;span data-raw-text=&quot;业&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3055&quot; class=&quot;character&quot;&gt;业&lt;/span&gt;&lt;span data-raw-text=&quot;务&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3056&quot; class=&quot;character&quot;&gt;务&lt;/span&gt;&lt;span data-raw-text=&quot;。&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3057&quot; class=&quot;character&quot;&gt;。&lt;/span&gt;&lt;span data-raw-text=&quot;目&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3058&quot; class=&quot;character&quot;&gt;目&lt;/span&gt;&lt;span data-raw-text=&quot;前&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3059&quot; class=&quot;character&quot;&gt;前&lt;/span&gt;&lt;span data-raw-text=&quot;聚&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3060&quot; class=&quot;character&quot;&gt;聚&lt;/span&gt;&lt;span data-raw-text=&quot;焦&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3061&quot; class=&quot;character&quot;&gt;焦&lt;/span&gt;&lt;span data-raw-text=&quot;于&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3062&quot; class=&quot;character&quot;&gt;于&lt;/span&gt;&lt;span data-raw-text=&quot;在&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3063&quot; class=&quot;character&quot;&gt;在&lt;/span&gt;&lt;span data-raw-text=&quot;线&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3064&quot; class=&quot;character&quot;&gt;线&lt;/span&gt;&lt;span data-raw-text=&quot;教&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3065&quot; class=&quot;character&quot;&gt;教&lt;/span&gt;&lt;span data-raw-text=&quot;育&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3066&quot; class=&quot;character&quot;&gt;育&lt;/span&gt;&lt;span data-raw-text=&quot;领&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3067&quot; class=&quot;character&quot;&gt;领&lt;/span&gt;&lt;span data-raw-text=&quot;域&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3068&quot; class=&quot;character&quot;&gt;域&lt;/span&gt;&lt;span data-raw-text=&quot;，&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3069&quot; class=&quot;character&quot;&gt;，&lt;/span&gt;&lt;span data-raw-text=&quot;精&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3070&quot; class=&quot;character&quot;&gt;精&lt;/span&gt;&lt;span data-raw-text=&quot;心&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3071&quot; class=&quot;character&quot;&gt;心&lt;/span&gt;&lt;span data-raw-text=&quot;打&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3072&quot; class=&quot;character&quot;&gt;打&lt;/span&gt;&lt;span data-raw-text=&quot;磨&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3073&quot; class=&quot;character&quot;&gt;磨&lt;/span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;137&quot; data-index=&quot;3074&quot; class=&quot;character&quot;&gt; &lt;/span&gt;&lt;span data-raw-text=&quot;腾&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3075&quot; class=&quot;character&quot;&gt;腾&lt;/span&gt;&lt;span data-raw-text=&quot;讯&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3076&quot; class=&quot;character&quot;&gt;讯&lt;/span&gt;&lt;span data-raw-text=&quot;课&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3077&quot; class=&quot;character&quot;&gt;课&lt;/span&gt;&lt;span data-raw-text=&quot;堂&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3078&quot; class=&quot;character&quot;&gt;堂&lt;/span&gt;&lt;span data-raw-text=&quot;、&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3079&quot; class=&quot;character&quot;&gt;、&lt;/span&gt;&lt;span data-raw-text=&quot;企&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3080&quot; class=&quot;character&quot;&gt;企&lt;/span&gt;&lt;span data-raw-text=&quot;鹅&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3081&quot; class=&quot;character&quot;&gt;鹅&lt;/span&gt;&lt;span data-raw-text=&quot;辅&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3082&quot; class=&quot;character&quot;&gt;辅&lt;/span&gt;&lt;span data-raw-text=&quot;导&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3083&quot; class=&quot;character&quot;&gt;导&lt;/span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;137&quot; data-index=&quot;3084&quot; class=&quot;character&quot;&gt; &lt;/span&gt;&lt;span data-raw-text=&quot;及&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3085&quot; class=&quot;character&quot;&gt;及&lt;/span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;137&quot; data-index=&quot;3086&quot; class=&quot;character&quot;&gt; &lt;/span&gt;&lt;span data-raw-text=&quot;A&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3087&quot; class=&quot;character&quot;&gt;A&lt;/span&gt;&lt;span data-raw-text=&quot;B&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3088&quot; class=&quot;character&quot;&gt;B&lt;/span&gt;&lt;span data-raw-text=&quot;C&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3089&quot; class=&quot;character&quot;&gt;C&lt;/span&gt;&lt;span data-raw-text=&quot;M&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3090&quot; class=&quot;character&quot;&gt;M&lt;/span&gt;&lt;span data-raw-text=&quot;o&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3091&quot; class=&quot;character&quot;&gt;o&lt;/span&gt;&lt;span data-raw-text=&quot;u&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3092&quot; class=&quot;character&quot;&gt;u&lt;/span&gt;&lt;span data-raw-text=&quot;s&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3093&quot; class=&quot;character&quot;&gt;s&lt;/span&gt;&lt;span data-raw-text=&quot;e&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3094&quot; class=&quot;character&quot;&gt;e&lt;/span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;137&quot; data-index=&quot;3095&quot; class=&quot;character&quot;&gt; &lt;/span&gt;&lt;span data-raw-text=&quot;三&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3096&quot; class=&quot;character&quot;&gt;三&lt;/span&gt;&lt;span data-raw-text=&quot;大&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3097&quot; class=&quot;character&quot;&gt;大&lt;/span&gt;&lt;span data-raw-text=&quot;产&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3098&quot; class=&quot;character&quot;&gt;产&lt;/span&gt;&lt;span data-raw-text=&quot;品&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3099&quot; class=&quot;character&quot;&gt;品&lt;/span&gt;&lt;span data-raw-text=&quot;。&quot; data-textnode-index=&quot;137&quot; data-index=&quot;3100&quot; class=&quot;character&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;span data-raw-text=&quot;&amp;#10;&quot; data-textnode-index=&quot;138&quot; data-index=&quot;3101&quot; class=&quot;character&quot;/&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;92321&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;__bg_gif&quot; data-ratio=&quot;0.8767123287671232&quot; data-type=&quot;gif&quot; data-w=&quot;219&quot; data-width=&quot;100%&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xsw6Lt5pDCu5fmibeKicBjM3FM4jEIIev9UKbrE6iccmXBZ8QZOnVzdwANfAGxFZtQMv6f1ibhO653TnusIZxa5dWQ/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span data-raw-text=&quot;扫&quot; data-textnode-index=&quot;139&quot; data-index=&quot;3102&quot; class=&quot;character&quot;&gt;扫&lt;/span&gt;&lt;span data-raw-text=&quot;码&quot; data-textnode-index=&quot;139&quot; data-index=&quot;3103&quot; class=&quot;character&quot;&gt;码&lt;/span&gt;&lt;span data-raw-text=&quot;关&quot; data-textnode-index=&quot;139&quot; data-index=&quot;3104&quot; class=&quot;character&quot;&gt;关&lt;/span&gt;&lt;span data-raw-text=&quot;注&quot; data-textnode-index=&quot;139&quot; data-index=&quot;3105&quot; class=&quot;character&quot;&gt;注&lt;/span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;139&quot; data-index=&quot;3106&quot; class=&quot;character&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span data-raw-text=&quot;腾&quot; data-textnode-index=&quot;140&quot; data-index=&quot;3107&quot; class=&quot;character&quot;&gt;腾&lt;/span&gt;&lt;span data-raw-text=&quot;讯&quot; data-textnode-index=&quot;140&quot; data-index=&quot;3108&quot; class=&quot;character&quot;&gt;讯&lt;/span&gt;&lt;span data-raw-text=&quot;I&quot; data-textnode-index=&quot;140&quot; data-index=&quot;3109&quot; class=&quot;character&quot;&gt;I&lt;/span&gt;&lt;span data-raw-text=&quot;M&quot; data-textnode-index=&quot;140&quot; data-index=&quot;3110&quot; class=&quot;character&quot;&gt;M&lt;/span&gt;&lt;span data-raw-text=&quot;W&quot; data-textnode-index=&quot;140&quot; data-index=&quot;3111&quot; class=&quot;character&quot;&gt;W&lt;/span&gt;&lt;span data-raw-text=&quot;e&quot; data-textnode-index=&quot;140&quot; data-index=&quot;3112&quot; class=&quot;character&quot;&gt;e&lt;/span&gt;&lt;span data-raw-text=&quot;b&quot; data-textnode-index=&quot;140&quot; data-index=&quot;3113&quot; class=&quot;character&quot;&gt;b&lt;/span&gt;&lt;span data-raw-text=&quot;前&quot; data-textnode-index=&quot;140&quot; data-index=&quot;3114&quot; class=&quot;character&quot;&gt;前&lt;/span&gt;&lt;span data-raw-text=&quot;端&quot; data-textnode-index=&quot;140&quot; data-index=&quot;3115&quot; class=&quot;character&quot;&gt;端&lt;/span&gt;&lt;span data-raw-text=&quot;团&quot; data-textnode-index=&quot;140&quot; data-index=&quot;3116&quot; class=&quot;character&quot;&gt;团&lt;/span&gt;&lt;span data-raw-text=&quot;队&quot; data-textnode-index=&quot;140&quot; data-index=&quot;3117&quot; class=&quot;character&quot;&gt;队&lt;/span&gt;&lt;/strong&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;141&quot; data-index=&quot;3118&quot; class=&quot;character&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-ratio=&quot;1&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xsw6Lt5pDCszP1CPZt7XDg49u7XL5d4fSxmCTyyLoxaEREmkDaaIOPLWkltPDYiaeibVvC1nLwMYk5BN4fpOJKfQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>