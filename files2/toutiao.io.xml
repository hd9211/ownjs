<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>8551e70740a5c67b671b491ab67438de</guid>
<title>深入分析 MySQL 系列之总体架构介绍</title>
<link>https://toutiao.io/k/zm3jxob</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entry-inner&quot;&gt;
                                                    
&lt;p&gt;在我们详细深入介绍MySQL的方方面面之前，让我们首先来看一下MySQL的总体架构，从总体上对MySQL有所了解，这样我们在后面的具体介绍部分的时候才能够知道这些部分属于哪个模块，大概有什么样的作用。&lt;/p&gt;



&lt;h2&gt;MySQL的逻辑架构&lt;/h2&gt;



&lt;p&gt;首先我们来看一下MySQL的逻辑架构，如下图所示。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/07/image-11.png&quot; alt=&quot;&quot; class=&quot;wp-image-793&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/07/image-11.png 566w, https://donggeitnote.com/wp-content/uploads/2021/07/image-11-224x300.png 224w&quot; sizes=&quot;(max-width: 566px) 100vw, 566px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;我们可以看到大概可以分成三层：&lt;/p&gt;



&lt;ul&gt;&lt;li&gt;Connection/thread handing，这一层其实和MySQL没有什么大的关系，在一般的C/S架构中都会存在，一般用来处理相关的连接，认证，安全等等方面，我们不具体介绍。&lt;/li&gt;&lt;li&gt;Parser/Optimizer。这一层就是MySQL的大脑了，它主要工作就是解析查询语句，分析并进行优化，所有跨storage engines的函数都是在这里实现的，比如Stored Procedures，views等等。&lt;/li&gt;&lt;li&gt;Storage Engines。顾名思义，这一层的主要作用就是存储和查询数据。MySQL支持很多种不同的Storage Engine，我们在后面一一给大家介绍。&lt;/li&gt;&lt;/ul&gt;



&lt;h2&gt;并行控制&lt;/h2&gt;



&lt;p&gt;在了解了MySQL的逻辑架构之后，我们来看一下MySQL对一些常见数据库的问题的处理方法。第一个问题当然就是我们常见的并行控制，简单说就是有读写同时发生的时候会如何处理。我们在之前的文章介绍过常见的处理方法，这里MySQL选用的是读写锁，也就是说读获取锁的时候，可以有多个读同时进行，但是写的锁是排外的，也就是说有写获取锁，那么任何别的读和写都没有办法获取相应的锁。&lt;/p&gt;



&lt;p&gt;使用锁有一个重要的问题就是如何确定锁的粒度，说白了，你把锁加在越大的粒度上，并行的性能就会降低，因为拿不到锁的概率就会变大。假如你把锁的粒度搞到比较小，拿不到锁的概率就会变低，这样并行的性能就会变好，但是问题是锁消耗的资源其实是很大的看，粒度越小就意味着需要更多的锁，从而有更多的资源消耗。这就是我们需要考虑的trade off。&lt;/p&gt;



&lt;p&gt;MySQL在这个方面提供了一些选择，根据不同的Storage engine可以实现不同的锁机制和锁粒度。不过通常来说有两种锁的机制比较常见：&lt;/p&gt;



&lt;ul&gt;&lt;li&gt;&lt;strong&gt;表锁：&lt;/strong&gt;顾名思义，即使lock整个表。每次写一个表的时候都去抓这个表锁，也就意味着其它任何读写都需要等待这个锁。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;行锁：&lt;/strong&gt;这个锁的粒度相比表锁来说就细了很多，它是应用到一行上面的。也就是说只有这行的数据被修改的时候，才会影响到需要修改这行数据的读和写。这样一来其实并行读写的性能就会变得比较好。&lt;/li&gt;&lt;/ul&gt;



&lt;p&gt;大多数MySQL使用的不是简单的行锁。他们使用的是行锁和一种称之为多版本同步控制（MVCC）的技术。这个技术我们在之前的《&lt;a href=&quot;https://donggeitnote.com/2021/06/06/snapshot-isolation/&quot;&gt;Snapshot的隔离和Repeatable的读&lt;/a&gt;》中有详细的介绍。&lt;/p&gt;



&lt;h2&gt;Transaction&lt;/h2&gt;



&lt;p&gt;Transaction是一个通用的概念，这里我们不详细介绍，大家可以参考《&lt;a href=&quot;https://donggeitnote.com/2021/06/03/transaction-introduction/&quot;&gt;Transactions的基本概念和介绍&lt;/a&gt;》这篇文章。&lt;/p&gt;



&lt;p&gt;具体到MySQL，它有不同的storage engine支持Transaction，我们这里以最推荐的InnoDB来说明。&lt;/p&gt;



&lt;p&gt;默认来说，单独的Insert，Update以及Delete操作是被隐式地转变成 一个Transaction并且立即commit的。也就是我们常说的AUTOCOMMIT。你可以使用SET AUTOCMMIT = 0/1来关掉或者打开这个功能。注意关掉之后，你就会一直在一个transaction里面，直到你commit或者rollback。&lt;/p&gt;



&lt;p&gt;另外MySQL还可以自己设置隔离的级别，你可以简单使用下面这个命令来进行设置&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/07/image-12.png&quot; alt=&quot;&quot; class=&quot;wp-image-794&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/07/image-12.png 624w, https://donggeitnote.com/wp-content/uploads/2021/07/image-12-300x25.png 300w&quot; sizes=&quot;(max-width: 624px) 100vw, 624px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;如果你想了解具体关于transaction的隔离相关知识，可以参见这些文章：&lt;/p&gt;



&lt;p&gt;《&lt;a href=&quot;https://donggeitnote.com/2021/06/06/transaction-read-commit/&quot;&gt;Transaction弱隔离之读提交的介绍和实现&lt;/a&gt;》&lt;/p&gt;



&lt;p&gt;《&lt;a href=&quot;https://donggeitnote.com/2021/06/06/snapshot-isolation/&quot;&gt;Snapshot的隔离和Repeatable的读&lt;/a&gt;》&lt;/p&gt;



&lt;p&gt;《&lt;a href=&quot;https://donggeitnote.com/2021/06/08/transaction-update-lost/&quot;&gt;Transaction弱隔离之更新丢失&lt;/a&gt;》&lt;/p&gt;



&lt;p&gt;《&lt;a href=&quot;https://donggeitnote.com/2021/06/10/transaction-write-skew/&quot;&gt;Transaction弱隔离之Write Skew和Phantoms&lt;/a&gt;》&lt;/p&gt;



&lt;p&gt;《&lt;a href=&quot;https://donggeitnote.com/2021/06/13/transaction-serializable/&quot;&gt;Transaction Serializable隔离之串行执行&lt;/a&gt;》&lt;/p&gt;



&lt;p&gt;《&lt;a href=&quot;https://donggeitnote.com/2021/06/15/transaction-serializable-2pl/&quot;&gt;Transaction Serializable隔离之两阶段锁&lt;/a&gt;》&lt;/p&gt;



&lt;p&gt;《&lt;a href=&quot;https://donggeitnote.com/2021/06/16/serializable-ssi/&quot;&gt;一文带你深入理解Serializable隔离最新技术SSI&lt;/a&gt;》&lt;/p&gt;



&lt;p&gt;相信读了这些文章之后，你会对Transaction的隔离相关内容有一个非常清晰的理解。&lt;/p&gt;



&lt;p&gt;需要注意的是在MySQL中，transaction是在storage engine level实现的，这也就意味着假如你一个transaction设计多个不同的engine，那么这个transaction是不可靠的，因为不同的engine都有自己的设置，尤其是需要rollback的时候，可能transaction在其中一个engine中的内容被rollback了，而另外一个则没有。当然有时它会报错，但是很多时候都不会有这样的错误出现，所以你自己需要小心。&lt;/p&gt;



&lt;p&gt;另外InnoDB使用的是两阶段锁，同时它也支持现实锁的设置，如下所示，这个是MySQL 8.0的新的功能。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/07/image-10.png&quot; alt=&quot;&quot; class=&quot;wp-image-792&quot;/&gt;&lt;/figure&gt;



&lt;h2&gt;Replication&lt;/h2&gt;



&lt;p&gt;MySQL中的replication使用的是pull的模式，也就是说它的每个replica是周期性的到source那边进行pull最新的log。简单的示意图如下所示：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/07/image-9.png&quot; alt=&quot;&quot; class=&quot;wp-image-791&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/07/image-9.png 506w, https://donggeitnote.com/wp-content/uploads/2021/07/image-9-300x218.png 300w&quot; sizes=&quot;(max-width: 506px) 100vw, 506px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;通常来说为了更好地达到replication的目的，我们需要有最少3个replica，他们最好能分布在不同的数据中心（位置）。这样即使有灾难发生，比如地震等等，我们也能保证有至少一个repica是可以使用的。有关replication的基础知识可以参见这篇文章《&lt;a href=&quot;https://donggeitnote.com/2021/05/22/leader-followers-replication/&quot;&gt;分布式系统之leader-followers Replication深入介绍&lt;/a&gt;》。&lt;/p&gt;



&lt;h2&gt;Storage Engines&lt;/h2&gt;



&lt;p&gt;MySQL支持很多不同的Storage Engine，你可以根据自己的应用需求来进行选择。每个版本的MySQL对Storage Engine都有不同的支持。具体可能需要大家参考各个版本的说明。&lt;/p&gt;



&lt;p&gt;在8.0之前，MySQL每个数据库是按照文件系统中的子目录格式来存储的。你创建了一个表，MySQL把表保存成一个.frm文件（定义）和一个.ibd文件（存储数据）。所以你创建了一个表Test，就会有两个文件出现，一个是Test.frm一个是Test.ibd。假如你使用了partition的话，还会有一个Test.par文件。&lt;/p&gt;



&lt;p&gt;在8.0之中，MySQL重新定义了表的metadata，把它直接包含到标的.ibd文件中。这样一来表的结构就支持了transaction和atomic数据定义的改变。这样我们可以使用一个基于LRU的memory cache来保存partition的定义，表的定义等等。这样可以有效的降低了IO的消耗。&lt;/p&gt;



&lt;p&gt;下面我们来看几种常见的存储引擎：&lt;/p&gt;



&lt;h3&gt;InnoDB引擎&lt;/h3&gt;



&lt;p&gt;我们其实上文也提到过，InnoDB是MySQL默认的也是最常见的存储引擎。它主要应用于那些很短的transaction。另外它的性能很好，且支持自动crash恢复，所以常见的无transaction应用也会使用它。&lt;/p&gt;



&lt;p&gt;InnoDB使用的MVCC来实现concurrency的处理，并且实现了所有的四种隔离。默认是Repeatable read的隔离。它使用的cluster index，所以primary key的查询很快，但是secondary index则有可能受primary key影响。&lt;/p&gt;



&lt;p&gt;InnoDB有一些内置的优化，比如预测读，内存哈希索引加速查询，插入buffer来加速插入操作等。后面我们会再写几篇文章来详细介绍这些内容。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;JSON&lt;/strong&gt;&lt;strong&gt;文档支持&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;从5.7版本开始，MySQL的InnoDB开始支持JSON格式的自动validation以及快速读。和以前的BLOB的存储方式相比有了很大的进步。紧接着InnoDB设置可以支持一些基于JSON的SQL函数。8.0.7之后，开始支持JSON数组的多指索引。这可以进一步加速JSON格式的匹配某种pattern的读速度。&lt;/p&gt;



&lt;h3&gt;MYISAM&lt;/h3&gt;



&lt;p&gt;这个引擎是MySQL的第一个引擎，也是5.6之前的默认引擎。它不支持transaction也不支持行锁。在8.0中已经完全移除了。&lt;/p&gt;



&lt;h3&gt;Archive Engine&lt;/h3&gt;



&lt;p&gt;Archive Engine只支持INSERT和SELECT查询，直到5.1才支持索引，相比来说，磁盘IO消耗会小很多。它只是一个简单的为高速插入和压缩设计的引擎。&lt;/p&gt;



&lt;h3&gt;CSV Engine&lt;/h3&gt;



&lt;p&gt;CSB引擎可以把逗号分割文件解析成表格，但是不支持索引。所以可以很方便地进行csv文件的导入和导出。&lt;/p&gt;



&lt;h3&gt;Memory Engine&lt;/h3&gt;



&lt;p&gt;这个引擎是用来匹配快速读写或者不需要在重启时保存的场景的。所有的数据都是保存在memory中，所以查询速度很快，不需要等待I/O。但是不会有数据保存。其实MySQL内部会使用它来作为一些临时表的结果保存。当然数据太大，也会把它转变成其他格式比如MyISAM表保存到磁盘中等。&lt;/p&gt;



&lt;h3&gt;Merge Storage Engine&lt;/h3&gt;



&lt;p&gt;它是多个MyISAM的组合，现在已经被废弃了。&lt;/p&gt;



&lt;h2&gt;总结&lt;/h2&gt;



&lt;p&gt;至此，本文详细介绍了MySQL的基本架构以及常见的并行控制，transaction, replication的实现。最后还介绍了各种不同的Storage Engine，希望大家阅读后能对MySQL有一个大概的了解。&lt;/p&gt;
                                                    &lt;nav class=&quot;pagination group&quot;&gt;
                      &lt;/nav&gt;
        &lt;/div&gt;

        
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5d569afef5a39f6c3c6cea776bf87b84</guid>
<title>工具 | 一款 Golang 实现的分布式事务管理器</title>
<link>https://toutiao.io/k/curakqj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cd0334c95b94f28c61bc9ff6e613b0d7</guid>
<title>你觉得我的这段 Java 代码还有优化的空间吗？</title>
<link>https://toutiao.io/k/lqm7cmx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article class=&quot;article-content&quot;&gt;
&lt;p&gt;上周，因为要测试一个方法的在并发场景下的结果是不是符合预期，我写了一段单元测试的代码。写完之后截了个图发了一个朋友圈，很多人表示短短的几行代码，涉及到好几个知识点。&lt;/p&gt;
&lt;p&gt;还有人给出了一些优化的建议。那么，这是怎样的一段代码呢？涉及到哪些知识，又有哪些可以优化的点呢？&lt;/p&gt;
&lt;p&gt;让我们来看一下。&lt;/p&gt;
&lt;h3&gt;背景&lt;/h3&gt;
&lt;p&gt;先说一下背景，也就是要知道我们单元测试要测的这个方法具体是什么样的功能。我们要测试的服务是AssetService，被测试的方法是update方法。&lt;/p&gt;
&lt;p&gt;update方法主要做两件事，第一个是更新Asset、第二个是插入一条AssetStream。&lt;/p&gt;
&lt;p&gt;更新Asset方法中，主要是更新数据库中的Asset的信息，这里为了防止并发，使用了乐观锁。&lt;/p&gt;
&lt;p&gt;插入AssetStream方法中，主要是插入一条AssetStream的流水信息，为了防止并发，这里在数据库中增加了唯一性约束。&lt;/p&gt;
&lt;p&gt;为了保证数据一致性，我们通过本地事务将这两个操作包在同一个事务中。&lt;/p&gt;
&lt;p&gt;以下是主要的代码，当然，这个方法中还会有一些前置的幂等性校验、参数合法性校验等，这里就都省略了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Service
public class AssetServiceImpl implements AssetService {

    @Autowired
    private TransactionTemplate transactionTemplate;

    @Override
    public String update(Asset asset) {
        //参数检查、幂等校验、从数据库取出最新asset等。
        return transactionTemplate.execute(status -&amp;gt; {
            updateAsset(asset);
            return insertAssetStream(asset);
        });
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为这个方法可能会在并发场景中执行，所以该方法通过事务+乐观锁+唯一性约束做了并发控制。关于这部分的细节就不多讲了，大家感兴趣的话后面我再展开关于如何防并发的内容。&lt;/p&gt;
&lt;h3&gt;单测&lt;/h3&gt;
&lt;p&gt;因为上面这个方法是可能在并发场景中被调用的，所以需要在单测中模拟并发场景，于是，我就写了以下的单元测试的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class AssetServiceImplTest {

    private static ThreadFactory namedThreadFactory = new ThreadFactoryBuilder()
        .setNameFormat(&quot;demo-pool-%d&quot;).build();

    private static ExecutorService pool = new ThreadPoolExecutor(5, 100,
        0L, TimeUnit.MILLISECONDS,
        new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(128), namedThreadFactory, new ThreadPoolExecutor.AbortPolicy());

    @Autowired
    AssetService assetService;

    @Test
    public void test_updateConcurrent() {
        Asset asset = getAsset();
        //参数的准备
        //...

        //并发场景模拟
        CountDownLatch countDownLatch = new CountDownLatch(10);
        AtomicInteger failedCount =new AtomicInteger();            
        //并发批量修改，只有一条可以修改成功
        for (int i = 0; i &amp;lt; 10; i++) {
            pool.execute(() -&amp;gt; {
                try {
                    String streamNo = assetService.update(asset);
                } catch (Exception e) {
                    System.out.println(&quot;Error : &quot; + e);
                    failedCount.getAndIncrement();
                } finally {
                    countDownLatch.countDown();
                }
            });
        }

        try {
            //主线程等子线程都执行完之后查询最新的资产
            countDownLatch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        Assert.assertEquals(failedCount.intValue(), 9);

        // 从数据库中反查出最新的Asset
        // 再对关键字段做注意校验
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上，就是我做了简化之后的单元测试的部分代码。因为要测并发场景，所以这里面涉及到了很多并发相关的知识。&lt;/p&gt;
&lt;p&gt;很多人之前和我说，并发相关的知识自己了解的很多，但是好像没什么机会写并发的代码。其实，单元测试就是个很好的机会。&lt;/p&gt;
&lt;p&gt;我们来看看上面的代码涉及到哪些知识点？&lt;/p&gt;
&lt;h3&gt;知识点&lt;/h3&gt;
&lt;p&gt;以上这段单元测试的代码中涉及到几个知识点，我这里简单说一下。&lt;/p&gt;
&lt;h4&gt;线程池&lt;/h4&gt;
&lt;p&gt;这里面因为要模拟并发的场景，所以需要用到多线程， 所以我这里使用了线程池，而且我没有直接用Java提供的Executors类创建线程池。&lt;/p&gt;
&lt;p&gt;而是使用guava提供的ThreadFactoryBuilder来创建线程池，使用这种方式创建线程时，不仅可以避免OOM的问题，还可以自定义线程名称，更加方便的出错的时候溯源。（&lt;a href=&quot;https://www.hollischuang.com/archives/2888&quot;&gt;关于线程池创建的OOM问题&lt;/a&gt;）&lt;/p&gt;
&lt;h4&gt;CountDownLatch&lt;/h4&gt;
&lt;p&gt;因为我的单元测试代码中，希望在所有的子线程都执行之后，主线程再去检查执行结果。&lt;/p&gt;
&lt;p&gt;所以，如何使主线程阻塞，直到所有子线程执行完呢？这里面用到了一个同步辅助类CountDownLatch。&lt;/p&gt;
&lt;p&gt;用给定的计数初始化 CountDownLatch。由于调用了 countDown() 方法，所以在当前计数到达零之前，await 方法会一直受阻塞。（&lt;a href=&quot;https://www.hollischuang.com/archives/290&quot;&gt;多线程中CountDownLatch的用法&lt;/a&gt;）&lt;/p&gt;
&lt;h4&gt;AtomicInteger&lt;/h4&gt;
&lt;p&gt;因为我在单测代码中，创建了10个线程，但是我需要保证只有一个线程可以执行成功。所以，我需要对失败的次数做统计。&lt;/p&gt;
&lt;p&gt;那么，如何在并发场景中做计数统计呢，这里用到了AtomicInteger，这是一个原子操作类，可以提供线程安全的操作方法。&lt;/p&gt;
&lt;h4&gt;异常处理&lt;/h4&gt;
&lt;p&gt;因为我们模拟了多个线程并发执行，那么就一定会存在部分线程执行失败的情况。&lt;/p&gt;
&lt;p&gt;因为方法底层没有对异常进行捕获。所以需要在单测代码中进行异常的捕获。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    try {
        String streamNo = assetService.update(asset);
    } catch (Exception e) {
        System.out.println(&quot;Error : &quot; + e);
        failedCount.increment();
    } finally {
        countDownLatch.countDown();
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码中，try、catch、finall都用上了，而且位置是不能调换的。失败次数的统计一定要放到catch中，countDownLatch的countDown也一定要放到finally中。&lt;/p&gt;
&lt;h4&gt;Assert&lt;/h4&gt;
&lt;p&gt;这个相信大家都比较熟悉，这就是JUnit中提供的断言工具类，在单元测试时可以用做断言。这就不详细介绍了。&lt;/p&gt;
&lt;h3&gt;优化点&lt;/h3&gt;
&lt;p&gt;以上代码涉及到了很多知识点，但是，难道就没有什么优化点了吗？&lt;/p&gt;
&lt;p&gt;首先说一下，其实单元测试的代码对性能、稳定性之类的要求并不高，所谓的优化点，也并不是必要的。这里只是说讨论下，如果真的是要做到精益求精，还有什么点可以优化呢？&lt;/p&gt;
&lt;h4&gt;使用LongAdder代替AtomicInteger&lt;/h4&gt;
&lt;p&gt;我的朋友圈的网友@zkx 提出，可以使用LongAdder代替AtomicInteger。&lt;/p&gt;
&lt;p&gt;java.util.concurrency.atomic.LongAdder是Java8新增的一个类，提供了原子累计值的方法。而且在其Javadoc中也明确指出其性能要优于AtomicLong。&lt;/p&gt;
&lt;p&gt;首先它有一个基础的值base，在发生竞争的情况下，会有一个Cell数组用于将不同线程的操作离散到不同的节点上去(会根据需要扩容，最大为CPU核数，即最大同时执行线程数)，sum()会将所有Cell数组中的value和base累加作为返回值。&lt;/p&gt;
&lt;p&gt;核心的思想就是将AtomicLong一个value的更新压力分散到多个value中去，从而降低更新热点。所以在激烈的锁竞争场景下，LongAdder性能更好。&lt;/p&gt;
&lt;h4&gt;增加并发竞争&lt;/h4&gt;
&lt;p&gt;朋友圈网友 Cafebabe 和 @普渡众生的面瘫青年 都提到同一个优化点，那就是如何增加并发竞争。&lt;/p&gt;
&lt;p&gt;这个问题其实我在发朋友圈之前就有想到过，心中早已经有了答案，只不过有两位朋友能够几乎同时提到这一点还是很不错的。&lt;/p&gt;
&lt;p&gt;我们来说说问题是什么。&lt;/p&gt;
&lt;p&gt;我们为了提升并发，使用线程池创建了多个线程，想让多个线程并发执行被测试的方法。&lt;/p&gt;
&lt;p&gt;但是，我们是在for循环中依次执行的，那么理论上这10次update方法的调用是顺序执行的。&lt;/p&gt;
&lt;p&gt;当然，因为有CPU时间片的存在，这10个线程会争抢CPU，真正执行的过程中还是会发生并发冲突的。&lt;/p&gt;
&lt;p&gt;但是，为了稳妥起见，我们还是需要尽量模拟出多个线程同时发起方法调用的。&lt;/p&gt;
&lt;p&gt;优化的方法也比较简单，那就是在每一个update方法被调用之前都wait一下，直到所有的子线程都创建成功了，再开始一起执行。&lt;/p&gt;
&lt;p&gt;这就还可以用都到我们前面讲过的CountDownLatch。&lt;/p&gt;
&lt;p&gt;所以，最终优化后的单测代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//主线程根据此CountDownLatch阻塞
CountDownLatch mainThreadHolder = new CountDownLatch(10);

//并发的多个子线程根据此CountDownLatch阻塞
CountDownLatch multiThreadHolder = new CountDownLatch(1);

//失败次数计数器
LongAdder failedCount = new LongAdder();

//并发批量修改，只有一条可以修改成功
for (int i = 0; i &amp;lt; 10; i++) {
    pool.execute(() -&amp;gt; {
        try {
            //子线程等待，等待主线程通知后统一执行
            multiThreadHolder.await();
            //调用被测试的方法
            String streamNo = assetService.update(asset);
        } catch (Exception e) {
            //异常发生时，对失败计数器+1
            System.out.println(&quot;Error : &quot; + e);
            failedCount.increment();
        } finally {
            //主线程的阻塞器奇数-1
            mainThreadHolder.countDown();
        }
    });
}

//通知所有子线程可以执行方法调用了
multiThreadHolder.countDown();

try {
    //主线程等子线程都执行完之后查询最新的资产池计划
    mainThreadHolder.await();
} catch (InterruptedException e) {
    e.printStackTrace();
}

//断言，保证失败9次，则成功一次
Assert.assertEquals(failedCount.intValue(), 9);

// 从数据库中反查出最新的Asset
// 再对关键字段做注意校验
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上，就是关于我的一次单元测试的代码所涉及到的知识点，以及目前所能想到的相关的优化点。&lt;/p&gt;
&lt;p&gt;第一次被公众号上近20万读者在线CodeReview，有点小小紧张。但是还是想问一下，对于这部分代码，你觉得还有什么可以优化的地方吗？&lt;/p&gt;
&lt;center&gt;&lt;b&gt;(全文完)&lt;/b&gt;&lt;/center&gt;&lt;hr/&gt;&lt;center&gt;&lt;b&gt;扫描二维码，关注作者微信公众号&lt;/b&gt;&lt;/center&gt;&lt;img src=&quot;http://www.hollischuang.com/wp-content/uploads/2019/04/二维码.png&quot;/&gt;
&lt;/article&gt;
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e143550e8d8a3810154f7b5ce6783fb3</guid>
<title>拆解一个 Elasticsearch Nested 类型复杂查询问题</title>
<link>https://toutiao.io/k/0l1fca4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、线上实战问题&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前置说明：本文是线上环境的实战问题拆解，涉及复杂 DSL，看着会很长，但强烈建议您耐心读完。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;问题描述&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;有个复杂的场景涉及到按照求和后过滤，user_id是用户编号，gender是性别，time_label是时间标签，时间标签是nested结构，intent_order_count是意向订单数量，time是对应时间。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在要筛选出在20210510~20210610，意向订单数总和为26的男性用户，请问应该怎么写dsl语句？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;感觉这个场景很复杂，涉及到array判断后求和，然后求和结果做筛选条件。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;请帮忙看看有什么好的dsl语句，或者改变现有mapping结构。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个是mapping结构 如下：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;PUT index_personal&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;mappings&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;properties&quot;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;time_label&quot;&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;nested&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;properties&quot;&lt;/span&gt;: {&lt;br/&gt;          &lt;span&gt;&quot;intent_order_count&quot;&lt;/span&gt;: {&lt;br/&gt;            &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;long&quot;&lt;/span&gt;&lt;br/&gt;          },&lt;br/&gt;          &lt;span&gt;&quot;time&quot;&lt;/span&gt;: {&lt;br/&gt;            &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;long&quot;&lt;/span&gt;&lt;br/&gt;          }&lt;br/&gt;        }&lt;br/&gt;      },&lt;br/&gt;      &lt;span&gt;&quot;user_id&quot;&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;keyword&quot;&lt;/span&gt;&lt;br/&gt;      },&lt;br/&gt;      &lt;span&gt;&quot;gender&quot;&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;keyword&quot;&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;下面是我构造的数据：&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;PUT index_personal/_doc/1&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;user_id&quot;&lt;/span&gt;: &lt;span&gt;&quot;1&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;gender&quot;&lt;/span&gt;: &lt;span&gt;&quot;male&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;time_label&quot;&lt;/span&gt;: [&lt;br/&gt;    {&lt;br/&gt;      &lt;span&gt;&quot;time&quot;&lt;/span&gt;: 20210601,&lt;br/&gt;      &lt;span&gt;&quot;intent_order_count&quot;&lt;/span&gt;: 3&lt;br/&gt;    },&lt;br/&gt;    {&lt;br/&gt;      &lt;span&gt;&quot;time&quot;&lt;/span&gt;: 20210602,&lt;br/&gt;      &lt;span&gt;&quot;intent_order_count&quot;&lt;/span&gt;: 2&lt;br/&gt;    },&lt;br/&gt;    {&lt;br/&gt;      &lt;span&gt;&quot;time&quot;&lt;/span&gt;: 20210605,&lt;br/&gt;      &lt;span&gt;&quot;intent_order_count&quot;&lt;/span&gt;: 20&lt;br/&gt;    },&lt;br/&gt;    {&lt;br/&gt;      &lt;span&gt;&quot;time&quot;&lt;/span&gt;: 20210606,&lt;br/&gt;      &lt;span&gt;&quot;intent_order_count&quot;&lt;/span&gt;: 1&lt;br/&gt;    },&lt;br/&gt;    {&lt;br/&gt;      &lt;span&gt;&quot;time&quot;&lt;/span&gt;: 20210611,&lt;br/&gt;      &lt;span&gt;&quot;intent_order_count&quot;&lt;/span&gt;: 15&lt;br/&gt;    }&lt;br/&gt;  ]&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;PUT index_personal/_doc/2&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;user_id&quot;&lt;/span&gt;: &lt;span&gt;&quot;2&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;gender&quot;&lt;/span&gt;: &lt;span&gt;&quot;female&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;PUT index_personal/_doc/3&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;user_id&quot;&lt;/span&gt;: &lt;span&gt;&quot;3&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;gender&quot;&lt;/span&gt;: &lt;span&gt;&quot;male&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;time_label&quot;&lt;/span&gt;: [&lt;br/&gt;    {&lt;br/&gt;      &lt;span&gt;&quot;time&quot;&lt;/span&gt;: 20210102,&lt;br/&gt;      &lt;span&gt;&quot;intent_order_count&quot;&lt;/span&gt;: 12&lt;br/&gt;    },&lt;br/&gt;    {&lt;br/&gt;      &lt;span&gt;&quot;time&quot;&lt;/span&gt;: 20210202,&lt;br/&gt;      &lt;span&gt;&quot;intent_order_count&quot;&lt;/span&gt;: 33&lt;br/&gt;    }&lt;br/&gt;  ]&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;问题扩展解释：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;1、&quot;intent_order_count&quot;代表：是订单数，不过都可以抽象成这个用户某个时间买了几个。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;比如第三条数据，表示用户编号为 3 的用户，是男性用户，曾经在 20210102 时有12个意向订单（跟订单一个意思），在 20210202 有 33 个意向订单，&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;2、每个用户除了性别还有很多属性，篇幅受限，没有列出。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;问题来源：https://t.zsxq.com/FmEeaIY&lt;/span&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、数据建模探讨&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.1 原问题 Nested 模型&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;原有数据，以 Nested 建模，存储结构如下：&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;user_id&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;gender&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;time_label {time:intent_order_count}&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;1&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;male&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;[ {20210601:3} {20210602:2}{20210605:20}{20210606:1}{20210611:15}]&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;2&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;female&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;3&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;male&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;{ 20210102:12}{20210202:33}&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以上表示并不严谨，仅是为了更直观的阐述问题。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.2 宽表建模方案&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;拿到问题后，我的第一反应：建模可能有问题。&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;第一：time 存储的是日期，应该是日期类型：date。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;第二：宽表拉平存储是不是更好？！也就是说：针对：“user_id” 的用户，一个时间数据，对应一个 document 文档。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;原有的 nested 结构，改成如下的一条条的记录，也就是“宽表”，类似简化存储如下：&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;user_id&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;gender&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;time&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;intent_order_count&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;1&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;male&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;20210601&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;3&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;1&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;male&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;20210602&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;2&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;1&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;male&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;20210605&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;20&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;1&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;male&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;20210606&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;1&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;1&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;male&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;20210611&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;15&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;2&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;female&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;3&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;male&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;20210102&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;12&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;3&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;male&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;20210202&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;33&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“宽表”是典型的以空间换时间的方案，我们肉眼看到的：对于 user_id=1 的 用户，user_id, gender 信息会存储 N 份（每多一次 time，就多存储一次）。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如前所述，每个用户除了性别还有很多属性，也就是属性非常多的话，会产生大量的冗余存储。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;宽表方案优缺点如下：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;优点&lt;/span&gt;&lt;span&gt;：更利用用户理解，写入和更新非常方便且效率高。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;缺点&lt;/span&gt;&lt;span&gt;：存在大量冗余存储，耗费空间大。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;针对“宽表”方案，问题提出者球友的反馈如下：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“这确实也是个思路。但是我的这个场景下，每个用户除了性别还有很多属性，这样会每天都会产生大量的冗余数据。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;是否有办法将一个用户的时间信息聚集到一个文档下，然后也能够查询，对查询效率要求不高。”&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所以，还得从 Nested 建模角度基础上，考虑如何实现查询？&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.3 Nested 建模方案&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;原有建模问题无大碍，只需将：time 字段由 long 类型改为 date 类型，其他保持不变。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;# 新的 Mapping 结构（微调）&lt;/span&gt;&lt;br/&gt;PUT index_personal_02&lt;br/&gt;{&lt;br/&gt; &lt;span&gt;&quot;mappings&quot;&lt;/span&gt;: {&lt;br/&gt;  &lt;span&gt;&quot;properties&quot;&lt;/span&gt;: {&lt;br/&gt;   &lt;span&gt;&quot;time_label&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;nested&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;properties&quot;&lt;/span&gt;: {&lt;br/&gt;     &lt;span&gt;&quot;intent_order_count&quot;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;long&quot;&lt;/span&gt;&lt;br/&gt;     },&lt;br/&gt;     &lt;span&gt;&quot;time&quot;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;date&quot;&lt;/span&gt;&lt;br/&gt;     }&lt;br/&gt;    }&lt;br/&gt;   },&lt;br/&gt;   &lt;span&gt;&quot;user_id&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;keyword&quot;&lt;/span&gt;&lt;br/&gt;   },&lt;br/&gt;   &lt;span&gt;&quot;gender&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;keyword&quot;&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 还是原来的构造数据，改成bulk，占据行数更少&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;PUT index_personal_02/_bulk&lt;br/&gt;{&lt;span&gt;&quot;index&quot;&lt;/span&gt;:{&lt;span&gt;&quot;_id&quot;&lt;/span&gt;:1}}&lt;br/&gt;{&lt;span&gt;&quot;user_id&quot;&lt;/span&gt;:&lt;span&gt;&quot;1&quot;&lt;/span&gt;,&lt;span&gt;&quot;gender&quot;&lt;/span&gt;:&lt;span&gt;&quot;male&quot;&lt;/span&gt;,&lt;span&gt;&quot;time_label&quot;&lt;/span&gt;:[{&lt;span&gt;&quot;time&quot;&lt;/span&gt;:20210601,&lt;span&gt;&quot;intent_order_count&quot;&lt;/span&gt;:3},{&lt;span&gt;&quot;time&quot;&lt;/span&gt;:20210602,&lt;span&gt;&quot;intent_order_count&quot;&lt;/span&gt;:2},{&lt;span&gt;&quot;time&quot;&lt;/span&gt;:20210605,&lt;span&gt;&quot;intent_order_count&quot;&lt;/span&gt;:20},{&lt;span&gt;&quot;time&quot;&lt;/span&gt;:20210606,&lt;span&gt;&quot;intent_order_count&quot;&lt;/span&gt;:1},{&lt;span&gt;&quot;time&quot;&lt;/span&gt;:20210611,&lt;span&gt;&quot;intent_order_count&quot;&lt;/span&gt;:15}]}&lt;br/&gt;{&lt;span&gt;&quot;index&quot;&lt;/span&gt;:{&lt;span&gt;&quot;_id&quot;&lt;/span&gt;:2}}&lt;br/&gt;{&lt;span&gt;&quot;user_id&quot;&lt;/span&gt;:&lt;span&gt;&quot;2&quot;&lt;/span&gt;,&lt;span&gt;&quot;gender&quot;&lt;/span&gt;:&lt;span&gt;&quot;female&quot;&lt;/span&gt;}&lt;br/&gt;{&lt;span&gt;&quot;index&quot;&lt;/span&gt;:{&lt;span&gt;&quot;_id&quot;&lt;/span&gt;:3}}&lt;br/&gt;{&lt;span&gt;&quot;user_id&quot;&lt;/span&gt;:&lt;span&gt;&quot;3&quot;&lt;/span&gt;,&lt;span&gt;&quot;gender&quot;&lt;/span&gt;:&lt;span&gt;&quot;male&quot;&lt;/span&gt;,&lt;span&gt;&quot;time_label&quot;&lt;/span&gt;:[{&lt;span&gt;&quot;time&quot;&lt;/span&gt;:20210102,&lt;span&gt;&quot;intent_order_count&quot;&lt;/span&gt;:12},{&lt;span&gt;&quot;time&quot;&lt;/span&gt;:20210202,&lt;span&gt;&quot;intent_order_count&quot;&lt;/span&gt;:33}]}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;良好的数据建模就好比盖大楼的地基，地基自然是越稳、越实、越牢靠越好！&lt;/span&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3、查询方案拆解&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1 分步骤拆解用户查询需求&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;问题拆解成如下几个部分：&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1.1 筛选出在20210510~20210610&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;铭毅拆解：&lt;/span&gt;&lt;span&gt;这是个范围查询，range query 搞定。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;DSL 写法如下：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;{&lt;br/&gt;    &lt;span&gt;&quot;nested&quot;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;path&quot;&lt;/span&gt;: &lt;span&gt;&quot;time_label&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;query&quot;&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;&quot;bool&quot;&lt;/span&gt;: {&lt;br/&gt;          &lt;span&gt;&quot;must&quot;&lt;/span&gt;: [&lt;br/&gt;            {&lt;br/&gt;              &lt;span&gt;&quot;range&quot;&lt;/span&gt;: {&lt;br/&gt;                &lt;span&gt;&quot;time_label.time&quot;&lt;/span&gt;: {&lt;br/&gt;                  &lt;span&gt;&quot;gte&quot;&lt;/span&gt;: 20210510,&lt;br/&gt;                  &lt;span&gt;&quot;lte&quot;&lt;/span&gt;: 20210601&lt;br/&gt;                }&lt;br/&gt;              }&lt;br/&gt;            }&lt;br/&gt;          ]&lt;br/&gt;        }&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;正常写 Query 不会涉及 Nested，只有涉及 Nested 数据类型，才必须在检索的前半部分加上 Nested 声明，其目的无非告诉 Elasticsearch 后台，这是针对 Nested 类型的检索。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Path 指定的Nested 最外层，在本文指定的是：time_label。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1.2 意向订单数总和为26的男性用户&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;铭毅拆解：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;关于男性用户，这里可以基于性别检索做过滤。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;DSL 写法如下：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;{&lt;br/&gt;  &lt;span&gt;&quot;term&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;gender&quot;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;value&quot;&lt;/span&gt;: &lt;span&gt;&quot;male&quot;&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;关于意向订单:对于 user_id = 1 的用户，意向订单总数就等于 3 + 2 + 20 + 1 + 15 = 41。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;要实现类似的求和，得需要借助 sum Metric 指标聚合实现。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;sum Metric 聚合的前提是：针对某一特定用户形成一个结果，所以其外层是基于用户维度（本文使用：user_id）层面的terms聚合。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了显示出除了聚合结果之外的其他属性列，需要借助 top_hits 的 _source 中的 include 实现。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;DSL 写法大致如下：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&quot;aggs&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;user_id_aggs&quot;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;terms&quot;&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;&quot;field&quot;&lt;/span&gt;: &lt;span&gt;&quot;user_id&quot;&lt;/span&gt;&lt;br/&gt;      },&lt;br/&gt;      &lt;span&gt;&quot;aggs&quot;&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;&quot;top_sales_hits&quot;&lt;/span&gt;: {&lt;br/&gt;          &lt;span&gt;&quot;top_hits&quot;&lt;/span&gt;: {&lt;br/&gt;            &lt;span&gt;&quot;_source&quot;&lt;/span&gt;: {&lt;br/&gt;              &lt;span&gt;&quot;includes&quot;&lt;/span&gt;: [&lt;br/&gt;                &lt;span&gt;&quot;user_id&quot;&lt;/span&gt;,&lt;br/&gt;                &lt;span&gt;&quot;gender&quot;&lt;/span&gt;&lt;br/&gt;              ]&lt;br/&gt;            }&lt;br/&gt;          }&lt;br/&gt;        },&lt;br/&gt;        &lt;span&gt;&quot;resellers&quot;&lt;/span&gt;: {&lt;br/&gt;          &lt;span&gt;&quot;nested&quot;&lt;/span&gt;: {&lt;br/&gt;            &lt;span&gt;&quot;path&quot;&lt;/span&gt;: &lt;span&gt;&quot;time_label&quot;&lt;/span&gt;&lt;br/&gt;          },&lt;br/&gt;          &lt;span&gt;&quot;aggs&quot;&lt;/span&gt;: {&lt;br/&gt;            &lt;span&gt;&quot;sum_count&quot;&lt;/span&gt;: {&lt;br/&gt;              &lt;span&gt;&quot;sum&quot;&lt;/span&gt;: {&lt;br/&gt;                &lt;span&gt;&quot;field&quot;&lt;/span&gt;: &lt;span&gt;&quot;time_label.intent_order_count&quot;&lt;/span&gt;&lt;br/&gt;              }&lt;br/&gt;            }&lt;br/&gt;          }&lt;br/&gt;        }&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如上：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;最外层 terms 聚合：是基于 user_id 的分桶聚合，每个 user_id 的结果聚成一桶。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;内层的聚合包含两个，两个是平级的。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其一：top_hits 指标聚合，用于显示聚合结果之外的字段。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其二：sum 指标聚合，用于对“time_label.intent_order_count”统计结果求和。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;除了上面的两层聚合，又涉及总和结果和 26 进行比较，所以要基于聚合的聚合，也就是子聚合的实现。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;DSL 写法如下：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;     &lt;span&gt;&quot;count_bucket_filter&quot;&lt;/span&gt;: {&lt;br/&gt;          &lt;span&gt;&quot;bucket_selector&quot;&lt;/span&gt;: {&lt;br/&gt;            &lt;span&gt;&quot;buckets_path&quot;&lt;/span&gt;: {&lt;br/&gt;              &lt;span&gt;&quot;totalcount&quot;&lt;/span&gt;: &lt;span&gt;&quot;resellers.sum_count&quot;&lt;/span&gt;&lt;br/&gt;            },&lt;br/&gt;            &lt;span&gt;&quot;script&quot;&lt;/span&gt;: &lt;span&gt;&quot;params.totalcount &amp;gt;= 26&quot;&lt;/span&gt;&lt;br/&gt;          }&lt;br/&gt;        }&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;文中给的实际例子没有满足 26 的文档，所以，这里为了直观显示结果，使用了 &amp;gt;= 26 实现。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1.3 应该怎么写dsl语句？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;铭毅拆解：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;基于上面几个步骤整合到一起，即可实现。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;查询 DSL ——即用户最终期望。查询 DSL 就类似“图纸”、“导航”或“路径”，给出了达到给定目的的可行性路径，后面无非就是：java 或者 Python 代码的“堆砌”实现。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2 最终 DSL&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;POST index_personal_02/_search&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;size&quot;&lt;/span&gt;: 0,&lt;br/&gt;  &lt;span&gt;&quot;query&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;bool&quot;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;must&quot;&lt;/span&gt;: [&lt;br/&gt;        {&lt;br/&gt;          &lt;span&gt;&quot;nested&quot;&lt;/span&gt;: {&lt;br/&gt;            &lt;span&gt;&quot;path&quot;&lt;/span&gt;: &lt;span&gt;&quot;time_label&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;query&quot;&lt;/span&gt;: {&lt;br/&gt;              &lt;span&gt;&quot;bool&quot;&lt;/span&gt;: {&lt;br/&gt;                &lt;span&gt;&quot;must&quot;&lt;/span&gt;: [&lt;br/&gt;                  {&lt;br/&gt;                    &lt;span&gt;&quot;range&quot;&lt;/span&gt;: {&lt;br/&gt;                      &lt;span&gt;&quot;time_label.time&quot;&lt;/span&gt;: {&lt;br/&gt;                        &lt;span&gt;&quot;gte&quot;&lt;/span&gt;: 20210510,&lt;br/&gt;                        &lt;span&gt;&quot;lte&quot;&lt;/span&gt;: 20210601&lt;br/&gt;                      }&lt;br/&gt;                    }&lt;br/&gt;                  }&lt;br/&gt;                ]&lt;br/&gt;              }&lt;br/&gt;            }&lt;br/&gt;          }&lt;br/&gt;        },&lt;br/&gt;        {&lt;br/&gt;          &lt;span&gt;&quot;term&quot;&lt;/span&gt;: {&lt;br/&gt;            &lt;span&gt;&quot;gender&quot;&lt;/span&gt;: {&lt;br/&gt;              &lt;span&gt;&quot;value&quot;&lt;/span&gt;: &lt;span&gt;&quot;male&quot;&lt;/span&gt;&lt;br/&gt;            }&lt;br/&gt;          }&lt;br/&gt;        }&lt;br/&gt;      ]&lt;br/&gt;    }&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;&quot;aggs&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;user_id_aggs&quot;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;terms&quot;&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;&quot;field&quot;&lt;/span&gt;: &lt;span&gt;&quot;user_id&quot;&lt;/span&gt;&lt;br/&gt;      },&lt;br/&gt;      &lt;span&gt;&quot;aggs&quot;&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;&quot;top_sales_hits&quot;&lt;/span&gt;: {&lt;br/&gt;          &lt;span&gt;&quot;top_hits&quot;&lt;/span&gt;: {&lt;br/&gt;            &lt;span&gt;&quot;_source&quot;&lt;/span&gt;: {&lt;br/&gt;              &lt;span&gt;&quot;includes&quot;&lt;/span&gt;: [&lt;br/&gt;                &lt;span&gt;&quot;user_id&quot;&lt;/span&gt;,&lt;br/&gt;                &lt;span&gt;&quot;gender&quot;&lt;/span&gt;&lt;br/&gt;              ]&lt;br/&gt;            }&lt;br/&gt;          }&lt;br/&gt;        },&lt;br/&gt;        &lt;span&gt;&quot;resellers&quot;&lt;/span&gt;: {&lt;br/&gt;          &lt;span&gt;&quot;nested&quot;&lt;/span&gt;: {&lt;br/&gt;            &lt;span&gt;&quot;path&quot;&lt;/span&gt;: &lt;span&gt;&quot;time_label&quot;&lt;/span&gt;&lt;br/&gt;          },&lt;br/&gt;          &lt;span&gt;&quot;aggs&quot;&lt;/span&gt;: {&lt;br/&gt;            &lt;span&gt;&quot;sum_count&quot;&lt;/span&gt;: {&lt;br/&gt;              &lt;span&gt;&quot;sum&quot;&lt;/span&gt;: {&lt;br/&gt;                &lt;span&gt;&quot;field&quot;&lt;/span&gt;: &lt;span&gt;&quot;time_label.intent_order_count&quot;&lt;/span&gt;&lt;br/&gt;              }&lt;br/&gt;            }&lt;br/&gt;          }&lt;br/&gt;        },&lt;br/&gt;        &lt;span&gt;&quot;count_bucket_filter&quot;&lt;/span&gt;: {&lt;br/&gt;          &lt;span&gt;&quot;bucket_selector&quot;&lt;/span&gt;: {&lt;br/&gt;            &lt;span&gt;&quot;buckets_path&quot;&lt;/span&gt;: {&lt;br/&gt;              &lt;span&gt;&quot;totalcount&quot;&lt;/span&gt;: &lt;span&gt;&quot;resellers.sum_count&quot;&lt;/span&gt;&lt;br/&gt;            },&lt;br/&gt;            &lt;span&gt;&quot;script&quot;&lt;/span&gt;: &lt;span&gt;&quot;params.totalcount &amp;gt;= 26&quot;&lt;/span&gt;&lt;br/&gt;          }&lt;br/&gt;        }&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;要强调的点是：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;第一：涉及 Nested 的 query 检索 以及 aggs 聚合，都需要明确指定 Nested Path。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;第二：复杂检索和聚合出错多数是：子聚合的位置放的不对、后括号和前括弧不匹配等，需要多在 Kibana 测试验证。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;第三：Kibana 的一键 DSL 美化快捷键：“ctrl + i” 要掌握和灵活使用。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;相信经过上面的拆解，这个相对“复杂”的 DSL 会变得非但不那么“复杂”，反而非常容易读懂。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3 查询后结果&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&quot;aggregations&quot;&lt;/span&gt; : {&lt;br/&gt;    &lt;span&gt;&quot;user_id_aggs&quot;&lt;/span&gt; : {&lt;br/&gt;      &lt;span&gt;&quot;doc_count_error_upper_bound&quot;&lt;/span&gt; : 0,&lt;br/&gt;      &lt;span&gt;&quot;sum_other_doc_count&quot;&lt;/span&gt; : 0,&lt;br/&gt;      &lt;span&gt;&quot;buckets&quot;&lt;/span&gt; : [&lt;br/&gt;        {&lt;br/&gt;          &lt;span&gt;&quot;key&quot;&lt;/span&gt; : &lt;span&gt;&quot;1&quot;&lt;/span&gt;,&lt;br/&gt;          &lt;span&gt;&quot;doc_count&quot;&lt;/span&gt; : 1,&lt;br/&gt;          &lt;span&gt;&quot;top_sales_hits&quot;&lt;/span&gt; : {&lt;br/&gt;            &lt;span&gt;&quot;hits&quot;&lt;/span&gt; : {&lt;br/&gt;              &lt;span&gt;&quot;total&quot;&lt;/span&gt; : {&lt;br/&gt;                &lt;span&gt;&quot;value&quot;&lt;/span&gt; : 1,&lt;br/&gt;                &lt;span&gt;&quot;relation&quot;&lt;/span&gt; : &lt;span&gt;&quot;eq&quot;&lt;/span&gt;&lt;br/&gt;              },&lt;br/&gt;              &lt;span&gt;&quot;max_score&quot;&lt;/span&gt; : 1.4418328,&lt;br/&gt;              &lt;span&gt;&quot;hits&quot;&lt;/span&gt; : [&lt;br/&gt;                {&lt;br/&gt;                  &lt;span&gt;&quot;_index&quot;&lt;/span&gt; : &lt;span&gt;&quot;index_personal_02&quot;&lt;/span&gt;,&lt;br/&gt;                  &lt;span&gt;&quot;_type&quot;&lt;/span&gt; : &lt;span&gt;&quot;_doc&quot;&lt;/span&gt;,&lt;br/&gt;                  &lt;span&gt;&quot;_id&quot;&lt;/span&gt; : &lt;span&gt;&quot;1&quot;&lt;/span&gt;,&lt;br/&gt;                  &lt;span&gt;&quot;_score&quot;&lt;/span&gt; : 1.4418328,&lt;br/&gt;                  &lt;span&gt;&quot;_source&quot;&lt;/span&gt; : {&lt;br/&gt;                    &lt;span&gt;&quot;gender&quot;&lt;/span&gt; : &lt;span&gt;&quot;male&quot;&lt;/span&gt;,&lt;br/&gt;                    &lt;span&gt;&quot;user_id&quot;&lt;/span&gt; : &lt;span&gt;&quot;1&quot;&lt;/span&gt;&lt;br/&gt;                  }&lt;br/&gt;                }&lt;br/&gt;              ]&lt;br/&gt;            }&lt;br/&gt;          },&lt;br/&gt;          &lt;span&gt;&quot;resellers&quot;&lt;/span&gt; : {&lt;br/&gt;            &lt;span&gt;&quot;doc_count&quot;&lt;/span&gt; : 5,&lt;br/&gt;            &lt;span&gt;&quot;sum_count&quot;&lt;/span&gt; : {&lt;br/&gt;              &lt;span&gt;&quot;value&quot;&lt;/span&gt; : 41.0&lt;br/&gt;            }&lt;br/&gt;          }&lt;br/&gt;        }&lt;br/&gt;      ]&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.6363636363636365&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9ZaFTKG1NEx5UPz5ibywCvIf5r6PdoUgMoAMqmlomgQq4DhmDGMaBJoicaI5taZ0XKbPSfH23qjSQAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;451&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;由于检索 size = 0，所以，只返回了聚合结果，没有返回检索结果。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;由于二层聚合设置了 top_hits,所以返回结果里除了sum_count的聚合结果，还包含的其下钻数据字段：“gender”、“user_id” 信息，如果实际业务还有更多需要召回字段，可以一并 include 包含后返回即可。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4、有没有更简单的方案？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第 3 小节的实现是基于聚合，但实际文档是 Nested 类型的，基于 userr_id 聚合显得非常的&lt;strong&gt;多余&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里自然想到，用检索能否实现？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果简单检索不行，那么脚本检索呢？&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.1 扩展方案 1：脚本检索实战&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;搞一把试试。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;GET index_personal_02/_search&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;query&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;bool&quot;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;must&quot;&lt;/span&gt;: [&lt;br/&gt;        {&lt;br/&gt;          &lt;span&gt;&quot;nested&quot;&lt;/span&gt;: {&lt;br/&gt;            &lt;span&gt;&quot;path&quot;&lt;/span&gt;: &lt;span&gt;&quot;time_label&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;query&quot;&lt;/span&gt;: {&lt;br/&gt;              &lt;span&gt;&quot;bool&quot;&lt;/span&gt;: {&lt;br/&gt;                &lt;span&gt;&quot;must&quot;&lt;/span&gt;: [&lt;br/&gt;                  {&lt;br/&gt;                    &lt;span&gt;&quot;range&quot;&lt;/span&gt;: {&lt;br/&gt;                      &lt;span&gt;&quot;time_label.time&quot;&lt;/span&gt;: {&lt;br/&gt;                        &lt;span&gt;&quot;gte&quot;&lt;/span&gt;: 20210510,&lt;br/&gt;                        &lt;span&gt;&quot;lte&quot;&lt;/span&gt;: 20210613&lt;br/&gt;                      }&lt;br/&gt;                    }&lt;br/&gt;                  },&lt;br/&gt;                  {&lt;br/&gt;                    &lt;span&gt;&quot;script&quot;&lt;/span&gt;: {&lt;br/&gt;                      &lt;span&gt;&quot;script&quot;&lt;/span&gt;: &lt;span&gt;&quot;&quot;&quot;&lt;br/&gt;                        int sum = 0;&lt;br/&gt;                        for (obj in doc[&#x27;time_label.intent_order_count&#x27;]) {&lt;br/&gt;                          sum += obj;&lt;br/&gt;                        } &lt;br/&gt;                        sum &amp;gt;= 10;&quot;&quot;&quot;&lt;/span&gt;&lt;br/&gt;                    }&lt;br/&gt;                  }&lt;br/&gt;                ]&lt;br/&gt;              }&lt;br/&gt;            }&lt;br/&gt;          }&lt;br/&gt;        },&lt;br/&gt;        {&lt;br/&gt;          &lt;span&gt;&quot;term&quot;&lt;/span&gt;: {&lt;br/&gt;            &lt;span&gt;&quot;gender&quot;&lt;/span&gt;: {&lt;br/&gt;              &lt;span&gt;&quot;value&quot;&lt;/span&gt;: &lt;span&gt;&quot;male&quot;&lt;/span&gt;&lt;br/&gt;            }&lt;br/&gt;          }&lt;br/&gt;        }&lt;br/&gt;      ]&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如上逻辑看似非常严谨的脚本，实际是行不通的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;sum += obj; 本质上只求了一个值。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Elastic 官方工程师&lt;/span&gt;&lt;span&gt;给出了详细的解释：“无法在查询时访问脚本中所有嵌套对象的值。脚本查询一次仅适用于一个嵌套对象。”&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;详细讨论参见：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;https://stackoverflow.com/questions/64140179/elasticsearch-sum-up-nested-object-field&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;https://discuss.elastic.co/t/help-for-painless-iterate-nested-fields/162394&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;结论：脚本检索不适用 Nested 嵌套对象求和。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;官方推荐用 Ingest pipeline 预处理方式实现，那就再搞一把。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.2 扩展方案 2：Ingest pipeline 方式实战&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.2.1 步骤 1——设置求和的 pipeline。&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;sum_pipeline 用途：将 nested 嵌套的 intent_order_count 字段进行求和。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;# 设定pipeline，统计计数总和&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;PUT _ingest/pipeline/sum_pipeline&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;processors&quot;&lt;/span&gt;: [&lt;br/&gt;    {&lt;br/&gt;      &lt;span&gt;&quot;script&quot;&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;&quot;source&quot;&lt;/span&gt;: &lt;span&gt;&quot;&quot;&quot;&lt;br/&gt;          ctx.sum_count = ctx.time_label.stream()&lt;br/&gt;            .mapToInt(thing -&amp;gt; thing.intent_order_count)&lt;br/&gt;            .sum()&lt;br/&gt;          &quot;&quot;&quot;&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  ]&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.2.2 步骤 2——结合 pipeline 更新数据&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;注意一下：nested 添加数据需要借助 script 实现，不能直接指定 id 插入。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;若指定 id 插入数据会覆盖掉之前的数据。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;# 新插入数据&lt;/span&gt;&lt;br/&gt;POST index_personal_02/_update_by_query?pipeline=sum_pipeline&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;query&quot;&lt;/span&gt;:{&lt;br/&gt;    &lt;span&gt;&quot;term&quot;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;user_id&quot;&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;&quot;value&quot;&lt;/span&gt;: &lt;span&gt;&quot;1&quot;&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;&quot;script&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;source&quot;&lt;/span&gt;: &lt;span&gt;&quot;ctx._source.time_label.add(params.newlabel)&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;params&quot;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;newlabel&quot;&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;&quot;time&quot;&lt;/span&gt;: 20210702,&lt;br/&gt;        &lt;span&gt;&quot;intent_order_count&quot;&lt;/span&gt;: 88&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.2.3 步骤 3——结合文章开头要求进行检索&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;借助 pipeline 新增的字段 sum_count 可以检索条件之一。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;# 检索结果&lt;/span&gt;&lt;br/&gt;GET index_personal_02/_search&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;query&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;bool&quot;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;must&quot;&lt;/span&gt;: [&lt;br/&gt;        {&lt;br/&gt;          &lt;span&gt;&quot;nested&quot;&lt;/span&gt;: {&lt;br/&gt;            &lt;span&gt;&quot;path&quot;&lt;/span&gt;: &lt;span&gt;&quot;time_label&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;query&quot;&lt;/span&gt;: {&lt;br/&gt;              &lt;span&gt;&quot;bool&quot;&lt;/span&gt;: {&lt;br/&gt;                &lt;span&gt;&quot;must&quot;&lt;/span&gt;: [&lt;br/&gt;                  {&lt;br/&gt;                    &lt;span&gt;&quot;range&quot;&lt;/span&gt;: {&lt;br/&gt;                      &lt;span&gt;&quot;time_label.time&quot;&lt;/span&gt;: {&lt;br/&gt;                        &lt;span&gt;&quot;gte&quot;&lt;/span&gt;: 20210510,&lt;br/&gt;                        &lt;span&gt;&quot;lte&quot;&lt;/span&gt;: 20210601&lt;br/&gt;                      }&lt;br/&gt;                    }&lt;br/&gt;                  }&lt;br/&gt;                ]&lt;br/&gt;              }&lt;br/&gt;            }&lt;br/&gt;          }&lt;br/&gt;        },&lt;br/&gt;        {&lt;br/&gt;          &lt;span&gt;&quot;term&quot;&lt;/span&gt;: {&lt;br/&gt;            &lt;span&gt;&quot;gender&quot;&lt;/span&gt;: {&lt;br/&gt;              &lt;span&gt;&quot;value&quot;&lt;/span&gt;: &lt;span&gt;&quot;male&quot;&lt;/span&gt;&lt;br/&gt;            }&lt;br/&gt;          }&lt;br/&gt;        },&lt;br/&gt;        {&lt;br/&gt;          &lt;span&gt;&quot;range&quot;&lt;/span&gt;: {&lt;br/&gt;            &lt;span&gt;&quot;sum_count&quot;&lt;/span&gt;: {&lt;br/&gt;              &lt;span&gt;&quot;gte&quot;&lt;/span&gt;: 26&lt;br/&gt;            }&lt;br/&gt;          }&lt;br/&gt;        }&lt;br/&gt;      ]&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Ingest pipeline 方案小结：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;通过预处理管道新增字段，以空间换时间。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;新增的字段作为检索的条件之一，不再需要聚合。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5、小结&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;分解是计算思维的核心思想之一，“大事化小，逐个击破”。本文的拆解思路也是基于分解的思想一步步拆解。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本文针对线上问题，抛转引玉，给出了方案拆解和完整的步骤实现。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;共探索出两种可行的方案：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;方案一&lt;strong&gt;本质&lt;/strong&gt;：两重嵌套聚合（terms分桶 + 分桶内 sum 指标聚合）+ 子聚合（基于聚合的聚合 bucket_selector）实现。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;方案二&lt;strong&gt;本质&lt;/strong&gt;：新增求和字段，以空间换时间。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;实战环境类似本文问题，铭毅&lt;/span&gt;&lt;span&gt;推荐使用方案二&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;细节问题待进一步结合线上需求进行扩展修改 DSL。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;欢迎就问题及方案进行留言，说一下您的思考和思路反馈。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;https://discuss.elastic.co/t/script-processor-ingest-pipelines-on-nested-fields/172092/2&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b59c442cb4c09a61ac5b00d8ccef6273</guid>
<title>浅谈 Hbase 在用户画像上的应用</title>
<link>https://toutiao.io/k/1fn2tc3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h2 data-mpa-powered-by=&quot;yiban.io&quot;&gt;背景&lt;/h2&gt;&lt;p&gt;用户画像，即用户信息标签化，是大数据精细化运营和精准营销服务的基础。设计从基础设施建设到应用层面，主要有数据平台搭建及运维管理、数据仓库开发、上层应用的统计分析、报表生成及可视化、用户画像建模、个性化推荐与精准营销等应用方向。&lt;/p&gt;&lt;p&gt;基本流程是：根据人口学特征、浏览行为&amp;amp;内容、社交活动和消费行为等信息而抽象出的一个标签化的用户模型。通过分析用户的基础信息、特征偏好、社会属性等各维度的数据，刻画出用户的信息全貌，从中挖掘用户价值。&lt;/p&gt;&lt;p&gt;用户画像的定义并不复杂，是系统通过用户自行上传或埋点上报收集记录了用户大量信息，为便于各业务应用，将这些信息进行沉淀、加工和抽象，形成一个以用户标志为主 key 的标签树，用于全面刻画用户的属性和行为信息，这就是用户画像。简而言之：画像是由标签树及末级标签的标签值构成的，全面定量刻画用户的结构化信息产品。画像是标签的总成，用户标签是具体刻画用户的结构化信息。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;img data-ratio=&quot;0.48165869218500795&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/TwK74MzofXfeRyelgNjnYI0GdiaXUNy238VsmKEJxVicWiclNskLkdXreHXgTic3PNYCscYyiaeU8Efq9iapaIzqD6ug/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1254&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;介绍&lt;/h2&gt;&lt;p&gt;基础处理逻辑架构：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;img data-ratio=&quot;0.3813620071684588&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/TwK74MzofXfeRyelgNjnYI0GdiaXUNy23O5uP9jaIOYljeqxAaj3Ip1JtWyX358pm767FiaoQQYwlBOLIdtb7H7w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2790&quot;/&gt;&lt;/figure&gt;&lt;p&gt;数仓架构：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;img data-ratio=&quot;0.6583333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/TwK74MzofXfeRyelgNjnYI0GdiaXUNy23kJTplRqYOibnIPQVFGgwfKFhv93ZhOdnJkRWrDqGenLurve4rsSlObw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1440&quot;/&gt;&lt;/figure&gt;&lt;p&gt;主要覆盖模块：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;img data-ratio=&quot;0.5354166666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/TwK74MzofXfeRyelgNjnYI0GdiaXUNy23EJh5b6IdYg1gG8ibhMy06Ha0N8ByIfORT5DK4HBxG3KSniaiaiaMBuCpGA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1440&quot;/&gt;&lt;/figure&gt;&lt;p&gt;数据仓库ETL加工流程是对每日的业务数据、日志数据、埋点数据等数据经过ETL过程，加工到对应的原始数据层（ODS）、数据仓库（DW）、数据集市层（DM）中。&lt;/p&gt;&lt;p&gt;用户画像不是产生数据的源头，是经过ODS层、DW层、DM层中的数据与用户相关数据的二次建模加工得到的数据。&lt;/p&gt;&lt;p&gt;在ETL过程将用户标签写入Hive，根据不同数据对应不同数据库的应用场景，再将数据同步到MySQL、HBase、Elasticsearch等数据库中。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Hive：存储用户标签、用户人群及用户特征库的计算结果&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;MySQL：存储标签元数据，监控相关数据，导出到业务系统的数据&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;HBase：存储线上实时数据&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Elasticsearch：支持海量数据的实时查询分析&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;其中用户画像最主要的两个部分：&lt;/p&gt;&lt;p&gt;&lt;span&gt;指标体系&lt;/span&gt;：&lt;/p&gt;&lt;p&gt;数据指标体系是建立用户画像的关键环节，也是在标签开发前要进行的工作，具体来说就是需要结合企业的业务情况设定相关的指标。&lt;/p&gt;&lt;p&gt;通常我们讲述的指标是指将业务单元精分后量化的度量值，譬如：DAU、订单数、金额等。当然，原子指标还会基于维度、修饰词、统计口径而构建出派生指标。指标的核心意义是它使得业务目标可描述、可度量、可拆解。&lt;/p&gt;&lt;p&gt;一个好的指标体系设计，不能说可以规避掉百分百的问题，但至少让问题出现时各方临危不乱。&lt;/p&gt;&lt;p&gt;首先，业务同学需要对自己的业务有一个大概的预判，譬如：在整体的业务里程碑上什么时间点会有哪些策略动作，对应的业务体量会是多大。与此同时也提前去预知大概会监控哪些指标，从哪些维度拆解等&lt;/p&gt;&lt;p&gt;其次，在有了初步预判之后与团队技术沟通，与数据团队沟通，尽量让各方信息对称。这样的好处是我们能尽量提前将指标体系设计得不重不漏、条理清晰。同时技术团队也会有所准备，在做数据底层设计时多去考虑其稳定性、扩展性等。&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、明确业务是什么&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在搭建指标体系之前，需要明确自己的业务是什么？公司整体的目标是什么？在产品实现上，如何帮助用户解决问题？&lt;/p&gt;&lt;p&gt;譬如像：电商C2C企业，业务本质上要解决的是需求「匹配」和「匹配效率」的问题，是一个不断丰富供给和满足需要的过程。目标上会去追求实现更多用户的双边关系需要，对应到数据去看会衍生出「DAU」、「订单」、「GMV」等战略指标。&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、按业务大盘拆解&lt;/span&gt;&lt;/p&gt;&lt;p&gt;根据企业战略目标，按照业务大盘的方式拆解数据指标体系，在业内有个有名的方法论AARRR（也叫海盗指标法，Acquisition用户获取、Activation用户活跃、Retention用户留存、Revenue营收、Refer传播），整体的拆分逻辑是「获取→活跃→留存→营收→传播」，观察其在业务主流程上，不同阶段实现用户侧买家和卖家需求时，用户会做什么、产生哪些数据、我们需要监控哪些数据。&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、第一关键指标&lt;/span&gt;&lt;/p&gt;&lt;p&gt;“第一关键指标”指的是当前阶段无比重要的第一指标，同时也指出了在创业阶段的任意时间点上应该且只关注一项重要指标。这套理论在我们去考核不同团队的时候同样有借鉴意义，公司当前阶段的“第一关键指标”拆解到不同部门之后，就成了各部门的“第一关键指标”，也是团队的考核度量（OKR或KPI）&lt;/p&gt;&lt;p&gt;例如：订单体系&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;img data-ratio=&quot;0.43680555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/TwK74MzofXfeRyelgNjnYI0GdiaXUNy235sHG9eq8amkNLTicbJWPgRFaRLDmaFo4zx9iaVlKFF5ETFSXQoD3icORA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1440&quot;/&gt;&lt;/figure&gt;&lt;p&gt;数据指标体系设计流程：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;img data-ratio=&quot;0.22033898305084745&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/TwK74MzofXfeRyelgNjnYI0GdiaXUNy23eOnQUxlrOOJE6iaHjp4wpibiaGCad8x0ECKgMHq89CbkLS0zSqP7PAsLQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1534&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;注意：模型未动 ， 指标先行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;常见C端的指标模型：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;img data-ratio=&quot;2.2069444444444444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/TwK74MzofXfeRyelgNjnYI0GdiaXUNy23eDdLe58OIbyat8W7ywGDUTWyo4AIezPhBlxBUwG3Y5KHTAkxZhNMNw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1440&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;标签体系：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在我们建立用户标签时，首先要明确基于哪种维度去建立标签。&lt;/p&gt;&lt;p&gt;一般除了基于用户维度（userid）建立用户标签体系外，还有基于设备维度（cookieid）建立相应的标签体系，当用户没有登录设备时，就需要这个维度。当然这两个维度还可以进行关联。而两者的关联就是需要ID-Mapping算法来解决，这也是一个非常复杂的算法。更多的时候我们还是以用户的唯一标识来建立用户画像。&lt;/p&gt;&lt;p&gt;用户指标体系和用户标签体系的最大的区别是：用户指标是我们定义的一系列和业务相关的统计指标，而标签是在指标上面的一层聚合和模型的定义。虽然可以定义成千上万个指标，但是可能多个指标的聚合才能对用户的某个维度进行打标签。而且标签是分层级的，可以为标签建模提供标签子集，梳理某类别的子分类时，尽可能的遵循MECE原则（相互独立、完全穷尽），最后要依据标签的相识度，标签的权重，以及标签的组合去圈选用户，做精确化营销或者推送。&lt;/p&gt;&lt;p&gt;用户画像指标体系和标签分类从两个不同角度来梳理标签，用户画像指标体系偏战略和应用，标签分类偏管理和技术实现侧。&lt;br/&gt;例如：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;img data-ratio=&quot;0.7177304964539007&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/TwK74MzofXfeRyelgNjnYI0GdiaXUNy23stvSdGVjoM3fs2YcjdDV2veYmLYUgIeyg9xcia1w9vPbiaibZtkruicU2Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1410&quot;/&gt;&lt;/figure&gt;&lt;p&gt;一个比较成熟的画像系统，会有成千上百的标签，这些标签的生产不是一次完成的，而是随着业务的发展需要，逐步补充完善，最终呈现在大家眼前的就是一棵庞大的标签树。所以在前期最重要的仍然是搭好画像骨架，确保后续的发展过程中，依然保持清晰的结构和高延展性。相反的，如果一开始为了抢时间，将大量标签无序的堆在线上，后期管理和使用的难度会迅速凸显出来，重构的代价巨大。&lt;/p&gt;&lt;p&gt;一个好的标签树结构要满足两个条件，“高概括性”和“强延展性”，高概括性意味着结构体系能够很好的包含一个用户的基本属性和产品交互的相关行为，同时对于业务重点单独强调，没有遗漏；“强延展性”意味着结构全面的同时也有一定的抽象概括能力，保证新增的标签可以很好的找到对应的分类，整个体系不会过于收敛局限。&lt;/p&gt;&lt;p&gt;从对用户打标签的方式来看，一般分为三种类型：1、基于统计类的标签；2、基于规则类的标签、3、基于挖掘类的标签。下面我们介绍这三种类型标签的区别：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;统计类标签：这类标签是最为基础也最为常见的标签类型，例如对于某个用户来说，他的性别、年龄、城市、星座、近7日活跃时长、近7日活跃天数、近7日活跃次数等字段可以从用户注册数据、用户访问、消费类数据中统计得出。该类标签构成了用户画像的基础；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;规则类标签：该类标签基于用户行为及确定的规则产生。例如对平台上“消费活跃”用户这一口径的定义为近30天交易次数&amp;gt;=2。在实际开发画像的过程中，由于运营人员对业务更为熟悉、而数据人员对数据的结构、分布、特征更为熟悉，因此规则类标签的规则确定由运营人员和数据人员共同协商确定；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;机器学习挖掘类标签：该类标签通过数据挖掘产生，应用在对用户的某些属性或某些行为进行预测判断。例如根据一个用户的行为习惯判断该用户是男性还是女性，根据一个用户的消费习惯判断其对某商品的偏好程度。该类标签需要通过算法挖掘产生。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;画像通常从八个维度组织标签，分别为：基本属性、平台属性、行为属性、产品偏好、兴趣偏好、敏感度、消费属性、用户生命周期及用户价值，每个维度再分成二级标签、三级标签等。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;img data-ratio=&quot;1.2618055555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/TwK74MzofXfeRyelgNjnYI0GdiaXUNy23Sf2fiaIOLsf4T8HbZPQz0wywNt4ibrwEyaZBw4qz6ia9wVzgrx5B2pylA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1440&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;① 基本属性&lt;/span&gt;&lt;/p&gt;&lt;p&gt;基本属性是指一个用户的基本社会属性和变更频率低的平台特征，例如真实社会年龄、性别、婚姻状况、昵称、号码、账号、lbs 等标签。这些标签类型多为直采型，可从用户基本信息表中直接获取，不需要统计或者算法挖掘。&lt;/p&gt;&lt;p&gt;&lt;span&gt;② 平台属性&lt;/span&gt;&lt;/p&gt;&lt;p&gt;平台属性是用户在平台上表现出的基本属性特征，是利用用户行为进行算法挖掘，标识用户真实属性的标签。&lt;/p&gt;&lt;p&gt;最典型的平台属性标签例如平台年龄标签，这里就有一个疑问，为什么在用户的基础属性中已经有年龄标签，但在平台属性中重复又有一个呢，这里就涉及两者之间的差别。设想一个真实的场景：一个用户社会身份为 20 岁，但他喜欢中年人的穿衣风格，在使用 app 购物的时候，表现出的真实偏好为 30-40 岁，对于这样使用产品时表现出的用户心智和真实年龄不相符合的用户，如果只采用上传的基本属性，给他推荐年轻人喜欢的物品，是不是很难命中个体用户的兴趣呢？&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据源与计算逻辑&lt;/span&gt;：基础属性是利用用户自行上传的存储在用户基础信息表里的数据，平台属性则利用客户端或者服务端埋点上报采集的用户行为数据进行挖掘计算生成。基本属性是典型的直采型标签，平台属性是典型的算法挖掘型标签。&lt;/p&gt;&lt;p&gt;&lt;span&gt;应用场景&lt;/span&gt;：平台属性通过用户行为进行挖掘，更能代表用户的真实倾向，输出结果比基本属性准确率高，在定向营销和算法里，年龄、性别等通常采用平台属性。而社会属性中电话、身份证、账号、昵称等使用较多。&lt;/p&gt;&lt;p&gt;&lt;span&gt;③ 行为属性&lt;/span&gt;&lt;/p&gt;&lt;p&gt;行为属性记录的是用户的全部单点行为，用户的单点行为包括启动、登录、浏览、点击、加车、下单等非常多，而且跟不同的产品，不同的模块交互，不同的时间窗选取，行为就更加复杂了，如何能够全面的梳理，可以按照“产品＊功能模块＊用户单点行为 * 时间”四大要素来组织。&lt;/p&gt;&lt;p&gt;&lt;span&gt;④ 产品偏好&lt;/span&gt;&lt;/p&gt;&lt;p&gt;产品偏好是对用户使用某些产品、产品核心功能或者其他渠道的偏好程度的刻画，属于挖掘型标签，其中产品的选取可以包括自家产品、竞品；功能和渠道包括站内产品功能，也包括 push、短信、开屏、弹窗等几大运营和产品法宝。&lt;/p&gt;&lt;p&gt;示例：搜索模块偏好、直接竞品 _ 京东偏好、短信偏好。&lt;/p&gt;&lt;p&gt;&lt;span&gt;⑤ 兴趣偏好&lt;/span&gt;&lt;/p&gt;&lt;p&gt;兴趣偏好是用户画像内非常重要的维度，以电商产品为例，用户对商品的喜爱程度是用户最终的信息之一，兴趣偏好就是对用户和物品之间的关系进行深度刻画的重要标签，其中最典型的要属品牌偏好、类目偏好和标签偏好。&lt;/p&gt;&lt;p&gt;&lt;span&gt;⑥ 敏感度&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在营销活动时，我们留意到有些用户不需要优惠也会下单，而有些用户一定要通过优惠券刺激才会转化，优惠券的额度也影响了用户下单的金额，这种情况下，如何识别对优惠敏感的用户发放合理的券额的优惠券，保证优惠券不浪费，去报促销活动的 ROI 最大，其中一个很重要的标签就是用户的敏感度标签，敏感度代表用户对平台活动或者优惠的敏感程度，也是典型的挖掘类标签。&lt;/p&gt;&lt;p&gt;示例：热点敏感度、折扣敏感度。&lt;/p&gt;&lt;p&gt;&lt;span&gt;⑦ 消费属性&lt;/span&gt;&lt;/p&gt;&lt;p&gt;无论是电商、内容或者其他领域，公司的目标最终都是收益，所以消费属性往往作为一个单独的维度重点刻画。消费属性包括统计型标签——消费频次、消费金额、最近一次消费时间等，也包括挖掘型标签——消费能力和消费意愿，同时包含敏感度标签——优惠促销敏感度、活动敏感度、新品敏感度、爆款敏感度等。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;⑧ 用户生命周期及用户价值&lt;/span&gt;&lt;/p&gt;&lt;p&gt;用户生命周期是用户运营的重要法典，一个用户从进入产品到离开，通常会经历“新手”“成长”“成熟”“衰退”“流失”5 个典型阶段，每个阶段对用户运营存在策略差异，画像在其中的作用是明确标记用户所处生命周期的阶段，便于后续业务同学落地。&lt;/p&gt;&lt;p&gt;用户价值是体现用户为产品贡献价值高低的标签，最经典的是 RFM 模型获得交易维度标签，与此同时，也应该看到用户的其它价值，例如为产品贡献活跃度，通过裂变拉来新用户，这些都可设计相应的标签。&lt;/p&gt;&lt;p&gt;示例：新手、成长、成熟、衰退、流失、高价值用户、VIP 等级等。&lt;/p&gt;&lt;p&gt;&lt;span&gt;标签命名规范：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在确定好标签后，需要对标签进行命名，以便于管理。&lt;/p&gt;&lt;p&gt;对一个标签，可从多个角度来确定唯一名称。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;img data-ratio=&quot;0.37916666666666665&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/TwK74MzofXfeRyelgNjnYI0GdiaXUNy23NiacJyKEic8XBY8bcc35ExbEFMzpicTZcJtTRAx2DJpHQXxbBTSQ94CWQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1440&quot;/&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;img data-ratio=&quot;0.5604166666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/TwK74MzofXfeRyelgNjnYI0GdiaXUNy236kVSDv3t9Xo9NdOGB9WLkJswnkIYJkvbcSuQ2icBdl7tLD7j4tS5vLw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1440&quot;/&gt;&lt;/figure&gt;&lt;p&gt;1、标签主题&lt;/p&gt;&lt;p&gt;标明属于哪个类型的标签，如人口属性（ATTRITUBE），行为属性（ACTION），用户消费（CONSUME），风险控制（RISKMANAGE）等。&lt;/p&gt;&lt;p&gt;2、用户维度&lt;/p&gt;&lt;p&gt;表明该标签来源，是用户唯一标识（userid），还是用户设备（cookie），一般用U和C区分。&lt;/p&gt;&lt;p&gt;一般常用userid，因为用户设备这块不同操作系统对应的唯一标识可能会有区别，而且在关联用户的时候会比较麻烦。&lt;/p&gt;&lt;p&gt;3、标签类型&lt;/p&gt;&lt;p&gt;标签分类，统计型（01）、规则型（02）、算法型（03）。&lt;/p&gt;&lt;p&gt;4、一级归类&lt;/p&gt;&lt;p&gt;在每个标签大类下面，进一步细分的标签类型。&lt;/p&gt;&lt;p&gt;参照上面的命名方式，举例用户的性别标签：&lt;/p&gt;&lt;p&gt;命名规则：标签主题_用户维度_标签类型_一级归类&lt;/p&gt;&lt;p&gt;【男】：ATTRITUBE_U_01_001&lt;/p&gt;&lt;p&gt;【女】：ATTRITUBE_U_01_002&lt;/p&gt;&lt;p&gt;ps: 实际应该全部显示文本，只有背后实现是字母数字。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.22764227642276422&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TwK74MzofXfeRyelgNjnYI0GdiaXUNy23EUmcyHvQ2wuWmxkbuxjJOLMJC9EKNaSXibFp0h9JSpvv1odmialTuibng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1476&quot;/&gt;&lt;/p&gt;&lt;p&gt;最后可以根据标签数据进行聚合，ER图如下：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;img data-ratio=&quot;0.6229166666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/TwK74MzofXfeRyelgNjnYI0GdiaXUNy23zoiad0o3KHMKEco8FnHTlRic0eicGDMH9X9wryjQGcSUax6Dic3RsYpyuQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1440&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;用户画像流程&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;img data-ratio=&quot;0.3855421686746988&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/TwK74MzofXfeRyelgNjnYI0GdiaXUNy23MDuLVOJWxJRC5UyNwqpogHAFPQQ7ale3DGmiaKVzU6IReT5g1KPeOeA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2822&quot;/&gt;&lt;/figure&gt;&lt;p&gt;● 用户画像基础&lt;/p&gt;&lt;p&gt;了解和明确用户画像包含的模块，设计数据仓库架构、开发流程、表结构，及ETL的设计。主要就是明确大方向的规划。&lt;/p&gt;&lt;p&gt;● 数据指标体系&lt;/p&gt;&lt;p&gt;建立数据指标体系，根据业务线梳理，包括用户属性、用户行为、用户消费、风险控制等维度的指标体系。&lt;/p&gt;&lt;p&gt;● 标签数据存储&lt;/p&gt;&lt;p&gt;设计好数据指标体系后，考虑不同应用场景使用哪种存储方式。&lt;/p&gt;&lt;p&gt;● 标签数据开发&lt;/p&gt;&lt;p&gt;重点模块。标签数据开发包含统计类、规则雷、挖掘类、流式计算类标签的开发，以及人群计算功能的开发。&lt;/p&gt;&lt;p&gt;重点内容：数据调研、和业务方确认数据口径、标签开发上线。打通画像数据和各业务系统之间的路，提供接口服务&lt;/p&gt;&lt;p&gt;● 开发性能调优&lt;/p&gt;&lt;p&gt;标签数据开发上线后，为了缩短调度时间、保证数据稳定性，需要对标签脚本、调度脚本进行迭代重构、调优。梳理现有标签开发、调度、校验告警、同步到服务层等相关脚本、明确可以优化的地方，迭代优化&lt;/p&gt;&lt;p&gt;重点内容：减少ETL调度时间，降低调度时的资源消耗。&lt;/p&gt;&lt;p&gt;● 作业流程调度&lt;/p&gt;&lt;p&gt;标签加工、人群计算、同步数据和业务系统、数据监控预警脚本开发完成后，需要调度工具把整套流程调度起来。&lt;/p&gt;&lt;p&gt;重点内容：满足定式调度、监控预警、失败重试，各调度任务之家的复杂依赖关系。&lt;/p&gt;&lt;p&gt;● 用户画像产品化&lt;/p&gt;&lt;p&gt;产品化的模块包括包括标签视图、用户标签查询、用户分群、透视分析等。&lt;/p&gt;&lt;p&gt;重点内容：满足业务方对用户精准营销的需求。&lt;/p&gt;&lt;p&gt;● 用户画像应用&lt;/p&gt;&lt;p&gt;应用场景包括用户特征分析、短信邮件、站内信、Push消息的精准推送、用户圈选等，客户针对不同用户的话术、针对高价值用户的极速退款等高级服务应用等。&lt;/p&gt;&lt;p&gt;重点内容：帮助业务方理解和应用用户画像数据，提高用户活跃度和GMV。&lt;/p&gt;&lt;p&gt;其中指标体系和标签体系这两个重要的点在上面已经介绍完了。后续主要是标签流程的开发和标签数据的存储。&lt;/p&gt;&lt;blockquote&gt;标签完成梳理和命名后，需要维护一张码表用例记录标签id名称、标签含义及标签口径等主要信息，方便元数据的维护与管理。&lt;br/&gt;用户画像的数据存储的技术选型有多种，不同存储方式适用于不同场景。主要有Hive、MySQL、HBase、Elasticsearch。&lt;br/&gt;在数仓建模过程中，主要是设计事实表和维度表的建模开发。&lt;br/&gt;在画像系统中主要使用Hive作为数据仓库，开发相应的事实表和维度表来存储标签、人群、应用到服务层的相关数据。&lt;/blockquote&gt;&lt;h2&gt;结论&lt;/h2&gt;&lt;p&gt;上面文章主要讨论的用户画像的主要流程，以及用户画像最主要的几个部分。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;用户画像的底层架构；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用户画像的指标定义和筛选；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用户画像的标签体系；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用户画像的标签的命名方式和元数据存储方式。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;系统架构图：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;img data-ratio=&quot;0.6055555555555555&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/TwK74MzofXfeRyelgNjnYI0GdiaXUNy23BjPYq9ibLianiaZkP4vT28L0Lfs945GicISQZlicicWBQ4423yVqBLQAMhVg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1440&quot;/&gt;&lt;/figure&gt;&lt;p&gt;模型架构图：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;img data-ratio=&quot;0.323943661971831&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/TwK74MzofXfeRyelgNjnYI0GdiaXUNy230rJ8VDuyGmjXAJOUP09wlRw2icyRG0yX1Hq02Vg23e78z7LPeP8gshg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2130&quot;/&gt;&lt;/figure&gt;&lt;p&gt;后续还会更新用户标签模型中权重的计算方法（核心算法包括聚类分析、分类算法、时间序列分析、RFM模型、推荐系统算法、关联分析），以及一些常用的标签开发规范，最后会在展现层实现用户画像的使用，例如：用户圈选、推送等等。&lt;/p&gt;&lt;p&gt;目前业内最常用的第三方软件：神策、GrowingIO等都提供了这块的第三方服务。&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUyMDA4OTY3MQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/TwK74MzofXdtvHKjv7OHYYSTQ2QOVuyAia3LaU56kibxKLlX5Lo9bgeUfz1R4JDmdW7ZGYSLqsiaBl3nTOwOmFOFQ/0?wx_fmt=png&quot; data-nickname=&quot;浪尖聊大数据&quot; data-alias=&quot;bigdatatip&quot; data-signature=&quot;主要分享大数据框架，如spark，flink，kafka，hbase原理源码，同时会分享数据仓库，图计算等浪尖擅长领域。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>