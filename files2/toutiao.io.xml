<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>176b6017f18f3f02b424b078d5682236</guid>
<title>基于ES的开源分布式SQL数据库，CrateDB适用于哪些场景？</title>
<link>https://toutiao.io/k/rce7d08</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkwOTIxNDQ3OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8YRIaicYx5pzj5Cxwick8DamnOgbTJu96QTibKyHEDZt1815yOV1r27oZ6HgoYTEYWYLRz4jIV4iasHgg/0?wx_fmt=png&quot; data-nickname=&quot;dbaplus社群&quot; data-alias=&quot;dbaplus&quot; data-signature=&quot;围绕Database、BigData、AIOps的企业级专业社群。资深大咖、技术干货，每天精品原创文章推送，每周线上技术分享，每月线下技术沙龙，每季度Gdevops&amp;amp;DAMS行业大会.&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-id=&quot;7&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;本文根据许鹏&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;老师在〖deeplus直播：开源分布式数据库CrateDB在携程的最佳实践〗线上分享演讲内容整理而成。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;（文末有回放的方式，不要错过）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.3992537313432836&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8Z2mTEo3ILuleeHQhL4AEBextsiaQSZEcVJdicUGR0lof8JmAvzSJAaR6aC7GjxdFQ2EcA0aMW43ajA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1072&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;许鹏&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;携程 研发总监&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;今天的分享主要包含以下几个方面的内容：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;CrateDB介绍&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;CrateDB在携程的实践&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;CrateDB在携程的优化&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot; draggable=&quot;true&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;一、CrateDB介绍&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、CrateDB&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;320&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8aMM5LAR7cRG5qWJFwHMzBXxs6PTEgyXSDKBiaZrwWw5E0PMnXyqv6vITYoYYTKPg2pjcibvBmymib3w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;CrateDB是一款基于ElasticSearch的分布式数据库，它与ElasticSearch最大的区别是提供了ANSI SQL查询访问接口。ElasticSearch在6.X版本以后，也开始提供SQL的查询，但CrateDB与ElasticSearch相比，能够支持多索引之间的关联查询，针对某些聚合函数，它返回的是精确的查询结果，而ElasticSearch返回的是近似值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、CrateDB的特性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CrateDB适用于海量时序数据存储，需要频繁更改的数据使用CrateDB存储效果较差。因为CrateDB基于ElasticSearch，频繁的删改操作会使它的性能大大受损。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CrateDB继承了ElasticSearch设计中高可靠的优点，集群较方便实现扩容，对于一些点查询或复杂度中等的查询均能够较为实时地返回结果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CrateDB支持Dynamic Schema，其最新版本能够支持json数据格式，写入数据更加方便。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我认为CrateDB的初衷是用SQL的方式查询访问基于&lt;span&gt;ElasticSearch&lt;/span&gt;存储的数据。基于这一概念，我们可以看到它大概的分层（如上图所示），从外部访问从下到上依次到达最终的存储，其最外一层提供了PostgresSQL兼容的访问协议和REST API的访问协议，接下来对语句进行解析，然后执行，获取存储在各个节点上的数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、海量数据存储对比&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;因为类似技术较多，这里只对比几个典型的技术，CrateDB、ElasticSearch以及MongoDB，这三者都可以归类于Nosql。下文将从7个维度对三者进行对比。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;320&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8aMM5LAR7cRG5qWJFwHMzBXQm8bncggQ7OicibdzeVcIM3xmHHnf2FLQV6rmXEPkMUq8OSiaCwCNmTZg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）Schema支持类型&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这三个数据库均支持&lt;span&gt;Dynamic Schema&lt;/span&gt;。但在现实的生产环境下，我们推荐采用Struct Schema，因为&lt;span&gt;Dynamic Schema&lt;/span&gt;可能会带来种种问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;paragraph&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section label=&quot;Copyright © 2015 Yead All Rights Reserved.&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;仅代表个人观点，并非适用于所有场景。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）是否支持SQL访问&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;SQL诞生四十多年，已成为非常成熟的语言，具有极强的表达能力。同时SQL具有通用性，被大家普遍接受。CrateDB基于SQL的通用性不断发展，其支持ANSI SQL，并且采用了PostgreSQL协议。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ElasticSearch起初只支持类json格式的查询语法，之后开始提供针对单索引的一些SQL语句支持函数，并不断丰富。&lt;/span&gt;&lt;span&gt;MongoDB据我所知并未直接支持SQL，如果写入SQL语句，需要通过第三方插件才能够被MongoDB识别，这在一定程度上会影响查询性能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3）可扩展性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从可扩展性角度出发，CrateDB和ElasticSearch采用gossip&lt;/span&gt;&lt;span&gt;协议组建集群，简单来说节点之间相应对等。在一个&lt;span&gt;ElasticSearch&lt;/span&gt;集群中，节点可分Master、Coordinator，以及承载数据的Data，一个节点可以同时扮演三个不同的角色，因此它们是对等的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;MongoDB则不同，如果用它来构建一个分布式集群，最起码有三个不同的Host，分别是Config Server、Mongos以及Data，为了实现高可靠，一个分片还需要分成相应的Master或Slave。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;综上所述，从可扩展角度来看，ElasticSearch和CrateDB更好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4）对于关联分析的支持程度&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CrateDB支持跨索引之间的关联分析，而ElasticSearch则使用一些变通的方式支持此类关联查询，这意味着在写入数据时需要做相应变更。MongoDB在4.X版本时不支持关联查询，之后的版本未及时关注，如描述有误，欢迎大家指正。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;5）聚合准确度&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CrateDB和MongoDB返回精确值，ElasticSearch则是返回近似值，虽然返回近似值执行速度快，但其计算的准确度会受到一定影响。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;6）性能&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在查询性能方面， CrateDB和ElasticSearch都能够较好地返回查询结果，上图中列出的耗时为100毫秒。对于较为简单的查询，100毫秒算是较高的消耗，事实上可以在更短的时间内返回结果。后文中会提到我们自己质量环境下的实际耗时。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;7）运维&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;引入一项新技术后，其带来的运维复杂度十分关键。CrateDB和ElasticSearch相较于MongoDB运维复杂度更低。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4、CrateDB系统架构及节点类型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;320&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8aMM5LAR7cRG5qWJFwHMzBXMNI3m6rnJB7cCZicGQWzgpYba0zBoiadnAoGA8NmWdAianicvXk1xxN3yA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;320&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8aMM5LAR7cRG5qWJFwHMzBXDic5QKVyibUm8frFwnWibWibhReazoTfDibssUC4D1aPnlMp5c7z5HuAkuA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上文中提到在CrateDB和&lt;span&gt;ElasticSearch&lt;/span&gt;中节点之间相互对等。以&lt;span&gt;ElasticSearch&lt;/span&gt;举例，由5个节点构成的ElasticSearch集群中起码有两个不同的角色。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该角色需要负责两个方面的工作，分别是管理节点和管理索引。节点加入集群，在集群中创建了多少个不同的索引，这些索引的分片分布在哪些机器上，这些信息都由 Master来管理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们创建好的索引，数据最终要落到一个具体的ElasticSearch节点上，这些最终承载数据的就是数据节点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上图右半部分所示为在生产上部署一个CrateDB或&lt;span&gt;ElasticSearch&lt;/span&gt;集群。&lt;/span&gt;&lt;span&gt;最上方的负载均衡部分可有可无。除上文提到的两种节点类型外，还有一种叫做Coordinator的节点类型，它既不承载具体的数据，也不扮演Master的角色，只接受外部的请求，并将外部请求路由到数据节点上做具体查询，然后在Coordinator节点做一些汇总，最后返回给应用程序。除此之外，ElasticSearch中可能还会有一个叫Ingest的节点类型，这里不进行过多阐述。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;综&lt;/span&gt;&lt;span&gt;上所述，一个CrateDB的表类似于一个ElasticSearch的索引，ElasticSearch中索引由多个不同的分片组成，每一个分片可能会落到某一个数据节点上。为了实现高可靠，一个分片又分成主分片和副本分片，即图中列出的Primary和Secondary。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;5、CrateDB具体操作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）表创建&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个操作和我们平时用PostgreSQL或MySQL创建一张表并无很大差别。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;320&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8aMM5LAR7cRG5qWJFwHMzBXVuKRUmJEZqX9ZiaPwDQroFJCsLn5rhlKJKZggwqNtlic7UQBRRjAcaUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;创建一张职工的表（如上图所示），其中包括姓名、年龄、性别以及住址。这张表根据姓名来进行哈希，哈希的结果分到4个不同的分片中，with后面跟着一些针对索引层面的配置，它的配置项多达几十项。我们最主要关注以下几点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果只有主分片，replica数为0。如果在主分片之外，还有别的副本分片，增加相应的replica数即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ElasticSearch进行刷新数据会从内存刷新到磁盘，不断刷新会降低性能。为了保证更多数据留在内存中，减少刷新的次数，我们可以调节刷新间隔，具体调整根据对数据的新鲜度要求而定。数据只有被刷新后才能被搜索到。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ElasticSearch采用的是write ahead log的方式，这意味着有大量的translog。translog同样将数据从内存写到磁盘，这当中有一个sync的间隔，如果调高这一间隔，可能会加快写入速度，但也有可能带来容错方面的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）乐观并发控制&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CrateDB是基于ElasticSearch的数据库，其在ElasticSearch基础上进行了叫做乐观并发控制的演变。我们将数据写入到某一张表时，有两个隐藏的列，一个是sequence_number，即这一列的版本号，另一个为primary_term，二者联合使用可以实现某一版本的数据只更新一次，避免频繁更新。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;320&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8aMM5LAR7cRG5qWJFwHMzBXXKmm1ZO620Jqc6SjjA8V8EbwL1YFmTU9gG4bT52EEanAEOW132M1CQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上图中的语句为例，对sequence_number等于0进行更新，当这条语句执行成功后，它的sequence_number会自动跳到1，每更新一次，这个值就会递增。如果有两个不同的进程或两个不同的外部访问，试图来更新同一条语句，那么只有一条会被执行成功，这就做到了乐观并发控制。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3）Partitioned Table&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;320&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8aMM5LAR7cRG5qWJFwHMzBXZJsZrNCYKtVFlHD3VrWe43HgpDvIg9ibibKpODoxOjjiaySbHahcsYicgA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CrateDB与ElasticSearch不同，它引入了Partitioned Table的概念，即所谓的分区表。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上文中讲到一个表存在多个分片承载数据，即ElasticSearch的一个索引有多个不同的分片，对应到&lt;span&gt;CrateDB&lt;/span&gt;中是分区，CrateDB中的分区可以与ElasticSearch中的别名相对应。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果我们要查询或写入表的数据量达几十亿或上百亿，将这些表都放到同样一个索引当中，可能会导致查询与写入的速度变慢，我们其实可以把这些数据分成多个不同的分区。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在我们实际的生产中有这样一种情况，一些坐过飞机的用户可能希望查看自己的飞行足迹，如果将所有用户的历史数据都放在同一个索引中，经过查询最后在前端展现的话，速度可能会较慢，因为这一操作对接口的要求较高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;例如要求在50毫秒内返回结果，如果不把这些数据做分区的话，查询会很慢。此处的慢是99%line的情况，在此情况下，我们要达到满足性能指标，其中一个变通方法就是把它拆成多个不同的分区，每个uid进入后只需要到对应的分区表查询即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在做分区的时候有一点需要注意，如果表已经创建了组件，分区的字段必须都属于组件字段的列表，因为这个组件可以由一个列或多个列组成，也可能是一种复合的组件，分区的字段必须在组件的字段列表当中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、CrateDB在携程的实践&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、实时聚合分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;320&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8aMM5LAR7cRG5qWJFwHMzBXuHkDCQX3n72217ztvoXkxU3lznOEnHrOv7arMIjce97mEMxrjKddEQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;上图是我们使用CrateDB之后进行的比较，图中只比较了CrateDB和Presto，我们当时的场景如下。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们有不少的表，每张表的数据量都有几千万条，有的甚至上亿条，需要对数据做比较复杂的聚合。&lt;/span&gt;&lt;span&gt;原来是用Presto查询，因为它是一个看板，每次刷新的间隔延迟较大，为了解决这个问题，我们尝试了一些方法，后来发现用CrateDB效果较好，右侧是性能对比，收益十分明显。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）具体分析场景&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在性能对比方面，采用CrateDB后，我们基本上能够在1~2秒之内返回结果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、海量数据存储以及实时查询&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;在我们实际的生产中有不少实时数据聚合分析的调用。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;320&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8aMM5LAR7cRG5qWJFwHMzBX08uxria2sWpnu382aibuSLEriaXtvKYfzxLKo5R12suS2PnoeYee5yFLw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;起初，我们是将数据放入Redis中，每收到一次取数请求，我们都会进行相应的代码开发，把取出的数据进行相应解析，处理之后返回给调用方。这个需求虽然不复杂，但是因为我们没有办法注入数据分析的逻辑，所以不得不进行代码工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;引入CrateDB后，我们可以将分析工作采用SQL的方式来实现，对于那些用SQL分析不能完全解决掉的剩余部分，则联合一些Groovy脚本完成。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于这样的理念，我们开发了一个模板，我们将SQL写入模板中，指定从哪个表中取数，如何分析，决定取完数后是否需要进行定制的后续处理，如果需要，则执行相应的Groovy的脚本，最后返回结果。这一套流程大大节省了开发的周期，提升了开发的效率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;320&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8aMM5LAR7cRG5qWJFwHMzBXwBHVf07YxV6mvUiaakLthctGKiboOUibhFXBRPwQ8r3KickDGkvOsoSsXg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除开发周期对比外，存储方面的对比也十分显著。&lt;/span&gt;&lt;span&gt;例如数据放入到Redis中，需要200g内存，用CrateDB来存，可能只需要50g，这不仅是数据量上的减少，同时意味着成本的大大缩减。&lt;/span&gt;&lt;span&gt;在携程，有基于RocksDB的存储，它开发有Redis兼容协议，可以做到把数据存储到磁盘上，同时可以用Redis的接口访问。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们将数据存入了磁盘，分别从均线、95%line、99%line三方面对比性能。均线方面还在可以忍受的范围内，当然CrateDB不可能比Redis更快。从上图中可以看出，除99.9%line的时候差距大一点，其他均在可接受的范围内。在数据导入耗时方面，我们运用Spark将数据导入CrateDB，两者差距不是特别大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、CrateDB在携程的优化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、落地时的调优&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;当我们将CrateDB引入整体的技术方案中时，还需要进行一些调优。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;320&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8aMM5LAR7cRG5qWJFwHMzBX5faibNqa2oKb65wa74ia4FWtbBoh3tZ3APY6KfgvpFGKV6KrpcwpMjpg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）磁盘空间调优&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了避免大量磁盘空间的消耗，需要对索引层面进行优化。除此之外，还可以进行聚合优化，关闭列存储。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）update操作优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了提升 update操作的性能，我们建议先insert，然后再删除已有的数据。为了达到目的，可以加上相应的版本号，每次只取最新版本的数据。对于在线更新的需求需要做转换，这也意味着采用CrateDB所能够支持的场景是有受限的,对于严格要求一致，或更新频繁的场景，CrateDB不是很好的选择。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3）查询优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上文中提到采用分区加多个分片的方式优化表结构的存储，使得每一次查询只需要去查尽可能少的分区或分片，查的数据越少、越精准，时间消耗就越短。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4）过期数据删除优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、Spark数据导入&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;在数据导入CrateDB时，我们可能会用 Spark进行操作，此处向大家分享这一过程中的一个细节点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;320&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8aMM5LAR7cRG5qWJFwHMzBXoibLBqjNefs1J7pmK4dovEJouK2tPsqh3DSSQ8m3P2rK2OINibvwnppw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此处用分区举例，如果有一个十几亿或几亿的用户ID，还有一些关联数据，要把它均匀地落到每个分区上，有一种比较简单的方法。我们把 uid（一串字符）进行相应的MD5，MD5之后，取前两位或后两位，就可以得到256个分片。256分片显然太多了，可以再除以一个系数，减少分片数，就可以让这些数据均匀分布，这样可以做到分片上承载的数据量是差不多的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样做的挑战是在写Spark程序时，怎样让每一个partition当中的数据都是落入同一个分片的内容，大家可能会想到repartition函数，但repetition是对某个字段进行哈希，并不能保证落到同一个 partition的数据，这时我们就需要去制定 partition。上图右侧写出了一些伪码，我们在spark中定义一个repartition，然后重载，显示这里可能会有多少个不同的分片。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;假设我们刚才取前两位或取后两位，然后除以4得到64个分片的话，那么我们把传进来的数字跟64取模就对应到某一个具体的partition的位置。在Spark中有&lt;span&gt;partitionB&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;，&lt;span&gt;partitionB&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;只支持rdd算子，DataFrame中没有partitionBy的算子，所以我们需要先把DataFrame或者DataSet转成rdd，通过组成一个 key键值对的方式进行&lt;span&gt;partitionB&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;操作。之后还需要将相应的rdd转换回DataFrame，这样就可以得到一个分布很均匀的 DataFrame，再将其写入CrateDB中，就能达到很快的写入速度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、运维自动化尝试&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;320&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8aMM5LAR7cRG5qWJFwHMzBXJCHJnumJeOZLPicFOaNxyLqfibkQiaIWel6xh5QTKN6N83WnicZEwbfhNw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;我当时是用 Rancher、OpenEBS，以及Nginx Ingress实现了一个在K8S上的CrateDB集群，这使得我们在云环境去部署CrateDB成为一种可能，部署到云上，即便是私有云上，也可以提高硬件使用率，这也是我的初衷。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4、CrateDB admin UI&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;320&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8aMM5LAR7cRG5qWJFwHMzBX1ApqGInUZCbibG5icXSNnlLlKQ0T2FLYtqhv2sXLSRZbf2GrCZLmnRAQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;CrateDB&lt;/span&gt;安装完成后，会打开上图所示的操作界面，我们能够直接写入查询语句，也可以方便地观测到整个集群的状况。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、CrateDB的适用场景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、CrateDB的不足&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Upsert性能较低&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;仅支持NRT查询&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;高阶SQL函数有待实现&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;不支持事务&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;Q&amp;amp;A&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Q1：CrateDB有解决ES字段类型无法修改、写入性能较低和高硬件资源消耗等痛点吗？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; &lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;A1：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;首先，CrateDB支持修改字段类型，这个字段类型的修改和PostgreSQL中相同，可以将varchar改成text，但将varchar类型直接改成time stamp可能就会有问题，这时就不得不从重写或者是进行转换。&lt;/span&gt;&lt;span&gt;其次，写入性能高低分场景，如果只是单独insert的话，它的性能还是很高的，&lt;/span&gt;&lt;span&gt;如果是upsert，或delete与insert掺杂在一起的话，这种混杂这种模式的话，写入性能就会有一些问题，需要进行相应的变通。变通的方式有两种，第一种是先把新数据insert，再把老数据delete。第二种方式是新数据较小的话，可以写入一张另外的临时表中，临时表和新的表进行关联，再做相应的update。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Q2：CrateDB 相比于 Elasticsearch 和 MongoDB ，备份和恢复能力如何？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;A2：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;CrateDB和Elasticsearch在备份和恢复能力层面一样，但是和MongoDB相比，可能更加直观和容易，这是我个人的理解。恢复方面，如果你要求写入时所有数据都吐到磁盘之后才返回，那么所有数据应该都是全部无丢失的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Q3：CrateDB运行一段时间性能会明显降低，除了重启还有什么方案？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;A3：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;CrateDB在实际运维中确实会碰到一些问题，但是我没有碰到性能明显下降的情况。如果有的话，你可以进行索引级别的重建，而不是整个集群的重启，因为集群重启带来的成本较高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Q4：CrateDB日志分析能力如何，有继承ES的ELK能力吗？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;A4：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;在与Logstash和Kibana搭配这一层面，还是ES能力更强。从整个生态圈的角度来看，CrateDB还是不能和&lt;span&gt;Elasticsearch&lt;/span&gt;相比的，因为&lt;span&gt;Elasticsearch&lt;/span&gt;的发展时间久，然后有Logstash和Kibana的加持，在数据的可视化还有分析展现层面确实很强，但是CrateDB可以和另外几个开源的产品搭配使用，比如说Apache Superset但是肯定没有Kibana那种原生定制的强大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Q5：如果把CrateDB部署在k8s上，数据存储应该怎么存放，是分布存储，本地存储，还是集中存储？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;A5：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;上文中提到需要和OpenEBS或Rancher结合，它是分布式处理的，你的节点要附着于相应的存储机器上面，即使Docker挂了，数据是不会丢失掉的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Q6：CrateDB贵司用在TP场景多还是AP场景多？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;A6：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;我们用到的是 AP场景，实时数据的聚合返回结果的，当然每一次查询所命中的数据集并不是特别大，我们要查询的数据集可能是很大的，但是真正被查询条件所命中的还是比较少的，可能是几十万。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Q7：CrateDB 的对标竞品是什么，和大数据生态圈比如hadoop有互补吗 ？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;A7：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;rateDB不是跟Hadoop相竞争，它们两个应该在不同的层面，因为Hadoop是进行离线数据存储的，而CrateDB是做数据分析的。如果要寻找对标竞品的话，我个人认为TimescaleDB是一个很强的竞品，因为它们都号称是时序数据库，同时也提供ANSI SQL的查询标准。从现在的态势来看，可能TimescaleDB获得的用户群更多一点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;活动推荐&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2022 Gdevops全球敏捷运维峰会·广州站将于6月17日举办&lt;/strong&gt;&lt;span&gt;，&lt;/span&gt;&lt;/span&gt;&lt;span&gt;精选数据库热门议题，共同探讨数据库走向技术融合及国产化下的挑战和突破，部分议题抢先剧透：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p draggable=&quot;true&quot;&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.37222222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8bIZLVZhXgDoRxrx4BFKmF6BGkbJzy2kvdoBt5rN7yCHCbEOolLPyamicuNCUHGCZN5exzqtmKXNibg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fc52b959f24c15259a2097db984ebee9</guid>
<title>Golang 常见设计模式之单例模式</title>
<link>https://toutiao.io/k/z2o8bzu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.11875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/OdIoEOgFgUGcibO4v5qxt8aOe6ArwX6qwM3icvwPccBDAjM1eoJTf9QbJ2WcUicIw5QkOiasIKgvNV56qWIXqTcBicg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;之前我们已经看过了 Golang 常见设计模式中的装饰和选项模式，今天要看的是 Golang 设计模式里最简单的单例模式。单例模式的作用是确保无论对象被实例化多少次，全局都只有一个实例存在。根据这一特性，我们可以将其应用到全局唯一性配置、数据库连接对象、文件访问对象等。Go 语言实现单例模式的方法有很多种，下面我们就一起来看一下。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;饿汉式&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;饿汉式实现单例模式非常简单，直接看代码：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;package singleton&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;type singleton struct{}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;var instance = &amp;amp;singleton{}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;func GetSingleton() *singleton {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    return instance&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;singleton 包在被导入时会自动初始化 instance 实例，使用时通过调用 singleton.GetSingleton() 函数即可获得 singleton 这个结构体的单例对象。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种方式的单例对象是在包加载时立即被创建，所以这个方式叫作饿汉式。与之对应的另一种实现方式叫作懒汉式，懒汉式模式下实例会在第一次被使用时被创建。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;需要注意的是，尽管饿汉式实现单例模式的方式简单，但大多数情况下并不推荐。因为如果单例实例化时初始化内容过多，会造成程序加载用时较长。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;懒汉式&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;接下来我们再来看下如何通过懒汉式实现单例模式：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;package singleton&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;type singleton struct{}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;var instance *singleton&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;func GetSingleton() *singleton {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if instance == nil {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        instance = &amp;amp;singleton{}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    return instance&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;相较于饿汉式的实现，懒汉式将实例化 singleton 结构体部分的代码移到了 GetSingleton() 函数内部。这样能够将对象实例化的步骤延迟到 GetSingleton() 第一次被调用时。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不过通过 instance == nil 的判断来实现单例并不十分可靠，如果有多个 goroutine 同时调用 GetSingleton() 就无法保证并发安全。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;支持并发的单例&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;如果你使用 Go 语言写过并发编程，应该很快能想到该如何解决懒汉式单例模式并发安全问题，比如像下面这样：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;package singleton&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import &quot;sync&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;type singleton struct{}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;var instance *singleton&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;var mu sync.Mutex&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;func GetSingleton() *singleton {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    mu.Lock()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    defer mu.Unlock()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if instance == nil {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        instance = &amp;amp;singleton{}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    return instance&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;上面代码的修改是通过加锁机制，即在 GetSingleton() 函数最开始加了如下两行代码：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;mu.Lock()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;defer mu.Unlock()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;加锁的机制可以有效保证这个实现单例模式的函数是并发安全的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不过使用了锁机制也带来了一些问题，这让每次调用 GetSingleton() 时程序都会进行加锁、解锁的步骤，从而导致程序性能的下降。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;双重锁定&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;加锁会导致程序性能下降，但又不用锁又无法保证程序的并发安全。为了解决这个问题有人提出了双重锁定（Double-Check Locking）的方案：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;package singleton&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import &quot;sync&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;type singleton struct{}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;var instance *singleton&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;var mu sync.Mutex&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;func GetSingleton() *singleton {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if instance == nil {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        mu.Lock()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        defer mu.Unlock()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        if instance == nil {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            instance = &amp;amp;singleton{}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    return instance&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;通过上面的可以看到，所谓双重锁定实际上就是在程序加锁前又加了一层 instance == nil 判断，通过这种方式来兼顾性能和安全两个方面。不过这让代码看起来有些奇怪，外层已经判断了 instance == nil，但是加锁后又进行了第二次 instance == nil  判断。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实外层的 instance == nil 判断是为了提高程序的执行效率，免去原来每次调用 GetSingleton() 都上锁的操作，将加锁的粒度更加精细化。简单说就是如果 instance 已经存在，则无需进入 if 逻辑，程序直接返回 instance 即可。而内层的 instance == nil  判断则考虑了并发安全，考虑到万一在极端情况下，多个 goroutine 同时走到了加锁这一步，内层判断会在这里起到作用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;Gopher 惯用方案&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;虽然双重锁定机制兼顾和性能和并发安全，但显然代码有些丑陋，不符合广大 Gopher 的期待。好在 Go 语言在 sync 包中提供了 Once 机制能够帮助我们写出更加优雅的代码：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;package singleton&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import &quot;sync&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;type singleton struct{}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;var instance *singleton&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;var once sync.Once&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;func GetSingleton() *singleton {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    once.Do(func() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        instance = &amp;amp;singleton{}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    })&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    return instance&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Once 是一个结构体，在执行 Do 方法的内部通过 atomic 操作和加锁机制来保证并发安全，且 once.Do 能够保证多个 goroutine 同时执行时 &amp;amp;singleton{} 只被创建一次。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实 Once 并不神秘，其内部实现跟上面使用的双重锁定机制非常类似，只不过把 instance == nil 换成了 atomic 操作，感兴趣的同学可以查看下其对应源码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;以上就是 Go 语言中实现单例模式的几种常用套路，经过对比可以得出结论，最推荐的方式是使用 once.Do 来实现，sync.Once 包帮我们隐藏了部分细节，却可以让代码可读性得到很大提升。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点击↓↓查看 Golang 常见设计模式详解：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODc5ODgyMw==&amp;amp;mid=2653587805&amp;amp;idx=1&amp;amp;sn=f6ef4a4d432a8e041fc4db731f9ba1e5&amp;amp;chksm=bd1b1dd58a6c94c32cd8b1771e8a88364c4ffd7b522446c56a4b03cd7c9c70f9ab1099a372cc&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;‍《Golang 常见设计模式之装饰模式》‍&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《Golang 常见设计模式之装饰模式》&lt;/span&gt;&lt;span/&gt;&lt;/a&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODc5ODgyMw==&amp;amp;mid=2653587299&amp;amp;idx=1&amp;amp;sn=84e36fdc80000f548a97f097f892f79e&amp;amp;chksm=bd1b13eb8a6c9afd3f838df28bbf3ab2c482747389e9afa2824b2ac94243acc523726b1e8785&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《Golang 常见设计模式之选项模式》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《Golang 常见设计模式之选项模式》&lt;/span&gt;&lt;span/&gt;&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;&lt;hr/&gt;&lt;/h2&gt;&lt;h2&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;快 来&lt;/span&gt;&lt;strong&gt;&lt;span&gt; 找 &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;又&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 小 拍&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h2&gt;&lt;h2&gt;&lt;hr/&gt;&lt;/h2&gt;&lt;h2&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;319&quot; data-backw=&quot;546&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;546&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;319&quot; data-fileid=&quot;506103129&quot; data-ratio=&quot;0.5833333333333334&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OdIoEOgFgUFAQemPjhnJTKkl7TwPLibto5mn4m21ZrshVQSeibqIYTw6XqhicImzlLxeW0v3BE4ycJbHd84ic5Oiayg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1200&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;hr/&gt;&lt;section&gt;&lt;span&gt;推 荐 阅 读&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODc5ODgyMw==&amp;amp;mid=2653588146&amp;amp;idx=1&amp;amp;sn=5a194e17a5b5b5a7368a8b371dd0be1a&amp;amp;chksm=bd1b1e3a8a6c972cbd59e930c37c94bf51ea8464514c6484f6c244d382158b498e015dce648e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;273&quot; data-backw=&quot;546&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;546&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;273&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5007751937984496&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OdIoEOgFgUHmhFPaMrOpmxj4d4URh0AoJzsQwupWXFtmaU0NwbXvhGsqpqSyN3GyOWDNXnYgB5eXfHPkSJnJlA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;645&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODc5ODgyMw==&amp;amp;mid=2653588120&amp;amp;idx=1&amp;amp;sn=12b192d93118d81339dd4328fed9c554&amp;amp;chksm=bd1b1e108a6c9706ba903a5aefa87dd775b776c1aaf4a2173b4a8cd7f465256ef3551e85f37e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;273&quot; data-backw=&quot;546&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;546&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;273&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5007751937984496&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OdIoEOgFgUEo6xF6sojk2ZykJiap359VRAhiaXGuJwfeYN3wQ6T9onDluliaIXFZicVSoQMcicyQ7zuKL7lXPaDCic4A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;645&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODc5ODgyMw==&amp;amp;mid=2653587863&amp;amp;idx=1&amp;amp;sn=969372d21ec4a5a0928a3bed5fbf4462&amp;amp;chksm=bd1b1d1f8a6c9409f26ccb4b68ff03a1ee4c2371b8bc0215938154a7bd32a2716602092a083f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;273&quot; data-backw=&quot;546&quot; data-before-oversubscription-url=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OdIoEOgFgUElpXebXbjgibum7I6LiboCtK6KV8gcYQ1mFV2XdonnCrOhaQdtBNh71z1u0JNzcdrx5EQRg56zb0IA/0?wx_fmt=jpeg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;546&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;273&quot; data-fileid=&quot;506103128&quot; data-oversubscription-url=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/OdIoEOgFgUEUylg3O41wsJR8aiasuMebIJsicZ1HyIIL8XbjU22CGg8eV9ZciclQxtibdwcudh6PAicxj2D6ibG3T8mg/0?wx_fmt=jpeg&quot; data-ratio=&quot;0.5007751937984496&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OdIoEOgFgUG2FudNIX0E8qYmDLIzicEIDhl1hFibB1nZLePo5lianibrhmJaGuDYlZshSAczicz8Ipjt9uoeNddNkZw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;645&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;设为星标&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;506103126&quot; data-ratio=&quot;0.9037037&quot; data-type=&quot;png&quot; data-w=&quot;135&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OdIoEOgFgUHbb6jzHdqCC83fulktKZtY2WUNN9vVlgibWSiaR7RDHYbVyTy8icCibHV04APOmEqXhdoJv7GHJDMgvg/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;更新不错过&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h2&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1ed32c47beab83e7dfa96f53e3c35080</guid>
<title>前端周刊：2022-8 期</title>
<link>https://toutiao.io/k/clixoe4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;blockquote&gt;
&lt;p&gt;&quot;如果一段文字没有标签，想要改变里面某个字符的尺寸，在过去只能使用 ::first-letter 伪元素，且只能改变第一个字符的尺寸。&quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cfc0f11c1e9ac1ed1fd2cd4acd32d2cb</guid>
<title>前端:从零到一, 轻松把自己的网站部署到服务器</title>
<link>https://toutiao.io/k/w4mlsvi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9qXnTkZPuxe8H1QicBcbrQQVKOeKw2PsaPtbkhed7icVWmmGk0o3VgYFqKdtNwPFicT2aW803Yp7DqjdiaoFRYVX3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;54&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;跑步本身就是一件孤独的事，他人再分享再加油，要跑到终点也只能倚仗自己的体力和意志，就像生活本来的样子。&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.8&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gUVKXuw5icTuicMe1TSd3CYPJzxFcxUnzpBLmOY2lYosbSmH5Ro01bJbqOVUwZ97d098kTPyiaWWicblornticcLu9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;50&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关注并将「&lt;strong&gt;趣谈前端&lt;/strong&gt;」设为星标&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;每早08:30按时推送&lt;strong&gt;技术干货&lt;/strong&gt;/&lt;strong&gt;优秀开源&lt;/strong&gt;/&lt;strong&gt;技术思维&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU2Mzk1NzkwOA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ibpVQtdHw0UaW5glBQ3RRqy8rYolxkF0tOaAqTUGW9MXPIGvLUGAJ7jB2JicLxJd6xvvWicThNSWFgg/0?wx_fmt=png&quot; data-nickname=&quot;趣谈前端&quot; data-alias=&quot;beautifulFront&quot; data-signature=&quot;徐小夕【知乎专栏作家】掘金优秀作者，定期分享前端工程化，可视化，企业实战项目知识，深度复盘企业中经常遇到的500+技术问题解决方案。【关注趣谈前端，前端路上不迷茫】&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;p&gt;hi, 大家好, 我是徐小夕, 周末博学不打烊, 今天我们来分享点轻松且有用的知识. 作为一名前端工程师, 没有个自己的网站怎么行, 接下来我就来带大家介绍一下如何从零到一, 配置并部署自己的网站到服务器.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;你将收获:&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如何合理选购一台服务器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何将域名解析到服务器上&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务器配套软件的安装和环境配置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过命令行上传自己的网站到服务器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;网站部署和运维(负载均衡等)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;接下来我们来开始fight!&lt;/p&gt;&lt;h3&gt;1. 如何合理选购一台服务器&lt;/h3&gt;&lt;p&gt;对于服务器的选择, 我们主要有以下几种选择:&lt;/p&gt;&lt;p&gt;国内用户如果没有特殊需求可以选择前三种, 这里我以阿里云举例, 当然其他服务器的配置都是相通的.&lt;/p&gt;&lt;h4&gt;1.1 服务器位置的选择&lt;/h4&gt;&lt;p&gt;我们都知道服务器的不同配置都是有讲究的, 并且一定程度上关系到我们网站的用户体验. 在选择服务器地址之前, 我们需要清楚的知道自己网站的用户群体主要集中在哪个区域:&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.49637305699481865&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ibEhXUfBFTgmvtyRnd0YKYngWQsBBBwlHiaXDm526IzCYtbIFKw1v8LXTc2yvpIulLd9NFNA3ibgBXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1930&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;比如我的用户在上海, 我们在&lt;strong&gt;地域及可用区&lt;/strong&gt;选项中可以选择&lt;strong&gt;华东2(上海)&lt;/strong&gt;, 以此类推.&lt;/p&gt;&lt;h4&gt;1.2 服务器镜像的选择&lt;/h4&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2597535934291581&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ibEhXUfBFTgmvtyRnd0YKYnSnlC8AKBWkLdVuy0pjNnicvNaMO8HrLLm0ibfz5W9XX3IdlZaHy2QUyg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1948&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;目前我们常用的服务器镜像有:&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;centos&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;windows Server&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Ubuntu&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;根据自己的使用习惯选择即可, 我一般习惯选择 &lt;strong&gt;centos&lt;/strong&gt;, 接下来也会以 &lt;strong&gt;centos&lt;/strong&gt; 来介绍相关的配置.&lt;/p&gt;&lt;h4&gt;1.3 服务器系统盘存储的选择&lt;/h4&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.15845410628019324&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ibEhXUfBFTgmvtyRnd0YKYnMEpkkfFG7D25CPicNVNdaQt46uPQBBORd1rtnDuw5HGHgk3ia2xFMhIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2070&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;系统存储的选择也需要结合自身网站, 如果网站是内容很多的资源型网站(图片, 视频等), 可以选择稍微大一点的, 比如 &lt;strong&gt;100G&lt;/strong&gt; 以上. 一般个人网站或者测试站&lt;strong&gt;50G&lt;/strong&gt;足已, 毕竟一份存储一份钱.&lt;/p&gt;&lt;h4&gt;1.4 服务器带宽选择&lt;/h4&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.17482517482517482&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ibEhXUfBFTgmvtyRnd0YKYnhM3U4icoOQ80Dbia2o0Lw2xvSmgHolHlYlicXl8NkjRCiaicfic2cwYfDQQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2574&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;一般为了给用户一个好的网站体验, 我们会提高带宽来降低网站加载时间. 但是一味的提高带宽会大大加大服务器的费用, 所以我们一方面需要在对网站自身做好优化, 另一方面也可以使用对象存储, 这样我们就能控制一定的带宽了, 比如目前 &lt;strong&gt;H5-Dooring&lt;/strong&gt; 的带宽在&lt;strong&gt;10M&lt;/strong&gt;左右, 一年服务器费用大概 &lt;strong&gt;1-2W&lt;/strong&gt;. 但是对一些测试型, 个人网站来说, 选择&lt;strong&gt;2-5M&lt;/strong&gt;都是一个合适的范围.&lt;/p&gt;&lt;p&gt;当然大家也可以选择按流量付费.&lt;/p&gt;&lt;h4&gt;1.5 服务器规格选择&lt;/h4&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3139635732870772&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ibEhXUfBFTgmvtyRnd0YKYnafE0QLAoqX3B5lNA4xvAWV8g1Q4RER528qhch3h6YGl3uBt7jckugw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2306&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;如果你是个人使用对吞吐性能没有过多要求, 可以选择&lt;strong&gt;1核1G&lt;/strong&gt;低配版的, 不过建议个人网站最好选择&lt;strong&gt;1核2G&lt;/strong&gt;或者&lt;strong&gt;2核4G&lt;/strong&gt;的, 说不定你的网站就突然🔥了呢?&lt;/p&gt;&lt;p&gt;至于服务器的其他配置,大家都可以随意选择, 也可以直接用默认的.&lt;/p&gt;&lt;h3&gt;2. 如何将域名解析到服务器上&lt;/h3&gt;&lt;p&gt;当我们选购好一台服务器之后, 我们在控制台可以看到自己服务器的&lt;strong&gt;公网IP&lt;/strong&gt;. 这也是域名解析的关键. 域名可以在云服务平台内直接购买, 一般一个域名在&lt;strong&gt;20-60&lt;/strong&gt;¥之间, 推荐使用 &lt;code&gt;.com&lt;/code&gt;, &lt;code&gt;.cn&lt;/code&gt;的域名, 当前其他后缀的域名也可以, 取决于你对网站的定位.&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.29982517482517484&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ibEhXUfBFTgmvtyRnd0YKYnfBRicmiasQet94pIia0BzI07jozlwwW7J8efWrnepRR5NtjGugH7W1I5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2288&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;我们只需要在云服务的域名管理中添加需要解析的服务器记录即可.&lt;/p&gt;&lt;p&gt;上图的&lt;strong&gt;主机记录&lt;/strong&gt;配置中常用的有 &lt;code&gt;www&lt;/code&gt; 和 &lt;code&gt;@&lt;/code&gt;, 我们选择任何一个即可. (主机记录相当于域名的前缀)&lt;/p&gt;&lt;p&gt;&lt;strong&gt;记录值&lt;/strong&gt; 就是我们服务器的IP, 也就是上面提到的&lt;strong&gt;公网IP&lt;/strong&gt;. 我们配置好之后点确认, 等待5-10分钟即可解析完成, 不过一般都在3分钟内.&lt;/p&gt;&lt;p&gt;通过以上方式, 我们的域名就成功解析到对应的服务器上了, 是不是很简单? (前提是域名必须备案, 至于如何备案, 也很简单, 可以按照云厂商指引进行操作)&lt;/p&gt;&lt;h3&gt;3. 服务器配套软件的安装和环境配置&lt;/h3&gt;&lt;p&gt;有了上面服务器的配置基础, 我们开始“倒腾”服务器. 作为一名前端程序员, 服务器上没有&lt;code&gt;nodejs&lt;/code&gt;说不过去了吧! 接下来我们开始安装&lt;code&gt;nodejs&lt;/code&gt;. 在安装之前, 我们需要先进入服务器终端:&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ibEhXUfBFTgmvtyRnd0YKYn0X7zVF17FU8xAI1OP6PTABM9m6Q8LA8al2iabK8LKiaPrvUZ1KR9tHicw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;密钥对一般在服务器列表的右侧更多下拉项里, 我们一般第一次使用需要重置密钥对, 在设置好密钥对之后, 我们在自己计算机的终端输入如下命令:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;ssh root@你的公网IP&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之后在终端输入完密码之后即可进入服务器.&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.18779342723004694&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ibEhXUfBFTgmvtyRnd0YKYn7T5JeSTSCKSYjec5yFcIlicjMVk1Ttk11H2u6FfWAU4wqE4NDcrkOvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;852&quot;/&gt;&lt;/p&gt;&lt;p&gt;如果服务器没有wget, 我建议大家可以安装一下, 毕竟后面很多场景都会用到.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;yum install wget&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;是不是神似我们的&lt;code&gt;npm&lt;/code&gt;. 之后我们就可以开心的安装&lt;code&gt;nodejs&lt;/code&gt;了:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;# 安装nodejs&lt;/span&gt;&lt;br/&gt;wget https://nodejs.org/dist/v14.15.4/node-v14.15.4-linux-x64.tar.xz&lt;br/&gt;&lt;span&gt;# 解压&lt;/span&gt;&lt;br/&gt;tar xf  node-v14.15.4-linux-x64.tar.xz &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;解压完成之后我们可以手动进入 &lt;code&gt;nodejs&lt;/code&gt; 的 &lt;code&gt;bin&lt;/code&gt; 目录, 测测&lt;code&gt;nodejs&lt;/code&gt;是否可用. 但是下载下来的&lt;code&gt;nodejs&lt;/code&gt;的目录名又臭又长, 怎么办呢? 这里就要学好&lt;code&gt;linux&lt;/code&gt;了, 我这里给大家介绍一种简单的重命名文件/目录名的方法:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;mv node-v14.15.4-linux-x64 nodejs&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;mv&lt;/code&gt;是&lt;code&gt;linux&lt;/code&gt;移动文件的命令,当然如果在同一个目录下, 它也可以做重命名功能使用.&lt;/p&gt;&lt;p&gt;最后一步就是配置&lt;code&gt;nodejs&lt;/code&gt;全局环境了. 这里我们也是使用 &lt;code&gt;linux&lt;/code&gt; 的命令&lt;code&gt;ln&lt;/code&gt;.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;ln -s /...你nodejs所在的更目录/nodejs/bin/node  /usr/&lt;span&gt;local&lt;/span&gt;/bin/node&lt;br/&gt;ln -s /...你nodejs所在的更目录/nodejs/bin/npm   /usr/&lt;span&gt;local&lt;/span&gt;/bin/npm&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样我们通过软连接就实现在全局环境下使用&lt;code&gt;nodejs&lt;/code&gt;.&lt;/p&gt;&lt;h3&gt;4. 通过命令行上传自己的网站到服务器&lt;/h3&gt;&lt;p&gt;那么环境有了之后我们就可以直接上传我们的网站代码了, 因为我们选择的是 &lt;strong&gt;centos&lt;/strong&gt; 服务器, 它没有可视化的界面来操作, 而且我的电脑是 &lt;code&gt;mac&lt;/code&gt;的, 这可咋整呢? 不用担心, 继续用命令行!&lt;/p&gt;&lt;p&gt;我们可以使用命令行从本地上传文件或文件夹到服务器, 也可以从服务器下载文件到本地电脑, 这些操作无疑多亏了&lt;code&gt;scp&lt;/code&gt;. 接下来我将演示如何从本地上传文件夹到服务器.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;scp -r 本地文件夹路径 root@你的公网IP:/上传到的服务器路径&lt;br/&gt;&lt;span&gt;# 如&lt;/span&gt;&lt;br/&gt;scp -r ./dist root@xxx.xxx.xxx:/website/&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中&lt;code&gt;-r&lt;/code&gt;是用来传文件夹用的, 如果你要上传的文件包含文件夹, 可以添加这个标识.&lt;/p&gt;&lt;h3&gt;5. 网站部署和运维(负载均衡等)&lt;/h3&gt;&lt;p&gt;网站可以用&lt;code&gt;nginx&lt;/code&gt;代理和做负载均衡, 网上也有很多资料介绍, 这里我带大家介绍一下&lt;code&gt;pm2&lt;/code&gt;.&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.44326990838618746&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ibEhXUfBFTgmvtyRnd0YKYnc5giaW5Scy3hrM9gotABUM7VM2qz3Ka19Z3zelhdyibj6TMnlKLpEWiag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2838&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;PM2 是一个守护进程管理器，它将帮助我们管理和保障应用程序稳定在线. 如果你是nodejs的忠实粉丝, 那么它将是个不错的选择. 作为前端工程师, 搭建全栈的网站用&lt;code&gt;nodejs&lt;/code&gt;也是一个非常高效的选择.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;安装&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;最新的 PM2 版本可以使用 NPM 或 Yarn 安装：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ npm install pm2@latest -g&lt;br/&gt;&lt;span&gt;# or&lt;/span&gt;&lt;br/&gt;$ yarn global add pm2&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;启动应用&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;启动、守护和监控应用程序的最简单方法是使用以下命令行：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ pm2 start app.js&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或轻松启动任何其他应用程序：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ pm2 start bashscript.sh&lt;br/&gt;$ pm2 start python-app.py --watch&lt;br/&gt;$ pm2 start binary-file -- --port 1520&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们可以传递给 CLI 的一些选项：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;# Specify an app name&lt;/span&gt;&lt;br/&gt;--name &amp;lt;app_name&amp;gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# Watch and Restart app when files change&lt;/span&gt;&lt;br/&gt;--watch&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# Set memory threshold for app reload&lt;/span&gt;&lt;br/&gt;--max-memory-restart &amp;lt;200MB&amp;gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# Specify log file&lt;/span&gt;&lt;br/&gt;--&lt;span&gt;log&lt;/span&gt; &amp;lt;log_path&amp;gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# Pass extra arguments to the script&lt;/span&gt;&lt;br/&gt;-- arg1 arg2 arg3&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# Delay between automatic restarts&lt;/span&gt;&lt;br/&gt;--restart-delay &amp;lt;delay &lt;span&gt;in&lt;/span&gt; ms&amp;gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# Prefix logs with time&lt;/span&gt;&lt;br/&gt;--time&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# Do not auto restart app&lt;/span&gt;&lt;br/&gt;--no-autorestart&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# Specify cron for forced restart&lt;/span&gt;&lt;br/&gt;--cron &amp;lt;cron_pattern&amp;gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# Attach to application log&lt;/span&gt;&lt;br/&gt;--no-daemon&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如我们所见，有许多选项可用于使用 &lt;strong&gt;PM2&lt;/strong&gt; 管理我们的应用程序。目前&lt;strong&gt;H5-Dooring&lt;/strong&gt;也是采用这种方式部署的, 所以如果你有自己的网站, 赶紧参考这个教程部署吧~&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.77602523659306&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dFTfMt01149azIOraEibmPa8b4hib04RNf3ZNbfOxzVgibicvJBDS0DLE6ibnUtQ94MJWE0nicfDexicX2plyMnub4TnA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;634&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;h2&gt;&lt;span&gt;❤️ 看完三件事&lt;/span&gt;&lt;/h2&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;如果你觉得这篇内容对你挺有启发，我想邀请你帮我三个小忙：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;点个【在看】，或者分享转发，让更多的人也能看到这篇内容&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;关注公众号【趣谈前端】，&lt;span&gt;定期分享 &lt;/span&gt;&lt;strong&gt;工程化 &lt;/strong&gt;&lt;span&gt;/ &lt;/span&gt;&lt;strong&gt;可视化&lt;/strong&gt;&lt;span&gt; / &lt;/span&gt;&lt;strong&gt;低代码&lt;/strong&gt;&lt;span&gt; / &lt;strong&gt;优秀开源&lt;/strong&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94385&quot;&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94715&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img border=&quot;0&quot; class=&quot;__bg_gif rich_pages wxw-img&quot; data-ratio=&quot;0.08658008658008658&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/usyTZ86MDicgqjLq0USF6icibfWiaLSV8bz17cBjvXylU7dz9mIMP7lUF50OE2gFrlZDQlIyWvGcUiaprq92fq8tgXg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;462&quot; data-width=&quot;100%&quot; height=&quot;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2Mzk1NzkwOA==&amp;amp;mid=2247489810&amp;amp;idx=1&amp;amp;sn=2663938569c4d361acae076bce9a9bf5&amp;amp;chksm=fc5300e9cb2489ff48db614f03093d71a81669bc6e0ccdf88b10af4a899b86ce59c6c95198b5&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;从零搭建全栈可视化大屏制作平台V6.Dooring&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2Mzk1NzkwOA==&amp;amp;mid=2247489467&amp;amp;idx=1&amp;amp;sn=be4b2a7f92f1c62e66432158212aee78&amp;amp;chksm=fc530e40cb248756193998c50b2e5e75de96dbde98170f871faa7e6ea043a50f87b7fc4468cf&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;从零设计可视化大屏搭建引擎&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2Mzk1NzkwOA==&amp;amp;mid=2247487877&amp;amp;idx=2&amp;amp;sn=770ff16d69d3e7ac2bbcd78e97ab8f32&amp;amp;chksm=fc53087ecb2481685451a50e892fa889781788ca16a4ce689ec7f7fff1ae99c91ac8b82a160d&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;Dooring可视化搭建平台数据源设计剖析&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2Mzk1NzkwOA==&amp;amp;mid=2247487950&amp;amp;idx=1&amp;amp;sn=e674a2f9379b9c9b8a149498a50c17f8&amp;amp;chksm=fc530835cb2481233acc7ac2c856b30c7698dd9d2aec1514b5c2fa4165bc2728f7b261c4938f&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;可视化搭建的一些思考和实践&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2Mzk1NzkwOA==&amp;amp;mid=2247486910&amp;amp;idx=2&amp;amp;sn=7ce865dd8a8f6769439f0e8eebb72212&amp;amp;chksm=fc531445cb249d534a7d8a362ad40d26bc90f2d2e867385768ee19575e32826fcbe419fcbe0b&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;基于Koa + React + TS从零开发全栈文档编辑器(进阶实战&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;点个&lt;span data-mid=&quot;&quot;&gt;在看&lt;/span&gt;你最好看&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.2&quot; data-type=&quot;png&quot; data-w=&quot;60&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SgotVleX0gOsmNiae4tDzLaG2rHT2FWEJcEvep02gEar4acRc4Nf9cxibxFj2Ygdn3ucM4THibzD8EwmZTyv88icAQ/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                          
              &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ea93e8749a09579bc3dce785936b696a</guid>
<title>叫板DALL·E 2，预训练大模型做编码器，谷歌把文字转图像模型卷上天</title>
<link>https://toutiao.io/k/b7ivfge</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-mpa-powered-by=&quot;yiban.io&quot; data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; data-style=&quot;white-space: normal; max-width: 100%; letter-spacing: 0.544px; text-size-adjust: auto; background-color: rgb(255, 255, 255); font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__0&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;section data-id=&quot;85660&quot; data-custom=&quot;rgb(117, 117, 118)&quot; data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;section data-id=&quot;85660&quot; data-custom=&quot;rgb(117, 117, 118)&quot; data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; data-style=&quot;margin-top: 2em; padding-top: 0.5em; padding-bottom: 0.5em; max-width: 100%; border-style: solid none; text-decoration: inherit; border-top-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-top-width: 1px; border-bottom-width: 1px; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__1&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;NaN&quot;&gt;&lt;span mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;NaN&quot;&gt;选自arXiv&lt;/span&gt;&lt;/section&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;51&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;作者：Chitwan Saharia等&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;51&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;机器之心编译&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;51&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;机器之心编辑部&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;blockquote data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;83&quot; data-source-title=&quot;&quot; mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;24&quot;&gt;&lt;p&gt;OpenAI：DALL・E 2 就是最好的。谷歌：看下我们 Imagen 生成的柴犬？&lt;/p&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;多&lt;/span&gt;&lt;span&gt;模态学习近来受到重视，特别是文本 - 图像合成和图像 - 文本对比学习两个方向。一些模型因在创意图像生成、编辑方面的应用引起了公众的广泛关注，例如 OpenAI 的文本转图像模型 DALL・E、英伟达的 GauGAN。现在，来自谷歌的研究者也在这一方向做出了探索，提出了一种文本到图像的扩散模型 Imagen。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Imagen 结合了 Transformer 语言模型和高保真扩散模型的强大功能，在文本到图像的合成中提供前所未有的逼真度和语言理解能力。与仅使用图像 - 文本数据进行模型训练的先前工作相比，Imagen 的关键突破在于：谷歌的研究者发现在纯文本语料库上预训练的大型 LM 的文本嵌入对文本到图像的合成显著有效。Imagen 的文本到图像生成可谓天马行空，能生成多种奇幻却逼真的有趣图像。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;比如正在户外享受骑行的柴犬：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.124792013311148&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicVaJLaqSzuGYzoibUsRy11QRHVpYiaz7jJzF8AaJmu4BBCSQLyHvDaia9iaIyicxotedhcO0zzribN9mhA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1202&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;泰迪熊的 400 米蝶泳首秀：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.1914285714285715&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicVaJLaqSzuGYzoibUsRy11Qw3ZZFP54FHO1ysh8UqG5mbsbXeAY6dRicHLJGKpzfpvgc7cnNCpqk0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;狗狗照镜子发现自己是只猫：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.2056338028169014&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicVaJLaqSzuGYzoibUsRy11QpZTpmSGS7FbOVib3oGLUWXKU8X5ZrRmnH43tSvJJrULarzThAarBS0A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;710&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;火龙果成精要打空手道了：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.1932773109243697&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicVaJLaqSzuGYzoibUsRy11QiayR3madS7xyllsc1MBpLk1I4238NKICxrZx3Zib8Z10Q0UOaUK23dEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;714&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果你觉得这些图片过于魔幻，那下面这张小鸟生气的图就非常真实了，隔着屏幕都能感觉到它的愤怒：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.1629213483146068&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicVaJLaqSzuGYzoibUsRy11QfWqxFt5WD2PEIepVLmBtiaGTl7tTgrPra7ibfZLDYDvicHl49FnDpiaMzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;712&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们发现这些图片的分辨率都很高，像是人工精心 PS 过的。然而这些模型都出自 Imagen 这个 AI 模型之手。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Imagen 模型中包含一个 frozen T5-XXL 编码器，用于将输入文本映射到一系列嵌入和一个 64×64 的图像扩散模型中，并带有两个超分辨率扩散模型，用于生成 256×256 和 1024×1024 的图像。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.80078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicVaJLaqSzuGYzoibUsRy11QmpVFBib8GgNJzeicrsFA9pKB3tkQlvbMg7ycgf5ptT3N1GP0icicOATG6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其中，所有扩散模型都以文本嵌入序列为条件，并使用无分类器指导。借助新型采样技术，Imagen 允许使用较大的指导权重，而不会发生样本质量下降，使得生成的图像具有更高的保真度、图像与文本更加吻合。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;虽然架构简单且易于训练，但 Imagen 产生了令人惊讶的强大结果。Imagen 在 COCO 上的零样本 FID-30K 分数为 7.27，性能显著优于之前的方法（GLIDE、DALL-E 2 等），并超越了当前的 SOTA 模型 Make-A-Scene（7.27 VS 7.55）。从人工评估看，Imagen 生成的样本在图像文本对齐方面与 COCO captions 的参考图像相当。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5458368376787216&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicVaJLaqSzuGYzoibUsRy11QZsS01Jg7YCWUNcIeiccaaPurRvdwmzpdgPXgNMu1Vic6DvY4EsXvOvWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1189&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5669144981412639&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicVaJLaqSzuGYzoibUsRy11Q1YYbvh8O62ZEWRoibDic3aDBMCL4aMqz58j0zSHcnyibxRNozbbUWiayuw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1076&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5659690627843494&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicVaJLaqSzuGYzoibUsRy11Ql9vZNCOv30bgadhxByibrOSySDmxkwTpiaCqF4nedup5trbxZwicqic2lA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1099&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5772432932469935&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicVaJLaqSzuGYzoibUsRy11QtktBT13kf0rjaSwPn1SaMbljiaoHmTz4iabP7u44iaq6ozMWrNdSguUWw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1081&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;此外，研究者还提出了一种用于文本到图像评估的文本 prompt 结构化新套件 DrawBench。DrawBench 对文本到图像模型进行多维评估，文本 prompt 旨在探索模型的不同语义属性。这些 prompt 包括组合性、基数、空间关系、处理复杂文本 prompt 或带有稀有单词的 prompt 的能力，它们包括创造性 prompt，这些 prompt 将模型生成高度难以置信的场景的能力扩展到训练数据范围之外。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;借助 DrawBench，研究者进行了广泛的人工评估，结果表明，Imagen 的性能明显优于其他方法。研究者进一步展示了相对于多模态嵌入（例如 CLIP）， 使用大型预训练语言模型作为 Imagen 的文本编码器具有明显的优势。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5234375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicVaJLaqSzuGYzoibUsRy11QUKicZBWnecytfruKxUV0fyn62W3Lm5z6q7MPqhpdaNFuNUdaNQzyjMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;论文地址：https://gweb-research-imagen.appspot.com/paper.pdf&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;不过，和前段时间大火的 DALL・E 2 一样，我们很难指望谷歌将这个模型开源。对此，有网友建议说，可以去 GitHub 上找一些「野生」复现来玩一玩，比如已经放出一段时间的「DALL-E 2-Pytorch」项目：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.48513302034428796&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicVaJLaqSzuGYzoibUsRy11QwbgG2dEBiaNMrcvQ0nFtHZXw8n7ya1fOxy9HcbIMEhS8HhtrscvgaQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1278&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;项目地址：https://github.com/lucidrains/DALLE2-pytorch&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;Imagen 细节&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Imagen 由一个文本编码器和一系列条件扩散模型组成，前者将文本映射为一系列嵌入，后者将这些嵌入映射为分辨率不断提高的图像，如图 Fig. A.4 所示。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;预训练文本编码器&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在构建 Imagen 的过程中，研究者探索了几个预训练文本编码器：BERT、T5 和 CLIP。为了简单起见，他们冻结了这些文本编码器的权重。冻结有几个优点，例如嵌入的离线计算，这使得文本 - 图像模型训练期间的计算或内存占用可以忽略。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在这项工作中，研究者发现，扩展文本编码器的大小可以提高文本到图像生成的质量。他们还发现，虽然 T5-XXL 和 CLIP 文本编码器在 MS-COCO 等简单基准上性能相似，但在 DrawBench 上的图像 - 文本对齐和图像保真度方面，人类评估员更喜欢 T5-XXL 编码器而不是 CLIP 文本编码器。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;扩散模型和无分类器指导&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;扩散模型是一类生成模型，通过迭代去噪过程，将高斯噪声从已知的数据分布转换为样本。这类模型可以是有条件的，例如类标签、文本或低分辨率图像。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;分类器指导是一种在采样期间使用来自预训练模型 p (c|z_t) 的梯度来提高样本质量，同时减少条件扩散模型多样性的技术。无分类器指导是一种替代技术，通过在训练期间随机丢弃 c（例如 10% 的概率），在有条件和无条件目标上联合训练单个扩散模型，从而避开上述预训练模型。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;较大指导权重采样器&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;研究者证实了最近的文本指导扩散工作的结果，并发现增加无分类器指导权重可以改善图像 - 文本对齐，但也会损害图像保真度，产生高度饱和、不自然的图像。他们发现这是由于高指导权重引起的训练 - 测试不匹配所造成的。并且由于扩散模型在整个采样过程中迭代地应用于其自身的输出，采样过程就产生了不自然的图像。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了解决这个问题，他们研究了静态阈值（static thresholding）和动态阈值（dynamic thresholding）。他们发现，动态阈值对于提升图像真实感和图像 - 文本对齐能力要有效得多，特别是在使用非常大的指导权重的时候。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;稳健的扩散模型组&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Imagen 利用一个 64 × 64 基本模型、两个文本条件超分辨率扩散模型将生成的 64 × 64 图像上采样为 256 × 256 图像，然后再上采样为 1024 × 1024 图像。具有噪声调节增强的扩散模型组在逐步生成高保真图像方面非常有效。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;此外，研究者通过噪声水平调节使超分辨率模型意识到添加的噪声量，显著提高了样本质量，而且有助于提高超分辨率模型处理较低分辨率模型产生的 artifacts 的稳健性。Imagen 对两个超分辨率模型都使用了噪声调节增强。研究者发现这是生成高保真图像的关键。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;给定调节低分辨率图像和增强水平（aug_level，例如高斯噪声或模糊的强度），研究者用增强（对应于 aug_level）破坏低分辨率图像，并在 aug_level 上调节扩散模型。在训练期间，aug_level 是随机选择的，而在推理期间，可以扫描它的不同值以找到最佳样本质量。在这项研究中，研究者使用高斯噪声作为一种增强形式，并应用类似于扩散模型中使用的正向过程的方差来保持高斯噪声增强。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;神经网络架构&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;研究者采用 U-Net 架构作为基本的 64 × 64 文本到图像扩散模型。该网络通过池化嵌入向量以文本嵌入为条件，加入到扩散时间步嵌入中，类似于 [16, 29] 中使用的类嵌入条件方法。通过在多分辨率的文本嵌入上添加交叉注意力，研究者进一步对整个文本嵌入序列进行了限制。此外，他们在注意力层和池化层发现了用于文本嵌入、可以大大提高性能的层归一化。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于 64 × 64→256 × 256 的超分辨率模型，研究者采用了改编自 [40,58] 的 U-Net 模型。为了提高内存效率、推理时间和收敛速度，研究者对 U-Net 模型进行了一些修改（该变体比 [40,58] 中使用的 U-Net 模型的每秒速度快 2-3 倍），并称这种变体为 Efficient U-Net。256 × 256→1024 × 1024 的超分辨率模型是在 1024 × 1024 图像的 64×64 → 256×256 crop 上训练的。他们去掉了自注意力层，但保留了文本交叉注意力层，这一点是很关键的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在推理过程中，模型接收完整 256 × 256 低分辨率图像作为输入，输出上采样的 1024 × 1024 图像。注意，研究者在两个超分辨率模型上都使用了文本交叉注意力。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;DrawBench&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;尽管 COCO 是一个很有价值的基准，但很明显它的 prompt 范围是有限的，不能很好地提供对模型之间差异的洞察。因此，研究者提出了 DrawBench，这是一个综合的、具有挑战性的 prompt 集，支持文本到图像模型的评估和比较。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;DrawBench 包含 11 种类型的 prompt，用于测试模型的不同功能，比如颜色渲染、对象数量、空间关系、场景中的文本以及对象之间的非常规交互。类别中还包括复杂的 prompt，包括冗长复杂的文本描述、不常见词汇以及拼写错误的 prompt。此外也包含从 DALL-E、Gary Marcus et al. [38]、Reddit 收集的几个 prompt 集。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在 11 个类别中，DrawBench 共包含 200 个 prompt，且在「足够大而全面」与「足够小而人工评估可行」之间取得了很好的平衡。图 2 展示了来自带有 Imagen 样本的 DrawBench 的示例 prompt。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6390625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicVaJLaqSzuGYzoibUsRy11Q5n7yicic40ibibxasJn0hdo2g1XTWQwJKgtQGxMsjmxt0229q8wQC7d3CQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;实验&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;第 4.1 节描述了训练细节，第 4.2 节和第 4.3 节分析了 MS-COCO 和 DrawBench 上的实验结果，第 4.4 节总结了消融研究和主要发现。对于下面的所有实验，图像是来自 Imagen 的公平随机样本，没有后期处理或重新排序。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;COCO 实验结果&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;研究者使用了 FID 评分对 COCO 验证集上的 Imagen 进行了评估，结果如表 1 所示。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.003125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicVaJLaqSzuGYzoibUsRy11QwMZbyp7XJJia7CS3tzo757KbCh2Rplutnib2cdDLrHB2bRIRN3ph6Qxg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Imagen 以 7.27 的得分在 COCO 上实现了 zero-shot FID 的 SOTA 结果，超越了 DALL-E 2 及其他同期工作，甚至超过了其他在 COCO 上训练的模型。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;表 2 展示了在 COCO 验证集上测试图像质量和对齐的人工评估结果，包括原始 COCO 验证集和过滤后的版本。在这个版本中，所有与人相关的参考数据都被删除了。在没有人的设置下，Imagen 的偏好率提高到了 43.6% ，这表明 Imagen 生成逼真人物的能力有限。在标题相似度方面，Imagen 的得分与原始的参考图片相当，这表明 Imagen 有能力生成与 COCO 标题相一致的图片。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5140625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicVaJLaqSzuGYzoibUsRy11Qo94kuMpAPl8YmTeWS9Wjiac1CHmy3ty9PtjhFktTWGcULlGgIL9SLzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;DrawBench 实验结果&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;使用 DrawBench，研究者将 Imagen 与 DALL-E 2 (公共版本)、 GLIDE、Latent Diffusion 和 CLIP-guided VQGAN 进行了比较。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;图 3 展示了三个模型中每一个模型对 Imagen 成对比较的人类评估结果，包括偏好模型 A、模型 B，或者不受图像保真度和图像文本对齐影响。可以看出，在图文对齐和图像保真度方面，人类评估者极其偏爱 Imagen 模型。读者可以参考附录 E，了解更详细的类别对比和定性对比。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.46953125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicVaJLaqSzuGYzoibUsRy11Qj4jHtib7yhaJNY0mN2NdmIQFraao388BKronibQSbHvs4zSFrg5EWXqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;更多研究细节，可参考原论文。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-id=&quot;90835&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-autoskip=&quot;1&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;5月25日14:30，深度解读从联邦学习到可信联邦学习的跨越路径，从理论完美走向实用完美，一场隐私计算联邦学习生态圈的研讨盛宴，邀请您共同参与！&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;511&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;4838&quot; data-ratio=&quot;9.467592592592593&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicVaJLaqSzuGYzoibUsRy11Qic4pJh2sdy0uziaibSOJ4ViaoLZtMAh0JIBJEkgeXeeWAoLlyqEoFXBcww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;© THE END &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;转载请联系本公众号获得授权&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;投稿或寻求报道：content@jiqizhixin.com&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>