<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>fb2df63f5523c5e3b48401b0b93f2078</guid>
<title>IndexedDB 快速入门</title>
<link>https://toutiao.io/k/7hbxp47</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-header&quot;&gt;&lt;h1 class=&quot;title&quot;&gt;IndexedDB 快速入门&lt;/h1&gt;&lt;p class=&quot;meta&quot;&gt;冯宇 Posted at — Aug 7, 2021
&lt;span class=&quot;meta&quot; id=&quot;busuanzi_container_page_pv&quot;&gt;阅读 &lt;span id=&quot;busuanzi_value_page_pv&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;markdown&quot;&gt;&lt;p&gt;&lt;strong&gt;注：如果你只是想快速体验一下 IndexedDB，建议直接去使用 &lt;a href=&quot;https://jsstore.net/&quot;&gt;JsStore&lt;/a&gt; 。它基本上完全隐藏了 IndexedDB 繁琐的技术细节，提供的接口也更加人性化，同时还有更高级的特性（如 sql join、upsert、webworker 等）。&lt;/strong&gt;&lt;/p&gt;&lt;h2 id=&quot;indexeddb-简介&quot;&gt;IndexedDB 简介&lt;/h2&gt;&lt;p&gt;作为前端开发工程师，你可能已经习惯了使用一些前端的存储方案，如 LocalStorage, Session Storage, Cookie 之类等等。而这些存储在存储结构简单、数据量小的场景中非常好用，但是遇到大规模结构化存储的场景中就不那么好用了。为此，诞生了一种新的存储标准 IndexedDB，用于在前端解决大规模量结构化数据存储的场景。如服务端数据缓存至前端加速，前端日志缓存记录等。&lt;/p&gt;&lt;p&gt;本文将介绍 IndexedDB 快速入门的相关内容，至于高级使用，仍建议详细阅读 IndexedDB 的&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;性能评测可参考： &lt;a href=&quot;https://zhuanlan.zhihu.com/p/104536473&quot;&gt;https://zhuanlan.zhihu.com/p/104536473&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;indexeddb-的兼容性&quot;&gt;IndexedDB 的兼容性&lt;/h2&gt;&lt;p&gt;如今 IndexedDB 几乎在现代化的浏览器都已经实现，因此可以放心大胆的在产品环境使用。截至本文撰写时间，当前 IndexedDB 的浏览器兼容性参考如下:&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;imgs/indexeddb1.png&quot; alt=&quot;IndexedDB 兼容性概览&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;数据来源: &lt;a href=&quot;https://caniuse.com/indexeddb&quot;&gt;https://caniuse.com/indexeddb&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;indexeddb-的存储容量限制&quot;&gt;IndexedDB 的存储容量限制&lt;/h2&gt;&lt;p&gt;IndexedDB 的最大存储容量通常是动态的，通常&lt;strong&gt;全局限制&lt;/strong&gt;为当前磁盘空间的 50%，如浏览器安装分区容量为 500GB，则 IndexedDB 最大可能占用空间为 250GB —— 这对于前端存储来几乎是足够的&lt;/p&gt;&lt;p&gt;还有另一个限制称为&lt;strong&gt;组限制&lt;/strong&gt;——这被定义为全局限制的 20％，但它至少有 10 MB，最大为 2GB。 每个源都是一组（源组）的一部分。 每个 eTLD+1 域都有一个组。 例如：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;mozilla.org&lt;/code&gt;——组 1，源 1&lt;/li&gt;&lt;li&gt;&lt;code&gt;www.mozilla.org&lt;/code&gt;——组 1，源 2&lt;/li&gt;&lt;li&gt;&lt;code&gt;joe.blogs.mozilla.org&lt;/code&gt;——组 1，源 3&lt;/li&gt;&lt;li&gt;&lt;code&gt;firefox.com&lt;/code&gt; ——组 2，源 4&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在这个组中，mozilla.org、www.mozilla.org和joe.blogs.mozilla.org可以聚合使用最多20％的全局限制。 firefox.com 单独最多使用 20％。&lt;/p&gt;&lt;p&gt;达到限制后有两种不同的反应：&lt;/p&gt;&lt;p&gt;组限制也称为“硬限制”：它不会触发源回收。
全局限制是一个“软限制”，因为其有可能释放一些空间并且这个操作可能持续。&lt;/p&gt;&lt;h2 id=&quot;indexeddb-安全性&quot;&gt;IndexedDB 安全性&lt;/h2&gt;&lt;p&gt;IndexedDB 使用同源原则，这意味着它把存储空间绑定到了创建它的站点的源（典型情况下，就是站点的域或是子域），所以它不能被任何其他源访问。&lt;/p&gt;&lt;h2 id=&quot;indexeddb-简易示例&quot;&gt;IndexedDB 简易示例&lt;/h2&gt;&lt;p&gt;IndexedDB 的 API 是基于事件响应全异步性的，使用的时候需要监听对应的事件完成操作。一个基本的创建数据库的操作实例如下:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span&gt;// 如果被打开的数据库不存在，则会自动创建
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;request&lt;/span&gt; = &lt;span&gt;window&lt;/span&gt;.&lt;span&gt;indexedDB&lt;/span&gt;.&lt;span&gt;open&lt;/span&gt;(&lt;span&gt;&quot;MyTestDatabase&quot;&lt;/span&gt;);

&lt;span&gt;request&lt;/span&gt;.&lt;span&gt;onerror&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;alert&lt;/span&gt;(&lt;span&gt;&quot;Why didn&#x27;t you allow my web app to use IndexedDB?!&quot;&lt;/span&gt;);
};

&lt;span&gt;request&lt;/span&gt;.&lt;span&gt;onsuccess&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;const&lt;/span&gt; &lt;span&gt;db&lt;/span&gt; = &lt;span&gt;event&lt;/span&gt;.&lt;span&gt;target&lt;/span&gt;.&lt;span&gt;result&lt;/span&gt;;

  &lt;span&gt;// 在不使用 db 的时候尽可能 close掉，否则无法打开一个更高版本的 db，表现形式为 hang 死，无法接收到 onsuccess 事件
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;// 注意 close() 函数不会立即中断已经在运行中的 transaction
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;// 但是不能再用这个实例创建新的transaction，否则会抛异常
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;db&lt;/span&gt;.&lt;span&gt;close&lt;/span&gt;();
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&quot;数据库的版本号&quot;&gt;数据库的版本号&lt;/h3&gt;&lt;p&gt;&lt;code&gt;open()&lt;/code&gt; 函数可以传一个可选的 &lt;code&gt;version&lt;/code&gt; 参数指定版本号，当 version 比当前 &lt;code&gt;db.version&lt;/code&gt; 高时，会触发 &lt;code&gt;onupgradeneeded&lt;/code&gt; 事件，同时，会更新 &lt;code&gt;db.version&lt;/code&gt; 属性：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;request&lt;/span&gt; = &lt;span&gt;window&lt;/span&gt;.&lt;span&gt;indexedDB&lt;/span&gt;.&lt;span&gt;open&lt;/span&gt;(&lt;span&gt;&quot;MyTestDatabase&quot;&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;);

&lt;span&gt;// 该事件仅在较新的浏览器中实现了
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;request&lt;/span&gt;.&lt;span&gt;onupgradeneeded&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;// 保存 IDBDataBase 接口
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;var&lt;/span&gt; &lt;span&gt;db&lt;/span&gt; = &lt;span&gt;event&lt;/span&gt;.&lt;span&gt;target&lt;/span&gt;.&lt;span&gt;result&lt;/span&gt;;

  &lt;span&gt;// 为该数据库创建一个对象仓库
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;// 注意 createObjectStore() 只能在 onupgradeneeded 事务中运行
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;var&lt;/span&gt; &lt;span&gt;objectStore&lt;/span&gt; = &lt;span&gt;db&lt;/span&gt;.&lt;span&gt;createObjectStore&lt;/span&gt;(&lt;span&gt;&quot;name&quot;&lt;/span&gt;, { &lt;span&gt;keyPath&lt;/span&gt;: &lt;span&gt;&quot;myKey&quot;&lt;/span&gt; });
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;为了防止在其他标签页中打开高版本的数据库 hang 住的情况，一种做法可以参考如下:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;openReq&lt;/span&gt; = &lt;span&gt;mozIndexedDB&lt;/span&gt;.&lt;span&gt;open&lt;/span&gt;(&lt;span&gt;&quot;MyTestDatabase&quot;&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;);

&lt;span&gt;openReq&lt;/span&gt;.&lt;span&gt;onblocked&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;// 如果其他的一些页签加载了该数据库，在我们继续之前需要关闭它们
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;alert&lt;/span&gt;(&lt;span&gt;&quot;请关闭其他由该站点打开的页签！&quot;&lt;/span&gt;);
};

&lt;span&gt;openReq&lt;/span&gt;.&lt;span&gt;onupgradeneeded&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;// 其他的数据已经被关闭，一切就绪
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;db&lt;/span&gt;.&lt;span&gt;createObjectStore&lt;/span&gt;(&lt;span&gt;/* ... */&lt;/span&gt;);
  &lt;span&gt;useDatabase&lt;/span&gt;(&lt;span&gt;db&lt;/span&gt;);
};

&lt;span&gt;openReq&lt;/span&gt;.&lt;span&gt;onsuccess&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;var&lt;/span&gt; &lt;span&gt;db&lt;/span&gt; = &lt;span&gt;event&lt;/span&gt;.&lt;span&gt;target&lt;/span&gt;.&lt;span&gt;result&lt;/span&gt;;
  &lt;span&gt;useDatabase&lt;/span&gt;(&lt;span&gt;db&lt;/span&gt;);
  &lt;span&gt;return&lt;/span&gt;;
};

&lt;span&gt;function&lt;/span&gt; &lt;span&gt;useDatabase&lt;/span&gt;(&lt;span&gt;db&lt;/span&gt;) {
  &lt;span&gt;// 当由其他页签请求了版本变更时，确认添加了一个会被通知的事件处理程序。
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;// 这里允许其他页签来更新数据库，如果不这样做，版本升级将不会发生知道用户关闭了这些页签。
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;db&lt;/span&gt;.&lt;span&gt;onversionchange&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
    &lt;span&gt;db&lt;/span&gt;.&lt;span&gt;close&lt;/span&gt;();
    &lt;span&gt;alert&lt;/span&gt;(&lt;span&gt;&quot;A new version of this page is ready. Please reload or close this tab!&quot;&lt;/span&gt;);
  };

  &lt;span&gt;// 处理数据库
&lt;/span&gt;&lt;span/&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&quot;一个基本的存储示例&quot;&gt;一个基本的存储示例&lt;/h3&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;dbName&lt;/span&gt; = &lt;span&gt;&quot;the_name&quot;&lt;/span&gt;;

&lt;span&gt;var&lt;/span&gt; &lt;span&gt;request&lt;/span&gt; = &lt;span&gt;indexedDB&lt;/span&gt;.&lt;span&gt;open&lt;/span&gt;(&lt;span&gt;dbName&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;);

&lt;span&gt;request&lt;/span&gt;.&lt;span&gt;onerror&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;// 错误处理
&lt;/span&gt;&lt;span/&gt;};
&lt;span&gt;request&lt;/span&gt;.&lt;span&gt;onupgradeneeded&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;var&lt;/span&gt; &lt;span&gt;db&lt;/span&gt; = &lt;span&gt;event&lt;/span&gt;.&lt;span&gt;target&lt;/span&gt;.&lt;span&gt;result&lt;/span&gt;;

  &lt;span&gt;// 建立一个对象仓库来存储我们客户的相关信息，我们选择 ssn 作为键路径（key path）
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;// 因为 ssn 可以保证是不重复的
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;var&lt;/span&gt; &lt;span&gt;objectStore&lt;/span&gt; = &lt;span&gt;db&lt;/span&gt;.&lt;span&gt;createObjectStore&lt;/span&gt;(&lt;span&gt;&quot;customers&quot;&lt;/span&gt;, { &lt;span&gt;keyPath&lt;/span&gt;: &lt;span&gt;&quot;ssn&quot;&lt;/span&gt; });

  &lt;span&gt;// 建立一个索引来通过姓名来搜索客户。名字可能会重复，所以我们不能使用 unique 索引
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;objectStore&lt;/span&gt;.&lt;span&gt;createIndex&lt;/span&gt;(&lt;span&gt;&quot;name&quot;&lt;/span&gt;, &lt;span&gt;&quot;name&quot;&lt;/span&gt;, { &lt;span&gt;unique&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt; });

  &lt;span&gt;// 使用邮箱建立索引，我们向确保客户的邮箱不会重复，所以我们使用 unique 索引
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;objectStore&lt;/span&gt;.&lt;span&gt;createIndex&lt;/span&gt;(&lt;span&gt;&quot;email&quot;&lt;/span&gt;, &lt;span&gt;&quot;email&quot;&lt;/span&gt;, { &lt;span&gt;unique&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt; });

  &lt;span&gt;// 使用事务的 oncomplete 事件确保在插入数据前对象仓库已经创建完毕
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;objectStore&lt;/span&gt;.&lt;span&gt;transaction&lt;/span&gt;.&lt;span&gt;oncomplete&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
    &lt;span&gt;// 将数据保存到新创建的对象仓库
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;var&lt;/span&gt; &lt;span&gt;customerObjectStore&lt;/span&gt; = &lt;span&gt;db&lt;/span&gt;.&lt;span&gt;transaction&lt;/span&gt;(&lt;span&gt;&quot;customers&quot;&lt;/span&gt;, &lt;span&gt;&quot;readwrite&quot;&lt;/span&gt;).&lt;span&gt;objectStore&lt;/span&gt;(&lt;span&gt;&quot;customers&quot;&lt;/span&gt;);
    &lt;span&gt;customerData&lt;/span&gt;.&lt;span&gt;forEach&lt;/span&gt;(&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;customer&lt;/span&gt;) {
      &lt;span&gt;// add 函数在 keyPath 冲突时会抛异常，如果期望直接覆盖，请使用 put 函数
&lt;/span&gt;&lt;span/&gt;      &lt;span&gt;customerObjectStore&lt;/span&gt;.&lt;span&gt;add&lt;/span&gt;(&lt;span&gt;customer&lt;/span&gt;);
    });
  };
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;关于索引&lt;/strong&gt;: IndexedDB 的索引会自动按照由小到大的顺序自动进行排列(有点像 HBase 的 RowKey 设计)，同时可以支持多个字段联合索引，如: objectStore.createIndex(“f1-f2”, [“f1”, “f2”]); 对于要想使用类似于 SQL 中的 where 条件查询，则必须预先在对应的字段创建索引才能实现。另外由于 IndexedDB API 并不提供类似于 Order By 的功能，因此只能使用 cursor 的遍历方向来替代。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&quot;基本-curd-示例&quot;&gt;基本 CURD 示例&lt;/h3&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span&gt;// ========= 增加数据 ============
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;// 在所有数据添加完毕后的处理
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;transaction&lt;/span&gt;.&lt;span&gt;oncomplete&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;alert&lt;/span&gt;(&lt;span&gt;&quot;All done!&quot;&lt;/span&gt;);
};

&lt;span&gt;transaction&lt;/span&gt;.&lt;span&gt;onerror&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;// 不要忘记错误处理！
&lt;/span&gt;&lt;span/&gt;};

&lt;span&gt;var&lt;/span&gt; &lt;span&gt;objectStore&lt;/span&gt; = &lt;span&gt;transaction&lt;/span&gt;.&lt;span&gt;objectStore&lt;/span&gt;(&lt;span&gt;&quot;customers&quot;&lt;/span&gt;);
&lt;span&gt;customerData&lt;/span&gt;.&lt;span&gt;forEach&lt;/span&gt;(&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;customer&lt;/span&gt;) {
  &lt;span&gt;var&lt;/span&gt; &lt;span&gt;request&lt;/span&gt; = &lt;span&gt;objectStore&lt;/span&gt;.&lt;span&gt;add&lt;/span&gt;(&lt;span&gt;customer&lt;/span&gt;);
  &lt;span&gt;request&lt;/span&gt;.&lt;span&gt;onsuccess&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
    &lt;span&gt;// event.target.result === customer.ssn;
&lt;/span&gt;&lt;span/&gt;  };
});

&lt;span&gt;// =========== 删除数据 ==================
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;request&lt;/span&gt; = &lt;span&gt;db&lt;/span&gt;
  .&lt;span&gt;transaction&lt;/span&gt;([&lt;span&gt;&quot;customers&quot;&lt;/span&gt;], &lt;span&gt;&quot;readwrite&quot;&lt;/span&gt;)
  .&lt;span&gt;objectStore&lt;/span&gt;(&lt;span&gt;&quot;customers&quot;&lt;/span&gt;)
  .&lt;span&gt;delete&lt;/span&gt;(&lt;span&gt;&quot;444-44-4444&quot;&lt;/span&gt;);
&lt;span&gt;request&lt;/span&gt;.&lt;span&gt;onsuccess&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;// 删除成功！
&lt;/span&gt;&lt;span/&gt;};

&lt;span&gt;// =========== 读取数据 ==================
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;transaction&lt;/span&gt; = &lt;span&gt;db&lt;/span&gt;.&lt;span&gt;transaction&lt;/span&gt;([&lt;span&gt;&quot;customers&quot;&lt;/span&gt;]);
&lt;span&gt;var&lt;/span&gt; &lt;span&gt;objectStore&lt;/span&gt; = &lt;span&gt;transaction&lt;/span&gt;.&lt;span&gt;objectStore&lt;/span&gt;(&lt;span&gt;&quot;customers&quot;&lt;/span&gt;);
&lt;span&gt;var&lt;/span&gt; &lt;span&gt;request&lt;/span&gt; = &lt;span&gt;objectStore&lt;/span&gt;.&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;&quot;444-44-4444&quot;&lt;/span&gt;);
&lt;span&gt;request&lt;/span&gt;.&lt;span&gt;onerror&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;// 错误处理!
&lt;/span&gt;&lt;span/&gt;};
&lt;span&gt;request&lt;/span&gt;.&lt;span&gt;onsuccess&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;// 对 request.result 做些操作！
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;alert&lt;/span&gt;(&lt;span&gt;&quot;Name for SSN 444-44-4444 is &quot;&lt;/span&gt; + &lt;span&gt;request&lt;/span&gt;.&lt;span&gt;result&lt;/span&gt;.&lt;span&gt;name&lt;/span&gt;);
};

&lt;span&gt;// 简化示例，和上面等效
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;db&lt;/span&gt;.&lt;span&gt;transaction&lt;/span&gt;(&lt;span&gt;&quot;customers&quot;&lt;/span&gt;).&lt;span&gt;objectStore&lt;/span&gt;(&lt;span&gt;&quot;customers&quot;&lt;/span&gt;).&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;&quot;444-44-4444&quot;&lt;/span&gt;).&lt;span&gt;onsuccess&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (
  &lt;span&gt;event&lt;/span&gt;
) {
  &lt;span&gt;alert&lt;/span&gt;(&lt;span&gt;&quot;Name for SSN 444-44-4444 is &quot;&lt;/span&gt; + &lt;span&gt;event&lt;/span&gt;.&lt;span&gt;target&lt;/span&gt;.&lt;span&gt;result&lt;/span&gt;.&lt;span&gt;name&lt;/span&gt;);
};

&lt;span&gt;// 使用游标
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;objectStore&lt;/span&gt; = &lt;span&gt;db&lt;/span&gt;.&lt;span&gt;transaction&lt;/span&gt;(&lt;span&gt;&quot;customers&quot;&lt;/span&gt;).&lt;span&gt;objectStore&lt;/span&gt;(&lt;span&gt;&quot;customers&quot;&lt;/span&gt;);

&lt;span&gt;objectStore&lt;/span&gt;.&lt;span&gt;openCursor&lt;/span&gt;().&lt;span&gt;onsuccess&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;var&lt;/span&gt; &lt;span&gt;cursor&lt;/span&gt; = &lt;span&gt;event&lt;/span&gt;.&lt;span&gt;target&lt;/span&gt;.&lt;span&gt;result&lt;/span&gt;;
  &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;cursor&lt;/span&gt;) {
    &lt;span&gt;alert&lt;/span&gt;(&lt;span&gt;&quot;Name for SSN &quot;&lt;/span&gt; + &lt;span&gt;cursor&lt;/span&gt;.&lt;span&gt;key&lt;/span&gt; + &lt;span&gt;&quot; is &quot;&lt;/span&gt; + &lt;span&gt;cursor&lt;/span&gt;.&lt;span&gt;value&lt;/span&gt;.&lt;span&gt;name&lt;/span&gt;);
    &lt;span&gt;cursor&lt;/span&gt;.&lt;span&gt;continue&lt;/span&gt;();
  } &lt;span&gt;else&lt;/span&gt; {
    &lt;span&gt;alert&lt;/span&gt;(&lt;span&gt;&quot;No more entries!&quot;&lt;/span&gt;);
  }
};

&lt;span&gt;// 使用 index 索引数据
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;// 首先，确定你已经在 request.onupgradeneeded 中创建了索引:
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;// objectStore.createIndex(&quot;name&quot;, &quot;name&quot;);
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;// 否则你将得到 DOMException。
&lt;/span&gt;&lt;span/&gt;
&lt;span&gt;var&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; = &lt;span&gt;objectStore&lt;/span&gt;.&lt;span&gt;index&lt;/span&gt;(&lt;span&gt;&quot;name&quot;&lt;/span&gt;);

&lt;span&gt;index&lt;/span&gt;.&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;&quot;Donna&quot;&lt;/span&gt;).&lt;span&gt;onsuccess&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;alert&lt;/span&gt;(&lt;span&gt;&quot;Donna&#x27;s SSN is &quot;&lt;/span&gt; + &lt;span&gt;event&lt;/span&gt;.&lt;span&gt;target&lt;/span&gt;.&lt;span&gt;result&lt;/span&gt;.&lt;span&gt;ssn&lt;/span&gt;);
};

&lt;span&gt;// =========== 更新数据 ==================
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;objectStore&lt;/span&gt; = &lt;span&gt;db&lt;/span&gt;.&lt;span&gt;transaction&lt;/span&gt;([&lt;span&gt;&quot;customers&quot;&lt;/span&gt;], &lt;span&gt;&quot;readwrite&quot;&lt;/span&gt;).&lt;span&gt;objectStore&lt;/span&gt;(&lt;span&gt;&quot;customers&quot;&lt;/span&gt;);
&lt;span&gt;var&lt;/span&gt; &lt;span&gt;request&lt;/span&gt; = &lt;span&gt;objectStore&lt;/span&gt;.&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;&quot;444-44-4444&quot;&lt;/span&gt;);
&lt;span&gt;request&lt;/span&gt;.&lt;span&gt;onerror&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;// 错误处理
&lt;/span&gt;&lt;span/&gt;};
&lt;span&gt;request&lt;/span&gt;.&lt;span&gt;onsuccess&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;// 获取我们想要更新的数据
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;var&lt;/span&gt; &lt;span&gt;data&lt;/span&gt; = &lt;span&gt;event&lt;/span&gt;.&lt;span&gt;target&lt;/span&gt;.&lt;span&gt;result&lt;/span&gt;;

  &lt;span&gt;// 更新你想修改的数据
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;data&lt;/span&gt;.&lt;span&gt;age&lt;/span&gt; = &lt;span&gt;42&lt;/span&gt;;

  &lt;span&gt;// 把更新过的对象放回数据库
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;var&lt;/span&gt; &lt;span&gt;requestUpdate&lt;/span&gt; = &lt;span&gt;objectStore&lt;/span&gt;.&lt;span&gt;put&lt;/span&gt;(&lt;span&gt;data&lt;/span&gt;);
  &lt;span&gt;requestUpdate&lt;/span&gt;.&lt;span&gt;onerror&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
    &lt;span&gt;// 错误处理
&lt;/span&gt;&lt;span/&gt;  };
  &lt;span&gt;requestUpdate&lt;/span&gt;.&lt;span&gt;onsuccess&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
    &lt;span&gt;// 完成，数据已更新！
&lt;/span&gt;&lt;span/&gt;  };
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&quot;关于搜索查询&quot;&gt;关于搜索查询&lt;/h2&gt;&lt;p&gt;通过上述的示例，可以看到其实 IndexedDB 存储其实是文档型数据库的套路，并且自身的 API 并不支持像 SQL 那样复杂功能多样的查询功能，因此在使用前必须好好设计存储结构，务必确保自己的查询条件不至于太复杂难以实现，这里列出一些常见的查询示例与 SQL 的对照(所有需要用到的 index 需要事先创建好，这里不再赘述):&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span&gt;// select * from table order by field desc
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;objectStore&lt;/span&gt;.&lt;span&gt;index&lt;/span&gt;(&lt;span&gt;&quot;field&quot;&lt;/span&gt;).&lt;span&gt;openCursor&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;&quot;prev&quot;&lt;/span&gt;);

&lt;span&gt;// select * from table where field between 1 and 10
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;objectStore&lt;/span&gt;.&lt;span&gt;index&lt;/span&gt;(&lt;span&gt;&quot;field&quot;&lt;/span&gt;).&lt;span&gt;openCursor&lt;/span&gt;(&lt;span&gt;IDBKeyRange&lt;/span&gt;.&lt;span&gt;bound&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;));

&lt;span&gt;// select distinct on (f1, f2) * from table
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;// 需要预先创建f1, f2的联合索引: objectStore.createIndex(&quot;f1-f2&quot;, [&quot;f1&quot;, &quot;f2&quot;], { unique: false });
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;objectStore&lt;/span&gt;.&lt;span&gt;index&lt;/span&gt;(&lt;span&gt;&quot;f1-f2&quot;&lt;/span&gt;).&lt;span&gt;openCursor&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;&quot;nextunique&quot;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;条件搜索主要使用&lt;code&gt;openCursor(keyRange, direction)&lt;/code&gt;函数，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/IDBKeyRange&quot;&gt;IDBKeyRange&lt;/a&gt; 参数表示查询的范围，类似于&lt;code&gt;where&lt;/code&gt;的功能，而&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/IDBCursor/direction&quot;&gt;direction&lt;/a&gt; 决定游标遍历的方向，因此可以实现简单的&lt;code&gt;order by&lt;/code&gt;的功能。但是特别注意对于联合索引，每个字段也都是按照&lt;code&gt;asc&lt;/code&gt;顺序排序的，因此没办法通过 direction 实现类似于&lt;code&gt;order by f1 asc, f2 desc, f3 desc&lt;/code&gt;这样的排序，使用前务必设计好存储结构。&lt;/p&gt;&lt;p&gt;还需要注意无论&lt;code&gt;nextunique&lt;/code&gt;还是&lt;code&gt;prevunique&lt;/code&gt;，由于它们内部对于相同 value 的排序都是从小到大的，因此它们返回的内容都是一样的，例如:&lt;/p&gt;&lt;p&gt;假设创建&lt;code&gt;objectStore.createIndex(&quot;f1-f2&quot;, [&quot;f1&quot;, &quot;f2&quot;], { unique: false })&lt;/code&gt;索引，无论&lt;code&gt;openCursor&lt;/code&gt;的 direction 参数是&lt;code&gt;nextunique&lt;/code&gt;还是&lt;code&gt;prevunique&lt;/code&gt;，都只会筛选出&lt;code&gt;{&quot;f1&quot;:&quot;a&quot;,&quot;f2&quot;:&quot;b&quot;,&quot;f3&quot;:&quot;c&quot;}&lt;/code&gt;这条结果，cursor 的遍历顺序只会影响这条记录出现的次序而已。&lt;/p&gt;&lt;h2 id=&quot;promise&quot;&gt;Promise&lt;/h2&gt;&lt;p&gt;IndexedDB API 本身并不提供 Promise 接口，如果你的场景确实需要用到 Promise，可以考虑自己简单封装下:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;resolve&lt;/span&gt;, &lt;span&gt;reject&lt;/span&gt;) {
  &lt;span&gt;const&lt;/span&gt; &lt;span&gt;request&lt;/span&gt; = &lt;span&gt;window&lt;/span&gt;.&lt;span&gt;indexedDB&lt;/span&gt;.&lt;span&gt;open&lt;/span&gt;(&lt;span&gt;&quot;MyTestDatabase&quot;&lt;/span&gt;);

  &lt;span&gt;request&lt;/span&gt;.&lt;span&gt;onerror&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;reject&lt;/span&gt;(&lt;span&gt;event&lt;/span&gt;);
  }

  &lt;span&gt;request&lt;/span&gt;.&lt;span&gt;onsuccess&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
    &lt;span&gt;const&lt;/span&gt; &lt;span&gt;db&lt;/span&gt; = &lt;span&gt;event&lt;/span&gt;.&lt;span&gt;target&lt;/span&gt;.&lt;span&gt;result&lt;/span&gt;;
    &lt;span&gt;const&lt;/span&gt; &lt;span&gt;getReq&lt;/span&gt; = &lt;span&gt;db&lt;/span&gt;
      .&lt;span&gt;transaction&lt;/span&gt;(&lt;span&gt;&quot;customers&quot;&lt;/span&gt;)
      .&lt;span&gt;objectStore&lt;/span&gt;(&lt;span&gt;&quot;customers&quot;&lt;/span&gt;)
      .&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;&quot;444-44-4444&quot;&lt;/span&gt;)

    &lt;span&gt;getReq&lt;/span&gt;.&lt;span&gt;onsuccess&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;resolve&lt;/span&gt;(&lt;span&gt;event&lt;/span&gt;.&lt;span&gt;target&lt;/span&gt;.&lt;span&gt;result&lt;/span&gt;.&lt;span&gt;name&lt;/span&gt;);
    };

    &lt;span&gt;getReq&lt;/span&gt;.&lt;span&gt;onerror&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;reject&lt;/span&gt;(&lt;span&gt;event&lt;/span&gt;)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果需要大量使用 Promise，可以考虑使用第三方类库&lt;a href=&quot;https://www.npmjs.com/package/idb&quot;&gt;idb&lt;/a&gt;或更精简的版本&lt;a href=&quot;https://www.npmjs.com/package/idb-keyval&quot;&gt;idb-keyval&lt;/a&gt;，它们将 IndexedDB 的 API 进行了 Promise 的封装，其中&lt;a href=&quot;https://www.npmjs.com/package/idb-keyval&quot;&gt;idb-keyval&lt;/a&gt;对 KV 对这种存储结构进行了更简化的封装调用，对于自己的场景只有简单的 KV 存储这种场景可以考虑使用&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4d5636bfda27716b709e5f03be48c443</guid>
<title>Java 进阶：从整体上观察面向对象</title>
<link>https://toutiao.io/k/d5zzykx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h1&gt;&lt;span&gt;一、面向对象&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;面向对象是Java编程中最核心的思想，基本特征：继承、封装、多态。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;1、特征之封装&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;将结构、数据、操作封装在对象实体中，使用时可以不关注对象内部结构，只能访问开放权限的功能入口，从而降低程序耦合程度，提供安全性和可持续维护性。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Concept01&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Student student = &lt;span&gt;new&lt;/span&gt; Student(&lt;span&gt;&quot;张三&quot;&lt;/span&gt;,&lt;span&gt;&quot;高三&quot;&lt;/span&gt;,&lt;span&gt;29f&lt;/span&gt;);&lt;br/&gt;        student.conclusion();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Student&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String name ;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String grade ;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Float score ;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Student&lt;/span&gt;&lt;span&gt;(String name, String grade, Float score)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.name = name;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.grade = grade;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.score = score;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;conclusion&lt;/span&gt; &lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;姓名：&quot;&lt;/span&gt;+&lt;span&gt;this&lt;/span&gt;.getName());&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;年级：&quot;&lt;/span&gt;+&lt;span&gt;this&lt;/span&gt;.getGrade());&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;分数：&quot;&lt;/span&gt;+&lt;span&gt;this&lt;/span&gt;.getGrade());&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.getScore() &amp;gt;= &lt;span&gt;100.0f&lt;/span&gt;){&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;评语：本学期优等生&quot;&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;评语：本学期潜力股&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;案例描述Student的学期总结，通过构造方法构建具体的学生对象，并且只通过conclusion方法获取学生学期评价。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2、特征之继承&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;子类除了提供自身的能力之外，还可以通过继承的方式获取父类开放的属性和方法，以增强自身的功能。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Concept02&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 判断 Digital 是 Phone 父类&lt;/span&gt;&lt;br/&gt;        System.out.println(Digital&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;.&lt;span&gt;isAssignableFrom&lt;/span&gt;(&lt;span&gt;Phone&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;))&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Digital&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Phone&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Digital&lt;/span&gt;&lt;/span&gt;{}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里通过isAssignableFrom方法判断Digital是Phone父类。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;3、特征之多态&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;不同主体类对同一个动作给出不同的实现方式，多态也是Java描述设计模式的常用手段，最直接的作用就是程序解耦。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Concept03&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Animal animalDog = &lt;span&gt;new&lt;/span&gt; Dog();&lt;br/&gt;        Animal animalCat = &lt;span&gt;new&lt;/span&gt; Cat();&lt;br/&gt;        animalDog.voice();&lt;br/&gt;        animalCat.voice();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Animal&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;voice&lt;/span&gt; &lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;Animal ... voice&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Dog&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Animal&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;voice&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;Dog ... Wang wang&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Cat&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Animal&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;voice&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;Cat ... Meow meow&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通常动物都有发出声音的能力，但是不同动物声音不同，这里基于多态实现，不同动物的声音特征。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;二、关系图谱&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;在了解面向对象之后，还需要理解一下基础的关系模型，在实际的业务中都是基于这些基础的关系解决场景问题。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;1、继承与实现&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;继承关系：强调属性和方法从父类向子类的传承。实现关系：强调描述抽象和具体实现的逻辑。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 继承&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;classA&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;classB&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;classA&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;interfaceA&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;interfaceB&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;interfaceA&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 实现&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;classC&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;interfaceA&lt;/span&gt;,&lt;span&gt;interfaceB&lt;/span&gt;&lt;/span&gt;{}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.37073170731707317&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvCp2RA5msCibTSo4dpYP8blibdg8u4iaTKknBD8PdpHIFeQjC0Wx7icgjqDmibVASTEkoSwS8apFdXdM8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;820&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2、依赖与关联&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;依赖关系：常用来描述方法局部变量或者入参，即类的方法中调用了另一个类。关联关系：类的成员变量是另一个类，比如常见的一对一，一对多关系。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 依赖&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RelyA&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RelyB&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;depend&lt;/span&gt; &lt;span&gt;(RelyA rely)&lt;/span&gt;&lt;/span&gt;{}&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 关联&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AssociateA&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AssociateB&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; AssociateA associateA ;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.35960591133004927&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvCp2RA5msCibTSo4dpYP8blibScn5TqWrXZL8tD5gRQBUIiaDsibWia4wib00Cw70gicBdatAiabUJsDZcpZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;812&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;3、组合与聚合&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;聚合关系：描述整体与部分的关系，但是部分不需要依赖整体存在。组合关系：描述整体与部分的关系，但是部分需要依赖整体存在。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 聚合&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ElementA&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ElementB&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Aggregation&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; ElementA elementA ;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; ElementB elementB ;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 组合&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PortionA&lt;/span&gt;&lt;/span&gt;{}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PortionB&lt;/span&gt;&lt;/span&gt;{}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Composition&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; PortionA portionA ;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; PortionB portionB ;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3117408906882591&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvCp2RA5msCibTSo4dpYP8blib0OdSWJPrr8jrOYjBq3UM6QTc4w2BBLic3kgS1YwHt2BfISTXSJjXG1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;988&quot;/&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;三、模式与原则&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;在面对复杂业务时，可以时常参考设计模式和基本原则，以此设计合理的业务结构，实现代码的高内聚低耦合，但是在一些特定场景下，也要果断的突破这些模板或原则，可以更好的支撑业务。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;1、设计模式&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;创建模式&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;抽象对象实例化的创建过程，对不同类型的对象提供高效的管理方式与合理的创建手段。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;结构模式&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;设计类的组装模式，合理的对象结构，有利于支持业务的持续迭代，结构会直接影响代码的可持续维护性。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;代理模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;外观模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;适配器模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;装饰者模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;组合模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;享元模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;桥梁模式&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;行为模式&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;行为模式涉及对象职责定义，通信协作，和最具体的业务逻辑实现，明确程序运行时的流程轨迹。&lt;/p&gt;&lt;p&gt;可以基于继承或实现的方式控制不同类的行为职责，即顶层抽象控制行为，下层逐级做具体逻辑实现；或者直接聚合管理责任对象，做统一分配。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;观察者模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;模版方法模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;策略模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;命令模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调停者模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;备忘录模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;解释器模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;迭代器模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;状态模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;责任链模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;访问者模式&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;2、基本原则&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;开闭原则：在做代码结构设计时，应该考虑对扩展开放，对修改关闭，抽象思维搭建结构，具体实现扩展细节。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;单一职责：一个类应该只负责一项职责；减少代码一处变更引起的程序大规模改动情况，降低类的复杂度；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;接口隔离：每一个接口应该是一种角色；尽量避免具体实现类中用不到但是又必须实现的方法；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;依赖倒转：上层模块不应该依赖下层模块，抽象逻辑不应该依赖具体细节，即中心思想是面向接口编程。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;里氏替换：继承时遵循里氏替换原则，子类中尽量不要重写父类的方法，可以扩展父类的功能；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;迪米特原则：最少知道原则即类对象对其依赖的类知道的越少越好，以此降低耦合程度；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;组合/聚合复用：新对象应使用部分已有的对象，使其成为新对象组成部分，实现已有功能的复用，以此降低单个类的复杂程度。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1&gt;&lt;span&gt;四、业务应用&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;在业务开发中，很多复杂的逻辑都是基于面向对象的思想做的设计和具体实现，但是在实际上业务是不断变化的，所以不管是常用的Mvc模式，或者领域设计，只要经过多个版本迭代，多人参与的开发，到最后代码在逻辑层面都会让人着迷。&lt;/p&gt;&lt;p&gt;也就是常说的一种现象：新人重构，老人不断修复问题，然而铁打的问题，流水的开发，但凡经历过重构的同学都知道，所谓的大规模重构很难彻底解决问题，甚至这是个循环动作。所以业务代码更多是在那个版本周期内是合理的，站在一个开发的角度，这里也可以理解为笔者个人角度，通常从下面几个角度去思考具体的业务开发：&lt;/p&gt;&lt;p&gt;这是个人认为业务工程中最重要的基础，不管业务如何复杂，都离不开与之相应的数据增删改查，所以对常规基础操作做好统一代码风格管理，这样有助于别人快速理解整体结构和逻辑。&lt;/p&gt;&lt;p&gt;这里风格指：接口命名，参数，组件，中间件等统一，以持久层为例，避免多个组件混用的情况，如果是周期相对较长的项目，经常看到单是分页查询的实现逻辑都有多种情况。&lt;/p&gt;&lt;p&gt;易变是业务本身的特点，所以高度复用的业务代码本身就存在很大的限制，例如常见的很多方法，为了适配各种场景，不断扩展入参，然后有些特殊业务也会进行特殊传参。&lt;/p&gt;&lt;p&gt;还有一些开发常说的，能用一个接口实现，绝对不使用两个接口，看似很有个性，实际已经走在挖坑的路上，多个功能请求同一个接口，即意味着任何接口的改动都要考虑很多逻辑的适配。&lt;/p&gt;&lt;p&gt;所以从上层向下看，不必过度考虑复用，从下向上看，底层的改动相对较少，应该考虑复用。&lt;/p&gt;&lt;p&gt;从项目生命周期的角度思考，业务是一个迭代的过程，不需要过度前卫的设计，项目的生命周期是多久没人知道，最稳妥的做法是快速迭代，产品和技术工程能快速稳定的支撑业务发展即可。&lt;/p&gt;&lt;p&gt;经典的业务分层管理是快速迭代的基本支撑，例如常用的Mvc模式，在复杂的业务场景下可以再次细化管理，或者向领域设计靠近。&lt;/p&gt;&lt;p&gt;业务可以理解为流程管理，小的流程通常service中可以直接处理，但是复杂流程则十分讲究设计，一个基础思想就是分段管理，比较经典的案例就是下单：构建结算页面时初始化订单-支付时订单提交-支付成功才会执行订单。&lt;/p&gt;&lt;p&gt;逻辑上的细节要持续追求严谨，业务实现手段和思路适当放宽，流程经得起考验，底层实现合理的复用，组件选择上应该站在高纬度，就基本足以。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;五、源代码地址&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;GitHub·地址&lt;br/&gt;https://github.com/cicadasmile/java-base-parent&lt;br/&gt;GitEE·地址&lt;br/&gt;https://gitee.com/cicadasmile/java-base-parent&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU4Njg0MzYwNw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBCuF3zfJnqPKpUia4wfn1FUtTHpxxkR5HvbicPgOjibPicX0goMOkny1NdkLAJvBaqrYh3UdwMjiaDQMA/0?wx_fmt=png&quot; data-nickname=&quot;知了一笑&quot; data-alias=&quot;cicada_smile&quot; data-signature=&quot;积累是一个孤独且枯燥的过程&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ac14c4b9298e7a43c4d0a98c1d07b436</guid>
<title>容器三把斧之 namespace 原理与实现</title>
<link>https://toutiao.io/k/1uwmeyu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h2&gt;&lt;span&gt;namespace介绍&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;code&gt;namespace（命名空间）&lt;/code&gt; 是Linux提供的一种内核级别环境隔离的方法，很多编程语言也有 namespace 这样的功能，例如C++，Java等，编程语言的 namespace 是为了解决项目中能够在不同的命名空间里使用相同的函数名或者类名。而Linux的 namespace 也是为了实现资源能够在不同的命名空间里有相同的名称，譬如在 &lt;code&gt;A命名空间&lt;/code&gt; 有个pid为1的进程，而在 &lt;code&gt;B命名空间&lt;/code&gt; 中也可以有一个pid为1的进程。&lt;/p&gt;&lt;p&gt;有了 &lt;code&gt;namespace&lt;/code&gt; 就可以实现基本的容器功能，著名的 &lt;code&gt;Docker&lt;/code&gt; 也是使用了 namespace 来实现资源隔离的。&lt;/p&gt;&lt;p&gt;Linux支持6种资源的 &lt;code&gt;namespace&lt;/code&gt;，分别为（文档）：&lt;/p&gt;&lt;section&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Type&lt;/th&gt;&lt;th&gt;Parameter&lt;/th&gt;&lt;th&gt;Linux Version&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Mount namespaces&lt;/td&gt;&lt;td&gt;CLONE_NEWNS&lt;/td&gt;&lt;td&gt;Linux 2.4.19&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;UTS namespaces&lt;/td&gt;&lt;td&gt;CLONE_NEWUTS&lt;/td&gt;&lt;td&gt;Linux 2.6.19&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;IPC namespaces&lt;/td&gt;&lt;td&gt;CLONE_NEWIPC&lt;/td&gt;&lt;td&gt;Linux 2.6.19&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;PID namespaces&lt;/td&gt;&lt;td&gt;CLONE_NEWPID&lt;/td&gt;&lt;td&gt;Linux 2.6.24&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Network namespaces&lt;/td&gt;&lt;td&gt;CLONE_NEWNET&lt;/td&gt;&lt;td&gt;Linux 2.6.24&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;User namespaces&lt;/td&gt;&lt;td&gt;CLONE_NEWUSER&lt;/td&gt;&lt;td&gt;Linux 2.6.23&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p&gt;在调用 &lt;code&gt;clone()&lt;/code&gt; 系统调用时，传入以上的不同类型的参数就可以实现复制不同类型的namespace。比如传入 &lt;code&gt;CLONE_NEWPID&lt;/code&gt; 参数时，就是复制 &lt;code&gt;pid命名空间&lt;/code&gt;，在新的 &lt;code&gt;pid命名空间&lt;/code&gt; 里可以使用与其他 &lt;code&gt;pid命名空间&lt;/code&gt; 相同的pid。代码如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; _GNU_SOURCE&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;sched.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;sys/wait.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;signal.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;errno.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;char&lt;/span&gt; child_stack[&lt;span&gt;5000&lt;/span&gt;];&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;child&lt;/span&gt;&lt;span&gt;(&lt;span&gt;void&lt;/span&gt;* arg)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;Child - %d\n&quot;&lt;/span&gt;, getpid());&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;Parent - fork child\n&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; pid = clone(child, child_stack+&lt;span&gt;5000&lt;/span&gt;, CLONE_NEWPID, &lt;span&gt;NULL&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (pid == &lt;span&gt;-1&lt;/span&gt;) {&lt;br/&gt;        perror(&lt;span&gt;&quot;clone:&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;exit&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;    waitpid(pid, &lt;span&gt;NULL&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;Parent - child(%d) exit\n&quot;&lt;/span&gt;, pid);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Parent - fork child&lt;br/&gt;Parent - child(9054) &lt;span&gt;exit&lt;/span&gt;&lt;br/&gt;Child - 1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从运行结果可以看出，在子进程的 &lt;code&gt;pid命名空间&lt;/code&gt; 里当前进程的pid为1，但在父进程的 &lt;code&gt;pid命名空间&lt;/code&gt; 中子进程的pid却是9045。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;namespace实现原理&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;为了让每个进程都可以从属于某一个namespace，Linux内核为进程描述符添加了一个 &lt;code&gt;struct nsproxy&lt;/code&gt; 的结构，如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;task_struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    ...&lt;br/&gt;    &lt;span&gt;/* namespaces */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;nsproxy&lt;/span&gt; *&lt;span&gt;nsproxy&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;nsproxy&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;atomic_t&lt;/span&gt; count;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;uts_namespace&lt;/span&gt;  *&lt;span&gt;uts_ns&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;ipc_namespace&lt;/span&gt;  *&lt;span&gt;ipc_ns&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;mnt_namespace&lt;/span&gt;  *&lt;span&gt;mnt_ns&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;pid_namespace&lt;/span&gt;  *&lt;span&gt;pid_ns&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;user_namespace&lt;/span&gt; *&lt;span&gt;user_ns&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;net&lt;/span&gt;            *&lt;span&gt;net_ns&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从 &lt;code&gt;struct nsproxy&lt;/code&gt; 结构的定义可以看出，Linux为每种不同类型的资源定义了不同的命名空间结构体进行管理。比如对于 &lt;code&gt;pid命名空间&lt;/code&gt; 定义了 &lt;code&gt;struct pid_namespace&lt;/code&gt; 结构来管理 。由于 namespace 涉及的资源种类比较多，所以本文主要以 &lt;code&gt;pid命名空间&lt;/code&gt; 作为分析的对象。&lt;/p&gt;&lt;p&gt;我们先来看看管理 &lt;code&gt;pid命名空间&lt;/code&gt; 的 &lt;code&gt;struct pid_namespace&lt;/code&gt; 结构的定义：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;pid_namespace&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;kref&lt;/span&gt; &lt;span&gt;kref&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;pidmap&lt;/span&gt; &lt;span&gt;pidmap&lt;/span&gt;[&lt;span&gt;PIDMAP_ENTRIES&lt;/span&gt;];&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; last_pid;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;task_struct&lt;/span&gt; *&lt;span&gt;child_reaper&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;kmem_cache&lt;/span&gt; *&lt;span&gt;pid_cachep&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; level;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;pid_namespace&lt;/span&gt; *&lt;span&gt;parent&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;ifdef&lt;/span&gt; CONFIG_PROC_FS&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;vfsmount&lt;/span&gt; *&lt;span&gt;proc_mnt&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为 &lt;code&gt;struct pid_namespace&lt;/code&gt; 结构主要用于为当前 &lt;code&gt;pid命名空间&lt;/code&gt; 分配空闲的pid，所以定义比较简单：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;kref&lt;/code&gt; 成员是一个引用计数器，用于记录引用这个结构的进程数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;pidmap&lt;/code&gt; 成员用于快速找到可用pid的位图&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;last_pid&lt;/code&gt; 成员是记录最后一个可用的pid&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;level&lt;/code&gt; 成员记录当前 &lt;code&gt;pid命名空间&lt;/code&gt; 所在的层次&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;parent&lt;/code&gt; 成员记录当前 &lt;code&gt;pid命名空间&lt;/code&gt; 的父命名空间&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;由于 &lt;code&gt;pid命名空间&lt;/code&gt; 是分层的，也就是说新创建一个 &lt;code&gt;pid命名空间&lt;/code&gt; 时会记录父级 &lt;code&gt;pid命名空间&lt;/code&gt; 到 &lt;code&gt;parent&lt;/code&gt; 字段中，所以随着 &lt;code&gt;pid命名空间&lt;/code&gt; 的创建，在内核中会形成一颗 &lt;code&gt;pid命名空间&lt;/code&gt; 的树，如下图（图片来源）：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7692307692307693&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ciab8jTiab9J74NbeVUdkM6eOh9r4NC48Kf8z17iaicxOZKQNUthUYx2NBictpiaIUdZIF6BPC7Ty4XI3GyUAYGvTvhA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;598&quot;/&gt;&lt;figcaption&gt;pid-namespace&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;第0层的 &lt;code&gt;pid命名空间&lt;/code&gt; 是 &lt;code&gt;init&lt;/code&gt; 进程所在的命名空间。如果一个进程所在的 &lt;code&gt;pid命名空间&lt;/code&gt; 为 &lt;code&gt;N&lt;/code&gt;，那么其在 &lt;code&gt;0 ~ N 层pid命名空间&lt;/code&gt; 都有一个唯一的pid号。也就是说 &lt;code&gt;高层pid命名空间&lt;/code&gt; 的进程对 &lt;code&gt;低层pid命名空间&lt;/code&gt; 的进程是可见的，但是 &lt;code&gt;低层pid命名空间&lt;/code&gt; 的进程对 &lt;code&gt;高层pid命名空间&lt;/code&gt; 的进程是不可见的。&lt;/p&gt;&lt;p&gt;由于在 &lt;code&gt;第N层pid命名空间&lt;/code&gt; 的进程其在 &lt;code&gt;0 ~ N层pid命名空间&lt;/code&gt; 都有一个唯一的pid号，所以在进程描述符中通过 &lt;code&gt;pids&lt;/code&gt; 成员来记录其在每个层的pid号，代码如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;task_struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    ...&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;pid_link&lt;/span&gt; &lt;span&gt;pids&lt;/span&gt;[&lt;span&gt;PIDTYPE_MAX&lt;/span&gt;];&lt;/span&gt;&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;enum&lt;/span&gt; pid_type {&lt;br/&gt;    PIDTYPE_PID,&lt;br/&gt;    PIDTYPE_PGID,&lt;br/&gt;    PIDTYPE_SID,&lt;br/&gt;    PIDTYPE_MAX&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;upid&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; nr;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;pid_namespace&lt;/span&gt; *&lt;span&gt;ns&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;hlist_node&lt;/span&gt; &lt;span&gt;pid_chain&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;pid&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;atomic_t&lt;/span&gt; count;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;hlist_head&lt;/span&gt; &lt;span&gt;tasks&lt;/span&gt;[&lt;span&gt;PIDTYPE_MAX&lt;/span&gt;];&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;rcu_head&lt;/span&gt; &lt;span&gt;rcu&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; level;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;upid&lt;/span&gt; &lt;span&gt;numbers&lt;/span&gt;[1];&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;pid_link&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;hlist_node&lt;/span&gt; &lt;span&gt;node&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;pid&lt;/span&gt; *&lt;span&gt;pid&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这几个结构的关系如下图：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5994623655913979&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ciab8jTiab9J74NbeVUdkM6eOh9r4NC48KicZDODa01icT37hqUoqJYhtiaUHDRjuzIFSKqa0v0dj6woKv60F77w9Uw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1116&quot;/&gt;&lt;figcaption&gt;pid-namespace-structs&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;我们主要关注 &lt;code&gt;struct pid&lt;/code&gt; 这个结构，&lt;code&gt;struct pid&lt;/code&gt; 有个类型为 &lt;code&gt;struct upid&lt;/code&gt; 的成员 &lt;code&gt;numbers&lt;/code&gt;，其定义为只有一个元素的数组，但是其实是一个动态的数据，它的元素个数与 &lt;code&gt;level&lt;/code&gt; 的值一致，也就是说当 &lt;code&gt;level&lt;/code&gt; 的值为5时，那么 &lt;code&gt;numbers&lt;/code&gt; 成员就是一个拥有5个元素的数组。而每个元素记录了其在每层 &lt;code&gt;pid命名空间&lt;/code&gt; 的pid号，而 &lt;code&gt;struct upid&lt;/code&gt; 结构的 &lt;code&gt;nr&lt;/code&gt; 成员就是用于记录进程在不同层级 &lt;code&gt;pid命名空间&lt;/code&gt; 的pid号。&lt;/p&gt;&lt;p&gt;我们通过代码来看看怎么为进程分配pid号的，在内核中是用过 &lt;code&gt;alloc_pid()&lt;/code&gt; 函数分配pid号的，代码如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;struct pid *&lt;span&gt;alloc_pid&lt;/span&gt;&lt;span&gt;(struct pid_namespace *ns)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;pid&lt;/span&gt; *&lt;span&gt;pid&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;enum&lt;/span&gt; pid_type type;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i, nr;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;pid_namespace&lt;/span&gt; *&lt;span&gt;tmp&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;upid&lt;/span&gt; *&lt;span&gt;upid&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    pid = kmem_cache_alloc(ns-&amp;gt;pid_cachep, GFP_KERNEL);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!pid)&lt;br/&gt;        &lt;span&gt;goto&lt;/span&gt; out;&lt;br/&gt;&lt;br/&gt;    tmp = ns;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (i = ns-&amp;gt;level; i &amp;gt;= &lt;span&gt;0&lt;/span&gt;; i--) {&lt;br/&gt;        nr = alloc_pidmap(tmp);    &lt;span&gt;// 为当前进程所在的不同层级pid命名空间分配一个pid&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (nr &amp;lt; &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;            &lt;span&gt;goto&lt;/span&gt; out_free;&lt;br/&gt;&lt;br/&gt;        pid-&amp;gt;numbers[i].nr = nr;   &lt;span&gt;// 对应i层namespace中的pid数字&lt;/span&gt;&lt;br/&gt;        pid-&amp;gt;numbers[i].ns = tmp;  &lt;span&gt;// 对应i层namespace的实体&lt;/span&gt;&lt;br/&gt;        tmp = tmp-&amp;gt;parent;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    get_pid_ns(ns);&lt;br/&gt;    pid-&amp;gt;level = ns-&amp;gt;level;&lt;br/&gt;    atomic_set(&amp;amp;pid-&amp;gt;count, &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (type = &lt;span&gt;0&lt;/span&gt;; type &amp;lt; PIDTYPE_MAX; ++type)&lt;br/&gt;        INIT_HLIST_HEAD(&amp;amp;pid-&amp;gt;tasks[type]);&lt;br/&gt;&lt;br/&gt;    spin_lock_irq(&amp;amp;pidmap_lock);&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (i = ns-&amp;gt;level; i &amp;gt;= &lt;span&gt;0&lt;/span&gt;; i--) {&lt;br/&gt;        upid = &amp;amp;pid-&amp;gt;numbers[i];&lt;br/&gt;        &lt;span&gt;// 把upid连接到全局pid中, 用于快速查找pid&lt;/span&gt;&lt;br/&gt;        hlist_add_head_rcu(&amp;amp;upid-&amp;gt;pid_chain,&lt;br/&gt;                &amp;amp;pid_hash[pid_hashfn(upid-&amp;gt;nr, upid-&amp;gt;ns)]);&lt;br/&gt;    }&lt;br/&gt;    spin_unlock_irq(&amp;amp;pidmap_lock);&lt;br/&gt;&lt;br/&gt;out:&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; pid;&lt;br/&gt;&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的代码中，那个 &lt;code&gt;for (i = ns-&amp;gt;level; i &amp;gt;= 0; i--)&lt;/code&gt; 就是通过 &lt;code&gt;parent&lt;/code&gt; 成员不断向上检索为不同层级的 &lt;code&gt;pid命名空间&lt;/code&gt; 分配一个唯一的pid号，并且保存到对应的 &lt;code&gt;nr&lt;/code&gt; 字段中。另外，还会把进程所在各个层级的pid号添加到全局pid哈希表中，这样做是为了通过pid号快速找到进程。&lt;/p&gt;&lt;p&gt;现在我们来看看怎么通过pid号快速找到一个进程，在内核中 &lt;code&gt;find_get_pid()&lt;/code&gt; 函数用来通过pid号查找对应的 &lt;code&gt;struct pid&lt;/code&gt; 结构，代码如下（find_get_pid() -&amp;gt; find_vpid() -&amp;gt; find_pid_ns()）：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;struct pid *&lt;span&gt;find_get_pid&lt;/span&gt;&lt;span&gt;(&lt;span&gt;pid_t&lt;/span&gt; nr)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;pid&lt;/span&gt; *&lt;span&gt;pid&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    rcu_read_lock();&lt;br/&gt;    pid = get_pid(find_vpid(nr));&lt;br/&gt;    rcu_read_unlock();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; pid;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;struct pid *&lt;span&gt;find_vpid&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; nr)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; find_pid_ns(nr, current-&amp;gt;nsproxy-&amp;gt;pid_ns);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;struct pid *&lt;span&gt;find_pid_ns&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; nr, struct pid_namespace *ns)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;hlist_node&lt;/span&gt; *&lt;span&gt;elem&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;upid&lt;/span&gt; *&lt;span&gt;pnr&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    hlist_for_each_entry_rcu(pnr, elem,&lt;br/&gt;            &amp;amp;pid_hash[pid_hashfn(nr, ns)], pid_chain)&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (pnr-&amp;gt;nr == nr &amp;amp;&amp;amp; pnr-&amp;gt;ns == ns)&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; container_of(pnr, struct pid,&lt;br/&gt;                    numbers[ns-&amp;gt;level]);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过pid号查找 &lt;code&gt;struct pid&lt;/code&gt; 结构时，首先会把进程pid号和当前进程的 &lt;code&gt;pid命名空间&lt;/code&gt; 传入到 &lt;code&gt;find_pid_ns()&lt;/code&gt; 函数，而在 &lt;code&gt;find_pid_ns()&lt;/code&gt; 函数中通过全局pid哈希表来快速查找对应的 &lt;code&gt;struct pid&lt;/code&gt; 结构。获取到 &lt;code&gt;struct pid&lt;/code&gt; 结构后就可以很容易地获取到进程对应的进程描述符，例如可以通过 &lt;code&gt;pid_task()&lt;/code&gt; 函数来获取 &lt;code&gt;struct pid&lt;/code&gt; 结构对应进程描述符，由于代码比较简单，这里就不再分析了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a88b3969972adb4e9f02e096971c026b</guid>
<title>除了这点技术，其它什么也不会啊</title>
<link>https://toutiao.io/k/x4pf7co</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;长按二维码向我转账&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;&gt;人生如梦，一樽还酹江月&lt;/p&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;受苹果公司新规定影响，微信 iOS 版的赞赏功能被关闭，可通过二维码转账支持公众号。&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a25a98150461a520254a6dcf6744c140</guid>
<title>eBay 基于 Istio 的应用网关的探索和实践</title>
<link>https://toutiao.io/k/njaygo0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;7月17日，在Cloud Native Days China云原生多云多集群专场，eBay软件工程师陈佑雄发表了《eBay基于Istio的应用网关的探索和实践》主题演讲，分享了eBay在多集群，多环境，大规模的场景下，Istio落地实践的探索和实践。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.6666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ia1Z7HH4plnANxZXFIZ96M6bwVzyXXPqZKK0fshAd2wiaYmhu3ibrRRvSmFKycGXyj1IiaxiaicZ25eGhAzIWqvicPRVQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;演讲主要包含四部分的内容：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;1）数据中心流量管理现状&lt;/p&gt;&lt;p&gt;2）基于Istio的应用网关实践&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Istio部署模式&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;应用高可用接入架构&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;流量统一管理模型&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;案例分享&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;3）Istio社区未解决的问题&lt;/p&gt;&lt;p&gt;4）未来展望&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;数据中心流量管理现状&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7351852&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia1Z7HH4plnANxZXFIZ96M6bwVzyXXPqZWOE9Zm6icGJVOTQf5tpcg9kkrAxaKkOicMsNK5dPYOiaTFWHicGg5yETdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;我们是有三个数据中心，每个数据中心有多个可用区，每个可用区有多个Kubernetes集群。现在流量接入数据中心主要是通过硬件负载均衡设备，也就是图中Web层的LB和APP层的LB，这些其实都是硬件负载均衡的设备对。目前，三个数据中心大概有2000多对这样的硬件负载均衡设备。我们内部应用相互间的调用主要是以南北向的流量为主，Web层会做流量的分发，将99%的流量转发到本地数据中心，1%的流量转发到远端的数据中心。数据中心的特征因我们是微服务的架构，所以它的VIP数量很多，同时会有公网和内网的VIP,并且在VIP上配置有少量L7规则，也就是应用间互相调用的防护规则。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们期望实现的目标是可以基于Istio将这2000多对硬件负载均衡设备对全部替换掉。这种两层的架构其实我们已经用了很多年了，它最大的好处是假设某一个服务的应用在某一个数据中心全部宕机，这种情况下流量会自动切换到远端的数据中心，因为这边的健康检查会将这条链路断掉，如此客户端就不会因为缓存了这个VIP地址，造成客户端数据面的影响。因此在应用部署时，在每一个数据中心是有容量冗余的，就是我们可以端掉一个数据中心，其他两个数据中心的容量可足够支撑这个服务。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;规模化带来的挑战&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;1）异构应用&lt;/span&gt;&lt;/p&gt;&lt;p&gt;2）日益增长的安全需求：全链路TLS&lt;/p&gt;&lt;p&gt;3）可见性需求&lt;/p&gt;&lt;p&gt;4）数据中心规模：3主数据中心，20边缘数据中心，100+ Kubernetes集群&lt;/p&gt;&lt;p&gt;5）规模化运营Kubernetes集群&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;总计100,000物理节点&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;单集群物理机节点规模高达 5,000&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;6）业务服务全面容器化，单集群&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Pod实例可达 100,000&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;发布服务 5,000-10000&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;7）单集群多环境支持&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;功能测试、集成测试、压力测试共用单集群&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;不同环境需要彼此隔离&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;目前我们采用的是基于IPVS和Istio的网络云原生架构：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7083333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia1Z7HH4plnANxZXFIZ96M6bwVzyXXPqZicOhPfiagyFkKy81EhTJuTnPkjj8lWeu5FQ1l01SKN5PMFLXXufGict2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;基于IPVS的L4 Service控制器：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Istio作为应用网关控制器：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;管理应用L7规则&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;自动化生成eBay证书&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;管理和注入sidecar&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;网格内部请求mTLS&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;基于Istio的应用网关实践&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;Istio单集群多环境部署&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.5324074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia1Z7HH4plnANxZXFIZ96M6bwVzyXXPqZCTIKhCsUBFGknsMrW0HFsKLA4fXsLo31cvTx00KTfEkZAfiabvJFAYg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;非生产环境：Feature/LnP/Staging/StagingPCI&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;生产环境：Pre-Prod/Prod/PCI(Payment Card Industry)&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;单个k8s集群部署多套Istiod，IngressGateway和L4集群&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Cheery-pick 社区Pilot scoped namespaces PR&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;不同环境控制面数据面隔离&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;Istio集群证书管理&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;网关证书&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.2277778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia1Z7HH4plnANxZXFIZ96M6bwVzyXXPqZBVEib9QhCRTwaLAI9SMMT1jfkCpT8IIgYQxHenxoeE9lFbZYiaslkIIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;集成eBay CA，secret保存证书Ref&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Istiod集成cert agent&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;SDS通过cert agent GRPC获取证书和key推送到IngressGateway&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;集群证书&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.3101852&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia1Z7HH4plnANxZXFIZ96M6bwVzyXXPqZ0d2n0g7RvJqVL2wgsXS5icRMoOLwIGzVWqYT9HicP38zGJ58PDPB3Djw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;利用自签根证书为每个Istio集群签发中间证书&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;因安全方面的需求，需保证中间证书更新期间新旧证书同时可用&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;单网关全链路加密模式&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.8148148&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia1Z7HH4plnANxZXFIZ96M6bwVzyXXPqZVDiaKdiaQkB4RK63MkWr4U4cRh7Jx5rjx4l3icdkdz0YFO7OOIkR5VonA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;单网关全链路加密模式的架构图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;1）应用场景&lt;/p&gt;&lt;p&gt;2）同时支持API Gateway和Mesh&lt;/p&gt;&lt;p&gt;3）软件防火墙集成(Sentinel)&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;默认阻止所有访问&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;保护Ingress/Egress流量&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;保护进入Pod的流量&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;4）模拟生产环境&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;多网关多集群部署&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.5324074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia1Z7HH4plnANxZXFIZ96M6bwVzyXXPqZyUvOZzNH0CK7CJoHzpkXfGPL46wutj18RGnlc65jHfiaPJfEjHpatBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1）Kubernetes集群联邦&lt;/p&gt;&lt;p&gt;2）可用区&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;数据中心中具有独立供电制冷设备的故障域&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;同一可用区有较小网络延迟&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;同一可用区部署了多个Kubernetes集群&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;3）多集群部署&lt;/p&gt;&lt;p&gt;4）东西南北流量统一管控&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;同一可用区的服务调用基于Sidecar&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;跨可用区的服务调用基于Istio Gateway&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;Istio Primary-Remote压力测试&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Istio控制面主要考虑两个配置推送到mesh的收敛时间(convergence time)：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.615&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia1Z7HH4plnANxZXFIZ96M6bwVzyXXPqZjql9sMwvMl7703ZQhALIB3G0aQgzy587sCWXSjNZotdiaeic7iaYR6jibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;400&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.6624365&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia1Z7HH4plnANxZXFIZ96M6bwVzyXXPqZmz36Hss2kRzCVv6Bg8U97kdOYrHsXdok4ibuVicfibaF8NcCicVgyLDSibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;394&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;结论：&lt;/p&gt;&lt;p&gt;1）单个Istiod 32 CPU/10G内存可以支持：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;32个Ingress Pods&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;2000个sidecar&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;2）收敛时间小于5秒能够支持的规模：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;2000 k8s service(5个端口)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;其中同时有100个Endpoint地址发生变更&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;3）如果k8s Service数量少于2000，为了实现收敛时间小于5s，Istiod Pod的数量可以通过如下公式计算:&lt;/p&gt;&lt;p&gt;Istio Number = gateway number / 32 + sidecar number / 2000&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;应用高可用接入方案-多集群1层&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;这里的一层是指 VIP的数量：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.637037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia1Z7HH4plnANxZXFIZ96M6bwVzyXXPqZUPtGibianb4kayoKJG7V4jWicUIHXoIcI94xM9cmH2H4z4eyDI51hm0vA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;流量管理&lt;/p&gt;&lt;p&gt;故障容灾&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;应用高可用接入方案-多集群2层&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;方案一：&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.6731481&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia1Z7HH4plnANxZXFIZ96M6bwVzyXXPqZm4fbxMz6iackaPqW8rrM9JD6RQvAxmJv8ODcAexMZ0KK8gj9ahIGNEg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;流量管理&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;L4 IPVS 为流量入口&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;本集群流量从Gateway直连后端服务器&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;跨集群流量经过远端IPVS VIP转发&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;ServiceEntry同时选择Pod和VIP&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;定义基于Locality的流量转发规则&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;同一数据中心流量权重99%，跨数据中心1%&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;故障容灾&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;单集群应用后端Pod整体宕机不会造成数据面影响&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Istio网关宕机，智能DNS停止返回该VIP&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因此我们又提出了另外一种两层的架构，这种两层的架构是我们现在比较倾向于选择的架构，它虽然也有两层VIP，但实际上它只有一个IP，只是我们开了两个端口。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;方案二：&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.6027778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia1Z7HH4plnANxZXFIZ96M6bwVzyXXPqZzbFKKTyZqpU7peAF75EhHaZvdUCOLOIicGr5x7WO2DQrQc4qI7qH65A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;流量管理&lt;/p&gt;&lt;p&gt;故障容灾&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;单集群应用后端Pod整体宕机不会造成数据面影响&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Istio 网关宕机会受客户端DNS缓存影响&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;应用高可用接入方案-数据面&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.6583333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia1Z7HH4plnANxZXFIZ96M6bwVzyXXPqZu67H8K54tiac7uVDy6mvV4n01oDX3f6hbwoKJWX4cLcuedic7K2h2Dog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;用户请求通过L4(IPVS)转发到IngressGateway&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;TLS PAASTHROUGH将请求路由至weighted cluster&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Weighted cluster的Endpoints为本地和远端的网关地址&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;请求转发至本集群:TLS握手发生在client和gateway pod&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;请求需经过2次TLS&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;IngressGateway将请求响应通过Direct Server Return返回客户端&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.8388815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia1Z7HH4plnANxZXFIZ96M6bwVzyXXPqZBHahD2nQBht89icBEUj0POMgUNxc3Dic5Fr9wgfgD0QznQFkp5JmT82A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;751&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;TLS握手发生在local gateway和gateway pod&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Ingress Gateway Pod需配置eBay Root CA&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;请求需经过2次TLS&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;正常接收1%流量，本集群后端服务整体宕机接收100%流量&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;适配服务间调用（L7转发规则）&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;99%请求走Mesh东西向流量&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;1%请求经Gateway跨Mesh&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;VirtualService配置weighted Destination&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;统一流量模型 - AccessPoint&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.6694444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia1Z7HH4plnANxZXFIZ96M6bwVzyXXPqZJQxMaAyDoYsE9vicibmcOEeFn7ia1jCQNQPPxhob4uMeIIF27ZLsNcuzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;基于Istio网关的feature测试开发环境&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.6388889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia1Z7HH4plnANxZXFIZ96M6bwVzyXXPqZg8ibyVUwfxbGayibIBKud2C2aREnoNoWWLtVUukmOiczJljZ78eaPqMXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Feature测试环境规模：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;VirtualService指定转发规则&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Host: foo.example.com&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Destination：foo-service&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Lesson Learn:&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因此这套方案后来我们没有使用，用另外一套方案去替换了。但是也有一个很大的教训，就是说一个merge的scalability不可能无限大，因此我们一是要做基于环境的隔离，二是要对merge的规模进行控制，这样才能保证整个merge的稳定性和可用性。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;基于Istio网关的集中日志系统CAL&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;CAL日志系统集成Mesh&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.6333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia1Z7HH4plnANxZXFIZ96M6bwVzyXXPqZ2vflS5CIiaBHkricsUlgkLft9bu5FUIYOUFsR4bBETCsR91GW3kAHicfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;不同网格同时部署应用以及日志服务器&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;同时注入sidecar到应用端以及日志系统服务端&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;网格内部mTLS实现日志脱敏&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;南北流量转成东西流量&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;全链路加密存储服务-NuObject&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;NuObject是我们目前做的一个新项目，用来替换Swift, 前期我们也做了很多压力测试，下图为压力测试环境与结果：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.2564815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia1Z7HH4plnANxZXFIZ96M6bwVzyXXPqZn4UsyR8icvYV9uZ5gQ5kNf6M1iaHkIKoDNPQuI3Gs8nqwQv2YuibsP5dQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;压力测试环境&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.3240741&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia1Z7HH4plnANxZXFIZ96M6bwVzyXXPqZqH4SIr1IvAwsUErQNXcV5fge91Q0rBnLB1ak51Zxcz2JY2RjUas2uA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;高吞吐压力测试&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;高安全性存储服务&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;注入Sidecar到后端服务&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;网关配置Simple TLS&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;网格内部mTLS&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;集成软件防火墙&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;Managed Stack全面集成Mesh&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.5435185&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia1Z7HH4plnANxZXFIZ96M6bwVzyXXPqZqbDUuLrxCBDPFjrZSKice29a5QE97WGViaJ95RXfLymmUFLmZ0icDWvnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Managed Stack是使用eBay框架的应用，包括Java, Java Web, Batch以及NodeJS应用&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;Istio社区未解决的问题&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;1）端口协议冲突&lt;/p&gt;&lt;p&gt;2）单点从外部访问mTLS Mesh机器&lt;/p&gt;&lt;p&gt;3）Envoy readiness probe&lt;/p&gt;&lt;p&gt;4）Init Container inbound/outbound被block，社区issue&lt;/p&gt;&lt;p&gt;5）控制面性能问题&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;未来展望&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;__bg_gif&quot; data-ratio=&quot;0.74&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/ZPtdzESiawhdMHyNfDvj0a36SiaN499NjK0BKean9ibV1T8rYe2gLG8OTSjeCB1NesY09JLKujB7DqpO8DGu4HFxw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;300&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzNzU5NTYzMA==&amp;amp;mid=2247493836&amp;amp;idx=1&amp;amp;sn=d2dd6ebbb5bedca205c7f7030256a93f&amp;amp;chksm=e8c4964ddfb31f5bc15b901b782b2e76d22aa1a6eb82868b62626582005232ac4c20383af989&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;您有一份Kubernetes 1.22 指南待查收~&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzNzU5NTYzMA==&amp;amp;mid=2247493814&amp;amp;idx=1&amp;amp;sn=45eb1d83218aa8ce41eb05920df4561e&amp;amp;chksm=e8c49637dfb31f2191289af1ccef43e375f0451c6529bf877fbd14a60afd15595b42e05c4c47&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;科普 | 从零开始入门容器，看这篇就够了！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzNzU5NTYzMA==&amp;amp;mid=2247493781&amp;amp;idx=1&amp;amp;sn=b4a1ab0eee727c00ed2fe80c33c0295a&amp;amp;chksm=e8c49614dfb31f026003b5c8a63fb85e519a43bb08180324285a67f54b51561d5a3dea84cfb1&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;【Ask云原生·VOL02】容器到底能“装”啥？&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;111&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;111&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ia1Z7HH4plnCqgkia6XMVK2WHqxZTTxdjOrOVKE3oBVsIRbB7hbhQTt3ll0pJo5icuicoKjAxAnoN07lu1ohK82w4A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;430&quot;/&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;扫描二维码 ｜ 加入Istio交流群&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong&gt;&lt;img class=&quot;__bg_gif&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/6aVaON9Kibf5ibKRPQgZ9XgbVNsIeQUnfKSiaErmr8dtdicicS3A8m6TiavR6ZB0Eah3pD0kjQg8ACyNb1x5ibdqRg2jA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;戳原文，&lt;span&gt;观看完整演讲视频&lt;/span&gt;！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>