<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>439d191b0f2b207cf79e985d5458f4ce</guid>
<title>什么是真正的程序员？| 码农周刊第 323 期</title>
<link>https://toutiao.io/k/v08ikpz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;issue&quot; id=&quot;readabilityBody&quot;&gt;
        &lt;h1&gt;什么是真正的程序员？| 码农周刊第 323 期&lt;/h1&gt;
        &lt;h2&gt;码农周刊第323期（2020-10-28）&lt;/h2&gt;
        &lt;p&gt;☞ &lt;a href=&quot;https://weekly.manong.io/bounce?nid=323&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3230&quot; target=&quot;_blank&quot;&gt;薪资翻番如何实现？程序员的涨薪秘诀&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;a href=&quot;https://weekly.manong.io/bounce?nid=323&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3230&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_321.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;small&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=323&amp;amp;aid=19185&amp;amp;url=https%3A%2F%2Fjinshuju.net%2Ff%2FV7DxN9&quot; target=&quot;_blank&quot;&gt;商务合作&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
        
        &lt;h3 id=&quot;程序设计&quot;&gt;程序设计&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;业界实战&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;VIP会员专区&quot;&gt;VIP会员专区&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;工作地点：成都 | 薪资：15-30K | 简历投递邮箱：xiexiaofang@huobi.com&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;适合入门&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;该框架由阿里云机器学习 PAI 团队研发，让自然语言处理场景的模型预训练和迁移学习开发与部署更加简单和高效。&lt;/p&gt;
        &lt;h3 id=&quot;工具资料&quot;&gt;工具资料&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;硬核&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;论文笔记&lt;/p&gt;
        
        &lt;p&gt;系列文章&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;因子分解机算法&lt;/p&gt;
        
        &lt;p&gt;深入讲解&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;Yahoo 开源的 Kafka 集群管理平台&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;更多可能&lt;/p&gt;
        
        &lt;p&gt;实战经验&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程语言&quot;&gt;编程语言&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;源码分析&lt;/p&gt;
        
        &lt;p&gt;一个 Android Jetpack 扩展库&lt;/p&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;一步步教你&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;倾向于使用 Less 或 Stylus&lt;/p&gt;
        &lt;h3 id=&quot;每周独家号推荐&quot;&gt;每周独家号推荐&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;这里有最接地气的架构师一线实战经验、核心技能的分享。运营和产品的总结。以及一些个人的深度思考。&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 268968 即可&lt;/p&gt;
        
        &lt;p&gt;GO PHP JS 一网打尽&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 146415 即可&lt;/p&gt;
        
        &lt;p&gt;分享技术，专注程序员成长&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 137785 即可&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;Coding虽易，debug不易....&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 98777 即可&lt;/p&gt;
        
        &lt;p&gt;专注分享Java实战技术、Java基础原理、微服务实战技术、分布式系统架构&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 22887 即可&lt;/p&gt;
        &lt;h3 id=&quot;每周一书&quot;&gt;每周一书&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;本书为对基本概率论感兴趣的读者以及之前未接触过此方向的人提供了一个坚实的基础。通过对话的方式和详细的数学推导，在迷人的风格和信息丰富的讨论上取得了平衡。欢迎到&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;兑换阅读。&lt;/p&gt;
        &lt;h3 id=&quot;编程之外&quot;&gt;编程之外&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;真实&lt;/p&gt;
        
        &lt;p&gt;值得思考&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;p&gt;
        &lt;/p&gt;
        
        
        
        
        &lt;div class=&quot;qrcode&quot;&gt;
  &lt;img src=&quot;https://img.toutiao.io/ads/vip_qrcode.png&quot; alt=&quot;Qrcode 258&quot;/&gt;&lt;span&gt;加入码农周刊VIP会员&lt;/span&gt;
&lt;/div&gt;
    &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c19c13967ef4564c5a9667d045b48dc3</guid>
<title>[推荐] 好的自我介绍，面试成功一大半</title>
<link>https://toutiao.io/k/lpyu6km</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;这里是Z哥的个人公众号&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;每周五11：45 按时送达&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;当然了，也会时不时加个餐～&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;我的第「164」篇原创敬上&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;大家好，我是Z哥。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;关于面试时的自我介绍，我想大家遇到的情况都差不多，大部分面试的第一个环节基本都是这个。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;每个人也都知道留下好的第一印象很重要，但我估计很多人对这件事的解决方式，也就在网上找个自我介绍的模版就完事了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;先不说你找的模版会不会过于普通，导致面试官听到的千篇一律。更重要的是，如果你搞不清楚自我介绍背后的深意和价值，哪怕是套用模版也只是学了它的“形”而没学到“神”，效果自然不会太好。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我做面试官也有将近6年时间了，不管是从我自己的感受还是与其他面试官的交流后得到的信息来看，自我介绍环节能让人有惊喜的，只要后面不太“拉胯”基本都能被录用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;心理学中有一个概念阐述了这背后的原因——「&lt;/span&gt;&lt;strong&gt;&lt;span&gt;首因效应&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;」，由美国心理学家洛钦斯提出。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;71&quot; data-source-title=&quot;维基百科&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;首因效应是对“第一印象”或“先入为主”所产生的心理学现象，指在行为过程中，最先接触的事物会给人留下深刻的感知或认知，影响人对事物的感知和判断。&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;blockquote_info js_blockquote_source&quot; data-json=&quot;%7B%22type%22%3A%22out%22%2C%22source%22%3A%22url%22%2C%22digest%22%3A%22%22%2C%22digestLen%22%3A71%2C%22text%22%3A%22%E9%A6%96%E5%9B%A0%E6%95%88%E5%BA%94%E6%98%AF%E5%AF%B9%E2%80%9C%E7%AC%AC%E4%B8%80%E5%8D%B0%E8%B1%A1%E2%80%9D%E6%88%96%E2%80%9C%E5%85%88%E5%85%A5%E4%B8%BA%E4%B8%BB%E2%80%9D%E6%89%80%E4%BA%A7%E7%94%9F%E7%9A%84%E5%BF%83%E7%90%86%E5%AD%A6%E7%8E%B0%E8%B1%A1%EF%BC%8C%E6%8C%87%E5%9C%A8%E8%A1%8C%E4%B8%BA%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E6%9C%80%E5%85%88%E6%8E%A5%E8%A7%A6%E7%9A%84%E4%BA%8B%E7%89%A9%E4%BC%9A%E7%BB%99%E4%BA%BA%E7%95%99%E4%B8%8B%E6%B7%B1%E5%88%BB%E7%9A%84%E6%84%9F%E7%9F%A5%E6%88%96%E8%AE%A4%E7%9F%A5%EF%BC%8C%E5%BD%B1%E5%93%8D%E4%BA%BA%E5%AF%B9%E4%BA%8B%E7%89%A9%E7%9A%84%E6%84%9F%E7%9F%A5%E5%92%8C%E5%88%A4%E6%96%AD%E3%80%82%22%2C%22article%22%3A%7B%7D%2C%22hasReportOverSize%22%3Afalse%2C%22editorReportData%22%3A%5B%7B%22id%22%3A%22122333%22%2C%22key%22%3A%2276%22%2C%22len%22%3A1%7D%5D%2C%22from%22%3A%22%E7%BB%B4%E5%9F%BA%E7%99%BE%E7%A7%91%22%7D&quot;&gt;&lt;span class=&quot;blockquote_other&quot;&gt;维基百科&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;那么我们如何能够把握住这个机会，借助「首因效应」让你在激烈的岗位竞争中占得先机呢？自然就得做好自我介绍的准备，下面我就来分享一些我的经验。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;/01  自我介绍的意义/&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;很多人都会告诉你，自我介绍是你主动展示自己更多信息的机会，所以自我介绍的时候要讲一些简历里没有提到的内容。这个方式没错，但是思路其实不完全对。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;阐述一个残酷的现实，面试你的面试官不一定就是筛选你简历的人，大家平时工作都很忙的，他很可能没有看过你的简历。所以自我介绍环节不但是你主动展示自己的机会，也是让面试官现场评估你简历的“刚需”环节。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以重点来了，你脑子里一定要有这样一个画面：&lt;/span&gt;&lt;span&gt;&lt;strong&gt;我在向一个一心二用的人做自我介绍&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在这个场景下，你的终极目的是：&lt;/span&gt;&lt;strong&gt;&lt;span&gt;提醒他注意到你的亮点，以及为什么适合这个职位&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;知己知彼才能百战不殆，那么对于面试官来说，除了获得了一个熟悉你简历的缓冲期还有什么意义呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;破冰。两个陌生人之间建立良好沟通的方式永远是开放性问题。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;初步判断你的沟通能力。在一个组织协作的中，1对1的对话是常见的场景，能不能把话讲明白决定了你未来与他人一起共事的能力下限。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;初步判断你的逻辑能力。通过你自我介绍阐述的内容顺序、结构，判断你的逻辑能力如何，是有条不紊的、还是混乱的。这决定了你未来做事能力的上限。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;判断你的可塑性。这个大多数时候只是一种感觉，感觉从何而来？除了语言外，你的表情、眼神等肢体语言也能传递出相关的信号。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;搞清楚了自我介绍的意义，那么我们就可以提炼出一些要点了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;/02  六个要点/&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;01&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&lt;strong&gt;时长控制&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一般来说，好的简历最多不超过3页A4纸，所以自我介绍不用准备的太长。因为面试官熟悉完你的简历后基本上就要准备发问了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;大多数人快速阅读一页A4纸的内容大概也就1分钟，所以我建议自我介绍的时长控制在（简历页数*60 + 30）秒左右。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;比如，你的简历是3页，那么就是210秒，3分半；2页是150秒，2分半。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果你是职场新人，那么最好能多准备一段1分钟左右的精简版，以防群面的时候做自我介绍。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;02&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&lt;strong&gt;内容构成&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先大家都知道的一点是，不要重复复述简历上的个人介绍，这就不多说了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另外需要注意的是，不同的工作时长自我介绍的侧重点应该是不同的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;比如你作为一个拥有8年丰富工作经验的人，做自我介绍的时候还在花不少时间突出自己学习能力强、抗压能力强，其实反而会起反面效果（实际这样的人还不少）。而更应该突出自己解决问题的能力和所创造的价值。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于不同资历的人需要阐述的内容组成，我大概划分了三个维度做了一个表供你参考，三个维度分别是：行业经历、业绩体现、可塑性。你在准备内容的时候可以参考这个比例来。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.410958904109589&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oB5bd6W6hI1YM0H3SbSu8C7sic16c1JslJOpa23NQ6oBgCQR9plLChJOWgXcvt58R9dzW4wYCmI2YMmkAD78CRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1022&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;如果你对自己的能力有自信，也可以提高一级来写。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;03&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&lt;strong&gt;精简内容&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;具体的内容信息就像写作文、写报告一样，内容太拖沓，会让人觉得你的逻辑不清晰，概括能力差，没有重点。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;要知道，对逻辑能力的印象其实就是在别人眼里你是不是一个聪明人。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，尽量把不影响信息完整性的那部分文字删掉，比如一些空话（只说自己学习能力强，并不举例），一些修饰性形容词什么的。然后再把剩下的内容按照某个顺序组织起来，并且要把why和how讲清楚。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;04&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&lt;strong&gt;量化相关指标&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;数字自己会说话，能量化的地方尽量去量化，这样可以减少很多冗长的文字描述。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;05&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&lt;strong&gt;注意做好内容承接准备，不要给自己挖坑&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;很多时候，面试官在你的自我介绍中发现了一个亮点，他后续会基于这个亮点展开来向你提问。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，在自我介绍部分你千万不能吹牛，不要把别人的业绩说成你的，否则面试官问你是怎么做到的，具体的细节是什么？你却支支吾吾的，那基本就要请你回家了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;06&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&lt;strong&gt;语气不要过于谦虚&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这点对有一定工作年限的小伙伴非常重要。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;职场新人谦虚一点也可以理解，但是作为老人，如果过度的谦虚，会让人觉得，你要么不够自信，在以后的工作中会出现沟通不畅的问题；要么是自身能力达不到你阐述的和简历上写的，心虚。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;好了，意义和要点都清楚了，那么具体该怎么准备内容呢？你可以试试&lt;/span&gt;&lt;strong&gt;&lt;span&gt;「PME」框架&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;「PME」中的三个字母分别表示热情（Passion）、匹配（Match）、出众（Excellence）。思路是，先展现出你对这个行业、这个岗位的「热情」，然后证明你是「匹配」这个岗位的，最后再亮出自己「出众」的地方说明比其他候选人更棒。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;体现Passion，你可以从下面三个方向入手：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你对该领域有深入的体验或研究&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。比如说你就读的是计算机相关的专业、学习过十几个「某时间」的课程等、看多二十多本XX领域的书。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;你时刻关注该领域动态&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。比如说你经常浏览XX网站、XX社区，会对各个大厂新出的框架花几天时间去折腾一下。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你的兴趣爱好相近&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。比如你平常会写点东西，会把所学到的知识重新整理后发表在自己的博客上。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;体现Match，需要从你过去的经历中做两件事情：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;体现Excellence就是做好一点：&lt;/span&gt;&lt;strong&gt;&lt;span&gt;用数字量化&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。比如，你通过引入了某个技术框架，并做了二次改造，使得某个系统的负载上限提高了3倍，资源消耗降低 了50%。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;体现Excellence是最后一部分内容，也是最重要的内容，因为这里说的内容是在表达你比别人牛逼，所以&lt;/span&gt;&lt;strong&gt;&lt;span&gt;很容易成为面试官接下去发问的点&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，不过你这也是一个你引导面试导向的一个机会，所以要把握好。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最后来举个例子，感受一下。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;212&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;我叫 XX，就读于 XX 大学 XX 专业。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;我每周会写博客，会将当周从书本或者「某时间」的课程上学到的知识进行整理，并用自己的语言写出来分享给所有人，对软件开发行业充满兴趣。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;我了解到贵公司有对分布式系统方面的要求，恰好我在上一家公司的系统就是分布式的。我在其中工作了3年，主导过多项核心技术的落地。比如在XX年，我引入了XXX框架并做了二次改造，使得某个系统的负载上限提高了3倍，资源消耗降低 了50%。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;所以对于胜任当前的岗位很有信心。&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;好了，以后可千万不能再做下面这样的自我介绍了哦。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;98&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;我叫 XX，就读于 XX 大学 XX 专业，之前是 XX 公司的高级软件工程师。我在该公司负责的工作是A系统、B系统、C系统、……的开发。现在应聘贵公司高级软件工程师岗位，希望能得到这个宝贵的机会，非常感谢！&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;好了，总结一下。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这篇呢，Z哥和你聊的是面试的时候自我介绍这件事。虽然这是一件很小的事，但是由于「&lt;/span&gt;&lt;strong&gt;&lt;span&gt;首因效应&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;」的存在，它对你能否拿到offer起到的作用可不小。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;自我介绍的意义其实除了展现你自己之外，大多数时候也是面试官熟悉你简历的时候，所以面对这样一个一心二用的人，你要注意以下六个要点：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;时长控制。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;内容构成。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;精简内容。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;量化相关指标。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;注意做好内容承接准备，不要给自己挖坑&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;语气不好过于谦虚。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果你还是无从下手，可以使用「PME」结构来试试。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;就这么多，希望对你有所帮助。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;推荐阅读：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;原创不易，如果你觉得这篇文章还不错，就「&lt;/span&gt;&lt;span&gt;&lt;strong&gt;在看&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;」或者「&lt;/span&gt;&lt;span&gt;&lt;strong&gt;分享&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;」一下吧。鼓励我的创作 ：）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.4428822495606327&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/oB5bd6W6hI1Xrkr3iaFRP5fErfmjHqlBw160icnia8yicWBlicnPEfqGE80alzGl9FLj6FxyuibIuliceoH9zicibj95loQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1138&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果你有关于软件架构、分布式系统、产品、运营的困惑&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以试试点击「&lt;strong&gt;阅读原文&lt;/strong&gt;」&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>67491edb68ddb863e71e837f919f8143</guid>
<title>[推荐] 哦，原来是这么回事：Golang 中的一些常识</title>
<link>https://toutiao.io/k/lxcx8vb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回想起来使用Go已三年有余，有很多踩过的坑。Go是门活力四射的语言，语法简单但表述能力强大且足够高效，但是也有很多细微的点，这些点就是一些基本细节实现，如果能注意这些细节，我相信我们能够对Go的理解能更深一些，写的bug会少一些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为一名初学者我们时常写对一些固定的写法，不知道为什么要这么写；我们时常写了一些bug，不知道为什么bug；我们时常知道可以这么写，但是不知道那样写是否可以；有时候我们很懒，懒得去测试是否可以，有时候我们很勤快，测试了并且知道答案，但是不求甚解；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再深一点？很多时候我们不求甚解，这天杀的产品经理又在催好像是个不错的借口。慢慢地又觉得自己理解不够深刻，所以总是闲暇的时候思考这些问题。我相信在二进制的世界里，nothing is magic, 一定是有Why的，因为这是我们所创造的世界 ( AI算法除外 🤭) 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;希望这篇文章能够帮到你，哪怕只是一点点。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Common Sense in Go&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. &lt;code&gt;interface{}&lt;/code&gt; 后面是有&lt;code&gt;{}&lt;/code&gt;的&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;现象&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;go中其他的类型都是没有&lt;code&gt;{}&lt;/code&gt;的， 只有&lt;code&gt;interface{}&lt;/code&gt;有。&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;理解&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;go中其他的类型都是没有&lt;code&gt;{}&lt;/code&gt; 的 比如 &lt;code&gt;map[int]int&lt;/code&gt;, 但是&lt;code&gt;interface{}&lt;/code&gt;都是带&lt;code&gt;{}&lt;/code&gt;的，据说是为了让你瞅瞅里边什么也没有。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 函数参数是值传递的(Passed by value)&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;现象&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;函数的参数是值传递，且在调用的时立即执行值拷贝的。&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;理解&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，函数调用是值传递的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以无论传递什么参数都会被copy到函数的参数变量的内存地址中，堆或者栈上，具体是堆还是栈上涉及到逃逸问题，这里不做过多分析。但是毫无疑问的是，在调用时立即对变量进行了Copy，以下例子中通过打印变量地址佐证。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; i &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;main: %p\n&quot;&lt;/span&gt;, &amp;amp;i)&lt;br/&gt;    foo(i)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;foo&lt;/span&gt;&lt;span&gt;(i &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;foo : %p\n&quot;&lt;/span&gt;, &amp;amp;i)&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 输出的变量地址不一样&lt;/span&gt;&lt;br/&gt;main: &lt;span&gt;0xc0000a0008&lt;/span&gt;&lt;br/&gt;foo : &lt;span&gt;0xc0000a0018&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以对于复杂结构我们应该尽量的传递指针减少copy时的开销。对于这里有看到不同的观点，主要是考虑到空指针问题，但是我仍然觉得应该使用指针。理由主要有以下几点&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;值传递会Copy对象，对于小内容对象，性能相差不大，但是在大结构下存在明显的性能损耗&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;return 的时候可以直接 &lt;code&gt;return nil, err&lt;/code&gt;，代码精简更加优雅&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;nil pointer panic 应该通过error handling来解决，不然即使没有发生panic，也会执行错误的逻辑，引入更多的问题。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是指针传递的同时也带来变量逃逸，和GC压力，也是一把双刃剑，好在大部分情况下不需要特别的对GC进行调优。所以，在make it simple的理念下，在需要时再针对性调优是个不错的选择。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以什么时候我们应该传递值，什么时候应该传递指针，这主要取决于copy开销和是否需要在函数内部对变量值进行更改。我们可以用一个简单的例子测试下两者的性能差距：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;passedByValue&lt;/span&gt;&lt;span&gt;(foo Value)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    foo.C = &lt;span&gt;&quot;1&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;passedByPointer&lt;/span&gt;&lt;span&gt;(bar *Value)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    bar.C = &lt;span&gt;&quot;1&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 值传递&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Benchmark_PassedByValue&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; val Value&lt;br/&gt;    str := bytes.Buffer{}&lt;br/&gt;    &lt;span&gt;// 这里为了构建一个大值进行传递，小值因为copy代价太小性能差距不明显。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; i:=&lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10000000&lt;/span&gt;; i ++ {&lt;br/&gt;        str.Write([]&lt;span&gt;byte&lt;/span&gt;(&lt;span&gt;&quot;=====&quot;&lt;/span&gt;))&lt;br/&gt;    }&lt;br/&gt;    val.C = str.String()&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;        passedByValue(val)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 指针传递&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Benchmark_PassedByPointer&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; val = &lt;span&gt;new&lt;/span&gt;(Value)&lt;br/&gt;    str := bytes.Buffer{}&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; i:=&lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10000000&lt;/span&gt;; i ++ {&lt;br/&gt;        str.Write([]&lt;span&gt;byte&lt;/span&gt;(&lt;span&gt;&quot;=====&quot;&lt;/span&gt;))&lt;br/&gt;    }&lt;br/&gt;    val.C = str.String()&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;        passedByPointer(val)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Benchmark结果差距也很明显，但是一般值的copy代价都比较小，差距不明显。&lt;/span&gt;&lt;br/&gt;goos: darwin&lt;br/&gt;goarch: amd64&lt;br/&gt;pkg: demo/&lt;span&gt;go&lt;/span&gt;&lt;br/&gt;Benchmark_PassedByValue&lt;span&gt;-4&lt;/span&gt;       &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;0.676&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_PassedByPointer&lt;span&gt;-4&lt;/span&gt;     &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;0.383&lt;/span&gt; ns/op&lt;br/&gt;PASS&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般来说，基本类型我们都应该传值，自定义类型中一般内容不可控，所以养成良好的习惯很关键。特别注意的是slice、map、ctx是引用值类型，所以copy时并没有copy其中数据，所以一般也进行值传递，除非你要对其中更改其中的元素。但如果你需要更改其中的内容，还是建议更改完尽量返回回来一个新的，像内置的append函数一样，通过返回新的地址来实现。这样会更加清晰一些，写代码时自己尽量不要和自己过不去。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个栗子，以下代码可能是一个bug：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; ids []&lt;span&gt;int&lt;/span&gt;&lt;br/&gt;    appendSlice(ids)&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;main&quot;&lt;/span&gt;, &lt;span&gt;len&lt;/span&gt;(ids))&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;appendSlice&lt;/span&gt;&lt;span&gt;(ids []&lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;4&lt;/span&gt;; i++ {&lt;br/&gt;        ids = &lt;span&gt;append&lt;/span&gt;(ids, i)&lt;br/&gt;    }&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;appendSlice&quot;&lt;/span&gt;, &lt;span&gt;len&lt;/span&gt;(ids))&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 输出， 因为appendSlice中的ids并不是main中的ids.&lt;/span&gt;&lt;br/&gt;appendSlice &lt;span&gt;4&lt;/span&gt;&lt;br/&gt;main &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其次，Copy发生在函数调用的时候。比如利用这个原理就可以使用以下代码打印函数耗时。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;do&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 因为 defer 语句执行的时候已经将函数参数转储，只是函数体执行时机有所调整&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(t time.Time)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;       fmt.Println(&lt;span&gt;&quot;do Cost: &quot;&lt;/span&gt;time.Slice(t).Second())&lt;br/&gt;    }(time.Now())&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;// balabalabala&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. &lt;code&gt;for _, i := range ss&lt;/code&gt;， ss 中的元素是 &lt;strong&gt;copy&lt;/strong&gt; 到 变量&lt;code&gt;i&lt;/code&gt; 的&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;现象&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;for range&lt;/code&gt; 的时候 slice 中的元素是copy给 &lt;code&gt;变量i&lt;/code&gt;的，并且下次&lt;code&gt;for循环&lt;/code&gt;，&lt;code&gt;变量i&lt;/code&gt;会被直接覆盖。并不是把 n号元素的地址给了&lt;code&gt;i&lt;/code&gt;，&lt;code&gt;i&lt;/code&gt; 是第 &lt;code&gt;n&lt;/code&gt; 号元素的 copy。&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;理解&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;值&lt;strong&gt;Copy&lt;/strong&gt;会产生两个变量，i 是个临时变量，下一次for循环就会被覆写，而且因为是临时值，所以以下代码因为更改也不生效，也是非常常见的bug。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; User &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;    Uid &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    users := []User{&lt;br/&gt;        {Uid: &lt;span&gt;1&lt;/span&gt;}, {Uid: &lt;span&gt;2&lt;/span&gt;},&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; idx, i := &lt;span&gt;range&lt;/span&gt; users {&lt;br/&gt;        i.Uid = &lt;span&gt;2&lt;/span&gt;&lt;br/&gt;        fmt.Printf(&lt;span&gt;&quot;i=%p, user_%d=%p\n&quot;&lt;/span&gt;, &amp;amp;i, idx, &amp;amp;users[idx])&lt;br/&gt;    }&lt;br/&gt;    fmt.Println(users[&lt;span&gt;0&lt;/span&gt;].Uid)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 输出&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// i 的地址不变，并且不是元素的地址&lt;/span&gt;&lt;br/&gt;i=&lt;span&gt;0xc00008c008&lt;/span&gt;, user_0=&lt;span&gt;0xc00008c010&lt;/span&gt;&lt;br/&gt;i=&lt;span&gt;0xc00008c008&lt;/span&gt;, user_1=&lt;span&gt;0xc00008c018&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;// 原数组中的user id并没有发生改变&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要更改生效也很简单，主要有两种方案，一种是使用切片指针 &lt;code&gt;[]*User&lt;/code&gt;，这样对于&lt;code&gt;i&lt;/code&gt;的修改会被自动寻址到数字元素上。另一种是使用下标 主动寻址如 &lt;code&gt;users[idx].Uid = 2&lt;/code&gt; 。至于[]T还是[]*T 的问题我们接下来再讨论。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题看似简单，如果将其使用go关键字并发将会发生巨大威力，造成血淋淋的事故。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实用go的公司经常听到这样的事故：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;某公司发运营push全部发给了&lt;code&gt;同一个&lt;/code&gt;uid&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;某研发发运营消息发短信发给了&lt;code&gt;同一个&lt;/code&gt;uid (如果通道商不限制，我相信用户哭了，哄不好的那种)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;批量发优惠券，给&lt;code&gt;同一个&lt;/code&gt;uid发了几百张&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;....&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;闭包问题一点都不新鲜，就是由于在go func里边使用for了循环的变量i了，然后因为函数体并没在go的时候立即执行需要申请资源挂载然后由M进行运行需要一些时间，所以一般for循环执行一段时间之后go func才会执行，这时候 内部函数取到的值就得听天命了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经典bug复现&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; _, i := &lt;span&gt;range&lt;/span&gt; []&lt;span&gt;int&lt;/span&gt;{&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;} {&lt;br/&gt;        &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;println&lt;/span&gt;(i)&lt;br/&gt;        }()&lt;br/&gt;    }&lt;br/&gt;    time.Sleep(&lt;span&gt;1&lt;/span&gt;* time.Millisecond)&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 只会打印 3， 因为等到func执行的时候 i已经变成3了&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 所以把 i 当做 匿名函数的参数传进去或者在for中重新定义一个变量是个不错的做法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，使用匿名函数的时候go func的时候要时刻注意循环变量的Scope, 该传参传参，该重新定义重新定义。好在 Goland 最新版本已经会提示i存在Scope问题了。但是好像没几个人会注意IDE警告，所以，习惯很重要，不要写出IDE警告的代码也是一个不错的编程理念。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. []T 还是 []*T&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;现象&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;一般来说[]T 会比较高效一些，但是如果T比较大，在For循环时存在Copy开销，个人觉得[]*T也是可以的。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5. &lt;code&gt;[]interface{}&lt;/code&gt;并不能接收&lt;code&gt;[]T&lt;/code&gt;类型&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;现象&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;很多时候我们都以为interface可以传递任意类型，凡事总有例外，他就不能接收 &lt;code&gt;[]T&lt;/code&gt; 类型, 如果你需要进行赋值，那你要将T转成interface{}&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;理解&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为一个&lt;code&gt;[]&lt;/code&gt;interface{}的空间是一定的，但是 &lt;code&gt;[]T&lt;/code&gt; 不是，因为占用空间不一致，编译器觉得有些代价，并没有进行转换.&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6. Send on closed chan 会Panic，但是 Receive from closed chan 不会&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;现象&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;往已经关闭的channel 再send数据会触发runtime panic，但是receive从已经关闭的channel中消费不会触发.&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;理解&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多人有误区，认为chan关闭了就不能再操作了，但是send进chan的数据总归要消费完的，不然就丢了，你品。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7. Goroutine 之间不能 Recover painc&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;现象&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;goroutine没有父子关系（创建应该不算父子吧），不能在一个go中 recover 另一个 go 的 panic&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;理解&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GPM模型在go的调度时没有上下级关系, 也没有跨goroutine的异常捕获机制。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8. error 是一个实现了Error()string 方法的任意类型.&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;现象&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;error 被定义为 interface{ Error()string }，只要实现该方法的类型，其值都可以认为是error&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;9. 是否实现某个interface的的判断是区别对待 &lt;code&gt;*T&lt;/code&gt; 和 &lt;code&gt;T&lt;/code&gt; 的&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;现象&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;一个接口实现必须实现接口定义的全部方法，使用 指针类型的receiver 和 值类型的 receiver 是两个不同的实现。&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;解释&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;*张三&lt;/code&gt;不吃香菜，不等于&lt;code&gt;张三&lt;/code&gt;不吃香菜。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; User &lt;span&gt;interface&lt;/span&gt; {&lt;br/&gt;    Eat(food &lt;span&gt;interface&lt;/span&gt;{}) (&lt;span&gt;bool&lt;/span&gt;, error)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; ZhangSan &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;    Name &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// *ZhangSan 实现了 User 接口&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 但是 ZhangSan 没有实现&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(*ZhangSan)&lt;/span&gt; &lt;span&gt;Eat&lt;/span&gt;&lt;span&gt;(food &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;(&lt;span&gt;bool&lt;/span&gt;, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; food == &lt;span&gt;&quot;香菜&quot;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;userEat&lt;/span&gt;&lt;span&gt;(u User,food &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;span&gt;bool&lt;/span&gt;, error)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; u.Eat(food)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    someone := ZhangSan{Name: &lt;span&gt;&quot;张三&quot;&lt;/span&gt;}&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;// 这里 someone 是不能传递给 userEat 的&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 因为 ZhangSan 这个结构没有实现 User 接口, 只能用 &amp;amp;ZhangSan进行传递。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// userEat(someone, &quot;花生&quot;)&lt;/span&gt;&lt;br/&gt;    userEat(&amp;amp;someone, &lt;span&gt;&quot;花生&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，实现接口时receiver类型要统一。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;10. Reveiver 在函数调用时其实是作为函数第一参数传递给函数的&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;现象&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;receiver 是可以为 nil 的&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;解释&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你细心看过panic的日志就会发现，打印日志的时候 receiver其实是作为函数第一参数传递的。所以，你可以在method中对receiver进行空值判断，来防止panic的发生。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; someone *ZhangSan&lt;br/&gt;    _, _ = someone.Eat(&lt;span&gt;&quot;花生&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 如果在Eat 中没有对 receiver进行空值判断也可能引发 空指针异常&lt;/span&gt;&lt;br/&gt;goroutine &lt;span&gt;1&lt;/span&gt; [running]:&lt;br/&gt;main.(*ZhangSan).Eat(&lt;span&gt;0x0&lt;/span&gt;, &lt;span&gt;0x10aafc0&lt;/span&gt;, &lt;span&gt;0x10e9680&lt;/span&gt;, &lt;span&gt;0x0&lt;/span&gt;, &lt;span&gt;0x10a9ec0&lt;/span&gt;, &lt;span&gt;0xc0000200b8&lt;/span&gt;)&lt;br/&gt;        /Users/haoliu/demo/&lt;span&gt;go&lt;/span&gt;/main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;16&lt;/span&gt; +&lt;span&gt;0x26&lt;/span&gt;&lt;br/&gt;main.main()&lt;br/&gt;        /Users/haoliu/demo/&lt;span&gt;go&lt;/span&gt;/main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;30&lt;/span&gt; +&lt;span&gt;0x42&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就Go在日常使用过程中的基本点进行了一下总结，是golang日常使用过程中经常碰到的点。由于水平有限，如果存在某些表述不清楚的地方，可以一起讨论下。&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;99&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;作者：保护我方李元芳，授权发布&lt;/p&gt;&lt;p&gt;链接：https://juejin.im/post/6881267557346344974&lt;/p&gt;&lt;p&gt;来源：掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1d02de76a2e7a5045cff32e6675b6cc3</guid>
<title>[推荐] Redis 集群搭建采坑总结</title>
<link>https://toutiao.io/k/b60qswo</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;    先澄清一下，整个过程问题都不是我解决的，我在里面就是起了个打酱油的角色。因为实际上我负责这个项目，整个过程也比较清楚。之前也跟具体负责的同事说过，等过段时间带他做做项目复盘。结果一直忙，之前做的事情都快忘了也没带他做复盘。所以趁着还记得，总结一下这个问题，也算一起做个复盘总结了。&lt;/p&gt;&lt;p&gt;    本周一的时候，我们测试环境遇到一个问题：启动一个服务就会导致后端调用耗时增加。当时咨询了对这个问题之前有了解的同事得到的答复是因为一笔请求发到两套测试环境(一个请求需要在两套环境下运行结果做对比)，因为这两套环境共用同一套redis集群。收到第二个相同请求的时候，会将这笔请求标记为重复请求。下游接收到这笔请求是重复的，需要重新查询数据库验证请求是否重复，不是的话做一个纠正。所以这时候会造成请求延迟升高。&lt;/p&gt;&lt;p&gt;    负责解决这个问题的同事小A就问我：那是不是再搭建一套将两套Redis集群分开就解决了。我说不一定，还有解释不通的地方：一个环境服务不启动不写redis，另一个环境服务启动写redis的时候也会遇到这个问题。&lt;/p&gt;&lt;p&gt;    于是小A找了这个服务相关负责的同事了解业务。因为测试环境的总责任人是我，所以了解业务的时候，小A也把我拉了一起了解。通过同事的讲述了解到一个环境中服务要写两个机房。如果两个机房的Redis是同一套也会被标记成重复请求。&lt;/p&gt;&lt;p&gt;    至此，解决环境问题的方法有了答案：每套环境要搭建两套Redis集群，两个环境4套Redis集群来解决问题。&lt;/p&gt;&lt;p&gt;    往往，一个答案只是一系列问题的开始。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;时间线&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;    我们的搭建方案是直接在使用Redis的服务上搭建连接它的两套Redis集群，只改下端口，多跑两个进程。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;问题1：服务器退出登录Redis服务会停止&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;     小A告诉我遇到问题的现象：按照网上经典的安装启动教程，启动成功了。但是当干会儿别的，ssh自动退出登录之后再看Redis服务就停止了。&lt;/p&gt;&lt;p&gt;     我听到这里首先想到的是这个现象基本可以断定是以非daemon进程在运行，于是我上网上找了以deamon方式运行的命令发给小A：&lt;/p&gt;&lt;p&gt;redis-server ./redis.conf --daemonize yes&lt;/p&gt;&lt;p&gt;     小A看了解决方法补充到那一定也可以在配置文件里直接配置daemon方式运行。我表示赞同，他也是这么做的。我当时没有点破，相信刚毕业的他不久也自己会发现配置文件和显示命令实际上是一回事。只是一个是永久生效，一个是每次运行时生效。而直接用这条命令只是为了说明本质问题。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;问题2：服务连接Redis报错Not Auth&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;     小A又向我反馈报了一个错，说他在网上查的是Redis版本问题，估计需要重新搭建Redis。我过去看了一下：Redis集群是3.X的版本，jedis客户端用的是2.9的版本。没有听说过Redis3.X的版本有不向下兼容的问题，同时因为这个Redis是从负责Redis的团队要过来的安装包，应该和现在跑着的是一个版本。如果怀疑Redis的团队发的安装包与之前不一样的话，我也确信之前肯定版本不会低于3.0，因为Redis是从3.0之后才支持集群的。所以我判定不是Redis版本问题。让他再查查。实际上我的意思是让他换关键词来查。比如可以按照报错的提示原因来查，也可以按照异常来查，不同的关键词搜索可以获得不同的信息。&lt;/p&gt;&lt;p&gt;    然后我看了报的错：其他的没细看，只见赫然写着：Not Auth。我就问：Redis服务有没有设置密码。他说没有，还演示了一下，我在旁边确认了没有。就查看客户端配置有没有配置密码。果然客户端里有密码配置。这就与服务端不匹配了。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;问题3：报错cluster support disabled&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;    小A将客户端密码去掉重新打包部署之后，Not Auth的错不报了，但是其实报了两个错，还有一个错没解决：就是提示cluster support disabled。&lt;/p&gt;&lt;p&gt;    我说集群方式启动应该就是一个配置，应该有个cluster-enabled什么的从no改成yes。我还出了个馊主意(注意这里用到的馊主意，想想《红楼梦》里每句话都是剧透，这里也不例外)：我说理论上一台集群也可以算一个集群。应该可以直接改个配置就以集群方式启动了。&lt;/p&gt;&lt;p&gt;    小A按照我说的思路用直接改配置为集群的方法，客户端再启动果然没有报错了。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;问题4：请求延迟没有好转，Redis服务端没有写入成功数据&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;    客户端没有报错之后，小A重试原问题现场，请求延迟没有好转。另外，还发现Redis服务端没有写入成功的数据。&lt;/p&gt;&lt;p&gt;    这次我和小A首先一起排查配置有没有配置对。发现配置没有问题，我就跟小A说：让他多打日志。客户端连接的地方打一些，读写数据的地方打一些。&lt;/p&gt;&lt;p&gt;    通过这个方法，小A定位到客户端连接的连接池为空。最终自己排查到是一台机器的集群的哈希槽在一台机器情况下哈希槽分配有问题，数据写入失败。最后每个集群多起了2个Redis进程做成3个节点的集群解决了问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;可优化的排查思路分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;    在问题4排查的时候，我和小A一起检查了配置是否正确来确认Redis请求是请求到了正确的服务端。其实，有个更为直接和说明问题的方法：抓包。可以tcpdump端口查请求流量是不是正确从客户端发出来了，被转发到了哪里。&lt;/p&gt;&lt;p&gt;    在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485553&amp;amp;idx=1&amp;amp;sn=945e46d81bef62f35ac447895d99cdd2&amp;amp;chksm=fafde2dfcd8a6bc905cd0e9e50a9e51247a6d53f614a948b89209341a55877893a3fcba295dd&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《技术方案设计的方法》&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《技术方案设计的方法》&lt;/a&gt;里我也提到，很多时候搜索不到自己想要的信息很可能是关键词的问题。排查问题的时候也可以试着换换关键词来搜索。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;根本原因分析&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;    这里面有个问题没有彻底搞清楚：为什么一台机器的Redis集群会有问题。&lt;/p&gt;&lt;p&gt;    问了小A，当时异常时getSlots方法时返回了空。就是说问题实际上可能是slot没有被分配。&lt;span/&gt;&lt;/p&gt;&lt;p&gt;    我就问他单台机器的时候有没有在redis-cli客户端上运行cluster info命令。他给我发了下面的运行情况截图。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6090750436300174&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl89y3phMeqKp0zqjUPXAouo4xPAUDrcwSPreZt9xV0gMHgeZVXh3dwkcVXbOcbJXOUsbuShHoXXCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;573&quot;/&gt;&lt;/p&gt;&lt;p&gt;    这张截图验证了我的猜想，slot没有被分配，集群状态为失败，所以连接不上。&lt;/p&gt;&lt;p&gt;    那需要连接上的条件并非是集群里有几个节点，而是slots分配，集群状态成功。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.2623688155922039&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl89y3phMeqKp0zqjUPXAouoK0n5ZK12F4Ge6qV0G5f0trZBftHpC3x5ekDMoApRstA6ejgyxE0xKw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1334&quot;/&gt;&lt;/p&gt;&lt;p&gt;    为了验证这个猜想，我搭建了一个一个节点的集群，手动cluster addslots了0到16383个slot。集群判断16384个slot都分配完毕，自动状态改成OK。&lt;/p&gt;&lt;p&gt;    &lt;/p&gt;&lt;p&gt;    这整个过程说明了：网上都是说Redis集群必须是3个节点以上的最好是单数个节点来启动。单数个节点是为了投票的时候可以三局两胜得出结论：一半以上的节点挂掉整个集群不可用。而对于Redis根本上判断集群是否可用是根据slot有没有完整的16384个slot在提供服务决定的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;    我觉得在整个过程中小A的表现我觉得很OK的。有4点：&lt;/p&gt;&lt;p&gt;1&amp;gt;主观能动性&lt;/p&gt;&lt;p&gt;    在过程中，他自己通过网上搜素找资源，自己解决了很多问题。整个问题处理过程中其实没花费我多少时间，花时间的事情他都自己解决了。&lt;/p&gt;&lt;p&gt;2&amp;gt;合理的利用了各种资源&lt;/p&gt;&lt;p&gt;    对于业务不理解，他找了理解业务的同事。技术问题搞不定他找了我。因为我对项目负责，所以找我是很合情合理的。同时，我是很希望他遇到这种事情来找我的。因为他找我证明他是信任我的，相信我能一定程度帮到他。第二，他找我是把我当成一种资源。作为资源我被需要，是有价值的。被需要让人觉得很踏实。&lt;/p&gt;&lt;p&gt;    我在有搞不定的事情的时候也向上寻求帮助。比如之前需要其他组协作的时候人家有排期遇到困难，领导出面帮忙搞定了。还有申请资源由于暂时性资源紧张，申请不到，也是更上级出面帮忙搞定了。一个称职的上级一定可以成为一种资源，也愿意让自己成为资源。但是成为资源的形式不同，有的可能提供的是战略，有的提供的是精神支持等。&lt;/p&gt;&lt;p&gt;3&amp;gt;事后总结&lt;/p&gt;&lt;p&gt;    问题解决后，小A有自己写wiki总结事情经过，避免后人采坑，同时自身也有总结收获。&lt;/p&gt;&lt;p&gt;4&amp;gt;及时沟通&lt;/p&gt;&lt;p&gt;    中间过程中，他每个关键步骤都有及时跟我沟通。因为解决完后他反馈给我：他自己觉得对于redis原理还没有理解，所以不清楚为什么3个节点就OK的原因。我因为了解他的想法，所以才自己又实验给出一个根本原因分析。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;    关于Redis，就一句话：那些很多人说只有面试的时候才能用到的东西，我总是发现实际工作中很有用。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;相关阅读&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7e3ffd47bd2dad2394c63ba25380d314</guid>
<title>[推荐] 理解完这些基本上能解决面试中 MySQL 的事务问题</title>
<link>https://toutiao.io/k/szxq5t8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;h1 cid=&quot;n0&quot; mdtype=&quot;heading&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;欢迎关注公众号【&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;Ccww技术博客&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;】，原创技术文章第一时间推出&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/h1&gt;&lt;hr/&gt;&lt;blockquote cid=&quot;n4&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n1135&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;越努力，越幸运，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1136&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;本文已收藏在GitHub中JavaCommunity, 里面有面试分享、源码分析系列文章，欢迎收藏，点赞&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1139&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;https://github.com/Ccww-lx/JavaCommunity&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 cid=&quot;n1134&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n1126&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;在面试中，基本上都会问到关于数据库的事务问题，如果啥都不会或者只回答到表面的上知识点的话，那面试基本上是没戏了，为了能顺利通过面试，那MySql的事务问题就需要了解，所以就根据网上的资料总结一版Mysql事务的知识点，巩固一下事务的知识。&lt;/span&gt;&lt;/p&gt;&lt;h2 cid=&quot;n1128&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;事务&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n1130&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;事务是指逻辑上的一组操作，要么都执行，要么都不执行,&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n5&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;事务的特性（ACID）&lt;/span&gt;&lt;/h3&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n6&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n8&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;原子性(&lt;code&gt;Atomicity&lt;/code&gt;)：事务是不可分割的工作单元，要么都成功，要么都失败， 如果事务中一个sql语句执行失败，则已执行的语句也必须回滚，数据库退回到事务前的状态。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n10&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;一致性(&lt;code&gt;Consistency&lt;/code&gt;)：事务不能破坏数据的完整性和业务的一致性 。例如在银行转账时，不管事务成功还是失败，双方钱的总额不变&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n12&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;隔离性(&lt;code&gt;Isolation&lt;/code&gt;)：一个事务所操作的数据在提交之前，对其他事务的可见性设定（一般是不可见）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n14&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;持久性(&lt;code&gt;Durability&lt;/code&gt;)：事务提交之后，所做的修改就会永久保存，不会因为系统故障导致数据丢失&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n15&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;严格来说，只有同时满足数据库的事务ACID特性才能算一个完整的事务，但现实中实现能够真正满足的完整的事务特性少之又少，但是在实现中也必须尽量达到事务要求的特性。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n592&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;那么事务ACID特性具体怎么实现的呢？我们来分析看看，首先先看看事务的特性。&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;h2 cid=&quot;n418&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;原子性(&lt;/span&gt;&lt;code&gt;&lt;span&gt;Atomicity&lt;/span&gt;&lt;/code&gt;&lt;span&gt;)&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n419&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;首先我们来看看事务的原子性特性，看看其如何实现的？&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n581&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;原子性(&lt;code&gt;Atomicity&lt;/code&gt;)：事务是不可分割的工作单元，要么都成功，要么都失败， 如果事务中一个sql语句执行失败，则已执行的语句也必须回滚，数据库退回到事务前的状态&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n428&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;原子性(&lt;code&gt;Atomicity&lt;/code&gt;)的实现离不开 MySQL的事务日志 &lt;code&gt;undo log&lt;/code&gt;日志类型，当事务需要回滚的时候需要将数据库状态回滚到事务开始前，即需要撤销所有已经成功执行的sql语句。那么&lt;code&gt;undo log&lt;/code&gt;起了关键性作用：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n432&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;当事务对数据库进行修改时，InnoDB会生成对应的&lt;code&gt;undo log&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;；如果事务执行失败或调用了&lt;code&gt;rollback&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;，导致事务需要回滚，便可以利用&lt;code&gt;undo log&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;中的信息将数据回滚到修改之前的样子。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n420&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;那么&lt;code&gt;undo log&lt;/code&gt;是什么呢？每个数据变更操作是怎么被记录下来的呢？&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n434&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;undo log（ 回滚日志 ）&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n421&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;code&gt;undo log&lt;/code&gt; (回滚日志)：是采用&lt;strong&gt;段(&lt;code&gt;segment&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;)&lt;/strong&gt;的方式来记录的，每个&lt;code&gt;undo&lt;/code&gt;操作在记录的时候占用一个&lt;strong&gt;&lt;code&gt;undo log segment&lt;/code&gt;&lt;/strong&gt;。为什么会在数据更改操作的时候，记录了相对应的&lt;code&gt;undo log&lt;/code&gt;呢？其目的在于：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n523&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;其中，&lt;code&gt;undo log&lt;/code&gt;分为：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n455&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;数据更改的&lt;code&gt;undo log&lt;/code&gt;怎么记录的呢？&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n462&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt; 因为&lt;code&gt;insert&lt;/code&gt;操作的记录，只对事务本身可见，对其他事务不可见。故该&lt;code&gt;undo log&lt;/code&gt;可以在事务提交后直接删除，不需要进行&lt;code&gt;purge&lt;/code&gt;操作，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n536&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt; 而&lt;code&gt;Delete&lt;/code&gt;操作在事务中实际上并不是真正的删除掉数据行，而是一种Delete Mark操作，在记录上标识&lt;code&gt;Delete_Bit&lt;/code&gt;，而不删除记录。是一种&quot;假删除&quot;,只是做了个标记，真正的删除工作需要后台&lt;code&gt;purge&lt;/code&gt;线程去完成。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n546&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;code&gt;update&lt;/code&gt;分为两种情况：&lt;code&gt;update&lt;/code&gt;的列是否是主键列。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n532&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;与&lt;code&gt;insert undo log&lt;/code&gt;不同的，&lt;code&gt;update undo log&lt;/code&gt;日志，当事务提交的时候，innodb不会立即删除&lt;code&gt;undo log&lt;/code&gt;， 会将该事务对应的&lt;code&gt;undo log&lt;/code&gt;放入到删除列表中，未来通过&lt;code&gt;purge&lt;/code&gt;线程来删除。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n542&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;因为后续还可能会用到&lt;code&gt;undo log&lt;/code&gt;，如隔离级别为&lt;code&gt;repeatable read&lt;/code&gt;时，事务读取的都是开启事务时的最新提交行版本，只要该事务不结束，该行版本就不能删除（即&lt;code&gt;undo log&lt;/code&gt;不能删除）,且&lt;code&gt;undo log&lt;/code&gt;分配的页可重用减少存储空间和提升性能。 &lt;/span&gt;&lt;/p&gt;&lt;blockquote cid=&quot;n488&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n563&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Note：purge线程两个主要作用是：清理undo页和清除page里面带有Delete_Bit标识的数据行。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p cid=&quot;n588&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n590&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;接着我们来看看事务的隔离性，看看事务有哪些隔离级别，而且事务并发中会产生什么问题。&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;h2 cid=&quot;n570&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;隔离性(&lt;/span&gt;&lt;code&gt;&lt;span&gt;Isolation&lt;/span&gt;&lt;/code&gt;&lt;span&gt;)&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n584&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;隔离性(&lt;code&gt;Isolation&lt;/code&gt;)，是指事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰 ，一个事务所操作的数据在提交之前，对其他事务的可见性设定(一般是不可见)。&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n624&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;事务隔离级别&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n896&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;而且数据库为了在并发下有效保证读取数据正确性，数据库提供了&lt;span&gt;四种事务隔离级别&lt;/span&gt;&amp;gt;，分别为：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n614&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n616&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;读未提交(&lt;strong&gt;脏读&lt;/strong&gt;)：允许读取尚未提交的数据，允许脏读&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n618&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;读已提交（ &lt;strong&gt;不可重复读&lt;/strong&gt; ）：允许读取事务已经提交的数据&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n620&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;可重复读（ &lt;strong&gt;幻读&lt;/strong&gt; ）：在同一个事务内的查询结果都是和事务开始时刻查询一致的（ InnoDB默认级别 ）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n622&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;串行化：所有事务逐个依次执行， 每次读都需要获得表级共享锁，读写相互都会阻塞&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n572&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;其中，&lt;span&gt;不同的隔离级别可能会存在在不同并发问题&lt;/span&gt;，主要并发问题包括：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n780&quot; mdtype=&quot;list&quot; data-mark=&quot;+&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n782&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;数据丢失：&lt;/strong&gt; 两个或多个事务操作相同数据，基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题——最后的更新覆盖了其他事务所做的更新&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n786&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;脏读：&lt;/strong&gt;读到了其他事务还未提交的数据，事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n787&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.38437978560490044&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDrgyKx4nzfu3dK9SD5jxqxFmmXvxnaQq5p8dQSTj5K8EMicF2c6WyBkFbQfOSzcbq6jk8YJGFcOh46g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;653&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n789&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;不可重复读（重点是修改）：&lt;/strong&gt;在一个事务中，先后进行两次相同的读取，由于另一个事务修改了数据，导致前后两次结果的不一致，事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n790&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.35222052067381315&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDrgyKx4nzfu3dK9SD5jxqxFm6tdicD2HjhvRXibhXCtTn6rH5cLPuicuexv7oH3wYibnBrovbvo4JHxvkw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;653&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n792&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;幻读（重点是新增、删除）：&lt;/strong&gt; 在一个事务中，先后进行两次相同的读取（一般是范围查询），由于另一个事务新增或删除了数据，导致前后两次结果不一致&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n793&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3592085235920852&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDrgyKx4nzfu3dK9SD5jxqxFm4d2C0AiaquwswcPdYyLxc9hTiamoyVbgdozoCSmNBmj2dvbykQyrZkdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;657&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote cid=&quot;n916&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n921&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;不可重复读和幻读的区别？&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n922&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;不可重复读和幻读最大的区别，就在于如何通过锁机制来解决他们产生的问题，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n924&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;使用锁机制来实现这两种隔离级别，在可重复读中，相同sql第一次读取到数据后就将这些数据加锁，其它事务无法更新操作这些数据来实现可重复读了隔离。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n926&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;但这种处理方式却无法锁住insert的数据，因此会出现当事务A先前读取了数据，事务B再&lt;code&gt;insert&lt;/code&gt;数据提交，结果发现事务A就会发现莫名其妙多了些数据，这就是幻读，不能通过行锁来避免 。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p cid=&quot;n914&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;了解了并发问题后，来看看不同的隔离级别可能会存在在不同并发问题：&lt;/span&gt;&lt;/p&gt;&lt;figure cid=&quot;n868&quot; mdtype=&quot;table&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr cid=&quot;n869&quot; mdtype=&quot;table_row&quot;&gt;&lt;th&gt;&lt;span&gt;事务隔离级别&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;脏读&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;不可重复读&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;幻读&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr cid=&quot;n874&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;读未提交&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;是&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;是&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;是&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n879&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;不可重复读&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;否&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;是&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;是&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n884&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;可重复读&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;否&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;否&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;是&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n889&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;串行化&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;否&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;否&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;否&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p cid=&quot;n70&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;为了实现事务隔离，延伸出了数据库锁。其中，&lt;span&gt;&lt;strong&gt;innodb事务的隔离级别是由锁机制和MVCC（多版本并发控制）来实现的&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n71&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;那我们来先看看锁的原理，怎么使用锁来实现事务隔离的呢？&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n73&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;锁机制&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n971&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;锁机制的基本工作原理，事务在修改数据之前，需要先获得相应的锁；获得锁之后，事务便可以修改数据；该事务操作期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放锁，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n74&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;MySQL主要分成三种类型（级别）的锁机制：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n75&quot; mdtype=&quot;list&quot; data-mark=&quot;+&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n77&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;表级锁：最大颗粒度的锁机制，锁定资源争用的概率也会最高 ，并发度最低 ，但开销小，加锁快，不会出现死锁，&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n79&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;行级锁：最大颗粒度的锁机制很小， 发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能 ，但 开销大，加锁慢；会出现死锁 ，&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n81&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;页级锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n82&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;而且不同的存储引擎支持不同的的锁机制，主要分析一下InnoDB锁。&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n83&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;InnoDB锁&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n84&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt; InnoDB实现了以下两种类型的行锁&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n90&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;对于&lt;code&gt;UPDATE&lt;/code&gt;,&lt;code&gt;DELETE&lt;/code&gt;,&lt;code&gt;INSERT&lt;/code&gt;操作， InnoDB会自动给涉及及数据集加排他锁（Ｘ）；对于普通SELECT语句，InnoDB不会加任何锁,&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n91&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;而且因为InnoDB引擎允许行锁和表锁共存，实现多粒度锁机制，使用意向锁实现表锁机制，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n97&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;意向锁(IS、IX)是InnoDB数据操作之前自动加的，不需要用户干预。它的意义在于：当事务想去进行锁表时，可以先判断意向锁是否存在，存在时则可快速返回该表不能启用表锁，否则就需要等待，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n98&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;其中，四种锁的兼容性如下&lt;/span&gt;&lt;/p&gt;&lt;figure cid=&quot;n99&quot; mdtype=&quot;table&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr cid=&quot;n100&quot; mdtype=&quot;table_row&quot;&gt;&lt;th&gt;&lt;span&gt;当前锁模式/是否兼容/请求锁模式&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;X&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;IX&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;S&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;IS&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr cid=&quot;n106&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;X&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;冲突&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;冲突&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;冲突&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;冲突&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n112&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;IX&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;冲突&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;兼容&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;冲突&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;兼容&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n118&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;S&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;冲突&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;冲突&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;兼容&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;兼容&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n124&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;IS&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;冲突&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;兼容&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;兼容&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;兼容&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p cid=&quot;n130&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;如果一个事务请求的锁模式与当前的锁兼容，InnoDB就请求的锁授予该事务；反之，如果两者两者不兼容，该事务就要等待锁释放。&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n131&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;InnoDB行锁&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n132&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;InnoDB的行锁是通过给索引上的&lt;strong&gt;索引项加锁&lt;/strong&gt;来实现的。&lt;strong&gt;只有通过索引检索数据，才能使用行锁，否则将使用表锁（锁住索引的所有记录）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n133&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;innodb的行锁，默认是由&lt;strong&gt;&lt;code&gt;临键锁(next-key)&lt;/code&gt;&lt;/strong&gt;算法实现的，可以防止幻读。根据索引，划分为一个个&lt;strong&gt;左开右闭&lt;/strong&gt;的区间。当进行范围查询的时候，若命中索引且能够检索到数据，则锁住记录所在的区间和它的下一个区间,&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n134&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;其实，&lt;strong&gt;临键锁(Next-Key)&lt;/strong&gt;=&lt;strong&gt;记录锁(Record Locks)&lt;/strong&gt;+&lt;strong&gt;间隙锁(Gap Locks)&lt;/strong&gt;，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n140&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;具体的使用体现在哪里呢？如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.46060606060606063&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDrgyKx4nzfu3dK9SD5jxqxFmIvTG2Z905QUWVJgL5KYvySqTVgJf3licqul9aCZgbMvlFthtOpTYVww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;660&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n145&quot; mdtype=&quot;list&quot; data-mark=&quot;+&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n147&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;当记录不存在（不论是等值查询，还是范围查询）时，next-key将退化成&lt;strong&gt;Gap Lock（间隙锁）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n148&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5150602409638554&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDrgyKx4nzfu3dK9SD5jxqxFmWpbMHJ8rEpFJyCiaa9vZGXPUsvricjWr0KxzQzHPyickY8zibqNLb6OemQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;664&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n150&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;当条件是精准匹配（即为等值查询时）且记录存在时，并且是唯一索引，&lt;strong&gt;临键锁(Next-Key)&lt;/strong&gt;退化成&lt;strong&gt;Record Lock（记录锁）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n151&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4180790960451977&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDrgyKx4nzfu3dK9SD5jxqxFmsdCoFtlnGsncibWh7DLGCDy9lsEjbJsgKISMUpKVkcauW4Fuibd54L0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;708&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n153&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;当条件是精准匹配（即为等值查询时）且记录存在，但不是唯一索引时，&lt;strong&gt;临键锁(Next-Key)&lt;/strong&gt;会有精准值的数据会增加&lt;strong&gt;Record Lock（记录锁）&lt;/strong&gt;和精准值前后的区间的数据会增加&lt;strong&gt;Gap Lock（间隙锁)&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n154&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4880597014925373&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDrgyKx4nzfu3dK9SD5jxqxFmz0VibbGWM6LPXzu6v2WfxfX41Xuo26h2StJrzu0GMpjtSojga6nbSVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;670&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 cid=&quot;n961&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;如何使用锁解决并发问题&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n962&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;利用锁解决脏读、不可重复读、幻读&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n960&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;&lt;code&gt;Multiversion concurrency control&lt;/code&gt; (&lt;code&gt;MVCC&lt;/code&gt; 多版本并发控制)&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n165&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;code&gt;InnoDB&lt;/code&gt;的&lt;code&gt;MVCC&lt;/code&gt;是通过在每行记录后面保存两个隐藏的列来实现的，&lt;strong&gt;一个保存了行的事务ID（事务ID就会递增 ）&lt;/strong&gt;，&lt;strong&gt;一个保存了行的回滚段的指针&lt;/strong&gt; 。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n398&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.21217391304347827&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDrgyKx4nzfu3dK9SD5jxqxFmR7uEiaSiaIwwML2kqPjwfcejNLV9I5qJrznHCtAhl7n3l6NiaDuMNCgGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;575&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n400&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;每开始一个新的事务，都会自动递增产 生一个新的事务id。事务开始时刻的会把事务id放到当前事务影响的行事务id中，而&lt;code&gt;DB_ROLL_PTR&lt;/code&gt;表示指向该行回滚段的指针，该行记录上所有版本数据，在undo中都通过链表形式组织，该值实际指向undo中该行的历史记录链表，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n166&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span&gt;在并发访问数据库时，对正在事务中的数据做MVCC多版本的管理，以避免写操作阻塞读操作，并且会通过比较版本解决幻读&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n167&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;而且MVCC只在&lt;code&gt;REPEATABLE READ&lt;/code&gt;和&lt;code&gt;READ COMMITIED&lt;/code&gt;两个隔离级别下才会工作，&lt;strong&gt;其中，MVCC实现实质就是保存数据在某个时间点的&lt;span&gt;快照&lt;/span&gt;来实现的。&lt;/strong&gt; 那哪些操作是快照读？&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n168&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;快照读和当前读&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n169&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;快照读&lt;/strong&gt;，innodb快照读，数据的读取将由 cache(原本数据) + undo(事务修改前的数据) 两部分组成&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n173&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;当前读&lt;/strong&gt;，SQL读取的数据是最新版本。通过锁机制来保证读取的数据无法通过其他事务进行修改&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n186&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;那么在RR隔离级别下，MVCC具体是如何操作的。&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n187&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;RR隔离级别下，MVCC具体操作&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n188&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;SELECT操作&lt;/strong&gt;，InnoDB遵循以后两个规则执行：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; cid=&quot;n189&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n191&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span&gt;InnoDB只查找版本早于当前事务版本的数据行（即行的事务编号小于或等于当前事务的事务编号）&lt;/span&gt;，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的记录。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n193&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span&gt;行的删除版本要么未定义,读取到事务开始之前状态的版本&lt;/span&gt;&amp;gt;,这可以确保事务读取到的行，在事务开始之前未被删除.只有同时满足的两者的记录，才能返回作为查询结果.&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p cid=&quot;n194&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;INSERT&lt;/strong&gt;：&lt;span&gt;InnoDB为新插入的每一行保存当前事务编号作为行版本号&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n195&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;DELETE&lt;/strong&gt;：&lt;span&gt;InnoDB为删除的每一行保存当前事务编号作为行删除标识&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n196&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;UPDATE&lt;/strong&gt;：&lt;span&gt;InnoDB为插入一行新记录，保存当前事务编号作为行版本号，同时保存当前事务编号到原来的行作为行删除标识&lt;/span&gt;&amp;gt;。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n197&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;保存这两个额外系统版本号，使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。&lt;span md-inline=&quot;tab&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n198&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;分析完了原子性和隔离性，我们继续看看事务的持久性。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n980&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h2 cid=&quot;n931&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;持久性(&lt;/span&gt;&lt;code&gt;&lt;span&gt;Durability&lt;/span&gt;&lt;/code&gt;&lt;span&gt;)&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n940&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;持久性(&lt;code&gt;Durability&lt;/code&gt;)：事务提交之后，所做的修改就会永久保存，不会因为系统故障导致数据丢失，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n983&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;而且其实现的关键在于&lt;code&gt;redo log&lt;/code&gt;， 在执行SQL时会保存已执行的SQL语句到一个指定的Log文件，当执行&lt;code&gt;recovery&lt;/code&gt;时重新执行&lt;code&gt;redo log&lt;/code&gt;记录的SQL操作。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n991&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;那么&lt;code&gt;redo log&lt;/code&gt;如何实现的呢？&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n993&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;redo log&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n995&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;当向数据库写入数据时，执行过程会首先写入Buffer Pool，Buffer Pool中修改的数据会定期刷新到磁盘中（这一过程称为刷脏），这整一过程称为redo log。redo log 分为：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1019&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Buffer Pool的使用可以大大提高了读写数据的效率，但是也带了新的问题：如果MySQL宕机，而此时Buffer Pool中修改的数据在内存还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1016&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;为了确保事务的持久性，在当事务提交时，会调用&lt;code&gt;fsync&lt;/code&gt;接口对&lt;code&gt;redo log&lt;/code&gt;进行刷盘, （即&lt;code&gt;redo log buffer&lt;/code&gt;写日志到磁盘的&lt;code&gt;redo log file&lt;/code&gt;中 ）,刷新频率由 &lt;code&gt;innodb_flush_log_at_trx_commit&lt;/code&gt;变量来控制的：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1043&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;redo log有更加详细的解读，后续有时间再补上，到现在为止，已经将事务三个特性都理解了，那事务一致性呢？&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;h2 cid=&quot;n1049&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;一致性(&lt;/span&gt;&lt;code&gt;&lt;span&gt;Consistency&lt;/span&gt;&lt;/code&gt;&lt;span&gt;)&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n989&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;一致性(&lt;code&gt;Consistency&lt;/code&gt;)：事务不能破坏数据的完整性和业务的一致性 ：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1065&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;那是如何保证数据一致性的？&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1067&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;其实数据一致性是通过事务的原子性、持久性和隔离性来保证的&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n1072&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n1074&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;原子性：语句要么全执行，要么全不执行，是事务最核心的特性，事务本身就是以原子性来定义的；实现主要基于undo log&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1076&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;持久性：保证事务提交后不会因为宕机等原因导致数据丢失；实现主要基于redo log&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1078&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;隔离性：保证事务执行尽可能不受其他事务影响；InnoDB默认的隔离级别是RR，RR的实现主要基于锁机制（包含next-key lock）、MVCC（包括数据的隐藏列、基于undo log的版本链、ReadView）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 cid=&quot;n4927&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n932&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;其中要同时满足ACID特性，这样的事务少之又少。实际中很多例子都只是满足一些特性，比如：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n4931&quot; mdtype=&quot;list&quot; data-mark=&quot;+&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n4934&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;MySQL的NDB Cluster事务不满足持久性和隔离性；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n4935&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;InnoDB默认事务隔离级别是可重复读，不满足隔离性；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n4941&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Oracle默认的事务隔离级别为READ COMMITTED，不满足隔离性&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n4929&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;所以我们只能使用这个四个维度的特性去衡量事务的操作。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n934&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;blockquote cid=&quot;n7947&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n7949&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;谢谢各位点赞，没点赞的点个赞支持支持&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n7949&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;最后，微信搜《Ccww技术博客》观看更多文章，也欢迎关注一波。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDrgfBz2Ve78FylxcGWmXaueSuqPguurBCWEkeY1ibeLl1wlxUyibdesc4YeuiaJJjSt6HTiab2iaHyXyyicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.36857142857142855&quot; data-w=&quot;350&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>