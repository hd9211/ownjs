<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>6d54429192265cce9e30925f098af914</guid>
<title>工具 | 腾讯开源的一套运维脚本管理系统</title>
<link>https://toutiao.io/k/6b7chfm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;大家好，我是周刊菌。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MzA0ODkyMA==&amp;amp;mid=2655077223&amp;amp;idx=2&amp;amp;sn=05d40fd92b2ed441b4bfcaaab853a1d2&amp;amp;chksm=bd2913508a5e9a46683351f781991e7e2ad2a4a1c63a4acd499df91a8861e07ba5f713df0f96&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;加入「码农周刊VIP会员」，一起牛起来！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以下内容选自「码农周刊 VIP 会员」圈子，每日更新，精彩不断&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;1239&quot; data-ratio=&quot;2.584&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavibrjuslbgA22ac28mmKSkmofwBgZl57TTsoqIvmibTK9IjT5ZGkghkWlRibOgROfezWLcibjtIl1Ug1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;码农周刊是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;码农周刊是一份专为广大程序员、编程爱好者们打造的 IT 技术周刊。每周发送。&lt;br/&gt;2013 年 9 月 12 日创刊至今，已发送 300 多期，订阅用户超 20 万。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;专业、简单、有用&lt;/span&gt;&lt;span&gt;，是我们一直坚持的办刊宗旨。一路走来，我们见证了不少订阅用户从编程新手进阶成了高级程序员、架构师、CTO……&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2020 年 4 月，为了给用户提供更优质的服务，我们推出了「&lt;/span&gt;&lt;span&gt;码农周刊VIP会员&lt;/span&gt;&lt;span&gt;」服务。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你与 BAT 技术大牛，只差一份「码农周刊VIP会员」的距离！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;VIP会员特权&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 52 期码农周刊VIP会员&lt;span&gt;专属邮件周报&lt;/span&gt;，让你及时掌握技术动向；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 只限VIP会员加入的&lt;span&gt;交流圈子&lt;/span&gt;，让你与技术大牛切磋学习；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. VIP会员独享的&lt;span&gt;工作机会&lt;/span&gt;，为你介绍好公司的好机会；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 更多会员特权，持续更新……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如何加入「码农周刊VIP会员」？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1. 微信扫描下方二维码，加入码农周刊VIP会员知识星球。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;促销期间，一年仅需 108 元！平均一天花费不到 3 毛！&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;34&quot; data-cropselx2=&quot;356&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;425&quot; data-ratio=&quot;1.0857487922705313&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNav8Byw4xNoV6O2YGutfKmQLKuMZEIhBJF6MrQvoShfIAT6u3dXs6VZRzwSa2eT9jcekfaYuaOD6Hhw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;828&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 加入码农周刊VIP会员知识星球后，客服会联系您，请留意知识星球内的私信。&lt;br/&gt;3. 客服向您发送码农周刊VIP会员欢迎邮件，开启您的码农周刊VIP会员之旅。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;心动不如心动，赶快订阅吧！&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>74ac97a80f1c58ba45a80842d2e3896a</guid>
<title>MySQL 索引连环 18 问</title>
<link>https://toutiao.io/k/x7420rp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-topic-des nc-post-content&quot;&gt;
&lt;p&gt;MySQL作为互联网中非常热门的数据库，现在大厂面试题横竖绕不开MySQL，其中MySQL索引是大厂必考面试题。今天带来了MySQL索引的常考面试题，看看你能答对多少~ &lt;/p&gt; 
&lt;p&gt;这是本期的MySQL索引面试题目录，不会的快快查漏补缺~&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;目录&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20210413/540390845_1618325752025/image-20210411230042052.png&quot;/&gt;&lt;/p&gt; 
&lt;h2&gt;1. 索引是什么？&lt;/h2&gt; 
&lt;p&gt;索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;索引是一种数据结构。数据库索引，是数据库管理系统中一个&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。而且索引是一个文件，它是要占据物理空间的。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。比如我们在查字典的时候，前面都有检索的拼音和偏旁、笔画等，然后找到对应字典页码，这样然后就打开字典的页数就可以知道我们要搜索的某一个key的全部值的信息了。&lt;/p&gt; 
&lt;h2&gt;2. 索引有哪些优缺点？&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;索引的优点&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;可以大大加快数据的检索速度，这也是创建索引的最主要的原因。 &lt;/li&gt;
 &lt;li&gt;通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;索引的缺点&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率； &lt;/li&gt;
 &lt;li&gt;空间方面：索引需要占物理空间。 &lt;/li&gt;
&lt;/ul&gt; 
&lt;h2&gt;3. MySQL有哪几种索引类型？&lt;/h2&gt; 
&lt;p&gt;1、从存储结构上来划分：BTree索引（B-Tree或B+Tree索引），Hash索引，full-index全文索引，R-Tree索引。这里所描述的是索引存储时保存的形式，&lt;/p&gt; 
&lt;p&gt;2、从应用层次来分：普通索引，唯一索引，复合索引。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;普通索引：即一个索引只包含单个列，一个表可以有多个单列索引&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;唯一索引：索引列的值必须唯一，但允许有空值&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;复合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;聚簇索引(聚集索引)：并不是一种单独的索引类型，而是一种数据存储方式。具体细节取决于不同的实现，InnoDB的聚簇索引其实就是在同一个结构中保存了B-Tree索引(技术上来说是B+Tree)和数据行。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;非聚簇索引： 不是聚簇索引，就是非聚簇索引&lt;/p&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;3、根据中数据的物理顺序与键值的逻辑（索引）顺序关系： 聚集索引，非聚集索引。&lt;/p&gt; 
&lt;h2&gt;4. 说一说索引的底层实现？&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;Hash索引&lt;/strong&gt; &lt;/p&gt; 
&lt;p&gt;&lt;span&gt;基于&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%93%88%E5%B8%8C%E8%A1%A8&quot; target=&quot;_blank&quot;&gt;哈希表&lt;/a&gt;实现，只有精确匹配索引所有列的查询才有效，对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），并且Hash索引将所有的哈希码存储在索引中，同时在索引表中保存指向每个数据行的指针。&lt;/span&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;图片来源：&lt;a href=&quot;https://www.javazhiyin.com/40232.html&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;https://www.javazhiyin.com/40232.html&lt;/a&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20210413/540390845_1618325752261/image-20210411215012443.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;B-Tree索引&lt;/strong&gt;（MySQL使用B+Tree）&lt;/p&gt; 
&lt;p&gt;B-Tree能加快数据的访问速度，因为存储引擎不再需要进行全表扫描来获取数据，数据分布在各个节点之中。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20210413/540390845_1618325752112/image-20210411215023820.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;B+Tree索引&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;是B-Tree的改进版本，同时也是数据库索引索引所采用的存储结构。数据都在叶子节点上，并且增加了顺序访问指针，每个叶子节点都指向相邻的叶子节点的地址。相比B-Tree来说，进行范围查找时只需要查找两个节点，进行遍历即可。而B-Tree需要获取所有节点，相比之下B+Tree效率更高。&lt;/p&gt; 
&lt;p&gt;B+tree性质：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;B+ 树中，数据对象的插入和删除仅在叶节点上进行。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。&lt;/p&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20210413/540390845_1618325752195/image-20210411215044332.png&quot;/&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;span&gt;5. 为什么索引结构默认使用B+Tree，而不是B-Tree，Hash，&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E4%BA%8C%E5%8F%89%E6%A0%91&quot; target=&quot;_blank&quot;&gt;二叉树&lt;/a&gt;，&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%BA%A2%E9%BB%91%E6%A0%91&quot; target=&quot;_blank&quot;&gt;红黑树&lt;/a&gt;？&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;B-tree： 从两个方面来回答&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B(B-)树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对&lt;code&gt;IO读写次数就降低&lt;/code&gt;了。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在&lt;code&gt;区间查询&lt;/code&gt;的情况，所以通常B+树用于数据库索引。&lt;/p&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;Hash： &lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;虽然可以快速定位，但是没有顺序，IO复杂度高；&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;基于Hash表实现，只有Memory存储引擎显式支持哈希索引 ；&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;适合&lt;strong&gt;等值查询&lt;/strong&gt;，如=、in()、&amp;lt;=&amp;gt;，不支持范围查询 ；&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;因为不是按照索引值顺序存储的，就不能像B+Tree索引一样利用索引完成&lt;a target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;排序&lt;/a&gt; ；&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;Hash索引在查询等值时非常快 ；&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;因为Hash索引始终索引的&lt;strong&gt;所有列的全部内容&lt;/strong&gt;，所以不支持部分索引列的匹配查找 ；&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题 。&lt;/p&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E4%BA%8C%E5%8F%89%E6%A0%91&quot; target=&quot;_blank&quot;&gt;二叉树&lt;/a&gt;： 树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且IO代价高。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%BA%A2%E9%BB%91%E6%A0%91&quot; target=&quot;_blank&quot;&gt;红黑树&lt;/a&gt;： 树的高度随着数据量增加而增加，IO代价高。&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;6. 讲一讲聚簇索引与非聚簇索引？&lt;/h2&gt; 
&lt;p&gt;在 InnoDB 里，索引B+ Tree的叶子节点存储了整行数据的是主键索引，也被称之为聚簇索引，即将数据存储与索引放到了一块，找到索引也就找到了数据。&lt;/p&gt; 
&lt;p&gt;而索引B+ Tree的叶子节点存储了主键的值的是非主键索引，也被称之为非聚簇索引、二级索引。&lt;/p&gt; 
&lt;p&gt;聚簇索引与非聚簇索引的区别：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;非聚集索引与聚集索引的区别在于非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键（行号） &lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;对于InnoDB来说，想要查找数据我们还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，我们称为&lt;strong&gt;回表&lt;/strong&gt;。第一次索引一般是顺序IO，回表的操作属于随机IO。需要回表的次数越多，即随机IO次数越多，我们就越倾向于使用全表扫描 。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;通常情况下， 主键索引（聚簇索引）查询只会查一次，而非主键索引（非聚簇索引）需要回表查询多次。当然，如果是覆盖索引的话，查一次即可 &lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;注意：MyISAM无论主键索引还是二级索引都是非聚簇索引，而InnoDB的主键索引是聚簇索引，二级索引是非聚簇索引。我们自己建的索引基本都是非聚簇索引。&lt;/p&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;h2&gt;7. 非聚簇索引一定会回表查询吗？&lt;/h2&gt; 
&lt;p&gt;不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。一个索引包含（覆盖）所有需要查询字段的值，被称之为&quot;覆盖索引&quot;。&lt;/p&gt; 
&lt;p&gt;举个简单的例子，假设我们在学生表的成绩上建立了索引，那么当进行&lt;code&gt;select score from student where score &amp;gt; 90&lt;/code&gt;的查询时，在索引的叶子节点上，已经包含了score 信息，不会再次进行回表查询。&lt;/p&gt; 
&lt;h2&gt;8. 联合索引是什么？为什么需要注意联合索引中的顺序？&lt;/h2&gt; 
&lt;p&gt;MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。&lt;/p&gt; 
&lt;p&gt;具体原因为:&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;MySQL使用索引时需要索引有序，假设现在建立了&quot;name，age，school&quot;的联合索引，那么索引的&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;为: 先按照name&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;，如果name相同，则按照age&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;，如果age的值也相等，则按照school进行&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。&lt;/p&gt; 
&lt;h2&gt;9. 讲一讲MySQL的最左前缀原则?&lt;/h2&gt; 
&lt;p&gt;最左前缀原则就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。&lt;br/&gt;mysql会一直向右匹配直到遇到范围查询(&amp;gt;、&amp;lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &amp;gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。&lt;/p&gt; 
&lt;p&gt;=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。&lt;/p&gt; 
&lt;h2&gt;10. 讲一讲前缀索引？&lt;/h2&gt; 
&lt;p&gt;因为可能我们索引的字段非常长，这既占内存空间，也不利于维护。所以我们就想，如果只把很长字段的前面的公共部分作为一个索引，就会产生超级加倍的效果。但是，我们需要注意，order by不支持前缀索引 。&lt;/p&gt; 
&lt;p&gt; 流程是： &lt;/p&gt; 
&lt;p&gt; 先计算完整列的选择性 :&lt;code&gt;select count(distinct col_1)/count(1) from table_1&lt;/code&gt;&lt;/p&gt; 
&lt;p&gt; 再计算不同前缀长度的选择性 :&lt;code&gt;select count(distinct left(col_1,4))/count(1) from table_1&lt;/code&gt;&lt;/p&gt; 
&lt;p&gt; 找到最优长度之后，创建前缀索引 :&lt;code&gt;create index idx_front on table_1 (col_1(4))&lt;/code&gt;&lt;/p&gt; 
&lt;h2&gt;11. 了解索引下推吗？&lt;/h2&gt; 
&lt;p&gt;MySQL 5.6引入了索引下推优化。默认开启，使用SET optimizer_switch = ‘index_condition_pushdown=off’;可以将其关闭。 &lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;有了索引下推优化，可以在&lt;strong&gt;减少回表次数&lt;/strong&gt; &lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;在InnoDB中只针对二级索引有效&lt;/p&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;官方文档中给的例子和解释如下：&lt;/p&gt; 
&lt;p&gt;在 people_table中有一个二级索引(zipcode，lastname，address)，查询是SELECT * FROM people WHERE zipcode=’95054′ AND lastname LIKE ‘%etrunia%’ AND address LIKE ‘%Main Street%’; &lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;如果没有使用索引下推技术，则MySQL会通过zipcode=’95054’从存储引擎中查询对应的数据，返回到MySQL服务端，然后MySQL服务端基于lastname LIKE ‘%etrunia%’ and address LIKE ‘%Main Street%’来判断数据是否符合条件 &lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;如果使用了索引下推技术，则MYSQL首先会返回符合zipcode=’95054’的索引，然后根据lastname LIKE ‘%etrunia%’ and address LIKE ‘%Main Street%’来判断索引是否符合条件。如果符合条件，则根据该索引来定位对应的数据，如果不符合，则直接reject掉。&lt;/p&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;h2&gt;12. 怎么查看MySQL语句有没有用到索引？&lt;/h2&gt; 
&lt;p&gt;通过explain，如以下例子：&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;EXPLAIN SELECT * FROM employees.titles WHERE emp_no=&#x27;10001&#x27; AND title=&#x27;Senior Engineer&#x27; AND from_date=&#x27;1986-06-26&#x27;;&lt;/code&gt;&lt;/p&gt; 
&lt;table&gt; 
 &lt;thead&gt; 
  &lt;tr&gt; 
   &lt;th&gt;id&lt;/th&gt; 
   &lt;th&gt;select_type&lt;/th&gt; 
   &lt;th&gt;table&lt;/th&gt; 
   &lt;th&gt;partitions&lt;/th&gt; 
   &lt;th&gt;type&lt;/th&gt; 
   &lt;th&gt;possible_keys&lt;/th&gt; 
   &lt;th&gt;key&lt;/th&gt; 
   &lt;th&gt;key_len&lt;/th&gt; 
   &lt;th&gt;ref&lt;/th&gt; 
   &lt;th&gt;filtered&lt;/th&gt; 
   &lt;th&gt;rows&lt;/th&gt; 
   &lt;th&gt;Extra&lt;/th&gt; 
  &lt;/tr&gt; 
 &lt;/thead&gt; 
 &lt;tbody&gt;
  &lt;tr&gt; 
   &lt;td&gt;1&lt;/td&gt; 
   &lt;td&gt;SIMPLE&lt;/td&gt; 
   &lt;td&gt;titles&lt;/td&gt; 
   &lt;td&gt;null&lt;/td&gt; 
   &lt;td&gt;const&lt;/td&gt; 
   &lt;td&gt;PRIMARY&lt;/td&gt; 
   &lt;td&gt;PRIMARY&lt;/td&gt; 
   &lt;td&gt;59&lt;/td&gt; 
   &lt;td&gt;const,const,const&lt;/td&gt; 
   &lt;td&gt;10&lt;/td&gt; 
   &lt;td&gt;1&lt;/td&gt; 
   &lt;td/&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt;
&lt;/table&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;id：在⼀个⼤的查询语句中每个&lt;strong&gt;SELECT&lt;/strong&gt;关键字都对应⼀个唯⼀的id ，如explain select * from s1 where id = (select id from s1 where name = &#x27;egon1&#x27;);第一个select的id是1，第二个select的id是2。有时候会出现两个select，但是id却都是1，这是因为优化器把子查询变成了连接查询 。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;select_type：select关键字对应的那个查询的类型，如SIMPLE,PRIMARY,SUBQUERY,DEPENDENT,SNION 。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;table：每个查询对应的表名 。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;type：&lt;code&gt;type&lt;/code&gt; 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 &lt;code&gt;type&lt;/code&gt; 字段, 我们判断此次查询是 &lt;code&gt;全表扫描&lt;/code&gt; 还是 &lt;code&gt;索引扫描&lt;/code&gt; 等。如const(主键索引或者唯一二级索引进行等值匹配的情况下),ref(普通的⼆级索引列与常量进⾏等值匹配),index(扫描全表索引的覆盖索引) 。&lt;/p&gt; &lt;p&gt;通常来说, 不同的 type 类型的性能关系如下:&lt;br/&gt;&lt;code&gt;ALL &amp;lt; index &amp;lt; range ~ index_merge &amp;lt; ref &amp;lt; eq_ref &amp;lt; const &amp;lt; system&lt;/code&gt;&lt;br/&gt;&lt;code&gt;ALL&lt;/code&gt; 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.&lt;br/&gt;而 &lt;code&gt;index&lt;/code&gt; 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;possible_key：查询中可能用到的索引&lt;em&gt;(可以把用不到的删掉，降低优化器的优化时间)&lt;/em&gt; 。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;key：此字段是 MySQL 在当前查询时所真正使用到的索引。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;filtered：查询器预测满足下一次查询条件的百分比 。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;rows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.&lt;br/&gt;这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;extra：表示额外信息，如Using where,Start temporary,End temporary,Using temporary等。&lt;/p&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;h2&gt;13. 为什么官方建议使用自增长主键作为索引？&lt;/h2&gt; 
&lt;p&gt;结合B+Tree的特点，自增主键是连续的，在插入过程中尽量减少页分裂，即使要进行页分裂，也只会分裂很少一部分。并且能减少数据的移动，每次插入都是插入到最后。总之就是减少分裂和移动的频率。&lt;/p&gt; 
&lt;p&gt;插入连续的数据：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;图片来自：&lt;a href=&quot;https://www.javazhiyin.com/40232.html&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;https://www.javazhiyin.com/40232.html&lt;/a&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20210413/540390845_1618325752160/java10-1562726251.gif&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;插入非连续的数据：&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20210413/540390845_1618325752674/java8-1562726251.gif&quot;/&gt;&lt;/p&gt; 
&lt;h2&gt;14. 如何创建索引？&lt;/h2&gt; 
&lt;p&gt;创建索引有三种方式。&lt;/p&gt; 
&lt;p&gt;1、 在执行CREATE TABLE时创建索引&lt;/p&gt; 
&lt;pre class=&quot;prettyprint lang-sql&quot; from-niu=&quot;default&quot;&gt;CREATE TABLE user_index2 (
    id INT auto_increment PRIMARY KEY,
    first_name VARCHAR (16),
    last_name VARCHAR (16),
    id_card VARCHAR (18),
    information text,
    KEY name (first_name, last_name),
    FULLTEXT KEY (information),
    UNIQUE KEY (id_card)
);
&lt;/pre&gt; 
&lt;p&gt;2、 使用ALTER TABLE命令去增加索引。&lt;/p&gt; 
&lt;pre class=&quot;prettyprint lang-sql&quot; from-niu=&quot;default&quot;&gt;ALTER TABLE table_name ADD INDEX index_name (column_list);&lt;/pre&gt; 
&lt;p&gt;ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。&lt;/p&gt; 
&lt;p&gt;其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。&lt;/p&gt; 
&lt;p&gt;索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。&lt;br/&gt;3、 使用CREATE INDEX命令创建。&lt;/p&gt; 
&lt;pre class=&quot;prettyprint lang-sql&quot; from-niu=&quot;default&quot;&gt;CREATE INDEX index_name ON table_name (column_list);&lt;/pre&gt; 
&lt;h2&gt;15. 创建索引时需要注意什么？&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值； &lt;/li&gt;
 &lt;li&gt;取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高； &lt;/li&gt;
 &lt;li&gt;索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。 &lt;/li&gt;
&lt;/ul&gt; 
&lt;h2&gt;16. 建索引的原则有哪些？&lt;/h2&gt; 
&lt;p&gt;1、最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&amp;gt;、&amp;lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &amp;gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。&lt;/p&gt; 
&lt;p&gt;2、=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。&lt;/p&gt; 
&lt;p&gt;3、尽量选择区分度高的列作为索引，区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。&lt;/p&gt; 
&lt;p&gt;4、索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。&lt;/p&gt; 
&lt;p&gt;5、尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。&lt;/p&gt; 
&lt;h2&gt;17. 使用索引查询一定能提高查询的性能吗？&lt;/h2&gt; 
&lt;p&gt;通常通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。&lt;/p&gt; 
&lt;p&gt;索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。 这意味着每条记录的I* NSERT，DELETE，UPDATE将为此多付出4，5 次的磁盘I/O。 因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;基于一个范围的检索，一般查询返回结果集小于表中记录数的30%。 &lt;/li&gt;
 &lt;li&gt;基于非唯一性索引的检索。 &lt;/li&gt;
&lt;/ul&gt; 
&lt;h2&gt;18. 什么情况下不走索引（索引失效）？&lt;/h2&gt; 
&lt;h5&gt;1、使用!= 或者 &amp;lt;&amp;gt; 导致索引失效&lt;/h5&gt; 
&lt;h5&gt;2、类型不一致导致的索引失效&lt;/h5&gt; 
&lt;h5&gt;3、函数导致的索引失效&lt;/h5&gt; 
&lt;p&gt;如：&lt;/p&gt; 
&lt;pre class=&quot;prettyprint&quot; from-niu=&quot;default&quot;&gt;SELECT * FROM `user` WHERE DATE(create_time) = &#x27;2020-09-03&#x27;;&lt;/pre&gt;
&lt;p&gt;如果你的索引字段使用了函数，对不起，他是真的不走索引的。&lt;/p&gt; 
&lt;h5&gt;4、运算符导致的索引失效&lt;/h5&gt; 
&lt;pre class=&quot;prettyprint&quot; from-niu=&quot;default&quot;&gt;SELECT * FROM `user` WHERE age - 1 = 20;&lt;/pre&gt;
&lt;p&gt;如果你对列进行了（+，-，*，/，!）, 那么都将不会走索引。&lt;/p&gt; 
&lt;h5&gt;5、OR引起的索引失效&lt;/h5&gt; 
&lt;pre class=&quot;prettyprint&quot; from-niu=&quot;default&quot;&gt;SELECT * FROM `user` WHERE `name` = &#x27;张三&#x27; OR height = &#x27;175&#x27;;&lt;/pre&gt;
&lt;p&gt;OR导致索引是在特定情况下的，并不是所有的OR都是使索引失效，如果OR连接的是同一个字段，那么索引不会失效，反之索引失效。&lt;/p&gt; 
&lt;h5&gt;6、模糊搜索导致的索引失效&lt;/h5&gt; 
&lt;pre class=&quot;prettyprint&quot; from-niu=&quot;default&quot;&gt;SELECT * FROM `user` WHERE `name` LIKE &#x27;%冰&#x27;;&lt;/pre&gt;
&lt;p&gt;当&lt;code&gt;%&lt;/code&gt;放在匹配字段前是不走索引的，放在后面才会走索引。&lt;/p&gt; 
&lt;h5&gt;7、NOT IN、NOT EXISTS导致索引失效&lt;/h5&gt; 
&lt;h2 id=&quot;end&quot;&gt;End&lt;/h2&gt; 
&lt;p&gt;整理不易，点个赞呗！&lt;/p&gt; 
&lt;h2&gt;巨人的肩膀&lt;/h2&gt; 
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/ThinkWon/article/details/104778621&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;https://blog.csdn.net/ThinkWon/article/details/104778621&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.javazhiyin.com/40232.html&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;https://www.javazhiyin.com/40232.html&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6844904039860142088&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;https://juejin.cn/post/6844904039860142088&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/ThinkWon/article/details/104778621&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;https://blog.csdn.net/ThinkWon/article/details/104778621&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000008131735&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;https://segmentfault.com/a/1190000008131735&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b03ede1a502030c675c5d5eef557c17e</guid>
<title>如何开发一个文件文档在线预览的网站？</title>
<link>https://toutiao.io/k/p3i66hk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;col-md-12 text-center&quot;&gt;&lt;p&gt;总访问量：&lt;span&gt;31012&lt;/span&gt;    今日访问量：&lt;span&gt;37&lt;/span&gt;    您是今天第：&lt;span&gt;37&lt;/span&gt; 个访问者&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b16f6de03361c8fc84754f1a633cb48d</guid>
<title>Golang 官方限流器的用法详解</title>
<link>https://toutiao.io/k/xvjaiyz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;限流器是提升服务稳定性的非常重要的组件，可以用来限制请求速率，保护服务，以免服务过载。限流器的实现方法有很多种，常见的限流算法有&lt;strong&gt;固定窗口、滑动窗口、漏桶、令牌桶&lt;/strong&gt;，我在前面的文章 &lt;strong&gt;「&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&amp;amp;mid=2247486937&amp;amp;idx=1&amp;amp;sn=d4ea6ebb38c52e8004e73f235bde9848&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;常用限流算法的应用场景和实现原理&lt;/a&gt;」&lt;/strong&gt; 中给大家讲解了这几种限流方法自身的特点和应用场景，其中令牌桶在限流的同时还可以应对一定的突发流量，与互联网应用容易因为热点事件出现突发流量高峰的特点更契合。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;简单来说，令牌桶就是想象有一个固定大小的桶，系统会以恒定速率向桶中放 Token，桶满则暂时不放。在请求比较的少的时候桶可以先&quot;攒&quot;一些Token，应对突发的流量，如果桶中有剩余 Token 就可以一直取。如果没有剩余 Token，则需要等到桶中被放置了 Token 才行。&lt;/p&gt;&lt;p&gt;关于令牌桶限流更详细的解释请参考文章：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&amp;amp;mid=2247486937&amp;amp;idx=1&amp;amp;sn=d4ea6ebb38c52e8004e73f235bde9848&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;常用限流算法的应用场景和实现原理&lt;/a&gt;&lt;span/&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有的同学在看明白令牌桶的原理后就非常想去自己实现一个限流器应用到自己的项目里，em... 怎么说呢，造个轮子确实有利于自己水平提高，不过要是应用到商用项目里的话其实大可不必自己去造轮子，Golang官方已经替我们造好轮子啦 ......~！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Golang 官方提供的扩展库里就自带了限流算法的实现，即 &lt;code&gt;golang.org/x/time/rate&lt;/code&gt;。该限流器也是基于 Token Bucket(令牌桶) 实现的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;限流器的内部结构&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;time/rate&lt;/code&gt;包的&lt;code&gt;Limiter&lt;/code&gt;类型对限流器进行了定义，所有限流功能都是通过基于&lt;code&gt;Limiter&lt;/code&gt;类型实现的，其内部结构如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Limiter &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; mu     sync.Mutex&lt;br/&gt; limit  Limit&lt;br/&gt; burst  &lt;span&gt;int&lt;/span&gt; &lt;span&gt;// 令牌桶的大小&lt;/span&gt;&lt;br/&gt; tokens &lt;span&gt;float64&lt;/span&gt;&lt;br/&gt; last time.Time &lt;span&gt;// 上次更新tokens的时间&lt;/span&gt;&lt;br/&gt; lastEvent time.Time &lt;span&gt;// 上次发生限速器事件的时间（通过或者限制都是限速器事件）&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其主要字段的作用是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;limit：&lt;code&gt;limit&lt;/code&gt;字段表示往桶里放Token的速率，它的类型是Limit，是int64的类型别名。&lt;strong&gt;设置&lt;code&gt;limit&lt;/code&gt;时既可以用数字指定每秒向桶中放多少个Token，也可以指定向桶中放Token的时间间隔&lt;/strong&gt;，其实指定了每秒放Token的个数后就能计算出放每个Token的时间间隔了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;burst: 令牌桶的大小。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;tokens: 桶中的令牌。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;last: 上次往桶中放 Token 的时间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;lastEvent：上次发生限速器事件的时间（通过或者限制都是限速器事件）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;可以看到在 &lt;code&gt;timer/rate&lt;/code&gt; 的限流器实现中，并没有单独维护一个 Timer 和队列去真的每隔一段时间向桶中放令牌，而是仅仅通过计数的方式表示桶中剩余的令牌。每次消费取 Token 之前会先根据上次更新令牌数的时间差更新桶中Token数&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大概了解了&lt;code&gt;time/rate&lt;/code&gt;限流器的内部实现后，下面的内容我们会集中介绍下该组件的具体使用方法：&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;构造限流器&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以使用以下方法构造一个限流器对象：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;limiter := rate.NewLimiter(&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有两个参数：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一个参数是 &lt;code&gt;r Limit&lt;/code&gt;，设置的是限流器Limiter的&lt;code&gt;limit&lt;/code&gt;字段，代表每秒可以向 Token 桶中产生多少 token。Limit 实际上是 float64 的别名。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二个参数是 &lt;code&gt;b int&lt;/code&gt;，b 代表 Token 桶的容量大小，也就是设置的限流器 Limiter 的&lt;code&gt;burst&lt;/code&gt;字段。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，对于以上例子来说，其构造出的限流器的令牌桶大小为 100, 以每秒 10 个 Token 的速率向桶中放置 Token。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了给&lt;code&gt;r Limit&lt;/code&gt;参数直接指定每秒产生的 Token 个数外，还可以用 Every 方法来指定向桶中放置 Token 的间隔，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;limit := rate.Every(&lt;span&gt;100&lt;/span&gt; * time.Millisecond);&lt;br/&gt;limiter := rate.NewLimiter(limit, &lt;span&gt;100&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就表示每 100ms 往桶中放一个 Token。本质上也是一秒钟往桶里放 10 个。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;使用限流器&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Limiter 提供了三类方法供程序消费 Token，可以每次消费一个 Token，也可以一次性消费多个 Token。每种方法代表了当 Token 不足时，各自不同的对应手段，可以阻塞等待桶中Token补充，也可以直接返回取Token失败。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Wait/WaitN&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(lim *Limiter)&lt;/span&gt; &lt;span&gt;Wait&lt;/span&gt;&lt;span&gt;(ctx context.Context)&lt;/span&gt; &lt;span&gt;(err error)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(lim *Limiter)&lt;/span&gt; &lt;span&gt;WaitN&lt;/span&gt;&lt;span&gt;(ctx context.Context, n &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(err error)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Wait 实际上就是 &lt;code&gt;WaitN(ctx,1)&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当使用 Wait 方法消费 Token 时，如果此时桶内 Token 数组不足 (小于 N)，那么 Wait 方法将会阻塞一段时间，直至 Token 满足条件。如果充足则直接返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里可以看到，Wait 方法有一个 context 参数。我们可以设置 context 的 Deadline 或者 Timeout，来决定此次 Wait 的最长时间。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 一直等到获取到桶中的令牌&lt;/span&gt;&lt;br/&gt;err := limiter.Wait(context.Background())&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;Error: &quot;&lt;/span&gt;, err)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 设置一秒的等待超时时间&lt;/span&gt;&lt;br/&gt;ctx, _ := context.WithTimeout(context.Background(), time.Second * &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;err := limiter.Wait(ctx)&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;Error: &quot;&lt;/span&gt;, err)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Allow/AllowN&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(lim *Limiter)&lt;/span&gt; &lt;span&gt;Allow&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(lim *Limiter)&lt;/span&gt; &lt;span&gt;AllowN&lt;/span&gt;&lt;span&gt;(now time.Time, n &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Allow 实际上就是对 &lt;code&gt;AllowN(time.Now(),1)&lt;/code&gt; 进行简化的函数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AllowN 方法表示，截止到某一时刻，目前桶中数目是否至少为 n 个，满足则返回 true，同时从桶中消费 n 个 token。反之不消费桶中的Token，返回false。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对应线上的使用场景是，如果请求速率超过限制，就直接丢弃超频后的请求。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; limiter.AllowN(time.Now(), &lt;span&gt;2&lt;/span&gt;) {&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;event allowed&quot;&lt;/span&gt;)&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;event not allowed&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Reserve/ReserveN&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(lim *Limiter)&lt;/span&gt; &lt;span&gt;Reserve&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; *&lt;span&gt;Reservation&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(lim *Limiter)&lt;/span&gt; &lt;span&gt;ReserveN&lt;/span&gt;&lt;span&gt;(now time.Time, n &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; *&lt;span&gt;Reservation&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Reserve 相当于 &lt;code&gt;ReserveN(time.Now(), 1)&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ReserveN 的用法就相对来说复杂一些，当调用完成后，无论 Token 是否充足，都会返回一个 &lt;code&gt;*Reservation&lt;/code&gt; 对象。你可以调用该对象的&lt;code&gt;Delay()&lt;/code&gt;方法，该方法返回的参数类型为&lt;code&gt;time.Duration&lt;/code&gt;，反映了需要等待的时间，必须等到等待时间之后，才能进行接下来的工作。如果不想等待，可以调用&lt;code&gt;Cancel()&lt;/code&gt;方法，该方法会将 Token 归还。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举一个简单的例子，我们可以这么使用 Reserve 方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;r := limiter.Reserve()&lt;br/&gt;f !r.OK() {&lt;br/&gt;    &lt;span&gt;// Not allowed to act! Did you remember to set lim.burst to be &amp;gt; 0 ?&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;time.Sleep(r.Delay())&lt;br/&gt;Act() &lt;span&gt;// 执行相关逻辑&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;动态调整速率和桶大小&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Limiter 支持创建后动态调整速率和桶大小：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;SetLimit(Limit) 改变放入 Token 的速率&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SetBurst(int) 改变 Token 桶大小&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了这两个方法，可以根据现有环境和条件以及我们的需求，动态地改变 Token 桶大小和速率。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天我们总结了 Golang 官方限流器的使用方法，它是一种令牌桶算实现的限流器。其中 &lt;strong&gt;Wait/WaitN&lt;/strong&gt;，&lt;strong&gt;Allow/AllowN&lt;/strong&gt; 这两组方法在平时用的比较多，前者是消费Token时如果桶中Token不足可以让程序等待桶中新Token的放入（最好设置上等待时长）后者则是在桶中的Token不足时选择直接丢弃请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了Golang官方提供的限流器实现，Uber公司开源的限流器&lt;code&gt;uber-go/ratelimit&lt;/code&gt;也是一个很好的选择，与Golang官方限流器不同的是Uber的限流器是通过漏桶算法实现的，不过对传统的漏桶算法进行了改良，有兴趣的同学可以自行去体验一下。&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUzNTY5MzU2MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f4pGhLz2xEbRFHnAQon2QLYgbBibCJo1ibJHesLWshPJeRibateRtAqkaf6BgjlbhYiaxHLq6Zu07CRPw/0?wx_fmt=png&quot; data-nickname=&quot;网管叨bi叨&quot; data-alias=&quot;kevin_tech&quot; data-signature=&quot;分享软件开发和系统架构设计基础、Go 语言和Kubernetes。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;推荐阅读：&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>330f342cf92ebed3e6d5f24cc50c6a6d</guid>
<title>聊聊知乎订单系统迁移</title>
<link>https://toutiao.io/k/5rfvjrx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;本文主要介绍知乎订单系统后端语言栈的转型升级过程，包括其间踩过的一些坑和遇到的一些问题。一来是想通过本篇文章为其它应用服务转型提供借鉴经验，二来是总结对于订单系统的理解。鉴于文字功底不足，对于业务理解不充分的地方，欢迎留言交流。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;迁移背景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;随着知乎整体技术栈的变化，原有的 Python 技术栈逐渐被抛弃，新的 Go 和 Java 技术栈逐渐兴起。知乎交易系统的稳定性相比其它业务系统的稳定性重要很多，因为交易系统核心链路发生故障不仅会造成数据问题，还会造成严重的资损问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;随着公司业务的不断壮大发展，交易场景变得复杂，重构和优化难以避免，因为语言特性，Python 虽然开始撸代码很爽，但是后期的维护成本慢慢变高，不过 Python 在数据分析和人工智能方向上还是有很大优势的，只是在交易领域目前看起来不太合适。从技术生态上来说，用 Java 做交易系统会更有优势，所以接下来要说的知乎订单系统语言栈转型。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;另外一个因素是 Python 的 GIL 锁导致它无法发挥多核的优势，性能上受到很大限制，在实际情况中遇到过多次主线程被 hang 住导致的可用性故障，所以坚定决心来迁移掉旧系统。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;前期准备&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;12&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;工欲善其事，必先利其器。&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;语言栈转型首先要明确转型的三个开发流程，即 MRO (Migration, Reconstruction, Optimization)&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;迁移 就是把原语言代码照着抄一遍到新语言项目上，按照新语言的工程实现风格来做就可以。其间最忌掺杂代码优化和 bug 修复，会容易引起新的问题，增加验证代码的难度。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;重构 目的是提高项目代码的可维护性和可迭代性，让代码更优雅和易读懂，可以放到迁移完成来做。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;优化 通过在模块依赖、调用关系、接口字段等方面的调整来降低项目的复杂性，提高合理性。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于语言栈转型来说，迁移流程是肯定要做的，重构和优化如何选择，可以按模块划分功能拆成子任务来分别评估方案，参考依据为现有模块如果同时优化或重构带来的直接收益和间接收益有多少。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9692832764505119&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOO3NOzia3XAPaU46ThxHbBQJeRB7mib9QnwbahcGlxZOn4aGCdD5IMTdTz9IsicvFM0chXicYnA3quByw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;293&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在风险可控的前提下，成本与收益要互相权衡，一般会有两种方案可供参考：第一种是锁定需求，堆人力开发上线，一步到位；第二种则是小步快走，迭代上线，分批交付。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.37910085054678005&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOO3NOzia3XAPaU46ThxHbBQJojluRqC3gDpN9JrkfFzyAC7kFuZJhDrjJVlCQvSicA7gzzhhwWAoygw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;823&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;基于以上分析，在本次转型过程中，人力成本是一个更重要的因素，所以采用只迁移的方案，来压缩人力成本，降低 bug 引入风险的同时也具有很好的可测试性。并且为了不阻塞业务需求，采用小步快走的方式分批交付，以最长两周作为一个迭代周期进行交付。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;迁移方案&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;确定了交付方式，下面我们需要梳理当前系统中的功能模块，做好任务拆分和排期计划。知乎交易系统在迁移前的业务是针对虚拟商品的交易场景，交易路径比较短，用户从购买到消费内容的流程如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;在商品详情页浏览&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;生成订单进入收银台和用户支付&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;确认支付后订单交付&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用户回到详情页消费内容&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;特定商品的七天无理由退款&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当时订单系统支持的功能还不多，业务模型和订单模型没有足够地抽象，梳理订单系统业务如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5767397521448999&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOO3NOzia3XAPaU46ThxHbBQJqr55JS4IgVdytr0BVdsvw2vQrFuDyH57QoltcRWurwpicNVl2PNNoYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2098&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;完成了订单模块的拆分后，新老系统如何无缝切换？如何做到业务无感？如何保障交易系统稳定性？出现故障如何及时止损？基于上面讲述的原则，将整个系统的迁移划分成两个阶段，迁移前后的数据存储和模型都不变。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.34676434676434675&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOO3NOzia3XAPaU46ThxHbBQJNlAr1glsqxTBvicTyec7PZrDZyO30QLson3ib65xic1XALMQZmCJhSDxA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1638&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;接口验证&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;不论是在迁移的哪个阶段，总需要调整订单接口，可以从订单操作角度分为读操作和写操作，需要针对读接口和写接口做不同的验证方案。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;写操作可以通过白名单测试以及灰度放量的方式进行验证上线，将接口未预期异常输出到 IM 工具以得到及时响应。主要的写操作相关接口有：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;订单的创建接口。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;订单绑定支付单的提交接口。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用户支付后回调确认接口。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用户发起退款接口。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下图展示的是 AB 平台的流量配置界面：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.45636363636363636&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOO3NOzia3XAPaU46ThxHbBQJJPFMDkMeicbfRoTyXc5y4QZibM1OIysSVo0ib4CfIxjI9nGd2icITY548g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1650&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下图展示了部分交易预警通知消息：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0763116057233704&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOO3NOzia3XAPaU46ThxHbBQJpM4yKbxkzbOPP8RcnGljJYyr9bvtbWj9K7sXzfPOnT2OTZbgzo1jVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1258&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;读操作往往伴随在写操作中。我们利用平台的录制回放功能进行接口的一致性检查，通过对比得出差异排查问题。主要的读操作接口有：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;获取支付方式列表接口&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;获取订单支付履约状态接口&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;获取充值列表接口&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;批量查询用户新客状态接口&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下图展示的是流量录制回放系统的数据大盘：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4238358326756117&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOO3NOzia3XAPaU46ThxHbBQJsEo12l0ouVzZFUmRI7FoCUnzib9gz3ZziaT9HAcL9V0kiczJxLckABnNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1267&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;指标梳理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;监控是我们系统的『第三只眼』，可以及时反应系统的健康状况，及时发出告警信息，并帮助我们在出现故障时分析问题和快速缩小排查范围。硬件、数据库、中间件的监控已经在平台层得到支持，这里只需要梳理出应用的监控指标。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;日志监控：请求日志、服务端的错误日志。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;订单业务指标&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;下单量、成单量、掉单量&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;单量环比数据&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;首次履约异常量&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;补偿机制履约量&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;各通知事件 P95 耗时&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;成功履约 P95 耗时&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;履约准时率/成功率&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支付业务指标&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用户购买完整耗时 P95。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;可用性保障&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在整个交付的过程中，转型前后对 SLA 要提供一致的可用性保障，可以看看下面的几个衡量标准：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.38011049723756907&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOO3NOzia3XAPaU46ThxHbBQJ85icUvoVtb0AxtlKZAdaqGbGvgFOXV0yQVArf8pPkKYoMXXszuJc2hQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1810&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;一般 3 个 9 的可用性全年宕机时间约为 8.76 小时，不同系统不同用户规模对于系统可用性的要求不一样，边缘业务的要求可能会低一些，但是对于核心链路场景 TPS 可能不高，但是必须要求保证高可用级别。如何保证或者提升服务的 SLA 是我们接下来要探讨的内容，一般有下面两个影响因素：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;也就是说我们要尽可能地降低故障频率，并确保出现故障后可以快速恢复。基于这两点我们在做系统平稳过渡时，要充分测试所有 case ，并且进行灰度方案和流量录制回放，发现异常立即回滚，定位问题解决后再重新灰度。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;MTTR 快速响应&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;持续监控&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;感知系统稳定性的第一步就是监控，通过监控来反映系统的健康状况以及辅助定位问题，监控有两个方向：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第一个方向是指标型监控，这里监控是在系统代码中安排各种实时打点，上报数据后通过配置报表呈现出来的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;基础设施提供的机器监控以及接口粒度的响应稳定性监控。&lt;/p&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;物理资源监控，如 CPU、硬盘、内存、网络 IO 等。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;中间件监控，消息队列、缓存、Nginx 等。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;服务接口，HTTP、RPC 接口等。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数据库监控，连接数、QPS、TPS、缓存命中率、主从延迟等。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;业务数据层面的多维度监控，从客户端和服务端两个角度来划分。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;p&gt;从客户端角度来监控服务端的接口成功率，支付成功率等维度。&lt;/p&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;从服务端角度从单量突变、环比变化、交易各阶段耗时等维度持续监控。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;以上两点基于公司的 statsd 组件进行业务打点，通过配置 Grafana 监控大盘实时展示系统的健康状况。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6001540832049307&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOO3NOzia3XAPaU46ThxHbBQJ7wlJ4GPuHPBq4qgicO76qYfKA8TeMzaoNIr1wPCOg1V0jjPzfRiaUKmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2596&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第二个方向是日志型监控，这主要依赖公司的 ELK 日志分析平台和 Sentry 异常捕获平台。通过 Sentry 平台可以及时发现系统告警日志和新发生的异常，便于快速定位异常代码的发生位置。ELK 平台则可以将关键的日志详细记录下来以便于分析产生的场景和复现问题，用来辅助修复问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;异常告警&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4759100642398287&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOO3NOzia3XAPaU46ThxHbBQJxoZb3Qk58ibGuv8mflJ3iaDlVcSzOia8OBic1FhXvhviaQObSa4ISQwun4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3736&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;基于以上实时监控数据配置异常告警指标，能够提前预知故障风险，并及时发出告警信息。然而达到什么阈值需要告警？对应的故障等级是多少呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;首先我们要在交易的黄金链路上制定比较严格的告警指标，从下单、提单、确认支付到履约发货的每个环节做好配置，配置的严重程度依次递增分为 Info、Warning、Critical。按照人员类别和通知手段来举例说明告警渠道：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.34558823529411764&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOO3NOzia3XAPaU46ThxHbBQJjRrgH3K2P6cpd6QBhYsnT8gWDdGdnXu6zktKeubjsoIiaV2V8TLjJQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1360&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;IM 中的预警消息截图如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.991701244813278&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOO3NOzia3XAPaU46ThxHbBQJDrYJCGNJ0tW7GWStoaXib0IzArosWYOppt25hgjzk727CDquXyQtjsg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1446&quot;/&gt;&lt;/p&gt;&lt;p&gt;订单主要预警点如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;核心接口异常&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;掉单率、成单率突变&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;交易各阶段耗时增加&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用户支付后履约耗时增加&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;下单成功率过低&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;MTBF 降低故障率&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;系统监控告警以及日志系统可以帮我们快速的发现和定位问题，以及时止损。接下来说的质量提升则可以帮助我们降低故障发生率以避免损失，主要从两个方向来说明：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;规范化的验收方案&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.34227330779054915&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOO3NOzia3XAPaU46ThxHbBQJ5KXgcWbGKpbIwAibqUWBH53QYbJGPR2jjSSh23CEfQlJQDY3brDkAhw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1566&quot;/&gt;&lt;/p&gt;&lt;p&gt;① 开发完成包括逻辑功能和单元测试，优先保证单测行数覆盖率再去保证分支覆盖率。然后在联调测试环境中自测，通过后向 QA 同学提测。&lt;/p&gt;&lt;p&gt;② QA 同学可以在测试环境下同时进行功能验收和接口测试，测试通过后便部署到 Staging 环境。&lt;/p&gt;&lt;p&gt;③ 在 Staging 环境下进行功能验收并通过。&lt;/p&gt;&lt;p&gt;④ 灰度交付以及双读验证可以根据实际情况选择性使用。&lt;/p&gt;&lt;p&gt;⑤ 上线后需要最后进行回归测试。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;统一的编码规约以及多轮 CR 保障&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;代码上线前一般至少要经过两次代码评审，太小的 MR 直接拉一位同事在工位 CR 即可，超过百行的变更需要拉会研讨，两次评审的关注点也不同。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第一次评审应关注编码风格，这样可以避免一些因在写法上自由发挥而带来的坑，以此来沉淀出组内相对统一的编码规约，在编码的稳定性上建立基本的共识，提升代码质量。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第二次评审应关注代码逻辑，这里有个需要注意的点是，如果明确只做迁移，那么其间发现旧逻辑难理解的地方不要随便优化，因为在不了解背景的情况下很有可能会写一个 bug 带上线（这种事见过好几次）。另外这样也好去对比验证，验证通过上线后再去优化。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;只有通过明确目的和流程并且遵循这个流程做，才能更快更好地交付有质量的代码。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;一致性保障&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;每一个微服务都有自己的数据库，微服务内部的数据一致性由数据库事务来保障，Java 中采用 Spring 的 @Transtaction注解可以很方便地实现。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;而跨微服务的分布式事务，像 支付、订单、会员三个微服务之间采用最终一致性，类似 TCC 模式的两阶段提交，订单通过全局发号器生成订单 ID，然后基于订单 ID 创建支付单，如果用户支付后订单会变更自身状态后通知会员微服务，履约成功则事务结束，履约失败则触发退款，如果用户未支付，那么订单系统将该订单以及支付单做关单处理。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对应一致性保障，我们对订单接口做了两个方面的处理：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;分布式锁&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于上游的支付消息监听、支付 HTTP 回调、订单主动查询支付结果三个同步机制分别基于订单 ID 加锁后再处理，保证同步机制不会被并发处理。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;接口幂等&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;加锁后对订单状态做了检查，处理过则响应成功，否则处理后响应成功，保证上游消息不会被重复处理。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;订单对于下游的履约，是通过订单 ID 作为幂等 key 来实现的，以保证同一个订单不会被重复履约，并且通过 ACK 机制保证履约后不会再重复调到下游。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4052346570397112&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOO3NOzia3XAPaU46ThxHbBQJGVjmX0onY077uLq5FP4ibNMib2gibu9mVdemoBOQ1DrarmUpJhdqtmVBQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1108&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其中分布式锁采用 etcd 锁，通过锁租约续期机制以及数据库唯一索引来进一步保障数据的一致性。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;补偿模式&lt;/strong&gt;，虽然我们通过多种手段来保证了系统最终一致，但是分布式环境下会有诸多的因素，如网络抖动、磁盘 IO、数据库异常等都可能导致我们的处理中断。这时我们有两种补偿机制来恢复我们的处理：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;带惩罚机制的延时重试&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果通知中断，或者未收到下游的 ACK 响应，则可以将任务放到延迟队列进行有限次的重试，重试间隔逐次递增。最后一次处理失败报警人工处理。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;定时任务兜底&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为了防止以上机制都失效，我们的兜底方案是定时扫描异常中断的订单再进行处理。如果处理依然失败则报警人工处理。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;事后总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;目标回顾&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;目标一：统一技术栈，降低项目维护成本。目标结果是下线旧订单系统。&lt;/p&gt;&lt;p&gt;目标二：简化下单流程，降低端接入成本。目标结果是后端统一接口，端上整合 SDK。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;执行计划&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;迁移的执行总共分成了三个大阶段：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第一阶段是迁移逻辑，即将客户端发起的 HTTP 请求转发到 RPC 接口，再由新系统执行。第一阶段做到所有的新功能需求都在新系统上开发，旧系统只需要日常维护。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第二阶段是通过和客户端同学合作，迁移并整合当前知乎所有下单场景，提供统一的下单购买接口，同时客户端也统一提供交易 SDK，新组件相对更加稳定和可监控，在经过灰度放量后于去年底完全上线。第二阶段做到了接口层的统一，更利于系统的维护和稳定，随着新版的发布，旧接口流量已经变得很低，大大降低了下阶段迁移的风险。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第三阶段是旧 HTTP 接口迁移，由新系统承载所有端的请求，提供相同规格的 HTTP 接口，最后通过修改 NGINX 配置完成接口迁移。第三阶段迁移完成后旧系统最终实现了下线。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;执行结果&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;截至此文撰写时间，语言栈已经 100% 迁移到新的系统上，旧系统已经完全下线，总计下线 12 个系统服务， 32 个对外 HTTP 接口，21 个 RPC 接口，15 个后台 HTTP 接口。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;根据 halo 指标，迁移前后接口 P95 耗时平均减少约 40%，硬件资源消耗减少约 20%。根据压测结果比较，迁移后支撑的业务容量增长约 10 倍。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;系统迁移完成只是取得了阶段性的胜利，接下来系统还需要经过一些小手术来消除病灶，主要是以下几点：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;不断细化监控粒度，优化告警配置，继续提高服务的稳定性。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;对于 Python 的硬翻译还需要不断重构和优化，这里借鉴 DDD 设计思想。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;完善监控大盘，通过数据驱动来运营优化我们的流程。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;项目复盘总结以及业务普及宣讲，提升人员对于业务细节的认知。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;问题整理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;迁移总是不能一帆风顺的，其间遇到了很多奇奇怪怪的问题，为此头发是真没少掉。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;问题 1：迁移了一半新需求来了，又没有人力补上来怎么办？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;迁移后再做重构和优化过程，其实很大一部分考量是因为人力不足啊，而且现状也不允许锁定需求。那么只能写两遍了，优先支持需求，后面再迁移。如果人力充足可以选择一个小组维护新的系统一个小组维护旧的系统。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;问题 2：我明明请求了，可日志怎么就是不出来呢？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;不要怀疑平台的问题，要先从自身找问题。总结两个原因吧，一个是新旧系统的迁移点太分散导致灰度不好控制，另一个是灰度开关忘记操作了，导致流量没有成功导到新系统上。这里要注意一个点就是在迁移过程中要尽可能的快速交付上线。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;问题 3：公司 Java 基础服务不够完善，很多基础平台没有支持怎么办?&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;于是自研了分布式延迟队列、分布式定时任务等组件，这里就不展开聊了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;问题 4：如何保证迁移过程中两个系统数据的一致性？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;首先我们前面讲到的是系统代码迁移，而数据存储不变，也就是说两个系统处理的数据会存在竞争，解决的办法是在处理时加上分布式锁，同时接口的处理也是要幂等的。这样即使在上下游系统做数据同步的时候也能避免竞争，保证数据的一致性。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;就用户支付后支付结果同步到订单系统这一机制来说，采用推拉的机制。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;① 用户支付后订单主动轮询支付结果，则是在主动拉取数据。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;② 支付系统发出 MQ 消息被订单系统监听到，这是被动推送。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;③ 支付成功后触发的订单系统 HTTP 回调机制，这也是被动推送。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;以上三种机制结合使用使得我们系统数据一致性有一个比较高的保障。我们要知道，一个系统绝非 100% 可靠，作为交易支付的核心链路，需要有多条机制保证数据的一致性。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;问题 5：用户支付后没有收到会员权益是怎么回事？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在交易过程中，订单、支付、会员是三个独立的服务，如果订单丢失了支付的消息或者会员丢失了订单的消息都会导致用户收不到会员权益。上一个问题中已经讲到最终一致性同步机制，可能因为中间件或者网络故障导致消息无法同步，这时可以再增加一个补偿机制，通过定时任务扫描未完成的订单，主动检查支付状态后去会员业务履约，这是兜底策略，可保障数据的最终一致。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;业务沉淀&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;从接收项目到现在也是对订单系统从懵懂到逐渐加深理解的一个过程，对于当前交易的业务和业务架构也有了一个理解。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;交易系统本身作为支付系统的上层系统，提供商品管理能力、交易收单能力、履约核销能力。外围业务子系统主要关注业务内容资源的管理。业务的收单履约管理接入交易系统即可，可减轻业务的开发复杂度。收单流程展示如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;业务定制商品详情页，然后通过详情页底栏调用端能力进入订单收银台。在这里客户端需要调用业务后端接口来获取商品详情，然后调用交易底栏的展示接口获取底部按钮的情况。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用户通过底部按钮进入收银台后，在收银台可以选择支付方式和优惠券，点击确认支付调起微信或者支付宝付款。收银台展示以及获取支付参数的接口由交易系统提供。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;订单后台确认收款后会通知业务履约，用户端会回到详情页，用户在详情页进入内容播放页享受权益。履约核销流程是业务后端与交易系统后端的接口调用来完成的。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.693200663349917&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOO3NOzia3XAPaU46ThxHbBQJrcfXyaZT7K80Q5wXsWMuegAADKfHOOQDicWU9etaXMoIMNhvdBqLyJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1206&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;现在知乎站内主要是虚拟商品的交易，一个通用的交易流程如下图：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7380281690140845&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOO3NOzia3XAPaU46ThxHbBQJ9oyLRibzlAF9sWbbicMnSh3tkIE3w6oXrsUNtUicIGoEMoSzzdnZwKqyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1420&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;用户经历了从商品的浏览到进入收银台下单支付，再回到内容页消费内容。随着业务的发展，不同的交易场景和交易流程叠加，系统开始变得复杂，一个交易的业务架构慢慢呈现。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6779026217228464&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOO3NOzia3XAPaU46ThxHbBQJ2VTxk3ibuJjQl8w1x0Nstdy8agrhcMCTibylLAO6epgiahsnIO0Fk1NTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2136&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;订单系统主要承载知乎站内站外的各种交易服务，提供稳定可靠的交易场景支撑。主要分为以下几个部分：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;首先产品服务层是面向用户能感受到的交互界面，提供对于这些页面的统一下单支付 API 网关。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;然后是订单服务层，由上层网关调用，提供着不同场景下的交易服务支撑。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;再往下是订单领域层，承载订单最核心逻辑代码，首先是用户购买需要的算价聚合，然后是管理订单模型的交易聚合，最后是买完商品后的履约处理的交付聚合。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;最底层是基础支撑服务层，主要是提供基本的服务支持以及交易依赖的一些服务。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;最后是运营服务，提供交易相关的后台功能支持。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;方法论实践&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;凡此以上，不论系统迁移方案还是架构理解都归结于参与人员的理解与认知，一个优秀的方案或合适的架构不是设计出来的，是迭代出来的。人的认知也是这样，需要不断的迭代升级，和很多的方法论一样，PDCA 循环为我们提炼了一个提升路径。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.985663082437276&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOO3NOzia3XAPaU46ThxHbBQJG5Qdab1H1Rdq44tUGSSiaL7H4GnofOgWNrz1Qp5jrAniccbfl7mIQkVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;279&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Plan 计划，明确我们迁移的目标，调研现状指定计划。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Do 执行，实现计划中的内容。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Check 检查，归纳总结，分析哪些做好了，还有什么问题。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Action 调整，总结经验教训，在下一个循环中解决。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;很多时候，也许你只做了前两步，但其实后两步对你的提升会有很大帮助。所以一个项目的复盘，一次 Code Review 很重要，有语言的交流和碰撞才更容易打破你的固有思维，做到业务认知的提升。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;参考文章&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;https://mp.weixin.qq.com/s/eKc8qoqNCgqrnont2nYNgA&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;https://zhuanlan.zhihu.com/p/138222300&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;https://blog.csdn.net/g6U8W7p06dCO99fQ3/article/details/103415254&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;招聘信息&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;知乎技术团队大量岗位持续招聘中，欢迎感兴趣的同学加入我们，可投简历至：&lt;span&gt;luohuijuan@zhihu.com&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;作者简介&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;42&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;张旭，知乎后端开发工程师，主要负责知乎商业基础相关系统研发，专注于电商交易营销领域。&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;参考阅读&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;高可用架构欢迎技术架构领域原创文章，欢迎通过公众号菜单「联系我们」进行投稿。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.55546875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8XkvNnTiapOMRvCRibd5Rxf4W9RY6pEILqJypJHyaNfBqIlzib26QKYtxgwGAeZcAhdFMYv3btF0DQwzD8Hh2a5gA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;2021年GIAC调整到7月30-31日在深圳举行，点击阅读原文了解更多详情。&lt;/span&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>