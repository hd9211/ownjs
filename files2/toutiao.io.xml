<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>2dd63a1b544a8398cb3cff7a6c05cd5c</guid>
<title>微服务架构下 CI/CD 如何落地</title>
<link>https://toutiao.io/k/303m5ez</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot;&gt;&lt;blockquote&gt;本文系云原生应用最佳实践杭州站活动演讲稿整理。杭州站活动邀请了 Apache APISIX 项目 VP 温铭、又拍云平台开发部高级工程师莫红波、蚂蚁金服技术专家王发康、有赞中间件开发工程师张超，分享云原生落地应用的经验心得，以下是莫红波《微服务架构下 CI/CD 如何落地》分享内容。&lt;/blockquote&gt;&lt;p&gt;莫红波，又拍云平台开发部高级工程师，目前专注于容器及虚拟化技术在又拍云的私有云实践，主要负责又拍云容器云的设计和开发工作。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-be6b7e97fb14baa6e5f2469bc106ef5f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;818&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-be6b7e97fb14baa6e5f2469bc106ef5f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;818&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-be6b7e97fb14baa6e5f2469bc106ef5f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-be6b7e97fb14baa6e5f2469bc106ef5f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;大家好，今天分享的主题是《微服务架构下 CI/CD 如何落地》，围绕以下两部分展开：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;理论篇，讨论从单体到微服务的过程中会面临怎样的挑战，以及微服务的测试模型&lt;/li&gt;&lt;li&gt;实践篇，围绕集成测试环境的服务发现需要怎么做，如何落地持续交付和持续部署&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;背景&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;或许大家对于互联网公司的共同印象是 996，对于我个人而言，互联网公司还有另一个特点，那就是经常需要拥抱变化。在互联网公司，新产品上线、下线、调整，这都是很家常便饭的事情。在这种情况下，一个好的松耦合的架构就显得尤为重要。&lt;/p&gt;&lt;p&gt;刚好我最近就有遇到这个问题，我在做的项目，账号这块是对标 GitHub 的注册制账号机制的。原本的需求是用户注册我们的平台，注册完成后可以创建一个属于自己的团队，并将其他人拉入自己的团队。但是当我们做完这部分内容后发现，客户还是更偏好「账号+子账号」的模式，公司一个总的账号，所有员工单独开子账号进行关联。这让我们已经做好的项目变得非常尴尬，需要立即拥抱变化，需要根据最新的需求进行调整。这时，我就发现拥有一套松耦合的架构的重要性，比如账号这一部分，如果把它单独拎出来，做好足够的抽象，提供必要的对外接口，可能会更加灵活，扩展性更加好。&lt;/p&gt;&lt;p&gt;&lt;b&gt;那怎样拥有一套松耦合的架构？有什么好的方案呢？在我看来有两个，一个是几年前出现的 SOA，即将服务进行单独化，将每一块都进行拆分；另一个就是最近几年火热的微服务了。&lt;/b&gt;我认为，微服务跟 SOA 其实是一回事，只不过微服务比 SOA 拆分粒度更细，功能也更小。&lt;/p&gt;&lt;p&gt;在调研微服务过程中，很多人会有疑问：“我们是一个很小的团队，小团队适不适合上微服务呢？”。因为上微服务就意味着一个服务可能就会被拆分成 10 个、20 个甚至更多个的服务，这就让小团队不得不去考虑自己的测试、部署、更新成本是不是会翻很多倍。&lt;/p&gt;&lt;p&gt;那么我对于“小团队适不适合上微服务”这个问题的答案是什么呢？我认为是完全可以上的，不过你需要注意一点：做好自动化，能交给自动化来实现的，就不要人工介入了。&lt;/p&gt;&lt;p&gt;在聊如何做自动化集成测试（CI）之前，我先和大家谈一谈从单体如何到微服务，服务是如何拆分的，以及微服务的测试一般是怎么做的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;从单体到微服务&lt;/b&gt;&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-558bbb277f5d33d1b8b622b521615f7e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;869&quot; data-rawheight=&quot;496&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-558bbb277f5d33d1b8b622b521615f7e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;869&quot; data-rawheight=&quot;496&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-558bbb277f5d33d1b8b622b521615f7e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-558bbb277f5d33d1b8b622b521615f7e_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;如上图所示，我们可以看到图左边是一个单体服务，右边则是经过微服务拆解后的。我们可以看到它有 4 个特点：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;根据不同领域拆分&lt;/li&gt;&lt;li&gt;服务之间通过网络协议通信&lt;/li&gt;&lt;li&gt;拥有独立的数据库&lt;/li&gt;&lt;li&gt;拥有特定对外开放的接口&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-701694c6721d9aae9dc6020cc4b120c7_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;973&quot; data-rawheight=&quot;512&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-701694c6721d9aae9dc6020cc4b120c7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;973&quot; data-rawheight=&quot;512&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-701694c6721d9aae9dc6020cc4b120c7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-701694c6721d9aae9dc6020cc4b120c7_b.jpg&quot;/&gt;&lt;figcaption&gt;△ 微服务测试模型&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;我们都知道，如果需要一个服务能够稳定运行，那测试肯定是少不了的。而就像我们微服务化有一套理论一样，微服务测试也拥有属于自己的金字塔理论：最底层是单元测试，成本相对较低，像我们在 API 认证部分做的签名校验模块，它一般不需要依赖其他东西，因此测试效率也比较高；第二层是集成测试，这一层你就必须要依赖一些第三方的服务模块或者组件，比如我们一般会用到数据库的测试，就属于集成测试的范畴；第三层是 e2e 测试，它会模拟客户端的行为来进行测试，大家也许都接触过这类测试，像K8S 就有一个 e2e 测试，当你去申请 CNCF 的一致性认证时，就需要通过官方提供的 e2e 测试；最上层是 UI 测试，比如对于页面的点击调整是否符合预期，这部分我们现在做的比较弱，还处在人工模式下，但我们也在努力将它更新成自动化。&lt;/p&gt;&lt;p&gt;从这个微服务测试金字塔我们可以看到，越靠近底层成本越低，你只需要几行代码就能完成，效率也非常高。同时越底层它对于三方或组件的依赖也越低，自动化也就越简单。到这里可能就有人想问：“既然越底层的成本越低，那我们能不能只跑单元测试？”在解答这个问题前，大家先看下面这张图。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b4e83ade2740d32abcf00a40d0725b82_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;957&quot; data-rawheight=&quot;540&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-b4e83ade2740d32abcf00a40d0725b82_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;957&quot; data-rawheight=&quot;540&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-b4e83ade2740d32abcf00a40d0725b82_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-b4e83ade2740d32abcf00a40d0725b82_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这两扇窗户，每一扇单独存在的时候都是完好的窗户，可以正常开合。但是两个都安装到墙上后就没有办法正常开合。这就是我们不能只跑单元测试的原因了，不跑集成测试就无法发现一些问题。同理不跑单元测试也会有一些无法发现的问题，所以&lt;b&gt;我们在跑测试的时候，集成测试和单元测试，一项都不能少。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;那具体实践的时候要如何做呢，我推荐大家分成两步来进行：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;第一步是将底子打好：你需要对你的的微服务进行单元化测试，编写单元化的测试用例，然后再强化集成测试。没有好底子的微服务是不可靠的，任何时候都可能会出问题，而且出问题后的排查会非常费时。&lt;/li&gt;&lt;li&gt;第二步是自动化的持续集成环境：将能够自动化的部分全部进行自动化，减少人工的介入。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;GitLab/CI&lt;/b&gt;&lt;/p&gt;&lt;p&gt;自动化集成环境这块目前已经有很多的开源方案了，比如常见的 Jenkins，还有 GitLab。我们选择的是 GitLab，或者说是选择了 GitLab/CI，选择它的原因有以下几点：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;统一的 web 页面&lt;/li&gt;&lt;li&gt;可以再 MR 中跳转查看&lt;/li&gt;&lt;li&gt;Pipeline 编排直观展示&lt;/li&gt;&lt;li&gt;所有操作都在项目中搞定&lt;/li&gt;&lt;li&gt;GitLab 官方支持&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;GitLab WorkFlow&lt;/b&gt;&lt;/p&gt;&lt;p&gt;既然我们选择使用了 GitLab，那我们内部就会严格遵守 GitLab 的 WorkFlow。WorkFlow 主要分为两个部分。&lt;/p&gt;&lt;p&gt;第一部分是面向代码仓库。代码仓库中，我们一般会有三类分支，第一类分支是 master 分支，一般只会有一个，我们会定义 master 分支，并基于这个分支进行线上版本的发布。第二类分支是 develop 分支，一般也只会有一个，develop 分支是从 master 分支中 checkout 出来的，功能比 master 领先，包含一些已经完成功能开发，但是还没有发布的功能。第三类分支是 feature 分支，特性分支，一般会有很多个，新功能都会在这个分支上进行开发，往往一个功能对应一个 feature 分支。最后一类是 hotfix 分支，这个就比较常见了，线上发布后，如果发现了一个需要紧急修复的bug，这时你就可以在 master 分支上 checkout 出来一个 hotfix 分支，把代码改掉。不过进行这个操作时你需要注意，master 分支和 develop 分支都需要进行该 commit 合并，否则就不能算完成了 bug 修复。&lt;/p&gt;&lt;p&gt;第二部分与 CI/CD 有关。以我们的流程举例，研发的同学提交代码到 GitLab 仓库，之后 GitLab 会触发事先约定好的 CI 的 pipeline 进行测试和构建。等待测试和构建成功后再进行 code review 的确认，确认无误后会合并到 develop 分支并最终合并到 master 分支进行发布。这就是 GitLabCI 的一个配置，总结来看可以划分为下图的四个阶段。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-dc4e1ba58791fc23afd303818c514a19_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;560&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-dc4e1ba58791fc23afd303818c514a19_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;560&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-dc4e1ba58791fc23afd303818c514a19_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-dc4e1ba58791fc23afd303818c514a19_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;下图是配置文件对应的 pipeline 的展示，大家可以看一下。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-4e3aa1ed965d9a696fdc612d2de97c33_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;497&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-4e3aa1ed965d9a696fdc612d2de97c33_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;497&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-4e3aa1ed965d9a696fdc612d2de97c33_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-4e3aa1ed965d9a696fdc612d2de97c33_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;&lt;b&gt;微服务下的场景变形&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;其实到目前为止的方案，已经是微服务没有大热前的完备方案了。如果你想要将方案运用到微服务的集成测试里，你还需要做一些变形，不妨参考下图中所示的又拍云现在使用的整套流程。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-ecf255264c307d4e95fcae4ff2072e5e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;499&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-ecf255264c307d4e95fcae4ff2072e5e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;499&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-ecf255264c307d4e95fcae4ff2072e5e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-ecf255264c307d4e95fcae4ff2072e5e_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;从图中可以看到，我们目前使用的整套流程相比标准的其实有做一些小的变形，变形主要集中在中间的集成测试环境这一块，我们将每个服务器都部署在了集成环境内，使集成环境变成一个准发布环境。具体流程是，当我们的创建 projectA 后，由它来 push 代码，完成后触发 CI，也就是在 GitLab runner 上进行测试。&lt;/p&gt;&lt;p&gt;在跑测试的过程中，因为 A 服务需要调用 B 和 C 服务，所以通过 API 去请求集成环境中的对应服务。如果测试完成后没有问题，则合并到主线。再通过在 master 分支打 tag 的方式来触发容器构建并推送到 Harbor 镜像仓库。最后我们会做一个线上 release。这个就是我们的大致流程了。&lt;/p&gt;&lt;p&gt;那么接下来我们来具体看一下变形中会遇到的问题。&lt;/p&gt;&lt;p&gt;&lt;b&gt;服务发现&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在微服务场景下的变形中遇到了很多问题，我觉得其中值得注意的是“服务发现”。比如我们现在有这样一个场景，A 服务在跑测试时需要依赖 B 服务和 C 服务，面对这个需求，在没有引入 Kubernetes 之前，我们可以通过使用一台共用机器，将服务都布置到这台机器上，并在测试代码里写死 IP 地址，让每一次测试都在这个环境内跑。但这个方法会有下面四个无法忽视的问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;服务更新延迟&lt;/li&gt;&lt;li&gt;环境权限混乱&lt;/li&gt;&lt;li&gt;人工操作容易出错&lt;/li&gt;&lt;li&gt;维护成本过高&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;因此我们引用了 Kubernetes Service 的方案进行优化。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Kubernetes Service&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8a70d364f628921d14ad227f39b37f34_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;502&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-8a70d364f628921d14ad227f39b37f34_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;502&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-8a70d364f628921d14ad227f39b37f34_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-8a70d364f628921d14ad227f39b37f34_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;Kubernetes Service 的流程大家可以大概看一下。我们先定义一个 Service， 我们这边创建的 ClusterIP 类型的，定义了暴露端口 8000，目标端口 8000，协议是 TCP，标签选择器是 app=holdon。通过这种方式，我们可以把一组相同功能的服务，绑定在同一个 Service 下。在 Kubernetes 集群内，定义好 Service 后，会提供内部的 DNS 解析，你可以通过一个固定的域名访问指定的 Service。这样当在跑测试的时候就可以通过这个域名加对应端口，调用到对应服务了。&lt;/p&gt;&lt;p&gt;&lt;b&gt;持续交付&lt;/b&gt;&lt;/p&gt;&lt;p&gt;持续交付（英语：Continuous Delivery，缩写为 CD）。每个项⽬都要有⼀个 Dockerfile，提供了服务运⾏所需的环境，以及服务对应的软件包。当需要发版本的时候，我们会在主线上打上⼀个 tag，触发镜像构建，然后推送到 Harbor 镜像仓库。其中，这个 tag 也会对应到镜像的版本号。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8ecd0a7ffe6f713ccc7fbbff59694357_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;894&quot; data-rawheight=&quot;354&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-8ecd0a7ffe6f713ccc7fbbff59694357_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;894&quot; data-rawheight=&quot;354&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-8ecd0a7ffe6f713ccc7fbbff59694357_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-8ecd0a7ffe6f713ccc7fbbff59694357_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;上图是我们的 CD 流程大家可以参考看一下。需要提一下的是，我们引用 Harbor 的原因是因为它相对官方的 Registry 更安全。大家应该都知道，官方的 Registry 本身不带权限校验，当你公司内部使用的时候，这个问题会导致你的镜像有被其他部门的人覆盖掉的可能性，所以我们引入了 Harbor。但这里也有一个问题，使用同一个 tag 去推依然会被覆盖的情况。不过好歹做到了小组和小组之间、部门和部门之间的隔离。&lt;/p&gt;&lt;p&gt;&lt;b&gt;持续部署&lt;/b&gt;&lt;/p&gt;&lt;p&gt;持续部署（英语：Continuous deployment，缩写为 CD），目前这块，在实践过程中，我们是只针对集成测试环境，线上更新还是走常规的流程。给项⽬增加⼀个 k8s-deploy.yaml 的⽂件，⾥⾯包含了服务相关的配置、部署⽅式、访问⽅式等等，等待镜像构建完成后，apply 该⽂件就可以了 。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-63dc2be0e4384be9dc05a9044379ed20_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;981&quot; data-rawheight=&quot;402&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-63dc2be0e4384be9dc05a9044379ed20_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;981&quot; data-rawheight=&quot;402&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-63dc2be0e4384be9dc05a9044379ed20_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-63dc2be0e4384be9dc05a9044379ed20_b.jpg&quot;/&gt;&lt;figcaption&gt;△ 持续部署流程图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;回顾&lt;/b&gt;&lt;/p&gt;&lt;p&gt;现在我们再回到服务变形的流程图来看一下，当我们有 A、B、C 三个服务，且 A 服务在测试时需要调用集成环境内的 B 服务与 C 服务时，可以通过 K8S 提供的内部域名进行访问。等待整块测试跑完后，我们在主线上打 tag，让 CI 去帮执行 image build 构建镜像并推送到 Harbor 仓库。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-93ddcc9c8efae07cd91613d1e5ed7800_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;516&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-93ddcc9c8efae07cd91613d1e5ed7800_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;516&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-93ddcc9c8efae07cd91613d1e5ed7800_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-93ddcc9c8efae07cd91613d1e5ed7800_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;其中涉及到的准发布环境，可以通过 kubectl apply 的方式进行部署。由于线上环境更复杂，推荐大家通过自研的容器云平台来进行操作，我们就是这么处理的，通过云平台发布，功能更加全面安全，更加符合线上部署的流程。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;成果展示&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;最后，跟大家分享下最近正在做的项目的情况。从 2019 年 12月 开始到现在，我们每天基本保持在一个较高的 commit 数上，而这其中一共进行了大约 4500 次的测试。想象下，如果没有这套自动化持续集成环境，测试需要怎么来进行，需要投入人力资源。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-30d3b7280a9ce3598a97476f2fcf06c4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;521&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-30d3b7280a9ce3598a97476f2fcf06c4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;521&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-30d3b7280a9ce3598a97476f2fcf06c4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-30d3b7280a9ce3598a97476f2fcf06c4_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;现场演讲视频观看及PPT下载：&lt;/b&gt;&lt;/p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.upyun.com/opentalk/453.html&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic1.zhimg.com/v2-36d256b830f5f0beb3ffab6467061974_180x120.jpg&quot; data-image-width=&quot;960&quot; data-image-height=&quot;540&quot; class=&quot;LinkCard LinkCard--hasImage&quot;&gt;&lt;span class=&quot;LinkCard-backdrop&quot;/&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;微服务架构下 CI/CD 如何落地&lt;/span&gt;&lt;span class=&quot;LinkCard-meta&quot;&gt;&lt;span&gt;​&lt;svg class=&quot;Zi Zi--InsertLink&quot; fill=&quot;currentColor&quot; viewbox=&quot;0 0 24 24&quot;&gt;&lt;path d=&quot;M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;www.upyun.com&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-imageCell&quot;&gt;&lt;img class=&quot;LinkCard-image LinkCard-image--horizontal&quot; alt=&quot;图标&quot; src=&quot;https://pic1.zhimg.com/v2-36d256b830f5f0beb3ffab6467061974_180x120.jpg&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f2f9681dbbf465a1da86ec118bb00bbb</guid>
<title>压箱底笔记：Promise 和 Async/await 的理解和使用</title>
<link>https://toutiao.io/k/iegr5g1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.2778649921507064&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/WYoaOn5t0APOE4dXIpvXLgmGfqHMfYFF8pRd3Q1wvd1GZNzn7Omibswzysa3wwkIpJhz7zic90hysZ13icEic5ib9xQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;637&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;以前学习写的笔记，感觉还不错，现在发出来，希望对你有帮助。如果文章对你有所启发和帮助，可以『一键三连』。哦，对了，我已经脱发了...😭😭&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;目录&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;1. 前置知识&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;1.1 区别实例对象与函数对象&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;1.2 两种类型的回调函数&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;1.3 JS的error处理&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;2. Promise 是什么？&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;2.1 理解&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;2.2 Promise的状态改变&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;2.3 Promise基本流程&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;2.4 Promise的基本使用&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;3. 为什么要用Promise？&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;3.1 指定回调函数的方式更加灵活&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;3.2 支持链式调用，可以解决回调地狱问题&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;4. Promise的API说明&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;4.1 API 说明&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;4.2 Promise的几个关键问题&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;5. async与await&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 前置知识&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1.1 区别实例对象与函数对象&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实例对象：&lt;code&gt;new&lt;/code&gt; 函数产生的对象, 称为实例对象, 简称为对象&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;函数对象：将函数作为对象使用时, 简称为函数对象&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;Fn&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{}&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; fn = &lt;span&gt;new&lt;/span&gt; Fn() &lt;span&gt;// fn为实例对象&lt;/span&gt;&lt;br/&gt;Fn.bind({}) &lt;span&gt;// Fn为函数对象&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1.2 两种类型的回调函数&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同步回调&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;理解：立即执行, 完全执行完了才结束, 不会放入回调队列中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;例子: 数组遍历相关的回调函数 / Promise 的 excutor 函数&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;异步回调&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;理解：不会立即执行, 会放入回调队列中将来执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;例子：定时器回调 / ajax 回调 / Promise 的成功|失败的回调&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; arr = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;]&lt;br/&gt;arr.forEach(&lt;span&gt;&lt;span&gt;item&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;console&lt;/span&gt;.log(item)) &lt;span&gt;// 同步回调, 不会放入回调队列, 而是立即执行&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;forEatch()之后&#x27;&lt;/span&gt;)&lt;br/&gt;setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; { &lt;span&gt;// 异步回调, 会放入回调队列, 所有同步执行完后才可能执行&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;timout 回调&#x27;&lt;/span&gt;)&lt;br/&gt;}, &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;setTimeout 之后&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1.3 JS的error处理&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;错误的类型&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Error：所有错误的父类型&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ReferenceError：引用的变量不存在&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;console&lt;/span&gt;.log(a) &lt;span&gt;// ReferenceError: a is not defined&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TypeError：数据类型不正确的错误&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; b = &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(b.xxx) &lt;span&gt;// TypeError: Cannot read property &#x27;xxx&#x27; of null&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RangeError：数据值不在其所允许的范围内&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;fn&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  fn()&lt;br/&gt;}&lt;br/&gt;fn() &lt;span&gt;// RangeError: Maximum call stack size exceeded&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SyntaxError：语法错误&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; c = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt; &lt;span&gt;// SyntaxError: Unexpected string&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;错误处理&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;捕获错误：try ... catch&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;抛出错误：throw error&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;error 对象的结构&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;message 属性：错误相关信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;stack 属性：函数调用栈记录信息&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. Promise 是什么？&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2.1 理解&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;抽象表达：Promise 是JS中进行异步编程的新的解决方案（旧的是谁？=&amp;gt; 纯回调的形式）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体表达：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;从语法上来说：Promise 是一个构造函数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从功能上来说：Promise 对象用来封装一个异步操作并可以获取其结果&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2.2 Promise的状态改变&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Promise的状态改变只有这2种：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6183368869936035&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0ANBeLLOYKW7NU8bxzq5kBSPby8sCCJ8Vfd5RZX1noQtyAleD8yicpfpG6ujJJ5wERnm5XKFNc6thTg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;469&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;且一个 Promise 对象只能改变一次，无论变成成功还是失败，都会有一个结果数据，成功的结果数据一般称为 &lt;code&gt;value&lt;/code&gt;，失败的结果数据一般称为 &lt;code&gt;reason&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2.3 Promise基本流程&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3055286129970902&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0ANBeLLOYKW7NU8bxzq5kBSPGU6MSna6muvRYkd5D2VrM8pw8HMIX3lJQhMMBwoxegg3oibiaFZOMDRA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2062&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;Promise基本流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2.4 Promise的基本使用&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例，如果当前时间是偶数就代表成功，否则代表失败&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 1. 创建一个新的Promise对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; p = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; { &lt;span&gt;// 执行器函数，同步执行&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 2. 执行异步操作任务&lt;/span&gt;&lt;br/&gt;  setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; time = &lt;span&gt;Date&lt;/span&gt;.now() &lt;span&gt;// 如果当前时间是偶数就代表成功，否则代表失败&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 3.1 如果成功了，调用resolve(value)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (time % &lt;span&gt;2&lt;/span&gt; === &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;        resolve(&lt;span&gt;&#x27;成功的数据，value = &#x27;&lt;/span&gt; + time)&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// 3.2 如果失败了，调用reject(reason)&lt;/span&gt;&lt;br/&gt;        reject(&lt;span&gt;&#x27;失败的数据，reason = &#x27;&lt;/span&gt; + time)&lt;br/&gt;    }&lt;br/&gt;  }, &lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;})&lt;br/&gt;&lt;br/&gt;p.then(&lt;span&gt;&lt;span&gt;value&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// 接受得到成功的value数据，专业术语：onResolved&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;成功的回调&#x27;&lt;/span&gt;, value)&lt;br/&gt;}, reason =&amp;gt; {&lt;br/&gt;  &lt;span&gt;// 接受得到失败的reason数据，专业术语：onRejected&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;失败的回调&#x27;&lt;/span&gt;, reason)&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 为什么要用Promise？&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.1 指定回调函数的方式更加灵活&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;旧的：回调函数必须在启动异步任务前指定&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 成功的回调函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;successCallback&lt;/span&gt;(&lt;span&gt;result&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;处理成功:&#x27;&lt;/span&gt; + result)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;failureCallback&lt;/span&gt;(&lt;span&gt;error&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;处理失败:&#x27;&lt;/span&gt; + error)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 使用纯回调函数&lt;/span&gt;&lt;br/&gt;createAudioFileSync(audioSettings, successCallback, failureCallback)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Promise：启动异步任务 =&amp;gt; 返回 Promise 对象 =&amp;gt; 给 Promise 对象绑定回调函数，甚至可以在异步任务结束后指定多个&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 使用 Promise&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; promise = createAudioFileSync(audioSettings)&lt;br/&gt;setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  promise.then(successCallback, failureCallback)&lt;br/&gt;}, &lt;span&gt;3000&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.2 支持链式调用，解决回调地狱问题&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;什么是回调地狱？回调函数嵌套调用，外部回调函数异步执行的结果是嵌套的回掉执行条件，代码是水平向右扩展&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 回调地狱&lt;/span&gt;&lt;br/&gt;doSomething(&lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;result&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  doSomethingElse(result, &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;newResult&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    doThirdThing(newResult, &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;finalResult&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;Got the final result: &#x27;&lt;/span&gt; + finalResult)&lt;br/&gt;    }, failureCallback)&lt;br/&gt;  }, failureCallback)&lt;br/&gt;},&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回调地狱的缺点：不便阅读，不便于异常处理&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解决方案：Promise 链式调用，代码水平向下扩展&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;doSomething().then(&lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;result&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; doSomethingElse(result)&lt;br/&gt;})&lt;br/&gt;.then(&lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;newResult&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; doThirdThing(newResult)&lt;br/&gt;})&lt;br/&gt;.then(&lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;finalResult&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;Got the final result: &#x27;&lt;/span&gt; + finalResult)&lt;br/&gt;})&lt;br/&gt;.catch(failureCallback)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;终极解决方案：&lt;strong&gt;async/await&lt;/strong&gt;，用同步的写法处理异步的操作&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;async&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;request&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; result = &lt;span&gt;await&lt;/span&gt; doSomething()&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; newResult = &lt;span&gt;await&lt;/span&gt; doSomethingElse(result)&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; finalResult = &lt;span&gt;await&lt;/span&gt; doThirdThing(newResult)&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;Got the final result: &#x27;&lt;/span&gt; + finalResult)&lt;br/&gt;  } &lt;span&gt;catch&lt;/span&gt; (error) {&lt;br/&gt;    failureCallback(error)&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. Promise的API说明&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;4.1 API 说明&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Promise 构造函数&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Promise (excutor) {}&lt;/code&gt;，excutor 会在 Promise 内部立即同步回调,异步操作在执行器中执行&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;excutor 函数：执行器 &lt;code&gt;(resolve, reject) =&amp;gt; {}&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;resolve 函数：内部定义成功时我们调用的函数 &lt;code&gt;value =&amp;gt; {}&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;reject 函数：内部定义失败时我们调用的函数 &lt;code&gt;reason =&amp;gt; {}&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Promise.prototype.then方法&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt; (onResolved, onRejected) =&amp;gt; {}&lt;/code&gt;，指定用于得到成功 value 的成功回调和用于得到失败 reason 的失败回调返回一个新的 promise 对象&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;onResolved 函数：成功的回调函数 &lt;code&gt;(value) =&amp;gt; {}&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;onRejected 函数：失败的回调函数 &lt;code&gt;(reason) =&amp;gt; {}&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Promise.prototype.catch 方法&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;(onRejected) =&amp;gt; {}&lt;/code&gt;，onRejected 函数：失败的回调函数 &lt;code&gt;(reason) =&amp;gt; {}&lt;/code&gt;，then() 的语法糖, 相当于：&lt;code&gt;then(undefined, onRejected)&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Promise.resolve方法&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt; (value) =&amp;gt; {}&lt;/code&gt;，value：成功的数据或 promise 对象，返回一个成功/失败的 promise 对象&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Promise.reject方法&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt; (reason) =&amp;gt; {}&lt;/code&gt;，reason：失败的原因，返回一个失败的 promise 对象&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Promise.all方法&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;(promises) =&amp;gt; {}&lt;/code&gt;，promises：包含 n 个 promise 的数组，返回一个新的 promise, 只有所有的 promise 都成功才成功, 只要有一个失败了就直接失败&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Promise.race方法&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;(promises) =&amp;gt; {}&lt;/code&gt;，promises: 包含 n 个 promise 的数组，返回一个新的 promise, 第一个完成的 promise 的结果状态就是最终的结果状态&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 产生一个成功值为 1 的 Promise 对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; p1 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  resolve(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;})&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 产生一个成功值为 2 的 Promise 对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; p2 = &lt;span&gt;Promise&lt;/span&gt;.resolve(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;// 产生一个失败值为 3 的 Promise 对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; p3 = &lt;span&gt;Promise&lt;/span&gt;.reject(&lt;span&gt;3&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;p1.then(&lt;span&gt;&lt;span&gt;value&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;console&lt;/span&gt;.log(value))&lt;br/&gt;p2.then(&lt;span&gt;&lt;span&gt;value&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;console&lt;/span&gt;.log(value))&lt;br/&gt;p3.catch(&lt;span&gt;&lt;span&gt;reason&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;console&lt;/span&gt;.error(reason))&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// const pAll = Promise.all([p1, p2])&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; pAll = &lt;span&gt;Promise&lt;/span&gt;.all([p1, p2, p3])&lt;br/&gt;pAll.then(&lt;span&gt;&lt;span&gt;values&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;all onResolved()&#x27;&lt;/span&gt;, values) &lt;span&gt;// all onResolved() [ 1, 2 ]&lt;/span&gt;&lt;br/&gt;}, reason =&amp;gt; {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;all onRejected()&#x27;&lt;/span&gt;, reason) &lt;span&gt;// all onRejected() 3&lt;/span&gt;&lt;br/&gt;})&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; race = &lt;span&gt;Promise&lt;/span&gt;.race([p1, p2, p3])&lt;br/&gt;race.then(&lt;span&gt;&lt;span&gt;value&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;all onResolved()&#x27;&lt;/span&gt;, value) &lt;br/&gt;}, reason =&amp;gt; {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;all onRejected()&#x27;&lt;/span&gt;, reason) &lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;4.2 Promise的几个关键问题&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2.1 如何改变Promise的状态&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;resolve(value)&lt;/strong&gt;，如果当前是 pendding 就会变为 resolved&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;reject(reason)&lt;/strong&gt;，如果当前是 pendding 就会变为 rejected&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;抛出异常&lt;/strong&gt;，如果当前是 pendding 就会变为 rejected&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; p = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// resolve(1) // Promise 变为 resolved 成功状态&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// reject(2) // Promise 变为 rejected 失败状态&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// Promise 变为 rejected 失败状态，reason为抛出的 error&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt;(&lt;span&gt;&#x27;我抛出的异常&#x27;&lt;/span&gt;) &lt;br/&gt;  &lt;span&gt;// 变为 rejected 失败状态，reason为抛出的 3&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// throw 3&lt;/span&gt;&lt;br/&gt;})&lt;br/&gt;&lt;br/&gt;p.then(&lt;br/&gt;  &lt;span&gt;&lt;span&gt;value&lt;/span&gt; =&amp;gt;&lt;/span&gt; {},&lt;br/&gt;  reason =&amp;gt; { &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;reason :&#x27;&lt;/span&gt;, reason); }&lt;br/&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2.2 当一个promise指定多个成功/失败回调函数, 都会调用吗？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 promise 改变为对应状态时都会调用&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; p = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// 变为 rejected 失败状态，reason为抛出的 3&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;br/&gt;})&lt;br/&gt;&lt;br/&gt;p.then(&lt;br/&gt;  &lt;span&gt;&lt;span&gt;value&lt;/span&gt; =&amp;gt;&lt;/span&gt; {},&lt;br/&gt;  reason =&amp;gt; { &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;reason :&#x27;&lt;/span&gt;, reason); }&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;p.then(&lt;br/&gt;  &lt;span&gt;&lt;span&gt;value&lt;/span&gt; =&amp;gt;&lt;/span&gt; {},&lt;br/&gt;  reason =&amp;gt; { &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;reason2 :&#x27;&lt;/span&gt;, reason); }&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 结果：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// reason : 3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// reason2 : 3&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;mpcpc js_editor_cpcad=&quot;&quot; class=&quot;js_cpc_area cpc_iframe&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/cpc_tmpl#1606321749162&quot; data-category_id_list=&quot;48|32|26|49|1|27|28|45|46|55|39|8|3|47|35|41|5|31|6|7|24|37|22|11|50|54|53|52|42|29|43|16|17|51|36&quot; data-id=&quot;1606321749162&quot;/&gt;&lt;/h4&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;4.2.3 改变promise状态和指定回调函数谁先谁后?&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;都有可能, 正常情况下是先指定回调再改变状态, 但也可以先改状态再指定回调。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何先改状态再指定回调?&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在执行器中直接调用 resolve()/reject()&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;延迟更长时间才调用 then()&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;什么时候才能得到数据?&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果先指定的回调, 那当状态发生改变时, 回调函数就会调用, 得到数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果先改变的状态, 那当指定回调时, 回调函数就会调用, 得到数据&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 常规：先指定回调函数,后改变状态&lt;/span&gt;&lt;br/&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    resolve(&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;// 后改变状态（同时指定数据），异步执行回调函数&lt;/span&gt;&lt;br/&gt;  }, &lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;}).then( &lt;span&gt;// 先指定回调函数，保存当前指定的回调函数&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;value&lt;/span&gt; =&amp;gt;&lt;/span&gt; {},&lt;br/&gt;  reason =&amp;gt; { &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;reason :&#x27;&lt;/span&gt;, reason); }&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 先改状态,后指定回调函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  resolve(&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;// 先改变状态（同时指定数据）&lt;/span&gt;&lt;br/&gt;}).then( &lt;span&gt;// 后指定回调函数，异步执行回调函数&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;value&lt;/span&gt; =&amp;gt;&lt;/span&gt; { &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;value2：&#x27;&lt;/span&gt;, value);},&lt;br/&gt;  reason =&amp;gt; { &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;reason2 :&#x27;&lt;/span&gt;, reason); }&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; p = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  resolve(&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;// 先改变状态（同时指定数据）&lt;/span&gt;&lt;br/&gt;})&lt;br/&gt;&lt;br/&gt;setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  p.then(&lt;br/&gt;    &lt;span&gt;&lt;span&gt;value&lt;/span&gt; =&amp;gt;&lt;/span&gt; { &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;value3：&#x27;&lt;/span&gt;, value);},&lt;br/&gt;    reason =&amp;gt; { &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;reason3 :&#x27;&lt;/span&gt;, reason); }&lt;br/&gt;  )&lt;br/&gt;}, &lt;span&gt;1500&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2.4 promise.then()返回的新 promise 的结果状态由什么决定?&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单表达：由 then()指定的回调函数执行的结果决定&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;详细表达：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果抛出异常, 新 promise 变为 rejected, reason 为抛出的异常&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果返回的是非 promise 的任意值, 新 promise 变为 resolved, value 为返回的值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果返回的是另一个新 promise, 此 promise 的结果就会成为新 promise 的结果&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  resolve(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;}).then(&lt;br/&gt;  &lt;span&gt;&lt;span&gt;value&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;onResolved1()&#x27;&lt;/span&gt;, value); &lt;span&gt;// 1&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// return 1.1 或 &lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;.resolve(&lt;span&gt;1.1&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;// return Promise.reject(1.1)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// throw 1.1&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;  reason =&amp;gt; { &lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;onRejected1()&#x27;&lt;/span&gt;, reason);&lt;br/&gt;  }&lt;br/&gt;).then(&lt;br/&gt;  &lt;span&gt;&lt;span&gt;value&lt;/span&gt; =&amp;gt;&lt;/span&gt; { &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;onResolved2()&#x27;&lt;/span&gt;, value); }, &lt;span&gt;// 1.1&lt;/span&gt;&lt;br/&gt;  reason =&amp;gt; { &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;onRejected2()&#x27;&lt;/span&gt;, reason) } &lt;span&gt;// 1.1&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2.5 promise 如何串连多个操作任务&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;promise 的 &lt;code&gt;then()&lt;/code&gt; 返回一个新的 promise, 可以开成 &lt;code&gt;then()&lt;/code&gt; 的链式调用，通过 then 的链式调用串连多个同步/异步任务。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2.6 promise 异常传透&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当使用 promise 的 then 链式调用时, 可以在最后指定失败的回调，前面任何操作出了异常, 都会传到最后失败的回调中处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面的示例代码演示了异常传透&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// resolve(1)&lt;/span&gt;&lt;br/&gt;  reject(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;}).then(&lt;br/&gt;  &lt;span&gt;&lt;span&gt;value&lt;/span&gt; =&amp;gt;&lt;/span&gt; { &lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;onResolved1()&#x27;&lt;/span&gt;, value);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;).then(&lt;br/&gt;  &lt;span&gt;&lt;span&gt;value&lt;/span&gt; =&amp;gt;&lt;/span&gt; { &lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;onResolved2()&#x27;&lt;/span&gt;, value);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;).then(&lt;br/&gt;  &lt;span&gt;&lt;span&gt;value&lt;/span&gt; =&amp;gt;&lt;/span&gt; { &lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;onResolved3()&#x27;&lt;/span&gt;, value);&lt;br/&gt;  }&lt;br/&gt;).catch(&lt;br/&gt;  &lt;span&gt;&lt;span&gt;reason&lt;/span&gt; =&amp;gt;&lt;/span&gt; { &lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;onRejected()&#x27;&lt;/span&gt;, reason);  &lt;span&gt;// onRejected() 1&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码会执行 &lt;code&gt;.catch&lt;/code&gt; 中的代码，但实际上代码的执行不是执行到第 3 行就直接跳转到 catch 里面了，而是从第一个 then 调用向下一个个的执行（逐级传递），但是由于我们 then 里面没有处理异常。在 then 里面没写处理异常实际上相当于默认添加了 &lt;code&gt;reason =&amp;gt; { throw reason }&lt;/code&gt; 或者 &lt;code&gt;reason =&amp;gt; Promise.reject(reason)&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  reject(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;}).then(&lt;br/&gt;  &lt;span&gt;&lt;span&gt;value&lt;/span&gt; =&amp;gt;&lt;/span&gt; {  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;onResolved1()&#x27;&lt;/span&gt;, value); },&lt;br/&gt;  &lt;span&gt;// reason =&amp;gt; { throw reason }&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 或者&lt;/span&gt;&lt;br/&gt;  reason =&amp;gt; &lt;span&gt;Promise&lt;/span&gt;.reject(reason)&lt;br/&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Promise的异常传透示意图&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.8196573489630298&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0APyp6OPGNw1Z9EDQMVE6X0uSawq1VP6iaBicqgyIv30BJ7tsbNicibicdAEgMXsmEqibTHKW6jwZ1GRQcvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1109&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;Promise的异常传透&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2.7 中断 promise 链&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当使用 promise 的 then 链式调用时, 在中间中断, 不再调用后面的回调函数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;办法: 在回调函数中返回一个 &lt;code&gt;pendding&lt;/code&gt; 状态的 promise 对象&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt; resolve(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;}).then(&lt;br/&gt;  &lt;span&gt;&lt;span&gt;value&lt;/span&gt; =&amp;gt;&lt;/span&gt; { &lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;onResolved1()&#x27;&lt;/span&gt;, value);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {}) &lt;span&gt;// 返回一个 pending 的 Promise，中断 promise 链&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;).then( &lt;span&gt;// 这个 then 不会执行力&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;value&lt;/span&gt; =&amp;gt;&lt;/span&gt;  { &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;onResolved2()&#x27;&lt;/span&gt;, value); }&lt;br/&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. async与await&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Async/await 实际上只是一种基于promises的糖衣语法糖，Async/await 和 promises一样，都是非堵塞式的，Async/await 让异步代码更具同步代码风格，这也是其优势所在。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;async function&lt;/code&gt; 用来定义一个返回 &lt;code&gt;AsyncFunction&lt;/code&gt; 对象的异步函数。异步函数是指通过事件循环异步执行的函数，它会通过一个隐式的 &lt;code&gt;Promise&lt;/code&gt; 返回其结果，。如果你在代码中使用了异步函数，就会发现它的语法和结构会更像是标准的同步函数。MDN async_function&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;await&lt;/code&gt;  操作符用于等待一个&lt;code&gt;Promise&lt;/code&gt; 对象。它只能在异步函数 &lt;code&gt;async function&lt;/code&gt; 中使用。MDN await&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;5.1 async函数&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;async&lt;/code&gt; 函数的返回值为 &lt;code&gt;Promise&lt;/code&gt; 对象，&lt;code&gt;async&lt;/code&gt; 函数返回的 &lt;code&gt;Promise&lt;/code&gt; 的结果由函数执行的结果决定&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;async&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;fn1&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; result = fn1()&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(result) &lt;span&gt;// Promise { 1 }&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在控制台可以看见如下信息&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然是Promise对象，那么我们用 then 来调用，并抛出错误，执行 &lt;code&gt;onRejected()&lt;/code&gt; 且 reason 为错误信息为“我是错误”&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;async&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;fn1&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// return 1&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// return Promise.resolve(1)&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// return Promise.reject(2)&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;&#x27;我是错误&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;fn1().then(&lt;br/&gt;  &lt;span&gt;&lt;span&gt;value&lt;/span&gt; =&amp;gt;&lt;/span&gt; { &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;onResolved()&#x27;&lt;/span&gt;, value) },&lt;br/&gt;  reason =&amp;gt; { &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;onRejected()&#x27;&lt;/span&gt;, reason) } &lt;span&gt;// onRejected() 我是错误&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;5.2 await表达式&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;await&lt;/code&gt; 右侧的表达式一般为 &lt;code&gt;promise&lt;/code&gt; 对象, 但也可以是其它的值:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果表达式是 &lt;code&gt;promise&lt;/code&gt; 对象, &lt;code&gt;await&lt;/code&gt; 返回的是 &lt;code&gt;promise&lt;/code&gt; 成功的值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果表达式是其它值, 直接将此值作为 &lt;code&gt;await&lt;/code&gt; 的返回值&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;fn2&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      resolve(&lt;span&gt;1000&lt;/span&gt;)&lt;br/&gt;    }, &lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;  })&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;fn4&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{ &lt;span&gt;return&lt;/span&gt; &lt;span&gt;6&lt;/span&gt; }&lt;br/&gt;&lt;br/&gt;&lt;span&gt;async&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;fn3&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// const value = await fn2() // await 右侧表达式为Promise，得到的结果就是Promise成功的value&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// const value = await &#x27;还可以这样&#x27;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; value = &lt;span&gt;await&lt;/span&gt; fn4()&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;value&#x27;&lt;/span&gt;, value)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;fn3() &lt;span&gt;// value 6&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;await&lt;/code&gt; 必须写在 &lt;code&gt;async&lt;/code&gt; 函数中, 但 &lt;code&gt;async&lt;/code&gt; 函数中可以没有 &lt;code&gt;await&lt;/code&gt;，如果 &lt;code&gt;await&lt;/code&gt; 的 &lt;code&gt;Promise&lt;/code&gt; 失败了, 就会抛出异常, 需要通过 &lt;code&gt;try...catch&lt;/code&gt; 捕获处理&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;fn2&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;// resolve(1000)&lt;/span&gt;&lt;br/&gt;      reject(&lt;span&gt;1000&lt;/span&gt;)&lt;br/&gt;    }, &lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;  })&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;async&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;fn3&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; value = &lt;span&gt;await&lt;/span&gt; fn2()&lt;br/&gt;  } &lt;span&gt;catch&lt;/span&gt; (error) {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;得到失败的结果&#x27;&lt;/span&gt;, error)&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;fn3() &lt;span&gt;// 得到失败的结果 1000&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;5.3 Async/await 比 Promise 更优越的表现&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;简洁干净&lt;/strong&gt;，使用async/await能省去写多少行代码&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;错误处理&lt;/strong&gt;，async/wait 能用相同的结构和好用的经典 try/catch 处理同步和异步错误，错误堆栈能指出包含错误的函数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;调试&lt;/strong&gt;，async/await 的一个极大优势是它更容易调试，使用async/ await则无需过多箭头函数，并且能像正常的同步调用一样直接跨过await调用。&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e3c25d1c85f726c568175abf39aca66e</guid>
<title>聊聊 k8s 调试工具 kt-connect 的实现</title>
<link>https://toutiao.io/k/p6ic0m3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entry-content e-content&quot; itemprop=&quot;description articleBody&quot;&gt;
&lt;pre&gt;&lt;code class=&quot;&quot;&gt;版权声明 本站原创文章 由 萌叔 发表
转载请注明 萌叔 | http://vearne.cc
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;1. 引言&lt;/h3&gt;
&lt;p&gt;kt-connect是阿里开源的k8s的调试工具，它的作用类似于VPN，能够打通k8s集群和本地的网络。&lt;br/&gt;
&lt;img src=&quot;http://ut-bucket01.sh1a.qingstor.com/woshiaotian/20201202/4f137862-3451-11eb-b64b-784f43a6cab8.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;传送门: &lt;a href=&quot;https://github.com/alibaba/kt-connect&quot;&gt;alibaba/kt-connect&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;它有3种模式&lt;br/&gt;
* Connect 本地网络直接访问k8s集群网络&lt;br/&gt;
* Exchange 转发集群流量到本地&lt;br/&gt;
* Service Mesh 支持&lt;/p&gt;
&lt;p&gt;另外它提供了一个Dashboard可以查看k8s集群内的所有可访问的service资源以及正在进行调试的&lt;code&gt;Connect&lt;/code&gt;和&lt;code&gt;Exchange&lt;/code&gt;数量, 用处不大。&lt;br/&gt;
&lt;img src=&quot;http://ut-bucket01.sh1a.qingstor.com/woshiaotian/20201202/866fbb52-3453-11eb-9cba-784f43a6cab8.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2. 使用介绍&lt;/h3&gt;
&lt;p&gt;这里萌叔只简单介绍&lt;code&gt;Connect&lt;/code&gt;和&lt;code&gt;Exchange&lt;/code&gt;2种模式，更详细的使用说明见参考资料1&lt;/p&gt;
&lt;h4&gt;2.1 &lt;code&gt;Connect&lt;/code&gt;模式&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;&quot;&gt;sudo ktctl -i ik8share/kt-connect-shadow:stable connect
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;: &lt;code&gt;kt-connect&lt;/code&gt; 依赖&lt;code&gt;sshuttle&lt;/code&gt;, 且运行时必须拥有root权限。另外&lt;code&gt;sshuttle&lt;/code&gt; 又依赖了iptables(linux操作系统), ptctl(macOS)&lt;/p&gt;
&lt;p&gt;-i 参数指定镜像的地址&lt;/p&gt;
&lt;p&gt;这里&lt;a href=&quot;https://hub.docker.com/r/ik8share/kt-connect-shadow&quot;&gt;ik8share/kt-connect-shadow:stable&lt;/a&gt;是镜像的名字，阿里默认提供的镜像地址&lt;a href=&quot;https://registry.cn-hangzhou.aliyuncs.com/rdc-incubator/kt-connect-shadow:stable&quot;&gt;rdc-incubator/kt-connect-shadow&lt;/a&gt;在萌叔的测试k8s集群中无法正常拉取。这里提供了一个docker hub的镜像地址。&lt;/p&gt;
&lt;h4&gt;2.2 &lt;code&gt;Exchange&lt;/code&gt;模式&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;&quot;&gt;sudo ktctl -n test -i ik8share/kt-connect-shadow:stable exchange dm-backend-v0-0-1 --expose 3000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;: 这里的&lt;code&gt;dm-backend-v0-0-1&lt;/code&gt; 是k8s集群中&lt;code&gt;Deployment&lt;/code&gt;资源的名称。&lt;/p&gt;
&lt;p&gt;该命令会将所有发往&lt;code&gt;dm-backend-v0-0-1&lt;/code&gt;所属&lt;code&gt;Pod&lt;/code&gt;的3000端口的请求都转发到本地的3000端口上。&lt;/p&gt;
&lt;p&gt;总结：&lt;code&gt;Connect&lt;/code&gt;和&lt;code&gt;Exchange&lt;/code&gt; 模式都是单向的，一个是从集群外部到集群内部，一个是从集群内部到集群外部。&lt;/p&gt;
&lt;h3&gt;3. 原理和实现&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;kt-connect&lt;/code&gt;设计巧妙，且最大限度的避免了重复发明轮子，值得称赞。&lt;/p&gt;
&lt;h4&gt;3.1 &lt;code&gt;Connect&lt;/code&gt;模式&lt;/h4&gt;
&lt;p&gt;我们先来看看&lt;code&gt;Connect&lt;/code&gt;模式要达到的目标&lt;br/&gt;
假定&lt;br/&gt;
&lt;code&gt;Namespace&lt;/code&gt;: test&lt;br/&gt;
&lt;code&gt;Service&lt;/code&gt;: sv-backend-v0-0-1&lt;br/&gt;
&lt;code&gt;Pod&lt;/code&gt;的IP: 172.20.1.29&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;&quot;&gt;curl http://sv-backend-v0-0-1.test.svc.cluster.local/info
curl 172.20.1.29:3000/info
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么显然，&lt;br/&gt;
对于场景1: &lt;code&gt;kt-connect&lt;/code&gt;需要知道sv-backend-v0-0-1.test.svc.cluster.local是k8s集群内的域名，针对此类域名的请求，需要转发到k8s内网&lt;/p&gt;
&lt;p&gt;对于场景1: &lt;code&gt;kt-connect&lt;/code&gt; 需要知道 172.20.1.29，是k8s集群的内网IP，请求需要转发到k8s内网&lt;/p&gt;
&lt;p&gt;&lt;code&gt;kt-connect&lt;/code&gt; 需要能够自动捕获这两类流量，然后转发到k8s内网。&lt;br/&gt;
&lt;img src=&quot;http://ut-bucket01.sh1a.qingstor.com/woshiaotian/20201202/b659ca8a-346f-11eb-b218-784f43a6cab8.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h5&gt;3.1.1 ① 创建Pod&lt;/h5&gt;
&lt;p&gt;此Pod镜像为&lt;a href=&quot;https://registry.cn-hangzhou.aliyuncs.com/rdc-incubator/kt-connect-shadow:stable&quot;&gt;rdc-incubator/kt-connect-shadow&lt;/a&gt;，并且暴露SSH端口&lt;/p&gt;
&lt;h5&gt;3.1.2 ② 在Local和K8s之间建立通道&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&quot;&quot;&gt;kubectl -n default port-forward kt-connect-daemon-dnwvy-5dbf9cb9c6-l96g6 2222:22
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;3.1.3 ③ 捕获请求，并重新路由&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&quot;&quot;&gt;sshuttle --dns --to-ns 172.20.3.25 -v -e ssh -oStrictHostKeyChecking=no -oUserKnownHostsFile=/dev/null -r root@127.0.0.1:2222 -x 127.0.0.1 172.20.0.0/24 172.20.2.0/24 172.20.1.0/24 172.20.3.0/24 10.68.0.0/16
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;sshuttle&lt;/code&gt;内部会调用&lt;code&gt;iptables&lt;/code&gt;或&lt;code&gt;pfctl&lt;/code&gt;修改NAT规则&lt;/p&gt;
&lt;p&gt;–dns –to-ns 172.20.3.25表示DNS解析使用172.20.3.25，实时上这个IP就是&lt;code&gt;Pod&lt;/code&gt; kt-connect-daemon-dnwvy-5dbf9cb9c6-l96g6的IP&lt;/p&gt;
&lt;p&gt;规则形如&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;&quot;&gt;iptables -t nat -A sshuttle-12300 -j REDIRECT --dest 10.68.0.0/16  -p tcp --to-ports 2222 
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;3.1.4 ④ sshuttle重建对目标的连接&lt;/h5&gt;
&lt;p&gt;我们再来梳理一遍流程。当使用curl请求接口时，域名解析会使用自定义的DNS服务器172.20.3.25，因此能够成功解析&lt;code&gt;sv-backend-v0-0-1.test.svc.cluster.local&lt;/code&gt;，解析得到的A记录是10.68.54.179, 显然命中了&lt;code&gt;shuttle&lt;/code&gt;创建的NAT规则(10.68.0.0/16)，于是请求被转发到127.0.0.1:2222端口, 请求又经过&lt;code&gt;port-forward&lt;/code&gt;转发到&lt;code&gt;kt-connect-daemon-dnwvy-5dbf9cb9c6-l96g6&lt;/code&gt;的22端口。在这个Pod中，&lt;code&gt;sshuttle&lt;/code&gt;重建对目标的连接，请求会被转发。&lt;/p&gt;
&lt;h4&gt;3.2 &lt;code&gt;Exchange&lt;/code&gt;模式&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://ut-bucket01.sh1a.qingstor.com/woshiaotian/20201202/752680b4-3477-11eb-a73e-784f43a6cab8.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h5&gt;3.2.1 ① 创建Pod &amp;amp; ② 删除原有Pod&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;http://ut-bucket01.sh1a.qingstor.com/woshiaotian/20201202/878aacd4-3478-11eb-8900-784f43a6cab8.jpeg&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;
实际上，&lt;code&gt;kt-connect&lt;/code&gt;将原来的&lt;code&gt;Deployment&lt;/code&gt; dm-backend-v0-0-1的&lt;code&gt;replicas&lt;/code&gt;置为0，变相删除了&lt;code&gt;Pod&lt;/code&gt;&lt;br/&gt;
创建了一个新的&lt;code&gt;Deployment&lt;/code&gt; dm-backend-v0-0-1-kt-dfoje, 注意看它使用的镜像是&lt;a href=&quot;https://registry.cn-hangzhou.aliyuncs.com/rdc-incubator/&quot;&gt;kt-connect-shadow&lt;/a&gt;。由它创建的&lt;code&gt;Pod&lt;/code&gt;，使用的&lt;code&gt;Label&lt;/code&gt;和原先的一模一样，这样它就能欺骗k8s，使得对&lt;code&gt;Service&lt;/code&gt; backend的请求都转发到它这里来。&lt;/p&gt;
&lt;h5&gt;3.2.2 ③在Local和K8s之间建立通道&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&quot;&quot;&gt;kubectl -n test port-forward dm-backend-v0-0-1-kt-dfoje-7ff5d9564-kmklv 2226:22
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;访问本地的2226端口，相当于访问了dm-backend-v0-0-1-kt-dfoje-7ff5d9564-kmklv的22端口&lt;/p&gt;
&lt;h5&gt;3.2.3 ④ssh 远程转发&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&quot;&quot;&gt;ssh -oStrictHostKeyChecking=no -oUserKnownHostsFile=/dev/null -R 3000:127.0.0.1:3000 root@127.0.0.1 -p2226 sh loop.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ssh自带远程转发功能，它会在dm-backend-v0-0-1-kt-dfoje-7ff5d9564-kmklv中监听3000端口，然后把所有发到3000端口的请求转发到127.0.0.1:3000（见参考资料2）&lt;/p&gt;
&lt;p&gt;我们再来梳理一遍流程。当其他服务访问&lt;code&gt;Service&lt;/code&gt; backend时，由于&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;&quot;&gt;  labels:
    app: backend
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只剩由&lt;code&gt;kt-connect&lt;/code&gt;伪造的1个&lt;code&gt;Pod&lt;/code&gt; dm-backend-v0-0-1-kt-dfoje-7ff5d9564-kmklv了，所以流量会被转发到这个&lt;code&gt;Pod&lt;/code&gt;中。请求的3000端口的流量会被SSH的远程转发功能转发给本地的3000端口。&lt;/p&gt;
&lt;h3&gt;参考资料&lt;/h3&gt;
&lt;p&gt;1.&lt;a href=&quot;https://alibaba.github.io/kt-connect/#/zh-cn/&quot;&gt;Kt Connect Docs&lt;/a&gt;&lt;br/&gt;
2.&lt;a href=&quot;https://jeremyxu2010.github.io/2018/12/ssh%E7%9A%84%E4%B8%89%E7%A7%8D%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/&quot;&gt;SSH的三种端口转发&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;h4&gt;打赏我&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/woshiaotian/ohw8kvpn5k7hthgbuol4e4aq/WechatIMG29.jpg&quot; alt=&quot;微信支付码&quot;/&gt;&lt;/p&gt;

&lt;p class=&quot;clear&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6c592f6d727992b6eee38cfb97305883</guid>
<title>35 岁以后，不要成为程序员中的钻石</title>
<link>https://toutiao.io/k/gbakyp5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;▲ &lt;/span&gt;&lt;span&gt;点击上方&quot;pointers&quot;&lt;/span&gt;&lt;span&gt;关注公众号&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;成长&amp;amp;认知 &lt;/span&gt;&lt;/span&gt;丨 作者&lt;/span&gt;&lt;span&gt; / &lt;/span&gt;&lt;span&gt;袁吴范&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是&lt;/span&gt;&lt;span&gt;&lt;span&gt;pointers公众号&lt;/span&gt;&lt;/span&gt;&lt;span&gt;的第25篇原创文章&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2020年，是一个不同寻常的一年。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从年初爆发的疫情，到全球经济下行的压力，大家都成为了历史的见证者。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;让本来就艰辛的成年人们，雪上加霜。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们都是社会中的人，在这场经济下行背景下，经济影响会以各种各样的方式最终传递到每个人身上，我们都无法逃避。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;仿佛从年初到年末，都充斥着悲观的情绪。裁员的声音，一直环绕在我们每个职场人耳边。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.319047619047619&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4XQ0RVoHjpzzBr9mZ9GC1LiaaIva6zccuWkUNXKFgOsibyZeENQfo5uEC9yMFHdB8pMff1106ciclHuehnBX07Bcw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;420&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.28451882845188287&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4XQ0RVoHjpzzBr9mZ9GC1LiaaIva6zccuAykSbv23ckkg9yBl14ic5NeCenL14x35xE04aOKas85biby9bmzSjuog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;478&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;来自某社交平台上爆料&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;他们有一些人是被迫的丢掉了工作。但对于35岁以上的中年人，打击实在太大了。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;明面上都不会说，但是在招聘的时候，确确实实都不考虑“35岁以上的中年人”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;例如某为在内部宣传词是“35岁以上的优化”，马爸爸的“每年向社会输送1000人才”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;似乎35岁就像每个程序员的一个坎，那为什么会这样呢？我们应该怎样做呢？&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;—&lt;/span&gt;&lt;span&gt;&lt;span&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;—&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;为什么？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为什么35岁以后，突然就没有了竞争力了呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为35岁以后，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;有些程序员成为了“程序员中的钻石”&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;什么意思？什么是钻石？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;就是又贵又没用的东西&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，比喻很难听，但事实就是这样。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着年纪的增长，每年都会进行调薪，自然年薪水涨船高，但能力并没有持续提升。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样导致了什么结果？&lt;/span&gt;&lt;span&gt;&lt;strong&gt;就是性价比太低了&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很多人会有疑问了，不是随着年龄的增大，经验也会变得更加丰富吗？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;或者是已经晋升为管理者了吗？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;的确，会有很多人能力在持续提升，最后成为了不可或缺的技术专家。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;也有许多人，一路披荆斩棘，千军万马过独木桥，最后成功晋升为管理者。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但对于另外一撮人来说，他们不是工作了10年，只是这10年重复干了一件应届生都会干的事情，而已！还在基层岗位上，坚守着。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们再想一想自己刚刚毕业的时候，是怎样的状态？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;是不是每天都充满了斗志，活力四射，精力充足。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对，这就是刚刚毕业的程序员的优势。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;他们正虎视眈眈的看着前面的那批所谓的中年人，中年人行动缓慢，一不留神就被后浪拍在了沙滩上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;要知道，我们生活在市场经济下的社会中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;也就是说，你所干的岗位价格是由你的稀缺性来决定的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;什么意思？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;就是你能拿到的工资是能干和你同样的事情的所有人中最便宜的那个人决定的。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这句话多看几遍！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;就是因为当初的你年轻，有活力，肯吃苦才让你干基础开发工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现在有比现在的你要价更低，甚至比你更勤奋，更优秀。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;你说你的老板有什么理由，不选择那个吃的少的马呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后呢？然后，曾经的年轻人也会慢慢变老，来到35岁这个节点上，被新的年轻人拍打在沙滩上，这样周而复始，不断循环。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;怎么破？&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;—&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;—&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;明确方向&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们不能改变社会的规律，我们唯一能做的就是改变自己，让自己的能力等到持续的发展。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;每个人的追求都不太一样。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有的人的志向就是想要从事技术相关工作，喜欢这种解决疑难问题带来的成就感。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有的人内心中渴望领导一个团队，带领团队攻坚，突破，拿下一个个大项目。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不管是喜欢什么方向，最重要的是明确自己的方向。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;作为程序员，应该要知道未来的路中有哪些荆棘，分别需要什么能力去克服，从而做大“手中有粮，心中不慌”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面我来讲一讲程序员有哪些常见道路可以走。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;互联网大厂的晋升通道一般有管理和技术两个通道，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;一边专业路线，一边是管理路线。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;技术类上&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，是有两个方向：&lt;/span&gt;&lt;span&gt;&lt;strong&gt;架构师和技术专家&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;架构师他的侧重点是在“广”上&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，他主要负责技术的整体和架构，在业务上，需要有很深的理解，有丰富的经验，甚至能做到“走的桥比你吃的盐还多”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在技术上，能够广泛涉略，掌握的技术知识越多，内力就越加深厚。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我觉得架构师还需要三点必备能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其一需要有极强的执行力，能够快速的给出合理的方案，推动技术落地。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其二需要有极强的判断力，能够准确的找到复杂系统的疑难问题所在，就像武林高手，一眼就看出对方的破绽。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后还需要有极强的创新力，能够创造新的解决方案，解决现有技术难题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以从程序员到架构师的成长之路，总的指导原则是：&lt;/span&gt;&lt;span&gt;&lt;strong&gt;积累经验，拓宽视野，深度思考&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;（可以参考我之前文章《&lt;/span&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247483826&amp;amp;idx=1&amp;amp;sn=c82601363825ba261b88c0198ee3a91d&amp;amp;chksm=cf2094a0f8571db6b69603ba66b1ac62ef588fc3668ffdcddd4ca2fa62713eb8c614e279290b&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;程序员进阶必备能力——深度思考&lt;/span&gt;&lt;/a&gt;&lt;span&gt;》）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;技术专家他的侧重点是在“专”上&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，这个就很好理解，就是在某个领域能够深入，能够熟悉其背后运行原理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不同的领域都会存在专家，例如：Java专家、前端专家、图像算法专家、Linux内核专家等等。专家相对架构师，更加专注，并不会考虑太多整体方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以从高级开发成长为技术专家，主要是扩展领域内的技术宽度，提升领域内的技术深度。因为领域也不是特别窄的一个面，而是包含多个技术面。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;举一个例子：Linux内核专家，要想成为Linux内核专家，需要掌握，Linux
CPU调度、内存管理、进程管理、存储管理、文件系统、设备管理和驱动、网络通信、系统调用、系统初始化等技术面。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在每个技术面中，同样包含了很多技术点，这些技术都是知识盲区，所以需要提升技术深度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;管理类上&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，也分为了两个方向，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;技术管理和职业管理&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。顾名思义，技术管理更加倾向于技术，而职业管理完全抛开了技术，纯粹的商业方向。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;技术管理，这个方向是程序员最自然的选择。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大部分的技术管理者，在其从程序员转为管理岗位的时候，都是在领导或公司的要求下，被动的推到技术经理岗位上的，并非是自己当初有强烈意愿、主动去选择管理岗的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后走上漫漫打怪升级的道路，从技术经理岗到技术总监，带领几十号人的团队冲关，然后到成为技术业务部和事业部的技术副总裁，相当于CTO了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;技术管理需要在业务上有较深的理解，在技术上能够根据技术发展趋势，进行技术规划。在产品上能够极强的洞察力，进行产品规划。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在团队加上能够规划团队建设、组织结构等等，所以这是综合素质的要求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;职业管理者往往更加关心于整体产品业务的团队，不限于技术团队&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如某个事业部的总裁，或者是某个业务部的总裁。大家往往都听过某某事业部空降了领导，这个领导就是属于职业管理者，他的移动性更加强，能力更加通用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个方向是可遇不可求的，有些人一辈子都不可能触及到。这个就是天花板上的别人家的楼板，你说难不难？所以随遇而安，时刻准备着出击！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;到现在知道你未来的路是怎样了，需要的能力是怎样的了，你以为这样就行了吗？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;显然还不够。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;—&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;—&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;跟时间做朋友&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们要跟时间做朋友。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;时间是一把杀猪刀，会让一部分变得越来越不值钱，当然也会让一部分越来越值钱。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;要让时间成为你的好伙伴。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;技术和管理的路已经给你指明，接下来就要靠你去做了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;刚毕业的时候，多努力一点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;千万不要贪图安逸却又不甘平庸，内心渴望挑战却又过得四平八稳。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;把体力多花在能力提升上，少看泡沫剧，少刷抖音，将你的体力换成经验，换成脑中的思想。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;35岁之后，我们的体力终将会被年轻人淘汰，否则就是对年轻人的不公平。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这时候我们还剩下什么？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;所谓中年人的优势，就是一路走来，所积攒下来的经验，能力，人脉和思想。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用这些东西，从顶层思考，帮助年轻人成长，我们自然的就成功了。&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;—&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;—&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们每个人都在经历着从砖头变钻石的过程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着工龄的增加，你的价格也越来越贵。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果你没有找到自己方向，没有在这个方向上让自己更加有价值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那变成职场中的钻石是必然的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以每隔一段时间，公司就会把职场上的钻石换成砖头，如此往复，直到这些砖头，再变成新的钻石。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;唯一能改变这个定律的，就是不断输入新的能量，让自己变成不可或缺的角色&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p lang=&quot;en-US&quot;&gt;&lt;span&gt;明白了这一点，就知道要怎么做了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;35岁之后，别成为又贵又没用的钻石。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后希望大家都能成为自己心中的那个人，献上！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我是袁吴范，物联网大厂技术总监，如有疑问，微信私信我：&lt;/span&gt;&lt;span&gt;&lt;span&gt;pointersss&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;em&gt;&lt;span&gt;推荐阅读（干货）&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;section data-darkmode-bgcolor-16033270487548=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16033270487548=&quot;rgb(255, 255, 255)&quot; data-style=&quot;margin-right: 8px; margin-left: 8px; white-space: normal; max-width: 100%; font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__135&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247484114&amp;amp;idx=1&amp;amp;sn=8e7dc76fa54087cf0784ef13dc261078&amp;amp;chksm=cf2097c0f8571ed6de8272864698e35cf0c78183bceb109fe71ee450d077f72ba29e5ac819f2&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;7年，从“游戏少年”到大厂技术总监的逆袭之路&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-darkmode-bgcolor-16033270487548=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16033270487548=&quot;rgb(255, 255, 255)&quot; data-style=&quot;margin-right: 8px; margin-left: 8px; white-space: normal; max-width: 100%; font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__135&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247484027&amp;amp;idx=1&amp;amp;sn=fb6fe35037e1693bf0f1c0a81d059bdc&amp;amp;chksm=cf209769f8571e7f311b5195d1f4c8fc1dc7f6905375bbdc6b0afbec0abc4775889b1012db7c&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;程序员成为高级管理者的三次跃升&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-darkmode-bgcolor-16033270487548=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16033270487548=&quot;rgb(255, 255, 255)&quot; data-style=&quot;margin-right: 8px; margin-left: 8px; white-space: normal; max-width: 100%; font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__135&quot;&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247484011&amp;amp;idx=1&amp;amp;sn=e52d915760314e3300c145039ede831b&amp;amp;chksm=cf209779f8571e6f81be5951b70607c2a2518fd0fc94c80c8f96c3331f82bdd6e07807179ce4&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;技术总监7年总结，如何进行正确的沟通？&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;hr/&gt;&lt;section data-darkmode-bgcolor-16033270487548=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16033270487548=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16033270487548=&quot;rgb(153, 153, 153)&quot; data-darkmode-original-color-16033270487548=&quot;rgb(77, 77, 77)&quot; data-style=&quot;margin-right: 8px; margin-bottom: 10px; margin-left: 8px; white-space: normal; max-width: 100%; font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; color: rgb(77, 77, 77); font-size: 16px; background-color: rgb(255, 255, 255); line-height: 25.5px; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__141&quot;&gt;&lt;span&gt;从业7年。从软件开发、高级软件开发、技术经理再到技术总监，分享职业发展、技术管理、职场晋升、技术成长等个人多年经验和心得。一起成长！&lt;/span&gt;&lt;/section&gt;&lt;section data-darkmode-bgcolor-16033270487548=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16033270487548=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16033270487548=&quot;rgb(153, 153, 153)&quot; data-darkmode-original-color-16033270487548=&quot;rgb(77, 77, 77)&quot; data-style=&quot;margin-right: 8px; margin-bottom: 10px; margin-left: 8px; white-space: normal; max-width: 100%; font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; color: rgb(77, 77, 77); font-size: 16px; background-color: rgb(255, 255, 255); line-height: 25.5px; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__148&quot;&gt;&lt;span&gt;&lt;span data-darkmode-bgcolor-16029336602567=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16029336602567=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16029336602567=&quot;rgb(153, 153, 153)&quot; data-darkmode-original-color-16029336602567=&quot;rgb(77, 77, 77)&quot; data-darkmode-bgcolor-16030173785544=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030173785544=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030173785544=&quot;rgb(153, 153, 153)&quot; data-darkmode-original-color-16030173785544=&quot;rgb(77, 77, 77)&quot; data-style=&quot;max-width: 100%; background-color: rgb(255, 255, 255); color: rgb(77, 77, 77); font-size: 14px; letter-spacing: 0.544px; white-space: normal; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__149&quot; data-darkmode-bgcolor-16033270487548=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16033270487548=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16033270487548=&quot;rgb(153, 153, 153)&quot; data-darkmode-original-color-16033270487548=&quot;rgb(77, 77, 77)&quot;&gt;关注我&lt;span data-darkmode-bgcolor-16029336602567=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16029336602567=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16029336602567=&quot;rgb(153, 153, 153)&quot; data-darkmode-original-color-16029336602567=&quot;rgb(77, 77, 77)&quot; data-darkmode-bgcolor-16030173785544=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030173785544=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030173785544=&quot;rgb(153, 153, 153)&quot; data-darkmode-original-color-16030173785544=&quot;rgb(77, 77, 77)&quot; data-style=&quot;max-width: 100%; background-color: rgb(255, 255, 255); color: rgb(77, 77, 77); font-size: 14px; letter-spacing: 0.544px; white-space: normal; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__149&quot; data-darkmode-bgcolor-16033270487548=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16033270487548=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16033270487548=&quot;rgb(153, 153, 153)&quot; data-darkmode-original-color-16033270487548=&quot;rgb(77, 77, 77)&quot;&gt;↓&lt;/span&gt;&lt;span data-darkmode-bgcolor-16029336602567=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16029336602567=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16029336602567=&quot;rgb(153, 153, 153)&quot; data-darkmode-original-color-16029336602567=&quot;rgb(77, 77, 77)&quot; data-darkmode-bgcolor-16030173785544=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030173785544=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030173785544=&quot;rgb(153, 153, 153)&quot; data-darkmode-original-color-16030173785544=&quot;rgb(77, 77, 77)&quot; data-style=&quot;max-width: 100%; background-color: rgb(255, 255, 255); color: rgb(77, 77, 77); font-size: 14px; letter-spacing: 0.544px; white-space: normal; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__149&quot; data-darkmode-bgcolor-16033270487548=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16033270487548=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16033270487548=&quot;rgb(153, 153, 153)&quot; data-darkmode-original-color-16033270487548=&quot;rgb(77, 77, 77)&quot;&gt;↓&lt;/span&gt;，帮你答疑解惑！&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt; &lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;430&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4XQ0RVoHjpwwHPUKTfFPuXricWutdgzqDd8IhicA9rFr2MtXU3SaVfxfR9Y5sfhTib9Wq0kkU5bEZj6aSkAQC7zzA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f3b98b900abb3ffce10a0fc312ed6af0</guid>
<title>研发团队技术学习与分享</title>
<link>https://toutiao.io/k/tlkngef</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article class=&quot;_2rhmJa&quot;&gt;&lt;h1&gt;研发团队技术学习与分享&lt;/h1&gt;
&lt;h1&gt;目的&lt;/h1&gt;
&lt;hr/&gt;
&lt;p&gt;首先，我们需要明确为什么要做这件事情。这件事情能给大家带来什么，预期结果又是什么，这里的“大家”主要有3个主体：公司、团队、个人，每个主体对于技术学习与分享这件事件，都有不同的预期结果，下面总结了几点目的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;学习新技术，提升自我，形成技术知识体系&lt;/li&gt;
&lt;li&gt;提升专业知识领域的经验&lt;/li&gt;
&lt;li&gt;提升沟通和表达能力&lt;/li&gt;
&lt;li&gt;学习和分析内容，可以帮助产品技术框架、性能、工具的推进&lt;/li&gt;
&lt;li&gt;技术资料的沉淀，形成公司技术价值&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;如何开始&lt;/h1&gt;
&lt;hr/&gt;
&lt;p&gt;了解了目的，我们需要想想如何做，才能达成目的。成人的学习、培训是比较难顺利推进，繁重的开发任务和人的惰性，Leader和管理层是否真正关注和帮助大家，这些都是历来公司内部推进技术学习与分享的各种困难，最后很多公司和团队都是不了了之。那么我们怎么做才能避免一些坑呢：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;管理层统一思想，技术学习和分享是长期工作，其效果体现需要长期来看和评估&lt;/li&gt;
&lt;li&gt;内容的质量，内容不能过浅&lt;/li&gt;
&lt;li&gt;明确的分享周期和分享团队，明确分享人和听众的责任&lt;/li&gt;
&lt;li&gt;选择内容不能随意，需要针对“听众”的情况，选择感兴趣的内容&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;如何做&lt;/h1&gt;
&lt;hr/&gt;
&lt;h2&gt;1.分享成员&lt;/h2&gt;
&lt;p&gt;降低责任分母，如果12人团队，责任分母是12，会因为各种原因，某个人觉得不是我一个人的事情，很难主动分享；把分享做成小组，责任分母变小，可能是2或者3，这样小组内推进，比每个人的自驱动力推进来的靠谱。&lt;/p&gt;
&lt;p&gt;我们目前的研发团队组成有3类&lt;/p&gt;

&lt;p&gt;以3个小组为单位，进行技术学习和分享活动，按照顺序轮流执行，小组内，可以一次多人分享，也可以一次一人分享。&lt;/p&gt;
&lt;h2&gt;2.周期确定&lt;/h2&gt;
&lt;p&gt;周期规则必须明确，这样分享人和听众，都有时间去准备。&lt;/p&gt;
&lt;h3&gt;分享时间规则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;频次：每2周1次（几组轮流）&lt;/li&gt;
&lt;li&gt;时间：周四晚上19点15分&lt;/li&gt;
&lt;li&gt;时长：60分钟内&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;分享人准备&lt;/h3&gt;

&lt;h3&gt;听众准备&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;阅读资料：分享会前1周内，需要把分享资料进行阅读，有分析显示，如果不提前看开会内容，在会议上可能听懂的内容也就20%，为了不浪费自己的生命，也应该分享前去阅读资料&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;3.内容选择&lt;/h2&gt;
&lt;p&gt;学习和分享的目的，是为了提高大家的技术水平，扩展大家认知的领域，所以内容选择建议分成2类：技术专题分享、自由主题分享。&lt;/p&gt;
&lt;h3&gt;如何选择内容&lt;/h3&gt;
&lt;p&gt;内容的选择，应该因团队情况和产品技术架构情况而异，每个季度进行一次规划，从团队中了解管理、技术弱点、希望提高的方面、产品下一步的技术和框架的要求，针对规划出来的内容，进行内容的选择（也包含培训课程平台的选择，目前选择的是拉勾教育）。&lt;/p&gt;
&lt;h3&gt;技术专题分享&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;有针对性提升团队在某一个技术领域的专业技能&lt;/li&gt;
&lt;li&gt;可以快速的，有针对性的使用在现有架构和产品中&lt;/li&gt;
&lt;li&gt;往往需要由浅入深，进行循序渐进的分享&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;自由主题分享&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;拓展认知&lt;/li&gt;
&lt;li&gt;内容可以更广，甚至可以邀请相关非技术同学参加&lt;/li&gt;
&lt;li&gt;更加要求分享者的表达的逻辑思维，怎么把大家不熟悉的内容，讲明白&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;针对分享类型，可以有针对性的进行技术专题分享和自由主题分享的交替&lt;/p&gt;
&lt;h3&gt;Reject Simple&lt;/h3&gt;
&lt;p&gt;想要分享的内容和形式NB，你就得变的NB&lt;br/&gt;
在内容上，我们拒绝特别简单的技术内容，不要分享安装什么什么环境、什么什么入门之类的&lt;/p&gt;
&lt;h2&gt;4.团队氛围&lt;/h2&gt;
&lt;p&gt;通过技术学习和分享，提升团队的技术氛围，加强大家的了解，提高凝聚力。&lt;/p&gt;
&lt;p&gt;分享会提供一些饮料、好吃的，在一个轻松的氛围下，免费学习知识，肯定有更多的人愿意来参与进来，主动性会增强很多。&lt;/p&gt;
&lt;h1&gt;总结&lt;/h1&gt;
&lt;hr/&gt;
&lt;p&gt;除了学习和分享，也希望大家学会感恩&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;感谢&lt;/strong&gt;公司可以提供平台给大家进行分享的机会；&lt;br/&gt;
&lt;strong&gt;感谢&lt;/strong&gt;分享人利用自己时间，准备PPT；&lt;br/&gt;
&lt;strong&gt;感谢&lt;/strong&gt;听众认真聆听，踊跃提问；&lt;/p&gt;
&lt;p&gt;怀着一颗感恩的心，你会看到更美好的东西，站在别人的角度思考，会让你走向另一个高度！&lt;/p&gt;
&lt;/article&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>