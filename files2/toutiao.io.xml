<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>1ce00ceb3eddb3e112433ef4bf9a69a8</guid>
<title>数位上市公司 CTO 都在订阅，你还等什么？</title>
<link>https://toutiao.io/k/y2pfkty</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;明天周五啦！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第 085 期「码农周刊 VIP 会员专属邮件周报」，将于本周五晚发送。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;数位上市公司 CTO 都在订阅，你还等什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;img class=&quot;rich_pages js_insertlocalimg wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;255&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;255&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/t8lpVibticjQ4LlicrXjOxMtaQDWoib2X24FnCibVaaZDqGa6VhDuw5a6cJtG8eg35xVuS75hozib0Z3Kib07lhzJsTSA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;274&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;码农周刊是什么？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;码农周刊是一份专为广大程序员、编程爱好者们打造的 IT 技术周刊。每周发送。&lt;br/&gt;2013 年 9 月 12 日创刊至今，已发送 300 多期，订阅用户超 20 万。&lt;br/&gt;&lt;span&gt;专业、简单、有用&lt;/span&gt;，是我们一直坚持的办刊宗旨。一路走来，我们见证了不少订阅用户从编程新手进阶成了高级程序员、架构师、CTO……&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2020 年 4 月，为了给用户提供更优质的服务，我们推出了「&lt;span&gt;码农周刊VIP会员&lt;/span&gt;」服务。&lt;br/&gt;&lt;strong&gt;你与 BAT 技术大牛，只差一份「码农周刊VIP会员」的距离！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;VIP会员特权&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 52 期码农周刊VIP会员&lt;span&gt;专属邮件周报&lt;/span&gt;，让你及时掌握技术动向；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 只限VIP会员加入的&lt;span&gt;交流圈子&lt;/span&gt;，让你与技术大牛切磋学习；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. VIP会员独享的&lt;span&gt;工作机会&lt;/span&gt;，为你介绍好公司的好机会；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 更多会员特权，持续更新……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;如何加入「码农周刊VIP会员」？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 微信扫描下方二维码，加入码农周刊VIP会员知识星球。&lt;strong&gt;&lt;span&gt;促销期间，一年仅需 108 元！平均一天花费不到 3 毛！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;391&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;425&quot; data-ratio=&quot;1.3478260869565217&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/t8lpVibticjQ6elqZKJKdKVMrGKUKjLwPpIFaDmrXyf1iaRtelGc6Fm6W4vp1uEAbb7Nz7QuBzxXNW96CiauDAL3Aw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;690&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 加入码农周刊VIP会员知识星球后，客服会联系您，请留意知识星球内的私信。&lt;br/&gt;3. 客服向您发送码农周刊VIP会员欢迎邮件，开启您的码农周刊VIP会员之旅。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;心动不如心动，赶快订阅吧！&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ebf4f1874e96dbad29a93f23081b512a</guid>
<title>优质网站同好者周刊（第 58 期）- 倾城之链 - 悠然宜想亭</title>
<link>https://toutiao.io/k/dxg25fv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;Post-body&quot;&gt;
                    &lt;p&gt;&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链&lt;/a&gt;作为一个开放平台，旨在云集全球&lt;strong&gt;优秀网站&lt;/strong&gt;，探索互联网中更广阔的世界。此周刊，将汇聚过去一周&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot; rel=&quot; nofollow ugc&quot;&gt;倾城&lt;/a&gt;所收录的内容，以飨同好；欢迎推荐或自荐（仅限有独立域名的网站，可以是二级域名）。您如果要了解收录要求，请参见&lt;a href=&quot;https://nicelinks.site/about?utm_source=weekly&quot; rel=&quot; nofollow ugc&quot;&gt;关于倾城&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt;：本周刊&lt;strong&gt;每周五&lt;/strong&gt;生成，首发于个人微信公众号&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI5MDIwMzM2Mg==&amp;amp;action=getalbum&amp;amp;album_id=1530765143352082433&amp;amp;scene=173&amp;amp;from_msgid=2650641087&amp;amp;from_itemidx=1&amp;amp;count=3#wechat_redirect&quot; rel=&quot; nofollow ugc&quot;&gt;晚晴幽草轩&lt;/a&gt;、博客&lt;a href=&quot;https://www.jeffjade.com&quot; rel=&quot; nofollow ugc&quot;&gt;晚晴幽草轩&lt;/a&gt;，以及&lt;a href=&quot;https://forum.lovejade.cn/&quot; rel=&quot; nofollow ugc&quot;&gt;悠然宜想亭&lt;/a&gt;社区；此一键生成脚本基于 &lt;a href=&quot;https://nicelinks.site/post/602d30aad099ff5688618591&quot; rel=&quot; nofollow ugc&quot;&gt;Deno&lt;/a&gt; 编写，并在 Github 开源：&lt;a href=&quot;https://github.com/nicejade/nicelinks-weekly&quot; rel=&quot; nofollow ugc&quot;&gt;nicejade/nicelinks-weekly&lt;/a&gt;。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E8%A7%86%E9%A2%91&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;视频&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E8%BD%AF%E4%BB%B6&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;软件&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%BC%80%E6%BA%90&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;开源&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关键字&lt;/strong&gt;：OBS, OBS Studio, Stream, Video, Live Streaming, Recording, Games, Twitch, YouTube, Livestream, Open Broadcaster Software&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;p&gt;OBS (Open Broadcaster Software) is free and open source software for video recording and live streaming. Stream to Twitch, YouTube and many other providers or record your own videos with high quality H264 / AAC encoding.&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/obsproject.com.png?x-oss-process=style/png2jpg&quot; title=&quot;&quot; alt=&quot;倾城之链 - Open Broadcaster Software | OBS&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://obsproject.com/&quot; rel=&quot; nofollow ugc&quot;&gt;OBS Studio&lt;/a&gt; (Open Broadcaster Software) 是&lt;strong&gt;免费的开源软件&lt;/strong&gt;，用于&lt;strong&gt;视频录制&lt;/strong&gt;和&lt;strong&gt;直播&lt;/strong&gt;。在 Windows、Mac 或 Linux 上，可快速轻松地下载，并开始流式传输。可流媒体到 Twitch、YouTube 和许多其他供应商，或用高质量的 H264 / AAC 编码录制你自己的视频。它具有以下功能特征：&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;高性能实时视频/音频捕获和混合。创建由多个来源组成的场景，包括窗口捕获、图像、文本、浏览器窗口、网络摄像头、采集卡等；&lt;/li&gt;
&lt;li&gt;设置无限数量的场景，您可以通过自定义过渡无缝切换；&lt;/li&gt;
&lt;li&gt;直观的混音器，带有每个源滤波器，例如噪声门、噪声抑制和增益。通过 VST 插件支持完全控制；&lt;/li&gt;
&lt;li&gt;功能强大且易于使用的配置选项。添加新来源、复制现有来源并轻松调整其属性；&lt;/li&gt;
&lt;li&gt;简化的设置面板使您可以访问各种配置选项，以调整广播或录制的各个方面；&lt;/li&gt;
&lt;li&gt;模块化的 “Dock” UI 允许您完全按照自己的喜好重新排列布局。您甚至可以将每个单独的 Dock 弹出到其自己的窗口。&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;值得一提的是，OBS Studio 配备了强大的 API，使插件和脚本能够根据您的需求提供进一步的定制和功能。利用本地插件进行高性能集成或使用 Lua 或 Python 编写的与现有源交互的脚本。与流媒体社区的开发人员合作，以无限可能获得您需要的功能。无论您是初级入门，还是专业视频创作人员，都能较为轻松的基于 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://obsproject.com/&quot; rel=&quot; nofollow ugc&quot;&gt;OBS Studio&lt;/a&gt; 录制精彩视频。&lt;/p&gt;

&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/623c7c48006c7408774a7c0e&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链 - Open Broadcaster Software | OBS&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E4%BA%BA%E6%96%87&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;人文&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E9%98%85%E8%AF%BB&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;阅读&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%9C%A8%E7%BA%BF&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;在线&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关键字&lt;/strong&gt;：道德经, 老子, 道德经全文, 道德经译文&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;/&gt;

&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/www.daodejing.org.png?x-oss-process=style/png2jpg&quot; title=&quot;&quot; alt=&quot;倾城之链 - 道德经网--老子道德经全文及译文&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://www.daodejing.org/&quot; rel=&quot; nofollow ugc&quot;&gt;道德经网&lt;/a&gt;，一个基于古老 Web 框架 ── ASP.NET 所搭建的网站，用以承载老子《道德经》全文及译文，以及老子其人的相关信息、智慧和故事等。&lt;/p&gt;

&lt;p&gt;《道德经》，是中国古代先秦诸子分家前的一部著作，为其时诸子所共仰，传说是春秋时期的老子李耳所撰写，是道家哲学思想的重要来源。道德经分上下两篇，原文上篇《德经》、下篇《道经》，不分章，后改为《道经》在前，《德经》在后，并分为 81 章,全文共约五千字，是中国历史上首部完整的&lt;code&gt;哲学&lt;/code&gt;著作。&lt;/p&gt;

&lt;p&gt;《道德经》常会被归属为道教学说。其实哲学上的道家，和宗教上的道教，是不能混为一谈的；但《道德经》作为道教基本教义的重要构成之一，被道教视为重要经典；其作者老子，也被道教视为至上的三清尊神之一道德天尊的化身，又称太上老君；所以应该说道教吸纳了道家思想，道家思想完善了道教。同时，前面所说的哲学，并不能涵括《道德经》（修身立命、治国安邦、出世入世）的全貌。《道德经》提出了“无为而治”的主张，&lt;strong&gt;无为而治&lt;/strong&gt;是道家的基本思想，也是其修行的基本方法。&lt;/p&gt;

&lt;p&gt;作为一种政治原则，“无为”在春秋末期已经出现。儒家也讲“无为而治”，如《论语·卫灵公》：“无为而治者，其舜也与？夫何为哉？恭己正南面而已矣”。朱熹认为“圣人德盛而民化，不待其有所作为也。“，实则表达了儒家的德治主张。使“无为而治”系统化而成为理论的是《老子》。他们认为统治者的一切作为都会破坏自然秩序，扰乱天下，祸害百姓。要求统治者无所作为，效法自然，让百姓自由发展。“无为而治”的理论根据是“道”，现实依据是变“乱”为“治”；“无为而治”的主要内容是“为无为”和“无为而无不为”，具体措施是“劝统治者少干涉”和“使民众无知无欲”。&lt;/p&gt;

&lt;p&gt;《道德经》并不像一般人所理解的那样，是一部论述「道德」的著作。事实上，道德二字，各有不同的概念。《道德经》，前三十七章讲道，后四十四章言德，简单说来，道是体，德是用，二者不能等同。&lt;/p&gt;

&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/623b2fc2006c7408774a7c0b&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链 - 道德经网--老子道德经全文及译文&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/AMP&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;AMP&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E8%90%A5%E9%94%80&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;营销&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E9%82%AE%E4%BB%B6&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;邮件&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;p&gt;Test drive AMP Emails without any code, and set up and send your first AMP email today. Get access to AMP Email industry updates, community, and more.&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/www.ampmails.com.png?x-oss-process=style/png2jpg&quot; title=&quot;&quot; alt=&quot;倾城之链 - AMP mails - Latest Templates, Use Cases, Expert Insights, Community &amp;amp; Best Practices&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://www.ampmails.com/&quot; rel=&quot; nofollow ugc&quot;&gt;AMP mails&lt;/a&gt;，可以帮助您在电子邮件中插入表单、日历、购物车、小部件等，以提高电子邮件参与度。立即在您的收件箱中收到这样一封 AMP 电子邮件。&lt;/p&gt;

&lt;h3&gt;什么是 AMP 电子邮件？&lt;/h3&gt;

&lt;p&gt;用于电子邮件的 AMP 是由 Google 开发的开放框架，旨在在电子邮件中创建流畅的网站式感觉，以改善用户体验。使用 AMP 电子邮件，人们可以发送带有 AMP 组件的电子邮件，通过允许读者在电子邮件本身内，采取诸如填写表格、或预订会议等操作，来使其具有交互性和吸引力。而且这些电子邮件是动态的，因此人们在这些表格或调查中提交的内容将实时更新。&lt;/p&gt;

&lt;h3&gt;AMP 电子邮件有何好处？&lt;/h3&gt;

&lt;ul&gt;&lt;li&gt;电子邮件之类的应用；&lt;/li&gt;
&lt;li&gt;动态内容；&lt;/li&gt;
&lt;li&gt;更好的电子邮件参与度；&lt;/li&gt;
&lt;li&gt;更高的投资回报率；&lt;/li&gt;
&lt;li&gt;安全技术；&lt;/li&gt;
&lt;li&gt;提高电子邮件转化率；&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;在 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://www.ampmails.com/&quot; rel=&quot; nofollow ugc&quot;&gt;AMP mails&lt;/a&gt;，您可以通过以下几个维度，了解如何实施 AMP 电子邮件，并创建 AMP 电子邮件：&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;💡 试驾各种 AMP 电子邮件；&lt;/li&gt;
&lt;li&gt;❤️ 了解现实生活中的用例和结果；&lt;/li&gt;
&lt;li&gt;✅ 加入论坛以分享您的问题和见解；&lt;/li&gt;
&lt;li&gt;🕹️ 阅读有关 AMP 电子邮件的博客和最新推文；&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;如果，您想了解更多关于 AMP mails，诸如：“哪些电子邮件客户端支持 AMP 电子邮件？“、“AMP 电子邮件是否有任何限制？“、“如何开始使用 AMP 电子邮件“、“AMP 电子邮件与 HTML 电子邮件的区别“等等，可以前往 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://www.ampmails.com/&quot; rel=&quot; nofollow ugc&quot;&gt;AMP mails 常问问题&lt;/a&gt;说明。&lt;/p&gt;

&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/623b2921006c7408774a7c09&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链 - AMP mails - Latest Templates, Use Cases, Expert Insights, Community &amp;amp; Best Practices&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E8%BD%AF%E4%BB%B6&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;软件&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E7%A8%8B%E5%BA%8F&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;程序&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%B9%B3%E5%8F%B0&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;平台&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;p&gt;Self-hosted and cloud-based application monitoring that helps software teams see clearer, solve quicker, &amp;amp; learn continuously.&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/sentry.io.png?x-oss-process=style/png2jpg&quot; title=&quot;&quot; alt=&quot;倾城之链 - Application Monitoring and Error Tracking Software | Sentry&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://www.swift.org/&quot; rel=&quot; nofollow ugc&quot;&gt;Sentry&lt;/a&gt;，是一个基于 Django 构建的现代化的实时事件日志监控、记录和聚合平台，主要用于如何快速的发现故障。支持几乎所有主流开发语言和平台，并提供了现代化 UI；它专门用于：&lt;strong&gt;监视错误&lt;/strong&gt;和提取执行适当的事后操作所需的所有信息，而无需使用标准用户反馈循环的任何麻烦。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/redirect?url=https://www.swift.org/&quot; rel=&quot; nofollow ugc&quot;&gt;Sentry&lt;/a&gt; 不仅仅是错误监控软件。它也是&lt;strong&gt;性能监控&lt;/strong&gt;软件。Sentry 平台可帮助每位开发人员诊断、修复和优化其代码的性能。使用 Sentry，世界各地的开发人员可以节省时间、精力，并可能节省一些治疗时间。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/redirect?url=https://www.swift.org/&quot; rel=&quot; nofollow ugc&quot;&gt;Sentry&lt;/a&gt; 支持 30 多种编码语言，比如：JavaScript、Node.js、Python、Android、Flutter、Go、&lt;code&gt;Kotlin&lt;/code&gt;、ServerLess、Ruby、Unity、Swift、Java 等等，这意味着它可能支持您的。它让开发者第一时间获悉错误信息，并方便的整合进自己和团队的工作流中；官方提供 saas 版本免费版支持每天 5000 个 Event，他们还集成了一大堆有用的工具（以及一些必要的弊端），包括但绝对不限于 GitHub、Slack 和 Jira。更值得一提的是，&lt;a href=&quot;https://nicelinks.site/redirect?url=https://www.swift.org/&quot; rel=&quot; nofollow ugc&quot;&gt;Sentry&lt;/a&gt; 是一个开源项目，您还可以根据需要，部署 Sentry 在自己的服务器。&lt;/p&gt;

&lt;p&gt;Sentry 支持自动收集和手动收集两种错误收集方法，我们能成功监控到 JavaScript 中的错误、异常，但是还不能捕捉到异步操作、接口请求中的错误，比如接口返回 404、500 等信息，此时我们可以通过 Sentry.caputureException() 进行主动上报。使用 Sentry 可结合两个部分，客户端与 sentry 服务端；客户端就像你需要去监听的对象，比如公司的前端项目，而服务端就是给你展示已搜集的错误信息，项目管理，组员等功能的一个服务平台。&lt;/p&gt;

&lt;p&gt;Sentry 最初是一个开源项目。其创始人的目标很简单：用一种简单的方法，来解决他们自己的错误，从而解决他们自己的问题。十年后，他们的两人激情项目成为世界领先的错误跟踪平台，在全球三个办事处拥有 130 名员工。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/redirect?url=https://www.swift.org/&quot; rel=&quot; nofollow ugc&quot;&gt;Sentry&lt;/a&gt;，有非常多的客户，诸如 &lt;a href=&quot;https://nicelinks.site/post/59ba80d93df6765c75b77911&quot; rel=&quot; nofollow ugc&quot;&gt;Github&lt;/a&gt;、reddit、vmware 等等；在国内，Sentry 也是最负盛名的错误监控服务，像前公司 &lt;a href=&quot;https://nicelinks.site/post/59ba81e73df6765c75b77913&quot; rel=&quot; nofollow ugc&quot;&gt;DJI ｜ 大疆&lt;/a&gt;等采用它来统计错误。笔者所维护的&lt;a href=&quot;https://nicelinks.site/post/5aa2579e56ee0d60651820c5&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链&lt;/a&gt;、&lt;a href=&quot;https://nicelinks.site/post/6143390948b293062990b351&quot; rel=&quot; nofollow ugc&quot;&gt;曼妙句子&lt;/a&gt;等 Web 应用，也都是使用 Sentry 来监控错误；这相当于给予我了一双&lt;code&gt;千里眼&lt;/code&gt;，感谢 Sentry。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Sentry&lt;/strong&gt;，从错误跟踪，到性能监控，开发人员可以看到真正重要的事情，更快地解决问题，并不断了解他们的应用程序：从前端到后端。通过 Sentry 的性能监控，您可以将性能问题追溯到性能不佳的 api 调用和缓慢的数据库查询。如果您也从事应用开发，相信 Sentry 类似服务，是产品级应用不可或缺的；而这 Sentry 是您最值得选取的服务，没有之一。&lt;/p&gt;

&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/62374518006c7408774a7c06&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链 - Application Monitoring and Error Tracking Software | Sentry&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E5%AF%BC%E8%88%AA&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;导航&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E7%BD%91%E7%AB%99&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;网站&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%88%86%E4%BA%AB&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;分享&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关键字&lt;/strong&gt;：uu 导航, 资源网, QQ 技术导航, 导航天下, 技术导航, 娱乐网, 小刀娱乐网, 爱 Q, QQ 技术, QQ 导航&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;p&gt;uu 导航-以最快的速度获取所求，为用户提供门户、新闻、视频、游戏、小说、彩票等各种分类的优秀内容和网站入口，提供简单便捷的上网导航服务。&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/www.daohanguu.com.png?x-oss-process=style/png2jpg&quot; title=&quot;&quot; alt=&quot;倾城之链 - UU导航 - 学技术，找资源。一网打尽&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://www.daohanguu.com/&quot; rel=&quot; nofollow ugc&quot;&gt;UU 导航&lt;/a&gt;，创建于 2021 年 4 月，致力于：为用户提供更简单、更实用、更贴心的导航服务。通过 &lt;code&gt;UU导航&lt;/code&gt;使您上网更轻松惬意、生活更便捷，是该团队努力的目标。UU 导航对收录内容做了以下分类：资源、活动、论坛、辅助、系统、社区、卡盟、发卡、支付、站长、游戏、CMS、博客、直播、IDC、下载、CDN、黑客、导航、其他。除了导航，该网站还提供了些其他内容，譬如 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://cms.daohanguu.com/&quot; rel=&quot; nofollow ugc&quot;&gt;UU 影视&lt;/a&gt;，播放流畅、无广告，初步体验还可以。&lt;/p&gt;

&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/62372ede006c7408774a7c04&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链 - UU 导航 - 学技术，找资源。一网打尽&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;对倾城之链感兴趣的朋友，可通过 Web，小程序，快应用等渠道进行访问(后续将支持更多，如 VsCode 插件，Chrome 扩展等)。您有任何问题，欢迎随时向我们反馈（您可以通过官网反馈渠道，或添加如下客服微信），🤲 。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://image.nicelinks.site/%E5%80%BE%E5%9F%8E%E4%B9%8B%E9%93%BE-%E5%BE%AE%E4%BF%A1-mini.jpeg&quot; title=&quot;&quot; alt=&quot;倾城之链 - 客服微信&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;本期文末寄语&lt;/h2&gt;

&lt;p&gt;无论多么美好的体验都会成为过去，无论多么深切的悲哀也会落在昨天，一如时光的流逝毫不留情。生命就像是一个疗伤的过程，我们受伤，痊愈，再受伤，再痊愈。&lt;strong&gt;每一次的痊愈好像都是为了迎接下一次的受伤。或许总要彻彻底底的绝望一次，才能重新再活一次&lt;/strong&gt;。── 当代作家 · 余华《第七天》&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链&lt;/a&gt;作为一个开放平台，旨在云集全球&lt;strong&gt;优秀网站&lt;/strong&gt;，探索互联网中更广阔的世界；在这里，你可以轻松发现、学习、分享更多有用或有趣的事物。&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://image.nicelinks.site/nicelinks-miniprogram-code.jpeg?imageView2/1/w/300/h/300/interlace/1/ignore-error/1&quot; title=&quot;&quot; alt=&quot;小程序码 - 倾城之链&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;您可能感兴趣的文章&lt;/h3&gt;



                &lt;/div&gt;
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>596a1ecc76d2f201e26f76f973d80b94</guid>
<title>错误码设计思考</title>
<link>https://toutiao.io/k/qas5y3j</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article class=&quot;markdown-body mt-4&quot;&gt;
        &lt;p&gt;在微服务化的今天，服务间的交互越来越复杂，统一异常处理规范作为框架的基础，一旦上线后很难再更改，如果设计不好，会导致后期的维护成本越来越来大。 对于错误码的设计，不同的开发团队有不同的风格习惯。本文分享作者从实践中总结的经验及对应的思考，期望对读者有所启发。&lt;/p&gt;
&lt;p&gt;本文中涉及的源码：&lt;a href=&quot;https://github.com/sofn/app-engine/tree/master/common-error&quot; target=&quot;_blank&quot;&gt;https://github.com/sofn/app-engine/tree/master/common-error&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;%E4%BB%80%E4%B9%88%E6%98%AF%E9%94%99%E8%AF%AF%E7%A0%81&quot; tabindex=&quot;-1&quot;&gt;什么是错误码&lt;/h1&gt;
&lt;p&gt;引自阿里巴巴《Java 开发手册》- 异常日志-错误码&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;错误码的制定原则：快速溯源、简单易记、沟通标准化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说明：错误码想得过于完美和复杂，就像康熙字典中的生僻字一样，用词似乎精准，但是字典不容易随身携带并且简单易懂。&lt;br/&gt;
正例：错误码回答的问题是谁的错？错在哪？&lt;br/&gt;
1）错误码必须能够快速知晓错误来源，可快速判断是谁的问题。&lt;br/&gt;
2）错误码易于记忆和比对（代码中容易 equals）。&lt;br/&gt;
3）错误码能够脱离文档和系统平台达到线下轻量化地自由沟通的目的。&lt;/p&gt;
&lt;p&gt;那么用Java异常能表示出来吗？答案显然是否定的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;必须能够快速知晓错误来源：异常类因为复用性不能很快的定位，异常类和代码行数也不是一个稳定的值&lt;/li&gt;
&lt;li&gt;必须易于记忆和对比：异常类不具有可比性，且不利于前后端交互&lt;/li&gt;
&lt;li&gt;能够脱离代码沟通：异常类只能存在于Java代码中&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;%E9%94%99%E8%AF%AF%E7%A0%81%E8%AE%BE%E8%AE%A1&quot; tabindex=&quot;-1&quot;&gt;错误码设计&lt;/h1&gt;
&lt;p&gt;错误码的设计是比较简单的，一般只需要定义一个数字和描述信息即可。不过想设计一套完善错误码系统还有很多需要考虑的场景。&lt;/p&gt;
&lt;h3 id=&quot;1%E3%80%81%E9%94%99%E8%AF%AF%E7%A0%81%E7%9A%84%E5%88%86%E5%B1%82&quot; tabindex=&quot;-1&quot;&gt;1、错误码的分层&lt;/h3&gt;
&lt;p&gt;大部分项目错误码设计分为3级能满足业务场景，即项目、模块、错误编码。比如错误码是6位，前两位是项目码、中间两位是模块码，最后两位是异常编号。以下是错误码10203的对应说明：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic.lesofn.com/image.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;2%E3%80%81%E9%94%99%E8%AF%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%EF%BC%9A%E6%9E%9A%E4%B8%BEor-%E7%B1%BB&quot; tabindex=&quot;-1&quot;&gt;2、错误的表示方法：枚举or 类&lt;/h3&gt;
&lt;p&gt;推荐使用枚举，因为枚举具有不可变性，且所有值都在一个文件里描述。&lt;/p&gt;
&lt;h3 id=&quot;3%E3%80%81%E5%A4%9A%E6%A8%A1%E5%9D%97%E9%94%99%E8%AF%AF%E7%A0%81%E5%AE%9A%E4%B9%89%E5%8F%8A%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89&quot; tabindex=&quot;-1&quot;&gt;3、多模块错误码定义及接口定义&lt;/h3&gt;
&lt;p&gt;最原始的错误定义方法是项目中所有的错误码都定义在一个类里，但是这样会随着业务的发展错误码越来越多，最终导致难以维护，推荐的做法是按照项目+模块粒度定义成多个错误码枚举类。有两个问题需要考虑：&lt;/p&gt;
&lt;p&gt;（1）项目编码、模块编码的维护：推荐另建一个枚举类统一维护&lt;/p&gt;
&lt;p&gt;（2）异常类的统一引用：定义接口，枚举类实现接口&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;//异常接口定义
public interface ErrorCode {
}
//模块定义
public enum UserProjectCodes {
    LOGIN(1, 1, &quot;登录模块&quot;),
    USER(1, 2, &quot;用户模块&quot;)
}
//登录模块异常码定义
public enum LoginErrorCodes implements ErrorCode {
    USER_NOT_EXIST(0, &quot;用户名不存在&quot;), //错误码: 10100
    PASSWORD_ERROR(1, &quot;密码错误&quot;);    //错误码: 10101
    
    private final int nodeNum;
    private final String msg;

    UserLoginErrorCodes(int nodeNum, String msg) {
        this.nodeNum = nodeNum;
        this.msg = msg;
        ErrorManager.register(UserProjectCodes.LOGIN, this);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;4%E3%80%81%E9%98%B2%E9%87%8D%E8%AE%BE%E8%AE%A1&quot; tabindex=&quot;-1&quot;&gt;4、防重设计&lt;/h3&gt;
&lt;p&gt;错误码本质上就是一个数字，且每一个都需要由RD编码定义，在错误码多的项目很容易重复。最佳实践是在枚举的构造方法里调用Helper类，Helper类统一维护所有的异常码，如有重复则枚举初始化失败。&lt;/p&gt;
&lt;h3 id=&quot;5%E3%80%81%E9%94%99%E8%AF%AF%E6%89%A9%E5%B1%95%E4%BF%A1%E6%81%AF&quot; tabindex=&quot;-1&quot;&gt;5、错误扩展信息&lt;/h3&gt;
&lt;p&gt;只有错误码是不够的，还需要反馈给调用方详细的错误信息已方便修正。固定的错误信息字符串在某些场景写也是不够的，这里推荐使用slf4j打日志时使用的动态参数，这种方式相比于String.format格式的好处是不需要关心参数的类型以及记忆%s、%d等的区别，且打印日志时经常使用，降低了团队成员的学习成本。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;//错误码定义
PARAM_ERROR(17, &quot;参数非法,期望得到:{},实际得到:{}&quot;)
//错误码使用
ErrorCodes.PARAM_ERROR.format(arg1, arg2);

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实现方式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;org.slf4j.helpers.MessageFormatter.arrayFormat(this.message, args).getMessage()  
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;%E9%94%99%E8%AF%AF%E7%A0%81%E5%92%8C%E5%BC%82%E5%B8%B8&quot; tabindex=&quot;-1&quot;&gt;错误码和异常&lt;/h1&gt;
&lt;p&gt;在日常业务开发中，对于异常使用最多的还是抛出Java异常（Exception），异常又分为受检查异常（Exception）和不受检查异常（RuntimeException）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;受检查的异常：这种在编译时被强制检查的异常称为&quot;受检查的异常&quot;。即在方法的声明中声明的异常。&lt;/li&gt;
&lt;li&gt;不受检查的异常：在方法的声明中没有声明，但在方法的运行过程中发生的各种异常被称为&quot;不被检查的异常&quot;。这种异常是错误，会被自动捕获。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1%E3%80%81%E5%BC%82%E5%B8%B8%E7%BB%91%E5%AE%9A%E9%94%99%E8%AF%AF%E7%A0%81&quot; tabindex=&quot;-1&quot;&gt;1、异常绑定错误码&lt;/h3&gt;
&lt;p&gt;定义两个父类，分别用于首检查异常和非受检查异常。可支持传入错误码，同时需要支持原始的异常传参，这种场景会赋予一个默认的错误码，比如：500服务器内部异常&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;//父类定义
public abstract class BaseException extends Exception {

    protected BaseException(String message) {...}

    protected BaseException(String message, Throwable cause) {...}

    protected BaseException(Throwable cause) {...}

    protected BaseException(ErrorInfo errorInfo) {...}

    protected BaseException(ErrorCode errorCode) {...}

    protected BaseException(ErrorCode errorCode, Object... args) {...}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;2%E3%80%81%E9%83%A8%E5%88%86%E5%BC%82%E5%B8%B8&quot; tabindex=&quot;-1&quot;&gt;2、部分异常&lt;/h3&gt;
&lt;p&gt;使用异常能适用于大部分场景，不过对于多条目的场景不是很适合，比如需要批量保存10条记录，某些成功、某些失败，这种场景就不适合直接抛出异常。&lt;/p&gt;
&lt;p&gt;在Node.js和Go语言中异常处理采用多返回值方式处理，第一个值是异常，如果为null则表示无异常。在Java里建议采用vavr库中的Either来实现，通常使用左值表示异常，而右值表示正常调用后的返回结果，即: Either&amp;lt;ErrorCode, T&amp;gt;&lt;/p&gt;
&lt;p&gt;注意不推荐Pair、Tuple来实现，因为Either只能设置一个左值或右值，而Pair、Tuple无此限制。&lt;/p&gt;
&lt;h1 id=&quot;%E9%94%99%E8%AF%AF%E7%A0%81%E5%92%8C%E7%BB%9F%E4%B8%80%E8%BF%94%E5%9B%9E%E5%80%BC&quot; tabindex=&quot;-1&quot;&gt;错误码和统一返回值&lt;/h1&gt;
&lt;p&gt;在前后端的交互中，后端一般使用JSON方式返回结果，整合前面说的错误码，可定义以下格式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;{
   &quot;code&quot;: number,
   &quot;msg&quot;: string,
   &quot;data&quot;: object
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在SpringMVC中实现方式是自定义ResponseBodyAdvice和异常拦截，具体实现方式直接查看：&lt;a href=&quot;https://github.com/sofn/app-engine/tree/master/common-error/src/main/java/com/lesofn/appengine/common/error/springmvc&quot; target=&quot;_blank&quot;&gt;源码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;实现了以上步骤之后就可以在SpringMVC框架中愉快的使用了，会自动处理异常及封装成统一返回格式&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;    @GetMapping(&quot;/order&quot;)
    public Order getOrder(Long orderId) {
        return service.findById(orderId);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;%E6%80%BB%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;总结&lt;/h1&gt;
&lt;p&gt;本文总结了设计错误码需要考虑的各种因素，并给出了参考示例，基本能满足一般中大型项目。规范有了最重要的还是落地，让团队成员遵守规范才能让项目健康的迭代。&lt;/p&gt;
&lt;p&gt;源码地址：&lt;a href=&quot;https://github.com/sofn/app-engine/tree/master/common-error&quot; target=&quot;_blank&quot;&gt;https://github.com/sofn/app-engine/tree/master/common-error&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文链接：&lt;a href=&quot;https://lesofn.com/archives/errorcode-design&quot; target=&quot;_blank&quot;&gt;错误码设计思考&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者简介：木小丰，美团Java技术专家，专注分享软件研发实践、架构思考。欢迎关注公共号：&lt;strong&gt;Java研发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blogpic.chekuspace.com/%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%B0%8F_1607785087313.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;更多精彩文章：&lt;br/&gt;
&lt;a href=&quot;https://lesofn.com/archives/threadpool-advance&quot; target=&quot;_blank&quot;&gt;Java线程池进阶&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;https://lesofn.com/archives/mvn-to-ddd-architecture&quot; target=&quot;_blank&quot;&gt;从MVC到DDD的架构演进&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;https://lesofn.com/archives/ping-tai-hua-jian-she-si-lu-qian-tan&quot; target=&quot;_blank&quot;&gt;平台化建设思路浅谈&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;https://lesofn.com/archives/gou-jian-ke-hui-gun-de-ying-yong-ji-shang-xian-checklist-shi-jian&quot; target=&quot;_blank&quot;&gt;构建可回滚的应用及上线checklist实践&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;https://lesofn.com/archives/maven-yi-lai-chong-tu-wen-ti-pai-cha-jing-yan&quot; target=&quot;_blank&quot;&gt;Maven依赖冲突问题排查经验&lt;/a&gt;&lt;/p&gt;

    &lt;/article&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ef332bb22c48bb0b28e06c1f1f20a2d1</guid>
<title>盘点俄罗斯大神写的几款软件，你用过几个？最后一个是我的童年！</title>
<link>https://toutiao.io/k/tr0bzf8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;俄乌之战已经打了两周了，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;美丽国、北约对俄罗斯采取了全方位的封锁，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;金融、手机APP、《天鹅湖》、别墅、游轮、足球、甚至猫都被区别对待，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于这场战争的起因，相信各位看官可以到各大媒体看各种专家的解读，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于孰是孰非，一口君就不班门弄斧了，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非要一口君的看法，那只有一句话：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;坚定的支持国家的立场！&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面只说一些和软件相关的一些制裁，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;苹果关闭了俄罗斯所有苹果手机的部分功能，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;导致很多用户无法乘坐地铁。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1160714285714286&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc8st9SrIibzBFd0JqtMWASpKJUmW7WRLWclaMLO5deCfB2uHibA51zTYBicDFLMOnYK2S7O6Rpb9rX9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;896&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;俄罗斯军事实力毋庸置疑，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是就是这么个庞大的国家，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;软件也受制于美丽国，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时我们就看出鸿蒙系统的重要性了，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那些之前嘲讽华为的，可以把嘴闭上了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么俄罗斯的软件水平到底如何呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面一口君给大家列举一些比较由俄罗斯大神编写的软件。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 7zip&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;7-Zip 作者：&lt;strong&gt;abhishek prakash&lt;/strong&gt;，是一款 开源 的 免费 软件。大多数源代码都基于 GNU LGPL 许可协议下发布。部分代码基于 BSD 3 句条款（BSD 3-clause）许可协议发布。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以在任何一台计算机上使用 7-Zip ，包括用在商业用途的计算机。不对 7-Zip 进行注册或支付费用并不影响您的使用。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5476429287863591&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc8st9SrIibzBFd0JqtMWASpKicwuibFps2bZtBXLRX1HEM4MFW6dm5rL20lyjJYtzfCMuXp1h8zR7Lqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;997&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;7-zip，最好用的压缩解压缩软件，&lt;strong&gt;很多收费软件都是用它做内核，而且没有任何广告&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;英文网址：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;https://www.7-zip.org/&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;中文网址&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;https://sparanoid.com/lab/7z/&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7-Zip 主要特征&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;使用了 LZMA 与 LZMA2 算法的 7z 格式 拥有极高的压缩比&lt;br/&gt;支持格式：&lt;br/&gt;    压缩 / 解压缩：7z、XZ、BZIP2、GZIP、TAR、ZIP 以及 WIM&lt;br/&gt;    仅解压缩：AR、ARJ、CAB、CHM、CPIO、CramFS、DMG、EXT、FAT、GPT、HFS、IHEX、ISO、LZH、LZMA、MBR、MSI、NSIS、NTFS、QCOW2、RAR、RPM、SquashFS、UDF、UEFI、VDI、VHD、VMDK、WIM、XAR 以及 Z&lt;br/&gt;与 ZIP 及 GZIP 格式相比，7-Zip 能提供比使用 PKZip 及 WinZip 高 2-10% 的压缩比&lt;br/&gt;为 7z 与 ZIP 提供更完善的 AES-256 加密算法&lt;br/&gt;7z 格式支持创建自释放压缩包&lt;br/&gt;Windows 资源管理器集成&lt;br/&gt;强大的文件管理器&lt;br/&gt;强大的命令行版本&lt;br/&gt;支持 FAR Manager 插件&lt;br/&gt;支持 87 种语言&lt;br/&gt;7-Zip 适用于 Windows 10 / 8 / 7 / Vista / XP / 2016 / 2012 / 2008 / 2003 / 2000 / NT。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让我们用 7-Zip 和 WinRAR 5.20 进行比较：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.426344505066251&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc8st9SrIibzBFd0JqtMWASpKWB0ialDmeUH8nviaIFXeJaRQVfeYv2oNj1Y6HlmehraD1SmG4bUyYhRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1283&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面整理了一下这款软件一些特点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;画面简洁，没有广告。（这个不是什么优点，这是基本操作。主要是国内跪的太久了，把没广告也当优点，就像孝顺还要人表扬一样，这不是理所应当吗）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持tar.gz tar.bz2的unix常用格式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有检验工具sha等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;界面，图标，也不错，还可以深度自定义。这是我组一套，图标是偷某压的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;操作速度快，不是指压缩和解压，是指右键那些，像bandizip（收费）和peazip响应有点慢。winrar用的响应也非常快。7zip和他相当。国内的就不提了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;zip和7z都能用aes256加密&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;7z格式速度慢，不算缺点，主要是格式的特性，7z压缩率高，速度就慢些。平时基本不用。主要用zip。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;缺点，7z格式容易坏包。这个问题对安全性要求高的就用zip或rar吧。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;优点，不是出身美丽国，不会成为万恶霉国祸害我们的工具。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基本功能稳定，操作简单，免费安全不用担心后门，借用曹公一句话，今天下英雄，唯使君(指winrar)与操(指7zip)耳。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 卡帕斯基&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;卡巴斯基反病毒软件创始人：&lt;strong&gt;尤金·卡巴斯基&lt;/strong&gt;是世界上拥有最尖端科技的杀毒软件之一，总部设在俄罗斯首都莫斯科，全名“卡巴斯基实验室”，是国际著名的信息安全领导厂商。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;曾经美国军方也使用这款杀毒软件，后来因为泄密问题被停用。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.45229007633587787&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc8st9SrIibzBFd0JqtMWASpKc7knG7zojyZKwic5nv7O4E48kAZ1TJPIYepwg9r63xiamUSjmHpVvjSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;524&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面总结点这款软件特点：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;卡巴斯基的优点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;1.查杀能力强，曾经一台被病毒搞的经常蓝屏的机子装上卡巴杀出500多个病毒后起死回生。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2.软件界面清爽，进程保护功能还可以，不过还是能被Icesword结束的，建议采取进程被结束后再自动开启的技术。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;3.更新速度快，这是其他杀软不能比的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;4.主动防御功能是技术亮点，这让很多木马加壳后也难逃法眼。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺点：卡巴斯基的缺点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;1.防盗版工作太差（呵呵，这样我们才用卡巴）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2.发现病毒，报警声（杀猪）太可怕。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;3.有误报现象，6.0更为严重，比如把QQ游戏的安装程序，金山词霸（因为xdict.exe要进行进程注入），windows优化大师带的流氓软件清理&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;4.全盘扫描过慢，这点一直为大家不爽。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;5.多数情况下对国产的流氓软件无能为力，包括弹网页这类流氓，对这类流氓的.dll和.sys文件视而不见，即使发现也无力删除。对国产木马的服务端识别还是不错的，但是对运行服务端生成的.dll和.exe识别不了。一个国产的木马到现在都三个多月了，卡巴6.0还是认不出。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;6.有时病毒改了系统关联，这样卡巴就会把系统文件删掉，导致系统瘫痪。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3 Nginx&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Nginx (engine x) 作者：伊戈尔·赛索耶夫。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Nginx 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一个公开版本0.1.0发布于2004年10月4日。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;中国大陆使用nginx网站用户有：&lt;strong&gt;百度、京东、新浪、网易、腾讯、淘宝&lt;/strong&gt;等。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4453125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc8st9SrIibzBFd0JqtMWASpKKZAbsP5UjvqDcjUiaeBHBfUsoxiaNqv0Ig4uPicv64Wo0816sa7RTuRrA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;nginx横空出世之前，Apache服务器一直占据web服务器的垄断地位，所以就用对比的方式来解释nginx那么强！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两者性能差别的主要原因在于网络IO模型选择不同，apache使用了select，而nginx使用了epoll模型！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Nginx 的5个主要优点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;高并发、高性能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可扩展性好&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;高可靠性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;热部署&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;BSD许可证&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最重要是的他有&lt;strong&gt;开源免费版本&lt;/strong&gt;，这个是大家都喜欢的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. MT外汇交易平台&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MetaTrader 外汇业务在线交易平台软件，通用客户端。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;据不完全统计，全世界85%的证券公司首选的股指交易专用软件&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是俄国人所编写，外汇、期货和CFD交易提供经纪服务的专业在线交易平台，最成熟版本为MetaTrader 4因此简称(MT4)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MT4是一个集成平台，在使用MT4时您将不需要再使用其他软件来获得金融服务。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc8st9SrIibzBFd0JqtMWASpKQmlzaNAu1pEgWs5K4MGqBMyX3oMu2qqfSV1ICvrSWCmgDbulvffqhQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;512&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. IJ(IntelliJ IDEA)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;IDEA 全称 IntelliJ IDEA，是java编程语言开发的集成环境。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;IntelliJ在业界被公认为最好的java开发工具，尤其在智能代码助手、代码自动提示、重构、JavaEE支持、各类版本工具(git、svn等)、JUnit、CVS整合、代码分析、 创新的GUI设计等方面的功能可以说是超常的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;IDEA是JetBrains公司的产品，这家公司总部位于捷克共和国的首都布拉格，开发人员以严谨著称的东欧程序员为主。它的旗舰版本还支持HTML，CSS，PHP，MySQL，Python等。免费版只支持Java,Kotlin等少数语言。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.36835164835164835&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc8st9SrIibzBFd0JqtMWASpKJvB4HXHvdRicmSMSgvA4wuQCU2Ewojq2eibNCnsQ6PwMLJhLCyMgicia7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2275&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6994047619047619&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc8st9SrIibzBFd0JqtMWASpKmlCjpGHcWzyzibW5ks2KJSW3SHz2vmqnCKRglM7hoIJ7AEu1eY5w5rg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2016&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下载地址：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;https://www.jetbrains.com/idea/&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. winrar&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;WinRAR是一个文件压缩管理共享软件，由Eugene Roshal（所以RAR的全名是：Roshal ARchive）开发。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc8st9SrIibzBFd0JqtMWASpKiacwNl9Qia9HVFliaLQM8ESiakzstM09oWUNTbebbrjTb5Ztjf0R0SWgJw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;200&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Eugene Roshal，1972年3月10日生于俄罗斯。毕业于俄罗斯车里雅宾斯克工业大学。也是FAR文件管理器的作者。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6422594142259415&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc8st9SrIibzBFd0JqtMWASpK0bqlKeHH5AI8cTUz45gEZOcweaoglyHxphwVMuBCDV6nuzonlGqdRg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;478&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;他开发程序压缩/解压RAR文件，最初用于DOS，后来移植到其它平台。主要的Windows版本编码器，称为WinRAR，以共享软件的形式发行。不过Roshal公开了解码器源码，UnRAR解码器许可证允许有条件自由发布与修改（条件：不许发布编译RAR兼容编码器）。而RAR编码器一直是有专利的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首个公开版本RAR 1.3发布于1993年。Pocket RAR是为Pocket PC平台发布的免费软件。它是仅有的几个可以读写RAR文件的软件之一，因为它保留版权。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7. SprutCAM&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SprutCAM 是一款功能强大的CAD加工编程软件，拥有强大的模型编辑及修改、加工工艺制定、加工过程仿真、NC程序后置处理器等，支持车削、去毛刺、热处理、铸造、雕刻、喷涂、打磨、抛光、3D打印等&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6050420168067226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc8st9SrIibzBFd0JqtMWASpKlibTsR0mdYXxCSXlUJZp6nX2OSOl2pLKKQfu6ze2kNpd3caiapPnmeKw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;595&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6591666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc8st9SrIibzBFd0JqtMWASpKpWHJsTIM7X7Wdsx1HxqbIDTZa4GLkfjsRiaMqVa5WM4I5zPNKUv5IzA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1200&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5644753476611883&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc8st9SrIibzBFd0JqtMWASpKkFORSoJ8eEvlia1RZEIFj3icSl9PEBqBXaFw8SSZEI2yiacwNmbhf4GSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1582&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8. 各种破解软件&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个就不用多说了，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多破解软件都是出自俄罗斯大牛之手！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9. Abbyy  fineReader&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文本扫描领域占有一席之地&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7384615384615385&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc8st9SrIibzBFd0JqtMWASpKWB6xrskPynSiaL3hLfgXxx7eENrRx3xuubXm81lDvGUDLxibLibSDj4vA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;390&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10. ClickHouse:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Yandex 开源的数据库&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc8st9SrIibzBFd0JqtMWASpKW3T5q7lVE5WiaETxGQbAoLlkgPaQiaicNbkhkbfeLsR1icGsWzD2fVGaUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;480&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;11. Telegram：&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安全通信领域独树一帜，国内用户不少&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.39418254764292876&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc8st9SrIibzBFd0JqtMWASpKex5RQjgm1xeG6Y3v6mhgwC3Fib8h8F2GqLTesRFsLljnGTFcdjkDCAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;997&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;12. KOMPAS-3D：&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3D专注建模领域，有自己的特色&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5633333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc8st9SrIibzBFd0JqtMWASpK8Xfp2belPAwJ2fBx2TQibjjFJIEzWDMRjQRwulM7gicmmibZK33uicWZ7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6163333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc8st9SrIibzBFd0JqtMWASpK5TG2ibKI41t5DN20z602XDWCDN4GQH38oq2hwY7iaGtLCwrSXDziavYQA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3000&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;13. dsc-world ：&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;模拟战机 也是相当牛逼&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5559030492572322&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc8st9SrIibzBFd0JqtMWASpKQialLQceMREf1OEZMTHribKcBxOrfIX58YgwQq2tiauDHgeaia5CgQ7e6g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1279&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6246803069053708&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc8st9SrIibzBFd0JqtMWASpKOBqlTK2KoTpgPXUOS78Hm1MzviajO35uXmUiaiadicibic8kbahicbIUnDT6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1564&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;14. 三维导师&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能是用的最广的模拟驾驶软件&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5066864784546805&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc8st9SrIibzBFd0JqtMWASpKj4Asb61jrLicNECQXEN5NPfPFibBYicwXtQpn3ydmTibN164icfMXjoCfmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1346&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc8st9SrIibzBFd0JqtMWASpKsI7XWYyHV45TGKqvzjeIsibnnLmaALJMQxbUNh00Y2UqRicT6tkJS4tQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;15. 俄罗斯方块&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;《俄罗斯方块》（Tetris， 俄文：Тетрис）是一款由俄罗斯人阿列克谢·帕基特诺夫于1984年6月发明的休闲游戏。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;玩过下面这个游戏的老铁，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;孩子至少上小学了吧！&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.3821656050955413&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc8st9SrIibzBFd0JqtMWASpKT9hcyPCSwbFqcLKKrGFZkUH1hAHyAmPxEjbs82bYTNbcibA4EHgzcWw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;314&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该游戏曾经被多家公司代理过。经过多轮诉讼后，该游戏的代理权最终被任天堂获得。任天堂对于俄罗斯方块来说意义重大，因为将它与GB搭配在一起后，获得了巨大的成功。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家是不是对俄罗斯软件有些新的认识了！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后希望这个世界永远没有战争！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;世界和平！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（完）&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MjM5MzA0ODkyMA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavibl7LIJIZn2AGvPibKqPgCqttHfv5QoBiaWnyBmH1rcE3q6YVTbz3M9Xl8pfibXgBt6npibB45tpwmYWA/0?wx_fmt=png&quot; data-nickname=&quot;我爱程序员&quot; data-alias=&quot;developerWorks&quot; data-signature=&quot;我们的产品：《码农周刊》 http://manong.io/ 、《开发者头条》 http://toutiao.io/&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1e842bde57497f2e560716e91479bfcc</guid>
<title>深入揭秘 epoll 是如何实现 IO 多路复用的</title>
<link>https://toutiao.io/k/ida2g9n</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：yanfeizhang，腾讯 PCG 后开开发工程师&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;提起 epoll，大家都不陌生，知道它性能不错。但是它内部是如何工作的，如何达到高性能的效果呢，鲜有文章能把原理介绍清楚，所以我就撸起袖子搞了一篇文章，献给大家。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进程在 Linux 上是一个开销不小的家伙，先不说创建，光是上下文切换一次就得几个微秒。所以为了高效地对海量用户提供服务，必须要让一个进程能同时处理很多个 tcp 连接才行。现在假设一个进程保持了 10000 条连接，那么如何发现哪条连接上有数据可读了、哪条连接可写了 ？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们当然可以采用循环遍历的方式来发现 IO 事件，但这种方式太低级了。我们希望有一种更高效的机制，在很多连接中的某条上有 IO 事件发生的时候直接快速把它找出来。其实这个事情 Linux 操作系统已经替我们都做好了，它就是我们所熟知的 &lt;strong&gt;IO 多路复用&lt;/strong&gt;机制。这里的复用指的就是对进程的复用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Linux 上多路复用方案有 select、poll、epoll。它们三个中 epoll 的性能表现是最优秀的，能支持的并发量也最大。所以我们今天把 epoll 作为要拆解的对象，深入揭秘内核是如何实现多路的 IO 管理的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了方便讨论，我们举一个使用了 epoll 的简单示例（只是个例子，实践中不这么写）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    listen(lfd, ...);&lt;br/&gt;&lt;br/&gt;    cfd1 = accept(...);&lt;br/&gt;    cfd2 = accept(...);&lt;br/&gt;    efd = epoll_create(...);&lt;br/&gt;&lt;br/&gt;    epoll_ctl(efd, EPOLL_CTL_ADD, cfd1, ...);&lt;br/&gt;    epoll_ctl(efd, EPOLL_CTL_ADD, cfd2, ...);&lt;br/&gt;    epoll_wait(efd, ...)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中和 epoll 相关的函数是如下三个：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;epoll_create：创建一个 epoll 对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;epoll_ctl：向 epoll 对象中添加要管理的连接&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;epoll_wait：等待其管理的连接上的 IO 事件&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;借助这个 demo，我们来展开对 epoll 原理的深度拆解。相信等你理解了这篇文章以后，你对 epoll 的驾驭能力将变得炉火纯青！！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;友情提示，万字长文，慎入！！&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一、accept 创建新 socket&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们直接从服务器端的 accept 讲起。当 accept 之后，进程会创建一个新的 socket 出来，专门用于和对应的客户端通信，然后把它放到当前进程的打开文件列表中。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3532219570405728&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavxOaOL8PgTuqHG7gFSzfYsFdRcRAg6n2bib68a2sr9JUlxexbibclVfEYvj7393JK4diaJcVmkEEpwg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;838&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中一条连接的 socket 内核对象更为具体一点的结构图如下。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7654155495978552&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavxOaOL8PgTuqHG7gFSzfYsr3H3gJgmtZJotxlWrooyrfEib8X6NvCyRVicfr4kibgCKIHxzf8Ktq6Mw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;746&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们来看一下接收连接时 socket 内核对象的创建源码。accept 的系统调用代码位于源文件 net/socket.c 下。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: net/socket.c&lt;/span&gt;&lt;br/&gt;SYSCALL_DEFINE4(accept4, &lt;span&gt;int&lt;/span&gt;, fd, struct sockaddr __user *, upeer_sockaddr,&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; __user *, upeer_addrlen, &lt;span&gt;int&lt;/span&gt;, flags)&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;socket&lt;/span&gt; *&lt;span&gt;sock&lt;/span&gt;, *&lt;span&gt;newsock&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//根据 fd 查找到监听的 socket&lt;/span&gt;&lt;br/&gt;    sock = sockfd_lookup_light(fd, &amp;amp;err, &amp;amp;fput_needed);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//1.1 申请并初始化新的 socket&lt;/span&gt;&lt;br/&gt;    newsock = sock_alloc();&lt;br/&gt;    newsock-&amp;gt;type = sock-&amp;gt;type;&lt;br/&gt;    newsock-&amp;gt;ops = sock-&amp;gt;ops;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//1.2 申请新的 file 对象，并设置到新 socket 上&lt;/span&gt;&lt;br/&gt;    newfile = sock_alloc_file(newsock, flags, sock-&amp;gt;sk-&amp;gt;sk_prot_creator-&amp;gt;name);&lt;br/&gt;    ......&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//1.3 接收连接&lt;/span&gt;&lt;br/&gt;    err = sock-&amp;gt;ops-&amp;gt;accept(sock, newsock, sock-&amp;gt;file-&amp;gt;f_flags);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//1.4 添加新文件到当前进程的打开文件列表&lt;/span&gt;&lt;br/&gt;    fd_install(newfd, newfile);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.1 初始化 struct socket 对象&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上述的源码中，首先是调用 sock_alloc 申请一个 struct socket 对象出来。然后接着把 listen 状态的 socket 对象上的协议操作函数集合 ops 赋值给新的 socket。（对于所有的 AF_INET 协议族下的 socket 来说，它们的 ops 方法都是一样的，所以这里可以直接复制过来）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.45596868884540115&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavxOaOL8PgTuqHG7gFSzfYsbjZreGlqj8sibSufEqLVuItTk8oOGSz6XRlvuLJDZr21YkiceUyHIbyw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;511&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中 inet_stream_ops 的定义如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: net/ipv4/af_inet.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;proto_ops&lt;/span&gt; &lt;span&gt;inet_stream_ops&lt;/span&gt; = {&lt;/span&gt;&lt;br/&gt;    ...&lt;br/&gt;    .accept        = inet_accept,&lt;br/&gt;    .listen        = inet_listen,&lt;br/&gt;    .sendmsg       = inet_sendmsg,&lt;br/&gt;    .recvmsg       = inet_recvmsg,&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2 为新 socket 对象申请 file&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;struct socket 对象中有一个重要的成员 -- file 内核对象指针。这个指针初始化的时候是空的。在 accept 方法里会调用 sock_alloc_file 来申请内存并初始化。然后将新 file 对象设置到 sock-&amp;gt;file 上。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2408660351826793&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavxOaOL8PgTuqHG7gFSzfYsPZvnTHicv9m6zibkT5vVx2ib76tNv5OIpq5ta39Jr6gqA4kDgebpLKy6g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;739&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来看 sock_alloc_file 的实现过程：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;struct file *&lt;span&gt;sock_alloc_file&lt;/span&gt;&lt;span&gt;(struct socket *sock, &lt;span&gt;int&lt;/span&gt; flags,&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *dname)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;file&lt;/span&gt; *&lt;span&gt;file&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    file = alloc_file(&amp;amp;path, FMODE_READ | FMODE_WRITE,&lt;br/&gt;            &amp;amp;socket_file_ops);&lt;br/&gt;    ......&lt;br/&gt;    sock-&amp;gt;file = file;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sock_alloc_file 又会接着调用到 alloc_file。注意在 alloc_file 方法中，把 socket_file_ops 函数集合一并赋到了新 file-&amp;gt;f_op 里了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: fs/file_table.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;struct file *&lt;span&gt;alloc_file&lt;/span&gt;&lt;span&gt;(struct path *path, &lt;span&gt;fmode_t&lt;/span&gt; mode,&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; struct file_operations *fop)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;file&lt;/span&gt; *&lt;span&gt;file&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    file-&amp;gt;f_op = fop;&lt;br/&gt;    ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;socket_file_ops 的具体定义如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: net/socket.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;file_operations&lt;/span&gt; &lt;span&gt;socket_file_ops&lt;/span&gt; = {&lt;/span&gt;&lt;br/&gt;    ...&lt;br/&gt;    .aio_read   = sock_aio_read,&lt;br/&gt;    .aio_write  = sock_aio_write,&lt;br/&gt;    .poll     = sock_poll,&lt;br/&gt;    .release  = sock_close,&lt;br/&gt;    ...&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里看到，在 accept 里创建的新 socket 里的 file-&amp;gt;f_op-&amp;gt;poll 函数指向的是 sock_poll。接下来我们会调用到它，后面我们再说。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;其实 file 对象内部也有一个 socket 指针，指向 socket 对象。&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.3 接收连接&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 socket 内核对象中除了 file 对象指针以外，有一个核心成员 sock。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: include/linux/net.h&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;socket&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;file&lt;/span&gt;     *&lt;span&gt;file&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;sock&lt;/span&gt;     *&lt;span&gt;sk&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个 struct sock 数据结构非常大，是 socket 的核心内核对象。发送队列、接收队列、等待队列等核心数据结构都位于此。其定义位置文件 include/net/sock.h，由于太长就不展示了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 accept 的源码中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: net/socket.c&lt;/span&gt;&lt;br/&gt;SYSCALL_DEFINE4(accept4, ...)&lt;br/&gt;    ...&lt;br/&gt;    &lt;span&gt;//1.3 接收连接&lt;/span&gt;&lt;br/&gt;    err = sock-&amp;gt;ops-&amp;gt;accept(sock, newsock, sock-&amp;gt;file-&amp;gt;f_flags);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sock-&amp;gt;ops-&amp;gt;accept&lt;/code&gt; 对应的方法是 inet_accept。它执行的时候会从握手队列里直接获取创建好的 sock。sock 对象的完整创建过程涉及到三次握手，比较复杂，不展开了说了。咱们只看 struct sock 初始化过程中用到的一个函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;sock_init_data&lt;/span&gt;&lt;span&gt;(struct socket *sock, struct sock *sk)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    sk-&amp;gt;sk_wq   =   &lt;span&gt;NULL&lt;/span&gt;;&lt;br/&gt;    sk-&amp;gt;sk_data_ready   =   sock_def_readable;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;在这里把 sock 对象的 sk_data_ready 函数指针设置为 sock_def_readable&lt;/strong&gt;。这个这里先记住就行了，后面会用到。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.4 添加新文件到当前进程的打开文件列表中&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 file、socket、sock 等关键内核对象创建完毕以后，剩下要做的一件事情就是把它挂到当前进程的打开文件列表中就行了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: fs/file.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;fd_install&lt;/span&gt;&lt;span&gt;(&lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; fd, struct file *file)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    __fd_install(current-&amp;gt;files, fd, file);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;void&lt;/span&gt; __fd_install(struct files_struct *files, &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; fd,&lt;br/&gt;        struct file *file)&lt;br/&gt;{&lt;br/&gt;    ...&lt;br/&gt;    fdt = files_fdtable(files);&lt;br/&gt;    BUG_ON(fdt-&amp;gt;fd[fd] != &lt;span&gt;NULL&lt;/span&gt;);&lt;br/&gt;    rcu_assign_pointer(fdt-&amp;gt;fd[fd], file);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二、epoll_create 实现&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在用户进程调用 epoll_create 时，内核会创建一个 struct eventpoll 的内核对象。并同样把它关联到当前进程的已打开文件列表中。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.37775061124694376&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavxOaOL8PgTuqHG7gFSzfYsp4RL6icgUEfOXWTAUIT4bSY0bib0faI0r3hkC2zg3zpaJ5dcLklrGoFw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;818&quot;/&gt;&lt;figcaption&gt;2_files&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 struct eventpoll 对象，更详细的结构如下（同样只列出和今天主题相关的成员）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4196277495769882&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavxOaOL8PgTuqHG7gFSzfYsJLspzNlUC9jTCDUhv65QT5zWfstLRpQRbh9xagZxEzmFeTbgGo5IMw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;591&quot;/&gt;&lt;figcaption&gt;2_eventepoll&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;epoll_create 的源代码相对比较简单。在 fs/eventpoll.c 下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// file：fs/eventpoll.c&lt;/span&gt;&lt;br/&gt;SYSCALL_DEFINE1(epoll_create1, &lt;span&gt;int&lt;/span&gt;, flags)&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;eventpoll&lt;/span&gt; *&lt;span&gt;ep&lt;/span&gt; = &lt;span&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//创建一个 eventpoll 对象&lt;/span&gt;&lt;br/&gt;    error = ep_alloc(&amp;amp;ep);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;struct eventpoll 的定义也在这个源文件中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// file：fs/eventpoll.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;eventpoll&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//sys_epoll_wait用到的等待队列&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;wait_queue_head_t&lt;/span&gt; wq;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//接收就绪的描述符都会放到这里&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;list_head&lt;/span&gt; &lt;span&gt;rdllist&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//每个epoll对象中都有一颗红黑树&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;rb_root&lt;/span&gt; &lt;span&gt;rbr&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;eventpoll 这个结构体中的几个成员的含义如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;wq：&lt;/strong&gt; 等待队列链表。软中断数据就绪的时候会通过 wq 来找到阻塞在 epoll 对象上的用户进程。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;rbr：&lt;/strong&gt; 一棵红黑树。为了支持对海量连接的高效查找、插入和删除，eventpoll 内部使用了一棵红黑树。通过这棵树来管理用户进程下添加进来的所有 socket 连接。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;rdllist：&lt;/strong&gt; 就绪的描述符的链表。当有的连接就绪的时候，内核会把就绪的连接放到 rdllist 链表里。这样应用进程只需要判断链表就能找出就绪进程，而不用去遍历整棵树。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然这个结构被申请完之后，需要做一点点的初始化工作，这都在 ep_alloc 中完成。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: fs/eventpoll.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;ep_alloc&lt;/span&gt;&lt;span&gt;(struct eventpoll **pep)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;eventpoll&lt;/span&gt; *&lt;span&gt;ep&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//申请 epollevent 内存&lt;/span&gt;&lt;br/&gt;    ep = kzalloc(&lt;span&gt;sizeof&lt;/span&gt;(*ep), GFP_KERNEL);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//初始化等待队列头&lt;/span&gt;&lt;br/&gt;    init_waitqueue_head(&amp;amp;ep-&amp;gt;wq);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//初始化就绪列表&lt;/span&gt;&lt;br/&gt;    INIT_LIST_HEAD(&amp;amp;ep-&amp;gt;rdllist);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//初始化红黑树指针&lt;/span&gt;&lt;br/&gt;    ep-&amp;gt;rbr = RB_ROOT;&lt;br/&gt;&lt;br/&gt;    ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说到这儿，这些成员其实只是刚被定义或初始化了，还都没有被使用。它们会在下面被用到。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三、epoll_ctl 添加 socket&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;理解这一步是理解整个 epoll 的关键&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了简单，我们只考虑使用 EPOLL_CTL_ADD 添加 socket，先忽略删除和更新。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设我们现在和客户端们的多个连接的 socket 都创建好了，也创建好了 epoll 内核对象。在使用 epoll_ctl 注册每一个 socket 的时候，内核会做如下三件事情&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;1.分配一个红黑树节点对象 epitem，&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2.添加等待事件到 socket 的等待队列中，其回调函数是 ep_poll_callback&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;3.将 epitem 插入到 epoll 对象的红黑树里&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 epoll_ctl 添加两个 socket 以后，这些内核数据结构最终在进程中的关系图大致如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.548502994011976&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavxOaOL8PgTuqHG7gFSzfYsnUXfFSJicPBVA9F3MEGhZvoGTgA9mCYicqFh5eHZCVT00J1YN265QtPA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;835&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来详细看看 socket 是如何添加到 epoll 对象里的，找到 epoll_ctl 的源码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// file：fs/eventpoll.c&lt;/span&gt;&lt;br/&gt;SYSCALL_DEFINE4(epoll_ctl, &lt;span&gt;int&lt;/span&gt;, epfd, &lt;span&gt;int&lt;/span&gt;, op, &lt;span&gt;int&lt;/span&gt;, fd,&lt;br/&gt;        struct epoll_event __user *, event)&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;eventpoll&lt;/span&gt; *&lt;span&gt;ep&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;file&lt;/span&gt; *&lt;span&gt;file&lt;/span&gt;, *&lt;span&gt;tfile&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//根据 epfd 找到 eventpoll 内核对象&lt;/span&gt;&lt;br/&gt;    file = fget(epfd);&lt;br/&gt;    ep = file-&amp;gt;private_data;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//根据 socket 句柄号， 找到其 file 内核对象&lt;/span&gt;&lt;br/&gt;    tfile = fget(fd);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;switch&lt;/span&gt; (op) {&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; EPOLL_CTL_ADD:&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!epi) {&lt;br/&gt;            epds.events |= POLLERR | POLLHUP;&lt;br/&gt;            error = ep_insert(ep, &amp;amp;epds, tfile, fd);&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;            error = -EEXIST;&lt;br/&gt;        clear_tfile_check_list();&lt;br/&gt;        &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 epoll_ctl 中首先根据传入 fd 找到 eventpoll、socket 相关的内核对象 。对于 EPOLL_CTL_ADD 操作来说，会然后执行到 ep_insert 函数。所有的注册都是在这个函数中完成的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: fs/eventpoll.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;ep_insert&lt;/span&gt;&lt;span&gt;(struct eventpoll *ep,&lt;br/&gt;                struct epoll_event *event,&lt;br/&gt;                struct file *tfile, &lt;span&gt;int&lt;/span&gt; fd)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//3.1 分配并初始化 epitem&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//分配一个epi对象&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;epitem&lt;/span&gt; *&lt;span&gt;epi&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!(epi = kmem_cache_alloc(epi_cache, GFP_KERNEL)))&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; -ENOMEM;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//对分配的epi进行初始化&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//epi-&amp;gt;ffd中存了句柄号和struct file对象地址&lt;/span&gt;&lt;br/&gt;    INIT_LIST_HEAD(&amp;amp;epi-&amp;gt;pwqlist);&lt;br/&gt;    epi-&amp;gt;ep = ep;&lt;br/&gt;    ep_set_ffd(&amp;amp;epi-&amp;gt;ffd, tfile, fd);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//3.2 设置 socket 等待队列&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//定义并初始化 ep_pqueue 对象&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;ep_pqueue&lt;/span&gt; &lt;span&gt;epq&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    epq.epi = epi;&lt;br/&gt;    init_poll_funcptr(&amp;amp;epq.pt, ep_ptable_queue_proc);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//调用 ep_ptable_queue_proc 注册回调函数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//实际注入的函数为 ep_poll_callback&lt;/span&gt;&lt;br/&gt;    revents = ep_item_poll(epi, &amp;amp;epq.pt);&lt;br/&gt;&lt;br/&gt;    ......&lt;br/&gt;    &lt;span&gt;//3.3 将epi插入到 eventpoll 对象中的红黑树中&lt;/span&gt;&lt;br/&gt;    ep_rbtree_insert(ep, epi);&lt;br/&gt;    ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1 分配并初始化 epitem&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于每一个 socket，调用 epoll_ctl 的时候，都会为之分配一个 epitem。该结构的主要数据如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: fs/eventpoll.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;epitem&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//红黑树节点&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;rb_node&lt;/span&gt; &lt;span&gt;rbn&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//socket文件描述符信息&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;epoll_filefd&lt;/span&gt; &lt;span&gt;ffd&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//所归属的 eventpoll 对象&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;eventpoll&lt;/span&gt; *&lt;span&gt;ep&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//等待队列&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;list_head&lt;/span&gt; &lt;span&gt;pwqlist&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对 epitem 进行了一些初始化，首先在 &lt;code&gt;epi-&amp;gt;ep = ep&lt;/code&gt; 这行代码中将其 ep 指针指向 eventpoll 对象。另外用要添加的 socket 的 file、fd 来填充 epitem-&amp;gt;ffd。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.28&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavxOaOL8PgTuqHG7gFSzfYs291KpKJW0iaXXHiaPaTe6cuEr7RgAJkLQ8ZuTk9z7xYwZBlZcbZKLbKg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;700&quot;/&gt;&lt;figcaption&gt;3_epitem&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中使用到的 ep_set_ffd 函数如下。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;inline&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;ep_set_ffd&lt;/span&gt;&lt;span&gt;(struct epoll_filefd *ffd,&lt;br/&gt;                        struct file *file, &lt;span&gt;int&lt;/span&gt; fd)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    ffd-&amp;gt;file = file;&lt;br/&gt;    ffd-&amp;gt;fd = fd;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2 设置 socket 等待队列&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在创建 epitem 并初始化之后，ep_insert 中第二件事情就是设置 socket 对象上的等待任务队列。并把函数 fs/eventpoll.c 文件下的 ep_poll_callback 设置为数据就绪时候的回调函数。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3526315789473684&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavxOaOL8PgTuqHG7gFSzfYsVbzaGY6ibpl1PdibGyJE0Ibqgxbqb1iacicdUdbERx5AVZVQUkBJ8E3Wbg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;760&quot;/&gt;&lt;figcaption&gt;3_wq&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一块的源代码稍微有点绕，没有耐心的话直接跳到下面的加粗字体来看。首先来看 ep_item_poll。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;inline&lt;/span&gt; &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;ep_item_poll&lt;/span&gt;&lt;span&gt;(struct epitem *epi, poll_table *pt)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    pt-&amp;gt;_key = epi-&amp;gt;event.events;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; epi-&amp;gt;ffd.file-&amp;gt;f_op-&amp;gt;poll(epi-&amp;gt;ffd.file, pt) &amp;amp; epi-&amp;gt;event.events;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看，这里调用到了 socket 下的 file-&amp;gt;f_op-&amp;gt;poll。通过上面第一节的 socket 的结构图，我们知道这个函数实际上是 sock_poll。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/* No kernel lock held - perfect */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;sock_poll&lt;/span&gt;&lt;span&gt;(struct file *file, poll_table *wait)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; sock-&amp;gt;ops-&amp;gt;poll(file, sock, wait);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样回看第一节里的 socket 的结构图，sock-&amp;gt;ops-&amp;gt;poll 其实指向的是 tcp_poll。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: net/ipv4/tcp.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;tcp_poll&lt;/span&gt;&lt;span&gt;(struct file *file, struct socket *sock, poll_table *wait)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;sock&lt;/span&gt; *&lt;span&gt;sk&lt;/span&gt; = &lt;span&gt;sock&lt;/span&gt;-&amp;gt;&lt;span&gt;sk&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    sock_poll_wait(file, sk_sleep(sk), wait);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 sock_poll_wait 的第二个参数传参前，先调用了 sk_sleep 函数。&lt;strong&gt;在这个函数里它获取了 sock 对象下的等待队列列表头 wait_queue_head_t，待会等待队列项就插入这里&lt;/strong&gt;。这里稍微注意下，是 socket 的等待队列，不是 epoll 对象的。来看 sk_sleep 源码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: include/net/sock.h&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;inline&lt;/span&gt; &lt;span&gt;wait_queue_head_t&lt;/span&gt; *&lt;span&gt;sk_sleep&lt;/span&gt;&lt;span&gt;(struct sock *sk)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    BUILD_BUG_ON(offsetof(struct socket_wq, wait) != &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &amp;amp;rcu_dereference_raw(sk-&amp;gt;sk_wq)-&amp;gt;wait;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着真正进入 sock_poll_wait。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;inline&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;sock_poll_wait&lt;/span&gt;&lt;span&gt;(struct file *filp,&lt;br/&gt;        &lt;span&gt;wait_queue_head_t&lt;/span&gt; *wait_address, poll_table *p)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    poll_wait(filp, wait_address, p);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;inline&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;poll_wait&lt;/span&gt;&lt;span&gt;(struct file * filp, &lt;span&gt;wait_queue_head_t&lt;/span&gt; * wait_address, poll_table *p)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (p &amp;amp;&amp;amp; p-&amp;gt;_qproc &amp;amp;&amp;amp; wait_address)&lt;br/&gt;        p-&amp;gt;_qproc(filp, wait_address, p);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的 qproc 是个函数指针，它在前面的 init_poll_funcptr 调用时被设置成了 ep_ptable_queue_proc 函数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;ep_insert&lt;/span&gt;&lt;span&gt;(...)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;    init_poll_funcptr(&amp;amp;epq.pt, ep_ptable_queue_proc);&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: include/linux/poll.h&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;inline&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;init_poll_funcptr&lt;/span&gt;&lt;span&gt;(poll_table *pt,&lt;br/&gt;    poll_queue_proc qproc)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    pt-&amp;gt;_qproc = qproc;&lt;br/&gt;    pt-&amp;gt;_key   = ~&lt;span&gt;0U&lt;/span&gt;L; &lt;span&gt;/* all events enabled */&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;敲黑板！！！注意，废了半天的劲，终于到了重点了！在 ep_ptable_queue_proc 函数中，新建了一个等待队列项，并注册其回调函数为 ep_poll_callback 函数。然后再将这个等待项添加到 socket 的等待队列中&lt;/strong&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: fs/eventpoll.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;ep_ptable_queue_proc&lt;/span&gt;&lt;span&gt;(struct file *file, &lt;span&gt;wait_queue_head_t&lt;/span&gt; *whead,&lt;br/&gt;                 poll_table *pt)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;eppoll_entry&lt;/span&gt; *&lt;span&gt;pwq&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    f (epi-&amp;gt;nwait &amp;gt;= &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) {&lt;br/&gt;                &lt;span&gt;//初始化回调方法&lt;/span&gt;&lt;br/&gt;                init_waitqueue_func_entry(&amp;amp;pwq-&amp;gt;wait, ep_poll_callback);&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;//将ep_poll_callback放入socket的等待队列whead（注意不是epoll的等待队列）&lt;/span&gt;&lt;br/&gt;                add_wait_queue(whead, &amp;amp;pwq-&amp;gt;wait);&lt;br/&gt;&lt;br/&gt;        }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前文 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==&amp;amp;mid=2247484834&amp;amp;idx=1&amp;amp;sn=b8620f402b68ce878d32df2f2bcd4e2e&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;深入理解高性能网络开发路上的绊脚石 - 同步阻塞网络 IO&lt;/a&gt; 里阻塞式的系统调用 recvfrom 里，由于需要在数据就绪的时候唤醒用户进程，所以等待对象项的 private (这个变量名起的也是醉了) 会设置成当前用户进程描述符 current。而我们今天的 socket 是交给 epoll 来管理的，不需要在一个 socket 就绪的时候就唤醒进程，所以这里的 &lt;code&gt;q-&amp;gt;private&lt;/code&gt; 没有啥卵用就设置成了 NULL。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:include/linux/wait.h&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;inline&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;init_waitqueue_func_entry&lt;/span&gt;&lt;span&gt;(&lt;br/&gt;    &lt;span&gt;wait_queue_t&lt;/span&gt; *q, &lt;span&gt;wait_queue_func_t&lt;/span&gt; func)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    q-&amp;gt;flags = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    q-&amp;gt;&lt;span&gt;private&lt;/span&gt; = &lt;span&gt;NULL&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//ep_poll_callback 注册到 wait_queue_t对象上&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//有数据到达的时候调用 q-&amp;gt;func&lt;/span&gt;&lt;br/&gt;    q-&amp;gt;func = func;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上，等待队列项中仅仅只设置了回调函数 q-&amp;gt;func 为 ep_poll_callback。在后面的第 5 节数据来啦中我们将看到，软中断将数据收到 socket 的接收队列后，会通过注册的这个 ep_poll_callback 函数来回调，进而通知到 epoll 对象。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.3 插入红黑树&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分配完 epitem 对象后，紧接着并把它插入到红黑树中。一个插入了一些 socket 描述符的 epoll 里的红黑树的示意图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23294509151414308&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavxOaOL8PgTuqHG7gFSzfYs4skMviaLYyM4pZbia7KAic0tHcgI3e6ncvVRwkrqZC9QImnq3Z2OdR2Dg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;601&quot;/&gt;&lt;figcaption&gt;3_rbtree&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们再聊聊为啥要用红黑树，很多人说是因为效率高。其实我觉得这个解释不够全面，要说查找效率树哪能比的上 HASHTABLE。我个人认为觉得更为合理的一个解释是为了让 epoll 在查找效率、插入效率、内存开销等等多个方面比较均衡，最后发现最适合这个需求的数据结构是红黑树。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;四、epoll_wait 等待接收&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;epoll_wait 做的事情不复杂，当它被调用时它观察 eventpoll-&amp;gt;rdllist 链表里有没有数据即可。有数据就返回，没有数据就创建一个等待队列项，将其添加到 eventpoll 的等待队列上，然后把自己阻塞掉就完事。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7418244406196214&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavxOaOL8PgTuqHG7gFSzfYsfIa3ib9BfYEicLneQXSYeAHRJic5llxZicp0hZdaP3aPXEcCawML9x8s0A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;581&quot;/&gt;&lt;figcaption&gt;4_epollwait&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意：epoll_ctl 添加 socket 时也创建了等待队列项。不同的是这里的等待队列项是挂在 epoll 对象上的，而前者是挂在 socket 对象上的。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其源代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: fs/eventpoll.c&lt;/span&gt;&lt;br/&gt;SYSCALL_DEFINE4(epoll_wait, &lt;span&gt;int&lt;/span&gt;, epfd, struct epoll_event __user *, events,&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt;, maxevents, &lt;span&gt;int&lt;/span&gt;, timeout)&lt;br/&gt;{&lt;br/&gt;    ...&lt;br/&gt;    error = ep_poll(ep, events, maxevents, timeout);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;ep_poll&lt;/span&gt;&lt;span&gt;(struct eventpoll *ep, struct epoll_event __user *events,&lt;br/&gt;             &lt;span&gt;int&lt;/span&gt; maxevents, &lt;span&gt;long&lt;/span&gt; timeout)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;wait_queue_t&lt;/span&gt; wait;&lt;br/&gt;    ......&lt;br/&gt;&lt;br/&gt;fetch_events:&lt;br/&gt;    &lt;span&gt;//4.1 判断就绪队列上有没有事件就绪&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!ep_events_available(ep)) {&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;//4.2 定义等待事件并关联当前进程&lt;/span&gt;&lt;br/&gt;        init_waitqueue_entry(&amp;amp;wait, current);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;//4.3 把新 waitqueue 添加到 epoll-&amp;gt;wq 链表里&lt;/span&gt;&lt;br/&gt;        __add_wait_queue_exclusive(&amp;amp;ep-&amp;gt;wq, &amp;amp;wait);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (;;) {&lt;br/&gt;            ...&lt;br/&gt;            &lt;span&gt;//4.4 让出CPU 主动进入睡眠状态&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (!schedule_hrtimeout_range(to, slack, HRTIMER_MODE_ABS))&lt;br/&gt;                timed_out = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;            ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.1 判断就绪队列上有没有事件就绪&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先调用 ep_events_available 来判断就绪链表中是否有可处理的事件。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: fs/eventpoll.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;inline&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;ep_events_available&lt;/span&gt;&lt;span&gt;(struct eventpoll *ep)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; !list_empty(&amp;amp;ep-&amp;gt;rdllist) || ep-&amp;gt;ovflist != EP_UNACTIVE_PTR;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.2 定义等待事件并关联当前进程&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设确实没有就绪的连接，那接着会进入 init_waitqueue_entry 中定义等待任务，并把 current （当前进程）添加到 waitqueue 上。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;是的，当没有 IO 事件的时候， epoll 也是会阻塞掉当前进程。这个是合理的，因为没有事情可做了占着 CPU 也没啥意义。网上的很多文章有个很不好的习惯，讨论阻塞、非阻塞等概念的时候都不说主语。这会导致你看的云里雾里。拿 epoll 来说，epoll 本身是阻塞的，但一般会把 socket 设置成非阻塞。只有说了主语，这些概念才有意义。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: include/linux/wait.h&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;inline&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;init_waitqueue_entry&lt;/span&gt;&lt;span&gt;(&lt;span&gt;wait_queue_t&lt;/span&gt; *q, struct task_struct *p)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    q-&amp;gt;flags = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    q-&amp;gt;&lt;span&gt;private&lt;/span&gt; = p;&lt;br/&gt;    q-&amp;gt;func = default_wake_function;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意这里的回调函数名称是 default_wake_function。后续在第 5 节数据来啦时将会调用到该函数。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.3 添加到等待队列&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;inline&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; __add_wait_queue_exclusive(&lt;span&gt;wait_queue_head_t&lt;/span&gt; *q,&lt;br/&gt;                                &lt;span&gt;wait_queue_t&lt;/span&gt; *wait)&lt;br/&gt;{&lt;br/&gt;    wait-&amp;gt;flags |= WQ_FLAG_EXCLUSIVE;&lt;br/&gt;    __add_wait_queue(q, wait);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这里，把上一小节定义的等待事件添加到了 epoll 对象的等待队列中。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.4 让出 CPU 主动进入睡眠状态&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 set_current_state 把当前进程设置为可打断。调用 schedule_hrtimeout_range 让出 CPU，主动进入睡眠状态&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: kernel/hrtimer.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; __sched &lt;span&gt;schedule_hrtimeout_range&lt;/span&gt;&lt;span&gt;(&lt;span&gt;ktime_t&lt;/span&gt; *expires,&lt;br/&gt;    &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; delta, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt; hrtimer_mode mode)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; schedule_hrtimeout_range_clock(&lt;br/&gt;            expires, delta, mode, CLOCK_MONOTONIC);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; __sched &lt;span&gt;schedule_hrtimeout_range_clock&lt;/span&gt;&lt;span&gt;(...)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    schedule();&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 schedule 中选择下一个进程调度&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: kernel/sched/core.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; __sched __schedule(&lt;span&gt;void&lt;/span&gt;)&lt;br/&gt;{&lt;br/&gt;    next = pick_next_task(rq);&lt;br/&gt;    ...&lt;br/&gt;    context_switch(rq, prev, next);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;五、数据来啦&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前面 epoll_ctl 执行的时候，内核为每一个 socket 上都添加了一个等待队列项。在 epoll_wait 运行完的时候，又在 event poll 对象上添加了等待队列元素。在讨论数据开始接收之前，我们把这些队列项的内容再稍微总结一下。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47597597597597596&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavxOaOL8PgTuqHG7gFSzfYsN5zMZy3gibibI1XsBsKNRrchiadiaJj4fssyiaVia4gyRZOYv6XRxYRAmmsg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;666&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;socket-&amp;gt;sock-&amp;gt;sk_data_ready 设置的就绪处理函数是 sock_def_readable&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在 socket 的等待队列项中，其回调函数是 ep_poll_callback。另外其 private 没有用了，指向的是空指针 null。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在 eventpoll 的等待队列项中，回调函数是 default_wake_function。其 private 指向的是等待该事件的用户进程。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这一小节里，我们将看到软中断是怎么样在数据处理完之后依次进入各个回调函数，最后通知到用户进程的。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.1 接收数据到任务队列&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于软中断是怎么处理网络帧，为了避免篇幅过于臃肿，这里不再介绍。感兴趣的可以看文章 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==&amp;amp;mid=2247484058&amp;amp;idx=1&amp;amp;sn=a2621bc27c74b313528eefbc81ee8c0f&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《图解 Linux 网络包接收过程》&lt;/a&gt;。我们今天直接从 tcp 协议栈的处理入口函数 tcp_v4_rcv 开始说起。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// file: net/ipv4/tcp_ipv4.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;tcp_v4_rcv&lt;/span&gt;&lt;span&gt;(struct sk_buff *skb)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    ......&lt;br/&gt;    th = tcp_hdr(skb); &lt;span&gt;//获取tcp header&lt;/span&gt;&lt;br/&gt;    iph = ip_hdr(skb); &lt;span&gt;//获取ip header&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//根据数据包 header 中的 ip、端口信息查找到对应的socket&lt;/span&gt;&lt;br/&gt;    sk = __inet_lookup_skb(&amp;amp;tcp_hashinfo, skb, th-&amp;gt;source, th-&amp;gt;dest);&lt;br/&gt;    ......&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//socket 未被用户锁定&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!sock_owned_by_user(sk)) {&lt;br/&gt;        {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (!tcp_prequeue(sk, skb))&lt;br/&gt;                ret = tcp_v4_do_rcv(sk, skb);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 tcp_v4_rcv 中首先根据收到的网络包的 header 里的 source 和 dest 信息来在本机上查询对应的 socket。找到以后，我们直接进入接收的主体函数 tcp_v4_do_rcv 来看。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: net/ipv4/tcp_ipv4.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;tcp_v4_do_rcv&lt;/span&gt;&lt;span&gt;(struct sock *sk, struct sk_buff *skb)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (sk-&amp;gt;sk_state == TCP_ESTABLISHED) {&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;//执行连接状态下的数据处理&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (tcp_rcv_established(sk, skb, tcp_hdr(skb), skb-&amp;gt;len)) {&lt;br/&gt;            rsk = sk;&lt;br/&gt;            &lt;span&gt;goto&lt;/span&gt; reset;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//其它非 ESTABLISH 状态的数据包处理&lt;/span&gt;&lt;br/&gt;    ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们假设处理的是 ESTABLISH 状态下的包，这样就又进入 tcp_rcv_established 函数中进行处理。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: net/ipv4/tcp_input.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;tcp_rcv_established&lt;/span&gt;&lt;span&gt;(struct sock *sk, struct sk_buff *skb,&lt;br/&gt;            &lt;span&gt;const&lt;/span&gt; struct tcphdr *th, &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; len)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    ......&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//接收数据到队列中&lt;/span&gt;&lt;br/&gt;    eaten = tcp_queue_rcv(sk, skb, tcp_header_len,&lt;br/&gt;                                    &amp;amp;fragstolen);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//数据 ready，唤醒 socket 上阻塞掉的进程&lt;/span&gt;&lt;br/&gt;    sk-&amp;gt;sk_data_ready(sk, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 tcp_rcv_established 中通过调用 tcp_queue_rcv 函数中完成了将接收数据放到 socket 的接收队列上。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6086105675146771&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavxOaOL8PgTuqHG7gFSzfYsEI3sVHK8Ef9vkibn8U41fN1NqUYpicqnyp6wVepYqiaKziajLJ9R2I1oHA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;511&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下源码所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: net/ipv4/tcp_input.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; __must_check &lt;span&gt;tcp_queue_rcv&lt;/span&gt;&lt;span&gt;(struct sock *sk, struct sk_buff *skb, &lt;span&gt;int&lt;/span&gt; hdrlen,&lt;br/&gt;            &lt;span&gt;bool&lt;/span&gt; *fragstolen)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//把接收到的数据放到 socket 的接收队列的尾部&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!eaten) {&lt;br/&gt;        __skb_queue_tail(&amp;amp;sk-&amp;gt;sk_receive_queue, skb);&lt;br/&gt;        skb_set_owner_r(skb, sk);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; eaten;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.2 查找就绪回调函数&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用 tcp_queue_rcv 接收完成之后，接着再调用 sk_data_ready 来唤醒在 socket 上等待的用户进程。这又是一个函数指针。回想上面第一节我们在 accept 函数创建 socket 流程里提到的 sock_init_data 函数，在这个函数里已经把 sk_data_ready 设置成 sock_def_readable 函数了。它是默认的数据就绪处理函数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 socket 上数据就绪时候，内核将以 sock_def_readable 这个函数为入口，找到 epoll_ctl 添加 socket 时在其上设置的回调函数 ep_poll_callback。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6307385229540918&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavxOaOL8PgTuqHG7gFSzfYseAs3qcuIXJAd2nofZXJgV3cNLbTFURV8ygKMfmnpvXZU21ruOFXzxw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;501&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来详细看下细节：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: net/core/sock.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;sock_def_readable&lt;/span&gt;&lt;span&gt;(struct sock *sk, &lt;span&gt;int&lt;/span&gt; len)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;socket_wq&lt;/span&gt; *&lt;span&gt;wq&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    rcu_read_lock();&lt;br/&gt;    wq = rcu_dereference(sk-&amp;gt;sk_wq);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//这个名字起的不好，并不是有阻塞的进程，&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//而是判断等待队列不为空&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (wq_has_sleeper(wq))&lt;br/&gt;        &lt;span&gt;//执行等待队列项上的回调函数&lt;/span&gt;&lt;br/&gt;        wake_up_interruptible_sync_poll(&amp;amp;wq-&amp;gt;wait, POLLIN | POLLPRI |&lt;br/&gt;                        POLLRDNORM | POLLRDBAND);&lt;br/&gt;    sk_wake_async(sk, SOCK_WAKE_WAITD, POLL_IN);&lt;br/&gt;    rcu_read_unlock();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的函数名其实都有迷惑人的地方。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;wq_has_sleeper，对于简单的 recvfrom 系统调用来说，确实是判断是否有进程阻塞。但是对于 epoll 下的 socket 只是判断等待队列不为空，不一定有进程阻塞的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;wake_up_interruptible_sync_poll，只是会进入到 socket 等待队列项上设置的回调函数，并不一定有唤醒进程的操作。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那接下来就是我们重点看 wake_up_interruptible_sync_poll 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看一下内核是怎么找到等待队列项里注册的回调函数的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: include/linux/wait.h&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; wake_up_interruptible_sync_poll(x, m)       \&lt;br/&gt;    __wake_up_sync_key((x), TASK_INTERRUPTIBLE, 1, (void *) (m))&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: kernel/sched/core.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;void&lt;/span&gt; __wake_up_sync_key(&lt;span&gt;wait_queue_head_t&lt;/span&gt; *q, &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; mode,&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; nr_exclusive, &lt;span&gt;void&lt;/span&gt; *key)&lt;br/&gt;{&lt;br/&gt;    ...&lt;br/&gt;    __wake_up_common(q, mode, nr_exclusive, wake_flags, key);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着进入 __wake_up_common&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; __wake_up_common(&lt;span&gt;wait_queue_head_t&lt;/span&gt; *q, &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; mode,&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; nr_exclusive, &lt;span&gt;int&lt;/span&gt; wake_flags, &lt;span&gt;void&lt;/span&gt; *key)&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;wait_queue_t&lt;/span&gt; *curr, *next;&lt;br/&gt;&lt;br/&gt;    list_for_each_entry_safe(curr, next, &amp;amp;q-&amp;gt;task_list, task_list) {&lt;br/&gt;        &lt;span&gt;unsigned&lt;/span&gt; flags = curr-&amp;gt;flags;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (curr-&amp;gt;func(curr, mode, wake_flags, key) &amp;amp;&amp;amp;&lt;br/&gt;                (flags &amp;amp; WQ_FLAG_EXCLUSIVE) &amp;amp;&amp;amp; !--nr_exclusive)&lt;br/&gt;            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 __wake_up_common 中，选出等待队列里注册某个元素 curr， 回调其 curr-&amp;gt;func。回忆我们 ep_insert 调用的时候，把这个 func 设置成 ep_poll_callback 了。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.3 执行 socket 就绪回调函数&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上一小节找到了 socket 等待队列项里注册的函数 ep_poll_callback，软中断接着就会调用它。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: fs/eventpoll.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;ep_poll_callback&lt;/span&gt;&lt;span&gt;(&lt;span&gt;wait_queue_t&lt;/span&gt; *wait, &lt;span&gt;unsigned&lt;/span&gt; mode, &lt;span&gt;int&lt;/span&gt; sync, &lt;span&gt;void&lt;/span&gt; *key)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//获取 wait 对应的 epitem&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;epitem&lt;/span&gt; *&lt;span&gt;epi&lt;/span&gt; = &lt;span&gt;ep_item_from_wait&lt;/span&gt;(&lt;span&gt;wait&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//获取 epitem 对应的 eventpoll 结构体&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;eventpoll&lt;/span&gt; *&lt;span&gt;ep&lt;/span&gt; = &lt;span&gt;epi&lt;/span&gt;-&amp;gt;&lt;span&gt;ep&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//1. 将当前epitem 添加到 eventpoll 的就绪队列中&lt;/span&gt;&lt;br/&gt;    list_add_tail(&amp;amp;epi-&amp;gt;rdllink, &amp;amp;ep-&amp;gt;rdllist);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//2. 查看 eventpoll 的等待队列上是否有在等待&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (waitqueue_active(&amp;amp;ep-&amp;gt;wq))&lt;br/&gt;        wake_up_locked(&amp;amp;ep-&amp;gt;wq);&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 ep_poll_callback 根据等待任务队列项上的额外的 base 指针可以找到 epitem， 进而也可以找到 eventpoll 对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先它做的第一件事就是&lt;strong&gt;把自己的 epitem 添加到 epoll 的就绪队列中&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着它又会查看 eventpoll 对象上的等待队列里是否有等待项（epoll_wait 执行的时候会设置）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果没执行软中断的事情就做完了。如果有等待项，那就查找到等待项里设置的回调函数。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3812375249500998&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavxOaOL8PgTuqHG7gFSzfYsVz4OEKwBpMbSegdbrgIj81YPE50LOC5JfOzanuoFfhxJJNiaw1HdcbQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;501&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用 wake_up_locked() =&amp;gt; __wake_up_locked() =&amp;gt; __wake_up_common。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; __wake_up_common(&lt;span&gt;wait_queue_head_t&lt;/span&gt; *q, &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; mode,&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; nr_exclusive, &lt;span&gt;int&lt;/span&gt; wake_flags, &lt;span&gt;void&lt;/span&gt; *key)&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;wait_queue_t&lt;/span&gt; *curr, *next;&lt;br/&gt;&lt;br/&gt;    list_for_each_entry_safe(curr, next, &amp;amp;q-&amp;gt;task_list, task_list) {&lt;br/&gt;        &lt;span&gt;unsigned&lt;/span&gt; flags = curr-&amp;gt;flags;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (curr-&amp;gt;func(curr, mode, wake_flags, key) &amp;amp;&amp;amp;&lt;br/&gt;                (flags &amp;amp; WQ_FLAG_EXCLUSIVE) &amp;amp;&amp;amp; !--nr_exclusive)&lt;br/&gt;            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 __wake_up_common 里， 调用 curr-&amp;gt;func。这里的 func 是在 epoll_wait 是传入的 default_wake_function 函数。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.4 执行 epoll 就绪通知&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 default_wake_function 中找到等待队列项里的进程描述符，然后唤醒之。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3871559633027523&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavxOaOL8PgTuqHG7gFSzfYso21lzFPaWZ7A9yRc0jqh090K8CVcUN9g3sysWhRQW3SuZe0kwYAj8g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;545&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:kernel/sched/core.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;default_wake_function&lt;/span&gt;&lt;span&gt;(&lt;span&gt;wait_queue_t&lt;/span&gt; *curr, &lt;span&gt;unsigned&lt;/span&gt; mode, &lt;span&gt;int&lt;/span&gt; wake_flags,&lt;br/&gt;                &lt;span&gt;void&lt;/span&gt; *key)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; try_to_wake_up(curr-&amp;gt;&lt;span&gt;private&lt;/span&gt;, mode, wake_flags);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;等待队列项 curr-&amp;gt;private 指针是在 epoll 对象上等待而被阻塞掉的进程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将 epoll_wait 进程推入可运行队列，等待内核重新调度进程。然后 epoll_wait 对应的这个进程重新运行后，就从 schedule 恢复&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当进程醒来后，继续从 epoll_wait 时暂停的代码继续执行。把 rdlist 中就绪的事件返回给用户进程&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: fs/eventpoll.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;ep_poll&lt;/span&gt;&lt;span&gt;(struct eventpoll *ep, struct epoll_event __user *events,&lt;br/&gt;             &lt;span&gt;int&lt;/span&gt; maxevents, &lt;span&gt;long&lt;/span&gt; timeout)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    ......&lt;br/&gt;    __remove_wait_queue(&amp;amp;ep-&amp;gt;wq, &amp;amp;wait);&lt;br/&gt;&lt;br/&gt;    set_current_state(TASK_RUNNING);&lt;br/&gt;    }&lt;br/&gt;check_events:&lt;br/&gt;    &lt;span&gt;//返回就绪事件给用户进程&lt;/span&gt;&lt;br/&gt;    ep_send_events(ep, events, maxevents))&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从用户角度来看，epoll_wait 只是多等了一会儿而已，但执行流程还是顺序的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来用一幅图总结一下 epoll 的整个工作路程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8726993865030674&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavxOaOL8PgTuqHG7gFSzfYs4KWxl9jibCyz7lu0kXBm27uzokTJwB0nxP2Rt45TqicstpOkTGAeG7iaQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;652&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中软中断回调的时候回调函数也整理一下：&lt;br/&gt;sock_def_readable：sock 对象初始化时设置的&lt;br/&gt;=&amp;gt; ep_poll_callback : epoll_ctl 时添加到 socket 上的&lt;br/&gt;=&amp;gt; default_wake_function: epoll_wait 是设置到 epoll 上的&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结下，epoll 相关的函数里内核运行环境分两部分：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;用户进程内核态。进行调用 epoll_wait 等函数时会将进程陷入内核态来执行。这部分代码负责查看接收队列，以及负责把当前进程阻塞掉，让出 CPU。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;硬软中断上下文。在这些组件中，将包从网卡接收过来进行处理，然后放到 socket 的接收队列。对于 epoll 来说，再找到 socket 关联的 epitem，并把它添加到 epoll 对象的就绪链表中。这个时候再捎带检查一下 epoll 上是否有被阻塞的进程，如果有唤醒之。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了介绍到每个细节，本文涉及到的流程比较多，把阻塞都介绍进来了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但其实&lt;strong&gt;在实践中，只要活儿足够的多，epoll_wait 根本都不会让进程阻塞&lt;/strong&gt;。用户进程会一直干活，一直干活，直到 epoll_wait 里实在没活儿可干的时候才主动让出 CPU。这就是 epoll 高效的地方所在！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;包括本文在内，飞哥总共用三篇文章分析了一件事情，一个网络包是如何从网卡达到你的用户进程里的。另外两篇如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;恭喜你没被内核源码劝退，一直能坚持到了现在。赶快给先自己鼓个掌，晚饭去加个鸡腿！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然网络编程剩下还有一些概念我们没有讲到，比如 Reactor 和 Proactor 等。不过相对内核来讲，这些用户层的技术相对就很简单了。这些只是在讨论当多进程一起配合工作时谁负责查看 IO 事件、谁该负责计算、谁负责发送和接收，仅仅是用户进程的不同分工模式罢了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;参考&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;推荐阅读：&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&amp;amp;mid=2649769420&amp;amp;idx=1&amp;amp;sn=e250de87dbcde414f9c67bf50cc32022&amp;amp;chksm=beccd6b789bb5fa1878d5ca110cdd45f186edf173058ebf5d0b28c62a2bb87fc24b5093b74c6&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;低代码是什么？有什么优势&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;低代码是什么？有什么优势&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&amp;amp;mid=2649769371&amp;amp;idx=1&amp;amp;sn=2aa88c3a960edeeeac98fbbe741e5207&amp;amp;chksm=beccd6e089bb5ff6e1f9c915f40af886cb00c42668395e1d13bb0fa53d254a712a1cc510eabd&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Go 高性能编程技法&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Go 高性能编程技法&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&amp;amp;mid=2649769274&amp;amp;idx=1&amp;amp;sn=a46fc1574ecbf5cfddd1f40af9cb1b4f&amp;amp;chksm=beccd64189bb5f57f80799fd2ea51c7669942254a2223dea55fe7d2bfa5762410a784dec8e2f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;微信全文搜索技术优化&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;微信全文搜索技术优化&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAAgB0w--0B5AAAAAstQy6ubaLX4KHWvLEZgBPE_KI4GAB-Goj8zNPgMIvbPj1WyRDazgJTIPzK8xxD&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=rjD5jyTuFrIpZ2ibE8T7Ym3K77SEULgkia7cnowanp6jmR47YY3C7HjjMJlXdWTd13QbfVMkAQmbWvuGuQIE19K3yL4RH95Ich4ngRuJqbLKFZl7nicAsO36w&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SZ&amp;amp;idx=1&amp;amp;m=&amp;amp;scene=0&amp;amp;token=AxricY7RBHdVAA50Nhl6Wm7K3LTg2vNxN6SBO0mynvjk5hjoiaEtZXGttiaJygic8mUbMiaVlU9uDWHw&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/I7awtksbibjQe7RZAy84xESOBAfIZ8xQ9ApXt4uTe8po/0&quot; data-username=&quot;v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder&quot; data-nickname=&quot;腾讯程序员&quot; data-desc=&quot;聊天常被猜错职业，其实我是名程序媛&amp;#10;&amp;#10;#程序媛&amp;#10;&quot; data-nonceid=&quot;5757332040059361517&quot; data-type=&quot;video&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>