<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>3b1bc769a0bf1b951f7e70e644ba4c5e</guid>
<title>用 Go 轻松完成一个 SAGA 分布式事务，保姆级教程</title>
<link>https://toutiao.io/k/xtqqvex</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;银行跨行转账业务是一个典型分布式事务场景，假设A需要跨行转账给B，那么就涉及两个银行的数据，无法通过一个数据库的本地事务保证转账的ACID，只能够通过分布式事务来解决。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-id=&quot;heading-0&quot;&gt;&lt;span&gt;分布式事务&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;分布式事务在分布式环境下，为了满足可用性、性能与降级服务的需要，降低一致性与隔离性的要求，一方面遵循 BASE 理论：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;另一方面，分布式事务也部分遵循 ACID 规范：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-id=&quot;heading-1&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-id=&quot;heading-1&quot;&gt;&lt;span&gt;SAGA&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Saga是这一篇数据库论文SAGAS提到的一个分布式事务方案。其核心思想是将长事务拆分为多个本地短事务，由Saga事务协调器协调，如果各个本地事务成功完成那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;目前可用于SAGA的开源框架，主要为Java语言，其中以seata为代表。我们的例子采用go语言，使用的分布式事务框架为github.com/yedf/dtm，它对分布式事务的支持非常优雅。下面来详细讲解SAGA的组成：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;DTM事务框架里，有3个角色，与经典的XA分布式事务一样：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下面看一个成功完成的SAGA时序图，就很容易理解SAGA分布式事务：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.7732463295269169&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9m9OfQX94VvJvhjNGBvp23oCHMicZHFfWK63yOSrJCT5YwyGmMgJkjib6cNiaGXZj7lmvmiaH33D98lMgU9sJgxicvg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;613&quot;/&gt;&lt;/p&gt;&lt;h2 data-id=&quot;heading-2&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-id=&quot;heading-2&quot;&gt;&lt;span&gt;SAGA实践&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;对于我们要进行的银行转账的例子，我们将在正向操作中，进行转入转出，在补偿操作中，做相反的调整。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;首先我们创建账户余额表：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;TABLE&lt;/span&gt; dtm_busi.&lt;span class=&quot;code-snippet__string&quot;&gt;`user_account`&lt;/span&gt; (&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;`id`&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;int&lt;/span&gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;11&lt;/span&gt;) AUTO_INCREMENT PRIMARY &lt;span class=&quot;code-snippet__keyword&quot;&gt;KEY&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;`user_id`&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;int&lt;/span&gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;11&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;UNIQUE&lt;/span&gt; ,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;`balance`&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;decimal&lt;/span&gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;0.00&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;`create_time`&lt;/span&gt; datetime &lt;span class=&quot;code-snippet__keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;now&lt;/span&gt;(),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;`update_time`&lt;/span&gt; datetime &lt;span class=&quot;code-snippet__keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;now&lt;/span&gt;()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;我们先编写核心业务代码，调整用户的账户余额&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;qsAdjustBalance&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(uid &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;, amount &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt;{}, error)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  _, err := dtmcli.SdbExec(sdbGet(), &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;update dtm_busi.user_account set balance = balance + ? where user_id = ?&quot;&lt;/span&gt;, amount, uid)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; dtmcli.ResultSuccess, err&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;下面我们来编写具体的正向操作/补偿操作的处理函数&lt;/p&gt;&lt;pre&gt;&lt;code lang=&quot;GO&quot;/&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;app.POST(qsBusiAPI+&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/TransIn&quot;&lt;/span&gt;, common.WrapHandler(&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(c *gin.Context)&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt;{}, error)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; qsAdjustBalance(&lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;30&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  app.POST(qsBusiAPI+&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/TransInCompensate&quot;&lt;/span&gt;, common.WrapHandler(&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(c *gin.Context)&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt;{}, error)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; qsAdjustBalance(&lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;-30&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  app.POST(qsBusiAPI+&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/TransOut&quot;&lt;/span&gt;, common.WrapHandler(&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(c *gin.Context)&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt;{}, error)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; qsAdjustBalance(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;-30&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  app.POST(qsBusiAPI+&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/TransOutCompensate&quot;&lt;/span&gt;, common.WrapHandler(&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(c *gin.Context)&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt;{}, error)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; qsAdjustBalance(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;30&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;到此各个子事务的处理函数已经OK了，然后是开启SAGA事务，进行分支调用&lt;/p&gt;&lt;pre&gt;&lt;code lang=&quot;GO&quot;/&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;req := &amp;amp;gin.H{&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;amount&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;30&lt;/span&gt;} &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  saga := dtmcli.NewSaga(DtmServer, dtmcli.MustGenGid(DtmServer)).&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Add(qsBusi+&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/TransOut&quot;&lt;/span&gt;, qsBusi+&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/TransOutCompensate&quot;&lt;/span&gt;, req).&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Add(qsBusi+&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/TransIn&quot;&lt;/span&gt;, qsBusi+&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/TransInCompensate&quot;&lt;/span&gt;, req)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  err := saga.Submit()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;至此，一个完整的SAGA分布式事务编写完成。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果您想要完整运行一个成功的示例，那么按照yedf/dtm项目的说明搭建好环境之后，通过下面命令运行saga的例子即可：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;go&lt;/span&gt; run app/main.&lt;span class=&quot;code-snippet__keyword&quot;&gt;go&lt;/span&gt; quick_start&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;br/&gt;&lt;/pre&gt;&lt;h2 data-id=&quot;heading-3&quot;&gt;&lt;span&gt;处理网络异常&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;假设提交给dtm的事务中，调用转入操作时，出现短暂的故障怎么办？按照SAGA事务的协议，dtm会重试未完成的操作，这时我们要如何处理？故障有可能是转入操作完成后出网络故障，也有可能是转入操作完成中出现机器宕机。如何处理才能够保障账户余额的调整是正确无问题的？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;DTM提供了子事务屏障功能，保证多次重试，只会有一次成功提交。（子事务屏障不仅保证幂等，还能够解决空补偿等问题，详情参考分布式事务最经典的七种解决方案的子事务屏障环节）&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们把处理函数调整为：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;sagaBarrierAdjustBalance&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(sdb *sql.Tx, uid &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;, amount &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt;{}, error)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  _, err := dtmcli.StxExec(sdb, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;update dtm_busi.user_account set balance = balance + ? where user_id = ?&quot;&lt;/span&gt;, amount, uid)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; dtmcli.ResultSuccess, err&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;sagaBarrierTransIn&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(c *gin.Context)&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt;{}, error)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; dtmcli.ThroughBarrierCall(sdbGet(), MustGetTrans(c), &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(sdb *sql.Tx)&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt;{}, error)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; sagaBarrierAdjustBalance(sdb, &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;, reqFrom(c).Amount)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  })&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;sagaBarrierTransInCompensate&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(c *gin.Context)&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt;{}, error)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; dtmcli.ThroughBarrierCall(sdbGet(), MustGetTrans(c), &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(sdb *sql.Tx)&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt;{}, error)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; sagaBarrierAdjustBalance(sdb, &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;, -reqFrom(c).Amount)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  })&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这里的dtmcli.TroughBarrierCall调用会使用子事务屏障技术，保证第三个参数里的回调函数仅被处理一次&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;您可以尝试多次调用这个TransIn服务，仅有一次余额调整。您可以运行以下命令，运行新的处理方式：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;go&lt;/span&gt; run app/main.&lt;span class=&quot;code-snippet__keyword&quot;&gt;go&lt;/span&gt; saga_barrier&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;br/&gt;&lt;/pre&gt;&lt;h2 data-id=&quot;heading-4&quot;&gt;&lt;span&gt;处理回滚&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;假如银行将金额准备转入用户2时，发现用户2的账户异常，返回失败，会怎么样？我们调整处理函数，让转入操作返回失败&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;sagaBarrierTransIn&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(c *gin.Context)&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt;{}, error)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; dtmcli.ResultFailure, &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;我们给出事务失败交互的时序图&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.9526916802610114&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9m9OfQX94VvJvhjNGBvp23oCHMicZHFfWBcUKmrYRyWIzibibiaYxnpOz2MokAo5ZhGjIcwOialw25Xxx9n50SjVJUA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;613&quot;/&gt;&lt;/p&gt;&lt;p&gt;这里有一点，TransIn的正向操作什么都没有做，就返回了失败，此时调用TransIn的补偿操作，会不会导致反向调整出错了呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;不用担心，前面的子事务屏障技术，能够保证TransIn的错误如果发生在提交之前，则补偿为空操作；TransIn的错误如果发生在提交之后，则补偿操作会将数据提交一次。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;您可以将返回错误的TransIn改成：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;sagaBarrierTransIn&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(c *gin.Context)&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt;{}, error)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  dtmcli.ThroughBarrierCall(sdbGet(), MustGetTrans(c), &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(sdb *sql.Tx)&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt;{}, error)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; sagaBarrierAdjustBalance(sdb, &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;30&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  })&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; dtmcli.ResultFailure, &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;最后的结果余额依旧会是对的，原理可以参考：分布式事务最经典的七种解决方案的子事务屏障环节&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-id=&quot;heading-5&quot;&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在这篇文章里，我们介绍了SAGA的理论知识，也通过一个例子，完整给出了编写一个SAGA事务的过程，涵盖了正常成功完成，异常情况，以及成功回滚的情况。相信读者通过这边文章，对SAGA已经有了深入的理解。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;文中使用的dtm是新开源的Golang分布式事务管理框架，功能强大，支持TCC、SAGA、XA、事务消息等事务模式，支持Go、python、PHP、node、csharp等语言的。同时提供了非常简单易用的接口。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;阅读完此篇干货，欢迎大家访问项目github.com/yedf/dtm，给颗星星支持！&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;点击左下角的&quot;阅读原文&quot;，可以直接访问项目&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9c9a112f2b45a5e4094dfd4a7c06b59c</guid>
<title>聊聊 Redis 分布式锁的 8 大坑</title>
<link>https://toutiao.io/k/e17erwk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;大家好，我是苏三，又跟大家见面了。&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在分布式系统中，由于redis分布式锁相对于更简单和高效，成为了分布式锁的首先，被我们用到了很多实际业务场景当中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但不是说用了redis分布式锁，就可以高枕无忧了，如果没有用好或者用对，也会引来一些意想不到的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天我们就一起聊聊redis分布式锁的一些坑，给有需要的朋友一个参考。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8096&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDFpywBzMdt5EHAekqHT61dCf8dmQJ1E3ez06Yvb94PSMmMaSMIP2PvMF9iciasZ6anaBNAmx9FvZBhA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1250&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1 非原子操作&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用redis的分布式锁，我们首先想到的可能是&lt;code&gt;setNx&lt;/code&gt;命令。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (jedis.setnx(lockKey, val) == &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;   jedis.expire(lockKey, timeout);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;容易，三下五除二，我们就可以把代码写好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码确实可以加锁成功，但你有没有发现什么问题？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;加锁操作&lt;/code&gt;和后面的&lt;code&gt;设置超时时间&lt;/code&gt;是分开的，并&lt;code&gt;非原子操作&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如加锁成功，但是设置超时时间失败了，该lockKey就变成永不失效。假如在高并发场景中，有大量的lockKey加锁成功了，但不会失效，有可能直接导致redis内存空间不足。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，有没有保证原子性的加锁命令呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是：有，请看下面。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2 忘了释放锁&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面说到使用&lt;code&gt;setNx&lt;/code&gt;命令加锁操作和设置超时时间是分开的，并非原子操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在redis中还有&lt;code&gt;set&lt;/code&gt;命令，该命令可以指定多个参数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String result = jedis.set(lockKey, requestId, &lt;span&gt;&quot;NX&quot;&lt;/span&gt;, &lt;span&gt;&quot;PX&quot;&lt;/span&gt;, expireTime);&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;OK&quot;&lt;/span&gt;.equals(result)) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;lockKey&lt;/code&gt;：锁的标识&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;requestId&lt;/code&gt;：请求id&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;NX&lt;/code&gt;：只在键不存在时，才对键进行设置操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;PX&lt;/code&gt;：设置键的过期时间为 millisecond 毫秒。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;expireTime&lt;/code&gt;：过期时间&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;set&lt;/code&gt;命令是原子操作，加锁和设置超时时间，一个命令就能轻松搞定。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;nice&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;set&lt;/code&gt;命令加锁，表面上看起来没有问题。但如果仔细想想，加锁之后，每次都要达到了超时时间才释放锁，会不会有点不合理？加锁后，如果不及时释放锁，会有很多问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分布式锁更合理的用法是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;手动加锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;业务操作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;手动释放锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果手动释放锁失败了，则达到超时时间，redis会自动释放锁。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大致流程图如下：&lt;img data-ratio=&quot;0.7063339731285988&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDFpywBzMdt5EHAekqHT61dCdnxwfwf8JSPb4ycN3CcdRbX7QFMV01L31c4Fpxxs63Glt8gAuvDuUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1042&quot;/&gt;那么问题来了，如何释放锁呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;伪代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;try&lt;/span&gt;{&lt;br/&gt;  String result = jedis.set(lockKey, requestId, &lt;span&gt;&quot;NX&quot;&lt;/span&gt;, &lt;span&gt;&quot;PX&quot;&lt;/span&gt;, expireTime);&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;OK&quot;&lt;/span&gt;.equals(result)) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;} &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;    unlock(lockKey);&lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要捕获业务代码的异常，然后在&lt;code&gt;finally&lt;/code&gt;中释放锁。换句话说就是：无论代码执行成功或失败了，都需要释放锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，有些朋友可能会问：假如刚好在释放锁的时候，系统被重启了，或者网络断线了，或者机房断点了，不也会导致释放锁失败？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个好问题，因为这种小概率问题确实存在。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但还记得前面我们给锁设置过超时时间吗？即使出现异常情况造成释放锁失败，但到了我们设定的超时时间，锁还是会被redis自动释放。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但只在finally中释放锁，就够了吗？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3 释放了别人的锁&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;做人要厚道，先回答上面的问题：只在finally中释放锁，当然是不够的，因为释放锁的姿势，还是不对。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哪里不对？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：在多线程场景中，可能会出现释放了别人的锁的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些朋友可能会反驳：假设在多线程场景中，线程A获取到了锁，但如果线程A没有释放锁，此时，线程B是获取不到锁的，何来释放了别人锁之说？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：假如线程A和线程B，都使用lockKey加锁。线程A加锁成功了，但是由于业务功能耗时时间很长，超过了设置的超时时间。这时候，redis会自动释放lockKey锁。此时，线程B就能给lockKey加锁成功了，接下来执行它的业务操作。恰好这个时候，线程A执行完了业务功能，接下来，在finally方法中释放了锁lockKey。这不就出问题了，线程B的锁，被线程A释放了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我想这个时候，线程B肯定哭晕在厕所里，并且嘴里还振振有词。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何解决这个问题呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道你们注意到没？在使用&lt;code&gt;set&lt;/code&gt;命令加锁时，除了使用lockKey锁标识，还多设置了一个参数：&lt;code&gt;requestId&lt;/code&gt;，为什么要需要记录requestId呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：requestId是在释放锁的时候用的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;伪代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (jedis.get(lockKey).equals(requestId)) {&lt;br/&gt;    jedis.del(lockKey);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在释放锁的时候，先获取到该锁的值（之前设置值就是requestId），然后判断跟之前设置的值是否相同，如果相同才允许删除锁，返回成功。如果不同，则直接返回失败。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;换句话说就是：自己只能释放自己加的锁，不允许释放别人加的锁。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里为什么要用requestId，用userId不行吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：如果用userId的话，对于请求来说并不唯一，多个不同的请求，可能使用同一个userId。而requestId是全局唯一的，不存在加锁和释放锁乱掉的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，使用lua脚本，也能解决释放了别人的锁的问题：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; redis.call(&lt;span&gt;&#x27;get&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;1&lt;/span&gt;]) == ARGV[&lt;span&gt;1&lt;/span&gt;] then &lt;br/&gt; &lt;span&gt;return&lt;/span&gt; redis.call(&lt;span&gt;&#x27;del&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;1&lt;/span&gt;]) &lt;br/&gt;&lt;span&gt;else&lt;/span&gt; &lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;br/&gt;end&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;lua脚本能保证查询锁是否存在和删除锁是原子操作，用它来释放锁效果更好一些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说到lua脚本，其实加锁操作也建议使用lua脚本：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (redis.call(&lt;span&gt;&#x27;exists&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;1&lt;/span&gt;]) == &lt;span&gt;0&lt;/span&gt;) then&lt;br/&gt;    redis.call(&lt;span&gt;&#x27;hset&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;1&lt;/span&gt;], ARGV[&lt;span&gt;2&lt;/span&gt;], &lt;span&gt;1&lt;/span&gt;); &lt;br/&gt;    redis.call(&lt;span&gt;&#x27;pexpire&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;1&lt;/span&gt;], ARGV[&lt;span&gt;1&lt;/span&gt;]); &lt;br/&gt; &lt;span&gt;return&lt;/span&gt; nil; &lt;br/&gt;&lt;span&gt;end&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;(redis.call(&lt;span&gt;&#x27;hexists&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;1&lt;/span&gt;], ARGV[&lt;span&gt;2&lt;/span&gt;])&lt;/span&gt; &lt;/span&gt;== &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;   redis.call(&lt;span&gt;&#x27;hincrby&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;1&lt;/span&gt;], ARGV[&lt;span&gt;2&lt;/span&gt;], &lt;span&gt;1&lt;/span&gt;); &lt;br/&gt;   redis.call(&lt;span&gt;&#x27;pexpire&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;1&lt;/span&gt;], ARGV[&lt;span&gt;1&lt;/span&gt;]); &lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; nil; &lt;br/&gt;end; &lt;br/&gt;&lt;span&gt;return&lt;/span&gt; redis.call(&lt;span&gt;&#x27;pttl&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;1&lt;/span&gt;]);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是redisson框架的加锁代码，写的不错，大家可以借鉴一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有趣，下面还有哪些好玩的东西？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4 大量失败请求&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的加锁方法看起来好像没有问题，但如果你仔细想想，如果有1万的请求同时去竞争那把锁，可能只有一个请求是成功的，其余的9999个请求都会失败。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在秒杀场景下，会有什么问题？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：每1万个请求，有1个成功。再1万个请求，有1个成功。如此下去，直到库存不足。这就变成均匀分布的秒杀了，跟我们想象中的不一样。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何解决这个问题呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，还有一种场景：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，有两个线程同时上传文件到sftp，上传文件前先要创建目录。假设两个线程需要创建的目录名都是当天的日期，比如：20210920，如果不做任何控制，直接并发的创建目录，第二个线程必然会失败。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候有些朋友可能会说：这还不容易，加一个redis分布式锁就能解决问题了，此外再判断一下，如果目录已经存在就不创建，只有目录不存在才需要创建。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;伪代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;  String result = jedis.set(lockKey, requestId, &lt;span&gt;&quot;NX&quot;&lt;/span&gt;, &lt;span&gt;&quot;PX&quot;&lt;/span&gt;, expireTime);&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;OK&quot;&lt;/span&gt;.equals(result)) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(!exists(path)) {&lt;br/&gt;       mkdir(path);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;} &lt;span&gt;finally&lt;/span&gt;{&lt;br/&gt;    unlock(lockKey,requestId);&lt;br/&gt;}  &lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一切看似美好，但经不起仔细推敲。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来自灵魂的一问：第二个请求如果加锁失败了，接下来，是返回失败，还是返回成功呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要流程图如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;2.2&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDFpywBzMdt5EHAekqHT61dCoUmZFovLJETjvPfLH5FezvOaCXZZuWBmlyBRGaHbZwkiaiadZUtmOgAg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;430&quot;/&gt;显然第二个请求，肯定是不能返回失败的，如果返回失败了，这个问题还是没有被解决。如果文件还没有上传成功，直接返回成功会有更大的问题。头疼，到底该如何解决呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：使用&lt;code&gt;自旋锁&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;  Long start = System.currentTimeMillis();&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;     String result = jedis.set(lockKey, requestId, &lt;span&gt;&quot;NX&quot;&lt;/span&gt;, &lt;span&gt;&quot;PX&quot;&lt;/span&gt;, expireTime);&lt;br/&gt;     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;OK&quot;&lt;/span&gt;.equals(result)) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(!exists(path)) {&lt;br/&gt;           mkdir(path);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;     }&lt;br/&gt;     &lt;br/&gt;     &lt;span&gt;long&lt;/span&gt; time = System.currentTimeMillis() - start;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (time&amp;gt;=timeout) {&lt;br/&gt;          &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;          Thread.sleep(&lt;span&gt;50&lt;/span&gt;);&lt;br/&gt;      } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;          e.printStackTrace();&lt;br/&gt;      }&lt;br/&gt;  }&lt;br/&gt;} &lt;span&gt;finally&lt;/span&gt;{&lt;br/&gt;    unlock(lockKey,requestId);&lt;br/&gt;}  &lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在规定的时间，比如500毫秒内，自旋不断尝试加锁（说白了，就是在死循环中，不断尝试加锁），如果成功则直接返回。如果失败，则休眠50毫秒，再发起新一轮的尝试。如果到了超时时间，还未加锁成功，则直接返回失败。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好吧，学到一招了，还有吗？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5 锁重入问题&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道redis分布式锁是互斥的。假如我们对某个key加锁了，如果该key对应的锁还没失效，再用相同key去加锁，大概率会失败。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，大部分场景是没问题的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么说是大部分场景呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为还有这样的场景：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设在某个请求中，需要获取一颗满足条件的菜单树或者分类树。我们以菜单为例，这就需要在接口中从根节点开始，递归遍历出所有满足条件的子节点，然后组装成一颗菜单树。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是菜单不是一成不变的，在后台系统中运营同学可以动态添加、修改和删除菜单。为了保证在并发的情况下，每次都可能获取最新的数据，这里可以加redis分布式锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加redis分布式锁的思路是对的。但接下来问题来了，在递归方法中递归遍历多次，每次都是加的同一把锁。递归第一层当然是可以加锁成功的，但递归第二层、第三层...第N层，不就会加锁失败了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;递归方法中加锁的伪代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; expireTime = &lt;span&gt;1000&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;fun&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; level,String lockKey,String requestId)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;try&lt;/span&gt;{&lt;br/&gt;     String result = jedis.set(lockKey, requestId, &lt;span&gt;&quot;NX&quot;&lt;/span&gt;, &lt;span&gt;&quot;PX&quot;&lt;/span&gt;, expireTime);&lt;br/&gt;     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;OK&quot;&lt;/span&gt;.equals(result)) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(level&amp;lt;=&lt;span&gt;10&lt;/span&gt;){&lt;br/&gt;           &lt;span&gt;this&lt;/span&gt;.fun(++level,lockKey,requestId);&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;           &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;     }&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;  } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;     unlock(lockKey,requestId);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你直接这么用，看起来好像没有问题。但最终执行程序之后发现，等待你的结果只有一个：&lt;code&gt;出现异常&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为从根节点开始，第一层递归加锁成功，还没释放锁，就直接进入第二层递归。因为锁名为lockKey，并且值为requestId的锁已经存在，所以第二层递归大概率会加锁失败，然后返回到第一层。第一层接下来正常释放锁，然后整个递归方法直接返回了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这下子，大家知道出现什么问题了吧？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，递归方法其实只执行了第一层递归就返回了，其他层递归由于加锁失败，根本没法执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么这个问题该如何解决呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：使用&lt;code&gt;可重入锁&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们以redisson框架为例，它的内部实现了可重入锁的功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;古时候有句话说得好：为人不识陈近南，便称英雄也枉然。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我说：分布式锁不识redisson，便称好锁也枉然。哈哈哈，只是自娱自乐一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由此可见，redisson在redis分布式锁中的江湖地位很高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;伪代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; expireTime = &lt;span&gt;1000&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;(String lockKey)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  RLock lock = redisson.getLock(lockKey);&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.fun(lock,&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;fun&lt;/span&gt;&lt;span&gt;(RLock lock,&lt;span&gt;int&lt;/span&gt; level)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;try&lt;/span&gt;{&lt;br/&gt;      lock.lock(&lt;span&gt;5&lt;/span&gt;, TimeUnit.SECONDS);&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt;(level&amp;lt;=&lt;span&gt;10&lt;/span&gt;){&lt;br/&gt;         &lt;span&gt;this&lt;/span&gt;.fun(lock,++level);&lt;br/&gt;      } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;         &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;      }&lt;br/&gt;  } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;     lock.unlock();&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的代码也许并不完美，这里只是给了一个大致的思路，如果大家有这方面需求的话，以上代码仅供参考。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，聊聊redisson可重入锁的实现原理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加锁主要是通过以下脚本实现的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (redis.call(&lt;span&gt;&#x27;exists&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;1&lt;/span&gt;]) == &lt;span&gt;0&lt;/span&gt;) &lt;br/&gt;then  &lt;br/&gt;   redis.call(&lt;span&gt;&#x27;hset&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;1&lt;/span&gt;], ARGV[&lt;span&gt;2&lt;/span&gt;], &lt;span&gt;1&lt;/span&gt;);        redis.call(&lt;span&gt;&#x27;pexpire&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;1&lt;/span&gt;], ARGV[&lt;span&gt;1&lt;/span&gt;]); &lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; nil; &lt;br/&gt;end;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (redis.call(&lt;span&gt;&#x27;hexists&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;1&lt;/span&gt;], ARGV[&lt;span&gt;2&lt;/span&gt;]) == &lt;span&gt;1&lt;/span&gt;) &lt;br/&gt;then  &lt;br/&gt;  redis.call(&lt;span&gt;&#x27;hincrby&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;1&lt;/span&gt;], ARGV[&lt;span&gt;2&lt;/span&gt;], &lt;span&gt;1&lt;/span&gt;); &lt;br/&gt;  redis.call(&lt;span&gt;&#x27;pexpire&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;1&lt;/span&gt;], ARGV[&lt;span&gt;1&lt;/span&gt;]); &lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; nil; &lt;br/&gt;end;&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; redis.call(&lt;span&gt;&#x27;pttl&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;1&lt;/span&gt;]);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;KEYS[1]：锁名&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ARGV[1]：过期时间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ARGV[2]：uuid + &quot;:&quot; + threadId，可认为是requestId&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;先判断如果锁名不存在，则加锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;接下来，判断如果锁名和requestId值都存在，则使用hincrby命令给该锁名和requestId值计数，每次都加1。注意一下，这里就是重入锁的关键，锁重入一次值就加1。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果锁名存在，但值不是requestId，则返回过期时间。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;释放锁主要是通过以下脚本实现的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (redis.call(&lt;span&gt;&#x27;hexists&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;1&lt;/span&gt;], ARGV[&lt;span&gt;3&lt;/span&gt;]) == &lt;span&gt;0&lt;/span&gt;) &lt;br/&gt;then &lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; nil&lt;br/&gt;end&lt;br/&gt;local counter = redis.call(&lt;span&gt;&#x27;hincrby&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;1&lt;/span&gt;], ARGV[&lt;span&gt;3&lt;/span&gt;], -&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (counter &amp;gt; &lt;span&gt;0&lt;/span&gt;) &lt;br/&gt;then &lt;br/&gt;    redis.call(&lt;span&gt;&#x27;pexpire&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;1&lt;/span&gt;], ARGV[&lt;span&gt;2&lt;/span&gt;]); &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;; &lt;br/&gt; &lt;span&gt;else&lt;/span&gt; &lt;br/&gt;   redis.call(&lt;span&gt;&#x27;del&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;1&lt;/span&gt;]); &lt;br/&gt;   redis.call(&lt;span&gt;&#x27;publish&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;2&lt;/span&gt;], ARGV[&lt;span&gt;1&lt;/span&gt;]); &lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;; &lt;br/&gt;end; &lt;br/&gt;&lt;span&gt;return&lt;/span&gt; nil&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;先判断如果锁名和requestId值不存在，则直接返回。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果锁名和requestId值存在，则重入锁减1。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果减1后，重入锁的value值还大于0，说明还有引用，则重试设置过期时间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果减1后，重入锁的value值还等于0，则可以删除锁，然后发消息通知等待线程抢锁。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;再次强调一下，如果你们系统可以容忍数据暂时不一致，有些场景不加锁也行，我在这里只是举个例子，本节内容并不适用于所有场景。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6 锁竞争问题&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果有大量需要写入数据的业务场景，使用普通的redis分布式锁是没有问题的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果有些业务场景，写入的操作比较少，反而有大量读取的操作。这样直接使用普通的redis分布式锁，会不会有点浪费性能？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道，锁的粒度越粗，多个线程抢锁时竞争就越激烈，造成多个线程锁等待的时间也就越长，性能也就越差。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，提升redis分布式锁性能的第一步，就是要把锁的粒度变细。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;6.1 读写锁&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;众所周知，加锁的目的是为了保证，在并发环境中读写数据的安全性，即不会出现数据错误或者不一致的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但在绝大多数实际业务场景中，一般是读数据的频率远远大于写数据。而线程间的并发读操作是并不涉及并发安全问题，我们没有必要给读操作加互斥锁，只要保证读写、写写并发操作上锁是互斥的就行，这样可以提升系统的性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们以redisson框架为例，它内部已经实现了读写锁的功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读锁的伪代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;RReadWriteLock readWriteLock = redisson.getReadWriteLock(&lt;span&gt;&quot;readWriteLock&quot;&lt;/span&gt;);&lt;br/&gt;RLock rLock = readWriteLock.readLock();&lt;br/&gt;&lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    rLock.lock();&lt;br/&gt;    &lt;span&gt;//业务操作&lt;/span&gt;&lt;br/&gt;} &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;    log.error(e);&lt;br/&gt;} &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;    rLock.unlock();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写锁的伪代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;RReadWriteLock readWriteLock = redisson.getReadWriteLock(&lt;span&gt;&quot;readWriteLock&quot;&lt;/span&gt;);&lt;br/&gt;RLock rLock = readWriteLock.writeLock();&lt;br/&gt;&lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    rLock.lock();&lt;br/&gt;    &lt;span&gt;//业务操作&lt;/span&gt;&lt;br/&gt;} &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;   log.error(e);&lt;br/&gt;} &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;    rLock.unlock();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将读锁和写锁分开，最大的好处是提升读操作的性能，因为读和读之间是共享的，不存在互斥性。而我们的实际业务场景中，绝大多数数据操作都是读操作。所以，如果提升了读操作的性能，也就会提升整个锁的性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面总结一个读写锁的特点：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;6.2 锁分段&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，为了减小锁的粒度，比较常见的做法是将大锁：&lt;code&gt;分段&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在java中&lt;code&gt;ConcurrentHashMap&lt;/code&gt;，就是将数据分为&lt;code&gt;16段&lt;/code&gt;，每一段都有单独的锁，并且处于不同锁段的数据互不干扰，以此来提升锁的性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;放在实际业务场景中，我们可以这样做：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如在秒杀扣库存的场景中，现在的库存中有2000个商品，用户可以秒杀。为了防止出现超卖的情况，通常情况下，可以对库存加锁。如果有1W的用户竞争同一把锁，显然系统吞吐量会非常低。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了提升系统性能，我们可以将库存分段，比如：分为100段，这样每段就有20个商品可以参与秒杀。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在秒杀的过程中，先把用户id获取hash值，然后除以100取模。模为1的用户访问第1段库存，模为2的用户访问第2段库存，模为3的用户访问第3段库存，后面以此类推，到最后模为100的用户访问第100段库存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2900662251655629&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDFpywBzMdt5EHAekqHT61dCziaWqPRnl9m4UytstIE2IibpsY5icYShp6CG003ibwUkHmoLmbPLG6lztg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1510&quot;/&gt;如此一来，在多线程环境中，可以大大的减少锁的冲突。以前多个线程只能同时竞争1把锁，尤其在秒杀的场景中，竞争太激烈了，简直可以用惨绝人寰来形容，其后果是导致绝大数线程在锁等待。现在多个线程同时竞争100把锁，等待的线程变少了，从而系统吞吐量也就提升了。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;需要注意的地方是：将锁分段虽说可以提升系统的性能，但它也会让系统的复杂度提升不少。因为它需要引入额外的路由算法，跨段统计等功能。我们在实际业务场景中，需要综合考虑，不是说一定要将锁分段。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7 锁超时问题&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我在前面提到过，如果线程A加锁成功了，但是由于业务功能耗时时间很长，超过了设置的超时时间，这时候redis会自动释放线程A加的锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些朋友可能会说：到了超时时间，锁被释放了就释放了呗，对功能又没啥影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：错，错，错。对功能其实有影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常我们加锁的目的是：为了防止访问临界资源时，出现数据异常的情况。比如：线程A在修改数据C的值，线程B也在修改数据C的值，如果不做控制，在并发情况下，数据C的值会出问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了保证某个方法，或者段代码的互斥性，即如果线程A执行了某段代码，是不允许其他线程在某一时刻同时执行的，我们可以用&lt;code&gt;synchronized&lt;/code&gt;关键字加锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这种锁有很大的局限性，只能保证单个节点的互斥性。如果需要在多个节点中保持互斥性，就需要用redis分布式锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;做了这么多铺垫，现在回到正题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设线程A加redis分布式锁的代码，包含代码1和代码2两段代码。&lt;img data-ratio=&quot;1.3113207547169812&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDFpywBzMdt5EHAekqHT61dCox1uldbqb3HAmWZyWRp8MlPsm5Ig1cMTTrLUukd5Hfenib7icnspSweA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;424&quot;/&gt;由于该线程要执行的业务操作非常耗时，程序在执行完代码1的时，已经到了设置的超时时间，redis自动释放了锁。而代码2还没来得及执行。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6539379474940334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDFpywBzMdt5EHAekqHT61dC9BC6ibtCtiarBJia5ZB5CJ2MGEKnMQWuhfZYq1LANZr8ibdVGiavzrEuo6g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;838&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，代码2相当于裸奔的状态，无法保证互斥性。假如它里面访问了临界资源，并且其他线程也访问了该资源，可能就会出现数据异常的情况。（PS：我说的访问临界资源，不单单指读取，还包含写入）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何解决这个问题呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：如果达到了超时时间，但业务代码还没执行完，需要给锁自动续期。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以使用&lt;code&gt;TimerTask&lt;/code&gt;类，来实现自动续期的功能：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Timer timer = &lt;span&gt;new&lt;/span&gt; Timer(); &lt;br/&gt;timer.schedule(&lt;span&gt;new&lt;/span&gt; TimerTask() {&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;(Timeout timeout)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;//自动续期逻辑&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;}, &lt;span&gt;10000&lt;/span&gt;, TimeUnit.MILLISECONDS);&lt;br/&gt;        &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;获取锁之后，自动开启一个定时任务，每隔10秒钟，自动刷新一次过期时间。这种机制在redisson框架中，有个比较霸气的名字：&lt;code&gt;watch dog&lt;/code&gt;，即传说中的&lt;code&gt;看门狗&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然自动续期功能，我们还是优先推荐使用lua脚本实现，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (redis.call(&lt;span&gt;&#x27;hexists&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;1&lt;/span&gt;], ARGV[&lt;span&gt;2&lt;/span&gt;]) == &lt;span&gt;1&lt;/span&gt;) then &lt;br/&gt;   redis.call(&lt;span&gt;&#x27;pexpire&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;1&lt;/span&gt;], ARGV[&lt;span&gt;1&lt;/span&gt;]);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;; &lt;br/&gt;end;&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的地方是：在实现自动续期功能时，还需要设置一个总的过期时间，可以跟redisson保持一致，设置成30秒。如果业务代码到了这个总的过期时间，还没有执行完，就不再自动续期了。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;自动续期的功能是获取锁之后开启一个定时任务，每隔10秒判断一下锁是否存在，如果存在，则刷新过期时间。如果续期3次，也就是30秒之后，业务方法还是没有执行完，就不再续期了。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8 主从复制的问题&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面花了这么多篇幅介绍的内容，对单个redis实例是没有问题的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;but，如果redis存在多个实例。比如：做了主从，或者使用了哨兵模式，基于redis的分布式锁的功能，就会出现问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体是什么问题？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设redis现在用的主从模式，1个master节点，3个slave节点。master节点负责写数据，slave节点负责读数据。&lt;img data-ratio=&quot;0.4693333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDFpywBzMdt5EHAekqHT61dCyHic3FF76je6MGKYvoBABpkPGT7iaV3RUPqTAX7EZtOSKZm2a2VN1jiag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;本来是和谐共处，相安无事的。redis加锁操作，都在master上进行，加锁成功后，再异步同步给所有的slave。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;突然有一天，master节点由于某些不可逆的原因，挂掉了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样需要找一个slave升级为新的master节点，假如slave1被选举出来了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.703125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDFpywBzMdt5EHAekqHT61dCfz9byBc8KmGqCmOTNVfp8tStCDw0MLqga8iaU1XWLf01PBV0Xib8H1bw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;512&quot;/&gt;如果有个锁A比较悲催，刚加锁成功master就挂了，还没来得及同步到slave1。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样会导致新master节点中的锁A丢失了。后面，如果有新的线程，使用锁A加锁，依然可以成功，分布式锁失效了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何解决这个问题呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：redisson框架为了解决这个问题，提供了一个专门的类：&lt;code&gt;RedissonRedLock&lt;/code&gt;，使用了Redlock算法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RedissonRedLock解决问题的思路如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;需要搭建几套相互独立的redis环境，假如我们在这里搭建了5套。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每套环境都有一个redisson node节点。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;多个redisson node节点组成了RedissonRedLock。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;环境包含：单机、主从、哨兵和集群模式，可以是一种或者多种混合。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这里我们以主从为例，架构图如下：&lt;img data-ratio=&quot;0.3622641509433962&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDFpywBzMdt5EHAekqHT61dCvn7c862zRO0Dn9b2ZLUZTwsaFuvOGMHf2vw77tjrpEwSK5NK2uOicNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1590&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RedissonRedLock加锁过程如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;获取所有的&lt;span&gt;redisson node节点信息，&lt;/span&gt;循环向所有的redisson node节点加锁，假设节点数为N，例子中N等于5。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果在N个节点当中，有N/2 + 1个节点加锁成功了，那么整个RedissonRedLock加锁是成功的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果在N个节点当中，小于N/2 + 1个节点加锁成功，那么整个RedissonRedLock加锁是失败的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果中途发现各个节点加锁的总耗时，大于等于设置的最大等待时间，则直接返回失败。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面可以看出，使用Redlock算法，确实能解决多实例场景中，假如master节点挂了，导致分布式锁失效的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但也引出了一些新问题，比如：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;需要额外搭建多套环境，申请更多的资源，需要评估一下成本和性价比。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果有N个redisson node节点，需要加锁N次，最少也需要加锁N/2+1次，才知道redlock加锁是否成功。显然，增加了额外的时间成本，有点得不偿失。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由此可见，在实际业务场景，尤其是高并发业务中，RedissonRedLock其实使用的并不多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在分布式环境中，CAP是绕不过去的。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;CAP指的是在一个分布式系统中：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一致性（Consistency）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可用性（Availability）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分区容错性（Partition tolerance）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这三个要素最多只能同时实现两点，不可能三者兼顾。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你的实际业务场景，更需要的是保证数据一致性。那么请使用CP类型的分布式锁，比如：zookeeper，它是基于磁盘的，性能可能没那么好，但数据一般不会丢。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你的实际业务场景，更需要的是保证数据高可用性。那么请使用AP类型的分布式锁，比如：redis，它是基于内存的，性能比较好，但有丢失数据的风险。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;其实，在我们绝大多数分布式业务场景中，使用redis分布式锁就够了，真的别太较真。因为数据不一致问题，可以通过最终一致性方案解决。但如果系统不可用了，对用户来说是暴击一万点伤害。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9c91d734e2c8ad77ebad9e6d6ccf863a</guid>
<title>走近 DDD</title>
<link>https://toutiao.io/k/zz67p1j</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;header class=&quot;post-header&quot;&gt;
      &lt;h1 class=&quot;post-title&quot;&gt;走近DDD&lt;/h1&gt;

      &lt;p class=&quot;post-meta&quot;&gt;
        &lt;span class=&quot;post-time&quot;&gt; 2021-09-26 &lt;/span&gt;
        
          &lt;span class=&quot;more-meta&quot;&gt; 约 5331 字 &lt;/span&gt;
          &lt;span class=&quot;more-meta&quot;&gt; 预计阅读 11 分钟 &lt;/span&gt;
        
      &lt;/p&gt;
    &lt;/header&gt;

    &lt;div class=&quot;post-content&quot;&gt;
      &lt;p&gt;《领域驱动设计精粹》这本书是 DDD 的发明者Evans在提出DDD多年后写的一本小册子，是为了降低DDD上手难度而写的一本小册子，它很棒地阐述了DDD的来龙去脉，而没有落入与之无关的细节中——入门的时候就是应该高屋建瓴，不是吗？&lt;/p&gt;
&lt;h2 id=&quot;为什么需要ddd&quot;&gt;为什么需要DDD？&lt;/h2&gt;
&lt;p&gt;没有实施DDD的情况下，我们经常会遇到什么问题？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;开发人员热衷于技术而不是深入了解业务。这是技术人员的职责使然，一个不高级的开发，通常他的业务经验不重要；一个高级的开发，通常因为竞业，也无法继续干类似的业务。所以开发人员对业务天然的没有足够的兴趣。但是开发过程中，对业务不够熟悉，很容易发现开发做了半天得到的，并不是用户和产品想要的；或者下次再有需求的时候，技术上的改动特别大，成本很高。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;业务协作不畅，一个需求提到好几个团队都能做，但是开发过程你推我我推你，需求一拖再拖，有时候项目中期还得找其他团队求资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对项目工时的估计占用了不少精力，还不准确。估时这件事能成为管理层和开发人员之间的拉锯战。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务之间紧耦合，牵一发而动全身，一个非核心的业务抖一抖，客户都说没法用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;那么ddd怎么解决这些问题&quot;&gt;那么 DDD 怎么解决这些问题？&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;找到边界：让设计系统的人知道一个业务的边界在哪里。只有知道边界在哪里，才能在需求到来的时候，轻易地找到相关团队，各个业务之间也才能真正解耦，降低非核心功能对核心功能的影响。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;知识获取：保证设计系统的人能够低成本地了解业务，让大家在怎么做，怎么验收方面达成一致。在此基础上，还可以免费得到一款评估时间的工具，项目的交付就更有把握。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是在此我要多说一下，我们现实实践中已经有一部分领域概念的影子了——谁能说他不知道自己的组织是干啥的？或者说哪个组织没有业务重心呢？可是为什么大家没有获得上边说的这诸多好处呢？那是因为DDD实践过程中巧妙地将设计模型落地成为开发的模型，让需求方和实施方说一种语言，才能真正跨越了需求和实现之间的鸿沟。所以实践DDD，绝不是只有开发写写代码就行，而是要跟产品，设计以及领域专家一起完成设计，才能得到DDD的好处。&lt;/p&gt;
&lt;h2 id=&quot;ddd是什么呢&quot;&gt;DDD是什么呢?&lt;/h2&gt;
&lt;p&gt;我们先看几个*DD：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;TDD 驱动测试开发&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BDD 行为驱动开发&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ADD 不是单词Add，而是 API 驱动开发&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DDD 领域驱动&lt;strong&gt;设计&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;前面几个概念落脚点都是开发，而DDD，是设计。&lt;/p&gt;
&lt;p&gt;它有三个关键词：领域，驱动，设计。领域，是要探索业务的边界；驱动,表示前者是后者的决定性因素；设计，包括产品设计，UIUE设计，软件设计。它不仅仅是开发架构的方案，而是完整的解决方案实施思路。正是因为它是完整的方案，才能让领域专家，产品和研发真正在同一个角度去思考和沟通，避免推诿扯皮，含糊不清。&lt;/p&gt;
&lt;h2 id=&quot;那么怎么做ddd呢&quot;&gt;那么怎么做DDD呢?&lt;/h2&gt;
&lt;p&gt;实施DDD一般有两步，并且需要开发，产品和领域专家的通力合作。为了实施速度有所保障，还有一些项目加速和项目管理工具：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;战略设计&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;战术设计&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;战略设计&quot;&gt;战略设计&lt;/h3&gt;
&lt;p&gt;战略设计可以说是搭建了业务思想上的框架。这个阶段要做这么几件事：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用限界上下文分离领域模型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在限界上下文发展通用语言&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用子域处理遗留系统&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用上下文映射来集成多个限界上下文&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;限界上下文分离领域模型&quot;&gt;限界上下文分离领域模型&lt;/h4&gt;
&lt;p&gt;限界上下文这个名字乍一看，每个字我都认识，但是这个词是啥意思？原文说它是语义和语境上的边界，我的理解是，它是在描述组织交付出来，面向客户的交付边界。如果是在SaaS场景，一个限界上下文应该是一个独立交付的软件；在PaaS场景，它应该说的是一个独立售卖的模块。它的含义是找到一个边界，要把这个边界以外的当成是无法改变的客观环境，不要幻想这个边界以外的人会配合你一起完成交付。那这一步设计就很好理解了，就是找到你业务对外承诺的边界，你要发展的业务在这个边界内，而不在此之外。如果你是对内交付的系统，那么你对其他同事交付的业务边界，就是你的业务限界上下文。&lt;/p&gt;
&lt;p&gt;一个组织里，最核心的限界上下文被称为核心域。通常除了它，还有通用子域和支撑子域。通用子域是很成熟的业务，通常可以外包或者购买现成的解决方案，比如搜索子域可以通过ES来支持；支撑子域通常没有现成产品，但是它没有核心域重要，因此也可以一定程度的外包，避免在核心域之外浪费资源，比如大多数公司的数据库中间件是在开源产品上做了一些定制开发和维护。&lt;/p&gt;
&lt;p&gt;限界上下文这个概念的目的是为了在业务扩展的时候，防止向领域内注入概念，导致业务变得没有边界，纠缠在一起。&lt;/p&gt;
&lt;p&gt;在做这一步的时候，DDD要求以领域专家意见为准，正所谓领域驱动嘛。当实施了DDD方法以后，不论是领域专家还是开发，都应该拒绝向领域注入与业务无关的概念，比如存储方式等。这与我们日常工作从如何存储开始构建业务系统是完全不同的。只有把这些技术概念放到业务之外，我们的业务核心往往才能足够集中，易于迁移，而且不论采用什么东西存储，用什么东西展示，它的逻辑都可以不变。&lt;/p&gt;
&lt;p&gt;这个过程中我们通常可以得到这样一个模型：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;Pasted%20image%2020210918025918.png&quot; alt=&quot;Pasted image 20210918025918&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;限界上下文发展通用语言&quot;&gt;限界上下文发展通用语言&lt;/h4&gt;
&lt;p&gt;当我们有了业务的限界上下文以后，就需要在这个限界上下文中发展一种语言用于表达软件模型，这个语言就叫做这个限界上下文里的通用语言。它可以是任何计算机语言、人类语言或者图形，只要能让团队内的每个人都能看懂。&lt;/p&gt;
&lt;p&gt;通用语言不止是名词，它应该使用一系列具体的模型场景来描述领域模型。它描述了各种业务组件（不是技术组件）做什么，而不是用例或者用户故事。&lt;/p&gt;
&lt;p&gt;比如微信朋友圈点赞这个场景，通用语言可能是：用户可以通过点赞，使得某个朋友圈的Feed发出人收到被点赞的通知，达到互动的目的。&lt;/p&gt;
&lt;p&gt;但是到这一步，我们怎么能验证领域模型能与领域专家的心智保持一致呢？那就是为这个模型写验收测试，并交由领域专家评估。一种做法是验收测试采用given-when-then语法（中文可以用假如-当-那么），便于阅读理解。验收测试也可以用脑图，文字来描述，甚至DDD不反对采用单元测试框架写验收测试，只要领域专家能够阅读并理解写出的验收测试。&lt;/p&gt;
&lt;p&gt;这一步做完后我们的模型图形其实没什么变化，但是现在，开发能够更充分的了解业务了。&lt;/p&gt;
&lt;h4 id=&quot;使用子域处理遗留系统&quot;&gt;使用子域处理遗留系统&lt;/h4&gt;
&lt;p&gt;我们代码不是在真空里运行，它们免不了会跟一些遗留系统打交道，这些遗留系统的边界并不清晰。因此我们会将遗留系统放到一个子域里，把它们的问题放到我们的设计之外。这一步做完后我们的图案与之前没有本质上的区别，无非是多了一点子域。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;Pasted%20image%2020210918035843.png&quot; alt=&quot;Pasted image 20210918035843&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;使用上下文映射来集成多个限界上下文&quot;&gt;使用上下文映射来集成多个限界上下文&lt;/h4&gt;
&lt;p&gt;上下文映射是两个限界上下文之间的连线，表示了这两个概念之间的关系，也表示这这两个概念的通用语言的翻译。通常来说，不同的限界上下文是不同的团队在维护，那么此时它也代表着两个团队之间合作的关系。&lt;/p&gt;
&lt;p&gt;我们常见的映射关系是RPC接口。然而在领域设计里，限界上下文之间使用RPC是有风险的方案，因为会承受网络风险，还意味着两个限界上下文之间存在紧耦合。如果系统A阻塞请求系统B，B又请求C，就很容易导致集成火车事故：火车里某一节车厢有问题就会变成整列火车的问题。&lt;/p&gt;
&lt;p&gt;最好的限界上下文映射关系采用事件的订阅，但是这要求领域专家在设计的时候就考虑不同领域之间通知的延迟对于业务的影响，以及如何消除影响。如果不采用DDD的方式，领域专家通常无法意识到领域之间的同步成本，技术人员也很容易一头撞进集成火车里。这就是我说的：DDD的目标是找到边界和促进学习知识，不仅仅是开发学习业务，领域专家也是在学习系统的边界与设计。&lt;/p&gt;
&lt;h3 id=&quot;战术设计&quot;&gt;战术设计&lt;/h3&gt;
&lt;p&gt;在战术设计阶段包括如下设计：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;把一些实体和值对象放一起，称为聚合。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;利用领域事件通知相关系统。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;聚合怎么设计&quot;&gt;聚合怎么设计&lt;/h4&gt;
&lt;p&gt;一个限界上下文里通常有多个聚合，聚合逻辑上是相对独立的。怎么理解聚合的概念呢？在DDD实践中，聚合是事务的边界；聚合之间并不保证事务，只能用最终一致性。任何需要事务保护的逻辑都应该在一个聚合内。在限界上下文里，将其他聚合能力整合在一起对外提供能力的聚合，被称为聚合根；其他聚合也被称为实体。&lt;/p&gt;
&lt;p&gt;此外，一个限界上下文里还有值对象，它也代表了某种相对独立的概念。怎么区分实体和值对象呢？这取决于业务。如果一个名词，具有多种动词去操作它，那么它应该是一个实体；如果一个名词，在系统里只是被传递而没有业务逻辑，那么它就是值对象。&lt;/p&gt;
&lt;p&gt;由于聚合是事务的边界，那么每个聚合在设计阶段，最重要的是找到业务的不变性，也就是说，在事务提交前后，数据的约束条件。比如说，你在知乎对一条回答点赞，那么这条回答的点赞数量必须立刻多1，那么点赞的动作和点赞的计数，就应当在一个聚合内。&lt;/p&gt;
&lt;p&gt;领域专家必然希望任何事情都能在触发后立刻完成，所以在沟通的过程中要不断质疑，如果不实时地做一件事，会不会有问题。甚至可以用一个夸张到显然无法接受的时间长度来质疑，以促成领域专家对此认真思考。&lt;/p&gt;
&lt;p&gt;在聚合被设计出来以后，我们的模型图看起来会是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;Pasted%20image%2020210918043208.png&quot; alt=&quot;Pasted image 20210918043208&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;领域事件怎么设计&quot;&gt;领域事件怎么设计&lt;/h4&gt;
&lt;p&gt;我们说聚合之间要采用最终一致性，而通常的做法是采用领域事件实现最终一致性。领域事件的名称应该采用通用语言命名，才能符合领域专家的心智。完整的时间名词应该是名词和动词构成的，动词应该是过去时。领域事件的名字和属性应该能够完整描述这个事件的含义。&lt;/p&gt;
&lt;p&gt;事件里通常至少包含业务动作和其业务参数，也可以增加更多的下游关注的事件信息，避免下游为了完成处理还需查询。&lt;/p&gt;
&lt;p&gt;领域事件会持久保存在专门的数据表中，用来表示领域事件的因果关系。&lt;/p&gt;
&lt;p&gt;有一种专门的存储方式是事件溯源，它不需要存储数据当前是什么，而是从历史事件中按顺序应用重建，得到当前的数据。这样写入时的成本只有校验后持久化，也没有增加和删除的能力。如果事件很多，性能问题很大，也可以加上缓存和快照，优化性能。这种方案通常会与CQRS方案一起做。&lt;/p&gt;
&lt;h2 id=&quot;进度加速和项目管理工具&quot;&gt;进度加速和项目管理工具&lt;/h2&gt;
&lt;p&gt;在这本小册子里,Evans提出了两个工具，分别用于加速设计阶段和评估工时。&lt;/p&gt;
&lt;h3 id=&quot;事件风暴&quot;&gt;事件风暴&lt;/h3&gt;
&lt;p&gt;事件风暴是快速的设计技术，让领域专家和开发人员都可以参与学习，目的是在有限的时间里尽可能多地完成设计，也就是加速设计阶段。&lt;/p&gt;
&lt;p&gt;事件风暴要先做如下准备：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;邀请领域专家和开发人员&lt;/li&gt;
&lt;li&gt;每个成员都应该以开放的心态参与讨论，不必追求正确和速度。&lt;/li&gt;
&lt;li&gt;各种颜色便利贴，正方形的。一般一个便利贴只会写几个词。&lt;/li&gt;
&lt;li&gt;每个人都有黑色的马克笔。&lt;/li&gt;
&lt;li&gt;最好有一面至少10米长的墙并且铺上白纸。最好建模的几天时间内保持每次讨论的结果一直保留并供下次讨论使用。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;事件风暴的基本步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在便利贴上写领域事件，梳理出业务流程，一般是橘色。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建领域事件强调我们首要关注的是业务流程，而不是数据和结构&lt;/li&gt;
&lt;li&gt;把每个领域事件写在一张便利贴上，应该是动词的过去式。&lt;/li&gt;
&lt;li&gt;把写好的便利贴按照时间顺序放到建模平面上，从左往右逐步发生。&lt;/li&gt;
&lt;li&gt;并行发生的领域可以上下排列，不明白时机的事件可以单放在某个单独的位置。&lt;/li&gt;
&lt;li&gt;如果发现了问题点，可以用红色的便利贴上，并用一段文字解释是什么问题。&lt;/li&gt;
&lt;li&gt;领域事件最终会触发一个执行的流程，每个流程都应该命名并记录在浅紫色的便利贴。需要从领域事件画个箭头指向这个流程。支队核心域中非常重要的细粒度事件进行建模。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建导致领域事件发生的命令，命令应该是指令式的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建领域事件的便利贴是浅蓝色的。&lt;/li&gt;
&lt;li&gt;触发事件的便利贴放在触发的事件左边，会有很多成对出现的命令和事件。但是也有不是命令触发的事件，比如时间触发的事件。&lt;/li&gt;
&lt;li&gt;如果存在一个执行动作的特定角色，那么可以在命令左下角使用亮黄色的便利贴记录角色名称。&lt;/li&gt;
&lt;li&gt;命令也可以触发流程。&lt;/li&gt;
&lt;li&gt;在命令和事件之间画出线条&lt;/li&gt;
&lt;li&gt;按照时间顺序，将命令和事件的关系处理好&lt;/li&gt;
&lt;li&gt;一个命令可以带来多个事件&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;把命令和领域事件通过实体、聚合联系起来。由于建模没完，因此没有真正的实体和聚合，而是领域专家思想里的业务概念和概念群。用淡黄色的便利贴来表示聚合，其左下角是命令，右下角是事件。聚合的名字应该是名词。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在建模平面上画出边界和事件流动的箭头。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;识别用户执行操作所需的各种视图，以及客户不同用户的关键角色。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;4和5是事件风暴的关键。&lt;/p&gt;
&lt;h3 id=&quot;时间评估工具&quot;&gt;时间评估工具&lt;/h3&gt;
&lt;p&gt;时间评估工具是如下的一个经验表格：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;领域内的组件类型&lt;/th&gt;
&lt;th&gt;简单&lt;/th&gt;
&lt;th&gt;适中&lt;/th&gt;
&lt;th&gt;复杂&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;领域事件&lt;/td&gt;
&lt;td&gt;0.1&lt;/td&gt;
&lt;td&gt;0.2&lt;/td&gt;
&lt;td&gt;0.3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;命令&lt;/td&gt;
&lt;td&gt;0.1&lt;/td&gt;
&lt;td&gt;0.2&lt;/td&gt;
&lt;td&gt;0.3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;聚合&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;…&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;作者Evans在原始表格里使用的单位是人时，然而根据我的经验，这个地方用人天还差不多……&lt;/p&gt;
&lt;p&gt;这个表格的好处是系统里关于业务的部分都很明确了，虽然时间还是经验得出的，但是实际上已经相对精细了，而且在领域内的部分，估时会更准确一些，  而且它的复杂度与业务方的预估不会差太多。&lt;/p&gt;
&lt;h2 id=&quot;常见的ddd误区&quot;&gt;常见的DDD误区：&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;DDD一定要用微服务？不，其实多个域在同一个进程也没问题，只要满足一个聚合在一个事务内保护就没有问题。&lt;/li&gt;
&lt;li&gt;DDD的架构是稳定的？这么问的人一定没有理解什么叫做领域驱动。当领域发生演化的时候，系统的改变肯定不会小。比如电商系统里收货地址，可能一开始只是没有业务意义的值对象，但是后续有了管理，比如家庭，公司，然后反过来绘制画像，精准推荐……地址有了管理系统，那就不再是值对象了。但是DDD能保证在每期迭代中，需要做的工作都是最贴合当前需求的，并且当下一迭代到来的时候，做的改造工作量也是各方可以理解的。与之相反的所谓提前规划，通常会演化为把之后若干迭代的部分放到当前迭代，而且当未来没有按照预定的方式改变时，这些工作可能还是无效的。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;
&lt;p&gt;我只是针对Evans的入门小册子做了读书笔记，它不涉及具体的代码设计部分。其实DDD的关键在于让业务，产品都参与系统设计，因此怎么写代码，其实还在其次。有兴趣看怎么在代码里实践DDD，在此推荐&lt;a href=&quot;https://insights.thoughtworks.cn/ddd-business-design/&quot;&gt;使用DDD指导业务设计的一点思考&lt;/a&gt;这篇文章。&lt;/p&gt;
&lt;p&gt;欢迎大家在评论区分享和讨论关于DDD的知识。&lt;/p&gt;

    &lt;/div&gt;

    
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>95fac6d5c837abf091a119d81d5cfa42</guid>
<title>雪花算法，什么情况下发生 ID 冲突？</title>
<link>https://toutiao.io/k/a0w8z9h</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5986394557823129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vtZYwyYqLc5sNNibjJFUDb6QvJo5VdaIplQSbqGTo4BWPEVz9r0HffBp0NZrEGkBDkHeiaWfe6gZKrb6pka16cqA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;735&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分布式系统中，有一些需要使用全局唯一 ID 的场景，这种时候为了防止 ID 冲突可以使用 36 位的 UUID，但是 UUID 有一些缺点，首先他相对比较长，另外 UUID 一般是无序的&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些时候我们希望能使用一种简单些的 ID，并且希望 ID 能够按照时间有序生成&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是雪花算法&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Snowflake 中文的意思是雪花，所以常被称为雪花算法，是 Twitter 开源的分布式 ID 生成算法&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Twitter 雪花算法生成后是一个 64bit 的 long 型的数值，组成部分引入了时间戳，基本保持了自增&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;SnowFlake 算法的优点：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;高性能高可用：生成时不依赖于数据库，完全在内存中生成&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;高吞吐：每秒钟能生成数百万的自增 ID&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ID 自增：存入数据库中，索引效率高&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;SnowFlake 算法的缺点：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;依赖与系统时间的一致性，如果系统时间被回调，或者改变，可能会造成 ID 冲突或者重复&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;雪花算法组成&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;snowflake 结构如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3777555110220441&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vtZYwyYqLc5sNNibjJFUDb6QvJo5VdaIp1EysYHGIdvfFJRvWB7s9hxYmDmt1PZk7PtqVGqUrm4dqKOnSLQyEIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;998&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;包含四个组成部分&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不使用&lt;/span&gt;：1bit，最高位是符号位，0 表示正，1 表示负，固定为 0&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;时间戳&lt;/span&gt;：41bit，毫秒级的时间戳（41 位的长度可以使用 69 年）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;标识位&lt;/span&gt;：5bit 数据中心 ID，5bit 工作机器 ID，两个标识位组合起来最多可以支持部署 1024 个节点&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8043052837573386&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vtZYwyYqLc5sNNibjJFUDb6QvJo5VdaIpbOq39PeBzz8oRwQb7gOHTRAwA4q6scicAXCmKVfLn9zp6XXmyHnbTng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;511&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;序列号&lt;/span&gt;：12bit 递增序列号，表示节点毫秒内生成重复，通过序列号表示唯一，12bit 每毫秒可产生 4096 个 ID&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;通过序列号 1 毫秒可以产生 4096 个不重复 ID，则 1 秒可以生成 4096 * 1000 = 409w ID&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认的雪花算法是 64 bit，具体的长度可以自行配置。如果希望运行更久，&lt;span&gt;增加时间戳的位数&lt;/span&gt;；如果需要支持更多节点部署，&lt;span&gt;增加标识位长度&lt;/span&gt;；如果并发很高，&lt;span&gt;增加序列号位数&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结&lt;/span&gt;：雪花算法并不是一成不变的，可以根据系统内具体场景进行定制&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;雪花算法适用场景&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为雪花算法有序自增，保障了 MySQL 中 B+ Tree 索引结构插入高性能&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，日常业务使用中，雪花算法更多是被应用在数据库的主键 ID 和业务关联主键&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;雪花算法生成 ID 重复问题&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;假设&lt;/span&gt;：一个订单微服务，通过雪花算法生成 ID，共部署三个节点，标识位一致&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时有 200 并发，均匀散布三个节点，三个节点同一毫秒同一序列号下生成 ID，那么就会产生重复 ID&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上述假设场景，可以知道雪花算法生成 ID 冲突存在一定的前提条件&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;服务通过集群的方式部署，其中部分机器标识位一致&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;业务存在一定的并发量，没有并发量无法触发重复问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;生成 ID 的时机：同一毫秒下的序列号一致&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;标识位如何定义&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果能保证标识位不重复，那么雪花 ID 也不会重复&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面的案例，知道了 ID 重复的必要条件。如果要避免服务内产生重复的 ID，那么就需要从标识位上动文章&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先看看开源框架中使用雪花算法，如何定义标识位&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Mybatis-Plus v3.4.2 雪花算法实现类 Sequence，提供了两种构造方法：无参构造，自动生成 dataCenterId 和 workerId；有参构造，创建 Sequence 时明确指定标识位&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Hutool v5.7.9 参照了 Mybatis-Plus dataCenterId 和 workerId 生成方案，提供了默认实现&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一起看下 Sequence 的创建默认无参构造，如何生成 dataCenterId 和 workerId&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;getDataCenterId&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; maxDatacenterId)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; id = &lt;span&gt;1L&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] mac = NetUtil.getLocalHardwareAddress();&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; != mac) {&lt;br/&gt;        id = ((&lt;span&gt;0x000000FF&lt;/span&gt; &amp;amp; (&lt;span&gt;long&lt;/span&gt;) mac[mac.length - &lt;span&gt;2&lt;/span&gt;])&lt;br/&gt;                | (&lt;span&gt;0x0000FF00&lt;/span&gt; &amp;amp; (((&lt;span&gt;long&lt;/span&gt;) mac[mac.length - &lt;span&gt;1&lt;/span&gt;]) &amp;lt;&amp;lt; &lt;span&gt;8&lt;/span&gt;))) &amp;gt;&amp;gt; &lt;span&gt;6&lt;/span&gt;;&lt;br/&gt;        id = id % (maxDatacenterId + &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; id;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;入参 &lt;code&gt;maxDatacenterId&lt;/code&gt; 是一个固定值，代表数据中心 ID 最大值，默认值 31&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;为什么最大值要是 31？因为 5bit 的二进制最大是 11111，刚好是 31&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;获取 dataCenterId 时存在两种情况，一种是网络接口为空，默认取 1L；另一种不为空，通过 Mac 地址获取 dataCenterId&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以得知，dataCenterId 的取值与 Mac 地址有关&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来再看看 workerId&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;getWorkerId&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; datacenterId, &lt;span&gt;long&lt;/span&gt; maxWorkerId)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; StringBuilder mpid = &lt;span&gt;new&lt;/span&gt; StringBuilder();&lt;br/&gt;    mpid.append(datacenterId);&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        mpid.append(RuntimeUtil.getPid());&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (UtilException igonre) {&lt;br/&gt;        &lt;span&gt;//ignore&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; (mpid.toString().hashCode() &amp;amp; &lt;span&gt;0xffff&lt;/span&gt;) % (maxWorkerId + &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;入参 maxWorkderId 也是一个固定值，代表工作机器 ID 最大值，默认值 31；datacenterId 取自上述的 getDatacenterId 方法&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;name 变量值为 &lt;code&gt;PID@IP&lt;/code&gt;，所以 name 需要根据 &lt;code&gt;@&lt;/code&gt; 分割并获取下标 0，得到 PID&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 MAC + PID 的 hashcode 获取16个低位，进行运算，最终得到 workerId&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;分配标识位&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Mybatis-Plus 标识位的获取依赖 Mac 地址和进程 PID，虽然能做到尽量不重复，但仍有小几率&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标识位如何定义才能不重复？有两种方案：&lt;span&gt;预分配和动态分配&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;预分配&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应用上线前，统计当前服务的节点数，人工去申请标识位&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方案，没有代码开发量，在服务节点固定或者项目少可以使用，但是解决不了服务节点动态扩容性问题&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;动态分配&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过将标识位存放在 Redis、Zookeeper、MySQL 等中间件，在服务启动的时候去请求标识位，请求后标识位更新为下一个可用的&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过存放标识位，延伸出一个问题：雪花算法的 ID 是 &lt;span&gt;服务内唯一还是全局唯一&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以 Redis 举例，如果要做服务内唯一，存放标识位的 Redis 节点使用自己项目内的就可以；如果是全局唯一，所有使用雪花算法的应用，要用同一个 Redis 节点&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两者的区别仅是 &lt;span&gt;不同的服务间是否公用 Redis&lt;/span&gt;。如果没有全局唯一的需求，最好使 ID 服务内唯一，因为这样可以避免单点问题&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;服务的节点数超过 1024，则需要做额外的扩展；可以扩展 10 bit 标识位，或者选择开源分布式 ID 框架&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;动态分配实现方案&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 存储一个 Hash 结构 Key，包含两个键值对：dataCenterId 和 workerId&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6294200848656294&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vtZYwyYqLc5sNNibjJFUDb6QvJo5VdaIpVhHiajjNNTia5icZ6BFQibprdnicJz4kT36JH8aUlOzB4EyMhcFdY26oZJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;707&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在应用启动时，通过 Lua 脚本去 Redis 获取标识位。dataCenterId 和 workerId 的获取与自增在 Lua 脚本中完成，调用返回后就是可用的标示位&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0269179004037685&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vtZYwyYqLc5sNNibjJFUDb6QvJo5VdaIpceVOWZ1PlSktAdGrZXwLwAoQicKvnh8GugUNGhVBz9VBEggGrgmTmAw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;743&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体 Lua 脚本逻辑如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一个服务节点在获取时，Redis 可能是没有 snowflake_work_id_key 这个 Hash 的，应该先判断 Hash 是否存在，不存在初始化 Hash，dataCenterId、workerId 初始化为 0&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果 Hash 已存在，判断 dataCenterId、workerId 是否等于最大值 31，满足条件初始化 dataCenterId、workerId 设置为 0 返回&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;dataCenterId 和 workerId 的排列组合一共是 1024，在进行分配时，先分配 workerId&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;判断 workerId 是否 != 31，条件成立对 workerId 自增，并返回；如果 workerId = 31，自增 dataCenterId 并将 workerId 设置为 0&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;dataCenterId、workerId 是一直向下推进的，总体形成一个环状。通过 &lt;span&gt;Lua 脚本的原子性&lt;/span&gt;，保证 1024 节点下的雪花算法生成不重复。如果标识位等于 1024，则从头开始继续循环推进&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4019471488178025&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vtZYwyYqLc5sNNibjJFUDb6QvJo5VdaIp6oGnDk0no2dAmUu8RY5FJfh3r80GD1t9lSojGEYO1ZjYEDcTCiaZGvw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;719&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;开源分布式 ID 框架&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Leaf 和 Uid 都有实现雪花算法，Leaf 额外提供了号段模式生成 ID&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;美团 Leaf：&lt;code&gt;https://github.com/Meituan-Dianping/Leaf&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;百度 Uid：&lt;code&gt;https://github.com/baidu/uid-generator&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;雪花算法可以满足大部分场景，如无必要，&lt;span&gt;不建议引入开源方案增加系统复杂度&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;回顾总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文章通过图文并茂的方式帮助读者梳理了一遍什么是雪花算法，以及如何解决雪花算法生成 ID 冲突的问题&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于雪环算法生成 ID 冲突问题，文中给了一种方案：&lt;span&gt;分配标示位&lt;/span&gt;；通过分配雪花算法的组成标识位，来达到默认 1024 节点下 ID 生成唯一&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;可以去看看  Hutool 或者 Mybatis-Plus 雪花算法的具体实现，帮助大家更好的理解&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;雪花算法不是万能的，并不能适用于所有场景。&lt;span&gt;如果 ID 要求全局唯一并且服务节点超出 1024 节点&lt;/span&gt;，可以选择修改算法本身的组成，即扩展标识位，或者选择开源方案：LEAF、UID&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创作不易，文章看完有帮助，&lt;span&gt;点关注支持一下&lt;/span&gt;，祝好&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.8796296296296297&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vtZYwyYqLc5sNNibjJFUDb6QvJo5VdaIpj56g12DEfia8bv6ItrBnZAzA4dJqSr5icam9ODThuaAer3855DnITQ2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-recommend-type=&quot;list-title&quot; data-recommend-tid=&quot;8&quot; data-mpa-template=&quot;t&quot; data-mid=&quot;&quot; data-from=&quot;yb-recommend&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;往期推荐&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-title&quot; data-recomment-template-id=&quot;8&quot; data-recommend-article-id=&quot;2247495646_1&quot; data-recommend-article-time=&quot;1622287800&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/vtZYwyYqLc4KyjmdZajUiamuoz5xCKwvQy7ZtTxt01ZGfFVub19HRuboZ3CMeEAtaWbvsJsG9fbm5N60LVRQjSw/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;某厂面试：如何优雅使用 SPI 机制&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4NDU0Mjk5OQ==&amp;amp;mid=2247495646&amp;amp;idx=1&amp;amp;sn=0d1074ae3978f108e3379a327c8eb037&amp;amp;chksm=cfb434a6f8c3bdb0a7b57b69b6dd1a7d1aa109f108ac26f3dd3501c72de14548d665d241db8b#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4NDU0Mjk5OQ==&amp;amp;mid=2247495646&amp;amp;idx=1&amp;amp;sn=0d1074ae3978f108e3379a327c8eb037&amp;amp;chksm=cfb434a6f8c3bdb0a7b57b69b6dd1a7d1aa109f108ac26f3dd3501c72de14548d665d241db8b&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;section data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;某厂面试：如何优雅使用 SPI 机制&lt;/p&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-title&quot; data-recomment-template-id=&quot;8&quot; data-recommend-article-id=&quot;2247493904_1&quot; data-recommend-article-time=&quot;1613393168&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/vtZYwyYqLc52Km1XKoXKWIlV7dtxVrCODcPic8YxOb1OlUicD9lhnAichKbbPg8CcWtkPbvxFv12MqLrZerUXSicaw/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;摊牌了！策略模式在项目设计中用的最多&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4NDU0Mjk5OQ==&amp;amp;mid=2247493904&amp;amp;idx=1&amp;amp;sn=c1161a98dc4c37ce88e9dc6865ee5d12&amp;amp;chksm=cfb43268f8c3bb7eea6dc1eea4b56a0f99876b2fb47e1ad91fc18066eb754cbf7b06bbdab0a8#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4NDU0Mjk5OQ==&amp;amp;mid=2247493904&amp;amp;idx=1&amp;amp;sn=c1161a98dc4c37ce88e9dc6865ee5d12&amp;amp;chksm=cfb43268f8c3bb7eea6dc1eea4b56a0f99876b2fb47e1ad91fc18066eb754cbf7b06bbdab0a8&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;section data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;摊牌了！策略模式在项目设计中用的最多&lt;/p&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-title&quot; data-recomment-template-id=&quot;8&quot; data-recommend-article-id=&quot;2247493832_1&quot; data-recommend-article-time=&quot;1612955377&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/vtZYwyYqLc6eEIS4bnZibO73H8gDAKjWNguGibhoOrSGfhrDIoTSkd2PA2b4hiaIeK37UYuccm717mSfvqbzrx6sQ/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;春节期间，我用责任链模式重构了业务代码&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4NDU0Mjk5OQ==&amp;amp;mid=2247493832&amp;amp;idx=1&amp;amp;sn=011fdb3ee785dffe559ba39fd6c4993c&amp;amp;chksm=cfb433b0f8c3baa6df40568f87efef2f17a79361b81ceba2167f2de42e6fcf810ff3b92c42f4#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4NDU0Mjk5OQ==&amp;amp;mid=2247493832&amp;amp;idx=1&amp;amp;sn=011fdb3ee785dffe559ba39fd6c4993c&amp;amp;chksm=cfb433b0f8c3baa6df40568f87efef2f17a79361b81ceba2167f2de42e6fcf810ff3b92c42f4&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;section data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;春节期间，我用责任链模式重构了业务代码&lt;/p&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4265c16d42ab0948160b860c9f85b517</guid>
<title>唯一入驻华为开源优选库的国产网络框架 t-io</title>
<link>https://toutiao.io/k/hrqe23t</link>
<content:encoded>&lt;div&gt;&lt;div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>