<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>11a673d4ced52d18eb15cd30cfc20aff</guid>
<title>踩坑 MySQL 索引，看看你真的会用吗？</title>
<link>https://toutiao.io/k/zdnq3fy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h3 data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.33184855233853006&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;898&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgRgzIV2YTLYP1C9K6m6ZesXIGMic8cBk5es1ZicMDfULrExGEw49a51icWhlYkA1pXmib62xNNUDrMgXA/640?wx_fmt=png&quot;/&gt;&lt;/h3&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;关于 MySQL 索引，对于研发同学，尤其是后端研发同学，一定不会陌生。我们工作中经常会用到 MySQL 数据库，就肯定会经常用到性能优化方面的设计和考量，常常用涉及到 MySQL 索引。但是关于 MySQL 索引，你真的用对了么？&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;对了，在开始正式知识点讲解之前，还需要来个不那么正式的自我介绍吧，哈哈哈~&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-type=&quot;blockquote&quot;&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;我多年后端研发经验，“混迹”于多个互联网大厂，专注软件架构技术研究学习，希望能够持续发挥自身多余的热量，将自己工作中的问题和技术总结输出，分享影响到更多的人。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;大家看我的头像图片像是一个陀螺，其实是寓意螺旋式上升，让技术和自我能够不断精进。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z2bVaFK6CgT0JL4BVF6MLv1jGDCTJGyKlCoSbwlXRVYjPkJUqdylM7lCA7lB5Ul5GdibuHNqW6Aib06U65RuG9RA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;512&quot;/&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;接下来，我会通过一个自己工作中真实遇到一个 MySQL 查询应用问题为背景，来逐步剖析分析，见招拆招，以科学理论为依据，分析探究，希望能带大家一起明确索引应用原则，最终将问题探究清楚。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-type=&quot;blockquote&quot;&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;主要原则：问题驱动；&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;主要流程：应用现象-问题分析-疑点跟进-层层探究-结论明晰。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;那接下来，让我们利用约 15min 的时间，让自由的思路飞一会儿吧！&lt;/span&gt;&lt;/p&gt;&lt;h2 data-id=&quot;heading0&quot; data-type=&quot;heading&quot;&gt;问题介绍&lt;/h2&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;我们存在这样一张数据表（cities），记录了城市 code 和名称一些基本数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.18781725888324874&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgT0JL4BVF6MLv1jGDCTJGyKy44FdxmFKIMxu6ibKTIX4ribNbgG66lpWjp0dec3hU6kT5oHjEFQSJDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1576&quot;/&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;有一天，我在执行如下 SQL 的时候（一个是指定了字段 id，另一个未指定查询字段，而是利用了 *），发现两种情况下查询执行结果竟然不一样！&lt;/span&gt;&lt;/p&gt;&lt;pre data-origin=&quot;pm_code_preview&quot; lang=&quot;text&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Case1：select id from cities limit 1;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;code data-type=&quot;codeline&quot;&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;查询结果：&lt;/span&gt;&lt;/p&gt;&lt;p data-align-center=&quot;&quot; data-type=&quot;paragraph&quot;&gt;&lt;span&gt;id：2&lt;/span&gt;&lt;/p&gt;&lt;pre data-origin=&quot;pm_code_preview&quot; lang=&quot;text&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Case2：select * from cities limit 1;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;查询结果：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.09692671394799054&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgT0JL4BVF6MLv1jGDCTJGyKsZ9gGUDIvMehm0vaauWpeLEf8b8BrOMuGLhf57ov7QgmaDicEP76MdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;423&quot;/&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;这事成功的引起了我的注意，那就继续搞起吧！&lt;/span&gt;&lt;/p&gt;&lt;h2 data-id=&quot;heading1&quot; data-type=&quot;heading&quot;&gt;问题分析&lt;/h2&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;按照之前的工作经验告诉我，遇事不要慌，先 explain 解释执行看看吧。&lt;/span&gt;&lt;/p&gt;&lt;pre data-origin=&quot;pm_code_preview&quot; lang=&quot;text&quot;&gt;&lt;code data-type=&quot;codeline&quot;/&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Case1：explain select id from cities limit 1;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-origin=&quot;pm_code_preview&quot; lang=&quot;text&quot;&gt;&lt;span&gt;执行结果：&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.06875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgT0JL4BVF6MLv1jGDCTJGyK9mIv6J8bU66oKH5L4eZDiaoAlpScKyawkiaiaE7N00V4mjISgMoAJa20A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;pre data-origin=&quot;pm_code_preview&quot; lang=&quot;text&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Case2：explain select * from cities limit 1;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;执行结果：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.06875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgT0JL4BVF6MLv1jGDCTJGyK3gFmqoDEzyibqZj5IoiamcrnDzaa9qibfC177njqDjwUAMdlNWhrngKLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;经过上面的执行计划查看，发现 Case1 中的 SQL 应用到了一个名为&#x27;uniq_city_code&#x27;的索引，而第二个走了全表扫描查询。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span data-type=&quot;strong&quot;&gt;问题初步结论：&lt;/span&gt;也就是说两个 SQL 由于查询字段的不同，导致 MySQL 在具体执行时候选取了不同的索引策略，从而导致了查询结果的不同。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-id=&quot;heading2&quot; data-type=&quot;heading&quot;&gt;疑点跟进&lt;/h2&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;其实经过上面的分析，其实还存在几个疑问点：&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;可能细心的同学也发现了，还有就是 Case2 查询计划中 Extra 字段为 Using index，说明满足了索引覆盖（索引中包含了所有满足查询条件的数据，无需从表中查询），可是 &lt;span data-type=&quot;strong&quot;&gt;uniq_city_code&lt;/span&gt; 这个索引中并没有 id 这个字段，为何能以覆盖索引的方式执行？&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;带着上面的一脸疑问，我们先来一起回顾下 MySQL 引擎索引的实现方式吧。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;如图所示，为 Innodb、以及参考对比的 MyISAM 引擎的索引实现图例。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;1、InnoDB 聚簇索引和辅助索引（非聚簇索引）的对比图示&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.1773700305810397&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgT0JL4BVF6MLv1jGDCTJGyKJ4736GuE6U2kWUYq1ibxRuMz9kZ5rVANRZWaL5Rx1cFFIGQ0URL91Iw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;654&quot;/&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;/p&gt;&lt;blockquote data-type=&quot;blockquote&quot;&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;同时便于大家理解，我标记黄线、红线分别代表两种引擎方式的数据查询路径，大家可以参照图例，体会对比一下。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;InnoDB 按聚簇索引的形式存储数据，所以它的数据布局有着很大的不同。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;1）聚簇索引中的每个叶子节点包含 primary key 的值，事务 ID 和回滚指针(rollback pointer)——用于事务和 MVCC，和余下的列(如 col2)。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;2）相对于 MyISAM，辅助索引与聚簇索引有很大的不同。InnoDB 的二级索引的叶子包含 primary key 的值，而不是行指针(row pointers)，这减小了移动数据或者数据页面分裂时维护二级索引的开销，因为 InnoDB 不需要更新索引的行指针。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;2、MyISAM 引擎方式索引图示&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.813953488372093&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgT0JL4BVF6MLv1jGDCTJGyKlU9CfZWkKBLibjkSS64brF9Q3sbIrZP6JTaFVvrohZGZga8DYdILx0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;774&quot;/&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;MyISAM 不支持聚簇索引，索引中每一个叶子节点仅仅包含行号(row number)，且叶子节点按照 col1 的顺序存储。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;在 MyISAM 中，primary key 和其它索引没有什么区别。Primary key 仅仅只是一个叫做 PRIMARY 的唯一，非空的索引而已。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;好了，我们还是回到问题本身。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;我们其实可以得出这样一个&lt;span data-type=&quot;strong&quot;&gt;初步结论：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre data-origin=&quot;pm_code_preview&quot; lang=&quot;text&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Case1：select id from cities limit 1;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;因为 uniq_city_code 索引中包含 id 字段，此查询可以从 uniq_city_code 索引中直接取得数据，所以优化器选择走 uniq_city_code 索引；&lt;/span&gt;&lt;/p&gt;&lt;pre data-origin=&quot;pm_code_preview&quot; lang=&quot;text&quot;&gt;&lt;code data-type=&quot;codeline&quot;/&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Case2：select * from cities limit 1;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;此查询中 select * 选取了在 uniq_city_code 索引中不包含的列，所以无法使用 uniq_city_code 这个索引。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;为了验证一下我们刚刚得到的初步结论，我们来利用 Case3 验证一下。&lt;/span&gt;&lt;/p&gt;&lt;pre data-origin=&quot;pm_code_preview&quot; lang=&quot;text&quot;&gt;&lt;code data-type=&quot;codeline&quot;/&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Case3：select id, city_code from cities limit 1;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;执行结果：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.06269113149847094&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgT0JL4BVF6MLv1jGDCTJGyKw3HvNawwG6rk3b8ibbrASu8yz4g3gywTmyhOgeiciaFDFxUNfMdF3VXGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;654&quot;/&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;按照上述的理论依据，Case1（查询 id）与 Case3（查询 id+city_code）执行应用的查询计划应该是一致的。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;通过验证实验我们可以确定一个结论：&lt;span data-type=&quot;strong&quot;&gt;Case1 的查询确实存在索引覆盖情况。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-id=&quot;heading3&quot; data-type=&quot;heading&quot;&gt;官方辅证&lt;/h2&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;我们再继续追问一下：&lt;span data-name=&quot;orange&quot; data-type=&quot;color&quot;&gt;为什么要用到索引覆盖呢？不用可不可以呢？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;我们先来看看 MySQL 官方的解释...&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.2141732283464567&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgT0JL4BVF6MLv1jGDCTJGyKFCHUVoZ834tp7LJHeWW1gdZgKw2VMtBnsyNqx1TO6K9RqM0EI4Ksew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;635&quot;/&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;其实说了这么多，本质就是最后一句，&lt;span data-type=&quot;strong&quot;&gt;这样做可以使查询更快！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;好了，大家可以一起来思考下这个问题：&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span data-name=&quot;orange&quot; data-type=&quot;color&quot;&gt;“&lt;/span&gt;&lt;em data-type=&quot;italic&quot;&gt;&lt;span data-name=&quot;orange&quot; data-type=&quot;color&quot;&gt;既然主键索引包含所有数据列，那么使用主键索引一样可以做到索引覆盖，为什么优化器不选择使用主键索引？”&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;......&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;其实这个问题，就是典型的 MySQL 索引选取原则。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;MySQL 在做全表扫描时，MySQL 会调用 find_shortest_key() 来选取最短的索引来扫描。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;关于 find_shortest_key()函数的解释，我们来看下官方解释，如下所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.45498783454987834&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgT0JL4BVF6MLv1jGDCTJGyKjqzhbjhPZibsbtiayp2sNb6ribZAgB0iaqb3dt4EFD0mvv0fR48U7cqYGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;411&quot;/&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;所以，上面大家一起思考的这个问题，答案就是：&lt;span data-type=&quot;strong&quot;&gt;索引长度不同，有多个可选索引时，MYSQL 会优先选择较短的索引。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;到现在，那我们可以对整个问题做个总结了：&lt;span data-type=&quot;strong&quot;&gt;因为辅助索引一定是主键索引的子集，从节约 IO 的角度，在全表扫描时优先选择辅助索引。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-id=&quot;heading4&quot; data-type=&quot;heading&quot;&gt;总结&lt;/h2&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;好了，最后我们一起来对整个分享做下总结吧。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;1）首先我们遇到一个查询问题，由于查询字段的不同导致我们的查询结果数据存在差异；&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;2）我们对问题进行追究，发现根据 select 的字段不同，MySQL 选取的索引策略不同，即结果数据不同；&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;3）对于是否存在索引覆盖问题，我们进行了 Case3 的验证，确认了存在索引覆盖的问题；&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;4）对于 MySQL 为什么会存在这样的索引选取原则，我们最终发现是辅助索引一定是主键索引的子集，从节约 IO 的角度，在&lt;span data-type=&quot;strong&quot;&gt;全表扫描&lt;/span&gt;时优先选择辅助索引。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;重点提炼：&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;不同引擎对于查询实现方式的不同、索引覆盖、MySQL 索引选取原则。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;不同引擎对于查询实现方式的不同、索引覆盖、MySQL 索引选取原则。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;不同引擎对于查询实现方式的不同、索引覆盖、MySQL 索引选取原则。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;重要的问题说三遍，哈哈哈~&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;其实踩坑，也是一种成长！&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;其实面对任何问题，都不要一上来就急于给出结论，可以尝试多做些深入分析，了解本质问题之后再考虑解决办法进行解决，希望大家能够掌握问题分析以及解决的能力，去触类旁通，而不是仅仅了解一招一式，盲目照搬。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.46449704142011833&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z2bVaFK6CgT0JL4BVF6MLv1jGDCTJGyKmbwUws3m4pYKGdadIdRQAXMFfNMZroxaDDIuRyvVgNzCsuxx5aNVoA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;676&quot;/&gt;&lt;/p&gt;&lt;p data-pm-slice=&quot;1 1 []&quot;&gt;&lt;/p&gt;&lt;p data-pm-slice=&quot;1 1 []&quot;&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;作者：架构精进之路，专注软件架构研究，技术学习与个人成长，关注并私信我回复“01”，送你一份程序员成长进阶大礼包，欢迎勾搭。&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;往期热文推荐：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;98311&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5555555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgTqLjdQBs7fV8zqHRaQhA2ibia13fFn6ibS5qr5PpmZoxd8nlhAyJu7d1CjLicAruicOEb7uxibEGM476xg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;87502&quot;&gt;&lt;p&gt;&lt;span&gt;「技术架构精进」专注架构研究，技术分享&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Thanks for reading!&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>88808f820074c4537c83b9929f3701a2</guid>
<title>Chrome 插件,实用且堪称神器</title>
<link>https://toutiao.io/k/kmh5ibc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3740234375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/sriaewibCqS1SdKCktwibu2xFx7KONo8GMbcYsOZ7OjWQz73Z1RbSUToiaB8BakvciceibyPkT9qzhV4uIfWakyDXU6Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1024&quot; title=&quot;&quot;/&gt;&lt;figcaption&gt;Madison龙少&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; 相信很多人都在使用&lt;code&gt;Chrome 浏览器&lt;/code&gt;，其流畅的浏览体验得到了不少用户的偏爱，但流畅只是一方面， Chrome 最大的优势还是其支持众多&lt;code&gt;强大好用的扩展程序（Extensions）&lt;/code&gt;最近为了更好的利用谷歌浏览器，我整理了一些常用的谷歌插件，分享给大家。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; 闲话不多说，直接上推荐的插件，文章的末尾附有插件的安装教程！！！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;通用类插件&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、 &lt;code&gt;OneTab&lt;/code&gt;：将无数 Tab 合并在一个页面&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; 很多时候我们在一个窗口打开太多的tab，每一个tab太小不容易管理，这时候使用OneTab能够把所有tab收起放在一个页面，点击就可打开该tab，非常方便。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Chrome商店地址:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://chrome.google.com/webstore/detail/onetab/chphlpgkkbolifaimnlloiipkdnihall&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.26714801444043323&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sriaewibCqS1SdKCktwibu2xFx7KONo8GMbKHhSxtkJCibqwZyxTepia0NQ1kQ40iahGGhKh9ll2XU6QtKXX012YOA3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;figcaption&gt;&quot;Madison龙少&quot;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、 &lt;code&gt;Momentum&lt;/code&gt;：美到爆表的新标签页&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; 受够了新建页面时候的空白页的话可以试试，&lt;code&gt;Momentum每天都会提供一张高清大图&lt;/code&gt;，都很好看。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Chrome商店地址:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://chrome.google.com/webstore/detail/momentum/laookkfknpbbblfpciffpaejjkokdgca&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5072202166064982&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sriaewibCqS1SdKCktwibu2xFx7KONo8GMb0Wib1HmrMzdKDiaM0CmuwlWhW9gASdB04SfNUt5PeWicmXPqwYFQQsibEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;figcaption&gt;&quot;Madison龙少&quot;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、&lt;code&gt;markdown here&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; 超好用的一款插件，强烈推荐！！有个它再也不用担心编辑器不支持markdown语法了，写好以后直接一键转换。而且也是一个跨平台神器，比如我们可以把简书写好的文章（带md语法）直接复制到微信公众号，然后一键转换，格式几乎无变化！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Chrome商店地址:https://markdown-here.com/&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4602888086642599&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sriaewibCqS1SdKCktwibu2xFx7KONo8GMb2IiaNx8uZw5YOiaDxzZVnk69YtZaIC7TGWn2fhdboHILjKia7fUDtP9sA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;figcaption&gt;&quot;Madison龙少&quot;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、 &lt;code&gt;Adblock Plus&lt;/code&gt;：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; &lt;code&gt;免除广告困扰&lt;/code&gt;只要是使用 Chrome 的人都应该安装的一款扩展应用，可以帮助你屏蔽几乎大部分网页广告，如果存在漏网之鱼，还可以手动添加到屏蔽列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Chrome商店地址:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://chrome.google.com/webstore/detail/adblock-plus-free-ad-bloc/cfhdojbkjhnklbpkdaibdccddilifddb?utm_source=chrome-app-launcher-info-dialog&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.628158844765343&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sriaewibCqS1SdKCktwibu2xFx7KONo8GMbl04iaLDDUHSRnQpc5xh5lupf73jWtvIKkvHvFtPiaLsqWY0m9hkLBzKQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;figcaption&gt;&quot;Madison龙少&quot;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5、&lt;code&gt;LastPass&lt;/code&gt;：密码管理软件&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; &lt;code&gt;LastPass&lt;/code&gt;，全球知名在线密码管理工具之一，采用军事级加密算法，支持自动填充网站用户名和密码，与朋友分享登录信息等实用功能，且在全平台同步免费，无需订阅 Premium，即可在手机、网页、电脑端同步你的所有 LastPass 信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Chrome商店地址:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://chrome.google.com/webstore/detail/lastpass-free-password-ma/hdokiejnpimakedhajhdlcegeplioahd/related&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5126353790613718&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sriaewibCqS1SdKCktwibu2xFx7KONo8GMbvoIOL5ibs6xEOO6iaicRc6wk3wrib9jzP9rL7qvtQzZqTbg5Nrv1CCffpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;figcaption&gt;&quot;Madison龙少&quot;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;6、 &lt;code&gt;关灯看视频&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; 有时候网速太差，全屏以后分辨率很低，可以试试这个，可以让周围页面变暗从而达到最好的视觉效果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Chrome商店地址:https://www.turnoffthelights.com/zh-cn/&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.30505415162454874&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sriaewibCqS1SdKCktwibu2xFx7KONo8GMbicqCOP1l6tn4GibbEPNdzjnotovUFbFJjiad6OVPgICLeSfxiaYh4LibV7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;figcaption&gt;&quot;Madison龙少&quot;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;7、&lt;code&gt;二维码(QR码)生成器&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; 在线的二维码生成器。可以把当前的网页直接生成二维码，进行编辑。还可以把文字生成二维码，这个很重要！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Chrome商店地址:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://chrome.google.com/webstore/detail/anything-to-qrcode/calkaljlpglgogjfcidhlmmlgjnpmnmf&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.2976744186046512&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sriaewibCqS1SdKCktwibu2xFx7KONo8GMbX5zCNEDfUxyvLb4owhbV6aAQeWWnQNYgrIspBgKSyOUybT99v673Gw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;215&quot;/&gt;&lt;figcaption&gt;&quot;Madison龙少&quot;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;8、&lt;code&gt;购物党&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; 在线的比价工具，网购的时候可以看价格历史记录，以及各大网站的价格对比，也有查快递的快捷方式。经常剁手的童鞋要注意了~~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Chrome商店地址:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://chrome.google.com/webstore/detail/%E8%B4%AD%E7%89%A9%E5%85%9A%E8%87%AA%E5%8A%A8%E6%AF%94%E4%BB%B7%E5%B7%A5%E5%85%B7/jgphnjokjhjlcnnajmfjlacjnjkhleah&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.138783269961977&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sriaewibCqS1SdKCktwibu2xFx7KONo8GMbGqe1PxKWDZauAOY0w2vicnO1GqOLIAZUDDPKicOCUib3KgGZRwZ3Fp6iaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;526&quot;/&gt;&lt;figcaption&gt;&quot;Madison龙少&quot;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;9、&lt;code&gt;Infinity&lt;/code&gt;：功能强大的新建标签页扩展&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; 功能强大的新建标签页扩展！做的界面很美，每日壁纸质量也很高！有同步笔记、代办事项等，同时，喜欢它的网页图标，提供了很多常用网站的图标，自定义书签时很好看~唯一的缺点，就是感觉启动比较慢~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Chrome商店地址:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://chrome.google.com/webstore/detail/infinity-new-tab-producti/dbfmnekepjoapopniengjbcpnbljalfg&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;10、&lt;code&gt;crxMouse Chrome Gestures&lt;/code&gt; 对于国产浏览器自带鼠标手势的功能，真觉得很方便！这款扩展也是必装啊！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Chrome商店地址:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://chrome.google.com/webstore/detail/crxmouse-chrome-gestures/jlgkpaicikihijadgifklkbpdajbkhjo?utm_source=chrome-app-launcher-info-dialog&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;11、 &lt;code&gt;Imagus&lt;/code&gt; 图片放大镜的功能！在体验了360浏览器、猎豹浏览器之后，特地去找的扩展！微博党的利器！这个不管能鼠标悬停放大图片，同时，对链接等也有预览。提供很多功能选项进行设置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Chrome商店地址:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://chrome.google.com/webstore/detail/imagus/immpkjjlgappgfkkfieppnmlhakdmaab?utm_source=chrome-app-launcher-info-dialog&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.48375451263537905&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sriaewibCqS1SdKCktwibu2xFx7KONo8GMbmC83JQc6BbkfH3qYAo9eicFlnhOMXB7sPXibWZdnglebawcmxDzicTNog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;figcaption&gt;&quot;Madison龙少&quot;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;12、&lt;code&gt;JSON Viewer&lt;/code&gt; &lt;code&gt;JSONView&lt;/code&gt; 是一个方便查看 Json 结构的插件，展开，折叠，可以非常方便的查看接口返回数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Chrome商店地址:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://chrome.google.com/webstore/detail/jsonviewer/gbmdgpbipfallnflgajpaliibnhdgobh/related&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5144404332129964&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sriaewibCqS1SdKCktwibu2xFx7KONo8GMbS12zgJFvke6iajdMq72LmYQtm6TlY5s2EyzU4Cmqu6MhdZeFfkEahhQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;figcaption&gt;&quot;Madison龙少&quot;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;13、 &lt;code&gt;Postman&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; 相信开发者朋友一定知道这款插件，这是一款强大的 API &amp;amp; HTTP 请求调试工具，它不仅可以调试简单的 HTML、CSS 以及脚本等简单的网页基本信息，这款 Chrome 插件甚至还能发送几乎所有的 HTTP 请求，可谓是 Web 开发者的一大利器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;chrome商店地址:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.49097472924187724&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sriaewibCqS1SdKCktwibu2xFx7KONo8GMbM6zibeskrvM3d96ibUdsoibxUTpPloMhhACH7qHqgicT41cYWhrJLTraKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;figcaption&gt;&quot;Madison龙少&quot;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;14、&lt;code&gt;Octotree&lt;/code&gt; github上查看代码的时候总是一层层进入再出来，有点麻烦，没关系，有Octotree。安装Octotree之后，浏览托管在Github上的项目，可看到左侧的树形结构，更方便查看代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;chrome商店地址:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4711191335740072&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sriaewibCqS1SdKCktwibu2xFx7KONo8GMbbCvqoyrNz9a60icRGRDJYm1jMZC18NHk6AcQNvJXdKXeaUrykQKMzDg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;figcaption&gt;&quot;Madison龙少&quot;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;15、&lt;code&gt;Tampermonkey&lt;/code&gt; 俗称‘油猴子’，是一款功能非常强大的插件，他包含：方便的脚本管理、脚本概览、设置多样性、脚本自动更新、安全、兼容性、Chrome 同步、CodeMirror 编辑器、JSHint 语法检查、快速开发、卸载等功能。其官方描述只一句 The world’s most popular userscript manager。足见其优秀。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Chrome商店地址:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo?utm_campaign=en&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.37364620938628157&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sriaewibCqS1SdKCktwibu2xFx7KONo8GMbLaibAxP9ibiaW1jRtoiaY7cq3X8mZwW2rcLG3Hib553MXdzwxzYaiafweBiaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;figcaption&gt;&quot;Madison龙少&quot;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;16、 Code Cola
 &lt;code&gt;Code Cola&lt;/code&gt;是一个可视化编辑在线页面css样式的chrome插件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Chrome商店地址:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://chrome.google.com/webstore/detail/code-cola/lomkpheldlbkkfiifcbfifipaofnmnkn&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4891696750902527&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sriaewibCqS1SdKCktwibu2xFx7KONo8GMbRcnaS7EZ1dCKse5Tjh2libMYp9W35kH5QvY0ZBKq7ZnyGdGiaoRbGEjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;figcaption&gt;&quot;Madison龙少&quot;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;17、&lt;code&gt;WEB前端助手&lt;/code&gt; FE助手：包括字符串编解码、图片base64编码、代码压缩、美化、JSON格式化、正则表达式、时间转换工具、二维码生成器、编码规范检测、页面性能检测、栅格检测、JS运行效率分析等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Chrome商店地址:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://chrome.google.com/webstore/detail/fehelper%E5%89%8D%E7%AB%AF%E5%8A%A9%E6%89%8B/pkgccpejnmalmdinmhkkfafefagiiiad&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5812274368231047&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sriaewibCqS1SdKCktwibu2xFx7KONo8GMbmySyYUQxmiaic4ZdlD2clp9ZTkYpyYal6Mc6pjRIoO9ChZGQANrR8vaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;figcaption&gt;&quot;Madison龙少&quot;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;插件安装&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;离线安装谷歌插件方法也很简单&lt;/code&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;打开谷歌浏览器输入：chrome://extensions/&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;打钩开发者模式&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.05426765015806112&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sriaewibCqS1SdKCktwibu2xFx7KONo8GMbqbFmZfWogu4DicnseQ7iaC8dXzqYhyl68LB6aw6p7RJ2ib9PCnWBF6A1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1898&quot;/&gt;&lt;figcaption&gt;&quot;Madison龙少&quot;&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;考虑到大部分朋友没有不能访问谷歌商店，这边给出两个方法&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;谷歌访问助手访问谷歌商店&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;离线下载全部插件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;微信搜索：Madison龙少，分别回复：&lt;code&gt;google访问助手&lt;/code&gt;、&lt;code&gt;chrome插件&lt;/code&gt; 获取资源。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;结束语&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;感谢阅读小生文章。祝大家早日富可敌国，实现财富自由。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整理不易，好几个小时才整理完，
后面如果有新的好玩的插件再补充进来， &lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你觉得有用的话&lt;code&gt;写文不易&lt;/code&gt;,一定要&lt;code&gt;点赞、评论、收藏哦&lt;/code&gt;,&lt;code&gt;感谢感谢感谢!!!&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>dbbbfe4a0cbe8fd807b338cc84d8ca22</guid>
<title>探索 Table 组件虚拟化</title>
<link>https://toutiao.io/k/sothdok</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;列表及表格的虚拟优化不是个新鲜的课题，近期，团队发现：业界对于 table 虚拟化竟然没有一个相对一劳永逸的解决方案。这是为什么？又该如何解决？在本文中，我们会循序渐进的介绍在 React+AntDesign 技术栈下，团队内部对 Table 组件虚拟化的不同实践思路，分析可能遇到的难点问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;虚拟化问题阐述&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在列表页、瀑布流、Select 组件中，我们都有可能遇到渲染大数量级列表的场景。在过去，我们总结了一套卓有成效的办法：对于列表，我们通过计算，保证在滚动视窗时，每次只渲染部分元素。这样既减少了首屏压力，也保证长时间加载也不会有更多的性能负担，可以满足上述大部分场景的高性能优化需求。具体做法上，我们利用已知的固定行高和滚动偏移量，计算出滚动到的表格行索引，只渲染出有限视窗内所需要的元素，，并对列表进行相应设置，简述过程如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;计算当前可见区域起始数据的 startIndex&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;计算当前可见区域结束数据的 endIndex&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;计算当前可见区域的数据，并渲染到页面中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;计算 startIndex 对应的数据在整个列表中的偏移位置 startOffset，并设置到列表上&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;计算 endIndex 对应的数据相对于可滚动区域最底部的偏移位置 endOffset，并设置到列表上&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.1092896174863387&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9egR3Y3zQbLecpKVOzHOfJ4D6q3XBzGO8o0VXy1dzwwhVu4fxpd3tsvC5RF4xE8ibGhrBib7AqUm1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;549&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一方案是广泛被大多数开发人员探讨的。我推荐参考&lt;span&gt;浅说虚拟列表的实现原理&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;，他对问题的思路，实现，均有比较详尽的描述。如今，我们的场景来到了 AntDesign 的 Table 组件。我们面对十分类似的问题：业务当中，&lt;strong&gt;Table &lt;/strong&gt;涉及&lt;strong&gt;1000+行 &lt;/strong&gt;&amp;amp; &lt;strong&gt;100+列&lt;/strong&gt;数量级别的渲染时，由于单元格内也具有一定的复杂逻辑，因此页面渲染时长往往需要卡顿 &lt;strong&gt;5000ms &lt;/strong&gt;前后的时间。这显然是不能够接受的。实际上，从长列表到 Table 组件，我们的列表无非是从一维轴线上升到了二维平面。因此，所谓表格虚拟化，无非就是希望表格可以实现：在兼容 &lt;strong&gt;Table&lt;/strong&gt; 现有功能的情况下，实现表格只渲染视窗平面内容，对于视窗外的行、列予以隐藏。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;整理现状&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;AntDesign&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们内部的 React + umi + AntDesign 技术栈是目前前端界较为常见的一种架构基础。AntD 作为业界 react 常用组件库，它提供的 Table 组件，能够方便的帮我们解决诸多常见需求，包括并不仅限于：行选择、行展开、行筛选、数据分页、列固定... 目前 AntDesign 有 AntD@3.26 和 AntD@4.11 两大版本，后者经过一定的重构和优化，是官方推荐的最新内容。AntDesign3 文档中已经删除了对于虚拟化支持的 demo（实际也可以使用），而在 AntDesign4 文档中，能看到官方推荐用户以接入 react-window 的方式解决虚拟化表格问题。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4941360437842064&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9egR3Y3zQbLecpKVOzHOfJ2ptbp61ibickibAqVaGd48SiaxYOcNFV5zx0zrF1ociabBalYrmIrgGMiaSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1279&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从官方的 Demo 来看，AntD 提供了一个 components 属性，通过传入一个对象，在其 body 属性中给到一个 ReactWindow 提供的虚拟化组件，以实现需求&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; ...&lt;br/&gt; &lt;span&gt;// VariableSizeGrid is a component provided by react-window&lt;/span&gt;&lt;br/&gt; &lt;span&gt;const&lt;/span&gt; renderVirtualList = &lt;span&gt;(&lt;span&gt;rawData, { scrollbarSize, ref, onScroll }&lt;/span&gt;)=&amp;gt;&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;VariableSizeGrid&lt;/span&gt;&lt;br/&gt;       {&lt;span&gt;...props&lt;/span&gt;}&lt;br/&gt;     /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; ...&lt;br/&gt; &amp;lt;Table&lt;br/&gt;    {...props}&lt;br/&gt;    className=&lt;span&gt;&quot;virtual-table&quot;&lt;/span&gt;&lt;br/&gt;    columns={mergedColumns}&lt;br/&gt;    pagination={&lt;span&gt;false&lt;/span&gt;}&lt;br/&gt;    components={{&lt;br/&gt;      // overwrite the body set by AntD&lt;br/&gt;      body: renderVirtualList,&lt;br/&gt;    }}&lt;br/&gt;  /&amp;gt;&lt;br/&gt;  ...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;ReactWindow&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;react-window 是一个广受欢迎的用于解决表格虚拟化问题的开源代码库，它产出了不同特性的虚拟化组件，以便用户聚焦不同虚拟场景的问题解决。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;react-window 的原理并不复杂，主要就是本文在虚拟化问题阐述中对于虚拟化要求内容的实现。主要是通过监控 onScroll，动态调整表格横轴偏移量，节选适当数量的部分数据，进行可视区内容渲染。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;他的前身是 react-virtualized。经过了重构和升级，作者对 table 和 list 两种不同的场景做了更好的抽象，通过重用共通部分的逻辑，实现了更好的性能，代码打包大小也减少到了原先的 20%。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;接入时遇到的问题&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看上去，AntD 已经给出了一套虚拟化方案。但稍稍深入调查不难发现，在 Github 的 Issue 中，对于官方推荐方案，用户反馈则不甚理想。比如：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在问题&lt;span&gt;#21022&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;中提出，使用 AntD3 后，展开、多选等功能点缺失。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在问题&lt;span&gt;#20339&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;中提出，使用 AntD4 后，大多数表格功能点都存在缺失。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对上述问题，官方均回复以用户自行解决，因此：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照 &lt;strong&gt;AntD&lt;/strong&gt; 文档使用虚拟化进行配置，虽然可以一定程度实现虚拟化，但会引起多处表格功能缺失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是目前我们主要亟待解决的问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;rc-table&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于官方没有给出很好的虚拟化方案，我们只好深入了解 AntD 内部的架构，寻找问题的切入点。经阅读代码可以了解，在 4.11 的 AntD/Table 代码架构简述如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7363083164300203&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9egR3Y3zQbLecpKVOzHOfJLNrWMoBTl2hqBko8yOdwtjMDcXkRkKIthcaTUYtdkWdlEZrnnJYYYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;986&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在 AntDesign/Table 中：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;初始化表格大小和行列内容&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;初步整理事件和数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;排序、分页、过滤等功能对 data 和 column 的计算逻辑&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用 rc-table 依赖&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在 rc-table 中：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;注册各类行列单元格事件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;完成各种样式需求，如列固定，行展开&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;完成渲染&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此，我们可以了解到，AntD 架构本身其实已经对表格逻辑进行了一定程度的划分，与 data 数据的顺序及内容无关的逻辑，已经被单独抽象到了 rc-table 这个库中。大致上我们可以理解为下图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4080604534005038&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9egR3Y3zQbLecpKVOzHOfJuHuR82wuHZTEnmRw4KDffuEub3PcZS4CyicvdNpiczXor2IxzAcENx8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;794&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们也必须要想清楚：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这三层逻辑，我们分别对他们做保留，改造，还是替换？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如保留，如何解决引入虚拟化逻辑后，虚拟化逻辑对现有框架造成的影响？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如不保留，新的框架如何选择？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;组内方案陈列&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目组内对于 table 的虚拟化工作产生了多种不同思路：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;方案 1：基于 rc-table 不依赖 react-window 和 AntD 实现虚拟化&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在不同业务中，我们需要的表格组件功能点并不一致，极端场景下，我们可能只需要使用少量 AntD 的 Feature，且定制化较高。因此我们可以考虑放弃使用 AntD，直接使用 rc-table 并做一定改造。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;实现方式：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;fork 一份稳定版本 rc-table 放入代码库内&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;按照虚拟化原理对 rc-table 完成必要改造&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自己实现排序、选择、列固定等上层功能点&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.9362416107382551&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9egR3Y3zQbLecpKVOzHOfJXIichXoXUz3HDp4T1HTicibfW4wdqFPWbgibBBh1bgFia4z3c5Y3RhgeXhg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;596&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;方案优劣：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;丢失了 AntD 的功能基础。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不再需要自己实现基础的表格呈现，这部分有 rc-table 完成，我们只需要针对虚拟化对滚动事件做少量改造。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;外部功能 feature 方便自定制。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;优点：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;缺点：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;方案 2：AntD 中截取显示数据，手动销毁表格外 dom，手动创建占位符。&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当业务重度依赖 AntD 的各个功能，不能直接移除 AntD。我们只能保留整体框架，找到切入点做部分改造。所以改造 antD 内表格 scroll 事件，使用新的 onScroll 逻辑：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;判定 dom 行位置，计算 index&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;setState 动作完成后，手动销毁超出视窗的 dom 内容，同时创建等高空白区域，以维护滚动条位置。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对 data 数据内容进行裁切并更新，保证视窗内数据的正确性。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该逻辑下只修改了 AntD 传入的 data 内容，其余操作均基于 jsdom 手动完成，影响面小，完成度高。但需要仔细测试对各个表格功能点的影响。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.8609154929577465&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9egR3Y3zQbLecpKVOzHOfJvvOA4jYGoNqDUmG9RMP3ZBGSzUfJ0diasWXFKveBmU9HHHm0jWNSiaLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1136&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;方案优劣：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;需要小心处理改方案对列固定、行展开等特性的影响。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;由于无法提前获取行高，暂不支持直接定位，等价方案是需要先搜索到对应的数据，然后将结果装入 InfinityTable&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;向前兼容 Antd Table 的配置参数，只需要新增少数 props，改造成本极低&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;直接操控 dom，开发工作除了数据截取，其余大部分不依赖 AntD/rcTable 代码，性能有保障。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;优点：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;缺点：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;方案 3：重新实现表格&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当项目定制化程度较高时，考虑直接放弃 antd。方案 3 保留了 AntD 的 props 定义，以保证从 AntD 迁移时的便利性，随后利用 react-table 完成大多数功能，虚拟化部分借助了 react-window，底层开发了全新的具有虚拟化功能的基础表格。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.18125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9egR3Y3zQbLecpKVOzHOfJgibOaAODEfj90IzK7cvT20NWWcyB9mGnzM8qRhIhn2klibmlh0YrGb2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该方案中引入了 github 上炙手可热的开源 react hook 框架 react-table，这是个数据逻辑 hook 框架，因为排序、选择、等数据逻辑是具有相似性的，所以没必要重写，它帮助节省了数据处理的成本，同时也没有干涉 UI 及虚拟化工作。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;方案优劣：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;表格基础实现的成本高，基础 table 需要结合 react-table 的 api 重新实现，遇到各种坑都需要自己踩&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;深入改造，重构程度高，方便后续做任何扩展，方便性能优化&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;利用开源产品实现原 AntD 的开发内容，节省一定成本&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;优点：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;缺点：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;改造重点问题复盘&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;空白闪烁&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5465686274509803&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9egR3Y3zQbLecpKVOzHOfJMv2K0dDPCA72uChibjxR65HO5k7aD5E4sFUfEc8oPdtyFNgG2Vj8s2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;816&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 react-window 的 README 中，可以看到对此问题的描述。当应用虚拟化后，过快的 scroll 动作会导致占位符尚未更新，只能看到空白内容，需要等少量时间后才加载。当连续快速滚动表格时，呈现不断闪烁空白内容的状态。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;问题解决：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;目前没有较好解决办法，增加预载区大小，且优化单元格渲染内容，可以减缓问题严重性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有同学提出通过监控 scroll 时候的 speed 动态调整预载区大小，不失为一个没实践的思路。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;单元格自适应换行&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当单元格文本内容较长时，希望高度可以自适应。此需求乍一看似乎可以利用 react-window 的不定高组件解决，但实际上，该组件需要提供一个高度函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Returns the size of a item in the direction being windowed.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// For vertical lists, this is the row height.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// For horizontal lists, this is the column width.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;itemSize&lt;/span&gt;: &lt;span&gt;(&lt;span&gt;index: number&lt;/span&gt;) =&amp;gt;&lt;/span&gt; number&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当文本变化时，我们也需要 render 后才能获取每一行的高度，所以这个 api 并没有想象中美好。该问题还是必须借助二次渲染后，通过 ref 拿 dom 节点才能解决，但这样会拖慢性能，因此考量后，对此方案不予支持&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;列固定&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9egR3Y3zQbLecpKVOzHOfJ6QNOicOVsNLObc7eUGGaCdIIjspibVg9cKxRvVzwSJT95scFaJu99UzA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.668041237113402&quot; data-w=&quot;970&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在方案 3 中，由于使用了 div 的 flex 排版而不是原生 table，为了实现列固定时，我们需要使用三个 table 来做固定效果，因此滚动时，我们需要同时改变多个表格的 scrollTop 以及其数据截取。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;问题解决&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;可以使用一个 state 同步多个 table 之间的 scrollTop，但这种实现有可能因为性能，产生表格渲染的先后，进而产生三张表对不齐的问题。（AntD 的 Header 与 body 对齐本身也有此问题）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;AntD 不区分三个 table，而是在一个 table 内利用原生 tr/td，以及 css 的 sticky 特性，部分回避了该问题，但没有解决的很好，fixedcolumn 存在的场景下，header 和 body 的同步依旧存有类似问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以将三个表格改为一个表格，然后利用性能最好的 3Dtransform 来解决此问题。下方推荐的开源产品 rsuite-table 比较好的通过此方案解决了问题。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;列虚拟化&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;问题描述：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;由于目前方案专注于行数据量大的场景，因此当遇到表格列数据量大的场景，依旧存在性能问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果我们引入 react-window 的 Grid 组件进行列虚拟化，会需要兼容子列，列固定等功能，实际实现比想象中复杂。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;问题解决：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;过多的列从产品设计来说是不合理的。建议从产品层面改善数据展示问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;目前暂不支持列虚拟化。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;开源表格组件推荐&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于内部资源不能外部分享，所以没有办法把上述方案的产品对外放出。如果您希望使用带有虚拟化功能的表格，但并不希望做任何开发工作，这里推荐您几款比较不错的开源产品&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;rsuite-table&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;http://rsuite.github.io/rsuite-table/&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;虚拟化及表格性能优秀，大多数功能点完备&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;表头功能薄弱，没有列筛选，没有拖拽改变列宽&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;react-base-table&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;https://github.com/Autodesk/react-base-table&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自带虚拟化，基本功能齐全，其他功能与 AntD 相比有一定差距&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Table 组件虚拟化从原理上来说，是比较单纯的。即便不借助 react-window，我们也看到了同学们每个人都可以用自己的思路实现相似的功能需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之所以产生方案丛生无法统一的现状，主要还是由于不同项目对表格库的要求不同：有的项目需要低成本，有的项目要求兼容各种不同 feature，有的项目有着繁重的历史包袱。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而一个新的、面面俱到的 Table 库，又会有替换成本、稳定性风险等问题。因此，因地制宜地对自己项目进行改造，实现一套适合自己项目的虚拟化方案反而是最快速的，最被大家接受的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，本文从三个不同场景出发，总结了视野可及范围内，大家解决该问题的不同思路。对于希望开箱即用的同学，也给出了几个横向比较下来值得推荐的开源产品。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所谓授人以鱼不如授人以渔，希望文中探讨的内容，或多或少在提升表格性能及表格虚拟化方向，能给与读者一些启发，为字节系产品的用户带来更快更好的体验。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;&lt;em&gt;https://github.com/dwqs/blog/issues/70#&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;&lt;em&gt;https://github.com/ant-design/ant-design/issues/21022&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;&lt;em&gt;https://github.com/ant-design/ant-design/issues/20339&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>70288cc26e06cd8e4709bc9e99d3825c</guid>
<title>再谈 synchronized 锁升级</title>
<link>https://toutiao.io/k/8qya0wq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIwMTgzOTQ0Ng==&amp;amp;mid=2247485128&amp;amp;idx=1&amp;amp;sn=7fc733a5b958ee4db00879c1e51fe80b&amp;amp;chksm=96e680f1a19109e79b6184e2792da40bf3e40c389f6394dec0f46c8156fcc324c858650b3a3b&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;图文详解Java对象内存布局&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;图文详解Java对象内存布局&lt;/a&gt;这篇文章中，在研究对象头时我们了解了&lt;code&gt;synchronized&lt;/code&gt;锁升级的过程，由于篇幅有限，对锁升级的过程介绍的比较简略，本文在上一篇的基础上，来详细研究一下锁升级的过程以及各个状态下锁的原理。本文结构如下：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;1 无锁&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上一篇文章中，我们提到过 jvm会有4秒的偏向锁开启的延迟时间，在这个偏向延迟内对象处于为无锁态。如果关闭偏向锁启动延迟、或是经过4秒且没有线程竞争对象的锁，那么对象会进入&lt;strong&gt;无锁可偏向&lt;/strong&gt;状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;准确来说，无锁可偏向状态应该叫做&lt;strong&gt;匿名偏向&lt;/strong&gt;(&lt;code&gt;Anonymously biased&lt;/code&gt;)状态，因为这时对象的&lt;code&gt;mark word&lt;/code&gt;中后三位已经是&lt;code&gt;101&lt;/code&gt;，但是&lt;code&gt;threadId&lt;/code&gt;指针部分仍然全部为0，它还没有向任何线程偏向。综上所述，对象在刚被创建时，根据jvm的配置对象可能会处于 &lt;strong&gt;无锁&lt;/strong&gt; 或 &lt;strong&gt;匿名偏向&lt;/strong&gt; 两个状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，如果在jvm的参数中关闭偏向锁，那么直到有线程获取这个锁对象之前，会一直处于无锁不可偏向状态。修改jvm启动参数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;-XX:-UseBiasedLocking&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;延迟5s后打印对象内存布局：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;    User user=&lt;span&gt;new&lt;/span&gt; User();&lt;br/&gt;    TimeUnit.SECONDS.sleep(&lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;    System.out.println(ClassLayout.parseInstance(user).toPrintable());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.18438003220611915&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZs9lJF2NoicPJC8HhBeYA5jPV9kGeCzrztTVTTCywic2JYv25iaO8V9UShudOJXAib7mphNQAgicORLeg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1242&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，即使经过一定的启动延时，对象一直处于&lt;code&gt;001&lt;/code&gt;无锁不可偏向状态。大家可能会有疑问，在无锁状态下，为什么要存在一个不可偏向状态呢？通过查阅资料得到的解释是：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;JVM内部的代码有很多地方也用到了synchronized，明确在这些地方存在线程的竞争，如果还需要从偏向状态再逐步升级，会带来额外的性能损耗，所以JVM设置了一个偏向锁的启动延迟，来降低性能损耗&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，在无锁不可偏向状态下，如果有线程试图获取锁，那么将跳过升级偏向锁的过程，直接使用轻量级锁。使用代码进行验证：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//-XX:-UseBiasedLocking&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;    User user=&lt;span&gt;new&lt;/span&gt; User();&lt;br/&gt;    &lt;span&gt;synchronized&lt;/span&gt; (user){&lt;br/&gt;        System.out.println(ClassLayout.parseInstance(user).toPrintable());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看结果可以看到，在关闭偏向锁情况下使用&lt;code&gt;synchronized&lt;/code&gt;，锁会直接升级为轻量级锁（&lt;code&gt;00&lt;/code&gt;状态）:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.1750599520383693&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZs9lJF2NoicPJC8HhBeYA5jjjeRg5KL24eT7C96TJ9GNf6QlK8BLQibZKxQoW22h3OBfGKrRl3Gg8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1251&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在目前的基础上，可以用流程图概括上面的过程：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.41514726507713884&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZs9lJF2NoicPJC8HhBeYA5jmo5xf4aP9aJpwibvYandh58pAMCU5eaAMrWEMsCG2ibN4SQic2iaAvonPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;713&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;额外注意一点就是匿名偏向状态下，如果调用系统的&lt;code&gt;hashCode()&lt;/code&gt;方法，会使对象回到无锁态，并在&lt;code&gt;markword&lt;/code&gt;中写入&lt;code&gt;hashCode&lt;/code&gt;。并且在这个状态下，如果有线程尝试获取锁，会直接从无锁升级到轻量级锁，不会再升级为偏向锁。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2 偏向锁&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2.1 偏向锁原理&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;匿名偏向状态是偏向锁的初始状态，在这个状态下第一个试图获取该对象的锁的线程，会使用CAS操作（汇编命令&lt;code&gt;CMPXCHG&lt;/code&gt;）尝试将自己的&lt;code&gt;threadID&lt;/code&gt;写入对象头的&lt;code&gt;mark word&lt;/code&gt;中，使匿名偏向状态升级为&lt;strong&gt;已偏向&lt;/strong&gt;（Biased）的偏向锁状态。在已偏向状态下，线程指针&lt;code&gt;threadID&lt;/code&gt;非空，且偏向锁的时间戳&lt;code&gt;epoch&lt;/code&gt;为有效值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果之后有线程再次尝试获取锁时，需要检查&lt;code&gt;mark word&lt;/code&gt;中存储的&lt;code&gt;threadID&lt;/code&gt;是否与自己相同即可，如果相同那么表示当前线程已经获得了对象的锁，不需要再使用CAS操作来进行加锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果&lt;code&gt;mark word&lt;/code&gt;中存储的&lt;code&gt;threadID&lt;/code&gt;与当前线程不同，那么将执行CAS操作，试图将当前线程的ID替换&lt;code&gt;mark word&lt;/code&gt;中的&lt;code&gt;threadID&lt;/code&gt;。只有当对象处于下面两种状态中时，才可以执行成功：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;对象处于匿名偏向状态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对象处于&lt;strong&gt;可重偏向&lt;/strong&gt;（Rebiasable）状态，新线程可使用CAS将&lt;code&gt;threadID&lt;/code&gt;指向自己&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果对象不处于上面两个状态，说明锁存在线程竞争，在CAS替换失败后会执行&lt;strong&gt;偏向锁撤销&lt;/strong&gt;操作。偏向锁的撤销需要等待全局安全点&lt;code&gt;Safe Point&lt;/code&gt;（安全点是 jvm为了保证在垃圾回收的过程中引用关系不会发生变化设置的安全状态，在这个状态上会暂停所有线程工作），在这个安全点会挂起获得偏向锁的线程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在暂停线程后，会通过遍历当前jvm的所有线程的方式，检查持有偏向锁的线程状态是否存活：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果线程还存活，且线程正在执行同步代码块中的代码，则升级为轻量级锁&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果持有偏向锁的线程未存活，或者持有偏向锁的线程未在执行同步代码块中的代码，则进行校验是否允许重偏向：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;不允许重偏向，则撤销偏向锁，将&lt;code&gt;mark word&lt;/code&gt;升级为轻量级锁，进行CAS竞争锁&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;允许重偏向，设置为匿名偏向锁状态，CAS将偏向锁重新指向新线程&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完成上面的操作后，唤醒暂停的线程，从安全点继续执行代码。可以使用流程图总结上面的过程：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.48413897280966767&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZs9lJF2NoicPJC8HhBeYA5jxOd4rmDHPkeutoGa7kiccr9ty2pXJvN12VNJVw71VedAvUjptswF6Ig/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1324&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2.2 偏向锁升级&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面的过程中，我们已经知道了匿名偏向状态可以变为无锁态或升级为偏向锁，接下来看一下偏向锁的其他状态的改变&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;    User user=&lt;span&gt;new&lt;/span&gt; User();&lt;br/&gt;    &lt;span&gt;synchronized&lt;/span&gt; (user){&lt;br/&gt;        System.out.println(ClassLayout.parseInstance(user).toPrintable());&lt;br/&gt;    }&lt;br/&gt;    Thread thread = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br/&gt;        &lt;span&gt;synchronized&lt;/span&gt; (user) {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;--THREAD--:&quot;&lt;/span&gt;+ClassLayout.parseInstance(user).toPrintable());&lt;br/&gt;        }&lt;br/&gt;    });&lt;br/&gt;    thread.start();&lt;br/&gt;    thread.join();&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;--END--:&quot;&lt;/span&gt;+ClassLayout.parseInstance(user).toPrintable());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看内存布局，偏向锁升级为轻量级锁，在执行完成同步代码后释放锁，变为无锁不可偏向状态：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.599037690457097&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZs9lJF2NoicPJC8HhBeYA5j3MTc44vCcpgynA4XecCCia1t0Gol23nNel1f5UFDPW1ZghJYNHVnCYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1247&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;    User user=&lt;span&gt;new&lt;/span&gt; User();&lt;br/&gt;    Thread thread = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br/&gt;        &lt;span&gt;synchronized&lt;/span&gt; (user) {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;--THREAD1--:&quot;&lt;/span&gt; + ClassLayout.parseInstance(user).toPrintable());&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                user.wait(&lt;span&gt;2000&lt;/span&gt;);&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;--THREAD END--:&quot;&lt;/span&gt; + ClassLayout.parseInstance(user).toPrintable());&lt;br/&gt;        }&lt;br/&gt;    });&lt;br/&gt;    thread.start();&lt;br/&gt;    thread.join();&lt;br/&gt;    TimeUnit.SECONDS.sleep(&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;    System.out.println(ClassLayout.parseInstance(user).toPrintable());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看内存布局，可以看到在调用了对象的&lt;code&gt;wait()&lt;/code&gt;方法后，直接从偏向锁升级成了重量级锁，并在锁释放后变为无锁态：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5888888888888889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZs9lJF2NoicPJC8HhBeYA5jc32GAdd6pNiapkDTC6FZbfBzwZOhuhDToYb0X8GoKCNEvVm68dLjgow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1260&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里是因为&lt;code&gt;wait()&lt;/code&gt;方法调用过程中依赖于重量级锁中与对象关联的&lt;code&gt;monitor&lt;/code&gt;，在调用&lt;code&gt;wait()&lt;/code&gt;方法后&lt;code&gt;monitor&lt;/code&gt;会把线程变为&lt;code&gt;WAITING&lt;/code&gt;状态，所以才会强制升级为重量级锁。除此之外，调用&lt;code&gt;hashCode&lt;/code&gt;方法时也会使偏向锁直接升级为重量级锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面分析的基础上，再加上我们上一篇中讲到的轻量级锁升级到重量级锁的知识，就可以对上面的流程图进行完善了：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3389121338912134&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZs9lJF2NoicPJC8HhBeYA5jybUxYtFCZB3sBx3U9avuy8xU9hYOAiasscQeeub1mGsb5UEz7Fh9mhQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;956&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2.3 批量重偏向&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在未禁用偏向锁的情况下，当一个线程建立了大量对象，并且对它们执行完同步操作解锁后，所有对象处于偏向锁状态，此时若再来另一个线程也尝试获取这些对象的锁，就会导偏向锁的&lt;strong&gt;批量重偏向&lt;/strong&gt;（Bulk Rebias）。当触发批量重偏向后，第一个线程结束同步操作后的锁对象当再被同步访问时会被重置为可重偏向状态，以便允许快速重偏向，这样能够减少撤销偏向锁再升级为轻量级锁的性能消耗。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先看一下和偏向锁有关的参数，修改jvm启动参数，使用下面的命令可以在项目启动时打印jvm的默认参数值：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;-XX:+PrintFlagsFinal&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要关注的属性有下面3个：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.10104166666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZs9lJF2NoicPJC8HhBeYA5jG3sG6sK69bbh7WrQybuAoVbrh5tsDgObnOMpxVCqSYP8NOrjBYqoNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;960&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;BiasedLockingBulkRebiasThreshold&lt;/code&gt;：偏向锁批量重偏向阈值，默认为20次&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;BiasedLockingBulkRevokeThreshold&lt;/code&gt;：偏向锁批量撤销阈值，默认为40次&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;BiasedLockingDecayTime&lt;/code&gt;：重置计数的延迟时间，默认值为25000毫秒（即25秒）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;批量重偏向是以&lt;code&gt;class&lt;/code&gt;而不是对象为单位的，每个&lt;code&gt;class&lt;/code&gt;会维护一个偏向锁的撤销计数器，每当该&lt;code&gt;class&lt;/code&gt;的对象发生偏向锁的撤销时，该计数器会加一，当这个值达到默认阈值20时，jvm就会认为这个锁对象不再适合原线程，因此进行批量重偏向。而距离上次批量重偏向的25秒内，如果撤销计数达到40，就会发生批量撤销，如果超过25秒，那么就会重置在[20, 40)内的计数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这段理论是不是听上去有些难理解，没关系，我们先用代码验证批量重偏向的过程：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Thread t1,t2;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{      &lt;br/&gt;    TimeUnit.SECONDS.sleep(&lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;    List&amp;lt;Object&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;40&lt;/span&gt;; i++) {&lt;br/&gt;        list.add(&lt;span&gt;new&lt;/span&gt; Object());&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    t1 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; list.size(); i++) {&lt;br/&gt;            &lt;span&gt;synchronized&lt;/span&gt; (list.get(i)) {&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        LockSupport.unpark(t2);&lt;br/&gt;    });&lt;br/&gt;    t2 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br/&gt;        LockSupport.park();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;30&lt;/span&gt;; i++) {&lt;br/&gt;            Object o = list.get(i);&lt;br/&gt;            &lt;span&gt;synchronized&lt;/span&gt; (o) {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (i == &lt;span&gt;18&lt;/span&gt; || i == &lt;span&gt;19&lt;/span&gt;) {&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;THREAD-2 Object&quot;&lt;/span&gt;+(i+&lt;span&gt;1&lt;/span&gt;)+&lt;span&gt;&quot;:&quot;&lt;/span&gt;+ClassLayout.parseInstance(o).toPrintable());&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    });&lt;br/&gt;    t1.start();&lt;br/&gt;    t2.start();&lt;br/&gt;    t2.join();&lt;br/&gt;&lt;br/&gt;    TimeUnit.SECONDS.sleep(&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;Object19:&quot;&lt;/span&gt;+ClassLayout.parseInstance(list.get(&lt;span&gt;18&lt;/span&gt;)).toPrintable());&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;Object20:&quot;&lt;/span&gt;+ClassLayout.parseInstance(list.get(&lt;span&gt;19&lt;/span&gt;)).toPrintable());&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;Object30:&quot;&lt;/span&gt;+ClassLayout.parseInstance(list.get(&lt;span&gt;29&lt;/span&gt;)).toPrintable());&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;Object31:&quot;&lt;/span&gt;+ClassLayout.parseInstance(list.get(&lt;span&gt;30&lt;/span&gt;)).toPrintable());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分析上面的代码，当线程&lt;code&gt;t1&lt;/code&gt;运行结束后，数组中所有对象的锁都偏向&lt;code&gt;t1&lt;/code&gt;，然后&lt;code&gt;t1&lt;/code&gt;唤醒被挂起的线程&lt;code&gt;t2&lt;/code&gt;，线程&lt;code&gt;t2&lt;/code&gt;尝试获取前30个对象的锁。我们打印线程&lt;code&gt;t2&lt;/code&gt;获取到的第19和第20个对象的锁状态：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.38735177865612647&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZs9lJF2NoicPJC8HhBeYA5j0o9znuRpM2D4JzgDv84C6iaD13LRVSGuOWcEr7jC4kzVxwLFMwoJ00g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1265&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程&lt;code&gt;t2&lt;/code&gt;在访问前19个对象时对象的偏向锁会升级到轻量级锁，在访问后11个对象（下标19-29）时，因为偏向锁撤销次数达到了20，会触发批量重偏向，将锁的状态变为偏向线程&lt;code&gt;t2&lt;/code&gt;。在全部线程结束后，再次查看第19、20、30、31个对象锁的状态：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8055555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZs9lJF2NoicPJC8HhBeYA5j6ziaZvshLMiaicbesTTPIlpVPHhpw8TZzmbhSf3Nxb84PPibVQohWXuVzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1008&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程&lt;code&gt;t2&lt;/code&gt;结束后，第1-19的对象释放轻量级锁变为无锁不可偏向状态，第20-30的对象状态为偏向锁、但从偏向&lt;code&gt;t1&lt;/code&gt;改为偏向&lt;code&gt;t2&lt;/code&gt;，第31-40的对象因为没有被线程&lt;code&gt;t2&lt;/code&gt;访问所以保持偏向线程&lt;code&gt;t1&lt;/code&gt;不变。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2.4 批量撤销&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在多线程竞争激烈的状况下，使用偏向锁将会导致性能降低，因此产生了批量撤销机制，接下来使用代码进行测试：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Thread t1, t2, t3;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;    TimeUnit.SECONDS.sleep(&lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    List&amp;lt;Object&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;40&lt;/span&gt;; i++) {&lt;br/&gt;        list.add(&lt;span&gt;new&lt;/span&gt; Object());&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    t1 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; list.size(); i++) {&lt;br/&gt;            &lt;span&gt;synchronized&lt;/span&gt; (list.get(i)) {&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        LockSupport.unpark(t2);&lt;br/&gt;    });&lt;br/&gt;    t2 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br/&gt;        LockSupport.park();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; list.size(); i++) {&lt;br/&gt;            Object o = list.get(i);&lt;br/&gt;            &lt;span&gt;synchronized&lt;/span&gt; (o) {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (i == &lt;span&gt;18&lt;/span&gt; || i == &lt;span&gt;19&lt;/span&gt;) {&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;THREAD-2 Object&quot;&lt;/span&gt;+(i+&lt;span&gt;1&lt;/span&gt;)+&lt;span&gt;&quot;:&quot;&lt;/span&gt;+ClassLayout.parseInstance(o).toPrintable());&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        LockSupport.unpark(t3);&lt;br/&gt;    });&lt;br/&gt;    t3 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br/&gt;        LockSupport.park();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; list.size(); i++) {&lt;br/&gt;            Object o = list.get(i);&lt;br/&gt;            &lt;span&gt;synchronized&lt;/span&gt; (o) {&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;THREAD-3 Object&quot;&lt;/span&gt;+(i+&lt;span&gt;1&lt;/span&gt;)+&lt;span&gt;&quot;:&quot;&lt;/span&gt;+ClassLayout.parseInstance(o).toPrintable());&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;    t1.start();&lt;br/&gt;    t2.start();&lt;br/&gt;    t3.start();&lt;br/&gt;    t3.join();&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;New: &quot;&lt;/span&gt;+ClassLayout.parseInstance(&lt;span&gt;new&lt;/span&gt; Object()).toPrintable());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对上面的运行流程进行分析：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;线程&lt;code&gt;t1&lt;/code&gt;中，第1-40的锁对象状态变为偏向锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程&lt;code&gt;t2&lt;/code&gt;中，第1-19的锁对象撤销偏向锁升级为轻量级锁，然后对第20-40的对象进行批量重偏向&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程&lt;code&gt;t3&lt;/code&gt;中，首先直接对第1-19个对象竞争轻量级锁，而从第20个对象开始往后的对象不会再次进行批量重偏向，因此第20-39的对象进行偏向锁撤销升级为轻量级锁，这时&lt;code&gt;t2&lt;/code&gt;和&lt;code&gt;t3&lt;/code&gt;线程一共执行了40次的锁撤销，触发锁的批量撤销机制，对偏向锁进行撤销置为轻量级锁&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看一下在3个线程都结束后创建的新对象：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.20449077786688052&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZs9lJF2NoicPJC8HhBeYA5jSW0ia3q8FD846WBAEzsxAURqAyNvOrT4IgXhjJQCjdGWxxP9R6jaR1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1247&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，创建的新对象为无锁不可偏向状态&lt;code&gt;001&lt;/code&gt;，说明当类触发了批量撤销机制后，jvm会禁用该类创建对象时的可偏向性，该类新创建的对象全部为无锁不可偏向状态。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2.5 总结&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;偏向锁通过消除资源无竞争情况下的同步原语，提高了程序在&lt;strong&gt;单线程&lt;/strong&gt;下访问同步资源的运行性能，但是当出现多个线程竞争时，就会撤销偏向锁、升级为轻量级锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们的应用系统是高并发、并且代码中同步资源一直是被多线程访问的，那么撤销偏向锁这一步就显得多余，偏向锁撤销时进入&lt;code&gt;Safe Point&lt;/code&gt;产生&lt;code&gt;STW&lt;/code&gt;的现象应该是被极力避免的，这时应该通过禁用偏向锁来减少性能上的损耗。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;3 轻量级锁&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;3.1 轻量级锁原理&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、在代码访问同步资源时，如果锁对象处于无锁不可偏向状态，jvm首先将在当前线程的栈帧中创建一条锁记录（&lt;code&gt;lock record&lt;/code&gt;），用于存放：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;displaced mark word&lt;/code&gt;（置换标记字）：存放锁对象当前的&lt;code&gt;mark word&lt;/code&gt;的拷贝&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;owner&lt;/code&gt;指针：指向当前的锁对象的指针，在拷贝&lt;code&gt;mark word&lt;/code&gt;阶段暂时不会处理它&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.37664473684210525&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZs9lJF2NoicPJC8HhBeYA5jedw06lQFqRtpKZrm3x4Wo2oz7FdIbEagtRpY63uzRsCqScbsZ4mZbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;608&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、在拷贝&lt;code&gt;mark word&lt;/code&gt;完成后，首先会挂起线程，jvm使用CAS操作尝试将对象的 &lt;code&gt;mark word&lt;/code&gt; 中的 &lt;code&gt;lock record&lt;/code&gt; 指针指向栈帧中的锁记录，并将锁记录中的&lt;code&gt;owner&lt;/code&gt;指针指向锁对象的&lt;code&gt;mark word&lt;/code&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果CAS替换成功，表示竞争锁对象成功，则将锁标志位设置成 &lt;code&gt;00&lt;/code&gt;，表示对象处于轻量级锁状态，执行同步代码中的操作&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3958691910499139&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZs9lJF2NoicPJC8HhBeYA5jIgcCxmWhWe7SGiaqLiaicg7jR5PMB12wPCHpZrGFRPfUKJibnLRNG20KUw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;581&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果CAS替换失败，则判断当前对象的&lt;code&gt;mark word&lt;/code&gt;是否指向当前线程的栈帧：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果是则表示当前线程已经持有对象的锁，执行的是&lt;code&gt;synchronized&lt;/code&gt;的锁重入过程，可以直接执行同步代码块&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;否则说明该其他线程已经持有了该对象的锁，如果在自旋一定次数后仍未获得锁，那么轻量级锁需要升级为重量级锁，将锁标志位变成&lt;code&gt;10&lt;/code&gt;，后面等待的线程将会进入阻塞状态&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、轻量级锁的释放同样使用了CAS操作，尝试将&lt;code&gt;displaced mark word&lt;/code&gt; 替换回&lt;code&gt;mark word&lt;/code&gt;，这时需要检查锁对象的&lt;code&gt;mark word&lt;/code&gt;中&lt;code&gt;lock record&lt;/code&gt;指针是否指向当前线程的锁记录：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果替换成功，则表示没有竞争发生，整个同步过程就完成了&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果替换失败，则表示当前锁资源存在竞争，有可能其他线程在这段时间里尝试过获取锁失败，导致自身被挂起，并修改了锁对象的&lt;code&gt;mark word&lt;/code&gt;升级为重量级锁，最后在执行重量级锁的解锁流程后唤醒被挂起的线程&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用流程图对上面的过程进行描述：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9522388059701492&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZs9lJF2NoicPJC8HhBeYA5jvzP0XKbC4McEaupM2L0bWQRlg9vlSMIjeD6weYQjYQscOQhTTriaFvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;670&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;3.2 轻量级锁重入&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道，&lt;code&gt;synchronized&lt;/code&gt;是可以锁重入的，在轻量级锁的情况下重入也是依赖于栈上的&lt;code&gt;lock record&lt;/code&gt;完成的。以下面的代码中3次锁重入为例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;synchronized&lt;/span&gt; (user){&lt;br/&gt;    &lt;span&gt;synchronized&lt;/span&gt; (user){&lt;br/&gt;        &lt;span&gt;synchronized&lt;/span&gt; (user){&lt;br/&gt;            &lt;span&gt;//TODO&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;轻量级锁的每次重入，都会在栈中生成一个&lt;code&gt;lock record&lt;/code&gt;，但是保存的数据不同：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首次分配的&lt;code&gt;lock record&lt;/code&gt;，&lt;code&gt;displaced mark word&lt;/code&gt;复制了锁对象的&lt;code&gt;mark word&lt;/code&gt;，&lt;code&gt;owner&lt;/code&gt;指针指向锁对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;之后重入时在栈中分配的&lt;code&gt;lock record&lt;/code&gt;中的&lt;code&gt;displaced mark word&lt;/code&gt;为&lt;code&gt;null&lt;/code&gt;，只存储了指向对象的&lt;code&gt;owner&lt;/code&gt;指针&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8056042031523643&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZs9lJF2NoicPJC8HhBeYA5jrPBWpctk6Eff1c71hxdJvDrvUdKG6hPuRumkTDQ21k5Bt2ibsMicQWjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;571&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;轻量级锁中，重入的次数等于该锁对象在栈帧中&lt;code&gt;lock record&lt;/code&gt;的数量，这个数量隐式地充当了锁重入机制的计数器。这里需要计数的原因是每次解锁都需要对应一次加锁，只有最后解锁次数等于加锁次数时，锁对象才会被真正释放。在释放锁的过程中，如果是重入则删除栈中的&lt;code&gt;lock record&lt;/code&gt;，直到没有重入时则使用CAS替换锁对象的&lt;code&gt;mark word&lt;/code&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;3.3 轻量级锁升级&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在jdk1.6以前，默认轻量级锁自旋次数是10次，如果超过这个次数或自旋线程数超过CPU核数的一半，就会升级为重量级锁。这时因为如果自旋次数过多，或过多线程进入自旋，会导致消耗过多cpu资源，重量级锁情况下线程进入等待队列可以降低cpu资源的消耗。自旋次数的值也可以通过jvm参数进行修改：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;-XX:PreBlockSpin&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jdk1.6以后加入了&lt;strong&gt;自适应自旋锁&lt;/strong&gt; （&lt;code&gt;Adapative Self Spinning&lt;/code&gt;），自旋的次数不再固定，由jvm自己控制，由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;对于某个锁对象，如果自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而允许自旋等待持续相对更长时间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于某个锁对象，如果自旋很少成功获得过锁，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面通过代码验证轻量级锁升级为重量级锁的过程：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;    User user = &lt;span&gt;new&lt;/span&gt; User();&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;--MAIN--:&quot;&lt;/span&gt; + ClassLayout.parseInstance(user).toPrintable());&lt;br/&gt;    Thread thread1 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br/&gt;        &lt;span&gt;synchronized&lt;/span&gt; (user) {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;--THREAD1--:&quot;&lt;/span&gt; + ClassLayout.parseInstance(user).toPrintable());&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                TimeUnit.SECONDS.sleep(&lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    });&lt;br/&gt;    Thread thread2 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            TimeUnit.SECONDS.sleep(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;synchronized&lt;/span&gt; (user) {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;--THREAD2--:&quot;&lt;/span&gt; + ClassLayout.parseInstance(user).toPrintable());&lt;br/&gt;        }&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;    thread1.start();&lt;br/&gt;    thread2.start();&lt;br/&gt;    thread1.join();&lt;br/&gt;    thread2.join();&lt;br/&gt;    TimeUnit.SECONDS.sleep(&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;    System.out.println(ClassLayout.parseInstance(user).toPrintable());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面的代码中，线程2在启动后休眠两秒后再尝试获取锁，确保线程1能够先得到锁，在此基础上造成锁对象的资源竞争。查看对象锁状态变化：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5911251980982567&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZs9lJF2NoicPJC8HhBeYA5j2riaJABWj9fZ4zomlKMTysc6K8dBbLoVZndhoEnLqtRZf0r7IHAicAeg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1262&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在线程1持有轻量级锁的情况下，线程2尝试获取锁，导致资源竞争，使轻量级锁升级到重量级锁。在两个线程都运行结束后，可以看到对象的状态恢复为了无锁不可偏向状态，在下一次线程尝试获取锁时，会直接从轻量级锁状态开始。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面在最后一次打印前将主线程休眠3秒的原因是锁的释放过程需要一定的时间，如果在线程执行完成后直接打印对象内存布局，对象可能仍处于重量级锁状态。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;3.4 总结&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;轻量级锁与偏向锁类似，都是jdk对于多线程的优化，不同的是轻量级锁是通过CAS来避免开销较大的互斥操作，而偏向锁是在无资源竞争的情况下完全消除同步。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;轻量级锁的“轻量”是相对于重量级锁而言的，它的性能会稍好一些。轻量级锁尝试利用CAS，在升级为重量级锁之前进行补救，目的是为了减少多线程进入互斥，当多个线程交替执行同步块时，jvm使用轻量级锁来保证同步，避免线程切换的开销，不会造成用户态与内核态的切换。但是如果过度自旋，会引起cpu资源的浪费，这种情况下轻量级锁消耗的资源可能反而会更多。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;4 重量级锁&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;4.1 Monitor&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重量级锁是依赖对象内部的monitor（监视器/管程）来实现的 ，而monitor 又依赖于操作系统底层的&lt;code&gt;Mutex Lock&lt;/code&gt;（互斥锁）实现，这也就是为什么说重量级锁比较“重”的原因了，操作系统在实现线程之间的切换时，需要从用户态切换到内核态，成本非常高。在学习重量级锁的工作原理前，首先需要了解一下monitor中的核心概念：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;owner&lt;/code&gt;：标识拥有该&lt;code&gt;monitor&lt;/code&gt;的线程，初始时和锁被释放后都为null&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;cxq (ConnectionList)&lt;/code&gt;：竞争队列，所有竞争锁的线程都会首先被放入这个队列中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;EntryList&lt;/code&gt;：候选者列表，当&lt;code&gt;owner&lt;/code&gt;解锁时会将&lt;code&gt;cxq&lt;/code&gt;队列中的线程移动到该队列中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;OnDeck&lt;/code&gt;：在将线程从&lt;code&gt;cxq&lt;/code&gt;移动到&lt;code&gt;EntryList&lt;/code&gt;时，会指定某个线程为Ready状态（即&lt;code&gt;OnDeck&lt;/code&gt;），表明它可以竞争锁，如果竞争成功那么称为&lt;code&gt;owner&lt;/code&gt;线程，如果失败则放回&lt;code&gt;EntryList&lt;/code&gt;中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;WaitSet&lt;/code&gt;：因为调用&lt;code&gt;wait()&lt;/code&gt;或&lt;code&gt;wait(time)&lt;/code&gt;方法而被阻塞的线程会被放在该队列中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;count&lt;/code&gt;：monitor的计数器，数值加1表示当前对象的锁被一个线程获取，线程释放monitor对象时减1&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;recursions&lt;/code&gt;：线程重入次数&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用图来表示线程竞争的的过程：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.46338028169014084&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZs9lJF2NoicPJC8HhBeYA5jnlrMjI5uiarlfDxtibBV54hxeia3XpQVW3AKM420Dq5QjPe4szpooHjsQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;710&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当线程调用&lt;code&gt;wait()&lt;/code&gt;方法，将释放当前持有的monitor，将&lt;code&gt;owner&lt;/code&gt;置为null，进入&lt;code&gt;WaitSet&lt;/code&gt;集合中等待被唤醒。当有线程调用&lt;code&gt;notify()&lt;/code&gt;或&lt;code&gt;notifyAll()&lt;/code&gt;方法时，也会释放持有的monitor，并唤醒&lt;code&gt;WaitSet&lt;/code&gt;的线程重新参与monitor的竞争。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;4.2 重量级锁原理&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当升级为重量级锁的情况下，锁对象的&lt;code&gt;mark word&lt;/code&gt;中的指针不再指向线程栈中的&lt;code&gt;lock record&lt;/code&gt;，而是指向堆中与锁对象关联的monitor对象。当多个线程同时访问同步代码时，这些线程会先尝试获取当前锁对象对应的monitor的所有权：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;获取成功，判断当前线程是不是重入，如果是重入那么&lt;code&gt;recursions+1&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;获取失败，当前线程会被阻塞，等待其他线程解锁后被唤醒，再次竞争锁对象&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在重量级锁的情况下，加解锁的过程涉及到操作系统的&lt;code&gt;Mutex Lock&lt;/code&gt;进行互斥操作，线程间的调度和线程的状态变更过程需要在用户态和核心态之间进行切换，会导致消耗大量的cpu资源，导致性能降低。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;总结&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在jdk1.6中，引入了偏向锁和轻量级锁，并使用锁升级机制对&lt;code&gt;synchronized&lt;/code&gt;进行了充分的优化。其实除锁升级外，还使用了锁消除、锁粗化等优化手段，所以对它的认识要脱离“重量级”这一概念，不要再单纯的认为它的性能差了。在某些场景下，&lt;code&gt;synchronized&lt;/code&gt;的性能甚至已经超过了&lt;code&gt;Lock&lt;/code&gt;同步锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽管java对&lt;code&gt;synchronized&lt;/code&gt;做了这些优化，但是在使用过程中，我们还是要尽量减少锁的竞争，通过减小加锁粒度和减少同步代码的执行时间，来降低锁竞争，尽量使锁维持在偏向锁和轻量级锁的级别，避免升级为重量级锁，造成性能的损耗。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后不得不再提一句，在java15中已经默认禁用了偏向锁，并弃用所有相关的命令行选项，虽然说不确定未来的LTS版本会怎样改动，但是了解一下偏向锁的基础也没什么不好的，毕竟你发任你发，我用java8~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b259bf11ec16458746c326e616b3485d</guid>
<title>常见的初级排序算法，这次全搞懂</title>
<link>https://toutiao.io/k/grivds8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;本文已被Github仓库收录 https://github.com/silently9527/JavaCore&lt;/p&gt;&lt;p&gt;程序员常用的IDEA插件：https://github.com/silently9527/ToolsetIdeaPlugin&lt;/p&gt;&lt;p&gt;完全开源的淘客项目：https://github.com/silently9527/mall-coupons-server&lt;/p&gt;&lt;p&gt;微信公众号：贝塔学Java&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信所有的程序员刚开始接触到的算法都会是排序算法，因为排序在对数据处理和计算有这重要的地位，排序算法往往是其他算法的基础；本文我们就先从初级排序算法开始学习算法。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;排序算法的模板&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在开始之前我们先定义一个排序算法通用的模板，在后面的排序算法都会实现这个模板&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public interface SortTemplate {&lt;br/&gt;&lt;br/&gt;    void sort(Comparable[] array);&lt;br/&gt;&lt;br/&gt;    default void &lt;span&gt;print&lt;/span&gt;(Comparable[] array) {&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (Comparable a : array) {&lt;br/&gt;            System.out.print(a + &lt;span&gt;&quot; &quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    default boolean less(Comparable a, Comparable b) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; a.compareTo(b) &amp;lt; 0;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    default void exch(Comparable[] array, int i, int j) {&lt;br/&gt;        Comparable tmp = array[i];&lt;br/&gt;        array[i] = array[j];&lt;br/&gt;        array[j] = tmp;&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Comparable: 为了让我们实现的排序算法更加的通用，可以排序任意的对象，所以我们这里使用了Comparable数组&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;sort: 不同的排序算法实现的方式不一样，子类自己去实现&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;less: 定义的公用方法，如果a &amp;lt; b就返回true&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;exch: 定义的公用方法，交换数组中的两个对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;print: 打印出数据中的每个元素&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;选择排序&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;算法实现的思路：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先找到数组中的最小元素，&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;其实将它和数组中的第一个元素进行交换，这样就排定了一个元素；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;再次找出剩余元素中最小的元素与数组中的第二个元素进行交换，如此反复直到所有元素都是有序的&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4006568144499179&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/ggRgNal7zGicS8Cq9j1YMfibVmYYibaIrpy3G1taVKjISCzxwuU2ja9UhBMbvs4l0ALwjhMBowyQkWiaYfn2q3XLibg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;609&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public class SelectionSort implements SortTemplate {&lt;br/&gt;&lt;br/&gt;    @Override&lt;br/&gt;    public void sort(Comparable[] array) {&lt;br/&gt;        int length = array.length;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (int i = 0; i &amp;lt; length; i++) {&lt;br/&gt;            int min = i;&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (int j = i + 1; j &amp;lt; length; j++) {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (less(array[j], array[min])) {&lt;br/&gt;                    min = j;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            exch(array, i, min);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如输入的数组是有序的，我们会发现选择排序运行的时候和未排序的时间一样长！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于N个元素的数组，使用&lt;strong&gt;「选择排序的时间复杂度是O(n²)」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;选择排序的是&lt;strong&gt;「数据移动最少」&lt;/strong&gt;的，交换的次数与数组的大小是线性关系，N个元素的数组需要N次交换&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;冒泡排序&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;算法实现的思路：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;比较相邻的两个元素，如果前一个比后一个大，那么就交换两个元素的位置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对每一组相邻的元素执行同样的操作，直到最后一个元素，操作完成之后就可以排定一个最大的元素&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如此往复，直到数组中所有的元素都有序&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4115384615384615&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/ggRgNal7zGicS8Cq9j1YMfibVmYYibaIrpyDVHzBhJibsUy1bXHBHUhgDIDXNJGZS9cG4Cs8Y9ZA8vExLbrHTR02lQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;780&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public class BubbleSort implements SortTemplate {&lt;br/&gt;&lt;br/&gt;    @Override&lt;br/&gt;    public void sort(Comparable[] array) {&lt;br/&gt;        int length = array.length - 1;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (int i = 0; i &amp;lt; length; i++) {&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (int j = 0; j &amp;lt; length - i; j++) {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (less(array[j + 1], array[j])) {&lt;br/&gt;                    exch(array, j, j + 1);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于N个元素的数组，使用&lt;strong&gt;「冒泡排序的时间复杂度是O(n²)」&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;插入排序&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想象我们在玩扑克牌时，整理扑克牌都是把每一张插入到左边已经排好序的牌中适当的位置。插入排序的思路类似&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;算法实现的思路：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;初始默认第一个元素就是有序的，当前索引的位置从0开始&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;先后移动当前索引的位置，当前索引位置左边的元素是有序的，从后往前开始扫码与当前索引位置元素进行比较&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当确定当前索引位置上的元素在左边有序适合的位置之后，插入到该位置上&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果当确定当前索引位置上的元素大于了已排序的最后一个元素，那么当前索引位置直接往后移动&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如此反复，直到所有元素有序&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3542319749216301&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/ggRgNal7zGicS8Cq9j1YMfibVmYYibaIrpyFjibORvFZAkgVgBaf5r4ew9GXChN80Ku1rU0n8ll1wDsa5aZxwLumzg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;638&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public class InsertionSort implements SortTemplate {&lt;br/&gt;&lt;br/&gt;    @Override&lt;br/&gt;    public void sort(Comparable[] array) {&lt;br/&gt;        int length = array.length;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (int i = 1; i &amp;lt; length; i++) {&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (int j = i; j &amp;gt; 0 &amp;amp;&amp;amp; less(array[j], array[j - 1]); j--) {&lt;br/&gt;                exch(array, j, j - 1);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从代码的实现我们可以看出，当遇到了当前索引的元素大于了左边有序数组的最后一个元素时，内层循环就直接结束了，所以所我们排序的数组中存在着部分有序，那么插入排序算法会很快。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;考虑最糟糕的情况，如果输入数组是一个倒置的，那么插入排序的效率和选择排序一样，&lt;strong&gt;「时间复杂度是O(n²)」&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;希尔排序&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于大规模的乱序数组插入排序很慢，是因为它只交换相邻的元素，元素只能一点一点的从数组中移动到正确的位置；插入排序对于部分有序的数组排序是的效率很高；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;希尔排序基于这两个特点对插入排序进行了改进；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;算法实现的思路&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先设置一个步长h用来分隔出子数组&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用插入排序将h个子数组独立排序&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;减小h步长继续排序子数组，直到h步长为1&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当步长为1时就成了普通的插入排序，这样数组一定是有序的&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;希尔排序高效的原因，在排序之初，各个子数组都很短，子数组排序之后都是部分有序的，这两种情况都很适合插入排序。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4359375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/ggRgNal7zGicS8Cq9j1YMfibVmYYibaIrpygDwGnZmU4VZnXTgBTLxNIE16sDaXlTjwHsXwmshuO3wX7jdia4BkWAg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public class ShellSort implements SortTemplate {&lt;br/&gt;&lt;br/&gt;    @Override&lt;br/&gt;    public void sort(Comparable[] array) {&lt;br/&gt;        int gap = 1;&lt;br/&gt;        int length = array.length;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (gap &amp;lt; length / 3) {&lt;br/&gt;            gap = 3 * gap + 1;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (gap &amp;gt;= 1) {&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (int i = gap; i &amp;lt; length; i++) {&lt;br/&gt;                &lt;span&gt;for&lt;/span&gt; (int j = i; j &amp;gt;= gap &amp;amp;&amp;amp; less(array[j], array[j - gap]); j -= gap) {&lt;br/&gt;                    exch(array, j, j - gap);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            gap = gap / 3;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最后（点关注，不迷路）&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文中或许会存在或多或少的不足、错误之处，有建议或者意见也非常欢迎大家在评论交流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，&lt;strong&gt;「写作不易，请不要白嫖我哟」&lt;/strong&gt;，希望朋友们可以&lt;strong&gt;「点赞评论关注」&lt;/strong&gt;三连，因为这些就是我分享的全部动力来源🙏&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;文中所有源码已放入到了github仓库https://github.com/silently9527/JavaCore&lt;/p&gt;&lt;p&gt;图片来源于网络; 参考书籍：算法第四版&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>