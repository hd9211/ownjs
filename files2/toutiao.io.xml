<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>4a225e2d07d887526ac95e9ada8924b5</guid>
<title>面试过 200 人的经验，都在这里了 | 码农周刊第 325 期</title>
<link>https://toutiao.io/k/xvysg5s</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;issue&quot; id=&quot;readabilityBody&quot;&gt;
        &lt;h1&gt;面试过 200 人的经验，都在这里了 | 码农周刊第 325 期&lt;/h1&gt;
        &lt;h2&gt;码农周刊第325期（2020-11-25）&lt;/h2&gt;
        &lt;p&gt;☞ &lt;a href=&quot;https://weekly.manong.io/bounce?nid=325&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3250&quot; target=&quot;_blank&quot;&gt;薪资翻番如何实现？程序员的涨薪秘诀&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;a href=&quot;https://weekly.manong.io/bounce?nid=325&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3250&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_321.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;small&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=325&amp;amp;aid=19185&amp;amp;url=https%3A%2F%2Fjinshuju.net%2Ff%2FV7DxN9&quot; target=&quot;_blank&quot;&gt;商务合作&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
        
        &lt;h3 id=&quot;程序设计&quot;&gt;程序设计&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;业界实战&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;VIP会员专区&quot;&gt;VIP会员专区&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;工作地点：成都 | 薪资：15-30K | 简历投递邮箱：xiexiaofang@huobi.com&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;相比 cocos2d 引擎有着更低的入门门槛和维护成本，为复杂动画的实现提供了一种全新的方式，新的复杂动画开发将会变得更加简单高效。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;让您享受极简编程体验，快速访问支付宝开放平台开放的各项核心能力。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;一个不错的 Python 学习教程，30 天循序渐进地教你学会 Python。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;白皮书从技术、市场、趋势、挑战等多维度，对我国开源产业生态进行了全面、深度的剖析，指出了我国开源产业发展的几大重要趋势。&lt;/p&gt;
        &lt;h3 id=&quot;工具资料&quot;&gt;工具资料&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;试试吧&lt;/p&gt;
        
        &lt;p&gt;经验总结&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;一步步教你&lt;/p&gt;
        
        &lt;p&gt;结合代码&lt;/p&gt;
        
        &lt;p&gt;供参考&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;图文并茂&lt;/p&gt;
        
        &lt;p&gt;收藏吧&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;实用&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;使用方便&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程语言&quot;&gt;编程语言&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;一步步教你&lt;/p&gt;
        
        &lt;p&gt;代码示例&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;良心教程&lt;/p&gt;
        
        &lt;p&gt;结合代码&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;你怎么看？&lt;/p&gt;
        
        &lt;p&gt;深入研究&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        &lt;h3 id=&quot;每周独家号推荐&quot;&gt;每周独家号推荐&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;技术总结，经验分享&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 451179 即可&lt;/p&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 429587 即可&lt;/p&gt;
        
        &lt;p&gt;分享计算机视觉与机器学习技术的最前沿&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 359575 即可&lt;/p&gt;
        
        &lt;p&gt;聚焦基础架构和Linux。十年架构，日百亿流量，与你探讨高并发世界，给你不一样的味道。&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 351247 即可&lt;/p&gt;
        
        &lt;p&gt;学习就是不停的积累&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 24912 即可&lt;/p&gt;
        &lt;h3 id=&quot;每周一书&quot;&gt;每周一书&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;本手册以开发工程师为中心视角，划分为单元测试、安全规约、MySQL 数据库、工程结构等七个维度，相应的扩展解释和说明、正例和反例，全面、立体、形象地帮助开发工程师成长。欢迎到&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;兑换阅读。&lt;/p&gt;
        &lt;h3 id=&quot;编程之外&quot;&gt;编程之外&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;个人经历&lt;/p&gt;
        
        &lt;p&gt;一直被追赶，从未被超越&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;p&gt;
        &lt;/p&gt;
        
        
        
        
        &lt;div class=&quot;qrcode&quot;&gt;
  &lt;img src=&quot;https://img.toutiao.io/ads/vip_qrcode.png&quot; alt=&quot;Qrcode 258&quot;/&gt;&lt;span&gt;加入码农周刊VIP会员&lt;/span&gt;
&lt;/div&gt;
    &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f772e2afc9b2deb2ee88c48d93827b7d</guid>
<title>如何优雅的实现分布式锁</title>
<link>https://toutiao.io/k/veeydsj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;概述&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提到分布式锁大家都会想到如下两种：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;基于 &lt;code&gt;Redisson&lt;/code&gt;组件，使用redlock算法实现&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;基于 &lt;code&gt;Apache Curator&lt;/code&gt;，利用Zookeeper的临时顺序节点模型实现&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天我们来说说第三种，使用 &lt;code&gt;Spring Integration&lt;/code&gt; 实现，也是我个人比较推荐的一种。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Spring Integration&lt;/code&gt;在基于Spring的应用程序中实现轻量级消息传递，并支持通过声明适配器与外部系统集成。Spring Integration的主要目标是提供一个简单的模型来构建企业集成解决方案，同时保持关注点的分离，这对于生成可维护，可测试的代码至关重要。我们熟知的
Spring Cloud Stream的底层就是Spring Integration。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官方地址：https://github.com/spring-projects/spring-integration&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring Integration提供的全局锁目前为如下存储提供了实现：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Gemfire&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;JDBC&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Redis&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Zookeeper&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它们使用相同的API抽象，这意味着，不论使用哪种存储，你的编码体验是一样的。试想一下你目前是基于zookeeper实现的分布式锁，哪天你想换成redis的实现，我们只需要修改相关依赖和配置就可以了，无需修改代码。下面是你使用 &lt;code&gt;Spring Integration&lt;/code&gt; 实现分布式锁时需要关注的方法：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法名&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;lock()&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;Acquires the lock.&lt;/code&gt;   加锁，如果已经被其他线程锁住或者当前线程不能获取锁则阻塞&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;lockInterruptibly()&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;Acquires the lock unless the current thread is interrupted.&lt;/code&gt; 加锁，除非当前线程被打断。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;tryLock()&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;Acquires the lock only if it is free at the time of invocation.&lt;/code&gt; 尝试加锁，如果已经有其他锁锁住，获取当前线程不能加锁，则返回false，加锁失败；加锁成功则返回true&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;tryLock(long time, TimeUnit unit)&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;Acquires the lock if it is free within the given waiting time and the current thread has not been interrupted.&lt;/code&gt; 尝试在指定时间内加锁，如果已经有其他锁锁住，获取当前线程不能加锁，则返回false，加锁失败；加锁成功则返回true&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;unlock()&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;Releases the lock.&lt;/code&gt; 解锁&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;实战&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;话不多说，我们看看使用 &lt;code&gt;Spring Integration&lt;/code&gt;  如何基于redis和zookeeper快速实现分布式锁，至于Gemfire 和 Jdbc的实现大家自行实践。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;基于Redis实现&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-integration&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.integration&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-integration-redis&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-data-redis&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在application.yml中添加redis的配置&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;spring:&lt;/span&gt;&lt;br/&gt; &lt;span&gt;redis:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;host:&lt;/span&gt; &lt;span&gt;172.31&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;&lt;span&gt;.149&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;port:&lt;/span&gt; &lt;span&gt;7111&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;建立配置类，注入 &lt;code&gt;RedisLockRegistry&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RedisLockConfiguration&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; RedisLockRegistry &lt;span&gt;redisLockRegistry&lt;/span&gt;&lt;span&gt;(RedisConnectionFactory redisConnectionFactory)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RedisLockRegistry(redisConnectionFactory, &lt;span&gt;&quot;redis-lock&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@RestController&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@RequestMapping&lt;/span&gt;(&lt;span&gt;&quot;lock&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@Log&lt;/span&gt;4j2&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DistributedLockController&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; RedisLockRegistry redisLockRegistry;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/redis&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Lock lock = redisLockRegistry.obtain(&lt;span&gt;&quot;redis&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;//尝试在指定时间内加锁，如果已经有其他锁锁住，获取当前线程不能加锁，则返回false，加锁失败；加锁成功则返回true&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt;(lock.tryLock(&lt;span&gt;3&lt;/span&gt;, TimeUnit.SECONDS)){&lt;br/&gt;                log.info(&lt;span&gt;&quot;lock is ready&quot;&lt;/span&gt;);&lt;br/&gt;                TimeUnit.SECONDS.sleep(&lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;            log.error(&lt;span&gt;&quot;obtain lock error&quot;&lt;/span&gt;,e);&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            lock.unlock();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;测试&lt;br/&gt;启动多个实例，分别访问 &lt;code&gt;/lock/redis&lt;/code&gt; 端点，一个正常秩序业务逻辑，另外一个实例访问出现如下错误&lt;img data-ratio=&quot;0.22916666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4h9kamAaicVpoFTfGUrfT9nrLfnZy7QibI42VeMClsGhOoTg2CEFreHSxeHyf8nYZs36H4c9ZBKVMicg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1488&quot;/&gt;说明第二个实例没有拿到锁，证明了分布式锁的存在。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;p&gt;注意，如果使用新版Springboot进行集成时需要使用Redis4版本，否则会出现下面的异常告警，主要是 unlock() 释放锁时使用了UNLINK命令，这个需要Redis4版本才能支持。&lt;/p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;2020-05-14 11:30:24,781 WARN  RedisLockRegistry:339 - The UNLINK &lt;span&gt;command&lt;/span&gt; has failed (not supported on the Redis server?); falling back to the regular DELETE &lt;span&gt;command&lt;/span&gt;&lt;br/&gt;org.springframework.data.redis.RedisSystemException: Error &lt;span&gt;in&lt;/span&gt; execution; nested exception is io.lettuce.core.RedisCommandExecutionException: ERR unknown &lt;span&gt;command&lt;/span&gt; &lt;span&gt;&#x27;UNLINK&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;基于Zookeeper实现&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-integration&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.integration&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-integration-zookeeper&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在application.yml中添加zookeeper的配置&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;zookeeper:&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;    host:&lt;/span&gt; &lt;span&gt;172.31&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;&lt;span&gt;.43&lt;/span&gt;&lt;span&gt;:2181&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;建立配置类，注入 &lt;code&gt;ZookeeperLockRegistry&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ZookeeperLockConfiguration&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${zookeeper.host}&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String zkUrl;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; CuratorFrameworkFactoryBean &lt;span&gt;curatorFrameworkFactoryBean&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; CuratorFrameworkFactoryBean(zkUrl);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; ZookeeperLockRegistry &lt;span&gt;zookeeperLockRegistry&lt;/span&gt;&lt;span&gt;(CuratorFramework curatorFramework)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ZookeeperLockRegistry(curatorFramework,&lt;span&gt;&quot;/zookeeper-lock&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@RestController&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@RequestMapping&lt;/span&gt;(&lt;span&gt;&quot;lock&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@Log&lt;/span&gt;4j2&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DistributedLockController&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; ZookeeperLockRegistry zookeeperLockRegistry;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/zookeeper&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Lock lock = zookeeperLockRegistry.obtain(&lt;span&gt;&quot;zookeeper&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;//尝试在指定时间内加锁，如果已经有其他锁锁住，获取当前线程不能加锁，则返回false，加锁失败；加锁成功则返回true&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt;(lock.tryLock(&lt;span&gt;3&lt;/span&gt;, TimeUnit.SECONDS)){&lt;br/&gt;                log.info(&lt;span&gt;&quot;lock is ready&quot;&lt;/span&gt;);&lt;br/&gt;                TimeUnit.SECONDS.sleep(&lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;            log.error(&lt;span&gt;&quot;obtain lock error&quot;&lt;/span&gt;,e);&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            lock.unlock();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;测试&lt;br/&gt;启动多个实例，分别访问 &lt;code&gt;/lock/zookeeper&lt;/code&gt; 端点，一个正常执行业务逻辑，另外一个实例访问出现如下错误：&lt;img data-ratio=&quot;0.254272043745728&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4h9kamAaicVpoFTfGUrfT9nrP70svZwaWl9dbMlaJ1VgDo059n3Q0fvfTJ0An3rRxYkL7CPNnKZReg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1463&quot;/&gt;说明第二个实例没有拿到锁，证明了分布式锁的存在。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>14b963d34214dbdb0fe0ddfa42649d55</guid>
<title>CTO 怒了：“如果中台不省钱，我建个屁中台啊！”</title>
<link>https://toutiao.io/k/batmypd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;&lt;span&gt;点击“&lt;/span&gt;&lt;span&gt;技术领导力&lt;/span&gt;&lt;span&gt;”关注&lt;/span&gt;&lt;span&gt;∆&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;每天&lt;/span&gt;&lt;span&gt;早上8:30&lt;/span&gt;&lt;span&gt;推送&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;作者| Mr.K   整理| Emma&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;来源| 技术领导力(ID：jishulingdaoli)&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;“妈的，A厂说的什么玩意儿，老子听不懂！你就告诉我，这次中台建设，投资多少钱，投了这些钱后，以后的信息化系统是否可以集约化建设？大概平均每个系统能省多少钱？” L总参观完杭州的A厂、深圳的T厂，一脸懵逼地对小M说。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小M急忙回复领导：“中台省钱这个事，它可以当成结果，但千万不能当成目标。”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;L总一听又怒了：“我建中台的目的就是为了省钱，公司一年信息化开支几千万上亿，如果中台不省钱，我建个屁中台啊！你还是没搞明白中台，再回去研究！”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小M是我的一位读者，他是某大型国企的中台项目经理，今年的工作目标就是规划和落地中台项目。L总是该国企IT部的负责人，相当于CTO。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小M跟我吐槽了一个小时，我大概知道他们中台项目的问题所在了，先来听听小M公司上中台的故事。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6633333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sqibwUCydDhzLd7hhMrVTggQN9SbiasvsLGlc322Xx2pmCpQ6oyVWh6BChRctiaibhEreqY4qu5qamWUxtZJPicGpdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;01&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;云平台专家，初露锋芒&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小M之前一直从事企业信息化改革工作，帮助过几家公司实现了云化，积累了一定的项目经验。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;L总所在的企业，信息系统架构老旧，经过10几年的发展，形成了几十个大“烟囱”系统，数据的互联互通是难题，严重制约了业务的发展，让集团大领导非常不满。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如客服系统、BOSS系统（Business &amp;amp; Operation Support System），数据是不联通的，市场人员和客服人员工作难以协同，售后都跟不上，更不用说客户关系的主动维护了，这直接导致了客户流失率高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;于是L总聘用了小M，先是任命他为“基础资源整合”负责人，具体干什么呢？就是建云平台，把集团各部门的服务器、网络资源统一管理，提高硬件使用率，降低成本。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个事情，目标明确，又是小M经验所在，小M思路也很清晰：新系统全部上云，老旧系统改造迁移上云，实在无法改造迁云的系统，继续运行，但各部门得制定未来的业务升级计划，逐步实现业务迁云。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不到一年的时间就理顺了，L总对小M的工作表现非常满意，似乎觉得可以委以重任了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小M是个有理想的年轻人，他的理想就是三十岁的时候，在北京拥有一套自己的房子。现在他的理想已经实现一半了：他已经三十岁了。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;02&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;上中台：没吃过猪肉，还没薅过猪毛？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;去年年底的某一天，L总把小M叫到办公室。L总说，年底了，要提出明年的公司技术板块工作规划。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;L总认为，现在公司虽然做到了业务系统上云，实现了资源的统一调度、统一管理，但存在业务不通、业务架构老旧、重复建设等等很多问题，无法快速应对外部市场的变化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;L总经过调研，觉得现在热门的“数据中台”应该是公司技术架构改革的方向。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小M领的任务就是，规划和落地数据中台项目。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小M虽然一直在搞云计算，但是大数据这块，没吃过猪肉，也薅过猪毛。不敢说很懂，至少是略知一二吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;于是小M无知者无畏，接下了这个项目，赶紧开始学习，在百度上一查可把小M吓坏了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原来，A厂们提出的数据中台、AI中台、视频中台、技术中台、移动中台......新概念层出不穷、眼花缭乱。各种敏捷开发、快速响应、集约建设、沉淀能力，网上的噱头一个比一个闪瞎狗眼。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;于是，小M整合了几篇文章，给L总写了个整体思路，“明年，公司将构建数据中台，整合公司内外数据资源，打造公司新一代技术基础设施，实现公司技术升级，支撑好公司未来的内外业务……”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;L总看了这个规划，非常满意，认可小M的思路，正式把中台建设写入了2020年度规划里。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/sqibwUCydDhzLd7hhMrVTggQN9SbiasvsLHLeblZktPKCwo39Z3x9mTrI8CzicdtmORaw1575adPW0zfSlLOyiazlA/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;900&quot; data-cropy1=&quot;98.09688581314879&quot; data-cropy2=&quot;599.4809688581314&quot; data-ratio=&quot;0.5577777777777778&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/sqibwUCydDhzLd7hhMrVTggQN9SbiasvsL24mu30CHaLaufXAytaEmib57bWvynnHQ68Nbpc6kJJr3jT4fpW15gNg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;03&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;上中台吗？会送命的那种！&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小M又看了一些中台实施文章，咨询了A厂、T厂们的中台架构师，制定出详细的中台规划。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小M的报告指出，公司信息化存在的业务墙、数据墙、重复投资建设等问题，提出“三中台——数据中台、AI中台、视频中台”的技术架构。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;并提出几个推进机制：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、开展公司信息化资产盘点；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、研究公司发展战略规划、开展顶层设计；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、公司一把手牵头项目，各部门立军令状；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、制定里程碑：5月底完成调研，6月份完成方案设计，9月份前完成中台产品部署实施，年底前完成核心业务基于中台架构的改造。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;你闻到熟悉的味道了吗？&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小M初学中台，听信A厂的中台实施方法论套路，准备从顶层设计开始，盘点信息化资产，中台必须是一把手工程，得领导挂帅，中台急不得，是中长期战略......&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;L总不傻，把方案一棒子打死了：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“谁TM让你做顶层设计？老子都未必做得了顶层设计！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;还盘点资产？盘你老木，捅出篓子，我TM都未必兜得住。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一把手挂帅？中台干好了，是领导英明，干不好你就给老子滚蛋。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;什么中长期规划？我明年还在不在这个位子上，都不好说......”&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;04&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;没有中台的命，却得了中台的病&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;故事讲到这，其实这个项目的命运已经基本注定了，总结下来有那么几个原因：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;第一，中台实施缺乏场景&lt;/strong&gt;。小M正在发愁中台怎么落地，A厂的顾问给他承诺：“我们做的很多中台项目，都是基于一些具体的需求来构建的。例如，一些公司要做某几个系统的数据治理，一些公司要做某些新业务要上中台。只要有场景，我们一定能建好中台。”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可惜，小M不知道，供应商的承诺就像放屁，当时惊天动地，过后苍白无力。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小M跑遍了各业务部门，推销他的中台梦想，得到的答复是，“这不是找事情做吗？我们的系统，一点儿问题都没有！”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小M碰了一鼻子灰，回来给L总汇报，被L总一顿骂，“你去管那些业务部门的需求干什么？你先把中台搭建起来，就跟云一样！搭建起来后，后续我们不给他们批信息项目资金就可以了！”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在领导眼里，所有的问题都是人和钱的问题，没有人和钱搞不定的问题。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;第二，规划不充分、预算不足&lt;/strong&gt;。小M听L总的，赶紧和A厂、T厂的顾问商量，那就先搭建中台系统吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;于是，按照小M原先的三中台：数据中台、AI中台、视频中台的规划，让A厂、T厂拉了产品清单，报了产品价格。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;结果，A厂报了个上亿的价格，T厂好一点，才报了4000万。小M给L总汇报了下，L总冒火了：“我们是先行先试，不是要推翻全公司的技术设施！我们最多投资300万，先做出一些效果，落地一两个场景，再来推动后期建设！”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小M心想，L总也真是“节俭”，中台这么好一副牌，就押这么点注，即使赢了又有多大意思？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小M把情况跟A厂、T厂进行说明，看看能不能先按框架招标，再一步步实施。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;A厂、T厂行走江湖多年，一看就明白了，给不起钱呗，没钱TM不早说。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;于是，翻脸比翻书还快，这些顾问，突然都变得忙起来，电话也经常接不通了，微信、钉钉也不怎么回了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小M在技术世界里呆太久了，没被社会狠狠地毒打过。其实生活就是这样，一半是倒霉，别一半是如何处理倒霉。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小M自己不懂中台，项目预算还不够上个OA的，现在连供应商也不鸟他了，这还怎么玩啊？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;第三，中台建设的目标没搞清楚&lt;/strong&gt;。小M是正儿八经想操盘一把中台项目的，毕竟年轻的时候多吃点苦，到老了吃苦才会习惯。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可是L总不这么想，大家都是打工人，尤其是做到了他那么高职位，保住乌纱帽是最重要的，在此基础上如果能捞点油水，是最好的，其它都是扯淡。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小M就没有领悟到这一点，一上来就提出资产盘点、顶层设计，一点都不懂领导的意图，你不死谁死？&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;先不说它是个中台项目，但凡任何IT项目，有三个原则是要注意的：一，不要去折腾业务部门，要帮他们解决实际问题；二、花钱要花在看得见的地方，花小钱办大事；三、要尽可能争取更多干系人的支持，至少他们不反对。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这么看下来，中台项目要想“成功”，其实也不是那么难。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;第四，对中台的理解不在一个层面上&lt;/strong&gt;。L总看着小M负责的中台项目，半天嘣不出个屁来，于是自己琢磨起中台来了，L总是搞网络出身的，不懂研发，更不用说中台了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是宏观层面的理解是有的，经过研究后，L总给小M提出了中台建设的三个目标：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、让BOSS系统长在中台上&lt;/strong&gt;。公司的BOSS系统，十多年了，每年光是升级一点功能，都要几百万。中台要让BOSS系统接进来，以后BOSS的改造就用轻应用进行部署，每年只需要花几十万。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、用中台代替OA&lt;/strong&gt;。公司的OA系统不是很好用，要用这个中台来代替OA。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不得不佩服L总，“用中台代替OA”这个方案还是很有想象力的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、&lt;/strong&gt;&lt;strong&gt;用中台管理云、网络、业务系统&lt;/strong&gt;。这个中台要实现对公司云、网络、业务系统的统一运维。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;L总啊，人家可是个正经的中台，你把人家当什么了？（咦？这句话好像在哪里听过的样子）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;听到这里，小M已经崩溃了：这TM怎么搞啊。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6088888888888889&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sqibwUCydDhwCCIUY8bibBCSkQh5fm6U8rXBxHnmvLJflxyVfEG9hOTWJrYNqKsFsaDeib7KiaZplxaFx8ibtDe2IhA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;05&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;写在末尾的话&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此时的小M感到很无力，&lt;/span&gt;&lt;span&gt;公司就他一个人在推动这个所谓的中台项目，业务方不搭理他、项目预算少得可怜、A厂和T厂也越来越不愿意配合、L总又一直责怪他项目推动不力......&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;仿佛被套在一个死循环里，无从解脱。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;俗话说，当局者迷，旁观者清。希望通过以上梳理，能让小M看清这个项目的全貌。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;混职场的核心能力是什么？就是做局与破局的能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有些局哪怕输个精光，也要All in。有些局即使赢面很大，也要选择退出。究竟路要怎么走，只能自己选择了。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后，祝福小M。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;作者简介&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;strong&gt;&lt;span&gt;Mr.&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，知名电商公司技术老K级人物。文出过畅销书，&lt;span&gt;武做过CTO&lt;/span&gt;，若非生活所迫，谁愿一身才华。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt; -END- &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p yahei=&quot;yahei&quot; sans=&quot;sans&quot; px=&quot;px&quot; normal=&quot;normal&quot; ui=&quot;ui&quot; gb=&quot;gb&quot; sc=&quot;sc&quot; neue=&quot;neue&quot; important=&quot;important&quot; helvetica=&quot;helvetica&quot; break-word=&quot;break-word&quot; sans-serif=&quot;sans-serif&quot; arial=&quot;arial&quot; microsoft=&quot;microsoft&quot; hiragino=&quot;hiragino&quot; pingfang=&quot;pingfang&quot; center=&quot;center&quot;&gt;&lt;span&gt;这是公众号作者老K的私人微信&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;围观老K的朋友圈！席位珍贵，快来占坑&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sqibwUCydDhzulVBFYfrZrhGoJyXbiaTKb98oJqVAGibhprOVrjuVSkoASNHQYu9DahrrM96gVGp0GxcYglD5yJtw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;430&quot;/&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;大家在看：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5MjE3NDQ1Mw==&amp;amp;mid=2649711026&amp;amp;idx=1&amp;amp;sn=e49c1ecdcbd3dd54089d7bcc7ba8d4e8&amp;amp;chksm=886ae0a8bf1d69be984001bd3e9221d35a9506ad24f07d8eb65b9b9fa7d28d0184e42cb6f74e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;呼兰辞掉百万&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;呼兰辞掉百万年薪工作,去做脱口秀,有病吧？&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5MjE3NDQ1Mw==&amp;amp;mid=2649710803&amp;amp;idx=1&amp;amp;sn=ed243eb16f7cb3607489b2e2f15ed13d&amp;amp;chksm=886ae1c9bf1d68df2c356a27a631dbbc6522fb6932135af6d98d91591a9d2cf3122b4b3d6be9&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;35岁，总监，离职创业，赔了魔都一套房&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5MjE3NDQ1Mw==&amp;amp;mid=2649710250&amp;amp;idx=1&amp;amp;sn=3b2bc771325ea94e78d2a5b21a4a9e8c&amp;amp;chksm=886adfb0bf1d56a6f00a4daf904ceced855c456b7db69f1569d62b7b95a5623221f55c43e36f&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;张一鸣：成功的反义词不是失败，而是平庸！&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;.&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5MjE3NDQ1Mw==&amp;amp;mid=2649711005&amp;amp;idx=1&amp;amp;sn=fa7b21ab73ae119a6ee782fcfbbc384f&amp;amp;chksm=886ae087bf1d6991cde50210a496f66c9f8fb626286a2b71fa37410dd580d90de364ec6398e0&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;阿里彭蕾：向上管理的最高境界，不是跪舔&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;.&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5MjE3NDQ1Mw==&amp;amp;mid=2649710978&amp;amp;idx=1&amp;amp;sn=073da9859691d43a4073aa36d19463d9&amp;amp;chksm=886ae098bf1d698eb74a7b164bc6040dad63a54720bdd01958e60b6d98e3815c6c08cd5d368f&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;中台为什么做不好？拆系统“烟囱”容易...&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0f0282e6a17f645fe4117251eccc9c51</guid>
<title>还不了解 Etcd？一文带你快速入门</title>
<link>https://toutiao.io/k/1eysos2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;br/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2018年12月 etcd 作为孵化项目 CNCF（云原生计算基金会），几天前 CNCF 宣布 etcd 正式毕业，成为 CNCF 顶级项目。CNCF 官方表示 etcd 项目的采用率持续增加，也有稳定的治理流程，功能已达一定成熟度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcd 已经被许多公司用于实际生产，其中包括亚马逊、百度、思科、EMC、谷歌、阿里、华为、IBM、Red Hat、Uber、Verizon 等；而且其身影也出现在包括 Kubernetes、CoreDNS、M3、Rook 以及 TiKV 等项目当中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面的系列 etcd 文章已经部分介绍了 etcd。本文将会做一个快速入门的介绍，带领大家十分钟快速入门云原生存储组件 etcd，主要内容如下（本文较长，建议收藏）：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;etcd 简介，以及其应用场景&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;etcd 的多种安装模式及高可用运维&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;etcd v3 的架构解析&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;etcdctl 的实践应用&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1 etcd 介绍&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2013 年 6 月，CoreOS 发起了 etcd 项目。etcd 使用 Go 语言实现，是分布式系统中重要的基础组件，目前最新版本为 V3.4.9。etcd 可以用来构建高可用的分布式键值数据库，根据官网介绍，总结来说有如下的特点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;简单：etcd 的安装简单，且为用户提供了 HTTP API，用户使用起来也很简单&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;存储：etcd 的基本功能，数据分层存储在文件目录中，类似于我们日常使用的文件系统&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Watch 机制：Watch 指定的键、前缀目录的更改，并对更改时间进行通知&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;安全通信：SSL 证书验证&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;高性能：etcd 单实例可以支持 2k/s 读操作，官方也有提供基准测试脚本&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一致可靠：基于 Raft 共识算法，实现分布式系统数据的高可用性、一致性&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0248447204968945&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Pd1oo3TBKydx40t8fXvNTX1kRLrVv0ywsTpNHBDlkYS462TzZqrzLgicUytQdIpSI8MJLtdtgWmaicsAh122D5mA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;322&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcd 是一个分布式键值存储数据库，支持跨平台，拥有强大的社区。etcd 的 Raft 算法，提供了可靠的方式存储分布式集群涉及的数据。etcd 广泛应用在微服务架构和 Kubernates 集群中，不仅可以作为服务注册与发现，还可以作为键值对存储的中间件。从业务系统 Web 到 Kubernetes 集群，都可以很方便地从 etcd 中读取、写入数据。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2 etcd 应用场景&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcd 在&lt;strong&gt;稳定性、可靠性和可伸缩性&lt;/strong&gt;表现极佳，同时也为云原生应用系统提供了协调机制。etcd 经常用于服务注册与发现的场景，此外还有键值对存储、消息发布与订阅、分布式锁等场景。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 键值对存储&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下是官方对 etcd 的描述：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;A highly-available key value store for shared configuration and service discovery.&lt;br/&gt;一个用于配置共享和服务发现的键值存储系统。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从其定义来看，etcd 是一个&lt;strong&gt;「键值存储」&lt;/strong&gt;的组件，存储是 etcd 最基本的功能，其他应用场景都是建立在 etcd 的可靠存储上。etcd 的存储有如下特点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;采用键值对数据存储，读写性能一般高于关系型数据库；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;etcd 集群分布式存储，多节点集群更加可靠；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;etcd 的存储采用类似文件目录的结构：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;叶子节点存储数据，其他节点不存储，这些数据相当于文件；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;非叶节点一定是目录，这些节点不能存储数据。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如 Kubernetes 将一些元数据存储在 etcd 中，将存储状态数据的的复杂工作交给 etcd，Kubernetes 自身的功能和架构能够更加专注。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 服务注册与发现&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分布式环境中，业务服务多实例部署，这个时候涉及到服务之间调用，就不能简单使用硬编码的方式指定服务实例信息。服务注册与发现就是解决如何找到分布式集群中的某一个服务（进程），并与之建立联系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务注册与发现涉及三个主要的角色：服务请求者、服务提供者和服务注册中心。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6691358024691358&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Pd1oo3TBKydx40t8fXvNTX1kRLrVv0ywtyhP6jGDcEnHG222odggENE7R7S6Yr9x5MPXf5WEKAPZX1aTAdPATA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;405&quot;/&gt;&lt;figcaption&gt;三大支柱&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务提供者启动的时候，在服务注册中心进行注册自己的服务名、主机地址、端口等信息；服务请求者需要调用对应的服务时，一般通过服务名请求服务注册中心，服务注册中心返回对应的实例地址和端口；服务请求者获取到实例地址、端口之后，绑定对应的服务提供者，实现远程调用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcd 基于 Raft 算法，能够有力地保证分布式场景中的一致性。各个服务启动时注册到 etcd 上，同时为这些服务配置键的 TTL 时间，定时保持服务的心跳以达到监控健康状态的效果。通过在 etcd 指定的主题下注册的服务也能在对应的主题下查找到。为了确保连接，我们可以在每个服务机器上都部署一个 Proxy 模式的 etcd，这样就可以确保访问 etcd 集群的服务都能够互相连接。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3 消息发布与订阅&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在分布式系统中，服务之间还可以通过消息通信，即消息的发布与订阅。通过构建一个消息中间件，服务提供者发布对应主题的消息，而消费者则订阅他们关心的主题，一旦对应的主题有消息发布，即会产生订阅事件，消息中间件就会通知该主题所有的订阅者。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6136783733826248&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Pd1oo3TBKydx40t8fXvNTX1kRLrVv0ywbSzxT7vujaTkd9FejeeUTXqMhNORYwglYwk81W2hyI4mw9TBROgejQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;541&quot;/&gt;如微服务架构中的认证鉴权服务，Auth 服务的实例地址、端口和实例节点的状态存放在 etcd 中，客户端应用订阅对应的主题，而 etcd 设置 key TTL 可以确保存储的服务实例的健康状态。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.4 分布式锁&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分布式系统中涉及到多个服务实例，存在跨进程之间资源调用，对于资源的协调分配，单体架构中的锁已经无法满足需要，需要引入分布式锁的概念。分布式锁可以将资源标记存储，这里的存储不是单纯属于某个进程，而是公共存储，诸如 Redis、Memcache、关系型数据库、文件等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcd 基于 Raft 算法，实现分布式集群的一致性，存储到 etcd 集群中的值必然是全局一致的，因此基于 etcd 很容易实现分布式锁。分布式锁有两种使用方式：保持独占和控制时序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.47643979057591623&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Pd1oo3TBKydx40t8fXvNTX1kRLrVv0yw19XsjYrgl5RiacwZSbibMFRGxRibxpwbremVQKYLNqy5IhKG6SGR6Wh9g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;382&quot;/&gt;保持独占，从字面可以知道，所有获取资源的请求，只有一个成功。etcd 通过分布式锁原子操作 CAS 的 API，设置 prevExist 值，从而保证在多个节点同时去创建某个目录时，最后只有一个成功，创建成功的请求获取到锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;控制时序，有点类似于队列缓冲，所有的请求都会被安排分配资源，但是获得锁的顺序也是全局唯一的，执行按照先后的顺序。etcd 提供了一套自动创建有序键的 API，对一个目录的建值操作，这样 etcd 会自动生成一个当前最大的值为键，并存储该值。同时还可以使用 API 按顺序列出当前目录下的所有键值。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3 etcd 的多种安装方法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcd 的安装非常简单，我们在本小节实践 etcd 单机和集群的几种安装方式。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1 etcd 概念词汇表&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下文的安装实践可能会涉及到 etcd 相关的概念词汇，因此我们首先了解下 etcd 的概念词汇表，以便于下文的理解。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Raft：分布式一致性算法；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Node：Raft 状态机实例；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Member：管理着 Node 的 etcd 实例，为客户端请求提供服务；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Cluster：etcd 集群，由多个 Member 构成；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Peer：同一个 etcd 集群中的另一个 Member；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Client：客户端，向 etcd 发送 HTTP 请求；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;WAL：持久化存储的日志格式，预写式日志；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Snapshot：etcd 数据快照，防止 WAL 文件过多而设置的快照。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在了解了 etcd 的常用术语之后，我们下面开始介绍 etcd v3 的架构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcd 的安装有多种方式，笔者以 Centos 7 和 MacOS 10.15 为例，可以通过 &lt;code&gt;yum install etcd&lt;/code&gt; 和 &lt;code&gt;brew install etcd&lt;/code&gt;进行安装。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然而通过系统工具安装的 etcd 版本比较滞后，如果需要安装最新版本的 etcd ，我们可以通过二进制包、源码编译以及 docker 容器安装。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2 etcd 单机安装部署&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcd 的安装有多种方式，笔者以 Centos 7 和 MacOS 10.15 为例，可以通过 &lt;code&gt;yum install etcd&lt;/code&gt; 和 &lt;code&gt;brew install etcd&lt;/code&gt;进行安装。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然而通过系统工具安装的 etcd 版本比较滞后，如果需要安装最新版本的 etcd ，我们可以通过二进制包、源码编译以及 docker 容器安装。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2.1 二进制安装&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 macOS 下，安装 3.4.5，指定 etcd 版本，执行如下的脚本：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ETCD_VER=v3.4.5&lt;br/&gt;GITHUB_URL=https://github.com/etcd-io/etcd/releases/download&lt;br/&gt;DOWNLOAD_URL=&lt;span&gt;${GITHUB_URL}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;rm -f /tmp/etcd-&lt;span&gt;${ETCD_VER}&lt;/span&gt;-darwin-amd64.zip&lt;br/&gt;rm -rf /tmp/etcd-download-test &amp;amp;&amp;amp; mkdir -p /tmp/etcd-download-test&lt;br/&gt;&lt;br/&gt;curl -L &lt;span&gt;${DOWNLOAD_URL}&lt;/span&gt;/&lt;span&gt;${ETCD_VER}&lt;/span&gt;/etcd-&lt;span&gt;${ETCD_VER}&lt;/span&gt;-darwin-amd64.zip -o /tmp/etcd-&lt;span&gt;${ETCD_VER}&lt;/span&gt;-darwin-amd64.zip&lt;br/&gt;unzip /tmp/etcd-&lt;span&gt;${ETCD_VER}&lt;/span&gt;-darwin-amd64.zip -d /tmp &amp;amp;&amp;amp; rm -f /tmp/etcd-&lt;span&gt;${ETCD_VER}&lt;/span&gt;-darwin-amd64.zip&lt;br/&gt;mv /tmp/etcd-&lt;span&gt;${ETCD_VER}&lt;/span&gt;-darwin-amd64/* /tmp/etcd-download-test &amp;amp;&amp;amp; rm -rf mv /tmp/etcd-&lt;span&gt;${ETCD_VER}&lt;/span&gt;-darwin-amd64&lt;br/&gt;&lt;br/&gt;/tmp/etcd-download-test/etcd --version&lt;br/&gt;/tmp/etcd-download-test/etcdctl version&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行完上面的脚本，控制台即可输出如下的结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;etcd Version: 3.4.5&lt;br/&gt;Git SHA: c65a9e2dd&lt;br/&gt;Go Version: go1.12.12&lt;br/&gt;Go OS/Arch: darwin/amd64&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据控制台的显示，etcd 安装成功，版本为 etcd 3.4.5，基于的 Go 语言版本为 &lt;code&gt;1.12.12&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Linux 上的操作也类似，Centos 7 系统执行的脚本可以参考 etcd 官方提供的脚本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在这一小节演示了单机 etcd 在 macOS 和 Linux 上的安装。etcd 在 Windows 系统的安装比较简单，下载可执行文件，其中 etcd.exe 是 etcd Server，etcdctl.exe 命令行工具。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2527881040892193&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Pd1oo3TBKydx40t8fXvNTX1kRLrVv0ywg8gYnklsYCOdLwTNnc4Bb48s2iaWXT985U5ll1xNJO1441pGT3iaj4eg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1076&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2.2 源码安装&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于那些想尝试最新版本的同学，可以从 master 分支构建 etcd。使用源码安装，首先需要确保本地的 Go 语言环境。如未安装，请参考 https://golang.org/doc/install。需要 Go 版本为 1.13+，来构建最新版本的 etcd。本地的 Go 版本为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ go version&lt;br/&gt;&lt;br/&gt;go version go1.14.2 darwin/amd64&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于 master 分支构建 etcd，脚本如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;git &lt;span&gt;clone&lt;/span&gt; https://github.com/etcd-io/etcd.git&lt;br/&gt;&lt;span&gt;cd&lt;/span&gt; etcd&lt;br/&gt;./build&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安装完记得执行测试命令，确保 etcd 源码编译安装成功。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3 etcd 集群部署&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcd 是分布式环境中重要的中间件，一般在生产环境不会单节点部署 etcd，为了 etcd 的高可用，避免单点故障，etcd 通常都是集群部署。本小节将会介绍如何进行 etcd 集群部署。引导 etcd 集群的启动有以下三种方式：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;静态指定的方式需要事先知道集群中的所有节点。在许多情况下，群集成员的信息是动态生成。这种情况下，可以在动态发现服务的帮助下启动 etcd 群集。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们将会分别介绍这几种方式。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3.1 静态方式启动 etcd 集群&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想要在一台机器上实践 etcd 集群的搭建，可以通过 goreman 工具。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;goreman 是一个 Go 语言编写的多进程管理工具，是对 Ruby 下广泛使用的 foreman 的重写（foreman 原作者也实现了一个 Go 版本：forego，不过没有 goreman 好用）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们需要确认 Go 安装环境，然后直接执行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go get github.com/mattn/goreman&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译后的文件放在 &lt;code&gt;$GOPATH/bin&lt;/code&gt; 中，&lt;code&gt;$GOPATH/bin&lt;/code&gt;目录已经添加到了系统 &lt;code&gt;$PATH&lt;/code&gt; 中，所以我们可以方便执行命令 &lt;code&gt;goreman&lt;/code&gt; 命令。下面就是编写 Procfile 脚本，我们启动三个 etcd，具体对应如下：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;HostName&lt;/th&gt;&lt;th&gt;ip&lt;/th&gt;&lt;th&gt;客户端交互端口&lt;/th&gt;&lt;th&gt;peer 通信端口&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;infra1&lt;/td&gt;&lt;td&gt;127.0.0.1&lt;/td&gt;&lt;td&gt;2379&lt;/td&gt;&lt;td&gt;2380&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;infra2&lt;/td&gt;&lt;td&gt;127.0.0.1&lt;/td&gt;&lt;td&gt;22379&lt;/td&gt;&lt;td&gt;22380&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;infra3&lt;/td&gt;&lt;td&gt;127.0.0.1&lt;/td&gt;&lt;td&gt;32379&lt;/td&gt;&lt;td&gt;32380&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Procfile 脚本如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.16595289079229122&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Pd1oo3TBKydx40t8fXvNTX1kRLrVv0ywHibFykd6OQXzRfAG5OaQehKdHajA6M396UXswNiayUq37tpapy10Nhsg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1868&quot;/&gt;其他两个 etcd 成员的配置类似，不在赘述。配置项说明如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;--name：etcd 集群中的节点名；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;--listen-peer-urls：用于节点之间通信的地址，可以监听多个；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;--initial-advertise-peer-urls：与其他节点之间通信的地址；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;--listen-client-urls：监听客户端通信的地址，可以有多个；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;--advertise-client-urls：用于客户端与节点通信的地址；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;--initial-cluster-token：标识不同 etcd 集群的 token；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;--initial-cluster：即指定的 initial-advertise-peer-urls 的所有节点；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;--initial-cluster-state：new，新建集群的标志。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意上面的脚本，etcd 命令执行时需要根据本地实际的安装地址进行配置。下面我们启动 etcd 集群。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;goreman -f /opt/procfile start&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用如上的命令启动启动 etcd 集群，启动完成之后查看集群内的成员。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ etcdctl --endpoints=http://localhost:22379  member list&lt;br/&gt;&lt;br/&gt;8211f1d0f64f3269, started, infra1, http://127.0.0.1:12380, http://127.0.0.1:12379, &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;91bc3c398fb3c146, started, infra2, http://127.0.0.1:22380, http://127.0.0.1:22379, &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;fd422379fda50e48, started, infra3, http://127.0.0.1:32380, http://127.0.0.1:32379, &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在单机搭建的伪集群成功，需要注意的是在集群启动时，我们通过静态的方式指定集群的成员，在实际环境中，集群成员的地址端口等信息可能不会事先知道。这时候就需要采用动态发现的机制。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3.2 docker 启动集群&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcd 使用 gcr.io/etcd-development/etcd 作为容器的主要加速器， quay.io/coreos/etcd 作为辅助的加速器。可惜这两个加速器我们都没法访问，如果下载不了，可以使用笔者提供的地址：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;docker pull bitnami/etcd:3.4.7&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后将拉取的镜像重新 tag：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;docker image tag bitnami/etcd:3.4.7 quay.io/coreos/etcd:3.4.7&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;镜像设置好之后，我们启动 3 个节点的 etcd 集群，脚本命令如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;REGISTRY=quay.io/coreos/etcd&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# For each machine&lt;/span&gt;&lt;br/&gt;ETCD_VERSION=3.4.5&lt;br/&gt;TOKEN=my-etcd-token&lt;br/&gt;CLUSTER_STATE=new&lt;br/&gt;NAME_1=etcd-node-0&lt;br/&gt;NAME_2=etcd-node-1&lt;br/&gt;NAME_3=etcd-node-2&lt;br/&gt;HOST_1= 192.168.202.128&lt;br/&gt;HOST_2= 192.168.202.129&lt;br/&gt;HOST_3= 192.168.202.130&lt;br/&gt;CLUSTER=&lt;span&gt;${NAME_1}&lt;/span&gt;=http://&lt;span&gt;${HOST_1}&lt;/span&gt;:2380,&lt;span&gt;${NAME_2}&lt;/span&gt;=http://&lt;span&gt;${HOST_2}&lt;/span&gt;:2380,&lt;span&gt;${NAME_3}&lt;/span&gt;=http://&lt;span&gt;${HOST_3}&lt;/span&gt;:2380&lt;br/&gt;DATA_DIR=/var/lib/etcd&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# For node 1&lt;/span&gt;&lt;br/&gt;THIS_NAME=&lt;span&gt;${NAME_1}&lt;/span&gt;&lt;br/&gt;THIS_IP=&lt;span&gt;${HOST_1}&lt;/span&gt;&lt;br/&gt;docker run \&lt;br/&gt;  -p 2379:2379 \&lt;br/&gt;  -p 2380:2380 \&lt;br/&gt;  --volume=&lt;span&gt;${DATA_DIR}&lt;/span&gt;:/etcd-data \&lt;br/&gt;  --name etcd &lt;span&gt;${REGISTRY}&lt;/span&gt;:&lt;span&gt;${ETCD_VERSION}&lt;/span&gt; \&lt;br/&gt;  /usr/&lt;span&gt;local&lt;/span&gt;/bin/etcd \&lt;br/&gt;  --data-dir=/etcd-data --name &lt;span&gt;${THIS_NAME}&lt;/span&gt; \&lt;br/&gt;  --initial-advertise-peer-urls http://&lt;span&gt;${THIS_IP}&lt;/span&gt;:2380 --listen-peer-urls http://0.0.0.0:2380 \&lt;br/&gt;  --advertise-client-urls http://&lt;span&gt;${THIS_IP}&lt;/span&gt;:2379 --listen-client-urls http://0.0.0.0:2379 \&lt;br/&gt;  --initial-cluster &lt;span&gt;${CLUSTER}&lt;/span&gt; \&lt;br/&gt;  --initial-cluster-state &lt;span&gt;${CLUSTER_STATE}&lt;/span&gt; --initial-cluster-token &lt;span&gt;${TOKEN}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# For node 2&lt;/span&gt;&lt;br/&gt;THIS_NAME=&lt;span&gt;${NAME_2}&lt;/span&gt;&lt;br/&gt;THIS_IP=&lt;span&gt;${HOST_2}&lt;/span&gt;&lt;br/&gt;docker run \&lt;br/&gt;  -p 2379:2379 \&lt;br/&gt;  -p 2380:2380 \&lt;br/&gt;  --volume=&lt;span&gt;${DATA_DIR}&lt;/span&gt;:/etcd-data \&lt;br/&gt;  --name etcd &lt;span&gt;${REGISTRY}&lt;/span&gt;:&lt;span&gt;${ETCD_VERSION}&lt;/span&gt; \&lt;br/&gt;  /usr/&lt;span&gt;local&lt;/span&gt;/bin/etcd \&lt;br/&gt;  --data-dir=/etcd-data --name &lt;span&gt;${THIS_NAME}&lt;/span&gt; \&lt;br/&gt;  --initial-advertise-peer-urls http://&lt;span&gt;${THIS_IP}&lt;/span&gt;:2380 --listen-peer-urls http://0.0.0.0:2380 \&lt;br/&gt;  --advertise-client-urls http://&lt;span&gt;${THIS_IP}&lt;/span&gt;:2379 --listen-client-urls http://0.0.0.0:2379 \&lt;br/&gt;  --initial-cluster &lt;span&gt;${CLUSTER}&lt;/span&gt; \&lt;br/&gt;  --initial-cluster-state &lt;span&gt;${CLUSTER_STATE}&lt;/span&gt; --initial-cluster-token &lt;span&gt;${TOKEN}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# For node 3&lt;/span&gt;&lt;br/&gt;THIS_NAME=&lt;span&gt;${NAME_3}&lt;/span&gt;&lt;br/&gt;THIS_IP=&lt;span&gt;${HOST_3}&lt;/span&gt;&lt;br/&gt;docker run \&lt;br/&gt;  -p 2379:2379 \&lt;br/&gt;  -p 2380:2380 \&lt;br/&gt;  --volume=&lt;span&gt;${DATA_DIR}&lt;/span&gt;:/etcd-data \&lt;br/&gt;  --name etcd &lt;span&gt;${REGISTRY}&lt;/span&gt;:&lt;span&gt;${ETCD_VERSION}&lt;/span&gt; \&lt;br/&gt;  /usr/&lt;span&gt;local&lt;/span&gt;/bin/etcd \&lt;br/&gt;  --data-dir=/etcd-data --name &lt;span&gt;${THIS_NAME}&lt;/span&gt; \&lt;br/&gt;  --initial-advertise-peer-urls http://&lt;span&gt;${THIS_IP}&lt;/span&gt;:2380 --listen-peer-urls http://0.0.0.0:2380 \&lt;br/&gt;  --advertise-client-urls http://&lt;span&gt;${THIS_IP}&lt;/span&gt;:2379 --listen-client-urls http://0.0.0.0:2379 \&lt;br/&gt;  --initial-cluster &lt;span&gt;${CLUSTER}&lt;/span&gt; \&lt;br/&gt;  --initial-cluster-state &lt;span&gt;${CLUSTER_STATE}&lt;/span&gt; --initial-cluster-token &lt;span&gt;${TOKEN}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意，上面的脚本是部署在三台机器上面，每台机器执行对应的脚本即可。在运行时可以指定 API 版本：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;docker &lt;span&gt;exec&lt;/span&gt; etcd /bin/sh -c &lt;span&gt;&quot;export ETCDCTL_API=3 &amp;amp;&amp;amp; /usr/local/bin/etcdctl put foo bar&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;docker 的安装方式比较简单，读者根据需要可以定制一些配置。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.4 动态发现启动 etcd 集群&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在大部分的情况下，集群成员的地址端口号等信息，并不会提前知道。在这种情况下，需要使用自动发现来引导 etcd 集群，而不是指定静态配置，这个过程被称为&lt;strong&gt;「发现」&lt;/strong&gt;。我们启动三个 etcd，具体对应如下：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;HostName&lt;/th&gt;&lt;th&gt;ip&lt;/th&gt;&lt;th&gt;客户端交互端口&lt;/th&gt;&lt;th&gt;peer 通信端口&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;etcd1&lt;/td&gt;&lt;td&gt;192.168.202.128&lt;/td&gt;&lt;td&gt;2379&lt;/td&gt;&lt;td&gt;2380&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;etcd2&lt;/td&gt;&lt;td&gt;192.168.202.129&lt;/td&gt;&lt;td&gt;2379&lt;/td&gt;&lt;td&gt;2380&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;etcd3&lt;/td&gt;&lt;td&gt;192.168.202.130&lt;/td&gt;&lt;td&gt;2379&lt;/td&gt;&lt;td&gt;2380&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.4.1 协议的原理&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于 Discovery Service Protocol ，新的 etcd 节点加入时，使用共享 URL 在启动阶段发现集群中的其它成员。需要注意的是，发现协议仅在集群启动阶段生效，不能用于其它阶段。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这其中涉及到发现令牌，用来标识唯一的 etcd 集群。一个发现令牌只能代表一个 etcd 集群。只要此令牌上的发现协议启动，即使启动失败，也不能用于引导其他的 etcd 集群。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所有 etcd 节点都与发现服务通信，并生成集群成员列表。随后每个新节点使用此列表启动服务，该列表与 &lt;code&gt;--initial-cluster&lt;/code&gt; 选项具有相同的功能，用以设置集群的成员信息。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.4.2 获取 discovery 的 token&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生成将标识新集群的唯一令牌。在以下步骤中，它将用作发现键空间中的唯一前缀。一种简单的方法是使用 uuidgen，我们运行之后的结果为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ uuidgen&lt;br/&gt;&lt;br/&gt;9CBAF7C8-123B-4E72-89C9-F81E4BC5F173&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.4.3 指定集群的大小&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;获取令牌时，必须指定群集大小。发现服务使用该大小来了解何时发现了最初将组成集群的所有成员。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;curl -X PUT http://10.0.10.10:2379/v2/keys/discovery/9CBAF7C8-123B-4E72-89C9-F81E4BC5F173/_config/size -d value=3&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们需要把该 url 地址 http://10.0.10.10:2379/v2/keys/discovery/9CBAF7C8-123B-4E72-89C9-F81E4BC5F173 作为 &lt;code&gt;--discovery&lt;/code&gt; 参数来启动 etcd。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;节点会自动使用 http://10.0.10.10:2379/v2/keys/discovery/9CBAF7C8-123B-4E72-89C9-F81E4BC5F173 目录进行 etcd 的注册和发现服务。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.4.4 公共发现服务&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们没有可用的本地 etcd 集群，则可以使用 etcd 官方提供的公共访问的 etcd 集群地址。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;公共发现服务 &lt;code&gt;discovery.etcd.io&lt;/code&gt; 以相同的方式工作，但是有一层修饰，可以提取丑陋的 URL，自动生成 UUID，并提供针对过多请求的保护。公共发现服务在其上仍然使用 etcd 群集作为数据存储。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ curl http://discovery.etcd.io/new?size=3&lt;br/&gt;&lt;br/&gt;http://discovery.etcd.io/3e86b59982e49066c5d813af1c2e2579cbf573de&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.4.5 以动态发现方式启动集群&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcd 发现模式下，启动 etcd 的命令如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# etcd1 启动&lt;/span&gt;&lt;br/&gt;$ /opt/etcd/bin/etcd  --name etcd1 --initial-advertise-peer-urls http://192.168.202.128:2380 \&lt;br/&gt;  --listen-peer-urls http://192.168.202.128:2380 \&lt;br/&gt;  --data-dir /opt/etcd/data \&lt;br/&gt;  --listen-client-urls http://192.168.202.128:2379,http://127.0.0.1:2379 \&lt;br/&gt;  --advertise-client-urls http://192.168.202.128:2379 \&lt;br/&gt;  --discovery https://discovery.etcd.io/3e86b59982e49066c5d813af1c2e2579cbf573de&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# etcd2 启动&lt;/span&gt;&lt;br/&gt; /opt/etcd/bin/etcd  --name etcd2 --initial-advertise-peer-urls http://192.168.202.129:2380 \&lt;br/&gt;  --listen-peer-urls http://192.168.202.129:2380 \&lt;br/&gt;  --data-dir /opt/etcd/data \&lt;br/&gt;  --listen-client-urls http://192.168.202.129:2379,http://127.0.0.1:2379 \&lt;br/&gt;  --advertise-client-urls http://192.168.202.129:2379 \&lt;br/&gt;  --discovery https://discovery.etcd.io/3e86b59982e49066c5d813af1c2e2579cbf573de&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# etcd3 启动&lt;/span&gt;&lt;br/&gt; /opt/etcd/bin/etcd  --name etcd3 --initial-advertise-peer-urls http://192.168.202.130:2380 \&lt;br/&gt;    --listen-peer-urls http://192.168.202.130:2380 \&lt;br/&gt;    --data-dir /opt/etcd/data \&lt;br/&gt;    --listen-client-urls http://192.168.202.130:2379,http://127.0.0.1:2379 \&lt;br/&gt;    --advertise-client-urls http://192.168.202.130:2379 \&lt;br/&gt;    --discovery https://discovery.etcd.io/3e86b59982e49066c5d813af1c2e2579cbf573de&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在每次启动新 etcd 集群时，使用新的 discovery token 进行注册。如果初始化启动的节点超过了请求 token 时指定的数量，则多的节点会自动转为 Proxy 模式的 etcd。需要注意的是，在我们完成了集群的初始化后，这些信息就失去了作用。当需要增加节点时，需要使用 etcdctl 进行操作。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.4.6 结果验证&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;集群启动好之后，进行验证，我们看一下集群的成员：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ /opt/etcd/bin/etcdctl member list&lt;br/&gt;&lt;span&gt;# 结果如下&lt;/span&gt;&lt;br/&gt;    40e2ac06ca1674a7, started, etcd3, http://192.168.202.130:2380, http://192.168.202.130:2379, &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;    c532c5cedfe84d3c, started, etcd1, http://192.168.202.128:2380, http://192.168.202.128:2379, &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;    db75d3022049742a, started, etcd2, http://192.168.202.129:2380, http://192.168.202.129:2379, &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.17967914438502675&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Pd1oo3TBKydx40t8fXvNTX1kRLrVv0ywX63KhmeRNx6lUj71icr2YqFm5V95k5TnTRk71A4AOnaxHy1Twvk7ErA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;935&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，集群中的三个节点都是健康的正常状态。以动态发现方式启动集群成功。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4 etcd v3 的架构解析&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcd v2 和 v3 在底层使用同一套 Raft 算法的两个独立应用，相互之间接口不一样、存储不一样，两个版本的数据互相隔离。由 etcd v2 升级到 etcd v3 的情况下，原有数据只能通过 etcd v2 接口访问，v3 接口创建的数据只能通过 新的 v3 的接口访问。本文重点讲解 v3 版本。etcd 总体的架构图如下所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5249569707401033&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Pd1oo3TBKydx40t8fXvNTX1kRLrVv0ywzzcibpSjVuTsTxg91stCUuDBEiaW5ZO3ibvKV1fgALcnlxLFHOvumribSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;581&quot;/&gt;分布式集群一般由奇数个节点组成，etcd 同样也是，多个 etcd 节点通过 Raft 算法相互协作。Raft 算法会选择一个主节点作为 Leader，负责数据同步和分发。当 Leader 发生故障时，系统会自动选择另一个节点作为 Leader，以再次完成数据同步。当 etcd 完成内部状态和数据协作时，仅需选择一个节点即可读取和写入数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Quorum（翻译成法定人数，简单理解为定义一个最少写入同步到多少个节点才算成功写入）机制是 etcd 中的关键概念。它定义为 (n + 1)/2，表示群集中超过一半的节点构成 Quorum。在三节点集群中，只要有两个节点可用，etcd 仍将运行。同样，在五节点集群中，只要有三个节点可用，etcd 仍会运行。这是 etcd 群集高可用性的关键。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了使 etcd 在某些节点出现故障后继续运行，必须解决分布式一致性问题。在 etcd 中，分布式共识算法由 Raft 实现。下面简要描述该算法。Raft 共识算法仅在任何两个 Quorum 具有共享成员时才可以工作。也就是说，任何有效的仲裁必须包含一个共享成员，该成员包含集群中所有已确认和已提交的数据。基于此，etcd 为 Raft 共识算法设计了一种数据同步机制，用于在更新 Leader 后同步最后 Quorum 所提交的所有数据。这样可以确保在群集状态更改时数据的一致性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4169139465875371&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Pd1oo3TBKydx40t8fXvNTX1kRLrVv0yw2HtvpibGaTdnu8bBQoIQo6jDP0bukY1kibtZ8wWseqnvR6ibaNdsZ9u3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;674&quot;/&gt;etcd 具有复杂的内部机制，但为客户端提供了简单直接的 API。如上图所示，我们可以通过 etcd 客户端访问群集数据，或通过 HTTP 直接访问 etcd，这与 curl 命令类似。etcd 中的数据结构很简单，我们可以将 etcd 的数据存储理解为存储键值数据的有序映射。etcd 还提供了一种 Watch 机制来为客户端订阅数据更改的事件。Watch 机制实时获取 etcd 中的增量数据更新，以使数据与 etcd 同步。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5 etcdctl 的实践应用&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcdctl 是 etcd 的命令行客户端，用户通过 etcdctl 直接跟 etcd 进行交互，可以实现 HTTP API 的功能。在测试阶段，etcdctl 可以方便对服务进行操作或更新数据库内容。对于刚入门的同学，建议通过 etdctl 来熟悉 etcd 相关操作。需要注意的是，etcdctl 在两个不同的 etcd 版本下的行为方式也完全不同。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; ETCDCTL_API=2&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; ETCDCTL_API=3&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里主要以讲解 API 3 为主。etcdctl 的命令分为数据库和非数据库两类操作。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.1 常用命令介绍&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先查看一下 etcd 的版本：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ etcd --version&lt;br/&gt;&lt;br/&gt;etcd Version: 3.4.7&lt;br/&gt;Git SHA: e784ba73c&lt;br/&gt;Go Version: go1.12.12&lt;br/&gt;Go OS/Arch: linux/amd64&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的版本是 etcd 3.4.7 ，下面介绍下 etcdctl 常用的命令。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ etcdctl -h&lt;br/&gt;&lt;br/&gt;NAME:&lt;br/&gt; etcdctl - A simple &lt;span&gt;command&lt;/span&gt; line client &lt;span&gt;for&lt;/span&gt; etcd3.&lt;br/&gt;&lt;br/&gt;USAGE:&lt;br/&gt; etcdctl [flags]&lt;br/&gt;&lt;br/&gt;VERSION:&lt;br/&gt; 3.4.7&lt;br/&gt;&lt;br/&gt;API VERSION:&lt;br/&gt; 3.4&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;COMMANDS:&lt;br/&gt; alarm disarm  Disarms all alarms&lt;br/&gt; alarm list  Lists all alarms&lt;br/&gt; auth &lt;span&gt;disable&lt;/span&gt;  Disables authentication&lt;br/&gt; auth &lt;span&gt;enable&lt;/span&gt;  Enables authentication&lt;br/&gt; check datascale  Check the memory usage of holding data &lt;span&gt;for&lt;/span&gt; different workloads on a given server endpoint.&lt;br/&gt; check perf  Check the performance of the etcd cluster&lt;br/&gt; compaction  Compacts the event &lt;span&gt;history&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; etcd&lt;br/&gt; defrag   Defragments the storage of the etcd members with given endpoints&lt;br/&gt; del   Removes the specified key or range of keys [key, range_end)&lt;br/&gt; elect   Observes and participates &lt;span&gt;in&lt;/span&gt; leader election&lt;br/&gt; endpoint hashkv  Prints the KV &lt;span&gt;history&lt;/span&gt; &lt;span&gt;hash&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; each endpoint &lt;span&gt;in&lt;/span&gt; --endpoints&lt;br/&gt; endpoint health  Checks the healthiness of endpoints specified &lt;span&gt;in&lt;/span&gt; `--endpoints` flag&lt;br/&gt; endpoint status  Prints out the status of endpoints specified &lt;span&gt;in&lt;/span&gt; `--endpoints` flag&lt;br/&gt; get   Gets the key or a range of keys&lt;br/&gt; &lt;span&gt;help&lt;/span&gt;   Help about any &lt;span&gt;command&lt;/span&gt;&lt;br/&gt; lease grant  Creates leases&lt;br/&gt; lease keep-alive Keeps leases alive (renew)&lt;br/&gt; lease list  List all active leases&lt;br/&gt; lease revoke  Revokes leases&lt;br/&gt; lease timetolive Get lease information&lt;br/&gt; lock   Acquires a named lock&lt;br/&gt; make-mirror  Makes a mirror at the destination etcd cluster&lt;br/&gt; member add  Adds a member into the cluster&lt;br/&gt; member list  Lists all members &lt;span&gt;in&lt;/span&gt; the cluster&lt;br/&gt; member promote  Promotes a non-voting member &lt;span&gt;in&lt;/span&gt; the cluster&lt;br/&gt; member remove  Removes a member from the cluster&lt;br/&gt; member update  Updates a member &lt;span&gt;in&lt;/span&gt; the cluster&lt;br/&gt; migrate   Migrates keys &lt;span&gt;in&lt;/span&gt; a v2 store to a mvcc store&lt;br/&gt; move-leader  Transfers leadership to another etcd cluster member.&lt;br/&gt; put   Puts the given key into the store&lt;br/&gt; role add  Adds a new role&lt;br/&gt; role delete  Deletes a role&lt;br/&gt; role get  Gets detailed information of a role&lt;br/&gt; role grant-permission Grants a key to a role&lt;br/&gt; role list  Lists all roles&lt;br/&gt; role revoke-permission Revokes a key from a role&lt;br/&gt; snapshot restore Restores an etcd member snapshot to an etcd directory&lt;br/&gt; snapshot save  Stores an etcd node backend snapshot to a given file&lt;br/&gt; snapshot status  Gets backend snapshot status of a given file&lt;br/&gt; txn   Txn processes all the requests &lt;span&gt;in&lt;/span&gt; one transaction&lt;br/&gt; user add  Adds a new user&lt;br/&gt; user delete  Deletes a user&lt;br/&gt; user get  Gets detailed information of a user&lt;br/&gt; user grant-role  Grants a role to a user&lt;br/&gt; user list  Lists all users&lt;br/&gt; user passwd  Changes password of user&lt;br/&gt; user revoke-role Revokes a role from a user&lt;br/&gt; version   Prints the version of etcdctl&lt;br/&gt; watch   Watches events stream on keys or prefixes&lt;br/&gt;&lt;br/&gt;OPTIONS:&lt;br/&gt;      --cacert=&lt;span&gt;&quot;&quot;&lt;/span&gt;    verify certificates of TLS-enabled secure servers using this CA bundle&lt;br/&gt;      --cert=&lt;span&gt;&quot;&quot;&lt;/span&gt;     identify secure client using this TLS certificate file&lt;br/&gt;      --&lt;span&gt;command&lt;/span&gt;-timeout=5s   timeout &lt;span&gt;for&lt;/span&gt; short running &lt;span&gt;command&lt;/span&gt; (excluding dial timeout)&lt;br/&gt;      --debug[=&lt;span&gt;false&lt;/span&gt;]    &lt;span&gt;enable&lt;/span&gt; client-side debug logging&lt;br/&gt;      --dial-timeout=2s    dial timeout &lt;span&gt;for&lt;/span&gt; client connections&lt;br/&gt;  -d, --discovery-srv=&lt;span&gt;&quot;&quot;&lt;/span&gt;   domain name to query &lt;span&gt;for&lt;/span&gt; SRV records describing cluster endpoints&lt;br/&gt;      --discovery-srv-name=&lt;span&gt;&quot;&quot;&lt;/span&gt;   service name to query when using DNS discovery&lt;br/&gt;      --endpoints=[127.0.0.1:2379]  gRPC endpoints&lt;br/&gt;  -h, --&lt;span&gt;help&lt;/span&gt;[=&lt;span&gt;false&lt;/span&gt;]    &lt;span&gt;help&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; etcdctl&lt;br/&gt;      --hex[=&lt;span&gt;false&lt;/span&gt;]    &lt;span&gt;print&lt;/span&gt; byte strings as hex encoded strings&lt;br/&gt;      --insecure-discovery[=&lt;span&gt;true&lt;/span&gt;]  accept insecure SRV records describing cluster endpoints&lt;br/&gt;      --insecure-skip-tls-verify[=&lt;span&gt;false&lt;/span&gt;] skip server certificate verification&lt;br/&gt;      --insecure-transport[=&lt;span&gt;true&lt;/span&gt;]  &lt;span&gt;disable&lt;/span&gt; transport security &lt;span&gt;for&lt;/span&gt; client connections&lt;br/&gt;      --keepalive-time=2s   keepalive time &lt;span&gt;for&lt;/span&gt; client connections&lt;br/&gt;      --keepalive-timeout=6s   keepalive timeout &lt;span&gt;for&lt;/span&gt; client connections&lt;br/&gt;      --key=&lt;span&gt;&quot;&quot;&lt;/span&gt;     identify secure client using this TLS key file&lt;br/&gt;      --password=&lt;span&gt;&quot;&quot;&lt;/span&gt;    password &lt;span&gt;for&lt;/span&gt; authentication (&lt;span&gt;if&lt;/span&gt; this option is used, --user option shouldn&lt;span&gt;&#x27;t include password)&lt;br/&gt;      --user=&quot;&quot;     username[:password] for authentication (prompt if password is not supplied)&lt;br/&gt;  -w, --write-out=&quot;simple&quot;   set the output format (fields, json, protobuf, simple, table)&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，etcdctl 支持的命令很多，常用的命令选项：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;--debug 输出 CURL 命令，显示执行命令的时候发起的请求&lt;br/&gt;--no-sync 发出请求之前不同步集群信息&lt;br/&gt;--output, -o &lt;span&gt;&#x27;simple&#x27;&lt;/span&gt; 输出内容的格式(simple 为原始信息，json 为进行 json 格式解码，易读性好一些)&lt;br/&gt;--peers, -C 指定集群中的同伴信息，用逗号隔开(默认为: &lt;span&gt;&quot;127.0.0.1:4001&quot;&lt;/span&gt;)&lt;br/&gt;--cert-file HTTPS 下客户端使用的 SSL 证书文件&lt;br/&gt;--key-file HTTPS 下客户端使用的 SSL 密钥文件&lt;br/&gt;--ca-file 服务端使用 HTTPS 时，使用 CA 文件进行验证&lt;br/&gt;--&lt;span&gt;help&lt;/span&gt;, -h 显示帮助命令信息&lt;br/&gt;--version, -v 打印版本信息&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们将介绍其中常用的数据库命令。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2 数据库操作&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcd 在键的组织上采用了如同类似文件目录的结构，即层次化的空间结构，我们可以为键指定单独的名字。etcd 数据库提供的操作，则主要围绕对键值和目录的增删改查。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2.1 键操作&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;set  指定某个键的值。例如：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;$ etcdctl put /testdir/testkey &lt;span&gt;&quot;Hello world&quot;&lt;/span&gt;&lt;br/&gt;$ etcdctl put /testdir/testkey2 &lt;span&gt;&quot;Hello world2&quot;&lt;/span&gt;&lt;br/&gt;$ etcdctl put /testdir/testkey3 &lt;span&gt;&quot;Hello world3&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;成功写入三对键值，/testdir/testkey、/testdir/testkey2 和 /testdir/testkey3。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;get  获取指定键的值。例如：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;$ etcdctl get /testdir/testkey&lt;br/&gt;Hello world&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;get 十六进制读指定的值：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;$ etcdctl get /testdir/testkey --hex&lt;br/&gt;\x2f\x74\x65\x73\x74\x64\x69\x72\x2f\x74\x65\x73\x74\x6b\x65\x79 &lt;span&gt;#键&lt;/span&gt;&lt;br/&gt;\x48\x65\x6c\x6c\x6f\x20\x77\x6f\x72\x6c\x64 &lt;span&gt;#值&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;加上 &lt;code&gt;--print-value-only&lt;/code&gt; 可以读取对应的值。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;get 范围内的值&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt; $ etcdctl get /testdir/testkey /testdir/testkey3&lt;br/&gt;&lt;br/&gt;/testdir/testkey&lt;br/&gt;Hello world&lt;br/&gt;/testdir/testkey2&lt;br/&gt;Hello world2&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到，获取了大于等于 /testdir/testkey，且小于 /testdir/testkey3 的键值对。testkey3 不在范围之内，因为范围是半开区间 [testkey, testkey3), 不包含 testkey3。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;获取某个前缀的所有键值对，通过 --prefix 可以指定前缀：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;$ etcdctl get --prefix /testdir/testkey&lt;br/&gt;/testdir/testkey&lt;br/&gt;Hello world&lt;br/&gt;/testdir/testkey2&lt;br/&gt;Hello world2&lt;br/&gt;/testdir/testkey3&lt;br/&gt;Hello world3&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样既可获取所有以 /testdir/testkey 开头的键值对。当前缀获取的结果过多时，还可以通过  --limit=2 限制获取的数量：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;etcdctl get --prefix --&lt;span&gt;limit&lt;/span&gt;=2 /testdir/testkey&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;读取键过往版本的值
应用可能想读取键的被替代的值。例如，应用可能想通过访问键的过往版本来回滚到旧的配置。或者，应用可能想通过多个请求来得到一个覆盖多个键的统一视图，而这些请求可以通过访问键历史记录而来。因为 etcd 集群上键值存储的每个修改都会增加 etcd 集群的全局修订版本，应用可以通过提供旧有的 etcd 修改版本来读取被替代的键。现有如下这些键值对：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;foo = bar         &lt;span&gt;# revision = 2&lt;/span&gt;&lt;br/&gt;foo1 = bar2       &lt;span&gt;# revision = 3&lt;/span&gt;&lt;br/&gt;foo = bar_new     &lt;span&gt;# revision = 4&lt;/span&gt;&lt;br/&gt;foo1 = bar1_new   &lt;span&gt;# revision = 5&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以下是访问以前版本 key 的示例：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;$ etcdctl get --prefix foo &lt;span&gt;# 访问最新版本的 key&lt;/span&gt;&lt;br/&gt;foo&lt;br/&gt;bar_new&lt;br/&gt;foo1&lt;br/&gt;bar1_new&lt;br/&gt;&lt;br/&gt;$ etcdctl get --prefix --rev=4 foo &lt;span&gt;# 访问第 4 个版本的 key&lt;/span&gt;&lt;br/&gt;foo&lt;br/&gt;bar_new&lt;br/&gt;foo1&lt;br/&gt;bar1&lt;br/&gt;&lt;br/&gt;$ etcdctl get --prefix --rev=3 foo &lt;span&gt;#  访问第 3 个版本的 key&lt;/span&gt;&lt;br/&gt;foo&lt;br/&gt;bar&lt;br/&gt;foo1&lt;br/&gt;bar1&lt;br/&gt;&lt;br/&gt;$ etcdctl get --prefix --rev=2 foo &lt;span&gt;#  访问第 3 个版本的 key&lt;/span&gt;&lt;br/&gt;foo&lt;br/&gt;bar&lt;br/&gt;&lt;br/&gt;$ etcdctl get --prefix --rev=1 foo &lt;span&gt;#  访问第 1 个版本的 key&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;读取大于等于指定键的 byte 值的键
应用可能想读取大于等于指定键 的 byte 值的键。假设 etcd 集群已经有下列键：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;a = 123&lt;br/&gt;b = 456&lt;br/&gt;z = 789&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;读取大于等于键 b 的 byte 值的键的命令：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;$ etcdctl get --from-key b&lt;br/&gt;b&lt;br/&gt;456&lt;br/&gt;z&lt;br/&gt;789&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;删除键。客户端应用可以从 etcd 数据库中删除指定的键。假设 etcd 集群已经有下列键：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;foo = bar&lt;br/&gt;foo1 = bar1&lt;br/&gt;foo3 = bar3&lt;br/&gt;zoo = val&lt;br/&gt;zoo1 = val1&lt;br/&gt;zoo2 = val2&lt;br/&gt;a = 123&lt;br/&gt;b = 456&lt;br/&gt;z = 789&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;删除键 foo 的命令：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;$ etcdctl del foo&lt;br/&gt;1 &lt;span&gt;# 删除了一个键&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;删除从 foo to foo9 范围的键的命令：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;$ etcdctl del foo foo9&lt;br/&gt;2 &lt;span&gt;# 删除了两个键&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;删除键 zoo 并返回被删除的键值对的命令：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;$ etcdctl del --prev-kv zoo&lt;br/&gt;1   &lt;span&gt;# 一个键被删除&lt;/span&gt;&lt;br/&gt;zoo &lt;span&gt;# 被删除的键&lt;/span&gt;&lt;br/&gt;val &lt;span&gt;# 被删除的键的值&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;删除前缀为 zoo 的键的命令：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;$ etcdctl del --prefix zoo&lt;br/&gt;2 &lt;span&gt;# 删除了两个键&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;删除大于等于键 b 的 byte 值的键的命令：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;$ etcdctl del --from-key b&lt;br/&gt;2 &lt;span&gt;# 删除了两个键&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2.2 watch 历史改动&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;watch 可以用来监测一个键值的变化，当该键值更新，控制台就会输出最新的值。例如：用户更新 watchkey 键值为 newwatchvalue。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;$ etcdctl watch  watchkey&lt;br/&gt;&lt;span&gt;# 在另外一个终端: etcdctl put  watchkey newwatchvalue&lt;/span&gt;&lt;br/&gt;watchkey&lt;br/&gt;newwatchvalue&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从 foo to foo9 范围内键的命令：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;$ etcdctl watch foo foo9&lt;br/&gt;&lt;span&gt;# 在另外一个终端: etcdctl put foo bar&lt;/span&gt;&lt;br/&gt;PUT&lt;br/&gt;foo&lt;br/&gt;bar&lt;br/&gt;&lt;span&gt;# 在另外一个终端: etcdctl put foo1 bar1&lt;/span&gt;&lt;br/&gt;PUT&lt;br/&gt;foo1&lt;br/&gt;bar1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以 16 进制格式在键 foo 上进行观察的命令：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;$ etcdctl watch foo --hex&lt;br/&gt;&lt;span&gt;# 在另外一个终端: etcdctl put foo bar&lt;/span&gt;&lt;br/&gt;PUT&lt;br/&gt;\x66\x6f\x6f          &lt;span&gt;# 键&lt;/span&gt;&lt;br/&gt;\x62\x61\x72          &lt;span&gt;# 值&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;观察多个键 foo 和 zoo 的命令：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;$ etcdctl watch -i&lt;br/&gt;$ watch foo&lt;br/&gt;$ watch zoo&lt;br/&gt;&lt;span&gt;# 在另外一个终端: etcdctl put foo bar&lt;/span&gt;&lt;br/&gt;PUT&lt;br/&gt;foo&lt;br/&gt;bar&lt;br/&gt;&lt;span&gt;# 在另外一个终端: etcdctl put zoo val&lt;/span&gt;&lt;br/&gt;PUT&lt;br/&gt;zoo&lt;br/&gt;val&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;查看 key 的历史修订版本。客户端应用需要获取某个键的所有修改。那么客户端应用连接到 etcd，watch 对应的 key 即可。如果 Watch 的过程中，etcd 或者客户端应用出错，又恰好发生了改动，这种情况下客户端应用可以在 Watch 时指定历史修订版本。&lt;br/&gt;假设我们完成了下列操作序列：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;$ etcdctl put foo bar         &lt;span&gt;# revision = 2&lt;/span&gt;&lt;br/&gt;OK&lt;br/&gt;$ etcdctl put foo1 bar1       &lt;span&gt;# revision = 3&lt;/span&gt;&lt;br/&gt;OK&lt;br/&gt;$ etcdctl put foo bar_new     &lt;span&gt;# revision = 4&lt;/span&gt;&lt;br/&gt;OK&lt;br/&gt;$ etcdctl put foo1 bar1_new   &lt;span&gt;# revision = 5&lt;/span&gt;&lt;br/&gt;OK&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;观察历史改动：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 从修订版本 2 开始观察键 `foo` 的改动&lt;/span&gt;&lt;br/&gt;$ etcdctl watch --rev=2 foo&lt;br/&gt;PUT&lt;br/&gt;foo&lt;br/&gt;bar&lt;br/&gt;PUT&lt;br/&gt;foo&lt;br/&gt;bar_new&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从上一次历史修改开始观察：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 在键 `foo` 上观察变更并返回被修改的值和上个修订版本的值&lt;/span&gt;&lt;br/&gt;$ etcdctl watch --prev-kv foo&lt;br/&gt;&lt;span&gt;# 在另外一个终端: etcdctl put foo bar_latest&lt;/span&gt;&lt;br/&gt;PUT&lt;br/&gt;foo         &lt;span&gt;# 键&lt;/span&gt;&lt;br/&gt;bar_new     &lt;span&gt;# 在修改前键 foo 的上一个值&lt;/span&gt;&lt;br/&gt;foo         &lt;span&gt;# 键&lt;/span&gt;&lt;br/&gt;bar_latest  &lt;span&gt;# 修改后键 foo 的值&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;压缩修订版本。etcd 保存了历史修订版本，客户端应用可以读取键的历史版本。大量的历史版本数据，会占据很多存储，因此需要压缩历史修订版本。经过压缩，etcd 会删除历史修订版本，释放出资源。压缩修订版本之前的版本数据不可访问。压缩修订版本的命令如下所示：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;$ etcdctl compact 5&lt;br/&gt;compacted revision 5  $ etcdctl get --rev=4 foo&lt;br/&gt;{&lt;span&gt;&quot;level&quot;&lt;/span&gt;:&lt;span&gt;&quot;warn&quot;&lt;/span&gt;,&lt;span&gt;&quot;ts&quot;&lt;/span&gt;:&lt;span&gt;&quot;2020-05-04T16:37:38.020+0800&quot;&lt;/span&gt;,&lt;span&gt;&quot;caller&quot;&lt;/span&gt;:&lt;span&gt;&quot;clientv3/retry_interceptor.go:62&quot;&lt;/span&gt;,&lt;span&gt;&quot;msg&quot;&lt;/span&gt;:&lt;span&gt;&quot;retrying of unary invoker failed&quot;&lt;/span&gt;,&lt;span&gt;&quot;target&quot;&lt;/span&gt;:&lt;span&gt;&quot;endpoint://client-c0d35565-0584-4c07-bfeb-034773278656/127.0.0.1:2379&quot;&lt;/span&gt;,&lt;span&gt;&quot;attempt&quot;&lt;/span&gt;:0,&lt;span&gt;&quot;error&quot;&lt;/span&gt;:&lt;span&gt;&quot;rpc error: code = OutOfRange desc = etcdserver: mvcc: required revision has been compacted&quot;&lt;/span&gt;}&lt;br/&gt;Error: etcdserver: mvcc: required revision has been compacted&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2.3 租约&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;授予租约
客户端应用可以为 etcd 数据库存储内的键授予租约。当 etcd 中的键被授予租约时，该键的存活时间与租约的时间绑定，而租约的存活时间相应的被 time-to-live (TTL)管理。在租约授予时每个租约的最小 TTL 值由客户端应用指定。当租约的 TTL 到期，即代表租约就过期，此时该租约绑定的键都将被删除。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 授予租约，TTL 为 100 秒&lt;/span&gt;&lt;br/&gt;$ etcdctl lease grant 100&lt;br/&gt;lease 694d71ddacfda227 granted with TTL(10s)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 附加键 foo 到租约 694d71ddacfda227&lt;/span&gt;&lt;br/&gt;$ etcdctl put --lease=694d71ddacfda227 foo10 bar&lt;br/&gt;OK&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;建议时间设置久一点，否则来不及操作会出现如下的错误：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code/&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;撤销租约
应用通过租约 id 可以撤销租约。撤销租约将删除所有它附带的 key。假设我们完成了下列的操作：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;$ etcdctl lease revoke 694d71ddacfda227&lt;br/&gt;lease 694d71ddacfda227 revoked&lt;br/&gt;&lt;br/&gt;$ etcdctl get foo10&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;刷新租期&lt;br/&gt;应用程序可以通过刷新其 TTL 来保持租约活着，因此不会过期。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;$ etcdctl lease keep-alive 694d71ddacfda227&lt;br/&gt;lease 694d71ddacfda227 keepalived with TTL(100)&lt;br/&gt;lease 694d71ddacfda227 keepalived with TTL(100)&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;查询租期
应用程序可能想要了解租赁信息，以便它们可以续订或检查租赁是否仍然存在或已过期。应用程序也可能想知道特定租约所附的 key。&lt;/p&gt;&lt;p&gt;假设我们完成了以下一系列操作：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;$ etcdctl lease grant 300&lt;br/&gt;lease 694d71ddacfda22c granted with TTL(300s)&lt;br/&gt;&lt;br/&gt;$ etcdctl put --lease=694d71ddacfda22c foo10 bar&lt;br/&gt;OK&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;获取有关租赁信息以及哪些 key 使用了租赁信息：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;$ etcdctl lease timetolive 694d71ddacfda22c&lt;br/&gt;lease 694d71ddacfda22c granted with TTL(300s), remaining(282s)&lt;br/&gt;&lt;br/&gt;$ etcdctl lease timetolive --keys 694d71ddacfda22c&lt;br/&gt;lease 694d71ddacfda22c granted with TTL(300s), remaining(220s), attached keys([foo10])&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6 etcd 安全运维&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcd 支持通过 TLS 协议进行的加密通信。TLS 通道可用于对等体之间的加密内部群集通信以及加密的客户端流量。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.1 TLS 与 SSL&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;互联网信息明文传播，带来了窃听风险，即第三方可以窃取通信内容；篡改风险，通信内容被篡改；冒充风险，身份被冒充，从而参与通信。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 SSL/TLS 协议实现互联网的通信安全。SSL/TLS 协议可以解决上述提到的三个问题，通信加密，使得第三方无法窃听；校验机制防止篡改，一旦被篡改，通信双方会立刻发现；安全身份证书防止身份被冒充。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TLS 是安全传输层协议，如果需要实现 HTTPS 加密访问，保障通信数据的安全，就需要 SSL 证书，下面我们开始实践如何实现 etcd 集群成员之间的通信。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.2 进行 TLS 加密实践&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了进行实践，我们将会安装一些实用的命令行工具，这包括 cfssl、cfssljson。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CFSSL 是 CloudFlare 的 PKI/TLS 工具，既是一个命令行工具，同时又可以用于签名，作为 HTTP API 服务器，验证和绑定 TLS 证书。它需要 Go 1.12+ 才能构建。环境配置如下：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;HostName&lt;/th&gt;&lt;th&gt;ip&lt;/th&gt;&lt;th&gt;客户端交互端口&lt;/th&gt;&lt;th&gt;peer 通信端口&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;etcd1&lt;/td&gt;&lt;td&gt;192.168.202.128&lt;/td&gt;&lt;td&gt;2379&lt;/td&gt;&lt;td&gt;2380&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;etcd2&lt;/td&gt;&lt;td&gt;192.168.202.129&lt;/td&gt;&lt;td&gt;2379&lt;/td&gt;&lt;td&gt;2380&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;etcd3&lt;/td&gt;&lt;td&gt;192.168.202.130&lt;/td&gt;&lt;td&gt;2379&lt;/td&gt;&lt;td&gt;2380&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.2.1 安装 cfssl&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ ls ~/Downloads/cfssl&lt;br/&gt;cfssl-certinfo_1.4.1_linux_amd64 cfssl_1.4.1_linux_amd64          cfssljson_1.4.1_linux_amd64&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;chmod +x cfssl_1.4.1_linux_amd64 cfssljson_1.4.1_linux_amd64 cfssl-certinfo_1.4.1_linux_amd64&lt;br/&gt;&lt;br/&gt;mv cfssl_1.4.1_linux_amd64 /usr/&lt;span&gt;local&lt;/span&gt;/bin/cfssl&lt;br/&gt;mv cfssljson_1.4.1_linux_amd64 /usr/&lt;span&gt;local&lt;/span&gt;/bin/cfssljson&lt;br/&gt;mv cfssl-certinfo_1.4.1_linux_amd64 /usr/bin/cfssl-certinfo&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安装完成之后，查看版本信息的结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ cfssl version&lt;br/&gt;&lt;br/&gt;Version: 1.4.1&lt;br/&gt;Runtime: go1.12.12&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.2.2 配置 CA 并创建 TLS 证书&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们将使用 CloudFlare&#x27;s PKI 工具 cfssl 来配置 PKI Infrastructure，然后使用它去创建 Certificate Authority（CA）， 并为 etcd 创建 TLS 证书。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先创建 ssl 配置目录：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;mkdir /data/etcd/{bin,cfg,ssl} -p&lt;br/&gt;&lt;span&gt;cd&lt;/span&gt; /data/etcd/ssl/&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcd ca 配置：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;cat &amp;lt;&amp;lt; EOF | tee ca-config.json&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;signing&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;default&quot;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;expiry&quot;&lt;/span&gt;: &lt;span&gt;&quot;87600h&quot;&lt;/span&gt;&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;&quot;profiles&quot;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;etcd&quot;&lt;/span&gt;: {&lt;br/&gt;         &lt;span&gt;&quot;expiry&quot;&lt;/span&gt;: &lt;span&gt;&quot;87600h&quot;&lt;/span&gt;,&lt;br/&gt;         &lt;span&gt;&quot;usages&quot;&lt;/span&gt;: [&lt;br/&gt;            &lt;span&gt;&quot;signing&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;key encipherment&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;server auth&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;client auth&quot;&lt;/span&gt;&lt;br/&gt;        ]&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;EOF&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcd ca 证书：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;cat &amp;lt;&amp;lt; EOF | tee ca-csr.json&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;&quot;CN&quot;&lt;/span&gt;: &lt;span&gt;&quot;etcd CA&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;key&quot;&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;&quot;algo&quot;&lt;/span&gt;: &lt;span&gt;&quot;rsa&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;size&quot;&lt;/span&gt;: 2048&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;&quot;names&quot;&lt;/span&gt;: [&lt;br/&gt;        {&lt;br/&gt;            &lt;span&gt;&quot;C&quot;&lt;/span&gt;: &lt;span&gt;&quot;CN&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;L&quot;&lt;/span&gt;: &lt;span&gt;&quot;Shanghai&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;ST&quot;&lt;/span&gt;: &lt;span&gt;&quot;Shanghai&quot;&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;    ]&lt;br/&gt;}&lt;br/&gt;EOF&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生成 CA 凭证和私钥：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ cfssl gencert -initca ca-csr.json | cfssljson -bare ca&lt;br/&gt;&lt;br/&gt;2020/04/30 20:36:58 [INFO] generating a new CA key and certificate from CSR&lt;br/&gt;2020/04/30 20:36:58 [INFO] generate received request&lt;br/&gt;2020/04/30 20:36:58 [INFO] received CSR&lt;br/&gt;2020/04/30 20:36:58 [INFO] generating key: rsa-2048&lt;br/&gt;2020/04/30 20:36:58 [INFO] encoded CSR&lt;br/&gt;2020/04/30 20:36:58 [INFO] signed certificate with serial number 252821789025044258332210471232130931231440888312&lt;br/&gt;&lt;br/&gt;$ ls&lt;br/&gt;&lt;br/&gt;ca-config.json  ca-csr.json  ca-key.pem  ca.csr  ca.pem&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcd server 证书：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;cat &amp;lt;&amp;lt; EOF | tee server-csr.json&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;&quot;CN&quot;&lt;/span&gt;: &lt;span&gt;&quot;etcd&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;hosts&quot;&lt;/span&gt;: [&lt;br/&gt;    &lt;span&gt;&quot;192.168.202.128&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;192.168.202.129&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;192.168.202.130&quot;&lt;/span&gt;&lt;br/&gt;    ],&lt;br/&gt;    &lt;span&gt;&quot;key&quot;&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;&quot;algo&quot;&lt;/span&gt;: &lt;span&gt;&quot;rsa&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;size&quot;&lt;/span&gt;: 2048&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;&quot;names&quot;&lt;/span&gt;: [&lt;br/&gt;        {&lt;br/&gt;            &lt;span&gt;&quot;C&quot;&lt;/span&gt;: &lt;span&gt;&quot;CN&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;L&quot;&lt;/span&gt;: &lt;span&gt;&quot;Beijing&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;ST&quot;&lt;/span&gt;: &lt;span&gt;&quot;Beijing&quot;&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;    ]&lt;br/&gt;}&lt;br/&gt;EOF&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生成 server 证书：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=etcd server-csr.json | cfssljson -bare server&lt;br/&gt;2020/04/30 20:44:37 [INFO] generate received request&lt;br/&gt;2020/04/30 20:44:37 [INFO] received CSR&lt;br/&gt;2020/04/30 20:44:37 [INFO] generating key: rsa-2048&lt;br/&gt;2020/04/30 20:44:37 [INFO] encoded CSR&lt;br/&gt;2020/04/30 20:44:37 [INFO] signed certificate with serial number 73061688633166283265484923779818839258466531108&lt;br/&gt;&lt;br/&gt;ls&lt;br/&gt;ca-config.json  ca-csr.json  ca-key.pem  ca.csr  ca.pem  server-csr.json  server-key.pem  server.csr  server.pem&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;启动 etcd 集群，命令的配置如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#etcd1 启动&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;$ /data/etcd/bin/etcd --name etcd1 --initial-advertise-peer-urls https://192.168.202.128:2380 \&lt;br/&gt;     --listen-peer-urls https://192.168.202.128:2380 \&lt;br/&gt;     --listen-client-urls https://192.168.202.128:2379,https://127.0.0.1:2379 \&lt;br/&gt;     --advertise-client-urls https://192.168.202.128:2379 \&lt;br/&gt;     --initial-cluster-token etcd-cluster-1 \&lt;br/&gt;     --initial-cluster etcd1=https://192.168.202.128:2380, etcd2=https://192.168.202.129:2380, etcd3=https://192.168.202.130:2380 \&lt;br/&gt;     --initial-cluster-state new \&lt;br/&gt;     --client-cert-auth --trusted-ca-file=/data/etcd/ssl/ca.pem \&lt;br/&gt;     --cert-file=/opt/etcd/ssl/server.pem --key-file=/data/etcd/ssl/server-key.pem \&lt;br/&gt;     --peer-client-cert-auth --peer-trusted-ca-file=/data/etcd/ssl/ca.pem \&lt;br/&gt;     --peer-cert-file=/opt/etcd/ssl/server.pem --peer-key-file= /data/etcd/ssl/server-key.pem&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#etcd2、etcd3 类似，此处省略&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过三台服务器的控制台可以知道，集群已经成功建立，我们进行验证：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看三个节点的健康状况，&lt;code&gt;endpoint health&lt;/code&gt; ；其次，查看集群的成员列表，是否输出三个成员；最后，经过 TLS 加密的 etcd 集群，在进行操作时，需要加上认证相关的信息，尝试先写再读的操作是否能够正常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照上述的步骤进行操作，这个验证的实践交给读者自行尝试。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.2.3 自动证书&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果集群需要加密的通信但不需要经过身份验证的连接，则可以将 etcd 配置为自动生成其密钥。在初始化时，每个成员都基于其通告的 IP 地址和主机创建自己的密钥集。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在每台机器上，etcd 将使用以下标志启动：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ etcd --name etcd1 --initial-advertise-peer-urls https://192.168.202.128:2380 \&lt;br/&gt;  --listen-peer-urls https://192.168.202.128:2380 \&lt;br/&gt;  --listen-client-urls https://192.168.202.128:2379,https://127.0.0.1:2379 \&lt;br/&gt;  --advertise-client-urls https://10.0.1.10:2379 \&lt;br/&gt;  --initial-cluster-token etcd-cluster-1 \&lt;br/&gt;  --initial-cluster infra0=https://192.168.202.128:2380,infra1=https://192.168.202.129:2380,infra2=https://192.168.202.130:2380 \&lt;br/&gt;  --initial-cluster-state new \&lt;br/&gt;  --auto-tls \&lt;br/&gt;  --peer-auto-tls&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于自动签发证书并不认证身份，因此直接 curl 会返回错误。需要使用 curl 的 &lt;code&gt;-k&lt;/code&gt; 命令屏蔽对证书链的校验。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7 小结&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcd 具有极佳的稳定性、可靠性、可伸缩性，为云原生分布式系统提供了必要的协调机制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文主要介绍了 etcd 的入门知识以及相关的实践。etcd 被设计为大型分布式系统的存储基石，etcd 以一致且容错的方式存储元数据。etcd 集群旨在提供具有稳定性、可靠性、可伸缩性和性能的键值存储。使用 etcd 的常见分布式场景包括领导者选举、键值对存储、分布式锁和消息订阅与发布等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实践是最好的学习方式，在看完本文之后，希望大家能够参照本文的介绍，进行相应的实践，期待你的讨论交流。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1342f9dfb97d03937c0ea67ba17b4a18</guid>
<title>M1 暴打 Intel？：这次的芯片有何不同</title>
<link>https://toutiao.io/k/j1ohqm1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;h2&gt;&lt;img data-backh=&quot;237&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.4255555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2Gybw9AhCUoE0unO7KNn5xmclBEZGpu0eKX99x0FwZv4P8gQdU66u6vrZXPL82gacaxaL3ArQPNaBJJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/h2&gt;&lt;h2&gt;1. 前言&lt;/h2&gt;&lt;p&gt;之前看到 M1 芯片出来之后，就想说些什么，结果光写 x86 和 ARM 就写了 4000 多字，考虑到文章篇幅，只得分为上下两篇，上一篇文章发出后有很多人表示非常喜欢，让我赶紧更新，在这里向支持我的读者们表示感谢 🙏。&lt;/p&gt;&lt;p&gt;那么话不多说，这篇我们来聊一聊，这次的芯片到底有何不同，以至于让那么多人说苹果不讲武德。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;在这之前我先说明，我只是一个计算机专业的学生，从来就没有自诩自己是什么专家学者，我写博客也只是为了做一些简单的科普，把自己知道的一些知识分享给大家。如果文章中有什么错误的地方，还请各位读者指正。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;2. M1 芯片 ≠ CPU&lt;/h2&gt;&lt;p&gt;&lt;img data-backh=&quot;203&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.6428571428571429&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybw9AhCUoE0unO7KNn5xmclBLQRfb1f9iaibM59arQ0tFczffSbQHn3Iiah1R0VRfpDbib2L4bZTWicKTTw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;980&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;首先，我们要先摆脱一个认知误区，M1 芯片&lt;strong&gt;不是一块 CPU&lt;/strong&gt;，而是一块专为 Mac 设计的 SoC 芯片。&lt;strong&gt;CPU 只是 M1 芯片的一个组成部分&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;所谓 SoC 芯片，指的是系统级芯片（System on Chip），也称片上芯片，是一个将电脑或其他电子系统集成到单一芯片的&lt;strong&gt;集成电路&lt;/strong&gt;。SoC 集成的主要包括处理器(CPU，GPU 等)、基带、各种接口控制模块、各种互联总线等，其典型代表为手机芯片。举个例子，CPU 公司将自己的所生产的 CPU 设计卖给其他公司，而其他公司就根据该 CPU 自己添加上所需要的各种外设控制器，这就是 SoC。&lt;/p&gt;&lt;p&gt;所以简单来说：SoC 就是一块集成了 CPU、GPU 等多种结构的芯片。因此，千万不要简单的认为 M1 芯片就是 CPU。&lt;/p&gt;&lt;p&gt;官网有一张图，就很好地说明了 M1 芯片的组成成分。如下图所示，苹果称其为&lt;strong&gt;统一内存架构（Unified memory architechture）&lt;/strong&gt;，即通过 Fabric 高速总线将中央处理器、图形处理器、神经网络引擎、缓存、DRAM 内存全部连接在一起。因此，M1 芯片的强大，绝不是靠一个强悍的 CPU 支撑的，而是众多性能强大的部件结合苹果优秀的设计共同努力的成果。&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;180&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.5718518518518518&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybw9AhCUoE0unO7KNn5xmclBmgIUXkMMz4zY78OjU2j9lEvyWiaCPTyHlS4AabxtCibRedOutpVlcgZw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1350&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h2&gt;3. 统一内存架构（UMA）&lt;/h2&gt;&lt;p&gt;通过上一段内容，我们知道了 M1 芯片的强大光靠一颗强大的 CPU 是不够的，毕竟苹果也没办法突破物理定律，单纯通过设计让 CPU 的性能提升数倍。很明显苹果采用了其他的技巧来弯道超车，而&lt;strong&gt;「统一内存架构」&lt;/strong&gt;就是其中之一。&lt;/p&gt;&lt;p&gt;我们知道，处理器在处理任务时，他要做的事情很简单就是&lt;strong&gt;取东西和算东西&lt;/strong&gt;，也就是上一篇文章中提到的“接收指令+运算数据”。&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;123&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.3897058823529412&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybw9AhCUoE0unO7KNn5xmclBqLb475xTcqDfj6eJPpEicfE8XkibenZu3cmkeaPPq9dM70z3xx3HRceg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1496&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;和上篇文章一样，我们还是以打工人为例，取东西就是打工人搬砖，算东西就是打工人砌砖，你砌砖砌得再快再好，砖搬的慢，砌砖的速度也不会快。反过来也是，如果砌砖的慢，搬砖的块，就会有砖堆积。&lt;/p&gt;&lt;p&gt;因此&lt;strong&gt;理想状态&lt;/strong&gt;下，搬砖的速度和砌砖的速度应该是一致的，这样就不用等对方。对于 CPU 来说也是同样的道理，如果双方的速度不一致，就会造成性能浪费。&lt;/p&gt;&lt;p&gt;因此，为了解决上述问题，苹果提供了一个解决方案，就是&lt;strong&gt;统一内存架构&lt;/strong&gt;。&lt;/p&gt;&lt;h3&gt;3.1 UMA 做了什么？&lt;/h3&gt;&lt;p&gt;那么 UMA 到底做了什么？&lt;/p&gt;&lt;p&gt;我们电脑里面有很多 PU（Processing Unit），即处理单元（处理器），我们常见的有 CPU（Central Processing Unit，即中央处理器）、GPU（Graphics Processing Unit，即图形处理器）和 NPU（Neural network Processing Unit，神经网络处理器）。他们都需要取东西、算东西，但是在 UMA 出现之前，他们只能通过 CPU 来分配东西，而 CPU 还要事先从内存中取数据。显然，这种工作方式的效率很低，况且，不同的处理器对于数据的运算速度也是不同的，为了做到时序同步，一定程度上不利于硬件性能的发挥。&lt;/p&gt;&lt;p&gt;而且，每个处理单元作为一个独立的个体，各自处理的数据包格式也不一样。不同 PU 之间通信的语言都是不一样的，统一数据格式时也需要消耗时间，如果这样通信效率还高那才有问题。就像来自不同国家的打工人一起打工时，都说各自的语言，通过翻译才能进行沟通，这听起来效率就很低。&lt;/p&gt;&lt;p&gt;当然了，以上只是简单的举一些例子，真实情况肯定是比这更加复杂的，但即使是这样，我们也能感受到有很多本来不应该存在的步骤耽误了很多时间。所以，为了解决上述这些问题，苹果给出了几个解决方案。&lt;/p&gt;&lt;h3&gt;3.1.1 PU 直接访问内存&lt;/h3&gt;&lt;p&gt;没有 UMA 之前，需要先将数据从内存中取出，然后由 CPU 优先处理、分配，如下图所示 👇&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;221&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.7014388489208633&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybw9AhCUoE0unO7KNn5xmclBpf0kHBc9cl2pPHiadNib3d7vKfXF4eict89ibAicTTSgh7fWGWibI744JcHw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1390&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;有了 UMA 之后，这些处理单元可以直接访问内存，再也不需要通过 CPU 去获取一些数据了，如下图所示 👇&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;239&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.7582025677603423&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybw9AhCUoE0unO7KNn5xmclBlESgUPiaYBtuG9hFrkuyyTfft2sibWCyTapBkMibickMMtepYXSAdKGOlA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1402&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;通过这样的设计方式，这个 PU 们不需要再和 CPU 同步语速，也不用什么乱七八糟的事情都先去找 CPU 过问一遍，这样就省下来一大笔时间了。&lt;/p&gt;&lt;h3&gt;3.1.2 Apple-designed package&lt;/h3&gt;&lt;p&gt;虽然解决了取数据时的时序问题，但是各处理单元的通信问题仍然没有得到解决，这里就要提到苹果所做的另一个解决方案了——Apple-designed package。&lt;/p&gt;&lt;p&gt;通过 Apple-designed package，各单元处理数据时的数据包格式统一了，他们之间的沟通不再需要翻译了，哪怕都说的是“阿巴阿巴阿巴”也都能明白各自说的是什么了，这就又省下了一部分时间。&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;200&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.6360424028268551&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybw9AhCUoE0unO7KNn5xmclB8e8kNM7SBqhZtP42UICXaVfTLCqibIm77KzXkv19tpWkiazwV3INHccw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1698&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h3&gt;3.1.3 高度集成&lt;/h3&gt;&lt;p&gt;无论是拆解图还是实例图，都说明苹果这次的高度集成，是直接将内存放到了处理器的旁边，这极大的缩小了内存和处理器之间的物理距离，取数据的速度自然就会更快了。&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;201&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.637155297532656&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybw9AhCUoE0unO7KNn5xmclBgBRN4GQOMVACoUduBJo1r8tibok7ibAUcscjDgxeFAOEicrNibXdP7hETQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1378&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;千万别小看了这点物理距离的减少，目前的计算机都属于&lt;strong&gt;冯诺依曼结构&lt;/strong&gt;，而该结构最大的一个隐患就是：在内存容量指数级提升以后，CPU 和内存之间的数据传输带宽成为了瓶颈，原因之一就在于内存和 CPU 的物理距离过大。虽然现在 CPU 和内存的速度越做越快，但是他们之间的距离却无法改变，而传输数据的速率-光速也无法改变。&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;139&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.44100719424460433&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybw9AhCUoE0unO7KNn5xmclBPrMaAzb7QEBtGGaXLUfmf4ZgABRLiacMNmCCN9aY6VTKsicwqiaAlSCzg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1390&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;我们可以来做一个简单的数学题，i9-7980XE 是一颗 18 核 36 线程的民用 CPU，这颗 CPU 最大睿频 4.4GHz，假设该 CPU 在一个时钟周期内执行一条运算指令，那么该 CPU 执行一个指令需要的时间是 0.000000000227273 秒，即 0.22ns（纳秒），那么在这段时间内，光所跑的距离是 0.0681819 米，四舍五入就约等于 7 厘米。所以说如果 CPU 和内存之间的距离超过 7 厘米，CPU 岂不是要多等一会才能继续收到指令了。这还是一次只取一条指令的情况，如果数量多了呢？&lt;/p&gt;&lt;p&gt;所以物理距离的缩小，自然可以让 CPU 取数据的速度更快一些，这也是 M1 芯片性能提升的关键一点。&lt;/p&gt;&lt;h3&gt;3.2 超大缓存&lt;/h3&gt;&lt;p&gt;上面说的这些也都只是让 CPU 取数据时可以更快一些，但是 CPU 和内存之间的数据传输带宽成为瓶颈不单单是因为物理距离的原因，最根本的原因还是因为 CPU 太快了，&lt;strong&gt;很难做到和内存同步&lt;/strong&gt;。所以我们得把计算机经常用到的数据导入 cache，也就是&lt;strong&gt;缓存&lt;/strong&gt;，避免计算机去内存要东西，更不应该让计算机去硬盘要东西。&lt;/p&gt;&lt;h3&gt;3.2.1 什么是缓存&lt;/h3&gt;&lt;p&gt;缓存就是数据交换的缓冲区（称作 Cache），是存贮数据（使用频繁的数据）的临时地方。其实在很多地方都用到了缓存，比如当用户查询数据，首先在缓存中寻找，如果找到了则直接执行。如果找不到，则去数据库中查找。&lt;/p&gt;&lt;p&gt;CPU 也同样设计了一个这样的存在，是一个用于减少处理器访问内存所需平均时间的部件。他的工作原理是：当处理器发出内存访问请求时，会先查看缓存内是否有请求数据。如果存在（命中），则不经访问内存直接返回该数据；如果不存在（失效），则要先把内存中的相应数据载入缓存，再将其返回处理器。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6400966183574879&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybw9AhCUoE0unO7KNn5xmclBupkjqFYAg1ArqC2hgBHqmOJ1Zbickr6PlUpJAlKIicYt8e4kEZlSXhtQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;828&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;还是拿搬砖这个例子来加深理解，如果我正在砌砖，就算搬砖的人把砖搬过来了，我也来不及砌，光让他在那站着等也不好，所以就让他把砖放到脚边（缓存），这个砌砖的每次就不用跑去搬砖的那里拿砖了，只需要从脚边（缓存）拿砖就好了。&lt;/p&gt;&lt;p&gt;所以，我们知道缓存主要是为了&lt;strong&gt;弥补 CPU 和内存之间的读写速度差异&lt;/strong&gt;而出现的，因此理论上，在一定范围内，缓存自然是越大越好。&lt;/p&gt;&lt;h3&gt;3.2.2 M1 芯片的缓存设计&lt;/h3&gt;&lt;p&gt;M1 芯片同样也是这么设计的，只是苹果为 M1 芯片带了&lt;strong&gt;超大&lt;/strong&gt;的缓存，这个缓存有多大呢，我们来做个简单的比较。（以下数据摘自维基百科和 CPU - Z）&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;81&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.2571785268414482&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybw9AhCUoE0unO7KNn5xmclBHWjIt8prE43wE0hN3mPgWr5nwiaqtyaUPVvjEUFYqaab69H73bDRtrw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1602&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;L1 表示一级缓存，L2 表示二级缓存，即一级缓存的缓存。一级缓存还分为一级数据缓存（Data Cache，D-Cache，L1d）和一级指令缓存(Instruction Cache，I-Cache，L1i)，分别用于存放数据及执行数据的指令解码，两者可同时被 CPU 访问，减少了 CPU 多核心、多线程争用缓存造成的冲突，提高了处理器的效能。一般 CPU 的 L1i 和 L1d 具备相同的容量。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img data-backh=&quot;126&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.3990740740740741&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybw9AhCUoE0unO7KNn5xmclBgYnpj0ghFK7RYz6IlWSibjycRrGWgUuSeAegLOISkZqricSrezoSIusA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;这个对比结果非常明显，尤其是在二级缓存，虽然在 M1 芯片中，二级缓存是共享的，但这 16MB 的缓存还是比 i9-10900K 的二级缓存大了不少。虽然 i9-10900K 的三级缓存有 20MB，但是也只是比 M1 的二级缓存大了 4MB，并且三级缓存的速度是比二级缓存慢得多的。&lt;/p&gt;&lt;p&gt;而且，可别忘了，基于苹果这次的高度集成，DRAM 内存和处理器直接通过 Fabric 高速总线连接在一起，这样使得集成的内存可以&lt;strong&gt;近似看做&lt;/strong&gt;是一个&lt;strong&gt;超大容量的 L3 缓存&lt;/strong&gt;，苹果用牺牲扩展性换取吞吐量的策略，给 M1 芯片带来了更高的带宽与更低的延迟。当然了，缓存也并不是越大越好，一方面是制作的难度，另一方面&lt;strong&gt;缓存命中率&lt;/strong&gt;也是评价缓存性能的一个重要指标。如果缓存过大，命中率就会下降，如果这样就会有些得不偿失了。&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;126&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.4&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybw9AhCUoE0unO7KNn5xmclBnic4NjDLgvsJYribAD0ta7GW8qLBw1PicKyP43gVxC4yrUjKTVJodYMQA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1480&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;其实 M1 芯片之所以可以塞入这么大的缓存，和其制作工艺是有很大的关系的，相较于 10nm、14nm，M1 芯片采用台积电最先进的 5nm 工艺制成，晶体管越小，单位面积内可塞入晶体管的数量就更多，这样就让苹果可以为 M1 芯片设计更大的缓存。这一部分具体我们下一节来说。&lt;/p&gt;&lt;p&gt;现在再回过头看我们一开始所说的：“所谓统一内存架构，就是通过 Fabric 高速总线将中央处理器、图形处理器、神经网络引擎、缓存、DRAM 内存全部连接在一起。”这不仅仅是简单的将各单元连接在一起，而是苹果这么多年在移动端 SoC 优秀实践经验的结晶，是只属于苹果自己独享的 moment。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4448633364750236&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybw9AhCUoE0unO7KNn5xmclBKsLjKukCZRVEBWWGBGymdkejE1lBtCmMgicBRiby43QCu5RKZDL46ABg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1061&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;所以说，这么一套搞下来，哪怕 M1 芯片的 CPU 芯片的物理性能没有得到提升，性能也不是最强大的，但 UMA 的设计架构也会给 M1 芯片带来综合性能的提升。&lt;/p&gt;&lt;p&gt;况且，谁说 M1 芯片的 CPU 就不行了呢？&lt;/p&gt;&lt;h2&gt;4. 制程&amp;amp;晶体管数量&lt;/h2&gt;&lt;p&gt;Apple 官网对于 M1 芯片有如下的介绍：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;M1 也是 Apple 首款采用先进 &lt;strong&gt;5 纳米&lt;/strong&gt;制程打造的个人电脑芯片，封装了惊人的 &lt;strong&gt;160 亿&lt;/strong&gt;个晶体管，其数量为 Apple 所有芯片之最。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;这里我将两个重要的数字加粗标注了出来，第一个数字是刚才提到的 5 纳米制程，第二个数字是 160 亿个晶体管。&lt;/p&gt;&lt;h3&gt;4.1 5 纳米制程指的是什么？&lt;/h3&gt;&lt;p&gt;当我们阅读一个和芯片有关的文章时，经常会看到诸如 5nm、7nm、14nm 这些词，例如华为的“最后一款”麒麟芯片，麒麟 9000 就是 5nm 工艺制程，那么这个 5nm 指的到底是什么呢？&lt;/p&gt;&lt;p&gt;说实话，这一块内容水太深了，我自己也不是从事半导体领域的，很难解释清楚，这里就只能简单的说明一下。&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;147&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.46570972886762363&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybw9AhCUoE0unO7KNn5xmclBiayEArCdibqib5U4hiatiaQP72wZDibcMCoibAW62eEnTelI0VKiclFXuicwRBA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;627&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;引用知乎的一张图，在上图所示的晶体管结构中，电流从 Source（源极）流入 Drain（漏级），Gate（栅极）相当于闸门，主要负责控制两端源极和漏级的通断。电流会损耗，而栅极的宽度则决定了电流通过时的损耗，表现出来就是手机常见的发热和功耗。宽度越窄，功耗越低。而栅极的最小宽度（栅长），就是 XX nm 工艺中的数值。&lt;/p&gt;&lt;p&gt;简单来说就是，Leakage Path 越小，电流损耗越小，总体来看就是功耗越小。宏观来看，随着 Leakage Path 越小，晶体管之间的距离就越小，单位面积内可以塞入的晶体管数量就越多，整体的运算性能就越强。&lt;/p&gt;&lt;p&gt;最近，AMD 疯狂 yes 的原因和其工艺制程的提升有很大关系，而此次 M1 芯片所采用的是目前市面上最先进的 5nm 工艺制程，性能强也是意料之中的事情了。&lt;/p&gt;&lt;h3&gt;4.2 为什么晶体管数量越多，运算性能越强？&lt;/h3&gt;&lt;p&gt;晶体管就可以看成一个小开关，有通断两种状态。你可以理解为通是 1，断是 0，那么一个晶体管的一次开，或者一次关，就提供一个 2 位的数据：0 或者 1。用无数个 0 或者 1 就可以代表所有的数据。这也就是为什么电子时代信息被称为数字化。其实就是把所有的信息用数字来表示。而数字，可以用电脑来处理。电脑是没法直接处理人类的信息的。这就是计算机采用二进制表示数据的的原因。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;所以我们要理解，是因为电路的这个特性才让先辈们选择二进制作为机器的语言，而不是因为二进制简单所以采用二进制的。这里提两个小问题：人为什么要使用十进制？生活中有没有使用其他进制计数的例子？欢迎在评论区留下你的想法。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img data-backh=&quot;122&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.3875476493011436&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybw9AhCUoE0unO7KNn5xmclBUKbP4yCAIeq7FmVcCrOY9yClbayLYOdXW83zS1Y7QdLgr1PbBkpEWw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1574&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;一个晶体管一次只能表示一个 0，或者 1。那么一大堆晶体管同时工作呢？&lt;/p&gt;&lt;p&gt;简单的说就像是一个大的存放开关的工厂，每个晶体管就是一个开关，关的时候表示 0，开的时候表示 1，晶体管越多，开关也越多，在处理同一个问题的时候走的线路也就越多。这就像是你以前学初中物理时的并联电路，支路越多流通的线路也越多。同样，CPU 的晶体管越多，单位时间内可以流过的电流的支路也就越多，反映在宏观上就是你在一颗 CPU 上能同时处理的数据也就越多，机器也就越快。&lt;/p&gt;&lt;p&gt;不过晶体管越多芯片性能越好这一点并不是绝对的，只是相对来说，晶体管多了之后，可设计的空间就更大了，剩下的就要看厂商能否利用好这部分设计空间了。&lt;/p&gt;&lt;h2&gt;5. M1 真的完美吗？&lt;/h2&gt;&lt;p&gt;那么问题来了？说了这么多 M1 芯片的优点，又是采用了 UMA 架构，又是最先进的工艺制程，他是一个完美的芯片吗？我想未必。&lt;/p&gt;&lt;h3&gt;5.1 扩展性&lt;/h3&gt;&lt;p&gt;相比上面的介绍让你对 M1 芯片的统一内存架构有了一定了解，也知道这样的架构对于性能的提升有很大的帮助。&lt;/p&gt;&lt;p&gt;只是将内存这样焊死在一块 SoC 芯片上，对于后期想要硬件扩展的用户来说，无疑是不可能的。&lt;/p&gt;&lt;p&gt;而且虽然 M1 的 GPU 的性能很强，但也是相对手机上的 GPU 来说的，和桌面级的 GPU 相比还是有很大的差距的，毕竟体积摆在那了，这对外接显示器或者玩游戏的用户来说也是很难熬的。同样的，外接显卡也是用不了的，不过应该也不会有人用 Mac 玩游戏吧。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Mac 当然可以玩游戏，这里挖个坑，下次我们来窥探一下未来——云游戏。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;5.2 兼容性&lt;/h3&gt;&lt;p&gt;从 x86 架构迁移到 ARM 架构，苹果是下了很大决心的，也是布局已久了。为了不让用户担心应用生态会出现较大的变化，苹果给出了三种不同应用的解决方案，分别是&lt;strong&gt;「Universal 通用应用」&lt;/strong&gt;、&lt;strong&gt;「Rosetta 2 转译应用」&lt;/strong&gt;以及&lt;strong&gt;「原生 ARM 应用」&lt;/strong&gt;。其中，Universal 是横跨 ARM 和 X86 平台的应用，目前以后部分开发者将自家软件转向 Universal，例如 Adobe 的 Lightroom，Photoshop 则会在明年更新。这里不得不感慨一下苹果的号召力，apple silicon 一出，各大厂商都在快速跟进，估计隔壁某厂要羡慕哭了。&lt;/p&gt;&lt;p&gt;如果新应用没有适配 Universal，那你也可以通过 Rosetta 2 转译应用，那些原生的 X86 编译应用可以通过苹果提供的 Rosetta 工具，转译成可以在 ARM 平台直接运行的应用，虽然会损失一些性能，但是可以极大提升兼容性。目前从各种兼容性测试视频来看，Rosetta 2 的完成度非常高，并不像隔壁某厂，推出的是一个半成品。&lt;/p&gt;&lt;p&gt;如果说，上面两种解决方案还是无法满足你的需求，那么你还可以依托苹果建成依旧的 App Store 生态，直接运行原生 ARM 应用，它们能够直接在 macOS、iOS 和 iPadOS 上运行，相当于苹果打通了小屏到大屏的主要设备。&lt;/p&gt;&lt;p&gt;即便曾经 macOS 的软件生态还不完善，但在 iOS 几乎已经没有了这个问题，也使得搭载 M1 芯片的 Mac 产品并不需要太过担心没有足够的应用可以使用。&lt;/p&gt;&lt;p&gt;而且，从此次更新的 macOS Big Sur 也可以看出，苹果也是有意让这三端的风格更加统一。无论是系统界面还是图标样式，都在往 iPad 和 iPhone 上统一。&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;165&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.5231481481481481&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybw9AhCUoE0unO7KNn5xmclBNEBvaKKw3knxZB0NicJyQzLZXz9AA6LV786xZVwJehicyBFG0dDuR2Qg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;那么为什么同样的软件在迁移的时候会有兼容性的问题？这已经和本文要介绍的 M1 没什么关系了，考虑到篇幅问题，我们之后再说。&lt;/p&gt;&lt;p&gt;那么到底 M1 版 MacBook 能兼容什么软件、不能兼容什么软件？&lt;/p&gt;&lt;p&gt;一个个软件测试，工程量非常大，而且软件们也处于不停的更新换代中。好在 GitHub 上出现了一个关于 M1 版 MacBook 的兼容性测试项目“DoseitARM”。在这个项目中，可以看到开发工具、影音工具、图形图像工具、剪辑工具等各种生产力软件的兼容性测试。各类软件的兼容性又被分为几种不同的情况，分别如下：&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;96&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.30594405594405594&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybw9AhCUoE0unO7KNn5xmclB97WOAUwSfqYQmsuVLRvI5OL236icOqjVruS7Yn2u5RVibFhgG95ZTChg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1144&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;他的地址是 👉：https://github.com/ThatGuySam/doesitarm&lt;/p&gt;&lt;p&gt;有兴趣的读者可以长期关注该项目。&lt;/p&gt;&lt;h2&gt;6. 最后&lt;/h2&gt;&lt;p&gt;对于财大气粗的苹果来说，未来无疑将会长期进行大量的投入来对 M 系列芯片进行迭代，并且其自有生态也保证了能够反哺 M 系列芯片的研发。希望国内的企业也可以像苹果一样有属于自己的芯片，未来值得期待！&lt;/p&gt;&lt;p&gt;如果你觉得我的文章对你有所帮助，不妨点个赞关注我，就当是给我的一点鼓励了，你们的鼓励会让我更加努力做好分享，感谢支持 🙏。&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下图是我新建的读者群，有兴趣的读者可以扫码加群一起交流，一起进步～&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.2427536231884058&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2Gybw9AhCUoE0unO7KNn5xmclB7ic6ibDicEf63WmV7gQBKq7fiaSg2Jwl8qtZiayJpNyPUTXic6IajXWic1XKQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;828&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>