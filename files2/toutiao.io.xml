<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>8551e70740a5c67b671b491ab67438de</guid>
<title>深入分析 MySQL 系列之总体架构介绍</title>
<link>https://toutiao.io/k/zm3jxob</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entry-inner&quot;&gt;
                                                    
&lt;p&gt;在我们详细深入介绍MySQL的方方面面之前，让我们首先来看一下MySQL的总体架构，从总体上对MySQL有所了解，这样我们在后面的具体介绍部分的时候才能够知道这些部分属于哪个模块，大概有什么样的作用。&lt;/p&gt;



&lt;h2&gt;MySQL的逻辑架构&lt;/h2&gt;



&lt;p&gt;首先我们来看一下MySQL的逻辑架构，如下图所示。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/07/image-11.png&quot; alt=&quot;&quot; class=&quot;wp-image-793&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/07/image-11.png 566w, https://donggeitnote.com/wp-content/uploads/2021/07/image-11-224x300.png 224w&quot; sizes=&quot;(max-width: 566px) 100vw, 566px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;我们可以看到大概可以分成三层：&lt;/p&gt;



&lt;ul&gt;&lt;li&gt;Connection/thread handing，这一层其实和MySQL没有什么大的关系，在一般的C/S架构中都会存在，一般用来处理相关的连接，认证，安全等等方面，我们不具体介绍。&lt;/li&gt;&lt;li&gt;Parser/Optimizer。这一层就是MySQL的大脑了，它主要工作就是解析查询语句，分析并进行优化，所有跨storage engines的函数都是在这里实现的，比如Stored Procedures，views等等。&lt;/li&gt;&lt;li&gt;Storage Engines。顾名思义，这一层的主要作用就是存储和查询数据。MySQL支持很多种不同的Storage Engine，我们在后面一一给大家介绍。&lt;/li&gt;&lt;/ul&gt;



&lt;h2&gt;并行控制&lt;/h2&gt;



&lt;p&gt;在了解了MySQL的逻辑架构之后，我们来看一下MySQL对一些常见数据库的问题的处理方法。第一个问题当然就是我们常见的并行控制，简单说就是有读写同时发生的时候会如何处理。我们在之前的文章介绍过常见的处理方法，这里MySQL选用的是读写锁，也就是说读获取锁的时候，可以有多个读同时进行，但是写的锁是排外的，也就是说有写获取锁，那么任何别的读和写都没有办法获取相应的锁。&lt;/p&gt;



&lt;p&gt;使用锁有一个重要的问题就是如何确定锁的粒度，说白了，你把锁加在越大的粒度上，并行的性能就会降低，因为拿不到锁的概率就会变大。假如你把锁的粒度搞到比较小，拿不到锁的概率就会变低，这样并行的性能就会变好，但是问题是锁消耗的资源其实是很大的看，粒度越小就意味着需要更多的锁，从而有更多的资源消耗。这就是我们需要考虑的trade off。&lt;/p&gt;



&lt;p&gt;MySQL在这个方面提供了一些选择，根据不同的Storage engine可以实现不同的锁机制和锁粒度。不过通常来说有两种锁的机制比较常见：&lt;/p&gt;



&lt;ul&gt;&lt;li&gt;&lt;strong&gt;表锁：&lt;/strong&gt;顾名思义，即使lock整个表。每次写一个表的时候都去抓这个表锁，也就意味着其它任何读写都需要等待这个锁。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;行锁：&lt;/strong&gt;这个锁的粒度相比表锁来说就细了很多，它是应用到一行上面的。也就是说只有这行的数据被修改的时候，才会影响到需要修改这行数据的读和写。这样一来其实并行读写的性能就会变得比较好。&lt;/li&gt;&lt;/ul&gt;



&lt;p&gt;大多数MySQL使用的不是简单的行锁。他们使用的是行锁和一种称之为多版本同步控制（MVCC）的技术。这个技术我们在之前的《&lt;a href=&quot;https://donggeitnote.com/2021/06/06/snapshot-isolation/&quot;&gt;Snapshot的隔离和Repeatable的读&lt;/a&gt;》中有详细的介绍。&lt;/p&gt;



&lt;h2&gt;Transaction&lt;/h2&gt;



&lt;p&gt;Transaction是一个通用的概念，这里我们不详细介绍，大家可以参考《&lt;a href=&quot;https://donggeitnote.com/2021/06/03/transaction-introduction/&quot;&gt;Transactions的基本概念和介绍&lt;/a&gt;》这篇文章。&lt;/p&gt;



&lt;p&gt;具体到MySQL，它有不同的storage engine支持Transaction，我们这里以最推荐的InnoDB来说明。&lt;/p&gt;



&lt;p&gt;默认来说，单独的Insert，Update以及Delete操作是被隐式地转变成 一个Transaction并且立即commit的。也就是我们常说的AUTOCOMMIT。你可以使用SET AUTOCMMIT = 0/1来关掉或者打开这个功能。注意关掉之后，你就会一直在一个transaction里面，直到你commit或者rollback。&lt;/p&gt;



&lt;p&gt;另外MySQL还可以自己设置隔离的级别，你可以简单使用下面这个命令来进行设置&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/07/image-12.png&quot; alt=&quot;&quot; class=&quot;wp-image-794&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/07/image-12.png 624w, https://donggeitnote.com/wp-content/uploads/2021/07/image-12-300x25.png 300w&quot; sizes=&quot;(max-width: 624px) 100vw, 624px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;如果你想了解具体关于transaction的隔离相关知识，可以参见这些文章：&lt;/p&gt;



&lt;p&gt;《&lt;a href=&quot;https://donggeitnote.com/2021/06/06/transaction-read-commit/&quot;&gt;Transaction弱隔离之读提交的介绍和实现&lt;/a&gt;》&lt;/p&gt;



&lt;p&gt;《&lt;a href=&quot;https://donggeitnote.com/2021/06/06/snapshot-isolation/&quot;&gt;Snapshot的隔离和Repeatable的读&lt;/a&gt;》&lt;/p&gt;



&lt;p&gt;《&lt;a href=&quot;https://donggeitnote.com/2021/06/08/transaction-update-lost/&quot;&gt;Transaction弱隔离之更新丢失&lt;/a&gt;》&lt;/p&gt;



&lt;p&gt;《&lt;a href=&quot;https://donggeitnote.com/2021/06/10/transaction-write-skew/&quot;&gt;Transaction弱隔离之Write Skew和Phantoms&lt;/a&gt;》&lt;/p&gt;



&lt;p&gt;《&lt;a href=&quot;https://donggeitnote.com/2021/06/13/transaction-serializable/&quot;&gt;Transaction Serializable隔离之串行执行&lt;/a&gt;》&lt;/p&gt;



&lt;p&gt;《&lt;a href=&quot;https://donggeitnote.com/2021/06/15/transaction-serializable-2pl/&quot;&gt;Transaction Serializable隔离之两阶段锁&lt;/a&gt;》&lt;/p&gt;



&lt;p&gt;《&lt;a href=&quot;https://donggeitnote.com/2021/06/16/serializable-ssi/&quot;&gt;一文带你深入理解Serializable隔离最新技术SSI&lt;/a&gt;》&lt;/p&gt;



&lt;p&gt;相信读了这些文章之后，你会对Transaction的隔离相关内容有一个非常清晰的理解。&lt;/p&gt;



&lt;p&gt;需要注意的是在MySQL中，transaction是在storage engine level实现的，这也就意味着假如你一个transaction设计多个不同的engine，那么这个transaction是不可靠的，因为不同的engine都有自己的设置，尤其是需要rollback的时候，可能transaction在其中一个engine中的内容被rollback了，而另外一个则没有。当然有时它会报错，但是很多时候都不会有这样的错误出现，所以你自己需要小心。&lt;/p&gt;



&lt;p&gt;另外InnoDB使用的是两阶段锁，同时它也支持现实锁的设置，如下所示，这个是MySQL 8.0的新的功能。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/07/image-10.png&quot; alt=&quot;&quot; class=&quot;wp-image-792&quot;/&gt;&lt;/figure&gt;



&lt;h2&gt;Replication&lt;/h2&gt;



&lt;p&gt;MySQL中的replication使用的是pull的模式，也就是说它的每个replica是周期性的到source那边进行pull最新的log。简单的示意图如下所示：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/07/image-9.png&quot; alt=&quot;&quot; class=&quot;wp-image-791&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/07/image-9.png 506w, https://donggeitnote.com/wp-content/uploads/2021/07/image-9-300x218.png 300w&quot; sizes=&quot;(max-width: 506px) 100vw, 506px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;通常来说为了更好地达到replication的目的，我们需要有最少3个replica，他们最好能分布在不同的数据中心（位置）。这样即使有灾难发生，比如地震等等，我们也能保证有至少一个repica是可以使用的。有关replication的基础知识可以参见这篇文章《&lt;a href=&quot;https://donggeitnote.com/2021/05/22/leader-followers-replication/&quot;&gt;分布式系统之leader-followers Replication深入介绍&lt;/a&gt;》。&lt;/p&gt;



&lt;h2&gt;Storage Engines&lt;/h2&gt;



&lt;p&gt;MySQL支持很多不同的Storage Engine，你可以根据自己的应用需求来进行选择。每个版本的MySQL对Storage Engine都有不同的支持。具体可能需要大家参考各个版本的说明。&lt;/p&gt;



&lt;p&gt;在8.0之前，MySQL每个数据库是按照文件系统中的子目录格式来存储的。你创建了一个表，MySQL把表保存成一个.frm文件（定义）和一个.ibd文件（存储数据）。所以你创建了一个表Test，就会有两个文件出现，一个是Test.frm一个是Test.ibd。假如你使用了partition的话，还会有一个Test.par文件。&lt;/p&gt;



&lt;p&gt;在8.0之中，MySQL重新定义了表的metadata，把它直接包含到标的.ibd文件中。这样一来表的结构就支持了transaction和atomic数据定义的改变。这样我们可以使用一个基于LRU的memory cache来保存partition的定义，表的定义等等。这样可以有效的降低了IO的消耗。&lt;/p&gt;



&lt;p&gt;下面我们来看几种常见的存储引擎：&lt;/p&gt;



&lt;h3&gt;InnoDB引擎&lt;/h3&gt;



&lt;p&gt;我们其实上文也提到过，InnoDB是MySQL默认的也是最常见的存储引擎。它主要应用于那些很短的transaction。另外它的性能很好，且支持自动crash恢复，所以常见的无transaction应用也会使用它。&lt;/p&gt;



&lt;p&gt;InnoDB使用的MVCC来实现concurrency的处理，并且实现了所有的四种隔离。默认是Repeatable read的隔离。它使用的cluster index，所以primary key的查询很快，但是secondary index则有可能受primary key影响。&lt;/p&gt;



&lt;p&gt;InnoDB有一些内置的优化，比如预测读，内存哈希索引加速查询，插入buffer来加速插入操作等。后面我们会再写几篇文章来详细介绍这些内容。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;JSON&lt;/strong&gt;&lt;strong&gt;文档支持&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;从5.7版本开始，MySQL的InnoDB开始支持JSON格式的自动validation以及快速读。和以前的BLOB的存储方式相比有了很大的进步。紧接着InnoDB设置可以支持一些基于JSON的SQL函数。8.0.7之后，开始支持JSON数组的多指索引。这可以进一步加速JSON格式的匹配某种pattern的读速度。&lt;/p&gt;



&lt;h3&gt;MYISAM&lt;/h3&gt;



&lt;p&gt;这个引擎是MySQL的第一个引擎，也是5.6之前的默认引擎。它不支持transaction也不支持行锁。在8.0中已经完全移除了。&lt;/p&gt;



&lt;h3&gt;Archive Engine&lt;/h3&gt;



&lt;p&gt;Archive Engine只支持INSERT和SELECT查询，直到5.1才支持索引，相比来说，磁盘IO消耗会小很多。它只是一个简单的为高速插入和压缩设计的引擎。&lt;/p&gt;



&lt;h3&gt;CSV Engine&lt;/h3&gt;



&lt;p&gt;CSB引擎可以把逗号分割文件解析成表格，但是不支持索引。所以可以很方便地进行csv文件的导入和导出。&lt;/p&gt;



&lt;h3&gt;Memory Engine&lt;/h3&gt;



&lt;p&gt;这个引擎是用来匹配快速读写或者不需要在重启时保存的场景的。所有的数据都是保存在memory中，所以查询速度很快，不需要等待I/O。但是不会有数据保存。其实MySQL内部会使用它来作为一些临时表的结果保存。当然数据太大，也会把它转变成其他格式比如MyISAM表保存到磁盘中等。&lt;/p&gt;



&lt;h3&gt;Merge Storage Engine&lt;/h3&gt;



&lt;p&gt;它是多个MyISAM的组合，现在已经被废弃了。&lt;/p&gt;



&lt;h2&gt;总结&lt;/h2&gt;



&lt;p&gt;至此，本文详细介绍了MySQL的基本架构以及常见的并行控制，transaction, replication的实现。最后还介绍了各种不同的Storage Engine，希望大家阅读后能对MySQL有一个大概的了解。&lt;/p&gt;
                                                    &lt;nav class=&quot;pagination group&quot;&gt;
                      &lt;/nav&gt;
        &lt;/div&gt;

        
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cd0334c95b94f28c61bc9ff6e613b0d7</guid>
<title>你觉得我的这段 Java 代码还有优化的空间吗？</title>
<link>https://toutiao.io/k/lqm7cmx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article class=&quot;article-content&quot;&gt;
&lt;p&gt;上周，因为要测试一个方法的在并发场景下的结果是不是符合预期，我写了一段单元测试的代码。写完之后截了个图发了一个朋友圈，很多人表示短短的几行代码，涉及到好几个知识点。&lt;/p&gt;
&lt;p&gt;还有人给出了一些优化的建议。那么，这是怎样的一段代码呢？涉及到哪些知识，又有哪些可以优化的点呢？&lt;/p&gt;
&lt;p&gt;让我们来看一下。&lt;/p&gt;
&lt;h3&gt;背景&lt;/h3&gt;
&lt;p&gt;先说一下背景，也就是要知道我们单元测试要测的这个方法具体是什么样的功能。我们要测试的服务是AssetService，被测试的方法是update方法。&lt;/p&gt;
&lt;p&gt;update方法主要做两件事，第一个是更新Asset、第二个是插入一条AssetStream。&lt;/p&gt;
&lt;p&gt;更新Asset方法中，主要是更新数据库中的Asset的信息，这里为了防止并发，使用了乐观锁。&lt;/p&gt;
&lt;p&gt;插入AssetStream方法中，主要是插入一条AssetStream的流水信息，为了防止并发，这里在数据库中增加了唯一性约束。&lt;/p&gt;
&lt;p&gt;为了保证数据一致性，我们通过本地事务将这两个操作包在同一个事务中。&lt;/p&gt;
&lt;p&gt;以下是主要的代码，当然，这个方法中还会有一些前置的幂等性校验、参数合法性校验等，这里就都省略了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Service
public class AssetServiceImpl implements AssetService {

    @Autowired
    private TransactionTemplate transactionTemplate;

    @Override
    public String update(Asset asset) {
        //参数检查、幂等校验、从数据库取出最新asset等。
        return transactionTemplate.execute(status -&amp;gt; {
            updateAsset(asset);
            return insertAssetStream(asset);
        });
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为这个方法可能会在并发场景中执行，所以该方法通过事务+乐观锁+唯一性约束做了并发控制。关于这部分的细节就不多讲了，大家感兴趣的话后面我再展开关于如何防并发的内容。&lt;/p&gt;
&lt;h3&gt;单测&lt;/h3&gt;
&lt;p&gt;因为上面这个方法是可能在并发场景中被调用的，所以需要在单测中模拟并发场景，于是，我就写了以下的单元测试的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class AssetServiceImplTest {

    private static ThreadFactory namedThreadFactory = new ThreadFactoryBuilder()
        .setNameFormat(&quot;demo-pool-%d&quot;).build();

    private static ExecutorService pool = new ThreadPoolExecutor(5, 100,
        0L, TimeUnit.MILLISECONDS,
        new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(128), namedThreadFactory, new ThreadPoolExecutor.AbortPolicy());

    @Autowired
    AssetService assetService;

    @Test
    public void test_updateConcurrent() {
        Asset asset = getAsset();
        //参数的准备
        //...

        //并发场景模拟
        CountDownLatch countDownLatch = new CountDownLatch(10);
        AtomicInteger failedCount =new AtomicInteger();            
        //并发批量修改，只有一条可以修改成功
        for (int i = 0; i &amp;lt; 10; i++) {
            pool.execute(() -&amp;gt; {
                try {
                    String streamNo = assetService.update(asset);
                } catch (Exception e) {
                    System.out.println(&quot;Error : &quot; + e);
                    failedCount.getAndIncrement();
                } finally {
                    countDownLatch.countDown();
                }
            });
        }

        try {
            //主线程等子线程都执行完之后查询最新的资产
            countDownLatch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        Assert.assertEquals(failedCount.intValue(), 9);

        // 从数据库中反查出最新的Asset
        // 再对关键字段做注意校验
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上，就是我做了简化之后的单元测试的部分代码。因为要测并发场景，所以这里面涉及到了很多并发相关的知识。&lt;/p&gt;
&lt;p&gt;很多人之前和我说，并发相关的知识自己了解的很多，但是好像没什么机会写并发的代码。其实，单元测试就是个很好的机会。&lt;/p&gt;
&lt;p&gt;我们来看看上面的代码涉及到哪些知识点？&lt;/p&gt;
&lt;h3&gt;知识点&lt;/h3&gt;
&lt;p&gt;以上这段单元测试的代码中涉及到几个知识点，我这里简单说一下。&lt;/p&gt;
&lt;h4&gt;线程池&lt;/h4&gt;
&lt;p&gt;这里面因为要模拟并发的场景，所以需要用到多线程， 所以我这里使用了线程池，而且我没有直接用Java提供的Executors类创建线程池。&lt;/p&gt;
&lt;p&gt;而是使用guava提供的ThreadFactoryBuilder来创建线程池，使用这种方式创建线程时，不仅可以避免OOM的问题，还可以自定义线程名称，更加方便的出错的时候溯源。（&lt;a href=&quot;https://www.hollischuang.com/archives/2888&quot;&gt;关于线程池创建的OOM问题&lt;/a&gt;）&lt;/p&gt;
&lt;h4&gt;CountDownLatch&lt;/h4&gt;
&lt;p&gt;因为我的单元测试代码中，希望在所有的子线程都执行之后，主线程再去检查执行结果。&lt;/p&gt;
&lt;p&gt;所以，如何使主线程阻塞，直到所有子线程执行完呢？这里面用到了一个同步辅助类CountDownLatch。&lt;/p&gt;
&lt;p&gt;用给定的计数初始化 CountDownLatch。由于调用了 countDown() 方法，所以在当前计数到达零之前，await 方法会一直受阻塞。（&lt;a href=&quot;https://www.hollischuang.com/archives/290&quot;&gt;多线程中CountDownLatch的用法&lt;/a&gt;）&lt;/p&gt;
&lt;h4&gt;AtomicInteger&lt;/h4&gt;
&lt;p&gt;因为我在单测代码中，创建了10个线程，但是我需要保证只有一个线程可以执行成功。所以，我需要对失败的次数做统计。&lt;/p&gt;
&lt;p&gt;那么，如何在并发场景中做计数统计呢，这里用到了AtomicInteger，这是一个原子操作类，可以提供线程安全的操作方法。&lt;/p&gt;
&lt;h4&gt;异常处理&lt;/h4&gt;
&lt;p&gt;因为我们模拟了多个线程并发执行，那么就一定会存在部分线程执行失败的情况。&lt;/p&gt;
&lt;p&gt;因为方法底层没有对异常进行捕获。所以需要在单测代码中进行异常的捕获。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    try {
        String streamNo = assetService.update(asset);
    } catch (Exception e) {
        System.out.println(&quot;Error : &quot; + e);
        failedCount.increment();
    } finally {
        countDownLatch.countDown();
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码中，try、catch、finall都用上了，而且位置是不能调换的。失败次数的统计一定要放到catch中，countDownLatch的countDown也一定要放到finally中。&lt;/p&gt;
&lt;h4&gt;Assert&lt;/h4&gt;
&lt;p&gt;这个相信大家都比较熟悉，这就是JUnit中提供的断言工具类，在单元测试时可以用做断言。这就不详细介绍了。&lt;/p&gt;
&lt;h3&gt;优化点&lt;/h3&gt;
&lt;p&gt;以上代码涉及到了很多知识点，但是，难道就没有什么优化点了吗？&lt;/p&gt;
&lt;p&gt;首先说一下，其实单元测试的代码对性能、稳定性之类的要求并不高，所谓的优化点，也并不是必要的。这里只是说讨论下，如果真的是要做到精益求精，还有什么点可以优化呢？&lt;/p&gt;
&lt;h4&gt;使用LongAdder代替AtomicInteger&lt;/h4&gt;
&lt;p&gt;我的朋友圈的网友@zkx 提出，可以使用LongAdder代替AtomicInteger。&lt;/p&gt;
&lt;p&gt;java.util.concurrency.atomic.LongAdder是Java8新增的一个类，提供了原子累计值的方法。而且在其Javadoc中也明确指出其性能要优于AtomicLong。&lt;/p&gt;
&lt;p&gt;首先它有一个基础的值base，在发生竞争的情况下，会有一个Cell数组用于将不同线程的操作离散到不同的节点上去(会根据需要扩容，最大为CPU核数，即最大同时执行线程数)，sum()会将所有Cell数组中的value和base累加作为返回值。&lt;/p&gt;
&lt;p&gt;核心的思想就是将AtomicLong一个value的更新压力分散到多个value中去，从而降低更新热点。所以在激烈的锁竞争场景下，LongAdder性能更好。&lt;/p&gt;
&lt;h4&gt;增加并发竞争&lt;/h4&gt;
&lt;p&gt;朋友圈网友 Cafebabe 和 @普渡众生的面瘫青年 都提到同一个优化点，那就是如何增加并发竞争。&lt;/p&gt;
&lt;p&gt;这个问题其实我在发朋友圈之前就有想到过，心中早已经有了答案，只不过有两位朋友能够几乎同时提到这一点还是很不错的。&lt;/p&gt;
&lt;p&gt;我们来说说问题是什么。&lt;/p&gt;
&lt;p&gt;我们为了提升并发，使用线程池创建了多个线程，想让多个线程并发执行被测试的方法。&lt;/p&gt;
&lt;p&gt;但是，我们是在for循环中依次执行的，那么理论上这10次update方法的调用是顺序执行的。&lt;/p&gt;
&lt;p&gt;当然，因为有CPU时间片的存在，这10个线程会争抢CPU，真正执行的过程中还是会发生并发冲突的。&lt;/p&gt;
&lt;p&gt;但是，为了稳妥起见，我们还是需要尽量模拟出多个线程同时发起方法调用的。&lt;/p&gt;
&lt;p&gt;优化的方法也比较简单，那就是在每一个update方法被调用之前都wait一下，直到所有的子线程都创建成功了，再开始一起执行。&lt;/p&gt;
&lt;p&gt;这就还可以用都到我们前面讲过的CountDownLatch。&lt;/p&gt;
&lt;p&gt;所以，最终优化后的单测代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//主线程根据此CountDownLatch阻塞
CountDownLatch mainThreadHolder = new CountDownLatch(10);

//并发的多个子线程根据此CountDownLatch阻塞
CountDownLatch multiThreadHolder = new CountDownLatch(1);

//失败次数计数器
LongAdder failedCount = new LongAdder();

//并发批量修改，只有一条可以修改成功
for (int i = 0; i &amp;lt; 10; i++) {
    pool.execute(() -&amp;gt; {
        try {
            //子线程等待，等待主线程通知后统一执行
            multiThreadHolder.await();
            //调用被测试的方法
            String streamNo = assetService.update(asset);
        } catch (Exception e) {
            //异常发生时，对失败计数器+1
            System.out.println(&quot;Error : &quot; + e);
            failedCount.increment();
        } finally {
            //主线程的阻塞器奇数-1
            mainThreadHolder.countDown();
        }
    });
}

//通知所有子线程可以执行方法调用了
multiThreadHolder.countDown();

try {
    //主线程等子线程都执行完之后查询最新的资产池计划
    mainThreadHolder.await();
} catch (InterruptedException e) {
    e.printStackTrace();
}

//断言，保证失败9次，则成功一次
Assert.assertEquals(failedCount.intValue(), 9);

// 从数据库中反查出最新的Asset
// 再对关键字段做注意校验
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上，就是关于我的一次单元测试的代码所涉及到的知识点，以及目前所能想到的相关的优化点。&lt;/p&gt;
&lt;p&gt;第一次被公众号上近20万读者在线CodeReview，有点小小紧张。但是还是想问一下，对于这部分代码，你觉得还有什么可以优化的地方吗？&lt;/p&gt;
&lt;center&gt;&lt;b&gt;(全文完)&lt;/b&gt;&lt;/center&gt;&lt;hr/&gt;&lt;center&gt;&lt;b&gt;扫描二维码，关注作者微信公众号&lt;/b&gt;&lt;/center&gt;&lt;img src=&quot;http://www.hollischuang.com/wp-content/uploads/2019/04/二维码.png&quot;/&gt;
&lt;/article&gt;
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>57f850ef710d20d0c6506f3a96e8162c</guid>
<title>漫画：要不是因为家庭困难，谁会选择干程序员？</title>
<link>https://toutiao.io/k/qd3xnuw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d4a9edebd90976b72530def8199415e8</guid>
<title>由两道面试题，深入线程池，并连环 17 问</title>
<link>https://toutiao.io/k/nzgfdcv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你好，我是yes。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两面试题是基友朋友最近去面滴滴遇到的，今天就借着这两面试真题来深入一波线程池吧，这篇文章力求把线程池核心点和常问的面试点一网打尽，当然个人能力有限，可能会有遗漏，欢迎留言补充！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先把问题列出来，如果你都答得出来，那没必要看下去：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;为什么会有线程池？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;简单手写一个线程池？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么要把任务先放在任务队列里面，而不是把线程先拉满到最大线程数？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程池如何动态修改核心线程数和最大线程数？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果你是 JDK 设计者，如何设计？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果要让你设计一个线程池，你要怎么设计？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你是如何理解核心线程的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你是怎么理解 KeepAliveTime 的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;那 workQueue 有什么用？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你是如何理解拒绝策略的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你说你看过源码，那你肯定知道线程池里的 ctl 是干嘛的咯？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你知道线程池有几种状态吗？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你知道线程池的状态是如何变迁的吗？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何修改原生线程池，使得可以先拉满线程数再入任务队列排队？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Tomcat 中的定制化线程池实现 如果线程池中的线程在执行任务的时候，抛异常了，会怎么样？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;原生线程池的核心线程一定伴随着任务慢慢创建的吗？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程池的核心线程在空闲的时候一定不会被回收吗？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接得住吗？话不多说，发车！&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;为什么会有线程池？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想要深入理解线程池的原理得先知道为什么需要线程池。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先你要明白，&lt;span&gt;线程是一个重资源&lt;/span&gt;，JVM 中的线程与操作系统的线程是一对一的关系，所以在 JVM 中每创建一个线程就需要调用操作系统提供的 API 创建线程，赋予资源，并且销毁线程同样也需要系统调用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而系统调用就意味着上下文切换等开销，并且线程也是需要占用内存的，而内存也是珍贵的资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此线程的创建和销毁是一个&lt;span&gt;重操作&lt;/span&gt;，并且线程本身也占用资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后你还需要知道，&lt;span&gt;线程数并不是越多越好&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道线程是 CPU 调度的最小单位，在单核时代，如果是纯运算的操作是不需要多线程的，一个线程一直执行运算即可。但如果这个线程正在等待 I/O 操作，此时 CPU 就处于空闲状态，这就浪费了 CPU 的算力，因此有了多线程，在某线程等待 I/O 等操作的时候，另一个线程顶上，充分利用 CPU，提高处理效率。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nFApmmGxuSmkFnGZIczU6HYyHnZOzKUKIJkVqXDC1WszOT7V18faAdnW0f7JPoAjAQWjIzic6Qm9Kg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时的多线程主要是为了提高 CPU 的利用率而提出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而随着 CPU 的发展，核心数越来越多，能同时运行的线程数也提升了，此时的多线程不仅是为了提高单核 CPU 的利用率，也是为了充分利用多个核心。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此想必应该明白了为什么会有多线程，无非就是为了充分利用 CPU 空闲的时间，一刻也不想让他停下来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但 CPU 的核心数有限，同时能运行的线程数有限，所以需要根据调度算法切换执行的线程，而线程的切换需要开销，比如替换寄存器的内容、高速缓存的失效等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果线程数太多，切换的频率就变高，可能使得多线程带来的好处抵不过线程切换带来的开销，得不偿失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此线程的数量需要得以控制，结合上述的描述可知，线程的数量与 CPU 核心数和 I/O 等待时长息息相关。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小结一下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Java中线程与操作系统线程是一比一的关系。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程的创建和销毁是一个“较重”的操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;多线程的主要是为了提高 CPU 的利用率。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程的切换有开销，线程数的多少需要结合 CPU核心数与 I/O 等待占比。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;综上我们知道了线程的这些特性，所以说它不是一个可以“随意拿捏”的东西，我们需要重视它，好好规划和管理它，充分利用硬件的能力，从而提升程序执行效率，所以线程池应运而生。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是线程池？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那我们要如何管理好线程呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为线程数太少无法充分利用 CPU ，太多的话由于上下文切换的消耗又得不偿失，所以我们需要评估系统所要承载的并发量和所执行任务的特性，得出大致需要多少个线程数才能充分利用 CPU，因此需要&lt;span&gt;控制线程数量&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;又因为线程的创建和销毁是一个“重”操作，所以我们需要避免线程频繁地创建与销毁，因此我们需要&lt;span&gt;缓存一批线程&lt;/span&gt;，让它们时刻准备着执行任务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目标已经很清晰了，弄一个池子，里面存放约定数量的线程，这就是线程池，一种池化技术。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;熟悉对象池、连接池的朋友肯定对池化技术不陌生，&lt;span&gt;一般池化技术的使用方式是从池子里拿出资源&lt;/span&gt;，然后使用，用完了之后归还。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但是线程池的实现不太一样&lt;/span&gt;，不是说我们从线程池里面拿一个线程来执行任务，等任务执行完了之后再归还线程，你可以想一下这样做是否合理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池的常见实现更像是一个黑盒存在，我们设置好线程池的大小之后，直接往线程池里面丢任务，然后就不管了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6058700209643606&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nFApmmGxuSmkFnGZIczU6HY9DV4yJWzLTQsFKMvmvQXD6KPvzAbY2RiblSf9pflWZNwo7uYKiaF82iaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;954&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;剥开来看，&lt;span&gt;线程池其实是一个典型的生产者-消费者模式&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池内部会有一个队列来存储我们提交的任务，而内部线程不断地从队列中索取任务来执行，这就是线程池最原始的执行机制。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4773462783171521&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nFApmmGxuSmkFnGZIczU6HYuQ8utgPjUGeuX45a7eVWYI4CL8Yfqnicx3Z2j4QjtKSfAqiaRIyeSkHQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1236&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照这个思路，我们可以很容易的实现一个简单版线程池，想必看了下面这个代码实现，对线程池的核心原理就会了然于心。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先线程池内需要定义两个成员变量，分别是阻塞队列和线程列表，然后自定义线程使它的任务就是不断的从阻塞队列中拿任务然后执行。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;YesThreadPool&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt; BlockingQueue&amp;lt;Runnable&amp;gt; taskQueue;  &lt;span&gt;//存放任务的阻塞队列&lt;/span&gt;&lt;br/&gt; List&amp;lt;YesThread&amp;gt; threads; &lt;span&gt;//线程列表&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; YesThreadPool(BlockingQueue&amp;lt;Runnable&amp;gt; taskQueue, &lt;span&gt;int&lt;/span&gt; threadSize) {&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.taskQueue = taskQueue;&lt;br/&gt;  threads = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(threadSize);&lt;br/&gt;  &lt;span&gt;// 初始化线程，并定义名称&lt;/span&gt;&lt;br/&gt;  IntStream.rangeClosed(&lt;span&gt;1&lt;/span&gt;, threadSize).forEach((i)-&amp;gt; {&lt;br/&gt;   YesThread thread = &lt;span&gt;new&lt;/span&gt; YesThread(&lt;span&gt;&quot;yes-task-thread-&quot;&lt;/span&gt; + i);&lt;br/&gt;   thread.start();&lt;br/&gt;   threads.add(thread);&lt;br/&gt;  });&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;//提交任务只是往任务队列里面塞任务&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;execute&lt;/span&gt;&lt;span&gt;(Runnable task)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;  taskQueue.put(task);&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;YesThread&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Thread&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;//自定义一个线程&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;YesThread&lt;/span&gt;&lt;span&gt;(String name)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;super&lt;/span&gt;(name);&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) { &lt;span&gt;//死循环&lt;/span&gt;&lt;br/&gt;    Runnable task = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;     task = taskQueue.take(); &lt;span&gt;//不断从任务队列获取任务&lt;/span&gt;&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;     logger.error(&lt;span&gt;&quot;记录点东西.....&quot;&lt;/span&gt;, e);&lt;br/&gt;    }&lt;br/&gt;    task.run(); &lt;span&gt;//执行&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个简单版线程池就完成了，简单吧！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再写个 main 方法用一用，丝滑，非常丝滑。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  YesThreadPool pool = &lt;span&gt;new&lt;/span&gt; YesThreadPool(&lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;&amp;gt;(&lt;span&gt;10&lt;/span&gt;), &lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;  IntStream.rangeClosed(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;).forEach((i)-&amp;gt; {&lt;br/&gt;   &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    pool.execute(()-&amp;gt; {&lt;br/&gt;     System.out.println(Thread.currentThread().getName() + &lt;span&gt;&quot; 公众号：yes的练级攻略&quot;&lt;/span&gt;);&lt;br/&gt;    });&lt;br/&gt;   } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;    logger.error(&lt;span&gt;&quot;记录点东西.....&quot;&lt;/span&gt;, e);&lt;br/&gt;   }&lt;br/&gt;  });&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行结果如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3713527851458886&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nFApmmGxuSmkFnGZIczU6HY9XCeMy1mrl4f2RKUpGFrbFKBibnETadzVsujHqECiczKBQbH1S5JCKGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;377&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下次面试官让你手写线程池，直接上这个简单版，然后他会开始让你优化，比如什么线程一开始都 start 了不好，想懒加载，然后xxxx...最终其实就是想往李老爷实现的 ThreadPoolExecutor 上面靠。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那就来嘛。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;ThreadPoolExecutor 剖析&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这玩意就是常被问的线程池的实现类了，先来看下构造函数：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2926829268292683&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nFApmmGxuSmkFnGZIczU6HY4eiaJ8I5TzVcVP0R57kN6icmHUVrNhdd5Yk8CkbSF07sq0YyY4zqAatQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;861&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;核心原理其实和咱们上面实现的差不多，只是生产级别的那肯定是要考虑的更多，接下来我们就来看看此线程池的工作原理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先来一张图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4238197424892704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nFApmmGxuSmkFnGZIczU6HYDguQXRlrglaIKgUCZ5ZCGj64s4S0iaFzIW990yfJiaplaC1z6aYDtoEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;932&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单来说线程池把任务的提交和任务的执行剥离开来，当一个任务被提交到线程池之后：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果此时线程数&lt;span&gt;小于&lt;/span&gt;核心线程数，那么就会新起一个线程来执行当前的任务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果此时线程数&lt;span&gt;大于&lt;/span&gt;核心线程数，那么就会将任务塞入阻塞队列中，等待被执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果阻塞队列满了，并且此时线程数&lt;span&gt;小于&lt;/span&gt;最大线程数，那么会创建新线程来执行当前任务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果阻塞队列满了，并且此时线程数&lt;span&gt;大于&lt;/span&gt;最大线程数，那么会采取拒绝策略。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是任务提交给线程池后各种状况汇总，一个很容易出现理解错误的地方就是当线程数达到核心数的时候，任务是先入队，而不是先创建最大线程数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上述可知，线程池里的线程不是一开始就直接拉满的，是根据任务量开始慢慢增多的，这就算一种懒加载，到用的时候再创建线程，节省资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来先吃我几问。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;此时线程数小于核心线程数，并且线程都处于空闲状态，现提交一个任务，是新起一个线程还是给之前创建的线程？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;李老是这样说的：&lt;code&gt;If fewer than corePoolSize threads are running, try to start a new thread with the given command as its first task.&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我觉得把 &lt;code&gt;threads are running&lt;/code&gt; 去了，更合理一些，此时线程池会新起一个线程来执行这个新任务，不管老线程是否空闲。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;你是如何理解核心线程的 ?&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上一个问题可以看出，线程池虽说&lt;span&gt;默认&lt;/span&gt;是懒创建线程，但是它实际是想要快速拥有核心线程数的线程。核心线程指的是线程池承载日常任务的中坚力量，也就是说本质上线程池是需要这么些数量的线程来处理任务的，所以在懒中又急着创建它。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而最大线程数其实是为了应付突发状况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个装修的例子，正常情况下施工队只要 5 个人去干活，这 5 人其实就是核心线程，但是由于工头接的活太多了，导致 5 个人在约定工期内干不完，所以工头又去找了 2 个人来一起干，所以 5 是核心线程数，7 是最大线程数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;平时就是 5 个人干活，特别忙的时候就找 7 个，等闲下来就会把多余的 2 个辞了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这里&lt;span&gt;你可能会觉得核心线程在线程池里面会有特殊标记&lt;/span&gt;？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并没有，不论是核心还是非核心线程，在线程池里面都是一视同仁，当淘汰的时候不会管是哪些线程，反正留下核心线程数个线程即可，下文会作详解。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;你是怎么理解 KeepAliveTime 的？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是上面提到的，线程池其实想要的只是核心线程数个线程，但是又预留了一些数量来预防突发状况，当突发状况过去之后，线程池希望只维持核心线程数的线程，所以就弄了个 KeepAliveTime，当线程数大于核心数之后，如果线程空闲了一段时间（KeepAliveTime），就回收线程，直到数量与核心数持平。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;那 workQueue 有什么用？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缓存任务供线程获取，这里要注意限制工作队列的大小。队列长了，堆积的任务就多，堆积的任务多，后面任务等待的时长就长。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想想你点击一个按钮是一直转圈等半天没反应舒服，还是直接报错舒服，所以有时心是好的，想尽量完成提交的任务，但是用户体验不如直接拒绝。&lt;span&gt;更有可能由于允许囤积的任务过多，导致资源耗尽而系统崩溃&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以工作队列起到一个缓冲作用，具体队列长度需要结合线程数，任务的执行时长，能承受的等待时间等。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;你是如何理解拒绝策略的？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程数总有拉满的一天，工作队列也是一样，如果两者都满了，此时的提交任务就需要拒绝，默认实现是 AbortPolicy 直接抛出异常。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6071428571428571&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nFApmmGxuSmkFnGZIczU6HYpWDtx5DwZ8PVFx39dEeukZMicgniaPw8YuMy660rocINAuZd9OrV1RRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;840&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;剩下的拒绝策略有直接丢弃任务一声不吭的、让提交任务的线程自己运行的、淘汰老的未执行的任务而空出位置的，具体用哪个策略，根据场景选择。当然也可以自定义拒绝策略，实现 &lt;code&gt;RejectedExecutionHandler&lt;/code&gt; 这个接口即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以线程池尽可能只维护核心数量的线程，提供任务队列暂存任务，并提供拒绝策略来应对过载的任务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里还有个细节，如果线程数已经达到核心线程数，那么新增加的任务只会往任务队列里面塞，不会直接给予某个线程，如果任务队列也满了，&lt;span&gt;新增最大线程数的线程时，任务是可以直接给予新建的线程执行的，而不是入队&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;感觉已经会了？那再来看几道面试题：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;你说你看过源码，那你肯定知道线程池里的 ctl 是干嘛的咯？&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.16951566951566951&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nFApmmGxuSmkFnGZIczU6HYgvTeQeXfKCLpHk0sWGbudSric4NiaSibgbypShWwicrrfmoIWfSULVmKHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;702&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实看下注释就很清楚了，ctl 是一个涵盖了两个概念的原子整数类，它将工作线程数和线程池状态结合在一起维护，低 29 位存放 workerCount，高 3 位存放 runState。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.10344827586206896&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nFApmmGxuSmkFnGZIczU6HYAibnicPusBzzIhBTtQBxVzzk7rkcBMTOicESJ2HVyicicCicYiciaSDEukBuKQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;812&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实并发包中有很多实现都是一个字段存多个值的，比如读写锁的高 16 位存放读锁，低 16 位存放写锁，这种一个字段存放多个值可以更容易的维护多个值之间的一致性，也算是极简主义。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;你知道线程池有几种状态吗？&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.32965686274509803&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nFApmmGxuSmkFnGZIczU6HYrJvhUHntiaxLHeD2orM2ic1H9o0G5pafSQpjV7ohG1WrtLkbtKicYucfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;816&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注解说的很明白，我再翻译一下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;RUNNING：能接受新任务，并处理阻塞队列中的任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SHUTDOWN：不接受新任务，但是可以处理阻塞队列中的任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;STOP：不接受新任务，并且不处理阻塞队列中的任务，并且还打断正在运行任务的线程，就是直接撂担子不干了！&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TIDYING：所有任务都终止，并且工作线程也为0，处于关闭之前的状态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TERMINATED：已关闭。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;你知道线程池的状态是如何变迁的吗？&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.35526315789473684&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nFApmmGxuSmkFnGZIczU6HYuE2Wxic90XYaIyptm4QTibypcezBjftfibMuIMiaVAV9fl5PP93sA6zTMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;760&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注释里面也写的很清楚，我再画个图&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8734177215189873&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nFApmmGxuSmkFnGZIczU6HYs2XzibU6JNtBALibRhZTFWPVicaQ5IYst97Zh1mOIlSdJLbanMEIX8N4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;711&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;为什么要把任务先放在任务队列里面，而不是把线程先拉满到最大线程数？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我说下我的个人理解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实经过上面的分析可以得知，线程池本意只是让核心数量的线程工作着，不论是 core 的取名，还是 keepalive 的设定，所以你可以直接把 core 的数量设为你想要线程池工作的线程数，而任务队列起到一个缓冲的作用。最大线程数这个参数更像是无奈之举，在最坏的情况下做最后的努力，去新建线程去帮助消化任务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我个人觉得没有为什么，就是这样设计的，并且这样的设定挺合理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然如果你想要扯一扯 CPU 密集和 I/O 密集，那可以扯一扯。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原生版线程池的实现可以认为是偏向 CPU 密集的，也就是当任务过多的时候不是先去创建更多的线程，而是先缓存任务，让核心线程去消化，从上面的分析我们可以知道，当处理 CPU 密集型任务的时，线程太多反而会由于线程频繁切换的开销而得不偿失，所以优先堆积任务而不是创建新的线程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而像 Tomcat 这种业务场景，大部分情况下是需要大量 I/O 处理的情况就做了一些定制，修改了原生线程池的实现，使得在队列没满的时候，可以创建线程至最大线程数。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如何修改原生线程池，使得可以先拉满线程数再入任务队列排队？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果了解线程池的原理，很轻松的就知道关键点在哪，就是队列的 offer 方法。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7881996974281392&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nFApmmGxuSmkFnGZIczU6HYv9Q9h5iaiabPicOvHMYcpdib8HUxZdD2ReKibIFPqtQ0Picn7trOz2v7AdSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;661&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;execute 方法想必大家都不陌生，就是给线程池提交任务的方法。在这个方法中可以看到只要在 offer 方法内部判断此时线程数还小于最大线程数的时候返回 false，即可走下面 &lt;code&gt;else if&lt;/code&gt; 中 &lt;code&gt;addWorker&lt;/code&gt; (新增线程)的逻辑，如果数量已经达到最大线程数，直接入队即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;详细的我们可以看看 Tomcat 中是如何定制线程的。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Tomcat 中的定制化线程池实现&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadPoolExecutor&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;java&lt;/span&gt;.&lt;span&gt;util&lt;/span&gt;.&lt;span&gt;concurrent&lt;/span&gt;.&lt;span&gt;ThreadPoolExecutor&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到先继承了 JUC 的线程池，然后我们重点关注一下 execute 这个方法&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5263628239499554&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nFApmmGxuSmkFnGZIczU6HYrrMZfgMpSEnia5EyOrswscGFT81NmDOgy3dhibcF6Ds20AgP2Urnq3HQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1119&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里可以看到，Tomcat 维护了一个 submittedCount 变量，这个变量的含义是统计已经提交的但是还未完成的任务数量(记住这个变量，很关键)，所以只要提交一个任务，这个数就加一，并且捕获了拒绝异常，再次尝试将任务入队，这个操作其实是为了尽可能的挽救回一些任务，因为这么点时间差可能已经执行完很多任务，队列腾出了空位，这样就不需要丢弃任务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后我们再来看下代码里出现的 TaskQueue，这个就是上面提到的定制关键点了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TaskQueue&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;LinkedBlockingQueue&lt;/span&gt;&amp;lt;&lt;span&gt;Runnable&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; ThreadPoolExecutor parent = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    ........&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到这个任务队列继承了 LinkedBlockingQueue，并且有个 ThreadPoolExecutor 类型的成员变量 parent ，我们再来看下 offer 方法的实现，这里就是修改原来线程池任务提交与线程创建逻辑的核心了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.27580645161290324&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nFApmmGxuSmkFnGZIczU6HYeJictmb78ICmocv3pGG2rOZfZ9TDLLEibuwceYWbBt3qO20czVx8jdWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的逻辑可以看出是有机会在队列还未满的时候，先创建线程至最大线程数的！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再补充一下，如果对直接返回 false 就能创建线程感到疑惑的话，往上翻一翻，上面贴了原生线程池 execute 的逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后上面的代码其实只看到 submittedCount 的增加，正常的减少在 &lt;code&gt;afterExecute&lt;/code&gt; 里实现了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.41954022988505746&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nFApmmGxuSmkFnGZIczU6HYW1dlH23bQE0ibjU6k4xgmSMMuqcIE6DInanYYQ4hsQkF9y1Sicf2ywHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;870&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而这个 &lt;code&gt;afterExecute&lt;/code&gt; 在任务执行完毕之后就会调用，与之对应的还有个 &lt;code&gt;beforeExecute&lt;/code&gt;，在任务执行之前调用。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7083926031294452&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nFApmmGxuSmkFnGZIczU6HYsYocgYiaDzsfEdKLxlic0gAhYNG1LXibPzVUicwg11vcC5bUJm15OcvTnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;703&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此，想必 Tomcat 中的定制化线程池的逻辑已经明白了。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如果线程池中的线程在执行任务的时候，抛异常了，会怎么样？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;嘿嘿，细心的同学想必已经瞄到了上面的代码，task.run() 被 &lt;code&gt;try catch finally&lt;/code&gt;包裹，异常被扔到了 &lt;code&gt;afterExecute&lt;/code&gt; 中，并且也继续被抛了出来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而这一层外面，还有个&lt;code&gt;try finally&lt;/code&gt;，所以异常的抛出打破了 while 循环，最终会执行 `processWorkerExit方法&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.596130592503023&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nFApmmGxuSmkFnGZIczU6HYuJsF21HSFlynHXCCmIuk58j7RTjBuFsEP5icwV5T8K8iaIKeH1xMNYzA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;827&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看下这个方法，其实逻辑很简单，&lt;span&gt;把这个线程废了，然后新建一个线程替换之&lt;/span&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7811816192560175&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nFApmmGxuSmkFnGZIczU6HYZwjnMZyLooICWjHesabu2zKh2k5e4pxE1EH3DEKzEYeT3LYE0sIq7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;914&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;移除了引用等于销毁了，这事儿 GC 会做的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以如果一个任务执行一半就抛出异常，并且你没有自行处理这个异常，那么这个任务就这样戛然而止了，后面也不会有线程继续执行剩下的逻辑，所以要自行捕获和处理业务异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;addWorker 的逻辑就不分析了，就是新建一个线程，然后塞到 workers 里面，然后调用 &lt;code&gt;start()&lt;/code&gt; 让它跑起来。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原生线程池的核心线程一定伴随着任务慢慢创建的吗？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并不是，线程池提供了两个方法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;prestartCoreThread：启动一个核心线程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;prestartAllCoreThreads ：启动所有核心线程&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不要小看这个预创建方法，预热很重要，不然刚重启的一些服务有时是顶不住瞬时请求的，就立马崩了，所以有预热线程、缓存等等操作。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;线程池的核心线程在空闲的时候一定不会被回收吗？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有个 allowCoreThreadTimeOut 方法，把它设置为 true ，则所有线程都会超时，不会有核心数那条线的存在。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体是会调用 &lt;code&gt;interruptIdleWorkers&lt;/code&gt; 这个方法。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.848297213622291&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nFApmmGxuSmkFnGZIczU6HYZicm7urMpC0aHUUQuO20x3bBD8SEzH7XocrVB9B11L9jj61Yvuc8iaJw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;646&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里需要讲一下的是 w.tryLock() 这个方法，有些人可能会奇怪，Worker 怎么还能 lock。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Worker 是属于工作线程的封装类，它不仅实现了 Runnable 接口，还继承了 AQS。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4233490566037736&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nFApmmGxuSmkFnGZIczU6HYOXmKianVQtibicBvwcLlNrtz4XqweU8G0q04nAzom3pxjYsjuPgic8nVUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;848&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之所以要继承 AQS 就是为了用上 lock 的状态，&lt;span&gt;执行任务的时候上锁，任务执行完了之后解锁&lt;/span&gt;，这样执行关闭线程池等操作的时候可以通过 tryLock 来判断此时线程是否在干活，如果 tryLock 成功说明此时线程是空闲的，可以安全的回收。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与&lt;code&gt;interruptIdleWorkers&lt;/code&gt; 对应的还有一个  &lt;code&gt;interruptWorkers&lt;/code&gt; 方法，从名字就能看出差别，不空闲的 worker 也直接给打断了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据这两个方法，又可以扯到 shutdown 和 shutdownNow，就是关闭线程池的方法，一个是安全的关闭线程池，会等待任务都执行完毕，一个是粗暴的直接咔嚓了所有线程，管你在不在运行，两个方法分别调用的就是 interruptIdleWorkers() 和 interruptWorkers() 来中断线程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9751552795031055&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nFApmmGxuSmkFnGZIczU6HYEyRvATEicYRsUnw8vDjPePolGAuvpG9IlZxB6KCETrTp8ibN5ThF8zpQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;805&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这又可以引申出一个问题，&lt;span&gt;shutdownNow 了之后还在任务队列中的任务咋办&lt;/span&gt;？眼尖的小伙伴应该已经看到了，线程池还算负责，把未执行的任务拖拽到了一个列表中然后返回，至于怎么处理，就交给调用者了！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;详细就是上面的 drainQueue 方法。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.507223113964687&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nFApmmGxuSmkFnGZIczU6HYbicDsXeVoQibBjowqdkAGV0dKvUEFnUjG7jnGWaj3nFOo6UAgDBYnIJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;623&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里可能又会有同学有疑问，都 drainTo 了，为什么还要判断一下队列是否为空，然后进行循环？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那是因为如果队列是 DelayQueue 或任何其他类型的队列，其中 poll 或 drainTo 可能无法删除某些元素，所以需要遍历，逐个删除它们。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;回到最开始的面试题&lt;/span&gt;&lt;/h1&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;线程池如何动态修改核心线程数和最大线程数？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实之所以会有这样的需求是因为线程数是真的不好配置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可能会在网上或者书上看到很多配置公式，比如：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;CPU 密集型的话，核心线程数设置为 CPU核数+1&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;I/O 密集型的话，核心线程数设置为 2*CPU核数&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程数=CPU核数 *（1+线程等待时间 / 线程时间运行时间）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个比上面的更贴合与业务，还有一些理想的公式就不列了。就这个公式而言，这个线程等待时间就很难测，拿 Tomcat 线程池为例，每个请求的等待时间能知道？不同的请求不同的业务，就算相同的业务，不同的用户数据量也不同，等待时间也不同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以说线程数真的很难通过一个公式一劳永逸，&lt;span&gt;线程数的设定是一个迭代的过程，需要压测适时调整&lt;/span&gt;，以上的公式做个初始值开始调试是 ok 的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再者，流量的突发性也是无法判断的，举个例子 1 秒内一共有 1000 个请求量，但是如果这 1000 个请求量都是在第一毫秒内瞬时进来的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就很需要线程池的动态性，也是这个上面这个面试题的需求来源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原生的线程池核心我们大致都过了一遍，不过这几个方法一直没提到，先来看看这几个方法：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5829787234042553&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nFApmmGxuSmkFnGZIczU6HYckUGLk17Xm68gibcG4viacUMFFwVNZo1wzvC1rQdssJdMxIQf1bwX2DQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;470&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我就不一一翻译了，大致可以看出线程池其实已经给予方法暴露出内部的一些状态，例如正在执行的线程数、已完成的任务数、队列中的任务数等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然你可以想要更多的数据监控都简单的，像 Tomcat 那种继承线程池之后自己加呗，动态调整的第一步监控就这样搞定了！定时拉取这些数据，然后搞个看板，再结合邮件、短信、钉钉等报警方式，我们可以很容易的监控线程池的状态！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着就是动态修改线程池配置了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.24293785310734464&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nFApmmGxuSmkFnGZIczU6HYcIdcRQ6TMCuBwUIoFI9G3ZSYiaJnBmLoI6y62VFq3ABmyQibZyO0iaV9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;531&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到线程池已经提供了诸多修改方法来更改线程池的配置，所以李老都已经考虑到啦！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样，也可以继承线程池增加一些方法来修改，看具体的业务场景了。同样搞个页面，然后给予负责人员配置修改即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以原生线程池已经提供修改配置的方法，也对外暴露出线程池内部执行情况，所以只要我们实时监控情况，调用对应的 set 方法，即可动态修改线程池对应配置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回答面试题的时候一定要提监控，显得你是有的放矢的。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如果你是 JDK 设计者，如何设计？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实我觉得这个是紧接着上一题问的，应该算是同一个问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且 JDK 设计者已经设计好了呀？所以怎么说我也不清楚，不过我们可以说一说具体的实现逻辑呗。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先来看下设置核心线程数的方法：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5578673602080624&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nFApmmGxuSmkFnGZIczU6HYoKmuJIN5pUT2pdFBSK49UiaiaD9X5NEicPYDrKSy5jTYeD6oYbHZ8MpHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;769&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着注释看下来应该没什么问题，就是那个 k 值我说一下，李老觉得核心线程数是配置了，但是此时线程池内部是否需要这么多线程是不确定的，那么就按工作队列里面的任务数来，直接按任务数立刻新增线程，当任务队列为空了之后就终止新增。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这其实和李老设计的默认核心线程数增加策略是一致的，都是懒创建线程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再看看设置最大线程数的方法：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.28&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nFApmmGxuSmkFnGZIczU6HYqTanoxQ3txRtYqzPe8TyZgDQPcoDy8SfpG3icrae5c67iaJtzhoyMZrQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没啥花头，调用的 &lt;code&gt;interruptIdleWorkers&lt;/code&gt; 之前都分析过了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我再贴一下之前写过的线程池设计面试题吧。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如果要让你设计一个线程池，你要怎么设计？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种设计类问题还是一样，先说下理解，表明你是知道这个东西的用处和原理的，然后开始 BB。基本上就是按照现有的设计来说，再添加一些个人见解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池讲白了就是存储线程的一个容器，池内保存之前建立过的线程来重复执行任务，减少创建和销毁线程的开销，提高任务的响应速度，并便于线程的管理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我个人觉得如果要设计一个线程池的话得考虑池内工作线程的管理、任务编排执行、线程池超负荷处理方案、监控。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初始化线程数、核心线程数、最大线程池都暴露出来可配置，包括超过核心线程数的线程空闲消亡配置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;任务的存储结构可配置，可以是无界队列也可以是有界队列，也可以根据配置分多个队列来分配不同优先级的任务，也可以采用 stealing 的机制来提高线程的利用率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再提供配置来表明此线程池是 IO 密集还是 CPU 密集型来改变任务的执行策略。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;超负荷的方案可以有多种，包括丢弃任务、拒绝任务并抛出异常、丢弃最旧的任务或自定义等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池埋好点暴露出用于监控的接口，如已处理任务数、待处理任务数、正在运行的线程数、拒绝的任务数等等信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我觉得基本上这样答就差不多了，等着面试官的追问就好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意不需要跟面试官解释什么叫核心线程数之类的，都懂的没必要。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然这种开放型问题还是仁者见仁智者见智，我这个不是标准答案，仅供参考。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;关于线程池的一点碎碎念&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池的好处我们都知道了，但是不是任何时刻都上线程池的，我看过一些奇怪的代码，就是为了用线程池而用线程池...&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有需要根据不同的业务划分不同的线程池，不然会存在一些耗时的业务影响了另一个业务导致这个业务崩了，然后都崩了的情况，所以要做好线程池隔离。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最后&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，有关线程池的知识点和一些常见的一些面试题应该都涉及到了吧，如果还有别的啥角度刁钻的面试题，欢迎留言提出，咱们一起研究研究。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信看了这篇文章之后，关于线程池出去面试可以开始吹了！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果觉得文章不错，来个点赞和在看呗！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我还提供&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkxNTE3NjQ3MA==&amp;amp;mid=2247489472&amp;amp;idx=2&amp;amp;sn=20da41118ddb4208d57e16eceea677c3&amp;amp;chksm=c1627ab9f615f3afac97fd9923ced4cf43301ae159baf3a68d628e42b5184759c40ad1be8aa3&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;1v1，我的专属回答服务，有兴趣的可以点下&lt;/a&gt;&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我是yes，从一点点到亿点点，我们下篇见。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5d569afef5a39f6c3c6cea776bf87b84</guid>
<title>工具 | 一款 Golang 实现的分布式事务管理器</title>
<link>https://toutiao.io/k/curakqj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>