<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>b8aac4f8e7c207e41019d2c03121cde2</guid>
<title>3+1 保障：高可用系统稳定性是如何炼成的？</title>
<link>https://toutiao.io/k/u8lcu6b</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>722870d8cf9ad13c4ee60732a6ae257e</guid>
<title>不要让追求完美阻碍你做决策</title>
<link>https://toutiao.io/k/mah7i09</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section&gt;&lt;p&gt;平时大家做研发的过程中，肯定经常遇到需要自己做决策的时候。不管是技术决策，还是团队管理上的决策。有时候为了追求完美经常迟迟难下决定，导致实际工作反而难以推进。&lt;/p&gt;&lt;p&gt;前几天团队就遇到一个这样的问题：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;项目中有个技术难题交给同事A，并且项目进度非常紧急，结果过了两天迟迟没有开展。所以就询问了一下情况。原来A同事为了方便后续扩展，一直苦思冥想方案的兼容性。然而考虑的扩展功能可能很难规划到产品中。另一方面是迫在眉睫的deadline。&lt;/p&gt;&lt;p&gt;所以我就建议他考虑一下另一种方案，先把目前的问题解决。虽然最后采用了这个建议，但是说服过程相当困难，还有点不愉快。事后我也有一点自我怀疑，我的决定真的正确吗？好在后来我找到了答案。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;极客时间的《研发效率破局之道》专栏“Facebook的10x程序员效率心法”提到一个快速迭代的原则：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;不要追求完美，不要过度计划，而是要尽快实现功能，通过不断迭代来完善。&lt;/strong&gt;优秀的架构往往不是设计出来的，而是在实现过程中逐步发展、完善起来的。&lt;/p&gt;&lt;p&gt;Facebook 有一条常见的海报标语，叫作“Done is better than perfect”，意思就是完成比完美要重要。要实现快速迭代，我们在设计和实现功能时都要注意简单化。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;有些开发者过于追求技术，投入了大量时间去设计精美、复杂的系统。这样做没有问题，但一定要有一个度，切忌杀鸡用牛刀。&lt;/strong&gt;因为复杂的系统虽然精美，但往往不容易理解，维护成本也比较高，修改起来更是不容易。&lt;/p&gt;&lt;p&gt;所以，在 Facebook 进行开发的时候，尽量使用简单实用的设计，然后快速进行版本迭代。&lt;/p&gt;&lt;p&gt;亨利·明茨伯格《写给管理者的睡前故事》有一章《决策：与你的想法不同》写的很有意思，下面是部分节选，祝开卷有益。&lt;/p&gt;&lt;p&gt;我们是怎么做决策的？很简单。首先诊断，接下来设计（可能的解决方案），然后决定，最后执行（把选择付诸行动）。换句话说，我们是先思考后行动，我把这个叫作思考先行。&lt;/p&gt;&lt;p&gt;你一生中最重要的决策可能是：寻找伴侣。你是思考先行的吗？我们以一位男性寻找女性伴侣为例，使用下面这个模式：首先列出你希望未来伴侣拥有的一些品质，如聪颖、漂亮、羞涩；接下来列出所有的可能人选；然后进行分析，根据上述标准给每位候选人打分；最后把分数加起来看谁胜出，并告知这位幸运的女士。&lt;/p&gt;&lt;p&gt;可是，她却告诉你：“你在忙活这些的时候，我结婚了，现在已经有几个孩子了。”看来，思考先行还是有缺点的。&lt;/p&gt;&lt;p&gt;所以，你可能会用其他方式来寻找伴侣，就像我的父亲那样。有一天，他跟我的奶奶说：“今天，我遇到了一个我想跟她结婚的女孩！”我跟你保证，这个决策里面真的没有多少分析，不过它的结局很圆满。我父母的婚姻长久而幸福。&lt;/p&gt;&lt;p&gt;我们把这称为“一见钟情”。作为一种决策模式，我称之为视觉先行。如果你知道有多少重要的决策是这么来的，可能会大吃一惊。比如，面试不到两秒钟就决定聘用某人，或者购买某设备的原因仅仅是你看上了这个地方。这些决策不一定是一时心血来潮，有可能是真知灼见。&lt;/p&gt;&lt;p&gt;但是，不要仓促下结论：&lt;strong&gt;还有另外一种更明智的决策方式，我称之为行动先行。&lt;/strong&gt;你可以想象如何用这种模式来寻找理想的伴侣。这么说吧，不管是做大决策还是小决策，当你不确定该怎么做的时候，你可能需要先行动后思考，而不是先思考后行动。你先进行小幅度的尝试性行动，看看是否奏效，如果没效果，就换另一种方式，直到找到有效的方式，再放开手去做。也就是摸石头过河。&lt;/p&gt;&lt;p&gt;当然，这种方式也有它的弊端。研究决策的特里·康诺利教授对此曾有妙语：“核战争和生孩子这样的事情就不适合用‘摸石头过河’的战略。”但是，在众多决策方式中，这种决策方式应该是一种完美的方式。例如，你本来打算把一个产品染成蓝色，但最后，你可能卖出的是彩虹色的产品。&lt;/p&gt;&lt;p&gt;你现在需要做一个重要的决策吗？好，先不要想了，明天四处看看！然后干点儿什么！到那个时候，你可能就会发现你的想法完全变了。&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;大师幽默的口吻在其它章节也处处可见，大家感兴趣可以看看，微信读书就有。&lt;br/&gt;大家如果有启发，可以关注铁柱，大家进群交流一下日常开发中遇到的问题。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/bymGBmLC3zGctwqKP4fLPhjJWtjKdqcr8nLEcXTHRibCshlQPYkuURiaxcdkoFmmNwo8hSVI8HDicLO9DiaIic0iaAhA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ea6f3b6027240968f334490cd941b4e8</guid>
<title>[译] 使用 QueryDSL 过程中你肯定遇到过的问题</title>
<link>https://toutiao.io/k/az1umqg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;header class=&quot;post-header&quot;&gt;
        &lt;h1 class=&quot;post-title&quot; itemprop=&quot;name headline&quot;&gt;
          使用QueryDSL过程中你肯定遇到过的问题
        &lt;/h1&gt;

        &lt;p class=&quot;post-meta&quot;&gt;
            &lt;span class=&quot;post-meta-item&quot;&gt;
              &lt;span class=&quot;post-meta-item-icon&quot;&gt;
                &lt;i class=&quot;far fa-calendar&quot;/&gt;
              &lt;/span&gt;
              &lt;span class=&quot;post-meta-item-text&quot;&gt;发表于&lt;/span&gt;

              &lt;time title=&quot;创建时间：2019-10-28 00:00:00&quot; itemprop=&quot;dateCreated datePublished&quot; datetime=&quot;2019-10-28T00:00:00+00:00&quot;&gt;2019-10-28&lt;/time&gt;
            &lt;/span&gt;
              &lt;span class=&quot;post-meta-item&quot;&gt;
                &lt;span class=&quot;post-meta-item-icon&quot;&gt;
                  &lt;i class=&quot;far fa-calendar-check&quot;/&gt;
                &lt;/span&gt;
                &lt;span class=&quot;post-meta-item-text&quot;&gt;更新于&lt;/span&gt;
                &lt;time title=&quot;修改时间：2021-02-05 09:55:14&quot; itemprop=&quot;dateModified&quot; datetime=&quot;2021-02-05T09:55:14+00:00&quot;&gt;2021-02-05&lt;/time&gt;
              &lt;/span&gt;

          
            &lt;span class=&quot;post-meta-item&quot; title=&quot;阅读次数&quot; id=&quot;busuanzi_container_page_pv&quot;&gt;
              &lt;span class=&quot;post-meta-item-icon&quot;&gt;
                &lt;i class=&quot;fa fa-eye&quot;/&gt;
              &lt;/span&gt;
              &lt;span class=&quot;post-meta-item-text&quot;&gt;阅读次数：&lt;/span&gt;
              &lt;span id=&quot;busuanzi_value_page_pv&quot;/&gt;
            &lt;/span&gt;&lt;br/&gt;
            &lt;span class=&quot;post-meta-item&quot; title=&quot;本文字数&quot;&gt;
              &lt;span class=&quot;post-meta-item-icon&quot;&gt;
                &lt;i class=&quot;far fa-file-word&quot;/&gt;
              &lt;/span&gt;
                &lt;span class=&quot;post-meta-item-text&quot;&gt;本文字数：&lt;/span&gt;
              &lt;span&gt;4.5k&lt;/span&gt;
            &lt;/span&gt;
            &lt;span class=&quot;post-meta-item&quot; title=&quot;阅读时长&quot;&gt;
              &lt;span class=&quot;post-meta-item-icon&quot;&gt;
                &lt;i class=&quot;far fa-clock&quot;/&gt;
              &lt;/span&gt;
                &lt;span class=&quot;post-meta-item-text&quot;&gt;阅读时长 ≈&lt;/span&gt;
              &lt;span&gt;9 分钟&lt;/span&gt;
            &lt;/span&gt;

        &lt;/p&gt;
      &lt;/header&gt;

    
    
    
    &lt;div class=&quot;post-body&quot; itemprop=&quot;articleBody&quot;&gt;

      
        &lt;p&gt;&lt;em&gt;来自官网的介绍（翻译版）&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;/&gt;前言&lt;/h3&gt;&lt;p&gt;Querydsl是一个框架，可用于构造静态类型的类似SQL的查询。可以通过诸如Querydsl之类的流畅API构造查询，而不是将查询编写为内联字符串或将其外部化为XML文件。&lt;/p&gt;
&lt;a id=&quot;more&quot;/&gt;

&lt;p&gt;例如，与简单字符串相比，使用流利的API的好处是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在IDE中使用代码完成；会有代码提示和自动补全，较为高效&lt;/li&gt;
&lt;li&gt;(几乎)语法安全；&lt;/li&gt;
&lt;li&gt;可以安全地引用域类型和属性；可以直接使用领域模型进行操作，毕竟本质就是面向对象&lt;/li&gt;
&lt;li&gt;更好地重构域类型的更改；&lt;/li&gt;
&lt;li&gt;跟写SQL一样的方便；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;/&gt;1. 简介&lt;/h3&gt;&lt;h4 id=&quot;1-1-背景&quot;&gt;&lt;a href=&quot;#1-1-背景&quot; class=&quot;headerlink&quot; title=&quot;1.1. 背景&quot;/&gt;1.1. 背景&lt;/h4&gt;&lt;p&gt;Querydsl是出于以类型安全的方式维护HQL查询的需要而诞生的。HQL查询的增量构造需要String连接，并导致难以阅读的代码。通过纯字符串对域类型和属性的不安全引用是基于字符串的HQL构造的另一个问题。&lt;/p&gt;
&lt;p&gt;随着域模型的不断变化，类型安全性在软件开发中带来了巨大的好处。域更改直接反映在查询中，而查询构造中的自动完成功能使查询构造更快，更安全。&lt;/p&gt;
&lt;p&gt;用于Hibernate的HQL是Querydsl的第一种目标语言，但如今它支持JPA，JDO，JDBC，Lucene，Hibernate Search，MongoDB，Collections和RDFBean作为后端。&lt;/p&gt;
&lt;h4 id=&quot;1-2-原则&quot;&gt;&lt;a href=&quot;#1-2-原则&quot; class=&quot;headerlink&quot; title=&quot;1.2. 原则&quot;/&gt;1.2. 原则&lt;/h4&gt;&lt;p&gt;&lt;em&gt;类型安全&lt;/em&gt; 是Querydsl的核心原则。查询是根据生成的反映查询类型的属性来构造的。函数/方法调用也以完全类型安全的方式构造。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;一致性&lt;/em&gt; 是另一个重要原则。在所有实现中，查询路径和操作都是相同的，而且Query接口具有公共的基本接口。&lt;/p&gt;
&lt;p&gt;要了解Querydsl查询和表达式类型的表达能力，请访问javadocs并进行探索&lt;code&gt;com.querydsl.core.Query&lt;/code&gt;，&lt;code&gt;com.querydsl.core.Fetchable&lt;/code&gt; 以及&lt;code&gt;com.querydsl.core.types.Expression&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果是初次使用QueryDSL的同学建议去这篇博客：&lt;/strong&gt;&lt;a href=&quot;https://blog.csdn.net/phapha1996/article/details/83614975&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SpringDataJPA+QueryDSL玩转态动条件/投影查询&lt;/a&gt;，&lt;/p&gt;
&lt;p&gt;本文针探讨的是使用时遇到的一些问题&lt;/p&gt;
&lt;h3 id=&quot;2-拓展示例&quot;&gt;&lt;a href=&quot;#2-拓展示例&quot; class=&quot;headerlink&quot; title=&quot;2. 拓展示例&quot;/&gt;2. 拓展示例&lt;/h3&gt;&lt;h4 id=&quot;1-Projections简化代码，使代码更优雅&quot;&gt;&lt;a href=&quot;#1-Projections简化代码，使代码更优雅&quot; class=&quot;headerlink&quot; title=&quot;1. Projections简化代码，使代码更优雅&quot;/&gt;1. Projections简化代码，使代码更优雅&lt;/h4&gt;&lt;p&gt;使用Projections方法可以更简单更方便的返回自定义的参数属性&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;QHajOrderDetails orderDetails = QHajOrderDetails.hajOrderDetails;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; jpaQueryFactory.select(&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;Projections.bean(&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;CommoditySalesDto&lt;span class=&quot;class&quot;&gt;.&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;                  // 取别名，与&lt;span class=&quot;title&quot;&gt;CommoditySalesDto&lt;/span&gt;实体中字段相同&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;orderDetails.number.sum().as(&quot;sales&quot;),&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;orderDetails.commodityNo&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;).from(orderDetails)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;.where(orderDetails.commodityNo.in(commodityNos))&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;.groupBy(orderDetails.commodityNo)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;.fetch();&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;Projections的bean方法第一个属性是要查询对象的泛型类，对象中orderDetails.“commodityNo”属性就是CommoditySalesDto对应属性，大小写相同。如属性不同时可以使用as来为指定结果集添加别名对应dto内属性。&lt;/p&gt;
&lt;h4 id=&quot;2-关联同一张表两次进行查询&quot;&gt;&lt;a href=&quot;#2-关联同一张表两次进行查询&quot; class=&quot;headerlink&quot; title=&quot;2. 关联同一张表两次进行查询&quot;/&gt;2. 关联同一张表两次进行查询&lt;/h4&gt;&lt;p&gt;有时遇到一些查询需要在同一张表关联查询两次或多次，知道在sql中怎么写，但是在querydsl中就不知道怎么下手了，方法其实很简单&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;QHajCommodityType type1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; QHajCommodityType(&lt;span class=&quot;string&quot;&gt;&quot;type1&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;QHajCommodityType type2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; QHajCommodityType(&lt;span class=&quot;string&quot;&gt;&quot;type2&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; jPAQueryFactory.select(type2.id)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    .from(type1)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    .join(type2).on(type1.id.eq(type2.parentId))&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;.fetch();&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;创建对应对象和别名，这样关联查询时才会区分。&lt;/p&gt;
&lt;h4 id=&quot;3-格式化字段进行查询&quot;&gt;&lt;a href=&quot;#3-格式化字段进行查询&quot; class=&quot;headerlink&quot; title=&quot;3. 格式化字段进行查询&quot;/&gt;3. 格式化字段进行查询&lt;/h4&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//获取到每日订单数量&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;QHajOrder order = QHajOrder.hajOrder;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//格式化字段，按每日格式化&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;StringTemplate dateExpr = Expressions.stringTemplate(&lt;span class=&quot;string&quot;&gt;&quot;DATE_FORMAT({0},&#x27;%Y-%m-%d&#x27;)&quot;&lt;/span&gt;, order.createTime);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; jpaQueryFactory.select(dateExpr,order.id.count())&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;.from(order)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;.orderBy(order.id.desc())&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;.groupBy(dateExpr)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;.limit(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;.fetch();&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&quot;4-可添加判断逻辑，根据业务需要拼接，在代码中书写更便捷&quot;&gt;&lt;a href=&quot;#4-可添加判断逻辑，根据业务需要拼接，在代码中书写更便捷&quot; class=&quot;headerlink&quot; title=&quot;4. 可添加判断逻辑，根据业务需要拼接，在代码中书写更便捷&quot;/&gt;4. 可添加判断逻辑，根据业务需要拼接，在代码中书写更便捷&lt;/h4&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;QHajOrder order = QHajOrder.hajOrder;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;JPAQuery&amp;lt;Integer&amp;gt; jpaQuery = jpaQueryFactory.select(order.id.sum()).from(order);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;Integer count;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (ObjectUtil.isNotNull(type)) {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    count = jpaQuery.where(order.status.eq(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)).fetchOne();&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;} &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    count = jpaQuery.where(order.status.eq(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)).fetchOne();&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 数据为空时，值为null&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (ObjectUtil.isNull(count)) {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    count = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; count;&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&quot;5-分页处理&quot;&gt;&lt;a href=&quot;#5-分页处理&quot; class=&quot;headerlink&quot; title=&quot;5. 分页处理&quot;/&gt;5. 分页处理&lt;/h4&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; List&amp;lt;HajOrder&amp;gt; &lt;span class=&quot;title&quot;&gt;getOrderListByPage&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Pager page)&lt;/span&gt;&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;QHajOrder order = QHajOrder.hajOrder;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;QueryResults&amp;lt;HajOrder&amp;gt; queryResults = jpaQueryFactory&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;.selectFrom(order)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;.where(order.status.eq(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;))&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;comment&quot;&gt;// 分页逻辑&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;.offset((page.getCurrentPage() - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) * page.getPageSize())&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;.limit(page.getPageSize())&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;.fetchResults();&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 总条数&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;page.setRecordTotal((&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;) queryResults.getTotal());&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; queryResults.getResults();&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&quot;6-多数据源配置使用&quot;&gt;&lt;a href=&quot;#6-多数据源配置使用&quot; class=&quot;headerlink&quot; title=&quot;6.多数据源配置使用&quot;/&gt;6.多数据源配置使用&lt;/h4&gt;&lt;p&gt;如果你还没配置多数据源使用，可以参照这个博客 &lt;a href=&quot;http://blog.didispace.com/spring-boot-learning-21-3-8/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring Boot 2.x基础教程：Spring Data JPA的多数据源配置&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之前一直是单数据源使用，在多数据源中使用可能会报这样的错&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;java.lang.IllegalArgumentException: org.hibernate.hql.internal.ast.QuerySyntaxException: * is not mapped&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;at org.springframework.orm.jpa.ExtendedEntityManagerCreator$ExtendedEntityManagerInvocationHandler.invoke(ExtendedEntityManagerCreator.java:&lt;span class=&quot;number&quot;&gt;350&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;at com.sun.proxy.$Proxy119.createQuery(Unknown Source)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;at com.querydsl.jpa.impl.AbstractJPAQuery.createQuery(AbstractJPAQuery.java:&lt;span class=&quot;number&quot;&gt;101&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;at com.querydsl.jpa.impl.AbstractJPAQuery.fetchResults(AbstractJPAQuery.java:&lt;span class=&quot;number&quot;&gt;211&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;配置多个实体管理器EntityManager&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@SpringBootApplication&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;@EnableJpaAuditing&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;public class ApiApplication {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;public static void main(String[] args) {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;SpringApplication.run(ThirdApiApplication.class, args);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt; * Spring管理JPAQueryFactory&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt; * 默认&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt; * @param entityManager&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt; * @return&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;@Bean&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;public JPAQueryFactory jpaQueryFactory(@Qualifier(&quot;entityManagerPrimary&quot;) EntityManager entityManager) {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;return new JPAQueryFactory(entityManager);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt; * 新配置数据源wmsJpaQueryFactory&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt; *&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt; * @param entityManager&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt; * @return&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;@Bean&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;public JPAQueryFactory wmsJpaQueryFactory(@Qualifier(&quot;entityManagerSecondary&quot;) EntityManager entityManager) {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;return new JPAQueryFactory(entityManager);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;业务使用中按如下操作就可以了&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//默认的数据源&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Autowired&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; JPAQueryFactory jpaQueryFactory;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//新的数据源&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Autowired&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; JPAQueryFactory wmsJpaQueryFactory;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;QCustomer customer = QCustomer.customer;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    Customer bob = wmsJpaQueryFactory.select(customer)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;      .from(customer)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;      .where(customer.firstName.eq(&lt;span class=&quot;string&quot;&gt;&quot;Bob&quot;&lt;/span&gt;))&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;      .fetchOne();&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;资料：&quot;&gt;&lt;a href=&quot;#资料：&quot; class=&quot;headerlink&quot; title=&quot;资料：&quot;/&gt;资料：&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/querydsl/querydsl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;github-querydsl资源&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.querydsl.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Querydsl官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.querydsl.com/static/querydsl/latest/reference/html/ch02.html#jpa_integration&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网querydsl-jpa示例&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.querydsl.com/static/querydsl/4.1.3/reference/html_single/#preface&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Querydsl参考指南&lt;/a&gt;&lt;/p&gt;

    &lt;/div&gt;

    
    
    

 

      &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>554abe34d8808bf7acef77c81b7f27ea</guid>
<title>[译] 为什么人们还没有转向 Svelte</title>
<link>https://toutiao.io/k/gyzoweq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;mp-miniprogram data-miniprogram-appid=&quot;wxefd4afaf8f544069&quot; data-miniprogram-path=&quot;pages/index/index&quot; data-miniprogram-nickname=&quot;编程日历&quot; data-miniprogram-avatar=&quot;http://mmbiz.qpic.cn/mmbiz_png/Q0hHjLye7cQQhdC6qSllw3wyGNEas8MqiazjZHG6PdOK7zp6lCF2vVibUdiaIyW2cAicFAgkS4yf1qFfR7Vx9hLJ7w/640?wx_fmt=png&amp;amp;wxfrom=200&quot; data-miniprogram-title=&quot;编程日历，程序员专属日历&quot; data-miniprogram-imageurl=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/WYoaOn5t0ANkBNLp3U19JiczsialTCuxmuAsTm5vjpvWewvhAVzj5fB9X9vCRPJ9hmSSbibbMkEf5F00sSvgRFBjg/0?wx_fmt=jpeg&quot; data-miniprogram-type=&quot;card&quot; data-miniprogram-servicetype=&quot;0&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Svelte是一个轻量级的基于组件的框架，比如React、Vue或Angular也都是，它允许开发人员用JavaScript编写易于阅读的代码，然后将编写的代码编译成在浏览器中运行速度超快的高效JavaScript。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当其他框架（如React）采用虚拟DOM diffing技术时，Svelte将你的代码编译成JavaScript，当你的组件中的状态变化时，DOM就会更新。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自从2016年11月由Richard Harris首次发布以来，很多开发者都爱上了这种新的构建应用的方法，在其官方Github仓库上有超过3.9万颗星，并在顶级JavaScript前端框架的选择中争得一席之地。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽管有这些数据，但是，很多人在前端开发过程中都在犹豫要不要采用Svelte这个框架。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据trends.buildwith.com的数据，截至2020年10月，总共只有约6000个注册的直播和历史网站使用Svelte作为首选前端库。相比React的340万左右、Vue的150多万、Angular的370多万，这个数据是超低的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.10625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0ANkBNLp3U19JiczsialTCuxmuTfp3mA1f1eGbnjMC3QSXiacDkp4R5RtaKvFKZ2fSqo2qP1KlImaicBcw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;figcaption&gt;Svelte根据使用趋势的使用情况屏幕截图：https://trends.builtwith.com/framework/Svelte&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.829296875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0ANkBNLp3U19JiczsialTCuxmutwntic73qFJQuxmHDrxrPZ9ABbs7mBbJZU6bcgOOqEST6ZEic9rzGWqA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;figcaption&gt;Vue使用趋势统计信息的屏幕截图：https://trends.builtwith.com/Javascript/Vue&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;为什么开发人员尚未切换到Svelte&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;迟来的TypeScript支持&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，当你从Angular这样的框架中走出来时，你会很习惯于开箱即为你预置一个TypeScript开发环境。Svelte团队在2020年7月才刚刚发布了包含官方支持TypeScript的更新。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这意味着开发者现在可以在创建Svelte项目时运行以下命令来设置TypeScript：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;npx degit sveltejs/template svelte-typescript-app&lt;br/&gt;cd svelte-typescript-app&lt;br/&gt;node scripts/setupTypeScript.js&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然事先可以使用TypeScript，但最初的设置过程相当繁琐，因为它涉及到一堆耗时的自定义Webpack和Svelte预处理配置。Svelte现在默认包含TypeScript支持，这是一件好事，因为这个主要的缺失点似乎是阻碍开发者学习和使用该框架的因素之一。前段时间Deno正式发布的时候，在开发者中考虑到的一个关键卖点就是它比Node的TypeScript集成优势。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;没有官方的CRA或Svelte CLI&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你需要快速构建一个React应用的脚手架，你可以很容易地使用create-react-app CLI应用（鉴于它已在全球范围内安装），只需运行 &lt;code&gt;create react app myreactproject&lt;/code&gt; 命令就会自动为你生成应用脚手架。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于Vue来说，过程是类似的，只要你的机器上安装了Vue CLI，你只需要运行这个命令，你的脚手架就设置好了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;vue init myvueproject&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然而Svelte并没有官方维护的脚手架项目的CLI应用，因为 &lt;code&gt;svelte/cli&lt;/code&gt; 包已经在2018年被废弃。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8643835616438356&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0ANkBNLp3U19JiczsialTCuxmu5Y7icL7xv3aay8ySfFdJvI6XickqDFYgT0IYvkkHgSTZaEZCTn1aKpRA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;730&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你需要总是从它的 npx 仓库（已经集成了 CLI）中提取脚手架模板。这意味着，每次你想创建一个Svelte应用程序时，你需要始终运行以下命令来设置一个Svelte项目。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;npx degit sveltejs/template my-svelte-project&lt;br/&gt;cd my-svelte-project&lt;br/&gt;npm install&lt;br/&gt;npm run dev&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然这看似是一个小小的DX（开发者体验）缺陷，但这绝对是Svelte团队可以研究的问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;小型社区&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与其他主要的前端开发框架相比，Svelte拥有一个非常小的社区。如果您使用的是拥有大型社区的流行语言，那么您更有可能找到需要合作的人，你也更有可能找到参考资料和资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如在Stack Overflow上，Svelte标签下提出的讨论（问题和答案）只有一千多条。相比React的25万+、Angular的23.4万+、Vue的6.4万+分别来说，还有很多工作要做。这意味着，如果你作为开发者在使用Svelte时遇到问题，得到帮助的机会相对较小。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7123287671232876&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0ANkBNLp3U19JiczsialTCuxmuia3SFGUrPWJnAQrLYjKMiaia2giaTw8e6xae4xkPnWb9Ez4A5ZjmexZgrg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;730&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0ANkBNLp3U19JiczsialTCuxmudHcCml6DicGFBywNYmXOpSGYUtz2JlOTkra7UIvjTYkjevMszYicibJ8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;730&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;更少的包装/工具支持&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多开发者发现，整合现有的包，有助于更快地实现任务。由于Svelte的普及率比较低，所以包和实用程序的支持比较少。例如，如果你想在React中实现一个date-picker组件，在NPM仓库中就有数百个包可供选择。然而，对于Svelte您就没有这样的奢侈了，因为可供开发人员挑选的特性很少，因此，开发人员通常要花时间从头开始实现这些特性。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;行业需求低迷&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果雇主对一个工具有足够的需求，开发人员学习这个工具是有道理的。作为一名开发人员，如果学习一种工具有利可图的话，您会希望获得它的知识。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Svelte在JavaScript世界中比较年轻，因此，行业对Svelte开发人员的需求不大，因为很多公司的基础设施中还没有采用Svelte（还没有）。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;为什么企业还不转用Svelte？&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;公司的支持&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;React得到了Facebook的大力支持，因为最初开发它的是Facebook内部员工，Angular的开发团队由谷歌的开发人员领导，他们也在自己的职业网站上使用Vue。比如苹果，在他们的SwiftUI教程网站中也使用了Vue。然而Svelte并没有（还没有）得到这些大型科技公司的明显支持。我坚信，如果Svelte获得这些公司的支持，将会有更多的公司开始采用Svelte。如果这些公司中的任何一家在其基础设施中采用或支持该框架，Svelte的受欢迎程度可能会飙升。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;成熟度&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一项技术存在的时间较长，那么它就会被认为比其对应的技术更可靠，因为随着时间的推移，技术会随着错误修复、更多的文档和教程、语言语法和安全性的改进等方面而不断改进。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于Svelte（2016年发布）在前端框架领域比React、Vue、Angular等年轻，相对较新，所以对其成熟度存在一定程度的担忧是很正常的。相信不少公司因为Svelte的年龄，对采用Svelte构建产品的安全性持怀疑态度。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最后&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从目前的流行程度和有用性来看，毫无疑问，Svelte是未来web开发的重要组成部分。作为一个Svelte开发者，如果能有更多的公司和开发者采用Svelte及其所有的美感，作为他们制作Web应用的前端Web框架的选择，那将是一件非常棒的事情。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;原文：https://blog.logrocket.com/why-people-arent-switching-to-svelte-yet/&lt;br/&gt;&lt;span&gt;作者：Oluwaseun Raphael Afolayan&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0MDIwNTQ1Mg==&amp;amp;mid=2676496340&amp;amp;idx=1&amp;amp;sn=41f5b6c6cce3887a2096dbd945a94288&amp;amp;chksm=f362dc37c41555216960e45cb9e033ae086efb626794d07d0971a78d6b27c08df486fe8a236a&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4255555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/WYoaOn5t0ANkBNLp3U19JiczsialTCuxmugVU1Ky6MoBgj3xhQDIoY2CgnmrPu9GOONcxFzbp4lqVm2o6KXIAcZg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0MDIwNTQ1Mg==&amp;amp;mid=2676496258&amp;amp;idx=1&amp;amp;sn=4cd6e372a6e169391a8a3ca6d2b51e90&amp;amp;chksm=f362dc61c415557776bc48a26bc1cb72b50315172c1f5644543d3c7749ba856c067e79a21168&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4255555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/WYoaOn5t0ANkBNLp3U19JiczsialTCuxmuMok9fwZm4ysMaFkgibWpHP9K0J3HT0FPMO1zzqObSMx4dTLcWiaicoaMQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fd0292accd606175825f59b9043f6615</guid>
<title>Go 源码阅读之 flag 包</title>
<link>https://toutiao.io/k/4nqqg6x</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;Go 源码阅读系列是我的源码阅读笔记。因为本人的电脑上 Go 的版本是1.13.4，所以就选择了该版本作为学习的版本。为此我在 Github 上 Fork 了 Go 的源码，并创建了 study1.13.4 分支，来记录对于源码的个人理解或者说中文注释也行。每当阅读完一个包后都会进行一下小结，就像这篇是对flag包的总结整理。当然在整理的过程中发现 Go夜读系列视频，也让我受益颇多。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;简介&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;文件结构&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;运行测试&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;总结&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;接口转换能实现类似 C++ 中模板的功能&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;函数 vs 方法&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;new&lt;/code&gt; vs &lt;code&gt;make&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;指针赋值给接口变量&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;flag文件夹中有&lt;code&gt;flag_test&lt;/code&gt;包&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;作用域&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;后续深入TODO&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;参考文献&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;简介&lt;/h2&gt;&lt;p&gt;flag 包是 Go 里用于解析命令行参数的包。为什么选择它作为第一个阅读的包，因为它的代码量少。其核心代码只有一个 1000 不到的 flag.go 文件。&lt;/p&gt;&lt;h2&gt;文件结构&lt;/h2&gt;&lt;p&gt;flag 包的文件结构很简单，就一层。一个文件夹里放了 5 个文件，其文件及其作用如下：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;flag.go&lt;/p&gt;&lt;p&gt;flag 的核心包，实现了命令行参数解析的所有功能&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;export_test.go&lt;/p&gt;&lt;p&gt;测试的实用工具，定义了所有测试需要的基础变量和函数&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;flag_test.go&lt;/p&gt;&lt;p&gt;flag 的测试文件，包含了 17 个测试单元&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;example_test.go&lt;/p&gt;&lt;p&gt;flag 的样例文件，介绍了 flag 包的三种常用的用法样例&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;example_value_test.go&lt;/p&gt;&lt;p&gt;flag 的样例文件，介绍了一个更复杂的样例&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;运行测试&lt;/h2&gt;&lt;p&gt;我先介绍一下 Go 的运行环境。&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;br/&gt;&lt;/span&gt;&lt;span&gt;2&lt;br/&gt;&lt;/span&gt;&lt;span&gt;3&lt;br/&gt;&lt;/span&gt;&lt;span&gt;4&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;code data-lang=&quot;bash&quot;&gt;&lt;span&gt;# 通过 brew install go 安装，源码位置为 $GOROOT/src&lt;/span&gt;&lt;br/&gt;&lt;span&gt;GOROOT&lt;/span&gt;=/usr/local/opt/go/libexec&lt;br/&gt;&lt;span&gt;# 阅读的源码通过 go get -v -d github.com/haojunyu/go 下载，源码位置为 $GOPATH/src/github.com&lt;/span&gt;&lt;br/&gt;&lt;span&gt;GOPATH&lt;/span&gt;=&lt;span&gt;$HOME&lt;/span&gt;/go&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;单独测试 flag 包踩过的坑：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;无法针对单个文件进行测试，需要针对包。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;这里重点说一下 export_test.go 文件，它是flag包的一部分&lt;code&gt;package flag&lt;/code&gt;，但是它确实专门为测试而存在的，说白了也就一个&lt;code&gt;ResetForTesting&lt;/code&gt;方法，用来清除所有命令参数状态并且直接设置Usage函数。该方法会在测试用例中被频繁使用。所以单独运行以下命令会报错&quot;flag_test.go:30:2: undefined: ResetForTesting”&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;br/&gt;&lt;/span&gt;&lt;span&gt;2&lt;br/&gt;&lt;/span&gt;&lt;span&gt;3&lt;br/&gt;&lt;/span&gt;&lt;span&gt;4&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;code data-lang=&quot;bash&quot;&gt;&lt;span&gt;# 测试当前目录（报错）&lt;/span&gt;&lt;br/&gt;go &lt;span&gt;test&lt;/span&gt; -v .&lt;br/&gt;&lt;span&gt;# 测试包&lt;/span&gt;&lt;br/&gt;go &lt;span&gt;test&lt;/span&gt; -v flag&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;go test -v flag&lt;/code&gt; 测试的源码是 &lt;code&gt;$GOROOT/src&lt;/code&gt; 下的（以我当前的测试环境）&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;指定 flag 包后，实际运行的源码是 &lt;code&gt;$GOROOT&lt;/code&gt; 下的，这个应该和我的安装方式有关系。&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;h3&gt;接口转换能实现类似 C++ 中模板的功能&lt;/h3&gt;&lt;p&gt;flag 包中定义了一个结构体类型叫 &lt;code&gt;Flag&lt;/code&gt;，它用来存放一个命令参数，其定义如下。&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;br/&gt;&lt;/span&gt;&lt;span&gt;2&lt;br/&gt;&lt;/span&gt;&lt;span&gt;3&lt;br/&gt;&lt;/span&gt;&lt;span&gt;4&lt;br/&gt;&lt;/span&gt;&lt;span&gt;5&lt;br/&gt;&lt;/span&gt;&lt;span&gt;6&lt;br/&gt;&lt;/span&gt;&lt;span&gt;7&lt;br/&gt;&lt;/span&gt;&lt;span&gt;8&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;code data-lang=&quot;go&quot;&gt;&lt;span&gt;// A Flag represents the state of a flag.&lt;br/&gt;&lt;/span&gt;&lt;span/&gt;&lt;span&gt;// 结构体Flag表示一个参数的所有信息，包括名称，帮助信息，实际值和默认值&lt;br/&gt;&lt;/span&gt;&lt;span/&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;Flag&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;Name&lt;/span&gt;     &lt;span&gt;string&lt;/span&gt; &lt;span&gt;// name as it appears on command line名称&lt;br/&gt;&lt;/span&gt;&lt;span/&gt;&lt;span&gt;Usage&lt;/span&gt;    &lt;span&gt;string&lt;/span&gt; &lt;span&gt;// help message帮助信息&lt;br/&gt;&lt;/span&gt;&lt;span/&gt;&lt;span&gt;Value&lt;/span&gt;    &lt;span&gt;Value&lt;/span&gt;  &lt;span&gt;// value as set实现了取值/赋值方法的接口&lt;br/&gt;&lt;/span&gt;&lt;span/&gt;&lt;span&gt;DefValue&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; &lt;span&gt;// default value (as text); for usage message默认值&lt;br/&gt;&lt;/span&gt;&lt;span/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;其中命令参数的值是一个 &lt;code&gt;Value&lt;/code&gt; 接口类型，其定义如下：&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;br/&gt;&lt;/span&gt;&lt;span&gt;2&lt;br/&gt;&lt;/span&gt;&lt;span&gt;3&lt;br/&gt;&lt;/span&gt;&lt;span&gt;4&lt;br/&gt;&lt;/span&gt;&lt;span&gt;5&lt;br/&gt;&lt;/span&gt;&lt;span&gt;6&lt;br/&gt;&lt;/span&gt;&lt;span&gt;7&lt;br/&gt;&lt;/span&gt;&lt;span&gt;8&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;code data-lang=&quot;go&quot;&gt;&lt;span&gt;// Set is called once, in command line order, for each flag present.&lt;br/&gt;&lt;/span&gt;&lt;span/&gt;&lt;span&gt;// The flag package may call the String method with a zero-valued receiver,&lt;br/&gt;&lt;/span&gt;&lt;span/&gt;&lt;span&gt;// such as a nil pointer.&lt;br/&gt;&lt;/span&gt;&lt;span/&gt;&lt;span&gt;// 接口Value是个接口，在结构体Flag中用来存储每个参数的动态值（参数类型格式各样）&lt;br/&gt;&lt;/span&gt;&lt;span/&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;Value&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;String&lt;/span&gt;() &lt;span&gt;string&lt;/span&gt;   &lt;span&gt;// 取值方法&lt;br/&gt;&lt;/span&gt;&lt;span/&gt;&lt;span&gt;Set&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;) &lt;span&gt;error&lt;/span&gt; &lt;span&gt;// 赋值方法&lt;br/&gt;&lt;/span&gt;&lt;span/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;为什么这么做？因为这样做能够实现类似模板的功能。任何一个类型 &lt;code&gt;T&lt;/code&gt; 只要实现了 &lt;code&gt;Value&lt;/code&gt; 接口里的 &lt;code&gt;String&lt;/code&gt; 和 &lt;code&gt;Set&lt;/code&gt; 方法，那么该类型 &lt;code&gt;T&lt;/code&gt; 的变量 &lt;code&gt;v&lt;/code&gt; 就可以转换成 &lt;code&gt;Value&lt;/code&gt; 接口类型，并使用 &lt;code&gt;String&lt;/code&gt; 来取值，使用 &lt;code&gt;Set&lt;/code&gt; 来赋值。这样就能完美的解决不同类型使用相同的代码操作目的，和 C++ 中的模板有相同的功效。&lt;/p&gt;&lt;h3&gt;函数 vs 方法&lt;/h3&gt;&lt;p&gt;函数和方法都是一组一起执行一个任务的语句，二者的区别在于调用者不同，函数的调用者是包 package，而方法的调用者是接受者 receiver。在 flag 的源码中，有太多的函数里面只有一行，就是用包里的变量 &lt;code&gt;CommandLine&lt;/code&gt; 调用同名方法。&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;br/&gt;&lt;/span&gt;&lt;span&gt; 2&lt;br/&gt;&lt;/span&gt;&lt;span&gt; 3&lt;br/&gt;&lt;/span&gt;&lt;span&gt; 4&lt;br/&gt;&lt;/span&gt;&lt;span&gt; 5&lt;br/&gt;&lt;/span&gt;&lt;span&gt; 6&lt;br/&gt;&lt;/span&gt;&lt;span&gt; 7&lt;br/&gt;&lt;/span&gt;&lt;span&gt; 8&lt;br/&gt;&lt;/span&gt;&lt;span&gt; 9&lt;br/&gt;&lt;/span&gt;&lt;span&gt;10&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;code data-lang=&quot;go&quot;&gt;&lt;span&gt;// Parsed reports whether f.Parse has been called.&lt;br/&gt;&lt;/span&gt;&lt;span/&gt;&lt;span&gt;// Parsed方法：命令行参数是否已经解析&lt;br/&gt;&lt;/span&gt;&lt;span/&gt;&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;f&lt;/span&gt; *&lt;span&gt;FlagSet&lt;/span&gt;) &lt;span&gt;Parsed&lt;/span&gt;() &lt;span&gt;bool&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;.&lt;span&gt;parsed&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Parsed reports whether the command-line flags have been parsed.&lt;br/&gt;&lt;/span&gt;&lt;span/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Parsed&lt;/span&gt;() &lt;span&gt;bool&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;CommandLine&lt;/span&gt;.&lt;span&gt;Parsed&lt;/span&gt;()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3&gt;&lt;code&gt;new&lt;/code&gt; vs &lt;code&gt;make&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;new&lt;/code&gt; 和 &lt;code&gt;make&lt;/code&gt; 是 Go 语言中两种内存分配原语。二者所做的事情和针对的类型都不一样。 &lt;code&gt;new&lt;/code&gt; 和其他编程语言中的关键字功能类似，都是向系统申请一段内存空间来存储对应类型的数据，但又有些区别，区别在于它会将该片空间置零。也就是说 &lt;code&gt;new(T)&lt;/code&gt; 会根据类型 &lt;code&gt;T&lt;/code&gt; 在堆上 申请一片置零的内存空间，并返回指针 &lt;code&gt;*T&lt;/code&gt;。 &lt;code&gt;make&lt;/code&gt; 只针对切片，映射和信道三种数据类型 &lt;code&gt;T&lt;/code&gt; 的构建，并返回类型为 &lt;code&gt;T&lt;/code&gt; 的一个已经初始化（而非零）的值。原因是这三种数据类型都是引用数据类型，在使用前必须初始化。就像切片是一个具有三项内容的描述符，包含一个指向数组的指针，长度和容量。通过 &lt;code&gt;make&lt;/code&gt; 创建对应类型的变量过程是先分配一段空间，接着根据对应的描述符来创建对应的类型变量。关于 &lt;code&gt;make&lt;/code&gt; 的细节可以看 draveness 写的 Go语言设计与实现。&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;br/&gt;&lt;/span&gt;&lt;span&gt; 2&lt;br/&gt;&lt;/span&gt;&lt;span&gt; 3&lt;br/&gt;&lt;/span&gt;&lt;span&gt; 4&lt;br/&gt;&lt;/span&gt;&lt;span&gt; 5&lt;br/&gt;&lt;/span&gt;&lt;span&gt; 6&lt;br/&gt;&lt;/span&gt;&lt;span&gt; 7&lt;br/&gt;&lt;/span&gt;&lt;span&gt; 8&lt;br/&gt;&lt;/span&gt;&lt;span&gt; 9&lt;br/&gt;&lt;/span&gt;&lt;span&gt;10&lt;br/&gt;&lt;/span&gt;&lt;span&gt;11&lt;br/&gt;&lt;/span&gt;&lt;span&gt;12&lt;br/&gt;&lt;/span&gt;&lt;span&gt;13&lt;br/&gt;&lt;/span&gt;&lt;span&gt;14&lt;br/&gt;&lt;/span&gt;&lt;span&gt;15&lt;br/&gt;&lt;/span&gt;&lt;span&gt;16&lt;br/&gt;&lt;/span&gt;&lt;span&gt;17&lt;br/&gt;&lt;/span&gt;&lt;span&gt;18&lt;br/&gt;&lt;/span&gt;&lt;span&gt;19&lt;br/&gt;&lt;/span&gt;&lt;span&gt;20&lt;br/&gt;&lt;/span&gt;&lt;span&gt;21&lt;br/&gt;&lt;/span&gt;&lt;span&gt;22&lt;br/&gt;&lt;/span&gt;&lt;span&gt;23&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;code data-lang=&quot;go&quot;&gt;&lt;span&gt;// Bool defines a bool flag with specified name, default value, and usage string.&lt;br/&gt;&lt;/span&gt;&lt;span/&gt;&lt;span&gt;// The return value is the address of a bool variable that stores the value of the flag.&lt;br/&gt;&lt;/span&gt;&lt;span/&gt;&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;f&lt;/span&gt; *&lt;span&gt;FlagSet&lt;/span&gt;) &lt;span&gt;Bool&lt;/span&gt;(&lt;span&gt;name&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;, &lt;span&gt;value&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;, &lt;span&gt;usage&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;) *&lt;span&gt;bool&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;p&lt;/span&gt; := &lt;span&gt;new&lt;/span&gt;(&lt;span&gt;bool&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;f&lt;/span&gt;.&lt;span&gt;BoolVar&lt;/span&gt;(&lt;span&gt;p&lt;/span&gt;, &lt;span&gt;name&lt;/span&gt;, &lt;span&gt;value&lt;/span&gt;, &lt;span&gt;usage&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;p&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// sortFlags returns the flags as a slice in lexicographical sorted order.&lt;br/&gt;&lt;/span&gt;&lt;span/&gt;&lt;span&gt;// sortFlags函数：按字典顺序排序命令参数，并返回Flag的切片&lt;br/&gt;&lt;/span&gt;&lt;span/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;sortFlags&lt;/span&gt;(&lt;span&gt;flags&lt;/span&gt; &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]*&lt;span&gt;Flag&lt;/span&gt;) []*&lt;span&gt;Flag&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;result&lt;/span&gt; := &lt;span&gt;make&lt;/span&gt;([]*&lt;span&gt;Flag&lt;/span&gt;, &lt;span&gt;len&lt;/span&gt;(&lt;span&gt;flags&lt;/span&gt;))&lt;br/&gt;&lt;span&gt;i&lt;/span&gt; := &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; &lt;span&gt;_&lt;/span&gt;, &lt;span&gt;f&lt;/span&gt; := &lt;span&gt;range&lt;/span&gt; &lt;span&gt;flags&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;result&lt;/span&gt;[&lt;span&gt;i&lt;/span&gt;] = &lt;span&gt;f&lt;/span&gt;&lt;br/&gt;&lt;span&gt;i&lt;/span&gt;++&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;sort&lt;/span&gt;.&lt;span&gt;Slice&lt;/span&gt;(&lt;span&gt;result&lt;/span&gt;, &lt;span&gt;func&lt;/span&gt;(&lt;span&gt;i&lt;/span&gt;, &lt;span&gt;j&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;) &lt;span&gt;bool&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;result&lt;/span&gt;[&lt;span&gt;i&lt;/span&gt;].&lt;span&gt;Name&lt;/span&gt; &amp;lt; &lt;span&gt;result&lt;/span&gt;[&lt;span&gt;j&lt;/span&gt;].&lt;span&gt;Name&lt;/span&gt;&lt;br/&gt;})&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;result&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3&gt;指针赋值给接口变量&lt;/h3&gt;&lt;p&gt;Go 中的接口有两层含义，第一层是一组方法（不是函数）的签名，它需要接受者（具体类型 &lt;code&gt;T&lt;/code&gt; 或具体类型指针 &lt;code&gt;*T&lt;/code&gt; ）来实现细节；另一层是一个类型，而该类型能接受所有现实该接受的接受者。深入理解接口的概念可以细读 Go语言设计与实现之接口。在 flag 包中的 &lt;code&gt;StringVar&lt;/code&gt; 方法中&lt;code&gt;newStringValue(value, p)&lt;/code&gt;返回的是 &lt;code&gt;*stringValue&lt;/code&gt; 类型，而该类型（接受者）实现了 &lt;code&gt;Value&lt;/code&gt; 接口（ &lt;code&gt;String&lt;/code&gt; 和 &lt;code&gt;Set&lt;/code&gt; 方法），此时该类型就可以赋值给 &lt;code&gt;Value&lt;/code&gt; 接口变量。&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;br/&gt;&lt;/span&gt;&lt;span&gt;2&lt;br/&gt;&lt;/span&gt;&lt;span&gt;3&lt;br/&gt;&lt;/span&gt;&lt;span&gt;4&lt;br/&gt;&lt;/span&gt;&lt;span&gt;5&lt;br/&gt;&lt;/span&gt;&lt;span&gt;6&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;code data-lang=&quot;go&quot;&gt;&lt;span&gt;// StringVar defines a string flag with specified name, default value, and usage string.&lt;br/&gt;&lt;/span&gt;&lt;span/&gt;&lt;span&gt;// The argument p points to a string variable in which to store the value of the flag.&lt;br/&gt;&lt;/span&gt;&lt;span/&gt;&lt;span&gt;// StringVar方法：将命令行参数的默认值value赋值给变量*p,并生成结构Flag并置于接受者中f.formal&lt;br/&gt;&lt;/span&gt;&lt;span/&gt;&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;f&lt;/span&gt; *&lt;span&gt;FlagSet&lt;/span&gt;) &lt;span&gt;StringVar&lt;/span&gt;(&lt;span&gt;p&lt;/span&gt; *&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;name&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;, &lt;span&gt;value&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;, &lt;span&gt;usage&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;) {&lt;br/&gt;&lt;span&gt;f&lt;/span&gt;.&lt;span&gt;Var&lt;/span&gt;(&lt;span&gt;newStringValue&lt;/span&gt;(&lt;span&gt;value&lt;/span&gt;, &lt;span&gt;p&lt;/span&gt;), &lt;span&gt;name&lt;/span&gt;, &lt;span&gt;usage&lt;/span&gt;) &lt;span&gt;// newStringValue返回值是*stringValue类型，之所以能赋值给Value接口是因为newStringValue实现Value接口时定义的接受者为*stringValue&lt;br/&gt;&lt;/span&gt;&lt;span/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3&gt;flag文件夹中有&lt;code&gt;flag_test&lt;/code&gt;包&lt;/h3&gt;&lt;p&gt;flag 文件夹下有 &lt;code&gt;flag_test&lt;/code&gt; 包，是因为该文件夹下包含了核心代码 flag.go 和测试代码 *_test.go 。这两部分代码并没有通过文件夹来区分。所以该 &lt;code&gt;flag_test&lt;/code&gt; 包存在的意义是将测试代码与核心代码区分出来。而该包被引用时只会使用到核心代码。&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;br/&gt;&lt;/span&gt;&lt;span&gt;2&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;code data-lang=&quot;go&quot;&gt;&lt;span&gt;// example_test.go&lt;br/&gt;&lt;/span&gt;&lt;span/&gt;&lt;span&gt;package&lt;/span&gt; &lt;span&gt;flag_test&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3&gt;作用域&lt;/h3&gt;&lt;p&gt;关于作用域 Golang变量作用域 和 GO语言圣经中关于作用域 都有了详细的介绍，前者更通俗易懂些，后者更专业些。在 flag 包的 &lt;code&gt;TestUsage&lt;/code&gt; 测试样例中，因为 &lt;code&gt;func(){called=true}&lt;/code&gt; 是在函数 &lt;code&gt;TestUsage&lt;/code&gt; 中定义函数，并且直接作为形参传递给 &lt;code&gt;ResetForTesting&lt;/code&gt; 函数，所以该函数是和局部变量 &lt;code&gt;called&lt;/code&gt; 是同级的，当然在该函数中给该变量赋值也是合理的。&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;br/&gt;&lt;/span&gt;&lt;span&gt; 2&lt;br/&gt;&lt;/span&gt;&lt;span&gt; 3&lt;br/&gt;&lt;/span&gt;&lt;span&gt; 4&lt;br/&gt;&lt;/span&gt;&lt;span&gt; 5&lt;br/&gt;&lt;/span&gt;&lt;span&gt; 6&lt;br/&gt;&lt;/span&gt;&lt;span&gt; 7&lt;br/&gt;&lt;/span&gt;&lt;span&gt; 8&lt;br/&gt;&lt;/span&gt;&lt;span&gt; 9&lt;br/&gt;&lt;/span&gt;&lt;span&gt;10&lt;br/&gt;&lt;/span&gt;&lt;span&gt;11&lt;br/&gt;&lt;/span&gt;&lt;span&gt;12&lt;br/&gt;&lt;/span&gt;&lt;span&gt;13&lt;br/&gt;&lt;/span&gt;&lt;span&gt;14&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;code data-lang=&quot;go&quot;&gt;&lt;span&gt;//  called变量的作用域&lt;br/&gt;&lt;/span&gt;&lt;span/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;TestUsage&lt;/span&gt;(&lt;span&gt;t&lt;/span&gt; *&lt;span&gt;testing&lt;/span&gt;.&lt;span&gt;T&lt;/span&gt;) {&lt;br/&gt;&lt;span&gt;called&lt;/span&gt; := &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 变量called的作用域&lt;br/&gt;&lt;/span&gt;&lt;span/&gt;&lt;span&gt;ResetForTesting&lt;/span&gt;(&lt;span&gt;func&lt;/span&gt;() { &lt;span&gt;called&lt;/span&gt; = &lt;span&gt;true&lt;/span&gt; })&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;CommandLine&lt;/span&gt;.&lt;span&gt;Parse&lt;/span&gt;([]&lt;span&gt;string&lt;/span&gt;{&lt;span&gt;&quot;-x&quot;&lt;/span&gt;}) == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;t&lt;/span&gt;.&lt;span&gt;Error&lt;/span&gt;(&lt;span&gt;&quot;parse did not fail for unknown flag&quot;&lt;/span&gt;)&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;t&lt;/span&gt;.&lt;span&gt;Error&lt;/span&gt;(&lt;span&gt;&quot;hahahh&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; !&lt;span&gt;called&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;t&lt;/span&gt;.&lt;span&gt;Error&lt;/span&gt;(&lt;span&gt;&quot;did not call Usage for unknown flag&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;后续深入TODO&lt;/h2&gt;&lt;h2&gt;参考文献&lt;/h2&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Go 夜读之 flag 包视频&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;实效 Go 编程之内存分配&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Go 语言设计与实现之 make 和 new&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;菜鸟教程之 Go 语言变量作用域&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Go 语言圣经中关于作用域&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Go 语言中值 receiver 和指针 receiver 的对比&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Go CodeReviewComments&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Golang 变量作用域&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Go 语言圣经中关于作用域&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Go 语言设计与实现之接口&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>