<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>c754b5e331946e9eced256584b3ac950</guid>
<title>推荐 7 个牛哄哄 Spring Cloud 实战项目</title>
<link>https://toutiao.io/k/016vv4f</link>
<content:encoded>&lt;div&gt;&lt;div&gt;

                

                
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>81a426122bacfc3c908f02b1c37a1ad7</guid>
<title>字节跳动前端日常实习一二三面面经（Offer 还愿）</title>
<link>https://toutiao.io/k/lu4qgp2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-topic-des nc-post-content&quot;&gt;
&lt;h1&gt; 时间线 &lt;/h1&gt; 
&lt;p&gt;
  5.19投递简历 
&lt;/p&gt; 
&lt;p&gt;
  5.20hr约一面 
&lt;/p&gt; 
&lt;p&gt;
  5.24一面 
&lt;/p&gt; 
&lt;p&gt;
  5.25中午一面通过，hr约二面时间。本来约的是6月1号，但面试官临时请假，改到了3号 
&lt;/p&gt; 
&lt;p&gt;
  6.3二面 
&lt;/p&gt; 
&lt;p&gt;
  6.4下午二面通过，hr约三面时间 
&lt;/p&gt; 
&lt;p&gt;
  6.8三面 
&lt;/p&gt; 
&lt;p&gt;
  6.9中午三面通过，hr约10号三面 
&lt;/p&gt; 
&lt;p&gt;
  有些问题可能不是面试官的本意，还有一些问题没听懂，从场景题提取问题出来还是挺难的 
&lt;/p&gt; 
&lt;div&gt;
 &lt;span&gt; 其实15号中午的时候就offer了，现在来添加&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%9D%A2%E7%BB%8F&quot; target=&quot;_blank&quot;&gt;面经&lt;/a&gt;答案，答案只是我的见解哈，有些部分也没给出来，如果有错误欢迎指出 &lt;/span&gt;
&lt;/div&gt; 
 
&lt;h1&gt; &lt;span&gt;&lt;span&gt;一面（&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%89%9B%E5%AE%A2&quot; target=&quot;_blank&quot;&gt;牛客&lt;/a&gt;50mins）&lt;/span&gt;&lt;/span&gt; &lt;/h1&gt; 
&lt;div&gt; 
 &lt;span&gt; 
  &lt;ol&gt; 
   &lt;li&gt; &lt;p&gt; &lt;span&gt;怎么判断两个网站是否同域&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;浏览器从一个域向另一个域的服务器发送请求来访问其资源。 浏览器的同源策略：协议、域名、端口号一致。&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;保持登录状态能够使用什么实现&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;cookie,token&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;externals是怎么实现的&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span/&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;你这些外部的资源是存在公共的CDN上，还是有现成可以直接用的托管CDN&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;回答了公共的CDN&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;是哪种类型的CDN呢，具体是哪些域名&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;为什么CDN能够加速用户访问一个网站，它的原理是什么&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;最简单的CDN网络由一个DNS服务器和几台缓存服务器组成：&lt;/span&gt; &lt;/p&gt; 
     &lt;ol&gt; 
      &lt;li&gt; &lt;p&gt; &lt;span&gt;当用户点击网站页面上的内容URL，经过本地DNS系统解析，DNS系统会最终将域名的解析权交给CNAME指向的CDN专用DNS服务器。&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
      &lt;li&gt; &lt;p&gt; &lt;span&gt;CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回给用户&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
      &lt;li&gt; &lt;p&gt; &lt;span&gt;用户向CDN的全局负载均衡设备发起内容URL访问请求&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
      &lt;li&gt; &lt;p&gt; &lt;span&gt;CDN全局负载均衡设备根据用户IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
      &lt;li&gt; &lt;p&gt; &lt;span&gt;区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：根据用户IP地址，判断哪一台服务器距用户最近；根据用户所请求的URL中携带的内容名称，判断哪一台服务器上有用户所需内容；查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。基于以上这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
      &lt;li&gt; &lt;p&gt; &lt;span&gt;全局负载均衡设备把服务器的IP地址返回给用户&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
      &lt;li&gt; &lt;p&gt; &lt;span&gt;用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
     &lt;/ol&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;怎么确定哪个CDN节点离用户最近呢&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;上个问题答案的第4.5点&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;假设同样的资源，我用域名去访问，访问到哪个服务器取决于什么？&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;DNS &lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;DNS解析过程&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/yanshuanche3765/article/details/82589210&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;参考文章&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;简单的来说，浏览器先检查自身有没有缓存，如果没有就检查操作系统有没有缓存，如果还是没有就会向本地域名服务器发起一个请求来解析这个域名；如果本地域名服务器还是没有，则会从根域名服务器开始递归查找域名，直到找到为止。&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;DNS解析过程中，某个DNS服务器的记录被篡改过，指向一个恶意网站，这种情况会对用户的访问造成安全风险，这么防范。怎么防范DNS污染（应该是这个问题）&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;感觉这个问题不是很重要&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;DNS使用什么网络协议&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_41563161/article/details/106069473?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&amp;amp;spm=1001.2101.3001.4242&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;参考文章&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;&lt;strong&gt;DNS区域传输的时候使用TCP协议：&lt;/strong&gt;&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;1.辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;2.TCP是一种可靠连接，保证了数据的准确性。&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;&lt;strong&gt;域名解析时使用UDP协议：&lt;/strong&gt;&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;除了打包体积减小，还有哪些手段可以提升用户的访问速度&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;缓存，懒加载，代码优化，SSR...&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;HTTP缓存怎么设置&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/jiang_yonghui/article/details/100569565&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;参考这个&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;通过设置Cache-Control/Pragma、Expires(过期时间)、Last-Modified/Etag。&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;确定协商缓存有效性的协商过程是怎么样的&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;在第一次请求服务器时，服务器会返回资源，并且返回一个资源的缓存标识，一起存到浏览器的缓存数据库。当第二次请求资源时，浏览器会首先将缓存标识发送给服务器，服务器拿到标识后判断标识是否匹配，如果不匹配，表示资源有更新，服务器会将新数据和新的缓存标识一起返回到浏览器；如果缓存标识匹配，表示资源没有更新，并且返回 &lt;/span&gt;&lt;span&gt;304&lt;/span&gt;&lt;span&gt; 状态码，浏览器就读取本地缓存服务器中的数据。&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;有些资源打开页面的时候不需要，需要的时候在加载&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/bury_/article/details/79516223&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;懒加载原理&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;懒加载&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;不同类型的东西处理方式不一样，例如图片，js代码，他们分别怎么懒加载&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;js通过设置defer和async&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;建议图片懒加载多去看看实现方法&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/w1418899532/article/details/90515969?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-4.control&amp;amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-4.control&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;图片懒加载&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;有没有更简单的方式去判断图片离浏览器顶部距离的方法&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;阮一峰老师的文章&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;面试官建议：intersectionObserver?这个API，可以监控一个元素即将进入到窗口的范围&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;说一下Vue的工作原理（响应式原理）&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;Vue响应式底层实现方法是 Object.defineProperty() 方法，该方法中存在一个getter和setter的可选项，可以对属性值的获取和设置造成影响&lt;/span&gt; &lt;/p&gt; 
     &lt;ul&gt; 
      &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;当你把一个普通的 &lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=JavaScript&quot; target=&quot;_blank&quot;&gt;JavaScript&lt;/a&gt; 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的 property，并使用 Object.defineProperty 把这些 property 全部转为 getter/setter。&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
      &lt;li&gt; &lt;p&gt; &lt;span&gt;这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
      &lt;li&gt; &lt;p&gt; &lt;span&gt;每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
     &lt;/ul&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;我改变了一个Data中数据后，他怎么更新到实际页面的DOM，这个过程是怎样的&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;模板里面，对于一个字段的引用是怎么收集的&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;对于这个字段的依赖是在什么时候建立的呢，是怎么建立的呢&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;假设有A，B两个请求，希望在A请求完后拿到一个结果，之后将A的结果作为参数给B，B发起请求，这样的过程要怎么实现&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;异步操作&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;如果A，B没有依赖关系，希望两个都拿到结果之后，在执行一些操作，要怎么实现&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;Promise.all&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;你提到Promise.all，那假设浏览器没有这个东西，你给我整一个&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;div&gt; 
      &lt;span&gt;接下来是20分钟的修改代码过程...&lt;/span&gt;
      &lt;span&gt; &lt;pre class=&quot;prettyprint lang-js&quot; from-niu=&quot;default&quot;&gt;function myPromiseAll(promises) {
  let results = [];
  let promiseCount = 0;
  let promisesLength = promises.length;
  return new Promise(function(resolve, reject) {
    for(let i = 0; i &amp;lt; promises.length; i++){
      Promise.resolve(promises[i]).then(function(res) {
        promiseCount++;
        results[i] = res;
        // 当所有函数都正确执行了，resolve输出所有返回结果。
        if (promiseCount === promisesLength) {
          return resolve(results);
        }
      }, function(err) {
        return reject(err);
      });
    }
  });
};
&lt;/pre&gt; &lt;br/&gt; &lt;span/&gt;&lt;/span&gt; 
     &lt;/div&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;反问&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;部门：交叉面试&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;建议：多实践&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
  &lt;/ol&gt; &lt;br/&gt; &lt;/span&gt; 
&lt;/div&gt; 
&lt;h1&gt; &lt;span&gt;&lt;span&gt;二面（&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%89%9B%E5%AE%A2&quot; target=&quot;_blank&quot;&gt;牛客&lt;/a&gt;38mins）&lt;/span&gt;&lt;/span&gt; &lt;/h1&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;简单问了下&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;的东西&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
 &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;里有订单管理的功能，一般来说订单要考虑什么状态呢&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
 &lt;li&gt; &lt;p&gt; &lt;span&gt;如何实时拿到这些状态呢&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
 &lt;li&gt; &lt;p&gt; &lt;span&gt;最近在学什么呢&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
 &lt;li&gt; &lt;span&gt; &lt;p&gt; &lt;span&gt;vue框架有什么特点&lt;/span&gt; &lt;/p&gt; 
   &lt;blockquote&gt; 
    &lt;p&gt; &lt;span&gt;数据驱动、组件化&lt;/span&gt; &lt;/p&gt; 
   &lt;/blockquote&gt; &lt;/span&gt; &lt;/li&gt;
 &lt;li&gt; &lt;p&gt; &lt;span&gt;手撕代码（写完说思路&lt;/span&gt; &lt;/p&gt; 
  &lt;blockquote&gt; 
   &lt;div&gt; 
    &lt;span&gt;&lt;span&gt;冒泡，快速&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt; &lt;/span&gt;&lt;pre class=&quot;prettyprint lang-js&quot; from-niu=&quot;default&quot;&gt;function bubbleSort(array){
    let length = array.length;
    for(let i = 0; i &amp;lt; length - 1; i++){
        for(let j = 0; j &amp;lt; length - i -1; j++){
            if(array[j] &amp;lt; array[j+1]){
                [array[j],array[j+1]] = [array[j+1],array[j]];
            }
        }
    }
}

let test = [6,8,4,5,1];
bubbleSort(test);
console.log(test);

function quickSort(array){
    if(array.length &amp;lt; 2) return array;
    let leftArray = [];
    let rightArray = [];
    let base = array[0];
    array.forEach((element) =&amp;gt; {
        if(element &amp;gt; base){
            leftArray.push(element);
        } else if(element &amp;lt; base){
            rightArray.push(element);
        }
    });
    return quickSort(leftArray).concat(base,quickSort(rightArray));
};

let test2 = [5,3,2,1,4];
let res = quickSort(test2);

console.log(res);&lt;/pre&gt; &lt;br/&gt; &lt;span/&gt;&lt;/span&gt; 
   &lt;/div&gt; 
  &lt;/blockquote&gt; 
  &lt;blockquote&gt; 
   &lt;p&gt; &lt;span&gt;实现一个函数，把一个字符串数组（[&#x27;zm&#x27;, &#x27;za&#x27;, &#x27;b&#x27;, &#x27;lm&#x27;, &#x27;ln&#x27;, &#x27;k&#x27;]）格式化成一个对象 { &#x27;b&#x27;: [&#x27;b&#x27;], &#x27;k&#x27;: [&#x27;k&#x27;], &#x27;l&#x27;: [&#x27;lm&#x27;, &#x27;ln&#x27;], &#x27;z&#x27;: [&#x27;za&#x27;, &#x27;zm&#x27;] }&lt;/span&gt; &lt;/p&gt; 
  &lt;/blockquote&gt; &lt;p&gt; &lt;span&gt;这道题没写完整，说了下思路用伪代码写了下。&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
 &lt;li&gt; &lt;p&gt; &lt;span&gt;近一两年的规划&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
 &lt;li&gt; &lt;p&gt; &lt;span&gt;为什么选择字节&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt; &lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
&lt;/ol&gt; 
&lt;h1&gt; &lt;span&gt;&lt;span&gt;三面6.8（&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%89%9B%E5%AE%A2&quot; target=&quot;_blank&quot;&gt;牛客&lt;/a&gt;38mins）&lt;/span&gt;&lt;span/&gt;&lt;/span&gt; &lt;/h1&gt; 
&lt;div&gt; 
 &lt;span&gt; 
  &lt;ol&gt; 
   &lt;li&gt; &lt;p&gt; &lt;span&gt;聊了下之前的笔试&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;参与之前的面试下来，有什么感受，有没有总结出自己的长处与短板&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;&lt;span&gt;提到了要深入学原理&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%BA%90%E7%A0%81&quot; target=&quot;_blank&quot;&gt;源码&lt;/a&gt;啥的&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;你打算怎么看&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%BA%90%E7%A0%81&quot; target=&quot;_blank&quot;&gt;源码&lt;/a&gt;&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;聊一下&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;为什么做这个&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;有没有你自己想的一些功能&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;怎样从零搭建&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/baidu_41690072/article/details/88820400&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;感觉就是看你是不是真的自己做了一遍&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;使用vue-cli初始化的步骤&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;vue-cli主要帮你完成了哪些事情&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;1.ES6代码转换成ES5代码 2. scss/sass/less/stylus转css 3. .vue文件转换成js文件 4. 使用 jpg、png，font等资源文件 4. 自动添加css各浏览器产商的前缀 5. 代码热更新 6. 资源预加载 7. 每次构建代码清除之前生成的代码 8. 定义环境变量 9. 区分开发环境打包跟生产环境打包 ......&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;其中生成的那些文件，分别是干什么的&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;packjson文件里有一些key，value。其中一个key叫dependencies和devDependencies，能说说作用吗&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;package.json:&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;&lt;span&gt;主要用来定义&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;中需要依赖的包&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;package-lock.json：&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;在 &lt;/span&gt;&lt;span&gt;npm install&lt;/span&gt;&lt;span&gt;时候生成一份文件，用以记录当前状态下实际安装的各个npm package的具体来源和版本号。&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;&#x27;^&#x27; :&lt;/span&gt;放在版本号之前，表示向后兼容依赖，说白了就是在大版本号不变的情况下，下载最新版的包 &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;中引入的包版本号之前经常会加^号，每次在执行npm install之后，下载的包都会发生变化，为了系统的稳定性考虑，每次执行完npm install之后会对应生成package-lock文件，该文件记录了上一次安装的具体的版本号，相当于是提供了一个参考，在出现版本兼容性问题的时候，就可以参考这个文件来修改版本号即可。&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; 
    &lt;blockquote&gt; 
     &lt;ol&gt; 
      &lt;li&gt; &lt;p&gt; &lt;span&gt;“dependencies”&lt;/span&gt;&lt;span&gt; 运行依赖，需引入页面使用&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
      &lt;li&gt; &lt;p&gt; &lt;span&gt;“devDependencies”&lt;/span&gt;&lt;span&gt; 开发依赖(生产环境使用)，只是开发阶段需要&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
     &lt;/ol&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;babel.config.js的作用&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;Babel是一个JS编译器，主要作用是将ECMAScript 2015+ 版本的代码，转换为向后兼容的JS语法，以便能够运行在当前和旧版本的浏览器或其它环境中。&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;&lt;span&gt;Vue&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;中普遍使用ES6语法，若要求兼容低版本浏览器，就需要引入Babel，将ES6转换为ES5。&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;babel怎么把es6转成es5&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;es6哪些特性你觉得比较常用或者好用&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;let const var区别&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;&lt;strong&gt;变量提升方面&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：var声明的变量存在变量提升，即变量可以在声明之前调用，值为undefined。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;let和const不存在变量提升问题(&lt;/span&gt;&lt;span&gt;注意这个‘问题’后缀，其实是有提升的，只不过是let和const具有一个暂时性死区的概念，即没有到其赋值时，之前就不能用&lt;/span&gt;&lt;span&gt;)，即它们所声明的变量一定要在声明后使用，否则报错。&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;&lt;strong&gt;块级作用域方面&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：var不存在块级作用域,let和const存在块级作用域&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;&lt;strong&gt;声明方面&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：var允许重复声明变量,let和const在同一作用域不允许重复声明变量。其中const声明一个只读的常量(因为如此，其声明时就一定要赋值，不然报错)。一旦声明，常量的值就不能改变。&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;回到&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;，登录功能怎么实现的&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;token怎么保持登录状态&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/u014322206/article/details/85089481&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;&lt;span&gt;当用户请求页面，输入用户信息，服务端经过验证后，会生成一个token安全令牌（随机字符串），并返回给&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;，当&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;发送下一次请求的时候，直接携带这个token，服务端识别后，就可以直接访问页面，不需要再次登录了&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;sessionStorage有什么优势，token应该放在哪&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/fejerry/p/10898530.html&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;sessionStorage的特点&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;+各个标签页的sessionStorage 是独立的 。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;+在a标签页写入修改删除sessionStorage ，不会影响到已经打开的标签页中的sessionStorage 。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;+通过a标签，window.open,window.location,windows.history ，右键复制 等方式在新标签页，本页，iframe ，新窗口中打开新页面，当前标签页的 sessionStorage 会传递到新页面。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;+通过按住 ctrl键打开新标签页，或者右键菜单打开新标签页，新窗口 ，当前标签页的 sessionStorage 是不会传递到新页面的 。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;+关闭某个标签页，该标签页的sessionStorage 会被销毁。不影响其他标签页或者窗口 。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;+在某个标签页即使跳出了当前站点，返回来的时候，sessionStorage 也还在的 。&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;鉴于它有以上特点 ：&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;1，可以用来做多账户登录 ， sessionid 不用cookie存储，用 sessionStorage 来存储。spa应用比较适合 。&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;p&gt; &lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/qq_43618136/article/details/114656505&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;token存放位置参考&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;Cookie 的作用是与服务器进行交互，作为 HTTP 规范的一部分而存在 ，而 Web Storage 仅仅是为了在本地“存储”数据而生。而token的安全和性能都是中肯的，唯一的问题就是cookie的存储性能和提取安全性太低，而localstorage更安全而且能够跨会话实现身份鉴别，很明显token应该存在localstorage里。&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;localStorage里可以存图片吗，怎么存&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/cockroach02/article/details/49926595&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;参考文章&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;我们的想法是做到将已经当前页面中已缓存的图片保存到本地存储中。不过就像我们之前已经确定的，本地存储只支持字符串的存取，那么我们要做的就是将图片转换成 &lt;/span&gt;&lt;span&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Data_URI_scheme&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;Data URI&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;span&gt; 。其中一种实现方式就是用canvas元素来加载图片。然后你可以以Data URI的形式从canvas中读取出当前展示的内容。&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;token能放在cookie里吗&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;可以&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;xss能不能取到sessionStorage里的数据&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;可以&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;hash路由和history路由&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;除了这个&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;还有别的&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;吗&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;翻页功能怎么实现&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;数据是&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%89%8D%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;前端&lt;/a&gt;来分页还是后端来分页&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;能实现&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%89%8D%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;前端&lt;/a&gt;分页吗&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;怎么实现&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;数据存哪&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;vuex有用过吗&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;vuex的目的是什么&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;已经有sessionStorage这类的放数据的地方，为什么还要有vuex，有什么特别的价值吗&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;聊了下笔试&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;问了下是不是还没有开始复习&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;和数据结构&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;说一个最近在复习的&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;再说说对应的例题&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;说了道最大无重复子串，双指针&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;复杂度&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92&quot; target=&quot;_blank&quot;&gt;动态规划&lt;/a&gt;一般解决什么样类型的问题&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92&quot; target=&quot;_blank&quot;&gt;动态规划&lt;/a&gt;相比于回溯，有什么优势&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;异步组件的懒加载是你自己想的还是教程有的&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;怎么实现懒加载&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;优化效果有看过吗&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;看到面评，问实习是想积累经验还是想转正&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;反问&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;部门：技术中台&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;看重实习生哪些方面&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
  &lt;/ol&gt; &lt;br/&gt; &lt;/span&gt; 
&lt;/div&gt; 
&lt;h1&gt; 碎碎念 &lt;/h1&gt; 
&lt;div&gt;&lt;p&gt;
  字节的面试官是能够看到你之前投递的简历，参加过的笔试和面试结果，所以如果要投的话一定要认真对待面试和笔试吧。
 &lt;/p&gt;&lt;span&gt;&lt;span&gt;另外我看到&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%89%9B%E5%AE%A2&quot; target=&quot;_blank&quot;&gt;牛客&lt;/a&gt;网也有&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%89%8D%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;前端&lt;/a&gt;的课程，笔试面试会涉及到的知识点里边基本都会涵盖，如果大家不知道从哪里开始学起的话可以报名这种课程~&lt;/span&gt;&lt;img data-card-emoji=&quot;[考得全会]&quot; src=&quot;https://uploadfiles.nowcoder.com/images/20191018/63_1571399956257_2484A7DF36877A14689574EEBDA6DD7C&quot;/&gt;&lt;/span&gt; 
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1757b3cc46b3d3b2af00b2772f344ca9</guid>
<title>Java 类加载器：坑爹是我的特色</title>
<link>https://toutiao.io/k/gnxxx4b</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是头发还很多的阿星&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0480769230769231&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzynmJ9bWzU7WbaTHAUb6lKfwPh7MfJsd4ZGiaKxs8KCBnUlaLzoNLgRMzPROpl4HzqDianVCkQulpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;312&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天的主角是「在日常开发中，存在感非常低的&lt;strong&gt;类加载器&lt;/strong&gt;」，众所周知大佬除了头发比较少，还非常低调，如果想和大佬交朋友，那一定要先认识大佬，下面阿星来带大家认识一下&lt;strong&gt;类加载器&lt;/strong&gt;（本文不涉及源码）。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是类加载器&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们平时写了那么多的&lt;code&gt;Java&lt;/code&gt;代码，却不知&lt;code&gt;Java&lt;/code&gt;类的加载过程，岂不是很尴尬，为了打破尴尬，阿星得从&lt;code&gt;Java&lt;/code&gt;类说起。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们编写的&lt;code&gt;Java&lt;/code&gt;类也就是&lt;code&gt;.java&lt;/code&gt;文件，通过&lt;code&gt;Java&lt;/code&gt;编译器编译成&lt;code&gt;.class&lt;/code&gt;文件，&lt;code&gt;.class&lt;/code&gt;文件中保存着&lt;code&gt;Java&lt;/code&gt;代码转换后的虚拟机指令。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7701317715959004&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzynmJ9bWzU7WbaTHAUb6lKhoWWRy3r114ib0lppyMJiaUhMVibeyA00qvb78sYy7o56VOKWwmiaII8Aw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;683&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当程序使用某个&lt;code&gt;Java&lt;/code&gt;类时，&lt;code&gt;JVM&lt;/code&gt;虚拟机会加载它的&lt;code&gt;.class&lt;/code&gt;文件到虚拟机的内存中，负责加载工作的就是&lt;strong&gt;类加载器&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;类加载过程&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实类加载器和日常生活中坐地铁过安检是一样的道理，不信你看下面的图&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.33208676140613314&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzynmJ9bWzU7WbaTHAUb6lKqO7QkKWDkBV72tfLMtwmicd2L8A11EoFrepK2rAqM37Yrnjx3nnnWsw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1337&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安检要经过一系列的检查过程，目的是让进入地铁站的人群符合乘坐标准，比如你不能感冒，不能带威胁人生安全的物品等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样&lt;strong&gt;类加载&lt;/strong&gt;也要经过一系列检查过程，这个过程称为&lt;strong&gt;类加载过程&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类加载过程分为&lt;strong&gt;加载、验证、准备、解析、初始化&lt;/strong&gt;，下图是对&lt;strong&gt;类加载过程&lt;/strong&gt;简单的介绍。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.34366925064599485&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzynmJ9bWzU7WbaTHAUb6lKy9LBicibYXM8STEJQoTJbzLGv2NKyIl592uqC2NKnQfI2vGjxBR41H7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1161&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类加载过程不是本文的重点，如果对这块有兴趣深入研究的伙伴可以去自行百度或google。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面要说说本文的重点，双亲委派模式&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;实力坑爹&lt;/span&gt;&lt;/h1&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0238095238095237&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/23OQmC1ia8nzynmJ9bWzU7WbaTHAUb6lKK0lTx8iaseiaBGGSljqicTxg2Ilcw2yy69W8cX2w3tC8zicz3d3QXQksKw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;252&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双亲委派机制有点像实力坑爹，出了什么事情都让爹去擦屁股，爹解决不了，自己才承担。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;JVM&lt;/code&gt;虚拟机提供了&lt;code&gt;3&lt;/code&gt;种类加载器，它们分别是启动类加载器（&lt;code&gt;Bootstrap&lt;/code&gt;）、扩展类加载器（&lt;code&gt;Extension&lt;/code&gt;）、系统类加载器（&lt;code&gt;System&lt;/code&gt;）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个类加载器都有明确的加载范围：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;启动类加载器（&lt;code&gt;Bootstrap&lt;/code&gt;）：加载&lt;code&gt;&amp;lt;JAVA_HOME&amp;gt;/lib&lt;/code&gt;路径下的核心类库&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;扩展类加载器（&lt;code&gt;Extension&lt;/code&gt;）：加载&lt;code&gt;&amp;lt;JAVA_HOME&amp;gt;/lib/ext&lt;/code&gt;l路径下的&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;系统类加载器（&lt;code&gt;System&lt;/code&gt;）：加载系统类路径&lt;code&gt;classpath&lt;/code&gt;，也就是我们经常用到的&lt;code&gt;classpath&lt;/code&gt;路径，一般情况该类加载器是程序中默认的类加载器&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzynmJ9bWzU7WbaTHAUb6lKSk4JpD8ibwFLC9OAFdwXZFhzqvE9okrsaU1ASJO1uKN1ibSib0pAFibNjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;652&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双亲委派模式的原理也十分简单，类加载器收到类加载请求，会委托给父类加载器去执行，父类加载器还存在其父类加载器，则进一步向上委托，依次递归，直到顶层类加载器，如果顶层类加载器加载到该类，就成功返回&lt;code&gt;class&lt;/code&gt;对象，否则委托给下级类加载器去执行，依次递归（&lt;strong&gt;此处的父子关系并非通常所说的继承关系，而是采用组合关系来实现&lt;/strong&gt;）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9266666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/23OQmC1ia8nzynmJ9bWzU7WbaTHAUb6lKrKvNzRpO9LdkXPKsIbg1vlZXZDDqKY01A57q1ahPtAwHQrxsHYT90A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;300&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用大白话来说就是，每个儿子都很懒，有事就丢给爹去干，直到爹说这件事我也干不了，儿子自己再想办法完成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双亲委派模式是为了避免重复加载和核心类篡改。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;特殊需求&lt;/span&gt;&lt;/h1&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9246376811594202&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/23OQmC1ia8nzynmJ9bWzU7WbaTHAUb6lKqDfmzeNeTDhl4f3N5LD06yKlXdD7YKeazBaK9v6hick53MMqqDOhJlA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;345&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在日常开发中，我们可能会有特殊的业务需求，可能就需要使用到&lt;strong&gt;自定义类加载器&lt;/strong&gt;，该加载器的上级一定是&lt;strong&gt;系统类加载器&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;你们想要的特殊需求&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;资源隔离&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;web&lt;/code&gt;容器可能需要部署两个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，因此要保证每个应用程序的类库都是独立的，相互隔离&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;web&lt;/code&gt;容器有自己依赖的类库，不能与应用程序的类库混淆，基于安全考虑，应该让容器的类库和程序的类库隔离&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;加密保护&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;公司的一些核心类库，可能会把字节码加密，这样加载类的时候就必须对字节码进行解密&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;其他来源加载类&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;类重新加载&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;JVM&lt;/code&gt;中类对象的唯一性：类加载器实例+完整类名&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;程序运行中，类内容发生变化，创建自定义加载器实例重新加载类，达到的热部署效果。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6775&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/23OQmC1ia8nzynmJ9bWzU7WbaTHAUb6lKfJAWTpJjRwzYL58nPnurgUG7KFuRcDsz5K1afdNhye6Xgh0PMp3wLQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;400&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里大家有个概念，理解下就够了，想深入探索就需要涉及源码分析，如果大伙有兴趣，评论区留言，阿星后续单独补一篇源码分析~&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;强大的父亲&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些爹的实力恐怖如斯，为了啥事都能帮后代处理好，直接破坏双亲委派模式，深受孩儿们的喜爱。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7671232876712328&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/23OQmC1ia8nzynmJ9bWzU7WbaTHAUb6lKGrj1sME5fw2kwdPSYLaFhuU8X9N5kmo4lic7YYfQhhF1YlZH7fOqqqA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;292&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Java&lt;/code&gt;应用中存在着很多服务提供者接口（&lt;code&gt;Service Provider Interface，SPI&lt;/code&gt;），这些接口允许第三方为它们提供实现，如常见的&lt;code&gt;SPI&lt;/code&gt;有&lt;code&gt;JDBC、JNDI&lt;/code&gt;等，这些&lt;code&gt;SPI&lt;/code&gt;的接口属于&lt;code&gt;Java&lt;/code&gt;核心库，一般存在&lt;code&gt;rt.jar&lt;/code&gt;包中，由启动类加载器（&lt;code&gt;Bootstrap&lt;/code&gt;）加载，而&lt;code&gt;SPI&lt;/code&gt;的第三方实现代码则是作为&lt;code&gt;Java&lt;/code&gt;应用所依赖的&lt;code&gt;jar&lt;/code&gt;包被存放在&lt;code&gt;classpath&lt;/code&gt;路径下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于&lt;code&gt;SPI&lt;/code&gt;接口中的代码需要加载第三方实现类并调用其相关函数，但&lt;code&gt;SPI&lt;/code&gt;的核心接口类是由启动类加载器（&lt;code&gt;Bootstrap&lt;/code&gt;）加载的，&lt;code&gt;Bootstrap&lt;/code&gt;加载器无法直接加载&lt;code&gt;SPI&lt;/code&gt;的实现类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这种情况下，我们就需要一种特殊的类加载器来加载第三方的类库，它就是线程上下文类加载器，线程的上下文类加载器默认设置的就是系统类加载器（&lt;code&gt;System&lt;/code&gt;）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.549636803874092&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzynmJ9bWzU7WbaTHAUb6lKGNxzlzvtfIhiaCdkbZ3lDz3w2ZTO6URxUr0Nt6t44HGV5GEPnhnQWEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;826&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;后面的计划安排&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给各位读者们汇报下后续的安排，嗯....，不出意外的话，基本都是周更了，然后期间转载一些精品的文章，大伙们看完了，记得一键三连啊，报告完毕！&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;关于我&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里是阿星，一个热爱技术的Java程序猿，公众号  &lt;strong&gt;「程序猿阿星」&lt;/strong&gt; 里将会定期分享操作系统、计算机网络、Java、分布式、数据库等精品原创文章，2021，与您在 Be Better 的路上共同成长！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非常感谢各位小哥哥小姐姐们能看到这里，原创不易，文章有帮助可以关注、点个赞、分享与评论，都是支持（莫要白嫖）！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/23OQmC1ia8nzynmJ9bWzU7WbaTHAUb6lKvVzTH2TeVfISvjO0ULLgUOF7AGSWIbYc6wPURjbHuF2yB5DmRqyo2Q/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;240&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;愿你我都能奔赴在各自想去的路上，我们下篇文章见&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0048991b6334114dddde320226e8ca10</guid>
<title>把 Redis 当作队列来用，真的合适吗？</title>
<link>https://toutiao.io/k/3r6oq79</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;阅读本文大约需要 15 分钟。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我经常听到很多人讨论，关于「把 Redis 当作队列来用是否合适」的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些人表示赞成，他们认为 Redis 很轻量，用作队列很方便。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也些人则反对，认为 Redis 会「丢」数据，最好还是用「专业」的队列中间件更稳妥。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;究竟哪种方案更好呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章，我就和你聊一聊把 Redis 当作队列，究竟是否合适这个问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我会从简单到复杂，一步步带你梳理其中的细节，把这个问题真正的讲清楚。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看完这篇文章后，我希望你对这个问题你会有全新的认识。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在文章的最后，我还会告诉你关于「技术选型」的思路，文章有点长，希望你可以耐心读完。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4188861985472155&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gB9Yvac5K3PnYugKyFT6iaYiaXnHG02HFWmGodwpNsE4KsZ4XLRU2u9AmStUn9AIv3bHiarGSI8JtS2He3Irj5pZg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;826&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从最简单的开始：List 队列&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，我们先从最简单的场景开始讲起。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你的业务需求足够简单，想把 Redis 当作队列来使用，肯定最先想到的就是使用 List 这个数据类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为 List 底层的实现就是一个「链表」，在头部和尾部操作元素，时间复杂度都是 O(1)，这意味着它非常符合消息队列的模型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果把 List 当作队列，你可以这么来用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生产者使用 LPUSH 发布消息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; LPUSH queue msg1&lt;br/&gt;(integer) 1&lt;br/&gt;127.0.0.1:6379&amp;gt; LPUSH queue msg2&lt;br/&gt;(integer) 2&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消费者这一侧，使用 RPOP 拉取消息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; RPOP queue&lt;br/&gt;&quot;msg1&quot;&lt;br/&gt;127.0.0.1:6379&amp;gt; RPOP queue&lt;br/&gt;&quot;msg2&quot;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个模型非常简单，也很容易理解。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.29515418502202645&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3PnYugKyFT6iaYiaXnHG02HFWu8QC6wleS3iaKtD1iaHBCicxiapia7DfYWH1qzum9iaiaaf2MAxoE3dR4xicSA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;681&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这里有个小问题，当队列中已经没有消息了，消费者在执行 RPOP 时，会返回 NULL。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; RPOP queue&lt;br/&gt;(nil)   // 没消息了&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而我们在编写消费者逻辑时，一般是一个「死循环」，这个逻辑需要不断地从队列中拉取消息进行处理，伪代码一般会这么写：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;while&lt;/span&gt; true:&lt;br/&gt;    msg = redis.rpop(&lt;span&gt;&quot;queue&quot;&lt;/span&gt;)&lt;br/&gt;    // 没有消息，继续循环&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; msg == null:&lt;br/&gt;        &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;    // 处理消息&lt;br/&gt;    handle(msg)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果此时队列为空，那消费者依旧会频繁拉取消息，这会造成「CPU 空转」，不仅浪费 CPU 资源，还会对 Redis 造成压力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;怎么解决这个问题呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也很简单，当队列为空时，我们可以「休眠」一会，再去尝试拉取消息。代码可以修改成这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;while&lt;/span&gt; true:&lt;br/&gt;    msg = redis.rpop(&lt;span&gt;&quot;queue&quot;&lt;/span&gt;)&lt;br/&gt;    // 没有消息，休眠&lt;span&gt;2&lt;/span&gt;s&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; msg == null:&lt;br/&gt;        sleep(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;    // 处理消息        &lt;br/&gt;    handle(msg)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就解决了 CPU 空转问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题虽然解决了，但又带来另外一个问题：当消费者在休眠等待时，有新消息来了，那消费者处理新消息就会存在「延迟」。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设设置的休眠时间是 2s，那新消息最多存在 2s 的延迟。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要想缩短这个延迟，只能减小休眠的时间。但休眠时间越小，又有可能引发 CPU 空转问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;鱼和熊掌不可兼得。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那如何做，既能及时处理新消息，还能避免 CPU 空转呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 是否存在这样一种机制：如果队列为空，消费者在拉取消息时就「阻塞等待」，一旦有新消息过来，就通知我的消费者立即处理新消息呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;幸运的是，Redis 确实提供了「阻塞式」拉取消息的命令：BRPOP / BLPOP，这里的 B 指的是阻塞（Block）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.23641703377386197&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3PnYugKyFT6iaYiaXnHG02HFWptBP43IUaOX9WHSibbIDMj4IIntO47FnUOCz94RQl6icCiaXlEaicxq7DQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;681&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在，你可以这样来拉取消息了：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;while&lt;/span&gt; true:&lt;br/&gt;    // 没消息阻塞等待，&lt;span&gt;0&lt;/span&gt;表示不设置超时时间&lt;br/&gt;    msg = redis.brpop(&lt;span&gt;&quot;queue&quot;&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; msg == null:&lt;br/&gt;        &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;    // 处理消息&lt;br/&gt;    handle(msg)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 BRPOP 这种阻塞式方式拉取消息时，还支持传入一个「超时时间」，如果设置为 0，则表示不设置超时，直到有新消息才返回，否则会在指定的超时时间后返回 NULL。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方案不错，既兼顾了效率，还避免了 CPU 空转问题，一举两得。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意：如果设置的超时时间太长，这个连接太久没有活跃过，可能会被 Redis Server 判定为无效连接，之后 Redis Server 会强制把这个客户端踢下线。所以，采用这种方案，客户端要有重连机制。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解决了消息处理不及时的问题，你可以再思考一下，这种队列模型，有什么缺点？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们一起来分析一下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;不支持重复消费&lt;/strong&gt;：消费者拉取消息后，这条消息就从 List 中删除了，无法被其它消费者再次消费，即不支持多个消费者消费同一批数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;消息丢失&lt;/strong&gt;：消费者拉取到消息后，如果发生异常宕机，那这条消息就丢失了&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一个问题是功能上的，使用 List 做消息队列，它仅仅支持最简单的，一组生产者对应一组消费者，不能满足多组生产者和消费者的业务场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二个问题就比较棘手了，因为从 List 中 POP 一条消息出来后，这条消息就会立即从链表中删除了。也就是说，无论消费者是否处理成功，这条消息都没办法再次消费了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也意味着，如果消费者在处理消息时异常宕机，那这条消息就相当于丢失了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对这 2 个问题怎么解决呢？我们一个个来看。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;发布/订阅模型：Pub/Sub&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从名字就能看出来，这个模块是 Redis 专门是针对「发布/订阅」这种队列模型设计的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它正好可以解决前面提到的第一个问题：重复消费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即多组生产者、消费者的场景，我们来看它是如何做的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 提供了 PUBLISH / SUBSCRIBE 命令，来完成发布、订阅的操作。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.40360610263522884&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3PnYugKyFT6iaYiaXnHG02HFWcVxxQr6pxO6UfDwAFgwicPNMFXicEOvBokFAsGbEMXUibzZNUAedQSnow/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;721&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设你想开启 2 个消费者，同时消费同一批数据，就可以按照以下方式来实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，使用 SUBSCRIBE 命令，启动 2 个消费者，并「订阅」同一个队列。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;// 2个消费者 都订阅一个队列&lt;br/&gt;127.0.0.1:6379&amp;gt; SUBSCRIBE queue&lt;br/&gt;Reading messages... (press Ctrl-C to quit)&lt;br/&gt;1) &quot;subscribe&quot;&lt;br/&gt;2) &quot;queue&quot;&lt;br/&gt;3) (integer) 1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，2 个消费者都会被阻塞住，等待新消息的到来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后，再启动一个生产者，发布一条消息。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; PUBLISH queue msg1&lt;br/&gt;(integer) 1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时，2 个消费者就会解除阻塞，收到生产者发来的新消息。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; SUBSCRIBE queue&lt;br/&gt;// 收到新消息&lt;br/&gt;1) &quot;message&quot;&lt;br/&gt;2) &quot;queue&quot;&lt;br/&gt;3) &quot;msg1&quot;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到了么，使用 Pub/Sub 这种方案，既支持阻塞式拉取消息，还很好地满足了多组消费者，消费同一批数据的业务需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，Pub/Sub 还提供了「匹配订阅」模式，允许消费者根据一定规则，订阅「多个」自己感兴趣的队列。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;// 订阅符合规则的队列&lt;br/&gt;127.0.0.1:6379&amp;gt; PSUBSCRIBE queue.*&lt;br/&gt;Reading messages... (press Ctrl-C to quit)&lt;br/&gt;1) &quot;psubscribe&quot;&lt;br/&gt;2) &quot;queue.*&quot;&lt;br/&gt;3) (integer) 1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的消费者，订阅了 queue.* 相关的队列消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后，生产者分别向 queue.p1 和 queue.p2 发布消息。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; PUBLISH queue.p1 msg1&lt;br/&gt;(integer) 1&lt;br/&gt;127.0.0.1:6379&amp;gt; PUBLISH queue.p2 msg2&lt;br/&gt;(integer) 1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时再看消费者，它就可以接收到这 2 个生产者的消息了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; PSUBSCRIBE queue.*&lt;br/&gt;Reading messages... (press Ctrl-C to quit)&lt;br/&gt;...&lt;br/&gt;// 来自queue.p1的消息&lt;br/&gt;1) &quot;pmessage&quot;&lt;br/&gt;2) &quot;queue.*&quot;&lt;br/&gt;3) &quot;queue.p1&quot;&lt;br/&gt;4) &quot;msg1&quot;&lt;br/&gt;&lt;br/&gt;// 来自queue.p2的消息&lt;br/&gt;1) &quot;pmessage&quot;&lt;br/&gt;2) &quot;queue.*&quot;&lt;br/&gt;3) &quot;queue.p2&quot;&lt;br/&gt;4) &quot;msg2&quot;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3792172739541161&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3PnYugKyFT6iaYiaXnHG02HFWEgHBBbv2VxurLPcgDd9CJnzueRPuqLS6hugowGMlKvdzsvoYIDd0ibQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;741&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以看到，Pub/Sub 最大的优势就是，支持多组生产者、消费者处理消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;讲完了它的优点，那它有什么缺点呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，Pub/Sub 最大问题是：&lt;strong&gt;丢数据&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果发生以下场景，就有可能导致数据丢失：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;消费者下线&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Redis 宕机&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息堆积&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;究竟是怎么回事？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这其实与 Pub/Sub 的实现方式有很大关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pub/Sub 在实现时非常简单，它没有基于任何数据类型，也没有做任何的数据存储，它只是单纯地为生产者、消费者建立「数据转发通道」，把符合规则的数据，从一端转发到另一端。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个完整的发布、订阅消息处理流程是这样的：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;消费者订阅指定队列，Redis 就会记录一个映射关系：队列-&amp;gt;消费者&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;生产者向这个队列发布消息，那 Redis 就从映射关系中找出对应的消费者，把消息转发给它&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.34876989869753977&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3PnYugKyFT6iaYiaXnHG02HFWmvU2w2M5re8p6Dq5uPtHa0Ws9RJ6cGZd6oRhibia9cveicrrqcu5A36LA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;691&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到了么，整个过程中，没有任何的数据存储，一切都是实时转发的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种设计方案，就导致了上面提到的那些问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，如果一个消费者异常挂掉了，它再重新上线后，只能接收新的消息，在下线期间生产者发布的消息，因为找不到消费者，都会被丢弃掉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果所有消费者都下线了，那生产者发布的消息，因为找不到任何一个消费者，也会全部「丢弃」。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，当你在使用 Pub/Sub 时，一定要注意：&lt;strong&gt;消费者必须先订阅队列，生产者才能发布消息，否则消息会丢失。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也是前面讲例子时，我们让消费者先订阅队列，之后才让生产者发布消息的原因。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，因为 Pub/Sub 没有基于任何数据类型实现，所以它也不具备「数据持久化」的能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，Pub/Sub 的相关操作，不会写入到 RDB 和 AOF 中，当 Redis 宕机重启，Pub/Sub 的数据也会全部丢失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，我们来看 Pub/Sub 在处理「消息积压」时，为什么也会丢数据？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当消费者的速度，跟不上生产者时，就会导致数据积压的情况发生。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果采用 List 当作队列，消息积压时，会导致这个链表很长，最直接的影响就是，Redis 内存会持续增长，直到消费者把所有数据都从链表中取出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但 Pub/Sub 的处理方式却不一样，当消息积压时，有可能会导致&lt;strong&gt;消费失败和消息丢失&lt;/strong&gt;！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是怎么回事？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是回到 Pub/Sub 的实现细节上来说。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个消费者订阅一个队列时，Redis 都会在 Server 上给这个消费者在分配一个「缓冲区」，这个缓冲区其实就是一块内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当生产者发布消息时，Redis 先把消息写到对应消费者的缓冲区中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后，消费者不断地从缓冲区读取消息，处理消息。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.34876989869753977&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3PnYugKyFT6iaYiaXnHG02HFW6z62WCJjDASE4WaQ2Th4CkMnZlshf59DiakB84vTnHDkG24xmPGsPuw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;691&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，问题就出在这个缓冲区上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为这个缓冲区其实是有「上限」的（可配置），如果消费者拉取消息很慢，就会造成生产者发布到缓冲区的消息开始积压，缓冲区内存持续增长。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果超过了缓冲区配置的上限，此时，Redis 就会「强制」把这个消费者踢下线。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时消费者就会消费失败，也会丢失数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你有看过 Redis 的配置文件，可以看到这个缓冲区的默认配置：client-output-buffer-limit pubsub 32mb 8mb 60。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的参数含义如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;32mb：缓冲区一旦超过 32MB，Redis 直接强制把消费者踢下线&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;8mb + 60：缓冲区超过 8MB，并且持续 60 秒，Redis 也会把消费者踢下线&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pub/Sub 的这一点特点，是与 List 作队列差异比较大的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从这里你应该可以看出，&lt;strong&gt;List 其实是属于「拉」模型，而 Pub/Sub 其实属于「推」模型&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;List 中的数据可以一直积压在内存中，消费者什么时候来「拉」都可以。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但 Pub/Sub 是把消息先「推」到消费者在 Redis Server 上的缓冲区中，然后等消费者再来取。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当生产、消费速度不匹配时，就会导致缓冲区的内存开始膨胀，Redis 为了控制缓冲区的上限，所以就有了上面讲到的，强制把消费者踢下线的机制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，现在我们总结一下 Pub/Sub 的优缺点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;支持发布 / 订阅，支持多组生产者、消费者处理消息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消费者下线，数据会丢失&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不支持数据持久化，Redis 宕机，数据也会丢失&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息堆积，缓冲区溢出，消费者会被强制踢下线，数据也会丢失&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有没有发现，除了第一个是优点之外，剩下的都是缺点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，很多人看到 Pub/Sub 的特点后，觉得这个功能很「鸡肋」。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也正是以上原因，Pub/Sub 在实际的应用场景中用得并不多。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;目前只有哨兵集群和 Redis 实例通信时，采用了 Pub/Sub 的方案，因为哨兵正好符合即时通讯的业务场景。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再来看一下，Pub/Sub 有没有解决，消息处理时异常宕机，无法再次消费的问题呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实也不行，Pub/Sub 从缓冲区取走数据之后，数据就从 Redis 缓冲区删除了，消费者发生异常，自然也无法再次重新消费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好，现在我们重新梳理一下，我们在使用消息队列时的需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们在使用一个消息队列时，希望它的功能如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;支持阻塞等待拉取消息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持发布 / 订阅模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消费失败，可重新消费，消息不丢失&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实例宕机，消息不丢失，数据可持久化&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息可堆积&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 除了 List 和 Pub/Sub 之外，还有符合这些要求的数据类型吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，Redis 的作者也看到了以上这些问题，也一直在朝着这些方向努力着。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 作者在开发 Redis 期间，还另外开发了一个开源项目 disque。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个项目的定位，就是一个基于内存的分布式消息队列中间件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但由于种种原因，这个项目一直不温不火。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;终于，在 Redis 5.0 版本，作者把 disque 功能移植到了 Redis 中，并给它定义了一个新的数据类型：&lt;strong&gt;Stream&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们就来看看，它能符合上面提到的这些要求吗？&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;趋于成熟的队列：Stream&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看 Stream 是如何解决上面这些问题的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们依旧从简单到复杂，依次来看 Stream 在做消息队列时，是如何处理的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，Stream 通过 XADD 和 XREAD 完成最简单的生产、消费模型：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生产者发布 2 条消息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;// *表示让Redis自动生成消息ID&lt;br/&gt;127.0.0.1:6379&amp;gt; XADD queue * name zhangsan&lt;br/&gt;&quot;1618469123380-0&quot;&lt;br/&gt;127.0.0.1:6379&amp;gt; XADD queue * name lisi&lt;br/&gt;&quot;1618469127777-0&quot;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 XADD 命令发布消息，其中的「*」表示让 Redis 自动生成唯一的消息 ID。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个消息 ID 的格式是「时间戳-自增序号」。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消费者拉取消息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;// 从开头读取5条消息，0-0表示从开头读取&lt;br/&gt;127.0.0.1:6379&amp;gt; XREAD COUNT 5 STREAMS queue 0-0&lt;br/&gt;1) 1) &quot;queue&quot;&lt;br/&gt;   2) 1) 1) &quot;1618469123380-0&quot;&lt;br/&gt;         2) 1) &quot;name&quot;&lt;br/&gt;            2) &quot;zhangsan&quot;&lt;br/&gt;      2) 1) &quot;1618469127777-0&quot;&lt;br/&gt;         2) 1) &quot;name&quot;&lt;br/&gt;            2) &quot;lisi&quot;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想继续拉取消息，需要传入上一条消息的 ID：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; XREAD COUNT 5 STREAMS queue 1618469127777-0&lt;br/&gt;(nil)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没有消息，Redis 会返回 NULL。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.23641703377386197&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3PnYugKyFT6iaYiaXnHG02HFWTGjnYoFly2IbkMAqaicicVhtgFsPlBW9kibBzmbFJDHVzDRWFbmgSTd7A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;681&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是 Stream 最简单的生产、消费。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里不再重点介绍 Stream 命令的各种参数，我在例子中演示时，凡是大写的单词都是「固定」参数，凡是小写的单词，都是可以自己定义的，例如队列名、消息长度等等，下面的例子规则也是一样，为了方便你理解，这里有必要提醒一下。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看，针对前面提到的消息队列要求，Stream 都是如何解决的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;1) Stream 是否支持「阻塞式」拉取消息？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以的，在读取消息时，只需要增加 BLOCK 参数即可。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;// BLOCK 0 表示阻塞等待，不设置超时时间&lt;br/&gt;127.0.0.1:6379&amp;gt; XREAD COUNT 5 BLOCK 0 STREAMS queue 1618469127777-0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时，消费者就会阻塞等待，直到生产者发布新的消息才会返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;2) Stream 是否支持发布 / 订阅模式？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也没问题，Stream 通过以下命令完成发布订阅：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;XGROUP：创建消费者组&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;XREADGROUP：在指定消费组下，开启消费者拉取消息&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看具体如何做？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，生产者依旧发布 2 条消息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; XADD queue * name zhangsan&lt;br/&gt;&quot;1618470740565-0&quot;&lt;br/&gt;127.0.0.1:6379&amp;gt; XADD queue * name lisi&lt;br/&gt;&quot;1618470743793-0&quot;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后，我们想要开启 2 组消费者处理同一批数据，就需要创建 2 个消费者组：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;// 创建消费者组1，0-0表示从头拉取消息&lt;br/&gt;127.0.0.1:6379&amp;gt; XGROUP CREATE queue group1 0-0&lt;br/&gt;OK&lt;br/&gt;// 创建消费者组2，0-0表示从头拉取消息&lt;br/&gt;127.0.0.1:6379&amp;gt; XGROUP CREATE queue group2 0-0&lt;br/&gt;OK&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消费者组创建好之后，我们可以给每个「消费者组」下面挂一个「消费者」，让它们分别处理同一批数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一个消费组开始消费：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;// group1的consumer开始消费，&amp;gt;表示拉取最新数据&lt;br/&gt;127.0.0.1:6379&amp;gt; XREADGROUP GROUP group1 consumer COUNT 5 STREAMS queue &amp;gt;&lt;br/&gt;1) 1) &quot;queue&quot;&lt;br/&gt;   2) 1) 1) &quot;1618470740565-0&quot;&lt;br/&gt;         2) 1) &quot;name&quot;&lt;br/&gt;            2) &quot;zhangsan&quot;&lt;br/&gt;      2) 1) &quot;1618470743793-0&quot;&lt;br/&gt;         2) 1) &quot;name&quot;&lt;br/&gt;            2) &quot;lisi&quot;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样地，第二个消费组开始消费：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;// group2的consumer开始消费，&amp;gt;表示拉取最新数据&lt;br/&gt;127.0.0.1:6379&amp;gt; XREADGROUP GROUP group2 consumer COUNT 5 STREAMS queue &amp;gt;&lt;br/&gt;1) 1) &quot;queue&quot;&lt;br/&gt;   2) 1) 1) &quot;1618470740565-0&quot;&lt;br/&gt;         2) 1) &quot;name&quot;&lt;br/&gt;            2) &quot;zhangsan&quot;&lt;br/&gt;      2) 1) &quot;1618470743793-0&quot;&lt;br/&gt;         2) 1) &quot;name&quot;&lt;br/&gt;            2) &quot;lisi&quot;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以看到，这 2 组消费者，都可以获取同一批数据进行处理了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样一来，就达到了多组消费者「订阅」消费的目的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4008559201141227&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3PnYugKyFT6iaYiaXnHG02HFWeoaD3ZnP3xHV4tazwd7AZvom0Cyjf5ZoibEBhnjlpKETib9ypLrhoyIg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;701&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;3) 消息处理时异常，Stream 能否保证消息不丢失，重新消费？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了上面拉取消息时用到了消息 ID，这里为了保证重新消费，也要用到这个消息 ID。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一组消费者处理完消息后，需要执行 XACK 命令告知 Redis，这时 Redis 就会把这条消息标记为「处理完成」。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;// group1下的 1618472043089-0 消息已处理完成&lt;br/&gt;127.0.0.1:6379&amp;gt; XACK queue group1 1618472043089-0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.42368045649072755&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3PnYugKyFT6iaYiaXnHG02HFWnqicNAVrYEghyoiaZqwtSlphRJ5FX3lhPGYr6XANByxxk1PwfuW2k3jQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;701&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果消费者异常宕机，肯定不会发送 XACK，那么 Redis 就会依旧保留这条消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;待这组消费者重新上线后，Redis 就会把之前没有处理成功的数据，重新发给这个消费者。这样一来，即使消费者异常，也不会丢失数据了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;// 消费者重新上线，0-0表示重新拉取未ACK的消息&lt;br/&gt;127.0.0.1:6379&amp;gt; XREADGROUP GROUP group1 consumer1 COUNT 5 STREAMS queue 0-0&lt;br/&gt;// 之前没消费成功的数据，依旧可以重新消费&lt;br/&gt;1) 1) &quot;queue&quot;&lt;br/&gt;   2) 1) 1) &quot;1618472043089-0&quot;&lt;br/&gt;         2) 1) &quot;name&quot;&lt;br/&gt;            2) &quot;zhangsan&quot;&lt;br/&gt;      2) 1) &quot;1618472045158-0&quot;&lt;br/&gt;         2) 1) &quot;name&quot;&lt;br/&gt;            2) &quot;lisi&quot;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;4) Stream 数据会写入到 RDB 和 AOF 做持久化吗？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Stream 是新增加的数据类型，它与其它数据类型一样，每个写操作，也都会写入到 RDB 和 AOF 中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们只需要配置好持久化策略，这样的话，就算 Redis 宕机重启，Stream 中的数据也可以从 RDB 或 AOF 中恢复回来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;5) 消息堆积时，Stream 是怎么处理的？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，当消息队列发生消息堆积时，一般只有 2 个解决方案：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;生产者限流：避免消费者处理不及时，导致持续积压&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;丢弃消息：中间件丢弃旧消息，只保留固定长度的新消息&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而 Redis 在实现 Stream 时，采用了第 2 个方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在发布消息时，你可以指定队列的最大长度，防止队列积压导致内存爆炸。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;// 队列长度最大10000&lt;br/&gt;127.0.0.1:6379&amp;gt; XADD queue MAXLEN 10000 * name zhangsan&lt;br/&gt;&quot;1618473015018-0&quot;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当队列长度超过上限后，旧消息会被删除，只保留固定长度的新消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这么来看，Stream 在消息积压时，如果指定了最大长度，还是有可能丢失消息的。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;除了以上介绍到的命令，Stream 还支持查看消息长度（XLEN）、查看消费者状态（XINFO）等命令，使用也比较简单，你可以查询官方文档了解一下，这里就不过多介绍了。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，通过以上介绍，我们可以看到，Redis 的 Stream 几乎覆盖到了消息队列的各种场景，是不是觉得很完美？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;既然它的功能这么强大，这是不是意味着，Redis 真的可以作为专业的消息队列中间件来使用呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是还「差一点」，就算 Redis 能做到以上这些，也只是「趋近于」专业的消息队列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原因在于 Redis 本身的一些问题，如果把其定位成消息队列，还是有些欠缺的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里，就不得不把 Redis 与专业的队列中间件做对比了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们就来看一下，Redis 在作队列时，到底还有哪些欠缺？&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;与专业的消息队列对比&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，一个专业的消息队列，必须要做到两大块：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;消息不丢&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息可堆积&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面我们讨论的重点，很大篇幅围绕的是第一点展开的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们换个角度，从一个消息队列的「使用模型」来分析一下，怎么做，才能保证数据不丢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用一个消息队列，其实就分为三大块：&lt;strong&gt;生产者、队列中间件、消费者&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.26265389876880985&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3PnYugKyFT6iaYiaXnHG02HFWcMh2Wso6LtJIzqfk87O0LwLsyOgGvBwJKiamJjrwALKUE47dqhBicdKw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;731&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息是否会发生丢失，其重点也就在于以下 3 个环节：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;生产者会不会丢消息？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消费者会不会丢消息？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;队列中间件会不会丢消息？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;1) 生产者会不会丢消息？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当生产者在发布消息时，可能发生以下异常情况：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;消息没发出去：网络故障或其它问题导致发布失败，中间件直接返回失败&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不确定是否发布成功：网络问题导致发布超时，可能数据已发送成功，但读取响应结果超时了&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是情况 1，消息根本没发出去，那么重新发一次就好了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是情况 2，生产者没办法知道消息到底有没有发成功？所以，为了避免消息丢失，它也只能继续重试，直到发布成功为止。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;生产者一般会设定一个最大重试次数，超过上限依旧失败，需要记录日志报警处理。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，生产者为了避免消息丢失，只能采用失败重试的方式来处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但发现没有？这也意味着消息可能会重复发送。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是的，在使用消息队列时，要保证消息不丢，宁可重发，也不能丢弃。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那消费者这边，就需要多做一些逻辑了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于敏感业务，当消费者收到重复数据数据时，要设计幂等逻辑，保证业务的正确性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从这个角度来看，生产者会不会丢消息，取决于生产者对于异常情况的处理是否合理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，无论是 Redis 还是专业的队列中间件，生产者在这一点上都是可以保证消息不丢的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;2) 消费者会不会丢消息？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种情况就是我们前面提到的，消费者拿到消息后，还没处理完成，就异常宕机了，那消费者还能否重新消费失败的消息？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要解决这个问题，消费者在处理完消息后，必须「告知」队列中间件，队列中间件才会把标记已处理，否则仍旧把这些数据发给消费者。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方案需要消费者和中间件互相配合，才能保证消费者这一侧的消息不丢。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论是 Redis 的 Stream，还是专业的队列中间件，例如 RabbitMQ、Kafka，其实都是这么做的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，从这个角度来看，Redis 也是合格的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;3) 队列中间件会不会丢消息？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面 2 个问题都比较好处理，只要客户端和服务端配合好，就能保证生产端、消费端都不丢消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，如果队列中间件本身就不可靠呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;毕竟生产者和消费者都依赖它，如果它不可靠，那么生产者和消费者无论怎么做，都无法保证数据不丢。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个方面，Redis 其实没有达到要求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 在以下 2 个场景下，都会导致数据丢失。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;AOF 持久化配置为每秒写盘，但这个写盘过程是异步的，Redis 宕机时会存在数据丢失的可能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主从复制也是异步的，主从切换时，也存在丢失数据的可能（从库还未同步完成主库发来的数据，就被提成主库）&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于以上原因我们可以看到，&lt;strong&gt;Redis 本身的无法保证严格的数据完整性&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，如果把 Redis 当做消息队列，在这方面是有可能导致数据丢失的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再来看那些专业的消息队列中间件是如何解决这个问题的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像 RabbitMQ 或 Kafka 这类专业的队列中间件，在使用时，一般是部署一个集群，生产者在发布消息时，队列中间件通常会写「多个节点」，以此保证消息的完整性。这样一来，即便其中一个节点挂了，也能保证集群的数据不丢失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也正因为如此，RabbitMQ、Kafka在设计时也更复杂。毕竟，它们是专门针对队列场景设计的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但 Redis 的定位则不同，它的定位更多是当作缓存来用，它们两者在这个方面肯定是存在差异的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，我们来看消息积压怎么办？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;4) 消息积压怎么办？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为 Redis 的数据都存储在内存中，这就意味着一旦发生消息积压，则会导致 Redis 的内存持续增长，如果超过机器内存上限，就会面临被 OOM 的风险。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，Redis 的 Stream 提供了可以指定队列最大长度的功能，就是为了避免这种情况发生。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但 Kafka、RabbitMQ 这类消息队列就不一样了，它们的数据都会存储在磁盘上，磁盘的成本要比内存小得多，当消息积压时，无非就是多占用一些磁盘空间，相比于内存，在面对积压时也会更加「坦然」。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;综上，我们可以看到，把 Redis 当作队列来使用时，始终面临的 2 个问题：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Redis 本身可能会丢数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;面对消息积压，Redis 内存资源紧张&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里，Redis 是否可以用作队列，我想这个答案你应该会比较清晰了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你的业务场景足够简单，对于数据丢失不敏感，而且消息积压概率比较小的情况下，把 Redis 当作队列是完全可以的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且，Redis 相比于 Kafka、RabbitMQ，部署和运维也更加轻量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你的业务场景对于数据丢失非常敏感，而且写入量非常大，消息积压时会占用很多的机器资源，那么我建议你使用专业的消息队列中间件。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，总结一下。这篇文章我们从「Redis 能否用作队列」这个角度出发，介绍了 List、Pub/Sub、Stream 在做队列的使用方式，以及它们各自的优劣。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后又把 Redis 和专业的消息队列中间件做对比，发现 Redis 的不足之处。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，我们得出 Redis 做队列的合适场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我也列了一个表格，总结了它们各自的优缺点。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.48043184885290147&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3PnYugKyFT6iaYiaXnHG02HFWjjanXypYOraDsDSBTYkXHXLD2gribiamm2GYvPmciaia3ziaN8ZeU0cEdibA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;741&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;后记&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，我想和你再聊一聊关于「&lt;strong&gt;技术方案选型&lt;/strong&gt;」的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你应该也看到了，这篇文章虽然始于 Redis，但并不止于 Redis。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在分析 Redis 细节时，一直在提出问题，然后寻找更好的解决方案，在文章最后，又聊到一个专业的消息队列应该怎么做。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，我们在讨论技术选型时，就是一个关于如何取舍的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而这里我想传达给你的信息是，&lt;strong&gt;在面对技术选型时，不要不经过思考就觉得哪个方案好，哪个方案不好&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你需要根据具体场景具体分析，这里我把这个分析过程分为 2 个层面：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;业务功能角度&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;技术资源角度&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章所讲到的内容，都是以业务功能角度出发做决策的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这里的第二点，从技术资源角度出发，其实也很重要。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;技术资源的角度是说，&lt;strong&gt;你所处的公司环境、技术资源能否匹配这些技术方案&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个怎么解释呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单来讲，就是你所在的公司、团队，是否有匹配的资源能 hold 住这些技术方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道 Kafka、RabbitMQ 是非常专业的消息中间件，但它们的部署和运维，相比于 Redis 来说，也会更复杂一些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你在一个大公司，公司本身就有优秀的运维团队，那么使用这些中间件肯定没问题，因为有足够优秀的人能 hold 住这些中间件，公司也会投入人力和时间在这个方向上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果你是在一个初创公司，业务正处在快速发展期，暂时没有能 hold 住这些中间件的团队和人，如果贸然使用这些组件，当发生故障时，排查问题也会变得很困难，甚至会阻碍业务的发展。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而这种情形下，如果公司的技术人员对于 Redis 都很熟，综合评估来看，Redis 也基本可以满足业务 90% 的需求，那当下选择 Redis 未必不是一个好的决策。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，&lt;strong&gt;做技术选型不只是技术问题，还与人、团队、管理、组织结构有关&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也正是因为这些原因，当你在和别人讨论技术选型问题时，你会发现每个公司的做法都不相同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;毕竟每个公司所处的环境和文化不一样，做出的决策当然就会各有差异。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你不了解这其中的逻辑，那在做技术选型时，只会趋于表面现象，无法深入到问题根源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而一旦你理解了这个逻辑，那么你在看待这个问题时，不仅对于技术会有更加深刻认识，对技术资源和人的把握，也会更加清晰。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;希望你以后在做技术选型时，能够把这些因素也考虑在内，这对你的技术成长之路也是非常有帮助的。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0c8b8955347ca98590bd58fb3e4a504a</guid>
<title>Nginx 最全操作总结</title>
<link>https://toutiao.io/k/0lvuhj9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：chrootliu，腾讯 QQ 音乐前端开发工程师&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;本文将会从：安装 -&amp;gt; 全局配置 -&amp;gt; 常用的各种配置 来书写，其中常用配置写的炒鸡详细，需要的童鞋可以直接滑倒相应的位置查看。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;安装 nginx&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;下载 nginx 的压缩包文件到根目录，官网下载地址：nginx.org/download/nginx-x.xx.xx.tar.gz&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;yum update &lt;span&gt;#更新系统软件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;cd&lt;/span&gt; /&lt;br/&gt;wget nginx.org/download/nginx-1.17.2.tar.gz&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;解压 tar.gz 压缩包文件，进去 nginx-1.17.2&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;tar -xzvf nginx-1.17.2.tar.gz&lt;br/&gt;&lt;span&gt;cd&lt;/span&gt; nginx-1.17.2&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;进入文件夹后进行配置检查&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;./configure&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;通过安装前的配置检查，发现有报错。检查中发现一些依赖库没有找到，这时候需要先安装 nginx 的一些依赖库&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;yum -y install pcre* &lt;span&gt;#安装使nginx支持rewrite&lt;/span&gt;&lt;br/&gt;yum -y install gcc-c++&lt;br/&gt;yum -y install zlib*&lt;br/&gt;yum -y install openssl openssl-devel&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;再次进行检查操作 ./configure 没发现报错显示，接下来进行编译并安装的操作&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; // 检查模块支持&lt;br/&gt;  ./configure  --prefix=/usr/&lt;span&gt;local&lt;/span&gt;/nginx  --with-http_ssl_module --with-http_v2_module --with-http_realip_module --with-http_addition_module --with-http_sub_module --with-http_dav_module --with-http_flv_module --with-http_mp4_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_auth_request_module --with-http_random_index_module --with-http_secure_link_module --with-http_degradation_module --with-http_slice_module --with-http_stub_status_module --with-mail --with-mail_ssl_module --with-stream --with-stream_ssl_module --with-stream_realip_module --with-stream_ssl_preread_module --with-threads --user=www --group=www&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里得特别注意下，你以后需要用到的功能模块是否存在，不然以后添加新的包会比较麻烦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;查看默认安装的模块支持&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;命令 &lt;code&gt;ls nginx-1.17.2&lt;/code&gt; 查看 nginx 的文件列表，可以发现里面有一个 auto 的目录。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个 auto 目录中有一个 options 文件，这个文件里面保存的就是 nginx 编译过程中的所有选项配置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过命令：&lt;code&gt;cat nginx-1.17.2/auto/options | grep YES&lt;/code&gt;就可以查看&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://jingyan.baidu.com/article/454316ab354edcf7a7c03a81.html&quot; data-linktype=&quot;2&quot;&gt;nginx 编译安装时，怎么查看安装模块&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;编译并安装&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;make &amp;amp;&amp;amp; make install&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里需要注意，模块的支持跟后续的 nginx 配置有关，比如 SSL，gzip 压缩等等，编译安装前最好检查需要配置的模块存不存在。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;查看 nginx 安装后在的目录，可以看到已经安装到 /usr/local/nginx 目录了&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;whereis nginx&lt;br/&gt;&lt;span&gt;$nginx&lt;/span&gt;: /usr/&lt;span&gt;local&lt;/span&gt;/nginx&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;启动 nginx 服务&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;cd&lt;/span&gt; /usr/&lt;span&gt;local&lt;/span&gt;/nginx/sbin/&lt;br/&gt;./nginx&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务启动的时候报错了：&lt;code&gt;nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)&lt;/code&gt; ，通过命令查看本机网络地址和端口等一些信息，找到被占用的 80 端口 &lt;code&gt;netstat -ntpl&lt;/code&gt; 的 tcp 连接，并杀死进程(kill 进程 pid)&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;netstat -ntpl&lt;br/&gt;&lt;span&gt;kill&lt;/span&gt; 进程PID&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;继续启动 nginx 服务，启动成功&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;./nginx&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在浏览器直接访问 ip 地址，页面出现 Welcome to Nginx! 则安装成功。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;nginx 配置&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;基本结构&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;main        # 全局配置，对全局生效&lt;br/&gt;├── events  # 配置影响 nginx 服务器或与用户的网络连接&lt;br/&gt;├── http    # 配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置&lt;br/&gt;│   ├── upstream # 配置后端服务器具体地址，负载均衡配置不可或缺的部分&lt;br/&gt;│   ├── server   # 配置虚拟主机的相关参数，一个 http 块中可以有多个 server 块&lt;br/&gt;│   ├── server&lt;br/&gt;│   │   ├── location  # server 块可以包含多个 location 块，location 指令用于匹配 uri&lt;br/&gt;│   │   ├── location&lt;br/&gt;│   │   └── ...&lt;br/&gt;│   └── ...&lt;br/&gt;└── ...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;主要配置含义&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;main:nginx 的全局配置，对全局生效。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;events:配置影响 nginx 服务器或与用户的网络连接。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;http：可以嵌套多个 server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;server：配置虚拟主机的相关参数，一个 http 中可以有多个 server。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;location：配置请求的路由，以及各种页面的处理情况。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;upstream：配置后端服务器具体地址，负载均衡配置不可或缺的部分。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;nginx.conf 配置文件的语法规则&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;配置文件由指令与指令块构成&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每条指令以 “;” 分号结尾，指令与参数间以空格符号分隔&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;指令块以 {} 大括号将多条指令组织在一起&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;include 语句允许组合多个配置文件以提升可维护性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过 # 符号添加注释，提高可读性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过 $ 符号使用变量&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;部分指令的参数支持正则表达式，例如常用的 location 指令&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;内置变量&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;nginx 常用的内置全局变量，你可以在配置中随意使用：&lt;img data-ratio=&quot;0.6285362853628537&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauLdHRFreUAZ7U9Bz4XsHwXCXwgNAhHxPKRibPGxTxtaMqNjeOaot8jEqwDYjyGD5VojZLYIApEMEw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1626&quot;/&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;常用命令&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里列举几个常用的命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;nginx -s reload  # 向主进程发送信号，重新加载配置文件，热重启&lt;br/&gt;nginx -s reopen  # 重启 Nginx&lt;br/&gt;nginx -s stop    # 快速关闭&lt;br/&gt;nginx -s quit    # 等待工作进程处理完成后关闭&lt;br/&gt;nginx -T         # 查看当前 Nginx 最终的配置&lt;br/&gt;nginx -t -c &amp;lt;配置路径&amp;gt;  # 检查配置是否有问题，如果已经在配置目录，则不需要 -c&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上命令通过 &lt;code&gt;nginx -h&lt;/code&gt; 就可以查看到，还有其它不常用这里未列出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Linux 系统应用管理工具 systemd 关于 nginx 的常用命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;systemctl start nginx    # 启动 Nginx&lt;br/&gt;systemctl stop nginx     # 停止 Nginx&lt;br/&gt;systemctl restart nginx  # 重启 Nginx&lt;br/&gt;systemctl reload nginx   # 重新加载 Nginx，用于修改配置后&lt;br/&gt;systemctl enable nginx   # 设置开机启动 Nginx&lt;br/&gt;systemctl disable nginx  # 关闭开机启动 Nginx&lt;br/&gt;systemctl status nginx   # 查看 Nginx 运行状态&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;配置 nginx 开机自启&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;利用 systemctl 命令&lt;/strong&gt;：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果用 yum install 命令安装的 nginx，yum 命令会自动创建 nginx.service 文件，直接用命令:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;systemctl &lt;span&gt;enable&lt;/span&gt; nginx   &lt;span&gt;# 设置开机启动 Nginx&lt;/span&gt;&lt;br/&gt;systemctl &lt;span&gt;disable&lt;/span&gt; nginx  &lt;span&gt;# 关闭开机启动 Nginx&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就可以设置开机自启，否则需要在系统服务目录里创建 nginx.service 文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建并打开 nginx.service 文件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;vi /lib/systemd/system/nginx.service&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内容如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[Unit]&lt;br/&gt;Description=nginx&lt;br/&gt;After=network.target&lt;br/&gt;&lt;br/&gt;[Service]&lt;br/&gt;Type=forking&lt;br/&gt;ExecStart=/usr/local/nginx/sbin/nginx&lt;br/&gt;ExecReload=/usr/local/nginx/sbin/nginx -s reload&lt;br/&gt;ExecStop=/usr/local/nginx/sbin/nginx -s quit&lt;br/&gt;PrivateTmp=true&lt;br/&gt;&lt;br/&gt;[Install]&lt;br/&gt;WantedBy=multi-user.target&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;:wq&lt;/code&gt; 保存退出，运行 &lt;code&gt;systemctl daemon-reload&lt;/code&gt; 使文件生效。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样便可以通过以下命令操作 nginx 了：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;systemctl start nginx.service # 启动nginx服务&lt;br/&gt;systemctl enable nginx.service # 设置开机启动&lt;br/&gt;systemctl disable nginx.service # 停止开机自启动&lt;br/&gt;systemctl status nginx.service # 查看服务当前状态&lt;br/&gt;systemctl restart nginx.service # 重新启动服务&lt;br/&gt;systemctl is-enabled nginx.service #查询服务是否开机启动&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;通过开机启动命令脚本实现开机自启&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建开机启动命令脚本文件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;vi /etc/init.d/nginx&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个 nginx 文件中插入一下启动脚本代码，启动脚本代码来源网络复制，实测有效：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#! /bin/bash&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# chkconfig: - 85 15&lt;/span&gt;&lt;br/&gt;PATH=/usr/&lt;span&gt;local&lt;/span&gt;/nginx&lt;br/&gt;DESC=&lt;span&gt;&quot;nginx daemon&quot;&lt;/span&gt;&lt;br/&gt;NAME=nginx&lt;br/&gt;DAEMON=&lt;span&gt;$PATH&lt;/span&gt;/sbin/&lt;span&gt;$NAME&lt;/span&gt;&lt;br/&gt;CONFIGFILE=&lt;span&gt;$PATH&lt;/span&gt;/conf/&lt;span&gt;$NAME&lt;/span&gt;.conf&lt;br/&gt;PIDFILE=&lt;span&gt;$PATH&lt;/span&gt;/logs/&lt;span&gt;$NAME&lt;/span&gt;.pid&lt;br/&gt;scriptNAME=/etc/init.d/&lt;span&gt;$NAME&lt;/span&gt;&lt;br/&gt;&lt;span&gt;set&lt;/span&gt; -e&lt;br/&gt;[ -x &lt;span&gt;&quot;&lt;span&gt;$DAEMON&lt;/span&gt;&quot;&lt;/span&gt; ] || &lt;span&gt;exit&lt;/span&gt; 0&lt;br/&gt;&lt;span&gt;&lt;span&gt;do_start&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;&lt;span&gt;$DAEMON&lt;/span&gt; -c &lt;span&gt;$CONFIGFILE&lt;/span&gt; || &lt;span&gt;echo&lt;/span&gt; -n &lt;span&gt;&quot;nginx already running&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;do_stop&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;&lt;span&gt;$DAEMON&lt;/span&gt; -s stop || &lt;span&gt;echo&lt;/span&gt; -n &lt;span&gt;&quot;nginx not running&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;do_reload&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;&lt;span&gt;$DAEMON&lt;/span&gt; -s reload || &lt;span&gt;echo&lt;/span&gt; -n &lt;span&gt;&quot;nginx can&#x27;t reload&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;span&gt;$1&lt;/span&gt;&quot;&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;br/&gt;start)&lt;br/&gt;&lt;span&gt;echo&lt;/span&gt; -n &lt;span&gt;&quot;Starting &lt;span&gt;$DESC&lt;/span&gt;: &lt;span&gt;$NAME&lt;/span&gt;&quot;&lt;/span&gt;&lt;br/&gt;do_start&lt;br/&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;.&quot;&lt;/span&gt;&lt;br/&gt;;;&lt;br/&gt;stop)&lt;br/&gt;&lt;span&gt;echo&lt;/span&gt; -n &lt;span&gt;&quot;Stopping &lt;span&gt;$DESC&lt;/span&gt;: &lt;span&gt;$NAME&lt;/span&gt;&quot;&lt;/span&gt;&lt;br/&gt;do_stop&lt;br/&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;.&quot;&lt;/span&gt;&lt;br/&gt;;;&lt;br/&gt;reload|graceful)&lt;br/&gt;&lt;span&gt;echo&lt;/span&gt; -n &lt;span&gt;&quot;Reloading &lt;span&gt;$DESC&lt;/span&gt; configuration...&quot;&lt;/span&gt;&lt;br/&gt;do_reload&lt;br/&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;.&quot;&lt;/span&gt;&lt;br/&gt;;;&lt;br/&gt;restart)&lt;br/&gt;&lt;span&gt;echo&lt;/span&gt; -n &lt;span&gt;&quot;Restarting &lt;span&gt;$DESC&lt;/span&gt;: &lt;span&gt;$NAME&lt;/span&gt;&quot;&lt;/span&gt;&lt;br/&gt;do_stop&lt;br/&gt;do_start&lt;br/&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;.&quot;&lt;/span&gt;&lt;br/&gt;;;&lt;br/&gt;*)&lt;br/&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;Usage: &lt;span&gt;$scriptNAME&lt;/span&gt; {start|stop|reload|restart}&quot;&lt;/span&gt; &amp;gt;&amp;amp;2&lt;br/&gt;&lt;span&gt;exit&lt;/span&gt; 3&lt;br/&gt;;;&lt;br/&gt;&lt;span&gt;esac&lt;/span&gt;&lt;br/&gt;&lt;span&gt;exit&lt;/span&gt; 0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置所有人都有对这个启动脚本 nginx 文件的执行权限：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;chmod a+x /etc/init.d/nginx&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把 nginx 加入系统服务中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;chkconfig --add nginx&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把服务设置为开机启动：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;chkconfig nginx on&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;reboot 重启系统生效，可以使用上面 systemctl 方法相同的命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;systemctl start nginx.service &lt;span&gt;# 启动nginx服务&lt;/span&gt;&lt;br/&gt;systemctl &lt;span&gt;enable&lt;/span&gt; nginx.service &lt;span&gt;# 设置开机启动&lt;/span&gt;&lt;br/&gt;systemctl &lt;span&gt;disable&lt;/span&gt; nginx.service &lt;span&gt;# 停止开机自启动&lt;/span&gt;&lt;br/&gt;systemctl status nginx.service &lt;span&gt;# 查看服务当前状态&lt;/span&gt;&lt;br/&gt;systemctl restart nginx.service &lt;span&gt;# 重新启动服务&lt;/span&gt;&lt;br/&gt;systemctl is-enabled nginx.service &lt;span&gt;#查询服务是否开机启动&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果服务启动的时候出现 &lt;code&gt;Restarting nginx daemon: nginxnginx: [error] open() &quot;/usr/local/nginx/logs/nginx.pid&quot; failed (2: No such file or directory) nginx not running&lt;/code&gt; 的错误，通过 nginx -c 参数指定配置文件即可解决&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/usr/&lt;span&gt;local&lt;/span&gt;/nginx/sbin/nginx -c /usr/&lt;span&gt;local&lt;/span&gt;/nginx/conf/nginx.conf&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果服务启动中出现 &lt;code&gt;nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)&lt;/code&gt; 的错误，可以先通过 &lt;code&gt;service nginx stop&lt;/code&gt; 停止服务，再启动就好。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;配置 nginx 全局可用&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当你每次改了 &lt;code&gt;nginx.conf&lt;/code&gt; 配置文件的内容都需要重新到 nginx 启动目录去执行命令，或者通过 -p 参数指向特定目录，会不会感觉很麻烦？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：直接执行 &lt;code&gt;nginx -s reload&lt;/code&gt; 会报错 &lt;code&gt;-bash: nginx: command not found&lt;/code&gt;，需要到 &lt;code&gt;/usr/local/nginx/sbin&lt;/code&gt; 目录下面去执行，并且是执行 &lt;code&gt;./nginx -s reload&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有两种方式可以解决，一种是通过脚本对 nginx 命令包装，这里介绍另外一种比较简单：通过把 nginx 配置到环境变量里，用 nginx 执行指令即可。步骤如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、编辑 /etc/profile&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;vi /etc/profile&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、在最后一行添加配置，:wq 保存&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;export PATH=$PATH:/usr/local/nginx/sbin&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、使配置立即生效&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;source /etc/profile&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就可以愉快的直接在全局使用 nginx 命令了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;nginx 常用功能&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;反向代理&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们最常说的反向代理的是通过反向代理解决跨域问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实反向代理还可以用来控制缓存（代理缓存 proxy cache），进行访问控制等等，以及后面说的负载均衡其实都是通过反向代理来实现的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;server {&lt;br/&gt;    listen    8080;&lt;br/&gt;        # 用户访问 ip:8080/test 下的所有路径代理到 github&lt;br/&gt;        location /test {&lt;br/&gt;         proxy_pass   https://github.com;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        # 所有 /api 下的接口访问都代理到本地的 8888 端口&lt;br/&gt;        # 例如你本地运行的 java 服务的端口是 8888，接口都是以 /api 开头&lt;br/&gt;        location /api {&lt;br/&gt;            proxy_pass   http://127.0.0.1:8888;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;访问控制&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;server {&lt;br/&gt;   location ~ ^/index.html {&lt;br/&gt;       # 匹配 index.html 页面 除了 127.0.0.1 以外都可以访问&lt;br/&gt;       deny 192.168.1.1;&lt;br/&gt;       deny 192.168.1.2;&lt;br/&gt;       allow all;&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的命令表示禁止 192.168.1.1 和 192.168.1.2 两个 ip 访问，其它全部允许。从上到下的顺序，匹配到了便跳出，可以按你的需求设置。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;负载均衡&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过负载均衡充利用服务器资源，nginx 目前支持自带 4 种负载均衡策略，还有 2 种常用的第三方策略。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;轮询策略（默认）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个请求按时间顺序逐一分配到不同的后端服务器，如果有后端服务器挂掉，能自动剔除。但是如果其中某一台服务器压力太大，出现延迟，会影响所有分配在这台服务器下的用户。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;http {&lt;br/&gt;    upstream test.com {&lt;br/&gt;        server 192.168.1.12:8887;&lt;br/&gt;        server 192.168.1.13:8888;&lt;br/&gt;    }&lt;br/&gt;    server {&lt;br/&gt;        location /api {&lt;br/&gt;            proxy_pass  http://test.com;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;根据服务器权重&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如要配置：10 次请求中大概 1 次访问到 8888 端口，9 次访问到 8887 端口：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;http {&lt;br/&gt;    upstream test.com {&lt;br/&gt;        server 192.168.1.12:8887 weight=9;&lt;br/&gt;        server 192.168.1.13:8888 weight=1;&lt;br/&gt;    }&lt;br/&gt;    server {&lt;br/&gt;        location /api {&lt;br/&gt;            proxy_pass  http://test.com;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;客户端 ip 绑定（ip_hash）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来自同一个 ip 的请求永远只分配一台服务器，有效解决了动态网页存在的 session 共享问题。例如：比如把登录信息保存到了 session 中，那么跳转到另外一台服务器的时候就需要重新登录了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以很多时候我们需要一个客户只访问一个服务器，那么就需要用 ip_hash 了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;http {&lt;br/&gt;    upstream test.com {&lt;br/&gt;     ip_hash;&lt;br/&gt;        server 192.168.1.12:8887;&lt;br/&gt;        server 192.168.1.13:8888;&lt;br/&gt;    }&lt;br/&gt;    server {&lt;br/&gt;        location /api {&lt;br/&gt;            proxy_pass  http://test.com;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;最小连接数策略&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将请求优先分配给压力较小的服务器，它可以平衡每个队列的长度，并避免向压力大的服务器添加更多的请求。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;http {&lt;br/&gt;    upstream test.com {&lt;br/&gt;     least_conn;&lt;br/&gt;        server 192.168.1.12:8887;&lt;br/&gt;        server 192.168.1.13:8888;&lt;br/&gt;    }&lt;br/&gt;    server {&lt;br/&gt;        location /api {&lt;br/&gt;            proxy_pass  http://test.com;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;最快响应时间策略（依赖于第三方 NGINX Plus）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;依赖于 NGINX Plus，优先分配给响应时间最短的服务器。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;http {&lt;br/&gt;    upstream test.com {&lt;br/&gt;     fair;&lt;br/&gt;        server 192.168.1.12:8887;&lt;br/&gt;        server 192.168.1.13:8888;&lt;br/&gt;    }&lt;br/&gt;    server {&lt;br/&gt;        location /api {&lt;br/&gt;            proxy_pass  http://test.com;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;按访问 url 的 hash 结果（第三方）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按访问 url 的 hash 结果来分配请求，使每个 url 定向到同一个后端服务器，后端服务器为缓存时比较有效。在 upstream 中加入 hash 语句，server 语句中不能写入 weight 等其他的参数，hash_method 是使用的 hash 算法&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;http {&lt;br/&gt;    upstream test.com {&lt;br/&gt;     hash $request_uri;&lt;br/&gt;     hash_method crc32;&lt;br/&gt;     server 192.168.1.12:8887;&lt;br/&gt;     server 192.168.1.13:8888;&lt;br/&gt;    }&lt;br/&gt;    server {&lt;br/&gt;        location /api {&lt;br/&gt;            proxy_pass  http://test.com;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;采用 HAproxy 的 loadbalance uri 或者 nginx 的 upstream_hash 模块，都可以做到针对 url 进行哈希算法式的负载均衡转发。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;gzip 压缩&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开启 gzip 压缩可以大幅减少 http 传输过程中文件的大小，可以极大的提高网站的访问速度，基本是必不可少的优化操作：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;gzip  on; # 开启gzip 压缩&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; gzip_types&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; gzip_static on;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; gzip_proxied expired no-cache no-store private auth;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; gzip_buffers 16 8k;&lt;/span&gt;&lt;br/&gt;gzip_min_length 1k;&lt;br/&gt;gzip_comp_level 4;&lt;br/&gt;gzip_http_version 1.0;&lt;br/&gt;gzip_vary off;&lt;br/&gt;gzip_disable &quot;MSIE [1-6]\.&quot;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解释一下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;gzip_types：要采用 gzip 压缩的 MIME 文件类型，其中 text/html 被系统强制启用；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;gzip_static：默认 off，该模块启用后，Nginx 首先检查是否存在请求静态文件的 gz 结尾的文件，如果有则直接返回该 .gz 文件内容；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;gzip_proxied：默认 off，nginx 做为反向代理时启用，用于设置启用或禁用从代理服务器上收到相应内容 gzip 压缩；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;gzip_buffers：获取多少内存用于缓存压缩结果，16 8k 表示以 8k*16 为单位获得；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;gzip_min_length：允许压缩的页面最小字节数，页面字节数从 header 头中的 Content-Length 中进行获取。默认值是 0，不管页面多大都压缩。建议设置成大于 1k 的字节数，小于 1k 可能会越压越大；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;gzip_comp_level：gzip 压缩比，压缩级别是 1-9，1 压缩级别最低，9 最高，级别越高压缩率越大，压缩时间越长，建议 4-6；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;gzip_http_version：默认 1.1，启用 gzip 所需的 HTTP 最低版本；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;gzip_vary：用于在响应消息头中添加 Vary：Accept-Encoding，使代理服务器根据请求头中的 Accept-Encoding 识别是否启用 gzip 压缩；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;gzip_disable 指定哪些不需要 gzip 压缩的浏览器&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中第 2 点，普遍是结合前端打包的时候打包成 gzip 文件后部署到服务器上，这样服务器就可以直接使用 gzip 的文件了，并且可以把压缩比例提高，这样 nginx 就不用压缩，也就不会影响速度。一般不追求极致的情况下，前端不用做任何配置就可以使用啦~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;附前端 webpack 开启 gzip 压缩配置，在 vue-cli3 的 vue.config.js 配置文件中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; CompressionWebpackPlugin = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;compression-webpack-plugin&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;module&lt;/span&gt;.exports = {&lt;br/&gt;  &lt;span&gt;// gzip 配置&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;configureWebpack&lt;/span&gt;: &lt;span&gt;&lt;span&gt;config&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (process.env.NODE_ENV === &lt;span&gt;&#x27;production&#x27;&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;// 生产环境&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;plugins&lt;/span&gt;: [&lt;span&gt;new&lt;/span&gt; CompressionWebpackPlugin({&lt;br/&gt;          &lt;span&gt;test&lt;/span&gt;: &lt;span&gt;/\.js$|\.html$|\.css/&lt;/span&gt;,    &lt;span&gt;// 匹配文件名&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;threshold&lt;/span&gt;: &lt;span&gt;1024&lt;/span&gt;,               &lt;span&gt;// 文件压缩阈值，对超过 1k 的进行压缩&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;deleteOriginalAssets&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;     &lt;span&gt;// 是否删除源文件&lt;/span&gt;&lt;br/&gt;        })]&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  },&lt;br/&gt;  ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;HTTP 服务器&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;nginx 本身也是一个静态资源的服务器，当只有静态资源的时候，就可以使用 nginx 来做服务器：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;server {&lt;br/&gt;  listen       80;&lt;br/&gt;  server_name  localhost;&lt;br/&gt;&lt;br/&gt;  location / {&lt;br/&gt;      root   /usr/local/app;&lt;br/&gt;      index  index.html;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样如果访问 http://ip 就会默认访问到 /usr/local/app 目录下面的 index.html，如果一个网站只是静态页面的话，那么就可以通过这种方式来实现部署，比如一个静态官网。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;动静分离&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就是把动态和静态的请求分开。方式主要有两种：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一种是纯粹把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流推崇的方案&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一种方法就是动态跟静态文件混合在一起发布， 通过 nginx 配置来分开&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 所有静态请求都由nginx处理，存放目录为 html&lt;/span&gt;&lt;br/&gt;location ~ \.(gif|jpg|jpeg|png|bmp|swf|css|js)$ {&lt;br/&gt;    root    /usr/&lt;span&gt;local&lt;/span&gt;/resource;&lt;br/&gt;    expires     10h; &lt;span&gt;# 设置过期时间为10小时&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 所有动态请求都转发给 tomcat 处理&lt;/span&gt;&lt;br/&gt;location ~ \.(jsp|&lt;span&gt;do&lt;/span&gt;)$ {&lt;br/&gt;    proxy_pass  127.0.0.1:8888;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意上面设置了 expires，当 nginx 设置了 expires 后，例如设置为：expires 10d; 那么，所在的 location 或 if 的内容，用户在 10 天内请求的时候，都只会访问浏览器中的缓存，而不会去请求 nginx 。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;请求限制&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于大流量恶意的访问，会造成带宽的浪费，给服务器增加压力。可以通过 nginx 对于同一 IP 的连接数以及并发数进行限制。合理的控制还可以用来防止 DDos 和 CC 攻击。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于请求限制主要使用 nginx 默认集成的 2 个模块：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;limit_conn_module 连接频率限制模块&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;limit_req_module 请求频率限制模块&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;涉及到的配置主要是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;limit_req_zone 限制请求数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;limit_conn_zone 限制并发连接数&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;通过 limit_req_zone 限制请求数&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;http{&lt;br/&gt;    limit_conn_zone $binary_remote_addrzone=limit:10m; // 设置共享内存空间大&lt;br/&gt;    server{&lt;br/&gt;     location /{&lt;br/&gt;            limit_conn addr 5; # 同一用户地址同一时间只允许有5个连接。&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果共享内存空间被耗尽，服务器将会对后续所有的请求返回 503 (Service Temporarily Unavailable) 错误。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当多个 limit_conn_zone 指令被配置时，所有的连接数限制都会生效。比如，下面配置不仅会限制单一 IP 来源的连接数，同时也会限制单一虚拟服务器的总连接数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;limit_conn_zone $binary_remote_addr zone=perip:10m;&lt;br/&gt;limit_conn_zone $server_name zone=perserver:10m;&lt;br/&gt;server {&lt;br/&gt;    limit_conn perip 10; # 限制每个 ip 连接到服务器的数量&lt;br/&gt;    limit_conn perserver 2000; # 限制连接到服务器的总数&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;通过 limit_conn_zone 限制并发连接数&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;limit_req_zone $binary_remote_addr zone=creq:10 mrate=10r/s;&lt;br/&gt;server{&lt;br/&gt;    location /{&lt;br/&gt;        limit_req zone=creq burst=5;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;限制平均每秒不超过一个请求，同时允许超过频率限制的请求数不多于 5 个。如果不希望超过的请求被延迟，可以用 nodelay 参数,如：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;limit_req zone=creq burst=5 nodelay;&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里只是简单讲讲，让大家有这个概念，配置的时候可以深入去找找资料。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;正向代理&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理，比如我们使用的 VPN 服务就是正向代理，直观区别：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0109409190371992&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauLdHRFreUAZ7U9Bz4XsHwXNDBe3m58FdgMKvWrqiaribzgPicia1GfpaB7q8D8p5jU7yOjT5t5Fx3Edw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;914&quot;/&gt;&lt;figcaption/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置正向代理：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;resolver 8.8.8.8 # 谷歌的域名解析地址&lt;br/&gt;server {&lt;br/&gt;    resolver_timeout 5s; // 设超时时间&lt;br/&gt;    location / {&lt;br/&gt;        # 当客户端请求我的时候，我会把请求转发给它&lt;br/&gt;        # $host 要访问的主机名 $request_uri 请求路径&lt;br/&gt;        proxy_pass http://$host$request_uri;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正向代理的对象是客户端，服务器端看不到真正的客户端。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;图片防盗链&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;server {&lt;br/&gt;    listen       80;&lt;br/&gt;    server_name  *.test;&lt;br/&gt;&lt;br/&gt;    # 图片防盗链&lt;br/&gt;    location ~* \.(gif|jpg|jpeg|png|bmp|swf)$ {&lt;br/&gt;        valid_referers none blocked server_names ~\.google\. ~\.baidu\. *.qq.com;  # 只允许本机 IP 外链引用，将百度和谷歌也加入白名单有利于 SEO&lt;br/&gt;        if ($invalid_referer){&lt;br/&gt;            return 403;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上设置就能防止其它网站利用外链访问我们的图片，有利于节省流量&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;适配 PC 或移动设备&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据用户设备不同返回不同样式的站点，以前经常使用的是纯前端的自适应布局，但是复杂的网站并不适合响应式，无论是复杂性和易用性上面还是不如分开编写的好，比如我们常见的淘宝、京东。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据用户请求的 user-agent 来判断是返回 PC 还是 H5 站点：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;server {&lt;br/&gt;    listen 80;&lt;br/&gt;    server_name test.com;&lt;br/&gt;&lt;br/&gt;    location / {&lt;br/&gt;     root  /usr/local/app/pc; # pc 的 html 路径&lt;br/&gt;        if ($http_user_agent ~* &#x27;(Android|webOS|iPhone|iPod|BlackBerry)&#x27;) {&lt;br/&gt;            root /usr/local/app/mobile; # mobile 的 html 路径&lt;br/&gt;        }&lt;br/&gt;        index index.html;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;设置二级域名&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新建一个 server 即可：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;server {&lt;br/&gt;    listen 80;&lt;br/&gt;    server_name admin.test.com; // 二级域名&lt;br/&gt;&lt;br/&gt;    location / {&lt;br/&gt;        root  /usr/local/app/admin; # 二级域名的 html 路径&lt;br/&gt;        index index.html;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;配置 HTTPS&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我使用的是 certbot 免费证书，但申请一次有效期只有 3 个月（好像可以用 crontab 尝试配置自动续期，我暂时没试过）：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先安装 certbot&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;wget https://dl.eff.org/certbot-auto&lt;br/&gt;chmod a+x certbot-auto&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;申请证书（注意：需要把要申请证书的域名先解析到这台服务器上，才能申请）:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;sudo ./certbot-auto certonly --standalone --email admin@abc.com -d test.com -d www.test.com&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行上面指令，按提示操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Certbot 会启动一个临时服务器来完成验证（会占用 80 端口或 443 端口，因此需要暂时关闭 Web 服务器），然后 Certbot 会把证书以文件的形式保存，包括完整的证书链文件和私钥文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文件保存在 /etc/letsencrypt/live/ 下面的域名目录下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;修改 nginx 配置：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;server{&lt;br/&gt;    listen 443 ssl http2; // 这里还启用了 http/2.0&lt;br/&gt;&lt;br/&gt;    ssl_certificate /etc/letsencrypt/live/test.com/fullchain.pem; # 证书文件地址&lt;br/&gt;    ssl_certificate_key /etc/letsencrypt/live/test.com/privkey.pem; # 私钥文件地址&lt;br/&gt;&lt;br/&gt;    server_name test.com www.test.com; // 证书绑定的域名&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;配置 HTTP 转 HTTPS&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;server {&lt;br/&gt;    listen      80;&lt;br/&gt;    server_name test.com www.test.com;&lt;br/&gt;&lt;br/&gt;    # 单域名重定向&lt;br/&gt;    if ($host = &#x27;www.sherlocked93.club&#x27;){&lt;br/&gt;        return 301 https://www.sherlocked93.club$request_uri;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    # 全局非 https 协议时重定向&lt;br/&gt;    if ($scheme != &#x27;https&#x27;) {&lt;br/&gt;        return 301 https://$server_name$request_uri;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    # 或者全部重定向&lt;br/&gt;    return 301 https://$server_name$request_uri;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上配置选择自己需要的一条即可，不用全部加。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;单页面项目 history 路由配置&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;server {&lt;br/&gt;    listen       80;&lt;br/&gt;    server_name  fe.sherlocked93.club;&lt;br/&gt;&lt;br/&gt;    location / {&lt;br/&gt;        root       /usr/local/app/dist;  # vue 打包后的文件夹&lt;br/&gt;        index      index.html index.htm;&lt;br/&gt;        try_files  $uri $uri/ /index.html @rewrites; # 默认目录下的 index.html，如果都不存在则重定向&lt;br/&gt;&lt;br/&gt;        expires -1;                          # 首页一般没有强制缓存&lt;br/&gt;        add_header Cache-Control no-cache;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    location @rewrites { // 重定向设置&lt;br/&gt;        rewrite ^(.+)$ /index.html break;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://router.vuejs.org/zh/guide/essentials/history-mode.html#%E5%90%8E%E7%AB%AF%E9%85%8D%E7%BD%AE%E4%BE%8B%E5%AD%90&quot; data-linktype=&quot;2&quot;&gt;vue-router&lt;/a&gt; 官网只有一句话 &lt;code&gt;try_files $uri $uri/ /index.html;&lt;/code&gt;，而上面做了一些重定向处理。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;配置高可用集群（双机热备）&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当主 nginx 服务器宕机之后，切换到备份的 nginx 服务器&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先安装 keepalived:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;yum install keepalived -y&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后编辑 &lt;code&gt;/etc/keepalived/keepalived.conf&lt;/code&gt; 配置文件，并在配置文件中增加 &lt;code&gt;vrrp_script&lt;/code&gt; 定义一个外围检测机制，并在 &lt;code&gt;vrrp_instance&lt;/code&gt; 中通过定义 &lt;code&gt;track_script&lt;/code&gt; 来追踪脚本执行过程，实现节点转移：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;global_defs{&lt;br/&gt;   notification_email {&lt;br/&gt;        cchroot@gmail.com&lt;br/&gt;   }&lt;br/&gt;   notification_email_from test@firewall.loc&lt;br/&gt;   smtp_server 127.0.0.1&lt;br/&gt;   smtp_connect_timeout 30 // 上面都是邮件配置&lt;br/&gt;   router_id LVS_DEVEL     // 当前服务器名字，用 hostname 命令来查看&lt;br/&gt;}&lt;br/&gt;vrrp_script chk_maintainace { // 检测机制的脚本名称为chk_maintainace&lt;br/&gt;    script &quot;[[ -e/etc/keepalived/down ]] &amp;amp;&amp;amp; exit 1 || exit 0&quot; // 可以是脚本路径或脚本命令&lt;br/&gt;    // script &quot;/etc/keepalived/nginx_check.sh&quot;    // 比如这样的脚本路径&lt;br/&gt;    interval 2  // 每隔2秒检测一次&lt;br/&gt;    weight -20  // 当脚本执行成立，那么把当前服务器优先级改为-20&lt;br/&gt;}&lt;br/&gt;vrrp_instanceVI_1 {   // 每一个vrrp_instance就是定义一个虚拟路由器&lt;br/&gt;    state MASTER      // 主机为MASTER，备用机为BACKUP&lt;br/&gt;    interface eth0    // 网卡名字，可以从ifconfig中查找&lt;br/&gt;    virtual_router_id 51 // 虚拟路由的id号，一般小于255，主备机id需要一样&lt;br/&gt;    priority 100      // 优先级，master的优先级比backup的大&lt;br/&gt;    advert_int 1      // 默认心跳间隔&lt;br/&gt;    authentication {  // 认证机制&lt;br/&gt;        auth_type PASS&lt;br/&gt;        auth_pass 1111   // 密码&lt;br/&gt;    }&lt;br/&gt;    virtual_ipaddress {  // 虚拟地址vip&lt;br/&gt;       172.16.2.8&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中检测脚本 &lt;code&gt;nginx_check.sh&lt;/code&gt;，这里提供一个：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/bin/bash&lt;/span&gt;&lt;br/&gt;A=`ps -C nginx --no-header | wc -l`&lt;br/&gt;if [ $A -eq 0 ];then&lt;br/&gt;    /usr/sbin/nginx # 尝试重新启动nginx&lt;br/&gt;    sleep 2         # 睡眠2秒&lt;br/&gt;    if [ `ps -C nginx --no-header | wc -l` -eq 0 ];then&lt;br/&gt;        killall keepalived # 启动失败，将keepalived服务杀死。将vip漂移到其它备份节点&lt;br/&gt;    fi&lt;br/&gt;fi&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;复制一份到备份服务器，备份 nginx 的配置要将 &lt;code&gt;state&lt;/code&gt; 后改为 &lt;code&gt;BACKUP&lt;/code&gt;，&lt;code&gt;priority&lt;/code&gt; 改为比主机小。设置完毕后各自 &lt;code&gt;service keepalived start&lt;/code&gt; 启动，经过访问成功之后，可以把 Master 机的 keepalived 停掉，此时 Master 机就不再是主机了 &lt;code&gt;service keepalived stop&lt;/code&gt;，看访问虚拟 IP 时是否能够自动切换到备机 ip addr。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再次启动 Master 的 keepalived，此时 vip 又变到了主机上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置高可用集群的内容来源于：&lt;a href=&quot;https://juejin.im/post/6844904144235413512#heading-11&quot; data-linktype=&quot;2&quot;&gt;Nginx 从入门到实践，万字详解！&lt;/a&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;其它功能和技巧&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;代理缓存&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;nginx 的 http_proxy 模块，提供类似于 Squid 的缓存功能，使用 proxy_cache_path 来配置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;nginx 可以对访问过的内容在 nginx 服务器本地建立副本，这样在一段时间内再次访问该数据，就不需要通过 nginx 服务器再次向后端服务器发出请求，减小数据传输延迟，提高访问速度：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;proxy_cache_path usr/&lt;span&gt;local&lt;/span&gt;/cache levels=1:2 keys_zone=my_cache:10m;&lt;br/&gt;&lt;br/&gt;server {&lt;br/&gt;  listen       80;&lt;br/&gt;  server_name  test.com;&lt;br/&gt;&lt;br/&gt;  location / {&lt;br/&gt;      proxy_cache my_cache;&lt;br/&gt;      proxy_pass http://127.0.0.1:8888;&lt;br/&gt;      proxy_set_header Host &lt;span&gt;$host&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的配置表示：nginx 提供一块 10 M 的内存用于缓存，名字为 my_cache, levels 等级为 1:2，缓存存放的路径为 &lt;code&gt;usr/local/cache&lt;/code&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;访问日志&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;访问日志默认是注释的状态，需要可以打开和进行更详细的配置，一下是 nginx 的默认配置：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;http {&lt;br/&gt;    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;&lt;br/&gt;                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;&lt;br/&gt;                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;&lt;br/&gt;&lt;br/&gt;    access_log  logs/access.log  main;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;错误日志&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;错误日志放在 main 全局区块中，童鞋们打开 nginx.conf 就可以看见在配置文件中和下面一样的代码了：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;error_log  logs/error.log;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;error_log  logs/error.log  notice;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;error_log  logs/error.log  info;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;nginx 错误日志默认配置为：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;error_log logs/error.log error;&lt;/code&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;静态资源服务器&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;server {&lt;br/&gt;    listen       80;&lt;br/&gt;    server_name  static.bin;&lt;br/&gt;    charset utf-8;    &lt;span&gt;# 防止中文文件名乱码&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    location /download {&lt;br/&gt;        &lt;span&gt;alias&lt;/span&gt;           /usr/share/nginx/static;  &lt;span&gt;# 静态资源目录&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        autoindex               on;    &lt;span&gt;# 开启静态资源列目录，浏览目录权限&lt;/span&gt;&lt;br/&gt;        autoindex_exact_size    off;   &lt;span&gt;# on(默认)显示文件的确切大小，单位是byte；off显示文件大概大小，单位KB、MB、GB&lt;/span&gt;&lt;br/&gt;        autoindex_localtime     off;   &lt;span&gt;# off(默认)时显示的文件时间为GMT时间；on显示的文件时间为服务器时间&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;禁止指定 user_agent&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;nginx 可以禁止指定的浏览器和爬虫框架访问：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; http_user_agent 为浏览器标识&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 禁止 user_agent 为baidu、360和sohu，~*表示不区分大小写匹配&lt;/span&gt;&lt;br/&gt;if ($http_user_agent ~* &#x27;baidu|360|sohu&#x27;) {&lt;br/&gt;    return 404;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span&gt; 禁止 Scrapy 等工具的抓取&lt;/span&gt;&lt;br/&gt;if ($http_user_agent ~* (Scrapy|Curl|HttpClient)) {&lt;br/&gt;    return 403;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;请求过滤&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;根据请求类型过滤&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 非指定请求全返回 403&lt;/span&gt;&lt;br/&gt;if ( $request_method !~ ^(GET|POST|HEAD)$ ) {&lt;br/&gt;    return 403;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;根据状态码过滤&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;error_page 502 503 /50x.html;&lt;br/&gt;location = /50x.html {&lt;br/&gt;    root /usr/share/nginx/html;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样实际上是一个内部跳转，当访问出现 502、503 的时候就能返回 50x.html 中的内容，这里需要注意是否可以找到 50x.html 页面，所以加了个 location 保证找到你自定义的 50x 页面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;根据 URL 名称过滤&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;if ($host = zy.com&#x27; ) {&lt;br/&gt;     #其中 $1是取自regex部分()里的内容,匹配成功后跳转到的URL。&lt;br/&gt;     rewrite ^/(.*)$  http://www.zy.com/$1  permanent；&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;location /test {&lt;br/&gt;    // /test 全部重定向到首页&lt;br/&gt;    rewrite  ^(.*)$ /index.html  redirect;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;ab 命令&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ab 命令全称为：Apache bench，是 Apache 自带的压力测试工具，也可以测试 Nginx、IIS 等其他 Web 服务器:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;-n 总共的请求数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-c 并发的请求数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-t 测试所进行的最大秒数，默认值 为 50000&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-p 包含了需要的 POST 的数据文件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-T POST 数据所使用的 Content-type 头信息&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ab -n 1000 -c 5000 http://127.0.0.1/ # 每次发送1000并发的请求数，请求数总数为5000。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试前需要安装 httpd-tools：&lt;code&gt;yum install httpd-tools&lt;/code&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;泛域名路径分离&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个非常实用的技能，经常有时候我们可能需要配置一些二级或者三级域名，希望通过 nginx 自动指向对应目录，比如：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;test1.doc.test.club 自动指向 /usr/local/html/doc/test1 服务器地址；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;test2.doc.test.club 自动指向 /usr/local/html/doc/test2 服务器地址；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;server {&lt;br/&gt;    listen       80;&lt;br/&gt;    server_name  ~^([\w-]+)\.doc\.test\.club$;&lt;br/&gt;&lt;br/&gt;    root /usr/local/html/doc/$1;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;泛域名转发&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和之前的功能类似，有时候我们希望把二级或者三级域名链接重写到我们希望的路径，让后端就可以根据路由解析不同的规则：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;test1.serv.test.club/api?name=a 自动转发到 127.0.0.1:8080/test1/api?name=a&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;test2.serv.test.club/api?name=a 自动转发到 127.0.0.1:8080/test2/api?name=a&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;server {&lt;br/&gt;    listen       80;&lt;br/&gt;    server_name ~^([\w-]+)\.serv\.test\.club$;&lt;br/&gt;&lt;br/&gt;    location / {&lt;br/&gt;        proxy_set_header        X-Real-IP $remote_addr;&lt;br/&gt;        proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;&lt;br/&gt;        proxy_set_header        Host $http_host;&lt;br/&gt;        proxy_set_header        X-NginX-Proxy true;&lt;br/&gt;        proxy_pass              http://127.0.0.1:8080/$1$request_uri;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;常见问题&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;nginx 中怎么设置变量&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;或许你不知道，nginx 的配置文件使用的是一门微型的编程语言。既然是编程语言，一般也就少不了“变量”这种东西，但是在 nginx 配置中，变量只能存放一种类型的值，因为也只存在一种类型的值，那就是字符串。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如我们在 nginx.conf 中有这样一行配置：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;set $name &quot;chroot&quot;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面使用了 set 配置指令对变量 &lt;code&gt;$name&lt;/code&gt;进行了赋值操作，把 &quot;chroot&quot; 赋值给了 &lt;code&gt;$name&lt;/code&gt;。nginx 变量名前面有一个 &lt;code&gt;$&lt;/code&gt; 符号，这是记法上的要求。所有的 Nginx 变量在 Nginx 配置文件中引用时都须带上 &lt;code&gt;$&lt;/code&gt; 前缀。这种表示方法和 Perl、PHP 这些语言是相似的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种表示方法的用处在哪里呢，那就是可以直接把变量嵌入到字符串常量中以构造出新的字符串，例如你需要进行一个字符串拼接：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;server {&lt;br/&gt;  listen       80;&lt;br/&gt;  server_name  test.com;&lt;br/&gt;&lt;br/&gt;  location / {&lt;br/&gt;     set $temp hello;&lt;br/&gt;     return &quot;$temp world&quot;;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上当匹配成功的时候就会返回字符串 &quot;hello world&quot; 了。需要注意的是，当引用的变量名之后紧跟着变量名的构成字符时（比如后跟字母、数字以及下划线），我们就需要使用特别的记法来消除歧义，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;server {&lt;br/&gt;  listen       80;&lt;br/&gt;  server_name  test.com;&lt;br/&gt;&lt;br/&gt;  location / {&lt;br/&gt;     set $temp &quot;hello &quot;;&lt;br/&gt;     return &quot;${temp}world&quot;;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里，我们在配置指令的参数值中引用变量 &lt;code&gt;$temp&lt;/code&gt; 的时候，后面紧跟着 &lt;code&gt;world&lt;/code&gt; 这个单词，所以如果直接写作 &lt;code&gt;&quot;$tempworld&quot;&lt;/code&gt; 则 nginx 的计算引擎会将之识别为引用了变量 &lt;code&gt;$tempworld&lt;/code&gt;. 为了解决这个问题，nginx 的字符串支持使用花括号在 &lt;code&gt;$&lt;/code&gt; 之后把变量名围起来，比如这里的 &lt;code&gt;${temp}&lt;/code&gt;，所以 上面这个例子返回的还是 &quot;hello world&quot;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; curl &lt;span&gt;&#x27;http://test.com/&#x27;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;    hello world&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还需要注意的是，若是想输出 &lt;code&gt;$&lt;/code&gt; 符号本身，可以这样做：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;geo $dollar {&lt;br/&gt;    default &quot;$&quot;;&lt;br/&gt;}&lt;br/&gt;server {&lt;br/&gt;    listen       80;&lt;br/&gt;    server_name  test.com;&lt;br/&gt;&lt;br/&gt;    location / {&lt;br/&gt;        set $temp &quot;hello &quot;;&lt;br/&gt;        return &quot;${temp}world: $dollar&quot;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面用到了标准模块 ngx_geo 提供的配置指令 geo 来为变量 &lt;code&gt;$dollar&lt;/code&gt; 赋予字符串 &lt;code&gt;&quot;$&quot;&lt;/code&gt; ，这样，这里的返回值就是 &quot;hello world: $&quot; 了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;附 nginx 内置预定义变量&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按字母顺序，变量名与对应定义：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$arg_PARAMETER&lt;/code&gt; #GET 请求中变量名 PARAMETER 参数的值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$args&lt;/code&gt; #这个变量等于 GET 请求中的参数，例如，foo=123&amp;amp;bar=blahblah;这个变量可以被修改&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$binary_remote_addr&lt;/code&gt; #二进制码形式的客户端地址&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$body_bytes_sent&lt;/code&gt; #传送页面的字节数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$content_length&lt;/code&gt; #请求头中的 Content-length 字段&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$content_type&lt;/code&gt; #请求头中的 Content-Type 字段&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$cookie_COOKIE&lt;/code&gt; #cookie COOKIE 的值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$document_root&lt;/code&gt; #当前请求在 root 指令中指定的值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$document_uri&lt;/code&gt; #与 $uri 相同&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$host&lt;/code&gt; #请求中的主机头(Host)字段，如果请求中的主机头不可用或者空，则为处理请求的 server 名称(处理请求的 server 的 server_name 指令的值)。值为小写，不包含端口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$hostname&lt;/code&gt; #机器名使用 gethostname 系统调用的值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$http_HEADER&lt;/code&gt; #HTTP 请求头中的内容，HEADER 为 HTTP 请求中的内容转为小写，-变为_(破折号变为下划线)，例如：&lt;code&gt;$http_user_agent&lt;/code&gt;(Uaer-Agent 的值)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$sent_http_HEADER&lt;/code&gt; #HTTP 响应头中的内容，HEADER 为 HTTP 响应中的内容转为小写，-变为_(破折号变为下划线)，例如：&lt;code&gt;$sent_http_cache_control&lt;/code&gt;、&lt;code&gt;$sent_http_content_type&lt;/code&gt;…&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$is_args&lt;/code&gt; #如果 $args 设置，值为&quot;?&quot;，否则为&quot;&quot;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$limit_rate&lt;/code&gt; #这个变量可以限制连接速率&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$nginx_version&lt;/code&gt; #当前运行的 nginx 版本号&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$query_string&lt;/code&gt; #与 $args 相同&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$remote_addr&lt;/code&gt; #客户端的 IP 地址&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$remote_port&lt;/code&gt; #客户端的端口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$remote_port&lt;/code&gt; #已经经过 Auth Basic Module 验证的用户名&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$request_filename&lt;/code&gt; #当前连接请求的文件路径，由 root 或 alias 指令与 URI 请求生成&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$request_body&lt;/code&gt; #这个变量（0.7.58+）包含请求的主要信息。在使用 proxy_pass 或 fastcgi_pass 指令的 location 中比较有意义&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$request_body_file&lt;/code&gt; #客户端请求主体信息的临时文件名&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$request_completion&lt;/code&gt; #如果请求成功，设为&quot;OK&quot;；如果请求未完成或者不是一系列请求中最后一部分则设为空&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$request_method&lt;/code&gt; #这个变量是客户端请求的动作，通常为 GET 或 POST。包括 0.8.20 及之前的版本中，这个变量总为 main request 中的动作，如果当前请求是一个子请求，并不使用这个当前请求的动作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$request_uri&lt;/code&gt; #这个变量等于包含一些客户端请求参数的原始 URI，它无法修改，请查看 $uri 更改或重写 URI&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$scheme&lt;/code&gt; #所用的协议，例如 http 或者是 https，例如 &lt;code&gt;rewrite ^(.+)$$scheme://example.com$1 redirect&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$server_addr&lt;/code&gt; #服务器地址，在完成一次系统调用后可以确定这个值，如果要绕开系统调用，则必须在 listen 中指定地址并且使用 bind 参数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$server_name&lt;/code&gt; #服务器名称&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$server_port&lt;/code&gt; #请求到达服务器的端口号&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$server_protocol&lt;/code&gt; #请求使用的协议，通常是 HTTP/1.0、HTTP/1.1 或 HTTP/2&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$uri&lt;/code&gt; #请求中的当前 URI(不带请求参数，参数位于 args ) ， 不 同 于 浏 览 器 传 递 的 args)，不同于浏览器传递的 args)，不同于浏览器传递的 request_uri 的值，它可以通过内部重定向，或者使用 index 指令进行修改。不包括协议和主机名，例如 /foo/bar.html&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;附 nginx 模块&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;nginx 模块分类&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;核心模块：nginx 最基本最核心的服务，如进程管理、权限控制、日志记录；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;标准 HTTP 模块：nginx 服务器的标准 HTTP 功能；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可选 HTTP 模块：处理特殊的 HTTP 请求&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;邮件服务模块：邮件服务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第三方模块：作为扩展，完成特殊功能&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;模块清单&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;核心模块&lt;/strong&gt;：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ngx_core&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_errlog&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_conf&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_events&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_event_core&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_epll&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_regex&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;标准 HTTP 模块&lt;/strong&gt;：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ngx_http&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_core #配置端口，URI 分析，服务器相应错误处理，别名控制 (alias) 等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_log #自定义 access 日志&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_upstream #定义一组服务器，可以接受来自 proxy, Fastcgi,Memcache 的重定向；主要用作负载均衡&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_static&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_autoindex #自动生成目录列表&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_index #处理以/结尾的请求，如果没有找到 index 页，则看是否开启了 random_index；如开启，则用之，否则用 autoindex&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_auth_basic #基于 http 的身份认证 (auth_basic)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_access #基于 IP 地址的访问控制 (deny,allow)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_limit_conn #限制来自客户端的连接的响应和处理速率&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_limit_req #限制来自客户端的请求的响应和处理速率&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_geo&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_map #创建任意的键值对变量&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_split_clients&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_referer #过滤 HTTP 头中 Referer 为空的对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_rewrite #通过正则表达式重定向请求&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_proxy&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_fastcgi #支持 fastcgi&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_uwsgi&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_scgi&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_memcached&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_empty_gif #从内存创建一个 1×1 的透明 gif 图片，可以快速调用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_browser #解析 http 请求头部的 User-Agent 值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_charset #指定网页编码&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_upstream_ip_hash&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_upstream_least_conn&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_upstream_keepalive&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_write_filter&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_header_filter&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_chunked_filter&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_range_header&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_gzip_filter&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_postpone_filter&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_ssi_filter&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_charset_filter&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_userid_filter&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_headers_filter #设置 http 响应头&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_copy_filter&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_range_body_filter&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_not_modified_filter&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;可选 HTTP 模块&lt;/strong&gt;:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ngx_http_addition #在响应请求的页面开始或者结尾添加文本信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_degradation #在低内存的情况下允许服务器返回 444 或者 204 错误&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_perl&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_flv #支持将 Flash 多媒体信息按照流文件传输，可以根据客户端指定的开始位置返回 Flash&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_geoip #支持解析基于 GeoIP 数据库的客户端请求&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_google_perftools&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_gzip #gzip 压缩请求的响应&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_gzip_static #搜索并使用预压缩的以.gz 为后缀的文件代替一般文件响应客户端请求&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_image_filter #支持改变 png，jpeg，gif 图片的尺寸和旋转方向&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_mp4 #支持.mp4,.m4v,.m4a 等多媒体信息按照流文件传输，常与 ngx_http_flv 一起使用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_random_index #当收到 / 结尾的请求时，在指定目录下随机选择一个文件作为 index&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_secure_link #支持对请求链接的有效性检查&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_ssl #支持 https&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_stub_status&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_sub_module #使用指定的字符串替换响应中的信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_dav #支持 HTTP 和 WebDAV 协议中的 PUT/DELETE/MKCOL/COPY/MOVE 方法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_xslt #将 XML 响应信息使用 XSLT 进行转换&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;邮件服务模块&lt;/strong&gt;:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ngx_mail_core&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_mail_pop3&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_mail_imap&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_mail_smtp&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_mail_auth_http&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_mail_proxy&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_mail_ssl&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第三方模块&lt;/strong&gt;：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;echo-nginx-module #支持在 nginx 配置文件中使用 echo/sleep/time/exec 等类 Shell 命令&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;memc-nginx-module&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;rds-json-nginx-module #使 nginx 支持 json 数据的处理&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;lua-nginx-module&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;视频号最新视频&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAAJjUhrlvPsAAAAAstQy6ubaLX4KHWvLEZgBPEkKNMLl9VOfD-zNPgMIuzeC2qwTgrRf13Vpi4lJ-I&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=RBfjicXSHKCOONJnTbRmmlD8cOQPXE48ibtBXUEAKtRgl7BUBSYHUNaRHsOibNxVHntKHcVhdahYfW9FUWseOhdjS248icaWhleRjpcWeF4S0IdQrK5SHu1BMb9Trvyiag4jniaQLwJHgicIiaD1lZquAlCCeh83dgIFOAick6HZAT3OH09I&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SH&amp;amp;idx=1&amp;amp;m=dc2dec1cd446892b76a52601807aa35e&amp;amp;token=cztXnd9GyrGhE2iaHGOXDiaIEWMBk1BY6bdAkbtbt3dRnIGnyp8bibIOhicHusCyVODD&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/I7awtksbibjQe7RZAy84xEecUymmic8cw4v7Y2zbnVDuo/0&quot; data-username=&quot;v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder&quot; data-nickname=&quot;腾讯程序员&quot; data-desc=&quot;你很可能不知道的 10 个手机实用技巧，欢迎在评论区分享你的小技巧&amp;#10;#手机 #效率 #技巧 #iPhone&amp;#10;&quot; data-nonceid=&quot;10972294623550344267&quot; data-type=&quot;video&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;想了解腾讯人的故事，欢迎关注：腾讯技术&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg5OTE3MDMzOA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/sz_mmbiz_png/YGYGFPll6xzwZBHwh7TgG3bjkhaTibXAC07CklcibMiateyQHO9oWOZBANkVvBichSQBRYf1H5D8PRRqDdWvyPicq1w/0?wx_fmt=png&quot; data-nickname=&quot;腾讯技术&quot; data-alias=&quot;&quot; data-signature=&quot;分享腾讯有料的技术，做有趣的技术人&quot; data-from=&quot;0&quot;/&gt;&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>