<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>cb3a8058d0a1a8fd30b5801e2d60ed92</guid>
<title>为什么要鼓励重复造轮子？| 码农周刊第 327 期</title>
<link>https://toutiao.io/k/fvbrmmu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;issue&quot; id=&quot;readabilityBody&quot;&gt;
        &lt;h1&gt;为什么要鼓励重复造轮子？| 码农周刊第 327 期&lt;/h1&gt;
        &lt;h2&gt;码农周刊第327期（2020-12-23）&lt;/h2&gt;
        &lt;p&gt;☞ &lt;a href=&quot;https://weekly.manong.io/bounce?nid=327&amp;amp;aid=20216&amp;amp;url=http%3A%2F%2Fwww.huodongxing.com%2Fevent%2F1573487912300%3Fcoupon%3DMNZK&quot; target=&quot;_blank&quot;&gt;汇聚云计算、区块链、数据等技术顶级大咖！点击抢购&lt;font&gt;限时早鸟票&lt;/font&gt;！&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;a href=&quot;https://weekly.manong.io/bounce?nid=327&amp;amp;aid=20216&amp;amp;url=http%3A%2F%2Fwww.huodongxing.com%2Fevent%2F1573487912300%3Fcoupon%3DMNZK&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/qiniu_326.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;small&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=327&amp;amp;aid=19185&amp;amp;url=https%3A%2F%2Fjinshuju.net%2Ff%2FV7DxN9&quot; target=&quot;_blank&quot;&gt;商务合作&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
        
        &lt;h3 id=&quot;程序设计&quot;&gt;程序设计&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;关注云计算、数据、区块链三大技术主题，云集十余位业内大咖和顶尖技术人。&lt;font&gt;早鸟票限时抢购中&lt;/font&gt;&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;从 Druid 到 ClickHouse&lt;/p&gt;
        
        &lt;p&gt;实战总结&lt;/p&gt;
        
        &lt;p&gt;实践验证&lt;/p&gt;
        &lt;h3 id=&quot;VIP会员专区&quot;&gt;VIP会员专区&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;能够低成本、无侵入的收集代码覆盖率数据&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;通过它可以在异常时直接 dump 出一个迷你内存快照。快照中没有任何敏感信息，更重要的是文件非常小的同时数据也相对完整，非常适合离线分析 OOM 及其他类型异常的调查定位。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;适合新手&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;在传统的计算机科学课程中，从操作系统、编程语言到机器学习，这些高大上课程和主题已经非常多了。然而有一个至关重要的主题却很少被专门讲授，而是留给学生们自己去探索。这部分内容就是：精通工具。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;干货满满&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;工具资料&quot;&gt;工具资料&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;关注云计算、数据、区块链三大技术主题，云集十余位业内大咖和顶尖技术人。&lt;font&gt;早鸟票限时抢购中&lt;/font&gt;&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;Service Mesh 篇&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;入门介绍&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;图文并茂&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;经验总结&lt;/p&gt;
        
        &lt;p&gt;结合代码&lt;/p&gt;
        
        &lt;p&gt;代码示例&lt;/p&gt;
        
        &lt;p&gt;完整代码&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        &lt;h3 id=&quot;编程语言&quot;&gt;编程语言&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;关注云计算、数据、区块链三大技术主题，云集十余位业内大咖和顶尖技术人。&lt;font&gt;早鸟票限时抢购中&lt;/font&gt;&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;值得收藏&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;背景介绍&lt;/p&gt;
        
        &lt;p&gt;深入讲解&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;一步步教你&lt;/p&gt;
        
        &lt;p&gt;一步步教你&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;结合代码&lt;/p&gt;
        
        &lt;p&gt;适合新手&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        &lt;h3 id=&quot;每周独家号推荐&quot;&gt;每周独家号推荐&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 429587 即可&lt;/p&gt;
        
        &lt;p&gt;分享OPPO前沿互联网技术及活动&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 429344 即可&lt;/p&gt;
        
        &lt;p&gt;实时分享K8S等云原生技术、教程、资讯&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 392908 即可&lt;/p&gt;
        
        &lt;p&gt;一群靠谱的人，愿为phper带来一些值得细细品味的精神食粮&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 56197 即可&lt;/p&gt;
        
        &lt;p&gt;关注系统架构，做到实现功能、可靠、易用、高效率、可维护、可移植和优雅。&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 42200 即可&lt;/p&gt;
        &lt;h3 id=&quot;每周一书&quot;&gt;每周一书&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;本书从一些经典算法出发，为读者展示了 100 个 Python 趣味编程实例。欢迎到&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;兑换阅读。&lt;/p&gt;
        &lt;h3 id=&quot;编程之外&quot;&gt;编程之外&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;关注云计算、数据、区块链三大技术主题，云集十余位业内大咖和顶尖技术人。&lt;font&gt;早鸟票限时抢购中&lt;/font&gt;&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;欢迎探讨&lt;/p&gt;
        
        &lt;p&gt;经验总结&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;p&gt;
        &lt;/p&gt;
        
        
        
        
        &lt;div class=&quot;qrcode&quot;&gt;
  &lt;img src=&quot;https://img.toutiao.io/ads/vip_qrcode.png&quot; alt=&quot;Qrcode 258&quot;/&gt;&lt;span&gt;加入码农周刊VIP会员&lt;/span&gt;
&lt;/div&gt;
    &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6c7354be1671cbf92b65ca027ded182f</guid>
<title>数据智能的未来，是不提大数据但其无所不在的时代</title>
<link>https://toutiao.io/k/4yeshi4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4124860646599777&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8cHicoiacTv8LEYDw1vNOkQqDNWLcau8YCvEco375K13UdJ0uLAfOz4341Nacican7659BxxII4YhRoP6JpYPmoaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1794&quot;/&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;回首过去十年，我们见证了大数据从概念诞生到行业落地，逐渐发展到基于数据中台驱动决策的数据智能时代。作为后互联网时代的产物，数据智能必将是未来很长一个发展阶段的核心所在。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;每日互动（个推）作为数据智能行业的代表企业之一，于今年迎来了第一个十年。在这十年间，个推以消息推送起家，借助技术力量拓宽以数据智能为核心的业务范畴，现已成长为一家在A股上市的数据智能企业。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但“数据智能”这个词，对于大众来说仍然相对比较陌生。&lt;strong&gt;&lt;span&gt;数据行业资深从业者如何定义“数据智能”？过去的十年间，个推经历了怎么样的发展历程？即将到来的“数据智能”新十年，个推又将以什么样的角色参与当中？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在个推十周年之际，个推 CTO 叶新江针对上述疑问，与 SegmentFault 思否展开了一次对话。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-cropselx1=&quot;40&quot; data-cropselx2=&quot;372&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;294&quot; data-ratio=&quot;0.7125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8cHicoiacTv8LEYDw1vNOkQqDNWLcau8YC2kunpxjNEjJW3T9SqHH1Fmb8rqKRH8GgogPxpHsIGSyicBMZcCMoib9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;320&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;01&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;何谓“数据智能”？&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;em&gt;随着移动互联网时代的到来，互联网内容传播和展现形式发生了巨大的变化，也让数据的量级和形态发生了改变，数据服务也随之发生了转变。传统的数据服务基本只针对于数据本身，而数据智能作为一种由数据、算力和算法等驱动的技术手段，具备着赋能企业进行管理和决策的能力。&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Q1、数据智能是今年非常热门的一个话题，能否谈谈对于「数据智能」和「数据中台」的定义与理解？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;目前数据经济在国家层面是一个非常重要的发展方向，但同时也延伸出了一个亟待解决的问题 —— &lt;strong&gt;&lt;span&gt;如何把各个行业的数据作为生产要素，通过数据治理发挥出更进一步的作用。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;针对看不见摸不着的数据，需要有一个东西能进行有感管理，数据中台就是一种用来进行数据治理的产品或者平台，而数据智能则属于一个更为广义的范畴，它是以数据作为生产资料，通过结合大规模数据处理、数据挖掘、机器学习、人机交互、可视化、云计算等多种技术，从大量的数据中提炼、发掘、获取知识，为人们在制定决策时提供有效的支持，减少或者消除不确定性的解决方案。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这两个词看起来很接近，但其实是不同维度的。以我们公司来讲，数据中台更多的是一个产品，体现了我们公司的数据能力；而数据智能则包含更多技术，融合了更多的行业知识，中台是其中一个很重要的工具。打一个形象的比喻，数据中台或者平台是一个电脑的操作系统，而数据智能则是结合业务，使用这个电脑，利用多种技术进行APP开发，并且不断进行优化的过程。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Q2、您认为数据中台的「行业壁垒」和「技术壁垒」分别是什么？个推作为一个成功上市的专业数据智能服务公司，自身在这个领域内具备的最大优势是什么？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;目前市面上有很多数据中台类的产品，据我们观察，其中大部分的重点仍主要聚焦于数据治理的能力，但这可能只是数据中台的“第一步”。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于数据中台产品来讲，技术壁垒可能并不是很高。&lt;strong&gt;&lt;span&gt;中台会应用到的技术，虽然有些功能可以通过直接使用开源产品来实现，但也有不少标准或者要求，比如安全性、实时性、可视化能力等，需要专业的技术来定制实现。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当然在数据中台层面，采用的技术架构不同、产品设计的理念不同也是可以有差异的，譬如是否容易使用、容易理解、对资源要求是否经济等。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果希望通过数据中台中来解决业务问题，实现降本增效或者发现新的业务模式，这就不是数据治理能解决的问题，需要有对行业的深度理解，也就是所谓的行业壁垒。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;个推和其他大数据公司的差别，就体现在如何挖掘数据价值的层面。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;个推的第一款产品是消息推送服务，这是一项跟数据紧密相关的业务。为了支撑这项业务的进行，实现消息推送在海量数据量下的快速响应，个推一直在尝试为企业内部打造一个业务 + 数据平台的协同闭环。这也为之后公司推出数据服务产品打下了很好的基础。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5650429799426934&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8cHicoiacTv8LEYDw1vNOkQqDNWLcau8YC2YWCVB0D6gv8Qx9lNB0Xmg21iaxf55YxznryV8sA1uQD5vpwof4q4Lw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1745&quot;/&gt;&lt;/p&gt;&lt;p&gt;在数据服务层面，个推既是服务的提供者也是使用者，这是我们在这个领域内最大的优势。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Q3、数据服务领域是否有一套标准化的判定体系？如何评定服务能力与技术水平的高低？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;数据服务领域暂时还没有一套国际或者国家权威机构提出的行业标准。&lt;strong&gt;&lt;span&gt;究其原因，是因为数据服务在不同的行业间有着很大的差别，与一般的技术体系相比，具备更强的服务属性。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于客户来说，挑选数据服务的时候会有几个考量的维度：&lt;/p&gt;&lt;p&gt;● 平台是否可以快速部署；&lt;/p&gt;&lt;p&gt;●  部署所耗费的资源是否合理；&lt;/p&gt;&lt;p&gt;●  能否借助数据服务快速实现业务提升；&lt;strong&gt;&lt;span&gt;譬如是否能快速开发出业务的新需求，是否能很好地完成内部各个角色之间的协同。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这三项标准会是客户选择服务时的决策依据。但在选择完之后，服务商应该如何完成、如何实现客户提出的需求，因为没有清晰的界定与评判方式，需要客户在选型时进行综合性的考虑，并在后续实际的业务场景中去感受平台的服务能力。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这种情况其实也和市场需求有关。目前国内企业提出的需求都较为“定制化”，再加上不同行业间的差异，导致国内的数据服务公司大部分是结合行业提供垂直的数据服务能力。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;02&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;个推发展的每一步，踩的都是行业需求&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;我国的数字经济发展才刚刚开始，数据智能服务的能力也在不断迭代、发展。人工智能、区块链、知识图谱、可视化等新兴技术，都可以作为底层的技术支撑为数据智能服务赋能，从而让我们的数据服务具备更强大的能力，产生更多价值。&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;Q1、个推的发展经历了多个阶段，技术也在不断迭代和演进。能否简要分享一下不同阶段的业务逻辑重点以及技术研发重点？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;个推是我们的消息推送产品，做得比较早并且比较成熟了。但其实我们公司发展到现在已经十年了，业务范畴也早就不止是消息推送了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;公司发展的第一个阶段是 2010 年到 2013年。当时我们的核心团队主要是在打磨消息推送的能力，也就是一套大规模的通信系统 + 互联网搜索系统，这是一个比较垂直但对于技术要求很高的领域。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2014年至2018年，公司进入了数据价值的“掘金”与“实践”阶段。在不断精进推送能力的同时，我们发现系统产生了非常多的数据，如何让这些数据发挥价值成为了我们需要思考和解决的问题&lt;span&gt;&lt;strong&gt;。也是从这个阶段开始，个推开始致力于大数据系统的研发。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;个推的消息推送产品每天会产生几十个 T 的数据，如何存储、清洗、建模，如何在业务场景中产生商业化的价值，这是这一阶段我们的研发重点。经过几年的业务培养与场景实践，我们将在数据服务领域沉淀下来的能力和 know how（知识、经验、流程） ，变成一种可以服务于更多行业的产品，可以说公司正式进入到了数据智能的阶段。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2019年3月，每日互动成功在A股创业板上市，也引起了数据智能领域的一次新风潮。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.6666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8cHicoiacTv8LEYDw1vNOkQqDNWLcau8YCiaibk3x5Gbt6iaG6sicFsic5iaNSicT54DPGLnicOh4Jl9X1u71KWqkGVBAorg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在今年的疫情过程中，个推数据智能的能力得到了相当程度的验证。疫情期间，我们与李兰娟院士取得联系，与李兰娟院士团队合作成立联合战队。通过大数据技术，联合战队对疫情发展态势进行了研判，帮助疫情防控部门找到工作重点区域、重点人群和重点场景。在全国逐步有序恢复生产的时候，个推也充分发挥大数据能力并参与其中，为多个省份的疫情联防联控与民生保障、复工复产的有序统筹提供了决策参考依据。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当然，个推的数据智能服务仍然是在不断迭代发展的。随着人工智能、区块链、知识图谱、可视化等等新兴技术的发展，这项基于数据的服务也将产生更多的价值。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Q2、个推致力于打造“每日治数平台”，目标方向是什么样的？与一般的中台产品有什么区别？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;「每日治数平台」其实也是数据中台的概念，但我们提供的数据服务主要是应用于数据治理领域，所以命名为治数平台更为准确。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个平台还有一个提炼后的名字 —— &lt;strong&gt;&lt;span&gt;DMP。D 代表了数据（DATA），M 代表了 机器（MACHINE），而 P 则代表了人（PEOPLE）和专业（PRO）。&lt;/span&gt;&lt;/strong&gt;这几个关键词也代表了我们平台的定位，即数据作为底层资料，快速专业地服务于具体业务当中。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我国的数字经济发展其实才刚刚开始，据了解，不少企业并不知道该如何进行数字化、智能化的转型，业内也缺乏专业的数据人才。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因此，我们的目标方向和传统的数据中台不同。我们希望真正将个推 know how 的能力沉淀下来，形成客户可以复用的服务或平台产品。之所以想要打造这样的一个平台，背后其实也是基于用户的实际需求。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Q3、个推的第一个客户是哪家企业？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;个推消息推送业务的第一个客户是新浪微博。当时微博非常火，有着上亿的用户量，消息推送对他们来说是不可或缺的一项功能。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2011年，我们主动联系了微博相关业务的负责人，表示可以提供专业的消息推送服务，用更低的成本来实现更好的效果，这也是我们能够打动他们的原因。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;之所以第一个客户就敢挑战“行业顶配”的难度，一方面是技术团队自身具备扎实的技术基础和行业基础，另一方面就是前面提到的，我们在支持自身业务的过程当中沉淀下来的数据和技术能力。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;有这样一个需求明确的大客户，让我们的技术服务能力得以更加高效地迭代，大大加快了技术进步的速度。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;接受挑战并做到“极致”，正是我们公司的工程师文化，&lt;/span&gt;&lt;/strong&gt;对此我们感觉很自豪。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Q4、目前面向的客户群体有哪些，涉及哪些领域？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;随着数据能力的增强，以及对于行业理解的不断加深，&lt;span&gt;&lt;strong&gt;我们目前的服务客户已经扩展到四大领域 —— 互联网、公共服务、风控服务和品牌营销服务。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;以金融领域为例， 很多金融机构内部有自己的 App，涉及推送、统计、分析之类非常繁复的数据和信息处理场景。我们帮他们打造了一个集成的消息平台中心，解决了消息处理的分散问题，改善了工作流程。在深度沟通之后，我们发现数据智能服务在金融行业中是一个非常重度的业务场景，为此我们也在考虑开发专门针对金融行业的治数平台。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Q5、对于数据公司来说，数据安全是红线。个推如何保障数据安全性？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;个推团队自建立之初，便非常注重对于数据安全的保障。正如问题所说，数据安全对数据公司来说是红线，&lt;strong&gt;&lt;span&gt;个推始终认为保护用户数据隐私是企业必须要坚守和捍卫的行业准则、道德底线，并要时刻保持对数据安全的敬畏之心。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;个推在严格落实合规和监管要求的同时，倡导行业自律，积极联合行业伙伴的力量，共同推动行业的健康发展。今年8月，由个推牵头起草的《信息安全技术移动互联网应用程序（App）SDK安全指南》国家标准项目，获得全国信息安全标准化技术委员会正式立项，这将有助于SDK行业在开发、运营、信息处理、安全管理等环节向更规范的方向迈进。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.3907407&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8cHicoiacTv8LEYDw1vNOkQqDNWLcau8YCell3gJYEgOwq2fvnMlE9Sx2kpyibWPcXpS15GzWvp6Vs5YloXXwT93A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在今年的浙江省网络攻防演练当中，个推在395家参选企业中不借助外部安全公司的力量，仅凭公司自身的安全能力，便取得了第 14 名的成绩，还是很自豪的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;03&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;大数据的未来，是不提大数据但是数据又无处不在的时代，“你意识不到我的存在就是我最大的存在”&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;随着数据产业的规模越来越大，生态分工在未来将会越来越细，数据服务也将越来越细。而随着人工智能、云计算、物联网等技术的发展，大数据会不会和互联网一样，不再成为人们单独讨论的概念，而是成为像水电一样的基础设施，服务于各行各业中？&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;Q1、随着社会的发展，未来的数据会呈现多形态共存的状态。您认为未来几年大数据领域会出现什么样的一些变化？哪些因素将推动这些变化？你们的生态布局是怎么样的？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;随着 5G 的成熟，数据领域的发展将从基础的量变迎来一次质变，成为像水电一样的社会基础设施。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;近几年大家其实很少再单独讨论互联网的概念，其中的一个因素，我认为是互联网已经不再是新鲜事物，现阶段技术的发展基于互联网但又高于互联网，大数据之后的发展肯定也会这样，&lt;span&gt;&lt;strong&gt;数据智能的未来，虽然基于大数据，但是不会再单独讨论大数据的概念。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;从技术层面来看，大数据行业的发展对海量数据的存储、处理、挖掘需求肯定会越来越高，未来可能也会诞生出几个巨头，将行业进行更加明确的细分。这是一个大家已经能够观察到的趋势。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;随着数据产业的规模越来越大，生态分工在未来将会越来越明确，数据类的服务也将越来越精细化。我们打造的个推每日治数平台，就是希望能够参与到生态的建设当中，甚至围绕平台打造出一种新的生态。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Q2、业内最近有个观点：“云原生体系架构是云服务时代的数据管理方法论”，从技术角度来看，您如何评判云与数据智能间的关系？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;不同的人评价同一件事肯定会有不同的出发点，这个观点看起来应该是云服务厂商提出的（笑）。很巧，我前一阵也跟吉利公司的人在讨论这个问题，他们最近刚从一家云厂商中迁移出来。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对企业来说，上不上云、选择公有云还是私有云、选择哪家云厂商需要考虑几个维度：&lt;span&gt;&lt;strong&gt;成本吃不吃得消、是否自主可控、当不满足业务需求或者服务需求时是否方便切换等。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;以个推为例，我们目前不会将数据放到第三方的云上，但从资源的调度、成本的控制等方面来看，云体系已经是一个公认的标准答案，所以我们也会使用云计算的相关技术，比如容器云、虚拟化等。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Q3、物联网、AI、机器学习等新技术的出现，对行业来说是机会还是挑战？个推应对技术的发展是否有做哪些前瞻性的探索？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;新技术的出现，对行业来讲既是机会也是挑战。每次新技术的出现，都能为人类解放生产力或者提高生产力提供了可能性。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但一些技术因为过于“新”，暂时还没有找到发挥能力的场景，没办法发挥出实际的社会价值，让企业的投入与产出不成正比。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;个推还成立了数据智能研究院，目前研究的方向是探索如何将技术更好地服务于具体的业务当中。比如我们对物联网技术方向的探索，是想将自身的推送技术能力延伸到电视机、汽车等场景当中；对机器学习和区块链的探索则是为了进行一些业务模式的研究。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;技术是面向未来的，但用户的需求是现在的。&lt;/span&gt;&lt;/strong&gt;对于我们来说，目前的重点还是如何借助技术快速迭代服务能力，为用户以及行业赋能。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.74&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/8cHicoiacTv8LEYDw1vNOkQqDNWLcau8YCJn4ycqXKYeycLhW4bUDVWFt3hpTblyNWb9OJVJ9dC5JaLuU6icf8Y4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;300&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;回顾大数据行业和个推的发展时间线，不难发现个推成立的这十年，恰巧也是大数据从一种辅助工具向引领发展方向的核心引擎转变的十年。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;随着大数据行业的发展，国家正在大力发展数字经济，企业正在迎来一波借助数据智能实现数字化、智能化的转型新浪潮。&lt;strong&gt;&lt;span&gt;在这股浪潮中，开始“治数”的个推将会扮演一个什么样的角色？我们拭目以待。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;限时福利&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;在十周年之际，个推为广大开发者准备了重磅福利 —— &lt;strong&gt;&lt;span&gt;爆款SDK免费用1年、热门大数据产品0门槛试用！&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;点击阅读原文，&lt;/span&gt;&lt;/strong&gt;即可参与，还有丰富的惊喜礼盒限时领取！&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.1111111&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/8cHicoiacTv8LEYDw1vNOkQqDNWLcau8YCWNaQqxNkpxdoTJ7zOChMOI1eQmXicHrjgKIeoe427q9P7w1KcHPlDDA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;900&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MDc1MjcyMQ==&amp;amp;mid=2247484780&amp;amp;idx=1&amp;amp;sn=eb3f3e453559de485c34f4905f3927df&amp;amp;chksm=fc027452cb75fd44ab0a0f9fde3d66c6cb023315d14ec1eee2f8aabffc18651ed4af0fdeee49&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img data-ratio=&quot;0.25&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8cHicoiacTv8LEYDw1vNOkQqDNWLcau8YCUeeSyHPm4j04DTdIudpJ52QZqZ6OnFU6bptMDia1dPx2NicRvIOeBMQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MDc1MjcyMQ==&amp;amp;mid=2247486015&amp;amp;idx=1&amp;amp;sn=e117d4c8516166c1714badbaf663b2cf&amp;amp;chksm=fc027b01cb75f217d335734f2fb346a394b8901048cc651e9e3eb96db2600de26cadf21bba6f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img data-ratio=&quot;0.25&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8cHicoiacTv8LEYDw1vNOkQqDNWLcau8YCR7jk3TibdREDohUxSWDvmZCdPHXcllDEQE8SicUNSA1IKbOweefZzZKw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/8cHicoiacTv8JqGJmY1vPHn4JX87favPMp4hm8cibDwyJ0C0P4kvgeo97vk0etSPE6tUic4J0iaxuojABvxvlELLM0g/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.005128205128205&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/8cHicoiacTv8JVOE5ibzQy7MmiadREHZ5jdb7lnZHBwRicz7V79AywTRCpiaVb7dvLF4PtB6iaIsKNUxAuwic21BrTqiaSA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;390&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/8cHicoiacTv8LEYDw1vNOkQqDNWLcau8YCQd7NXZlYIzdHDRPdL3Om3VFmh3ppvpqrplD4Umq5SDDRRyJiaIXge0A/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;300&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;立即参与，&lt;strong&gt;&lt;span&gt;领取福利！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>40d60a84bbf611587ad67b8626240a94</guid>
<title>是时候捋一捋 Java 的深浅拷贝了</title>
<link>https://toutiao.io/k/moq9ag3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.5789473684210527&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dLdju2RRyOVZCt6JROGL4RbVO3K89gEd9AzQsXcxXJI38Id203kk5cPmcuyZAYGvmXN5hBf2TDKHZc9oOHId2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;38&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;点击上方&lt;span data-mid=&quot;&quot;&gt;蓝字&lt;/span&gt;关注俺呀呀&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.2142857142857142&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ZuN7LNJw9RwRTibaY0K2FdiaA3okcYyjLJibJE4Yw0QGUNL6Cm4dlhKQj26HdY9QbY3SKBUG3Ce5X0icnvLETaSCDA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;28&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;在开发、刷题、面试中，我们可能会遇到将一个对象的属性赋值到另一个对象的情况，这种情况就叫做拷贝。拷贝与Java内存结构息息相关，搞懂Java深浅拷贝是很必要的！&lt;/p&gt;&lt;p&gt;在对象的拷贝中，很多初学者可能搞不清到底是拷贝了引用还是拷贝了对象。在拷贝中这里就分为引用拷贝、浅拷贝、深拷贝进行讲述。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;引用拷贝&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;引用拷贝会生成一个新的对象引用地址，但是两个最终指向依然是同一个对象。如何更好的理解引用拷贝呢？很简单，就拿我们人来说，通常有个姓名，但是不同场合、人物对我们的叫法可能不同，但我们很清楚哪些名称都是属于&quot;我&quot;的！&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4524053224155578&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lia5wemIHThyibqO46LcpibicsfE5J7FLIzKcK8ibKljtrU71NbQ1HoJoVOCKticIOwtsJf2ZGHNNWkTySAYCphJQRpQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1954&quot; title=&quot;image-20201216222353944&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;当然，通过一个代码示例让大家领略一下(为了简便就不写get、set等方法)：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Son&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    String name;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; age;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Son&lt;/span&gt;&lt;span&gt;(String name, &lt;span&gt;int&lt;/span&gt; age)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.name = name;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.age = age;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;test&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Son s1 = &lt;span&gt;new&lt;/span&gt; Son(&lt;span&gt;&quot;son1&quot;&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;);&lt;br/&gt;        Son s2 = s1;&lt;br/&gt;        s1.age = &lt;span&gt;22&lt;/span&gt;;&lt;br/&gt;        System.out.println(s1);&lt;br/&gt;        System.out.println(s2);&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;s1的age:&quot;&lt;/span&gt; + s1.age);&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;s2的age:&quot;&lt;/span&gt; + s2.age);&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;s1==s2&quot;&lt;/span&gt; + (s1 == s2));&lt;span&gt;//相等&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出的结果为：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Son@135fbaa4&lt;br/&gt;Son@135fbaa4&lt;br/&gt;s1的&lt;span&gt;age:&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;&lt;br/&gt;s2的&lt;span&gt;age:&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;&lt;br/&gt;&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;浅拷贝&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;如何创建一个对象，将目标对象的内容复制过来而不是直接拷贝引用呢？&lt;/p&gt;&lt;p&gt;这里先讲一下&lt;strong&gt;浅拷贝&lt;/strong&gt;，浅拷贝会创建一个新对象，新对象和原对象本身没有任何关系，&lt;strong&gt;新对象和原对象不等，但是新对象的属性和老对象相同&lt;/strong&gt;。具体可以看如下区别：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;如果属性是基本类型(int,double,long,boolean等)，拷贝的就是基本类型的值；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果属性是引用类型，拷贝的就是内存地址（即复制引用但不复制引用的对象） ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;如果用一张图来描述一下浅拷贝，它应该是这样的：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.49494020239190434&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lia5wemIHThyibqO46LcpibicsfE5J7FLIzKrXcxaxXbf1nyD6pPiazmkObU9kSCp3WotVK4oMSzGrGNyLXxwFbia6LA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2174&quot; title=&quot;image-20201217002917565&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;如何实现浅拷贝呢？也很简单，&lt;strong&gt;就是在需要拷贝的类上实现Cloneable接口并重写其clone()方法&lt;/strong&gt;。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; Object &lt;span&gt;clone&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; CloneNotSupportedException &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;.clone();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在使用的时候直接调用类的clone()方法即可。具体案例如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Father&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    String name;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Father&lt;/span&gt;&lt;span&gt;(String name)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.name=name;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;toString&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Father{&quot;&lt;/span&gt; +&lt;br/&gt;                &lt;span&gt;&quot;name=&#x27;&quot;&lt;/span&gt; + name + &lt;span&gt;&#x27;\&#x27;&#x27;&lt;/span&gt; +&lt;br/&gt;                &lt;span&gt;&#x27;}&#x27;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Son&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Cloneable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; age;&lt;br/&gt;    String name;&lt;br/&gt;    Father father;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Son&lt;/span&gt;&lt;span&gt;(String name,&lt;span&gt;int&lt;/span&gt; age)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.age=age;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.name = name;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Son&lt;/span&gt;&lt;span&gt;(String name,&lt;span&gt;int&lt;/span&gt; age, Father father)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.age=age;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.name = name;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.father = father;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;toString&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Son{&quot;&lt;/span&gt; +&lt;br/&gt;                &lt;span&gt;&quot;age=&quot;&lt;/span&gt; + age +&lt;br/&gt;                &lt;span&gt;&quot;, name=&#x27;&quot;&lt;/span&gt; + name + &lt;span&gt;&#x27;\&#x27;&#x27;&lt;/span&gt; +&lt;br/&gt;                &lt;span&gt;&quot;, father=&quot;&lt;/span&gt; + father +&lt;br/&gt;                &lt;span&gt;&#x27;}&#x27;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; Son &lt;span&gt;clone&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; CloneNotSupportedException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; (Son) &lt;span&gt;super&lt;/span&gt;.clone();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;test&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; CloneNotSupportedException &lt;/span&gt;{&lt;br/&gt;        Father f=&lt;span&gt;new&lt;/span&gt; Father(&lt;span&gt;&quot;bigFather&quot;&lt;/span&gt;);&lt;br/&gt;        Son s1 = &lt;span&gt;new&lt;/span&gt; Son(&lt;span&gt;&quot;son1&quot;&lt;/span&gt;,&lt;span&gt;13&lt;/span&gt;);&lt;br/&gt;        s1.father=f;&lt;br/&gt;        Son s2 = s1.clone();&lt;br/&gt;&lt;br/&gt;        System.out.println(s1);&lt;br/&gt;        System.out.println(s2);&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;s1==s2:&quot;&lt;/span&gt;+(s1 == s2));&lt;span&gt;//不相等&lt;/span&gt;&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;s1.name==s2.name:&quot;&lt;/span&gt;+(s1.name == s2.name));&lt;span&gt;//相等&lt;/span&gt;&lt;br/&gt;        System.out.println();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;//但是他们的Father father 和String name的引用一样&lt;/span&gt;&lt;br/&gt;        s1.age=&lt;span&gt;12&lt;/span&gt;;&lt;br/&gt;        s1.father.name=&lt;span&gt;&quot;smallFather&quot;&lt;/span&gt;;&lt;span&gt;//s1.father引用未变&lt;/span&gt;&lt;br/&gt;        s1.name=&lt;span&gt;&quot;son222&quot;&lt;/span&gt;;&lt;span&gt;//类似 s1.name=new String(&quot;son222&quot;) 引用发生变化&lt;/span&gt;&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;s1.Father==s2.Father:&quot;&lt;/span&gt;+(s1.father == s2.father));&lt;span&gt;//相等&lt;/span&gt;&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;s1.name==s2.name:&quot;&lt;/span&gt;+(s1.name == s2.name));&lt;span&gt;//不相等&lt;/span&gt;&lt;br/&gt;        System.out.println(s1);&lt;br/&gt;        System.out.println(s2);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行结果为：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Son{age=&lt;span&gt;13&lt;/span&gt;, name=&lt;span&gt;&#x27;son1&#x27;&lt;/span&gt;, father=Father{name=&lt;span&gt;&#x27;bigFather&#x27;&lt;/span&gt;}}&lt;br/&gt;Son{age=&lt;span&gt;13&lt;/span&gt;, name=&lt;span&gt;&#x27;son1&#x27;&lt;/span&gt;, father=Father{name=&lt;span&gt;&#x27;bigFather&#x27;&lt;/span&gt;}}&lt;br/&gt;s1==s2:&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;s1.name==s2.name:&lt;span&gt;true&lt;/span&gt;&lt;span&gt;//此时相等&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;s1.Father==s2.Father:&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;s1.name==s2.name:&lt;span&gt;false&lt;/span&gt;&lt;span&gt;//修改引用后不等&lt;/span&gt;&lt;br/&gt;Son{age=&lt;span&gt;12&lt;/span&gt;, name=&lt;span&gt;&#x27;son222&#x27;&lt;/span&gt;, father=Father{name=&lt;span&gt;&#x27;smallFather&#x27;&lt;/span&gt;}}&lt;br/&gt;Son{age=&lt;span&gt;13&lt;/span&gt;, name=&lt;span&gt;&#x27;son1&#x27;&lt;/span&gt;, father=Father{name=&lt;span&gt;&#x27;smallFather&#x27;&lt;/span&gt;}}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不出意外，这种浅拷贝除了对象本身不同以外，各个零部件和关系和拷贝对象都是相同的，就好像双胞胎一样，是两个人，但是其开始的样貌、各种关系(父母亲人)都是相同的。&lt;strong&gt;需要注意&lt;/strong&gt;的是其中name初始&lt;code&gt;==&lt;/code&gt;是相等的，是因为初始浅拷贝它们指向一个相同的String，而后&lt;code&gt;s1.name=&quot;son222&quot;&lt;/code&gt; 则改变引用指向。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5249221183800623&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lia5wemIHThyibqO46LcpibicsfE5J7FLIzKP60xBG4AP0u9eRxTSPx8BibPCHtBF6rHKGd5WPBsU2zrhQ9EssmGxLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1284&quot; title=&quot;image-20201217103648400&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;&lt;span&gt;深拷贝&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;对于上述的问题虽然拷贝的两个对象不同，但其内部的一些引用还是相同的，怎么样绝对的拷贝这个对象，使这个对象完全独立于原对象呢？就使用我们的深拷贝了。深拷贝：&lt;strong&gt;在对引用数据类型进行拷贝的时候，创建了一个新的对象，并且复制其内的成员变量。&lt;/strong&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.42483660130718953&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lia5wemIHThyibqO46LcpibicsfE5J7FLIzKr4jnrsUURq6FhcG4QuznmIrwOQvueK5ia5MRCEbsIGfbgGrYonRFNAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2142&quot; title=&quot;image-20201217111300466&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;在具体实现深拷贝上，这里提供两个方式，重写clone()方法和序列法。&lt;/p&gt;&lt;h5&gt;&lt;span&gt;重写clone()方法&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;如果使用重写clone()方法实现深拷贝，那么要将类中所有自定义引用变量的类也去实现Cloneable接口实现clone()方法。对于字符类可以创建一个新的字符串实现拷贝。&lt;/p&gt;&lt;p&gt;对于上述代码，Father类实现Cloneable接口并重写clone()方法。&lt;strong&gt;son的clone()方法需要对各个引用都拷贝一遍&lt;/strong&gt;。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;//Father clone()方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; Father &lt;span&gt;clone&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; CloneNotSupportedException &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; (Father) &lt;span&gt;super&lt;/span&gt;.clone();&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;//Son clone()方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; Son &lt;span&gt;clone&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; CloneNotSupportedException &lt;/span&gt;{&lt;br/&gt;    Son son= (Son) &lt;span&gt;super&lt;/span&gt;.clone();&lt;span&gt;//待返回拷贝的对象&lt;/span&gt;&lt;br/&gt;    son.name=&lt;span&gt;new&lt;/span&gt; String(name);&lt;br/&gt;    son.father=father.clone();&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; son;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其他代码不变，执行结果如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Son{age=13, name=&lt;span&gt;&#x27;son1&#x27;&lt;/span&gt;, father=Father{name=&lt;span&gt;&#x27;bigFather&#x27;&lt;/span&gt;}}&lt;br/&gt;Son{age=13, name=&lt;span&gt;&#x27;son1&#x27;&lt;/span&gt;, father=Father{name=&lt;span&gt;&#x27;bigFather&#x27;&lt;/span&gt;}}&lt;br/&gt;s1==s2:&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;s1.name==s2.name:&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;s1.Father==s2.Father:&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;s1.name==s2.name:&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;Son{age=12, name=&lt;span&gt;&#x27;son222&#x27;&lt;/span&gt;, father=Father{name=&lt;span&gt;&#x27;smallFather&#x27;&lt;/span&gt;}}&lt;br/&gt;Son{age=13, name=&lt;span&gt;&#x27;son1&#x27;&lt;/span&gt;, father=Father{name=&lt;span&gt;&#x27;bigFather&#x27;&lt;/span&gt;}}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5&gt;&lt;span&gt;序列化&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;可以发现这种方式实现了深拷贝。但是这种情况有个问题，如果引用数量或者层数太多了怎么办呢？&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.8809523809523809&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lia5wemIHThyibqO46LcpibicsfE5J7FLIzKXucf1AtIsLFBfoLCxFMabB7c9NkWKiaQiaRPgltbGjztGIGhu3ddPiagQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1176&quot; title=&quot;image-20201217105458651&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;不可能去每个对象挨个写clone()吧？那怎么办呢？借助序列化啊。&lt;/p&gt;&lt;p&gt;因为序列化后：将二进制字节流内容写到一个媒介（文本或字节数组），然后是从这个媒介读取数据，原对象写入这个媒介后拷贝给clone对象，原对象的修改不会影响clone对象，因为clone对象是从这个媒介读取。&lt;/p&gt;&lt;p&gt;熟悉对象缓存的知道我们经常将Java对象缓存到Redis中，然后还可能从Redis中读取生成Java对象，这就用到序列化和反序列化。一般可以将Java对象存储为字节流或者json串然后反序列化成Java对象。因为序列化会储存对象的属性但是&lt;strong&gt;不会也无法存储对象在内存中地址相关信息&lt;/strong&gt;。所以在反序列化成Java对象时候会重新创建所有的引用对象。&lt;/p&gt;&lt;p&gt;在具体实现上，自定义的类&lt;strong&gt;需要实现Serializable接口&lt;/strong&gt;。在需要深拷贝的类(Son)中定义一个函数返回该类对象：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; Son &lt;span&gt;deepClone&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException, ClassNotFoundException &lt;/span&gt;{&lt;br/&gt;      Son son=&lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;//在内存中创建一个字节数组缓冲区，所有发送到输出流的数据保存在该字节数组中&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;//默认创建一个大小为32的缓冲区&lt;/span&gt;&lt;br/&gt;      ByteArrayOutputStream byOut=&lt;span&gt;new&lt;/span&gt; ByteArrayOutputStream();&lt;br/&gt;      &lt;span&gt;//对象的序列化输出&lt;/span&gt;&lt;br/&gt;      ObjectOutputStream outputStream=&lt;span&gt;new&lt;/span&gt; ObjectOutputStream(byOut);&lt;span&gt;//通过字节数组的方式进行传输&lt;/span&gt;&lt;br/&gt;      outputStream.writeObject(&lt;span&gt;this&lt;/span&gt;);  &lt;span&gt;//将当前student对象写入字节数组中&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;//在内存中创建一个字节数组缓冲区，从输入流读取的数据保存在该字节数组缓冲区&lt;/span&gt;&lt;br/&gt;      ByteArrayInputStream byIn=&lt;span&gt;new&lt;/span&gt; ByteArrayInputStream(byOut.toByteArray()); &lt;span&gt;//接收字节数组作为参数进行创建&lt;/span&gt;&lt;br/&gt;      ObjectInputStream inputStream=&lt;span&gt;new&lt;/span&gt; ObjectInputStream(byIn);&lt;br/&gt;      son=(Son) inputStream.readObject(); &lt;span&gt;//从字节数组中读取&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;  son;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用时候调用我们写的方法即可，其他不变，实现的效果为：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Son{age=13, name=&lt;span&gt;&#x27;son1&#x27;&lt;/span&gt;, father=Father{name=&lt;span&gt;&#x27;bigFather&#x27;&lt;/span&gt;}}&lt;br/&gt;Son{age=13, name=&lt;span&gt;&#x27;son1&#x27;&lt;/span&gt;, father=Father{name=&lt;span&gt;&#x27;bigFather&#x27;&lt;/span&gt;}}&lt;br/&gt;s1==s2:&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;s1.name==s2.name:&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;s1.Father==s2.Father:&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;s1.name==s2.name:&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;Son{age=12, name=&lt;span&gt;&#x27;son222&#x27;&lt;/span&gt;, father=Father{name=&lt;span&gt;&#x27;smallFather&#x27;&lt;/span&gt;}}&lt;br/&gt;Son{age=13, name=&lt;span&gt;&#x27;son1&#x27;&lt;/span&gt;, father=Father{name=&lt;span&gt;&#x27;bigFather&#x27;&lt;/span&gt;}}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然这是对象的拷贝，对于数组的拷贝将在下一篇进行更细致的研究！敬请期待！&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/h2&gt;&lt;section&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2MTE1NjA2Mg==&amp;amp;mid=2247485697&amp;amp;idx=1&amp;amp;sn=2de52beeea8b5c1458a44e0086267471&amp;amp;chksm=ce1a2eb0f96da7a64aa86eb00779940f2b054127d4f2ba5eba28be6c2f6f8b966018566d0ddd&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;面试官本想拿一道求素数搞我，但被我优雅的&quot;回击&quot;了&lt;/strong&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2MTE1NjA2Mg==&amp;amp;mid=2247485341&amp;amp;idx=1&amp;amp;sn=9322f5ea2eca0fb3f6927d87c3b532fb&amp;amp;chksm=ce1a202cf96da93a615868dba376b98d77561b88cdcc776bd58c4dd8e00d52b9b9267ad9f3a1&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;strong&gt; 16张图带你彻底搞懂基数排序&lt;/strong&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2MTE1NjA2Mg==&amp;amp;mid=2247485575&amp;amp;idx=1&amp;amp;sn=5bf1be2af6213ee546c0435b92af149d&amp;amp;chksm=ce1a2f36f96da620957e0bf9ec87edc23087bc49800ed2456f41d3495cb16fcf7f1c2b707074&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;strong&gt;「干货总结」程序员必知必会的十大排序算法&lt;/strong&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2MTE1NjA2Mg==&amp;amp;mid=2247485682&amp;amp;idx=1&amp;amp;sn=e7959e1367394eb6f3a8fe37aa109cb1&amp;amp;chksm=ce1a2f43f96da6554a60ab9ce7f37ad26992ed2b9791693dd4d7e50fb7efc44e88ac77b3e2c0&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;strong&gt;花5分钟看这篇之前,你才发现你不懂RESTful&lt;/strong&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2MTE1NjA2Mg==&amp;amp;mid=2247485648&amp;amp;idx=1&amp;amp;sn=8ef9e4eb5dab360695a637b37ed488e2&amp;amp;chksm=ce1a2f61f96da6770494c1c2041efeb525ba1743cb00e733d57e62e47021f28e5da188a0d853&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;「五大常用算法」一文图解分治算法和思想&lt;/a&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;记得关注、咱们下次再见！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3579175704989154&quot; data-type=&quot;png&quot; data-w=&quot;2766&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lia5wemIHThxnTyOzzdibsIIhOb7FJJ4DqfczTibcsLSg6DHic9tJibhxBnjSVDDFmwpoRyQOiagY32aFxia190zIUiaLQ/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.9354838709677419&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pzXcQtZJNFv2HrgJ7ZwMzgeB9QByfWTxydpkuOicXKlUjZp9HpFFlT50ibBdIicCSmkW2ibibJpb1M1d5aRe9MfcXbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;62&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;点个&lt;span data-mid=&quot;&quot;&gt;在看&lt;/span&gt;你最好看&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.3695652173913043&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/sTJptKvBQLK8kA6B8BvyhLBiaicqchp7g1uS8Rv3VRyH7IOz0icMV5eoM23cyJWbicIaSjaxhABIbHvRp2736iaFcmicTq9GXganwC/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;46&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a59dc608ebd5c7fd9f4e8161baf719de</guid>
<title>Pulsar 和 Kafka 基准测试：Pulsar 性能精准解析（完整版）</title>
<link>https://toutiao.io/k/ntpn1n8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;blockquote&gt;&lt;h1&gt;关于 Apache Pulsar&lt;/h1&gt;&lt;p&gt;Apache Pulsar 是 Apache 软件基金会顶级项目，是下一代云原生分布式消息流平台，集消息、存储、轻量化函数式计算为一体，采用计算与存储分离架构设计，支持多租户、持久化存储、多机房跨区域数据复制，具有强一致性、高吞吐、低延时及高可扩展性等流数据存储特性。&lt;br/&gt;当前已有众多国内外大型互联网和传统行业公司采用 Apache Pulsar，案例分布在人工智能、金融、电信运营商、直播与短视频、物联网、零售与电子商务、在线教育等多个行业，如美国有线电视网络巨头 Comcast、Yahoo！、腾讯、中国电信、中国移动、BIGO、VIPKID 等。&lt;/p&gt;&lt;/blockquote&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;Confluent 最近开展了一次基准测试，对比 Kafka、Pulsar 和 RabbitMQ 的吞吐量和延迟差异。&lt;/span&gt;&lt;span&gt;Confluent 博客显示，Kakfa 能够以“低延迟”实现“最佳吞吐量”，而 RabbitMQ 能够以“较低的吞吐量” 达到 “低延迟”。&lt;/span&gt;&lt;span&gt;总体而言，基准测试结果显示 Kafka 在“速度”方面无疑更胜一筹。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Kafka 技术成熟完善，但当今众多公司（从跨国公司到创新型初创公司）还是首先选择了 Pulsar。在近期举办的 Splunk 峰会 conf20 上，Splunk 公司首席产品官 Sendur Sellakumar 对外宣布，他们决定用 Pulsar 取代 Kafka：&lt;/p&gt;&lt;p&gt;“... 我们已把 Apache Pulsar 作为基础流。我们把公司的前途压在了企业级多租户流的长期架构上。”&lt;/p&gt;&lt;p&gt;--Splunk 首席产品官 Sendur Sellakumar&lt;/p&gt;&lt;p&gt;很多公司都在使用 Pulsar，Splunk 只是其中一例。这些公司之所以选择 Pulsar，是因为在现代弹性云环境（如 Kubernetes）中，Pulsar 能够以经济有效的方式横向扩展处理海量数据，不存在单点失效的问题。同时，Pulsar 具有诸多内置特性，诸如数据自动重平衡、多租户、跨地域复制和持久化分层存储等，不仅简化了运维，同时还让团队更容易专注于业务目标。&lt;/p&gt;&lt;p&gt;开发者们最终选择 Pulsar 是因为 Pulsar 这些独特的功能和性能，让 Pulsar 成了流数据的基石。&lt;/p&gt;&lt;p&gt;了解了这些情况后，还需仔细研究 Confluent 的基准测试设置和结论。我们发现有两个问题存在高度争议。其一，Confluent 对 Pulsar 的了解有限，这正是造成结论不准确的最大根源。如不了解 Pulsar，就不能用正确的衡量标准来测试 Pulsar 性能。&lt;/p&gt;&lt;p&gt;其二，Confluent 的性能测试基于一组狭窄的测试参数。这限制了结果的适用性，也无法为读者提供不同工作负载和实际应用场景相匹配的准确结果。&lt;/p&gt;&lt;p&gt;为了向社区提供更准确的测试结果，我们决定解决这些问题并重复测试。重要调整包括：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;我们调整了基准测试设置，包含了 Pulsar 和 Kafka 支持的各持久性级别，在同一持久性级别下对比两者的吞吐量和延迟。&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;我们修复了 OpenMessaging 基准测试（OMB）框架，消除因运用不同实例产生的变量，并纠正了 OMB Pulsar 驱动程序中的配置错误。&lt;/span&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;最后，我们测量了其他性能因素和条件，例如分区的不同数量和包含 write、tailing-read 和 catch-up read 的混合工作负载，更全面地了解性能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;完成这些工作之后，我们重复了测试。测试结果显示，对于更接近真实工作负载的场景，Pulsar 的性能明显优于 Kafka，而对于 Confluent 在测试中所应用的基本场景，Pulsar 性能与 Kafka 性能相当。&lt;/p&gt;&lt;p&gt;以下各部分将重点说明本次测试得出的最重要结论。在 StreamNative 基准测试结果章节，我们详细介绍了测试设置和测试报告。&lt;/p&gt;&lt;h1&gt;StreamNative 基准测试结果概要&lt;/h1&gt;&lt;p&gt;1、在与 Kafka 的持久性保证相同的情况下，Pulsar 可达到 605 MB/s 的发布和端到端吞吐量（与 Kafka 相同）以及 3.5 GB/s 的 catch-up read 吞吐量（比 Kafka 高 3.5 倍）。Pulsar 的吞吐量不会因分区数量的增加和持久性级别的改变而受到影响，而 Kafka 的吞吐量会因分区数量或持久性级别的改变而受到严重影响。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7348377997179125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0EIbbCE3P2ZHTzKW1XL5gLxMQH27cPoiajLIpiaqmqyXTVIpV9Uj5JXCHNZRup1a60fRlU8OfX4D0ialpnaNm4X9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1418&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;表 1：在不同工作负载及不同持久性保证下，Pulsar 与 Kafka 的吞吐量差异&lt;/span&gt;&lt;/p&gt;&lt;p&gt;2、在不同的测试实例（包括不同订阅数量、不同主题数量和不同持久性保证）中，Pulsar 的延迟显著低于 Kafka。PulsarP99 延迟在 5 到 15 毫秒之间。KafkaP99 延迟可能长达数秒，并且会因主题数量、订阅数量和不同持久性保证而受到巨大影响。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.976878612716763&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0EIbbCE3P2ZHTzKW1XL5gLxMQH27cPoiac3XUa9WDLUF9NBjaZdXppcIEXNaEU6gkjAicM4OwPgETqfMWoKCgTog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1384&quot; title=&quot;null&quot; data-backw=&quot;562&quot; data-backh=&quot;549&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;表 2：在不同订阅数量及不同持久性保证下，Pulsar 与 Kafka 端到端 P99 延迟差异&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1.0115440115440115&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0EIbbCE3P2ZHTzKW1XL5gLxMQH27cPoiagE40HZoMLJo735ic9l9MOWHX0SscDq4ibBh3jTGLLibSTgbqyJkCTEnPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1386&quot; title=&quot;null&quot; data-backw=&quot;562&quot; data-backh=&quot;568&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;表 3：在不同主题数量及不同持久性保证下，Pulsar 与 Kafka 端到端 P99 延迟差异&lt;/span&gt;&lt;/p&gt;&lt;p&gt;3、Pulsar 的 I/O 隔离显著优于 Kafka。在有消费者 catch up 读取历史数据时，PulsarP99 发布延迟仍然在 5 毫秒左右。相比之下，Kafka 的延迟会因 catch up read 而受到严重影响。KafkaP99 发布延迟可能会从几毫秒增加到几秒。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5624103299856528&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0EIbbCE3P2ZHTzKW1XL5gLxMQH27cPoiaBHVxHk5RoPWIGj1NH84ibbmAqvGZap9Nd5Kyg7BmhGl9dItLrZiawBqQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1394&quot; title=&quot;null&quot; data-backw=&quot;562&quot; data-backh=&quot;316&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;表 4：在 catch up read 下，Pulsar 和 Kafka P99 发布延迟差异&lt;/span&gt;&lt;/p&gt;&lt;p&gt;我们所有的基准测试均 开源（ &lt;span&gt;Github 网址&lt;sup&gt;[1]&lt;/sup&gt;&lt;/span&gt;），感兴趣的读者可以自行生成结果，也可更深入研究该测试结果及仓库中提供的指标。&lt;/p&gt;&lt;p&gt;尽管我们的基准测试比 Confluent 的基准测试更准确全面，但并未涵盖全部场景。归根结底，通过自己的硬件 / 实际工作负载进行的测试，是任何一个基准测试都替代不了的。我们也鼓励各位读者评估其他变量和场景，并利用自己的设置和环境进行测试。&lt;/p&gt;&lt;h1&gt;深入探究 Confluent 基准测试&lt;/h1&gt;&lt;p&gt;Confluent 将 OpenMessaging 基准测试（OMB）框架 作为其基准测试的依据，并进行了一些修改。在本节中，我们将说明在 Confluent 基准测试中发现的问题，并阐述这些问题如何影响 Confluent 测试结果的准确性。&lt;/p&gt;&lt;h2&gt;Confluent 的设置问题&lt;/h2&gt;&lt;p&gt;Confluent 基准测试结论不正确是因为 Pulsar 参数设置不合理。我们会在 StreamNative 基准测试部分详细讲解这些问题。除了 Pulsar 调优问题，Confluent 针对 Pulsar 和 Kafka 设置了不同的持久性保证。持久性级别会影响性能，两个系统的持久性设置相同，对比才具有参考价值。&lt;/p&gt;&lt;p&gt;Confluent 工程师对 Pulsar 采用默认持久性保证，该保证比 Kafka 的持久性级别高。增加持久性级别会严重影响延迟和吞吐量，所以 Confluent 测试对 Pulsar 提出了比 Kafka 更高的要求。Confluent 使用的 Pulsar 版本尚不支持将持久性降低到与 Kafka 相同的级别，但 Pulsar 即将发布的版本支持该级别，在本次测试中也使用了该级别。如果 Confluent 工程师在两个系统上使用的持久性设置相同，那么测试结果显示的对比应该是准确的。我们当然不会因 Confluent 工程师未使用尚未发布的功能而指责他们。然而，测试记录并不能提供必要的情景，而且将其视为同等持久性设置的结果。本文会提供额外的情境说明。&lt;/p&gt;&lt;h2&gt;OMB 框架问题&lt;/h2&gt;&lt;p&gt;Confluent 基准测试遵循 OMB 框架指南，该指南建议在多个事件流系统中使用同一实例类型。但在测试中，我们发现同一类型的不同实例存在大量偏差，尤其是发生磁盘 I/O 故障的情况下。为了最大程度地减少这种差异，我们在每次运行 Pulsar 和 Kafka 时都使用了相同实例，我们发现这些实例在很大程度上改进了结果的准确性，磁盘 I/O 性能的微小差异可能会对系统整体性能造成较大差异。我们提议更新 OMB 框架指南，并在未来考虑采用这个建议。&lt;/p&gt;&lt;h2&gt;Confluent 研究方法的问题&lt;/h2&gt;&lt;p&gt;Confluent 基准测试仅测试了几种有限的场景。例如，实际工作负载包括写入、tailing read 和 catch-up read。当某一消费者正在读取日志“尾部”附近的最新消息时，即发生 tailing-read，Confluent 只测试了这一种场景。相比之下，catch-up read 在消费者有大量历史消息时发生，必须消耗至 “catch-up”位置到日志的尾部消息，这是实际系统中常见的关键任务。如果不考虑 catch-up read，则会严重影响写入和 tailing read 的延迟。由于 Confluent 基准测试只关注吞吐量和端到端延迟，所以未能就各种工作负载下的预期行为提供全面结果。为了进一步让结果更接近实际应用场景，我们认为对不同数量的订阅和分区进行基准测试至关重要。很少有企业只关心具有几个分区和消费者的少量主题，他们需要有能力容纳具有不同主题 / 分区的大量不同消费者，以映射到业务用例中。&lt;/p&gt;&lt;p&gt;我们在下表中概述了 Confluent 研究方法的具体问题。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.45609065155807366&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0EIbbCE3P2ZHTzKW1XL5gLxMQH27cPoiacQKrAicrqp1icdySlYfk3050BSJl9or4icoBWkEUskZuCZOkbwuF2icJ7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1412&quot; title=&quot;null&quot; data-backw=&quot;562&quot; data-backh=&quot;257&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;表 5：Confluent 基准测试研究方法的问题4&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Confluent 基准测试的诸多问题源于对 Pulsar 的了解有限。为帮助大家后续开展基准测试时避免这些问题，我们和大家分享一些 Pulsar 技术见解。&lt;/p&gt;&lt;p&gt;为了开展准确的基准测试，需了解 Pulsar 的持久性保证。我们将以此问题作为切入点进行探讨，先总体概述分布式系统的持久性，然后说明 Pulsar 和 Kafka 在持久性保证上的差异。&lt;/p&gt;&lt;h1&gt;分布式系统持久性概述&lt;/h1&gt;&lt;p&gt;持久性是指在面对诸如硬件或操作系统故障等外部问题时，对系统一致性和可用性的维持能力。诸如 RDBMS 单节点存储系统依靠 fsync 写入磁盘来确保最大的持久性。操作系统通常会缓存写入，在发生故障时，写入可能会丢失，但 fsync 将确保将这些数据写入物理存储中。在分布式系统中，持久性通常来自数据复制，即将数据的多个副本分布到可独立失效的不同节点。但不应将本地持久性（fsync 数据）与复制持久性混为一谈，两者目的不同。接下来我们会解释这些特性的重要性及主要区别。&lt;/p&gt;&lt;h2&gt;复制持久性和本地持久性&lt;/h2&gt;&lt;p&gt;分布式系统通常同时具备复制持久性和本地持久性。各种类型的持久性由单独的机制控制。可以灵活组合使用这些机制，根据需要设置不同的持久性级别。&lt;/p&gt;&lt;p&gt;复制持久性通过一种算法创建数据的多个副本实现，所以同一数据可存储在多个位置，可用性和可访问性均得以提高。副本的数量 N 决定了系统的容错能力，很多系统需要“仲裁”或 N/2 + 1 个节点来确认写入。在任何单个副本仍然可用的情况下，一些系统可以继续服务现有数据。这种复制机制对于处理彻底丢失实例数据至关重要，新实例可从现有副本中重新复制数据，这对可用性和共识性也至关重要（本节不展开探讨该问题）。&lt;/p&gt;&lt;p&gt;相比之下，本地持久性决定了各个节点级别对确认的不同理解。本地持久性要求把数据 fsync 到持久存储，确保即使发生断电或硬件故障，也不会丢失任何数据。数据的 fsync 可确保机器在短时间内出现故障恢复后，节点拥有先前确认的全部数据。&lt;/p&gt;&lt;h2&gt;持久性模式：同步和异步&lt;/h2&gt;&lt;p&gt;不同类型的系统提供不同级别的持久性保证。通常，系统的整体持久性受以下因素影响：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;系统是否将数据 fsync 到本地磁盘&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;系统是否将数据复制到多个位置&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;系统何时确认复制到对等系统&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;系统何时确认写入客户端&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在不同的系统中，这些选择差异很大，并非所有系统都支持用户控制这些值。缺少其中某些机制的系统（例如非分布式系统中的复制），持久性更低。&lt;/p&gt;&lt;p&gt;我们可以定义两种持久性模式，两者均可控制系统何时确认写入供内部复制，以及何时写入到客户端，即“同步”和“异步”。这两种模式操作如下。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;同步持久性：仅在数据成功 fsync 到本地磁盘（本地持久性）或复制到多个位置（复制持久性）后，系统才向对等系统 / 客户端返回写入响应。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;异步持久性：在数据成功 fsync 到本地磁盘（本地持久性）或复制到多个位置（复制持久性）前，系统会向对等系统 / 客户端返回写入响应。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;持久性级别：测量持久性保证&lt;/h2&gt;&lt;p&gt;持久性保证以多种形式存在，这取决于以下变量：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;数据是否存储在本地，是否在多个位置复制或符合这两种情况&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;何时确认写入（同步 / 异步）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;与持久性模式一样，为区分不同的分布式系统，我们为持久性定义了四个级别。表 6 列出了从最高持久性到最低持久性的各个级别。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5942857142857143&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0EIbbCE3P2ZHTzKW1XL5gLxMQH27cPoiaA7GecFlUYXFGTSL0yvtn2r55GUIUicAh9SB1RnYS97C6DKU8MiaJcYcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1400&quot; title=&quot;null&quot; data-backw=&quot;562&quot; data-backh=&quot;334&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;表 6：分布式系统的持久性级别&lt;/span&gt;&lt;/p&gt;&lt;p&gt;多数分布式关系数据库管理系统（例如 NewSQL 数据库）均可保证最高级别的持久性，所以将这类系统归为 1 级。&lt;/p&gt;&lt;p&gt;与数据库一样，Pulsar 属于 1 级系统，默认提供最高级别的持久性。此外，Pulsar 可针对每种应用分别自定义所需的持久性级别。相比之下，Kafka 大部分的生产环境部署都配置在 2 级或 4 级。据悉，通过设置 &lt;code&gt;flush.messages=1&lt;/code&gt; 和 &lt;code&gt;flush.ms=0&lt;/code&gt;，Kafka 也能达到 1 级标准。但这两项配置会严重影响吞吐量和延迟，我们会在基准测试中详细讨论这个问题。&lt;/p&gt;&lt;p&gt;下面我们从 Pulsar 入手，详细探究各系统的持久性。&lt;/p&gt;&lt;h2&gt;Pulsar 的持久性&lt;/h2&gt;&lt;p&gt;Pulsar 提供各级别的持久性保证，可将数据复制到多个位置，并将数据 fsync 到本地磁盘。Pulsar 拥有两种持久性模式（即上文所述的同步和异步）。用户可以根据使用场景自定义设置，单独使用某一模式，或组合使用。&lt;/p&gt;&lt;p&gt;Pulsar 利用筏等效、基于仲裁的复制协议来控制复制的持久性。通过调整 &lt;code&gt;ack-quorum-size&lt;/code&gt; 和 &lt;code&gt;write-quorum-size&lt;/code&gt; 参数可以调整复制持久性模式。表 7 列出了这些参数的设置，表 8 列出了 Pulsar 支持的持久性级别。（Pulsar 复制协议和共识算法不属于本文探讨范围，我们会在后续的博客中深入探讨该领域。）&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5329512893982808&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0EIbbCE3P2ZHTzKW1XL5gLxMQH27cPoiamoINTjzomzzBAr1NbknD2LhZmetljicdeKxyFq65Hm2iaJqiaT0ZicKeHQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1396&quot; title=&quot;null&quot; data-backw=&quot;562&quot; data-backh=&quot;300&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;表 7：Pulsar 持久性配置设置&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.8904694167852063&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0EIbbCE3P2ZHTzKW1XL5gLxMQH27cPoialichof4HBavnRRS5NEM11Itb22l93RtmxgvJy7yMGlhvZibHKviao0kaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1406&quot; title=&quot;null&quot; data-backw=&quot;562&quot; data-backh=&quot;501&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;表 8：Pulsar 持久性级别&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Pulsar 通过向日志磁盘写入和（或）fsync 数据来控制本地持久性。Pulsar 还提供选项，通过表 9 中的配置参数来调整本地持久性模式。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3593314763231198&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0EIbbCE3P2ZHTzKW1XL5gLxMQH27cPoia74ttdfy0PsD0fykTd6D6buzBiakjLPM0NgVFteF1EHRX7icoLmicEvU6g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1436&quot; title=&quot;null&quot; data-backw=&quot;562&quot; data-backh=&quot;202&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;表 9：Pulsar 本地持久性模式参数&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;Kafka 的持久性&lt;/h2&gt;&lt;p&gt;Kafka 提供 3 种持久性级别：1 级，2 级（默认设置）和 4 级。Kafka 在 2 级提供复制持久性，在 4 级无法提供持久性保证，因为不具备在确认写入之前将数据 fysnc 到磁盘的能力。通过设置 &lt;code&gt;flush.messages=1&lt;/code&gt; 和 &lt;code&gt;flush.ms=0&lt;/code&gt;，Kafka 可以达到 1 级系统级别，但 Kafka 几乎没有在生产环境部署过这种配置。&lt;/p&gt;&lt;p&gt;Kafka 的 ISR 复制协议控制复制持久性。通过调整与此协议关联的 &lt;code&gt;acks&lt;/code&gt; 和 &lt;code&gt;min.insync.replicas&lt;/code&gt; 参数，可以调整 Kafka 的复制持久性模式。表 10 列出了这些参数的设置。表 11 列出了 Kafka 支持的持久性级别。（有关 Kafka 复制协议的详细说明不属于本文探讨范围，我们将在后续博客中深入挖掘 Kafka 协议和 Pulsar 协议的差异。）&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4399441340782123&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0EIbbCE3P2ZHTzKW1XL5gLxMQH27cPoia6ctuxVH87TUeOw4IbvVy7ueJU4PEIcBXHSvy0E5ImW7FkchcS0DaFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1432&quot; title=&quot;null&quot; data-backw=&quot;562&quot; data-backh=&quot;247&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;表 10：Kafka 的持久性配置设置&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5928571428571429&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0EIbbCE3P2ZHTzKW1XL5gLxMQH27cPoiagt1m5UiaXmXAn3VqobKmR7QNQgTSJqCzGBL0HhyZyWC7A3Dia55PBgMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1400&quot; title=&quot;null&quot; data-backw=&quot;562&quot; data-backh=&quot;333&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;表 11：Kafka 持久性级别&lt;/span&gt;&lt;/p&gt;&lt;p&gt;与 Pulsar 不同，Kafka 不会将数据写入单独的日志磁盘。Kafka 会先确认写入操作，再将数据 fsync 到磁盘。这种操作可最大程度减少写入和读取之间的 I/O 争用，并防止性能降低。&lt;/p&gt;&lt;p&gt;通过对每条消息设置 &lt;code&gt;flush.messages = 1&lt;/code&gt; 和 &lt;code&gt;flush.ms = 0&lt;/code&gt;，Kafka 可以提供 fsync 功能，并且大大降低消息丢失的可能性，但这样会严重影响吞吐量和延迟。因此，这种设置几乎从未用于生产环境部署。&lt;/p&gt;&lt;p&gt;Kafka 无法传输日志数据，如果遇到机器故障或断电，就有丢失数据的风险。这个缺陷很明显，影响很大，这也是腾讯计费系统选用 Pulsar 的主要原因之一。&lt;/p&gt;&lt;h2&gt;Pulsar 和 Kafka 在持久性方面的差异&lt;/h2&gt;&lt;p&gt;Pulsar 的持久性设置灵活，用户可根据具体需要，优化持久性设置，满足各个应用程序、应用场景或硬件配置的要求。&lt;/p&gt;&lt;p&gt;Kafka 灵活性较差，根据场景限制，不能确保在两个系统中的持久性设置相同。这样就比较难进行基准测试。为解决这一问题，OMB 框架建议使用最接近的可用设置。&lt;/p&gt;&lt;p&gt;了解了这些背景后，我们来看看 Confluent 基准测试中的问题。Confluent 尝试模拟 Pulsar 的 fsync 行为，在他们的基准测试中，Confluent 为 Kafka 设置了异步持久性功能，为 Pulsar 设置了同步持久性功能。这种不对等导致测试结果不正确，作出的性能判断也有失偏颇。我们的基准测试显示，Pulsar 与 Kafka 性能匹敌甚至超过 Kafka，同时 Pulsar 还提供更强的持久性保证。&lt;/p&gt;&lt;h1&gt;StreamNative 基准测试&lt;/h1&gt;&lt;p&gt;为了更准确了解 Pulsar 性能，我们需要使用 Confluent 基准测试来解决这些问题。我们将焦点放在调整 Pulsar 的配置上，确保两个系统的持久性设置相同，并纳入其他性能因素和条件，例如不同的分区数量和混合工作负载，从而测量不同应用场景下的性能。在下面的章节我们会详细说明我们测试中的配置调整。&lt;/p&gt;&lt;h2&gt;StreamNative 测试设置&lt;/h2&gt;&lt;p&gt;我们的基准测试设置囊括 Pulsar 和 Kafka 支持的全部持久性级别。这样，我们才可对同一持久性级别下的吞吐量和延迟进行比较。我们使用的持久性设置如下。&lt;/p&gt;&lt;h3&gt;复制持久性设置&lt;/h3&gt;&lt;p&gt;我们的复制持久性设置与 Confluent 相同，未做任何变动，为保持完整性，此处沿用表 12 所列的设置。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6458923512747875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0EIbbCE3P2ZHTzKW1XL5gLxMQH27cPoia7CAd91B9zDx6v05GrWCYJE9yKc2TFfUUucxI2Fe90B6SmXjfyyNkhA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1412&quot; title=&quot;null&quot; data-backw=&quot;562&quot; data-backh=&quot;363&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;表 12：复制持久性设置&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Pulsar 新特性（ &lt;span&gt;新特性：&lt;sup&gt;[2]&lt;/sup&gt;&lt;/span&gt;）为应用程序提供了跳过日志记录的选项，从而放宽了本地持久性保证，避免了写入放大，提高了写入吞吐量。（该特性在下一版 Apache BookKeeper 提供）。我们没有把它设置成默认特性，因为还是有可能丢失消息，所以并不建议在大多数场景下使用。&lt;/p&gt;&lt;p&gt;为确保两种系统性能对比准确，我们在基准测试中使用了该特性。绕过 Pulsar 的日志记录可提供与 Kafka 默认 fsync 设置相同的本地持久性保证。&lt;/p&gt;&lt;p&gt;Pulsar 的新特性包括本地持久性模式（Async - Bypass journal）。我们利用此模式配置 Pulsar，保持与 Kafka 本地持久性默认级别相匹配。表 13 列出了基准测试的具体设置。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7535014005602241&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0EIbbCE3P2ZHTzKW1XL5gLxMQH27cPoiargs6jdCYDX2rNPRfJuHibU9BFXrXKEhs8sMnkJphialAP9PibSWiaM5URA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1428&quot; title=&quot;null&quot; data-backw=&quot;562&quot; data-backh=&quot;424&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;表 13：StreamNative 基准测试的本地持久性设置&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;StreamNative 框架&lt;/h2&gt;&lt;p&gt;我们在 Confluent OMB 框架分支 发现了一些问题，并修复了 OMB Pulsar 驱动程序中的一些配置错误。我们开发了新的基准测试代码（包括下述修复程序），都放在 开源 仓库中。&lt;/p&gt;&lt;h3&gt;修复 OMB 框架问题&lt;/h3&gt;&lt;p&gt;Confluent 遵循 OMB 框架建议，利用两套实例— 一套用于 Kafka，一套用于 Pulsar。在我们的基准测试中，我们分配了一组三个实例来增强测试的可靠性。在首个测试中，我们在 Pulsar 上运行了三个实例。然后利用同一组实例对 Kafka 进行同样的测试。&lt;/p&gt;&lt;p&gt;我们使用同一台机器对不同系统进行基准测试，在每次运行前都清除文件系统页面缓存，确保当前的测试不受到此前测试的影响。&lt;/p&gt;&lt;h3&gt;修复 OMB Pulsar 驱动程序配置问题&lt;/h3&gt;&lt;p&gt;我们修复了 Confluent 的 OMB Pulsar 驱动程序配置中的许多错误。以下各节将介绍我们对 broker、bookie、生产者、消费者和 Pulsar image 所作的具体调整。&lt;/p&gt;&lt;h3&gt;调整 Broker 配置&lt;/h3&gt;&lt;p&gt;Pulsar broker 利用 &lt;code&gt;managedLedgerNewEntriesCheckDelayInMillis&lt;/code&gt; 参数，确定 catch-up 订阅在向其消费者分发消息前必须等待的时长（以毫秒为单位）。在 OMB 框架中，此参数的值设置为 10，这是 Confluent 基准测试结论不准的主要原因，Confluent 基准测试结论是 Pulsar 延迟比 Kafka 高。我们将该值更改为 0， 模拟 Kafka 在 Pulsar 上的延迟行为。更改后，所有测试场景中，Pulsar 的延迟都显著低于 Kafka。&lt;/p&gt;&lt;p&gt;为了优化性能，我们将 &lt;code&gt;bookkeeperNumberOfChannelsPerBookie&lt;/code&gt; 参数值从 16 增加到 64，防止 broker 和 bookie 之间的任何单个 Netty 渠道成为瓶颈。当 Netty IO 队列中堆积大量消息时，该瓶颈会导致高延迟。&lt;/p&gt;&lt;p&gt;我们将在 Pulsar 文档中提供更清晰的指南，帮助用户优化端到端的延迟。&lt;/p&gt;&lt;h3&gt;调整 Bookie 配置&lt;/h3&gt;&lt;p&gt;我们为 Bookie 添加了新的配置，在绕过日志记录时测试 Pulsar 性能。Pulsar 和 Kafka 持久性保证势均力敌。&lt;/p&gt;&lt;p&gt;为测试该特性的性能，我们基于 Pulsar 2.6.1 官方发行版构建了自定义镜像，涵盖了该调整。（详情查看 Pulsar Image。）&lt;/p&gt;&lt;p&gt;我们手动配置了以下设置绕过 Pulsar 中的日志记录。&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;journalWriteData &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;journalSyncData &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;此外，我们将 &lt;code&gt;journalPageCacheFlushIntervalMSec&lt;/code&gt; 参数的值从 1 改成 1000，在 Pulsar 中对异步本地持久化进行基准测试（&lt;code&gt;journalSyncData = false&lt;/code&gt;）。将该值调高后，Pulsar 可按如下所述模拟 Kafka 的刷写行为。&lt;/p&gt;&lt;p&gt;Kafka 通过将文件系统页面缓存刷写到磁盘来确保本地持久性。数据由一组称为 pdflush 的后台线程刷写。可以设置 Pdflush，两次刷写之间的等待时长通常设置为 5 秒。将 Pulsar 的 &lt;code&gt;journalPageCacheFlushIntervalMSec&lt;/code&gt; 参数设置为 1000，相当于 Kafka 上的 5 秒 pdflush 间隔。更改后，我们即可更精确地对异步本地持久性进行基准测试，并对 Pulsar 和 Kafka 进行更准确的比较。&lt;/p&gt;&lt;h3&gt;调整生产者配置&lt;/h3&gt;&lt;p&gt;我们的批处理配置与 Confluent 相同，但有一个例外：即我们增加了切换间隔，使其比批处理间隔更长。具体来说，我们将 &lt;code&gt;batchingPartitionSwitchFrequencyByPublishDelay&lt;/code&gt; 参数值从 1 更改为 2。这一更改确保 Pulsar 的生产者在每个批处理期间仅集中于一个分区。&lt;/p&gt;&lt;p&gt;将切换间隔和批处理间隔设置为相同的值会导致 Pulsar 频繁切换分区，产生过多的小规模批处理，并可能影响吞吐量。把切换间隔设置大于批处理间隔，可最大程度降低这种风险。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;调整消费者配置&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;当应用程序无法快速处理传入消息时，Pulsar 客户端利用接收方队列施加反压。消费者接收方队列的规模会影响端到端延迟。与规模较小的队列相比，规模较大的队列可以预取和缓存更多消息。&lt;/p&gt;&lt;p&gt;这两项参数确定接收方队列的规模：&lt;code&gt;receiverQueueSize&lt;/code&gt; 和 &lt;code&gt;maxTotalReceiverQueueSizeAcrossPartitions&lt;/code&gt;。Pulsar 按下述方式计算接收方队列规模：&lt;/p&gt;&lt;p&gt;&lt;code&gt;Math.min(receiverQueueSize, maxTotalReceiverQueueSizeAcrossPartitions / number of partitions)&lt;/code&gt;&lt;/p&gt;&lt;p&gt;例如，如果将 &lt;code&gt;maxTotalReceiverQueueSizeAcrossPartitions&lt;/code&gt; 设置为 50000，当有 100 个分区时，Pulsar 客户端会在每个分区上将消费者的接收方队列规模设置为 500。&lt;/p&gt;&lt;p&gt;在我们的基准测试中，&lt;code&gt;maxTotalReceiverQueueSizeAcrossPartitions&lt;/code&gt; 从 50000 增加到 5000000。这种调优确保了消费者不会施加反压。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Pulsar image&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;我们构建了自定义的 Pulsar 版本（v.2.6.1-sn-16），其中包括上文所述的 Pulsar 和 BookKeeper 修复。2.6.1-Sn-16 版本基于 Pulsar 2.6.1 官方发行版本，可从 &lt;span&gt;https://github.com/streamnative/pulsar/releases/download/v2.6.1-sn-16/apache-pulsar-2.6.1-sn-16-bin.tar.gz &lt;sup&gt;[3]&lt;/sup&gt;&lt;/span&gt; 下载。&lt;/p&gt;&lt;h2&gt;StreamNative 测试方法&lt;/h2&gt;&lt;p&gt;我们调整了 Confluent 基准测试的测试方法，通过实际工作负载全面了解性能。具体对测试作了如下调整：&lt;/p&gt;&lt;p&gt;1.为评估以下内容，添加了 catch-up read&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;处理 catch-up read 时，每个系统可达到的最大吞吐量&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;写入如何影响发布和端到端延迟&lt;/span&gt;&lt;/p&gt;&lt;p&gt;2.更改分区数量，查看每个更改如何影响吞吐量和延迟&lt;/p&gt;&lt;p&gt;3.更改订阅数量，查看每个更改如何影响吞吐量和延迟&lt;/p&gt;&lt;p&gt;我们的基准测试场景测试了下述各类工作负载：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;strong&gt;最大吞吐量&lt;/strong&gt;：各系统可达到的最大吞吐量？&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;strong&gt;发布与 Tailing Read 延迟&lt;/strong&gt;：各系统在给定的吞吐量下可达到的最低发布和端到端拖延延迟？&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;strong&gt;Catch-up read&lt;/strong&gt;：从大量待办事项中读取消息时，各系统可实现的最大吞吐量？&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;strong&gt;混合工作负载&lt;/strong&gt;：消费者执行 catch-up 操作时，每个系统可以实现的最低发布和端到端拖延延迟级别是多少？Catch-up read 如何影响发布延迟和端到端拖延延迟？&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;Testbed&lt;/h1&gt;&lt;p&gt;OMB 框架建议，对于实例类型和 JVM 配置，使用特定的 testbed 定义；对于生产者、消费者和服务器端，使用工作负载驱动程序配置。我们的基准测试使用了与 Confluent 相同的 testbed 定义。关于这些 testbed 定义，可查看 Confluent OMB 仓库中 StreamNative 分支。&lt;/p&gt;&lt;p&gt;下面将重点介绍我们所观察到的磁盘吞吐量和磁盘 fsync 延迟。要解释基准测试结果，必须考虑这些硬件指标。&lt;/p&gt;&lt;h2&gt;磁盘吞吐量&lt;/h2&gt;&lt;p&gt;我们的基准测试采用与 Confluent 相同的实例类型，具体为 i3en.2xlarge （带 8 个 vCore，64 GB RAM，2 x 2、500 GB NVMe SSD）。我们确认 i3en.2xlarge 实例可支持两个磁盘间高达 655 MB/s 的写入的吞吐量。请参阅下文 dd 结果。&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;Disk&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;dd &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;/dev/&lt;/span&gt;&lt;span&gt;zero of&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;/mnt/&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;test bs&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1M&lt;/span&gt;&lt;span&gt; count&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;65536&lt;/span&gt;&lt;span&gt; oflag&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;direct&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;65536&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt; records &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;65536&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt; records &lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;68719476736&lt;/span&gt;&lt;span&gt; bytes &lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;&lt;span&gt; GB&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; copied&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;210.08&lt;/span&gt;&lt;span&gt; s&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;327&lt;/span&gt;&lt;span&gt; MB&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;s&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;Disk&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;dd &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;/dev/&lt;/span&gt;&lt;span&gt;zero of&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;/mnt/&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;test bs&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1M&lt;/span&gt;&lt;span&gt; count&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;65536&lt;/span&gt;&lt;span&gt; oflag&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;direct&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;65536&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt; records &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;65536&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt; records &lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;68719476736&lt;/span&gt;&lt;span&gt; bytes &lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;&lt;span&gt; GB&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; copied&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;209.635&lt;/span&gt;&lt;span&gt; s&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;328&lt;/span&gt;&lt;span&gt; MB&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;s&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h2&gt;磁盘数据同步延迟&lt;/h2&gt;&lt;p&gt;在进行延迟相关测试时，重要的是捕获 NVMe SSD 上的 fsync 延迟。我们观察到，这 3 个实例的 P99 fsync 延迟在 1 毫秒到 6 毫秒之间，如下图所示。如前所述，不同情况下磁盘发生很大差异，主要体现在该延迟中，我们发现有一组实例延迟一致。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.44814814814814813&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0EIbbCE3P2ZHTzKW1XL5gLxMQH27cPoiaTiaRGF0rBbc1XpOcNYnYKaM0b1Bj9WSq1yKAKXiaW5iaIibZ17CFibAm1pQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;null&quot; data-backw=&quot;562&quot; data-backh=&quot;252&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;图 1-1：3 个不同实例的 P99 fsync 延迟&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;StreamNative 基准测试结果&lt;/h1&gt;&lt;p&gt;下文将总结我们的基准测试结果。如需查看完整的基准测试报告，可以在 StreamNative 官网下载 或者在 openmessaging-benchmark 仓库查看。&lt;/p&gt;&lt;h2&gt;最大吞吐量测试&lt;/h2&gt;&lt;p&gt;最大吞吐量测试旨在确定在处理不同持久性保证的工作负载（包括发布和 tailing-read）时，各系统可实现的最大吞吐量。我们更改了主题分区的数量，查看每个更改如何影响最大吞吐量。&lt;/p&gt;&lt;p&gt;我们发现：&lt;/p&gt;&lt;p&gt;1.将持久性保证（同步复制持久性，同步本地持久性）配置为 1 级时，Pulsar 的最大吞吐量约为 300 Mb/s ，这是日志磁盘带宽的物理极限。有 100 个分区时，Kafka 可达到 420 MB/s 左右。值得注意的是，在持久性为 1 级时，Pulsar 配置为一个磁盘用作日志磁盘进行写入，另一个磁盘用作 ledger 磁盘进行读取；而 Kafka 同时使用两个磁盘进行读取和写入。尽管 Pulsar 的设置能够提供更好的 I/O 隔离，但其吞吐量也受单个磁盘最大带宽（〜300 MB/s）的限制。为 Pulsar 配置备用磁盘，能够实现更具成本效益的运行。此议题会在后续博客中探讨。&lt;/p&gt;&lt;p&gt;2.当将持久性（同步复制持久性和异步本地持久性）配置为 2 级时，Pulsar 和 Kafka 均可达到约 600 MB/s 的最大吞吐量。两个系统都达到了磁盘带宽的物理极限。&lt;/p&gt;&lt;p&gt;3.Kafka 在一个分区上的最大吞吐量仅为 Pulsar 最大吞吐量的二分之一。&lt;/p&gt;&lt;p&gt;4.Pulsar 的吞吐量不会因更改分区数量而受到影响，但 Kafka 的吞吐量会受到影响。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;当分区数量从 100 增加到 2000 时，Pulsar 保持了最大吞吐量（在 1 级持久性保证下约为 300 MB/s，在 2 级持久性保证下约为 600 MB/s）。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;当分区数量从 100 个增加到 2000 个时，Kafka 的吞吐量下降一半。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;发布和端到端延迟测试&lt;/h2&gt;&lt;p&gt;发布和端到端延迟测试旨在确定在处理不同持久性保证的工作负载（包括发布和 tailing-read）时，各系统可实现的最低延迟。我们修改了订阅数量和分区数量，以了解每个更改如何影响发布和端到端延迟。&lt;/p&gt;&lt;p&gt;我们发现：&lt;/p&gt;&lt;p&gt;1.在所有测试用例中，Pulsar 的发布和端到端延迟都显著（数百倍）低于 Kafka，这评估出了各种持久性保证以及不同数量的分区和订阅。即使分区数量从 100 增加到 10000 或订阅数量从 1 增加到 10，Pulsar P99 发布延迟和端到端延迟都在 10 毫秒之内。&lt;/p&gt;&lt;p&gt;2.订阅数量和分区数量变化会对 Kafka 的发布和端到端延迟产生巨大影响。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;当订阅数量从 1 增加到 10 时，发布和端到端延迟均从约 5 毫秒增加到约为 13 秒。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;当主题分区数量从 100 增加到 10000 时，发布和端到端延迟都从约 5 毫秒增加到约 200 秒。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;Catch-up read 测试&lt;/h2&gt;&lt;p&gt;Catch-up read 测试旨在确定在处理仅包含 catch-up read 的工作负载时各系统可实现的最大吞吐量。测试开始时，生产者以每秒 200K 的固定速率发送消息。生产者发送了 512GB 数据后，消费者开始读取收到的消息。消费者处理了累积消息，当生产者继续以相同速度发送新消息时，消费者可以和生产者保持同步。&lt;/p&gt;&lt;p&gt;处理 catch-up read 时，Pulsar 的最大吞吐量比 Kafka 快 3.5 倍。Pulsar 的最大吞吐量为 3.5 GB/s（350 万条消息 / 秒），而 Kafka 的吞吐量仅为 1 GB/s（100 万条消息 / 秒）。&lt;/p&gt;&lt;h2&gt;混合工作负载测试&lt;/h2&gt;&lt;p&gt;混合工作负载测试旨在确定 catch-up read 对混合工作负载中的发布和 tailing read 的影响。在测试开始时，生产者以每秒 200K 的固定速率发送消息，而消费者以 tailing 模式消费消息。生产者产生 512GB 消息后，将启动一组新的 catch-up 消费者，从头开始读取所有消息。同时，生产者和现有的 tailing-read 消费者继续以相同的速度发布和使用消息。&lt;/p&gt;&lt;p&gt;我们使用不同的持久性设置对 Kafka 和 Pulsar 进行了测试，发现 catch-up read 会严重影响 Kafka 的发布延迟，但对 Pulsar 的影响很小。Kafka P99 发布延迟从 5 毫秒增加到 1-3 秒，而 Pulsar P99 发布延迟保持在几毫秒到数十毫秒之间。&lt;/p&gt;&lt;h1&gt;结论&lt;/h1&gt;&lt;p&gt;基准测试通常仅呈现业务逻辑和配置选项的狭窄组合，可能反映或不反映实际应用场景或最佳实践，这是基准测试比较棘手的部分。基准测试可能会因其框架、设置和研究方法的问题而有失偏颇。我们在 Confluent 最近的基准测试中发现了这些问题。&lt;/p&gt;&lt;p&gt;应社区要求，StreamNative 团队着手开展该基准测试，从而就 Pulsar 的真实性能提供见解和看法。为了使基准测试更加准确，我们修复了 Confluent 基准测试中存在的问题，同时添加了新的测试参数，帮助我们深入探究各技术在真实用例中的对比结果。&lt;/p&gt;&lt;p&gt;根据我们的基准测试结果，在同一持久性保证下，在类似真实应用场景的工作负载中，Pulsar 性能超过 Kafka；在 Confluent 应用的同样有限测试用例中，Pulsar 可达到与 Kafka 相同的端到端吞吐量。此外，在每个不同的测试实例（包括不同的订阅数量、主题数量和持久性保证）中，Pulsar 的延迟优于 Kafka， 并且 I/O 隔离也比 Kafka 更好。&lt;/p&gt;&lt;p&gt;如前所述，任何一个基准测试均不能代替各自硬件上按真实工作负载所做的测试。我们鼓励读者使用自己的设置和工作负载来测试 Pulsar 和 Kafka，以了解每个系统在特定生产环境中的性能。如果你对 Pulsar 最佳实践有任何疑问，请直接 联系我们 或随时加入 Pulsar Slack。&lt;/p&gt;&lt;p&gt;未来几个月，我们会发布一系列博客，帮助社区更好地理解并利用 Pulsar 满足各自业务需求。我们会介绍 Pulsar 在不同工作负载和设置中的性能，介绍如何在不同的云提供商和本地环境中选择和调整硬件大小，以及如何利用 Pulsar 构建最具成本效益的流媒体平台。&lt;/p&gt;&lt;h3&gt;作者简介：&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;郭斯杰&lt;/strong&gt;，StreamNative 联合创始人兼 CEO。郭斯杰从事消息和流数据行业十多年，是消息和流数据资深专家。在创立 StreamNative 前，他联合创办过 Streamlio 公司，专注实时解决方案。他曾任 Twitter 消息基建团队技术负责人，联合创建了 DistributedLog 和 Twitter EventBus。在雅虎任职期间，他带领团队开发了 BookKeeper 和 Pulsar。他是 Apache BookKeeper 副总裁和 Apache Pulsar PMC 成员。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;李鹏辉&lt;/strong&gt;，StreamNative 软件工程师，Apache Pulsar Committer/PMC 成员。李鹏辉曾任职智联招聘，期间他作为主要推动者将 Apache Pulsar 落地智联招聘。他的工作经历始终围绕消息系统和微服务，目前已全力投入到 Pulsar 的世界中。&lt;/p&gt;&lt;h3&gt;参考链接:&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;StreamNative 基准测试报告&lt;sup&gt;[4]&lt;/sup&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;StreamNative 基准测试 Github 地址&lt;sup&gt;[5]&lt;/sup&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;Pulsar image 下载地址&lt;sup&gt;[6]&lt;/sup&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;OpenMessaging 基准测试（OMB）框架&lt;sup&gt;[7]&lt;/sup&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUxOTc4NDc2MQ==&amp;amp;mid=2247485123&amp;amp;idx=1&amp;amp;sn=d79f5f085646d75280455753ea7bc6fa&amp;amp;scene=21#wechat_redirect&quot; title=&quot;腾讯计费系统为何选择使用 Pulsar&quot; data-linktype=&quot;2&quot;&gt;腾讯计费系统为何选择使用 Pulsar&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;引用链接&lt;/h4&gt;&lt;p&gt;&lt;code&gt;[1]&lt;/code&gt; Github 网址: &lt;em&gt;https://github.com/streamnative/openmessaging-benchmark&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[2]&lt;/code&gt; 新特性：: &lt;em&gt;https://github.com/apache/bookkeeper/pull/2401&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[3]&lt;/code&gt; https://github.com/streamnative/pulsar/releases/download/v2.6.1-sn-16/apache-pulsar-2.6.1-sn-16-bin.tar.gz : &lt;em&gt;https://github.com/streamnative/pulsar/releases/download/v2.6.1-sn-16/apache-pulsar-2.6.1-sn-16-bin.tar.gz&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[4]&lt;/code&gt; StreamNative 基准测试报告: &lt;em&gt;https://github.com/streamnative/openmessaging-benchmark/blob/master/blog/benchmarking-pulsar-kafka-a-more-accurate-perspective-on-pulsar-performance.pdf/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[5]&lt;/code&gt; StreamNative 基准测试 Github 地址: &lt;em&gt;https://github.com/streamnative/openmessaging-benchmark&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[6]&lt;/code&gt; Pulsar image 下载地址: &lt;em&gt;https://github.com/streamnative/pulsar/releases/download/v2.6.1-sn-16/apache-pulsar-2.6.1-sn-16-bin.tar.gz&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[7]&lt;/code&gt; OpenMessaging 基准测试（OMB）框架: &lt;em&gt;http://openmessaging.cloud/docs/benchmarks/&lt;/em&gt;&lt;/p&gt;&lt;h1&gt;相关阅读&lt;/h1&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxOTc4NDc2MQ==&amp;amp;mid=2247486288&amp;amp;idx=1&amp;amp;sn=297303a5e3edd87130d0d6a6501f93d3&amp;amp;chksm=f9f51b06ce829210966e025c96761fd6e02f1aeea31cd9c5ba6637abcd72ecbdf424a715df64&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Pulsar 和 Kafka 基准测试: Pulsar 性能精准解析&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Pulsar 与 Kafka 全方位对比（上篇）：功能、性能、用例&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxOTc4NDc2MQ==&amp;amp;mid=2247486788&amp;amp;idx=1&amp;amp;sn=811e7d9e28bf5c3620ca1e2a4bb593a9&amp;amp;chksm=f9f51d12ce829404e39145914f84c7a2b9ee9e7c39e84f5d514aa2931859c3117c5f1522bd6d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;怎么用 Pulsar ？举个栗子来看看&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Pulsar 与 Kafka 全方位对比（下篇）：案例、特性、社区&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxOTc4NDc2MQ==&amp;amp;mid=2247486107&amp;amp;idx=1&amp;amp;sn=e09d87f2cc73001d6298b75150e0c22d&amp;amp;chksm=f9f51acdce8293dbb3776e00b4d2591471147e36c659c56c9499a3a69ce5ce90ed7d56f81507&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Apache Pulsar：从消息系统到流原生平台&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Apache Pulsar 与 Apache Kafka 在金融场景下的性能对比分析&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxOTc4NDc2MQ==&amp;amp;mid=2247486107&amp;amp;idx=1&amp;amp;sn=e09d87f2cc73001d6298b75150e0c22d&amp;amp;chksm=f9f51acdce8293dbb3776e00b4d2591471147e36c659c56c9499a3a69ce5ce90ed7d56f81507&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7703703703703704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0EIbbCE3P2ZHTzKW1XL5gLxMQH27cPoiaOeu2emASVv66Z1oDvJ4RgFPod4knUZ20n86033X7HHWvAfuYJzRLKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;null&quot; data-backw=&quot;562&quot; data-backh=&quot;433&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;点击「阅读原文」，下载英文版文件&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d5ecb82355fa10768cfa77dc2adcbc90</guid>
<title>[译] 从 PHP (Laravel) 迁移到 Go</title>
<link>https://toutiao.io/k/kle5cou</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;今年早些时候，我做出了一个糟糕的商业决定，我决定用Go重写Laravel应用Boxzilla，&lt;span&gt;虽然没有遗憾，最后效果惊人。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.4725&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/vbERicIdYZbAXEG5Nl71yMcutliaSYReNwaevAUPRc4yeXibx2ZjRx3AoQpPTTKKWqGx9rusktV3Z5PfjWO7wGG2g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    仅仅几个星期后我就部署了Go应用程序。构建它是我几个月来最有趣的事情，我学到了很多东西，最终结果是对旧应用程序的巨大改进、更好的性能、更容易的部署和更高的测试覆盖率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    该应用程序是一个相当简单的数据库驱动的API和包含帐户管理等应用程序，用户可以在登录以后下载产品，查看发票或更新付款方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    Stripe和Braintree用于接受订阅付款。发票使用MoneyBird处理，一些事务性的电子邮件使用Mailgun发送。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    虽然Laravel在这方面做得足够好，但有些事情总是让我感到过于复杂。每隔几个月发布一个新的“主要”版本，如果新的版本包含重大改进，我心里也会觉得这没什么，但是很多时候，感觉都是一些非常简单的改动，例如命名和目录结构进行了更改。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;Why Go？&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;去年，我已经将几种服务转移到了Go上，所以我对这种语言并不是完全陌生。作为销售基于WordPress的产品的开发人员，我的一部分工作是在一个古老的技术堆栈中工作，该堆栈主要关注最终用户。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果我不是自雇人士，我会简单地申请一份新工作来弥补这种缺乏性感技术的现象。作为我自己的老板，我有责任使自己的日常工作变得有趣，而不仅仅是追逐更多的即时资金。如果收入允许（并且确实如此），为什么不找点乐子呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;编写Go代码很高兴，工具很棒，不仅开发速度快，而且最终结果通常也很快。刚读完&lt;/span&gt;&lt;span&gt;Go项目的目的(https://golang.org/doc/faq#What_is_the_purpose_of_the_project)，就使&lt;/span&gt;&lt;span&gt;我对语言产生了浓厚的兴趣。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我认为我们会在未来几年内看到大量人从动态类型的语言（如PHP，Python和JavaScript）切换到Go。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;移植代码库&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;将代码迁移到Go中主要包括正确地进行数据库交互以及将Blade模板移植到我们可以在Go中使用的东西。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ORM总是会阻碍我的一件事，因此我选择了可模拟的数据访问层和简单的SQL查询。&lt;/span&gt;&lt;span&gt;使用Meddler&lt;/span&gt;&lt;span&gt;摆脱了一些烦恼：将查询结果映射到结构体中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了支持分层模板和&lt;/span&gt;&lt;span&gt;局部&lt;/span&gt;&lt;span&gt;，我开源了grender(https://github.com/dannyvankooten/grender)，这是基于Go的标准库html / template包的一个小包装。这使我可以相对轻松地将Blade模板文件移植到Go中，因为我可以使用相同的层次结构和部分模板。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了与Stripe集成，有官方的Stripe &lt;/span&gt;&lt;span&gt;-Go(https://github.com/stripe/stripe-go)&lt;/span&gt;&lt;span&gt;软件包。对于Braintree，有一个非正式的&lt;/span&gt;&lt;span&gt;braintree-go(https://github.com/lionelbarrow/braintree-go)&lt;/span&gt;&lt;span&gt;软件包，该软件包被忽略了一会儿，但最近又受到了新的关注。由于到目前为止，在Moneybird中还没有Go软件包来管理发票，因此我构建并开源了&lt;/span&gt;&lt;span&gt;moneybird-go(https://github.com/dannyvankooten/moneybird-go)&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;对比分析&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;由于Go是一种编译语言，具有比PHP更好的标准库，因此像我将要比较的那样比较这两种语言并不是很公平。就是说，我认为分享一些数字会很有趣。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;性能&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;wrk&lt;/span&gt;&lt;span&gt;用于为两个返回登录页面HTML的应用程序执行一些简单的HTTP基准测试。&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt; &lt;/th&gt;&lt;th&gt;&lt;span&gt;并发&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;平均 潜伏&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;要求/秒&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;传输/秒&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;Laravel&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;1&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;3.87ms&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;261.48&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;1.27MB&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;Laravel&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;100&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;108.86ms&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;917.27&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;6.04MB&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Go&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;1&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;325.72μs&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;7365.48&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;34.27MB&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Go&lt;/td&gt;&lt;td&gt;&lt;span&gt;100&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;11.63ms&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;19967.31&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;92.91MB&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Go&lt;/td&gt;&lt;td&gt;&lt;span&gt;200&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;37.68ms&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;22653.22&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;105.41MB&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;不幸的是，一旦我将并发“用户”的数量增加到100以上，Laravel应用程序（或PHP-FPM套接字）就一直崩溃。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;NetData&lt;span&gt;提供了以下图表，以查看服务器在所有这些负载下的承受能力。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;100个并发连接的Go程序&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4091666666666667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/vbERicIdYZbDro7hdC9AkzC6g4gChia5t2psawy8UKmGYxnEj9FK9pIiaKYibvLBG0MIWU1mQ9jiaDRcT5pwOV63fZQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;100个并发连接的Laravel&lt;/strong&gt; 程序&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4766666666666667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/vbERicIdYZbDro7hdC9AkzC6g4gChia5t2sfO5PfpFQmlS8EQvQUR7UlGYbl1hCMqePWuIcYhMaF99XjE1kMrKibg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;请注意，我在运行应用程序的同一台计算机上运行了基准测试，因此这会严重影响两个图表。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;代码行数&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;让我们比较两个应用程序中的代码行，包括所有的依赖项。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ find . -name &#x27;*.php&#x27; | xargs wc -l&lt;br/&gt;156289 total&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;Laravel版本包含超过156.000行代码。这还不包括要&lt;span&gt;运行&lt;span&gt;Laravel&lt;/span&gt;测试等相关的&lt;/span&gt;开发依赖包。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ find . -name &#x27;*.go&#x27; | xargs wc -l&lt;br/&gt;33624 total&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;另一方面，Go版本包含33.000行代码。这是完全相同功能的代码的五分之一。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;让我们在Laravel应用程序中排除外部依赖关系，以便知道我实际写了多少行php。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ find . -name &#x27;*.php&#x27; -not -path &quot;./vendor/*&quot; | xargs wc -l&lt;br/&gt;13921 total&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;多少行Go&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ find . -name &#x27;*.go&#x27; -not -path &quot;./vendor/*&quot; | xargs wc -l&lt;br/&gt;6750 total&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;即使仅查看托管代码行，结果也要稍微多一些。尽管如此，它还是只使用了原来完全相同的应用程序的&lt;span&gt;一半代码&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;测试范围&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;测试是Go中的头等公民，测试文件紧邻实际源文件存在。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;license.go&lt;br/&gt;license_test.go&lt;br/&gt;subscription.go&lt;br/&gt;subscription_test.go&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;这使得应用测试驱动的开发变得异常方便。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在我们的Laravel应用程序中，我们主要进行了集成测试，以检查请求处理程序是否返回正确的响应。总体测试覆盖率很低，主要是由于紧密耦合，而这又主要是我的错。再次编写相同的应用程序确实也有帮助。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;TLDR&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;做了一些您不应该做的事情：用另一种语言重写应用程序，因为我感觉很喜欢。获得了很多乐趣，并且得到了更小，更快的应用程序。&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>