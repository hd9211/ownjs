<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>5e11f40f1892f803d0f567aa7fd13350</guid>
<title>JVM 进阶之路（十二）：字节码指令</title>
<link>https://toutiao.io/k/l9yirih</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkwODE5ODM0Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeFt08hV3N1706WTzfhoTNoXm5LXRV0XibppmeNR4zSNMa3QOJJ7ib4O21P5yohibwuD26Tp9ETWZAqA/0?wx_fmt=png&quot; data-nickname=&quot;三分恶&quot; data-alias=&quot;Fighter3FullStack&quot; data-signature=&quot;一个全栈开发。分享Java后端、Web前端、计算机基础知识。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前面的  &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247485367&amp;amp;idx=1&amp;amp;sn=2d8693335a5d78efe0fbeaa10afa8208&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;【JVM进阶之路】三：探究虚拟机对象&lt;/a&gt; 里，提到了对象的初始化过程，对象初始化用的是&lt;code&gt;new&lt;/code&gt;指令——这就是字节码指令。在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247485787&amp;amp;idx=1&amp;amp;sn=88755336f545c7e0abcddb98b3a58426&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;【JVM进阶之路】十一：Class文件结构&lt;/a&gt; 中已经学习了JVM 字节码是JVM能直接识别的语言，了解了字节码文件的文件结构。接下来，我们进一步学习字节码的相关指令。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们来看一个简单的程序：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Main&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; x=&lt;span&gt;3&lt;/span&gt;,y=&lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; r=x+y;&lt;br/&gt;        System.out.println(x+y);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译运行，使用JDK自带的&lt;code&gt;javap&lt;/code&gt;查看字节码：&lt;code&gt;javap -c -s -v -l Main.class&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来找找相加指令在哪里：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8492688413948256&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdQYTiaX97YXrNVK8xKpwNGVQug9Ce1Ejrmj0fKpYnFPJn6xGaK64SaewAq9x8FRUSaPA71HarjspA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;889&quot;/&gt;&lt;figcaption&gt;image-20210515165355248&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务：i代表对int类型的数据操作，l代表long，s代表short，b代表byte，c代表char，f代表 float，d代表double，a代表reference。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为Java虚拟机的操作码长度只有一字节，所以包含了数据类型的操作码就为指令集的设计带来了很大的压力：如果每一种与数据类型相关的指令都支持Java虚拟机所有运行时数据类型的话，那么 指令的数量恐怕就会超出一字节所能表示的数量范围了。因此Java字节码指令支持的数据类型的坑位有限，不被支持的智能改头换面用支持的字节码指令来处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JVM主要支持byte、short、int、long、float、double、char、reference集中数据类型，每种数据类型的操作码分别以不同的字母开头，例如&lt;code&gt;iadd&lt;/code&gt;表示int类型的相加指令码：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.1063218390804597&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdQYTiaX97YXrNVK8xKpwNGVEwCQj6QDribwzVHcjiazbVWzUlIARlPRN3mXaXe9rO8J2euVslqJ2JBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;696&quot;/&gt;&lt;figcaption&gt;操作码帮助记忆&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，我们看看不同类型的字节码指令。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1、加载和存储指令&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加载（load）和存储（store）指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0712166172106825&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdQYTiaX97YXrNVK8xKpwNGVT0HyHz4gXUuHVVicyENu8cK2q8ic7WHlGCKMzrNVwKGVKmNOAeRvLv1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;337&quot;/&gt;&lt;figcaption&gt;加载和存储&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这类的主要指令有：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;将一个局部变量加载到操作栈：iload、iload_&amp;lt;n&amp;gt;、lload、lload_&amp;lt;n&amp;gt;、fload、fload_、dload、 dload_、aload、aload_&amp;lt;n&amp;gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;将一个数值从操作数栈存储到局部变量表：istore、istore_&amp;lt;n&amp;gt;、lstore、lstore_&amp;lt;n&amp;gt;、fstore、 fstore_、dstore、dstore_&amp;lt;n&amp;gt;、astore、astore_&amp;lt;n&amp;gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;将一个常量加载到操作数栈：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、 iconst_&amp;lt;i&amp;gt;、lconst_&amp;lt;l&amp;gt;、fconst_&amp;lt;f&amp;gt;、dconst_&amp;lt;d&amp;gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;扩充局部变量表的访问索引的指令：wide&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;存储数据的操作数栈和局部变量表主要由加载和存储指令进行操作，除此之外，还有少量指令， 如访问对象的字段或数组元素的指令也会向操作数栈传输数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;iload_这一类以尖括号结尾的指令，实际上代表了一组指令，例如iload_，它可能代表了iload_0、iload_1、iload_2和iload_3这几条指令，这几条指令表示把第1、2、3个局部变量加载进操作数栈。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2、运算指令&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。大体上运算指令可以分为两种：对整型数据进行运算的指令与对浮点型数据进行运算的指令。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所有的算术指令包括：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;加法指令：iadd、ladd、fadd、dadd&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;减法指令：isub、lsub、fsub、dsub&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;乘法指令：imul、lmul、fmul、dmul&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;除法指令：idiv、ldiv、fdiv、ddiv 这类的主要指令有：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;求余指令：irem、lrem、frem、drem&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;取反指令：ineg、lneg、fneg、dneg&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;位移指令：ishl、ishr、iushr、lshl、lshr、lushr&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;按位或指令：ior、lor&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;按位与指令：iand、land&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;按位异或指令：ixor、lxor&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;局部变量自增指令：iinc&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;比较指令：dcmpg、dcmpl、fcmpg、fcmpl、lcmp&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3、类型转换指令&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类型转换指令可以将两种不同的数值类型相互转换，这些转换操作有两个作用：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类型转换指令主要分为两种：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）宽化，小类型向大类型转换，比如 &lt;code&gt;int–&amp;gt;long–&amp;gt;float–&amp;gt;double&lt;/code&gt;，对应的指令有：i2l、i2f、i2d、l2f、l2d、f2d。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;从 int 到 long，或者从 int 到 double，是不会有精度丢失的；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从 int、long 到 float，或者 long 到 double 时，可能会发生精度丢失；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从 byte、char 和 short 到 int 的宽化类型转换实际上是隐式发生的，这样可以减少字节码指令，毕竟字节码指令只有 256 个，占一个字节。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2）窄化，大类型向小类型转换，比如从 int 类型到 byte、short 或者 char，对应的指令有：i2b、i2s、i2c；从 long 到 int，对应的指令有：l2i；从 float 到 int 或者 long，对应的指令有：f2i、f2l；从 double 到 int、long 或者  float，对应的指令有：d2i、d2l、d2f。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;窄化很可能会发生精度丢失，毕竟是不同的数量级；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;但 Java 虚拟机并不会因此抛出运行时异常。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3、对象创建与访问指令&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前面我们已经接触过了对象创建的指令。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ava虚拟机对类实例和数组的创建与操作使用了不同的字节码指令。对象创建后，就可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素，这些指令包括：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;创建类实例的指令：new&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;创建数组的指令：newarray、anewarray、multianewarray&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;访问类字段（static字段，或者称为类变量）和实例字段（非static字段，或者称为实例变量）的指令：getfield、putfield、getstatic、putstatic&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、 daload、aaload&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;将一个操作数栈的值储存到数组元素中的指令：bastore、castore、sastore、iastore、fastore、 dastore、aastore&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;取数组长度的指令：arraylength&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;检查类实例类型的指令：instanceof、checkcast&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4、操作数栈管理指令&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如同操作一个普通数据结构中的堆栈那样，Java虚拟机提供了一些用于直接操作操作数栈的指令，包括：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;将操作数栈的栈顶一个或两个元素出栈：pop、pop2&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;将栈最顶端的两个数值互换：swap&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5、控制转移指令&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;控制转移指令可以让Java虚拟机有条件或无条件地从指定位置指令（而不是控制转移指令）的下一条指令继续执行程序，从概念模型上理解，可以认为控制指令就是在有条件或无条件地修改PC寄存器的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;控制转移指令包括：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、 if_icmpgt、if_icmple、if_icmpge、if_acmpeq和if_acmpne&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;复合条件分支：tableswitch、lookupswitch&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;无条件分支：goto、goto_w、jsr、jsr_w、ret&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Java虚拟机中有专门的指令集用来处理int和reference类型的条件分支比较操作，为了可以无须明显标识一个数据的值是否null，也有专门的指令用来检测null值。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6、方法调用和返回指令&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法调用在后面会学到，我们这里只是了解一下方法调用的一些指令：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;invokevirtual指令：用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派）， 这也是Java语言中最常见的方法分派方式。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;invokeinterface指令：用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;invokespecial指令：用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;invokestatic指令：用于调用类静态方法（static方法）。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;invokedynamic指令：用于在运行时动态解析出调用点限定符所引用的方法。并执行该方法。前面四条调用指令的分派逻辑都固化在Java虚拟机内部，用户无法改变，而invokedynamic指令的分派逻辑 是由用户所设定的引导方法决定的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法调用指令与数据类型无关，而方法返回指令是根据返回值的类型区分的，包括ireturn（当返回值是boolean、byte、char、short和int类型时使用）、lreturn、freturn、dreturn和areturn，另外还有一条return指令供声明为void的方法、实例初始化方法、类和接口的类初始化方法使用。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7、异常处理指令&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Java程序中显式抛出异常的操作（throw语句）都由athrow指令来实现，除了用throw语句显式抛出异常的情况之外，《Java虚拟机规范》还规定了许多运行时异常会在其他Java虚拟机指令检测到异常状况时自动抛出。例如当除数为零时，虚拟机会在idiv或ldiv指令中抛出 ArithmeticException异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在Java虚拟机中，处理异常（catch语句）不是由字节码指令来实现的（很久之前曾经使用jsr和ret指令来实现，现在已经不用了），而是采用异常表来完成。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8、同步指令&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程（Monitor，更常见的是直接将它称为“锁”）来实现的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法级的同步是隐式的，无须通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池中的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个方法是否被声明为同步方法。当方法调用时，调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（无论是正常完成还是非正常完成）时释放管程。在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取到同一个管程。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的管程将在异常抛到同步方法边界之外时自动释放。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3416252072968491&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdQYTiaX97YXrNVK8xKpwNGVHboccjzK4X0fKgdNwUEdMKRAv7icViaLgG2sHNFeVz2kqTB0Ao1Lvrlg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;603&quot;/&gt;&lt;figcaption&gt;同步指令&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的，Java虚拟机的指令集中有monitorenter和monitorexit两条指令来支持synchronized关键字的语义，正确实现synchronized关键字需要Javac编译器与Java虚拟机两者共同协作支持。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如一段代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;onlyMe&lt;/span&gt;&lt;span&gt;(String f)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;synchronized&lt;/span&gt; (f) {&lt;br/&gt;            System.out.println(f);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译后查看字节码指令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;         &lt;span&gt;0&lt;/span&gt;: aload_1                          &lt;br/&gt;         &lt;span&gt;1&lt;/span&gt;: dup                              &lt;br/&gt;         &lt;span&gt;2&lt;/span&gt;: astore_2                         &lt;br/&gt;         &lt;span&gt;3&lt;/span&gt;: monitorenter                     &lt;span&gt;// 以栈顶元素作为锁，开始同步&lt;/span&gt;&lt;br/&gt;         &lt;span&gt;4&lt;/span&gt;: getstatic     #&lt;span&gt;2&lt;/span&gt;                 &lt;br/&gt;         &lt;span&gt;7&lt;/span&gt;: aload_1                          &lt;br/&gt;         &lt;span&gt;8&lt;/span&gt;: invokevirtual #&lt;span&gt;3&lt;/span&gt;                 &lt;br/&gt;        &lt;span&gt;11&lt;/span&gt;: aload_2&lt;br/&gt;        &lt;span&gt;12&lt;/span&gt;: monitorexit                     &lt;span&gt;// 退出同步&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;13&lt;/span&gt;: goto          &lt;span&gt;21&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;16&lt;/span&gt;: astore_3&lt;br/&gt;        &lt;span&gt;17&lt;/span&gt;: aload_2&lt;br/&gt;        &lt;span&gt;18&lt;/span&gt;: monitorexit&lt;br/&gt;        &lt;span&gt;19&lt;/span&gt;: aload_3&lt;br/&gt;        &lt;span&gt;20&lt;/span&gt;: athrow&lt;br/&gt;        &lt;span&gt;21&lt;/span&gt;: &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;big&gt;&lt;strong&gt;参考&lt;/strong&gt;&lt;/big&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;【1】：《深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）》&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;【2】：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIxNzQwNjM3NA==&amp;amp;mid=2247493564&amp;amp;idx=1&amp;amp;sn=1b64e663d056ef550beeaa936f5c5dca&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Java 字节码指令，让我发了疯疯疯！&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;【3】：《Java虚拟机规范(Java_SE_7)》&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkwODE5ODM0Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeFt08hV3N1706WTzfhoTNoXm5LXRV0XibppmeNR4zSNMa3QOJJ7ib4O21P5yohibwuD26Tp9ETWZAqA/0?wx_fmt=png&quot; data-nickname=&quot;三分恶&quot; data-alias=&quot;Fighter3FullStack&quot; data-signature=&quot;一个全栈开发。分享Java后端、Web前端、计算机基础知识。&quot; data-from=&quot;0&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>aa2b4258106a66f8707b71cf1aa01fcd</guid>
<title>Java 反编译工具的使用与对比分析</title>
<link>https://toutiao.io/k/3o1c6vb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Java 反编译&lt;/strong&gt;，一听可能觉得高深莫测，其实反编译并不是什么特别高级的操作，Java 对于 Class 字节码文件的生成有着严格的要求，如果你非常熟悉 Java 虚拟机规范，了解 Class 字节码文件中一些字节的作用，那么理解反编译的原理并不是什么问题。甚至像下面这样的 Class 文件你都能看懂一二。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.493&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4lfok2icUkibTUd7It7JewEpqb0rxtLyJEk4XPbAeyK22sBnJAiaDxibyFeHfPiao0oRG6ViaaMUNTSItQ8ciaK98X31g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1000&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般在逆向研究和代码分析中，反编译用到的比较多。不过在日常开发中，有时候只是简单的看一下所用依赖类的反编译，也是十分重要的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;恰好最近工作中也需要用到 &lt;strong&gt;Java 反编译&lt;/strong&gt;，所以这篇文章介绍目前常见的的几种 Java 反编译工具的使用，在文章的最后也会通过&lt;strong&gt;编译速度&lt;/strong&gt;、&lt;strong&gt;语法支持&lt;/strong&gt;以及&lt;strong&gt;代码可读性&lt;/strong&gt;三个维度，对它们&lt;strong&gt;进行测试&lt;/strong&gt;，分析几款工具的&lt;strong&gt;优缺点&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Procyon&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Github 链接：https://github.com/mstrobel/procyon&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Procyon&lt;/strong&gt; &lt;span&gt;不仅仅是反编译工具，它其实是专注于 Java 代码的生成和分析的一整套的 Java 元编程工具。主要包括下面几个部分：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Core Framework&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Reflection Framework&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Expressions Framework&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Compiler Toolset (Experimental)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Java Decompiler (Experimental)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到反编译只是 &lt;strong&gt;Procyon&lt;/strong&gt; 的其中一个模块，&lt;strong&gt;Procyon&lt;/strong&gt; 原来托管于 bitbucket，后来迁移到了 GitHub，根据 GitHub 的提交记录来看，也有将近两年没有更新了。不过也有依赖 &lt;strong&gt;Procyon&lt;/strong&gt; 的其他的开源反编译工具如** decompiler-procyon**，更新频率还是很高的，下面也会选择这个工具进行反编译测试。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;使用 Procyon&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;!-- https://mvnrepository.com/artifact/org.jboss.windup.decompiler/decompiler-procyon --&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.jboss.windup.decompiler&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;decompiler-procyon&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;5.1.4.Final&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写一个简单的反编译测试。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; com.wdbyte.decompiler;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.io.IOException;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.nio.file.Path;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.nio.file.Paths;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.Iterator;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.List;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.jboss.windup.decompiler.api.DecompilationFailure;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.jboss.windup.decompiler.api.DecompilationListener;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.jboss.windup.decompiler.api.DecompilationResult;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.jboss.windup.decompiler.api.Decompiler;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.jboss.windup.decompiler.procyon.ProcyonDecompiler;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * Procyon 反编译测试&lt;br/&gt; *&lt;br/&gt; *  &lt;span&gt;@author&lt;/span&gt; https://github.com/niumoo&lt;br/&gt; * &lt;span&gt;@date&lt;/span&gt; 2021/05/15&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ProcyonTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        Long time = procyon(&lt;span&gt;&quot;decompiler.jar&quot;&lt;/span&gt;, &lt;span&gt;&quot;procyon_output_jar&quot;&lt;/span&gt;);&lt;br/&gt;        System.out.println(String.format(&lt;span&gt;&quot;decompiler time: %dms&quot;&lt;/span&gt;, time));&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Long &lt;span&gt;procyon&lt;/span&gt;&lt;span&gt;(String source,String targetPath)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; start = System.currentTimeMillis();&lt;br/&gt;        Path outDir = Paths.get(targetPath);&lt;br/&gt;        Path archive = Paths.get(source);&lt;br/&gt;        Decompiler dec = &lt;span&gt;new&lt;/span&gt; ProcyonDecompiler();&lt;br/&gt;        DecompilationResult res = dec.decompileArchive(archive, outDir, &lt;span&gt;new&lt;/span&gt; DecompilationListener() {&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;decompilationProcessComplete&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;decompilationProcessComplete&quot;&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;decompilationFailed&lt;/span&gt;&lt;span&gt;(List&amp;lt;String&amp;gt; inputPath, String message)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;decompilationFailed&quot;&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;fileDecompiled&lt;/span&gt;&lt;span&gt;(List&amp;lt;String&amp;gt; inputPath, String outputPath)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isCancelled&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!res.getFailures().isEmpty()) {&lt;br/&gt;            StringBuilder sb = &lt;span&gt;new&lt;/span&gt; StringBuilder();&lt;br/&gt;            sb.append(&lt;span&gt;&quot;Failed decompilation of &quot;&lt;/span&gt; + res.getFailures().size() + &lt;span&gt;&quot; classes: &quot;&lt;/span&gt;);&lt;br/&gt;            Iterator failureIterator = res.getFailures().iterator();&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; (failureIterator.hasNext()) {&lt;br/&gt;                DecompilationFailure dex = (DecompilationFailure)failureIterator.next();&lt;br/&gt;                sb.append(System.lineSeparator() + &lt;span&gt;&quot;    &quot;&lt;/span&gt;).append(dex.getMessage());&lt;br/&gt;            }&lt;br/&gt;            System.out.println(sb.toString());&lt;br/&gt;        }&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;Compilation results: &quot;&lt;/span&gt; + res.getDecompiledFiles().size() + &lt;span&gt;&quot; succeeded, &quot;&lt;/span&gt; + res.getFailures().size() + &lt;span&gt;&quot; failed.&quot;&lt;/span&gt;);&lt;br/&gt;        dec.close();&lt;br/&gt;        Long end = System.currentTimeMillis();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; end - start;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Procyon 在反编译时会实时输出反编译文件数量的进度情况，最后还会统计反编译成功和失败的 Class 文件数量。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;....&lt;br/&gt;五月 15, 2021 10:58:28 下午 org.jboss.windup.decompiler.procyon.ProcyonDecompiler$3 call&lt;br/&gt;信息: Decompiling 650 / 783&lt;br/&gt;五月 15, 2021 10:58:30 下午 org.jboss.windup.decompiler.procyon.ProcyonDecompiler$3 call&lt;br/&gt;信息: Decompiling 700 / 783&lt;br/&gt;五月 15, 2021 10:58:37 下午 org.jboss.windup.decompiler.procyon.ProcyonDecompiler$3 call&lt;br/&gt;信息: Decompiling 750 / 783&lt;br/&gt;decompilationProcessComplete&lt;br/&gt;Compilation results: 783 succeeded, 0 failed.&lt;br/&gt;decompiler time: 40599ms&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Procyon GUI&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 Procyon 反编译来说，在 GitHub 上也有基于此实现的开源 GUI 界面，感兴趣的可以下载尝试。&lt;br/&gt;Github 地址：https://github.com/deathmarine/Luyten&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;CFR&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GitHub 地址：https://github.com/leibnitz27/cfr&lt;br/&gt;CFR 官方网站：http://www.benf.org/other/cfr/（可能需要FQ）&lt;br/&gt;Maven 仓库：https://mvnrepository.com/artifact/org.benf/cfr&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;CFR&lt;/strong&gt;（Class File Reader） 可以支持 Java 9、Java 12、Java 14 以及其他的最新版 Java 代码的反编译工作。而且 CFR 本身的代码是由 &lt;strong&gt;Java 6 编写&lt;/strong&gt;，所以基本可以使用 CFR 在任何版本的 Java 程序中。值得一提的是，使用 CFR 甚至可以将使用其他语言编写的的 JVM 类文件反编译回 Java 文件。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;CFR 命令行使用&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 CFR 反编译时，你可以下载已经发布的 JAR 包，进行命令行反编译，也可以使用 Maven 引入的方式，在代码中使用。下面先说命令行运行的方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接在 GitHub Tags 下载已发布的最新版 JAR. 可以直接运行查看帮助。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看帮助&lt;/span&gt;&lt;br/&gt;java -jar cfr-0.151.jar --help&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果只是反编译某个 class.&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 反编译 class 文件，结果输出到控制台&lt;/span&gt;&lt;br/&gt;java -jar cfr-0.151.jar WindupClasspathTypeLoader.class&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 反编译 class 文件，结果输出到 out 文件夹&lt;/span&gt;&lt;br/&gt;java -jar cfr-0.151.jar WindupClasspathTypeLoader.class --outputpath ./out&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反编译某个 JAR.&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 反编译 jar 文件，结果输出到 output_jar 文件夹&lt;/span&gt;&lt;br/&gt;➜  Desktop java -jar cfr-0.151.jar decompiler.jar --outputdir ./output_jar&lt;br/&gt;Processing decompiler.jar (use silent to silence)&lt;br/&gt;Processing com.strobel.assembler.metadata.ArrayTypeLoader&lt;br/&gt;Processing com.strobel.assembler.metadata.ParameterDefinition&lt;br/&gt;Processing com.strobel.assembler.metadata.MethodHandle&lt;br/&gt;Processing com.strobel.assembler.metadata.signatures.FloatSignature&lt;br/&gt;.....&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反编译结果会按照 class 的包路径写入到指定文件夹中。&lt;img data-ratio=&quot;0.631578947368421&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4lfok2icUkibTUd7It7JewEpqb0rxtLyJE0s0mf6qdskAYQfxibZJdwTmPRtAPubiczm1BiaicbDhiclg2UdxMF030n4w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;950&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;CFR 代码中使用&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;添加依赖这里不提。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&amp;lt;!-- https:&lt;span&gt;//mvnrepository.com/artifact/org.benf/cfr --&amp;gt;&lt;/span&gt;&lt;br/&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;    &amp;lt;groupId&amp;gt;org.benf&amp;lt;/groupId&amp;gt;&lt;br/&gt;    &amp;lt;artifactId&amp;gt;cfr&amp;lt;/artifactId&amp;gt;&lt;br/&gt;    &amp;lt;version&amp;gt;&lt;span&gt;0.151&lt;/span&gt;&amp;lt;/version&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上我在官方网站和 GitHub 上都没有看到具体的单元测试示例。不过没有关系，既然能在命令行运行，那么直接在 IDEA 中查看反编译后的 Main 方法入口，看下命令行是怎么执行的，就可以写出自己的单元测试了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; com.wdbyte.decompiler;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.io.IOException;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.ArrayList;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.HashMap;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.List;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.benf.cfr.reader.api.CfrDriver;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.benf.cfr.reader.util.getopt.OptionsImpl;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * CFR Test&lt;br/&gt; *&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; https://github.com/niumoo&lt;br/&gt; * &lt;span&gt;@date&lt;/span&gt; 2021/05/15&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CFRTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        Long time = cfr(&lt;span&gt;&quot;decompiler.jar&quot;&lt;/span&gt;, &lt;span&gt;&quot;./cfr_output_jar&quot;&lt;/span&gt;);&lt;br/&gt;        System.out.println(String.format(&lt;span&gt;&quot;decompiler time: %dms&quot;&lt;/span&gt;, time));&lt;br/&gt;        &lt;span&gt;// decompiler time: 11655ms&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Long &lt;span&gt;cfr&lt;/span&gt;&lt;span&gt;(String source, String targetPath)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        Long start = System.currentTimeMillis();&lt;br/&gt;        &lt;span&gt;// source jar&lt;/span&gt;&lt;br/&gt;        List&amp;lt;String&amp;gt; files = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;        files.add(source);&lt;br/&gt;        &lt;span&gt;// target dir&lt;/span&gt;&lt;br/&gt;        HashMap&amp;lt;String, String&amp;gt; outputMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;br/&gt;        outputMap.put(&lt;span&gt;&quot;outputdir&quot;&lt;/span&gt;, targetPath);&lt;br/&gt;&lt;br/&gt;        OptionsImpl options = &lt;span&gt;new&lt;/span&gt; OptionsImpl(outputMap);&lt;br/&gt;        CfrDriver cfrDriver = &lt;span&gt;new&lt;/span&gt; CfrDriver.Builder().withBuiltOptions(options).build();&lt;br/&gt;        cfrDriver.analyse(files);&lt;br/&gt;        Long end = System.currentTimeMillis();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; (end - start);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JD-Core&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GiHub 地址：https://github.com/java-decompiler/jd-core&lt;br/&gt;JD-core 官方网址：https://java-decompiler.github.io/&lt;br/&gt;JD-core 是一个的独立的 Java 库，可以用于 Java 的反编译，支持从 Java 1 至  Java 12 的字节码反编译，包括 Lambda 表达式、方式引用、默认方法等。知名的 JD-GUI 和 Eclipse 无缝集成反编译引擎就是 JD-core。JD-core 提供了一些反编译的核心功能，也提供了单独的 Class 反编译方法，但是如果你想在自己的代码中去直接反编译整个 JAR 包，还是需要一些改造的，如果是代码中有匿名函数，Lambda 等，虽然可以直接反编译，不过也需要额外考虑。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;使用 JD-core&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;        &lt;span&gt;&amp;lt;!-- https://mvnrepository.com/artifact/org.jd/jd-core --&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.jd&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;jd-core&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.1.3&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了可以反编译整个 JAR 包，使用的代码我做了一些简单改造，以便于最后一部分的对比测试，但是这个示例中没有考虑内部类，Lambda 等会编译出多个 Class 文件的情况，所以不能直接使用在生产中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; com.wdbyte.decompiler;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.io.File;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.io.IOException;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.io.InputStream;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.nio.file.Files;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.nio.file.Path;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.nio.file.Paths;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.Enumeration;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.HashMap;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.jar.JarFile;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.zip.ZipEntry;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.zip.ZipFile;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.apache.commons.io.IOUtils;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.apache.commons.lang3.StringUtils;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.jd.core.v1.ClassFileToJavaSourceDecompiler;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.jd.core.v1.api.loader.Loader;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.jd.core.v1.api.printer.Printer;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; https://github.com/niumoo&lt;br/&gt; * &lt;span&gt;@date&lt;/span&gt; 2021/05/15&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;JDCoreTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        JDCoreDecompiler jdCoreDecompiler = &lt;span&gt;new&lt;/span&gt; JDCoreDecompiler();&lt;br/&gt;        Long time = jdCoreDecompiler.decompiler(&lt;span&gt;&quot;decompiler.jar&quot;&lt;/span&gt;,&lt;span&gt;&quot;jd_output_jar&quot;&lt;/span&gt;);&lt;br/&gt;        System.out.println(String.format(&lt;span&gt;&quot;decompiler time: %dms&quot;&lt;/span&gt;, time));&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;JDCoreDecompiler&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; ClassFileToJavaSourceDecompiler decompiler = &lt;span&gt;new&lt;/span&gt; ClassFileToJavaSourceDecompiler();&lt;br/&gt;    &lt;span&gt;// 存放字节码&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; HashMap&amp;lt;String,&lt;span&gt;byte&lt;/span&gt;[]&amp;gt; classByteMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 注意：没有考虑一个 Java 类编译出多个 Class 文件的情况。&lt;br/&gt;     * &lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; source&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; target&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     * &lt;span&gt;@throws&lt;/span&gt; Exception&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Long &lt;span&gt;decompiler&lt;/span&gt;&lt;span&gt;(String source,String target)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; start = System.currentTimeMillis();&lt;br/&gt;        &lt;span&gt;// 解压&lt;/span&gt;&lt;br/&gt;        archive(source);&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (String className : classByteMap.keySet()) {&lt;br/&gt;            String path = StringUtils.substringBeforeLast(className, &lt;span&gt;&quot;/&quot;&lt;/span&gt;);&lt;br/&gt;            String name = StringUtils.substringAfterLast(className, &lt;span&gt;&quot;/&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (StringUtils.contains(name, &lt;span&gt;&quot;$&quot;&lt;/span&gt;)) {&lt;br/&gt;                name = StringUtils.substringAfterLast(name, &lt;span&gt;&quot;$&quot;&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;            name = StringUtils.replace(name, &lt;span&gt;&quot;.class&quot;&lt;/span&gt;, &lt;span&gt;&quot;.java&quot;&lt;/span&gt;);&lt;br/&gt;            decompiler.decompile(loader, printer, className);&lt;br/&gt;            String context = printer.toString();&lt;br/&gt;            Path targetPath = Paths.get(target + &lt;span&gt;&quot;/&quot;&lt;/span&gt; + path + &lt;span&gt;&quot;/&quot;&lt;/span&gt; + name);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (!Files.exists(Paths.get(target + &lt;span&gt;&quot;/&quot;&lt;/span&gt; + path))) {&lt;br/&gt;                Files.createDirectories(Paths.get(target + &lt;span&gt;&quot;/&quot;&lt;/span&gt; + path));&lt;br/&gt;            }&lt;br/&gt;            Files.deleteIfExists(targetPath);&lt;br/&gt;            Files.createFile(targetPath);&lt;br/&gt;            Files.write(targetPath, context.getBytes());&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; System.currentTimeMillis() - start;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;archive&lt;/span&gt;&lt;span&gt;(String path)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; (ZipFile archive = &lt;span&gt;new&lt;/span&gt; JarFile(&lt;span&gt;new&lt;/span&gt; File(path))) {&lt;br/&gt;            Enumeration&amp;lt;? extends ZipEntry&amp;gt; entries = archive.entries();&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; (entries.hasMoreElements()) {&lt;br/&gt;                ZipEntry entry = entries.nextElement();&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (!entry.isDirectory()) {&lt;br/&gt;                    String name = entry.getName();&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (name.endsWith(&lt;span&gt;&quot;.class&quot;&lt;/span&gt;)) {&lt;br/&gt;                        &lt;span&gt;byte&lt;/span&gt;[] bytes = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;                        &lt;span&gt;try&lt;/span&gt; (InputStream stream = archive.getInputStream(entry)) {&lt;br/&gt;                            bytes = IOUtils.toByteArray(stream);&lt;br/&gt;                        }&lt;br/&gt;                        classByteMap.put(name, bytes);&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Loader loader = &lt;span&gt;new&lt;/span&gt; Loader() {&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] load(String internalName) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; classByteMap.get(internalName);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;canLoad&lt;/span&gt;&lt;span&gt;(String internalName)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; classByteMap.containsKey(internalName);&lt;br/&gt;        }&lt;br/&gt;    };&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Printer printer = &lt;span&gt;new&lt;/span&gt; Printer() {&lt;br/&gt;        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String TAB = &lt;span&gt;&quot;  &quot;&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String NEWLINE = &lt;span&gt;&quot;\n&quot;&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; indentationCount = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;protected&lt;/span&gt; StringBuilder sb = &lt;span&gt;new&lt;/span&gt; StringBuilder();&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;toString&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            String toString = sb.toString();&lt;br/&gt;            sb = &lt;span&gt;new&lt;/span&gt; StringBuilder();&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; toString;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;start&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; maxLineNumber, &lt;span&gt;int&lt;/span&gt; majorVersion, &lt;span&gt;int&lt;/span&gt; minorVersion)&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;end&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;printText&lt;/span&gt;&lt;span&gt;(String text)&lt;/span&gt; &lt;/span&gt;{ sb.append(text); }&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;printNumericConstant&lt;/span&gt;&lt;span&gt;(String constant)&lt;/span&gt; &lt;/span&gt;{ sb.append(constant); }&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;printStringConstant&lt;/span&gt;&lt;span&gt;(String constant, String ownerInternalName)&lt;/span&gt; &lt;/span&gt;{ sb.append(constant); }&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;printKeyword&lt;/span&gt;&lt;span&gt;(String keyword)&lt;/span&gt; &lt;/span&gt;{ sb.append(keyword); }&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;printDeclaration&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; type, String internalTypeName, String name, String descriptor)&lt;/span&gt; &lt;/span&gt;{ sb.append(name); }&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;printReference&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; type, String internalTypeName, String name, String descriptor, String ownerInternalName)&lt;/span&gt; &lt;/span&gt;{ sb.append(name); }&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;indent&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;this&lt;/span&gt;.indentationCount++; }&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;unindent&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;this&lt;/span&gt;.indentationCount--; }&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;startLine&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; lineNumber)&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;indentationCount; i++) sb.append(TAB); }&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;endLine&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{ sb.append(NEWLINE); }&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;extraLine&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; count)&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;while&lt;/span&gt; (count-- &amp;gt; &lt;span&gt;0&lt;/span&gt;) sb.append(NEWLINE); }&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;startMarker&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; type)&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;endMarker&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; type)&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;    };&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;JD-GUI&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GitHub 地址：https://github.com/java-decompiler/jd-gui&lt;br/&gt;JD-core 也提供了官方的 GUI 界面，需要的也可以直接下载尝试。&lt;img data-ratio=&quot;0.595&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4lfok2icUkibTUd7It7JewEpqb0rxtLyJERibq2oXkicod6M7gzmB2xIHqppJ9LicYbHsXhonQgv2V4hjKFggKmVqXA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Jadx&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GitHub 地址：https://github.com/skylot/jadx&lt;br/&gt;Jadx 是一款可以反编译 JAR、APK、DEX、AAR、AAB、ZIP 文件的反编译工具，并且也配有 Jadx-gui 用于界面操作。Jadx 使用 Grade 进行依赖管理，可以自行克隆仓库打包运行。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;git clone https://github.com/skylot/jadx.git&lt;br/&gt;cd jadx&lt;br/&gt;./gradlew dist&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看帮助&lt;/span&gt;&lt;br/&gt; ./build/jadx/bin/jadx --help&lt;br/&gt; &lt;br/&gt;jadx - dex to java decompiler, version: dev&lt;br/&gt;&lt;br/&gt;usage: jadx [options] &amp;lt;input files&amp;gt; (.apk, .dex, .jar, .class, .smali, .zip, .aar, .arsc, .aab)&lt;br/&gt;options:&lt;br/&gt;  -d, --output-dir                    - output directory&lt;br/&gt;  -ds, --output-dir-src               - output directory for sources&lt;br/&gt;  -dr, --output-dir-res               - output directory for resources&lt;br/&gt;  -r, --no-res                        - do not decode resources&lt;br/&gt;  -s, --no-src                        - do not decompile source code&lt;br/&gt;  --single-class                      - decompile a single class&lt;br/&gt;  --output-format                     - can be &#x27;java&#x27; or &#x27;json&#x27;, default: java&lt;br/&gt;  -e, --export-gradle                 - save as android gradle project&lt;br/&gt;  -j, --threads-count                 - processing threads count, default: 6&lt;br/&gt;  --show-bad-code                     - show inconsistent code (incorrectly decompiled)&lt;br/&gt;  --no-imports                        - disable use of imports, always write entire package name&lt;br/&gt;  --no-debug-info                     - disable debug info&lt;br/&gt;  --add-debug-lines                   - add comments with debug line numbers if available&lt;br/&gt;  --no-inline-anonymous               - disable anonymous classes inline&lt;br/&gt;  --no-replace-consts                 - don&#x27;t replace constant value with matching constant field&lt;br/&gt;  --escape-unicode                    - escape non latin characters in strings (with \u)&lt;br/&gt;  --respect-bytecode-access-modifiers - don&#x27;t change original access modifiers&lt;br/&gt;  --deobf                             - activate deobfuscation&lt;br/&gt;  --deobf-min                         - min length of name, renamed if shorter, default: 3&lt;br/&gt;  --deobf-max                         - max length of name, renamed if longer, default: 64&lt;br/&gt;  --deobf-cfg-file                    - deobfuscation map file, default: same dir and name as input file with &#x27;.jobf&#x27; extension&lt;br/&gt;  --deobf-rewrite-cfg                 - force to save deobfuscation map&lt;br/&gt;  --deobf-use-sourcename              - use source file name as class name alias&lt;br/&gt;  --deobf-parse-kotlin-metadata       - parse kotlin metadata to class and package names&lt;br/&gt;  --rename-flags                      - what to rename, comma-separated, &#x27;case&#x27; for system case sensitivity, &#x27;valid&#x27; for java identifiers, &#x27;printable&#x27; characters, &#x27;none&#x27; or &#x27;all&#x27; (default)&lt;br/&gt;  --fs-case-sensitive                 - treat filesystem as case sensitive, false by default&lt;br/&gt;  --cfg                               - save methods control flow graph to dot file&lt;br/&gt;  --raw-cfg                           - save methods control flow graph (use raw instructions)&lt;br/&gt;  -f, --fallback                      - make simple dump (using goto instead of &#x27;if&#x27;, &#x27;for&#x27;, etc)&lt;br/&gt;  -v, --verbose                       - verbose output (set --log-level to DEBUG)&lt;br/&gt;  -q, --quiet                         - turn off output (set --log-level to QUIET)&lt;br/&gt;  --log-level                         - set log level, values: QUIET, PROGRESS, ERROR, WARN, INFO, DEBUG, default: PROGRESS&lt;br/&gt;  --version                           - print jadx version&lt;br/&gt;  -h, --help                          - print this help&lt;br/&gt;Example:&lt;br/&gt;  jadx -d out classes.dex&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据 HELP 信息，如果想要反编译 decompiler.jar 到 out 文件夹。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;./build/jadx/bin/jadx -d ./out ~/Desktop/decompiler.jar &lt;br/&gt;INFO  - loading ...&lt;br/&gt;INFO  - processing ...&lt;br/&gt;INFO  - doneress: 1143 of 1217 (93%)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Fernflower&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GitHub 地址：https://github.com/fesh0r/fernflower&lt;br/&gt;Fernflower 和 Jadx 一样使用 Grade 进行依赖管理，可以自行克隆仓库打包运行。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;➜  fernflower-master ./gradlew build&lt;br/&gt;&lt;br/&gt;BUILD SUCCESSFUL in 32s&lt;br/&gt;4 actionable tasks: 4 executed&lt;br/&gt;&lt;br/&gt;➜  fernflower-master java -jar build/libs/fernflower.jar&lt;br/&gt;Usage: java -jar fernflower.jar [-&amp;lt;option&amp;gt;=&amp;lt;value&amp;gt;]* [&amp;lt;source&amp;gt;]+ &amp;lt;destination&amp;gt;&lt;br/&gt;Example: java -jar fernflower.jar -dgs=true c:\my\source\ c:\my.jar d:\decompiled\&lt;br/&gt;&lt;br/&gt;➜  fernflower-master mkdir out&lt;br/&gt;➜  fernflower-master java -jar build/libs/fernflower.jar ~/Desktop/decompiler.jar ./out&lt;br/&gt;INFO:  Decompiling class com/strobel/assembler/metadata/ArrayTypeLoader&lt;br/&gt;INFO:  ... done&lt;br/&gt;INFO:  Decompiling class com/strobel/assembler/metadata/ParameterDefinition&lt;br/&gt;INFO:  ... done&lt;br/&gt;INFO:  Decompiling class com/strobel/assembler/metadata/MethodHandle&lt;br/&gt;...&lt;br/&gt;&lt;br/&gt;➜  fernflower-master ll out&lt;br/&gt;total 1288&lt;br/&gt;-rw-r--r--  1 darcy  staff   595K  5 16 17:47 decompiler.jar&lt;br/&gt;➜  fernflower-master&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Fernflower 在反编译 JAR 包时，默认反编译的结果也是一个 JAR 包。Jad&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;反编译速度&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里已经介绍了五款 Java 反编译工具了，那么在日常开发中我们应该使用哪一个呢？又或者在代码分析时我们又该选择哪一个呢？我想这两种情况的不同，使用时的关注点也是不同的。如果是日常使用，读读代码，我想应该是对可读性要求更高些，如果是大量的代码分析工作，那么可能反编译的速度和语法的支持上要求更高些。为了能有一个简单的参考数据，我使用 JMH 微基准测试工具分别对这五款反编译工具进行了简单的测试，下面是一些测试结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;测试环境&lt;/strong&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;环境变量&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;处理器&lt;/td&gt;&lt;td&gt;2.6 GHz 六核Intel Core i7&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;内存&lt;/td&gt;&lt;td&gt;16 GB 2667 MHz DDR4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Java 版本&lt;/td&gt;&lt;td&gt;JDK 14.0.2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;测试方式&lt;/td&gt;&lt;td&gt;JMH 基准测试。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;待反编译 JAR 1&lt;/td&gt;&lt;td&gt;procyon-compilertools-0.5.33.jar (1.5 MB)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;待反编译 JAR 2&lt;/td&gt;&lt;td&gt;python2java4common-1.0.0-20180706.084921-1.jar (42 MB)&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反编译 JAR 1：procyon-compilertools-0.5.33.jar (1.5 MB)&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;strong&gt;Benchmark&lt;/strong&gt;&lt;/th&gt;&lt;th&gt;&lt;strong&gt;Mode&lt;/strong&gt;&lt;/th&gt;&lt;th&gt;&lt;strong&gt;Cnt&lt;/strong&gt;&lt;/th&gt;&lt;th&gt;&lt;strong&gt;Score&lt;/strong&gt;&lt;/th&gt;&lt;th&gt;&lt;strong&gt;Units&lt;/strong&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;cfr&lt;/td&gt;&lt;td&gt;avgt&lt;/td&gt;&lt;td&gt;10&lt;/td&gt;&lt;td&gt;6548.642 ±  363.502&lt;/td&gt;&lt;td&gt;ms/op&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;fernflower&lt;/td&gt;&lt;td&gt;avgt&lt;/td&gt;&lt;td&gt;10&lt;/td&gt;&lt;td&gt;12699.147 ± 1081.539&lt;/td&gt;&lt;td&gt;ms/op&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;jdcore&lt;/td&gt;&lt;td&gt;avgt&lt;/td&gt;&lt;td&gt;10&lt;/td&gt;&lt;td&gt;5728.621 ±  310.645&lt;/td&gt;&lt;td&gt;ms/op&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;procyon&lt;/td&gt;&lt;td&gt;avgt&lt;/td&gt;&lt;td&gt;10&lt;/td&gt;&lt;td&gt;26776.125 ± 2651.081&lt;/td&gt;&lt;td&gt;ms/op&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;jadx&lt;/td&gt;&lt;td&gt;avgt&lt;/td&gt;&lt;td&gt;10&lt;/td&gt;&lt;td&gt;7059.354 ±  323.351&lt;/td&gt;&lt;td&gt;ms/op&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反编译 JAR 2:  python2java4common-1.0.0-20180706.084921-1.jar (42 MB)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JAR 2 这个包是比较大的，是拿很多代码仓库合并到一起的，同时还有很多 Python 转 Java 生成的代码，理论上代码的复杂度会更高。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Benchmark&lt;/th&gt;&lt;th&gt;Cnt&lt;/th&gt;&lt;th&gt;Score&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Cfr&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;413838.826ms&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;fernflower&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;246819.168ms&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;jdcore&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;Error&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;procyon&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;487647.181ms&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;jadx&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;505600.231ms&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;语法支持和可读性&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果反编译后的代码需要自己看的话，那么可读性更好的代码更占优势，下面我写了一些代码，主要是 Java 8 及以下的代码语法和一些嵌套的流程控制，看看反编译后的效果如何。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; com.wdbyte.decompiler;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.ArrayList;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.List;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.stream.IntStream;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.benf.cfr.reader.util.functors.UnaryFunction;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; https://www.wdbyte.com&lt;br/&gt; * &lt;span&gt;@date&lt;/span&gt; 2021/05/16&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;HardCode&lt;/span&gt; &amp;lt;&lt;span&gt;A&lt;/span&gt;, &lt;span&gt;B&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;HardCode&lt;/span&gt;&lt;span&gt;(A a, B b)&lt;/span&gt; &lt;/span&gt;{ }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;... args)&lt;/span&gt; &lt;/span&gt;{ }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String... args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        test(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;byteAnd0&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; b = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; x = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;            b = (&lt;span&gt;byte&lt;/span&gt;)((b ^ x));&lt;br/&gt;        } &lt;span&gt;while&lt;/span&gt; (b++ &amp;lt; &lt;span&gt;10&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; b;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;a&lt;/span&gt;&lt;span&gt;(Integer i)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        a(i);&lt;br/&gt;        b(i);&lt;br/&gt;        c(i);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;b&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; i)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        a(i);&lt;br/&gt;        b(i);&lt;br/&gt;        c(i);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;c&lt;/span&gt;&lt;span&gt;(&lt;span&gt;double&lt;/span&gt; d)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        c(d);&lt;br/&gt;        d(d);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;d&lt;/span&gt;&lt;span&gt;(Double d)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        c(d);&lt;br/&gt;        d(d);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;e&lt;/span&gt;&lt;span&gt;(Short s)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        b(s);&lt;br/&gt;        c(s);&lt;br/&gt;        e(s);&lt;br/&gt;        f(s);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(&lt;span&gt;short&lt;/span&gt; s)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        b(s);&lt;br/&gt;        c(s);&lt;br/&gt;        e(s);&lt;br/&gt;        f(s);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;(String path)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; x = &lt;span&gt;3&lt;/span&gt;;&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (NullPointerException t) {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;File Not found&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (path == &lt;span&gt;null&lt;/span&gt;) { &lt;span&gt;return&lt;/span&gt;; }&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; t;&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;Fred&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (path == &lt;span&gt;null&lt;/span&gt;) { &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(); }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; List&amp;lt;Integer&amp;gt; stuff = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();{&lt;br/&gt;        stuff.add(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        stuff.add(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;plus&lt;/span&gt;&lt;span&gt;(&lt;span&gt;boolean&lt;/span&gt; t, &lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt; b)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; c = t ? a : b;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; c;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Lambda&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;Integer &lt;span&gt;lambdaInvoker&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; arg, UnaryFunction&amp;lt;Integer, Integer&amp;gt; fn)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; fn.invoke(arg);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Lambda&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;testLambda&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; lambdaInvoker(&lt;span&gt;3&lt;/span&gt;, x -&amp;gt; x + &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;//        return 1;&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Lambda&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Integer &lt;span&gt;testLambda&lt;/span&gt;&lt;span&gt;(List&amp;lt;Integer&amp;gt; stuff, &lt;span&gt;int&lt;/span&gt; y, &lt;span&gt;boolean&lt;/span&gt; b)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; stuff.stream().filter(b ? x -&amp;gt; x &amp;gt; y : x -&amp;gt; x &amp;lt; &lt;span&gt;3&lt;/span&gt;).findFirst().orElse(&lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// stream&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;Y extends Integer&amp;gt; &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;testStream&lt;/span&gt;&lt;span&gt;(List&amp;lt;Y&amp;gt; list)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        IntStream s = list.stream()&lt;br/&gt;            .filter(x -&amp;gt; {&lt;br/&gt;                System.out.println(x);&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; x.intValue() / &lt;span&gt;2&lt;/span&gt; == &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;                })&lt;br/&gt;            .map(x -&amp;gt; (Integer)x+&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;            .mapToInt(x -&amp;gt; x);&lt;br/&gt;        s.toArray();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// switch&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testSwitch1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;switch&lt;/span&gt;(((Long)(i + &lt;span&gt;1L&lt;/span&gt;)) + &lt;span&gt;&quot;&quot;&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;1&quot;&lt;/span&gt;:&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;one&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// switch&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testSwitch2&lt;/span&gt;&lt;span&gt;(String string)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;switch&lt;/span&gt; (string) {&lt;br/&gt;            &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;apples&quot;&lt;/span&gt;:&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;apples&quot;&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;pears&quot;&lt;/span&gt;:&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;pears&quot;&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// switch&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testSwitch3&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; x)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (x &amp;lt; &lt;span&gt;5&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;switch&lt;/span&gt; (&lt;span&gt;&quot;test&quot;&lt;/span&gt;) {&lt;br/&gt;                    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;okay&quot;&lt;/span&gt;:&lt;br/&gt;                        &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;                    &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;                        &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;wow x2!&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此处本来贴出了所有工具的反编译结果，但是碍于文章长度和阅读体验，没有放出来，不过我在个人博客的发布上是有完整代码的，个人网站排版比较自由，可以使用 Tab 选项卡的方式展示。如果需要查看可以访问 https://www.wdbyte.com 进行查看。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Procyon&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到 Procyon 的反编译结果，还是比较吃惊的，在正常反编译的情况下，反编译后的代码基本上都是&lt;strong&gt;原汁原味&lt;/strong&gt;。唯一一处反编译后和源码语法上有变化的地方，是一个集合的初始化操作略有不同。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 源码&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;HardCode&lt;/span&gt;&lt;span&gt;(A a, B b)&lt;/span&gt; &lt;/span&gt;{ }&lt;br/&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; List&amp;lt;Integer&amp;gt; stuff = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();{&lt;br/&gt;    stuff.add(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    stuff.add(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt; }&lt;br/&gt;&lt;span&gt;// Procyon 反编译&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; List&amp;lt;Integer&amp;gt; stuff;&lt;br/&gt;    &lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;HardCode&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; A a, &lt;span&gt;final&lt;/span&gt; B b)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    (&lt;span&gt;this&lt;/span&gt;.stuff = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;()).add(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.stuff.add(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而其他部分代码， 比如装箱拆箱，Switch 语法，Lambda 表达式，流式操作以及流程控制等，几乎完全一致，阅读没有障碍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;装箱拆箱操作反编译后完全一致，没有多余的类型转换代码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 源码&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;a&lt;/span&gt;&lt;span&gt;(Integer i)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    a(i);&lt;br/&gt;    b(i);&lt;br/&gt;    c(i);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;b&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; i)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    a(i);&lt;br/&gt;    b(i);&lt;br/&gt;    c(i);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;c&lt;/span&gt;&lt;span&gt;(&lt;span&gt;double&lt;/span&gt; d)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    c(d);&lt;br/&gt;    d(d);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;d&lt;/span&gt;&lt;span&gt;(Double d)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    c(d);&lt;br/&gt;    d(d);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;e&lt;/span&gt;&lt;span&gt;(Short s)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    b(s);&lt;br/&gt;    c(s);&lt;br/&gt;    e(s);&lt;br/&gt;    f(s);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(&lt;span&gt;short&lt;/span&gt; s)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    b(s);&lt;br/&gt;    c(s);&lt;br/&gt;    e(s);&lt;br/&gt;    f(s);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// Procyon 反编译&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;a&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; Integer i)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.a(i);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.b(i);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.c(i);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;b&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; i)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.a(i);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.b(i);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.c(i);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;c&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; d)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.c(d);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.d(d);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;d&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; Double d)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.c(d);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.d(d);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;e&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; Short s)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.b(s);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.c(s);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.e(s);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.f(s);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; &lt;span&gt;short&lt;/span&gt; s)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.b(s);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.c(s);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.e(s);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.f(s);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Switch 部分也是一致，流程控制部分也没有变化。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 源码 switch&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testSwitch1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;switch&lt;/span&gt;(((Long)(i + &lt;span&gt;1L&lt;/span&gt;)) + &lt;span&gt;&quot;&quot;&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;1&quot;&lt;/span&gt;:&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;one&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testSwitch2&lt;/span&gt;&lt;span&gt;(String string)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;switch&lt;/span&gt; (string) {&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;apples&quot;&lt;/span&gt;:&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;apples&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;pears&quot;&lt;/span&gt;:&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;pears&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testSwitch3&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; x)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (x &amp;lt; &lt;span&gt;5&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;switch&lt;/span&gt; (&lt;span&gt;&quot;test&quot;&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;okay&quot;&lt;/span&gt;:&lt;br/&gt;                    &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;                &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;                    &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;wow x2!&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// Procyon 反编译&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testSwitch1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; String string = (Object)(i + &lt;span&gt;1L&lt;/span&gt;) + &lt;span&gt;&quot;&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;switch&lt;/span&gt; (string) {&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;1&quot;&lt;/span&gt;: {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;one&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testSwitch2&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; String string)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;switch&lt;/span&gt; (string) {&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;apples&quot;&lt;/span&gt;: {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;apples&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;pears&quot;&lt;/span&gt;: {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;pears&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}   &lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testSwitch3&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; x)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (x &amp;lt; &lt;span&gt;5&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;final&lt;/span&gt; String s = &lt;span&gt;&quot;test&quot;&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;switch&lt;/span&gt; (s) {&lt;br/&gt;                &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;okay&quot;&lt;/span&gt;: {&lt;br/&gt;                    &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;default&lt;/span&gt;: {&lt;br/&gt;                    &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;wow x2!&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Lambda 表达式和流式操作完全一致。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 源码&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Lambda&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; Integer &lt;span&gt;testLambda&lt;/span&gt;&lt;span&gt;(List&amp;lt;Integer&amp;gt; stuff, &lt;span&gt;int&lt;/span&gt; y, &lt;span&gt;boolean&lt;/span&gt; b)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; stuff.stream().filter(b ? x -&amp;gt; x &amp;gt; y : x -&amp;gt; x &amp;lt; &lt;span&gt;3&lt;/span&gt;).findFirst().orElse(&lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// stream&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;Y extends Integer&amp;gt; &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;testStream&lt;/span&gt;&lt;span&gt;(List&amp;lt;Y&amp;gt; list)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    IntStream s = list.stream()&lt;br/&gt;        .filter(x -&amp;gt; {&lt;br/&gt;            System.out.println(x);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; x.intValue() / &lt;span&gt;2&lt;/span&gt; == &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;            })&lt;br/&gt;        .map(x -&amp;gt; (Integer)x+&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;        .mapToInt(x -&amp;gt; x);&lt;br/&gt;    s.toArray();&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// Procyon 反编译&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; Integer &lt;span&gt;testLambda&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; List&amp;lt;Integer&amp;gt; stuff, &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; y, &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; b)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; stuff.stream().filter(b ? (x -&amp;gt; x &amp;gt; y) : (x -&amp;gt; x &amp;lt; &lt;span&gt;3&lt;/span&gt;)).findFirst().orElse(&lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;Y extends Integer&amp;gt; &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;testStream&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; List&amp;lt;Y&amp;gt; list)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; IntStream s = list.stream().filter(x -&amp;gt; {&lt;br/&gt;        System.out.println(x);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; x / &lt;span&gt;2&lt;/span&gt; == &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    }).map(x -&amp;gt; x + &lt;span&gt;2&lt;/span&gt;).mapToInt(x -&amp;gt; x);&lt;br/&gt;    s.toArray();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;流程控制，反编译后发现丢失了无异议的代码部分，阅读来说并无障碍。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 源码&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;(String path)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; x = &lt;span&gt;3&lt;/span&gt;;&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (NullPointerException t) {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;File Not found&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (path == &lt;span&gt;null&lt;/span&gt;) { &lt;span&gt;return&lt;/span&gt;; }&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; t;&lt;br/&gt;    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;Fred&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (path == &lt;span&gt;null&lt;/span&gt;) { &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(); }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// Procyon 反编译&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; String path)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {}&lt;br/&gt;    &lt;span&gt;catch&lt;/span&gt; (NullPointerException t) {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;File Not found&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (path == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; t;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;Fred&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (path == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;鉴于代码篇幅，下面几种的反编译结果的对比只会列出不同之处，相同之处会直接跳过。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;CFR&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CFR 的反编译结果多出了类型转换部分，个人来看没有 Procyon 那么原汁原味，不过也算是十分优秀，测试案例中唯一不满意的地方是对 &lt;code&gt;while continue&lt;/code&gt; 的处理。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// CFR 反编译结果&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 装箱拆箱&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;e&lt;/span&gt;&lt;span&gt;(Short s)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;this&lt;/span&gt;.b(s.shortValue()); &lt;span&gt;// 装箱拆箱多出了类型转换部分。&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;this&lt;/span&gt;.c(s.shortValue()); &lt;span&gt;// 装箱拆箱多出了类型转换部分。&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;this&lt;/span&gt;.e(s);&lt;br/&gt;   &lt;span&gt;this&lt;/span&gt;.f(s);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 流程控制&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;(String path)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; n = &lt;span&gt;3&lt;/span&gt;;&lt;span&gt;// 流程控制反编译结果十分满意，原汁原味，甚至此处的无意思代码都保留了。&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;catch&lt;/span&gt; (NullPointerException t) {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;File Not found&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (path == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; t;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;Fred&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (path == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// Lambda 和 Stream 操作完全一致，不提。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// switch 处，反编译后功能一致，但是流程控制有所更改。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testSwitch3&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; x)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    block6: &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) { &lt;span&gt;// 源码中只有 while(true)，反编译后多了 block6&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (x &amp;lt; &lt;span&gt;5&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;switch&lt;/span&gt; (&lt;span&gt;&quot;test&quot;&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;okay&quot;&lt;/span&gt;: {&lt;br/&gt;                    &lt;span&gt;continue&lt;/span&gt; block6; &lt;span&gt;// 多了 block6&lt;/span&gt;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;wow x2!&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;JD-Core&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JD-Core 和 CFR 一样，对于装箱拆箱操作，反编译后不再一致，多了类型转换部分，而且自动优化了数据类型。个人感觉，如果是反编译后自己阅读，通篇的数据类型的转换优化影响还是挺大的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// JD-Core 反编译&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;d&lt;/span&gt;&lt;span&gt;(Double d)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  c(d.doubleValue()); &lt;span&gt;// 新增了数据类型转换&lt;/span&gt;&lt;br/&gt;  d(d);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;e&lt;/span&gt;&lt;span&gt;(Short s)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  b(s.shortValue()); &lt;span&gt;// 新增了数据类型转换&lt;/span&gt;&lt;br/&gt;  c(s.shortValue()); &lt;span&gt;// 新增了数据类型转换&lt;/span&gt;&lt;br/&gt;  e(s);&lt;br/&gt;  f(s.shortValue()); &lt;span&gt;// 新增了数据类型转换&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(&lt;span&gt;short&lt;/span&gt; s)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  b(s);&lt;br/&gt;  c(s);&lt;br/&gt;  e(Short.valueOf(s)); &lt;span&gt;// 新增了数据类型转换&lt;/span&gt;&lt;br/&gt;  f(s);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// Stream 操作中，也自动优化了数据类型转换，阅读起来比较累。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;Y extends Integer&amp;gt; &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;testStream&lt;/span&gt;&lt;span&gt;(List&amp;lt;Y&amp;gt; list)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  IntStream s = list.stream().filter(x -&amp;gt; {&lt;br/&gt;        System.out.println(x);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; (x.intValue() / &lt;span&gt;2&lt;/span&gt; == &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;      }).map(x -&amp;gt; Integer.valueOf(x.intValue() + &lt;span&gt;2&lt;/span&gt;)).mapToInt(x -&amp;gt; x.intValue());&lt;br/&gt;  s.toArray();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Jadx&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先 Jadx 在反编译测试代码时，报出了&lt;strong&gt;错误&lt;/strong&gt;，反编译的结果里也有提示&lt;strong&gt;不能反编 Lambda 和 Stream 操作&lt;/strong&gt;，反编译结果中&lt;strong&gt;变量名称杂乱无章&lt;/strong&gt;，&lt;strong&gt;流程控制&lt;/strong&gt;几乎阵亡，如果你想反编译后生物肉眼阅读，Jadx 肯定不是一个好选择。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Jadx 反编译&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;e&lt;/span&gt;&lt;span&gt;(Short s)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    b(s.shortValue());&lt;span&gt;// 新增了数据类型转换&lt;/span&gt;&lt;br/&gt;    c((&lt;span&gt;double&lt;/span&gt;) s.shortValue());&lt;span&gt;// 新增了数据类型转换&lt;/span&gt;&lt;br/&gt;    e(s);&lt;br/&gt;    f(s.shortValue());&lt;span&gt;// 新增了数据类型转换&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(&lt;span&gt;short&lt;/span&gt; s)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    b(s);&lt;br/&gt;    c((&lt;span&gt;double&lt;/span&gt;) s);&lt;span&gt;// 新增了数据类型转换&lt;/span&gt;&lt;br/&gt;    e(Short.valueOf(s));&lt;span&gt;// 新增了数据类型转换&lt;/span&gt;&lt;br/&gt;    f(s);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;testLambda&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;// testLambda 反编译失败&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;/*&lt;br/&gt;        r2 = this;&lt;br/&gt;        r0 = 3&lt;br/&gt;        r1 = move-result&lt;br/&gt;        java.lang.Integer r0 = r2.lambdaInvoker(r0, r1)&lt;br/&gt;        int r0 = r0.intValue()&lt;br/&gt;        return r0&lt;br/&gt;    */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; UnsupportedOperationException(&lt;span&gt;&quot;Method not decompiled: com.wdbyte.decompiler.HardCode.testLambda():int&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// Stream 反编译失败&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;Y extends java.lang.Integer&amp;gt; &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;testStream&lt;/span&gt;&lt;span&gt;(java.util.List&amp;lt;Y&amp;gt; r3)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;/*&lt;br/&gt;        java.util.stream.Stream r1 = r3.stream()&lt;br/&gt;        r2 = move-result&lt;br/&gt;        java.util.stream.Stream r1 = r1.filter(r2)&lt;br/&gt;        r2 = move-result&lt;br/&gt;        java.util.stream.Stream r1 = r1.map(r2)&lt;br/&gt;        r2 = move-result&lt;br/&gt;        java.util.stream.IntStream r0 = r1.mapToInt(r2)&lt;br/&gt;        r0.toArray()&lt;br/&gt;        return&lt;br/&gt;    */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; UnsupportedOperationException(&lt;span&gt;&quot;Method not decompiled: com.wdbyte.decompiler.HardCode.testStream(java.util.List):void&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testSwitch2&lt;/span&gt;&lt;span&gt;(String string)&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;// switch 操作无法正常阅读，和源码出入较大。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;char&lt;/span&gt; c = &lt;span&gt;65535&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;switch&lt;/span&gt; (string.hashCode()) {&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; -&lt;span&gt;1411061671&lt;/span&gt;:&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (string.equals(&lt;span&gt;&quot;apples&quot;&lt;/span&gt;)) {&lt;br/&gt;                c = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; &lt;span&gt;106540109&lt;/span&gt;:&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (string.equals(&lt;span&gt;&quot;pears&quot;&lt;/span&gt;)) {&lt;br/&gt;                c = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;switch&lt;/span&gt; (c) {&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;:&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;apples&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;:&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;pears&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Fernflower&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Fernflower 的反编译结果总体上还是不错的，不过也有不足，它对变量名称的指定，以及 Switch 字符串时的反编译结果不够理想。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//反编译后变量命名不利于阅读，有很多 var 变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;byteAnd0&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;int&lt;/span&gt; b = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;   &lt;span&gt;byte&lt;/span&gt; x = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;byte&lt;/span&gt; var10000;&lt;br/&gt;   &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;int&lt;/span&gt; b = (&lt;span&gt;byte&lt;/span&gt;)(b ^ x);&lt;br/&gt;      var10000 = b;&lt;br/&gt;      b = b + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;   } &lt;span&gt;while&lt;/span&gt;(var10000 &amp;lt; &lt;span&gt;10&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; b;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// switch 反编译结果使用了hashCode&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testSwitch3&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; x)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (x &amp;lt; &lt;span&gt;5&lt;/span&gt;) {&lt;br/&gt;         String var1 = &lt;span&gt;&quot;test&quot;&lt;/span&gt;;&lt;br/&gt;         &lt;span&gt;byte&lt;/span&gt; var2 = -&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;         &lt;span&gt;switch&lt;/span&gt;(var1.hashCode()) {&lt;br/&gt;         &lt;span&gt;case&lt;/span&gt; &lt;span&gt;3412756&lt;/span&gt;: &lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (var1.equals(&lt;span&gt;&quot;okay&quot;&lt;/span&gt;)) {&lt;br/&gt;               var2 = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;           }&lt;br/&gt;         &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;            &lt;span&gt;switch&lt;/span&gt;(var2) {&lt;br/&gt;            &lt;span&gt;case&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;:&lt;br/&gt;            }&lt;br/&gt;         }&lt;br/&gt;      } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;         System.out.println(&lt;span&gt;&quot;wow x2!&quot;&lt;/span&gt;);&lt;br/&gt;      }&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;五种反编译工具比较下来，结合&lt;strong&gt;反编译速度&lt;/strong&gt;和代码可读性测试，看起来 &lt;strong&gt;CFR&lt;/strong&gt; 工具胜出，&lt;strong&gt;Procyon&lt;/strong&gt; 紧随其后。CFR 在速度上不落下风，在反编译的代码可读性上，是最好的，主要体现在反编译后的&lt;strong&gt;变量命名&lt;/strong&gt;、&lt;strong&gt;装箱拆箱&lt;/strong&gt;、&lt;strong&gt;类型转换&lt;/strong&gt;，&lt;strong&gt;流程控制&lt;/strong&gt;上，以及对 &lt;strong&gt;Lambda&lt;/strong&gt; 表达式、&lt;strong&gt;Stream&lt;/strong&gt; 流式操作和 &lt;strong&gt;Switch&lt;/strong&gt; 的&lt;strong&gt;语法支持&lt;/strong&gt;上，都非常优秀。根据 CFR 官方介绍，已经支持到 Java 14 语法，而且截止写这篇测试文章时，CFR 最新提交代码时间实在 11 小时之前，更新速度很快。&lt;/p&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文中部分代码已经上传 GitHub 的 &lt;span&gt;niumoo/lab-notes 仓库 的 java-decompiler 目录。&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;span&gt;---- E&lt;/span&gt;&lt;span&gt;ND ----&lt;/span&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&quot;未读代码，一线技术工具人，认认真真写文章&quot;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4lfok2icUkibTUd7It7JewEpqb0rxtLyJE17XokYic4keU90H4vF2qOib0ib7HibVtUOzAa2M61a38XWPTgyeBUnGyMA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;点个在看，加油充电～&lt;/span&gt;&lt;strong&gt;&lt;span&gt;👇&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>febcd97027d114eeb4dfd3fd0edb9aee</guid>
<title>Go sync.Pool 浅析</title>
<link>https://toutiao.io/k/pwz9rfd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;hi, 大家好，我是 haohongfan。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Pool 应该是 Go 里面明星级别的数据结构，有很多优秀的文章都在介绍这个结构，本篇文章简单剖析下 sync.Pool。不过说实话 sync.Pool 并不是我们日常开发中使用频率很高的的并发原语。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽管用的频率很低，但是不可否认的是 sync.Pool 确实是 Go 的杀手锏，合理使用 sync.Pool 会让我们的程序性能飙升。本篇文章会从使用方式，源码剖析，运用场景等方面，让你对 sync.Pool 有一个清晰的认知。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;使用方式&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Pool 使用很简单，但是想用对却很麻烦，因为你有可能看到网上一堆错误的示例，各位同学在搜索 sync.Pool 的使用例子时，要特别注意。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Pool 是一个内存池。通常内存池是用来防止内存泄露的（例如C/C++)。sync.Pool 这个内存池却不是干这个的，带 GC 功能的语言都存在垃圾回收 STW 问题，需要回收的内存块越多，STW 持续时间就越长。如果能让 new 出来的变量，一直不被回收，得到重复利用，是不是就减轻了 GC 的压力。&lt;/p&gt;&lt;p&gt;正确的使用示例（下面的demo选自gin）&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request)&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;    c := engine.pool.Get().(*Context)&lt;br/&gt;    c.writermem.reset(w)&lt;br/&gt;    c.Request = req&lt;br/&gt;    c.reset()&lt;br/&gt;&lt;br/&gt;    engine.handleHTTPRequest(c)&lt;br/&gt;&lt;br/&gt;    engine.pool.Put(c)&lt;br/&gt;&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一定要注意的是：是先 Get 获取内存空间，基于这个内存做相关的处理，然后再将这个内存还回（Put）到 sync.Pool。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;Pool 结构&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9594813614262561&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/picLDrXZzlobSg2E3icVLJRibPFrYD9ib2Yw2tia1ibmh3uncc8BNUjUMwibcibPIB6aiadD6qNnicgp2XmdZxaaQ8Mo2a2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1234&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;sync.Pool 全景图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;源码图解&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9374262101534829&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/picLDrXZzlobSg2E3icVLJRibPFrYD9ib2YwZlMxIYhfR6LJjfA46S2B3fScFvGZB5icpulDpPr8iaicSjibKIxwiaib4Dlg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1694&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;Pool.Get&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7169811320754716&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/picLDrXZzlobSg2E3icVLJRibPFrYD9ib2YwibarZj8RGvpqCv3Ayx5vuu2JssAyPUSXJQibNicpkVjS3tLkbqvbUiaWXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1696&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;Pool.Put&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单点可以总结成下面的流程：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3131768953068592&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/picLDrXZzlobSg2E3icVLJRibPFrYD9ib2Yw6BXv3BOjcfSBLysfCdtBO9r6K0MGgS7sHXVMdfur1TbfiauvsgZ4sibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2216&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;Pool.Get 流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4831804281345566&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/picLDrXZzlobSg2E3icVLJRibPFrYD9ib2Ywz8NQU7nn3wZxBAibsJRwMQ1b4waLqOaBliaf7GtVqIn2nJPyrR9zvJpg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1308&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;Pool.Put流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.23261117445838084&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/picLDrXZzlobSg2E3icVLJRibPFrYD9ib2YwNPHyvpGjSyKFiar4mibibU3XrOm3VZC8nW2lfpujnEnaNUuqQiaibec42uw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1754&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;Pool GC 流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Sync.Pool 梳理&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;Pool 的内容会清理？清理会造成数据丢失吗？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 会在每个 GC 周期内定期清理 sync.Pool 内的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要分几个方面来说这个问题。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;已经从 sync.Pool Get 的值，在 poolClean 时虽说将 pool.local 置成了nil，Get 到的值依然是有效的，是被 GC 标记为黑色的，不会被 GC回收，当 Put 后又重新加入到 sync.Pool 中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在第一个 GC 周期内 Put 到 sync.Pool 的数值，在第二个 GC 周期没有被 Get 使用，就会被放在 local.victim 中。如果在 第三个 GC 周期仍然没有被使用就会被 GC 回收。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;runtime.GOMAXPROCS 与 pool 之间的关系？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;s := p.localSize&lt;br/&gt;l := p.local&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;uintptr&lt;/span&gt;(pid) &amp;lt; s {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; indexLocal(l, pid), pid&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; p.local == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    allPools = &lt;span&gt;append&lt;/span&gt;(allPools, p)&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// If GOMAXPROCS changes between GCs, we re-allocate the array and lose the old one.&lt;/span&gt;&lt;br/&gt;size := runtime.GOMAXPROCS(&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;local := &lt;span&gt;make&lt;/span&gt;([]poolLocal, size)&lt;br/&gt;atomic.StorePointer(&amp;amp;p.local, unsafe.Pointer(&amp;amp;local[&lt;span&gt;0&lt;/span&gt;])) &lt;span&gt;// store-release&lt;/span&gt;&lt;br/&gt;runtime_StoreReluintptr(&amp;amp;p.localSize, &lt;span&gt;uintptr&lt;/span&gt;(size))     &lt;span&gt;// store-release&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;runtime.GOMAXPROCS(0) 是获取当前最大的 p 的数量。sync.Pool 的 poolLocal 数量受 p 的数量影响，会开辟 runtime.GOMAXPROCS(0) 个 poolLocal。某些场景下我们会使用 runtime.GOMAXPROCS（N) 来改变 p 的数量，会使 sync.Pool 的 pool.poolLocal 释放重新开辟新的空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么要开辟 runtime.GOMAXPROCS 个 local？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;pool.local 是个 poolLocal 结构，这个结构体是 private + shared链表组成，在多 goroutine 的 Get/Put 下是有数据竞争的，如果只有一个 local 就需要加锁来操作。每个 p 的 local 就能减少加锁造成的数据竞争问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;New() 的作用？假如没有 New 会出现什么情况？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的 pool.Get 流程图可以看出来，从 sync.Pool 获取一个内存会尝试从当前 private，shared，其他的 p 的 shared 获取或者 victim 获取，如果实在获取不到时，才会调用 New 函数来获取。也就是 New() 函数才是真正开辟内存空间的。New() 开辟出来的的内存空间使用完毕后，调用 pool.Put 函数放入到 sync.Pool 中被重复利用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果 New 函数没有被初始化会怎样呢？很明显，sync.Pool 就废掉了，因为没有了初始化内存的地方了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;先 Put，再 Get 会出现什么情况？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「一定要注意，下面这个例子的用法是错误的」&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    pool:= sync.Pool{&lt;br/&gt;        New: &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;/span&gt;{} {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; item{}&lt;br/&gt;        },&lt;br/&gt;    }&lt;br/&gt;    pool.Put(item{value:&lt;span&gt;1&lt;/span&gt;})&lt;br/&gt;    data := pool.Get()&lt;br/&gt;    fmt.Println(data)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你直接跑这个例子，能得到你想像的结果，但是在某些情况下就不是这个结果了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Pool.Get 注释里面有这么一句话：“Callers should not assume any relation between values passed to Put and the values returned by Get.”，告诉我们不能把值 Pool.Put 到 sync.Pool 中，再使用 Pool.Get 取出来，因为 sync.Pool 不是 map 或者 slice，放入的值是有可能拿不到的，sync.Pool 的数据结构就不支持做这个事情。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面说使用 sync.Pool 容易被错误示例误导，就是上面这个写法。为什么 Put 的值 再 Get 会出现问题？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;情况1：sync.Pool 的 poolCleanup 函数在系统 GC 时会被调用，Put 到 sync.Pool 的值，由于有可能一直得不到利用，被在某个 GC 周期内就有可能被释放掉了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;情况2：不同的 goroutine 绑定的 p 有可能是不一样的，当前 p 对应的 goroutine 放入到 sync.Pool 的值有可能被其他的 p 对应的 goroutine 取到，导致当前 goroutine 再也取不到这个值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;情况3：使用 runtime.GOMAXPROCS（N) 来改变 p 的数量，会使 sync.Pool 的 pool.poolLocal 释放重新开辟新的空间，导致 sync.Pool 被释放掉。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;情况4：还有很多情况&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;只 Get 不 Put 会内存泄露吗？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用其他的池，如连接池，如果取连接使用后不放回连接池，就会出现连接池泄露，&lt;strong&gt;「是不是 sync.Pool 也有这个问题呢？」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面的流程图，可以看出来 Pool.Get 的时候会尝试从当前 private，shared，其他的 p 的 shared 获取或者 victim 获取，如果实在获取不到时，才会调用 New 函数来获取，New 出来的内容本身还是受系统 GC 来控制的。所以如果我们提供的 New 实现不存在内存泄露的话，那么 sync.Pool 是不会内存泄露的。当 New 出来的变量如果不再被使用，就会被系统 GC 给回收掉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不 Put 回 sync.Pool，会造成 Get 的时候每次都调用的 New 来从堆栈申请空间，达不到减轻 GC 压力。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;使用场景&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面说到 sync.Pool 业务开发中不是一个常用结构，我们业务开发中没必要假想某块代码会有强烈的性能问题，一上来就用 sync.Pool 硬怼。sync.Pool 主要是为了解决 Go GC 压力过大问题的，所以一般情况下，当线上高并发业务出现 GC 问题需要被优化时，才需要用 sync.Pool 出场。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;使用注意点&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;sync.Pool 同样不能被复制。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;好的使用习惯，从 pool.Get 出来的值进行数据的清空（reset），防止垃圾数据污染。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;本文基于的 Go 源码版本：1.16.2&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;参考链接&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;深度解密 Go 语言之 sync.Pool https://www.cnblogs.com/qcrao-2018/p/12736031.html&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;请问sync.Pool有什么缺点？&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIyMTY3NDI3Ng==&amp;amp;mid=2247483691&amp;amp;idx=1&amp;amp;sn=92aa7a03d8229f64eee183ad118a3336&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;https://mp.weixin.qq.com/s/2ZC1BWTylIZMmuQ3HwrnUg&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Go 1.13中 sync.Pool 是如何优化的? https://colobu.com/2019/10/08/how-is-sync-Pool-improved-in-Go-1-13/&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Pool 的剖析到这里基本就写完了，想跟我交流的可以在评论区留言。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Pool 完整流程图获取链接：链接: https://pan.baidu.com/s/1T5e8qCzp8JcTgARZFjGQoQ  密码: ngea 其他模块流程图，请关注公众号回复1获取。学习资料分享，关注公众号回复指令：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;回复 0，获取 《Go 面经》&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;回复 1，获取 《Go 源码流程图》&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAwMDY4ODg5MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/picLDrXZzlob0NQenCHM7wrDdQicgdcYyDWDr78gNib4SBlxN6QnF644ytlDHx8EMq4DzbLWYqsajAXWQGDRZQ00g/0?wx_fmt=png&quot; data-nickname=&quot;HHFCodeRv&quot; data-alias=&quot;hhfcodearts&quot; data-signature=&quot;资深 Go 开发, Dubbogo commiter, 分享一些开发日常&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2dcba8279be74b5ef5a14ac703e1b3c9</guid>
<title>如何快速实现一个聊天室？</title>
<link>https://toutiao.io/k/6xcz0t9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;如何快速实现一个聊天室？&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5384615384615384&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/JJRW7FxQREz58QHz9k1ZDfgvLLIGqToR9cEK0XfhaNezuiaib8NlZjwqBEBaW8EK9QHVaNWibfiauic2LfJwnLAHQNQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;936&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;聊天室&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前些天做了一个网站：https://modubox.cn 其中有个群聊插件，许多人问如何实现的。这里简单说下，为了快速完成群聊功能，我选择从最简单的 WebSocket 开始。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;什么是WebSocket ？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然要使用它，就需要了解一下它吧。WebSocket其实也是一种基于TCP的网络协议，它与HTTP协议最大的不同是：是一种双向通信协议，在建立连接后，WebSocket服务器端和客户端都能主动向对方发送或接收数据，而HTTP协议只能客户端主动发起通信。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以WebSocket能够用于聊天，当然其他地方也能应用，如果做客服系统或推送消息都可以从这里开始。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;如何实现单聊/群聊？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;群聊：所有客户端的消息发送到服务器，服务端将消息发送给所有客户端。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单聊：WebSocket客户端之间是无法直接通信的，想要通信，必须由服务端转发。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.555&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/JJRW7FxQREz58QHz9k1ZDfgvLLIGqToRqr9iaZM2vdviaOWVibylkiaJhsdArOIO5r3D8WMSrSzicTW7bgCWpSB17sA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;群聊单聊&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;实现&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 引入WebSocket的支持&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们使用当前最流行的Spring Boot框架构建项目，然后引入Spring Boot 对 WebSocket 的支持：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-websocket&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 开启WebSocket&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;WebSocketConfig&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; ServerEndpointExporter &lt;span&gt;serverEndpointExporter&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ServerEndpointExporter();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 服务端&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里主要有以下几点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;声明服务端点路径&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;存储所有连接用户，等待匹配用户&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;连接 onOpen，消息OnMessage，关闭onClose，错误onError 方法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;发送消息给特定连接者&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@ServerEndpoint&lt;/span&gt;(value = &lt;span&gt;&quot;/websocket/random/&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ChatRandomServer&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//所有连接&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ConcurrentHashMap&amp;lt;String, ChatRandomServer&amp;gt; webSocketSet = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;//与某个客户端的连接会话，需要通过它来给客户端发送数据&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Session session;&lt;br/&gt;    &lt;span&gt;//所有在配对的ID&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;String&amp;gt; webSocketLiveList = &lt;span&gt;new&lt;/span&gt; CopyOnWriteArrayList();&lt;br/&gt;    &lt;span&gt;//自己的id标识&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String id = &lt;span&gt;&quot;&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;//连接对象的id标识&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String toUser = &lt;span&gt;&quot;&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 连接建立成功调用的方法&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@OnOpen&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onOpen&lt;/span&gt;&lt;span&gt;(Session session)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        session.setMaxIdleTimeout(&lt;span&gt;3600000&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.session = session;&lt;br/&gt;        &lt;span&gt;//获取用户ip&lt;/span&gt;&lt;br/&gt;        String ip = IpUtil.getRemoteAddress(session);&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.id = ip;&lt;br/&gt;        ChatRandomServer put = webSocketSet.put(&lt;span&gt;this&lt;/span&gt;.id, &lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;//如果已经在队里，就不去找对象&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (put == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (pair()) {&lt;br/&gt;                    sendMessage(&lt;span&gt;&quot;匹配成功&quot;&lt;/span&gt;);&lt;br/&gt;                }&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                sendMessage(&lt;span&gt;&quot;匹配失败&quot;&lt;/span&gt;);&lt;br/&gt;                webSocketSet.remove(&lt;span&gt;this&lt;/span&gt;.id); &lt;br/&gt;                session.close();&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;        }&lt;br/&gt;        log.info(&lt;span&gt;&quot;用户{}加入！当前在线人数为: {}&quot;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.id, webSocketSet.size());&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 连接关闭调用的方法&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@OnClose&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onClose&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ChatRandomServer UserId = webSocketSet.get(toUser);&lt;br/&gt;        webSocketLiveList.remove(&lt;span&gt;this&lt;/span&gt;.id);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (UserId != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                sendToUser(session, &lt;span&gt;&quot;对方已离开&quot;&lt;/span&gt;, toUser);&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        webSocketSet.remove(&lt;span&gt;this&lt;/span&gt;.id);&lt;br/&gt;        log.info(&lt;span&gt;&quot;{}连接关闭！当前在线人数:{}, 当前在匹配的人数:{}&quot;&lt;/span&gt; ,&lt;span&gt;this&lt;/span&gt;.id,webSocketSet.size(), webSocketLiveList.size());&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 收到客户端消息后调用的方法&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; message 客户端发送过来的消息&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@OnMessage&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onMessage&lt;/span&gt;&lt;span&gt;(String message, Session session)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        log.info(&lt;span&gt;&quot;来自 {} 的消息: {}&quot;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.id, message);&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            ChatRandomServer.sendToUser(session, message, toUser, &lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@OnError&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onError&lt;/span&gt;&lt;span&gt;(Session session, Throwable error)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        log.error(&lt;span&gt;&quot;发生错误&quot;&lt;/span&gt;);&lt;br/&gt;        error.printStackTrace();&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            SendSelf(session,&lt;span&gt;&quot;服务器出现错误&quot;&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 发送消息给自己&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;sendMessage&lt;/span&gt;&lt;span&gt;(String message)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        SendSelf(&lt;span&gt;this&lt;/span&gt;.session, message);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;SendSelf&lt;/span&gt;&lt;span&gt;(Session session, String message)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        session.getBasicRemote().sendText(message);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 发送信息给指定ID用户&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;sendToUser&lt;/span&gt;&lt;span&gt;(Session session, String message, String sendUserId)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        ChatRandomServer UserId = webSocketSet.get(sendUserId);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (UserId != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            UserId.sendMessage(message);&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            SendSelf(session, &lt;span&gt;&quot;发送失败&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 通知除了自己之外的所有人&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;sendOnlineCount&lt;/span&gt;&lt;span&gt;(String message)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (String key : webSocketSet.keySet()) {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (key.equals(id)) {&lt;br/&gt;                    &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;                }&lt;br/&gt;                webSocketSet.get(key).sendMessage(message);&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 发送信息给所有人&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;sendToAll&lt;/span&gt;&lt;span&gt;(String message)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (String key : webSocketSet.keySet()) {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                webSocketSet.get(key).sendMessage(message);&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;pair&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//是否存在等待匹配的用户&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (webSocketLiveList.size() &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;//随机匹配一个&lt;/span&gt;&lt;br/&gt;            Random ra = &lt;span&gt;new&lt;/span&gt; Random();&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; nextInt = ra.nextInt(webSocketLiveList.size());&lt;br/&gt;            toUser = webSocketLiveList.get(nextInt);&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                ChatRandomServer UserId = webSocketSet.get(toUser);&lt;br/&gt;                UserId.setToUser(id);&lt;br/&gt;                sendToUser(session, &lt;span&gt;&quot;配对成功&quot;&lt;/span&gt;, toUser);&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;            webSocketLiveList.remove(nextInt);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//没有匹配的，则将自己加入等待匹配队列&lt;/span&gt;&lt;br/&gt;        webSocketLiveList.add(id);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. 前端支持&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt; start: &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; (WebSocket) === &lt;span&gt;&quot;undefined&quot;&lt;/span&gt;) {&lt;br/&gt;          alert(&lt;span&gt;&quot;您的浏览器不支持socket&quot;&lt;/span&gt;)&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;          &lt;span&gt;// 实例化socket&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;this&lt;/span&gt;.socket = &lt;span&gt;new&lt;/span&gt; WebSocket(&lt;span&gt;`ws://localhost:8082/websocket/room`&lt;/span&gt;);&lt;br/&gt;          &lt;span&gt;// 监听socket连接&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;this&lt;/span&gt;.socket.onopen = &lt;span&gt;this&lt;/span&gt;.open&lt;br/&gt;          &lt;span&gt;// 监听socket错误信息&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;this&lt;/span&gt;.socket.onerror = &lt;span&gt;this&lt;/span&gt;.error&lt;br/&gt;          &lt;span&gt;// 监听socket消息&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;this&lt;/span&gt;.socket.onmessage = &lt;span&gt;this&lt;/span&gt;.getMessage&lt;br/&gt;          &lt;span&gt;this&lt;/span&gt;.socket.onclose = &lt;span&gt;this&lt;/span&gt;.close&lt;br/&gt;        }&lt;br/&gt;      },&lt;br/&gt;      &lt;span&gt;open&lt;/span&gt;: &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;      },&lt;br/&gt;      &lt;span&gt;error&lt;/span&gt;: &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;      },&lt;br/&gt;      &lt;span&gt;getMessage&lt;/span&gt;: &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;obj&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//接收信息后根据不同情况不同处理方式&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; data = &lt;span&gt;JSON&lt;/span&gt;.parse(obj.data);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (data.code === &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (data.code === &lt;span&gt;2&lt;/span&gt;) {&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        }&lt;br/&gt;      },&lt;br/&gt;      &lt;span&gt;close&lt;/span&gt;: &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;e&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;      },&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;doSend&lt;/span&gt;: &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (that.sendData === &lt;span&gt;&#x27;&#x27;&lt;/span&gt;) {&lt;br/&gt;          &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.socket.send(that.sendData);&lt;br/&gt;        that.sendData = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;      },&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上代码不完整，如果需要看下完整代码，联系我。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;500&quot; data-backw=&quot;500&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;256&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;257&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JJRW7FxQRExGEvHCSlBlBDLibfHJXldiaZ96rd67AIDF213cJzwICFLdUOFuib9cCibV1G8WVsG983iaRQZ1v1LRkUw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;300&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b1c9cff728553936a0a849311b7b75a8</guid>
<title>实践解析 | 如何通过 WebAssembly 在 Web 进行实时视频人像分割</title>
<link>https://toutiao.io/k/3auey0k</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;5 月 15 日，声网Agora 高级架构师高纯参加了 WebAssambly 社区举办的第一场线下活动“WebAssembly Meetup”，并围绕声网Agora 在 Web 实时视频人像分割技术的应用落地，分享了实践经验。以下为演讲分享整理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qlogo.cn/mmbiz_jpg/YO07vjlZVBEL86uUh6Az7NfWTWEX7AGoG0fsNBaGRGibNeADYBGvBVX2ZGQp2nNW4bq3dPkKHW7MffJcj8SkbtA/0?wx_fmt=jpeg&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1280&quot; data-cropy1=&quot;132.87197231833912&quot; data-cropy2=&quot;719.7231833910035&quot; data-ratio=&quot;0.45859375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YO07vjlZVBEL86uUh6Az7NfWTWEX7AGoKZfquzAlXgU6VAKxI1ico2tV5t5eKMLkb00q8oqwribDkZq7yrh42C4g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;RTC 行业在近几年的发展日新月异，在线教育、视频会议等场景繁荣蓬勃。&lt;/span&gt;&lt;span&gt;场景的发展也给技术提出了更高的要求。&lt;/span&gt;&lt;span&gt;于是，机器学习越来越多地应用到了实时音视频场景中，比如超分辨率、美颜、实时美声等。&lt;/span&gt;&lt;span&gt;这些应用在 Web 端也存在同样的需求，同时也是所有音视频开发者面对的挑战。&lt;/span&gt;&lt;span&gt;所幸 WebAssembly 技术为 Web 高性能计算提供了可能。&lt;/span&gt;&lt;span&gt;我们首先围绕 Web 端的人像分割应用进行了探索实践。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;93408&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;195.32421875:401.62109375&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;视频人像分割都用在什么场景？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;提到人像分割，我们首先想到的应用场景，就是在影视制作中的绿幕抠图。在绿幕环境下拍摄视频后，经过后期制作，将背景替换成电脑合成的电影场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另一种应用场景大家应该都见过。在 B 站上，你会发现有些视频的弹幕不会遮挡画面上的人物，文字会从人像的后面穿过。这也是基于人像分割技术。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上列举的人像分割技术都是在服务端实现的，而且不是实时音视频场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而我们声网做的人像分割技术适用于视频会议、在线教学等实时音视频场景。我们可以通过人像分割技术，可以对视频的背景进行模糊处理，或替换视频背景。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p/&gt;&lt;p&gt;&lt;span&gt;为什么这些实时场景需要这项技术呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最近的一项研究发现，在平均 38 分钟的电话会议中，有整整 13 分钟的时间被浪费在处理干扰和中断上。从在线面试、演讲和员工培训课程到集思广益、销售推介、IT 协助、客户支持和 网络研讨会，所有这些情况都面临同样的问题。因此，使用背景模糊或从自定义和预设的许多虚拟背景选项中选择一个，可以大大减少干扰。&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;还有一项调查显示，有 23％ 的美国员工表示视频会议让他们感到不舒服；75％ 的人表示他们仍然更喜欢语音会议，而不是视频会议。这是由于人们不希望将自己的居住环境、隐私暴露在公众视野中。那么通过替换视频背景，就可以解决这个问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前，实时音视频场景下的人像分割、虚拟背景，大多是运行在原生客户端上的。只有 Google Meet 利用 WebAssembly 实现过在 Web 实时视频中的人像分割。声网的实现是结合机器学习、WebAssembly、WebGL 等技术实现的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;93408&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;195.32421875:401.62109375&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Web 实时视频虚拟背景的实现&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;人像分割的技术组件和实时处理流程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3455621301775148&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBEL86uUh6Az7NfWTWEX7AGoklOE3v9Ib2eLiblh0ws0QziaM2Iy6NHKjcAzMOOfWdiaDEmYzdg0ftGmQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1690&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在做 Web 的人像分割时，我们还会需要用到这些组件：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;人像分割的实时处理流程是这样的。首先会利用 W3C 的 MediaStream 的 API 进行采集。然后数据会交给 WebAssembly 的引擎去进行预测。因为机器学习的运算开销较大，这就要求输入的数据不能太大，所以需要在输入到机器学习框架前对视频图像做一些缩放的处理或归一化。运算结果从 WebAssembly 输出后还要进行一些后处理，然后再传递给 WebGL。WebGL 会通过这些信息与原始视频信息来做滤波、叠加等处理，最后生成出的结果。这些结果会到 Canvas 上，然后通过 Agora Web SDK 来进行实时传输。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.46482122260668973&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBEL86uUh6Az7NfWTWEX7AGo2ZQT6aib7OhW13KEZb3KdzRvcgzjDTFrfKEia5d65bib4O87DIS4Oz6yg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1734&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;机器学习框架的选择&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们在做这样的人像分割之前，肯定会考虑是不是有现成的机器学习框架。目前可用的包括 ONNX.js、TensorFlow.js、Keras.js、MIL WebDNN 等。它们都会采用 WebGL 或 WebAssembly 作为运算后端。但是在尝试这些框架的时候，都发现了一些问题：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;1.缺少对模型文件的必要保护。一般在运行的时候会让浏览器从服务端把模型加载过来。那么模型会直接暴露在浏览器客户端上。这不利于知识产权保护。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.通用 JS 框架 IO 设计未考虑实际场景。比如 TensorFlow.js 的输入是通用数组，在运算的时候会将内容包装成 InputTensor，然后交给 WebAssembly 或上传为 WebGL 纹理来处理。这个过程相对复杂，在处理对实时性要求很高的视频数据时性能得不到保障。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.算子支持不完善。通用框架或多或少会缺少可以处理视频数据的算子。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;对于这些问题，我们的解决策略是这样的：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;1.实现原生机器学习框架的 Wasm 移植。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.对于没有实现的算子，我们通过定制来补齐。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.性能方面，我们用 SIMD （单指令多数据流的指令集）和多线程来进行优化。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;视频数据预处理&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;数据的预处理需要对图像进行缩放。在前端一般有两种方式来做：一种是用 Canvas2D，另一种是使用 WebGL。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;通过 Canvas2D.drawImage()把 Video 元素里的内容画到 Canvas 上，然后用 Canvas2D.getImageData() 来获取你需要缩放的图像尺寸。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;WebGL 本身可以将 Video 元素本身作为一个参数上传成为纹理。WebGL 也提供了从 FrameBuffer 里读取 Video 数据的能力。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们也对这两种方法的性能进行了测试，如下图所示，在 x86_64 window10 的环境下，在两种浏览器上，分别测试了三种分辨率的视频在Canvas2D 和 WebGL 上的预处理时间开销。你可以从中判断出在针对不同分辨率的视频进行预处理时，应该选用的方法。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3690205011389522&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBEL86uUh6Az7NfWTWEX7AGoFibDoLyxFmpknWecRibMHicgQSLsY6dUEz0YoNW9sS11QXibKquK13cGvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1756&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;Web Workers 及多线程问题&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;由于 Wasm 计算开销过大，会导致 JS 主线程阻塞。而且当遇到一些比较特殊的情况，比如进入一家咖啡馆，附近没有电源，那么设备就会处于低能耗模式，这时候 CPU 会降频，从而可能引起的视频处理丢帧。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，我们要提升性能。在这里，我们用到的是 Web Workers。我们将机器学习推理运算运行在 Web Worker 上，能有效减少 JS 主线程的阻塞。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;使用方法也比较简单。主线程来创建 Web Worker，它会在另一个线程上运行。主线程通过 worker.postMessage 给它发消息，让 worker 来访问。（如下述代码示例）&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.23603192702394526&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBEL86uUh6Az7NfWTWEX7AGozQ1CibGWy7mwQsErW9W1ALIibd3RxJKebCld257ElAQI8PbAQlyC1hOA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1754&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但这也可能会引入一些新的问题：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;针对这两个问题，我们也做了一些分析。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当传输数据的时候，你的数据是 JS原始数据类型、ArrayBuffer 、 ArrayBufferView、lImageData，或 File / FileList / Blob，或 Boolean / String / Object / Map / Set 类型的时候，那么 postMessage 会使用结构化克隆算法进行深拷贝。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们在 JS 主线程和 WebWorkers 之间或不同 page 之间进行数据传输的性能测试。如下图所示，测试环境是 x86_64 window10 的电脑。测试结果如下：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7350427350427351&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBEL86uUh6Az7NfWTWEX7AGov9g2rnibxQgNefad8TPlyxPyhnTe0AATP9iaxG9GNPpIcCrPzBMpXmLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;936&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;我们预处理后的数据大概在 200KB 以下，所以可以从上图对比看出，时间开销会在 1.68ms 以下。这种性能开销几乎可以忽略不计。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果你想要避免结构化拷贝，那么可以采用 SharedArrayBuffer。顾名思义，SharedArrayBuffer 原理是让主线程与 Worker 共享一块内存区域，做到同时存取数据。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.32632743362831856&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBEL86uUh6Az7NfWTWEX7AGoKdULjU9vsrH2I0bYjMOFknxicRSl470CwXMSqA3Zc3CIaRfx3MVZ2iaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1808&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;但是与所有的共享内存方法一样（包括原生的），SharedArrayBuffer 也会出现资源竞争的问题。那么这时候就需要 JS 引入额外的机制来处理竞争。JavaScript 中的 Atomics 就是为解决这个问题而诞生的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们声网在做人像分割的时候也尝试过 SharedArrayBuffer，也发现了它还会引发一些问题。首先一点就是兼容性问题。目前只有 Chrome 67 版本以上能使用 SharedArrayBuffer。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;要知道，在 2018 之前，Chrome、Firefox 两个平台都支持 SharedArrayBuffer，但是 18 年所有 CPU 都被爆出了两个严重漏洞，Meltdown 和 Spectre，它们会导致进程之间的数据隔离被打破，于是两个浏览器就禁用了 SharedArrayBuffer。直到 Chrome 67 做了站点上的进程隔离之后，才又开始允许使用 SharedarrayBuffer。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另一个问题就是开发难度比较高。为解决资源竞争引入的 Atomics 对象使前端开发难度不亚于原生语言的多线程编程。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;WebAssembly 模块的功能与实现策略&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;WebAssembly 主要负责人像分割。我们要实现的主要功能以及实现策略如下：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3975501113585746&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBEL86uUh6Az7NfWTWEX7AGoz8ibiale5tYkgFmkFQ43PrFTEcY5nZzllfD55RkI38vqCVDdZLOib4aGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1796&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其中，机器学习模型会有不同的向量、矩阵的运算框架。以 TensorFlow 为例，它有三套运算框架：XNNPACK、Eigen、ruy。实际上它们在不同平台上的性能都有差异。我们对此也进行了测试。在 x86_64 window10 环境下的测试结果如下。可以明显看到在我们的处理场景下 XNNPACK 的表现是最好的，因为它是专门针对浮点运算进行了优化的运算框架。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3687089715536105&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBEL86uUh6Az7NfWTWEX7AGoHrjaxCIhdHWicZpWRMzia45cKberm6ib2Sl7SOCic6aSeeLAPicRhticRbHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1828&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;这里我们只是展示了 x86 下的运算测试结果，并不能代表所有平台上的最终结果。因为 ruy 这个框架是 TensorFlow 在移动平台上的默认运算框架，它对 ARM 架构优化更好。所以我们也在别的不同平台上进行了测试。这里就不做一一分享了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;WASM 多线程&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;开启 WASM 多线程可将 pthread 映射到 Web Workers，将 pthread mutex 方法映射到 Atomics 方法。在开启多线程之后，人像分割场景在 4 线程时性能提升达到最大值，提升幅度达到了 26%。线程的使用不是越多越好，因为本身会有调度开销。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3574097135740971&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBEL86uUh6Az7NfWTWEX7AGoU3R2HKKX9oW1IV7af8GKocBzFaBm0iaiaSZPkulibRh7eZL77nnibTLjUw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1606&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后，我们在通过人像分割处理后，会通过 WebGL 来实现图像的滤波、抖动消除与画面合成，最后会得到下图的效果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4192355117139334&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBEL86uUh6Az7NfWTWEX7AGogzkpb7SdBlib7PbM0Pjbf3I9r2QibJgm3IeBf0PmlGAfUOgdq3BmYswg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1622&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;93408&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;195.32421875:401.62109375&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;目前在使用 WebAssembly 的过程中还存在一些痛点。首先在上文提到过，我们会通过 SIMD 指令来优化计算效率。目前 WebAssembly 的 SIMD 指令优化仅支持 128-bit 数据宽度。所以目前社区中也有很多人提出，如果可以实现对 256-bit AVX2 及512-bit AVX512 指令的支持能进一步改善并行运算性能。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;第二，目前 WebAssambly 是无法直接访问 GPU 的。如果它能够提供较直接的OpenGL ES 调用能力，则可避免 OpenGL ES 到 WebGL 的 JSBridge 性能开销。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;第三，目前 WebAssambly 还无法直接访问音视频数据。从Camera和Mic采集的数据需要经过较多的处理步骤才能到达wasm。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最后，针对 Web 端人像分割，我们总结了几点：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;WebAssembly是Web平台使用机器学习的正确方法之一&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;特定情况下启用SIMD、多线程带来性能提升有显著意义&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;当基本运算性能和算法设计较差时，SIMD、多线程带来的性能提升意义不大&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;使用WebGL进行视频处理和渲染时，WebAssembly输出数据需保持WebGL纹理采样的格式兼容&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;运用WebAssembly进行实时视频处理时需考虑整个Web处理流程中的关键开销，并做合适优化提升整体性能&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;如果想了解更多关于 Web 端人像分割的相关实践经验，欢迎访问 rtcdeveloper.com 发帖与我们交流。阅读更多技术实践干货，请访问 agora.io/cn/community。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.24300310972900932&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBGiaH4Bkto9ORXASBJJS5mIFEGsKMSxsjNwPfDg3p3TtMltLXArMLibIQO6x3LZkOPDUI2C30Dofz9g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2251&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>