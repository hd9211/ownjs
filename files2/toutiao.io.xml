<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>7e0588d7b2e4097af4d6378acb7339b1</guid>
<title>优雅整洁的 Java 代码命名技巧，风之极·净化</title>
<link>https://toutiao.io/k/abc8vou</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;&lt;span&gt;可能是最全的命名规范，建议收藏，文末抽奖福利。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.562962962962963&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/EoJib2tNvVtdsxhk6iazHH8Yfoyz95eLhOqLCsQcKbVL29Wx3PibOSxseYoKnI7zcXibn7tP2Z07yvLJBevtx4s4sw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;合格的程序员不仅仅是让代码跑起来，而是要做到代码整洁，只满足为了能让编译器通过编译，机器能跑就行而写代码的程序会算不上开发者，码农都不算。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好的命名能体现出代码的特征，含义或者是用途，让阅读者可以根据名称的含义快速厘清程序的脉络。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本篇分享如下代码命名套路来提高我们代码命名：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;勿模糊，准确达意&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;避免误导&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;做有意义的区分&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;结合上下文简化名称&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用可搜索、易读的名称&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;包命名规范&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;类名与方法名规范&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;混乱的代价&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我相信每个程序员都被某些人的垃圾代码恶心过，导致开发进度被严重延缓、性能差劲、bug 多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每次新增和修改代码如履薄冰，我们只有对那堆腐朽的代码了然于胸才敢修改。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着时间推移，团队生产力下降，所有人都抵触这个项目，对其束手无策。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新手不熟悉原来的场景和设计，不知道如何修改才符合实际意图，导致更容易出现混乱。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，开发团队产生了抵触心理并造反了，再也无法忍受在这个垃圾代码基础上做开发，而管理层不愿意投入资源重新设计。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;一个优秀的开发者应该时刻保持代码整洁，无关 deadline。&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;为什么会写出垃圾代码呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有的人可能会说，需求变化违背了最初的设计、排期太紧没法干好......&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，这是一种不专业的托词。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推进进度是产品经理他们该干的，虽然痴迷于进度，但是多数产品经理也会期望有良好的可拓展代码以便应对市场变换莫测的需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;连海誓山盟的爱情都会变，又如何做到需求不会改变呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们比他们更加重视代码质量，才能应对变化的需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;保护代码持续整洁优雅是每个优秀开发者都应该遵守的原则。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;混乱的代码只会拖慢未来的开发进度，唯一加快进度的方法：&lt;strong&gt;始终尽可能保持代码优雅整洁&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好比医生在做手术之前要先消毒，你说消毒太耗时间了，直接拿刀子整吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为专业的医生你会照做么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;作为专业的程序员，我们要了解代码变坏的风险并坚持保持代码质量。&lt;/strong&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是整洁代码&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码质量评判需要综合各种因素得到的，我们并不能从单一的维度去评判。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如代码可读性好，但是空间与时间复杂度高，这并不能算得上是好代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好的代码应该具备：&lt;strong&gt;易拓展和维护、简洁（只做好一件事）、可复用性强（没有重复代码）、能快速写出单元测试。可读性强、没有副作用（做了名称以外的工作）。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5455974842767296&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EoJib2tNvVtdsxhk6iazHH8Yfoyz95eLhOM9Vh4F4vDIOmzZVvpYYtqNlJfnI9yRMzvSR4Hb7EGNj6wEWAqBnicZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;636&quot;/&gt;*&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;易拓展和维护&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在不破坏原来的代码设计下，可以简单快速的修改和添加代码实现功能拓展。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单地说就是预留了拓展点，将新代码放在设计的可拓展点，不会因为新增一个功能而改动大量原始代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;对修改关闭，对拓展开放，开闭原则。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于开发而言，我们维护旧代码的时间超过新项目新代码的时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码的可维护性就变得很重要，也就是说代码分层清晰、模块划分精当，满足高内聚低耦合、抽象出合理的接口，面向接口编程就意味着有较好的可维护性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样的代码，熟悉他的资深工程师会觉得很容易维护，而新人因为不熟悉代码，不懂设计模式而无法理解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，易拓展具有主观性，我们需要提高基础技能才有资格说代码是否易拓展和维护。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;只做好一件事&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单一职责：每个函数、每个类、每个模块只专注于一件事。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不要设计大而全的类或者函数，我们需要将他们拆分成更细粒度功能更加单一的类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它不会隐藏设计者的意图，干净利落的抽象和直截了当的控制语句。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们应该让每个函数每行代码简单、逻辑清晰。这样的话，类依赖和被依赖的类也会变少，减少耦合度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是，也不能拆分太细，否则就会破坏内聚性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;高手，就是用最简单的方法去解决复杂问题。&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;没有重复代码&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在开发过程中，我们应该尽可能抽象出「变与不变」，复用已经存在的代码，不要写重复的代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如运用「封装、继承、抽象、多态」特性，代码封装成模块，隐藏变化的细节，暴露不变的接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把业务与非业务的代码逻辑分析，抽象成通用的框架、工具类等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如应用模板方法设计模式将不变的算法逻辑框架定义出来，把变化的点延迟到子类重写。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;能快速写成单元测试&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码的可测试性差，比较难写单元测试，那基本上就能说明代码设计得有问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;试想下，如果一个类大而全，有一个方法依赖了十几个外部对象才能完成工作，耦合严重。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当你在编写单元测试的时候，需要 mock 十几个依赖对象和数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那说明这个代码糟透了，需要合理拆分和设计。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;可读性强&lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;软件设计大师 Martin Fowler 说过：「Any fool can write code that a computer can understand. Good programmers write code that humans can understand.」&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;翻译成中文就是：&quot;任何二货都会编写计算机能跑的代码。优秀的程序员能够编写人能够理解的代码。”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而可读性就会涉及到编码规范、命名、注释、函数职责是否单一、长度是否精简。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;有数据显示读代码的时间与写代码的时间比例超过 10：1，并且编写当前代码的难度，取决于读周边代码的难度。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我认为可读性强是最重要的一点。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;高质量命名套路&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开发过程后命名随处可见，我们给变量、方法、参数、类、包命名。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而命名的好坏会影响我们的可读性，我们不妨从命名作为切入口来写好代码。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;勿模糊，准确达意&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在开发过程中，一旦发现更好的名称，就换掉旧的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个变量、方法、或者类的名称应该展示出它该有的功能。根据名字我们能知道它能做什么事情，如何使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如果一个名称需要大量注释来补充避免使用者跳坑，那就是糟糕的名字。&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;变量名体现出该字段作用，比如  &lt;code&gt;LocalDate now = LocaDate.now();&lt;/code&gt;  now 标识当前时间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;防止出现让人模糊无法理解，必须还要依据大量上下文才能理解的代码。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不要使用魔术。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;反例 1 ：使用魔数&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 从数据库获取列表&lt;/span&gt;&lt;br/&gt;List&amp;lt;String&amp;gt; buyerList = dao.getList();&lt;br/&gt;buyerList.forEach(x -&amp;gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= &lt;span&gt;5&lt;/span&gt;; i++) {&lt;br/&gt;  processedBuyerList.add(String.format(&lt;span&gt;&quot;%s,%s&quot;&lt;/span&gt;, i, x));&lt;br/&gt; }&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你会疑问，为啥索引是从 1 开始？为啥 &amp;lt;= 5。除此之外， i 与 1 极其相似，难以区分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正确的方式应该使用实际含义的名字让人理解这么写的目的，否则维护的人将痛苦不堪。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;反例 2：使用生僻字，又臭又长&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;UltimateAssociatedSubjectRunBatchServiceImpl&lt;/code&gt;，当我们看到这样的类名，是不是不知道怎么读，也不知道如何搜索和定位，更不知道到底表达的意思是什么，可能命这个名字的人还以为准确表达，其实是“王大妈的裹脚布，又臭又长”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原本的业务含义是：执行关联主体任务相关业务类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;鉴于此，我们第一步要避免使用生僻字，可以命名为&lt;code&gt;LinkSubjectServiceImpl&lt;/code&gt; ，清晰简单的表达出关联主体的业务逻辑都在该类。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;不要误导&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽量&lt;strong&gt;不要使用不同之处较小&lt;/strong&gt;的名称，这样让他人无法一眼区分两个名称是啥意思。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：函数 &lt;code&gt;deleteIndex&lt;/code&gt; 和函数&lt;code&gt;deleteIndexEx&lt;/code&gt;，这两个函数名区别很小了，加之函数 &lt;code&gt;deleteIndexEx&lt;/code&gt;后面&lt;code&gt;Ex&lt;/code&gt;还是缩写，也不知道是什么意思，所以他人只能去看函数内容才能明白两者的区别。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;XYZStringHandler&lt;/code&gt;与 &lt;code&gt;XYZStringStorage&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;UserController&lt;/code&gt;与 &lt;code&gt;UserInfoController&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让人抓狂，他们到底是一个东西还是不同的？差别在哪？没有两年脑血栓写不出这样的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;反例 3：名不副实&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是一个生成文件并提供下载功能的接口。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;downloadExcel&lt;/span&gt;&lt;span&gt;(HttpServletResponse response)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; List&amp;lt;File&amp;gt; files = listFile();&lt;br/&gt; String fileName = System.currentTimeMillis() + &lt;span&gt;&quot;.zip&quot;&lt;/span&gt;;&lt;br/&gt; DownloadZip.downLoadFiles(files, filePath);&lt;br/&gt; DownloadZip.fileDownload(response, filePath, fileName);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们会疑惑，&lt;code&gt;downLoadFiles&lt;/code&gt; 与 &lt;code&gt;fileDownload&lt;/code&gt; 到底有啥区别？为啥要调用两次。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种真的是十年脑血栓才写得出来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;downLoadFiles&lt;/code&gt; 的功能是创建将 files 打包成 zip 文件，而  &lt;code&gt;fileDownload&lt;/code&gt;则是把指定的文件输出给浏览器下载。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以 &lt;code&gt;downLoadFiles&lt;/code&gt; 应该命名为 &lt;code&gt;createZipFile&lt;/code&gt;用于合理区分避免误人子弟。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;做有意义的区分&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;getActiveOrder();&lt;br/&gt;getActiveOrderInfo();&lt;br/&gt;getActiveOrderData();&lt;br/&gt;getActiveOrders();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面都是废话命名，别人你怎么知道到底该调用那个方法？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哪个表示订单明细？还是历史订单，还是全部订单查询，废话是另一种没有意义的区分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;名称不同，意思却无差别。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Order、OrderInfo、OrderData&lt;/code&gt;，他们名称相同 ，意思却无差别，属于&lt;strong&gt;毫无意义的废话&lt;/strong&gt;。如果缺少明确约定，变量&lt;code&gt;moneyAmount&lt;/code&gt;就与&lt;code&gt;money&lt;/code&gt;没区别。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Variable&lt;/code&gt;一词永远不应当出现在变量名中。&lt;code&gt;Table&lt;/code&gt;一词永远不应当出现在表名中。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;结合上下文简化名称&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Order&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; String orderNum;&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; String orderCreateTime;&lt;br/&gt;  &lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如 &lt;code&gt;Order&lt;/code&gt;类，在该上下文中，没必要给每个成员变量重复添加 order 这个前缀单词，直接命名为 &lt;code&gt;createTime&lt;/code&gt;、&lt;code&gt;num&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为我们可以借助 &lt;code&gt;Order&lt;/code&gt; 这个上下文来获取信息。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Order order = &lt;span&gt;new&lt;/span&gt; Order();&lt;br/&gt;order.getCreateTime();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;名称易读、可搜索&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可读指的是不要使用一些生僻字，难以发音的单词。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可搜索是便于利用 IED 的自动补全和搜索功能，能根据我们的命名规范快速定位想要找的类或者方法等。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;可读&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;名称读不出来，在讨论的时候就好像是一个沙雕。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哎，那个「treeNewBeeAxibaKula」类是什么作用？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;听到这样的名字尴尬癌都犯了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用一些生僻字，犹如「王大妈的裹脚布，又长又臭」，没有两年脑血栓写不出这样的垃圾代码。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;可搜索&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;IED 很智能，当我们输入 「Hash」的时候，会列举出所有 Hash 相关的类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;命名的时候最好符合项目命名习惯，列表数据查询大家使用 listXXX，你就不要用 queryXXX，统一命名规范，很重要。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;包命名&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;包名&lt;/strong&gt;统一使用&lt;strong&gt;小写&lt;/strong&gt;，&lt;strong&gt;点分隔符&lt;/strong&gt;之间有且仅有一个自然语义的英文单词或者多个单词自然连接到一块（如 springframework，deepspace 不需要使用任何分割）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;包名的构成可以分为以下几四部分【前缀】 【发起者名】【项目名】【模块名】。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;以下表格授权于「Java 填坑笔记」&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的前缀可以分为以下几种：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;前缀名&lt;/th&gt;&lt;th&gt;例&lt;/th&gt;&lt;th&gt;含义&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;indi（或onem ）&lt;/td&gt;&lt;td&gt;indi.发起者名.项目名.模块名.……&lt;/td&gt;&lt;td&gt;个体项目，指个人发起，但非自己独自完成的项目，可公开或私有项目，copyright主要属于发起者。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;pers&lt;/td&gt;&lt;td&gt;pers.个人名.项目名.模块名.……&lt;/td&gt;&lt;td&gt;个人项目，指个人发起，独自完成，可分享的项目，copyright主要属于个人&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;priv&lt;/td&gt;&lt;td&gt;priv.个人名.项目名.模块名.……&lt;/td&gt;&lt;td&gt;私有项目，指个人发起，独自完成，非公开的私人使用的项目，copyright属于个人。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;team&lt;/td&gt;&lt;td&gt;team.团队名.项目名.模块名.……&lt;/td&gt;&lt;td&gt;团队项目，指由团队发起，并由该团队开发的项目，copyright属于该团队所有&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;顶级域名&lt;/td&gt;&lt;td&gt;com.公司名.项目名.模块名.……&lt;/td&gt;&lt;td&gt;公司项目，copyright由项目发起的公司所有&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;类名&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;类名使用大驼峰命名形式&lt;/strong&gt;，应该使用&lt;strong&gt;名词或者名词短语&lt;/strong&gt;，比如：Customer、Account。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;避免使用 Manager、Processor 等动词。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接口名除了用名词和名词短语以外，还可以使用形容词或形容词短语，如 Cloneable，Callable 等，表示实现该接口的类有某种功能或能力。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;属性&lt;/th&gt;&lt;th&gt;约束&lt;/th&gt;&lt;th&gt;例&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;抽象类&lt;/td&gt;&lt;td&gt;Abstract 或者 Base 开头&lt;/td&gt;&lt;td&gt;BaseUserService&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;枚举类&lt;/td&gt;&lt;td&gt;Enum 作为后缀&lt;/td&gt;&lt;td&gt;GenderEnum&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;工具类&lt;/td&gt;&lt;td&gt;Utils作为后缀&lt;/td&gt;&lt;td&gt;StringUtils&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;异常类&lt;/td&gt;&lt;td&gt;Exception结尾&lt;/td&gt;&lt;td&gt;RuntimeException&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;接口实现类&lt;/td&gt;&lt;td&gt;接口名+ ImpI 或者 前缀接口名 + 接口名&lt;/td&gt;&lt;td&gt;UserService + UserServiceImpl、IUserService + UserService&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;领域模型相关&lt;/td&gt;&lt;td&gt;/DO/DTO/VO/DAO&lt;/td&gt;&lt;td&gt;正例：UserDAO 反例：UserDo， UserDao&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;设计模式相关类&lt;/td&gt;&lt;td&gt;Builder，Factory等&lt;/td&gt;&lt;td&gt;当使用到设计模式时，需要使用对应的设计模式作为后缀，如ThreadFactory&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;处理特定功能的&lt;/td&gt;&lt;td&gt;Handler，Predicate, Validator&lt;/td&gt;&lt;td&gt;表示处理器，校验器，断言，这些类工厂还有配套的方法名如handle，predicate，validate&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;测试类&lt;/td&gt;&lt;td&gt;Test结尾&lt;/td&gt;&lt;td&gt;UserServiceTest， 表示用来测试UserService类的&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;方法名&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法命名一般为&lt;strong&gt;动词或动词短语&lt;/strong&gt;，与参数或参数名共同组成动宾短语，即动词 + 名词。一个好的函数名一般能通过名字直接获知该函数实现什么样的功能。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;布尔返回值的方法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注：Prefix-前缀，Suffix-后缀，Alone-单独使用&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;位置&lt;/th&gt;&lt;th&gt;单词&lt;/th&gt;&lt;th&gt;意义&lt;/th&gt;&lt;th&gt;例&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;is&lt;/td&gt;&lt;td&gt;对象是否符合期待的状态&lt;/td&gt;&lt;td&gt;isValid&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;can&lt;/td&gt;&lt;td&gt;对象&lt;strong&gt;能否执行&lt;/strong&gt;所期待的动作&lt;/td&gt;&lt;td&gt;canRemove&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;should&lt;/td&gt;&lt;td&gt;调用方执行某个命令或方法是&lt;strong&gt;好还是不好&lt;/strong&gt;,&lt;strong&gt;应不应该&lt;/strong&gt;，或者说&lt;strong&gt;推荐还是不推荐&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;shouldMigrate&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;has&lt;/td&gt;&lt;td&gt;对象&lt;strong&gt;是否持有&lt;/strong&gt;所期待的数据和属性&lt;/td&gt;&lt;td&gt;hasObservers&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;needs&lt;/td&gt;&lt;td&gt;调用方&lt;strong&gt;是否需要&lt;/strong&gt;执行某个命令或方法&lt;/td&gt;&lt;td&gt;needsMigrate&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;按需执行的方法&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;位置&lt;/th&gt;&lt;th&gt;单词&lt;/th&gt;&lt;th&gt;意义&lt;/th&gt;&lt;th&gt;例&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Suffix&lt;/td&gt;&lt;td&gt;IfNeeded&lt;/td&gt;&lt;td&gt;需要的时候执行，不需要的时候什么都不做&lt;/td&gt;&lt;td&gt;drawIfNeeded&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;might&lt;/td&gt;&lt;td&gt;同上&lt;/td&gt;&lt;td&gt;mightCreate&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;try&lt;/td&gt;&lt;td&gt;尝试执行，失败时抛出异常或是返回errorcode&lt;/td&gt;&lt;td&gt;tryCreate&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Suffix&lt;/td&gt;&lt;td&gt;OrDefault&lt;/td&gt;&lt;td&gt;尝试执行，失败时返回默认值&lt;/td&gt;&lt;td&gt;getOrDefault&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Suffix&lt;/td&gt;&lt;td&gt;OrElse&lt;/td&gt;&lt;td&gt;尝试执行、失败时返回实际参数中指定的值&lt;/td&gt;&lt;td&gt;getOrElse&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;force&lt;/td&gt;&lt;td&gt;强制尝试执行。error抛出异常或是返回值&lt;/td&gt;&lt;td&gt;forceCreate, forceStop&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;用来检查的方法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;单词&lt;/th&gt;&lt;th&gt;意义&lt;/th&gt;&lt;th&gt;例&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;ensure&lt;/td&gt;&lt;td&gt;检查是否为期待的状态，不是则抛出异常或返回error code&lt;/td&gt;&lt;td&gt;ensureCapacity&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;validate&lt;/td&gt;&lt;td&gt;检查是否为正确的状态，不是则抛出异常或返回error code&lt;/td&gt;&lt;td&gt;validateInputs&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;异步相关方法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;位置&lt;/th&gt;&lt;th&gt;单词&lt;/th&gt;&lt;th&gt;意义&lt;/th&gt;&lt;th&gt;例&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;blocking&lt;/td&gt;&lt;td&gt;线程阻塞方法&lt;/td&gt;&lt;td&gt;blockingGetUser&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Suffix&lt;/td&gt;&lt;td&gt;InBackground&lt;/td&gt;&lt;td&gt;执行在后台的线程&lt;/td&gt;&lt;td&gt;doInBackground&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Suffix&lt;/td&gt;&lt;td&gt;Async&lt;/td&gt;&lt;td&gt;异步方法&lt;/td&gt;&lt;td&gt;sendAsync&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Suffix&lt;/td&gt;&lt;td&gt;Sync&lt;/td&gt;&lt;td&gt;对应已有异步方法的同步方法&lt;/td&gt;&lt;td&gt;sendSync&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix or Alone&lt;/td&gt;&lt;td&gt;schedule&lt;/td&gt;&lt;td&gt;Job和Task放入队列&lt;/td&gt;&lt;td&gt;schedule, scheduleJob&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix or Alone&lt;/td&gt;&lt;td&gt;post&lt;/td&gt;&lt;td&gt;同上&lt;/td&gt;&lt;td&gt;postJob&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix or Alone&lt;/td&gt;&lt;td&gt;execute&lt;/td&gt;&lt;td&gt;执行异步方法（注：我一般拿这个做同步方法名）&lt;/td&gt;&lt;td&gt;execute, executeTask&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix or Alone&lt;/td&gt;&lt;td&gt;start&lt;/td&gt;&lt;td&gt;同上&lt;/td&gt;&lt;td&gt;start, startJob&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix or Alone&lt;/td&gt;&lt;td&gt;cancel&lt;/td&gt;&lt;td&gt;停止异步方法&lt;/td&gt;&lt;td&gt;cancel, cancelJob&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix or Alone&lt;/td&gt;&lt;td&gt;stop&lt;/td&gt;&lt;td&gt;同上&lt;/td&gt;&lt;td&gt;stop, stopJob&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;回调方法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;位置&lt;/th&gt;&lt;th&gt;单词&lt;/th&gt;&lt;th&gt;意义&lt;/th&gt;&lt;th&gt;例&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;on&lt;/td&gt;&lt;td&gt;事件发生时执行&lt;/td&gt;&lt;td&gt;onCompleted&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;before&lt;/td&gt;&lt;td&gt;事件发生前执行&lt;/td&gt;&lt;td&gt;beforeUpdate&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;pre&lt;/td&gt;&lt;td&gt;同上&lt;/td&gt;&lt;td&gt;preUpdate&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;will&lt;/td&gt;&lt;td&gt;同上&lt;/td&gt;&lt;td&gt;willUpdate&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;after&lt;/td&gt;&lt;td&gt;事件发生后执行&lt;/td&gt;&lt;td&gt;afterUpdate&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;post&lt;/td&gt;&lt;td&gt;同上&lt;/td&gt;&lt;td&gt;postUpdate&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;did&lt;/td&gt;&lt;td&gt;同上&lt;/td&gt;&lt;td&gt;didUpdate&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;should&lt;/td&gt;&lt;td&gt;确认事件是否可以发生时执行&lt;/td&gt;&lt;td&gt;shouldUpdate&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;操作对象生命周期的方法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;单词&lt;/th&gt;&lt;th&gt;意义&lt;/th&gt;&lt;th&gt;例&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;initialize&lt;/td&gt;&lt;td&gt;初始化。也可作为延迟初始化使用&lt;/td&gt;&lt;td&gt;initialize&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;pause&lt;/td&gt;&lt;td&gt;暂停&lt;/td&gt;&lt;td&gt;onPause ，pause&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;stop&lt;/td&gt;&lt;td&gt;停止&lt;/td&gt;&lt;td&gt;onStop，stop&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;abandon&lt;/td&gt;&lt;td&gt;销毁的替代&lt;/td&gt;&lt;td&gt;abandon&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;destroy&lt;/td&gt;&lt;td&gt;同上&lt;/td&gt;&lt;td&gt;destroy&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;dispose&lt;/td&gt;&lt;td&gt;同上&lt;/td&gt;&lt;td&gt;dispose&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.7 与集合操作相关的方法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;单词&lt;/th&gt;&lt;th&gt;意义&lt;/th&gt;&lt;th&gt;例&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;contains&lt;/td&gt;&lt;td&gt;是否持有与指定对象相同的对象&lt;/td&gt;&lt;td&gt;contains&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;add&lt;/td&gt;&lt;td&gt;添加&lt;/td&gt;&lt;td&gt;addJob&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;append&lt;/td&gt;&lt;td&gt;添加&lt;/td&gt;&lt;td&gt;appendJob&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;insert&lt;/td&gt;&lt;td&gt;插入到下标n&lt;/td&gt;&lt;td&gt;insertJob&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;put&lt;/td&gt;&lt;td&gt;添加与key对应的元素&lt;/td&gt;&lt;td&gt;putJob&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;remove&lt;/td&gt;&lt;td&gt;移除元素&lt;/td&gt;&lt;td&gt;removeJob&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;enqueue&lt;/td&gt;&lt;td&gt;添加到队列的最末位&lt;/td&gt;&lt;td&gt;enqueueJob&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;dequeue&lt;/td&gt;&lt;td&gt;从队列中头部取出并移除&lt;/td&gt;&lt;td&gt;dequeueJob&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;push&lt;/td&gt;&lt;td&gt;添加到栈头&lt;/td&gt;&lt;td&gt;pushJob&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;pop&lt;/td&gt;&lt;td&gt;从栈头取出并移除&lt;/td&gt;&lt;td&gt;popJob&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;peek&lt;/td&gt;&lt;td&gt;从栈头取出但不移除&lt;/td&gt;&lt;td&gt;peekJob&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;find&lt;/td&gt;&lt;td&gt;寻找符合条件的某物&lt;/td&gt;&lt;td&gt;findById&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;与数据相关的方法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;单词&lt;/th&gt;&lt;th&gt;意义&lt;/th&gt;&lt;th&gt;例&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;create&lt;/td&gt;&lt;td&gt;新创建&lt;/td&gt;&lt;td&gt;createAccount&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;new&lt;/td&gt;&lt;td&gt;新创建&lt;/td&gt;&lt;td&gt;newAccount&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;from&lt;/td&gt;&lt;td&gt;从既有的某物新建，或是从其他的数据新建&lt;/td&gt;&lt;td&gt;fromConfig&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;to&lt;/td&gt;&lt;td&gt;转换&lt;/td&gt;&lt;td&gt;toString&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;update&lt;/td&gt;&lt;td&gt;更新既有某物&lt;/td&gt;&lt;td&gt;updateAccount&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;load&lt;/td&gt;&lt;td&gt;读取&lt;/td&gt;&lt;td&gt;loadAccount&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;fetch&lt;/td&gt;&lt;td&gt;远程读取&lt;/td&gt;&lt;td&gt;fetchAccount&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;delete&lt;/td&gt;&lt;td&gt;删除&lt;/td&gt;&lt;td&gt;deleteAccount&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;remove&lt;/td&gt;&lt;td&gt;删除&lt;/td&gt;&lt;td&gt;removeAccount&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;save&lt;/td&gt;&lt;td&gt;保存&lt;/td&gt;&lt;td&gt;saveAccount&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;store&lt;/td&gt;&lt;td&gt;保存&lt;/td&gt;&lt;td&gt;storeAccount&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;commit&lt;/td&gt;&lt;td&gt;保存&lt;/td&gt;&lt;td&gt;commitChange&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;apply&lt;/td&gt;&lt;td&gt;保存或应用&lt;/td&gt;&lt;td&gt;applyChange&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;clear&lt;/td&gt;&lt;td&gt;清除数据或是恢复到初始状态&lt;/td&gt;&lt;td&gt;clearAll&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;reset&lt;/td&gt;&lt;td&gt;清除数据或是恢复到初始状态&lt;/td&gt;&lt;td&gt;resetAll&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;成对出现的动词&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;单词&lt;/th&gt;&lt;th&gt;意义&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;get获取&lt;/td&gt;&lt;td&gt;set 设置&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;add 增加&lt;/td&gt;&lt;td&gt;remove 删除&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;create 创建&lt;/td&gt;&lt;td&gt;destory 移除&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;start 启动&lt;/td&gt;&lt;td&gt;stop 停止&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;open 打开&lt;/td&gt;&lt;td&gt;close 关闭&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;read 读取&lt;/td&gt;&lt;td&gt;write 写入&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;load 载入&lt;/td&gt;&lt;td&gt;save 保存&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;create 创建&lt;/td&gt;&lt;td&gt;destroy 销毁&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;begin 开始&lt;/td&gt;&lt;td&gt;end 结束&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;backup 备份&lt;/td&gt;&lt;td&gt;restore 恢复&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;import 导入&lt;/td&gt;&lt;td&gt;export 导出&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;split 分割&lt;/td&gt;&lt;td&gt;merge 合并&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;inject 注入&lt;/td&gt;&lt;td&gt;extract 提取&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;attach 附着&lt;/td&gt;&lt;td&gt;detach 脱离&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;bind 绑定&lt;/td&gt;&lt;td&gt;separate 分离&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;view 查看&lt;/td&gt;&lt;td&gt;browse 浏览&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;edit 编辑&lt;/td&gt;&lt;td&gt;modify 修改&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;select 选取&lt;/td&gt;&lt;td&gt;mark 标记&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;copy 复制&lt;/td&gt;&lt;td&gt;paste 粘贴&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;undo 撤销&lt;/td&gt;&lt;td&gt;redo 重做&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;insert 插入&lt;/td&gt;&lt;td&gt;delete 移除&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;add 加入&lt;/td&gt;&lt;td&gt;append 添加&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;clean 清理&lt;/td&gt;&lt;td&gt;clear 清除&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;index 索引&lt;/td&gt;&lt;td&gt;sort 排序&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;find 查找&lt;/td&gt;&lt;td&gt;search 搜索&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;increase 增加&lt;/td&gt;&lt;td&gt;decrease 减少&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;play 播放&lt;/td&gt;&lt;td&gt;pause 暂停&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;launch 启动&lt;/td&gt;&lt;td&gt;run 运行&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;compile 编译&lt;/td&gt;&lt;td&gt;execute 执行&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;debug 调试&lt;/td&gt;&lt;td&gt;trace 跟踪&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;observe 观察&lt;/td&gt;&lt;td&gt;listen 监听&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;build 构建&lt;/td&gt;&lt;td&gt;publish 发布&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;input 输入&lt;/td&gt;&lt;td&gt;output 输出&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;encode 编码&lt;/td&gt;&lt;td&gt;decode 解码&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;encrypt 加密&lt;/td&gt;&lt;td&gt;decrypt 解密&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;compress 压缩&lt;/td&gt;&lt;td&gt;decompress 解压缩&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;pack 打包&lt;/td&gt;&lt;td&gt;unpack 解包&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;parse 解析&lt;/td&gt;&lt;td&gt;emit 生成&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;connect 连接&lt;/td&gt;&lt;td&gt;disconnect 断开&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;send 发送&lt;/td&gt;&lt;td&gt;receive 接收&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;download 下载&lt;/td&gt;&lt;td&gt;upload 上传&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;refresh 刷新&lt;/td&gt;&lt;td&gt;synchronize 同步&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;update 更新&lt;/td&gt;&lt;td&gt;revert 复原&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;lock 锁定&lt;/td&gt;&lt;td&gt;unlock 解锁&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;check out 签出&lt;/td&gt;&lt;td&gt;check in 签入&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;submit 提交&lt;/td&gt;&lt;td&gt;commit 交付&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;push 推&lt;/td&gt;&lt;td&gt;pull 拉&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;expand 展开&lt;/td&gt;&lt;td&gt;collapse 折叠&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;begin 起始&lt;/td&gt;&lt;td&gt;end 结束&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;start 开始&lt;/td&gt;&lt;td&gt;finish 完成&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;enter 进入&lt;/td&gt;&lt;td&gt;exit 退出&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;abort 放弃&lt;/td&gt;&lt;td&gt;quit 离开&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;obsolete 废弃&lt;/td&gt;&lt;td&gt;depreciate 废旧&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;collect 收集&lt;/td&gt;&lt;td&gt;aggregate 聚集&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;命名目的都是为了让代码和工程师进行对话，增强代码的可读性，可维护性。优秀的代码往往能够见名知意。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家在工作中是否有遇到一些垃圾命名的代码呢？&lt;strong&gt;&lt;span&gt;欢迎留言&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651508541&amp;amp;idx=1&amp;amp;sn=551a5034a7f374d8ed3da25327bccca4&amp;amp;chksm=bd25a3428a522a5458b3148a80ec26ac3b454a563034bb88694839bed796d2d3212f105b82d1&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;还在用策略模式解决 if-else？Map+函数式接口方法才是YYDS！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;还在用策略模式解决 if-else？Map+函数式接口方法才是YYDS！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651503297&amp;amp;idx=2&amp;amp;sn=5f19e03d6b86789b3b28af5cee97d1e9&amp;amp;chksm=bd25d6be8a525fa8b8d16745d3454ddc4aa562571964d88eb9fd4e2cb274f8a9ae806bf0b3d5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;一个 HashMap 跟面试官扯了半个小时&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;一个 HashMap 跟面试官扯了半个小时&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651508534&amp;amp;idx=1&amp;amp;sn=dbe47cc505ca306c80db884fae973b46&amp;amp;chksm=bd25a3498a522a5fb4c338276bfd8af8699618e0e93c76aea2a11090cd7968e4ff07074a9c93&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;阿里二面：main 方法可以继承吗？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;阿里二面：main 方法可以继承吗？&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关注「ImportNew」，提升Java技能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9166666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;点赞和在看就是最大的支持&lt;/span&gt;&lt;span&gt;❤️&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>32e429bbcd695b11de237454e3534990</guid>
<title>深度剖析 Seata TCC 模式【图解 + 源码分析】</title>
<link>https://toutiao.io/k/dxwt6fy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;span&gt;点击上方“&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;后端进阶&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;”，选择“&lt;/span&gt;&lt;span&gt;设为星标&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Seata 目前支持 AT 模式、XA 模式、TCC 模式和 SAGA 模式，之前文章更多谈及的是非侵入式的 AT 模式，今天带大家认识一下同样是二阶段提交的 TCC 模式。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是 TCC&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCC 是分布式事务中的二阶段提交协议，它的全称为 Try-Confirm-Cancel，即资源预留（Try）、确认操作（Confirm）、取消操作（Cancel），他们的具体含义如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Try：对业务资源的检查并预留；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Confirm：对业务处理进行提交，即 commit 操作，只要 Try 成功，那么该步骤一定成功；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Cancel：对业务处理进行取消，即回滚操作，该步骤回对 Try 预留的资源进行释放。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCC 是一种侵入式的分布式事务解决方案，以上三个操作都需要业务系统自行实现，对业务系统有着非常大的入侵性，设计相对复杂，但优点是 TCC 完全不依赖数据库，能够实现跨数据库、跨应用资源管理，对这些不同数据访问通过侵入式的编码方式实现一个原子操作，更好地解决了在各种复杂业务场景下的分布式事务问题。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7768924302788844&quot; data-type=&quot;png&quot; data-w=&quot;1004&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4MfwdbrwE6d4mBXw77t7OtKMBVRlRBbl9iatc1Cuh6qWgTib3aicMGFkfHFULpKNYeRjLJeqWIUiaCUv6MIge8TQXQ/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Seata TCC 模式&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Seata TCC 模式跟通用型 TCC 模式原理一致，我们先来使用 Seata TCC 模式实现一个分布式事务：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设现有一个业务需要同时使用服务 A 和服务 B 完成一个事务操作，我们在服务 A 定义该服务的一个 TCC 接口：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;TccActionOne&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@TwoPhaseBusinessAction&lt;/span&gt;(name = &lt;span&gt;&quot;DubboTccActionOne&quot;&lt;/span&gt;, commitMethod = &lt;span&gt;&quot;commit&quot;&lt;/span&gt;, rollbackMethod = &lt;span&gt;&quot;rollback&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;prepare&lt;/span&gt;&lt;span&gt;(BusinessActionContext actionContext, @BusinessActionContextParameter(paramName = &lt;span&gt;&quot;a&quot;&lt;/span&gt;)&lt;/span&gt; String a)&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;commit&lt;/span&gt;&lt;span&gt;(BusinessActionContext actionContext)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;rollback&lt;/span&gt;&lt;span&gt;(BusinessActionContext actionContext)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样，在服务 B 定义该服务的一个 TCC 接口：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;TccActionTwo&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@TwoPhaseBusinessAction&lt;/span&gt;(name = &lt;span&gt;&quot;DubboTccActionTwo&quot;&lt;/span&gt;, commitMethod = &lt;span&gt;&quot;commit&quot;&lt;/span&gt;, rollbackMethod = &lt;span&gt;&quot;rollback&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;prepare&lt;/span&gt;&lt;span&gt;(BusinessActionContext actionContext, @BusinessActionContextParameter(paramName = &lt;span&gt;&quot;b&quot;&lt;/span&gt;)&lt;/span&gt; String b)&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;commit&lt;/span&gt;&lt;span&gt;(BusinessActionContext actionContext)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;rollback&lt;/span&gt;&lt;span&gt;(BusinessActionContext actionContext)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在业务所在系统中开启全局事务并执行服务 A 和服务 B 的 TCC 预留资源方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@GlobalTransactional&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;doTransactionCommit&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//服务A事务参与者&lt;/span&gt;&lt;br/&gt;    tccActionOne.prepare(&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;&quot;one&quot;&lt;/span&gt;);&lt;br/&gt; &lt;span&gt;//服务B事务参与者&lt;/span&gt;&lt;br/&gt;    tccActionTwo.prepare(&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;&quot;two&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是使用 Seata TCC 模式实现一个全局事务的例子，可以看出，TCC 模式同样使用 &lt;code&gt;@GlobalTransactional&lt;/code&gt; 注解开启全局事务，而服务 A 和服务 B 的 TCC 接口为事务参与者，Seata 会把一个 TCC 接口当成一个 Resource，也叫 TCC Resource。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCC 接口可以是 RPC，也可以是 JVM 内部调用，意味着一个 TCC 接口，会有发起方和调用方两个身份，以上例子，TCC 接口在服务 A 和服务 B 中是发起方，在业务所在系统中是调用方。如果该 TCC 接口为 Dubbo RPC，那么调用方就是一个 dubbo:reference，发起方则是一个 dubbo:service。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8055555555555556&quot; data-type=&quot;png&quot; data-w=&quot;1440&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4MfwdbrwE6d4mBXw77t7OtKMBVRlRBblib91IzAYbpYyyUcn2rMdPxmxAkvYicApr9jIiaAicCPTHNw4r2pw8VKcnQ/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Seata 启动时会对 TCC 接口进行扫描并解析，如果 TCC 接口是一个发布方，则在 Seata 启动时会向 TC 注册 TCC Resource，每个 TCC Resource 都有一个资源 ID；如果 TCC 接口时一个调用方，Seata 代理调用方，与 AT 模式一样，代理会拦截 TCC 接口的调用，即每次调用 Try 方法，会向 TC 注册一个分支事务，接着才执行原来的 RPC 调用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当全局事务决议提交/回滚时，TC 会通过分支注册的的资源 ID 回调到对应参与者服务中执行 TCC Resource 的 Confirm/Cancel 方法。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Seata 如何实现 TCC 模式&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的 Seata TCC 模型可以看出，TCC 模式在 Seata 中也是遵循 TC、TM、RM 三种角色模型的，如何在这三种角色模型中实现 TCC 模式呢？我将其主要实现归纳为资源解析、资源管理、事务处理。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;资源解析&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;资源解析即是把 TCC 接口进行解析并注册，前面说过，TCC 接口可以是 PRC，也可以是 JVM 内部调用，在 Seata TCC 模块中中一个 remoting 模块，该模块专门用于解析具有 &lt;code&gt;TwoPhaseBusinessAction&lt;/code&gt; 注解的 TCC 接口资源：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8501742160278746&quot; data-type=&quot;png&quot; data-w=&quot;574&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4MfwdbrwE6d4mBXw77t7OtKMBVRlRBblxIvRqlftiaiacrEPl5pEpnqIokjUia87qlp43aZm2TXupVBPXvibdV38Jg/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;RemotingParser&lt;/code&gt; 接口主要有 &lt;code&gt;isRemoting&lt;/code&gt;、&lt;code&gt;isReference&lt;/code&gt;、&lt;code&gt;isService&lt;/code&gt;、&lt;code&gt;getServiceDesc&lt;/code&gt; 等方法，默认的实现为 &lt;code&gt;DefaultRemotingParser&lt;/code&gt;，其余各自的 RPC 协议解析类都在 &lt;code&gt;DefaultRemotingParser&lt;/code&gt; 中执行，Seata 目前已经实现了对 Dubbo、HSF、SofaRpc、LocalTCC 的 RPC 协议的解析，同时具备 SPI 可扩展性，未来欢迎大家为 Seata 提供更多的 RPC 协议解析类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Seata 启动过程中，有个 &lt;code&gt;GlobalTransactionScanner&lt;/code&gt; 注解进行扫描，会执行以下方法：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;io.seata.spring.util.TCCBeanParserUtils#isTccAutoProxy&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该方法目的是判断 bean 是否已被 TCC 代理，在过程中会先判断 bean 是否是一个 Remoting bean，如果是则调用 &lt;code&gt;getServiceDesc&lt;/code&gt; 方法对 remoting bean 进行解析，同时判断如果是一个发起方，则对其进行资源注册：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;io.seata.rm.tcc.remoting.parser.DefaultRemotingParser#parserRemotingServiceInfo&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; RemotingDesc &lt;span&gt;parserRemotingServiceInfo&lt;/span&gt;&lt;span&gt;(Object bean, String beanName, RemotingParser remotingParser)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    RemotingDesc remotingBeanDesc = remotingParser.getServiceDesc(bean, beanName);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (remotingBeanDesc == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    remotingServiceMap.put(beanName, remotingBeanDesc);&lt;br/&gt;&lt;br/&gt;    Class&amp;lt;?&amp;gt; interfaceClass = remotingBeanDesc.getInterfaceClass();&lt;br/&gt;    Method[] methods = interfaceClass.getMethods();&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (remotingParser.isService(bean, beanName)) {&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;//service bean, registry resource&lt;/span&gt;&lt;br/&gt;            Object targetBean = remotingBeanDesc.getTargetBean();&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (Method m : methods) {&lt;br/&gt;                TwoPhaseBusinessAction twoPhaseBusinessAction = m.getAnnotation(TwoPhaseBusinessAction&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (twoPhaseBusinessAction != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    TCCResource tccResource = &lt;span&gt;new&lt;/span&gt; TCCResource();&lt;br/&gt;                    tccResource.setActionName(twoPhaseBusinessAction.name());&lt;br/&gt;                    tccResource.setTargetBean(targetBean);&lt;br/&gt;                    tccResource.setPrepareMethod(m);&lt;br/&gt;                    tccResource.setCommitMethodName(twoPhaseBusinessAction.commitMethod());&lt;br/&gt;                    tccResource.setCommitMethod(interfaceClass.getMethod(twoPhaseBusinessAction.commitMethod(),&lt;br/&gt;                                                                         twoPhaseBusinessAction.commitArgsClasses()));&lt;br/&gt;                    tccResource.setRollbackMethodName(twoPhaseBusinessAction.rollbackMethod());&lt;br/&gt;                    tccResource.setRollbackMethod(interfaceClass.getMethod(twoPhaseBusinessAction.rollbackMethod(),&lt;br/&gt;                                                                           twoPhaseBusinessAction.rollbackArgsClasses()));&lt;br/&gt;                    &lt;span&gt;// set argsClasses&lt;/span&gt;&lt;br/&gt;                    tccResource.setCommitArgsClasses(twoPhaseBusinessAction.commitArgsClasses());&lt;br/&gt;                    tccResource.setRollbackArgsClasses(twoPhaseBusinessAction.rollbackArgsClasses());&lt;br/&gt;                    &lt;span&gt;// set phase two method&#x27;s keys&lt;/span&gt;&lt;br/&gt;                    tccResource.setPhaseTwoCommitKeys(&lt;span&gt;this&lt;/span&gt;.getTwoPhaseArgs(tccResource.getCommitMethod(),&lt;br/&gt;                                                                           twoPhaseBusinessAction.commitArgsClasses()));&lt;br/&gt;                    tccResource.setPhaseTwoRollbackKeys(&lt;span&gt;this&lt;/span&gt;.getTwoPhaseArgs(tccResource.getRollbackMethod(),&lt;br/&gt;                                                                             twoPhaseBusinessAction.rollbackArgsClasses()));&lt;br/&gt;                    &lt;span&gt;//registry tcc resource&lt;/span&gt;&lt;br/&gt;                    DefaultResourceManager.get().registerResource(tccResource);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Throwable t) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; FrameworkException(t, &lt;span&gt;&quot;parser remoting service error&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (remotingParser.isReference(bean, beanName)) {&lt;br/&gt;        &lt;span&gt;//reference bean, TCC proxy&lt;/span&gt;&lt;br/&gt;        remotingBeanDesc.setReference(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; remotingBeanDesc;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上方法，先调用解析类 &lt;code&gt;getServiceDesc&lt;/code&gt; 方法对 remoting bean 进行解析，并将解析后的 &lt;code&gt;remotingBeanDesc&lt;/code&gt; 放入 本地缓存 &lt;code&gt;remotingServiceMap&lt;/code&gt; 中，同时调用解析类 &lt;code&gt;isService&lt;/code&gt; 方法判断是否为发起方，如果是发起方，则解析 &lt;code&gt;TwoPhaseBusinessAction&lt;/code&gt; 注解内容生成一个 &lt;code&gt;TCCResource&lt;/code&gt;，并对其进行资源注册。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;资源管理&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1、资源注册&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Seata TCC 模式的资源叫 &lt;code&gt;TCCResource&lt;/code&gt;，其资源管理器叫 &lt;code&gt;TCCResourceManager&lt;/code&gt;，前面讲过，当解析完 TCC 接口 RPC 资源后，如果是发起方，则会对其进行资源注册：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;io.seata.rm.tcc.TCCResourceManager#registerResource&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;registerResource&lt;/span&gt;&lt;span&gt;(Resource resource)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    TCCResource tccResource = (TCCResource)resource;&lt;br/&gt;    tccResourceCache.put(tccResource.getResourceId(), tccResource);&lt;br/&gt;    &lt;span&gt;super&lt;/span&gt;.registerResource(tccResource);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;TCCResource&lt;/code&gt; 包含了 TCC 接口的相关信息，同时会在本地进行缓存。继续调用父类 &lt;code&gt;registerResource&lt;/code&gt; 方法（封装了通信方法）向 TC 注册，TCC 资源的 resourceId 是 actionName，actionName 就是 &lt;code&gt;@TwoParseBusinessAction&lt;/code&gt; 注解中的 name。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2、资源提交/回滚&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;io.seata.rm.tcc.TCCResourceManager#branchCommit&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; BranchStatus &lt;span&gt;branchCommit&lt;/span&gt;&lt;span&gt;(BranchType branchType, String xid, &lt;span&gt;long&lt;/span&gt; branchId, String resourceId,&lt;br/&gt;                                 String applicationData)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; TransactionException &lt;/span&gt;{&lt;br/&gt;    TCCResource tccResource = (TCCResource)tccResourceCache.get(resourceId);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (tccResource == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ShouldNeverHappenException(String.format(&lt;span&gt;&quot;TCC resource is not exist, resourceId: %s&quot;&lt;/span&gt;, resourceId));&lt;br/&gt;    }&lt;br/&gt;    Object targetTCCBean = tccResource.getTargetBean();&lt;br/&gt;    Method commitMethod = tccResource.getCommitMethod();&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (targetTCCBean == &lt;span&gt;null&lt;/span&gt; || commitMethod == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ShouldNeverHappenException(String.format(&lt;span&gt;&quot;TCC resource is not available, resourceId: %s&quot;&lt;/span&gt;, resourceId));&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;//BusinessActionContext&lt;/span&gt;&lt;br/&gt;        BusinessActionContext businessActionContext = getBusinessActionContext(xid, branchId, resourceId,&lt;br/&gt;                                                                               applicationData);&lt;br/&gt;        &lt;span&gt;// ... ... &lt;/span&gt;&lt;br/&gt;        ret = commitMethod.invoke(targetTCCBean, args);&lt;br/&gt;        &lt;span&gt;// ... ... &lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result ? BranchStatus.PhaseTwo_Committed : BranchStatus.PhaseTwo_CommitFailed_Retryable;&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (Throwable t) {&lt;br/&gt;        String msg = String.format(&lt;span&gt;&quot;commit TCC resource error, resourceId: %s, xid: %s.&quot;&lt;/span&gt;, resourceId, xid);&lt;br/&gt;        LOGGER.error(msg, t);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; BranchStatus.PhaseTwo_CommitFailed_Retryable;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 TM 决议二阶段提交，TC 会通过分支注册的的资源 ID 回调到对应参与者（即 TCC 接口发起方）服务中执行 TCC Resource 的 Confirm/Cancel 方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;资源管理器中会根据 resourceId 在本地缓存找到对应的 &lt;code&gt;TCCResource&lt;/code&gt;，同时根据 xid、branchId、resourceId、applicationData 找到对应的 &lt;code&gt;BusinessActionContext&lt;/code&gt; 上下文，执行的参数就在上下文中。最后，执行 &lt;code&gt;TCCResource&lt;/code&gt; 中获取 &lt;code&gt;commit&lt;/code&gt; 的方法进行二阶段提交。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;二阶段回滚同理类似。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;事务处理&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面讲过，如果 TCC 接口时一个调用方，则会使用 Seata TCC 代理对调用方进行拦截处理，并在处理调用真正的 RPC 方法前对分支进行注册。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行方法&lt;code&gt;io.seata.spring.util.TCCBeanParserUtils#isTccAutoProxy&lt;/code&gt;除了对 TCC 接口资源进行解析，还会判断 TCC 接口是否为调用方，如果是调用方则返回 true：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;io.seata.spring.annotation.GlobalTransactionScanner#wrapIfNecessary&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1905940594059406&quot; data-type=&quot;png&quot; data-w=&quot;2424&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4MfwdbrwE6d4mBXw77t7OtKMBVRlRBblNdcVQC7ZQTVyUBvWK2qQYJ2mXib19r6h7hn3ERdbkMibZOVBicMcMZhGg/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图，当 &lt;code&gt;GlobalTransactionalScanner&lt;/code&gt; 扫描到 TCC 接口调用方（Reference）时，会使 &lt;code&gt;TccActionInterceptor&lt;/code&gt; 对其进行代理拦截处理，&lt;code&gt;TccActionInterceptor&lt;/code&gt; 实现 &lt;code&gt;MethodInterceptor&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;code&gt;TccActionInterceptor&lt;/code&gt; 中还会调用 &lt;code&gt;ActionInterceptorHandler&lt;/code&gt; 类型执行拦截处理逻辑，事务相关处理就在 &lt;code&gt;ActionInterceptorHandler#proceed&lt;/code&gt; 方法中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;proceed&lt;/span&gt;&lt;span&gt;(Method method, Object[] arguments, String xid, TwoPhaseBusinessAction businessAction,&lt;br/&gt;                      Callback&amp;lt;Object&amp;gt; targetCallback)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Throwable &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//Get action context from arguments, or create a new one and then reset to arguments&lt;/span&gt;&lt;br/&gt;    BusinessActionContext actionContext = getOrCreateActionContextAndResetToArguments(method.getParameterTypes(), arguments);&lt;br/&gt;    &lt;span&gt;//Creating Branch Record&lt;/span&gt;&lt;br/&gt;    String branchId = doTccActionLogStore(method, arguments, businessAction, actionContext);&lt;br/&gt;    &lt;span&gt;// ... ... &lt;/span&gt;&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; { &lt;br/&gt;        &lt;span&gt;// ... ...&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; targetCallback.execute();&lt;br/&gt;    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;//to report business action context finally if the actionContext.getUpdated() is true&lt;/span&gt;&lt;br/&gt;            BusinessActionContextUtil.reportContext(actionContext);&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;// ... ... &lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上，在执行 TCC 接口一阶段之前，会调用 &lt;code&gt;doTccActionLogStore&lt;/code&gt; 方法分支注册，同时还会将 TCC 相关信息比如参数放置在上下文，上面讲的资源提交/回滚就会用到这个上下文。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;如何控制异常&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 TCC 模型执行的过程中，还可能会出现各种异常，其中最为常见的有空回滚、幂等、悬挂等。下面我讲下 Seata 是如何处理这三种异常的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;如何处理空回滚&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;什么是空回滚？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;空回滚指的是在一个分布式事务中，在没有调用参与方的 Try 方法的情况下，TM 驱动二阶段回滚调用了参与方的 Cancel 方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么空回滚是如何产生的呢？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7925824175824175&quot; data-type=&quot;png&quot; data-w=&quot;1456&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4MfwdbrwE6d4mBXw77t7OtKMBVRlRBblb5C8gBNTaD94MDQZanBsvUPvicnibaQ7jb9cic8ibYzsnBWeUiciaFib21HzA/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图所示，全局事务开启后，参与者 A 分支注册完成之后会执行参与者一阶段 RPC 方法，如果此时参与者 A 所在的机器发生宕机，网络异常，都会造成 RPC 调用失败，即参与者 A 一阶段方法未成功执行，但是此时全局事务已经开启，Seata 必须要推进到终态，在全局事务回滚时会调用参与者 A 的 Cancel 方法，从而造成空回滚。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要想防止空回滚，那么必须在 Cancel 方法中识别这是一个空回滚，Seata 是如何做的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Seata 的做法是新增一个 TCC 事务控制表，包含事务的 XID 和 BranchID 信息，在 Try 方法执行时插入一条记录，表示一阶段执行了，执行 Cancel 方法时读取这条记录，如果记录不存在，说明 Try 方法没有执行。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;如何处理幂等&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;幂等问题指的是 TC 重复进行二阶段提交，因此 Confirm/Cancel 接口需要支持幂等处理，即不会产生资源重复提交或者重复释放。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么幂等问题是如何产生的呢？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7977839335180056&quot; data-type=&quot;png&quot; data-w=&quot;1444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4MfwdbrwE6d4mBXw77t7OtKMBVRlRBbl7JzkibThAicvzkwwShb0DkaCGBKXY4hvEF7UlwOAhVjAfkrWwvOl4xBQ/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图所示，参与者 A 执行完二阶段之后，由于网络抖动或者宕机问题，会造成 TC 收不到参与者 A 执行二阶段的返回结果，TC 会重复发起调用，直到二阶段执行结果成功。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Seata 是如何处理幂等问题的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样的也是在 TCC 事务控制表中增加一个记录状态的字段 status，该字段有有 3 个值，分别为：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;tried：1&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;committed：2&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;rollbacked：3&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;二阶段 Confirm/Cancel 方法执行后，将状态改为 committed 或 rollbacked 状态。当重复调用二阶段 Confirm/Cancel 方法时，判断事务状态即可解决幂等问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;如何处理悬挂&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;悬挂指的是二阶段 Cancel 方法比 一阶段 Try 方法优先执行，由于允许空回滚的原因，在执行完二阶段 Cancel 方法之后直接空回滚返回成功，此时全局事务已结束，但是由于 Try 方法随后执行，这就会造成一阶段 Try 方法预留的资源永远无法提交和释放了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么悬挂是如何产生的呢？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7988980716253443&quot; data-type=&quot;png&quot; data-w=&quot;1452&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4MfwdbrwE6d4mBXw77t7OtKMBVRlRBblFPZGKcAX6icRxb2NNicibataztZkSxDuaKywrgkWFNb8aOL6DdKEGXKQg/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图所示，在执行参与者 A 的一阶段 Try 方法时，出现网路拥堵，由于 Seata 全局事务有超时限制，执行 Try 方法超时后，TM 决议全局回滚，回滚完成后如果此时 RPC 请求才到达参与者 A，执行 Try 方法进行资源预留，从而造成悬挂。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Seata 是怎么处理悬挂的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 TCC 事务控制表记录状态的字段 status 中增加一个状态：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;suspended：4&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当执行二阶段 Cancel 方法时，如果发现 TCC 事务控制表有相关记录，说明二阶段 Cancel 方法优先一阶段 Try 方法执行，因此插入一条 status=4 状态的记录，当一阶段 Try 方法后面执行时，判断 status=4 ，则说明有二阶段 Cancel 已执行，并返回 false 以阻止一阶段 Try 方法执行成功。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>37de57313fdb1333255237365308f517</guid>
<title>带你彻底击溃跳表原理及其Golang实现！（内含图解）</title>
<link>https://toutiao.io/k/fp0dy5f</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;导语 |&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;最近在看《Redis设计与实现》这本书，书中简单描述了跳表的性质和数据结构，但对它的具体实现没有详细描述。本文是基于我个人对跳表原理的深入探究，并通过golang实现了一个基础跳表的理解和实践。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;3a26b884b077fb53a486350792000b3f&quot;&gt;&lt;span&gt;书里对跳表结构的描述是这样的：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.36875&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe94BamfdADEtEEzibEzibpjgXPWhiaibO9ABtnkTqxeAofAbxB8iaJBicXH0LURYurswNaBQiaR53ztbSkNBg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;跳跃表节点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;zskiplistNode&lt;/span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;zskiplistNode&lt;/span&gt; *&lt;span class=&quot;code-snippet__title&quot;&gt;backward&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__keyword&quot;&gt;double&lt;/span&gt; score;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     robj *obj;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;zskiplistLevel&lt;/span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;zskiplistNode&lt;/span&gt; *&lt;span class=&quot;code-snippet__title&quot;&gt;forward&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;span class=&quot;code-snippet__keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; span;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } level[];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; } zskiplistNode;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;跳跃表结构：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;zskiplist&lt;/span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;zskiplistNode&lt;/span&gt; *&lt;span class=&quot;code-snippet__title&quot;&gt;header&lt;/span&gt;, *&lt;span class=&quot;code-snippet__title&quot;&gt;tail&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; length;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; level;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; } zskiplist;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虽然大概懂了跳表是一种怎么样的存在，它有媲美平衡树的效率，但比平衡树更加容易实现，但这本书并没有详细描述跳表的实现，其中一些关键点也没有说明，比如：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为什么表头节点是不被计算在length属性里？新增节点时是如何决定level的指针指向哪个后继节点？为什么zset分值可以相同而成员对象不能相同？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了解答这些问题，我决定完全弄懂跳表的原理，自己实现一个基础的跳表。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;一、跳表的原理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;（一）有序单链表和二分查找法&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;顾名思义，有序单链表就是节点的排列是有顺序的链表。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.08174386920980926&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1101&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe94BamfdADEtEEzibEzibpjgXPpriaEKyB2K3wQ8ClasPVbLxyOrSPQj2AdFWz0t8zJ4Ixaz4yJ6Ajg4A/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果我们想从中找到一个节点，比如15，除了从头节点开始遍历，是否有其他方式？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经典的查找算法中，有专门针对一个有序的数据集合的算法，即“&lt;/span&gt;&lt;span&gt;&lt;strong&gt;二分算法&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;”，以O(logN)的时间复杂度进行查找。它通过对比目标数据和中间数据的大小，在每轮查找中直接淘汰一半的数据：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;设想在链表中，我们参考二分算法的思想，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;为“中&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;间节点”加索引&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，就能像二分算法一样进行链表数据的查找了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.16348773841961853&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1101&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe94BamfdADEtEEzibEzibpjgXPWIr7y4o2Me5LUibgSiciaC3k2pia7TKibYicODJMWrKm6GcL70WiaCia5fI0Kw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;OK，现在我们将每一个中间节点抽了出来，组成了另一条链表，即一级索引，一级索引的每个节点都指向原单链表对应的节点，这样可以通过二分算法来快速查找有序单链表中的节点了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果原链表节点数量太多将会导致一级索引的节点数量也很多，这时需要继续向上建立索引，选取一级索引的中间节点建立二级索引。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2452316076294278&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1101&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe94BamfdADEtEEzibEzibpjgXPHWmZdNIL5VKpPpqrgDHQjibNOHYwkIZFHMCb5fTIoQ5WmVu1qWmMX9w/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这就是跳表的&lt;/span&gt;&lt;span&gt;&lt;strong&gt;本质&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;&lt;strong&gt;是对有序链表的改造，为单链表加多层索引，以空间换时间的策略，解决了单链表中查询速度的问题，同时也能快速实现范围查询&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;链表节点数少时提升的效果有限，但当链表长度达到1000甚至10000时，从中查找一个数的效率会得到极大的提升。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;（二）跳表索引的更新&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;前言中提到，跳表具有媲美平衡树的效率，平衡树之所以称之为平衡树，是为了解决普通树结构在极端情况下容易退化成一个单链表的问题，每次插入或删除节点时，会维持树的平衡性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面这种二叉树具有O(log n) 的查找时间复杂度，但在极端情况下容易发生退化，比如删除了4，5，6三个节点后，会退化为单链表，查询时间复杂度退化为O(n).&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6775510204081633&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;490&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe94BamfdADEtEEzibEzibpjgXPupbWkkopCyI1Qmic0FfLf8t2mn156VnThllae6uib3fjf8nsfF7XpD8Q/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;退化后的二叉树：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1527777777777777&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;288&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe94BamfdADEtEEzibEzibpjgXPMY3Ea5uShHlZm6oyANDLZ81JMSpQwhvPoibYD4yV52htG7vNjnOgqtQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果跳表在插入新节点后索引就不再更新，在极端情况下，它可能发生退化，比如下面这种情况：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.19921875&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe94BamfdADEtEEzibEzibpjgXPlUNLV3BT57cq2p49UY9evo0rp4x0iczBXnduutVD999RLxQko7NSibpw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;10到100之间插入n多个节点，查询这其中的数据时，查询时间复杂度将退化到接近O(n)。既然跳表被称之为媲美平衡树的数据结构，也必然会维护索引以保证不退化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;通过晋升机制&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;既然现在跳表每两个原始链表节点中有一个被建立了一级索引，而每两个一级&lt;/span&gt;&lt;span&gt;索引中有一个被建立了二级索引，n&lt;/span&gt;&lt;span&gt;个节点中有&lt;/span&gt;&lt;span&gt;n/2&lt;/span&gt;&lt;span&gt;个索引，可以理解为：&lt;/span&gt;&lt;span&gt;在同一级中，每个节点&lt;/span&gt;&lt;span&gt;晋升&lt;/span&gt;&lt;span&gt;到上一级索引的概率为&lt;/span&gt;&lt;span&gt;1/2。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果不严格按照“每两个节点中有一个晋升”，而是“每个节点有1/2的概率晋升”，当节点数量少时，可能会有部分索引聚集，但当节点数量足够大时，建立的索引也就足够分散，就越接近“严格的每两个节点中有一个晋升”的效果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然，晋升的概率可以根据需求进行调整，1/3或1/4，晋升概率稍小时，空间复杂度小，但查询效率会降低。在下文中，我们将晋升率设置为p。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;（三）时间复杂度与空间复杂度&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;结论：跳&lt;/span&gt;&lt;span&gt;表的时间复杂度为O(log n)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;证明：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;按二分法进化出的跳表，无论是原链表还是&lt;/span&gt;&lt;span&gt;N&lt;/span&gt;&lt;span&gt;级&lt;/span&gt;&lt;span&gt;索引，都是每两个节点中有一个被用作上一级索引。&lt;/span&gt;&lt;span&gt;这个过程我们称之为“晋升”，晋升的概率为&lt;/span&gt;&lt;span&gt;p。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;假设原链表节点数量为n，一级索引节点数为n*p^1，二级索引节点数为n*p^2，以此类推，h级索引的节点数应为n*(p^h)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最高层的期望节点数应为1/p，我的理解是：小于等于这个期望数，再高一层索引的期望节点数将为1，没有意义了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据上述推算，易得一个跳表的期望索引高度h为：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.296551724137931&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;145&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe94BamfdADEtEEzibEzibpjgXP3wicTAtWaA6CM2GmM1fuBVJKN69PZpDdHS0S0TNMngKAem8IcrSmZkQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;加上底层的原始链表，跳表的期望总高度H为：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3644067796610169&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;118&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe94BamfdADEtEEzibEzibpjgXPlLFibVtPQzG4VoAaQBz8qzC4ib8mjeso66tTa6sJFMcIvnHS41ibkVsJw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;查找索引时，我们运用倒推的思维，从原始链表上的目标节点推到顶层索引的起始节点，示意图如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24977293369663942&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1101&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe94BamfdADEtEEzibEzibpjgXPpy3VskHRJISC4W5Lmdgn6HpamTRRHwfyTiaMNsnVJRFYEuunw0962qw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当我们在底层节点时，只有两种路径可走，向上或向左，向上的概率为p，向左的概率为1-p。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;假设C(i)为一个无限长度的跳表中向上爬i层的期望代价（即经过的节点数量）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;爬到第0层时，无需经过任何节点，所以有：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2891566265060241&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;166&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe94BamfdADEtEEzibEzibpjgXPNZ3abzcxJ61ic0wTk7SJ5aFZuDhOrnPHxNjaXR1tmkCT1YmiayqaLrlg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;爬到第1层时，可能有两种情况：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从有p的概率是从第0层直接爬升1个节点，这种情况经过的节点数为：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;4&quot; data-cropselx2=&quot;170&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;48&quot; data-ratio=&quot;0.27450980392156865&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;204&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe94BamfdADEtEEzibEzibpjgXPA38MVGaj2z3Zsd9K8ORKDUw18t7o0VkjajlJQ7NYSn6w0ibaARUe8EA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有1-p的概率是从第1层向左移动一个节点，则经过的节点数为：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;40&quot; data-cropselx2=&quot;244&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;56&quot; data-ratio=&quot;0.19736842105263158&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;304&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe94BamfdADEtEEzibEzibpjgXPDVNCMl0kKmphLqLxDhuP4mwXQ9h5drB4WCbE0bBWE591I5MRc9jCSA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;则有：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.08571428571428572&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;700&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe94BamfdADEtEEzibEzibpjgXPmOc1yfC3boYcesSjjhSPYFqkk7IOQANCicRarVmdvnaRw8BLqqTsbpQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;解得：C(i) = i/p&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当爬到期望中的最高层——第h层时，则期望步数为h/p，在第h层，继续向左走的期望步数不会超过当前层节点的期望总和1/p，向上走的期望步数也不会超过当前层节点的期望总和1/p，全部加起来，从最底层的目标节点到最顶层的头节点，期望步数为h/p+2/p，将上面h的公式带入，忽略常量，时间复杂度为O(log n)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;空间复杂度基本上就是等比数列之和的计算，比值为p。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;直接说结果为O(n)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;二、跳表的实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了更好地理解跳表，自己参考着跳表的原理，尝试手撸一条跳表，当然这是最基础的，没有redis跳表那样丰富的能力，粗略实现了对数字的增删改查，以插入的数字作为排序的基准，不支持重复数字的插入。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;redis跳表在经典跳表之上有额外的实现：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在这之前需要说明，索引的节点其实并不是像底层链表一样的节点Node，而是一种Level层结构，每个层中都包含了Node的指针，指向下一个节点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;（一）基础数据结构&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; MaxLevel = &lt;span class=&quot;code-snippet__number&quot;&gt;32&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; p = &lt;span class=&quot;code-snippet__number&quot;&gt;0.5&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; Node &lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  value  &lt;span class=&quot;code-snippet__keyword&quot;&gt;uint32&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  levels []*Level &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; Level &lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  next *Node&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; SkipList &lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  header *Node  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  length &lt;span class=&quot;code-snippet__keyword&quot;&gt;uint32&lt;/span&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  height &lt;span class=&quot;code-snippet__keyword&quot;&gt;uint32&lt;/span&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;NewSkipList&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; *&lt;span class=&quot;code-snippet__title&quot;&gt;SkipList&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &amp;amp;SkipList{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    header: NewNode(MaxLevel, &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    length: &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    height: &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;NewNode&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(level, value &lt;span class=&quot;code-snippet__keyword&quot;&gt;uint32&lt;/span&gt;)&lt;/span&gt; *&lt;span class=&quot;code-snippet__title&quot;&gt;Node&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  node := &lt;span class=&quot;code-snippet__built_in&quot;&gt;new&lt;/span&gt;(Node)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  node.value = value&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  node.levels = &lt;span class=&quot;code-snippet__built_in&quot;&gt;make&lt;/span&gt;([]*Level, level)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;len&lt;/span&gt;(node.levels); i++ {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    node.levels[i] = &lt;span class=&quot;code-snippet__built_in&quot;&gt;new&lt;/span&gt;(Level)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; node&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里的p就是上面提到的节点晋升概率，MaxLevel为跳表最高的层数，这两个数字可以根据需求设定，根据上面推出的跳表高度公式：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3644067796610169&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;118&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe94BamfdADEtEEzibEzibpjgXPlLFibVtPQzG4VoAaQBz8qzC4ib8mjeso66tTa6sJFMcIvnHS41ibkVsJw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以倒推出此跳表的容纳元素数量上限，n为2^32个。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;（二）插入元素&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;重点在于如何确认插入的这个新节点需要几层索引？通过下面这个函数根据晋升概率随机生成这个新节点的层数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;func&lt;/span&gt; (&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;sl&lt;/span&gt; *&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;SkipList&lt;/span&gt;) &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;randomLevel&lt;/span&gt;() &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;int&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attribute&quot;&gt;level &lt;/span&gt;:= &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  r := rand.&lt;span class=&quot;code-snippet__built_in&quot;&gt;New&lt;/span&gt;(rand.NewSource(time.Now().&lt;span class=&quot;code-snippet__built_in&quot;&gt;UnixNano&lt;/span&gt;()))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  for r.&lt;span class=&quot;code-snippet__built_in&quot;&gt;Float64&lt;/span&gt;() &amp;lt; p &amp;amp;&amp;amp; level &amp;lt; MaxLevel {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    level++&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;level&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看出，默认层数为1，即无索引，通过随机一个0-1的数，如果小于晋升概率p，且总层数不大于最大层数时，将level+1。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样就有：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里需要注意一下，上面我们说有1/2的概率有一层索引，即level为2的概率应该是1/2，为什么这里是1/4呢？&lt;/span&gt;&lt;span&gt;而位于第一层的原始链表存在的概率应该是1，这里为什么le&lt;/span&gt;&lt;span&gt;vel=1的概率为1/2呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原因在于，当level为2时，同时也表示存在第一层；当level为3时，同时也存在第一层和第二层；毕竟不能出现“空中阁楼”。所以：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;插入元素的具体代码如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(sl *SkipList)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(value &lt;span class=&quot;code-snippet__keyword&quot;&gt;uint32&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;bool&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; value &amp;lt;= &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  update := &lt;span class=&quot;code-snippet__built_in&quot;&gt;make&lt;/span&gt;([]*Node, MaxLevel)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  tmp := sl.header&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;(sl.height) - &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;; i &amp;gt;= &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i-- {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; tmp.levels[i].next != &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; &amp;amp;&amp;amp; tmp.levels[i].next.value &amp;lt; value {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      tmp = tmp.levels[i].next&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; tmp.levels[i].next != &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; &amp;amp;&amp;amp; tmp.levels[i].next.value == value {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    update[i] = tmp&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  level := sl.randomLevel()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  node := NewNode(&lt;span class=&quot;code-snippet__keyword&quot;&gt;uint32&lt;/span&gt;(level), value)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;uint32&lt;/span&gt;(level) &amp;gt; sl.height {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    sl.height = &lt;span class=&quot;code-snippet__keyword&quot;&gt;uint32&lt;/span&gt;(level)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; level; i++ {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; update[i] == &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      sl.header.levels[i].next = node&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;continue&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    node.levels[i].next = update[i].levels[i].next&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    update[i].levels[i].next = node&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  sl.length++&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数组update保存了每一层对应的插入位置。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如下面这张跳表，我要新增元素9，最高高度为5，当前最高高度为3:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2984375&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe94BamfdADEtEEzibEzibpjgXPA4b67jhJGpmSVtqgxyatrPibaLD1TeUyT7M4kvvDoic6uoI7CziclBMdg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;update长度为5&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么会从3层开始向下遍历，在二级索引这层找到9应该插入的位置——1和10之间，update[2]记录包含1的节点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在一级索引这层找到9应该插入的位置——7和10之间，update[1]记录了包含7的节点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在原链表这层找到9应该插入的位置——8和10之间，update[0]记录了包含8的节点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;假设新节点的level为4，则修改当前最高高度为4，然后开始逐层插入这个新节点，update[3]为空，因为目前整个跳表的高度只有3，所以需要将三级索引上的节点9插入到头节点后面，插入过程与普通的链表插入无异。示意图如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.28359375&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe94BamfdADEtEEzibEzibpjgXPTBK5fyGgjI05o4Gd0kCxGegkQBR8zL0aM2IrrocdBUwqwgXYuKofxg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;（三）删除元素&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(sl *SkipList)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Delete&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(value &lt;span class=&quot;code-snippet__keyword&quot;&gt;uint32&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;bool&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; node *Node&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  last := &lt;span class=&quot;code-snippet__built_in&quot;&gt;make&lt;/span&gt;([]*Node, sl.height)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  tmp := sl.header&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;(sl.height) - &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;; i &amp;gt;= &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i-- {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; tmp.levels[i].next != &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; &amp;amp;&amp;amp; tmp.levels[i].next.value &amp;lt; value {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      tmp = tmp.levels[i].next&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    last[i] = tmp&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; tmp.levels[i].next!=&lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt;&amp;amp;&amp;amp;tmp.levels[i].next.value == value {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      node = tmp.levels[i].next&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; node == &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;len&lt;/span&gt;(node.levels); i++ {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    last[i].levels[i].next = node.levels[i].next&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    node.levels[i].next = &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;len&lt;/span&gt;(sl.header.levels); i++ {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; sl.header.levels[i].next == &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      sl.height = &lt;span class=&quot;code-snippet__keyword&quot;&gt;uint32&lt;/span&gt;(i)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;break&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  sl.length--&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;与插入节点思路一致，从最上层开始向下遍历寻找，找到需要删除的节点的前置节点并记录在 last 数组中，然后修改前置节点指针的指向。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;（四）查找&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;解决了增删，剩下的查询就很简单了，可以查找对应value的node，也可以查找一个范围。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;查找范围即先找到范围前边界的节点，再通过链表向后遍历即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里我只实现了查找单个node的函数：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(sl *SkipList)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Find&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(value &lt;span class=&quot;code-snippet__keyword&quot;&gt;uint32&lt;/span&gt;)&lt;/span&gt; *&lt;span class=&quot;code-snippet__title&quot;&gt;Node&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; node *Node&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  tmp := sl.header&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;(sl.height) - &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;; i &amp;gt;= &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i-- {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; tmp.levels[i].next != &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; &amp;amp;&amp;amp; tmp.levels[i].next.value &amp;lt;= value {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      tmp = tmp.levels[i].next&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; tmp.value == value {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      node = tmp&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;break&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; node&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;三、redis的跳表实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上述是一个标准跳表的原理和实现，redis中的跳表还有所不同，它提供了更多的特性和能力：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;redis中，跳表只在zset结构有使用。zset结构在成员较少时使用压缩列表 ziplist作为存储结构，成员达到一定数量后会改用map+skiplist作为存储结构。这里只讨论使用skiplist的实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;zset结构要求，分值可以相同，但保存的成员对象不能相同。zset对跳表排序的依据是“分值和成员对象”两个维度，分值可以相同，但成员对象不能一样。分值相同时，按成员对象首字母在字典的顺序确定先后。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;zset还维护了一个map，保存成员对象与分值的映射关系，被用来通过成员对象快速查找分值，定位对应的节点，在ZRANK、ZREVRANK、ZSCORE等命令中均有使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，这个map还用于插入节点时，判断是否存在重复的成员对象。见下面redis源码中的dictFind函数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;php&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;int zsetAdd(robj *zobj, double score, sds ele, int in_flags, int *out_flags, double *newscore) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (zobj-&amp;gt;encoding == OBJ_ENCODING_ZIPLIST) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (zobj-&amp;gt;encoding == OBJ_ENCODING_SKIPLIST) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        zset *zs = zobj-&amp;gt;ptr;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        zskiplistNode *znode;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        dictEntry *de;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        de = dictFind(zs-&amp;gt;dict,ele);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (de != &lt;span class=&quot;code-snippet__keyword&quot;&gt;NULL&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (!xx) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            ele = sdsdup(ele);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            znode = zslInsert(zs-&amp;gt;zsl,score,ele);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            serverAssert(dictAdd(zs-&amp;gt;dict,ele,&amp;amp;znode-&amp;gt;score) == DICT_OK);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            *out_flags |= ZADD_OUT_ADDED;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (newscore) *newscore = score;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            *out_flags |= ZADD_OUT_NOP;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;四、回顾问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;前面提到，在看《Redis设计与实现》这本书时我有几点疑问，在详细了解跳表之后现在就完全理解了。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;br/&gt;&lt;/h4&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;（一）为什么表头节点是不被计算在length属性里？&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为表头节点是初始化跳表时提供的空节点，不保存任何节点，只用于提供各级索引的入口。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;（二）新增节点时是如何决定level的指针指向哪个后继节点？&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过分值和成员对象共同决定，判断新节点的插入位置和顺序。分值相同时，按成员对象首字母在字典的顺序确定先后。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经典跳表也同样需要一个维度来确定插入的顺序，我的跳表实现中直接使用了新节点的值作为排序的维度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;（三）为什么zset分值可以相同而成员对象不能相同？&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据第二个问题的答案，如果都相同，就无法确定插入的位置和顺序。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt; 作者简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe94BamfdADEtEEzibEzibpjgXPvsxTTJOXYeF4KKAPujUd9IsbyClV8VQGc1n3Sb2NBlMR5SVMqMWhIA/0?wx_fmt=jpeg&quot; data-cropx1=&quot;23.925233644859812&quot; data-cropx2=&quot;1280&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;1280&quot; data-fileid=&quot;100044396&quot; data-ratio=&quot;1.0188679245283019&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe94BamfdADEtEEzibEzibpjgXPibZFt3OefNUxTAvVg5HDJGFzl2xCsNjnl6Umv3vpQ7ZFHQG5GicibOuCw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1060&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;冯启源&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;腾讯后台开发工程师&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;腾讯后台开发工程师，毕业于中南大学，目前负责腾讯教育业务的后端开发工作，希望能用技术改善人们的生活。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;参考阅读：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;技术原创及架构实践文章，欢迎通过公众号菜单「联&lt;/span&gt;&lt;span&gt;系我们」进行投稿。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;高可用架构&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;改变互联网的构建方式&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAwMDU1MTE1OQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapONl06YmHad4csRU93kcbJ76JIWzEAmOSVooibFHHkzfWzzkc7dpU4H06Wp9F6Z687vIghdawxvl47A/0?wx_fmt=png&quot; data-nickname=&quot;高可用架构&quot; data-alias=&quot;ArchNotes&quot; data-signature=&quot;高可用架构公众号。&quot; data-from=&quot;0&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3b0c6a6fbf1f61bdd809e8f3371dafaf</guid>
<title>Python代替Excel VBA，原来真的可以</title>
<link>https://toutiao.io/k/zqnpdh9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;markdown-body detail-content&quot;&gt;&amp;#13;
                &amp;#13;
                &lt;p&gt;&lt;img src=&quot;http://download.broadview.com.cn/Original/2201eec8142255c6a859&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;strong&gt;【本文原创：童大谦】&lt;/strong&gt;&lt;/p&gt;&amp;#13;
&lt;h4 id=&quot;h4-vba-python-&quot;&gt;&lt;a name=&quot;VBA与Python：当王者荣耀遇到卷王之王&quot; class=&quot;reference-link&quot;/&gt;&lt;span class=&quot;header-link octicon octicon-link&quot;/&gt;VBA与Python：当王者荣耀遇到卷王之王&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;VBA&lt;/strong&gt;语言是VB的一个子集，具有简单易学、功能强大的特点。&lt;/p&gt;&amp;#13;
&lt;p&gt;上世纪90年代末至今，VBA语言被大部分主流行业软件用作脚本语言，包括办公软件如Excel、Word、PowerPoint等，GIS软件如ArcGIS、MapInfo、GeoMedia等，CAD软件如AutoCAD、 SolidWorks等，统计软件如SPSS等，甚至连图形软件如PhotoShop、CoralDraw等也使用VBA进行脚本编程。&lt;/p&gt;&amp;#13;
&lt;p&gt;近年来，&lt;strong&gt;Python&lt;/strong&gt;语言异军突起，在各大计算机语言排行榜上牢牢占据前3名。&lt;/p&gt;&amp;#13;
&lt;p&gt;Python语言同样简单易学，并且免费开源，在系统运维、网络编程、科学计算等领域取得广泛的应用。Python有很多内置的库和第三方库，每个库在某个行业或方向上提供功能。利用它们，用户可以站在前人的肩膀上，将主要精力放在自己的事情上，做到事半功倍。&lt;/p&gt;&amp;#13;
&lt;p&gt;另外，Python号称&lt;strong&gt;胶水语言&lt;/strong&gt;，被越来越多的软件用作脚本语言。上面提到的很多行业软件中，ArcGIS和SPSS软件官方已经将Python作为内置的脚本语言，与VBA语言放在一起供用户选择使用。其他如Excel、Word、PowerPoint、AutoCAD等也能找到各种第三方Python包，&lt;strong&gt;利用它们可以部分或整体替换VBA，实现对应的脚本编程&lt;/strong&gt;。&lt;/p&gt;&amp;#13;
&lt;h4 id=&quot;h4--excel-python-&quot;&gt;&lt;a name=&quot;与Excel有关的Python包&quot; class=&quot;reference-link&quot;/&gt;&lt;span class=&quot;header-link octicon octicon-link&quot;/&gt;与Excel有关的Python包&lt;/h4&gt;&lt;p&gt;目前，常用的与Excel有关的第三方Python包如下表所示。&lt;br/&gt;&lt;img src=&quot;http://download.broadview.com.cn/Original/2201e025c3d8f41a1e59&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;这些包都有各自的特点，有的小、快、灵，有的功能齐全可与VBA使用的对象模型相媲美；有的不依赖Excel，有的必须依赖Excel；有的工作效率一般，有的工作效率很高。&amp;#13;
&lt;/p&gt;&lt;h4 id=&quot;h4-xlwings-python-excel-vba-&quot;&gt;&lt;a name=&quot;xlwings: 为什么Python能完美代替Excel VBA？&quot; class=&quot;reference-link&quot;/&gt;&lt;span class=&quot;header-link octicon octicon-link&quot;/&gt;xlwings: 为什么Python能完美代替Excel VBA？&lt;/h4&gt;&lt;p&gt;在上面的表格中，目前图书和网络介绍得比较多的有xlrd、xlwt和OpenPyXl等包。&lt;/p&gt;&amp;#13;
&lt;p&gt;这几个包提供的功能比较有限，所以给很多同学造成了Python不如VBA的错觉。&lt;/p&gt;&amp;#13;
&lt;p&gt;这里要给大家重点推荐的是表中的win32com包和xlwings包。win32com包将Excel、Word和Powerpoint等软件的所有对象打包成一个COM组件提供给Python调用，所以，它使用的对象模型跟VBA使用的对象模型是完全一样的。&lt;/p&gt;&amp;#13;
&lt;p&gt;Excel脚本编程有两个重要内容，一个是脚本语言，另一个是对象模型，脚本语言通过面向这些对象编程，控制Excel并与Excel软件进行交互操作。&lt;/p&gt;&amp;#13;
&lt;p&gt;现在，对象模型是一样的，Python语言可以代替VBA语言，所以Python能完美代替VBA进行Excel脚本编程，VBA能做的，使用win32com也能做。&lt;/p&gt;&amp;#13;
&lt;p&gt;xlwings包则是在win32com包的基础上进行了二次封装，所以，&lt;strong&gt;VBA能做的，使用xlwings也能做&lt;/strong&gt;。&lt;/p&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;不仅如此，用Python代替Excel VBA，还可以免费获得Python提供的大量数据分析、数据可视化和网络编程等方面的能力。&lt;/strong&gt;&lt;/p&gt;&amp;#13;
&lt;h4 id=&quot;h4-xlwings-&quot;&gt;&lt;a name=&quot;xlwings牛刀小试&quot; class=&quot;reference-link&quot;/&gt;&lt;span class=&quot;header-link octicon octicon-link&quot;/&gt;xlwings牛刀小试&lt;/h4&gt;&lt;p&gt;下面这段代码用于在工作簿中批量创建10个工作表：&lt;br/&gt;&lt;img src=&quot;http://download.broadview.com.cn/Original/2201d934b6250b0a41fd&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;效果如下图所示。&lt;br/&gt;&lt;img src=&quot;http://download.broadview.com.cn/Original/220196986adcb612965f&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;下面的代码利用工作表中的数据创建图表：&lt;br/&gt;&lt;img src=&quot;http://download.broadview.com.cn/Original/220156768b10d0e87da3&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;效果如下图所示：&lt;br/&gt;&lt;img src=&quot;http://download.broadview.com.cn/Original/22017525be1471417a49&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;xlwings的主要功能综述如下：&lt;br/&gt;&lt;img src=&quot;http://download.broadview.com.cn/Original/2201b433ec75de89b18a&quot; alt=&quot;&quot;/&gt;&amp;#13;
&lt;/p&gt;&lt;h4 id=&quot;h4-xlwings-&quot;&gt;&lt;a name=&quot;xlwings好学吗？&quot; class=&quot;reference-link&quot;/&gt;&lt;span class=&quot;header-link octicon octicon-link&quot;/&gt;xlwings好学吗？&lt;/h4&gt;&lt;p&gt;既然VBA能做的，Python基于xlwings包都能做，那么问题来了：xlwings好学吗？&lt;/p&gt;&amp;#13;
&lt;p&gt;xlwings包在win32com包的基础上进行了二次封装，所以它一方面间接继承了VBA所使用的Excel对象模型甚至VBA的语法，另一方面它又对常用的功能封装了新的语法。&lt;/p&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;所以，xlwings实际上有两种使用方式&lt;/strong&gt;，一种是使用类VBA语法的API使用方式，另一种是使用封装后的新语法的使用方式。&lt;/p&gt;&amp;#13;
&lt;p&gt;下面的代码分别使用Excel VBA和xlwings的API来选择工作表中的一个单行。&lt;br/&gt;&lt;img src=&quot;http://download.broadview.com.cn/Original/22019a8768b641a45cb2&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;可见，二者在语法上高度相似。对于熟悉VBA语法的同学而言，使用xlwings很快就能上手。&amp;#13;
&lt;/p&gt;&lt;p&gt;xlwings封装的新语法则更简练。例如，下面的代码同样实现选择单行的功能。&lt;br/&gt;&lt;img src=&quot;http://download.broadview.com.cn/Original/2201b497c52162f73186&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;使用xlwings的新语法从工作表中获取一个单行或单列区域的值，返回的是一个列表表示的一维数组。&lt;br/&gt;&lt;img src=&quot;http://download.broadview.com.cn/Original/2201103abbfebb04739f&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;使用Excel VBA获取到的则是一个二维数组，需要通过转换得到一维数组。&amp;#13;
&lt;/p&gt;&lt;h4 id=&quot;h4--xlwings-&quot;&gt;&lt;a name=&quot;学习xlwings的好书&quot; class=&quot;reference-link&quot;/&gt;&lt;span class=&quot;header-link octicon octicon-link&quot;/&gt;学习xlwings的好书&lt;/h4&gt;&lt;p&gt;这里给大家分享一本学习xlwings的好书——&lt;strong&gt;《代替VBA！用Python轻松实现Excel编程》&lt;/strong&gt;！&lt;br/&gt;&lt;img src=&quot;http://download.broadview.com.cn/Original/22012dc2e363d510c37c&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;本书以xlwings为主线，用Python一对一复现了Excel VBA的各种脚本编程能力。内容从语言基础，到Excel对象模型、文件、图形图表，到字典、正则表达式应用专题，到pandas数据分析，混合编程等，覆盖了Excel办公自动化和数据分析编程的主要内容。&amp;#13;
&lt;/p&gt;&lt;h4 id=&quot;h4--&quot;&gt;&lt;a name=&quot;怎样解决语言问题？&quot; class=&quot;reference-link&quot;/&gt;&lt;span class=&quot;header-link octicon octicon-link&quot;/&gt;怎样解决语言问题？&lt;/h4&gt;&lt;p&gt;Python基于xlwings包进行Excel脚本编程时，由于使用的Excel对象模型与VBA使用的一样，所以能实现完美替换VBA。&lt;/p&gt;&amp;#13;
&lt;p&gt;但是，有的同学可能会讲，还有语言问题呢，Python看起来并没有宣传的那样好学！&lt;/p&gt;&amp;#13;
&lt;p&gt;我们想到的办法是&lt;strong&gt;语言对照学习&lt;/strong&gt;。&lt;/p&gt;&amp;#13;
&lt;p&gt;对照学习是将两种语言的语法打碎，并实现语法知识点一对一的对照和融合，能帮助我们在自己熟悉的语境里快速理解和掌握另一门语言。&lt;/p&gt;&amp;#13;
&lt;p&gt;关于Python与Excel VBA语言对照学习方面的图书我们正在撰写，敬请关注。我们愿意以最贴心的服务，为您从Excel VBA快速平稳过渡到Python保驾护航。&lt;/p&gt;&amp;#13;
&lt;h4 id=&quot;h4--&quot;&gt;&lt;a name=&quot;扫码抢购！&quot; class=&quot;reference-link&quot;/&gt;&lt;span class=&quot;header-link octicon octicon-link&quot;/&gt;扫码抢购！&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;http://download.broadview.com.cn/Original/2201f2d3b187d4b181ea&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://download.broadview.com.cn/Original/220166a7c0211715e7e8&quot; alt=&quot;&quot;/&gt;&amp;#13;
&amp;#13;
            &lt;/p&gt;&lt;/div&gt;&amp;#13;
&amp;#13;
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7d935b068631049138a8e1ebc2bfc5db</guid>
<title>一位程序员的财务自由之路</title>
<link>https://toutiao.io/k/libwh52</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavicaI1BJcqGolKjg5UqMPw9slThuiaxw1aNPNgh17wXuIDAibIboEkSpeVuS5p0OLWibicexn0TNC9gNcg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原文作者：Rajiv Prabhakar  翻译：我爱程序员&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;我的微信号：&lt;/span&gt;&lt;span&gt;toutiaoio007&lt;/span&gt;&lt;span&gt; ，欢迎加我，拉你入群！&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;20岁那年，我作为实习生参加了一个关于“个人理财”的工作坊——这是我生命中的一个重要时刻。&lt;br/&gt;在一个小时的学习中，我了解了买入并持有资产和复利的力量。&lt;br/&gt;我了解到，&lt;strong&gt;通过财务和投资规划，即使是一个薪水只有五位数的普通工程师，也可以在30多岁时成为百万富翁。&lt;/strong&gt;&lt;br/&gt;我一直认为，为了支付账单和维持生计需要工作到60岁，成为“千万富翁”是遥不可及的事情。这次学习改变了我对自己财务命运的看法。&lt;br/&gt;从那时起，财务自由成了我优先考虑和追求的事情。到今年为止，在工作了12年后，我终于实现了自己的目标。&lt;br/&gt;这篇文章是关于我财务自由之路的具体细节，希望对你有所帮助。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;这是我职业生涯每一年的收入、储蓄以及储蓄增长情况。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.1348884381338742&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;986&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavicaI1BJcqGolKjg5UqMPw9sG76lpXwd1ibJ6SfZWA8AxicoO0dyczKVKBjicib7mIPI4o2ibt6dwmM9Tng/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;在实现财务自由的过程中，我总结的一些经验：&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;1、当你获得大幅加薪时，会想着把钱花在买东西上，比如更大的房子或更好的汽车。&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;这当然可以理解，但应避免陷入“享乐主义”，而应节省这些钱。如果可能，把钱花在体验上，而不是东西上。与我花钱买的所有东西相比，财务自由是最大的奢侈。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、房价贵得离谱，我会选择在旧金山、纽约或通勤距离很短的地方租房。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;与人合租，我要支付约1000美元，单独住则要支付约2000美元。你可能讨厌与人合租，但它创造了一种非常有趣的社交生活体验，并且还省钱。 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3、学会投资，别只把钱存在银行里。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;作为一个职业生涯很长的年轻人，你具备承担风险的条件。将大部分资金投资于全球股票市场，短期来看，你可能会遭受损失，但长期来看，你会赚钱。通过投资复利，我的净资产增加了近100万美元。 &lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4、买房是你做出的最大财务决定，需要清楚地了解其利弊。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;在很多情况下，租房比买房更划算。 &lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;5、如果你还是学生或者正准备读研究生，请尽一切可能考入一所好的院校。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;6、从计算机硬件工程师转行为软件工程师时，我的收入获得了最大的提升。&lt;/strong&gt;&lt;br/&gt;你选择的职业将对薪酬产生巨大影响，不要害怕改变你的职业生涯。如果我现在20岁，我会认真考虑专攻机器学习。&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;7、不要让短期恐惧阻碍你的长期成功。&lt;/strong&gt;&lt;br/&gt;我在硬件行业的前5年阻碍了我的职业发展，从那以后我一直在追赶那些直接进入软件行业的同学。&lt;br/&gt;大一的时候，有人问我为什么不想主修计算机科学，我回答：“从高中就开始编程的人很多，与他们相比我会处于劣势。” 我最终还是转行了，但是7年后，我处于更大的劣势。&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;8、去创业公司还是大公司？&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;如果你的目标是稳赚，应该去大公司；如果你的目标是做很多很酷的东西，或者希望有一天成为高管，你应该去创业公司。 &lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;9、练习你的面试技巧，这是你能做的最好的财务投资&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;br/&gt;你的薪酬期望越高，你就越需要在面试和工作中给他们留下深刻印象。&lt;br/&gt;&lt;br/&gt;现在我“退休”了，理论上我可以在海滩上睡觉、放松、度过余生。但这不是我想要的，也不是我追求财务自由的原因。&lt;strong&gt;我真正的目标一直是按照我自己的方式追求我的人生目标，而不必担心金钱。&lt;/strong&gt;（完）&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;原文链接：https://software.rajivprab.com/2021/12/26/my-path-to-financial-independence-as-a-software-engineer/&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;加入「码农周刊VIP会员」，成为更好的开发者！&lt;br/&gt;↓↓↓&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5493333333333333&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavicibroqCN98y5SNT9NbfA3oHYQiaicFScHFfppgek7ZGicJiaHK45qc2zoccBibfEzIvzTsI4AB2xO2IaOw/640?wx_fmt=jpeg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>