<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>5562370abedb19ef10cba80377e171ac</guid>
<title>Java 知识点整理：Spring、MySQL</title>
<link>https://toutiao.io/k/j4kd9qh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-topic-des nc-post-content&quot;&gt;
&lt;h2 id=&quot;spring-10&quot;&gt;Spring 10&lt;/h2&gt; 
&lt;h3&gt;P1：Spring 框架&lt;/h3&gt; 
&lt;p&gt;Spring 是分层的企业级应用轻量级开源框架，以 IoC 和 AOP为内核。Spring 可以降低企业级应用开发的复杂性，对此主要采取了四个关键策略：基于 POJO 的轻量级和最小侵入性编程、通过依赖注入和面向接口实现松耦合、基于切面和惯性进行声明式编程、通过切面和模板减少样板式代码。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;好处&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;降低代码耦合度、简化开发。通过 Spring 提供的 IoC 容器可以将对象间的依赖关系交由 Spring 进行控制，避免硬编码所造成的过度程序耦合。用户也不必再为单例模式类、属性文件解析等这些底层的需求编写代码，可以更专注于上层的应用。&lt;/p&gt; 
&lt;p&gt;AOP 编程以及声明式事务的支持。通过 Spring 的 AOP 功能可以方便进行面向切面的编程，通过声明式事务可以灵活进行事务管理，提高开发效率和质量。&lt;/p&gt; 
&lt;p&gt;方便程序的测试和集成各种框架。可以用非容器依赖的编程方式进行几乎所有的测试工作，可以降低各种框架的使用难度，提供了对 Mybatis 和 Hibernate 等框架的直接支持。&lt;/p&gt; 
&lt;p&gt;降低了 JavaEE API 的使用难度。Spring 对 JDBC、JavaMail、远程调用等 API 进行了封装，使这些 API 的使用难度大幅降低。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;核心容器&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;核心容器由 spring-beans、spring-core、spring-context 和 spring-expression 四个模块组成。&lt;/p&gt; 
&lt;p&gt;spring-beans 和 spring-core 模块是 Spring 的核心模块，包括了控制反转和依赖注入。BeanFactory 使用控制反转对应用程序的配置和依赖性规范与实际的应用代码进行分离，BeanFactory 实例化后并不会自动实例化 Bean，只有当 Bean 被使用时才会对其进行实例化与依赖关系的装配。&lt;/p&gt; 
&lt;p&gt;spring-context 模块构架于核心模块之上，扩展了 BeanFactory，为它添加了 Bean 的生命周期控制、框架事件体系及资源透明化加载等功能。ApplicationConext 是该模块的核心接口，它是 BeanFactory 的子接口，它实例化后会自动对所有单例 Bean 进行实例化与依赖关系的装配，使之处于待用状态。&lt;/p&gt; 
&lt;p&gt;spring-expression 是 EL 语言的扩展模块，可以查询、管理运行中的对象，同时也可以方便地调用对象方法，以及操作数组、集合等。&lt;/p&gt; 
&lt;hr/&gt; 
&lt;h3&gt;P2：IoC 控制反转&lt;/h3&gt; 
&lt;p&gt;IoC 即控制反转，是一种给予应用程序中目标组件更多控制的设计范式，简单来说就是把原来代码里需要实现的对象创建、依赖反转给容器来帮忙实现，需要创建一个容器并且需要一种描述来让容器知道要创建的对象之间的关系，在 Spring 框架中管理对象及其依赖关系是通过 Spring 的 IoC 容器实现的，IoC 的作用是降低代码耦合度。&lt;/p&gt; 
&lt;p&gt;IoC 的实现方式有依赖注入和依赖查找，由于依赖查找使用的很少，因此 IoC 也叫做依赖注入。依赖注入指对象被动地接受依赖类而不用自己主动去找，对象不是从容器中查找它依赖的类，而是在容器实例化对象时主动将它依赖的类注入给它。假设一个 Car 类需要一个 Engine 的对象，那么一般需要需要手动 new 一个 Engine，利用 IoC 就只需要定义一个私有的 Engine 类型的成员变量，容器会在运行时自动创建一个 Engine 的实例对象并将引用自动注入给成员变量。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;基于 XML 的容器初始化&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;当创建一个 ClassPathXmlApplicationContext 时，构造器做了两件事：首先调用父容器的构造器为容器设置好 Bean 资源加载器，然后调用父类的 setConfigLocations 方法设置 Bean 配置信息的定位路径。&lt;/p&gt; 
&lt;p&gt;ClassPathXmlApplicationContext 通过调用父类 AbstractApplicationContext 的 refresh 方法启动整个 IoC 容器对 Bean 定义的载入过程，refresh 是一个模板方法，规定了 IoC 容器的启动流程。refresh 方法的主要作用是：在创建 IoC 容器之前如果已有容器存在，需要把已有的容器销毁和关闭，以保证在 refresh 方法之后使用的是新创建的 IoC 容器。&lt;/p&gt; 
&lt;p&gt;容器创建后通过 loadBeanDefinitions 方法加载 Bean 配置资源，该方***做两件事：首先调用资源加载器的方法获取要加载的资源，其次真正执行加载功能，由子类 XmlBeanDefinitionReader 实现。在加载资源时，首先会解析配置文件路径，读取配置文件的内容，然后通过 XML 解析器将 Bean 配置信息转换成文档对象，之后再按照 Spring Bean 的定义规则对文档对象进行解析。&lt;/p&gt; 
&lt;p&gt;Spring IoC 容器中注册解析的 Bean 信息存放在一个 HashMap 集合中，key 是 String 字符串，值是 BeanDefinition，在注册过程中需要使用 synchronized 同步块保证线程安全。当 Bean 配置信息中配置的 Bean 被解析后且被注册到 IoC 容器中，初始化就算真正完成了，Bean 定义信息已经可以使用，并且可以被检索。Spring IoC 容器的作用就是对这些注册的 Bean 定义信息进行处理和维护，注册的 Bean 定义信息是控制反转和依赖注入的基础。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;基于注解的容器初始化&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;Spring 对注解的处理分为两种方式：① 直接将注解 Bean 注册到容器中，可以在初始化容器时注册，也可以在容器创建之后手动注册，然后刷新容器使其对注册的注解 Bean 进行处理。② 通过扫描指定的包及其子包的所有类处理，在初始化注解容器时指定要自动扫描的路径。&lt;/p&gt; 
&lt;hr/&gt; 
&lt;h3&gt;P3：DI 依赖注入&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;可注入的数据类型&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;基本数据类型和 String、集合类型、Bean 类型。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;实现方式&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;构造器注入：IoC Service Provider 会检查被注入对象的构造器，取得它所需要的依赖对象列表，进而为其注入相应的对象。这种方法的优点是在对象构造完成后就处于就绪状态，可以马上使用。缺点是当依赖对象较多时，构造器的参数列表会比较长，构造器无法被继承，无法设置默认值。对于非必需的依赖处理可能需要引入多个构造器，参数数量的变动可能会造成维护的困难。&lt;/p&gt; 
&lt;p&gt;setter 方法注入：当前对象只需要为其依赖对象对应的属性添加 setter 方法，就可以通过 setter 方法将依赖对象注入到被依赖对象中。setter 方法注入在描述性上要比构造器注入强，并且可以被继承，允许设置默认值。缺点是无法在对象构造完成后马上进入就绪状态。&lt;/p&gt; 
&lt;p&gt;接口注入：必须实现某个接口，这个接口提供一个方法来为其注入依赖对象。使用较少，因为它强制要求被注入对象实现不必要的接口，侵入性强。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;相关注解&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;@Autowired&lt;/code&gt;：自动按类型注入，如果有多个匹配则按照指定 Bean 的 id 查找，查找不到会报错。&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;@Qualifier&lt;/code&gt;：在自动按照类型注入的基础上再按照 Bean 的 id 注入，给变量注入时必须搭配 &lt;code&gt;@Autowired&lt;/code&gt;，给方法注入时可单独使用。&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;@Resource&lt;/code&gt; ：直接按照 Bean 的 id 注入，只能注入 Bean 类型。&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;@Value&lt;/code&gt; ：用于注入基本数据类型和 String 类型。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;依赖注入的过程&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;getBean 方法是获取 Bean 实例的方法，该方***调用 doGetBean 方法，doGetBean 真正实现向 IoC 容器获取 Bean 的功能，也是触发依赖注入的地方。如果 Bean 定义为单例模式，容器在创建之前先从缓存中查找以确保整个容器中只存在一个实例对象。如果 Bean 定义为原型模式，则容器每次都会创建一个新的实例。&lt;/p&gt; 
&lt;p&gt;具体创建 Bean 实例对象的过程由 ObjectFactory 的 createBean 方法完成，该方法主要通过 createBeanInstance 方法生成 Bean 包含的 Java 对象实例和 populateBean 方法对 Bean 属性的依赖注入进行处理。&lt;/p&gt; 
&lt;p&gt;在 createBeanInstance 方法中根据指定的初始化策略，通过简单工厂、工厂方法或容器的自动装配特性生成 Java 实例对象，对工厂方法和自动装配特性的 Bean，调用相应的工厂方法或参数匹配的构造器即可完成实例化对象的工作，但最常用的默认无参构造器需要使用 JDK 的反射或 CGLib 来进行初始化。&lt;/p&gt; 
&lt;p&gt;在 populateBean 方法中，注入过程主要分为两种情况：① 属性值类型不需要强制转换时，不需要解析属性值，直接进行依赖注入。② 属性值类型需要强制转换时，首先需要解析属性值，然后对解析后的属性值进行依赖注入。依赖注入的过程就是将 Bean 对象实例设置到它所依赖的 Bean 对象属性上，真正的依赖注入是通过 setPropertyValues 方法实现的，该方法使用了委派模式。&lt;/p&gt; 
&lt;p&gt;BeanWrapperImpl 类负责对容器完成初始化的 Bean 实例对象进行属性的依赖注入，对于非集合类型的属性，大量使用 JDK 的反射机制，通过属性的 getter 方法获取指定属性注入前的值，同时调用属性的 setter 方法为属性设置注入后的值。对于集合类型的属性，将属性值解析为目标类型的集合后直接赋值给属性。&lt;/p&gt; 
&lt;p&gt;当 Spring IoC 容器对 Bean 定义资源的定位、载入、解析和依赖注入全部完成后，就不再需要我们手动创建所需的对象，Spring IoC 容器会自动为我们创建对象并且注入好相关依赖。&lt;/p&gt; 
&lt;hr/&gt; 
&lt;h3&gt;P4：Bean 对象&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;生命周期&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;在 IoC 容器的初始化过程中会对 Bean 定义完成资源定位，加载读取配置并解析，最后将解析的 Bean 信息放在一个 HashMap 集合中。当 IoC 容器初始化完成后，会进行对 Bean 实例的创建和依赖注入过程，注入对象依赖的各种属性值，在初始化时可以指定自定义的初始化方法。经过这一系列初始化操作后 Bean 达到可用状态，接下来就可以使用 Bean 了，当使用完成后会调用 destroy 方法进行销毁，此时也可以指定自定义的销毁方法，最终 Bean 被销毁且从容器中移除。&lt;/p&gt; 
&lt;p&gt;指定 Bean 初始化和销毁的方法：&lt;/p&gt; 
&lt;p&gt;XML 方式通过配置 bean 标签中的 init-Method 和 destory-Method 指定自定义初始化和销毁方法。 &lt;/p&gt; 
&lt;p&gt;注解方式通过 &lt;code&gt;@PreConstruct&lt;/code&gt; 和 &lt;code&gt;@PostConstruct&lt;/code&gt; 注解指定自定义初始化和销毁方法。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;作用范围&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;通过 scope 属性指定 bean 的作用范围，包括：① singleton：单例模式，是默认作用域，不管收到多少 Bean 请求每个容器中只有一个唯一的 Bean 实例。② prototype：原型模式，和 singleton 相反，每次 Bean 请求都会创建一个新的实例。③ request：每次 HTTP 请求都会创建一个新的 Bean 并把它放到 request 域中，在请求完成后 Bean 会失效并被垃圾收集器回收。④ session：和 request 类似，确保每个 session 中有一个 Bean 实例，session 过期后 bean 会随之失效。⑤ global session：当应用部署在 Portlet 容器中时，如果想让所有 Portlet 共用全局存储变量，那么这个变量需要存储在 global session 中。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;创建方式&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;XML&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;通过默认无参构造器，只需要指明 bean 标签中的 id 和 class 属性，如果没有无参构造器会报错。&lt;/p&gt; 
&lt;p&gt;使用静态工厂方法，通过 bean 标签中的 class 属性指明静态工厂，factory-method 属性指明静态工厂方法。&lt;/p&gt; 
&lt;p&gt;使用实例工厂方法，通过 bean 标签中的 factory-bean 属性指明实例工厂，factory-method 属性指明实例工厂方法。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;注解&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;@Component&lt;/code&gt; 把当前类对象存入 Spring 容器中，相当于在 xml 中配置一个 bean 标签。value 属性指定 bean 的 id，默认使用当前类的首字母小写的类名。&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;@Controller&lt;/code&gt;，&lt;code&gt;@Service&lt;/code&gt;，&lt;code&gt;@Repository&lt;/code&gt; 三个注解都是 &lt;code&gt;@Component&lt;/code&gt; 的衍生注解，作用及属性都是一模一样的。只是提供了更加明确语义，&lt;code&gt;@Controller&lt;/code&gt; 用于表现层，&lt;code&gt;@Service&lt;/code&gt;用于业务层，&lt;code&gt;@Repository&lt;/code&gt;用于持久层。如果注解中有且只有一个 value 属性要赋值时可以省略 value。&lt;/p&gt; 
&lt;p&gt;如果想将第三方的类变成组件又没有源代码，也就没办法使用 &lt;code&gt;@Component&lt;/code&gt; 进行自动配置，这种时候就要使用 &lt;code&gt;@Bean&lt;/code&gt; 注解。被 &lt;code&gt;@Bean&lt;/code&gt; 注解的方法返回值是一个对象，将会实例化，配置和初始化一个新对象并返回，这个对象由 Spring 的 IoC 容器管理。name 属性用于给当前 &lt;code&gt;@Bean&lt;/code&gt; 注解方法创建的对象指定一个名称，即 bean 的 id。当使用注解配置方法时，如果方法有参数，Spring 会去容器查找是否有可用 bean对象，查找方式和 &lt;code&gt;@Autowired&lt;/code&gt; 一样。&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;@Configuration&lt;/code&gt; 用于指定当前类是一个 spring 配置类，当创建容器时会从该类上加载注解，value 属性用于指定配置类的字节码。&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;@ComponentScan&lt;/code&gt; 用于指定 Spring 在初始化容器时要扫描的包。basePackages 属性用于指定要扫描的包。&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;@PropertySource&lt;/code&gt; 用于加载 &lt;code&gt;.properties&lt;/code&gt; 文件中的配置。value 属性用于指定文件位置，如果是在类路径下需要加上 classpath。&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;@Import&lt;/code&gt; 用于导入其他配置类，在引入其他配置类时可以不用再写 &lt;code&gt;@Configuration&lt;/code&gt; 注解。有 &lt;code&gt;@Import&lt;/code&gt; 的是父配置类，引入的是子配置类。value 属性用于指定其他配置类的字节码。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;BeanFactory、FactoryBean 和 ApplicationContext 的区别&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;BeanFactory 是一个 Bean 工厂，实现了工厂模式，是 Spring IoC 容器最顶级的接口，可以理解为含有 Bean 集合的工厂类，它的作用是管理 Bean，包括实例化、定位、配置应用程序中的对象及建立这些对象之间的依赖。BeanFactory 实例化后并不会自动实例化 Bean，只有当 Bean 被使用时才会对其进行实例化与依赖关系的装配，属于延迟加载，适合多例模式。&lt;/p&gt; 
&lt;p&gt;FactoryBean 是一个工厂 Bean，作用是生产其他 Bean 实例，可以通过实现该接口，提供一个工厂方法来自定义实例化 Bean 的逻辑。&lt;/p&gt; 
&lt;p&gt;ApplicationConext 是 BeanFactory 的子接口，扩展了 BeanFactory 的功能，提供了支持国际化的文本消息，统一的资源文件读取方式，事件传播以及应用层的特别配置等。容器会在初始化时对配置的 Bean 进行预实例化，Bean 的依赖注入在容器初始化时就已经完成，属于立即加载，适合单例模式，一般推荐使用 ApplicationContext。&lt;/p&gt; 
&lt;hr/&gt; 
&lt;h3&gt;P5：AOP 面向切面编程&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;概念和原理&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;AOP 即面向切面编程，简单地说就是将代码中重复的部分抽取出来，在需要执行的时候使用动态代理的技术，在不修改&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%BA%90%E7%A0%81&quot; target=&quot;_blank&quot;&gt;源码&lt;/a&gt;的基础上对方法进行增强。优点是可以减少代码的冗余，提高开发效率，维护方便。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;Spring 会根据类是否实现了接口来判断动态代理的方式，如果实现了接口会使用 JDK 的动态代理，核心是 InvocationHandler 接口和 Proxy 类，如果没有实现接口会使用 CGLib 动态代理，CGLib 是在运行时动态生成某个类的子类，如果某一个类被标记为 final，是不能使用 CGLib 动态代理的。&lt;/p&gt; 
&lt;p&gt;JDK 动态代理主要通过重组字节码实现，首先获得被代理对象的引用和所有接口，生成新的类必须实现被代理类的所有接口，动态生成Java 代码后编译新生成的 &lt;code&gt;.class&lt;/code&gt; 文件并重新加载到 JVM 运行。JDK 代理直接写 Class 字节码，CGLib是采用ASM框架写字节码，生成代理类的效率低。但是CGLib调用方法的效率高，因为 JDK 使用反射调用方法，CGLib 使用 FastClass 机制为代理类和被代理类各生成一个类，这个类会为代理类或被代理类的方法生成一个 index，这个 index 可以作为参数直接定位要调用的方法。&lt;/p&gt; 
&lt;p&gt;常用场景包括权限认证、自动缓存、错误处理、日志、调试和事务等。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;相关注解&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;@Aspect&lt;/code&gt;：声明被注解的类是一个切面 Bean。&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;@Before&lt;/code&gt;：前置通知，指在某个连接点之前执行的通知。&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;@After&lt;/code&gt;：后置通知，指某个连接点退出时执行的通知（不论正常返回还是异常退出）。&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;@AfterReturning&lt;/code&gt;：返回后通知，指某连接点正常完成之后执行的通知，返回值使用returning属性接收。&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;@AfterThrowing&lt;/code&gt;：异常通知，指方法抛出异常导致退出时执行的通知，和&lt;code&gt;@AfterReturning&lt;/code&gt;只会有一个执行，异常使用throwing属性接收。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;相关术语&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;Aspect&lt;/code&gt;：切面，一个关注点的模块化，这个关注点可能会横切多个对象。&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;Joinpoint&lt;/code&gt;：连接点，程序执行过程中的某一行为，即业务层中的所有方法。。&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;Advice&lt;/code&gt;：通知，指切面对于某个连接点所产生的动作，包括前置通知、后置通知、返回后通知、异常通知和环绕通知。&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;Pointcut&lt;/code&gt;：切入点，指被拦截的连接点，切入点一定是连接点，但连接点不一定是切入点。&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;Proxy&lt;/code&gt;：代理，Spring AOP 中有 JDK 动态代理和 CGLib 代理，目标对象实现了接口时采用 JDK 动态代理，反之采用 CGLib 代理。&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;Target&lt;/code&gt;：代理的目标对象，指一个或多个切面所通知的对象。&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;Weaving&lt;/code&gt; ：织入，指把增强应用到目标对象来创建代理对象的过程。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;AOP 的过程&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;Spring AOP 是由 BeanPostProcessor 后置处理器开始的，这个后置处理器是一个***，可以监听容器触发的 Bean 生命周期事件，向容器注册后置处理器以后，容器中管理的 Bean 就具备了接收 IoC 容器回调事件的能力。BeanPostProcessor 的调用发生在 Spring IoC 容器完成 Bean 实例对象的创建和属性的依赖注入之后，为 Bean 对象添加后置处理器的入口是 initializeBean 方法。&lt;/p&gt; 
&lt;p&gt;Spring 中 JDK 动态代理生通过 JdkDynamicAopProxy 调用 Proxy 的 newInstance 方法来生成代理类，JdkDynamicAopProxy 也实现了 InvocationHandler 接口，invoke 方法的具体逻辑是先获取应用到此方法上的拦截器链，如果有拦截器则创建 MethodInvocation 并调用其 proceed 方法，否则直接反射调用目标方法。因此 Spring AOP 对目标对象的增强是通过拦截器实现的。&lt;/p&gt; 
&lt;hr/&gt; 
&lt;h3&gt;P6：Spring MVC 核心组件&lt;/h3&gt; 
&lt;p&gt;&lt;code&gt;DispatcherServlet&lt;/code&gt;&lt;span&gt;：SpringMVC 中的&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%89%8D%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;前端&lt;/a&gt;控制器，是整个流程控制的核心，负责接收请求并转发给对应的处理组件。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;Handler&lt;/code&gt;：处理器，完成具体业务逻辑，相当于 Servlet 或 Action。&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;HandlerMapping&lt;/code&gt;：完成URL 到 Controller映射的组件，DispatcherServlet 接收到请求之后，通过 HandlerMapping 将不同的请求映射到不同的 Handler。&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;HandlerInterceptor&lt;/code&gt;：处理器拦截器，是一个接口，如果需要完成一些拦截处理，可以实现该接口。&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;HandlerExecutionChain&lt;/code&gt;：处理器执行链，包括两部分内容：Handler 和 HandlerInterceptor。&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;HandlerAdapter&lt;/code&gt;：处理器适配器，Handler执行业务方法前需要进行一系列操作，包括表单数据验证、数据类型转换、将表单数据封装到JavaBean等，这些操作都由 HandlerAdapter 完成。DispatcherServlet 通过 HandlerAdapter 来执行不同的 Handler。&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;ModelAndView&lt;/code&gt;：装载了模型数据和视图信息，作为 Handler 的处理结果返回给 DispatcherServlet。&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;ViewResolver&lt;/code&gt;&lt;span&gt;：视图解析器，DispatcherServlet 通过它将逻辑视图解析为物理视图，最终将渲染的结果响应给&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt; 
&lt;hr/&gt; 
&lt;h3&gt;P7：Spring MVC 处理流程&lt;/h3&gt; 
&lt;p&gt;Web 容器启动时会通知 Spring 初始化容器，加载 Bean 的定义信息并初始化所有单例 Bean，然后遍历容器中的 Bean，获取每一个 Controller 中的所有方法访问的 URL，将 URL 和对应的 Controller 保存到一个 Map 集合中。&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;所有的请求会转发给 DispatcherServlet &lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%89%8D%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;前端&lt;/a&gt;处理器处理，DispatcherServlet 会请求 HandlerMapping 找出容器中被 &lt;/span&gt;&lt;code&gt;@Controler&lt;/code&gt; 注解修饰的 Bean 以及被 &lt;code&gt;@RequestMapping&lt;/code&gt; 修饰的方法和类，生成 Handler 和 HandlerInterceptor 并以一个 HandlerExcutionChain 处理器执行链的形式返回。&lt;/p&gt; 
&lt;p&gt;之后 DispatcherServlet 使用 Handler 找到对应的 HandlerApapter，通过 HandlerApapter 调用 Handler 的方法，将请求参数绑定到方法的形参上，执行方法处理请求并得到 ModelAndView。&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;最后 DispatcherServlet 根据使用 ViewResolver 试图解析器对得到的 ModelAndView 逻辑视图进行解析得到 View 物理视图，然后对视图渲染，将数据填充到视图中并返回给&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;注解&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;@Controller&lt;/code&gt;：在类定义处添加，将类交给IoC容器管理。&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;@RequtestMapping&lt;/code&gt;：将URL请求和业务方法映射起来，在类和方法定义上都可以添加该注解。&lt;code&gt;value&lt;/code&gt; 属性指定URL请求的实际地址，是默认值。&lt;code&gt;method&lt;/code&gt; 属性限制请求的方法类型，包括GET、POST、PUT、DELETE等。如果没有使用指定的请求方法请求URL，会报405 Method Not Allowed 错误。&lt;code&gt;params&lt;/code&gt; 属性限制必须提供的参数，如果没有会报错。&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;@RequestParam&lt;/code&gt;：如果 Controller 方法的形参和 URL 参数名一致可以不添加注解，如果不一致可以使用该注解绑定。&lt;code&gt;value&lt;/code&gt; 属性表示HTTP请求中的参数名。&lt;code&gt;required&lt;/code&gt; 属性设置参数是否必要，默认false。&lt;code&gt;defaultValue&lt;/code&gt; 属性指定没有给参数赋值时的默认值。&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;@PathVariable&lt;/code&gt;：Spring MVC 也支持 RESTful 风格的 URL，通过 &lt;code&gt;@PathVariable&lt;/code&gt; 完成请求参数与形参的绑定。&lt;/p&gt; 
&lt;hr/&gt; 
&lt;h3&gt;P8：Spring Data JPA 框架&lt;/h3&gt; 
&lt;p&gt;Spring Data JPA 是 Spring 基于 ORM 框架、JPA 规范的基础上封装的一套 JPA 应用框架，可使开发者用极简的代码实现对数据库的访问和操作。它提供了包括增删改查等在内的常用功能，且易于扩展，可以极大提高开发效率。&lt;/p&gt; 
&lt;p&gt;ORM 即 Object-Relational Mapping ，表示对象关系映射，映射的不只是对象的值还有对象之间的关系，通过 ORM 就可以把对象映射到关系型数据库中。操作实体类就相当于操作数据库表，可以不再重点关注 SQL 语句。&lt;/p&gt; 
&lt;p&gt;使用时只需要持久层接口继承 JpaRepository 即可，泛型参数列表中第一个参数是实体类类型，第二个参数是主键类型。运行时通过 &lt;code&gt;JdkDynamicAopProxy&lt;/code&gt; 的 &lt;code&gt;invoke&lt;/code&gt; 方法创建了一个动态代理对象 &lt;code&gt;SimpleJpaRepository&lt;/code&gt;，&lt;code&gt;SimpleJpaRepository&lt;/code&gt; 中封装了 JPA 的操作，通过 &lt;code&gt;hibernate&lt;/code&gt;（封装了JDBC）完成数据库操作。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;注解&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;@Entity&lt;/code&gt;：表明当前类是一个实体类。&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;@Table&lt;/code&gt; ：关联实体类和数据库表。&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;@Column&lt;/code&gt; ：关联实体类属性和数据库表中字段。&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;@Id&lt;/code&gt; ：声明当前属性为数据库表主键对应的属性。&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;@GeneratedValue&lt;/code&gt;： 配置主键生成策略。&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;@OneToMany&lt;/code&gt; ：配置一对多关系，mappedBy 属性值为主表实体类在从表实体类中对应的属性名。&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;@ManyToOne&lt;/code&gt; ：配置多对一关系，targetEntity 属性值为主表对应实体类的字节码。&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;@JoinColumn&lt;/code&gt;：配置外键关系，name 属性值为外键名称，referencedColumnName 属性值为主表主键名称。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;对象导航查询&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;通过 get 方法查询一个对象的同时，通过此对象可以查询它的关联对象。&lt;/p&gt; 
&lt;p&gt;对象导航查询一到多默认使用延迟加载的形式， 关联对象是集合，因此使用立即加载可能浪费资源。&lt;/p&gt; 
&lt;p&gt;对象导航查询多到一默认使用立即加载的形式， 关联对象是一个对象，因此使用立即加载。&lt;/p&gt; 
&lt;p&gt;如果要改变加载方式，在实体类注解配置加上 fetch 属性即可，LAZY 表示延迟加载，EAGER 表示立即加载。&lt;/p&gt; 
&lt;hr/&gt; 
&lt;h3&gt;P9：Mybatis 框架&lt;/h3&gt; 
&lt;p&gt;Mybatis 是一个实现了数据持久化的 ORM 框架，简单理解就是对 JDBC 进行了封装。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;相比 JDBC 减少了大量代码量，减少冗余代码。&lt;/p&gt; 
&lt;p&gt;使用灵活，SQL 语句写在 XML 里，从程序代码中彻底分离，降低了耦合度，便于管理。&lt;/p&gt; 
&lt;p&gt;提供 XML 标签，支持编写动态 SQL 语句。&lt;/p&gt; 
&lt;p&gt;提供映射标签，支持对象与数据库的 ORM 字段映射关系。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;SQL 语句编写工作量较大，尤其是字段和关联表多时。&lt;/p&gt; 
&lt;p&gt;SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;映射文件标签&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;select&lt;/code&gt;、&lt;code&gt;insert&lt;/code&gt;、&lt;code&gt;update&lt;/code&gt;、&lt;code&gt;delete&lt;/code&gt; 标签分别对应查询、添加、更新、删除操作。&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;parameterType&lt;/code&gt; 属性表示参数的数据类型，包括基本数据类型和对应的包装类型、String 和 Java Bean 类型，当有多个参数时可以使用 &lt;code&gt;#{argn}&lt;/code&gt; 的形式表示第 n 个参数。除了基本数据类型都要以全限定类名的形式指定参数类型。&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;resultType&lt;/code&gt; 表示返回的结果类型，包括基本数据类型和对应的包装类型、String 和 Java Bean 类型。还可以使用把返回结果封装为复杂类型的 &lt;code&gt;resultMap&lt;/code&gt; 。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;缓存&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;使用缓存可以减少程序和数据库交互的次数，从而提高程序的运行效率。第一次查询后会自动将结果保存到缓存中，下一次查询时直接从缓存中返回结果无需再次查询数据库。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;&lt;strong&gt;一级缓存&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;SqlSession 级别，默认开启且不能关闭。&lt;/p&gt; &lt;p&gt;操作数据库时需要创建 SqlSession 对象，在对象中有一个 HashMap 用于存储缓存数据，不同 SqlSession 之间缓存数据区域互不影响。&lt;/p&gt; &lt;p&gt;一级缓存的作用域是 SqlSession 范围的，在同一个 SqlSession 中执行两次相同的 SQL 语句时，第一次执行完毕会将结果保存在缓存中，第二次查询直接从缓存中获取。&lt;/p&gt; &lt;p&gt;如果 SqlSession 执行了 DML 操作（insert、update、delete），Mybatis 必须将缓存清空以保证数据的有效性。 &lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;&lt;strong&gt;二级缓存&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;Mapper 级别，默认关闭。&lt;/p&gt; &lt;p&gt;使用二级缓存时多个 SqlSession 使用同一个 Mapper 的 SQL 语句操作数据库，得到的数据会存在二级缓存区，同样使用 HashMap 进行数据存储，相比于一级缓存，二级缓存范围更大，多个 SqlSession 可以共用二级缓存，作用域是 Mapper 的同一个 namespace，不同 SqlSession 两次执行相同的 namespace 下的 SQL 语句，参数也相等，则第一次执行成功后会将数据保存在二级缓存中，第二次可直接从二级缓存中取出数据。&lt;/p&gt; &lt;p&gt;要使用二级缓存，先在在全局配置文件中配置：&lt;/p&gt; &lt;pre class=&quot;prettyprint lang-xml&quot; from-niu=&quot;default&quot;&gt;&amp;lt;!-- 开启二级缓存 --&amp;gt;
&amp;lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&amp;gt;&lt;/pre&gt; &lt;p&gt;再在对应的映射文件中配置一个 cache 标签即可。&lt;/p&gt; &lt;pre class=&quot;prettyprint lang-xml&quot; from-niu=&quot;default&quot;&gt;&amp;lt;cache/&amp;gt;&lt;/pre&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;hr/&gt; 
&lt;h3&gt;P10：Spring Cloud 框架&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;单体应用存在的问题&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;随着业务发展，开发越来越复杂。&lt;/p&gt; 
&lt;p&gt;修改、新增某个功能，需要对整个系统进行测试、重新部署。&lt;/p&gt; 
&lt;p&gt;一个模块出现问题，可能导致整个系统崩溃。&lt;/p&gt; 
&lt;p&gt;多个开发团队同时对数据进行管理，容易产生安全漏洞。&lt;/p&gt; 
&lt;p&gt;各个模块使用同一种技术开发，各个模块很难根据实际情况选择更合适的技术框架，局限性很大。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;分布式和集群的区别&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;集群：一台服务器无法负荷高并发的数据访问量，就设置多台服务器一起分担压力，是在物理层面解决问题。&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;分布式：将一个复杂的问题拆分成若干简单的小问题，将一个大型的&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;架构拆分成若干个微服务来协同完成，在软件设计层面解决问题。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;微服务的优点&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;各个服务的开发、测试、部署都相互独立，用户服务可以拆分为独立服务，如果用户量很大，可以很容易对其实现负载。&lt;/p&gt; 
&lt;p&gt;当新需求出现时，使用微服务不再需要考虑各方面的问题，例如兼容性、影响度等。&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;使用微服务拆分&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;后，各个服务之间消除了很多限制，只需要保证对外提供的接口正常可用，而不限制语言和框架等选择。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;服务治理 Eureka&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;服务治理的核心由三部分组成：&lt;strong&gt;服务提供者&lt;/strong&gt;、&lt;strong&gt;服务消费者&lt;/strong&gt;、&lt;strong&gt;注册中心&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;服务注册：在分布式系统架构中，每个微服务在启动时，将自己的信息存储在注册中心。&lt;/p&gt; 
&lt;p&gt;服务发现：服务消费者从注册中心获取服务提供者的网络信息，通过该信息调用服务。&lt;/p&gt; 
&lt;p&gt;Spring Cloud 的服务治理使用 Eureka 实现，Eureka 是 Netflix 开源的基于 REST 的服务治理解决方案，Spring Cloud 集成了 Eureka，提供服务注册和服务发现的功能，可以和基于 Spring Boot 搭建的微服务应用轻松完成整合，将 Eureka 二次封装为 Spring Cloud Eureka。&lt;strong&gt;Eureka Server&lt;/strong&gt; 是注册中心，所有要进行注册的微服务通过 Eureka Client 连接到 Eureka Server 完成注册。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;服务网关 Zuul&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;Spring Cloud 集成了 Zuul 组件，实现服务网关。Zuul 是 Netflix 提供的一个开源的 API 网关服务器，是&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;和网站后端所有请求的中间层，对外开放一个 API，将所有请求导入统一的入口，屏蔽了服务端的具体实现逻辑，可以实现方向代理功能，在网关内部实现动态路由、身份认证、IP过滤、数据监控等。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;负载均衡 Ribbon&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;Spring Cloud Ribbon 是一个负载均衡的解决方案，Ribbon 是 Netflix 发布的均衡负载器，Spring Cloud Ribbon是基于 Netflix Ribbon 实现的，是一个用于对 HTTP 请求进行控制的负载均衡&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;在注册中心对 Ribbon 进行注册之后，Ribbon 就可以基于某种负载均衡算***循、随机、加权轮询、加权随机等）自动帮助服务消费者调用接口，开发者也可以根据具体需求自定义 Ribbon 负载均衡&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;。实际开发中 Spring Clooud Ribbon 需要结合 Spring Cloud Eureka 使用，Eureka 提供所有可以调用的服务提供者列表，Ribbon 基于特定的负载均衡&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;从这些服务提供者中选择要调用的具体实例。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;声明式接口调用 Feign&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;Feign 与 Ribbon 一样也是 Netflix 提供的，Feign 是一个声明式、模板化的 Web Service &lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;，简化了开发者编写 Web 服务&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;的操作，开发者可以通过简单的接口和注解来调用 HTTP API，Spring Cloud Feign 整合了 Ribbon 和 Hystrix，具有可插拔、基于注解、负载均衡、服务熔断等一系列功能。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;相比于 Ribbon + RestTemplate 的方式，Feign 可以大大简化代码开发，支持多种注解，包括 Feign 注解、JAX-RS 注解、Spring MVC 注解等。RestTemplate 是 Spring 框架提供的基于 REST 的服务组件，底层是对 HTTP 请求及响应进行了封装，提供了很多访问 REST 服务的方法，可以简化代码开发。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;服务熔断 Hystrix&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;熔断器的作用是在不改变各个微服务调用关系的前提下，针对错误情况进行预先处理。&lt;/p&gt; 
&lt;p&gt;设计原则：服务隔离机制、服务降级机制、熔断机制、提供实时监控和报警功能和提供实时配置修改功能&lt;/p&gt; 
&lt;p&gt;Hystrix 数据监控需要结合 &lt;code&gt;Spring Boot Actuator&lt;/code&gt; 使用，Actuator 提供了对服务的数据监控、数据统计，可以通过 &lt;code&gt;hystirx-stream&lt;/code&gt; 节点获取监控的请求数据，同时提供了可视化监控界面。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;服务配置 Config&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;Spring Cloud Config 通过服务端可以为多个&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;提供配置服务，既可以将配置文件存储在本地，也可以将配置文件存储在远程的 Git 仓库，创建 Config Server，通过它管理所有的配置文件。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;服务跟踪 Zipkin&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;Spring Cloud Zipkin 是一个可以采集并跟踪分布式系统中请求数据的组件，让开发者更直观地监控到请求在各个微服务耗费的时间，Zipkin 包括两部分 Zipkin Server 和 Zipkin Client。&lt;/p&gt; 
&lt;hr/&gt; 
&lt;h2 id=&quot;mysql-15&quot;&gt;MySQL 15&lt;/h2&gt; 
&lt;h3&gt;P1：逻辑架构&lt;/h3&gt; 
&lt;p&gt;第一层是服务器层，主要提供连接处理、授权认证、安全等功能，该层的服务不是 MySQL 独有的，大多数基于网络的 C/S 服务都有类似架构。&lt;/p&gt; 
&lt;p&gt;第二层实现了 MySQL 核心服务功能，包括查询解析、分析、优化、缓存以及日期、时间等所有内置函数，所有跨存储引擎的功能都在这一层实现，例如存储过程、触发器、视图等。&lt;/p&gt; 
&lt;p&gt;第三层是存储引擎层，存储引擎负责 MySQL 中数据的存储和提取。服务器通过API 与存储引擎通信，这些接口屏蔽了不同存储引擎的差异，使得差异对上层查询过程透明。除了会解析外键定义的 InnoDB 外，存储引擎不会解析SQL，不同存储引擎之间也不会相互通信，只是简单响应上层服务器请求。&lt;/p&gt; 
&lt;hr/&gt; 
&lt;h3&gt;P2：锁&lt;/h3&gt; 
&lt;p&gt;当有多个查询需要在同一时刻修改数据时就会产生并发控制的问题，MySQL 在两个层面进行并发控制：服务器层与存储引擎层。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;读写锁&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;在处理并发读或写时，可以通过实现一个由两种类型组成的锁系统来解决问题。这两种类型的锁通常被称为共享锁和排它锁，也叫读锁和写锁。读锁是共享的，或者说相互不阻塞的，多个客户在同一时刻可以同时读取同一个资源而不相互干扰。写锁则是排他的，也就是说一个写锁会阻塞其他的写锁和读锁，只有如此才能确保在给定时间内只有一个用户能执行写入并防止其他用户读取正在写入的同一资源。在实际的数据库系统中，每时每刻都在发生锁定，当某个用户在修改某一部分数据时，MySQL 会通过锁定防止其他用户读取同一数据。写锁比读锁有更高的优先级，一个写锁请求可能会被插入到读锁队列的前面，但是读锁不能插入到写锁前面。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;锁策略&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;一种提高共享资源并发性的方法就是让锁定对象更有选择性，尽量只锁定需要修改的部分数据而不是所有资源，更理想的方式是只对会修改的数据进行精确锁定。任何时刻在给定的资源上，锁定的数据量越少，系统的并发程度就越高，只要不发生冲突即可。&lt;/p&gt; 
&lt;p&gt;锁策略就是在锁的开销和数据安全性之间寻求平衡，这种平衡也会影响性能。大多数商业数据库系统没有提供更多选择，一般都是在表上加行锁，而 MySQL 提供了多种选择，每种MySQL存储引擎都可以实现自己的锁策略和锁粒度。MySQL最重要的两种锁策略是：&lt;/p&gt; 
 
&lt;p&gt;&lt;strong&gt;死锁&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;死锁是指两个或者多个事务在同一资源上相互占用并请求锁定对方占用的资源，从而导致恶性循环的现象。当多个事务试图以不同顺序锁定资源时就可能会产生死锁，多个事务同时锁定同一个资源时也会产生死锁。&lt;/p&gt; 
&lt;p&gt;为了解决死锁问题，数据库系统实现了各种死锁检测和死锁超时机制。越复杂的系统，例如InnoDB 存储引擎，越能检测到死锁的循环依赖，并立即返回一个错误。这种解决方式很有效，否则死锁会导致出现非常慢的查询。还有一种解决方法，就是当查询的时间达到锁等待超时的设定后放弃锁请求，这种方式通常来说不太好。InnoDB 目前处理死锁的方法是将持有最少行级排它锁的事务进行回滚。&lt;/p&gt; 
&lt;p&gt;锁的行为与顺序是和存储引擎相关的，以同样的顺序执行语句，有些存储引擎会产生死锁有些则不会。死锁的产生有双重原因：有些是真正的数据冲突，这种情况很难避免，有些则完全是由于存储引擎的实现方式导致的。&lt;/p&gt; 
&lt;p&gt;死锁发生之后，只有部分或者完全回滚其中一个事务，才能打破死锁。对于事务型系统这是无法避免的，所以应用程序在设计时必须考虑如何处理死锁。大多数情况下只需要重新执行因死锁回滚的事务即可。&lt;/p&gt; 
&lt;hr/&gt; 
&lt;h3&gt;&lt;font&gt;P3：事务&lt;/font&gt;&lt;/h3&gt; 
&lt;p&gt;事务就是一组原子性的 SQL 查询，或者说一个独立的工作单元。如果数据库引擎能够成功地对数据库应用该组查询的全部语句，那么就执行该组查询。如果其中有任何一条语句因为崩溃或其他原因无法执行，那么所有的语句都不会执行。也就是说事务内的语句要么全部执行成功，要么全部执行失败。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;ACID 特性&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;一个运行良好的事务处理系统必须具备 ACID 特性，实现了 ACID 的数据库需要更强的CPU处理能力、更大的内存和磁盘空间。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;&lt;strong&gt;原子性 atomicity&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;一个事务在逻辑上是必须不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说不可能只执行其中的一部分。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;&lt;strong&gt;一致性 consistency&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;数据库总是从一个一致性的状态转换到另一个一致性的状态。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;&lt;strong&gt;隔离性 isolation&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;针对并发事务而言，隔离性就是要隔离并发运行的多个事务之间的相互影响，一般来说一个事务所做的修改在最终提交以前，对其他事务是不可见的。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;&lt;strong&gt;持久性 durability&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;一旦事务提交成功，其修改就会永久保存到数据库中，此时即使系统崩溃，修改的数据也不会丢失。&lt;/p&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;隔离级别&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;在 SQL 标准中定义了四种隔离级别，每一种隔离级别都规定了一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的。较低级别的隔离通常可以执行更高的并发，系统的开销也更低。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;&lt;strong&gt;未提交读 READ UNCOMMITTED&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;在该级别事务中的修改即使没有被提交，对其他事务也是可见的。事务可以读取其他事务修改完但未提交的数据，这种问题称为脏读。这个级别还会导致不可重复读和幻读，从性能上说也没有比其他级别好很多，因此很少使用。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;&lt;strong&gt;提交读 READ COMMITTED&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;大多数数据库系统默认的隔离级别就是提交读，但 MySQL 不是。提交读满足了隔离性的简单定义：一个事务开始时只能&quot;看见&quot;已经提交的事务所做的修改。换句话说，一个事务从开始直到提交之前的任何修改对其他事务都是不可见的。这个级别有时也叫不可重复读，因为两次执行同样的查询可能会得到不同结果。提交读存在不可重复读和幻读的问题。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;&lt;strong&gt;可重复读 REPEATABLE READ&lt;/strong&gt;（MySQL默认的隔离级别）&lt;/p&gt; &lt;p&gt;可重复读解决了不可重复读的问题，该级别保证了在同一个事务中多次读取同样的记录结果是一致的。但可重复读隔离级别还是无法解决幻读的问题，所谓幻读，指的是当某个事务在读取某个范围内的记录时，会产生幻行。InnoDB 存储引擎通过多版本并发控制MVCC 解决幻读的问题。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;&lt;strong&gt;可串行化 SERIALIZABLE&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;该级别是最高的隔离级别，通过强制事务串行执行，避免了幻读的问题。可串行化会在读取的每一行数据上都加锁，可能导致大量的超时和锁争用的问题。实际应用中很少用到这个隔离级别，只有非常需要确保数据一致性且可以接受没有并发的情况下才考虑该级别。&lt;/p&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;MySQL 中的事务&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;MySQL 提供了两种事务型的存储引擎：InnoDB 和 NDB Cluster。&lt;/p&gt; 
&lt;p&gt;MySQL 事务默认采用自动提交模式，如果不是显式地开始一个事务，则每个查询都将被当作一个事务执行提交操作。在当前连接中，可以通过设置 AUTOCOMMIT 变量来启用或禁用自动提交模式。&lt;/p&gt; 
&lt;p&gt;1 或 ON 表示启用，0 或 OFF表示禁用，当禁用自动提交时，所有的查询都是在一个事务中，直到显式地执行 COMMIT 或 ROLLBACK 后该事务才会结束，同时又开始了一个新事务。修改 AUTOCOMMIT 对非事务型表，例如 MyISAM 或内存表不会有任何影响，对这类表来说没有 COMMIT 或 ROLLBACK 的概念，也可以理解为一直处于启用自动提交的模式&lt;/p&gt; 
&lt;p&gt;有一些命令在执行之前会强制执行提交当前的活动事务，例如&lt;code&gt;ALTER TABLE&lt;/code&gt;和&lt;code&gt;LOCK TABLES&lt;/code&gt;等。&lt;/p&gt; 
&lt;p&gt;MySQL能够识别所有的 4个 ANSI 隔离级别，InnoDB 引擎也支持所有隔离级别。&lt;/p&gt; 
&lt;hr/&gt; 
&lt;h3&gt;P4：MVCC 多版本并发控制&lt;/h3&gt; 
&lt;p&gt;可以认为 MVCC 是行级锁的一个变种，但它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只锁定必要的行。&lt;/p&gt; 
&lt;p&gt;MVCC 的实现，是通过保存数据在某个时间点的快照来实现的。也就是说不管需要执行多长时间，每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。&lt;/p&gt; 
&lt;p&gt;不同的存储引擎的 MVCC 实现是不同的，典型的有乐观并发控制和悲观并发控制。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;InnoDB 的 MVCC 实现&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;InnoDB 的MVCC 通过在每行记录后面保存两个隐藏的列来实现，这两个列一个保存了行的创建时间，一个保存行的过期时间间。不过存储的不是实际的时间值而是系统版本号，每开始一个新的事务系统版本号都会自动递增，事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;REPEATABLE READ 级别下 MVCC 的具体实现&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;SELECT：InnoDB 会根据以下两个条件检查每行记录：&lt;/p&gt; 
 
&lt;p&gt;INSERT ：为新插入的每一行保存当前系统版本号作为行版本号。&lt;/p&gt; 
&lt;p&gt;DELETE：为删除的每一行保存当前系统版本号作为行删除标识。&lt;/p&gt; 
&lt;p&gt;UPDATE：为插入的每一行新记录保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。&lt;/p&gt; 
&lt;p&gt;保存这两个额外系统版本号使大多数读操作都可以不用加锁。这样设计使读数据操作简单且高效，并且能保证只会读取到符合标准的行。不足之处是每行记录都需要额外存储空间，需要做更多行检查工作以及一些额外维护工作。&lt;/p&gt; 
&lt;p&gt;MVCC 只能在 &lt;code&gt;READ COMMITTED&lt;/code&gt; 和 &lt;code&gt;REPEATABLE READ&lt;/code&gt; 两个隔离级别下工作，因为 &lt;code&gt;READ UNCOMMITTED&lt;/code&gt; 总是读取最新的数据行，而不是符合当前事务版本的数据行，而 &lt;code&gt;SERIALIZABLE&lt;/code&gt; 则会对所有读取的行都加锁。&lt;/p&gt; 
&lt;hr/&gt; 
&lt;h3&gt;P5：InnoDB 存储引擎&lt;/h3&gt; 
&lt;p&gt;InnoDB 是 MySQL 的默认事务型引擎，它被设计用来处理大量的短期事务。InnoDB 的性能和自动崩溃恢复特性，使得它在非事务型存储需求中也很流行，除非有特别原因否则应该优先考虑 InnoDB 引擎。&lt;/p&gt; 
&lt;p&gt;InnoDB 的数据存储在表空间中，表空间由一系列数据文件组成。MySQL4.1 后 InnoDB 可以将每个表的数据和索引放在单独的文件中。&lt;/p&gt; 
&lt;p&gt;InnoDB 采用 MVCC 来支持高并发，并且实现了四个标准的隔离级别。其默认级别是 &lt;code&gt;REPEATABLE READ&lt;/code&gt;，并且通过间隙锁策略防止幻读，间隙锁使 InnoDB 不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定防止幻行的插入。&lt;/p&gt; 
&lt;p&gt;InnoDB 表是基于聚簇索引建立的，InnoDB 的索引结构和其他存储引擎有很大不同，聚簇索引对主键查询有很高的性能，不过它的二级索引中必须包含主键列，所以如果主键很大的话其他所有索引都会很大，因此如果表上索引较多的话主键应当尽可能小。&lt;/p&gt; 
&lt;p&gt;InnoDB 的存储格式是平***立的，可以将数据和索引文件从一个平台复制到另一个平台。&lt;/p&gt; 
&lt;p&gt;InnoDB 内部做了很多优化，包括从磁盘读取数据时采用的可预测性预读，能够自动在内存中创建加速读操作的自适应哈希索引，以及能够加速插入操作的插入缓冲区等。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;选择合适的存储引擎&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;MySQL5.5 将 InnoDB 作为默认存储引擎，除非需要用到某些 InnoDB 不具备的特性，并且没有其他方法可以代替，否则都应该优先选用InnoDB。&lt;/p&gt; 
&lt;p&gt;如果应用需要事务支持，那么 InnoDB 是目前最稳定并且经过验证的选择。如果不需要事务并且主要是 SELECT 和 INSERT 操作，那么MyISAM 是不错的选择。相对而言，MyISAM 崩溃后发生损坏的概率要比 InnoDB 大很多而且恢复速度也要慢，因此即使不需要事务支持，也可以选择InnoDB。&lt;/p&gt; 
&lt;p&gt;如果可以定期地关闭服务器来执行备份，那么备份的因素可以忽略。反之如果需要在线热备份，那么 InnoDB 就是基本的要求。&lt;/p&gt; 
&lt;hr/&gt; 
&lt;h3&gt;P6：MyISAM 存储引擎&lt;/h3&gt; 
&lt;p&gt;在 MySQL5.1及之前，MyISAM 是默认的存储引擎，MyISAM 提供了大量的特性，包括全文索引、压缩、空间函数等，但不支持事务和行锁，最大的缺陷就是崩溃后无法安全恢复。对于只读的数据或者表比较小、可以忍受修复操作的情况仍然可以使用 MyISAM。&lt;/p&gt; 
&lt;p&gt;MyISAM 将表存储在数据文件和索引文件中，分别以 &lt;code&gt;.MYD&lt;/code&gt; 和 &lt;code&gt;.MYI&lt;/code&gt; 作为扩展名。MyISAM 表可以包含动态或者静态行，MySQL 会根据表的定义决定行格式。MyISAM 表可以存储的行记录数一般受限于可用磁盘空间或者操作系统中单个文件的最大尺寸。&lt;/p&gt; 
&lt;p&gt;MyISAM 对整张表进行加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但是在表有读取查询的同时，也支持并发往表中插入新的记录。&lt;/p&gt; 
&lt;p&gt;对于MyISAM 表，MySQL 可以手动或自动执行检查和修复操作，这里的修复和事务恢复以及崩溃恢复的概念不同。执行表的修复可能导致一些数据丢失，而且修复操作很慢。&lt;/p&gt; 
&lt;p&gt;对于 MyISAM 表，即使是 BLOB 和 TEXT 等长字段，也可以基于其前 500 个字符创建索引。MyISAM 也支持全文索引，这是一种基于分词创建的索引，可以支持复杂的查询。&lt;/p&gt; 
&lt;p&gt;创建 MyISAM 表时如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时不会立刻将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理缓冲区或关闭表的时候才会将对应的索引库写入磁盘。这种方式可以极大提升写性能，但在数据库或主机崩溃时会造成索引损坏，需要执行修复。延迟更新索引键的特性可以在全局设置也可以单个表设置。&lt;/p&gt; 
&lt;p&gt;MyISAM 设计简单，数据以紧密格式存储，所以在某些场景下性能很好。MyISAM 最典型的性能问题还是表锁问题，如果所有的查询长期处于 Locked 状态，那么原因毫无疑问就是表锁。&lt;/p&gt; 
&lt;h3&gt;P7：Memory 存储引擎&lt;/h3&gt; 
&lt;p&gt;如果需要快速访问数据，并且这些数据不会被修改，重启以后丢失也没有关系，那么使用 Memory 表是非常有用的。Memory 表至少要比 MyISAM 表快一个数量级，因为所有的数据都保存在内存中，不需要进行磁盘 IO，Memory 表的结构在重启以后还会保留，但数据会丢失。&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;Memory 表适合的场景：查找或者映射表、缓存周期性聚合数据的结果、保存&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90&quot; target=&quot;_blank&quot;&gt;数据分析&lt;/a&gt;中产生的中间数据。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;Memory 表支持哈希索引，因此查找速度极快。虽然速度很快但还是无法取代传统的基于磁盘的表，Memory 表使用表级锁，因此并发写入的性能较低。它不支持 BLOB 和 TEXT 类型的列，并且每行的长度是固定的，所以即使指定了 VARCHAR 列，实际存储时也会转换成CHAR，这可能导致部分内存的浪费。&lt;/p&gt; 
&lt;p&gt;如果 MySQL 在执行查询的过程中需要使用临时表来保持中间结果，内部使用的临时表就是 Memory 表。如果中间结果太大超出了Memory 表的限制，或者含有 BLOB 或 TEXT 字段，临时表会转换成 MyISAM 表。&lt;/p&gt; 
&lt;hr/&gt; 
&lt;h3&gt;P8：数据类型&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;整数类型&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;如果存储整数可以使用这几种整数类型：TINYINT、SMALLINT、MEDIUMINT、INT，BIGINT，它们分别使用8、16、24、32、64 位存储空间。&lt;/p&gt; 
&lt;p&gt;整数类型有可选的 UNSIGNED 属性，表示不允许负值，可以使整数的上限提高一倍。有符号和无符号类型使用相同的存储空间并具有相同的性能，可以根据实际情况选择合适的类型。&lt;/p&gt; 
&lt;p&gt;MySQL 可以为整数类型指定宽度，例如 INT(11)，这对大多数应用没有意义，不会限制值的范围，只是规定了 MySQL 的交互工具显示字符的个数，对于存储和计算来说 INT(1) 和 INT(11) 是相同的。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;实数类型&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;实数是带有小数部分的数字，但它们不只是为了存储小数，也可以使用 DECIMAL 存储比 BIGINT 还大的整数。MySQL既支持精确类型，也支持不精确类型。&lt;/p&gt; 
&lt;p&gt;FLOAT 和 DOUBLE 支持使用标准的浮点运算进行近似运算，DECIMAL 用于存储精确的小数。&lt;/p&gt; 
&lt;p&gt;浮点类型在存储同样范围的值时，通常比 DECIMAL 使用更少的空间。FLOAT 使用 4 字节存储，DOUBLE 占用8字节，MySQL 内部使用DOUBLE 作为内部浮点计算的类型。&lt;/p&gt; 
&lt;p&gt;因为需要额外空间和计算开销，所以应当尽量只在对小数进行精确计算时才使用 DECIMAL。在数据量较大时可以考虑 BIGINT 代替DECIMAL，将需要存储的货币单位根据小数的位数乘以相应的倍数即可。假设要存储的数据精确到万分之一分，则可以把所有金额乘以一百万将结果存储在 BIGINT 中，这样可以同时避免浮点存储计算不精确和 DECIMAL 精确计算代价高的问题。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;VARCHAR&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;VARCHAR 用于存储可变字符串，是最常见的字符串数据类型。它比定长字符串更节省空间，因为它仅使用必要的空间。VARCHAR 需要 1或 2 个额外字节记录字符串长度，如果列的最大长度不大于 255 字节则只需要1 字节。VARCHAR 不会删除末尾空格。&lt;/p&gt; 
&lt;p&gt;VARCHAR 节省了存储空间，但由于行是变长的，在 UPDATE 时可能使行变得比原来更长，这就导致需要做额外的工作。如果一个行占用的空间增长并且页内没有更多的空间可以存储，这种情况下不同存储引擎处理不同，InnoDB 会分裂页而 MyISAM 会将行拆分成不同片。&lt;/p&gt; 
&lt;p&gt;适用场景：字符串列的最大长度比平均长度大很多、列的更新很少、使用了 UTF8 这种复杂字符集，每个字符都使用不同的字节数存储。&lt;/p&gt; 
&lt;p&gt;InnoDB 可以把过长的 VARCHAR 存储为 BLOB。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;CHAR&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;CHAR 是定长的，根据定义的字符串长度分配足够的空间。CHAR 会删除末尾空格。&lt;/p&gt; 
&lt;p&gt;CHAR 适合存储很短的字符串，或所有值都接近同一个长度，例如存储密码的 MD5 值。对于经常变更的数据，CHAR 也比 VARCHAR更好，因为定长的 CHAR 不容易产生碎片。对于非常短的列，CHAR 在存储空间上也更有效率，例如用 CHAR 来存储只有 Y 和 N 的值只需要一个字节，但是 VARCHAR 需要两个字节，因为还有一个记录长度的额外字节。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;BLOB 和 TEXT 类型&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;BLOB 和TEXT 都是为了存储大数据而设计的字符串数据类型，分别采用二进制和字符串方式存储。MySQL会把每个 BLOB 和 TEXT 值当作一个独立的对象处理，存储引擎在存储时通常会做特殊处理。当值太大时，InnoDB 会使用专门的外部存储区来进行存储。BLOB 和TEXT 仅有的不同是 BLOB 存储的是二进制数据，没有&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;规则或字符集，而 TEXT 有字符集和&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;规则。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;MySQL 对 BLOB 和TEXT 列进行&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;与其他类型不同：它只对每个列最前 &lt;/span&gt;&lt;code&gt;max_sort_length&lt;/code&gt;&lt;span&gt; 字节而不是整个字符串做&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;，如果只需要&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;前面一小部分字符，则可以减小 &lt;/span&gt;&lt;code&gt;max_sort_length&lt;/code&gt;&lt;span&gt; 的配置。MySQL 不能将 BLOB 和 TEXT 列全部长度的字符串进行索引，也不能使用这些索引消除&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;DATETIME&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;这个类型能保存大范围的值，从 1001 年到 9999 年，精度为秒。它把日期和时间封装到了一个整数中，与时区无关，使用 8 字节的存储空间。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;TIMESTAMP&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;它和 UNIX 时间戳相同。TIMESTAMP 只使用 4 字节的存储空间，因此它的范围比DATETIME 小得多，只能表示1970年到2038年，并且依赖于时区。通常应该选择 TIMESTAMP，因为它比 DATETIME 空间效率更高。&lt;/p&gt; 
&lt;hr/&gt; 
&lt;h3&gt;P9：索引的分类&lt;/h3&gt; 
&lt;p&gt;索引在也叫做键，是存储引擎用于快速找到记录的一种数据结构。索引对于良好的性能很关键，尤其是当表中数据量越来越大时，索引对性能的影响愈发重要。在数据量较小且负载较低时，不恰当的索引对性能的影响可能还不明显，但数据量逐渐增大时，性能会急剧下降。&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;索引大大减少了服务器需要扫描的数据量、可以帮助服务器避免&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;和临时表、可以将随机 IO 变成顺序 IO。但索引并不总是最好的工具，对于非常小的表，大部分情况下会采用全表扫描。对于中到大型的表，索引就非常有效。但对于特大型的表，建立和使用索引的代价也随之增长，这种情况下应该使用分区技术。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;在MySQL中，首先在索引中找到对应的值，然后根据匹配的索引记录找到对应的数据行。索引可以包括一个或多个列的值，如果索引包含多个列，那么列的顺序也十分重要，因为 MySQL 只能高效地使用索引的最左前缀列。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;B-Tree 索引&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;大多数 MySQL 引擎都支持这种索引，使用术语 B-Tree 是因为 MySQL 在 CREATE TABLE 和其他语句中也使用该关键字。不过底层的存储引擎可能使用不同的存储结构，例如 NDB 集群实际使用 T-Tree，而 InnoDB 则使用 B+Tree。&lt;/p&gt; 
&lt;p&gt;存储引擎以不同方式使用 B-Tree 索引，性能也不同。例如 MyISAM 使用前缀压缩技术使得索引更小，但 InnoDB 则按照原数据格式进行存储。再例如 MyISAM 索引通过数据的物理位置引用被索引的行，而 InnoDB 则根据主键引用被索引的行。&lt;/p&gt; 
&lt;p&gt;B-Tree 通常意味着所有的值都是按顺序存储的，并且每个叶子页到根的距离相同。B-Tree 索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索。根节点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下层查找。通过比较节点页的值和要查找的值可以找到合适的指针进入下层子节点，这些指针实际上定义了子节点页中值的上限和下限。最终存储引擎要么找到对应的值，要么该记录不存在。叶子节点的指针指向的是被索引的数据，而不是其他的节点页。&lt;/p&gt; 
&lt;p&gt;B-Tree索引适用于全键值、键值范围或键前缀查找，其中键前缀查找只适用于最左前缀查找。索引对如下类型的查询有效：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;全值匹配：全值匹配指的是和索引中的所有列进行匹配。 &lt;/li&gt;
 &lt;li&gt;匹配最左前缀：只使用索引的第一列。 &lt;/li&gt;
 &lt;li&gt;匹配列前缀：只匹配某一列的值的开头部分。 &lt;/li&gt;
 &lt;li&gt;匹配范围值：查找某两个值之间的范围。 &lt;/li&gt;
 &lt;li&gt;精确匹配某一列并范围匹配另一列：有一列全匹配而另一列范围匹配。 &lt;/li&gt;
 &lt;li&gt;只访问索引的查询：B-Tree 通常可以支持只访问索引的查询，即查询只需要访问索引而无需访问数据行。 &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;&lt;span&gt;因为索引树中的节点有序，所以除了按值查找之外索引还可以用于查询中的 ORDER BY 操作。一般如果 B-Tree 可以按照某种方式查找到值，那么也可以按照这种方式&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;B-Tree索引的限制：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;如果不是按照索引的最左列开始查找，则无法使用索引。 &lt;/li&gt;
 &lt;li&gt;不能跳过索引中的列，例如索引为 (id,name,sex)，不能只使用 id 和 sex 而跳过 name。 &lt;/li&gt;
 &lt;li&gt;如果查询中有某个列的范围查询，则其右边的所有列都无法使用索引。 &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;哈希索引&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;哈希索引基于&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%93%88%E5%B8%8C%E8%A1%A8&quot; target=&quot;_blank&quot;&gt;哈希表&lt;/a&gt;实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希码是一个较小的值，并且不同键值的行计算出的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%93%88%E5%B8%8C%E8%A1%A8&quot; target=&quot;_blank&quot;&gt;哈希表&lt;/a&gt;中保存指向每个数据行的指针。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;只有 Memory 引擎显式支持哈希索引，这也是 Memory 引擎的默认索引类型。&lt;/p&gt; 
&lt;p&gt;因为索引自身只需存储对应的哈希值，所以索引的结构十分紧凑，这让哈希索引的速度非常快，但它也有一些限制：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;哈希索引只包含哈希值和行指针而不存储字段值，所以不能使用索引中的值来避免读取行。 &lt;/li&gt;
 &lt;li&gt;&lt;span&gt;哈希索引数据并不是按照索引值顺序存储的，因此无法用于&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;。 &lt;/span&gt;&lt;/li&gt;
 &lt;li&gt;哈希索引不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。例如在数据列(a,b)上建立哈希索引，如果查询的列只有a就无法使用该索引。 &lt;/li&gt;
 &lt;li&gt;哈希索引只支持等值比较查询，不支持任何范围查询。 &lt;/li&gt;
 &lt;li&gt;&lt;span&gt;访问哈希索引的数据非常快，除非有很多哈希冲突。当出现哈希冲突时，存储引擎必须遍历&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8&quot; target=&quot;_blank&quot;&gt;链表&lt;/a&gt;中所有的行指针，逐行进行比较直到找到所有符合条件的行。 &lt;/span&gt;&lt;/li&gt;
 &lt;li&gt;如果哈希冲突很高的话，索引维护的代价也会很高。 &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;自适应哈希索引是 InnoDB 引擎的一个特殊功能，当它注意到某些索引值被使用的非常频繁时，会在内存中基于 B-Tree 索引之上再创键一个哈希索引，这样就让 B-Tree 索引也具有哈希索引的一些优点，比如快速哈希查找。这是一个完全自动的内部行为，用户无法控制或配置，但如果有必要可以关闭该功能。&lt;/p&gt; 
&lt;p&gt;如果存储引擎不支持哈希索引，可以创建自定义哈希索引，在 B-Tree基础 上创建一个伪哈希索引，它使用哈希值而不是键本身进行索引查找，需要在查询的 WHERE 子句中手动指定哈希函数。当数据表非常大时，CRC32 会出现大量的哈希冲突，可以考虑自己实现 64 位哈希函数，或者使用 MD5 函数返回值的一部分作为自定义哈希函数。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;空间索引&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;MyISAM 表支持空间索引，可以用作地理数据存储。和 B-Tree 索引不同，这类索引无需前缀查询。空间索引会从所有维度来索引数据，查询时可以有效地使用任意维度来组合查询。必须使用 MySQL 的 GIS 即地理信息系统的相关函数来维护数据，但 MySQL 对 GIS 的支持并不完善，因此大部分人都不会使用这个特性。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;全文索引&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;通过数值比较、范围过滤等就可以完成绝大多数需要的查询，但如果希望通过关键字的匹配进行查询过滤，那么就需要基于相似度的查询，而不是精确的数值比较，全文索引就是为这种场景设计的。全文索引有自己独特的语法，没有索引也可以工作，如果有索引效率会更高。&lt;/p&gt; 
&lt;p&gt;全文索引可以支持各种字符内容的搜索，包括 CHAR、VARCHAR 和 TEXT 类型，也支持自然语言搜索和布尔搜索。在 MySQL 中全文索引有很多限制，例如表锁对性能的影响、数据文件的崩溃恢复等，这使得 MyISAM 的全文索引对很多应用场景并不合适。MyISAM 的全文索引作用对象是一个&quot;全文集合&quot;，可能是某个数据表的一列，也可能是多个列。具体的对某一条记录，MySQL 会将需要索引的列全部拼接成一个字符串然后进行索引。&lt;/p&gt; 
&lt;p&gt;MyISAM 的全文索引是一种特殊的 B-Tree 索引，一共有两层。第一层是所有关键字，然后对于每一个关键字的第二层，包含的是一组相关的&quot;文档指针&quot;。全文索引不会索引文档对象中的所有词语，它会根据规则过滤掉一些词语，例如停用词列表中的词都不会被索引。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;聚簇索引&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。InnoDB 的聚簇索引实际上在同一个结构中保存了 B-Tree 索引和数据行。当表有聚餐索引时，它的行数据实际上存放在索引的叶子页中，因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。&lt;/p&gt; 
&lt;p&gt;优点：① 可以把相关数据保存在一起，例如实现电子邮箱时可以根据用户 ID 聚集数据，这样只需要从磁盘读取少数数据页就能获取某个用户的全部邮件，如果没有使用聚簇索引，每封邮件可能都导致一次磁盘 IO。② 数据访问更快，聚簇索引将索引和数据保存在同一个 B-Tree 中，因此获取数据比非聚簇索引要更快。③ 使用覆盖索引扫描的查询可以直接使用页节点中的主键值。&lt;/p&gt; 
&lt;p&gt;缺点：① 聚簇索引最大限度提高了 IO 密集型应用的性能，如果数据全部在内存中将会失去优势。② 插入速度验证依赖于插入顺序，按照主键的顺序插入是加载数据到 InnoDB 引擎最快的方式。③ 更新聚簇索引列的代价很高，因为会强制每个被更新的行移动到新位置。④ 基于聚簇索引的表插入新行或主键被更新导致行移动时，可能导致页分裂，表会占用更多磁盘空间。④ 当行稀疏或由于页分裂导致数据存储不连续时，全表扫描可能很慢。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;覆盖索引&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;覆盖索引指一个索引包含或覆盖了所有需要查询的字段的值，不再需要根据索引回表查询数据。覆盖索引必须要存储索引列的值，因此 MySQL 只能使用 B-Tree 索引做覆盖索引。&lt;/p&gt; 
&lt;p&gt;优点：① 索引条目通常远小于数据行大小，可以极大减少数据访问量。② 因为索引按照列值顺序存储，所以对于 IO 密集型防伪查询回避随机从磁盘读取每一行数据的 IO 少得多。③ 由于 InnoDB 使用聚簇索引，覆盖索引对 InnoDB 很有帮助。InnoDB 的二级索引在叶子节点保存了行的主键值，如果二级主键能覆盖查询那么可以避免对主键索引的二次查询。&lt;/p&gt; 
&lt;hr/&gt; 
&lt;h3&gt;&lt;font&gt;P10：索引使用原则&lt;/font&gt;&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;建立索引&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;对查询频次较高，且数据量比较大的表建立索引。索引字段的选择，最佳候选列应当从 WHERE 子句的条件中提取，如果 WHERE 子句中的组合比较多，那么应当挑选最常用、过滤效果最好的列的组合。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;使用前缀索引&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;索引列开始的部分字符，索引创建后也是使用硬盘来存储的，因此短索引可以提升索引访问的 IO 效率。对于 BLOB、TEXT 或很长的 VARCHAR 列必须使用前缀索引，MySQL 不允许索引这些列的完整长度。前缀索引是一种能使索引更小更快的有效方法，但缺点是 MySQL 无法使用前缀索引做 ORDER BY 和 GROUP BY，也无法使用前缀索引做覆盖扫描。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;选择合适的索引顺序&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;当不需要考虑&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;和分组时，将选择性最高的列放在前面。索引的选择性是指不重复的索引值和数据表的记录总数之比，索引的选择性越高则查询效率越高，唯一索引的选择性是 1，因此也可以使用唯一索引提升查询效率。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;删除无用索引&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;MySQL 允许在相同列上创建多个索引，重复的索引需要单独维护，并且优化器在优化查询时也需要逐个考虑，这会影响性能。重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引，应该避免创建重复索引。如果创建了索引 (A,B) 再创建索引 (A) 就是冗余索引，因为这只是前一个索引的前缀索引，对于 B-Tree 索引来说是冗余的。解决重复索引和冗余索引的方法就是删除这些索引。除了重复索引和冗余索引，可能还会有一些服务器永远不用的索引，也应该考虑删除。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;减少碎片&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;B-Tree 索引可能会碎片化，碎片化的索引可能会以很差或无序的方式存储在磁盘上，这会降低查询的效率。表的数据存储也可能碎片化，包括行碎片、行间碎片、剩余空间碎片，对于 MyISAM 这三类碎片化都有可能发生，对于 InnoDB 不会出现短小的行碎片，它会移动短小的行重写到一个片段中。可以通过执行 OPTIMIZE TABLE 或者导出再导入的方式重新整理数据，对于 MyISAM 可以通过&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;重建索引消除碎片。InnoDB 可以通过先删除再重新创建索引的方式消除索引碎片。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;索引失效情况&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;如果索引列出现了隐式类型转换，则 MySQL 不会使用索引。常见的情况是在 SQL 的 WHERE 条件中字段类型为字符串，其值为数值，如果没有加引号那么 MySQL 不会使用索引。&lt;/p&gt; 
&lt;p&gt;如果 WHERE 条件中含有 OR，除非 OR 前使用了索引列而 OR 之后是非索引列，索引会失效。&lt;/p&gt; 
&lt;p&gt;MySQL 不能在索引中执行 LIKE 操作，这是底层存储引擎 API 的限制，最左匹配的 LIKE 比较会被转换为简单的比较操作，但如果是以通配符开头的 LIKE 查询，存储引擎就无法做笔记。这种情况下 MySQL 服务器只能提取数据行的值而不是索引值来做比较。&lt;/p&gt; 
&lt;p&gt;如果查询中的列不是独立的，则 MySQL 不会使用索引。独立的列是指索引列不能是表达式的一部分，也不能是函数的参数。&lt;/p&gt; 
&lt;p&gt;对于多个范围条件查询，MySQL 无法使用第一个范围列后面的其他索引列，对于多个等值查询则没有这种限制。&lt;/p&gt; 
&lt;p&gt;如果 MySQL 判断全表扫描比使用索引查询更快，则不会使用索引。&lt;/p&gt; 
&lt;hr/&gt; 
&lt;h3&gt;P11：优化数据类型&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;更小的通常更好&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;一般情况下尽量使用可以正确存储数据的最小数据类型，更小的数据类型通常也更快，因为它们占用更少的磁盘、内存和 CPU 缓存。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;尽可能简单&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;简单数据类型的操作通常需要更少的 CPU 周期，例如整数比字符操作代价更低，因为字符集和校对规则使字符相比整形更复杂。应该使用 MySQL 的内建类型 date、time 和 datetime 而不是字符串来存储日期和时间，另一点是应该使用整形存储 IP 地址。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;尽量避免 NULL&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;通常情况下最好指定列为 NOT NULL，除非需要存储 NULL值。因为如果查询中包含可为 NULL 的列对 MySQL 来说更难优化，可为 NULL 的列使索引、索引统计和值比较都更复杂，并且会使用更多存储空间。当可为 NULL 的列被索引时，每个索引记录需要一个额外字节，在MyISAM 中还可能导致固定大小的索引变成可变大小的索引。&lt;/p&gt; 
&lt;p&gt;通常把可为 NULL 的列设置为 NOT NULL 带来的性能提升较小，因此调优时没必要首先查找并修改这种情况。但如果计划在列上建索引，就应该尽量避免设计成可为 NULL 的列。&lt;/p&gt; 
&lt;p&gt;在为列选择数据类型时，第一步需要确定合适的大类型：数字、字符串、时间等。下一步是选择具体类型，很多 MySQL 数据类型可以存储相同类型的数据，只是存储的长度和范围不一样，允许的精度不同或需要的物理空间不同。&lt;/p&gt; 
&lt;hr/&gt; 
&lt;h3&gt;P12：优化查询概述&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;优化数据访问&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;如果把查询看作一个任务，那么它由一系列子任务组成，每个子任务都会消耗一定时间。如果要优化查询，要么消除一些子任务，要么减少子任务的执行次数。查询性能低下最基本的原因是访问的数据太多，大部分性能低下的查询都可以通过减少访问的数据量进行优化。可以通过以下两个步骤分析。&lt;/p&gt; 
&lt;p&gt;是否向数据库请求了不需要的数据：有些查询会请求超过实际需要的数据，然后这些多余的数据会被应用程序丢弃，这会给 MySQL 服务器造成额外负担并增加网络开销，另外也会消耗应用服务器的 CPU 和内存资源。例如多表关联时返回全部列，取出全部列会让优化器无法完成索引覆盖扫描这类优化，还会为服务器带来额外的 IO、内存和 CPU 的消耗，因此使用 SELECT * 时需要仔细考虑是否真的需要返回全部列。再例如总是重复查询相同的数据，比较好的解决方案是初次查询时将数据缓存起来，需要的时候从缓存中取出。&lt;/p&gt; 
&lt;p&gt;MySQL 是否在扫描额外的记录：在确定查询只返回需要的数据后，应该看看查询为了返回结果是否扫描了过多的数据，最简单的三个衡量指标时响应时间、扫描的行数和返回的行数。如果发现查询需要扫描大量数据但只返回少数的行，可以使用以下手动优化：① 使用覆盖索引扫描，把所有需要用的列都放到索引中，这样存储引擎无需回表查询对应行就可以返回结果。② 改变库表结构。 ③ 重写这个复杂的查询，让 MySQL 优化器能够以更优化的方式执行这个查询。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;重构查询方式&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;在优化有问题的查询时，目标应该是找到一个更优的方法获取实际需要的结果，而不一定总是需要从 MySQL 获取一模一样的结果集。&lt;/p&gt; 
&lt;p&gt;切分查询：有时候对于一个大查询可以将其切分成小查询，每个查询功能完全一样，只完成一小部分，每次只返回一小部分查询结果。例如删除旧数据，定期清除大量数据时，如果用一个大的语句一次性完成的话可能需要一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。将一个大的 DELETE 语句切分成多个较小的查询可以尽可能小地影响 MySQL 的性能，同时还可以减少MySQL 复制的延迟。&lt;/p&gt; 
&lt;p&gt;分解关联查询：很多高性能应用都会对关联查询进行分解，可以对每一个表进行单表查询，然后将结果在应用程序中进行关联。分解关联查询可以让缓存的效率更高、减少锁的竞争、提升查询效率、还可以减少冗余记录的查询。&lt;/p&gt; 
&lt;hr/&gt; 
&lt;h3&gt;P13：查询执行流程&lt;/h3&gt; 
&lt;p&gt;&lt;span&gt;简单来说分为五步：① &lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;发送一条查询给服务器。② 服务器先检查查询缓存，如果命中了缓存则立刻返回存储在缓存中的结果，否则进入下一阶段。③ 服务器端进行 SQL 解析、预处理，再由优化器生成对应的执行计划。④ MySQL 根据优化器生成的执行计划，调用存储引擎的 API 来执行查询。⑤ 将结果返回给&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;。 &lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;查询缓存&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;在解析一个查询语句之前，如果查询缓存是打开的，那么 MySQL 会优先检查这个查询是否命中查询缓存中的数据。这个检查是通过一个对大小写敏感的哈希查找实现的。查询和缓存中的查询即使只有一个字节不同，也不会匹配缓存结果，这种情况下会进行下一个阶段的处理。如果当前的查询恰好命中了查询缓存，那么在返回查询结果之前 MySQL 会检查一次用户权限。如果权限没有问题，MySQL 会跳过其他阶段，直接从缓冲中拿到结果并返回给&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;，这种情况下查询不会被解析，不用生成执行计划，不会被执行。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;查询优化处理&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;该阶段包括多个子阶段：解析 SQL、预处理、优化 SQL 执行计划。首先 MySQL 通过关键字将 SQL 语句进行解析，并生成一颗对应的解析树，MySQL 解析器将使用 MySQL 语法规则验证和解析查询。例如它将验证是否使用了错误的关键字，或者使用关键字的顺序是否正确等。预处理器则根据一些 MySQL 规则进一步检查解析树是否合法，例如检查数据表和数据列是否存在，还会解析名字和别名看它们是否有歧义。下一步预处理器会验证权限，这一步通常很快，除非服务器上有非常多的权限配置。&lt;/p&gt; 
&lt;p&gt;语法树被认为合法后，查询优化器将其转成执行计划。一条查询可以有多种查询方式，最后都返回相同的结果，优化器的作用就是找到这其中最好的执行计划。MySQL 使用基于成本的优化器，它将尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最小的一个。优化策略可以简单分为两种，一种是静态优化，可以直接对解析树分析并完成优化，不依赖于特别的数值，可以认为是一种编译时优化。另一种是动态优化，和查询的上下文有关，每次查询时都需要重新评估。&lt;/p&gt; 
&lt;p&gt;MySQL 可以处理的优化类型包括：重新定义表的关联顺序、将外连接转化成内连接、使用等价变换规则、优化 COUNT() 和 MIN() 以及 MAX() 函数、预估并转为常数表达式、覆盖索引扫描、子查询优化等。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;查询执行引擎&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;在解析和优化阶段，MySQL 将生成查询对应的执行计划，MySQL 的查询执行引擎则根据这个计划来完成整个查询。执行计划是一个数据结构，而不是其他关系型数据库那样会生成对应的字节码。查询执行阶段并不复杂，MySQL 只是简单的根据执行计划给出的指令逐步执行，再根据执行计划执行的过程中，有大量操作需要通过调用存储引擎实现的接口来完成。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;&lt;span&gt;返回结果给&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;查询执行的最后一个阶段是将结果返回给&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;，即使查询不需要返回结果集，MySQL 仍然会返回这个查询的一些信息，如该查询影响到的行数。如果查询可以被缓存，那么 MySQL 会在这个阶段将结果存放到查询缓冲中。MySQL 将结果集返回&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;是一个增量、逐步返回的过程，这样做的好处是服务器无需存储太多的结果，减少内存消耗，也可以让&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;第一时间获得响应结果。结果集中的每一行给都会以一个满足 MySQL &lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;/服务器通信协议的包发送，再通过 TCP 协议进行传输，在 TCP 传输过程中可能对包进行缓存然后批量传输。&lt;/span&gt;&lt;/p&gt; 
&lt;hr/&gt; 
&lt;h3&gt;&lt;font&gt;P14：优化 SQL&lt;/font&gt;&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;优化 COUNT 查询&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;COUNT 是一个特殊的函数，它可以统计某个列值的数量，在统计列值时要求列值是非空的，不会统计 NULL 值。如果在 COUNT 中指定了列或列的表达式，则统计的就是这个表达式有值的结果数，而不是 NULL。&lt;/p&gt; 
&lt;p&gt;COUNT 的另一个作用是统计结果集的行数，当 MySQL 确定括号内的表达式不可能为 NULL 时，实际上就是在统计行数。当使用 COUNT(&lt;em&gt;) 时，\&lt;/em&gt; 不会扩展成所有列，它会忽略所有的列而直接统计所有的行数。&lt;/p&gt; 
&lt;p&gt;某些业务场景并不要求完全精确的 COUNT 值，此时可以使用近似值来代替，EXPLAIN 出来的优化器估算的行数就是一个不错的近似值，因为执行 EXPLAIN 并不需要真正地执行查询。&lt;/p&gt; 
&lt;p&gt;通常来说 COUNT 都需要扫描大量的行才能获取精确的结果，因此很难优化。在 MySQL 层还能做的就只有覆盖扫描了，如果还不够就需要修改应用的架构，可以增加汇总表或者外部缓存系统。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;优化关联查询&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;确保 ON 或 USING 子句中的列上有索引，在创建索引时就要考虑到关联的顺序。&lt;/p&gt; 
&lt;p&gt;确保任何 GROUP BY 和 ORDER BY 的表达式只涉及到一个表中的列，这样 MySQL 才有可能使用索引来优化这个过程。&lt;/p&gt; 
&lt;p&gt;在 MySQL 5.5 及以下版本尽量避免子查询，可以用关联查询代替，因为执行器会先执行外部的 SQL 再执行内部的 SQL。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;优化 GROUP BY&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;如果没有通过 ORDER BY 子句显式指定要&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;的列，当查询使用 GROUP BY 子句的时候，结果***自动按照分组的字段进行&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;，如果不关心结果集的顺序，可以使用 ORDER BY NULL 禁止&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;优化 LIMIT 分页&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;在偏移量非常大的时候，需要查询很多条数据再舍弃，这样的代价非常高。要优化这种查询，要么是在页面中限制分页的数量，要么是优化大偏移量的性能。最简单的办法是尽可能地使用覆盖索引扫描，而不是查询所有的列，然后根据需要做一次关联操作再返回所需的列。&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;还有一种方法是从上一次取数据的位置开始扫描，这样就可以避免使用 OFFSET。其他优化方法还包括使用预先计算的汇总表，或者关联到一个冗余表，冗余表只包含主键列和需要做&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;的数据列。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;优化 UNION 查询&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;MySQL 通过创建并填充临时表的方式来执行 UNION 查询，除非确实需要服务器消除重复的行，否则一定要使用 UNION ALL，如果没有 ALL 关键字，MySQL 会给临时表加上 DISTINCT 选项，这会导致对整个临时表的数据做唯一性检查，这样做的代价非常高。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;使用用户自定义变量&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;在查询中混合使用过程化和关系化逻辑的时候，自定义变量可能会非常有用。用户自定义变量是一个用来存储内容的临时容器，在连接 MySQL 的整个过程中都存在，可以在任何可以使用表达式的地方使用自定义变量。例如可以使用变量来避免重复查询刚刚更新过的数据、统计更新和插入的数量等。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;优化 INSERT&lt;/strong&gt; &lt;/p&gt; 
&lt;p&gt;&lt;span&gt;需要对一张表插入很多行数据时，应该尽量使用一次性插入多个值的 INSERT 语句，这种方式将缩减&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;与数据库之间的连接、关闭等消耗，效率比多条插入单个值的 INSERT 语句高。也可以关闭事务的自动提交，在插入完数据后提交。当插入的数据是按主键的顺序插入时，效率更高。&lt;/span&gt;&lt;/p&gt; 
&lt;hr/&gt; 
&lt;h3&gt;P15：复制&lt;/h3&gt; 
&lt;p&gt;复制解决的基本问题是让一台服务器的数据与其他服务器保持同步，一台主库的数据可以同步到多台备库上，备库本身也可以被配置成另外一台服务器的主库。主库和备库之间可以有多种不同的组合方式。&lt;/p&gt; 
&lt;p&gt;MySQL 支持两种复制方式：基于行的复制和基于语句的复制，基于语句的复制也称为逻辑复制，从 MySQL 3.23 版本就已存在，基于行的复制方式在 5.1 版本才被加进来。这两种方式都是通过在主库上记录二进制日志、在备库重放日志的方式来实现异步的数据复制。因此同一时刻备库的数据可能与主库存在不一致，并且无法包装主备之间的延迟。&lt;/p&gt; 
&lt;p&gt;MySQL 复制大部分是向后兼容的，新版本的服务器可以作为老版本服务器的备库，但是老版本不能作为新版本服务器的备库，因为它可能无法解析新版本所用的新特性或语法，另外所使用的二进制文件格式也可能不同。&lt;/p&gt; 
&lt;p&gt;复制解决的问题：数据分布、负载均衡、备份、高可用性和故障切换、MySQL 升级测试。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;复制步骤&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;概述：① 在主库上把数据更改记录到二进制日志中。② 备库将主库的日志复制到自己的中继日志中。 ③ 备库读取中继日志中的事件，将其重放到备库数据之上。&lt;/p&gt; 
&lt;p&gt;第一步是在主库上记录二进制日志，每次准备提交事务完成数据更新前，主库将数据更新的事件记录到二进制日志中。MySQL 会按事务提交的顺序而非每条语句的执行顺序来记录二进制日志，在记录二进制日志后，主库会告诉存储引擎可以提交事务了。&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;下一步，备库将主库的二进制日志复制到其本地的中继日志中。备库首先会启动一个工作的 IO 线程，IO 线程跟主库建立一个普通的&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;连接，然后在主库上启动一个特殊的二进制转储线程，这个线程会读取主库上二进制日志中的事件。它不会对事件进行轮询。如果该线程追赶上了主库将进入睡眠状态，直到主库发送信号量通知其有新的事件产生时才会被唤醒，备库 IO 线程会将接收到的事件记录到中继日志中。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;备库的 SQL 线程执行最后一步，该线程从中继日志中读取事件并在备库执行，从而实现备库数据的更新。当 SQL 线程追赶上 IO 线程时，中继日志通常已经在系统缓存中，所以中继日志的开销很低。SQL 线程执行的时间也可以通过配置选项来决定是否写入其自己的二进制日志中。&lt;/p&gt; 
&lt;p&gt;这种复制架构实现了获取事件和重放事件的解耦，允许这两个过程异步进行，也就是说 IO 线程能够独立于 SQL 线程工作。但这种架构也限制了复制的过程，在主库上并发允许的查询在备库只能串行化执行，因为只有一个 SQL 线程来重放中继日志中的事件。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>22ed3766d45b09a255ec0717186c4442</guid>
<title>[推荐] Redis：我是如何与客户端进行通信的</title>
<link>https://toutiao.io/k/dr4u4yt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;江湖上说，&lt;strong&gt;天下武功，无坚不摧，唯快不破&lt;/strong&gt;，这句话简直是为我量身定制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我是一个Redis服务，最引以为傲的就是我的速度，我的 QPS 能达到10万级别。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我的手下有数不清的小弟，他们会时不时到我这来存放或者取走一些数据，我管他们叫做客户端，还给他们起了英文名叫 Redis-client。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候一个小弟会来的非常频繁，有时候一堆小弟会同时过来，但是，即使再多的小弟我也能管理的井井有条。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一天，小弟们问我。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8333333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZ08KPRWFa6JlBqaskXvoyfoy2icYqicT72JftlHDibibSES2rlIOOYyFGNpDvc9lEy5Je4pkIpwpYjdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;552&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想当年，为了不让小弟们拖垮我傲人的速度，在设计和他们的通信协议时，我绞尽脑汁，制定了下面的三条原则：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;实现简单&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;针对计算机来说，解析速度快&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;针对人类来说，可读性强&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么这么设计呢？先来看看一条指令发出的过程，首先在客户端需要对指令操作进行封装，使用网络进行传输，最后在服务端进行相应的解析、执行。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.463768115942029&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/zpom4BeZSicaLtJLCXG77p4PNzYoiaRAw5KYTmIWibRvsmxTp149neUMtI3gWFTiageu3ic5KFHm9HlmPkGxkCbZIMA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;690&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一过程如果设计成一种非常复杂的协议，那么封装、解析、传输的过程都将非常耗时，无疑会降低我的速度。什么，你问我为什么要遵循最后一条规则？算是对于程序员们的馈赠吧，我真是太善良了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我把创造出来的这种协议称为 RESP (&lt;code&gt;REdis Serialization Protocol&lt;/code&gt;)协议，它工作在 TCP 协议的上层，作为我和客户端之间进行通讯的标准形式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说到这，我已经有点迫不及待想让你们看看我设计出来的杰作了，但我好歹也是个大哥，得摆点架子，不能我主动拿来给你们看。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我建议你直接使用客户端发出一条向服务器的命令，然后取出这条命令对应的报文来直观的看一下。话虽如此，不过我已经被封装的很严实了，正常情况下你是看不到我内部进行通讯的具体报文的，所以，你可以&lt;strong&gt;伪装&lt;/strong&gt;成一个Redis的服务端，来截获小弟们发给我的消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现起来也很简单，我和小弟之间是基于 Socket 进行通讯，所以在本地先启动一个&lt;code&gt;ServerSocket&lt;/code&gt;，用来监听Redis服务的6379端口：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;server&lt;/span&gt;() &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;    ServerSocket serverSocket = &lt;span&gt;new&lt;/span&gt; ServerSocket(&lt;span&gt;6379&lt;/span&gt;);&lt;br/&gt;    Socket socket = serverSocket.accept();&lt;br/&gt;    &lt;span&gt;byte&lt;/span&gt;[] bytes = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;1024&lt;/span&gt;];&lt;br/&gt;    InputStream input = socket.getInputStream();&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(input.read(bytes)!=&lt;span&gt;0&lt;/span&gt;){&lt;br/&gt;        System.out.println(&lt;span&gt;new&lt;/span&gt; String(bytes));&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后启动&lt;code&gt;redis-cli&lt;/code&gt;客户端，发送一条命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;set key1 value1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时，伪装的服务端就会收到报文了，在控制台打印了：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;*3&lt;br/&gt;$3&lt;br/&gt;set&lt;br/&gt;$4&lt;br/&gt;key1&lt;br/&gt;$6&lt;br/&gt;value1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这里，隐隐约约看到了刚才输入的几个关键字，但是还有一些其他的字符，要怎么解释呢，是时候让我对协议报文中的格式进行一下揭秘了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我对小弟们说了，对大哥说话的时候得按规矩来，这样吧，你们在请求的时候要遵循下面的规则：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;*&amp;lt;参数数量&amp;gt; CRLF&lt;br/&gt;$&amp;lt;参数1的字节长度&amp;gt; CRLF&lt;br/&gt;&amp;lt;参数1的数据&amp;gt; CRLF&lt;br/&gt;$&amp;lt;参数2的字节长度&amp;gt; CRLF&lt;br/&gt;&amp;lt;参数2的数据&amp;gt; CRLF&lt;br/&gt;...&lt;br/&gt;$&amp;lt;参数N的字节长度&amp;gt; CRLF&lt;br/&gt;&amp;lt;参数N的数据&amp;gt; CRLF&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先解释一下每行末尾的&lt;code&gt;CRLF&lt;/code&gt;，转换成程序语言就是&lt;code&gt;\r\n&lt;/code&gt;，也就是回车加换行。看到这里，你也就能够明白为什么控制台打印出的指令是竖向排列了吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在命令的解析过程中，&lt;code&gt;set&lt;/code&gt;、&lt;code&gt;key1&lt;/code&gt;、&lt;code&gt;value1&lt;/code&gt;会被认为是3个参数，因此参数数量为3，对应第一行的&lt;code&gt;*3&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一个参数&lt;code&gt;set&lt;/code&gt;，长度为3对应&lt;code&gt;$3&lt;/code&gt;；第二个参数&lt;code&gt;key1&lt;/code&gt;，长度为4对应&lt;code&gt;$4&lt;/code&gt;；第三个参数&lt;code&gt;value1&lt;/code&gt;，长度为6对应&lt;code&gt;$6&lt;/code&gt;。在每个参数长度的下一行对应真正的参数数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这，一条指令被转换为协议报文的过程是不是就很好理解了？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4444444444444444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/zpom4BeZSicZ08KPRWFa6JlBqaskXvoyf1BJ8xSic8HRQJKdbo0xVqK3ZpxPW5jFxibEcGeajCuxuoqg8PFDkINEg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;900&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当小弟对我发送完请求后，作为大哥，我就要对小弟的请求进行&lt;strong&gt;指令回复&lt;/strong&gt;了，而且我得根据回复内容进行一下分类，要不然小弟该搞不清我的指示了。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;简单字符串&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单字符串回复只有一行回复，回复的内容以&lt;code&gt;+&lt;/code&gt;作为开头，不允许换行，并以&lt;code&gt;\r\n&lt;/code&gt;结束。有很多指令在执行成功后只会回复一个&lt;code&gt;OK&lt;/code&gt;，使用的就是这种格式，能够有效的将传输、解析的开销降到最低。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.084033613445378&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZ08KPRWFa6JlBqaskXvoyfqlJaHViaKC8OqiaoUCnUSleGjticb8hukVjQAVyzfiboxYDvhdCjbBLkgA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;476&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;错误回复&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在RESP协议中，错误回复可以当做简单字符串回复的变种形式，它们之间的格式也非常类似，区别只有第一个字符是以&lt;code&gt;-&lt;/code&gt;作为开头，错误回复的内容通常是错误类型及对错误描述的字符串。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;错误回复出现在一些异常的场景，例如当发送了错误的指令、操作数的数量不对时，都会进行错误回复。在客户端收到错误回复后，会将它与简单字符串回复进行区分，视为异常。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.184873949579832&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZ08KPRWFa6JlBqaskXvoyfg3vfSI3FdGySPRlPuGDajnFfmNmqoEyDfwzDzMo1u9fWKw01Qb8PgQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;476&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;整数回复&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整数回复的应用也非常广泛，它以&lt;code&gt;:&lt;/code&gt;作为开头，以&lt;code&gt;\r\n&lt;/code&gt;结束，用于返回一个整数。例如当执行&lt;code&gt;incr&lt;/code&gt;后返回自增后的值，执行&lt;code&gt;llen&lt;/code&gt;返回数组的长度，或者使用&lt;code&gt;exists&lt;/code&gt;命令返回的0或1作为判断一个&lt;code&gt;key&lt;/code&gt;是否存在的依据，这些都使用了整数回复。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9537815126050421&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZ08KPRWFa6JlBqaskXvoyfa4LiaqVYk1TOahicuRq4E2ib6nxDLEyzQsLiaRXzBtoiaKWeYzlETzhDia8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;476&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;批量回复&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;批量回复，就是多行字符串的回复。它以&lt;code&gt;$&lt;/code&gt;作为开头，后面是发送的字节长度，然后是&lt;code&gt;\r\n&lt;/code&gt;，然后发送实际的数据，最终以&lt;code&gt;\r\n&lt;/code&gt;结束。如果要回复的数据不存在，那么回复长度为-1。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.5126050420168067&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZ08KPRWFa6JlBqaskXvoyfBnACFwLBXNNhggIcPH9K5JXQjXeJna8zEqicQBA30rYW7ZnyzfDkic5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;476&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;多条批量回复&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当服务端要返回多个值时，例如返回一些元素的集合时，就会使用多条批量回复。它以&lt;code&gt;*&lt;/code&gt;作为开头，后面是返回元素的个数，之后再跟随多个上面讲到过的批量回复。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.3907563025210083&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZ08KPRWFa6JlBqaskXvoyfq3s6vL0Ud67Ivib4UE6BRUibInIkmiaOUf2OX8ibWpJ4ThDSwGQ4JJZwcw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;476&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里，基本上我和小弟之间的通讯协议就介绍完了。刚才你尝试了伪装成一个服务端，这会再来试一试直接写一个客户端来直接和我进行交互吧。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;client&lt;/span&gt;() &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;    String CRLF=&lt;span&gt;&quot;\r\n&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    Socket socket=&lt;span&gt;new&lt;/span&gt; Socket(&lt;span&gt;&quot;localhost&quot;&lt;/span&gt;, &lt;span&gt;6379&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; (OutputStream out = socket.getOutputStream()) {&lt;br/&gt;        StringBuffer sb=&lt;span&gt;new&lt;/span&gt; StringBuffer();&lt;br/&gt;        sb.append(&lt;span&gt;&quot;*3&quot;&lt;/span&gt;).append(CRLF)&lt;br/&gt;                .append(&lt;span&gt;&quot;$3&quot;&lt;/span&gt;).append(CRLF).append(&lt;span&gt;&quot;set&quot;&lt;/span&gt;).append(CRLF)&lt;br/&gt;                .append(&lt;span&gt;&quot;$4&quot;&lt;/span&gt;).append(CRLF).append(&lt;span&gt;&quot;key1&quot;&lt;/span&gt;).append(CRLF)&lt;br/&gt;                .append(&lt;span&gt;&quot;$6&quot;&lt;/span&gt;).append(CRLF).append(&lt;span&gt;&quot;value1&quot;&lt;/span&gt;).append(CRLF);&lt;br/&gt;        out.write(sb.toString().getBytes());&lt;br/&gt;        out.flush();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; (InputStream inputStream = socket.getInputStream()) {&lt;br/&gt;            &lt;span&gt;byte&lt;/span&gt;[] buff = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;1024&lt;/span&gt;];&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; len = inputStream.read(buff);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (len &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                String ret = &lt;span&gt;new&lt;/span&gt; String(buff, &lt;span&gt;0&lt;/span&gt;, len);&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;Recv:&quot;&lt;/span&gt; + ret);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行上面的代码，控制台输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Recv:+OK&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面模仿了客户端发出&lt;code&gt;set&lt;/code&gt;命令的过程，并收到了回复。依此类推，你也可以自己封装其他的命令，来实现一个自己的Redis客户端，作为小弟，来和我进行通信。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过记住，要叫我大哥。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2a8f2350c52f53df988e6ee9f3b055e2</guid>
<title>[推荐] Spring Boot 引起的 “堆外内存泄漏”</title>
<link>https://toutiao.io/k/o802afr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;src-views-article-detail-main-module__content--2qOBd markdown-body&quot;&gt;&lt;h1&gt;背景&lt;/h1&gt;
&lt;p&gt;组内一个项目最近一直报swap区域使用过高异常，笔者被叫去帮忙查看原因。发现配置的4G堆内内存，但是实际使用的物理内存高达7G，确实有点不正常，JVM参数配置是：&lt;/p&gt;
&lt;pre class=&quot;hljs&quot;&gt;&lt;code class=&quot;hljs-code-wrap&quot;&gt;-XX:MetaspaceSize=&lt;span class=&quot;hljs-number&quot;&gt;256&lt;/span&gt;M -XX:MaxMetaspaceSize=&lt;span class=&quot;hljs-number&quot;&gt;256&lt;/span&gt;M -XX:+AlwaysPreTouch -XX:ReservedCodeCacheSize=&lt;span class=&quot;hljs-number&quot;&gt;128&lt;/span&gt;m -XX:InitialCodeCacheSize=&lt;span class=&quot;hljs-number&quot;&gt;128&lt;/span&gt;m, -Xss512k -Xmx4g -Xms4g,-XX:+UseG1GC -XX:G1HeapRegionSize=&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;M
&lt;/code&gt;&lt;button class=&quot;pre-button&quot;&gt;复制&lt;/button&gt;&lt;/pre&gt;
&lt;p&gt;但是使用的虚拟内存和物理内存使用情况如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/386034&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h1&gt;排查过程&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;步骤一：先使用java层面的工具定位是不是堆内内存、code区域或者使用unsafe.allocateMemory和DirectByteBuffer申请的堆外内存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;笔者在项目中添加“-XX:NativeMemoryTracking=summary ”JVM参数重启项目，查看查到的内存分布如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/386059&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现这个命令显示的committed的远内存小于物理内存。因为之前就对NativeMemoryTracking有所了解和测试，知道NativeMemoryTracking可以追踪到堆内内存、code区域、通过unsafe.allocateMemory和DirectByteBuffer申请的内存，但是追踪不到其他native code（c代码）申请的堆外内存。这一步也可以使用arthas去查看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/386084&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了防止误判，笔者适应了pmap查看内存分布，发现大量的64M的地址，而这些地址空间不在NativeMemoryTracking所给出的地址空间里面。基本上就断定就是这些64M的内存导致的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/386087&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤二：使用系统层面的工具定位堆外内存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为基本上确定是native code引起之后，java层面的工具基本上就失效了，只能使用系统层面的工具去查找问题。首先使用了gperftools去查看，截图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/386113&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图可以看出，使用malloc申请的的内存最高到3G之后就释放了，之后始终维持在700M-800M。第一反应就是难道native code 中没有使用malloc申请，直接使用mmap/brk申请的？（gperftools原理就使用动态链接的方式替换了操作系统默认的内存分配器（glibc））&lt;/p&gt;
&lt;p&gt;直接使用strace对mmap/brk进行追踪发现，并没有申请内存，此时陷入了比较迷茫的状态。于是想着能不能看看内存里面是啥东西，就用gdb去dump这些64M的内存下来看看，内容如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/386121&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从内容上来看像解压后的jar信息。读取jar信息应该是在项目启动的时候，那么在项目启动之后使用strace作用就不是很大了，于是在项目启动的时候就使用strace，发现确实申请了很多64M内存空间，截图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/386153&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用该mmap申请的地址空间在pmap对应如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/386182&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据strace显示的线程Id，去jstack一下java进程，找到线程栈如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/386188&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里基本上就可以看出问题来了，这里使用了Reflections进行扫包，底层使用了spring boot loader去加载了jar。因为需要解压jar肯定需要Inflater类，这个需要用到堆外内存，然后使用btrace去追踪这个方法如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/386197&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在代码中找到扫包的地方，发现没有配置扫包路径，默认的是扫描所有jar，修改为扫描特定的jar路径。上线测试，内存正常，问题修复。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤三：为什么堆外内存没有释放掉呢&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;到步骤二的时候，问题已经解决了，但是有几个疑问：&lt;/p&gt;
&lt;p&gt;为什么堆外内存没有释放&lt;/p&gt;
&lt;p&gt;为什么内存大小都是64M，jar大小不可能这么大，而且都是一样大&lt;/p&gt;
&lt;p&gt;为什么gperftools最终显示使用的的内存大小是700M左右，解压包真的没有使用malloc申请内存吗？&lt;/p&gt;
&lt;p&gt;直接看了一下spring boot loader那一块源码，发现spring对jdk的JarFile的进行了包装。他使用Inflater却没有手动去释放，依赖于Inflater中的finalize机制，在gc的时候释放。于是怀疑gc的时候没有调用finalize。带着这样的怀疑，我把Inflater进行包装在spring loader里面替换成我包装的Inflater，在finalize进行打点监控，发现finalize在young gc 的时候确实被调用了啊。去看了一下Inflater对应的C代码，初始化的使用了malloc 申请内存，调用end的时候调用了free去释放内存了。于是怀疑free的时候没有真正释放内存。然后想着把spring boot包装JarFile 替换成jdk 自带的 JarFile，发现替换之后内存问题解决。&lt;/p&gt;
&lt;p&gt;然后再返过来看gperftools的内存分布情况。发现使用spring loader的时候，内存使用一直在增加，突然某个点内存使用下降了好多。这个点应该就是gc引起的，内存应该释放了。但是操作系统层面没有看到内存变化，怀疑没有释放到操作系统，被内存分配器持有了。&lt;/p&gt;
&lt;p&gt;发现和不使用gperftools内存地址分布差别很明显，2.5G地址使用smaps发现他是属于native stack。物理内存地址分布如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/386217&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到此基本上可以确定是内存分配器在捣鬼，搜索了一下glibc 64M，发现从glibc 从2.11 开始对每个线程引入内存池（64位机器大小就是64M内存），原文如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/386228&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按照文中所说去修改MALLOC_ARENA_MAX环境变量，发现没什么效果，去查看tcmalloc（gperftools使用的内存分配器）也使用了内存池方式。&lt;/p&gt;
&lt;p&gt;因为glibc 内存分配器代码太多，懒得去看，为了验证就自己简单写个内存分配器。使用动态链接替换掉glibc 的内存分配器，代码如下（因为都是从main中分配内存，没有考虑线程安全，realloc，calloc代码类似没截图了）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/386240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过在自定义分配器当中埋点可以发现其实程序启动之后程序实际申请的堆外内存其实始终在700M-800M之前，tcmalloc 也有相关埋点也是在700M-800M左右。但是从操作系统角度来看进程占用的内存差别很大（这里只是监控堆外内存）。&lt;/p&gt;
&lt;p&gt;笔者做了一下测试，使用不同分配器进行不同程度的扫包，占用的内存如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/386259&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为什么自定义的malloc 申请800M，最终占用的物理内存在1.7G呢？&lt;/p&gt;
&lt;p&gt;因为自定义内存采用的是mmap分配内存，mmap分配内存的单位是page，也就是page的整数倍，笔者使用的系统pagesize=4k，也就说如果用户申请了1一个字节，也会分配一个page，存在着巨大的空间浪费，可以通过埋点查看系统申请了多少页。埋点发现最终在536k左右吧。那实际上向系统申请的内存 = 512k * 4k = 2G，为什么这个数据由大于1.7G内，因为操作系统采取的是延迟加载的方式，也就是说通过mmap向系统申请内存的时候系统仅仅返回地址并没有分配真实的物理地址，只有在使用的时候系统产生一个缺页中断然后在加载这个page到内存当中，这也是使用pmap看到的物理和虚拟内存的区别。&lt;/p&gt;
&lt;h1&gt;总结&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/386284&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;整个内存分配的流程如上图。在扫描包的时候，spring loader不会主动去释放堆外内存，导致在扫描过程中，堆外内存占用量一直持续飙升。当发生gc 的时候会依赖于finalize机制一并去释放了堆外内存。但是glibc为了性能考虑，并没有真正把内存归返到操作系统，而是留下来当做内存池了，导致应用层以为发生了“内存泄漏”。&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a9d2dc9667671b974fdc13380b207a27</guid>
<title>[推荐] 95% 的算法都是基于这 6 种算法思想</title>
<link>https://toutiao.io/k/pbwl6pl</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section class=&quot;mp_profile_iframe_wrp&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg2NjUxOTM2Mg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/bwG40XYiaOKmTRcFWKB5pLtwz9auwyvjn6nhiaSydyGVuAfOfGmdpTBaqLJyLHVwDgXKNicS1VHhJSBADHCk2dib4Q/0?wx_fmt=png&quot; data-nickname=&quot;三分钟学前端&quot; data-alias=&quot;&quot; data-signature=&quot;每日三分钟，学习一个前端小 Tip！&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;点击上方 &lt;/span&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(0, 128, 255)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(0, 128, 255)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(0, 128, 255)&quot;&gt;三分钟学前端&lt;/span&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;，关注公众号&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;回复&lt;/span&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(0, 128, 255)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(0, 128, 255)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(0, 128, 255)&quot;&gt;交流&lt;/span&gt;&lt;span&gt;，加入前端编程面试算法每日一题群&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a class=&quot;weapp_text_link js_weapp_entry&quot; data-miniprogram-appid=&quot;wx27c980b913cbfb08&quot; data-miniprogram-path=&quot;pages/index/index&quot; data-miniprogram-nickname=&quot;高级前端面试&quot; data-miniprogram-type=&quot;text&quot; data-miniprogram-servicetype=&quot;0&quot; href=&quot;&quot;&gt;面试官也在看的前端面试资料&lt;/a&gt;&lt;/p&gt;&lt;p&gt;算法思想是解决问题的核心，万丈高楼起于平地，在算法中也是如此，95% 的算法都是基于这 6 种算法思想，结下了介绍一下这 6 种算法思想，帮助你理解及解决各种算法问题。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;1 递归算法&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;1.1 算法策略&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;递归算法是一种直接或者间接调用自身函数或者方法的算法。&lt;/p&gt;&lt;p&gt;递归算法的实质是把问题分解成规模缩小的同类问题的子问题，然后递归调用方法来表示问题的解。递归算法对解决一大类问题很有效，它可以使算法简洁和易于理解。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;优缺点：&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;优点：实现简单易上手&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;缺点：递归算法对常用的算法如普通循环等，运行效率较低；并且在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储，递归太深，容易发生栈溢出&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;1.2 适用场景&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;递归算法一般用于解决三类问题：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;数据的定义是按递归定义的。（斐波那契数列）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;问题解法按递归算法实现。（回溯）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据的结构形式是按递归定义的。（树的遍历，图的搜索）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;递归的解题策略：&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一步：明确你这个函数的输入输出，先不管函数里面的代码什么，而是要先明白，你这个函数的输入是什么，输出为何什么，功能是什么，要完成什么样的一件事。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二步：寻找递归结束条件，我们需要找出什么时候递归结束，之后直接把结果返回&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第三步：明确递归关系式，怎么通过各种递归调用来组合解决当前问题&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;1.3 使用递归算法求解的一些经典问题&lt;/span&gt;&lt;/h3&gt;&lt;h4&gt;DOM树为例&lt;/h4&gt;&lt;p&gt;下面以以 DOM 🌲为例，实现一个 &lt;code&gt;document.getElementById&lt;/code&gt; 功能&lt;/p&gt;&lt;p&gt;由于DOM是一棵树，而树的定义本身就是用的递归定义，所以用递归的方法处理树，会非常地简单自然。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第一步：明确你这个函数的输入输出&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;从 DOM 🌲根节点一层层往下递归，判断当前节点的 id 是否是我们要寻找的 &lt;code&gt;id=&#x27;d-cal&#x27;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;输入：DOM 🌲根节点 &lt;code&gt;document&lt;/code&gt; ，我们要寻找的 &lt;code&gt;id=&#x27;d-cal&#x27;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;输出：返回满足 &lt;code&gt;id=&#x27;sisteran&#x27;&lt;/code&gt; 的子结点&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;getElementById&lt;/span&gt;(&lt;span&gt;node, id&lt;/span&gt;)&lt;/span&gt;{}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;第二步：寻找递归结束条件&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;从document开始往下找，对所有子结点递归查找他们的子结点，一层一层地往下查找：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果当前结点的 id 符合查找条件，则返回当前结点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果已经到了叶子结点了还没有找到，则返回 null&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;getElementById&lt;/span&gt;(&lt;span&gt;node, id&lt;/span&gt;)&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 当前结点不存在，已经到了叶子结点了还没有找到，返回 null&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(!node) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 当前结点的 id 符合查找条件，返回当前结点&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(node.id === id) &lt;span&gt;return&lt;/span&gt; node&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;第三步：明确递归关系式&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;当前结点的 id 不符合查找条件，递归查找它的每一个子结点&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;getElementById&lt;/span&gt;(&lt;span&gt;node, id&lt;/span&gt;)&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 当前结点不存在，已经到了叶子结点了还没有找到，返回 null&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(!node) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 当前结点的 id 符合查找条件，返回当前结点&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(node.id === id) &lt;span&gt;return&lt;/span&gt; node&lt;br/&gt;    &lt;span&gt;// 前结点的 id 不符合查找条件，继续查找它的每一个子结点&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; node.childNodes.length; i++){&lt;br/&gt;        &lt;span&gt;// 递归查找它的每一个子结点&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;var&lt;/span&gt; found = getElementById(node.childNodes[i], id);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(found) &lt;span&gt;return&lt;/span&gt; found;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;就这样，我们的一个 &lt;code&gt;document.getElementById&lt;/code&gt; 功能已经实现了：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;getElementById&lt;/span&gt;(&lt;span&gt;node, id&lt;/span&gt;)&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(!node) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(node.id === id) &lt;span&gt;return&lt;/span&gt; node;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; node.childNodes.length; i++){&lt;br/&gt;        &lt;span&gt;var&lt;/span&gt; found = getElementById(node.childNodes[i], id);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(found) &lt;span&gt;return&lt;/span&gt; found;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;getElementById(&lt;span&gt;document&lt;/span&gt;, &lt;span&gt;&quot;d-cal&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后在控制台验证一下，执行结果如下图所示：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.15047021943573669&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bwG40XYiaOKnuJoEMkRQzmiawsflfy7jgjAl3KN8xL01fGUYkLliaQeV28Qf6gficmIPbTGPuBeXEgdiaRR5N9W1Qjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;319&quot;/&gt;&lt;/figure&gt;&lt;p&gt;使用递归的优点是代码简单易懂，缺点是效率比不上非递归的实现。Chrome浏览器的查DOM是使用非递归实现。非递归要怎么实现呢？&lt;/p&gt;&lt;p&gt;如下代码：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;getByElementId&lt;/span&gt;(&lt;span&gt;node, id&lt;/span&gt;)&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//遍历所有的Node&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(node){&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(node.id === id) &lt;span&gt;return&lt;/span&gt; node;&lt;br/&gt;        node = nextElement(node);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;还是依次遍历所有的 &lt;code&gt;DOM&lt;/code&gt; 结点，只是这一次改成一个 &lt;code&gt;while&lt;/code&gt; 循环，函数 &lt;code&gt;nextElement&lt;/code&gt; 负责找到下一个结点。所以关键在于这个 &lt;code&gt;nextElement&lt;/code&gt; 如何实现非递归查找结点功能：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 深度遍历&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;nextElement&lt;/span&gt;(&lt;span&gt;node&lt;/span&gt;)&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 先判断是否有子结点&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(node.children.length) {&lt;br/&gt;        &lt;span&gt;// 有则返回第一个子结点&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; node.children[&lt;span&gt;0&lt;/span&gt;];&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 再判断是否有相邻结点&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(node.nextElementSibling){&lt;br/&gt;        &lt;span&gt;// 有则返回它的下一个相邻结点&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; node.nextElementSibling;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 否则，往上返回它的父结点的下一个相邻元素，相当于上面递归实现里面的for循环的i加1&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(node.parentNode){&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(node.parentNode.nextElementSibling) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; node.parentNode.nextElementSibling;&lt;br/&gt;        }&lt;br/&gt;        node = node.parentNode;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在控制台里面运行这段代码，同样也可以正确地输出结果。不管是非递归还是递归，它们都是深度优先遍历，这个过程如下图所示。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.734375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bwG40XYiaOKnuJoEMkRQzmiawsflfy7jgjd6ic73IhdCfhuBp5nM2vCQdkT2D3D8h4JrG1Kib0APPJviaApib8ZsAkpQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p&gt;实际上 getElementById 浏览器是用的一个哈希 map 存储的，根据 id 直接映射到 DOM 结点，而 getElementsByClassName 就是用的这样的非递归查找。&lt;/p&gt;&lt;p&gt;参考：我接触过的前端数据结构与算法&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2 分治算法&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;2.1 算法策略&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;在计算机科学中，分治算法是一个很重要的算法，快速排序、归并排序等都是基于分治策略进行实现的，所以，建议理解掌握它。&lt;/p&gt;&lt;p&gt;分治，顾名思义，就是 &lt;strong&gt;分而治之&lt;/strong&gt; ，将一个复杂的问题，分成两个或多个相似的子问题，在把子问题分成更小的子问题，直到更小的子问题可以简单求解，求解子问题，则原问题的解则为阿子问题解的合并。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;2.2 适用场景&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;当出现满足以下条件的问题，可以尝试只用分治策略进行求解：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;原始问题可以分成多个相似的子问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;子问题可以很简单的求解&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;原始问题的解是子问题解的合并&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;各个子问题是相互独立的，不包含相同的子问题&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;分治的解题策略：&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一步：分解，将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二步：解决，解决各个子问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第三步：合并，将各个子问题的解合并为原问题的解&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;2.3 &lt;strong&gt;使用分治法求解的一些经典问题&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;二分查找&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;归并排序&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;快速排序&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;汉诺塔问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;React 时间分片&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;二分查找&lt;/h4&gt;&lt;p&gt;也称折半查找算法，它是一种简单易懂的快速查找算法。例如我随机写0-100之间的一个数字，让你猜我写的是什么？你每猜一次，我就会告诉你猜的大了还是小了，直到猜中为止。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第一步：分解&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;每次猜拳都把上一次的结果分出大的一组和小的一组，两组相互独立&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;binarySearch&lt;/span&gt;(&lt;span&gt;items, item&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// low、mid、high将数组分成两组&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; low = &lt;span&gt;0&lt;/span&gt;,&lt;br/&gt;        high = items.length - &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;        mid = &lt;span&gt;Math&lt;/span&gt;.floor((low+high)/&lt;span&gt;2&lt;/span&gt;),&lt;br/&gt;        elem = items[mid]&lt;br/&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;第二步：解决子问题&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;查找数与中间数对比&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;比中间数低，则去中间数左边的子数组中寻找；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;比中间数高，则去中间数右边的子数组中寻找；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;相等则返回查找成功&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;while&lt;/span&gt;(low &amp;lt;= high) {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt;(elem &amp;lt; item) { &lt;span&gt;// 比中间数高&lt;/span&gt;&lt;br/&gt;  low = mid + &lt;span&gt;1&lt;/span&gt;&lt;br/&gt; } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(elem &amp;gt; item) { &lt;span&gt;// 比中间数低&lt;/span&gt;&lt;br/&gt;  high = mid - &lt;span&gt;1&lt;/span&gt;&lt;br/&gt; } &lt;span&gt;else&lt;/span&gt; { &lt;span&gt;// 相等&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; mid&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;第三步：合并&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;binarySearch&lt;/span&gt;(&lt;span&gt;items, item&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; low = &lt;span&gt;0&lt;/span&gt;,&lt;br/&gt;        high = items.length - &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;        mid, elem&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(low &amp;lt;= high) {&lt;br/&gt;        mid = &lt;span&gt;Math&lt;/span&gt;.floor((low+high)/&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;        elem = items[mid]&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(elem &amp;lt; item) {&lt;br/&gt;            low = mid + &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(elem &amp;gt; item) {&lt;br/&gt;            high = mid - &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; mid&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;-1&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后，二分法只能应用于数组有序的情况，如果数组无序，二分查找就不能起作用了&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;binarySearch&lt;/span&gt;(&lt;span&gt;items, item&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 快排&lt;/span&gt;&lt;br/&gt;    quickSort(items)&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; low = &lt;span&gt;0&lt;/span&gt;,&lt;br/&gt;        high = items.length - &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;        mid, elem&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(low &amp;lt;= high) {&lt;br/&gt;        mid = &lt;span&gt;Math&lt;/span&gt;.floor((low+high)/&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;        elem = items[mid]&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(elem &amp;lt; item) {&lt;br/&gt;            low = mid + &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(elem &amp;gt; item) {&lt;br/&gt;            high = mid - &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; mid&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;-1&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 测试&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; arr = [&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;]&lt;br/&gt;binarySearch(arr, &lt;span&gt;3&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;// 2&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;binarySearch(arr, &lt;span&gt;5&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;// -1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;测试成功&lt;/p&gt;&lt;h2&gt;&lt;span&gt;3 贪心算法&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;3.1 算法策略&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;贪心算法，故名思义，总是做出当前的最优选择，即期望通过局部的最优选择获得整体的最优选择。&lt;/p&gt;&lt;p&gt;某种意义上说，贪心算法是很贪婪、很目光短浅的，它不从整体考虑，仅仅只关注当前的最大利益，所以说它做出的选择仅仅是某种意义上的局部最优，但是贪心算法在很多问题上还是能够拿到最优解或较优解，所以它的存在还是有意义的。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;3.2 适用场景&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;在日常生活中，我们使用到贪心算法的时候还是挺多的，例如：&lt;/p&gt;&lt;p&gt;从100章面值不等的钞票中，抽出 10 张，怎样才能获得最多的价值？&lt;/p&gt;&lt;p&gt;我们只需要每次都选择剩下的钞票中最大的面值，最后一定拿到的就是最优解，这就是使用的贪心算法，并且最后得到了整体最优解。&lt;/p&gt;&lt;p&gt;但是，我们任然需要明确的是，期望通过局部的最优选择获得整体的最优选择，仅仅是期望而已，也可能最终得到的结果并不一定不能是整体最优解。&lt;/p&gt;&lt;p&gt;例如：求取A到G最短路径：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.45131086142322097&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bwG40XYiaOKnuJoEMkRQzmiawsflfy7jgj8nz3CUJ0yel7n0cL6hl2u6HuN8JmQK2xicriaVlSRTibsv2c7YRicN3BSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1068&quot;/&gt;&lt;/figure&gt;&lt;p&gt;根据贪心算法总是选择当前最优选择，所以它首先选择的路径是 AB，然后 BE、EG，所得到的路径总长为 1 + 5 + 4 = 10，然而这并不是最短路径，最短路径为 A-&amp;gt;C-&amp;gt;G : 2 + 2 = 4，所以说，贪心算法得到得并不一定是最优解。&lt;/p&gt;&lt;p&gt;那么一般在什么时候可以尝试选择使用贪心算法喃？&lt;/p&gt;&lt;p&gt;当满足一下条件时，可以使用：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;原问题复杂度过高&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;求全局最优解的数学模型难以建立或计算量过大&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;没有太大必要一定要求出全局最优解，“比较优”就可以&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;如果使用贪心算法求最优解，可以按照以下 &lt;strong&gt;步骤求解&lt;/strong&gt; ：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先，我们需要明确什么是最优解（期望）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;然后，把问题分成多个步骤，每一步都需要满足：&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;- 不可取消：选择一旦做出，在后面遇到任何情况都不可取消&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后，叠加所有步骤的最优解，就是全局最优解&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;3.3 经典案例：活动选择问题&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;使用贪心算法求解的经典问题有：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;最小生成树算法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;单源最短路径的 Dijkstra 算法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Huffman 压缩编码&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;背包问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;活动选择问题等&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;其中活动选择问题是最简单的，这里详细介绍这个。&lt;/p&gt;&lt;p&gt;活动选择问题是《算法导论》上的例子，也是一个非常经典的问题。有 n 个活动（a1,a2,…,an）需要使用同一个资源（例如教室），资源在某个时刻只能供一个活动使用。每个活动 ai 都有一个开始时间 si 和结束时间 fi 。一旦被选择后，活动 ai 就占据半开时间区间 [si,fi) 。如果 [si,fi) 和 [sj,fj) 互不重叠，ai 和 aj 两个活动就可以被安排在这一天。&lt;/p&gt;&lt;p&gt;该问题就是要安排这些活动，使得尽量多的活动能不冲突的举行。例如下图所示的活动集合S，其中各项活动按照结束时间单调递增排序。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.55&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bwG40XYiaOKnuJoEMkRQzmiawsflfy7jgjE2QHwZsdIbcH8Qqib0bpI6iciaCaRcCNnWxZJVmibzkVLnhdN8RHsrjvHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1500&quot;/&gt;&lt;/figure&gt;&lt;p&gt;共有 7 个活动，它们在 18 个小时内需要占用的时间如上图，如何选择活动，能让这间教室利用率最高喃（能够举行更多的活动）？&lt;/p&gt;&lt;p&gt;贪心算法对这种问题的解决很简单的，它开始时刻开始选择，每次选择开始时间与与已选择活动不冲突的，结束时间又比较靠前的活动，这样会让剩下的时间区间更长。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5333333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bwG40XYiaOKnuJoEMkRQzmiawsflfy7jgj5rHSHmzhnYj2X9wh1B1OE9chyvTIUib10QZxyHe51fEeeFqsx6Ng7Og/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1500&quot;/&gt;&lt;/figure&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先 a1 活动的结束时间最早，选择 a1 活动&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;a1 结束后，a2 有时间冲突，不可选择，a3、a4 都可选择，但 a4 结束时间最早，选择 a4&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;依次选择时间没有冲突的，又结束时间最早的活动&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;最终选择活动为 a1，a4，a5，a7。为最优解。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;4 回溯算法&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;4.1 算法策略&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;回溯算法是一种搜索法，试探法，它会在每一步做出选择，一旦发现这个选择无法得到期望结果，就回溯回去，重新做出选择。深度优先搜索利用的就是回溯算法思想。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;4.2 适用场景&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;回溯算法很简单，它就是不断的尝试，直到拿到解。它的这种算法思想，使它通常用于解决广度的搜索问题，即从一组可能的解中，选择一个满足要求的解。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;4.3 使用回溯算法的经典案例&lt;/span&gt;&lt;/h3&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;深度优先搜索&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;0-1背包问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;正则表达式匹配&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;八皇后&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数独&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;全排列&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;等等，深度优先搜索我们在图那一章已经介绍过，这里以正则表达式匹配为例，介绍一下&lt;/p&gt;&lt;h4&gt;正则表达式匹配&lt;/h4&gt;&lt;blockquote&gt;&lt;p&gt;var string = &quot;abbc&quot;&lt;/p&gt;&lt;p&gt;var regex = /ab{1,3}c/&lt;/p&gt;&lt;p&gt;console.log( string.match(regex) )&lt;/p&gt;&lt;p&gt;// [&quot;abbc&quot;, index: 0, input: &quot;abbc&quot;, groups: undefined]&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;它的匹配过程：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.8680445151033387&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bwG40XYiaOKnuJoEMkRQzmiawsflfy7jgjc1PczkYecKZVGhyibXe5pHNaexicB9XQx65zwicysE4XGFibQaBXYxZFoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;629&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在第 5 步匹配失败，此时 &lt;code&gt;b{1,3}&lt;/code&gt; 已经匹配到了两个 &lt;code&gt;b&lt;/code&gt; 正在尝试第三个 &lt;code&gt;b&lt;/code&gt; ，结果发现接下来是 &lt;code&gt;c&lt;/code&gt; 。此时就需要回溯到上一步， &lt;code&gt;b{1,3}&lt;/code&gt; 匹配完毕（匹配到了 &lt;code&gt;bb&lt;/code&gt; ），然后再匹配 &lt;code&gt;c&lt;/code&gt; ，匹配到了 &lt;code&gt;c&lt;/code&gt; 匹配结束。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;5 动态规划&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;5.1 算法策略&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;动态规划也是将复杂问题分解成小问题求解的策略，与分治算法不同的是，分治算法要求各子问题是相互独立的，而动态规划各子问题是相互关联的。&lt;/p&gt;&lt;p&gt;所以，动态规划适用于子问题重叠的情况，即不同的子问题具有公共的子子问题，在这种情况下，分治策略会做出很多不必要的工作，它会反复求解那些公共子子问题，而动态规划会对每个子子问题求解一次，然后保存在表格中，如果遇到一致的问题，从表格中获取既可，所以它无需求解每一个子子问题，避免了大量的不必要操作。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;5.2 适用场景&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;动态规划适用于求解最优解问题，比如，从面额不定的100个硬币中任意选取多个凑成10元，求怎样选取硬币才可以使最后选取的硬币数最少又刚好凑够了10元。这就是一个典型的动态规划问题。它可以分成一个个子问题（每次选取硬币），每个子问题又有公共的子子问题（选取硬币），子问题之间相互关联（已选取的硬币总金额不能超过10元），边界条件就是最终选取的硬币总金额为 10 元。&lt;/p&gt;&lt;p&gt;针对上例，也许你也可以说，我们可以使用回溯算法，不断的去试探，但回溯算法是使用与求解广度的解（满足要求的解），如果是用回溯算法，我们需要尝试去找所有满足条件的解，然后找到最优解，时间复杂度为 O(2^n^) ，这性能是相当差的。大多数适用于动态规划的问题，都可以使用回溯算法，只是使用回溯算法的时间复杂度比较高而已。&lt;/p&gt;&lt;p&gt;最后，总结一下，我们使用动态规划求解问题时，需要遵循以下几个重要步骤：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;定义子问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实现需要反复执行解决的子子问题部分&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;识别并求解出边界条件&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;5.3 使用动态规划求解的一些经典问题&lt;/span&gt;&lt;/h3&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;爬楼梯问题：假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;背包问题：给出一些资源（有总量及价值），给一个背包（有总容量），往背包里装资源，目标是在背包不超过总容量的情况下，装入更多的价值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;硬币找零：给出面额不定的一定数量的零钱，以及需要找零的钱数，找出有多少种找零方案&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;图的全源最短路径：一个图中包含 u、v 顶点，找出从顶点 u 到顶点 v 的最短路径&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最长公共子序列：找出一组序列的最长公共子序列（可由另一序列删除元素但不改变剩下元素的顺序实现）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这里以最长公共子序列为例。&lt;/p&gt;&lt;h4&gt;爬楼梯问题&lt;/h4&gt;&lt;p&gt;这里以动态规划经典问题爬楼梯问题为例，介绍求解动态规划问题的步骤。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第一步：定义子问题&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;如果用 &lt;code&gt;dp[n]&lt;/code&gt; 表示第 &lt;code&gt;n&lt;/code&gt; 级台阶的方案数，并且由题目知：最后一步可能迈 2 个台阶，也可迈 1 个台阶，即第 &lt;code&gt;n&lt;/code&gt; 级台阶的方案数等于第 &lt;code&gt;n-1&lt;/code&gt; 级台阶的方案数加上第 &lt;code&gt;n-2&lt;/code&gt; 级台阶的方案数&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第二步：实现需要反复执行解决的子子问题部分&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;dp[n] = dp[n−&lt;span&gt;1&lt;/span&gt;] + dp[n−&lt;span&gt;2&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;第三步：识别并求解出边界条件&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 第 0 级 1 种方案 &lt;/span&gt;&lt;br/&gt;dp[&lt;span&gt;0&lt;/span&gt;]=&lt;span&gt;1&lt;/span&gt; &lt;br/&gt;&lt;span&gt;// 第 1 级也是 1 种方案 &lt;/span&gt;&lt;br/&gt;dp[&lt;span&gt;1&lt;/span&gt;]=&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;最后一步：把尾码翻译成代码，处理一些边界情况&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; climbStairs = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;n&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; dp = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;2&lt;/span&gt;; i &amp;lt;= n; i++) {&lt;br/&gt;        dp[i] = dp[i - &lt;span&gt;1&lt;/span&gt;] + dp[i - &lt;span&gt;2&lt;/span&gt;]&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; dp[n]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;复杂度分析：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;优化空间复杂度：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; climbStairs = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;n&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; res = &lt;span&gt;1&lt;/span&gt;, n1 = &lt;span&gt;1&lt;/span&gt;, n2 = &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;2&lt;/span&gt;; i &amp;lt;= n; i++) {&lt;br/&gt;        res = n1 + n2&lt;br/&gt;        n1 = n2&lt;br/&gt;        n2 = res&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; res&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;空间复杂度：O(1)&lt;/p&gt;&lt;h2&gt;&lt;span&gt;6 枚举算法&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;6.1 算法策略&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;枚举算法的思想是：将问题的所有可能的答案一一列举，然后根据条件判断此答案是否合适，保留合适的，丢弃不合适的。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;6.2 解题思路&lt;/span&gt;&lt;/h3&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;确定枚举对象、枚举范围和判定条件。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;逐一列举可能的解，验证每个解是否是问题的解。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;7 刷题&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;7.1 爬楼梯问题&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;假设你正在爬楼梯。需要 n 阶你才能到达楼顶。&lt;/p&gt;&lt;p&gt;每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？&lt;/p&gt;&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 给定 n 是一个正整数。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入： &lt;span&gt;2&lt;/span&gt;&lt;br/&gt;输出： &lt;span&gt;2&lt;/span&gt;&lt;br/&gt;解释： 有两种方法可以爬到楼顶。&lt;br/&gt;&lt;span&gt;1.&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; 阶 + &lt;span&gt;1&lt;/span&gt; 阶&lt;br/&gt;&lt;span&gt;2.&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; 阶&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入： &lt;span&gt;3&lt;/span&gt;&lt;br/&gt;输出： &lt;span&gt;3&lt;/span&gt;&lt;br/&gt;解释： 有三种方法可以爬到楼顶。&lt;br/&gt;&lt;span&gt;1.&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; 阶 + &lt;span&gt;1&lt;/span&gt; 阶 + &lt;span&gt;1&lt;/span&gt; 阶&lt;br/&gt;&lt;span&gt;2.&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; 阶 + &lt;span&gt;2&lt;/span&gt; 阶&lt;br/&gt;&lt;span&gt;3.&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; 阶 + &lt;span&gt;1&lt;/span&gt; 阶&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;解法：动态规划&lt;/h4&gt;&lt;p&gt;动态规划（Dynamic Programming，DP）是一种将复杂问题分解成小问题求解的策略，但与分治算法不同的是，分治算法要求各子问题是相互独立的，而动态规划各子问题是相互关联的。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;分治，顾名思义，就是分而治之，将一个复杂的问题，分成两个或多个相似的子问题，在把子问题分成更小的子问题，直到更小的子问题可以简单求解，求解子问题，则原问题的解则为子问题解的合并。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;我们使用动态规划求解问题时，需要遵循以下几个重要步骤：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;定义子问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实现需要反复执行解决的子子问题部分&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;识别并求解出边界条件&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;第一步：定义子问题&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;如果用 &lt;code&gt;dp[n]&lt;/code&gt; 表示第 &lt;code&gt;n&lt;/code&gt; 级台阶的方案数，并且由题目知：最后一步可能迈 2 个台阶，也可迈 1 个台阶，即第 &lt;code&gt;n&lt;/code&gt; 级台阶的方案数等于第 &lt;code&gt;n-1&lt;/code&gt; 级台阶的方案数加上第 &lt;code&gt;n-2&lt;/code&gt; 级台阶的方案数&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第二步：实现需要反复执行解决的子子问题部分&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;dp[n] = dp[n−&lt;span&gt;1&lt;/span&gt;] + dp[n−&lt;span&gt;2&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;第三步：识别并求解出边界条件&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 第 0 级 1 种方案 &lt;/span&gt;&lt;br/&gt;dp[&lt;span&gt;0&lt;/span&gt;]=&lt;span&gt;1&lt;/span&gt; &lt;br/&gt;&lt;span&gt;// 第 1 级也是 1 种方案 &lt;/span&gt;&lt;br/&gt;dp[&lt;span&gt;1&lt;/span&gt;]=&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;最后一步：把尾码翻译成代码，处理一些边界情况&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; climbStairs = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;n&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; dp = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;2&lt;/span&gt;; i &amp;lt;= n; i++) {&lt;br/&gt;        dp[i] = dp[i - &lt;span&gt;1&lt;/span&gt;] + dp[i - &lt;span&gt;2&lt;/span&gt;]&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; dp[n]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;复杂度分析：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;优化空间复杂度：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; climbStairs = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;n&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; res = &lt;span&gt;1&lt;/span&gt;, n1 = &lt;span&gt;1&lt;/span&gt;, n2 = &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;2&lt;/span&gt;; i &amp;lt;= n; i++) {&lt;br/&gt;        res = n1 + n2&lt;br/&gt;        n1 = n2&lt;br/&gt;        n2 = res&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; res&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;空间复杂度：O(1)&lt;/p&gt;&lt;p&gt;更多解答&lt;/p&gt;&lt;h3&gt;&lt;span&gt;7.2 使用最小花费爬楼梯&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;数组的每个索引作为一个阶梯，第 &lt;code&gt;i&lt;/code&gt; 个阶梯对应着一个非负数的体力花费值 &lt;code&gt;cost[i]&lt;/code&gt; (索引从0开始)。&lt;/p&gt;&lt;p&gt;每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。&lt;/p&gt;&lt;p&gt;您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: cost = [&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;15&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;]&lt;br/&gt;输出: &lt;span&gt;15&lt;/span&gt;&lt;br/&gt;解释: 最低花费是从cost[&lt;span&gt;1&lt;/span&gt;]开始，然后走两步即可到阶梯顶，一共花费&lt;span&gt;15&lt;/span&gt;。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: cost = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;输出: &lt;span&gt;6&lt;/span&gt;&lt;br/&gt;解释: 最低花费方式是从cost[&lt;span&gt;0&lt;/span&gt;]开始，逐个经过那些&lt;span&gt;1&lt;/span&gt;，跳过cost[&lt;span&gt;3&lt;/span&gt;]，一共花费&lt;span&gt;6&lt;/span&gt;。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;cost&lt;/code&gt; 的长度将会在 &lt;code&gt;[2, 1000]&lt;/code&gt; 。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每一个 &lt;code&gt;cost[i]&lt;/code&gt; 将会是一个Integer类型，范围为 &lt;code&gt;[0, 999]&lt;/code&gt; 。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;解法：动态规划&lt;/h4&gt;&lt;p&gt;本题注意理解题意：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第 &lt;code&gt;i&lt;/code&gt; 级台阶是第 &lt;code&gt;i-1&lt;/code&gt; 级台阶的阶梯顶部。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;踏上第 &lt;code&gt;i&lt;/code&gt; 级台阶花费 &lt;code&gt;cost[i]&lt;/code&gt; ，直接迈一大步跨过而不踏上去则不用花费。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;楼梯顶部在数组之外，如果数组长度为 &lt;code&gt;len&lt;/code&gt;，那么楼顶就在下标为 &lt;code&gt;len&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;第一步：定义子问题&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;踏上第 &lt;code&gt;i&lt;/code&gt; 级台阶的体力消耗为到达前两个阶梯的最小体力消耗加上本层体力消耗：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;最后迈 1 步踏上第 &lt;code&gt;i&lt;/code&gt; 级台阶：&lt;code&gt;dp[i-1] + cost[i]&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后迈 1 步踏上第 &lt;code&gt;i&lt;/code&gt; 级台阶：&lt;code&gt;dp[i-2] + cost[i]&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;第二步：实现需要反复执行解决的子子问题部分&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;所以踏上第 &lt;code&gt;i&lt;/code&gt; 级台阶的最小花费为：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;dp[i] = min(dp[i&lt;span&gt;-2&lt;/span&gt;], dp[i&lt;span&gt;-1&lt;/span&gt;]) + cost[i]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;第三步：识别并求解出边界条件&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 第 0 级 cost[0] 种方案 &lt;/span&gt;&lt;br/&gt;dp[&lt;span&gt;0&lt;/span&gt;] = cost[&lt;span&gt;0&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;// 第 1 级，有两种情况&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 1：分别踏上第0级与第1级台阶，花费cost[0] + cost[1]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 2：直接从地面开始迈两步直接踏上第1级台阶，花费cost[1]&lt;/span&gt;&lt;br/&gt;dp[&lt;span&gt;1&lt;/span&gt;] = min(cost[&lt;span&gt;0&lt;/span&gt;] + cost[&lt;span&gt;1&lt;/span&gt;], cost[&lt;span&gt;1&lt;/span&gt;]) = cost[&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;最后一步：把尾码翻译成代码，处理一些边界情况&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; minCostClimbingStairs = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;cost&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    cost.push(&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; dp = [], n = cost.length&lt;br/&gt;    dp[&lt;span&gt;0&lt;/span&gt;] = cost[&lt;span&gt;0&lt;/span&gt;]&lt;br/&gt;    dp[&lt;span&gt;1&lt;/span&gt;] = cost[&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;2&lt;/span&gt;; i &amp;lt; n; i++){&lt;br/&gt;        dp[i] = &lt;span&gt;Math&lt;/span&gt;.min(dp[i&lt;span&gt;-2&lt;/span&gt;] , dp[i&lt;span&gt;-1&lt;/span&gt;]) + cost[i]&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; dp[n&lt;span&gt;-1&lt;/span&gt;]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;复杂度分析：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;优化：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; minCostClimbingStairs = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;cost&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; n = cost.length,&lt;br/&gt;        n1 = cost[&lt;span&gt;0&lt;/span&gt;],&lt;br/&gt;        n2 = cost[&lt;span&gt;1&lt;/span&gt;] &lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;2&lt;/span&gt;;i &amp;lt; n;i++){&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; tmp = n2&lt;br/&gt;        n2 = &lt;span&gt;Math&lt;/span&gt;.min(n1,n2)+cost[i]&lt;br/&gt;        n1 = tmp&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;Math&lt;/span&gt;.min(n1,n2)&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;更多解答&lt;/p&gt;&lt;h3&gt;&lt;span&gt;7.3 最大子序和&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;给定一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: [&lt;span&gt;-2&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;-3&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;-1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;-5&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;]&lt;br/&gt;输出: &lt;span&gt;6&lt;/span&gt;&lt;br/&gt;解释: 连续子数组 [&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;-1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;] 的和最大，为 &lt;span&gt;6&lt;/span&gt;。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;进阶:&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第一步：定义子问题&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;动态规划是将整个数组归纳考虑，假设我们已经知道了以第 &lt;code&gt;i-1&lt;/code&gt; 个数结尾的连续子数组的最大和 &lt;code&gt;dp[i-1]&lt;/code&gt;，显然以第&lt;code&gt;i&lt;/code&gt;个数结尾的连续子数组的最大和的可能取值要么为 &lt;code&gt;dp[i-1]+nums[i]&lt;/code&gt;，要么就是 &lt;code&gt;nums[i]&lt;/code&gt; 单独成一组，也就是 &lt;code&gt;nums[i]&lt;/code&gt; ，在这两个数中我们取最大值&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第二步：实现需要反复执行解决的子子问题部分&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;dp[n] = &lt;span&gt;Math&lt;/span&gt;.max(dp[n−&lt;span&gt;1&lt;/span&gt;]+nums[n], nums[n])&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;第三步：识别并求解出边界条件&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;dp[&lt;span&gt;0&lt;/span&gt;]=nums[&lt;span&gt;0&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;最后一步：把尾码翻译成代码，处理一些边界情况&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;因为我们在计算 &lt;code&gt;dp[i]&lt;/code&gt; 的时候，只关心 &lt;code&gt;dp[i-1]&lt;/code&gt; 与 &lt;code&gt;nums[i]&lt;/code&gt;，因此不用把整个 &lt;code&gt;dp&lt;/code&gt; 数组保存下来，只需设置一个 &lt;code&gt;pre&lt;/code&gt; 保存 &lt;code&gt;dp[i-1]&lt;/code&gt; 就好了。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;代码实现（优化）：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; maxSubArray = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;nums&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; max = nums[&lt;span&gt;0&lt;/span&gt;], pre = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;const&lt;/span&gt; num &lt;span&gt;of&lt;/span&gt; nums) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(pre &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            pre += num&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            pre = num&lt;br/&gt;        }&lt;br/&gt;        max = &lt;span&gt;Math&lt;/span&gt;.max(max, pre)&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; max&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;复杂度分析：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;更多解答&lt;/p&gt;&lt;h3&gt;&lt;span&gt;7.4 买卖股票的最佳时机&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。&lt;/p&gt;&lt;p&gt;如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。&lt;/p&gt;&lt;p&gt;注意：你不能在买入股票前卖出股票。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: [&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;]&lt;br/&gt;输出: &lt;span&gt;5&lt;/span&gt;&lt;br/&gt;解释: 在第 &lt;span&gt;2&lt;/span&gt; 天（股票价格 = &lt;span&gt;1&lt;/span&gt;）的时候买入，在第 &lt;span&gt;5&lt;/span&gt; 天（股票价格 = &lt;span&gt;6&lt;/span&gt;）的时候卖出，最大利润 = &lt;span&gt;6&lt;/span&gt;&lt;span&gt;-1&lt;/span&gt; = &lt;span&gt;5&lt;/span&gt; 。&lt;br/&gt;     注意利润不能是 &lt;span&gt;7&lt;/span&gt;&lt;span&gt;-1&lt;/span&gt; = &lt;span&gt;6&lt;/span&gt;, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: [&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;输出: &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;解释: 在这种情况下, 没有交易完成, 所以最大利润为 &lt;span&gt;0&lt;/span&gt;。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;解法：动态规划&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;第一步：定义子问题&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;动态规划是将整个数组归纳考虑，假设我们已经知道了 &lt;code&gt;i-1&lt;/code&gt; 个股票的最大利润为 &lt;code&gt;dp[i-1]&lt;/code&gt;，显然 &lt;code&gt;i&lt;/code&gt; 个连续股票的最大利润为 &lt;code&gt;dp[i-1]&lt;/code&gt; ，要么就是就是 &lt;code&gt;prices[i] - minprice&lt;/code&gt; （ &lt;code&gt;minprice&lt;/code&gt; 为前 &lt;code&gt;i-1&lt;/code&gt; 支股票的最小值 ），在这两个数中我们取最大值&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第二步：实现需要反复执行解决的子子问题部分&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;dp[i] = &lt;span&gt;Math&lt;/span&gt;.max(dp[i−&lt;span&gt;1&lt;/span&gt;], prices[i] - minprice)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;第三步：识别并求解出边界条件&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;dp[&lt;span&gt;0&lt;/span&gt;]=&lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;最后一步：把尾码翻译成代码，处理一些边界情况&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;因为我们在计算 &lt;code&gt;dp[i]&lt;/code&gt; 的时候，只关心 &lt;code&gt;dp[i-1]&lt;/code&gt; 与 &lt;code&gt;prices[i]&lt;/code&gt;，因此不用把整个 &lt;code&gt;dp&lt;/code&gt; 数组保存下来，只需设置一个 &lt;code&gt;max&lt;/code&gt; 保存 &lt;code&gt;dp[i-1]&lt;/code&gt; 就好了。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;代码实现（优化）：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; maxProfit = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;prices&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; max = &lt;span&gt;0&lt;/span&gt;, minprice = prices[&lt;span&gt;0&lt;/span&gt;]&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt; prices.length; i++) {&lt;br/&gt;        minprice = &lt;span&gt;Math&lt;/span&gt;.min(prices[i], minprice)&lt;br/&gt;        max = &lt;span&gt;Math&lt;/span&gt;.max(max, prices[i] - minprice)&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; max&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;复杂度分析：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;更多解答&lt;/p&gt;&lt;h3&gt;&lt;span&gt;7.5 回文子串&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。&lt;/p&gt;&lt;p&gt;具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入：&lt;span&gt;&quot;abc&quot;&lt;/span&gt;&lt;br/&gt;输出：3&lt;br/&gt;解释：三个回文子串: &lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;b&quot;&lt;/span&gt;, &lt;span&gt;&quot;c&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入：&lt;span&gt;&quot;aaa&quot;&lt;/span&gt;&lt;br/&gt;输出：6&lt;br/&gt;解释：6个回文子串: &lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;aa&quot;&lt;/span&gt;, &lt;span&gt;&quot;aa&quot;&lt;/span&gt;, &lt;span&gt;&quot;aaa&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;&lt;h4&gt;解法一：暴力法&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; countSubstrings = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;s&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; s.length; i++) {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; j = i; j &amp;lt; s.length; j++) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (isPalindrome(s.substring(i, j + &lt;span&gt;1&lt;/span&gt;))) {&lt;br/&gt;        count++&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; count&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; isPalindrome = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;s&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;, j = s.length - &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; (i &amp;lt; j) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (s[i] != s[j]) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;    i++&lt;br/&gt;    j--&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;复杂度分析：&lt;/strong&gt;&lt;/p&gt;&lt;h4&gt;解法二：动态规划&lt;/h4&gt;&lt;p&gt;一个字符串是回文串，它的首尾字符相同，且剩余子串也是一个回文串。其中，剩余子串是否为回文串，就是规模小一点的子问题，它的结果影响大问题的结果。&lt;/p&gt;&lt;p&gt;我们怎么去描述子问题呢？&lt;/p&gt;&lt;p&gt;显然，一个子串由两端的 &lt;code&gt;i&lt;/code&gt; 、&lt;code&gt;j&lt;/code&gt; 指针确定，就是描述子问题的变量，子串 &lt;code&gt;s[i...j]&lt;/code&gt; （ &lt;code&gt;dp[i][j]&lt;/code&gt; ） 是否是回文串，就是子问题。&lt;/p&gt;&lt;p&gt;我们用二维数组记录计算过的子问题的结果，从base case出发，像填表一样递推出每个子问题的解。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;    j&lt;br/&gt;    a  a  b  a&lt;br/&gt;i a ✅&lt;br/&gt;  a    ✅  &lt;br/&gt;  b       ✅&lt;br/&gt;  a          ✅&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意： &lt;code&gt;i&amp;lt;=j&lt;/code&gt; ，只需用半张表，竖向扫描&lt;/p&gt;&lt;p&gt;所以：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;i === j：dp[i][j]=&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;j - i == &lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp; s[i] == s[j]：dp[i][j] = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;j - i &amp;gt; &lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp; s[i] == s[j] &amp;amp;&amp;amp; dp[i + &lt;span&gt;1&lt;/span&gt;][j - &lt;span&gt;1&lt;/span&gt;]：dp[i][j] = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;即：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;s[i] == s[j] &amp;amp;&amp;amp; (j - i &amp;lt;= &lt;span&gt;1&lt;/span&gt; || dp[i + &lt;span&gt;1&lt;/span&gt;][j - &lt;span&gt;1&lt;/span&gt;]): dp[i][j]=&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;否则为 &lt;code&gt;false&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; countSubstrings = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;s&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; len = s.length&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; dp = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Array&lt;/span&gt;(len)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; len; i++) {&lt;br/&gt;    dp[i] = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Array&lt;/span&gt;(len).fill(&lt;span&gt;false&lt;/span&gt;)&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; len; j++) {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt;= j; i++) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (s[i] == s[j] &amp;amp;&amp;amp; (j - i &amp;lt;= &lt;span&gt;1&lt;/span&gt; || dp[i + &lt;span&gt;1&lt;/span&gt;][j - &lt;span&gt;1&lt;/span&gt;])) {&lt;br/&gt;        dp[i][j] = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;        count++&lt;br/&gt;      } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        dp[i][j] = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; count&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;代码实现（优化）：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;把上图的表格竖向一列看作一维数组，还是竖向扫描，此时仅仅需要将 &lt;code&gt;dp&lt;/code&gt; 定义为一维数组即可&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; countSubstrings = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;s&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; len = s.length&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; dp = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Array&lt;/span&gt;(len)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; len; j++) {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt;= j; i++) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (s[i] === s[j] &amp;amp;&amp;amp; (j - i &amp;lt;= &lt;span&gt;1&lt;/span&gt; || dp[i + &lt;span&gt;1&lt;/span&gt;])) {&lt;br/&gt;        dp[i] = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;        count++&lt;br/&gt;      } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        dp[i] = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; count;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;复杂度分析：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;更多解答&lt;/p&gt;&lt;h3&gt;&lt;span&gt;7.6 最长回文子串&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: &lt;span&gt;&quot;babad&quot;&lt;/span&gt;&lt;br/&gt;输出: &lt;span&gt;&quot;bab&quot;&lt;/span&gt;&lt;br/&gt;注意: &lt;span&gt;&quot;aba&quot;&lt;/span&gt; 也是一个有效答案。&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: &lt;span&gt;&quot;cbbd&quot;&lt;/span&gt;&lt;br/&gt;输出: &lt;span&gt;&quot;bb&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;解法：动态规划&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;第 1 步：定义状态&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;dp[i][j]&lt;/code&gt; 表示子串 &lt;code&gt;s[i..j]&lt;/code&gt; 是否为回文子串，这里子串 &lt;code&gt;s[i..j]&lt;/code&gt; 定义为左闭右闭区间，可以取到 &lt;code&gt;s[i]&lt;/code&gt; 和 &lt;code&gt;s[j]&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第 2 步：思考状态转移方程&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;对于一个子串而言，如果它是回文串，那么在它的首尾增加一个相同字符，它仍然是个回文串&lt;/p&gt;&lt;pre&gt;&lt;code&gt;dp[i][j] = (s[i] === s[j]) &amp;amp;&amp;amp; dp[i+&lt;span&gt;1&lt;/span&gt;][j&lt;span&gt;-1&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;第 3 步：初始状态&lt;/strong&gt;：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;dp[i][i] = &lt;span&gt;true&lt;/span&gt; &lt;span&gt;// 单个字符是回文串&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(s[i] === s[i+&lt;span&gt;1&lt;/span&gt;]) dp[i][i+&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;true&lt;/span&gt; &lt;span&gt;// 连续两个相同字符是回文串 &lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; longestPalindrome = &lt;span&gt;(&lt;span&gt;s&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (s.length &amp;lt; &lt;span&gt;2&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; s&lt;br/&gt;  &lt;span&gt;// res: 最长回文子串&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; res = s[&lt;span&gt;0&lt;/span&gt;], dp = []&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; s.length; i++) {&lt;br/&gt;    dp[i][i] = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;; j &amp;lt; s.length; j++) {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; j; i++) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (j - i === &lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp; s[i] === s[j]) {&lt;br/&gt;        dp[i][j] = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;      } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (s[i] === s[j] &amp;amp;&amp;amp; dp[i + &lt;span&gt;1&lt;/span&gt;][j - &lt;span&gt;1&lt;/span&gt;]) {&lt;br/&gt;        dp[i][j] = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;      }   &lt;br/&gt;      &lt;span&gt;// 获取当前最长回文子串&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (dp[i][j] &amp;amp;&amp;amp; j - i + &lt;span&gt;1&lt;/span&gt; &amp;gt; res.length) {&lt;br/&gt;        res = s.substring(i, j + &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; res&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;复杂度分析：&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;时间复杂度：O(n^2^)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;空间复杂度：O(n^2^)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;更多解答&lt;/p&gt;&lt;h3&gt;&lt;span&gt;7.7 最小路径和&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;给定一个包含非负整数的 &lt;code&gt;m x n&lt;/code&gt; 网格 &lt;code&gt;grid&lt;/code&gt; ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。&lt;/p&gt;&lt;p&gt;说明：每次只能向下或者向右移动一步。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/bwG40XYiaOKnuJoEMkRQzmiawsflfy7jgjD5nBiaBYpbXPy8fhkwdKOYfxkKTjcR6mlzWHVKM8aTlfwBbGH9coOLw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;242&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入：grid = [[1,3,1],[1,5,1],[4,2,1]]&lt;br/&gt;输出：7&lt;br/&gt;解释：因为路径 1→3→1→1→1 的总和最小。&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入：grid = [[1,2,3],[4,5,6]]&lt;br/&gt;输出：12&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;m == grid.length&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;n == grid[i].length&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;1 &amp;lt;= m, n &amp;lt;= 200&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;0 &amp;lt;= grid[i][j] &amp;lt;= 100&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;1、DP方程&lt;/strong&gt; 当前项最小路径和 = 当前项值 + 上项或左项中的最小值 &lt;code&gt;grid[i][j] += Math.min( grid[i - 1][j], grid[i][j - 1] )&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2、边界处理&lt;/strong&gt; grid的第一行与第一列 分别没有上项与左项 故单独处理计算起项最小路径和 计算第一行：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;; j &amp;lt; col; j++) grid[&lt;span&gt;0&lt;/span&gt;][j] += grid[&lt;span&gt;0&lt;/span&gt;][j - &lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;计算第一列：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt; row; i++) grid[i][&lt;span&gt;0&lt;/span&gt;] += grid[i - &lt;span&gt;1&lt;/span&gt;][&lt;span&gt;0&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;3、代码实现&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; minPathSum = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;grid&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; row = grid.length, col = grid[&lt;span&gt;0&lt;/span&gt;].length&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// calc boundary&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt; row; i++)&lt;br/&gt;        &lt;span&gt;// calc first col&lt;/span&gt;&lt;br/&gt;        grid[i][&lt;span&gt;0&lt;/span&gt;] += grid[i - &lt;span&gt;1&lt;/span&gt;][&lt;span&gt;0&lt;/span&gt;]&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;; j &amp;lt; col; j++)&lt;br/&gt;        &lt;span&gt;// calc first row&lt;/span&gt;&lt;br/&gt;        grid[&lt;span&gt;0&lt;/span&gt;][j] += grid[&lt;span&gt;0&lt;/span&gt;][j - &lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt; row; i++)&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;; j &amp;lt; col; j++)&lt;br/&gt;            grid[i][j] += &lt;span&gt;Math&lt;/span&gt;.min(grid[i - &lt;span&gt;1&lt;/span&gt;][j], grid[i][j - &lt;span&gt;1&lt;/span&gt;])&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; grid[row - &lt;span&gt;1&lt;/span&gt;][col - &lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;更多解答&lt;/p&gt;&lt;h3&gt;&lt;span&gt;7.8 买卖股票的最佳时机 II&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。&lt;/p&gt;&lt;p&gt;设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: [&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;]&lt;br/&gt;输出: &lt;span&gt;7&lt;/span&gt;&lt;br/&gt;解释: 在第 &lt;span&gt;2&lt;/span&gt; 天（股票价格 = &lt;span&gt;1&lt;/span&gt;）的时候买入，在第 &lt;span&gt;3&lt;/span&gt; 天（股票价格 = &lt;span&gt;5&lt;/span&gt;）的时候卖出, 这笔交易所能获得利润 = &lt;span&gt;5&lt;/span&gt;&lt;span&gt;-1&lt;/span&gt; = &lt;span&gt;4&lt;/span&gt; 。&lt;br/&gt;     随后，在第 &lt;span&gt;4&lt;/span&gt; 天（股票价格 = &lt;span&gt;3&lt;/span&gt;）的时候买入，在第 &lt;span&gt;5&lt;/span&gt; 天（股票价格 = &lt;span&gt;6&lt;/span&gt;）的时候卖出, 这笔交易所能获得利润 = &lt;span&gt;6&lt;/span&gt;&lt;span&gt;-3&lt;/span&gt; = &lt;span&gt;3&lt;/span&gt; 。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: [&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;]&lt;br/&gt;输出: &lt;span&gt;4&lt;/span&gt;&lt;br/&gt;解释: 在第 &lt;span&gt;1&lt;/span&gt; 天（股票价格 = &lt;span&gt;1&lt;/span&gt;）的时候买入，在第 &lt;span&gt;5&lt;/span&gt; 天 （股票价格 = &lt;span&gt;5&lt;/span&gt;）的时候卖出, 这笔交易所能获得利润 = &lt;span&gt;5&lt;/span&gt;&lt;span&gt;-1&lt;/span&gt; = &lt;span&gt;4&lt;/span&gt; 。&lt;br/&gt;     注意你不能在第 &lt;span&gt;1&lt;/span&gt; 天和第 &lt;span&gt;2&lt;/span&gt; 天接连购买股票，之后再将它们卖出。&lt;br/&gt;     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: [&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;输出: &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;解释: 在这种情况下, 没有交易完成, 所以最大利润为 &lt;span&gt;0&lt;/span&gt;。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;1 &amp;lt;= prices.length &amp;lt;= 3 * 10 ^ 4&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;0 &amp;lt;= prices[i] &amp;lt;= 10 ^ 4&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;解法一：峰底买入，峰顶卖出&lt;/h4&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6175&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bwG40XYiaOKnuJoEMkRQzmiawsflfy7jgjP7RDxmGAicjUsWiaxTshwHfmGlpZAxf6FXF3yry4MOIdmibzibDZfa5hVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;/figure&gt;&lt;p&gt;如图，在第二天买入，第三天卖出，第四天买入，第五天卖出获利最高，此处代码不再赘述，可以自己尝试写一下&lt;/p&gt;&lt;h4&gt;解法二：贪心算法&lt;/h4&gt;&lt;p&gt;贪心算法，故名思义，总是做出当前的最优选择，即期望通过局部的最优选择获得整体的最优选择。&lt;/p&gt;&lt;p&gt;某种意义上说，贪心算法是很贪婪、很目光短浅的，它不从整体考虑，仅仅只关注当前的最大利益，所以说它做出的选择仅仅是某种意义上的局部最优，但是贪心算法在很多问题上还是能够拿到最优解或较优解，所以它的存在还是有意义的。&lt;/p&gt;&lt;p&gt;对应于该题，第一天买入，第二天卖出，…，第 &lt;code&gt;i&lt;/code&gt; 天买入，第 &lt;code&gt;i+1&lt;/code&gt; 天卖出，如果 &lt;code&gt;i&lt;/code&gt; 天买入第 &lt;code&gt;i+1&lt;/code&gt; 天卖出有利润则买入，否则不买&lt;/p&gt;&lt;p&gt;第 &lt;code&gt;i-1&lt;/code&gt; 天买入第 &lt;code&gt;i&lt;/code&gt; 天卖出获利 &lt;code&gt;prices[i+1]-prices[i]&lt;/code&gt; ，我们仅仅需要将 &lt;code&gt;prices[i+1]-prices[i]&lt;/code&gt; 的所有正值加起来就是可获取的最大利益&lt;/p&gt;&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; maxProfit = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;prices&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; profit = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; prices.length - &lt;span&gt;1&lt;/span&gt;; i++) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (prices[i + &lt;span&gt;1&lt;/span&gt;] &amp;gt; prices[i]) {&lt;br/&gt;            profit += prices[i + &lt;span&gt;1&lt;/span&gt;] - prices[i]&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; profit&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;复杂度分析：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;更多解答&lt;/p&gt;&lt;h3&gt;&lt;span&gt;7.9 分发饼干&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 g~i~ ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 s~j~。如果 s~j~ &amp;gt;= g~i~ ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;你可以假设胃口值为正。一个小朋友最多只能拥有一块饼干。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: [1,2,3], [1,1]&lt;br/&gt;&lt;br/&gt;输出: 1&lt;br/&gt;&lt;br/&gt;解释: &lt;br/&gt;你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。&lt;br/&gt;虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。&lt;br/&gt;所以你应该输出1。&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: [1,2], [1,2,3]&lt;br/&gt;&lt;br/&gt;输出: 2&lt;br/&gt;&lt;br/&gt;解释: &lt;br/&gt;你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。&lt;br/&gt;你拥有的饼干数量和尺寸都足以让所有孩子满足。&lt;br/&gt;所以你应该输出2.&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;解法：贪心算法&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; findContentChildren = &lt;span&gt;(&lt;span&gt;g, s&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!g.length || !s.length) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;    &lt;br/&gt;    g.sort(&lt;span&gt;(&lt;span&gt;a, b&lt;/span&gt;) =&amp;gt;&lt;/span&gt; a - b)&lt;br/&gt;    s.sort(&lt;span&gt;(&lt;span&gt;a, b&lt;/span&gt;) =&amp;gt;&lt;/span&gt; a - b)&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; gi = &lt;span&gt;0&lt;/span&gt;, si = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (gi &amp;lt; g.length &amp;amp;&amp;amp; si &amp;lt; s.length) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (g[gi] &amp;lt;= s[si++]) gi++&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; gi&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;更多解答&lt;/p&gt;&lt;h3&gt;&lt;span&gt;7.10 分割数组为连续子序列&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;给你一个按升序排序的整数数组 &lt;code&gt;num&lt;/code&gt;（可能包含重复数字），请你将它们分割成一个或多个子序列，其中每个子序列都由连续整数组成且长度至少为 3 。&lt;/p&gt;&lt;p&gt;如果可以完成上述分割，则返回 &lt;code&gt;true&lt;/code&gt; ；否则，返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: [1,2,3,3,4,5]&lt;br/&gt;输出: True&lt;br/&gt;解释:&lt;br/&gt;你可以分割出这样两个连续子序列 : &lt;br/&gt;1, 2, 3&lt;br/&gt;3, 4, 5&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: [1,2,3,3,4,4,5,5]&lt;br/&gt;输出: True&lt;br/&gt;解释:&lt;br/&gt;你可以分割出这样两个连续子序列 : &lt;br/&gt;1, 2, 3, 4, 5&lt;br/&gt;3, 4, 5&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: [1,2,3,4,4,5]&lt;br/&gt;输出: False&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;&lt;h4&gt;解法：贪心算法&lt;/h4&gt;&lt;p&gt;从头开始，我们每次仅仅寻找满足条件的序列（连续子序列长度为3），剔除之后，依次往后遍历：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;判断当前元素是否能够拼接到前一个满足条件的连续子序列上，可以的话，则拼接&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果不可以，则判断以当前元素开始能否构成连续子序列（长度为3），可以的话，则剔除连续子序列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;否则，返回 false&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; isPossible = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;nums&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; max = nums[nums.length - &lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;    &lt;span&gt;// arr：存储原数组中数字每个数字出现的次数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// tail：存储以数字num结尾的且符合题意的连续子序列个数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; arr = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Array&lt;/span&gt;(max + &lt;span&gt;2&lt;/span&gt;).fill(&lt;span&gt;0&lt;/span&gt;), &lt;br/&gt;        tail = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Array&lt;/span&gt;(max + &lt;span&gt;2&lt;/span&gt;).fill(&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; num &lt;span&gt;of&lt;/span&gt; nums) {&lt;br/&gt;        arr[num] ++&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; num &lt;span&gt;of&lt;/span&gt; nums) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(arr[num] === &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(tail[num&lt;span&gt;-1&lt;/span&gt;] &amp;gt; &lt;span&gt;0&lt;/span&gt;){&lt;br/&gt;            tail[num&lt;span&gt;-1&lt;/span&gt;]--&lt;br/&gt;            tail[num]++&lt;br/&gt;        }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(arr[num+&lt;span&gt;1&lt;/span&gt;] &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; arr[num+&lt;span&gt;2&lt;/span&gt;] &amp;gt; &lt;span&gt;0&lt;/span&gt;){&lt;br/&gt;            arr[num+&lt;span&gt;1&lt;/span&gt;]--&lt;br/&gt;            arr[num+&lt;span&gt;2&lt;/span&gt;]--&lt;br/&gt;            tail[num+&lt;span&gt;2&lt;/span&gt;]++&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;        arr[num]--&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;复杂度分析：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;更多解答&lt;/p&gt;&lt;h3&gt;&lt;span&gt;7.11 全排列问题&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;给定一个 &lt;strong&gt;没有重复&lt;/strong&gt; 数字的序列，返回其所有可能的全排列。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: [&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;]&lt;br/&gt;输出:&lt;br/&gt;[&lt;br/&gt;  [&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;解法：回溯算法&lt;/h4&gt;&lt;p&gt;本题是回溯算法的经典应用场景&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1. 算法策略&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;回溯算法是一种搜索法，试探法，它会在每一步做出选择，一旦发现这个选择无法得到期望结果，就回溯回去，重新做出选择。深度优先搜索利用的就是回溯算法思想。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2. 适用场景&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;回溯算法很简单，它就是不断的尝试，直到拿到解。它的这种算法思想，使它通常用于解决广度的搜索问题，即从一组可能的解中，选择一个满足要求的解。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3. 代码实现&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;我们可以写一下，数组 [1, 2, 3] 的全排列有：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;先写以 1 开头的全排列，它们是：[1, 2, 3], [1, 3, 2]，即 1 + [2, 3] 的全排列；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;再写以 2 开头的全排列，它们是：[2, 1, 3], [2, 3, 1]，即 2 + [1, 3] 的全排列；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后写以 3 开头的全排列，它们是：[3, 1, 2], [3, 2, 1]，即 3 + [1, 2] 的全排列。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;即回溯的处理思想，有点类似枚举搜索。我们枚举所有的解，找到满足期望的解。为了有规律地枚举所有可能的解，避免遗漏和重复，我们把问题求解的过程分为多个阶段。每个阶段，我们都会面对一个岔路口，我们先随意选一条路走，当发现这条路走不通的时候（不符合期望的解），就回退到上一个岔路口，另选一种走法继续走。&lt;/p&gt;&lt;p&gt;这显然是一个 &lt;strong&gt;递归&lt;/strong&gt; 结构；&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;递归的终止条件是：一个排列中的数字已经选够了 ，因此我们需要一个变量来表示当前程序递归到第几层，我们把这个变量叫做 &lt;code&gt;depth&lt;/code&gt; ，或者命名为 &lt;code&gt;index&lt;/code&gt; ，表示当前要确定的是某个全排列中下标为 &lt;code&gt;index&lt;/code&gt; 的那个数是多少；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;used（object）：用于把表示一个数是否被选中，如果这个数字(num)被选择这设置为 &lt;code&gt;used[num] = true&lt;/code&gt; ，这样在考虑下一个位置的时候，就能够以 O(1)的时间复杂度判断这个数是否被选择过，这是一种「以空间换时间」的思想。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; permute = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;nums&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 使用一个数组保存所有可能的全排列&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; res = []&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (nums.length === &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; res&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; used = {}, path = []&lt;br/&gt;    dfs(nums, nums.length, &lt;span&gt;0&lt;/span&gt;, path, used, res)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; res&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; dfs = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;nums, len, depth, path, used, res&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 所有数都填完了&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (depth === len) {&lt;br/&gt;        res.push([...path])&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; len; i++) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!used[i]) {&lt;br/&gt;            &lt;span&gt;// 动态维护数组&lt;/span&gt;&lt;br/&gt;            path.push(nums[i])&lt;br/&gt;            used[i] = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;// 继续递归填下一个数&lt;/span&gt;&lt;br/&gt;            dfs(nums, len, depth + &lt;span&gt;1&lt;/span&gt;, path, used, res)&lt;br/&gt;            &lt;span&gt;// 撤销操作&lt;/span&gt;&lt;br/&gt;            used[i] = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;            path.pop()&lt;br/&gt;        }&lt;br/&gt;      &lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;4. 复杂度分析&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;时间复杂度：O(n∗n!)，其中 n 为序列的长度&lt;/p&gt;&lt;p&gt;这是一个排列组合，每层的排列组合数为：A^m^ ~n~=n!/(n−m)! ，故而所有的排列有 ：&lt;/p&gt;&lt;p&gt;A^1^ ~n~ + A^2^ ~n~ + … + A^n-1^ ~n~ = n!/(n−1)! + n!/(n−2)! + … + n! = n! * (1/(n−1)! + 1/(n−2)! + … + 1) &amp;lt;= n! * (1 + 1/2 + 1/4 + … + 1/2^n-1^) &amp;lt; 2 * n!&lt;/p&gt;&lt;p&gt;并且每个内部结点循环 n 次，故非叶子结点的时间复杂度为 O(n∗n!)&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;空间复杂度：O(n)&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;更多解答&lt;/p&gt;&lt;h3&gt;&lt;span&gt;7.12 括号生成&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;数字 &lt;code&gt;n&lt;/code&gt; 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 &lt;strong&gt;有效的&lt;/strong&gt; 括号组合。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入：n = &lt;span&gt;3&lt;/span&gt;&lt;br/&gt;输出：[&lt;br/&gt;       &lt;span&gt;&quot;((()))&quot;&lt;/span&gt;,&lt;br/&gt;       &lt;span&gt;&quot;(()())&quot;&lt;/span&gt;,&lt;br/&gt;       &lt;span&gt;&quot;(())()&quot;&lt;/span&gt;,&lt;br/&gt;       &lt;span&gt;&quot;()(())&quot;&lt;/span&gt;,&lt;br/&gt;       &lt;span&gt;&quot;()()()&quot;&lt;/span&gt;&lt;br/&gt;     ]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;解答：回溯算法（深度优先遍历）&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;算法策略：&lt;/strong&gt; 回溯算法是一种搜索法，试探法，它会在每一步做出选择，一旦发现这个选择无法得到期望结果，就回溯回去，重新做出选择。深度优先搜索利用的就是回溯算法思想。&lt;/p&gt;&lt;p&gt;对应于本题，我们可以每次试探增加 &lt;code&gt;(&lt;/code&gt; 或 &lt;code&gt;)&lt;/code&gt; ，注意：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;加入 &lt;code&gt;(&lt;/code&gt; 的条件是，当前是否还有 &lt;code&gt;(&lt;/code&gt; 可以选择&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;加入 &lt;code&gt;)&lt;/code&gt; 的时候，受到 &lt;code&gt;(&lt;/code&gt; 的限制，如果已选择的结果里的 &lt;code&gt;(&lt;/code&gt; 小于等于已选择里的 &lt;code&gt;)&lt;/code&gt; 时，此时是不能选择 &lt;code&gt;)&lt;/code&gt; 的，例如如果当前是 &lt;code&gt;()&lt;/code&gt; ，继续选择 &lt;code&gt;)&lt;/code&gt; 就是 &lt;code&gt;())&lt;/code&gt; ，是不合法的&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; generateParenthesis = &lt;span&gt;(&lt;span&gt;n&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; res = []&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; dfs = &lt;span&gt;(&lt;span&gt;path, left, right&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// 肯定不合法，提前结束&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (left &amp;gt; n || left &amp;lt; right) &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 到达结束条件&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (left + right === &lt;span&gt;2&lt;/span&gt; * n) {&lt;br/&gt;            res.push(path)&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;// 选择&lt;/span&gt;&lt;br/&gt;        dfs(path + &lt;span&gt;&#x27;(&#x27;&lt;/span&gt;, left + &lt;span&gt;1&lt;/span&gt;, right)&lt;br/&gt;        dfs(path + &lt;span&gt;&#x27;)&#x27;&lt;/span&gt;, left, right + &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;    }&lt;br/&gt;    dfs(&lt;span&gt;&#x27;&#x27;&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; res&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;复杂度分析（来源leetcode官方题解）：&lt;/strong&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.24057217165149544&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bwG40XYiaOKnuJoEMkRQzmiawsflfy7jgj2ZzfgK706a8fGSYEL3egXoHlb82mKFreHYTckX7IeAnlJsP76438sA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1538&quot;/&gt;&lt;/figure&gt;&lt;p&gt;更多解答&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最近开源&lt;/span&gt;&lt;span&gt;了一个github仓库：&lt;/span&gt;&lt;span&gt;百问百答，在工作中很难做到对社群问题进行立即解答，所以可以将问题提交至 https://github.com/Advanced-Frontend/Just-Now-QA ，我会在每晚花费 1 个小时左右进行处理，更多的是鼓励与欢迎更多人一起参与探讨与解答🌹&lt;/span&gt;&lt;/p&gt;&lt;h2 data-id=&quot;heading-13&quot;&gt;最后&lt;/h2&gt;&lt;section&gt;&lt;span&gt;欢迎关注「&lt;/span&gt;&lt;span&gt;三分钟学前端&lt;/span&gt;&lt;span&gt;」，回复「&lt;/span&gt;&lt;span&gt;交流&lt;/span&gt;&lt;span&gt;」自动加入&lt;/span&gt;&lt;span&gt;前端三分钟进阶群，每日一道编程算法面试题（含解答），助力你成为更优秀的前端开发！&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg2NjUxOTM2Mg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/bwG40XYiaOKmTRcFWKB5pLtwz9auwyvjn6nhiaSydyGVuAfOfGmdpTBaqLJyLHVwDgXKNicS1VHhJSBADHCk2dib4Q/0?wx_fmt=png&quot; data-nickname=&quot;三分钟学前端&quot; data-alias=&quot;&quot; data-signature=&quot;每日三分钟，学习一个前端小 Tip！&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;号内回复：&lt;/p&gt;&lt;section&gt;「&lt;strong&gt;网络&lt;/strong&gt;」，自动获取三分钟学前端网络篇小书（90+页）&lt;/section&gt;&lt;section&gt;「&lt;strong&gt;JS&lt;/strong&gt;」，自动获取三分钟学前端 JS 篇小书（120+页）&lt;/section&gt;&lt;section&gt;「&lt;strong&gt;算法&lt;/strong&gt;」，自动获取 github 2.9k+ 的前端算法小书&lt;/section&gt;&lt;section&gt;「&lt;strong&gt;面试&lt;/strong&gt;」，自动获取 github 23.2k+ 的前端面试小书&lt;/section&gt;&lt;section&gt;「&lt;strong&gt;简历&lt;/strong&gt;」，自动获取程序员系列的 &lt;code&gt;120&lt;/code&gt; 套模版&lt;/section&gt;&lt;section&gt;&lt;a class=&quot;weapp_text_link js_weapp_entry&quot; data-miniprogram-appid=&quot;wx27c980b913cbfb08&quot; data-miniprogram-path=&quot;pages/index/index&quot; data-miniprogram-nickname=&quot;高级前端面试&quot; data-miniprogram-type=&quot;text&quot; data-miniprogram-servicetype=&quot;0&quot; href=&quot;&quot;&gt;》》面试官也在看的前端面试资料《《&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;“在看和转发”&lt;/span&gt;&lt;span&gt;就是最大的&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>98550de25220051cdd43cd9e7661defb</guid>
<title>[推荐] 月薪两万程序员应该知道的编程模型</title>
<link>https://toutiao.io/k/3kwp297</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;我承认这篇文章有标题党的嫌疑，看完这篇文章并不会让你月薪两万。如果想月薪两万甚至更多，并不是靠一篇文章，一本书，一个项目来实现的。&lt;/p&gt;&lt;p&gt;但是一个合格的程序员对响应式编程多少都应该有些了解，甚至有个清楚的认识。&lt;/p&gt;&lt;p&gt;希望这边文章能够让你对响应式编程有个基本的认识，以及响应式编程会带来哪些好处，解决哪些问题，或者说为什么响应式编程如此重要。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;响应式编程发展过程&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;响应式编程的概念是微软最开始提出并且在&lt;code&gt;.net&lt;/code&gt;平台上实现&lt;/span&gt;的&lt;span&gt;一个库。&lt;/span&gt;&lt;span&gt;后来这个模型被大家接受并认可，&lt;/span&gt;&lt;code&gt;ReactiveX&lt;/code&gt;&lt;span&gt; 就实现了很多其它语言对应的库，大名鼎鼎的&lt;/span&gt;&lt;code&gt;RXJava&lt;/code&gt;&lt;span&gt;就是针对&lt;/span&gt;&lt;code&gt;Java&lt;/code&gt;&lt;span&gt;语言实现的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;后来&lt;code&gt;ReactiveX&lt;/code&gt; 和 &lt;code&gt;Reactor&lt;/code&gt;共同制定了&lt;code&gt;Reactive Stream&lt;/code&gt;标准，&lt;code&gt;ReactiveX&lt;/code&gt;和&lt;code&gt;Reactor&lt;/code&gt;都是在这个标准下实现的框架。&lt;code&gt;Spring5&lt;/code&gt; 正式引入&lt;code&gt;Reactor&lt;/code&gt; 并基于该框架实现了&lt;code&gt;WEB-FLUX&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;此外&lt;code&gt;Java8&lt;/code&gt;引进了&lt;code&gt;Stream&lt;/code&gt;流以及&lt;code&gt;lamada&lt;/code&gt;表达式，&lt;code&gt;Java9&lt;/code&gt;引入了&lt;code&gt;Flow&lt;/code&gt;，也是对响应式编程的一种支持。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;什么是响应式编程&lt;/span&gt;&lt;/h4&gt;&lt;blockquote&gt;&lt;p&gt;reactive programming is a declarative programming paradigm concerned with data streams and the propagation of change&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;这是维基百科对响应式编程给出的定义。我对这个定义的评价是，懂的自然懂，不懂的还是不懂。&lt;/p&gt;&lt;p&gt;我提炼一下这个定义的关键词 &lt;strong&gt;声明式&lt;/strong&gt;，&lt;strong&gt;数据流&lt;/strong&gt;， &lt;strong&gt;传递变化（响应）&lt;/strong&gt;，我自己再给加一个&lt;strong&gt;异步&lt;/strong&gt;，因为实际上生产级别代码都是进行异步响应的，几乎很少进行同步响应。&lt;/p&gt;&lt;p&gt;在具体介绍响应式编程之前，先简单解释一下这几个关键词的含义。&lt;/p&gt;&lt;h5&gt;&lt;span&gt;声明式编程&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;声明式和指令式对应。指令式大家比较熟悉，就是依次写出完成某个任务的每条指令。&lt;/p&gt;&lt;p&gt;比如从一个苹果列表里，找出所有红色的苹果，指令式编程是这样做的。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;List&amp;lt;Apple&amp;gt; apples = new ArrayList&amp;lt;Apple&amp;gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;for (Apple apple : apples){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if (apple.getColor() == &quot;red&quot;){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.out.println(apple);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;声明式编程，只要写出你想要什么就OK了。&lt;/p&gt;&lt;p&gt;典型的声明式语言的就是&lt;code&gt;sql&lt;/code&gt;，对应上面的找红色苹果的需求，应该是这样的 &lt;code&gt;select * from apple where color = red&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;简单的讲，声明式编程就是聊天式编程，和计算机说你想要什么就OK了。&lt;/p&gt;&lt;h5&gt;&lt;span&gt;数据流&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;再说说数据流，其实数据流可以把它想象成水流，里面流淌的是数据,事件，信号等内容。如果大家对&lt;code&gt;Java8&lt;/code&gt;引入的&lt;code&gt;Stream&lt;/code&gt;流有一定了解的话，就会好理解。如果不了解的可以通过我&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMzE4MDY0Nw==&amp;amp;mid=2247483888&amp;amp;idx=1&amp;amp;sn=4bf8b2819070d6ad2466cd64579265b9&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;这篇文章&lt;/a&gt;做个入门。&lt;/p&gt;&lt;h5&gt;&lt;span&gt;传递变化（响应）&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;传递变化(响应)，其实就是对响应二字的体现。所谓的响应就是你和某个人打了招呼，然后某人回应你了。某人对你的回应就是响应。&lt;/p&gt;&lt;p&gt;将上面的场景对应到面向对象的编程里面，就是观察者（订阅）模式。观察者对被观察者的某些行为做出对应的动作。&lt;/p&gt;&lt;p&gt;有些前端程序员对观察者模式可能比较陌生，那么大家比较熟悉的&lt;code&gt;Ajax&lt;/code&gt;回调函数也是响应式编程的一种体现，比如如下&lt;code&gt;JS&lt;/code&gt;代码&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;$.ajax(&quot;example.action&quot;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    .done(function(){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        console.log(&quot;success&quot;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    })&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    .fail(function(){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        console.log(&quot;error&quot;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    })&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    .always(function(){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        console.log(&quot;complete&quot;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    });&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;这就是典型的异步回调，当请求成功的时候会有一种响应动作，请求失败的时候会有另一种响应动作。&lt;/p&gt;&lt;h5&gt;&lt;span&gt;异步&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;关于响应的方式，有同步响应和异步响应。实际应用中大部分都会采用异步响应。&lt;/p&gt;&lt;p&gt;同步：你给旅行社打电话预定一张机票，接线员接到你的电话后，开始查询航班信息，然后进行预订，这期间你一直拿着电话等他的结果。&lt;/p&gt;&lt;p&gt;异步：你给旅行社打电话预定一张机票，接线员接到电话后，记录下你要预定的航班信息，然后就挂掉电话。等他预定好之后，把预定结果打电话告诉你。这就是异步。&lt;/p&gt;&lt;p&gt;&lt;span&gt;很明显异步操作对你来说效率更高，因为你不用一&lt;/span&gt;直&lt;span&gt;等接线员的操作，你可以干其他事情。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;上面的场景也被很多人称为好莱坞规则。很多好演员去好莱坞报名拍戏，经纪公司会登记下演员的姓名，等有合适的机会的时候，经纪公司会给演员打电话，而不用演员一直在现场等，或者不断的给经纪公司打电话询问。&lt;code&gt;don&#x27;t call me I will call you&lt;/code&gt;。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;小试牛刀&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;其实介绍完上面那些东西，可能对响应式编程的理解还是模糊的。那么我们就以&lt;code&gt;Reactor&lt;/code&gt;框架为例子做一个简单的说明。毕竟程序员都喜欢&lt;code&gt;show me the code&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;上面提到了响应式编程的核心是基于观察者(订阅)模式的。观察者观察被观察者的行为，根据不同的行为做出不同的响应行为。&lt;/p&gt;&lt;p&gt;在&lt;code&gt;Reactor&lt;/code&gt;框架中用两个类来表示&lt;code&gt;Publisher&lt;/code&gt;，分别是&lt;code&gt;Flux&lt;/code&gt;和&lt;code&gt;Mono&lt;/code&gt;。&lt;code&gt;Flux&lt;/code&gt;表示&lt;code&gt;0...N&lt;/code&gt;个元素序列；&lt;code&gt;Mono&lt;/code&gt;表示零或一个元素序列。&lt;/p&gt;&lt;p&gt;&lt;code&gt;Flux/Mono&lt;/code&gt;可以发布三类值 正常数值，异常信号，完成信号。三类信号不会同时存在，最多同时发布两类信号。&lt;/p&gt;&lt;p&gt;举个例子，我们假设让&lt;code&gt;Flux&lt;/code&gt;发射一个&lt;code&gt;1-6&lt;/code&gt;的&lt;code&gt;6&lt;/code&gt;个整数的数字流，&lt;code&gt;6&lt;/code&gt;个数字流发送完成后，会紧跟着发送一个完成信号，告诉订阅者或者观察者，数据流完成。同样的，如果发送正常数据的过程中出现异常，也可以发送一个异常信号给订阅者或者观察者，表示出现异常，将停止发送。异常信号和完成信号不能同时存在，因为出现任何一个该数据流都将结束。但是信号流里面可以即没有异常信号也没有完成信号，这表示该流是一个无限流。&lt;/p&gt;&lt;p&gt;&lt;code&gt;Flux.just(1,2,3,4,5,6)&lt;/code&gt;&lt;/p&gt;&lt;p&gt;上面这行代码表示发布者发布了&lt;code&gt;6&lt;/code&gt;条消息，下面我们订阅者&lt;code&gt;6&lt;/code&gt;条消息，也就是对这&lt;code&gt;6&lt;/code&gt;条消息进行响应。&lt;/p&gt;&lt;p&gt;&lt;code&gt;Flux.just(1,2,3,4,5,6).subscribe(System.out::print)&lt;/code&gt;&lt;/p&gt;&lt;p&gt;在控制台将会打印出&lt;code&gt;1，2，3，4，5，6&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;em&gt;注意，只有订阅的时候才会对事件或者元素进行响应。&lt;/em&gt;&lt;/p&gt;&lt;p&gt;上面的例子，我们对元素或者事件没有做任何操作，仅仅是将它们原封不动的打印了出来，这显然不是我们想要的。接下来我们对元素做一些有意义的操作。&lt;/p&gt;&lt;h6&gt;&lt;span&gt;操作符&lt;/span&gt;&lt;/h6&gt;&lt;p&gt;&lt;strong&gt;map&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;对数据流里面的每个元素执行一次&lt;code&gt;map&lt;/code&gt;里面的函数。示意图如下&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.436435124508519&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/jmjNkE9L9Qj3BBuIm0thug2dxWLt6G0rm5z1TMpTkh7kmH1Io82xzkWJ4gO1v1ichapYqzcthFPJKciajezMw0aQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;763&quot;/&gt;&lt;/p&gt;&lt;p&gt;代码示例&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Flux.range(1,6).map(i -&amp;gt; i*i).subscribe(System.out::println);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;将会输出 &lt;code&gt;1 4 9 16 25 36&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;flatmap&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;该操作符逻辑上包含两个操作，第一个操作是&lt;code&gt;map&lt;/code&gt;操作，第二个是&lt;code&gt;flatten&lt;/code&gt;，&lt;code&gt;flatten&lt;/code&gt;类似于&lt;code&gt;merge&lt;/code&gt;操作，将对每个元素进行映射之后，合并成一个新的流。示意图如下。&lt;/p&gt;&lt;figure&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4364963503649635&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/jmjNkE9L9Qj3BBuIm0thug2dxWLt6G0r1cVemJ1wb5ELmUGkaPM6z2q4dCGWjY1HicK2E8fl0JChjeuEZM4dToA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;685&quot;/&gt;&lt;/p&gt;&lt;/figure&gt;&lt;p&gt;代码示例&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Flux.just(&quot;apple-1&quot;,&quot;pear-2&quot;).flatMap(i -&amp;gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Flux.fromArray(i.split(&quot;-&quot;))).subscribe(System.out::println);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;以上代码将会输出 &lt;code&gt;apple 1 pear 2&lt;/code&gt;；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;filter&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;过滤出符合条件的元素。&lt;/p&gt;&lt;p&gt;代码示例&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Flux.range(1,6).filter(i -&amp;gt; i&amp;gt;3).subscribe(System.out::println)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;以上代码将会输出 &lt;code&gt;4,5,6&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;zip&lt;/strong&gt; &lt;code&gt;zip&lt;/code&gt;英文单词有拉链的意思，在&lt;code&gt;Reactor&lt;/code&gt;中，表示将两个数据流合并到一起。示意图如下。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5100133511348465&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/jmjNkE9L9Qj3BBuIm0thug2dxWLt6G0rcChCXOVVlnvISRLPzzvJu41MUM8qscJn5glOc76ueg4jm9E44mXfTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;749&quot;/&gt;&lt;/p&gt;&lt;p&gt;示例代码&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Flux.zip(       &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Flux.just(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Flux.just(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    (x,y) -&amp;gt; x + y        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ).subscribe(System.out::println);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;以上代码输出 &lt;code&gt;A1 B2 C3&lt;/code&gt;&lt;/p&gt;&lt;p&gt;还有很多操作符这里不一一介绍了，感兴趣的可以看官网。&lt;/p&gt;&lt;h5&gt;&lt;span&gt;线程调度&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;&lt;code&gt;Reactor&lt;/code&gt;自然也是支持多线程的。而且多线程调度很简单。 &lt;code&gt;Reactor&lt;/code&gt;中创建线程是通过&lt;code&gt;Scheduler&lt;/code&gt;接口来表示的。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;//创建一个线程&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Scheduler single = Schedulers.single();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;//创建等于CPU核心数量的线程&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Scheduler parallel = Schedulers.parallel();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;//创建有界限的线程池，不传参数的默认创建10倍于CPU核心数量&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Scheduler elastic = Schedulers.boundedElastic();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;创建了线程，自然要分配线程，也就是线程调度。切换线程上下文主要通过&lt;code&gt;publishOn()&lt;/code&gt;和&lt;code&gt;subscribeOn()&lt;/code&gt;两个函数实现。&lt;/p&gt;&lt;p&gt;&lt;code&gt;publishOn()&lt;/code&gt;会影响调用该函数之后的操作。而&lt;code&gt;subscribeOn()&lt;/code&gt;会从源头影响整个操作链，无论&lt;code&gt;subscribeOn()&lt;/code&gt;调用发生在何处。&lt;/p&gt;&lt;p&gt;举个例子：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Flux.just(&quot;hello&quot;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    .map(s -&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            System.out.println(&quot;[map] Thread name: &quot; + Thread.currentThread().getName());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            return s.concat(&quot; world!&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        })&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    //只改变publishOn()之后的操作的线程。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    .publishOn(Schedulers.newSingle(&quot;thread-publishOn&quot;))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    .filter(s -&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            System.out.println(&quot;[filter] Thread name: &quot; + Thread.currentThread().getName());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            return s.startsWith(&quot;h&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        })&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    //从源头变整个操作链的线程&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    .subscribeOn(Schedulers.newSingle(&quot;thread-subscribeOn&quot;))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    .subscribe(s -&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                System.out.println(&quot;[subscribe] Thread name: &quot; + Thread.currentThread().getName());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                System.out.println(s);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;上面的代码输出结果是这样的&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;[map] Thread name: thread-subscribeOn-1&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;[filter] Thread name: thread-publishOn-2&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;[subscribe] Thread name: thread-publishOn-2&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;hello world!&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;建议各位把上面这段代码复制到本地运行一下，同时可以把&lt;code&gt;subscribeOn()&lt;/code&gt;和&lt;code&gt;publishOn()&lt;/code&gt;分别注释掉，感受一下区别。&lt;/p&gt;&lt;p&gt;这两个函数经常用于有阻塞操作的时候，将阻塞操作调度到新的线程，以便提高效率。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;响应编程解决哪些问题&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;响应式编程可以帮助解决两类棘手问题，第一个问题就是大家熟悉的&lt;code&gt;callback hell&lt;/code&gt;，第二个问题就是同步阻塞效率低的问题。&lt;/p&gt;&lt;p&gt;先说第一个问题，这里拿&lt;code&gt;reactor&lt;/code&gt;官方的例子做个说明，找出某个用户最喜爱的五个爱好。通过&lt;code&gt;Callback&lt;/code&gt;的方式实现是这样的。&lt;/p&gt;&lt;figure&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7304347826086957&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/jmjNkE9L9Qj3BBuIm0thug2dxWLt6G0rnl38MpoB3DOiczz5kMZsvFVIndeic7T0dHtJTU4Lia7DctTf3ZJhYXyDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1035&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;基于回调的服务使用一个匿名 &lt;code&gt;Callback&lt;/code&gt; 作为参数。后者的两个方法分别在异步执行成功或异常时被调用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;获取到&lt;code&gt;Favorite ID&lt;/code&gt;的&lt;code&gt;list&lt;/code&gt;后调用第一个服务的回调方法&lt;code&gt;onSuccess&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果 &lt;code&gt;list&lt;/code&gt; 为空， 调用 &lt;code&gt;suggestionService&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务 &lt;code&gt;suggestionService&lt;/code&gt; 传递 &lt;code&gt;List&amp;lt;Favorite&amp;gt;&lt;/code&gt; 给第二个回调。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;既然是处理 &lt;code&gt;UI&lt;/code&gt;，我们需要确保消费代码运行在 &lt;code&gt;UI&lt;/code&gt; 线程。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用 &lt;code&gt;Java 8 Stream&lt;/code&gt; 来限制建议数量为5，然后在 &lt;code&gt;UI&lt;/code&gt; 中显示。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在每一层，我们都以同样的方式处理错误：在一个 &lt;code&gt;popup&lt;/code&gt; 中显示错误信息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;回到&lt;code&gt;Favorite ID&lt;/code&gt;这一层，如果返回 &lt;code&gt;list&lt;/code&gt;，我们需要使用&lt;code&gt;favoriteService&lt;/code&gt; 来获取 &lt;code&gt;Favorite&lt;/code&gt;对象。由于只想要5个，因此使用 &lt;code&gt;stream&lt;/code&gt; 。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;再一次回调。这次对每个&lt;code&gt;ID&lt;/code&gt;，获取 &lt;code&gt;Favorite&lt;/code&gt; 对象在 &lt;code&gt;UI&lt;/code&gt; 线程中推送到前端显示。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;采用&lt;code&gt;Reactor&lt;/code&gt; 响应式编程代码大概应该是这个样子的&lt;/p&gt;&lt;figure&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.20206766917293234&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/jmjNkE9L9Qj3BBuIm0thug2dxWLt6G0rVspK0ndow4DakSp2bMnW8njp6LvbDErVHzlotG9XDPl9pZCsFFcbRA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1064&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;我们获取到&lt;code&gt;Favorite ID&lt;/code&gt;的流。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我们 异步地转换 它们(ID)为 &lt;code&gt;Favorite&lt;/code&gt; 对象（使用&lt;code&gt;flatMap&lt;/code&gt;），现在我们有了&lt;code&gt;Favorite&lt;/code&gt;流。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一旦 &lt;code&gt;Favorite&lt;/code&gt; 为空，切换到 &lt;code&gt;suggestionService&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我们只关注流中的最多5个元素。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后，我们希望在 &lt;code&gt;UI&lt;/code&gt; 线程中进行处理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过描述对数据的最终处理（在 &lt;code&gt;UI&lt;/code&gt; 中显示）和对错误的处理（显示在 &lt;code&gt;popup&lt;/code&gt; 中）来触发（&lt;code&gt;subscribe&lt;/code&gt;）。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;可以看到通过采用响应式编程，大大提高了代码的可读性，逻辑表达也更清晰。&lt;/p&gt;&lt;p&gt;再&lt;span&gt;来看第二个问题，同步阻塞通常被认为是低效率的。而异步非阻塞被认为是高效率的。而响应式编程，天生就是异步非阻塞的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;来举个简单例子说明一下，为什么同步阻塞是低效率的而异步非阻塞是高效率的。&lt;/p&gt;&lt;p&gt;同步和异步描述的是服务提供者提供服务的能力。当调用者向服务者发起请求后，服务提供者能够立即返回，并且在处理完后通过某种方式通知调用者，那么就是异步的。相反如果服务提供者只在处理完之后才返回，或者要求调用者主动去查询处理结果，就是同步。&lt;/p&gt;&lt;p&gt;阻塞和非阻塞描述的是调用者的状态。当调用者向服务提供者发起请求后，一直等待处理结果返回，否则无法执行后续操作，就是阻塞状态。如果调用后直接返回，继续执行后续操作就是非阻塞状态。&lt;/p&gt;&lt;p&gt;上面提到的打电话的例子就是异步非阻塞的例子，你给旅行社打电话，预定一张机票。旅行社接线员收到你的请求，就立刻给你回复(异步)，告诉你请求已经收到，稍后会通知你。然后你就挂掉电话，去处理其他事情(非阻塞)，等旅行社预定好之后，会立刻给你打电话通知你结果。&lt;/p&gt;&lt;p&gt;如果是同步阻塞的话，场景应该是这样的，你给旅行社打电话预定机票，接线员接听你的电话，然后处理订票请求，你在电话另一端一直在等待，什么都做不了。更可怕的是，其他旅客的订票请求一直打不进来，因为线路资源一直被你占用。这将是多么低效的处理方式。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;响应式编程虽好，但并不是包治百病，首先掌握起来就有一定难度，同时&lt;code&gt;Debug&lt;/code&gt;也需要有一定的相关经验。更主要的是，我们要根据业务场景来决定响应式编程是否能给我们带来真正的好处。记住软件工程里面，没有银弹。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMzE4MDY0Nw==&amp;amp;mid=2247484022&amp;amp;idx=1&amp;amp;sn=d3176ea73e48360b64c3f50e8fd622bf&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;1. Java并发编程那些事儿(十)——最后的总结&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMzE4MDY0Nw==&amp;amp;mid=2247484130&amp;amp;idx=1&amp;amp;sn=eb09dd99d1a8e892a3de73d898c04b0c&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;2. 程序员应该掌握的常用网络问题定位工具&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMzE4MDY0Nw==&amp;amp;mid=2247483893&amp;amp;idx=1&amp;amp;sn=85f6a2063048cc244aedde3172444e32&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;3. Awk这件上古神兵你会用了吗&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMzE4MDY0Nw==&amp;amp;mid=2247483852&amp;amp;idx=1&amp;amp;sn=6efb0db3d5dff639fae2aaec978c2160&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;4. 手把手教你搭建一套ELK日志搜索运维平台&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>