<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>ce2c83d4ba2ee7618bec3c90ae4921e0</guid>
<title>10+ 条 Go 官方谚语，你知道几条？</title>
<link>https://toutiao.io/k/t267uv1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p data-track=&quot;1&quot;&gt;&lt;span&gt;作为一个 Go 语言开发工程师，总是在入门、深入、撕提案时能够听到各种带有 Go 特色的话语，例如：少即是多（less is more），非常有趣。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;2&quot;&gt;&lt;span&gt;今天带来了 Go 语言之父 Rob Pike 在 2015 年分享的主题《Go Proverbs》，它在该主题中讲了的 10+ 条 Go 谚语，希望大家可以用上。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;3&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;核心理念&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;是：简单、诗意、简洁（Simple, Poetic, Pithy）。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;不要通过共享内存来通信，通过通信来共享内存（Don&#x27;t communicate by sharing memory, share memory by communicating）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;并发不是并行（Concurrency is not parallelism）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;通道是协调的，互斥是串行的（Channels orchestrate; mutexes serialize）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;接口越大，抽象性越弱（The bigger the interface, the weaker the abstraction）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;让零值变得有用（Make the zero value useful）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;interface{} 什么也没说（interface{} says nothing）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Gofmt 的风格没有人喜欢，但 Gofmt 却是大家的最爱（Gofmt&#x27;s style is&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;no one&#x27;s favorite, yet gofmt is everyone&#x27;s favorite）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;复制一点总比依赖一点好（A little copying is better than a little dependency）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Syscall 必须始终用 build 标签来保护（Syscall must always be guarded with build tags）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Cgo 必须始终用构建标签来保护（Cgo must always be guarded with build tags）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Cgo 不是 Go（Cgo is not Go）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;使用 unsafe 包没有任何保证（With the unsafe package there are no guarantees）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;清晰的比聪明的好（Clear is better than clever）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;反射从来不是清晰的（Reflection is never clear）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;错误就是价值（Errors are values）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;不要只是检查错误，要优雅地处理它们（Don&#x27;t just check errors, handle them gracefully）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;设计架构，命名组件，记录细节（Design the architecture, name the components, document the details）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;文档是为用户准备的（Documentation is for users）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;不要使用恐慌（Don&#x27;t panic）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;Rob Pike 在演讲中所涉及到的这 18 条谚语，是他常年在计算机软件领域开发和设计 Go 时所积累下来的经验。（希望能够对你有所帮助）&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;END&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;br/&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA4ODg0NDkzOA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/vbERicIdYZbC53rq7PQziczkzCA4pIPx8Xdx2r0a6FgQWEicTOgFNY1KlJD3jSKQKlTiavwTUgHS1HMXza2RYApkDw/0?wx_fmt=png&quot; data-nickname=&quot;GoCN&quot; data-alias=&quot;golangchina&quot; data-signature=&quot;最具规模和生命力的 Go 开发者社区&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;-猜你想看-&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;想要了解Go更多内容，欢迎扫描下方👇 关注 公众号，回复关键词 [实战群]  ,就有机会进群和我们进行交流~&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5763688760806917&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vbERicIdYZbDrrBk1KBPqY1QNI320ZK2IIycDa77FcDQAeAFJRVb240xr8biceh23auy7ZpPibEYXPNOnmfsEewkw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;694&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;分享、在看与点赞，至少我要拥有一个叭~&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img __bg_gif&quot; data-ratio=&quot;0.2106667&quot; data-type=&quot;gif&quot; data-w=&quot;750&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/vbERicIdYZbB79dKphkWU3rVKFiaZGWHEic0qXJ8QAeF6XRTLwTCEgUxxiamV13wPv9kMtaqrOtsrVibdHzvYiaxCwgA/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.696&quot; data-type=&quot;gif&quot; data-w=&quot;500&quot; class=&quot;__bg_gif&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/vbERicIdYZbB79dKphkWU3rVKFiaZGWHEicOoCY9eHaUhZY0vkZibusOg9ibjGibicfyjHiaWfkN9QOiclK2DnfLh4KYTLA/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e96ca66efcbad62d42ed671744356375</guid>
<title>Camel入门及原理分析</title>
<link>https://toutiao.io/k/tf5fz0a</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Camel最核心的功能就是提供路由引擎。你可以自己定义路由规则，包括从哪里接收消息，怎么处理消息，发给哪个目标。最关键的是你去集成各种系统而不用关心怎么转换数据格式，也不用关心通讯协议是什么。Camel的组件有去实现不同协议和数据类型的API，开箱即用，现在已经支持超过8&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;种的协议和数据类型。&lt;/span&gt;&lt;span&gt;Apache ServiceMix 和 ActiveMQ 已经使用 Camel 作为进行企业&lt;/span&gt;&lt;span&gt;级&lt;/span&gt;&lt;span&gt;集成的一种方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有的人说Camel是一个轻量级的ESB（&lt;/span&gt;&lt;span&gt;Enterprise Service Bus&lt;/span&gt;&lt;span&gt;），因为它有路由功能、转换功能、监控功能、编排功能等等，但是它并没有容器和可靠的消息总线，所以其实它并不能算是一个ESB服务。但是它可以部署到Open&lt;/span&gt;&lt;span&gt;-ESB&lt;/span&gt;&lt;span&gt;上，比如Service&lt;/span&gt;&lt;span&gt;Mix&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Domain-Specific Language (DSL)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DSL的目的是让开发人员关注功能集成的过程而不是工具本身。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;Java DSL&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__title&quot;&gt;from&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;file:data/inbox&quot;&lt;/span&gt;&lt;/span&gt;).&lt;span class=&quot;code-snippet__title&quot;&gt;to&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;jms:queue:order&quot;&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Spring DSL&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;route&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; uri&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;file:data/inbox&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;to uri=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;jms:queue:order&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/route&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Scala DSL&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;file:data/inbox&quot;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;jms:queue:order&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面这个例子可以很简单的将某个文件夹的文件发送到JMS消息队列里。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;简单的配置&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;file:data/inbox?recursive=true&amp;amp;include=*.txt&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;这句话表示循环从文件夹下面读取txt文件。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Camel有内建的类型转换机制，包含了1&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;&lt;span&gt;多种转换器，比如从字节数组转换成字符串，你不用配置转换器。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;拷贝文件的需求&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;shape type=&quot;#_x0000_t75&quot; filled=&quot;f&quot;&gt;&lt;imagedata title=&quot;image1&quot;/&gt;&lt;/shape&gt;&lt;img data-ratio=&quot;0.39338235294117646&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ol23aUXIU7OzH8dUxa4U3zcoMM3IQkzGE6TvibszXU9UfgoIExFCicUgicmic5szwIz4Hgic6SpE7QKuHKQiaNqEmWzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;544&quot;/&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;将data/&lt;/span&gt;&lt;span&gt;inbox&lt;/span&gt;&lt;span&gt;拷贝到data&lt;/span&gt;&lt;span&gt;/outbox&lt;/span&gt;&lt;span&gt;下，noop&lt;/span&gt;&lt;span&gt;=true&lt;/span&gt;&lt;span&gt;，表示保留源文件，如果不加则表示移动文件到指定目录，原文件夹的文件会不在。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;消息模型&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Camel有2个抽象出来的消息模型。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;org.apache.camel.Message&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;基础的消息实体类，包含携带和路由的数据。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;org.apache.camel.Exchange&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;为交换的消息抽象出来的类，包含了“in”和“out”2个对象。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Exchange跟普通的“请求-响应”模式不太一样。Exchange支持“&lt;/span&gt;&lt;span&gt;InOnly&lt;/span&gt;&lt;span&gt;”、“InOut”两种模式。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;InOnly&lt;/span&gt;&lt;span&gt;”-只支持单方向的发送消息&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“InOut”-请求-响应式的发送消息&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Exchange内部的结构如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;1.1491935483870968&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ol23aUXIU7OzH8dUxa4U3zcoMM3IQkzG3g7aLRUZpMRLicNRERglRCLhfgfibia040EBsoBvrIXme2umVkTCOrlYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;248&quot;/&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有了上面的基础概念，我们可以开始看看Camel的架构。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.4602888086642599&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ol23aUXIU7OzH8dUxa4U3zcoMM3IQkzG0kFGru0sGAxAlGAOmey5XmNGbYjMUib8EQ9iabn4d2w9d5lFqqW4ZicIw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Camel由p&lt;/span&gt;&lt;span&gt;rocessor&lt;/span&gt;&lt;span&gt;、component、route三部分组成，而CamelContext又包含了这三部分。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;R&lt;/span&gt;&lt;span&gt;oute决定了路由的规则，通过Camel的DSL（Doman-specific&lt;/span&gt;&lt;span&gt; languages&lt;/span&gt;&lt;span&gt;）定义路由规则。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Porcessor用来转换和处理消息，在DSL中也有对应的关键字来指定processor。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Component用来拓展跟其他系统的连接。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Endpoint&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Endpoint相当于是一个借口的切入点，Endpoint&lt;/span&gt;&lt;span&gt; URI&lt;/span&gt;&lt;span&gt;的格式如下：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.4110169491525424&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ol23aUXIU7OzH8dUxa4U3zcoMM3IQkzGFOqfbibbJt8Gt998pY1ib9mlGwywjQGBFGpQVpgjdvD62esQ0vFWNOIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;236&quot;/&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;生产者和消费者&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;前面说到Endpoint已经指定好消息接收的uri，消息接收后可以通过processor加工处理，也可以发给下游。那消息的来源是哪里？这里就涉及生产者和消费者的概念了。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;生产者发送消息到指定的Endpoint&lt;/span&gt;&lt;span&gt; uri&lt;/span&gt;&lt;span&gt;，再由&lt;/span&gt;&lt;span&gt;route&lt;/span&gt;&lt;span&gt;指定后续的处理，这个后续处理的角色我们就叫Consumer。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有了以上的理解，我们可以回过头来看前面拷贝文件的代码示例。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.4599236641221374&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ol23aUXIU7OzH8dUxa4U3zcoMM3IQkzGJIleZ9dasVEJc7jESR0Zx8DjPMcmWumB0qBMxTb8AVBurZHImaiavfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;524&quot;/&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里的U&lt;/span&gt;&lt;span&gt;RI&lt;/span&gt;&lt;span&gt;是“file:&lt;/span&gt;&lt;span&gt;/data/inbox?noop=true&lt;/span&gt;&lt;span&gt;”,表示routes从/&lt;/span&gt;&lt;span&gt;data/inbox&lt;/span&gt;&lt;span&gt;路径监听文件消息，这个时候如果你放一个文件到这个目录下你就相当于生产者，camel接收到这个文件后没有调用processor做中间的加工，而是直接通过to将消息发送到“data&lt;/span&gt;&lt;span&gt;/outbox&lt;/span&gt;&lt;span&gt;”路径，这里的消息就是你放进去的文件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;精选推荐：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;578&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Ol23aUXIU7PwUiboz6yDJLEEDkBY81gYxBLIedbtEJnDAsJXuiaSKfB7uhwtm6DcRV1Z0JkEicyZp23EefI4cBPnA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;*本文为IT技术栈原创文章，独家版权归于本平台，受到原创保护。任何渠道的转载请后台留言联系授权，侵权必究。&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f1ef2e7ae763c7dfe0bbc662ef77adbe</guid>
<title>RocketMQ 5.0: 存储计算分离新思路</title>
<link>https://toutiao.io/k/ju1gfga</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.625&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naLvgXTzRAjN8pDiaNqib6oqib9ocrPM2nazG4nEbiaVDzBfmd3BKJfbl6Kia6r6Cf8dVRJa8v660Qzj9CQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Apache RocketMQ 自 2012 年开源以来，因其架构简单、业务功能丰富、具备极强的可扩展性等特点被广泛采用。RocketMQ 在阿里巴巴集团内部有着数千台的集群规模，每天十万亿消息流转的规模。在阿里云上，RocketMQ 的商业化产品也以弹性云服务的形式为全球数万个用户提供企业级的消息解决方案，被广泛应用于互联网、大数据、移动互联网、物联网等领域的业务场景，成为了业务开发的首选消息中间件。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;尽管消息中间件 RocketMQ 在阿里巴巴和开源社区已经走过了十多个年头，但在云原生浩浩荡荡的浪潮下&lt;/span&gt;&lt;span&gt;，我们开始对 RocketMQ 的架构有了一些新的思考。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;痛点与困局&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;阿里巴巴有大规模实践 RocketMQ 的生产经验，自 RocketMQ 从 2016 年对外商业化以来，一直延续跟集团消息中间件相同的架构为云上的客户提供全托管的消息服务，发展至今，消息队列 RocketMQ 在云上已经具备相当大的业务规模。随着业务的发展，这套极简的分布式架构在云原生环境下逐渐显露出了一些不足，比如，运维成本增加、效率降低。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0709987966305656&quot; data-type=&quot;png&quot; data-w=&quot;831&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJnngbClwBdsKDxwSbicOfR3fYZA5351Qu0ZMTxmK73hIKaMfbdu6AySzfriayVlNwONruxoboficucA/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;集团消息中间件通过存储计算一体化的部署架构，为集团电商业务提供了高性能、低延迟、低成本的消息服务。随着云的进化，云开始变得更加弹性，网络环境更加复杂，云原生时代对效率也有了更高的要求，我们也迎来了对云上消息架构进行云原生化改造的契机。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上图是目前RocketMQ在云上部署的一个简化版架构（仅包含最核心的组件），这套部署架构近年来在云上遇到的主要痛点有以下几点：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;01&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;富客户端形态&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;RocketMQ 的用户需要借助官方提供的 SDK 使用云上的服务，这是一个比较重量级的富客户端，提供了诸如顺序消费、广播消费、消费者负载均衡、消息缓存、消息重试、位点管理、推拉结合、流控、诊断、故障转移、异常节点隔离等一系列企业级特性。RocketMQ 的富客户端极大地降低了集团内客户的接入成本，一站式助力集团客户构建高韧性、高性能的消息驱动应用，但云上的富客户端有一些不足：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;02&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;计算存储一体化&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Broker 是 RocketMQ 最核心的节点，承担了服务端所有的计算和存储逻辑，其核心能力为：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;计算存储一体化的 Broker 具备以下优点：部署结构简单、开源用户可以开箱即用；部署节点少，低成本支持集团双十一万亿级的消息规模；数据就近处理，无中间环节，性能高，延迟低。但一体化的 Broker 在云环境也有其局限性：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;03&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;客户端与Broker直连&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;RocketMQ 当前的用户通过客户端直接与 Broker 进行通信，链路是最短化的，运维简单、延迟低，但这样的设计无法很灵活地适配网络极其复杂的云环境，网络上有经典网络、VPC 网络、公网，部署环境上有 OXS 区、售卖区，为客户暴露每一个 Broker 节点带来了运维上的负担：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;基于这个大背景，阿里云消息团队对 RocketMQ 在云上进行了云原生架构升级专项，实践存储计算分离的新架构，同时引入基于gRPC 的全新多语言解决方案&lt;/span&gt;&lt;span&gt;，来加速消息中间件的云原生化。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;存算分离新思路&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;如何在云上实践存算分离，如何探索出一个适合 RocketMQ 三位一体的新架构，是 RocketMQ 进行云原生架构升级主要考虑的点，这里面有很多现实因素的考量：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于第一个问题，实践的结果已经告诉我们架构简单的优异性，但在云上遇到的痛点又告诉我们存算分离势在必行，可见存储与计算要不要分离，并不是一个非此即彼的选择，架构上的选择是否能都要呢？对于这个问题，我们的解法是存储计算需要做到可分可合：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于第二个问题，在阿里云上有多个自研的不同协议标准的消息服务，如何通过单一架构支持多产品形态至关重要，将 RocketMQ 的核心业务消息的能力无缝复制到多个产品，放大业务价值。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;总而言之，架构层面的核心理念是以存储计算架构分离为切入点，进一步探索单一架构多产品形态，以降低消息子产品的重复建设，最终也需要实现存储与计算可分可合的部署形态，同时满足云上的运维灵活性以及开源、集团等部署简单、高性能的需求。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;01&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;存储计算分离架构&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;RocketMQ 5.0 在架构上的第一个升级便是存储计算分离改造，通过引入无状态的 Proxy 集群来承担计算职责，原Broker 节点会逐步演化为以存储为核心的有状态集群，同时会重新研发一批多语言的瘦客户端来解决富客户端带来的诸多问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8784596871239471&quot; data-type=&quot;png&quot; data-w=&quot;831&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJnngbClwBdsKDxwSbicOfR3aiavPLVXdfQ4ev3sb1tQiaMu0wgwW4JT0icibeQ7S2JGicZstAYd3ZGuLPg/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上图是一个存储计算分离架构的简图，图中借用了 Service Mesh 关于控制和数据面的划分思想以及 xDS 的概念来描述，架构中各个组件的职责分别为：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;存储计算分离带来的额外成本主要是延迟和成本。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;简而言之，在云上环境，云服务形态的 RocketMQ 非常适合存储计算分离架构。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;02&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;存储计算合并架构&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;但从本质来讲，存储计算分离与就近计算和就近存储的理念是冲突的。存储计算一体化的架构在云上带来了困扰，本质还是因为云上是一个多租户的环境，存储计算一体化在多租户的场景下灵活性不够。但很多场景往往都是小规格单租户，其实更适合存储计算一体化。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了云外云内都能统一技术方案，我们更加期望的一种机构是存储与计算可分可合的部署形态，分开部署是计算节点完全无状态，运维迭代极其简单，合并部署时更原架构体验保持一致。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但无论采用什么样的部署架构，存储和计算的分离都是一种良好的模块化设计方式，在编程层面的分开是必须要进行的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.44765342960288806&quot; data-type=&quot;png&quot; data-w=&quot;831&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJnngbClwBdsKDxwSbicOfR3PcPawz81jSezm0YNUyzTsylrLptbeSvuSNQia649ffholEwxztojHwA/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如上图所示，左边是云上一个分离部署的形态，右边是合并部署的形态，合并部署时计算节点可以作为存储节点的SideCar，采用网格的思想进行部署，也可以将计算和存储揉进同一个进程进行部署。实际上，我们在实践的过程中，通过对代码进行充分设计，Proxy 节点可以通过构造器构造出「Local」和「Cluster」部署两种形态，分别对应合并部署和分离部署的两种架构形态。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;03&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;单一架构多产品形态&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;《云原生时代消息中间件的演进路线》一&lt;/span&gt;&lt;span&gt;文中提到，阿里云消息团队目前有业界最丰富的消息产品矩阵，包括消息队列 RocketMQ、消息队列 Kafka、微消息队列 MQTT、消息队列 AMQP、消息服务 MNS、事件总线EventBridge。丰富的产品矩阵是团队多年来践行多样性和标准化演进路线的结果，所有的消息子产品目前都构建在RocketMQ 存储内核之上，非常具备统一架构的前提。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5415162454873647&quot; data-type=&quot;png&quot; data-w=&quot;831&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJnngbClwBdsKDxwSbicOfR3TPteUJDWWiborMib99dH7lKL5dRL3e3RteR8UiazvPcuHlibASAJwTbaag/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;通过单一的存储计算分离架构，支持多产品的业务形态，是云原生消息探索的一个重要方向。这种单一架构多产品形态会带来诸多好处，比如计算节点共建，通过模型抽象支持多业务模型，多通信协议，释放重复建设的人力。通过存储节点并池，各产品打通内部存储节点，形成资源池合并，统一运维和管控，有助于降低成本、提高效率，加速存储创新，孵化消息中台。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.184115523465704&quot; data-type=&quot;png&quot; data-w=&quot;831&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJnngbClwBdsKDxwSbicOfR3d27We7XSlxqnMEiaIDAXTvsGkL7ywDhpIpMkt4kNlFiaeZhib7251Vicpg/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如上图所示，单一架构多产品形态的核心先统一存储和计算，并进一步统一管控和运维，真正做到一套架构支撑多个云产品。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h1&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;目前，阿里云消息队列 RocketMQ 实践存储计算彻底分离的架构还处于第一个过渡阶段，未来的路还很长，我们会投入至少 1 年的时间在公有云环境全面落地存储计算分离架构，让消息服务更弹性、更云原生，让团队提高效率，加速业务创新。&lt;/span&gt;&lt;span&gt;我们期望新的架构能稳定服务于未来至少 5 年的业务增长，同时，存算可分可合的部署架构也能够非常好地支撑不同规模开源用户的个性化需求，让 Apache RocketMQ 开源社区能够整体收益于存算计算可分可合架构的新形态。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;RocketMQ从诞生第一天起就在GitHub上开发的开源项目，也是中国第一个非Hadoop生态的Apache顶级项目。它统一了阿里集团内部所有业务线的消息中间件，伴随着中国互联网发展数次迭代。《十万亿条消息背后的故事》记录了RocketMQ从诞生、开源到发展至今背后鲜为人知的故事。通过「开源人说」的娓娓道来，让我们一起来了解分布式消息中间件Apache RocketMQ背后的人与事！点击观看《十万亿条消息背后的故事》&lt;/span&gt;&lt;span&gt;https://developer.aliyun.com/live/249109&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;hr/&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;❖&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;《开源人说》为阿里云开发者社区与InfoQ 联合出品的一档精品开源视频栏目。栏目围绕四大开源领域：云原生、操作系统、数据库、大数据&amp;amp;AI，介绍优秀的开源软件背后的故事，记录传播技术人追求极致和开放共享的精神。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;点击阅读原文了解《开源人说》！&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>56e88cde56b85469cf21036375c2047a</guid>
<title>爱奇艺内容中台之数据中心的设计与实现</title>
<link>https://toutiao.io/k/yief2yo</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;h3 data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;互联网技术发展至今，当业务复杂度比较高的时候，采用微服务化是一个有效的手段，但是随着服务的拆分，数据管理工作变得极具挑战。数据中心(OLTP)通过对数据的统一收集和管理，一方面可以建立数据之间的联系，从而带来更大的价值；另一方面还可以提供强大的数据阅览、数据分析、挖掘数据等能力，进而为企业创造价值收益。数据中心(OLTP)不仅可以为不同业务线屏蔽技术难点，还可以降低业务逻辑开发的复杂度，使得开发同学能够专注于业务逻辑的开发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;利用数据中心(OLTP)整合不同业务线的数据，解决数据孤岛问题已经是各个互联网企业的必用手段。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;本文将分享爱奇艺内容中台数据中心(OLTP)的设计与实现。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;01&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;   &lt;span&gt;方案设计与实现&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;之前各个业务线自己维护自己的数据和接口，这样既不利于第三方的接入，也浪费了人力进行重复建设，为了解决诸多类似问题，我们进行了如下设计。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;  2.1 方案设计目标  &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;首先我们梳理了目前系统存在的各种亟待解决的问题：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1．数据孤岛：无法全面的看到内容运营的所有数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2．重复建设：各业务团队均需具备同样能力的服务建设&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3．对接复杂：各业务团队接口规范不统一，增加对接难度&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4．耦合严重：各业务团队因需要共享数据，导致服务严重互相依赖&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5．开发繁琐：各业务团队需要考虑自研数据中心(OLTP)的技术痛点和难点，无法做到专人做专事，即业务开发只关注自身&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了满足业务长远的发展，我们还制定了一些需要达到的目标：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1．支持百亿级数据的存储&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2．支持高QPS的读、写请求&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3．统一的字段变化消息通知&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4．极少的运维成本，页面操作添加字段&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5．通用的查询与保存能力，避免个性化需求带来的额外开发成本&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;  2.2 业务架构图  &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;基于以上的目标我们设计了内容中台数据中心的业务架构，如下图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8872549019607843&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;408&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/unymlvueOvuA8iaDc3HLqWgicYUSnrDVB98UlxfYr76XX6ibLjMlH5OmEXiamh3BbqSMqbPJ5c9sSX853K47Xjyzpw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图1数据中心(OLTP)业务架构图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据写入方统一将数据写到数据中心(OLTP)，然后数据中心(OLTP)统一对外广播字段的变化，其它业务方监听自身关心的字段变化。同一个业务方既可以是写入方也可以是读取方。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;  2.3 数据一致性方案  &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;由于数据中心(OLTP)将数据分别存储到了MongoDB和ES，这样就引入了数据一致性的问题。为了解决这个问题我们调研了业内的一些方案最终选定了最终一致性的方案。具体设计如下图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.2811387900355873&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;562&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/unymlvueOvuA8iaDc3HLqWgicYUSnrDVB9SK5vrAbQYf107sDgVzd6SvribicvUDGQJtLAgSYYxeUh9bndNSN5FvBg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图2数据一致性方案设计图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了避免脏数据的产生，我们设计字段权限控制，字段有归属的业务方，非归属的业务方没有权限写入该字段。由于实际使用场景中，我们大量使用ES查询数据，所以我们设计了MongoDB字段与ES字段的映射，业务方只需要分别创建MongoDB和ES的字段元数据，并建立好两者之间的映射关系。在投递数据的时候只需要投递一份原始数据，我们即可保存到MongoDB和ES中。为了避免ES中字段的相互覆盖问题，我们采取的方案是查询MongoDB中的最新数据并根据映射关系转化为ES结构，然后将ES中对应的文档进行整体覆盖。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;  2.4 数据高可用方案  &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;数据中心(OLTP)存储着业务的关键数据，其重要性不言而喻，所以一定要保证服务的高可用，所以我们设计了高可用的方案，具体如下图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.44041450777202074&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;965&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/unymlvueOvuA8iaDc3HLqWgicYUSnrDVB9c6FiaYJNTqQYnO8XVDJamiab9544I48bWLFPfHwJzicTU7U1u4238OGYg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图3数据高可用方案设计图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;方案中为了支持海量数据存储采用了分布式文件的存储能力。分片MongoDB集群采用同城多地部署，达到同城多活的效果，以提升集群的容灾能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了避免单点问题，我们设计了实时数据备份，利用服务配置化双写能力，将数据写入备份集群。代码层面设计数据库切换开关，以支持主集群不可用后，可以方便的切换至备份集群，从而达到数据高可用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了满足数据报表等大数据处理需求我们规划了离线数仓，充分利用MongoDB的备用集群能力。在日常使用中，备用集群可以为大数据平台和离线数仓提供数据支撑。离线数仓可以通过指定时间读取备用集群数据，如将9时、12时、18时共3份快照（可根据业务自身的特征自定义快照时间）进行备份。可依据离线数仓数据来恢复指定时间点的数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;  2.5 海量数据存储方案  &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;随着互联网的高速发展，很多业务场景的数据量都达到了上亿的级别甚至更多，这就涉及到了海量数据的存储问题。由于我们的业务场景也达到了上亿的级别，所以我们设计了海量数据存储方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;DB层面：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;DB层面使用分布式文件存储的DB，详见2.4中MongoDB的分片集群，支持横向扩展，可以支撑大数据量存储，且性能仅受限于单分片collection的数据量级。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;ES层面：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;ES在创建index时需要指定索引的分片个数，一旦创建后不可修改，所以我们在创建索引时需要评估好该索引的数据量级与增长趋势。当索引单分片的数据量级过大，会导致性能急剧下降，此时我们可以使用ES的reIndex API进行索引重建，但该操作会最大程度占用ESserver端的服务资源，导致影响正常业务。为了解决此类问题我们可以利用ES的别名Alias + 分库分表的思路，设计出支持不受数据量级限制的ES索引。ES的别名下可挂载多个真实的索引名，而我们按照一定的规则对索引数据进行拆分，将数据写入到拆分后的真实索引中，而真实索引挂在在同一个别名下，这样可以做到读业务方无感知的效果。但是ES的别名并不具备写入能力（别名下多个索引时），所以我们需要自己执行路由规则，进行索引拆分和写入。具体设计方案如下图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.35756056808688386&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1197&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/unymlvueOvuA8iaDc3HLqWgicYUSnrDVB9288AJmh8WicXuibeoiaSVZS1p45Jx8vyH39yxrzZftTLaWfm47Lu62BEA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图4ES索引拆分写入与查询流程图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;02&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;   &lt;span&gt;最佳实践&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;h4&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h4&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;  3.1 标准化、通用化消息通知  &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;为了解决各业务团队因需要共享数据，导致服务严重互相依赖的问题，我们设计了标准化、通用化的消息通知机制。用户只需要引入数据中心(OLTP) SDK ，并做简单的配置，便可监听到指定字段发生变化时的消息，以触发自身的业务逻辑。数据中心(OLTP)消息通知 SDK 设计图如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.1537290715372908&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;657&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/unymlvueOvuA8iaDc3HLqWgicYUSnrDVB9kpLDbCBicNQ6gVTjw108Xa1g8kWfva1RSlibNRHJGd5q5YKicVeITmCPA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图5 消息通知SDK设计图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当数据中心(OLTP)的字段发生变化时，会向RMQ 消息队列投放相关信息；SDK根据业务方配置信息会订阅 RMQ 消息队列，并根据用户的订阅配置，过滤掉用户不关心的消息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;SDK设计的关键点：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一、将RMQ封装起来，降低业务方的复杂度；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;二、轻服务端重客户端，将消息的过滤与去重放到SDK,降低服务端的压力；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;三、消息的过滤可以支持到二级字段维度，更精确的过滤掉业务方不需要的消息，减少客户端的压力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;  3.2 技术难点  &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;在数据中心(OLTP)的应用实践当中我们遇到了一些技术挑战，经过研究我们进行了很好的解决：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;数据库乐观锁锁粒度控制&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据中心(OLTP)一张表中的字段都有归属的业务方，如果我们用一个version作为乐观锁控制，那A业务方在保存a字段时，B业务方就无法保存b字段，会导致服务性能的急剧下降，这不是我们期望的结果。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们期望A业务方保存归属字段时，B业务方不受影响，做到业务隔离。而A业务方乐观锁只控制A业务方并发保存时的数据一致性。所以我们的乐观锁version可以以业务方维度设计，可以做到锁隔离和锁粒度的控制，进而提升保存性能。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;ES批量写入&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;作为数据中心(OLTP)，避免不了业务方批量写入数据的场景。&lt;/span&gt;&lt;span&gt;而此时我们可以利用ES的Bulk API，来提升ES的写入性能。&lt;/span&gt;&lt;span&gt;经验证ES的Bulk API比单条数据写入index API性能高几十倍（针对大数据量写入）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Bulk API官网地址：&lt;/span&gt;&lt;span&gt;https://www.elastic.co/guide/en/elasticsearch/reference/7.6/docs-bulk.html#docs-bulk&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;ES之深度分页查询&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;ES在分页查询时，为避免深度翻页对server端带来的压力，故默认控制检索深度不能超过1万条。&lt;/span&gt;&lt;span&gt;如果我们需要实时查询深度分页数据时，可以使用Search After API进行查询；&lt;/span&gt;&lt;span&gt;如果我们需要快速查询深度分页数据，可以使用Scroll API进行查询。&lt;/span&gt;&lt;span&gt;经验&lt;/span&gt;证&lt;span&gt;性能远大于深度翻页，且无深度限制。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;业务方维度控制&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;由于数据中心(OLTP)需要跟多个业务方交互，为了避免某个业务方流量异常影响其它业务方，我们设计了业务方维度的分布式限速，从而达到业务方之间的隔离。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;03&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;   效果与展望&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据中心(OLTP)上线后，可以看到内容运营的所有数据，解决了数据孤岛问题；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;各写入方只需要按规范将数据投递给数据中心(OLTP)即可对外提供数据，解决了重复建设的问题；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;查询业务方只需要对接数据中心(OLTP)即可获取所需的所有内容运营数据，解决了对接复杂的问题；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;各业务团队统一从数据中心(OLTP)获取需要的数据，不再需要跟数据写入方交互，解决了业务系统耦合严重的问题。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前数据中心(OLTP)已对接26个业务方，部署物理隔离的独立集群4套，流量较大的集群，读QPS超过2K，写入QPS超过500，最大的表数据量已达2.5亿。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然数据中心(OLTP)还需要持续建设，为了数据的高可用我们设计了主备集群，但这样也带来了主备集群间的数据一致性问题——数据中心的数据量会越来越大。为了看到整个数据的全貌，传统的技术已经无法解决，我们目前正在打通此系统与&lt;/span&gt;&lt;span&gt;离线数据平台(OLAP)平台的通&lt;/span&gt;&lt;span&gt;路，借助实时数仓与离线数仓的技术，全面赋能业务需要。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;推荐阅读：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA5Njk3Njc5Mw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/zKQJJopg9UNNc0BBpMTTMakQVZHWAndEgicgysue8cQdH1Fv6acUo1BIaEbdXC9PNjgAmZVH2CoRW3AnOiaWoyJg/0?wx_fmt=png&quot; data-nickname=&quot;HelloTech&quot; data-alias=&quot;HelloTech&quot; data-signature=&quot;专注于大数据和微服务架构实践，分享来自技术人的一手干货文章，从入门到深入，通过夯实的技术积累和丰富的一线实战经验，充分利用碎片化时间，为你带来最有料的技术分享~&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;！&lt;strong&gt;关注不迷路~ 各种福利、资源定期分享&lt;/strong&gt;！&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;🧐&lt;strong&gt;分享、点赞、在看&lt;/strong&gt;，给个&lt;strong&gt;3连击&lt;/strong&gt;呗！&lt;strong&gt;👇&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a4efbe793d1b093e5a6c4324a9e267ee</guid>
<title>我们为什么选择使用分布式持续交付新星 Zadig</title>
<link>https://toutiao.io/k/z5u4lvd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.75&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/5tqrztXFpulf3icqxYlrYGBlhEbtuX87XpuXUtQIrCStDor1rNI0SlFmv3twBbgZDIbWYSWdcLHWLUpSMgU35Uw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1440&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文原创作者 Alan Wang - 闪电出行工程师，已授权本站转发&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;持续交付作为运维工作里极其重要的一个环节，本身就存在一些历史悠久的工具，拿 Jenkins 来说，可以通过插件实现各种各样复杂的功能；随着云原生、devops、gitops 等理念的不断普及，也涌现出不少新生力量，比如说 Gitlab CI、KubeVela、ArgoCD、云效等，在 CI 或者 CD 环节中大展身手，合理使用的情况下都能显著的提升效率；但是今天我们的主角不是上面的这些选手，而是另一个极具潜力的黑马：Zadig。&lt;/p&gt;&lt;/blockquote&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;简介&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Zadig 是一款分布式持续交付产品，由 KodeRover 公司基于 Kubernetes 自主设计研发，具有产品持续交付、持续测试、持续追踪的全流程能力，业务架构图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6599839615076183&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5tqrztXFpulf3icqxYlrYGBlhEbtuX87XySbXVrTHHgcCAVjkicibnhC34Sjm0ECA8AIUpXbaVZhztQ8jYEkJ6T7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2494&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;为什么选择 Zadig？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原来是使用 Jenkins 做的交付，结合 kustomize 也能实现基于 k8s 编排应用的丝滑交付。我们考虑其他工具的出发点一方面是：新增一个环境的话配置对应的交付任务也比较复杂；另一方面是：为了方便测试和开发同学，作为一个交付系统来说，Jenkins 是足够胜任的，但是并不能很好的展示被交付应用的运行状态、日志等，还需要其他工具或者系统去看应用运行是不是正常、查看日志等，所以考虑是否有开源的产品可以满足需求，经过一顿找找找，Zadig 凭借着出色的能力，在一众选手中杀出重围，另一个有力的竞争者是云效，云效是阿里云的 PaaS 应用，基于阿里云能力栈可完整覆盖整个应用的生命周期，简单说明如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;zadig 核心优势&lt;/strong&gt;：并发工作流（云效并发任务大于 6 的话需额外购买）、更灵活&amp;amp;维护成本更低（构建与部署过程可高度个性化定制，公共配置可复用）、100%开源（私有化部署，不强耦合指定云厂商）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;云效核心优势&lt;/strong&gt;：产品线更全（覆盖应用全生命周期）、功能开箱即用、更完善的发布策略（分批发布、灰度发布、蓝绿发布，且发布过程可控）；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg4NDY0NTMyNw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/icf3gWOtgJp5eHEISZazhjkMGmpbG2gds96ibTEMXIvfTX5PEX1DITLHQBQ8LmOAHKhGnT3wQYGjsUW0dp4qtDUA/0?wx_fmt=png&quot; data-nickname=&quot;KodeRover&quot; data-alias=&quot;KodeRover&quot; data-signature=&quot;KodeRover 是开源、分布式持续交付（CD）产品 Zadig 背后的团队，专注于云原生软件交付产品的研发。我们的目标是通过云原生技术的运用和工程产品赋能，打造极致、高效、愉悦的开发者工作体验，让工程师成为企业创新的核心引擎。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结合需求和当前运维现状，权衡后选择了 Zadig，可用的核心功能：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;高并发的工作流：基于云原生实现多环境、多服务的高效并发交付；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;灵活的集成环境：跨环境共享服务配置，通过参数化实现隔离业务数据和访问入口区分，可以在数分钟内创建一套隔离的全新测试环境；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;兼容性好：无缝集成 GitHub/GitLab、Jenkins、多家云厂商等；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;无侵入的自动化测试：支持对接已有的自动化测试框架，通过 GitHub/GitLab WebHook 自动触发测试任务；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;开发本地联调 CLI：支持通过 IDE 插件远程调试本地代码、日志查看等功能；&lt;span/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;落地过程&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;安装&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Zadig 提供云上测试环境（非常 Nice）：&lt;span&gt;https://os.koderover.com/&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;官方提供完善的&lt;span&gt;安装文档&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;，并且有微信群进行全方位技术支持 👍👍👍，这里只提一下推荐使用外部高可用的数据库、存储来提高部署安全性。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;使用&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;官方提供了很多案例帮助用户熟悉 Zadig 能力栈和具体配置，这里就不展开细说，只说明一下我们在落地过程中做了哪些关键的事情&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;集成外部系统：ldap（用户管理）、gitlab（代码管理）、oss（保存缓存文件）、镜像仓库（保存镜像制品）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将业务线的各个环境拆成不同的项目隔离管理；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;项目初始化流程：项目 &amp;gt;&amp;gt; 服务 &amp;gt;&amp;gt; 环境 &amp;gt;&amp;gt; 构建 &amp;gt;&amp;gt; 工作流交付。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;价值&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;并发工作流显著提高了发布效率；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;很好的满足了落盘和 Stdout 日志查看的需求；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使拉起一个新环境的成本大幅度降低；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自测模式使低成本高效率的开发联调成为可能。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;不足&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Zadig 目前还处于快速迭代的阶段，难免存在一些功能和易用性问题，但每次更新都能显著看到改善，分享下我们落地过程中的遇到的部分心得。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在 v1.11.0 版本中，存在以下略影响使用体验的点：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;zadig 暂不兼容 kustomize，提供了模板库功能实现公共配置抽离和复用，缺点是只适合服务初始化使用，更新模板后需要逐个手动应用到服务（批量更新功能预计 v1.12.0 上线）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;构建配置目前不支持复用（服务和代码仓库强关联），每个服务就需要单独创建一个构建，同类服务的构建过程其实就一个代码仓库不同其他完全一致，也就是说 90%的配置工作都是多余的；相关优化功能 zadig 开发团队已经在计划中，后续版本会解决这个问题；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务编排里任何改动都会重建 deployment 的 rs、重建 pod，一些资源对象比如 pdb、hpa 这种仍倾向于手动维护。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;展望&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们目前已经接入了多个环境的数百个前后端微服务的交付，顺利进行了数千次部署交付，Zadig 漂亮的界面（可强 Jenkins 太多了~）和易用性也得到了测试和研发同学的肯定。作为一个懒人，希望 Zadig 在配置复用上再改善一些，虽然可以自己开发脚本通过 API 实现很多重复配置的自动化，我们落地过程中就开发了脚本实现：服务、构建、用户权限分配等功能的批量管理，极大降低了配置成本；但还是希望 Zadig 能提供原生功能实现，降低大家的使用成本。服务编排里面的改动会造成不必要的 pod 重启的问题，也希望 Zadig 后面能有解决方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Zadig 已经很出色了，未来可期，共勉。&lt;span/&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Git 仓库：https://github.com/koderover/zadig&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;Zadig云上测试环境: &lt;span&gt;https://os.koderover.com/&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;安装文档: &lt;span&gt;https://docs.koderover.com/zadig/v1.11.0/install/overview/&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA3MTgzNTQwNA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/5tqrztXFpulnjUO595yPz4ia90X3ejHwUszAk04ff0hsfuQl0D3RPFNiagEQbV9oib8OVvepsibXPVEddGPz4DyPbA/0?wx_fmt=png&quot; data-nickname=&quot;Github爱好者&quot; data-alias=&quot;gitfan&quot; data-signature=&quot;我们是一群 Github 爱好者，专注分享有价值、有趣的开源项目和学习资料，包括 Python、Golang、Java、Rust、AI、前端、运维、数据分析、大数据、云计算、Kubernetes、Service Mesh 等领域资源。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>